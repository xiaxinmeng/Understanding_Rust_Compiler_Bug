{"sha": "af35aeb289edbb673349d8ee865140c9bf86263f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYzNWFlYjI4OWVkYmI2NzMzNDlkOGVlODY1MTQwYzliZjg2MjYzZg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-16T04:38:38Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-16T04:38:38Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r497", "tree": {"sha": "a93df81baf224c0c120e43ab733106ef093d9010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a93df81baf224c0c120e43ab733106ef093d9010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af35aeb289edbb673349d8ee865140c9bf86263f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af35aeb289edbb673349d8ee865140c9bf86263f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af35aeb289edbb673349d8ee865140c9bf86263f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af35aeb289edbb673349d8ee865140c9bf86263f/comments", "author": null, "committer": null, "parents": [{"sha": "df87b07e99c0ddece9952e76f9cc8d4b2c51dbd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df87b07e99c0ddece9952e76f9cc8d4b2c51dbd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df87b07e99c0ddece9952e76f9cc8d4b2c51dbd3"}], "stats": {"total": 351, "additions": 151, "deletions": 200}, "files": [{"sha": "558b06492b8e06d0baaa2d02e07c73c213fabbe5", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 151, "deletions": 200, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af35aeb289edbb673349d8ee865140c9bf86263f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af35aeb289edbb673349d8ee865140c9bf86263f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=af35aeb289edbb673349d8ee865140c9bf86263f", "patch": "@@ -36,7 +36,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n  *\n  *      code generation `options':\n  *\n- *      - OBJC_INT_SELECTORS, OBJC_NONUNIQUE_SELECTORS\n+ *      - OBJC_INT_SELECTORS, OBJC_NONUNIQUE_SELECTORS, NEXT_OBJC_RUNTIME\n  */\n \n #include <stdio.h>\n@@ -203,13 +203,12 @@ static void dump_interfaces ();\n \n /* some commonly used instances of \"identifier_node\". */\n \n-static tree self_id, _cmd_id, _msg_id, _msgSuper_id;\n-static tree objc_getClass_id, objc_getMetaClass_id;\n+static tree self_id, _cmd_id;\n \n static tree self_decl, _msg_decl, _msgSuper_decl;\n static tree objc_getClass_decl, objc_getMetaClass_decl;\n \n-static tree super_type, _selector_type, id_type, class_type;\n+static tree super_type, selector_type, id_type, class_type;\n static tree instance_type;\n \n static tree interface_chain = NULLT;\n@@ -267,9 +266,6 @@ static tree objc_symtab_template, objc_module_template;\n static tree objc_super_template, objc_object_reference;\n \n static tree objc_object_id, objc_class_id;\n-#ifdef OBJC_NONUNIQUE_SELECTORS\n-static tree _OBJC_SELECTOR_REFERENCES_id;\n-#endif\n static tree _OBJC_SUPER_decl;\n \n static tree method_context = NULLT;\n@@ -475,6 +471,27 @@ get_static_reference (interface)\n   return xref_tag (RECORD_TYPE, CLASS_NAME (interface));\n }\n \n+/* Create and push a decl for a built-in external variable or field NAME.\n+   CODE says which.\n+   TYPE is its data type.  */\n+\n+static tree\n+create_builtin_decl (code, type, name)\n+     enum tree_code code;\n+     char *name;\n+     tree type;\n+{\n+  tree decl = build_decl (code, get_identifier (name), type);\n+  if (code == VAR_DECL)\n+    {\n+      TREE_EXTERNAL (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n+      make_decl_rtl (decl, 0, 1);\n+      pushdecl (decl);\n+    }\n+  return decl;\n+}\n+\n /*\n  *\tpurpose: \"play\" parser, creating/installing representations\n  *\t\t of the declarations that are required by Objective-C.\n@@ -490,138 +507,68 @@ get_static_reference (interface)\n static void\n synth_module_prologue ()\n {\n-  tree sc_spec, type_spec, decl_specs, expr_decl, parms, record;\n+  tree expr_decl, temp_type;\n \n   /* defined in `objc.h' */\n   objc_object_id = get_identifier (TAG_OBJECT);\n \n   objc_object_reference = xref_tag (RECORD_TYPE, objc_object_id);\n \n-  id_type = groktypename (build_tree_list (\n-\t\t\t\t\t   build_tree_list (NULLT, objc_object_reference),\n-\t\t\t\t\t   build1 (INDIRECT_REF, NULLT, NULLT)));\n+  id_type = build_pointer_type (objc_object_reference);\n \n   objc_class_id = get_identifier (TAG_CLASS);\n   \n-  class_type = groktypename (build_tree_list\n-\t\t\t     (build_tree_list\n-\t\t\t      (NULLT, xref_tag (RECORD_TYPE, objc_class_id)),\n-\t\t\t      build1 (INDIRECT_REF, NULLT, NULLT)));\n+  class_type = build_pointer_type (xref_tag (RECORD_TYPE, objc_class_id));\n \n-/* Declare SEL type before prototypes for objc_msgSend(), or else those\n-   struct tags are considered local to the prototype and won't match the one\n-   in <objc/objc-runtime.h>. */\n+  /* Declare type of selector-objects that represent an operation name.  */\n \n #ifdef OBJC_INT_SELECTORS\n   /* `unsigned int' */\n-  _selector_type = unsigned_type_node;\n+  selector_type = unsigned_type_node;\n #else\n   /* `struct objc_selector *' */\n-  _selector_type = groktypename (build_tree_list (\n-\t     build_tree_list (NULLT,\n-\t\t\t      xref_tag (RECORD_TYPE,\n-\t\t\t\t\tget_identifier (TAG_SELECTOR))),\n-\t     build1 (INDIRECT_REF, NULLT, NULLT)));\n+  selector_type\n+    = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t    get_identifier (TAG_SELECTOR)));\n #endif /* not OBJC_INT_SELECTORS */\n \n-  /* forward declare type...or else the prototype for `super' will bitch */\n-  groktypename (build_tree_list (build_tree_list (NULLT,\n-\t\t\t\t\t\t  xref_tag (RECORD_TYPE, get_identifier (TAG_SUPER))),\n-\t\t\t\t build1 (INDIRECT_REF, NULLT, NULLT)));\n-\n-  _msg_id = get_identifier (\"objc_msgSend\");\n-  _msgSuper_id = get_identifier (\"objc_msgSendSuper\");\n-  objc_getClass_id = get_identifier (\"objc_getClass\");\n-  objc_getMetaClass_id = get_identifier (\"objc_getMetaClass\");\n-\n   /* struct objc_object *objc_msgSend (id, SEL, ...); */\n-  pushlevel (0);\n-  decl_specs = build_tree_list (NULLT, objc_object_reference);\n-  push_parm_decl (build_tree_list (decl_specs,\n-\t\t\t\t   build1 (INDIRECT_REF, NULLT, NULLT)));\n-\n-#ifdef OBJC_INT_SELECTORS\n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_UNSIGNED]);\n-  decl_specs = tree_cons (NULLT, ridpointers[(int) RID_INT], decl_specs);\n-  expr_decl = NULLT;\n-#else\n-  decl_specs = build_tree_list (NULLT,\n-\t\t\t\txref_tag (RECORD_TYPE,\n-\t\t\t\t\t  get_identifier (TAG_SELECTOR)));\n-  expr_decl = build1 (INDIRECT_REF, NULLT, NULLT);\n-#endif /* not OBJC_INT_SELECTORS */\n \n-  push_parm_decl (build_tree_list (decl_specs, expr_decl));\n-  parms = get_parm_info (0);\n-  poplevel (0, 0, 0);\n+  temp_type\n+    = build_function_type (id_type,\n+\t\t\t   tree_cons (NULL_TREE, id_type,\n+\t\t\t\t      tree_cons (NULLT, selector_type, NULLT)));\n \n-  decl_specs = build_tree_list (NULLT, objc_object_reference);\n-  expr_decl = build_nt (CALL_EXPR, _msg_id, parms, NULLT);\n-  expr_decl = build1 (INDIRECT_REF, NULLT, expr_decl);\n+  _msg_decl = builtin_function (\"objc_msgSend\", temp_type, NOT_BUILT_IN, 0);\n \n-  _msg_decl = define_decl (expr_decl, decl_specs);\n+  /* struct objc_object *objc_msgSendSuper (void *, SEL, ...); */\n \n-  /* struct objc_object *objc_msgSendSuper (struct objc_super *, SEL, ...); */\n-  pushlevel (0);\n-  decl_specs = build_tree_list (NULLT, xref_tag (RECORD_TYPE,\n-\t\t\t\t\t\t get_identifier (TAG_SUPER)));\n-  push_parm_decl (build_tree_list (decl_specs,\n-\t\t\t\t   build1 (INDIRECT_REF, NULLT, NULLT)));\n+  temp_type\n+    = build_function_type (id_type,\n+\t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t      tree_cons (NULLT, selector_type, NULLT)));\n \n-#ifdef OBJC_INT_SELECTORS\n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_UNSIGNED]);\n-  decl_specs = tree_cons (NULLT, ridpointers[(int) RID_INT], decl_specs);\n-  expr_decl = NULLT;\n-#else /* not OBJC_INT_SELECTORS */\n-  decl_specs = build_tree_list (NULLT,\n-\t\t\t\txref_tag (RECORD_TYPE,\n-\t\t\t\t\t  get_identifier (TAG_SELECTOR)));\n-  expr_decl = build1 (INDIRECT_REF, NULLT, NULLT);\n-#endif /* not OBJC_INT_SELECTORS */\n-\n-  push_parm_decl (build_tree_list (decl_specs, expr_decl));\n-  parms = get_parm_info (0);\n-  poplevel (0, 0, 0);\n-\n-  decl_specs = build_tree_list (NULLT, objc_object_reference);\n-  expr_decl = build_nt (CALL_EXPR, _msgSuper_id, parms, NULLT);\n-  expr_decl = build1 (INDIRECT_REF, NULLT, expr_decl);\n-\n-  _msgSuper_decl = define_decl (expr_decl, decl_specs);\n+  _msgSuper_decl = builtin_function (\"objc_msgSendSuper\",\n+\t\t\t\t     temp_type, NOT_BUILT_IN, 0);\n \n   /* id objc_getClass (); */\n-  parms = build_tree_list (NULLT, NULLT);\n-  expr_decl = build_nt (CALL_EXPR, objc_getClass_id, parms, NULLT);\n-  expr_decl = build1 (INDIRECT_REF, NULLT, expr_decl);\n+  \n+  temp_type = build_function_type (id_type, NULLT);\n \n-  objc_getClass_decl = define_decl (expr_decl, decl_specs);\n+  objc_getClass_decl\n+    = builtin_function (\"objc_getClass\", temp_type, NOT_BUILT_IN, 0);\n \n   /* id objc_getMetaClass (); */\n-  parms = build_tree_list (NULLT, NULLT);\n-  expr_decl = build_nt (CALL_EXPR, objc_getMetaClass_id, parms, NULLT);\n-  expr_decl = build1 (INDIRECT_REF, NULLT, expr_decl);\n \n-  objc_getMetaClass_decl = define_decl (expr_decl, decl_specs);\n-\n-#ifdef OBJC_NONUNIQUE_SELECTORS\n-  _OBJC_SELECTOR_REFERENCES_id = get_identifier (\"_OBJC_SELECTOR_REFERENCES\");\n+  objc_getMetaClass_decl\n+    = builtin_function (\"objc_getMetaClass\", temp_type, NOT_BUILT_IN, 0);\n \n   /* extern SEL _OBJC_SELECTOR_REFERENCES[]; */\n-  sc_spec = tree_cons (NULLT, ridpointers[(int) RID_EXTERN], NULLT);\n-  \n-#ifdef OBJC_INT_SELECTORS\n-  decl_specs = tree_cons (NULLT, ridpointers[(int) RID_UNSIGNED], sc_spec);\n-  decl_specs = tree_cons (NULLT, ridpointers[(int) RID_INT], decl_specs);\n-  expr_decl = _OBJC_SELECTOR_REFERENCES_id;\n-#else  /* not OBJC_INT_SELECTORS */\n-  decl_specs = build_tree_list (NULLT,\n-\t\t\t\txref_tag (RECORD_TYPE,\n-\t\t\t\t\t  get_identifier (TAG_SELECTOR)));\n-  expr_decl = build1 (INDIRECT_REF, NULLT, _OBJC_SELECTOR_REFERENCES_id);\n-#endif /* not OBJC_INT_SELECTORS */\n \n-  expr_decl = build_nt (ARRAY_REF, expr_decl, NULLT);\n-  _OBJC_SELECTOR_REFERENCES_decl = define_decl (expr_decl, decl_specs);\n+#ifdef OBJC_NONUNIQUE_SELECTORS\n+  _OBJC_SELECTOR_REFERENCES_decl\n+    = create_builtin_decl (VAR_DECL, build_array_type (selector_type, NULLT),\n+\t\t\t   \"_OBJC_SELECTOR_REFERENCES\");\n #endif\n }\n \n@@ -650,73 +597,68 @@ my_build_string (len, str)\n \n   return aString;\n }\n+\f\n+/* Take care of defining and initializing _OBJC_SYMBOLS.  */\n+\n+/* Predefine the following data type:\n+\n+\tstruct _objc_symtab {\n+\t\tlong sel_ref_cnt;\n+\t\tSEL *refs;\n+\t\tshort cls_def_cnt;\n+\t\tshort cat_def_cnt;\n+\t\tvoid *defs[cls_def_cnt + cat_def_cnt];\n+\t}; */\n \n-/*\n- *\tstruct objc_symtab {\n- *\t\tlong sel_ref_cnt;\n- *\t\tchar *refs;\n- *\t\tlong cls_def_cnt;\n- *\t\tlong cat_def_cnt;\n- *\t\tvoid *defs[cls_def_cnt + cat_def_cnt];\n- *\t};\n- */\n static void\n build_objc_symtab_template ()\n {\n-  tree decl_specs, field_decl, field_decl_chain;\n+  tree field_decl, field_decl_chain, index;\n \n   objc_symtab_template = start_struct (RECORD_TYPE, get_identifier (_TAG_SYMTAB));\n \n   /* long sel_ref_cnt; */\n \n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_LONG]);\n-  field_decl = get_identifier (\"sel_ref_cnt\");\n-  field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n+  field_decl = create_builtin_decl (FIELD_DECL,\n+\t\t\t\t    long_integer_type_node,\n+\t\t\t\t    \"sel_ref_cnt\");\n   field_decl_chain = field_decl;\n \n-#ifdef OBJC_INT_SELECTORS\n-  /* unsigned int *sel_ref; */\n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_UNSIGNED]);\n-  decl_specs = tree_cons (NULLT, ridpointers[(int) RID_INT], decl_specs);\n-  field_decl = build1 (INDIRECT_REF, NULLT, get_identifier (\"refs\"));\n-#else /* not OBJC_INT_SELECTORS */\n-  /* struct objc_selector **sel_ref; */\n-  decl_specs = build_tree_list (NULLT,\n-\t\t\t\txref_tag (RECORD_TYPE,\n-\t\t\t\t\t  get_identifier (TAG_SELECTOR)));\n-  field_decl = build1 (INDIRECT_REF, NULLT, get_identifier (\"refs\"));\n-  field_decl = build1 (INDIRECT_REF, NULLT, field_decl);\n-#endif /* not OBJC_INT_SELECTORS */\n+  /* SEL *refs; */\n \n-  field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n+  field_decl = create_builtin_decl (FIELD_DECL,\n+\t\t\t\t    build_pointer_type (selector_type),\n+\t\t\t\t    \"refs\");\n   chainon (field_decl_chain, field_decl);\n \n   /* short cls_def_cnt; */\n \n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_SHORT]);\n-  field_decl = get_identifier (\"cls_def_cnt\");\n-  field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n+  field_decl = create_builtin_decl (FIELD_DECL,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    \"cls_def_cnt\");\n   chainon (field_decl_chain, field_decl);\n \n   /* short cat_def_cnt; */\n \n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_SHORT]);\n-  field_decl = get_identifier (\"cat_def_cnt\");\n-  field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n+  field_decl = create_builtin_decl (FIELD_DECL,\n+\t\t\t\t    short_integer_type_node,\n+\t\t\t\t    \"cat_def_cnt\");\n   chainon (field_decl_chain, field_decl);\n \n   /* void *defs[cls_def_cnt + cat_def_cnt]; */\n \n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_VOID]);\n-  field_decl = build_nt (ARRAY_REF, get_identifier (\"defs\"),\n-\t\t\t build_int_2 (imp_count + cat_count, 0));\n-  field_decl = build1 (INDIRECT_REF, NULLT, field_decl);\n-  field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n+  index = build_index_type (build_int_2 (imp_count + cat_count - 1, 0));\n+  field_decl = create_builtin_decl (FIELD_DECL,\n+\t\t\t\t    build_array_type (ptr_type_node, index),\n+\t\t\t\t    \"defs\");\n   chainon (field_decl_chain, field_decl);\n \n   finish_struct (objc_symtab_template, field_decl_chain);\n }\n \n+/* Create the initial value for the `defs' field of _objc_symtab.\n+   This is a CONSTRUCTOR.  */\n+\n static tree\n init_def_list ()\n {\n@@ -745,15 +687,8 @@ init_def_list ()\n   return build_nt (CONSTRUCTOR, NULLT, nreverse (initlist));\n }\n \n-/*\n- *\tstruct objc_symtab {\n- *\t\tlong sel_ref_cnt;\n- *\t\tchar *refs;\n- *\t\tlong cls_def_cnt;\n- *\t\tlong cat_def_cnt;\n- *\t\tvoid *defs[cls_def_cnt + cat_def_cnt];\n- *\t};\n- */\n+/* Construct the initial value for all of _objc_symtab.  */\n+\n static tree\n init_objc_symtab ()\n {\n@@ -793,6 +728,9 @@ init_objc_symtab ()\n   return build_nt (CONSTRUCTOR, NULLT, nreverse (initlist));\n }\n \n+/* Push forward-declarations of all the categories\n+   so that init_def_list can use them in a CONSTRUCTOR.  */\n+\n static void\n forward_declare_categories ()\n {\n@@ -802,20 +740,19 @@ forward_declare_categories ()\n     {\n       if (TREE_CODE (impent->imp_context) == CATEGORY_TYPE)\n \t{\n-\t  tree sc_spec, decl_specs, decl;\n-\n-\t  sc_spec = build_tree_list (NULLT, ridpointers[(int) RID_EXTERN]);\n-\t  decl_specs = tree_cons (NULLT, objc_category_template, sc_spec);\n-\n+\t  /* Set an invisible arg to synth_id_with_class_suffix.  */\n \t  implementation_context = impent->imp_context;\n-\t  impent->class_decl = define_decl (\n-\t\t\t\t\t    synth_id_with_class_suffix (\"_OBJC_CATEGORY\"),\n-\t\t\t\t\t    decl_specs);\n+\t  impent->class_decl\n+\t    = create_builtin_decl (VAR_DECL, objc_category_template,\n+\t\t\t\t   synth_id_with_class_suffix (\"_OBJC_CATEGORY\"));\n \t}\n     }\n   implementation_context = sav;\n }\n \n+/* Create the declaration of _OBJC_SYMBOLS, with type `strict _objc_symtab'\n+   and initialized appropriately.  */\n+\n static void\n generate_objc_symtab_decl ()\n {\n@@ -838,7 +775,7 @@ generate_objc_symtab_decl ()\n \n   finish_decl (_OBJC_SYMBOLS_decl, init_objc_symtab (), NULLT);\n }\n-\n+\f\n /*\n  *\ttree_node------->tree_node----->...\n  *          |                |\n@@ -1133,7 +1070,7 @@ build_selector_reference (idx)\n     decl = IDENTIFIER_GLOBAL_VALUE (ident); /* set by pushdecl() */\n   else \n     {\n-      decl = build_decl (VAR_DECL, ident, _selector_type);\n+      decl = build_decl (VAR_DECL, ident, selector_type);\n       TREE_EXTERNAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n       TREE_USED (decl) = 1;\n@@ -1153,7 +1090,7 @@ init_selector (offset)\n      int offset;\n {\n   tree expr = build_msg_pool_reference (offset);\n-  TREE_TYPE (expr) = _selector_type; /* cast */\n+  TREE_TYPE (expr) = selector_type; /* cast */\n   return expr;\n }\n \n@@ -1167,7 +1104,9 @@ build_selector_translation_table ()\n   tree decl, var_decl;\n   int idx = 0;\n   char buf[256];\n-#else/\n+#else\n+  tree _OBJC_SELECTOR_REFERENCES_id\n+    = get_identifier (\"_OBJC_SELECTOR_REFERENCES\");\n \n   sc_spec = tree_cons (NULLT, ridpointers[(int) RID_STATIC], NULLT);\n \n@@ -2506,19 +2445,14 @@ build_method_decl (code, ret_type, selector, add_args)\n \n #define METHOD_DEF 0\n #define METHOD_REF 1\n-/*\n- * used by `build_message_expr' and `comp_method_types'.\n- *\n- * add_args is a tree_list node the following info on a parameter list:\n- *\n- *    The TREE_PURPOSE is a chain of decls of those parms.\n- *    The TREE_VALUE is a list of structure, union and enum tags defined.\n- *    The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.\n- *    This tree_list node is later fed to `grokparms'.\n- *\n- *    VOID_AT_END nonzero means append `void' to the end of the type-list.\n- *    Zero means the parmlist ended with an ellipsis so don't append `void'.\n- */\n+/* Used by `build_message_expr' and `comp_method_types'.\n+   Return an argument list for method METH.\n+   CONTEXT is either METHOD_DEF or METHOD_REF,\n+    saying whether we are trying to define a method or call one.\n+   SUPERFLAG says this is for a send to super;\n+    this makes a difference for the NeXT calling sequence\n+    in which the lookup and the method call are done together.  */\n+\n static tree\n get_arg_type_list (meth, context, superflag)\n      tree meth;\n@@ -2527,10 +2461,14 @@ get_arg_type_list (meth, context, superflag)\n {\n   tree arglist, akey;\n \n+#ifdef NEXT_OBJC_RUNTIME\n   /* receiver type */\n   if (superflag)\n-    arglist = build_tree_list (NULLT, super_type);\n+    {\n+      arglist = build_tree_list (NULLT, super_type);\n+    }\n   else\n+#endif\n     {\n       if (context == METHOD_DEF)\n \targlist = build_tree_list (NULLT, TREE_TYPE (self_decl));\n@@ -2539,7 +2477,7 @@ get_arg_type_list (meth, context, superflag)\n     }\n \n   /* selector type - will eventually change to `int' */\n-  chainon (arglist, build_tree_list (NULLT, _selector_type));\n+  chainon (arglist, build_tree_list (NULLT, selector_type));\n \n   /* build a list of argument types */\n   for (akey = METHOD_SEL_ARGS (meth); akey; akey = TREE_CHAIN (akey))\n@@ -2616,11 +2554,11 @@ receiver_is_class_object (receiver)\n \n \t  if (arg != 0\n \t      && TREE_CODE (arg) == TREE_LIST\n-\t      && arg = TREE_VALUE (arg)\n+\t      && (arg = TREE_VALUE (arg))\n \t      && TREE_CODE (arg) == NOP_EXPR\n-\t      && arg = TREE_OPERAND (arg, 0)\n+\t      && (arg = TREE_OPERAND (arg, 0))\n \t      && TREE_CODE (arg) == ADDR_EXPR\n-\t      && arg = TREE_OPERAND (arg, 0)\n+\t      && (arg = TREE_OPERAND (arg, 0))\n \t      && TREE_CODE (arg) == STRING_CST)\n \t    /* finally, we have the class name */\n \t    return get_identifier (TREE_STRING_POINTER (arg));\n@@ -4166,36 +4104,49 @@ really_start_method (method, parmlist)\n {\n   tree sc_spec, ret_spec, ret_decl, decl_specs;\n   tree method_decl, method_id;\n-  char buf[256];\n+  char *buf;\n \n   /* synth the storage class & assemble the return type */\n   sc_spec = tree_cons (NULLT, ridpointers[(int) RID_STATIC], NULLT);\n   ret_spec = TREE_PURPOSE (TREE_TYPE (method));\n   decl_specs = chainon (sc_spec, ret_spec);\n \n   if (TREE_CODE (implementation_context) == IMPLEMENTATION_TYPE)\n+    {\n+      /* Make sure this is big enough for any plausible method label.  */\n+      buf = (char *) alloca (50\n+\t\t\t     + strlen (IDENTIFIER_POINTER (METHOD_SEL_NAME (method)))\n+\t\t\t     + strlen (IDENTIFIER_POINTER (CLASS_NAME (implementation_context))));\n #ifdef OBJC_GEN_METHOD_LABEL\n-    OBJC_GEN_METHOD_LABEL (buf,\n-      TREE_CODE (method) == INSTANCE_METHOD_DECL,\n-      IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n-      NULL,\n-      IDENTIFIER_POINTER (METHOD_SEL_NAME (method)));\n+      OBJC_GEN_METHOD_LABEL (buf,\n+\t\t\t     TREE_CODE (method) == INSTANCE_METHOD_DECL,\n+\t\t\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n+\t\t\t     NULL,\n+\t\t\t     IDENTIFIER_POINTER (METHOD_SEL_NAME (method)));\n #else\n-    sprintf (buf, \"_%d_%s\", ++method_slot,\n-\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_context)));\n+      sprintf (buf, \"_%d_%s\", ++method_slot,\n+\t       IDENTIFIER_POINTER (CLASS_NAME (implementation_context)));\n #endif\n+    }\n   else\t\t\t\t/* we have a category */\n+    {\n+      /* Make sure this is big enough for any plausible method label.  */\n+      buf = (char *) alloca (50\n+\t\t\t     + strlen (IDENTIFIER_POINTER (METHOD_SEL_NAME (method)))\n+\t\t\t     + strlen (IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)))\n+\t\t\t     + strlen (IDENTIFIER_POINTER (CLASS_NAME (implementation_context))));\n #ifdef OBJC_GEN_METHOD_LABEL\n-    OBJC_GEN_METHOD_LABEL (buf,\n-      TREE_CODE (method) == INSTANCE_METHOD_DECL,\n-      IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n-      IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)),\n-      IDENTIFIER_POINTER (METHOD_SEL_NAME (method)));\n+      OBJC_GEN_METHOD_LABEL (buf,\n+\t\t\t     TREE_CODE (method) == INSTANCE_METHOD_DECL,\n+\t\t\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n+\t\t\t     IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)),\n+\t\t\t     IDENTIFIER_POINTER (METHOD_SEL_NAME (method)));\n #else\n-    sprintf (buf, \"_%d_%s_%s\", ++method_slot,\n-\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n-\t     IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)));\n+      sprintf (buf, \"_%d_%s_%s\", ++method_slot,\n+\t       IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n+\t       IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)));\n #endif\n+    }\n \n   method_id = get_identifier (buf);\n "}]}