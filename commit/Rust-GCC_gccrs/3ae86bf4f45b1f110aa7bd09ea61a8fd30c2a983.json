{"sha": "3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlODZiZjRmNDViMWYxMTBhYTdiZDA5ZWE2MWE4ZmQzMGMyYTk4Mw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-08-16T03:38:31Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-08-16T03:38:31Z"}, "message": "re PR libfortran/35863 ([F2003] Implement ENCODING=\"UTF-8\")\n\n2008-08-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/35863\n\t* intrinsics/selected_char_kind.c: Enable iso_10646.\n\t* io/read.c (typedef uchar): New type.\n\t(read_utf8): New function to read a single UTF-8 encoded character.\n\t(read_utf8_char1): New function to read UTF-8 into a KIND=1 string.\n\t(read_default_char1): New functio to read default into KIND=1 string.\n\t(read_utf8_char4): New function to read UTF-8 into a KIND=4 string.\n\t(read_default_char4): New function to read UTF-8 into a KIND=4 string.\n\t(read_a): Modify to use the new functions.\n\t(read_a_char4): Modify to use the new functions.\n\t* io/write.c (error.h): Add include. (typedef uchar): New type.\n\t(write_default_char4): New function to default write KIND=4 string.\n\t(write_utf8_char4): New function to UTF-8 write KIND=4 string.\n\t(write_a_char4): Modify to use new functions.\n\t(write_character): Modify to use new functions.\n\nFrom-SVN: r139147", "tree": {"sha": "659ac99319524f53dd916bbef37cd895b6a5cadb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/659ac99319524f53dd916bbef37cd895b6a5cadb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/comments", "author": null, "committer": null, "parents": [{"sha": "dad80a1bff182651128f352095e2163534c5d81c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad80a1bff182651128f352095e2163534c5d81c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad80a1bff182651128f352095e2163534c5d81c"}], "stats": {"total": 512, "additions": 405, "deletions": 107}, "files": [{"sha": "3e10c2e467d1a0d020d98d3c192513cb10a17d78", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "patch": "@@ -1,3 +1,21 @@\n+2008-08-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/35863\n+\t* intrinsics/selected_char_kind.c: Enable iso_10646.\n+\t* io/read.c (typedef uchar): New type.\n+\t(read_utf8): New function to read a single UTF-8 encoded character.\n+\t(read_utf8_char1): New function to read UTF-8 into a KIND=1 string.\n+\t(read_default_char1): New functio to read default into KIND=1 string.\n+\t(read_utf8_char4): New function to read UTF-8 into a KIND=4 string.\n+\t(read_default_char4): New function to read UTF-8 into a KIND=4 string.\n+\t(read_a): Modify to use the new functions.\n+\t(read_a_char4): Modify to use the new functions.\n+\t* io/write.c (error.h): Add include. (typedef uchar): New type.\n+\t(write_default_char4): New function to default write KIND=4 string.\n+\t(write_utf8_char4): New function to UTF-8 write KIND=4 string.\n+\t(write_a_char4): Modify to use new functions.\n+\t(write_character): Modify to use new functions.\n+\n 2008-08-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR libfortran/37123"}, {"sha": "686636198b24b61b144f28e114a067051c2cd522", "filename": "libgfortran/intrinsics/selected_char_kind.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2Fintrinsics%2Fselected_char_kind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2Fintrinsics%2Fselected_char_kind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fselected_char_kind.c?ref=3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "patch": "@@ -44,6 +44,8 @@ selected_char_kind (gfc_charlen_type name_len, char *name)\n   if ((len == 5 && strncasecmp (name, \"ascii\", 5) == 0)\n       || (len == 7 && strncasecmp (name, \"default\", 7) == 0))\n     return 1;\n+  else if (len == 9 && strncasecmp (name, \"iso_10646\", 9) == 0)\n+    return 1;\n   else\n     return -1;\n }"}, {"sha": "8d25493b2fa660850a53ecc79bfa34e2defeb939", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 201, "deletions": 38, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02110-1301, USA.  */\n #include <ctype.h>\n #include <stdlib.h>\n \n+typedef unsigned char uchar;\n+\n /* read.c -- Deal with formatted reads */\n \n \n@@ -236,78 +238,239 @@ read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n }\n \n \n-/* read_a()-- Read a character record.  This one is pretty easy. */\n-\n-void\n-read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n+static inline gfc_char4_t\n+read_utf8 (st_parameter_dt *dtp, size_t *nbytes) \n {\n+  static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };\n+  static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n+  static uchar buffer[6];\n+  size_t i, nb, nread;\n+  gfc_char4_t c;\n+  int status;\n   char *s;\n-  int m, n, wi, status;\n-  size_t w;\n \n-  wi = f->u.w;\n-  if (wi == -1) /* '(A)' edit descriptor  */\n-    wi = length;\n+  *nbytes = 1;\n+  s = (char *) &buffer[0];\n+  status = read_block_form (dtp, s, nbytes);\n+  if (status == FAILURE)\n+    return 0;\n \n-  w = wi;\n+  /* If this is a short read, just return.  */\n+  if (*nbytes == 0)\n+    return 0;\n \n-  s = gfc_alloca (w);\n+  c = buffer[0];\n+  if (c < 0x80)\n+    return c;\n \n-  dtp->u.p.sf_read_comma = 0;\n-  status = read_block_form (dtp, s, &w);\n-  dtp->u.p.sf_read_comma =\n-    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+  /* The number of leading 1-bits in the first byte indicates how many\n+     bytes follow.  */\n+  for (nb = 2; nb < 7; nb++)\n+    if ((c & ~masks[nb-1]) == patns[nb-1])\n+      goto found;\n+  goto invalid;\n+\t\n+ found:\n+  c = (c & masks[nb-1]);\n+  nread = nb - 1;\n+\n+  s = (char *) &buffer[1];\n+  status = read_block_form (dtp, s, &nread);\n+  if (status == FAILURE)\n+    return 0;\n+  /* Decode the bytes read.  */\n+  for (i = 1; i < nb; i++)\n+    {\n+      gfc_char4_t n = *s++;\n+\n+      if ((n & 0xC0) != 0x80)\n+\tgoto invalid;\n+\n+      c = ((c << 6) + (n & 0x3F));\n+    }\n+\n+  /* Make sure the shortest possible encoding was used.  */\n+  if (c <=      0x7F && nb > 1) goto invalid;\n+  if (c <=     0x7FF && nb > 2) goto invalid;\n+  if (c <=    0xFFFF && nb > 3) goto invalid;\n+  if (c <=  0x1FFFFF && nb > 4) goto invalid;\n+  if (c <= 0x3FFFFFF && nb > 5) goto invalid;\n+\n+  /* Make sure the character is valid.  */\n+  if (c > 0x7FFFFFFF || (c >= 0xD800 && c <= 0xDFFF))\n+    goto invalid;\n+\n+  return c;\n+      \n+ invalid:\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, \"Invalid UTF-8 encoding\");\n+  return (gfc_char4_t) '?';\n+}\n+\n+\n+static void\n+read_utf8_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)\n+{\n+  gfc_char4_t c;\n+  char *dest;\n+  size_t nbytes;\n+  int i, j;\n+\n+  len = ((int) width < len) ? len : (int) width;\n+\n+  dest = (char *) p;\n+\n+  /* Proceed with decoding one character at a time.  */\n+  for (j = 0; j < len; j++, dest++)\n+    {\n+      c = read_utf8 (dtp, &nbytes);\n+\n+      /* Check for a short read and if so, break out.  */\n+      if (nbytes == 0)\n+\tbreak;\n+\n+      *dest = c > 255 ? '?' : (uchar) c;\n+    }\n+\n+  /* If there was a short read, pad the remaining characters.  */\n+  for (i = j; i < len; i++)\n+    *dest++ = ' ';\n+  return;\n+}\n+\n+static void\n+read_default_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)\n+{\n+  char *s;\n+  int m, n, status;\n+\n+  s = gfc_alloca (width);\n+\n+  status = read_block_form (dtp, s, &width);\n+  \n   if (status == FAILURE)\n     return;\n-  if (w > (size_t) length)\n-     s += (w - length);\n+  if (width > (size_t) len)\n+     s += (width - len);\n \n-  m = ((int) w > length) ? length : (int) w;\n+  m = ((int) width > len) ? len : (int) width;\n   memcpy (p, s, m);\n \n-  n = length - w;\n+  n = len - width;\n   if (n > 0)\n     memset (p + m, ' ', n);\n }\n \n-void\n-read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n+\n+static void\n+read_utf8_char4 (st_parameter_dt *dtp, void *p, int len, size_t width)\n {\n-  char *s;\n   gfc_char4_t *dest;\n-  int m, n, wi, status;\n-  size_t w;\n+  size_t nbytes;\n+  int i, j;\n \n-  wi = f->u.w;\n-  if (wi == -1) /* '(A)' edit descriptor  */\n-    wi = length;\n+  len = ((int) width < len) ? len : (int) width;\n \n-  w = wi;\n+  dest = (gfc_char4_t *) p;\n \n-  s = gfc_alloca (w);\n+  /* Proceed with decoding one character at a time.  */\n+  for (j = 0; j < len; j++, dest++)\n+    {\n+      *dest = read_utf8 (dtp, &nbytes);\n \n-  /* Read in w bytes, treating comma as not a separator.  */\n-  dtp->u.p.sf_read_comma = 0;\n-  status = read_block_form (dtp, s, &w);\n-  dtp->u.p.sf_read_comma =\n-    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+      /* Check for a short read and if so, break out.  */\n+      if (nbytes == 0)\n+\tbreak;\n+    }\n+\n+  /* If there was a short read, pad the remaining characters.  */\n+  for (i = j; i < len; i++)\n+    *dest++ = (gfc_char4_t) ' ';\n+  return;\n+}\n+\n+\n+static void\n+read_default_char4 (st_parameter_dt *dtp, char *p, int len, size_t width)\n+{\n+  char *s;\n+  gfc_char4_t *dest;\n+  int m, n, status;\n+\n+  s = gfc_alloca (width);\n+\n+  status = read_block_form (dtp, s, &width);\n   \n   if (status == FAILURE)\n     return;\n-  if (w > (size_t) length)\n-     s += (w - length);\n+  if (width > (size_t) len)\n+     s += (width - len);\n \n-  m = ((int) w > length) ? length : (int) w;\n+  m = ((int) width > len) ? len : (int) width;\n   \n   dest = (gfc_char4_t *) p;\n   \n   for (n = 0; n < m; n++, dest++, s++)\n     *dest = (unsigned char ) *s;\n \n-  for (n = 0; n < length - (int) w; n++, dest++)\n+  for (n = 0; n < len - (int) width; n++, dest++)\n     *dest = (unsigned char) ' ';\n }\n \n+\n+/* read_a()-- Read a character record into a KIND=1 character destination,\n+   processing UTF-8 encoding if necessary.  */\n+\n+void\n+read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n+{\n+  int wi;\n+  size_t w;\n+\n+  wi = f->u.w;\n+  if (wi == -1) /* '(A)' edit descriptor  */\n+    wi = length;\n+  w = wi;\n+\n+  /* Read in w characters, treating comma as not a separator.  */\n+  dtp->u.p.sf_read_comma = 0;\n+\n+  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+    read_utf8_char1 (dtp, p, length, w);\n+  else\n+    read_default_char1 (dtp, p, length, w);\n+  \n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+}\n+\n+\n+/* read_a_char4()-- Read a character record into a KIND=4 character destination,\n+   processing UTF-8 encoding if necessary.  */\n+\n+void\n+read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n+{\n+  int wi;\n+  size_t w;\n+\n+  wi = f->u.w;\n+  if (wi == -1) /* '(A)' edit descriptor  */\n+    wi = length;\n+  w = wi;\n+\n+  /* Read in w characters, treating comma as not a separator.  */\n+  dtp->u.p.sf_read_comma = 0;\n+\n+  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+    read_utf8_char4 (dtp, p, length, w);\n+  else\n+    read_default_char4 (dtp, p, length, w);\n+  \n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n+}\n+\n /* eat_leading_spaces()-- Given a character pointer and a width,\n  * ignore the leading spaces.  */\n "}, {"sha": "8194cf8b7193d8b587d554c8d1e0bca51df7f117", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 184, "deletions": 69, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=3ae86bf4f45b1f110aa7bd09ea61a8fd30c2a983", "patch": "@@ -36,10 +36,161 @@ Boston, MA 02110-1301, USA.  */\n #include <ctype.h>\n #include <stdlib.h>\n #include <stdbool.h>\n+#include <errno.h>\n #define star_fill(p, n) memset(p, '*', n)\n \n #include \"write_float.def\"\n \n+typedef unsigned char uchar;\n+\n+/* Write out default char4.  */\n+\n+static void\n+write_default_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n+\t\t     int src_len, int w_len)\n+{\n+  char *p;\n+  int j, k = 0;\n+  gfc_char4_t c;\n+  uchar d;\n+      \n+  /* Take care of preceding blanks.  */\n+  if (w_len > src_len)\n+    {\n+      k = w_len - src_len;\n+      p = write_block (dtp, k);\n+      if (p == NULL)\n+\treturn;\n+      memset (p, ' ', k);\n+    }\n+\n+  /* Get ready to handle delimiters if needed.  */\n+\n+  switch (dtp->u.p.delim_status)\n+    {\n+    case DELIM_APOSTROPHE:\n+      d = '\\'';\n+      break;\n+    case DELIM_QUOTE:\n+      d = '\"';\n+      break;\n+    default:\n+      d = ' ';\n+      break;\n+    }\n+\n+  /* Now process the remaining characters, one at a time.  */\n+  for (j = k; j < src_len; j++)\n+    {\n+      c = source[j];\n+    \n+      /* Handle delimiters if any.  */\n+      if (c == d && d != ' ')\n+\t{\n+\t  p = write_block (dtp, 2);\n+\t  if (p == NULL)\n+\t    return;\n+\t  *p++ = (uchar) c;\n+\t}\n+      else\n+\t{\n+\t  p = write_block (dtp, 1);\n+\t  if (p == NULL)\n+\t    return;\n+\t}\n+      *p = c > 255 ? '?' : (uchar) c;\n+    }\n+}\n+\n+\n+/* Write out UTF-8 converted from char4.  */\n+\n+static void\n+write_utf8_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n+\t\t     int src_len, int w_len)\n+{\n+  char *p;\n+  int j, k = 0;\n+  gfc_char4_t c;\n+  static const uchar masks[6] =  { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n+  static const uchar limits[6] = { 0x80, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };\n+  size_t nbytes;\n+  uchar buf[6], d, *q; \n+\n+  /* Take care of preceding blanks.  */\n+  if (w_len > src_len)\n+    {\n+      k = w_len - src_len;\n+      p = write_block (dtp, k);\n+      if (p == NULL)\n+\treturn;\n+      memset (p, ' ', k);\n+    }\n+\n+  /* Get ready to handle delimiters if needed.  */\n+\n+  switch (dtp->u.p.delim_status)\n+    {\n+    case DELIM_APOSTROPHE:\n+      d = '\\'';\n+      break;\n+    case DELIM_QUOTE:\n+      d = '\"';\n+      break;\n+    default:\n+      d = ' ';\n+      break;\n+    }\n+\n+  /* Now process the remaining characters, one at a time.  */\n+  for (j = k; j < src_len; j++)\n+    {\n+      c = source[j];\n+      if (c < 0x80)\n+\t{\n+\t  /* Handle the delimiters if any.  */\n+\t  if (c == d && d != ' ')\n+\t    {\n+\t      p = write_block (dtp, 2);\n+\t      if (p == NULL)\n+\t\treturn;\n+\t      *p++ = (uchar) c;\n+\t    }\n+\t  else\n+\t    {\n+\t      p = write_block (dtp, 1);\n+\t      if (p == NULL)\n+\t\treturn;\n+\t    }\n+\t  *p = (uchar) c;\n+\t}\n+      else\n+\t{\n+\t  /* Convert to UTF-8 sequence.  */\n+\t  nbytes = 1;\n+\t  q = &buf[6];\n+\n+\t  do\n+\t    {\n+\t      *--q = ((c & 0x3F) | 0x80);\n+\t      c >>= 6;\n+\t      nbytes++;\n+\t    }\n+\t  while (c >= 0x3F || (c & limits[nbytes-1]));\n+\n+\t  *--q = (c | masks[nbytes-1]);\n+\n+\t  p = write_block (dtp, nbytes);\n+\t  if (p == NULL)\n+\t    return;\n+\n+\t  while (q < &buf[6])\n+\t    *p++ = *q++;\n+\t}\n+    }\n+}\n+\n+\n void\n write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n@@ -126,17 +277,16 @@ write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n \n \n /* The primary difference between write_a_char4 and write_a is that we have to\n-   deal with writing from the first byte of the 4-byte character and take care\n-   of endianess.  This currently implements encoding=\"default\" which means we\n-   write the lowest significant byte. If the 3 most significant bytes are\n-   not representable emit a '?'.  TODO: Implement encoding=\"UTF-8\"\n-   which will process all 4 bytes and translate to the encoded output.  */\n+   deal with writing from the first byte of the 4-byte character and pay\n+   attention to the most significant bytes.  For ENCODING=\"default\" write the\n+   lowest significant byte. If the 3 most significant bytes contain\n+   non-zero values, emit a '?'.  For ENCODING=\"utf-8\", convert the UCS-32 value\n+   to the UTF-8 encoded string before writing out.  */\n \n void\n write_a_char4 (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n {\n   int wlen;\n-  char *p;\n   gfc_char4_t *q;\n \n   wlen = f->u.string.length < 0\n@@ -173,19 +323,15 @@ write_a_char4 (st_parameter_dt *dtp, const fnode *f, const char *source, int len\n \t      /* Write out the previously scanned characters in the string.  */\n \t      if (bytes > 0)\n \t\t{\n-\t\t  p = write_block (dtp, bytes);\n-\t\t  if (p == NULL)\n-\t\t    return;\n-\t\t  for (j = 0; j < bytes; j++)\n-\t\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n+\t\t  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\t\t    write_utf8_char4 (dtp, q, bytes, 0);\n+\t\t  else\n+\t\t    write_default_char4 (dtp, q, bytes, 0);\n \t\t  bytes = 0;\n \t\t}\n \n \t      /* Write out the CR_LF sequence.  */ \n-\t      p = write_block (dtp, 2);\n-              if (p == NULL)\n-                return;\n-\t      memcpy (p, crlf, 2);\n+\t      write_default_char4 (dtp, crlf, 2, 0);\n \t    }\n \t  else\n \t    bytes++;\n@@ -194,32 +340,19 @@ write_a_char4 (st_parameter_dt *dtp, const fnode *f, const char *source, int len\n       /*  Write out any remaining bytes if no LF was found.  */\n       if (bytes > 0)\n \t{\n-\t  p = write_block (dtp, bytes);\n-\t  if (p == NULL)\n-\t    return;\n-\t  for (j = 0; j < bytes; j++)\n-\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n+\t  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\t    write_utf8_char4 (dtp, q, bytes, 0);\n+\t  else\n+\t    write_default_char4 (dtp, q, bytes, 0);\n \t}\n     }\n   else\n     {\n #endif\n-      int j;\n-      p = write_block (dtp, wlen);\n-      if (p == NULL)\n-\treturn;\n-\n-      if (wlen < len)\n-\t{\n-\t  for (j = 0; j < wlen; j++)\n-\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n-\t}\n+      if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\twrite_utf8_char4 (dtp, q, len, wlen);\n       else\n-\t{\n-\t  memset (p, ' ', wlen - len);\n-\t  for (j = wlen - len; j < wlen; j++)\n-\t    p[j] = q[j] > 255 ? '?' : (unsigned char) q[j];\n-\t}\n+\twrite_default_char4 (dtp, q, len, wlen);\n #ifdef HAVE_CRLF\n     }\n #endif\n@@ -745,8 +878,6 @@ write_character (st_parameter_dt *dtp, const char *source, int kind, int length)\n {\n   int i, extra;\n   char *p, d;\n-  gfc_char4_t *q;\n-\n \n   switch (dtp->u.p.delim_status)\n     {\n@@ -769,9 +900,9 @@ write_character (st_parameter_dt *dtp, const char *source, int kind, int length)\n \t{\n \t  extra = 2;\n \n-\t    for (i = 0; i < length; i++)\n-\t      if (source[i] == d)\n-\t\textra++;\n+\t  for (i = 0; i < length; i++)\n+\t    if (source[i] == d)\n+\t      extra++;\n \t}\n \n       p = write_block (dtp, length + extra);\n@@ -796,40 +927,24 @@ write_character (st_parameter_dt *dtp, const char *source, int kind, int length)\n     }\n   else\n     {\n-      /* We have to scan the source string looking for delimiters to determine\n-\t how large the write block needs to be.  */\n       if (d == ' ')\n-\textra = 0;\n-      else\n \t{\n-\t  extra = 2;\n-\n-\t  q = (gfc_char4_t *) source;\n-\t  for (i = 0; i < length; i++, q++)\n-\t    if (*q == (gfc_char4_t) d)\n-\t      extra++;\n-\t}\n-\n-      p = write_block (dtp, length + extra);\n-      if (p == NULL)\n-\treturn;\n-\n-      if (d == ' ')\n-\t{\n-\t  q = (gfc_char4_t *) source;\n-\t  for (i = 0; i < length; i++, q++)\n-\t    p[i] = *q > 255 ? '?' : (unsigned char) *q;\n+\t  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\t    write_utf8_char4 (dtp, (gfc_char4_t *) source, length, 0);\n+\t  else\n+\t    write_default_char4 (dtp, (gfc_char4_t *) source, length, 0);\n \t}\n       else\n \t{\n-\t  *p++ = d;\n-\t  q = (gfc_char4_t *) source;\n-\t  for (i = 0; i < length; i++, q++)\n-\t    {\n-\t      *p++ = *q > 255 ? '?' : (unsigned char) *q;\n-\t      if (*q == (gfc_char4_t) d)\n-\t\t*p++ = d;\n-\t    }\n+\t  p = write_block (dtp, 1);\n+\t  *p = d;\n+\n+\t  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+\t    write_utf8_char4 (dtp, (gfc_char4_t *) source, length, 0);\n+\t  else\n+\t    write_default_char4 (dtp, (gfc_char4_t *) source, length, 0);\n+\n+\t  p = write_block (dtp, 1);\n \t  *p = d;\n \t}\n     }"}]}