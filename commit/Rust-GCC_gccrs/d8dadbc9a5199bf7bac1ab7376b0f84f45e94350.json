{"sha": "d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "node_id": "C_kwDOANBUbNoAKGQ4ZGFkYmM5YTUxOTliZjdiYWMxYWI3Mzc2YjBmODRmNDVlOTQzNTA", "commit": {"author": {"name": "Andrea Corallo", "email": "andrea.corallo@arm.com", "date": "2021-12-06T10:34:35Z"}, "committer": {"name": "Andrea Corallo", "email": "andrea.corallo@arm.com", "date": "2023-01-23T10:20:09Z"}, "message": "[PATCH 1/15] arm: Make mbranch-protection opts parsing common to AArch32/64\n\nHi all,\n\nThis change refactors all the mbranch-protection option parsing code and\ntypes to make it common to both AArch32 and AArch64 backends.\n\nThis change also pulls in some supporting types from AArch64 to make\nit common (aarch_parse_opt_result).\n\nThe significant changes in this patch are the movement of all branch\nprotection parsing routines from aarch64.c to aarch-common.c and\nsupporting data types and static data structures.\n\nThis patch also pre-declares variables and types required in the\naarch32 back-end for moved variables for function sign scope and key\nto prepare for the impending series of patches that support parsing\nthe feature mbranch-protection in the aarch32 back-end.\n\ngcc/ChangeLog:\n\n\t* common/config/aarch64/aarch64-common.cc: Include aarch-common.h.\n\t(all_architectures): Fix comment.\n\t(aarch64_parse_extension): Rename return type, enum value names.\n\t* config/aarch64/aarch64-c.cc (aarch64_update_cpp_builtins): Rename\n\tfactored out aarch_ra_sign_scope and aarch_ra_sign_key variables.\n\tAlso rename corresponding enum values.\n\t* config/aarch64/aarch64-opts.h (aarch64_function_type): Factor\n\tout aarch64_function_type and move it to common code as\n\taarch_function_type in aarch-common.h.\n\t* config/aarch64/aarch64-protos.h: Include common types header,\n\tmove out types aarch64_parse_opt_result and aarch64_key_type to\n\taarch-common.h\n\t* config/aarch64/aarch64.cc: Move mbranch-protection parsing types\n\tand functions out into aarch-common.h and aarch-common.cc.  Fix up\n\tall the name changes resulting from the move.\n\t* config/aarch64/aarch64.md: Fix up aarch64_ra_sign_key type name change\n\tand enum value.\n\t* config/aarch64/aarch64.opt: Include aarch-common.h to import\n\ttype move.  Fix up name changes from factoring out common code and\n\tdata.\n\t* config/arm/aarch-common-protos.h: Export factored out routines to both\n\tbackends.\n\t* config/arm/aarch-common.cc: Include newly factored out types.\n\tMove all mbranch-protection code and data structures from\n\taarch64.cc.\n\t* config/arm/aarch-common.h: New header that declares types shared\n\tbetween aarch32 and aarch64 backends.\n\t* config/arm/arm-protos.h: Declare types and variables that are\n\tmade common to aarch64 and aarch32 backends - aarch_ra_sign_key,\n\taarch_ra_sign_scope and aarch_enable_bti.\n\t* config/arm/arm.opt (config/arm/aarch-common.h): Include header.\n\t(aarch_ra_sign_scope, aarch_enable_bti): Declare variable.\n\t* config/arm/arm.cc: Add missing includes.\n\nCo-Authored-By: Tejas Belagod  <tbelagod@arm.com>", "tree": {"sha": "17ca1cb26898d0d6c537dcc3fe5b4c871e2e940f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17ca1cb26898d0d6c537dcc3fe5b4c871e2e940f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/comments", "author": {"login": "AndreaCorallo", "id": 6765576, "node_id": "MDQ6VXNlcjY3NjU1NzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6765576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreaCorallo", "html_url": "https://github.com/AndreaCorallo", "followers_url": "https://api.github.com/users/AndreaCorallo/followers", "following_url": "https://api.github.com/users/AndreaCorallo/following{/other_user}", "gists_url": "https://api.github.com/users/AndreaCorallo/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreaCorallo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreaCorallo/subscriptions", "organizations_url": "https://api.github.com/users/AndreaCorallo/orgs", "repos_url": "https://api.github.com/users/AndreaCorallo/repos", "events_url": "https://api.github.com/users/AndreaCorallo/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreaCorallo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AndreaCorallo", "id": 6765576, "node_id": "MDQ6VXNlcjY3NjU1NzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6765576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreaCorallo", "html_url": "https://github.com/AndreaCorallo", "followers_url": "https://api.github.com/users/AndreaCorallo/followers", "following_url": "https://api.github.com/users/AndreaCorallo/following{/other_user}", "gists_url": "https://api.github.com/users/AndreaCorallo/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreaCorallo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreaCorallo/subscriptions", "organizations_url": "https://api.github.com/users/AndreaCorallo/orgs", "repos_url": "https://api.github.com/users/AndreaCorallo/repos", "events_url": "https://api.github.com/users/AndreaCorallo/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreaCorallo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47465fff9738b08796f4b52570fec49bbdbf3e57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47465fff9738b08796f4b52570fec49bbdbf3e57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47465fff9738b08796f4b52570fec49bbdbf3e57"}], "stats": {"total": 711, "additions": 390, "deletions": 321}, "files": [{"sha": "5fb9e9de74792e6e8515d21ab29262b45da65351", "filename": "gcc/common/config/aarch64/aarch64-common.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.cc?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -31,6 +31,7 @@\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"config/aarch64/aarch64-feature-deps.h\"\n+#include \"config/arm/aarch-common.h\"\n \n #ifdef  TARGET_BIG_ENDIAN_DEFAULT\n #undef  TARGET_DEFAULT_TARGET_FLAGS\n@@ -191,13 +192,13 @@ static constexpr arch_to_arch_name all_architectures[] =\n \n /* Parse the architecture extension string STR and update ISA_FLAGS\n    with the architecture features turned on or off.  Return a\n-   aarch64_parse_opt_result describing the result.\n+   aarch_parse_opt_result describing the result.\n    When the STR string contains an invalid extension,\n    a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n-enum aarch64_parse_opt_result\n+enum aarch_parse_opt_result\n aarch64_parse_extension (const char *str, aarch64_feature_flags *isa_flags,\n-\t\t\t std::string *invalid_extension)\n+                         std::string *invalid_extension)\n {\n   /* The extension string is parsed left to right.  */\n   const struct aarch64_option_extension *opt = NULL;\n@@ -228,7 +229,7 @@ aarch64_parse_extension (const char *str, aarch64_feature_flags *isa_flags,\n \tadding_ext = 1;\n \n       if (len == 0)\n-\treturn AARCH64_PARSE_MISSING_ARG;\n+\treturn AARCH_PARSE_MISSING_ARG;\n \n \n       /* Scan over the extensions table trying to find an exact match.  */\n@@ -250,13 +251,13 @@ aarch64_parse_extension (const char *str, aarch64_feature_flags *isa_flags,\n \t  /* Extension not found in list.  */\n \t  if (invalid_extension)\n \t    *invalid_extension = std::string (str, len);\n-\t  return AARCH64_PARSE_INVALID_FEATURE;\n+\t  return AARCH_PARSE_INVALID_FEATURE;\n \t}\n \n       str = ext;\n     };\n \n-  return AARCH64_PARSE_OK;\n+  return AARCH_PARSE_OK;\n }\n \n /* Append all architecture extension candidates to the CANDIDATES vector.  */"}, {"sha": "a016ee0bedf7de993a74f57ea68ac73b69fa31d3", "filename": "gcc/config/aarch64/aarch64-c.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -183,14 +183,14 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n \t\t\t\"__ARM_FEATURE_BTI_DEFAULT\", pfile);\n \n   cpp_undef (pfile, \"__ARM_FEATURE_PAC_DEFAULT\");\n-  if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE)\n+  if (aarch_ra_sign_scope != AARCH_FUNCTION_NONE)\n     {\n       int v = 0;\n-      if (aarch64_ra_sign_key == AARCH64_KEY_A)\n+      if (aarch_ra_sign_key == AARCH_KEY_A)\n \tv |= 1;\n-      if (aarch64_ra_sign_key == AARCH64_KEY_B)\n+      if (aarch_ra_sign_key == AARCH_KEY_B)\n \tv |= 2;\n-      if (aarch64_ra_sign_scope == AARCH64_FUNCTION_ALL)\n+      if (aarch_ra_sign_scope == AARCH_FUNCTION_ALL)\n \tv |= 4;\n       builtin_define_with_int_value (\"__ARM_FEATURE_PAC_DEFAULT\", v);\n     }"}, {"sha": "a9f3e2715ca6f76a6610b58794907906df441a57", "filename": "gcc/config/aarch64/aarch64-opts.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -75,16 +75,6 @@ enum aarch64_code_model {\n   AARCH64_CMODEL_LARGE\n };\n \n-/* Function types -msign-return-address should sign.  */\n-enum aarch64_function_type {\n-  /* Don't sign any function.  */\n-  AARCH64_FUNCTION_NONE,\n-  /* Non-leaf functions.  */\n-  AARCH64_FUNCTION_NON_LEAF,\n-  /* All functions.  */\n-  AARCH64_FUNCTION_ALL\n-};\n-\n /* SVE vector register sizes.  */\n enum aarch64_sve_vector_bits_enum {\n   SVE_SCALABLE,"}, {"sha": "9bd8bfe12618761d8ea28f0422d682f270225d57", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -23,6 +23,7 @@\n #define GCC_AARCH64_PROTOS_H\n \n #include \"input.h\"\n+#include \"config/arm/aarch-common.h\"\n \n /* SYMBOL_SMALL_ABSOLUTE: Generate symbol accesses through\n    high and lo relocs that calculate the base address using a PC\n@@ -651,18 +652,6 @@ enum aarch64_extra_tuning_flags\n   AARCH64_EXTRA_TUNE_ALL = (1u << AARCH64_EXTRA_TUNE_index_END) - 1\n };\n \n-/* Enum describing the various ways that the\n-   aarch64_parse_{arch,tune,cpu,extension} functions can fail.\n-   This way their callers can choose what kind of error to give.  */\n-\n-enum aarch64_parse_opt_result\n-{\n-  AARCH64_PARSE_OK,\t\t\t/* Parsing was successful.  */\n-  AARCH64_PARSE_MISSING_ARG,\t\t/* Missing argument.  */\n-  AARCH64_PARSE_INVALID_FEATURE,\t/* Invalid feature modifier.  */\n-  AARCH64_PARSE_INVALID_ARG\t\t/* Invalid arch, tune, cpu arg.  */\n-};\n-\n /* Enum to distinguish which type of check is to be done in\n    aarch64_simd_valid_immediate.  This is used as a bitmask where\n    AARCH64_CHECK_MOV has both bits set.  Thus AARCH64_CHECK_MOV will\n@@ -673,6 +662,8 @@ enum simd_immediate_check {\n   AARCH64_CHECK_MOV  = AARCH64_CHECK_ORR | AARCH64_CHECK_BIC\n };\n \n+extern enum aarch_key_type aarch_ra_sign_key;\n+\n extern struct tune_params aarch64_tune_params;\n \n /* The available SVE predicate patterns, known in the ACLE as \"svpattern\".  */\n@@ -1038,9 +1029,9 @@ void aarch64_set_asm_isa_flags (gcc_options *, aarch64_feature_flags);\n bool aarch64_handle_option (struct gcc_options *, struct gcc_options *,\n \t\t\t     const struct cl_decoded_option *, location_t);\n const char *aarch64_rewrite_selected_cpu (const char *name);\n-enum aarch64_parse_opt_result aarch64_parse_extension (const char *,\n-\t\t\t\t\t\t       aarch64_feature_flags *,\n-\t\t\t\t\t\t       std::string *);\n+enum aarch_parse_opt_result aarch64_parse_extension (const char *,\n+                                                     aarch64_feature_flags *,\n+                                                     std::string *);\n void aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates);\n std::string aarch64_get_extension_string_for_isa_flags (aarch64_feature_flags,\n \t\t\t\t\t\t\taarch64_feature_flags);"}, {"sha": "a482d93b5f00458f8b5e5def10781f09690e5f5d", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 81, "deletions": 279, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -82,6 +82,8 @@\n #include \"tree-dfa.h\"\n #include \"asan.h\"\n #include \"aarch64-feature-deps.h\"\n+#include \"config/arm/aarch-common.h\"\n+#include \"config/arm/aarch-common-protos.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -318,12 +320,8 @@ bool aarch64_pcrelative_literal_loads;\n /* Global flag for whether frame pointer is enabled.  */\n bool aarch64_use_frame_pointer;\n \n-#define BRANCH_PROTECT_STR_MAX 255\n char *accepted_branch_protection_string = NULL;\n \n-static enum aarch64_parse_opt_result\n-aarch64_parse_branch_protection (const char*, char**);\n-\n /* Support for command line parsing of boolean flags in the tuning\n    structures.  */\n struct aarch64_flag_desc\n@@ -2761,6 +2759,8 @@ static const struct processor all_cores[] =\n   {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, NULL}\n };\n \n+enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A;\n+\n /* The current tuning set.  */\n struct tune_params aarch64_tune_params = generic_tunings;\n \n@@ -2826,100 +2826,6 @@ aarch64_cc;\n \n #define AARCH64_INVERSE_CONDITION_CODE(X) ((aarch64_cc) (((int) X) ^ 1))\n \n-struct aarch64_branch_protect_type\n-{\n-  /* The type's name that the user passes to the branch-protection option\n-    string.  */\n-  const char* name;\n-  /* Function to handle the protection type and set global variables.\n-    First argument is the string token corresponding with this type and the\n-    second argument is the next token in the option string.\n-    Return values:\n-    * AARCH64_PARSE_OK: Handling was sucessful.\n-    * AARCH64_INVALID_ARG: The type is invalid in this context and the caller\n-      should print an error.\n-    * AARCH64_INVALID_FEATURE: The type is invalid and the handler prints its\n-      own error.  */\n-  enum aarch64_parse_opt_result (*handler)(char*, char*);\n-  /* A list of types that can follow this type in the option string.  */\n-  const aarch64_branch_protect_type* subtypes;\n-  unsigned int num_subtypes;\n-};\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_no_branch_protection (char* str, char* rest)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_NONE;\n-  aarch64_enable_bti = 0;\n-  if (rest)\n-    {\n-      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n-      return AARCH64_PARSE_INVALID_FEATURE;\n-    }\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_standard_branch_protection (char* str, char* rest)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n-  aarch64_ra_sign_key = AARCH64_KEY_A;\n-  aarch64_enable_bti = 1;\n-  if (rest)\n-    {\n-      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n-      return AARCH64_PARSE_INVALID_FEATURE;\n-    }\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_pac_ret_protection (char* str ATTRIBUTE_UNUSED,\n-\t\t\t\t    char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n-  aarch64_ra_sign_key = AARCH64_KEY_A;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_pac_ret_leaf (char* str ATTRIBUTE_UNUSED,\n-\t\t\t      char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_ra_sign_scope = AARCH64_FUNCTION_ALL;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_pac_ret_b_key (char* str ATTRIBUTE_UNUSED,\n-\t\t\t      char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_ra_sign_key = AARCH64_KEY_B;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static enum aarch64_parse_opt_result\n-aarch64_handle_bti_protection (char* str ATTRIBUTE_UNUSED,\n-\t\t\t\t    char* rest ATTRIBUTE_UNUSED)\n-{\n-  aarch64_enable_bti = 1;\n-  return AARCH64_PARSE_OK;\n-}\n-\n-static const struct aarch64_branch_protect_type aarch64_pac_ret_subtypes[] = {\n-  { \"leaf\", aarch64_handle_pac_ret_leaf, NULL, 0 },\n-  { \"b-key\", aarch64_handle_pac_ret_b_key, NULL, 0 },\n-  { NULL, NULL, NULL, 0 }\n-};\n-\n-static const struct aarch64_branch_protect_type aarch64_branch_protect_types[] = {\n-  { \"none\", aarch64_handle_no_branch_protection, NULL, 0 },\n-  { \"standard\", aarch64_handle_standard_branch_protection, NULL, 0 },\n-  { \"pac-ret\", aarch64_handle_pac_ret_protection, aarch64_pac_ret_subtypes,\n-    ARRAY_SIZE (aarch64_pac_ret_subtypes) },\n-  { \"bti\", aarch64_handle_bti_protection, NULL, 0 },\n-  { NULL, NULL, NULL, 0 }\n-};\n \n /* The condition codes of the processor, and the inverse function.  */\n static const char * const aarch64_condition_codes[] =\n@@ -9020,18 +8926,18 @@ aarch64_return_address_signing_enabled (void)\n   if (crtl->calls_eh_return)\n     return false;\n \n-  /* If signing scope is AARCH64_FUNCTION_NON_LEAF, we only sign a leaf function\n+  /* If signing scope is AARCH_FUNCTION_NON_LEAF, we only sign a leaf function\n      if its LR is pushed onto stack.  */\n-  return (aarch64_ra_sign_scope == AARCH64_FUNCTION_ALL\n-\t  || (aarch64_ra_sign_scope == AARCH64_FUNCTION_NON_LEAF\n+  return (aarch_ra_sign_scope == AARCH_FUNCTION_ALL\n+\t  || (aarch_ra_sign_scope == AARCH_FUNCTION_NON_LEAF\n \t      && known_ge (cfun->machine->frame.reg_offset[LR_REGNUM], 0)));\n }\n \n /* Return TRUE if Branch Target Identification Mechanism is enabled.  */\n bool\n aarch64_bti_enabled (void)\n {\n-  return (aarch64_enable_bti == 1);\n+  return (aarch_enable_bti == 1);\n }\n \n /* The caller is going to use ST1D or LD1D to save or restore an SVE\n@@ -10023,12 +9929,12 @@ aarch64_expand_prologue (void)\n   /* Sign return address for functions.  */\n   if (aarch64_return_address_signing_enabled ())\n     {\n-      switch (aarch64_ra_sign_key)\n+      switch (aarch_ra_sign_key)\n \t{\n-\t  case AARCH64_KEY_A:\n+\t  case AARCH_KEY_A:\n \t    insn = emit_insn (gen_paciasp ());\n \t    break;\n-\t  case AARCH64_KEY_B:\n+\t  case AARCH_KEY_B:\n \t    insn = emit_insn (gen_pacibsp ());\n \t    break;\n \t  default:\n@@ -10329,12 +10235,12 @@ aarch64_expand_epilogue (bool for_sibcall)\n   if (aarch64_return_address_signing_enabled ()\n       && (for_sibcall || !TARGET_ARMV8_3))\n     {\n-      switch (aarch64_ra_sign_key)\n+      switch (aarch_ra_sign_key)\n \t{\n-\t  case AARCH64_KEY_A:\n+\t  case AARCH_KEY_A:\n \t    insn = emit_insn (gen_autiasp ());\n \t    break;\n-\t  case AARCH64_KEY_B:\n+\t  case AARCH_KEY_B:\n \t    insn = emit_insn (gen_autibsp ());\n \t    break;\n \t  default:\n@@ -17359,12 +17265,12 @@ static void initialize_aarch64_code_model (struct gcc_options *);\n \n /* Parse the TO_PARSE string and put the architecture struct that it\n    selects into RES and the architectural features into ISA_FLAGS.\n-   Return an aarch64_parse_opt_result describing the parse result.\n+   Return an aarch_parse_opt_result describing the parse result.\n    If there is an error parsing, RES and ISA_FLAGS are left unchanged.\n    When the TO_PARSE string contains an invalid extension,\n    a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n-static enum aarch64_parse_opt_result\n+static enum aarch_parse_opt_result\n aarch64_parse_arch (const char *to_parse, const struct processor **res,\n \t\t    aarch64_feature_flags *isa_flags,\n \t\t    std::string *invalid_extension)\n@@ -17381,7 +17287,7 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n     len = strlen (to_parse);\n \n   if (len == 0)\n-    return AARCH64_PARSE_MISSING_ARG;\n+    return AARCH_PARSE_MISSING_ARG;\n \n \n   /* Loop through the list of supported ARCHes to find a match.  */\n@@ -17395,32 +17301,32 @@ aarch64_parse_arch (const char *to_parse, const struct processor **res,\n \t  if (ext != NULL)\n \t    {\n \t      /* TO_PARSE string contains at least one extension.  */\n-\t      enum aarch64_parse_opt_result ext_res\n+\t      enum aarch_parse_opt_result ext_res\n \t\t= aarch64_parse_extension (ext, &isa_temp, invalid_extension);\n \n-\t      if (ext_res != AARCH64_PARSE_OK)\n+\t      if (ext_res != AARCH_PARSE_OK)\n \t\treturn ext_res;\n \t    }\n \t  /* Extension parsing was successful.  Confirm the result\n \t     arch and ISA flags.  */\n \t  *res = arch;\n \t  *isa_flags = isa_temp;\n-\t  return AARCH64_PARSE_OK;\n+\t  return AARCH_PARSE_OK;\n \t}\n     }\n \n   /* ARCH name not found in list.  */\n-  return AARCH64_PARSE_INVALID_ARG;\n+  return AARCH_PARSE_INVALID_ARG;\n }\n \n /* Parse the TO_PARSE string and put the result tuning in RES and the\n-   architecture flags in ISA_FLAGS.  Return an aarch64_parse_opt_result\n+   architecture flags in ISA_FLAGS.  Return an aarch_parse_opt_result\n    describing the parse result.  If there is an error parsing, RES and\n    ISA_FLAGS are left unchanged.\n    When the TO_PARSE string contains an invalid extension,\n    a copy of the string is created and stored to INVALID_EXTENSION.  */\n \n-static enum aarch64_parse_opt_result\n+static enum aarch_parse_opt_result\n aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n \t\t   aarch64_feature_flags *isa_flags,\n \t\t   std::string *invalid_extension)\n@@ -17437,7 +17343,7 @@ aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n     len = strlen (to_parse);\n \n   if (len == 0)\n-    return AARCH64_PARSE_MISSING_ARG;\n+    return AARCH_PARSE_MISSING_ARG;\n \n \n   /* Loop through the list of supported CPUs to find a match.  */\n@@ -17450,29 +17356,29 @@ aarch64_parse_cpu (const char *to_parse, const struct processor **res,\n \t  if (ext != NULL)\n \t    {\n \t      /* TO_PARSE string contains at least one extension.  */\n-\t      enum aarch64_parse_opt_result ext_res\n+\t      enum aarch_parse_opt_result ext_res\n \t\t= aarch64_parse_extension (ext, &isa_temp, invalid_extension);\n \n-\t      if (ext_res != AARCH64_PARSE_OK)\n+\t      if (ext_res != AARCH_PARSE_OK)\n \t\treturn ext_res;\n \t    }\n \t  /* Extension parsing was successfull.  Confirm the result\n \t     cpu and ISA flags.  */\n \t  *res = cpu;\n \t  *isa_flags = isa_temp;\n-\t  return AARCH64_PARSE_OK;\n+\t  return AARCH_PARSE_OK;\n \t}\n     }\n \n   /* CPU name not found in list.  */\n-  return AARCH64_PARSE_INVALID_ARG;\n+  return AARCH_PARSE_INVALID_ARG;\n }\n \n /* Parse the TO_PARSE string and put the cpu it selects into RES.\n-   Return an aarch64_parse_opt_result describing the parse result.\n+   Return an aarch_parse_opt_result describing the parse result.\n    If the parsing fails the RES does not change.  */\n \n-static enum aarch64_parse_opt_result\n+static enum aarch_parse_opt_result\n aarch64_parse_tune (const char *to_parse, const struct processor **res)\n {\n   const struct processor *cpu;\n@@ -17483,12 +17389,12 @@ aarch64_parse_tune (const char *to_parse, const struct processor **res)\n       if (strcmp (cpu->name, to_parse) == 0)\n \t{\n \t  *res = cpu;\n-\t  return AARCH64_PARSE_OK;\n+\t  return AARCH_PARSE_OK;\n \t}\n     }\n \n   /* CPU name not found in list.  */\n-  return AARCH64_PARSE_INVALID_ARG;\n+  return AARCH_PARSE_INVALID_ARG;\n }\n \n /* Parse TOKEN, which has length LENGTH to see if it is an option\n@@ -18079,22 +17985,22 @@ aarch64_validate_mcpu (const char *str, const struct processor **res,\n \t\t       aarch64_feature_flags *isa_flags)\n {\n   std::string invalid_extension;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_cpu (str, res, isa_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     return true;\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing cpu name in %<-mcpu=%s%>\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"unknown value %qs for %<-mcpu%>\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs in %<-mcpu=%s%>\",\n \t       invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18179,110 +18085,6 @@ aarch64_validate_sls_mitigation (const char *const_str)\n   free (str_root);\n }\n \n-/* Parses CONST_STR for branch protection features specified in\n-   aarch64_branch_protect_types, and set any global variables required.  Returns\n-   the parsing result and assigns LAST_STR to the last processed token from\n-   CONST_STR so that it can be used for error reporting.  */\n-\n-static enum\n-aarch64_parse_opt_result aarch64_parse_branch_protection (const char *const_str,\n-\t\t\t\t\t\t\t  char** last_str)\n-{\n-  char *str_root = xstrdup (const_str);\n-  char* token_save = NULL;\n-  char *str = strtok_r (str_root, \"+\", &token_save);\n-  enum aarch64_parse_opt_result res = AARCH64_PARSE_OK;\n-  if (!str)\n-    res = AARCH64_PARSE_MISSING_ARG;\n-  else\n-    {\n-      char *next_str = strtok_r (NULL, \"+\", &token_save);\n-      /* Reset the branch protection features to their defaults.  */\n-      aarch64_handle_no_branch_protection (NULL, NULL);\n-\n-      while (str && res == AARCH64_PARSE_OK)\n-\t{\n-\t  const aarch64_branch_protect_type* type = aarch64_branch_protect_types;\n-\t  bool found = false;\n-\t  /* Search for this type.  */\n-\t  while (type && type->name && !found && res == AARCH64_PARSE_OK)\n-\t    {\n-\t      if (strcmp (str, type->name) == 0)\n-\t\t{\n-\t\t  found = true;\n-\t\t  res = type->handler (str, next_str);\n-\t\t  str = next_str;\n-\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n-\t\t}\n-\t      else\n-\t\ttype++;\n-\t    }\n-\t  if (found && res == AARCH64_PARSE_OK)\n-\t    {\n-\t      bool found_subtype = true;\n-\t      /* Loop through each token until we find one that isn't a\n-\t\t subtype.  */\n-\t      while (found_subtype)\n-\t\t{\n-\t\t  found_subtype = false;\n-\t\t  const aarch64_branch_protect_type *subtype = type->subtypes;\n-\t\t  /* Search for the subtype.  */\n-\t\t  while (str && subtype && subtype->name && !found_subtype\n-\t\t\t  && res == AARCH64_PARSE_OK)\n-\t\t    {\n-\t\t      if (strcmp (str, subtype->name) == 0)\n-\t\t\t{\n-\t\t\t  found_subtype = true;\n-\t\t\t  res = subtype->handler (str, next_str);\n-\t\t\t  str = next_str;\n-\t\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n-\t\t\t}\n-\t\t      else\n-\t\t\tsubtype++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (!found)\n-\t    res = AARCH64_PARSE_INVALID_ARG;\n-\t}\n-    }\n-  /* Copy the last processed token into the argument to pass it back.\n-    Used by option and attribute validation to print the offending token.  */\n-  if (last_str)\n-    {\n-      if (str) strcpy (*last_str, str);\n-      else *last_str = NULL;\n-    }\n-  if (res == AARCH64_PARSE_OK)\n-    {\n-      /* If needed, alloc the accepted string then copy in const_str.\n-\tUsed by override_option_after_change_1.  */\n-      if (!accepted_branch_protection_string)\n-\taccepted_branch_protection_string = (char *) xmalloc (\n-\t\t\t\t\t\t      BRANCH_PROTECT_STR_MAX\n-\t\t\t\t\t\t\t+ 1);\n-      strncpy (accepted_branch_protection_string, const_str,\n-\t\tBRANCH_PROTECT_STR_MAX + 1);\n-      /* Forcibly null-terminate.  */\n-      accepted_branch_protection_string[BRANCH_PROTECT_STR_MAX] = '\\0';\n-    }\n-  return res;\n-}\n-\n-static bool\n-aarch64_validate_mbranch_protection (const char *const_str)\n-{\n-  char *str = (char *) xmalloc (strlen (const_str));\n-  enum aarch64_parse_opt_result res =\n-    aarch64_parse_branch_protection (const_str, &str);\n-  if (res == AARCH64_PARSE_INVALID_ARG)\n-    error (\"invalid argument %<%s%> for %<-mbranch-protection=%>\", str);\n-  else if (res == AARCH64_PARSE_MISSING_ARG)\n-    error (\"missing argument for %<-mbranch-protection=%>\");\n-  free (str);\n-  return res == AARCH64_PARSE_OK;\n-}\n-\n /* Validate a command-line -march option.  Parse the arch and extensions\n    (if any) specified in STR and throw errors if appropriate.  Put the\n    results, if they are valid, in RES and ISA_FLAGS.  Return whether the\n@@ -18293,27 +18095,27 @@ aarch64_validate_march (const char *str, const struct processor **res,\n \t\t\taarch64_feature_flags *isa_flags)\n {\n   std::string invalid_extension;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_arch (str, res, isa_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     return true;\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing arch name in %<-march=%s%>\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"unknown value %qs for %<-march%>\", str);\n \taarch64_print_hint_for_arch (str);\n \t/* A common user error is confusing -march and -mcpu.\n \t   If the -march string matches a known CPU suggest -mcpu.  */\n \tparse_res = aarch64_parse_cpu (str, res, isa_flags, &invalid_extension);\n-\tif (parse_res == AARCH64_PARSE_OK)\n+\tif (parse_res == AARCH_PARSE_OK)\n \t  inform (input_location, \"did you mean %<-mcpu=%s%>?\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs in %<-march=%s%>\",\n \t       invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18333,18 +18135,18 @@ aarch64_validate_march (const char *str, const struct processor **res,\n static bool\n aarch64_validate_mtune (const char *str, const struct processor **res)\n {\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_tune (str, res);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     return true;\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing cpu name in %<-mtune=%s%>\", str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"unknown value %qs for %<-mtune%>\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n@@ -18406,7 +18208,7 @@ aarch64_override_options (void)\n     aarch64_validate_sls_mitigation (aarch64_harden_sls_string);\n \n   if (aarch64_branch_protection_string)\n-    aarch64_validate_mbranch_protection (aarch64_branch_protection_string);\n+    aarch_validate_mbranch_protection (aarch64_branch_protection_string);\n \n   /* -mcpu=CPU is shorthand for -march=ARCH_FOR_CPU, -mtune=CPU.\n      If either of -march or -mtune is given, they override their\n@@ -18459,12 +18261,12 @@ aarch64_override_options (void)\n \n   selected_tune = tune ? tune->ident : cpu->ident;\n \n-  if (aarch64_enable_bti == 2)\n+  if (aarch_enable_bti == 2)\n     {\n #ifdef TARGET_ENABLE_BTI\n-      aarch64_enable_bti = 1;\n+      aarch_enable_bti = 1;\n #else\n-      aarch64_enable_bti = 0;\n+      aarch_enable_bti = 0;\n #endif\n     }\n \n@@ -18474,9 +18276,9 @@ aarch64_override_options (void)\n   if (!TARGET_ILP32 && accepted_branch_protection_string == NULL)\n     {\n #ifdef TARGET_ENABLE_PAC_RET\n-      aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n+      aarch_ra_sign_scope = AARCH_FUNCTION_NON_LEAF;\n #else\n-      aarch64_ra_sign_scope = AARCH64_FUNCTION_NONE;\n+      aarch_ra_sign_scope = AARCH_FUNCTION_NONE;\n #endif\n     }\n \n@@ -18490,7 +18292,7 @@ aarch64_override_options (void)\n   /* Convert -msve-vector-bits to a VG count.  */\n   aarch64_sve_vg = aarch64_convert_sve_vector_bits (aarch64_sve_vector_bits);\n \n-  if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE && TARGET_ILP32)\n+  if (aarch_ra_sign_scope != AARCH_FUNCTION_NONE && TARGET_ILP32)\n     sorry (\"return address signing is only supported for %<-mabi=lp64%>\");\n \n   /* The pass to insert speculation tracking runs before\n@@ -18705,10 +18507,10 @@ aarch64_handle_attr_arch (const char *str)\n   const struct processor *tmp_arch = NULL;\n   std::string invalid_extension;\n   aarch64_feature_flags tmp_flags;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_arch (str, &tmp_arch, &tmp_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       gcc_assert (tmp_arch);\n       selected_arch = tmp_arch->arch;\n@@ -18718,14 +18520,14 @@ aarch64_handle_attr_arch (const char *str)\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing name in %<target(\\\"arch=\\\")%> pragma or attribute\");\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"invalid name %qs in %<target(\\\"arch=\\\")%> pragma or attribute\", str);\n \taarch64_print_hint_for_arch (str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %s of value %qs in \"\n \t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18745,10 +18547,10 @@ aarch64_handle_attr_cpu (const char *str)\n   const struct processor *tmp_cpu = NULL;\n   std::string invalid_extension;\n   aarch64_feature_flags tmp_flags;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_cpu (str, &tmp_cpu, &tmp_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       gcc_assert (tmp_cpu);\n       selected_tune = tmp_cpu->ident;\n@@ -18759,14 +18561,14 @@ aarch64_handle_attr_cpu (const char *str)\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing name in %<target(\\\"cpu=\\\")%> pragma or attribute\");\n \tbreak;\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"invalid name %qs in %<target(\\\"cpu=\\\")%> pragma or attribute\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs of value %qs in \"\n \t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n \taarch64_print_hint_for_extensions (invalid_extension);\n@@ -18784,23 +18586,23 @@ aarch64_handle_attr_cpu (const char *str)\n  aarch64_handle_attr_branch_protection (const char* str)\n  {\n   char *err_str = (char *) xmalloc (strlen (str) + 1);\n-  enum aarch64_parse_opt_result res = aarch64_parse_branch_protection (str,\n-\t\t\t\t\t\t\t\t      &err_str);\n+  enum aarch_parse_opt_result res = aarch_parse_branch_protection (str,\n+\t\t\t\t\t\t\t\t   &err_str);\n   bool success = false;\n   switch (res)\n     {\n-     case AARCH64_PARSE_MISSING_ARG:\n+     case AARCH_PARSE_MISSING_ARG:\n        error (\"missing argument to %<target(\\\"branch-protection=\\\")%> pragma or\"\n \t      \" attribute\");\n        break;\n-     case AARCH64_PARSE_INVALID_ARG:\n+     case AARCH_PARSE_INVALID_ARG:\n        error (\"invalid protection type %qs in %<target(\\\"branch-protection\"\n \t      \"=\\\")%> pragma or attribute\", err_str);\n        break;\n-     case AARCH64_PARSE_OK:\n+     case AARCH_PARSE_OK:\n        success = true;\n       /* Fall through.  */\n-     case AARCH64_PARSE_INVALID_FEATURE:\n+     case AARCH_PARSE_INVALID_FEATURE:\n        break;\n      default:\n        gcc_unreachable ();\n@@ -18815,10 +18617,10 @@ static bool\n aarch64_handle_attr_tune (const char *str)\n {\n   const struct processor *tmp_tune = NULL;\n-  enum aarch64_parse_opt_result parse_res\n+  enum aarch_parse_opt_result parse_res\n     = aarch64_parse_tune (str, &tmp_tune);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       gcc_assert (tmp_tune);\n       selected_tune = tmp_tune->ident;\n@@ -18827,7 +18629,7 @@ aarch64_handle_attr_tune (const char *str)\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_INVALID_ARG:\n+      case AARCH_PARSE_INVALID_ARG:\n \terror (\"invalid name %qs in %<target(\\\"tune=\\\")%> pragma or attribute\", str);\n \taarch64_print_hint_for_core (str);\n \tbreak;\n@@ -18846,7 +18648,7 @@ aarch64_handle_attr_tune (const char *str)\n static bool\n aarch64_handle_attr_isa_flags (char *str)\n {\n-  enum aarch64_parse_opt_result parse_res;\n+  enum aarch_parse_opt_result parse_res;\n   auto isa_flags = aarch64_asm_isa_flags;\n \n   /* We allow \"+nothing\" in the beginning to clear out all architectural\n@@ -18860,19 +18662,19 @@ aarch64_handle_attr_isa_flags (char *str)\n   std::string invalid_extension;\n   parse_res = aarch64_parse_extension (str, &isa_flags, &invalid_extension);\n \n-  if (parse_res == AARCH64_PARSE_OK)\n+  if (parse_res == AARCH_PARSE_OK)\n     {\n       aarch64_set_asm_isa_flags (isa_flags);\n       return true;\n     }\n \n   switch (parse_res)\n     {\n-      case AARCH64_PARSE_MISSING_ARG:\n+      case AARCH_PARSE_MISSING_ARG:\n \terror (\"missing value in %<target()%> pragma or attribute\");\n \tbreak;\n \n-      case AARCH64_PARSE_INVALID_FEATURE:\n+      case AARCH_PARSE_INVALID_FEATURE:\n \terror (\"invalid feature modifier %qs of value %qs in \"\n \t       \"%<target()%> pragma or attribute\", invalid_extension.c_str (), str);\n \tbreak;\n@@ -19121,10 +18923,10 @@ aarch64_process_target_attr (tree args)\n \t     leading '+'.  */\n \t  aarch64_feature_flags isa_temp = 0;\n \t  auto with_plus = std::string (\"+\") + token;\n-\t  enum aarch64_parse_opt_result ext_res\n+\t  enum aarch_parse_opt_result ext_res\n \t    = aarch64_parse_extension (with_plus.c_str (), &isa_temp, nullptr);\n \n-\t  if (ext_res == AARCH64_PARSE_OK)\n+\t  if (ext_res == AARCH_PARSE_OK)\n \t    error (\"arch extension %<%s%> should be prefixed by %<+%>\",\n \t\t   token);\n \t  else\n@@ -22896,7 +22698,7 @@ void\n aarch64_post_cfi_startproc (FILE *f, tree ignored ATTRIBUTE_UNUSED)\n {\n   if (cfun->machine->frame.laid_out && aarch64_return_address_signing_enabled ()\n-      && aarch64_ra_sign_key == AARCH64_KEY_B)\n+      && aarch_ra_sign_key == AARCH_KEY_B)\n \tasm_fprintf (f, \"\\t.cfi_b_key_frame\\n\");\n }\n \n@@ -27308,7 +27110,7 @@ aarch64_file_end_indicate_exec_stack ()\n   if (aarch64_bti_enabled ())\n     feature_1_and |= GNU_PROPERTY_AARCH64_FEATURE_1_BTI;\n \n-  if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE)\n+  if (aarch_ra_sign_scope != AARCH_FUNCTION_NONE)\n     feature_1_and |= GNU_PROPERTY_AARCH64_FEATURE_1_PAC;\n \n   if (feature_1_and)"}, {"sha": "e4d7587aac7be813094804f2b8becbbbc508ed6f", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -891,7 +891,7 @@\n     if (aarch64_return_address_signing_enabled ()\n \t&& (TARGET_PAUTH))\n       {\n-\tif (aarch64_ra_sign_key == AARCH64_KEY_B)\n+\tif (aarch_ra_sign_key == AARCH_KEY_B)\n \t  ret = \"retab\";\n \telse\n \t  ret = \"retaa\";"}, {"sha": "137e506fe19847ec1a3242ee9c9dde16e0421494", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -21,6 +21,9 @@\n HeaderInclude\n config/aarch64/aarch64-opts.h\n \n+HeaderInclude\n+config/arm/aarch-common.h\n+\n TargetVariable\n enum aarch64_processor selected_tune = aarch64_none\n \n@@ -34,7 +37,7 @@ TargetVariable\n aarch64_feature_flags aarch64_isa_flags = 0\n \n TargetVariable\n-unsigned aarch64_enable_bti = 2\n+unsigned aarch_enable_bti = 2\n \n TargetVariable\n enum aarch64_key_type aarch64_ra_sign_key = AARCH64_KEY_A\n@@ -164,21 +167,21 @@ Target RejectNegative Joined Var(aarch64_branch_protection_string) Save\n Use branch-protection features.\n \n msign-return-address=\n-Target WarnRemoved RejectNegative Joined Enum(aarch64_ra_sign_scope_t) Var(aarch64_ra_sign_scope) Init(AARCH64_FUNCTION_NONE) Save\n+Target WarnRemoved RejectNegative Joined Enum(aarch_ra_sign_scope_t) Var(aarch_ra_sign_scope) Init(AARCH_FUNCTION_NONE) Save\n Select return address signing scope.\n \n Enum\n-Name(aarch64_ra_sign_scope_t) Type(enum aarch64_function_type)\n+Name(aarch_ra_sign_scope_t) Type(enum aarch_function_type)\n Supported AArch64 return address signing scope (for use with -msign-return-address= option):\n \n EnumValue\n-Enum(aarch64_ra_sign_scope_t) String(none) Value(AARCH64_FUNCTION_NONE)\n+Enum(aarch_ra_sign_scope_t) String(none) Value(AARCH_FUNCTION_NONE)\n \n EnumValue\n-Enum(aarch64_ra_sign_scope_t) String(non-leaf) Value(AARCH64_FUNCTION_NON_LEAF)\n+Enum(aarch_ra_sign_scope_t) String(non-leaf) Value(AARCH_FUNCTION_NON_LEAF)\n \n EnumValue\n-Enum(aarch64_ra_sign_scope_t) String(all) Value(AARCH64_FUNCTION_ALL)\n+Enum(aarch_ra_sign_scope_t) String(all) Value(AARCH_FUNCTION_ALL)\n \n mlow-precision-recip-sqrt\n Target Var(flag_mrecip_low_precision_sqrt) Optimization"}, {"sha": "f3d28f8dd4e930117e4df52235b0c17be0758a61", "filename": "gcc/config/arm/aarch-common-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Faarch-common-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common-protos.h?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -153,4 +153,10 @@ rtx_insn *arm_md_asm_adjust (vec<rtx> &outputs, vec<rtx> & /*inputs*/,\n \t\t\t     vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs,\n \t\t\t     location_t loc);\n \n+/* Parsing routine for branch-protection common to AArch64 and Arm.  */\n+enum aarch_parse_opt_result aarch_parse_branch_protection (const char*, char**);\n+\n+/* Validation routine for branch-protection common to AArch64 and Arm.  */\n+bool aarch_validate_mbranch_protection (const char *);\n+\n #endif /* GCC_AARCH_COMMON_PROTOS_H */"}, {"sha": "27e6c8f39b47c8a366c7e5767ca49c184a0ddb76", "filename": "gcc/config/arm/aarch-common.cc", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Faarch-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Faarch-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.cc?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -36,6 +36,7 @@\n #include \"expr.h\"\n #include \"function.h\"\n #include \"emit-rtl.h\"\n+#include \"aarch-common.h\"\n \n /* Return TRUE if X is either an arithmetic shift left, or\n    is a multiplication by a power of two.  */\n@@ -657,3 +658,187 @@ arm_md_asm_adjust (vec<rtx> &outputs, vec<rtx> & /*inputs*/,\n \n   return saw_asm_flag ? seq : NULL;\n }\n+\n+#define BRANCH_PROTECT_STR_MAX 255\n+extern char *accepted_branch_protection_string;\n+extern enum aarch_key_type aarch_ra_sign_key;\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_no_branch_protection (char* str, char* rest)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_NONE;\n+  aarch_enable_bti = 0;\n+  if (rest)\n+    {\n+      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n+      return AARCH_PARSE_INVALID_FEATURE;\n+    }\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_standard_branch_protection (char* str, char* rest)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_NON_LEAF;\n+  aarch_ra_sign_key = AARCH_KEY_A;\n+  aarch_enable_bti = 1;\n+  if (rest)\n+    {\n+      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n+      return AARCH_PARSE_INVALID_FEATURE;\n+    }\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_pac_ret_protection (char* str ATTRIBUTE_UNUSED,\n+\t\t\t\t char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_NON_LEAF;\n+  aarch_ra_sign_key = AARCH_KEY_A;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_pac_ret_leaf (char* str ATTRIBUTE_UNUSED,\n+\t\t\t   char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_ra_sign_scope = AARCH_FUNCTION_ALL;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_pac_ret_b_key (char* str ATTRIBUTE_UNUSED,\n+\t\t\t    char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_ra_sign_key = AARCH_KEY_B;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static enum aarch_parse_opt_result\n+aarch_handle_bti_protection (char* str ATTRIBUTE_UNUSED,\n+\t\t\t     char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch_enable_bti = 1;\n+  return AARCH_PARSE_OK;\n+}\n+\n+static const struct aarch_branch_protect_type aarch_pac_ret_subtypes[] = {\n+  { \"leaf\", aarch_handle_pac_ret_leaf, NULL, 0 },\n+  { \"b-key\", aarch_handle_pac_ret_b_key, NULL, 0 },\n+  { NULL, NULL, NULL, 0 }\n+};\n+\n+static const struct aarch_branch_protect_type aarch_branch_protect_types[] = {\n+  { \"none\", aarch_handle_no_branch_protection, NULL, 0 },\n+  { \"standard\", aarch_handle_standard_branch_protection, NULL, 0 },\n+  { \"pac-ret\", aarch_handle_pac_ret_protection, aarch_pac_ret_subtypes,\n+    ARRAY_SIZE (aarch_pac_ret_subtypes) },\n+  { \"bti\", aarch_handle_bti_protection, NULL, 0 },\n+  { NULL, NULL, NULL, 0 }\n+};\n+\n+/* Parses CONST_STR for branch protection features specified in\n+   aarch64_branch_protect_types, and set any global variables required.  Returns\n+   the parsing result and assigns LAST_STR to the last processed token from\n+   CONST_STR so that it can be used for error reporting.  */\n+\n+enum aarch_parse_opt_result\n+aarch_parse_branch_protection (const char *const_str, char** last_str)\n+{\n+  char *str_root = xstrdup (const_str);\n+  char* token_save = NULL;\n+  char *str = strtok_r (str_root, \"+\", &token_save);\n+  enum aarch_parse_opt_result res = AARCH_PARSE_OK;\n+  if (!str)\n+    res = AARCH_PARSE_MISSING_ARG;\n+  else\n+    {\n+      char *next_str = strtok_r (NULL, \"+\", &token_save);\n+      /* Reset the branch protection features to their defaults.  */\n+      aarch_handle_no_branch_protection (NULL, NULL);\n+\n+      while (str && res == AARCH_PARSE_OK)\n+\t{\n+\t  const aarch_branch_protect_type* type = aarch_branch_protect_types;\n+\t  bool found = false;\n+\t  /* Search for this type.  */\n+\t  while (type && type->name && !found && res == AARCH_PARSE_OK)\n+\t    {\n+\t      if (strcmp (str, type->name) == 0)\n+\t\t{\n+\t\t  found = true;\n+\t\t  res = type->handler (str, next_str);\n+\t\t  str = next_str;\n+\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n+\t\t}\n+\t      else\n+\t\ttype++;\n+\t    }\n+\t  if (found && res == AARCH_PARSE_OK)\n+\t    {\n+\t      bool found_subtype = true;\n+\t      /* Loop through each token until we find one that isn't a\n+\t\t subtype.  */\n+\t      while (found_subtype)\n+\t\t{\n+\t\t  found_subtype = false;\n+\t\t  const aarch_branch_protect_type *subtype = type->subtypes;\n+\t\t  /* Search for the subtype.  */\n+\t\t  while (str && subtype && subtype->name && !found_subtype\n+\t\t\t  && res == AARCH_PARSE_OK)\n+\t\t    {\n+\t\t      if (strcmp (str, subtype->name) == 0)\n+\t\t\t{\n+\t\t\t  found_subtype = true;\n+\t\t\t  res = subtype->handler (str, next_str);\n+\t\t\t  str = next_str;\n+\t\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n+\t\t\t}\n+\t\t      else\n+\t\t\tsubtype++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (!found)\n+\t    res = AARCH_PARSE_INVALID_ARG;\n+\t}\n+    }\n+  /* Copy the last processed token into the argument to pass it back.\n+    Used by option and attribute validation to print the offending token.  */\n+  if (last_str)\n+    {\n+      if (str)\n+\tstrcpy (*last_str, str);\n+      else\n+\t*last_str = NULL;\n+    }\n+\n+  if (res == AARCH_PARSE_OK)\n+    {\n+      /* If needed, alloc the accepted string then copy in const_str.\n+\tUsed by override_option_after_change_1.  */\n+      if (!accepted_branch_protection_string)\n+\taccepted_branch_protection_string\n+\t  = (char *) xmalloc (BRANCH_PROTECT_STR_MAX + 1);\n+      strncpy (accepted_branch_protection_string, const_str,\n+\t       BRANCH_PROTECT_STR_MAX + 1);\n+      /* Forcibly null-terminate.  */\n+      accepted_branch_protection_string[BRANCH_PROTECT_STR_MAX] = '\\0';\n+    }\n+  return res;\n+}\n+\n+bool\n+aarch_validate_mbranch_protection (const char *const_str)\n+{\n+  char *str = (char *) xmalloc (strlen (const_str));\n+  enum aarch_parse_opt_result res =\n+    aarch_parse_branch_protection (const_str, &str);\n+  if (res == AARCH_PARSE_INVALID_ARG)\n+    error (\"invalid argument %<%s%> for %<-mbranch-protection=%>\", str);\n+  else if (res == AARCH_PARSE_MISSING_ARG)\n+    error (\"missing argument for %<-mbranch-protection=%>\");\n+  free (str);\n+  return res == AARCH_PARSE_OK;\n+}"}, {"sha": "c6a67f0d05cc75d85d019e1cc910c37173884c03", "filename": "gcc/config/arm/aarch-common.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Faarch-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Faarch-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faarch-common.h?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -0,0 +1,73 @@\n+/* Types shared between arm and aarch64.\n+\n+   Copyright (C) 2009-2021 Free Software Foundation, Inc.\n+   Contributed by Arm Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_AARCH_COMMON_H\n+#define GCC_AARCH_COMMON_H\n+\n+/* Enum describing the various ways that the\n+   aarch*_parse_{arch,tune,cpu,extension} functions can fail.\n+   This way their callers can choose what kind of error to give.  */\n+\n+enum aarch_parse_opt_result\n+{\n+  AARCH_PARSE_OK,\t\t\t/* Parsing was successful.  */\n+  AARCH_PARSE_MISSING_ARG,\t\t/* Missing argument.  */\n+  AARCH_PARSE_INVALID_FEATURE,\t\t/* Invalid feature modifier.  */\n+  AARCH_PARSE_INVALID_ARG\t\t/* Invalid arch, tune, cpu arg.  */\n+};\n+\n+/* Function types -msign-return-address should sign.  */\n+enum aarch_function_type {\n+  /* Don't sign any function.  */\n+  AARCH_FUNCTION_NONE,\n+  /* Non-leaf functions.  */\n+  AARCH_FUNCTION_NON_LEAF,\n+  /* All functions.  */\n+  AARCH_FUNCTION_ALL\n+};\n+\n+/* The key type that -msign-return-address should use.  */\n+enum aarch_key_type {\n+  AARCH_KEY_A,\n+  AARCH_KEY_B\n+};\n+\n+struct aarch_branch_protect_type\n+{\n+  /* The type's name that the user passes to the branch-protection option\n+     string.  */\n+  const char* name;\n+  /* Function to handle the protection type and set global variables.\n+     First argument is the string token corresponding with this type and the\n+     second argument is the next token in the option string.\n+     Return values:\n+     * AARCH_PARSE_OK: Handling was sucessful.\n+     * AARCH_INVALID_ARG: The type is invalid in this context and the caller\n+     should print an error.\n+     * AARCH_INVALID_FEATURE: The type is invalid and the handler prints its\n+     own error.  */\n+  enum aarch_parse_opt_result (*handler)(char*, char*);\n+  /* A list of types that can follow this type in the option string.  */\n+  const struct aarch_branch_protect_type* subtypes;\n+  unsigned int num_subtypes;\n+};\n+\n+#endif /* GCC_AARCH_COMMON_H */"}, {"sha": "4c0376eb5fb384f12a601a46c9e81085719a0fdf", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -582,6 +582,8 @@ struct cpu_option\n extern const arch_option all_architectures[];\n extern const cpu_option all_cores[];\n \n+extern enum aarch_key_type aarch_ra_sign_key;\n+\n const cpu_option *arm_parse_cpu_option_name (const cpu_option *, const char *,\n \t\t\t\t\t     const char *, bool = true);\n const arch_option *arm_parse_arch_option_name (const arch_option *,"}, {"sha": "da84ba50f92436f9ea9d00e1c1fb38ea25acc2a9", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -72,6 +72,8 @@\n #include \"selftest.h\"\n #include \"tree-vectorizer.h\"\n #include \"opts.h\"\n+#include \"aarch-common.h\"\n+#include \"aarch-common-protos.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -2413,6 +2415,11 @@ const struct tune_params arm_fa726te_tune =\n   tune_params::SCHED_AUTOPREF_OFF\n };\n \n+/* Key type for Pointer Authentication extension.  */\n+enum aarch_key_type aarch_ra_sign_key = AARCH_KEY_A;\n+\n+char *accepted_branch_protection_string = NULL;\n+\n /* Auto-generated CPU, FPU and architecture tables.  */\n #include \"arm-cpu-data.h\"\n "}, {"sha": "16d8df808c3f915bb8b73dcdc0e68aced0dae2cf", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8dadbc9a5199bf7bac1ab7376b0f84f45e94350/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=d8dadbc9a5199bf7bac1ab7376b0f84f45e94350", "patch": "@@ -21,6 +21,15 @@\n HeaderInclude\n config/arm/arm-opts.h\n \n+HeaderInclude\n+config/arm/aarch-common.h\n+\n+TargetVariable\n+enum aarch_function_type aarch_ra_sign_scope = AARCH_FUNCTION_NONE\n+\n+TargetVariable\n+unsigned aarch_enable_bti = 0\n+\n Enum\n Name(tls_type) Type(enum arm_tls_type)\n TLS dialect to use:"}]}