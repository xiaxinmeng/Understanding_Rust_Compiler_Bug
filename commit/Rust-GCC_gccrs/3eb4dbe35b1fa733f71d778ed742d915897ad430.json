{"sha": "3eb4dbe35b1fa733f71d778ed742d915897ad430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ViNGRiZTM1YjFmYTczM2Y3MWQ3NzhlZDc0MmQ5MTU4OTdhZDQzMA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2010-04-14T15:01:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2010-04-14T15:01:40Z"}, "message": "PR 42694: Optimize pow (x, 0.25), pow (x, 0.75), pow (x, 1./6.)\n\nFrom-SVN: r158346", "tree": {"sha": "1dc5a9d090fe9779a1aa60fe74b740b62104fc5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dc5a9d090fe9779a1aa60fe74b740b62104fc5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3eb4dbe35b1fa733f71d778ed742d915897ad430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb4dbe35b1fa733f71d778ed742d915897ad430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb4dbe35b1fa733f71d778ed742d915897ad430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb4dbe35b1fa733f71d778ed742d915897ad430/comments", "author": null, "committer": null, "parents": [{"sha": "fc249fe5d62c73210b3f752fb45119391d0774f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc249fe5d62c73210b3f752fb45119391d0774f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc249fe5d62c73210b3f752fb45119391d0774f0"}], "stats": {"total": 104, "additions": 104, "deletions": 0}, "files": [{"sha": "4b85b58a6d9dd91ddd08378403a480f12fbc5125", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb4dbe35b1fa733f71d778ed742d915897ad430/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb4dbe35b1fa733f71d778ed742d915897ad430/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3eb4dbe35b1fa733f71d778ed742d915897ad430", "patch": "@@ -1,3 +1,11 @@\n+2010-04-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR middle-end/42694\n+\t* builtins.c (expand_builtin_pow_root): New function to expand pow\n+\tcalls with exponents 0.25, 0.50, 0.75, 1./3., and 1./6. into a\n+\tseries of sqrt and cbrt calls under -ffast-math.\n+\t(expand_builtin_pow): Call it.\n+\n 2010-04-14  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/42963"}, {"sha": "dbab4847af025f79fb88c0a0deb399ec2aa87175", "filename": "gcc/builtins.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb4dbe35b1fa733f71d778ed742d915897ad430/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb4dbe35b1fa733f71d778ed742d915897ad430/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3eb4dbe35b1fa733f71d778ed742d915897ad430", "patch": "@@ -2923,6 +2923,95 @@ expand_powi (rtx x, enum machine_mode mode, HOST_WIDE_INT n)\n   return result;\n }\n \n+/* Fold a builtin function call to pow, powf, or powl into a series of sqrts or\n+   cbrts.  Return NULL_RTX if no simplification can be made or expand the tree\n+   if we can simplify it.  */\n+static rtx\n+expand_builtin_pow_root (location_t loc, tree arg0, tree arg1, tree type,\n+\t\t\t rtx subtarget)\n+{\n+  if (TREE_CODE (arg1) == REAL_CST\n+      && !TREE_OVERFLOW (arg1)\n+      && flag_unsafe_math_optimizations)\n+    {\n+      enum machine_mode mode = TYPE_MODE (type);\n+      tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n+      tree cbrtfn = mathfn_built_in (type, BUILT_IN_CBRT);\n+      REAL_VALUE_TYPE c = TREE_REAL_CST (arg1);\n+      tree op = NULL_TREE;\n+\n+      if (sqrtfn)\n+\t{\n+\t  /* Optimize pow (x, 0.5) into sqrt.  */\n+\t  if (REAL_VALUES_EQUAL (c, dconsthalf))\n+\t    op = build_call_nofold_loc (loc, sqrtfn, 1, arg0);\n+\n+\t  else\n+\t    {\n+\t      REAL_VALUE_TYPE dconst1_4 = dconst1;\n+\t      REAL_VALUE_TYPE dconst3_4;\n+\t      SET_REAL_EXP (&dconst1_4, REAL_EXP (&dconst1_4) - 2);\n+\n+\t      real_from_integer (&dconst3_4, VOIDmode, 3, 0, 0);\n+\t      SET_REAL_EXP (&dconst3_4, REAL_EXP (&dconst3_4) - 2);\n+\n+\t      /* Optimize pow (x, 0.25) into sqrt (sqrt (x)).  Assume on most\n+\t\t machines that a builtin sqrt instruction is smaller than a\n+\t\t call to pow with 0.25, so do this optimization even if\n+\t\t -Os.  */\n+\t      if (REAL_VALUES_EQUAL (c, dconst1_4))\n+\t\t{\n+\t\t  op = build_call_nofold_loc (loc, sqrtfn, 1, arg0);\n+\t\t  op = build_call_nofold_loc (loc, sqrtfn, 1, op);\n+\t\t}\n+\n+\t      /* Optimize pow (x, 0.75) = sqrt (x) * sqrt (sqrt (x)) unless we\n+\t\t are optimizing for space.  */\n+\t      else if (optimize_insn_for_speed_p ()\n+\t\t       && !TREE_SIDE_EFFECTS (arg0)\n+\t\t       && REAL_VALUES_EQUAL (c, dconst3_4))\n+\t\t{\n+\t\t  tree sqrt1 = build_call_expr_loc (loc, sqrtfn, 1, arg0);\n+\t\t  tree sqrt2 = builtin_save_expr (sqrt1);\n+\t\t  tree sqrt3 = build_call_expr_loc (loc, sqrtfn, 1, sqrt1);\n+\t\t  op = fold_build2_loc (loc, MULT_EXPR, type, sqrt2, sqrt3);\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Check whether we can do cbrt insstead of pow (x, 1./3.) and\n+\t cbrt/sqrts instead of pow (x, 1./6.).  */\n+      if (cbrtfn && ! op\n+\t  && (tree_expr_nonnegative_p (arg0) || !HONOR_NANS (mode)))\n+\t{\n+\t  /* First try 1/3.  */\n+\t  REAL_VALUE_TYPE dconst1_3\n+\t    = real_value_truncate (mode, dconst_third ());\n+\n+\t  if (REAL_VALUES_EQUAL (c, dconst1_3))\n+\t    op = build_call_nofold_loc (loc, cbrtfn, 1, arg0);\n+\n+\t      /* Now try 1/6.  */\n+\t  else if (optimize_insn_for_speed_p ())\n+\t    {\n+\t      REAL_VALUE_TYPE dconst1_6 = dconst1_3;\n+\t      SET_REAL_EXP (&dconst1_6, REAL_EXP (&dconst1_6) - 1);\n+\n+\t      if (REAL_VALUES_EQUAL (c, dconst1_6))\n+\t\t{\n+\t\t  op = build_call_nofold_loc (loc, sqrtfn, 1, arg0);\n+\t\t  op = build_call_nofold_loc (loc, cbrtfn, 1, op);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (op)\n+\treturn expand_expr (op, subtarget, mode, EXPAND_NORMAL);\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n /* Expand a call to the pow built-in mathematical function.  Return NULL_RTX if\n    a normal call should be emitted rather than expanding the function\n    in-line.  EXP is the expression that is a call to the builtin\n@@ -3017,6 +3106,13 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n \t}\n     }\n \n+  /* Check whether we can do a series of sqrt or cbrt's instead of the pow\n+     call.  */\n+  op = expand_builtin_pow_root (EXPR_LOCATION (exp), arg0, arg1, type,\n+\t\t\t\tsubtarget);\n+  if (op)\n+    return op;\n+\n   /* Try if the exponent is a third of an integer.  In this case\n      we can expand to x**(n/3) * cbrt(x)**(n%3).  As cbrt (x) is\n      different from pow (x, 1./3.) due to rounding and behavior"}]}