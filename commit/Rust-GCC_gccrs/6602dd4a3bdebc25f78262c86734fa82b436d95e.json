{"sha": "6602dd4a3bdebc25f78262c86734fa82b436d95e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYwMmRkNGEzYmRlYmMyNWY3ODI2MmM4NjczNGZhODJiNDM2ZDk1ZQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-11-18T13:22:55Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-11-18T13:22:55Z"}, "message": "PlainSocketImpl.java: Reworked imports.\n\n2002-11-18  Michael Koch <konqueror@gmx.de>\n\n\t* java/net/PlainSocketImpl.java: Reworked imports.\n\t* java/net/ServerSocket.java\n\t(ServerSocket): Create socket.\n\t* java/net/SocketAddress.java: Documentation added.\n\t* java/net/natPlainSocketImpl.cc: Reindented.\n\t* java/nio/ReadOnlyBufferException.java: New file\n\t* java/nio/channels/ClosedChannelException.java: Documentation added.\n\t* java/nio/channels/ClosedSelectorException.java: New file.\n\nFrom-SVN: r59214", "tree": {"sha": "3b1a137eb9c8aecc2f3d077b3289c75f77675b79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b1a137eb9c8aecc2f3d077b3289c75f77675b79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6602dd4a3bdebc25f78262c86734fa82b436d95e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6602dd4a3bdebc25f78262c86734fa82b436d95e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6602dd4a3bdebc25f78262c86734fa82b436d95e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6602dd4a3bdebc25f78262c86734fa82b436d95e/comments", "author": null, "committer": null, "parents": [{"sha": "3503150c4c5f3f6b5e7ba5d6430a419ff8d38fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3503150c4c5f3f6b5e7ba5d6430a419ff8d38fe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3503150c4c5f3f6b5e7ba5d6430a419ff8d38fe2"}], "stats": {"total": 624, "additions": 389, "deletions": 235}, "files": [{"sha": "9afa6c92e9697b94de54f66d72d57afaa0840d3d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -1,3 +1,14 @@\n+2002-11-18  Michael Koch <konqueror@gmx.de>\n+\n+\t* java/net/PlainSocketImpl.java: Reworked imports.\n+\t* java/net/ServerSocket.java\n+\t(ServerSocket): Create socket.\n+\t* java/net/SocketAddress.java: Documentation added.\n+\t* java/net/natPlainSocketImpl.cc: Reindented.\n+\t* java/nio/ReadOnlyBufferException.java: New file\n+\t* java/nio/channels/ClosedChannelException.java: Documentation added.\n+\t* java/nio/channels/ClosedSelectorException.java: New file.\n+\n 2002-11-17  Mark Wielaard  <mark@klomp.org>\n \n \t* java/net/HttpURLConnection.java ((getPermission): Take port"}, {"sha": "3cb2e3e6009de2f9573893451c8e77523d6e4338", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -9,8 +9,8 @@\n details.  */\n \n package java.net;\n-import java.io.*;\n \n+import java.io.IOException;\n \n /**\n  * The standard GCJ socket implementation."}, {"sha": "dda834e5f985e97a33bf12b4bde16fc1af2bec7c", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -60,16 +60,11 @@\n  */\n public class ServerSocket\n {\n-\n-  // Class Variables\n-\n   /**\n    * This is the user defined SocketImplFactory, if one is supplied\n    */\n   private static SocketImplFactory factory;\n \n-  // Instance Variables\n-\n   /**\n    * This is the SocketImp object to which most instance methods in this\n    * class are redirected\n@@ -95,6 +90,8 @@ public ServerSocket() throws IOException\n       impl = factory.createSocketImpl();\n     else\n       impl = new PlainSocketImpl();\n+\n+    impl.create(true);\n   }\n \n   /**"}, {"sha": "370049d6fdcdbb0ffbd1b45f3dff815a36b3480f", "filename": "libjava/java/net/SocketAddress.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FSocketAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FSocketAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketAddress.java?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -37,20 +37,23 @@\n \n package java.net;\n \n-import java.io.*;\n+import java.io.Serializable;\n \n /** \n  * Abstract base class for InetSocketAddress.\n  * InetSocketAddress is to my knowledge the only derived\n  * class. [Ronald]\n+ *\n+ * @since 1.4\n  */\n-\n public abstract class SocketAddress implements Serializable\n {\n   static final long serialVersionUID = 5215720748342549866L;\n \n+  /**\n+   * Initializes the socket address.\n+   */\n   public SocketAddress()\n   {\n   }\n }\n-"}, {"sha": "275e8f9a4c8a6e3b39a0f2d817d830776c6a5404", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 261, "deletions": 226, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -259,6 +259,7 @@ void\n java::net::PlainSocketImpl::create (jboolean stream)\n {\n   int sock = ::socket (AF_INET, stream ? SOCK_STREAM : SOCK_DGRAM, 0);\n+\n   if (sock < 0)\n     {\n       char* strerr = strerror (errno);\n@@ -285,10 +286,12 @@ java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n   if (len == 4)\n     {\n       u.address.sin_family = AF_INET;\n+\n       if (host != NULL)\n         memcpy (&u.address.sin_addr, bytes, len);\n       else\n-\tu.address.sin_addr.s_addr = htonl (INADDR_ANY);        \n+        u.address.sin_addr.s_addr = htonl (INADDR_ANY);\n+\n       len = sizeof (struct sockaddr_in);\n       u.address.sin_port = htons (lport);\n     }\n@@ -311,22 +314,25 @@ java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n     {\n       address = host;\n       socklen_t addrlen = sizeof(u);\n+\n       if (lport != 0)\n         localport = lport;\n       else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n         localport = ntohs (u.address.sin_port);\n       else\n         goto error;\n+\n       return;\n     }\n+\n  error:\n   char* strerr = strerror (errno);\n   throw new java::net::BindException (JvNewStringUTF (strerr));\n }\n \n void\n java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n-\t\t                     jint timeout)\n+                                     jint timeout)\n {\n   java::net::InetSocketAddress *tmp = (java::net::InetSocketAddress*) addr;\n   java::net::InetAddress *host = tmp->getAddress();\n@@ -376,10 +382,10 @@ java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n       int retval;\n       \n       if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-\tgoto error;\n+        goto error;\n       else if (retval == 0)\n-\tthrow new java::net::SocketTimeoutException ( \n-\t         JvNewStringUTF(\"Connect timed out\"));\n+        throw new java::net::SocketTimeoutException\n+          (JvNewStringUTF (\"Connect timed out\"));\n     }\n   else\n #endif\n@@ -390,15 +396,18 @@ java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n \n   address = host;\n   port = rport;\n+\n   // A bind may not have been done on this socket; if so, set localport now.\n   if (localport == 0)\n     {\n       if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n-\tlocalport = ntohs (u.address.sin_port);\n+        localport = ntohs (u.address.sin_port);\n       else\n-\tgoto error;\n+        goto error;\n     }\n+\n   return;  \n+\n  error:\n   char* strerr = strerror (errno);\n   throw new java::net::ConnectException (JvNewStringUTF (strerr));\n@@ -434,14 +443,15 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n       tv.tv_usec = (timeout % 1000) * 1000;\n       int retval;\n       if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-\tgoto error;\n+        goto error;\n       else if (retval == 0)\n-\tthrow new java::io::InterruptedIOException (\n-\t         JvNewStringUTF(\"Accept timed out\"));\n+        throw new java::io::InterruptedIOException (\n+\t                                  JvNewStringUTF(\"Accept timed out\"));\n     }\n #endif /* WIN32 */\n \n   new_socket = _Jv_accept (fnum, (sockaddr*) &u, &addrlen);\n+\n   if (new_socket < 0)\n     goto error;\n \n@@ -471,6 +481,7 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n   s->address = new InetAddress (raddr, NULL);\n   s->port = rport;\n   return;\n+\n  error:\n   char* strerr = strerror (errno);\n   throw new java::io::IOException (JvNewStringUTF (strerr));\n@@ -491,7 +502,7 @@ java::net::PlainSocketImpl::close()\n       // These three errors are not errors according to tests performed\n       // on the reference implementation.\n       if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-\tthrow new java::io::IOException  (JvNewStringUTF (strerror (errno)));\n+        throw new java::io::IOException  (JvNewStringUTF (strerror (errno)));\n     }\n   // Safe place to reset the file pointer.\n   fnum = -1;\n@@ -509,20 +520,20 @@ java::net::PlainSocketImpl::write(jint b)\n     {\n       r = ::write (fnum, &d, 1);\n       if (r == -1)\n-\t{\n-\t  if (java::lang::Thread::interrupted())\n-\t    {\n-\t      java::io::InterruptedIOException *iioe\n-\t\t= new java::io::InterruptedIOException \n-\t\t(JvNewStringLatin1 (strerror (errno)));\n-\t      iioe->bytesTransferred = 0;\n-\t      throw iioe;\n-\t    }\n-\t  // Some errors should not cause exceptions.\n-\t  if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-\t    throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n-\t  break;\n-\t}\n+        {\n+          if (java::lang::Thread::interrupted())\n+            {\n+              java::io::InterruptedIOException *iioe\n+                = new java::io::InterruptedIOException \n+                (JvNewStringLatin1 (strerror (errno)));\n+              iioe->bytesTransferred = 0;\n+              throw iioe;\n+            }\n+          // Some errors should not cause exceptions.\n+          if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n+            throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+          break;\n+        }\n     }\n }\n \n@@ -537,24 +548,27 @@ java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n \n   jbyte *bytes = elements (b) + offset;\n   int written = 0;\n+\n   while (len > 0)\n     {\n       int r = ::write (fnum, bytes, len);\n+\n       if (r == -1)\n         {\n-\t  if (java::lang::Thread::interrupted())\n-\t    {\n-\t      java::io::InterruptedIOException *iioe\n-\t\t= new java::io::InterruptedIOException\n-\t\t(JvNewStringLatin1 (strerror (errno)));\n-\t      iioe->bytesTransferred = written;\n-\t      throw iioe;\n-\t    }\n-\t  // Some errors should not cause exceptions.\n-\t  if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-\t    throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n-\t  break;\n-\t}\n+          if (java::lang::Thread::interrupted())\n+            {\n+              java::io::InterruptedIOException *iioe\n+                = new java::io::InterruptedIOException\n+                (JvNewStringLatin1 (strerror (errno)));\n+              iioe->bytesTransferred = written;\n+              throw iioe;\n+            }\n+          // Some errors should not cause exceptions.\n+          if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n+            throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+          break;\n+        }\n+\n       written += r;\n       len -= r;\n       bytes += r;\n@@ -578,48 +592,51 @@ java::net::PlainSocketImpl::read(void)\n #ifndef WIN32\n   // Do timeouts via select.\n   if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-  {\n-    // Create the file descriptor set.\n-    fd_set read_fds;\n-    FD_ZERO (&read_fds);\n-    FD_SET (fnum,&read_fds);\n-    // Create the timeout struct based on our internal timeout value.\n-    struct timeval timeout_value;\n-    timeout_value.tv_sec = timeout / 1000;\n-    timeout_value.tv_usec = (timeout % 1000) * 1000;\n-    // Select on the fds.\n-    int sel_retval =\n-\t    _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n-    // If select returns 0 we've waited without getting data...\n-    // that means we've timed out.\n-    if (sel_retval == 0)\n-      throw new java::io::InterruptedIOException\n-\t(JvNewStringUTF (\"read timed out\") );\n-    // If select returns ok we know we either got signalled or read some data...\n-    // either way we need to try to read.\n-  }\n+    {\n+      // Create the file descriptor set.\n+      fd_set read_fds;\n+      FD_ZERO (&read_fds);\n+      FD_SET (fnum,&read_fds);\n+      // Create the timeout struct based on our internal timeout value.\n+      struct timeval timeout_value;\n+      timeout_value.tv_sec = timeout / 1000;\n+      timeout_value.tv_usec = (timeout % 1000) * 1000;\n+      // Select on the fds.\n+      int sel_retval =\n+        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+      // If select returns 0 we've waited without getting data...\n+      // that means we've timed out.\n+      if (sel_retval == 0)\n+        throw new java::io::InterruptedIOException\n+          (JvNewStringUTF (\"read timed out\") );\n+      // If select returns ok we know we either got signalled or read some data...\n+      // either way we need to try to read.\n+    }\n #endif /* WIN32 */\n \n   int r = ::read (fnum, &b, 1);\n \n   if (r == 0)\n     return -1;\n+\n   if (java::lang::Thread::interrupted())\n     {\n       java::io::InterruptedIOException *iioe =\n-\tnew java::io::InterruptedIOException\n-\t(JvNewStringUTF(\"read interrupted\"));\n+        new java::io::InterruptedIOException\n+        (JvNewStringUTF(\"read interrupted\"));\n       iioe->bytesTransferred = r == -1 ? 0 : r;\n       throw iioe;\n     }\n   else if (r == -1)\n     {\n       // Some errors cause us to return end of stream...\n       if (errno == ENOTCONN)\n-\treturn -1;\n+        return -1;\n+\n       // Other errors need to be signalled.\n       throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n     }\n+\n   return b & 0xFF;\n }\n \n@@ -629,61 +646,68 @@ java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n {\n   if (! buffer)\n     throw new java::lang::NullPointerException;\n+\n   jsize bsize = JvGetArrayLength (buffer);\n+\n   if (offset < 0 || count < 0 || offset + count > bsize)\n     throw new java::lang::ArrayIndexOutOfBoundsException;\n+\n   jbyte *bytes = elements (buffer) + offset;\n \n // FIXME: implement timeout support for Win32\n #ifndef WIN32\n   // Do timeouts via select.\n   if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-  {\n-    // Create the file descriptor set.\n-    fd_set read_fds;\n-    FD_ZERO (&read_fds);\n-    FD_SET (fnum, &read_fds);\n-    // Create the timeout struct based on our internal timeout value.\n-    struct timeval timeout_value;\n-    timeout_value.tv_sec = timeout / 1000;\n-    timeout_value.tv_usec =(timeout % 1000) * 1000;\n-    // Select on the fds.\n-    int sel_retval = \n-\t    _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n-    // We're only interested in the 0 return.\n-    // error returns still require us to try to read \n-    // the socket to see what happened.\n-    if (sel_retval == 0)\n-      {\n-\tjava::io::InterruptedIOException *iioe =\n-\t  new java::io::InterruptedIOException\n-\t  (JvNewStringUTF (\"read interrupted\"));\n-\tiioe->bytesTransferred = 0;\n-\tthrow iioe;\n-      }\n-  }\n+    {\n+      // Create the file descriptor set.\n+      fd_set read_fds;\n+      FD_ZERO (&read_fds);\n+      FD_SET (fnum, &read_fds);\n+      // Create the timeout struct based on our internal timeout value.\n+      struct timeval timeout_value;\n+      timeout_value.tv_sec = timeout / 1000;\n+      timeout_value.tv_usec =(timeout % 1000) * 1000;\n+      // Select on the fds.\n+      int sel_retval =\n+        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+      // We're only interested in the 0 return.\n+      // error returns still require us to try to read \n+      // the socket to see what happened.\n+      if (sel_retval == 0)\n+        {\n+          java::io::InterruptedIOException *iioe =\n+            new java::io::InterruptedIOException\n+            (JvNewStringUTF (\"read interrupted\"));\n+          iioe->bytesTransferred = 0;\n+          throw iioe;\n+        }\n+    }\n #endif\n \n   // Read the socket.\n   int r = ::recv (fnum, (char *) bytes, count, 0);\n+\n   if (r == 0)\n     return -1;\n+\n   if (java::lang::Thread::interrupted())\n     {\n       java::io::InterruptedIOException *iioe =\n-\tnew java::io::InterruptedIOException\n-\t(JvNewStringUTF (\"read interrupted\"));\n+        new java::io::InterruptedIOException\n+        (JvNewStringUTF (\"read interrupted\"));\n       iioe->bytesTransferred = r == -1 ? 0 : r;\n       throw iioe;\n     }\n   else if (r == -1)\n     {\n       // Some errors cause us to return end of stream...\n       if (errno == ENOTCONN)\n-\treturn -1;\n+        return -1;\n+\n       // Other errors need to be signalled.\n       throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n     }\n+\n   return r;\n }\n \n@@ -698,6 +722,7 @@ java::net::PlainSocketImpl::available(void)\n \n #if defined(FIONREAD)\n   r = ::ioctl (fnum, FIONREAD, &num);\n+\n   if (r == -1 && errno == ENOTTY)\n     {\n       // If the ioctl doesn't work, we don't care.\n@@ -718,34 +743,32 @@ java::net::PlainSocketImpl::available(void)\n     {\n     posix_error:\n       throw new java::io::IOException(JvNewStringUTF(strerror(errno)));\n-\n     }\n \n   // If we didn't get anything we can use select.\n \n #if defined(HAVE_SELECT)\n   if (! num_set)\n-  if (! num_set && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      fd_set rd;\n-      FD_ZERO (&rd);\n-      FD_SET (fnum, &rd);\n-      struct timeval tv;\n-      tv.tv_sec = 0;\n-      tv.tv_usec = 0;\n-      r = _Jv_select (fnum + 1, &rd, NULL, NULL, &tv);\n-      if(r == -1)\n-\tgoto posix_error;\n-      num = r == 0 ? 0 : 1;\n-    }\n+    if (! num_set && fnum >= 0 && fnum < FD_SETSIZE)\n+      {\n+        fd_set rd;\n+        FD_ZERO (&rd);\n+        FD_SET (fnum, &rd);\n+        struct timeval tv;\n+        tv.tv_sec = 0;\n+        tv.tv_usec = 0;\n+        r = _Jv_select (fnum + 1, &rd, NULL, NULL, &tv);\n+        if(r == -1)\n+          goto posix_error;\n+        num = r == 0 ? 0 : 1;\n+      }\n #endif /* HAVE_SELECT */\n \n   return (jint) num;\n #else\n   throw new java::io::IOException (JvNewStringUTF (\"unimplemented\"));\n #endif\n- }\n-\n+}\n \n void\n java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n@@ -764,10 +787,10 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n         val = 1; \n       else \n         {\n-\t  if (optID == _Jv_SO_LINGER_)\n-\t    val = -1;\n-\t  else\n-\t    val = 0;\n+          if (optID == _Jv_SO_LINGER_)\n+            val = -1;\n+          else\n+            val = 0;\n         }\n     }\n   else if (_Jv_IsInstanceOf (value, &java::lang::Integer::class$))\n@@ -787,28 +810,28 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n       case _Jv_TCP_NODELAY_ :\n #ifdef TCP_NODELAY\n         if (::setsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n-\t    val_len) != 0)\n-\t  goto error;\n+                          val_len) != 0)\n+          goto error;\n #else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"TCP_NODELAY not supported\"));\n+        throw new java::lang::InternalError\n+          (JvNewStringUTF (\"TCP_NODELAY not supported\"));\n #endif /* TCP_NODELAY */\n         return;\n \n       case _Jv_SO_KEEPALIVE_ :\n         if (::setsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n-\t    val_len) != 0)\n-\t  goto error;\n-\tbreak;\n+                          val_len) != 0)\n+          goto error;\n+        break;\n       \n       case _Jv_SO_BROADCAST_ :\n-        throw new java::net::SocketException (\n-          JvNewStringUTF (\"SO_BROADCAST not valid for TCP\"));\n-\tbreak;\n+        throw new java::net::SocketException\n+          (JvNewStringUTF (\"SO_BROADCAST not valid for TCP\"));\n+        break;\n \t\n       case _Jv_SO_OOBINLINE_ :\n         if (::setsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n-            val_len) != 0)\n+                          val_len) != 0)\n           goto error;\n         break;\n \n@@ -817,30 +840,34 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n         struct linger l_val;\n         l_val.l_onoff = (val != -1);\n         l_val.l_linger = val;\n+\n         if (::setsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n-\t    sizeof(l_val)) != 0)\n-\t  goto error;    \n+                          sizeof(l_val)) != 0)\n+          goto error;    \n #else\n         throw new java::lang::InternalError (\n           JvNewStringUTF (\"SO_LINGER not supported\"));\n #endif /* SO_LINGER */\n         return;\n+\n       case _Jv_SO_SNDBUF_ :\n       case _Jv_SO_RCVBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n         if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n-\t  goto error;    \n+          goto error;    \n #else\n         throw new java::lang::InternalError (\n           JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n #endif \n         return;\n+\n       case _Jv_SO_BINDADDR_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_BINDADDR: read only option\"));\n         return;\n+\n       case _Jv_IP_MULTICAST_IF_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n@@ -854,21 +881,23 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n       case _Jv_IP_MULTICAST_LOOP_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n-\tbreak;\n+        break;\n \t\n       case _Jv_IP_TOS_ :\n         if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-\t   val_len) != 0)\n-\t  goto error;    \n-\tbreak;\n+                          val_len) != 0)\n+          goto error;    \n+        break;\n \t\n       case _Jv_SO_REUSEADDR_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n         return;\n+\n       case _Jv_SO_TIMEOUT_ :\n-\ttimeout = val;\n+        timeout = val;\n         return;\n+\n       default :\n         errno = ENOPROTOOPT;\n     }\n@@ -891,123 +920,129 @@ java::net::PlainSocketImpl::getOption (jint optID)\n   switch (optID)\n     {\n #ifdef TCP_NODELAY\n-      case _Jv_TCP_NODELAY_ :\n-        if (::getsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n-\t    &val_len) != 0)\n-          goto error;\n-        else\n-\t  return new java::lang::Boolean (val != 0);\n+    case _Jv_TCP_NODELAY_ :\n+      if (::getsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n+                        &val_len) != 0)\n+        goto error;\n+      else\n+        return new java::lang::Boolean (val != 0);\n #else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"TCP_NODELAY not supported\"));\n+      throw new java::lang::InternalError\n+        (JvNewStringUTF (\"TCP_NODELAY not supported\"));\n #endif       \n-        break;\n-\n-      case _Jv_SO_LINGER_ :\n+      break;\n+      \n+    case _Jv_SO_LINGER_ :\n #ifdef SO_LINGER\n-        if (::getsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n-\t    &l_val_len) != 0)\n-\t  goto error;    \n-        if (l_val.l_onoff)\n-          return new java::lang::Integer (l_val.l_linger);\n-        else\n-\t  return new java::lang::Boolean ((jboolean)false);\n+      if (::getsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n+                        &l_val_len) != 0)\n+        goto error;    \n+ \n+      if (l_val.l_onoff)\n+        return new java::lang::Integer (l_val.l_linger);\n+      else\n+        return new java::lang::Boolean ((jboolean)false);\n #else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_LINGER not supported\"));\n+      throw new java::lang::InternalError\n+        (JvNewStringUTF (\"SO_LINGER not supported\"));\n #endif\n-        break;    \n+      break;    \n \n-      case _Jv_SO_KEEPALIVE_ :\n-        if (::getsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n-\t    &val_len) != 0)\n-          goto error;\n-        else\n-\t  return new java::lang::Boolean (val != 0);\n+    case _Jv_SO_KEEPALIVE_ :\n+      if (::getsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n+                        &val_len) != 0)\n+        goto error;\n+      else\n+        return new java::lang::Boolean (val != 0);\n \n-      case _Jv_SO_BROADCAST_ :\n-        if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n-\t   &val_len) != 0)\n-\t  goto error;    \n-        return new java::lang::Boolean ((jboolean)val);\n+    case _Jv_SO_BROADCAST_ :\n+      if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+                        &val_len) != 0)\n+        goto error;    \n+      return new java::lang::Boolean ((jboolean)val);\n \t\n-      case _Jv_SO_OOBINLINE_ :\n-        if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n-\t    &val_len) != 0)\n-\t  goto error;    \n-        return new java::lang::Boolean ((jboolean)val);\n+    case _Jv_SO_OOBINLINE_ :\n+      if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n+                        &val_len) != 0)\n+        goto error;    \n+      return new java::lang::Boolean ((jboolean)val);\n \t\n-      case _Jv_SO_RCVBUF_ :\n-      case _Jv_SO_SNDBUF_ :\n+    case _Jv_SO_RCVBUF_ :\n+    case _Jv_SO_SNDBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n-        int opt;\n-        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n-\t  goto error;    \n-        else\n-\t  return new java::lang::Integer (val);\n+      int opt;\n+      optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n+      if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n+        goto error;    \n+      else\n+        return new java::lang::Integer (val);\n #else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n+      throw new java::lang::InternalError\n+        (JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n #endif    \n-\tbreak;\n-      case _Jv_SO_BINDADDR_:\n-\t// cache the local address \n-\tif (localAddress == NULL)\n-\t  {\n-\t    jbyteArray laddr;\n-\t    if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n-\t      goto error;\n-\t    if (u.address.sin_family == AF_INET)\n-\t      {\n-\t\tladdr = JvNewByteArray (4);\n-\t\tmemcpy (elements (laddr), &u.address.sin_addr, 4);\n-\t      }\n+      break;\n+    case _Jv_SO_BINDADDR_:\n+      // cache the local address \n+      if (localAddress == NULL)\n+        {\n+          jbyteArray laddr;\n+\n+          if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+            goto error;\n+\n+          if (u.address.sin_family == AF_INET)\n+            {\n+              laddr = JvNewByteArray (4);\n+              memcpy (elements (laddr), &u.address.sin_addr, 4);\n+            }\n #ifdef HAVE_INET6\n-            else if (u.address.sin_family == AF_INET6)\n-\t      {\n-\t\tladdr = JvNewByteArray (16);\n-\t\tmemcpy (elements (laddr), &u.address6.sin6_addr, 16);\n-\t      }\n+          else if (u.address.sin_family == AF_INET6)\n+            {\n+              laddr = JvNewByteArray (16);\n+              memcpy (elements (laddr), &u.address6.sin6_addr, 16);\n+            }\n #endif\n-\t    else\n-\t      throw new java::net::SocketException (\n-\t\t\t      JvNewStringUTF (\"invalid family\"));\n-\t    localAddress = new java::net::InetAddress (laddr, NULL);\n-\t  }\n-\treturn localAddress;\n-\tbreak;\n-      case _Jv_IP_MULTICAST_IF_ :\n-\tthrow new java::net::SocketException (\n-\t  JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n-\tbreak;\n+          else\n+            throw new java::net::SocketException\n+              (JvNewStringUTF (\"invalid family\"));\n+          localAddress = new java::net::InetAddress (laddr, NULL);\n+        }\n+\n+      return localAddress;\n+      break;\n+    case _Jv_IP_MULTICAST_IF_ :\n+      throw new java::net::SocketException\n+        (JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n+      break;\n \t\n-      case _Jv_IP_MULTICAST_IF2_ :\n-\tthrow new java::net::SocketException (\n-\t  JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n-\tbreak;\n+    case _Jv_IP_MULTICAST_IF2_ :\n+      throw new java::net::SocketException\n+        (JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n+      break;\n \t\n-      case _Jv_IP_MULTICAST_LOOP_ :\n-\tthrow new java::net::SocketException(\n-          JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n-\tbreak;\n+    case _Jv_IP_MULTICAST_LOOP_ :\n+      throw new java::net::SocketException\n+        (JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n+      break;\n \t\n-      case _Jv_IP_TOS_ :\n-        if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-           &val_len) != 0)\n-          goto error;\n-        return new java::lang::Integer (val);\n-\tbreak;\n+    case _Jv_IP_TOS_ :\n+      if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n+                        &val_len) != 0)\n+        goto error;\n+      return new java::lang::Integer (val);\n+      break;\n \t\n-      case _Jv_SO_REUSEADDR_ :\n-\tthrow new java::net::SocketException (\n-\t  JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n-\tbreak;\n-      case _Jv_SO_TIMEOUT_ :\n-\treturn new java::lang::Integer (timeout);\n-\tbreak;\n-      default :\n-\terrno = ENOPROTOOPT;\n+    case _Jv_SO_REUSEADDR_ :\n+      throw new java::net::SocketException\n+        (JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n+      break;\n+\n+    case _Jv_SO_TIMEOUT_ :\n+      return new java::lang::Integer (timeout);\n+      break;\n+\n+    default :\n+      errno = ENOPROTOOPT;\n     }\n \n  error:"}, {"sha": "0fcdc3ac7db64868cf917cfee5db1aaba142b5bf", "filename": "libjava/java/nio/ReadOnlyBufferException.java", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnio%2FReadOnlyBufferException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnio%2FReadOnlyBufferException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FReadOnlyBufferException.java?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -0,0 +1,52 @@\n+/* ReadOnlyBufferException.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+/**\n+ * @author Michael Koch\n+ * @since 1.4\n+ */\n+public class ReadOnlyBufferException extends UnsupportedOperationException\n+{\n+  /**\n+   * Creates the exception\n+   */\n+  public ReadOnlyBufferException ()\n+  {\n+  }\n+}"}, {"sha": "353a820264747831be68cdfadfbb9d18798ed446", "filename": "libjava/java/nio/channels/ClosedChannelException.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnio%2Fchannels%2FClosedChannelException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnio%2Fchannels%2FClosedChannelException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FClosedChannelException.java?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -39,6 +39,10 @@\n \n import java.io.IOException;\n \n+/**\n+ * @author Michael Koch\n+ * @since 1.4\n+ */\n public class ClosedChannelException extends IOException\n {\n   /**"}, {"sha": "98a9d505ded801957281532e8cb43d3f6da7d5cc", "filename": "libjava/java/nio/channels/ClosedSelectorException.java", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnio%2Fchannels%2FClosedSelectorException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6602dd4a3bdebc25f78262c86734fa82b436d95e/libjava%2Fjava%2Fnio%2Fchannels%2FClosedSelectorException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FClosedSelectorException.java?ref=6602dd4a3bdebc25f78262c86734fa82b436d95e", "patch": "@@ -0,0 +1,52 @@\n+/* ClosedSelectorException.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio.channels;\n+\n+/**\n+ * @author Michael Koch\n+ * @since 1.4\n+ */\n+public class ClosedSelectorException extends IllegalStateException\n+{\n+  /**\n+   * Creates the exception\n+   */\n+  public ClosedSelectorException()\n+  {\n+  }\n+}"}]}