{"sha": "b699adcc9eec16b7856635658d12518b45ef0d3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY5OWFkY2M5ZWVjMTZiNzg1NjYzNTY1OGQxMjUxOGI0NWVmMGQzYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-11-30T14:44:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-30T14:44:48Z"}, "message": "nvptx.c (nvptx_name_replacement): Move earlier.\n\n\t* config/nvptx/nvptx.c (nvptx_name_replacement): Move earlier.\n\t(write_one_arg): Reorder parms, add 'sep' param.\n\t(nvptx_write_function_decl): Rename to ...\n\t(write_fn_proto): ... here.  Do name replacement. Emit linaer\n\tcomment marker. Deal with both decls and defns. Simplify argument\n\tformatting.\n\t(write_function_decl_and_comment): Delete.\n\t(write_func_decl_from_insn): Rename to ...\n\t(write_fn_proto_from_insn): ... here.  Don't do name replacement.\n\t(nvptx_record_fndecl): Call write_fn_proto.\n\t(nvptx_record_libfunc): Call write_fn_proto_from_insn.\n\t(nvptx_declare_function_name): Adjust for write_fn_proto changes.\n\t(nvotx_output_call_insn): Call write_fn_prot_from_insn.\n\nFrom-SVN: r231073", "tree": {"sha": "a2350bda8fe6ea2aa1ac44c2acaeeab4141a1349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2350bda8fe6ea2aa1ac44c2acaeeab4141a1349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b699adcc9eec16b7856635658d12518b45ef0d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b699adcc9eec16b7856635658d12518b45ef0d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b699adcc9eec16b7856635658d12518b45ef0d3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b699adcc9eec16b7856635658d12518b45ef0d3b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ef5fbc1f4b4e34e4b084f5b59b0885bfa3300fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ef5fbc1f4b4e34e4b084f5b59b0885bfa3300fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ef5fbc1f4b4e34e4b084f5b59b0885bfa3300fb"}], "stats": {"total": 270, "additions": 132, "deletions": 138}, "files": [{"sha": "f5a8238869d4209af0201bb031413cfdfeb5caed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b699adcc9eec16b7856635658d12518b45ef0d3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b699adcc9eec16b7856635658d12518b45ef0d3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b699adcc9eec16b7856635658d12518b45ef0d3b", "patch": "@@ -1,3 +1,19 @@\n+2015-11-30  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.c (nvptx_name_replacement): Move earlier.\n+\t(write_one_arg): Reorder parms, add 'sep' param.\n+\t(nvptx_write_function_decl): Rename to ...\n+\t(write_fn_proto): ... here.  Do name replacement. Emit linaer\n+\tcomment marker. Deal with both decls and defns. Simplify argument\n+\tformatting.\n+\t(write_function_decl_and_comment): Delete.\n+\t(write_func_decl_from_insn): Rename to ...\n+\t(write_fn_proto_from_insn): ... here.  Don't do name replacement.\n+\t(nvptx_record_fndecl): Call write_fn_proto.\n+\t(nvptx_record_libfunc): Call write_fn_proto_from_insn.\n+\t(nvptx_declare_function_name): Adjust for write_fn_proto changes.\n+\t(nvotx_output_call_insn): Call write_fn_prot_from_insn.\n+\n 2015-11-30  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* config/i386/i386.md (define_mode_iterator SWI1248_AVX512BW): New."}, {"sha": "899c8566df23ee60e68cdfc29e781c6c6115ba6f", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 116, "deletions": 138, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b699adcc9eec16b7856635658d12518b45ef0d3b/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b699adcc9eec16b7856635658d12518b45ef0d3b/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=b699adcc9eec16b7856635658d12518b45ef0d3b", "patch": "@@ -224,6 +224,24 @@ nvptx_addr_space_from_sym (rtx sym)\n   return ADDR_SPACE_GLOBAL;\n }\n \n+/* Check NAME for special function names and redirect them by returning a\n+   replacement.  This applies to malloc, free and realloc, for which we\n+   want to use libgcc wrappers, and call, which triggers a bug in ptxas.  */\n+\n+static const char *\n+nvptx_name_replacement (const char *name)\n+{\n+  if (strcmp (name, \"call\") == 0)\n+    return \"__nvptx_call\";\n+  if (strcmp (name, \"malloc\") == 0)\n+    return \"__nvptx_malloc\";\n+  if (strcmp (name, \"free\") == 0)\n+    return \"__nvptx_free\";\n+  if (strcmp (name, \"realloc\") == 0)\n+    return \"__nvptx_realloc\";\n+  return name;\n+}\n+\n /* If MODE should be treated as two registers of an inner mode, return\n    that inner mode.  Otherwise return VOIDmode.  */\n \n@@ -309,18 +327,18 @@ arg_promotion (machine_mode mode)\n    a decl with zero TYPE_ARG_TYPES, i.e. an old-style C decl.  */\n \n static int\n-write_one_arg (std::stringstream &s, tree type, int i, machine_mode mode,\n-\t       bool no_arg_types)\n+write_one_arg (std::stringstream &s, const char *sep, int i,\n+\t       tree type, machine_mode mode, bool no_arg_types)\n {\n   if (!PASS_IN_REG_P (mode, type))\n     mode = Pmode;\n \n   machine_mode split = maybe_split_mode (mode);\n   if (split != VOIDmode)\n     {\n-      i = write_one_arg (s, NULL_TREE, i, split, false);\n-      i = write_one_arg (s, NULL_TREE, i, split, false);\n-      return i;\n+      i = write_one_arg (s, sep, i, TREE_TYPE (type), split, false);\n+      sep = \", \";\n+      mode = split;\n     }\n \n   if (no_arg_types && !AGGREGATE_TYPE_P (type))\n@@ -330,8 +348,7 @@ write_one_arg (std::stringstream &s, tree type, int i, machine_mode mode,\n       mode = arg_promotion (mode);\n     }\n \n-  if (i)\n-    s << \", \";\n+  s << sep;\n   s << \".param\" << nvptx_ptx_type_from_mode (mode, false) << \" %in_ar\"\n     << i << (mode == QImode || mode == HImode ? \"[1]\" : \"\");\n   if (mode == BLKmode)\n@@ -349,41 +366,41 @@ write_as_kernel (tree attrs)\n \t  || lookup_attribute (\"omp target entrypoint\", attrs) != NULL_TREE);\n }\n \n-/* Write a function decl for DECL to S, where NAME is the name to be used.\n-   This includes ptx .visible or .extern specifiers, .func or .kernel, and\n-   argument and return types.  */\n+/* Write a .func or .kernel declaration or definition along with\n+   a helper comment for use by ld.  S is the stream to write to, DECL\n+   the decl for the function with name NAME.   For definitions, emit\n+   a declaration too.  */\n \n-static void\n-nvptx_write_function_decl (std::stringstream &s, const char *name, const_tree decl)\n+static const char *\n+write_fn_proto (std::stringstream &s, bool is_defn,\n+\t\tconst char *name, const_tree decl)\n {\n-  tree fntype = TREE_TYPE (decl);\n-  tree result_type = TREE_TYPE (fntype);\n-  tree args = TYPE_ARG_TYPES (fntype);\n-  tree attrs = DECL_ATTRIBUTES (decl);\n-  bool kernel = write_as_kernel (attrs);\n-  bool is_main = strcmp (name, \"main\") == 0;\n-  bool args_from_decl = false;\n-\n-  /* We get:\n-     NULL in TYPE_ARG_TYPES, for old-style functions\n-     NULL in DECL_ARGUMENTS, for builtin functions without another\n-       declaration.\n-     So we have to pick the best one we have.  */\n-  if (args == 0)\n+  if (is_defn)\n+    /* Emit a declaration. The PTX assembler gets upset without it.   */\n+    name = write_fn_proto (s, false, name, decl);\n+  else\n     {\n-      args = DECL_ARGUMENTS (decl);\n-      args_from_decl = true;\n+      /* Avoid repeating the name replacement.  */\n+      name = nvptx_name_replacement (name);\n+      if (name[0] == '*')\n+\tname++;\n     }\n \n+  /* Emit the linker marker.  */\n+  s << \"\\n// BEGIN\";\n+  if (TREE_PUBLIC (decl))\n+    s << \" GLOBAL\";\n+  s << \" FUNCTION \" << (is_defn ? \"DEF\" : \"DECL\") << \": \" << name << \"\\n\";\n+\n+  /* PTX declaration.  */\n   if (DECL_EXTERNAL (decl))\n     s << \".extern \";\n   else if (TREE_PUBLIC (decl))\n     s << (DECL_WEAK (decl) ? \".weak \" : \".visible \");\n+  s << (write_as_kernel (DECL_ATTRIBUTES (decl)) ? \".entry \" : \".func \");\n \n-  if (kernel)\n-    s << \".entry \";\n-  else\n-    s << \".func \";\n+  tree fntype = TREE_TYPE (decl);\n+  tree result_type = TREE_TYPE (fntype);\n \n   /* Declare the result.  */\n   bool return_in_mem = false;\n@@ -396,78 +413,74 @@ nvptx_write_function_decl (std::stringstream &s, const char *name, const_tree de\n \t{\n \t  mode = arg_promotion (mode);\n \t  s << \"(.param\" << nvptx_ptx_type_from_mode (mode, false)\n-\t    << \" %out_retval)\";\n+\t    << \" %out_retval) \";\n \t}\n     }\n \n-  if (name[0] == '*')\n-    s << (name + 1);\n-  else\n-    s << name;\n-\n-  /* Declare argument types.  */\n-  if ((args != NULL_TREE\n-       && !(TREE_CODE (args) == TREE_LIST\n-\t    && TREE_VALUE (args) == void_type_node))\n-      || is_main\n-      || return_in_mem\n-      || DECL_STATIC_CHAIN (decl))\n+  s << name;\n+\n+  const char *sep = \" (\";\n+  int i = 0;\n+\n+  /* Emit argument list.  */\n+  if (return_in_mem)\n     {\n-      s << \"(\";\n-      int i = 0;\n+      s << sep << \".param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_ar0\";\n+      sep  = \", \";\n+      i++;\n+    }\n \n-      if (return_in_mem)\n-\t{\n-\t  s << \".param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_ar0\";\n-\t  i++;\n-\t}\n-      while (args != NULL_TREE)\n-\t{\n-\t  tree type = args_from_decl ? TREE_TYPE (args) : TREE_VALUE (args);\n-\t  machine_mode mode = TYPE_MODE (type);\n+  /* We get:\n+     NULL in TYPE_ARG_TYPES, for old-style functions\n+     NULL in DECL_ARGUMENTS, for builtin functions without another\n+       declaration.\n+     So we have to pick the best one we have.  */\n+  tree args = TYPE_ARG_TYPES (fntype);\n+  bool null_type_args = !args;\n+  if (null_type_args)\n+    args = DECL_ARGUMENTS (decl);\n \n-\t  if (mode != VOIDmode)\n-\t    i = write_one_arg (s, type, i, mode,\n-\t\t\t       TYPE_ARG_TYPES (fntype) == 0);\n-\t  args = TREE_CHAIN (args);\n-\t}\n-      if (stdarg_p (fntype))\n-\t{\n-\t  gcc_assert (i > 0);\n-\t  s << \", .param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_argp\";\n-\t}\n-      if (DECL_STATIC_CHAIN (decl))\n-\t{\n-\t  if (i)\n-\t    s << \", \";\n-\t  s << \".reg.u\" << GET_MODE_BITSIZE (Pmode)\n-\t    << reg_names [STATIC_CHAIN_REGNUM];\n-\t}\n-      if (!i && is_main)\n-\ts << \".param.u32 %argc, .param.u\" << GET_MODE_BITSIZE (Pmode)\n-\t  << \" %argv\";\n-      s << \")\";\n+  for (; args; args = TREE_CHAIN (args))\n+    {\n+      tree type = null_type_args ? TREE_TYPE (args) : TREE_VALUE (args);\n+      machine_mode mode = TYPE_MODE (type);\n+\n+      if (mode == VOIDmode)\n+\tbreak;\n+      i = write_one_arg (s, sep, i, type, mode, null_type_args);\n+      sep = \", \";\n     }\n-}\n \n-/* Write a .func or .kernel declaration (not a definition) along with\n-   a helper comment for use by ld.  S is the stream to write to, DECL\n-   the decl for the function with name NAME.  */\n+  if (stdarg_p (fntype))\n+    {\n+      s << sep << \".param.u\" << GET_MODE_BITSIZE (Pmode) << \" %in_argp\";\n+      i++;\n+      sep = \", \";\n+    }\n \n-static void\n-write_function_decl_and_comment (std::stringstream &s, const char *name, const_tree decl)\n-{\n-  s << \"\\n// BEGIN\";\n-  if (TREE_PUBLIC (decl))\n-    s << \" GLOBAL\";\n-  s << \" FUNCTION DECL: \";\n-  if (name[0] == '*')\n-    s << (name + 1);\n-  else\n-    s << name;\n-  s << \"\\n\";\n-  nvptx_write_function_decl (s, name, decl);\n-  s << \";\\n\";\n+  if (DECL_STATIC_CHAIN (decl))\n+    {\n+      s << sep << \".reg.u\" << GET_MODE_BITSIZE (Pmode)\n+\t<< reg_names [STATIC_CHAIN_REGNUM];\n+      i++;\n+      sep = \", \";\n+    }\n+\n+  if (!i && strcmp (name, \"main\") == 0)\n+    {\n+      s << sep\n+\t<< \".param.u32 %argc, .param.u\" << GET_MODE_BITSIZE (Pmode)\n+\t<< \" %argv\";\n+      i++;\n+      sep = \", \";\n+    }\n+\n+  if (i)\n+    s << \")\";\n+\n+  s << (is_defn ? \"\\n\" : \";\\n\");\n+\n+  return name;\n }\n \n /* Construct a function declaration from a call insn.  This can be\n@@ -476,8 +489,8 @@ write_function_decl_and_comment (std::stringstream &s, const char *name, const_t\n    generated by emit_library_call for which no decl exists.  */\n \n static void\n-write_func_decl_from_insn (std::stringstream &s, const char *name,\n-\t\t\t   rtx result, rtx pat)\n+write_fn_proto_from_insn (std::stringstream &s, const char *name,\n+\t\t\t  rtx result, rtx pat)\n {\n   if (!name)\n     {\n@@ -486,6 +499,7 @@ write_func_decl_from_insn (std::stringstream &s, const char *name,\n     }\n   else\n     {\n+      name = nvptx_name_replacement (name);\n       s << \"\\n// BEGIN GLOBAL FUNCTION DECL: \" << name << \"\\n\";\n       s << \"\\t.extern .func \";\n     }\n@@ -519,24 +533,6 @@ write_func_decl_from_insn (std::stringstream &s, const char *name,\n   s << \";\\n\";\n }\n \n-/* Check NAME for special function names and redirect them by returning a\n-   replacement.  This applies to malloc, free and realloc, for which we\n-   want to use libgcc wrappers, and call, which triggers a bug in ptxas.  */\n-\n-static const char *\n-nvptx_name_replacement (const char *name)\n-{\n-  if (strcmp (name, \"call\") == 0)\n-    return \"__nvptx_call\";\n-  if (strcmp (name, \"malloc\") == 0)\n-    return \"__nvptx_malloc\";\n-  if (strcmp (name, \"free\") == 0)\n-    return \"__nvptx_free\";\n-  if (strcmp (name, \"realloc\") == 0)\n-    return \"__nvptx_realloc\";\n-  return name;\n-}\n-\n /* DECL is an external FUNCTION_DECL, make sure its in the fndecl hash\n    table and and write a ptx prototype.  These are emitted at end of\n    compilation.  */\n@@ -549,8 +545,7 @@ nvptx_record_fndecl (tree decl)\n     {\n       *slot = decl;\n       const char *name = get_fnname_from_decl (decl);\n-      name = nvptx_name_replacement (name);\n-      write_function_decl_and_comment (func_decls, name, decl);\n+      write_fn_proto (func_decls, false, name, decl);\n     }\n }\n \n@@ -567,8 +562,7 @@ nvptx_record_libfunc (rtx callee, rtx retval, rtx pat)\n       *slot = callee;\n \n       const char *name = XSTR (callee, 0);\n-      name = nvptx_name_replacement (name);\n-      write_func_decl_from_insn (func_decls, name, retval, pat);\n+      write_fn_proto_from_insn (func_decls, name, retval, pat);\n     }\n }\n \n@@ -625,29 +619,13 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   tree result_type = TREE_TYPE (fntype);\n   int argno  = 0;\n \n-  name = nvptx_name_replacement (name);\n-\n   std::stringstream s;\n-  write_function_decl_and_comment (s, name, decl);\n-  s << \"// BEGIN\";\n-  if (TREE_PUBLIC (decl))\n-    s << \" GLOBAL\";\n-  s << \" FUNCTION DEF: \";\n-\n-  if (name[0] == '*')\n-    s << (name + 1);\n-  else\n-    s << name;\n-  s << \"\\n\";\n-\n-  nvptx_write_function_decl (s, name, decl);\n+  write_fn_proto (s, true, name, decl);\n   fprintf (file, \"%s\", s.str().c_str());\n+  fprintf (file, \"{\\n\");\n \n   bool return_in_mem = (TYPE_MODE (result_type) != VOIDmode\n \t\t\t&& !RETURN_IN_REG_P (TYPE_MODE (result_type)));\n-\n-  fprintf (file, \"\\n{\\n\");\n-\n   if (return_in_mem)\n     {\n       fprintf (file, \"\\t.reg.u%d %%ar%d;\\n\", GET_MODE_BITSIZE (Pmode), argno);\n@@ -1794,7 +1772,7 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n       labelno++;\n       ASM_OUTPUT_LABEL (asm_out_file, buf);\n       std::stringstream s;\n-      write_func_decl_from_insn (s, NULL, result, pat);\n+      write_fn_proto_from_insn (s, NULL, result, pat);\n       fputs (s.str().c_str(), asm_out_file);\n     }\n "}]}