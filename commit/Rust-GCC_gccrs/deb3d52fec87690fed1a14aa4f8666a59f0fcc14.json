{"sha": "deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGViM2Q1MmZlYzg3NjkwZmVkMWExNGFhNGY4NjY2YTU5ZjBmY2MxNA==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2004-06-21T16:52:14Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2004-06-21T16:52:14Z"}, "message": "ObjectOutputStream.java: Add DEBUG statements everywhere.\n\n2004-06-21  Andrew Haley  <aph@redhat.com>\n\n\t* java/io/ObjectOutputStream.java: Add DEBUG statements\n\teverywhere.\n\t(dumpElementln): New method.\n\t(depth): New field.\n\t* java/io/ObjectInputStream.java\n\t(currentClassLoader): Make native.\n\t(callersClassLoader): New field.\n\t(depth): New field.\n\t(readObject): ENDBLOCKDATA is generated if the class has a write\n\tmethod, not if it has a read method.\n\t(readObject): Save and restore this.currentObject and\n\tthis.currentObjectStreamClass around calls to callReadMethod().\n\t* java/io/natObjectInputStream.cc (getCallersClassLoader): New\n\tmethod.\n\nFrom-SVN: r83440", "tree": {"sha": "3a45653fc7061bc610f982b563c34279fc5ae046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a45653fc7061bc610f982b563c34279fc5ae046"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "413ed876c51b0b85661e938b1914dcd3821066f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/413ed876c51b0b85661e938b1914dcd3821066f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/413ed876c51b0b85661e938b1914dcd3821066f7"}], "stats": {"total": 200, "additions": 170, "deletions": 30}, "files": [{"sha": "a08f217de681103cee846c959064e18794e19034", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "patch": "@@ -1,3 +1,20 @@\n+2004-06-21  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/io/ObjectOutputStream.java: Add DEBUG statements\n+\teverywhere.\n+\t(dumpElementln): New method.\n+\t(depth): New field.\n+\t* java/io/ObjectInputStream.java\n+\t(currentClassLoader): Make native.\n+\t(callersClassLoader): New field.\n+\t(depth): New field.\n+\t(readObject): ENDBLOCKDATA is generated if the class has a write\n+\tmethod, not if it has a read method.\n+\t(readObject): Save and restore this.currentObject and\n+\tthis.currentObjectStreamClass around calls to callReadMethod().\n+\t* java/io/natObjectInputStream.cc (getCallersClassLoader): New\n+\tmethod.\n+\n 2004-06-18  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* testsuite/libjava.jni/jni.exp (gcj_jni_test_one): Add lgcc_s for"}, {"sha": "292f841a65795377a9acf24f8e81e00d3def36ce", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "patch": "@@ -38,20 +38,24 @@\n \n package java.io;\n \n-import gnu.classpath.Configuration;\n-import gnu.java.io.ObjectIdentityWrapper;\n-\n import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Proxy;\n+import java.security.PrivilegedAction;\n+import java.security.AccessController;\n import java.util.Arrays;\n import java.util.Hashtable;\n import java.util.Vector;\n \n \n+import gnu.java.io.ObjectIdentityWrapper;\n+import gnu.java.lang.reflect.TypeSignature;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import gnu.classpath.Configuration;\n+\n public class ObjectInputStream extends InputStream\n   implements ObjectInput, ObjectStreamConstants\n {\n@@ -120,6 +124,15 @@ else if (dump == true && (val == null || val.equals(\"\")))\n    */\n   public final Object readObject() throws ClassNotFoundException, IOException\n   {\n+      if (callersClassLoader == null)\n+\t{\n+\t  callersClassLoader = getCallersClassLoader ();\n+\t  if (Configuration.DEBUG && dump)\n+\t    {\n+\t      dumpElementln (\"CallersClassLoader = \" + callersClassLoader);\n+\t    }\n+\t}\n+\n     if (this.useSubclassMethod)\n       return readObjectOverride();\n \n@@ -134,6 +147,9 @@ public final Object readObject() throws ClassNotFoundException, IOException\n     this.isDeserializing = true;\n \n     byte marker = this.realInputStream.readByte();\n+\n+    depth += 2;\n+\n     if(dump) dumpElement(\"MARKER: 0x\" + Integer.toHexString(marker) + \" \");\n \n     try\n@@ -151,9 +167,9 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t  case TC_BLOCKDATALONG:\n \t    {\n \t      if (marker == TC_BLOCKDATALONG)\n-\t\tif(dump) dumpElementln(\"BLOCKDATALONG\");\n+\t\t{ if(dump) dumpElementln(\"BLOCKDATALONG\"); }\n \t      else\n-\t\tif(dump) dumpElementln(\"BLOCKDATA\");\n+\t\t{ if(dump) dumpElementln(\"BLOCKDATA\"); }\n \t      readNextBlock(marker);\n \t      throw new StreamCorruptedException(\"Unexpected blockData\");\n \t    }\n@@ -319,6 +335,9 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t      Object obj = newObject(clazz, osc.firstNonSerializableParent);\n \t      \n \t      int handle = assignNewHandle(obj);\n+\t      Object prevObject = this.currentObject;\n+\t      ObjectStreamClass prevObjectStreamClass = this.currentObjectStreamClass;\n+\t      \n \t      this.currentObject = obj;\n \t      ObjectStreamClass[] hierarchy =\n \t\tinputGetObjectStreamClasses(clazz);\n@@ -341,34 +360,42 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t\t      boolean oldmode = setBlockDataMode(true);\n \t\t      callReadMethod(readObjectMethod, this.currentObjectStreamClass.forClass(), obj);\n \t\t      setBlockDataMode(oldmode);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      readFields(obj, currentObjectStreamClass);\n+\t\t    }\n+\n+\t\t  if (this.currentObjectStreamClass.hasWriteMethod())\n+\t\t    {\n \t\t      if(dump) dumpElement(\"ENDBLOCKDATA? \");\n \t\t      try\n \t\t\t{\n-\t\t\t  // FIXME: XXX: This try block is to catch EOF which is\n-\t\t\t  // thrown for some objects.  That indicates a bug in the logic.\n+\t\t\t  // FIXME: XXX: This try block is to\n+\t\t\t  // catch EOF which is thrown for some\n+\t\t\t  // objects.  That indicates a bug in\n+\t\t\t  // the logic.\n+\n \t\t\t  if (this.realInputStream.readByte() != TC_ENDBLOCKDATA)\n \t\t\t    throw new IOException\n \t\t\t      (\"No end of block data seen for class with readObject (ObjectInputStream) method.\");\n \t\t\t  if(dump) dumpElementln(\"yes\");\n \t\t\t}\n-\t\t      catch (EOFException e)\n-\t\t\t{\n-\t\t\t  if(dump) dumpElementln(\"no, got EOFException\");\n-\t\t\t}\n+// \t\t      catch (EOFException e)\n+// \t\t\t{\n+// \t\t\t  if(dump) dumpElementln(\"no, got EOFException\");\n+// \t\t\t}\n \t\t      catch (IOException e)\n \t\t\t{\n \t\t\t  if(dump) dumpElementln(\"no, got IOException\");\n \t\t\t}\n \t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      readFields(obj, currentObjectStreamClass);\n-\t\t    }\n \t\t}\n \n-\t      this.currentObject = null;\n-\t      this.currentObjectStreamClass = null;\n+\t      this.currentObject = prevObject;\n+\t      this.currentObjectStreamClass = prevObjectStreamClass;\n \t      ret_val = processResolution(osc, obj, handle);\n+\t\t  \n \t      break;\n \t    }\n \n@@ -397,6 +424,8 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t\n \tthis.isDeserializing = was_deserializing;\n \t\n+\tdepth -= 2;\n+\t\n \tif (! was_deserializing)\n \t  {\n \t    if (validators.size() > 0)\n@@ -710,7 +739,7 @@ public void registerValidation(ObjectInputValidation validator,\n   protected Class resolveClass(ObjectStreamClass osc)\n     throws ClassNotFoundException, IOException\n   {\n-    return Class.forName(osc.getName(), true, currentLoader());\n+    return Class.forName(osc.getName(), true, callersClassLoader);\n   }\n \n   /**\n@@ -1802,11 +1831,9 @@ private void invokeValidators() throws InvalidObjectException\n    * @param sm SecurityManager instance which should be called.\n    * @return The current class loader in the calling stack.\n    */\n-  private static ClassLoader currentClassLoader (SecurityManager sm)\n-  {\n-    // FIXME: This is too simple.\n-    return ClassLoader.getSystemClassLoader ();\n-  }\n+  private static native ClassLoader currentClassLoader (SecurityManager sm);\n+  \n+  private native ClassLoader getCallersClassLoader();\n \n   private void callReadMethod (Method readObject, Class klass, Object obj) throws IOException\n   {\n@@ -1864,6 +1891,11 @@ private native Object allocateObject (Class clazz)\n \n   private static boolean dump = false && Configuration.DEBUG;\n \n+  private ClassLoader callersClassLoader;\n+\n+  // The nesting depth for debugging output\n+  private int depth = 0;\n+\n   private void dumpElement (String msg)\n   {\n     System.out.print(msg);\n@@ -1872,6 +1904,9 @@ private void dumpElement (String msg)\n   private void dumpElementln (String msg)\n   {\n     System.out.println(msg);\n+    for (int i = 0; i < depth; i++)\n+      System.out.print (\" \");\n+    System.out.print (Thread.currentThread() + \": \");\n   }\n \n   static"}, {"sha": "cc77976b492e040cf574644e49bf4f45c8fad9fd", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "patch": "@@ -144,6 +144,13 @@ public ObjectOutputStream (OutputStream out) throws IOException\n     protocolVersion = defaultProtocolVersion;\n     useSubclassMethod = false;\n     writeStreamHeader();\n+\n+    if (Configuration.DEBUG)\n+      {\n+\tString val = System.getProperty(\"gcj.dumpobjects\");\n+\tif (val != null && !val.equals(\"\"))\n+\t  dump = true;\n+      }\n   }\n \n   /**\n@@ -172,10 +179,18 @@ public final void writeObject(Object obj) throws IOException\n   {\n     if (useSubclassMethod)\n       {\n+\tif (dump)\n+\t  dumpElementln (\"WRITE OVERRIDE: \" + obj);\n+\t  \n \twriteObjectOverride(obj);\n \treturn;\n       }\n \n+    if (dump)\n+      dumpElementln (\"WRITE: \" + obj);\n+    \n+    depth += 2;    \n+\n     boolean was_serializing = isSerializing;\n     boolean old_mode = setBlockDataMode(false);\n     try\n@@ -318,6 +333,8 @@ public final void writeObject(Object obj) throws IOException\n \n \t    if (obj instanceof Serializable)\n \t      {\n+\t\tObject prevObject = this.currentObject;\n+\t\tObjectStreamClass prevObjectStreamClass = this.currentObjectStreamClass;\n \t\tcurrentObject = obj;\n \t\tObjectStreamClass[] hierarchy =\n \t\t  ObjectStreamClass.getObjectStreamClasses(clazz);\n@@ -329,17 +346,25 @@ public final void writeObject(Object obj) throws IOException\n \t\t    fieldsAlreadyWritten = false;\n \t\t    if (currentObjectStreamClass.hasWriteMethod())\n \t\t      {\n+\t\t\tif (dump)\n+\t\t\t  dumpElementln (\"WRITE METHOD CALLED FOR: \" + obj);\n \t\t\tsetBlockDataMode(true);\n \t\t\tcallWriteMethod(obj, currentObjectStreamClass);\n \t\t\tsetBlockDataMode(false);\n \t\t\trealOutput.writeByte(TC_ENDBLOCKDATA);\n+\t\t\tif (dump)\n+\t\t\t  dumpElementln (\"WRITE ENDBLOCKDATA FOR: \" + obj);\n \t\t      }\n \t\t    else\n+\t\t      {\n+\t\t\tif (dump)\n+\t\t\t  dumpElementln (\"WRITE FIELDS CALLED FOR: \" + obj);\n \t\t      writeFields(obj, currentObjectStreamClass);\n \t\t  }\n+\t\t  }\n \n-\t\tcurrentObject = null;\n-\t\tcurrentObjectStreamClass = null;\n+\t\tthis.currentObject = prevObject;\n+\t\tthis.currentObjectStreamClass = prevObjectStreamClass;\n \t\tcurrentPutField = null;\n \t\tbreak;\n \t      }\n@@ -360,12 +385,22 @@ public final void writeObject(Object obj) throws IOException\n \tsetBlockDataMode(false);\n \ttry\n \t  {\n+\t    if (Configuration.DEBUG)\n+\t      {\n+\t\te.printStackTrace(System.out);\n+\t      }\n \t    writeObject(e);\n \t  }\n \tcatch (IOException ioe)\n \t  {\n-\t    throw new StreamCorruptedException\n-\t      (\"Exception \" + ioe + \" thrown while exception was being written to stream.\");\n+\t    StreamCorruptedException ex = \n+\t      new StreamCorruptedException\n+\t      (ioe + \" thrown while exception was being written to stream.\");\n+\t    if (Configuration.DEBUG)\n+\t      {\n+\t\tex.printStackTrace(System.out);\n+\t      }\n+\t    throw ex;\n \t  }\n \n \treset (true);\n@@ -375,6 +410,10 @@ public final void writeObject(Object obj) throws IOException\n       {\n \tisSerializing = was_serializing;\n \tsetBlockDataMode(old_mode);\n+\tdepth -= 2;\n+\n+\tif (dump)\n+\t  dumpElementln (\"END: \" + obj);\n       }\n   }\n \n@@ -1171,6 +1210,9 @@ private void writeFields(Object obj, ObjectStreamClass osc)\n \tfield_name = fields[i].getName();\n \ttype = fields[i].getType();\n \n+\tif (dump)\n+\t  dumpElementln (\"WRITE FIELD: \" + field_name + \" type=\" + type);\n+\n \tif (type == Boolean.TYPE)\n \t  realOutput.writeBoolean(getBooleanField(obj, osc.forClass(), field_name));\n \telse if (type == Byte.TYPE)\n@@ -1512,6 +1554,14 @@ public Object run()\n     return m;\n   }\n \n+  private void dumpElementln (String msg)\n+  {\n+    for (int i = 0; i < depth; i++)\n+      System.out.print (\" \");\n+    System.out.print (Thread.currentThread() + \": \");\n+    System.out.println(msg);\n+  }\n+\n   // this value comes from 1.2 spec, but is used in 1.1 as well\n   private final static int BUFFER_SIZE = 1024;\n \n@@ -1534,6 +1584,12 @@ public Object run()\n   private int protocolVersion;\n   private boolean useSubclassMethod;\n \n+  // The nesting depth for debugging output\n+  private int depth = 0;\n+\n+  // Set if we're generating debugging dumps\n+  private boolean dump = false;\n+\n   static\n   {\n     if (Configuration.INIT_LOAD_LIBRARY)"}, {"sha": "9da4910aa068495ee175f8c80692c683d2a94575", "filename": "libjava/java/io/natObjectInputStream.cc", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deb3d52fec87690fed1a14aa4f8666a59f0fcc14/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc?ref=deb3d52fec87690fed1a14aa4f8666a59f0fcc14", "patch": "@@ -19,6 +19,8 @@ details.  */\n #include <java/lang/Class.h>\n #include <java/lang/reflect/Modifier.h>\n #include <java/lang/reflect/Method.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/SecurityManager.h>\n \n #ifdef DEBUG\n #include <java/lang/System.h>\n@@ -69,3 +71,33 @@ java::io::ObjectInputStream::callConstructor (jclass klass, jobject obj)\n \t\t\t\t+ m->offset);\n   _Jv_CallAnyMethodA (obj, JvPrimClass (void), meth, false, arg_types, NULL);\n }\n+\n+java::lang::ClassLoader* \n+java::io::ObjectInputStream::getCallersClassLoader ()\n+{\n+  java::lang::ClassLoader *loader = NULL;\n+  gnu::gcj::runtime::StackTrace *t \n+    = new gnu::gcj::runtime::StackTrace(4);\n+  java::lang::Class *klass = NULL;\n+  try\n+    {\n+      for (int i = 2; !klass; i++)\n+\t{\n+\t  klass = t->classAt (i);\n+\t}\n+      loader = klass->getClassLoaderInternal();\n+    }\n+  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n+    {\n+      // FIXME: RuntimeError\n+    }\n+\n+  return loader;\n+}\n+\n+java::lang::ClassLoader*\n+java::io::ObjectInputStream::currentClassLoader (::java::lang::SecurityManager *sm)\n+{\n+  return sm->currentClassLoader ();\n+}\n+"}]}