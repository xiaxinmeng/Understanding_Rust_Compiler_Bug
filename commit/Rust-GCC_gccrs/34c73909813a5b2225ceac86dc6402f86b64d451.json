{"sha": "34c73909813a5b2225ceac86dc6402f86b64d451", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRjNzM5MDk4MTNhNWIyMjI1Y2VhYzg2ZGM2NDAyZjg2YjY0ZDQ1MQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-09-24T09:59:41Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-09-24T09:59:41Z"}, "message": "expr.c (store_constructor): When initializing a field that is smaller than a word...\n\n\t* expr.c (store_constructor): When initializing a field that is smaller\n\tthan a word, at the start of a word, try to widen it to a full word.\n\t* cse.c (cse_insn): When we are about to change a register,\n\tremove any invalid references to it.\n\t(remove_invalid_subreg_refs): New function.\n\t(mention_regs): Special treatment for SUBREGs.\n\t(insert_regs): Don't strip SUBREG for call to mention_regs.\n\tCheck if reg_tick needs to be bumped up before that call.\n\t(lookup_as_function): Try to match known word_mode constants when\n\tlooking for a norrower constant.\n\t(canon_hash): Special treatment for SUBREGs.\n\nFrom-SVN: r22567", "tree": {"sha": "7abc19d3b6986f83e3eeb1c3ac8b63037020a7c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7abc19d3b6986f83e3eeb1c3ac8b63037020a7c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34c73909813a5b2225ceac86dc6402f86b64d451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c73909813a5b2225ceac86dc6402f86b64d451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34c73909813a5b2225ceac86dc6402f86b64d451", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34c73909813a5b2225ceac86dc6402f86b64d451/comments", "author": null, "committer": null, "parents": [{"sha": "c5a951a851895f7184200911e63b12f884a01ded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a951a851895f7184200911e63b12f884a01ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a951a851895f7184200911e63b12f884a01ded"}], "stats": {"total": 182, "additions": 178, "deletions": 4}, "files": [{"sha": "e178f528dbc96347c663b243822030d6290e7116", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c73909813a5b2225ceac86dc6402f86b64d451/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c73909813a5b2225ceac86dc6402f86b64d451/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34c73909813a5b2225ceac86dc6402f86b64d451", "patch": "@@ -1,3 +1,19 @@\n+Thu Sep 24 17:45:55 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* expr.c (store_constructor): When initializing a field that is smaller\n+\tthan a word, at the start of a word, try to widen it to a full word.\n+\n+\t* cse.c (cse_insn): When we are about to change a register,\n+\tremove any invalid references to it.\n+\n+\t(remove_invalid_subreg_refs): New function.\n+\t(mention_regs): Special treatment for SUBREGs.\n+\t(insert_regs): Don't strip SUBREG for call to mention_regs.\n+\tCheck if reg_tick needs to be bumped up before that call.\n+\t(lookup_as_function): Try to match known word_mode constants when\n+\tlooking for a norrower constant.\n+\t(canon_hash): Special treatment for SUBREGs.\n+\n Thu Sep 24 01:35:34 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \n \t* config/sparc/sol2-sld-64.h (TRANSFER_FROM_TRAMPOLINE): Define."}, {"sha": "ddb164d9629b7c3bd288a7c8b710398e31941bf6", "filename": "gcc/cse.c", "status": "modified", "additions": 131, "deletions": 3, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c73909813a5b2225ceac86dc6402f86b64d451/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c73909813a5b2225ceac86dc6402f86b64d451/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=34c73909813a5b2225ceac86dc6402f86b64d451", "patch": "@@ -626,6 +626,7 @@ static void merge_equiv_classes PROTO((struct table_elt *,\n static void invalidate\t\tPROTO((rtx, enum machine_mode));\n static int cse_rtx_varies_p\tPROTO((rtx));\n static void remove_invalid_refs\tPROTO((int));\n+static void remove_invalid_subreg_refs\tPROTO((int, int, enum machine_mode));\n static void rehash_using_reg\tPROTO((rtx));\n static void invalidate_memory\tPROTO((void));\n static void invalidate_for_call\tPROTO((void));\n@@ -980,6 +981,30 @@ mention_regs (x)\n       return 0;\n     }\n \n+  /* If this is a SUBREG, we don't want to discard other SUBREGs of the same\n+     pseudo if they don't use overlapping words.  We handle only pseudos\n+     here for simplicity.  */\n+  if (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n+      && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      int i = REGNO (SUBREG_REG (x));\n+\n+      if (reg_in_table[i] >= 0 && reg_in_table[i] != reg_tick[i])\n+\t{\n+\t  /* If reg_tick has been incremented more than once since\n+\t     reg_in_table was last set, that means that the entire\n+\t     register has been set before, so discard anything memorized\n+\t     for the entrire register, including all SUBREG expressions.  */\n+\t  if (reg_in_table[i] != reg_tick[i] - 1)\n+\t    remove_invalid_refs (i);\n+\t  else\n+\t    remove_invalid_subreg_refs (i, SUBREG_WORD (x), GET_MODE (x));\n+\t}\n+\n+      reg_in_table[i] = reg_tick[i];\n+      return 0;\n+    }\n+\n   /* If X is a comparison or a COMPARE and either operand is a register\n      that does not have a quantity, give it one.  This is so that a later\n      call to record_jump_equiv won't cause X to be assigned a different\n@@ -1077,8 +1102,19 @@ insert_regs (x, classp, modified)\n   else if (GET_CODE (x) == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n \t   && ! REGNO_QTY_VALID_P (REGNO (SUBREG_REG (x))))\n     {\n+      int regno = REGNO (SUBREG_REG (x));\n+\n       insert_regs (SUBREG_REG (x), NULL_PTR, 0);\n-      mention_regs (SUBREG_REG (x));\n+      /* Mention_regs checks if REG_TICK is exactly one larger than\n+\t REG_IN_TABLE to find out if there was only a single preceding\n+\t invalidation - for the SUBREG - or another one, which would be\n+\t for the full register.  Since we don't invalidate the SUBREG\n+\t here first, we might have to bump up REG_TICK so that mention_regs\n+\t will do the right thing.  */\n+      if (reg_in_table[regno] >= 0\n+\t  && reg_tick[regno] == reg_in_table[regno] + 1)\n+\treg_tick++;\n+      mention_regs (x);\n       return 1;\n     }\n   else\n@@ -1254,6 +1290,17 @@ lookup_as_function (x, code)\n {\n   register struct table_elt *p = lookup (x, safe_hash (x, VOIDmode) % NBUCKETS,\n \t\t\t\t\t GET_MODE (x));\n+  /* If we are looking for a CONST_INT, the mode doesn't really matter, as\n+     long as we are narrowing.  So if we looked in vain for a mode narrower\n+     than word_mode before, look for word_mode now.  */\n+  if (p == 0 && code == CONST_INT\n+      && GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (word_mode))\n+    {\n+      x = copy_rtx (x);\n+      PUT_MODE (x, word_mode);\n+      p = lookup (x, safe_hash (x, VOIDmode) % NBUCKETS, word_mode);\n+    }\n+\n   if (p == 0)\n     return 0;\n \n@@ -1684,6 +1731,37 @@ remove_invalid_refs (regno)\n \t  remove_from_table (p, i);\n       }\n }\n+\n+/* Likewise for a subreg with subreg_reg WORD and mode MODE.  */\n+static void\n+remove_invalid_subreg_refs (regno, word, mode)\n+     int regno;\n+     int word;\n+     enum machine_mode mode;\n+{\n+  register int i;\n+  register struct table_elt *p, *next;\n+  int end = word + (GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD;\n+\n+  for (i = 0; i < NBUCKETS; i++)\n+    for (p = table[i]; p; p = next)\n+      {\n+\trtx exp;\n+\tnext = p->next_same_hash;\n+\t\n+\texp = p->exp;\n+\tif (GET_CODE (p->exp) != REG\n+\t    && (GET_CODE (exp) != SUBREG\n+\t\t|| GET_CODE (SUBREG_REG (exp)) != REG\n+\t\t|| REGNO (SUBREG_REG (exp)) != regno\n+\t\t|| (((SUBREG_WORD (exp)\n+\t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1) / UNITS_PER_WORD)\n+\t\t     >= word)\n+\t\t && SUBREG_WORD (exp) <= end))\n+\t    && refers_to_regno_p (regno, regno + 1, p->exp, NULL_PTR))\n+\t  remove_from_table (p, i);\n+      }\n+}\n \f\n /* Recompute the hash codes of any valid entries in the hash table that\n    reference X, if X is a register, or SUBREG_REG (X) if X is a SUBREG.\n@@ -1930,6 +2008,20 @@ canon_hash (x, mode)\n \treturn hash;\n       }\n \n+    /* We handle SUBREG of a REG specially because the underlying\n+       reg changes its hash value with every value change; we don't\n+       want to have to forget unrelated subregs when one subreg changes.  */\n+    case SUBREG:\n+      {\n+\tif (GET_CODE (SUBREG_REG (x)) == REG)\n+\t  {\n+\t    hash += (((unsigned) SUBREG << 7)\n+\t\t     + REGNO (SUBREG_REG (x)) + SUBREG_WORD (x));\n+\t    return hash;\n+\t  }\n+\tbreak;\n+      }\n+\n     case CONST_INT:\n       {\n \tunsigned HOST_WIDE_INT tem = INTVAL (x);\n@@ -7409,8 +7501,44 @@ cse_insn (insn, libcall_insn)\n      we are going to hash the SET_DEST values unconditionally.  */\n \n   for (i = 0; i < n_sets; i++)\n-    if (sets[i].rtl && GET_CODE (SET_DEST (sets[i].rtl)) != REG)\n-      mention_regs (SET_DEST (sets[i].rtl));\n+    {\n+      if (sets[i].rtl)\n+\t{\n+\t  rtx x = SET_DEST (sets[i].rtl);\n+\n+\t  if (GET_CODE (x) != REG)\n+\t    mention_regs (x);\n+\t  else\n+\t    {\n+\t      /* We used to rely on all references to a register becoming\n+\t\t inaccessible when a register changes to a new quantity,\n+\t\t since that changes the hash code.  However, that is not\n+\t\t safe, since after NBUCKETS new quantities we get a\n+\t\t hash 'collision' of a register with its own invalid\n+\t\t entries.  And since SUBREGs have been changed not to\n+\t\t change their hash code with the hash code of the register,\n+\t\t it wouldn't work any longer at all.  So we have to check\n+\t\t for any invalid references lying around now.\n+\t\t This code is similar to the REG case in mention_regs,\n+\t\t but it knows that reg_tick has been incremented, and\n+\t\t it leaves reg_in_table as -1 .  */\n+\t      register int regno = REGNO (x);\n+\t      register int endregno\n+\t\t= regno + (regno >= FIRST_PSEUDO_REGISTER ? 1\n+\t\t\t   : HARD_REGNO_NREGS (regno, GET_MODE (x)));\n+\t      int i;\n+\n+\t      for (i = regno; i < endregno; i++)\n+\t\t{\n+\t\t  if (reg_in_table[i] >= 0)\n+\t\t    {\n+\t\t      remove_invalid_refs (i);\n+\t\t      reg_in_table[i] = -1;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   /* We may have just removed some of the src_elt's from the hash table.\n      So replace each one with the current head of the same class.  */"}, {"sha": "2c82924d2208e2be38883821119efd03e3b293bb", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34c73909813a5b2225ceac86dc6402f86b64d451/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34c73909813a5b2225ceac86dc6402f86b64d451/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=34c73909813a5b2225ceac86dc6402f86b64d451", "patch": "@@ -3819,6 +3819,7 @@ store_constructor (exp, target, cleared)\n      int cleared;\n {\n   tree type = TREE_TYPE (exp);\n+  rtx exp_size = expr_size (exp);\n \n   /* We know our target cannot conflict, since safe_from_p has been called.  */\n #if 0\n@@ -3880,6 +3881,7 @@ store_constructor (exp, target, cleared)\n       for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n \t{\n \t  register tree field = TREE_PURPOSE (elt);\n+\t  tree value = TREE_VALUE (elt);\n \t  register enum machine_mode mode;\n \t  int bitsize;\n \t  int bitpos = 0;\n@@ -3951,8 +3953,36 @@ store_constructor (exp, target, cleared)\n \t      RTX_UNCHANGING_P (to_rtx) = 1;\n \t    }\n \n+#ifdef WORD_REGISTER_OPERATIONS\n+\t  /* If this initializes a field that is smaller than a word, at the\n+\t     start of a word, try to widen it to a full word.\n+\t     This special case allows us to output C++ member function\n+\t     initializations in a form that the optimizers can understand.  */\n+\t  if (constant\n+\t      && GET_CODE (target) == REG\n+\t      && bitsize < BITS_PER_WORD\n+\t      && bitpos % BITS_PER_WORD == 0\n+\t      && GET_MODE_CLASS (mode) == MODE_INT\n+\t      && TREE_CODE (value) == INTEGER_CST\n+\t      && GET_CODE (exp_size) == CONST_INT\n+\t      && bitpos + BITS_PER_WORD <= INTVAL (exp_size) * BITS_PER_UNIT)\n+\t    {\n+\t      tree type = TREE_TYPE (value);\n+\t      if (TYPE_PRECISION (type) < BITS_PER_WORD)\n+\t\t{\n+\t\t  type = type_for_size (BITS_PER_WORD, TREE_UNSIGNED (type));\n+\t\t  value = convert (type, value);\n+\t\t}\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\tvalue\n+\t\t  = fold (build (LSHIFT_EXPR, type, value,\n+\t\t\t\t build_int_2 (BITS_PER_WORD - bitsize, 0)));\n+\t      bitsize = BITS_PER_WORD;\n+\t      mode = word_mode;\n+\t    }\n+#endif\n \t  store_constructor_field (to_rtx, bitsize, bitpos,\n-\t\t\t\t   mode, TREE_VALUE (elt), type, cleared);\n+\t\t\t\t   mode, value, type, cleared);\n \t}\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)"}]}