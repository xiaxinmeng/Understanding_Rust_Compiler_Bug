{"sha": "507148866c2116c2d15dadc4b1609eb21ce88a45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3MTQ4ODY2YzIxMTZjMmQxNWRhZGM0YjE2MDllYjIxY2U4OGE0NQ==", "commit": {"author": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2004-11-15T20:02:08Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2004-11-15T20:02:08Z"}, "message": "004-11-15  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\tImport/Merge the X.509 certificate code from Classpath.\n\n\t* Makefile.am: Add imported files.\n\t* Makefile.in: Regenerate.\n\n\t2004-11-07  Casey Marshall  <csm@gnu.org>\n\n\t* gnu/java/security/provider/Gnu.java(<init>): Add entries in a\n\tpriviliged action. Add new algorithms.\n\t* gnu/java/security/provider/X509CertificateFactory.java\n\t(engineGenerateCertificate): Chain exceptions.\n\t(engineGenerateCertificates): Likewise.\n\t(engineGenerateCRL): Likewise.\n\t(engineGenerateCRLs): Likewise.\n\t(engineGenerateCertPath): New methods.\n\t(generateCert): Throw exception if 'inStream' is null.\n\t(generateCRL): Likewise.\n\t* gnu/java/security/x509/X500DistinguishedName.java: Replaced with\n\tversion from GNU Crypto CVS.\n\t* gnu/java/security/x509/X509CRL.java: Likewise.\n\t* gnu/java/security/x509/X509CRLEntry.java: Likewise.\n\t* gnu/java/security/x509/X509Certificate.java: Likewise.\n\t* java/security/cert/TrustAnchor.java: Call 'toString' and not\n\ttoRFC2253.\n\t* gnu/java/security/provider/CollectionCertStoreImpl.java,\n\t* gnu/java/security/provider/EncodedKeyFactory.java,\n\t* gnu/java/security/provider/GnuDHPublicKey.java,\n\t* gnu/java/security/provider/GnuRSAPrivateKey.java,\n\t* gnu/java/security/provider/GnuRSAPublicKey.java,\n\t* gnu/java/security/provider/MD2withRSA.java,\n\t* gnu/java/security/provider/MD4withRSA.java,\n\t* gnu/java/security/provider/MD5withRSA.java,\n\t* gnu/java/security/provider/PKIXCertPathValidatorImpl.java,\n\t* gnu/java/security/provider/RSA.java,\n\t* gnu/java/security/provider/RSAKeyFactory.java,\n\t* gnu/java/security/provider/SHA1withRSA.java,\n\t* gnu/java/security/x509/GnuPKIExtension.java,\n\t* gnu/java/security/x509/PolicyNodeImpl.java,\n\t* gnu/java/security/x509/Util.java,\n\t* gnu/java/security/x509/X509CRLSelectorImpl.java,\n\t* gnu/java/security/x509/X509CertPath.java,\n\t* gnu/java/security/x509/X509CertSelectorImpl.java,\n\t* gnu/java/security/x509/ext/AuthorityKeyIdentifier.java,\n\t* gnu/java/security/x509/ext/BasicConstraints.java,\n\t* gnu/java/security/x509/ext/CRLNumber.java,\n\t* gnu/java/security/x509/ext/CertificatePolicies.java,\n\t* gnu/java/security/x509/ext/ExtendedKeyUsage.java,\n\t* gnu/java/security/x509/ext/Extension.java,\n\t* gnu/java/security/x509/ext/GeneralNames.java,\n\t* gnu/java/security/x509/ext/IssuerAlternativeNames.java,\n\t* gnu/java/security/x509/ext/KeyUsage.java,\n\t* gnu/java/security/x509/ext/PolicyConstraint.java,\n\t* gnu/java/security/x509/ext/PolicyMappings.java,\n\t* gnu/java/security/x509/ext/PrivateKeyUsagePeriod.java,\n\t* gnu/java/security/x509/ext/ReasonCode.java,\n\t* gnu/java/security/x509/ext/SubjectAlternativeNames.java,\n\t* gnu/java/security/x509/ext/SubjectKeyIdentifier.java: New files.\n\n\t2004-11-07  Casey Marshall  <csm@gnu.org>\n\n\t* gnu/java/security/x509/X509CRL.java:\n\tMissed import statements in previous checkin.\n\n\t2004-11-07  Casey Marshall  <csm@gnu.org>\n\n\t* gnu/java/security/x509/X509CertPath.java (parse): Fixed reference\n\tto 'X509CertificateImpl' from previous checkin.\n\nFrom-SVN: r90682", "tree": {"sha": "397eb5fe893a7d4cba478362f2a48f749834452d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/397eb5fe893a7d4cba478362f2a48f749834452d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/507148866c2116c2d15dadc4b1609eb21ce88a45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507148866c2116c2d15dadc4b1609eb21ce88a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/507148866c2116c2d15dadc4b1609eb21ce88a45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507148866c2116c2d15dadc4b1609eb21ce88a45/comments", "author": null, "committer": null, "parents": [{"sha": "fcb94d103b1e287f95bb7de1c582a25223529654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcb94d103b1e287f95bb7de1c582a25223529654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcb94d103b1e287f95bb7de1c582a25223529654"}], "stats": {"total": 7778, "additions": 6669, "deletions": 1109}, "files": [{"sha": "a9a492f33267ef91b18efbe2c6d5eaa34a109e43", "filename": "libjava/ChangeLog", "status": "modified", "additions": 76, "deletions": 6, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -1,3 +1,73 @@\n+2004-11-15  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\tImport/Merge the X.509 certificate code from Classpath.\n+\n+\t* Makefile.am: Add imported files.\n+\t* Makefile.in: Regenerate.\n+\n+\t2004-11-07  Casey Marshall  <csm@gnu.org>\n+\n+\t* gnu/java/security/provider/Gnu.java(<init>): Add entries in a\n+\tpriviliged action. Add new algorithms.\n+\t* gnu/java/security/provider/X509CertificateFactory.java\n+\t(engineGenerateCertificate): Chain exceptions.\n+\t(engineGenerateCertificates): Likewise.\n+\t(engineGenerateCRL): Likewise.\n+\t(engineGenerateCRLs): Likewise.\n+\t(engineGenerateCertPath): New methods.\n+\t(generateCert): Throw exception if 'inStream' is null.\n+\t(generateCRL): Likewise.\n+\t* gnu/java/security/x509/X500DistinguishedName.java: Replaced with\n+\tversion from GNU Crypto CVS.\n+\t* gnu/java/security/x509/X509CRL.java: Likewise.\n+\t* gnu/java/security/x509/X509CRLEntry.java: Likewise.\n+\t* gnu/java/security/x509/X509Certificate.java: Likewise.\n+\t* java/security/cert/TrustAnchor.java: Call 'toString' and not\n+\ttoRFC2253.\n+\t* gnu/java/security/provider/CollectionCertStoreImpl.java,\n+\t* gnu/java/security/provider/EncodedKeyFactory.java,\n+\t* gnu/java/security/provider/GnuDHPublicKey.java,\n+\t* gnu/java/security/provider/GnuRSAPrivateKey.java,\n+\t* gnu/java/security/provider/GnuRSAPublicKey.java,\n+\t* gnu/java/security/provider/MD2withRSA.java,\n+\t* gnu/java/security/provider/MD4withRSA.java,\n+\t* gnu/java/security/provider/MD5withRSA.java,\n+\t* gnu/java/security/provider/PKIXCertPathValidatorImpl.java,\n+\t* gnu/java/security/provider/RSA.java,\n+\t* gnu/java/security/provider/RSAKeyFactory.java,\n+\t* gnu/java/security/provider/SHA1withRSA.java,\n+\t* gnu/java/security/x509/GnuPKIExtension.java,\n+\t* gnu/java/security/x509/PolicyNodeImpl.java,\n+\t* gnu/java/security/x509/Util.java,\n+\t* gnu/java/security/x509/X509CRLSelectorImpl.java,\n+\t* gnu/java/security/x509/X509CertPath.java,\n+\t* gnu/java/security/x509/X509CertSelectorImpl.java,\n+\t* gnu/java/security/x509/ext/AuthorityKeyIdentifier.java,\n+\t* gnu/java/security/x509/ext/BasicConstraints.java,\n+\t* gnu/java/security/x509/ext/CRLNumber.java,\n+\t* gnu/java/security/x509/ext/CertificatePolicies.java,\n+\t* gnu/java/security/x509/ext/ExtendedKeyUsage.java,\n+\t* gnu/java/security/x509/ext/Extension.java,\n+\t* gnu/java/security/x509/ext/GeneralNames.java,\n+\t* gnu/java/security/x509/ext/IssuerAlternativeNames.java,\n+\t* gnu/java/security/x509/ext/KeyUsage.java,\n+\t* gnu/java/security/x509/ext/PolicyConstraint.java,\n+\t* gnu/java/security/x509/ext/PolicyMappings.java,\n+\t* gnu/java/security/x509/ext/PrivateKeyUsagePeriod.java,\n+\t* gnu/java/security/x509/ext/ReasonCode.java,\n+\t* gnu/java/security/x509/ext/SubjectAlternativeNames.java,\n+\t* gnu/java/security/x509/ext/SubjectKeyIdentifier.java: New files.\n+\n+\t2004-11-07  Casey Marshall  <csm@gnu.org>\n+\n+\t* gnu/java/security/x509/X509CRL.java:\n+\tMissed import statements in previous checkin.\n+\n+\t2004-11-07  Casey Marshall  <csm@gnu.org>\n+\n+\t* gnu/java/security/x509/X509CertPath.java (parse): Fixed reference\n+\tto 'X509CertificateImpl' from previous checkin.\n+\n 2004-11-12  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR other/14264\n@@ -11,12 +81,12 @@\n \t'F_RDLCK' for shared locks, 'F_WRLCK' for exclusive locks.\n \n 2004-11-11  Robert Schuster <thebohemian@gmx.net>\n-  \n-  \tFixed regression:\n-  \t* gnu/java/beans/IntrospectionIncubator.java:\n-  \t(addMethod): corrected classification of normal and property methods\n-  \t(capitalize): added documentation\n-  \t(DoubleKey): [class] added documentation\n+\n+\tFixed regression:\n+\t* gnu/java/beans/IntrospectionIncubator.java:\n+\t(addMethod): Corrected classification of normal and property methods.\n+\t(capitalize): Added documentation.\n+\t(DoubleKey): [class] Added documentation.\n \n 2004-11-09  Tom Tromey  <tromey@redhat.com>\n "}, {"sha": "9a439fada5a88b8708ee17430fd3d0dc285ef95f", "filename": "libjava/Makefile.am", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -2749,24 +2749,57 @@ gnu/java/security/der/DEREncodingException.java \\\n gnu/java/security/der/DERReader.java \\\n gnu/java/security/der/DERValue.java \\\n gnu/java/security/der/DERWriter.java \\\n+gnu/java/security/provider/CollectionCertStoreImpl.java \\\n gnu/java/security/provider/DSAKeyFactory.java \\\n gnu/java/security/provider/DSAKeyPairGenerator.java \\\n gnu/java/security/provider/DSAParameterGenerator.java \\\n gnu/java/security/provider/DSAParameters.java \\\n gnu/java/security/provider/DSASignature.java \\\n gnu/java/security/provider/DefaultPolicy.java \\\n+gnu/java/security/provider/EncodedKeyFactory.java \\\n gnu/java/security/provider/Gnu.java \\\n+gnu/java/security/provider/GnuDHPublicKey.java \\\n gnu/java/security/provider/GnuDSAPrivateKey.java \\\n gnu/java/security/provider/GnuDSAPublicKey.java \\\n+gnu/java/security/provider/GnuRSAPrivateKey.java \\\n+gnu/java/security/provider/GnuRSAPublicKey.java \\\n+gnu/java/security/provider/MD2withRSA.java \\\n+gnu/java/security/provider/MD4withRSA.java \\\n gnu/java/security/provider/MD5.java \\\n+gnu/java/security/provider/MD5withRSA.java \\\n+gnu/java/security/provider/PKIXCertPathValidatorImpl.java \\\n+gnu/java/security/provider/RSA.java \\\n+gnu/java/security/provider/RSAKeyFactory.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/security/provider/SHA1withRSA.java \\\n gnu/java/security/provider/X509CertificateFactory.java \\\n gnu/java/security/util/Prime.java \\\n+gnu/java/security/x509/GnuPKIExtension.java \\\n+gnu/java/security/x509/PolicyNodeImpl.java \\\n+gnu/java/security/x509/Util.java \\\n gnu/java/security/x509/X500DistinguishedName.java \\\n gnu/java/security/x509/X509CRL.java \\\n gnu/java/security/x509/X509CRLEntry.java \\\n+gnu/java/security/x509/X509CRLSelectorImpl.java \\\n gnu/java/security/x509/X509Certificate.java \\\n+gnu/java/security/x509/X509CertPath.java \\\n+gnu/java/security/x509/X509CertSelectorImpl.java \\\n+gnu/java/security/x509/ext/AuthorityKeyIdentifier.java \\\n+gnu/java/security/x509/ext/BasicConstraints.java \\\n+gnu/java/security/x509/ext/CRLNumber.java \\\n+gnu/java/security/x509/ext/CertificatePolicies.java \\\n+gnu/java/security/x509/ext/ExtendedKeyUsage.java \\\n+gnu/java/security/x509/ext/Extension.java \\\n+gnu/java/security/x509/ext/GeneralNames.java \\\n+gnu/java/security/x509/ext/IssuerAlternativeNames.java \\\n+gnu/java/security/x509/ext/KeyUsage.java \\\n+gnu/java/security/x509/ext/PolicyConstraint.java \\\n+gnu/java/security/x509/ext/PolicyMappings.java \\\n+gnu/java/security/x509/ext/PrivateKeyUsagePeriod.java \\\n+gnu/java/security/x509/ext/ReasonCode.java \\\n+gnu/java/security/x509/ext/SubjectAlternativeNames.java \\\n+gnu/java/security/x509/ext/SubjectKeyIdentifier.java \\\n gnu/java/text/AttributedFormatBuffer.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\"}, {"sha": "7227bc8c36c3c625193b5108248eeafc0afade43", "filename": "libjava/Makefile.in", "status": "modified", "additions": 308, "deletions": 2, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -802,24 +802,57 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tgnu/java/security/der/DERReader.java \\\n \tgnu/java/security/der/DERValue.java \\\n \tgnu/java/security/der/DERWriter.java \\\n+\tgnu/java/security/provider/CollectionCertStoreImpl.java \\\n \tgnu/java/security/provider/DSAKeyFactory.java \\\n \tgnu/java/security/provider/DSAKeyPairGenerator.java \\\n \tgnu/java/security/provider/DSAParameterGenerator.java \\\n \tgnu/java/security/provider/DSAParameters.java \\\n \tgnu/java/security/provider/DSASignature.java \\\n \tgnu/java/security/provider/DefaultPolicy.java \\\n+\tgnu/java/security/provider/EncodedKeyFactory.java \\\n \tgnu/java/security/provider/Gnu.java \\\n+\tgnu/java/security/provider/GnuDHPublicKey.java \\\n \tgnu/java/security/provider/GnuDSAPrivateKey.java \\\n \tgnu/java/security/provider/GnuDSAPublicKey.java \\\n+\tgnu/java/security/provider/GnuRSAPrivateKey.java \\\n+\tgnu/java/security/provider/GnuRSAPublicKey.java \\\n+\tgnu/java/security/provider/MD2withRSA.java \\\n+\tgnu/java/security/provider/MD4withRSA.java \\\n \tgnu/java/security/provider/MD5.java \\\n+\tgnu/java/security/provider/MD5withRSA.java \\\n+\tgnu/java/security/provider/PKIXCertPathValidatorImpl.java \\\n+\tgnu/java/security/provider/RSA.java \\\n+\tgnu/java/security/provider/RSAKeyFactory.java \\\n \tgnu/java/security/provider/SHA.java \\\n \tgnu/java/security/provider/SHA1PRNG.java \\\n+\tgnu/java/security/provider/SHA1withRSA.java \\\n \tgnu/java/security/provider/X509CertificateFactory.java \\\n \tgnu/java/security/util/Prime.java \\\n+\tgnu/java/security/x509/GnuPKIExtension.java \\\n+\tgnu/java/security/x509/PolicyNodeImpl.java \\\n+\tgnu/java/security/x509/Util.java \\\n \tgnu/java/security/x509/X500DistinguishedName.java \\\n \tgnu/java/security/x509/X509CRL.java \\\n \tgnu/java/security/x509/X509CRLEntry.java \\\n+\tgnu/java/security/x509/X509CRLSelectorImpl.java \\\n \tgnu/java/security/x509/X509Certificate.java \\\n+\tgnu/java/security/x509/X509CertPath.java \\\n+\tgnu/java/security/x509/X509CertSelectorImpl.java \\\n+\tgnu/java/security/x509/ext/AuthorityKeyIdentifier.java \\\n+\tgnu/java/security/x509/ext/BasicConstraints.java \\\n+\tgnu/java/security/x509/ext/CRLNumber.java \\\n+\tgnu/java/security/x509/ext/CertificatePolicies.java \\\n+\tgnu/java/security/x509/ext/ExtendedKeyUsage.java \\\n+\tgnu/java/security/x509/ext/Extension.java \\\n+\tgnu/java/security/x509/ext/GeneralNames.java \\\n+\tgnu/java/security/x509/ext/IssuerAlternativeNames.java \\\n+\tgnu/java/security/x509/ext/KeyUsage.java \\\n+\tgnu/java/security/x509/ext/PolicyConstraint.java \\\n+\tgnu/java/security/x509/ext/PolicyMappings.java \\\n+\tgnu/java/security/x509/ext/PrivateKeyUsagePeriod.java \\\n+\tgnu/java/security/x509/ext/ReasonCode.java \\\n+\tgnu/java/security/x509/ext/SubjectAlternativeNames.java \\\n+\tgnu/java/security/x509/ext/SubjectKeyIdentifier.java \\\n \tgnu/java/text/AttributedFormatBuffer.java \\\n \tgnu/java/text/BaseBreakIterator.java \\\n \tgnu/java/text/CharacterBreakIterator.java \\\n@@ -3747,24 +3780,57 @@ am__objects_14 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/java/security/der/DERReader.lo \\\n \tgnu/java/security/der/DERValue.lo \\\n \tgnu/java/security/der/DERWriter.lo \\\n+\tgnu/java/security/provider/CollectionCertStoreImpl.lo \\\n \tgnu/java/security/provider/DSAKeyFactory.lo \\\n \tgnu/java/security/provider/DSAKeyPairGenerator.lo \\\n \tgnu/java/security/provider/DSAParameterGenerator.lo \\\n \tgnu/java/security/provider/DSAParameters.lo \\\n \tgnu/java/security/provider/DSASignature.lo \\\n \tgnu/java/security/provider/DefaultPolicy.lo \\\n+\tgnu/java/security/provider/EncodedKeyFactory.lo \\\n \tgnu/java/security/provider/Gnu.lo \\\n+\tgnu/java/security/provider/GnuDHPublicKey.lo \\\n \tgnu/java/security/provider/GnuDSAPrivateKey.lo \\\n \tgnu/java/security/provider/GnuDSAPublicKey.lo \\\n+\tgnu/java/security/provider/GnuRSAPrivateKey.lo \\\n+\tgnu/java/security/provider/GnuRSAPublicKey.lo \\\n+\tgnu/java/security/provider/MD2withRSA.lo \\\n+\tgnu/java/security/provider/MD4withRSA.lo \\\n \tgnu/java/security/provider/MD5.lo \\\n+\tgnu/java/security/provider/MD5withRSA.lo \\\n+\tgnu/java/security/provider/PKIXCertPathValidatorImpl.lo \\\n+\tgnu/java/security/provider/RSA.lo \\\n+\tgnu/java/security/provider/RSAKeyFactory.lo \\\n \tgnu/java/security/provider/SHA.lo \\\n \tgnu/java/security/provider/SHA1PRNG.lo \\\n+\tgnu/java/security/provider/SHA1withRSA.lo \\\n \tgnu/java/security/provider/X509CertificateFactory.lo \\\n \tgnu/java/security/util/Prime.lo \\\n+\tgnu/java/security/x509/GnuPKIExtension.lo \\\n+\tgnu/java/security/x509/PolicyNodeImpl.lo \\\n+\tgnu/java/security/x509/Util.lo \\\n \tgnu/java/security/x509/X500DistinguishedName.lo \\\n \tgnu/java/security/x509/X509CRL.lo \\\n \tgnu/java/security/x509/X509CRLEntry.lo \\\n+\tgnu/java/security/x509/X509CRLSelectorImpl.lo \\\n \tgnu/java/security/x509/X509Certificate.lo \\\n+\tgnu/java/security/x509/X509CertPath.lo \\\n+\tgnu/java/security/x509/X509CertSelectorImpl.lo \\\n+\tgnu/java/security/x509/ext/AuthorityKeyIdentifier.lo \\\n+\tgnu/java/security/x509/ext/BasicConstraints.lo \\\n+\tgnu/java/security/x509/ext/CRLNumber.lo \\\n+\tgnu/java/security/x509/ext/CertificatePolicies.lo \\\n+\tgnu/java/security/x509/ext/ExtendedKeyUsage.lo \\\n+\tgnu/java/security/x509/ext/Extension.lo \\\n+\tgnu/java/security/x509/ext/GeneralNames.lo \\\n+\tgnu/java/security/x509/ext/IssuerAlternativeNames.lo \\\n+\tgnu/java/security/x509/ext/KeyUsage.lo \\\n+\tgnu/java/security/x509/ext/PolicyConstraint.lo \\\n+\tgnu/java/security/x509/ext/PolicyMappings.lo \\\n+\tgnu/java/security/x509/ext/PrivateKeyUsagePeriod.lo \\\n+\tgnu/java/security/x509/ext/ReasonCode.lo \\\n+\tgnu/java/security/x509/ext/SubjectAlternativeNames.lo \\\n+\tgnu/java/security/x509/ext/SubjectKeyIdentifier.lo \\\n \tgnu/java/text/AttributedFormatBuffer.lo \\\n \tgnu/java/text/BaseBreakIterator.lo \\\n \tgnu/java/text/CharacterBreakIterator.lo \\\n@@ -6573,24 +6639,57 @@ gnu/java/security/der/DEREncodingException.java \\\n gnu/java/security/der/DERReader.java \\\n gnu/java/security/der/DERValue.java \\\n gnu/java/security/der/DERWriter.java \\\n+gnu/java/security/provider/CollectionCertStoreImpl.java \\\n gnu/java/security/provider/DSAKeyFactory.java \\\n gnu/java/security/provider/DSAKeyPairGenerator.java \\\n gnu/java/security/provider/DSAParameterGenerator.java \\\n gnu/java/security/provider/DSAParameters.java \\\n gnu/java/security/provider/DSASignature.java \\\n gnu/java/security/provider/DefaultPolicy.java \\\n+gnu/java/security/provider/EncodedKeyFactory.java \\\n gnu/java/security/provider/Gnu.java \\\n+gnu/java/security/provider/GnuDHPublicKey.java \\\n gnu/java/security/provider/GnuDSAPrivateKey.java \\\n gnu/java/security/provider/GnuDSAPublicKey.java \\\n+gnu/java/security/provider/GnuRSAPrivateKey.java \\\n+gnu/java/security/provider/GnuRSAPublicKey.java \\\n+gnu/java/security/provider/MD2withRSA.java \\\n+gnu/java/security/provider/MD4withRSA.java \\\n gnu/java/security/provider/MD5.java \\\n+gnu/java/security/provider/MD5withRSA.java \\\n+gnu/java/security/provider/PKIXCertPathValidatorImpl.java \\\n+gnu/java/security/provider/RSA.java \\\n+gnu/java/security/provider/RSAKeyFactory.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/security/provider/SHA1withRSA.java \\\n gnu/java/security/provider/X509CertificateFactory.java \\\n gnu/java/security/util/Prime.java \\\n+gnu/java/security/x509/GnuPKIExtension.java \\\n+gnu/java/security/x509/PolicyNodeImpl.java \\\n+gnu/java/security/x509/Util.java \\\n gnu/java/security/x509/X500DistinguishedName.java \\\n gnu/java/security/x509/X509CRL.java \\\n gnu/java/security/x509/X509CRLEntry.java \\\n+gnu/java/security/x509/X509CRLSelectorImpl.java \\\n gnu/java/security/x509/X509Certificate.java \\\n+gnu/java/security/x509/X509CertPath.java \\\n+gnu/java/security/x509/X509CertSelectorImpl.java \\\n+gnu/java/security/x509/ext/AuthorityKeyIdentifier.java \\\n+gnu/java/security/x509/ext/BasicConstraints.java \\\n+gnu/java/security/x509/ext/CRLNumber.java \\\n+gnu/java/security/x509/ext/CertificatePolicies.java \\\n+gnu/java/security/x509/ext/ExtendedKeyUsage.java \\\n+gnu/java/security/x509/ext/Extension.java \\\n+gnu/java/security/x509/ext/GeneralNames.java \\\n+gnu/java/security/x509/ext/IssuerAlternativeNames.java \\\n+gnu/java/security/x509/ext/KeyUsage.java \\\n+gnu/java/security/x509/ext/PolicyConstraint.java \\\n+gnu/java/security/x509/ext/PolicyMappings.java \\\n+gnu/java/security/x509/ext/PrivateKeyUsagePeriod.java \\\n+gnu/java/security/x509/ext/ReasonCode.java \\\n+gnu/java/security/x509/ext/SubjectAlternativeNames.java \\\n+gnu/java/security/x509/ext/SubjectKeyIdentifier.java \\\n gnu/java/text/AttributedFormatBuffer.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\\n@@ -9407,6 +9506,9 @@ gnu/java/security/provider/$(am__dirstamp):\n gnu/java/security/provider/$(DEPDIR)/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/security/provider/$(DEPDIR)\n \t@: > gnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/CollectionCertStoreImpl.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/DSAKeyFactory.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n@@ -9425,24 +9527,57 @@ gnu/java/security/provider/DSASignature.lo:  \\\n gnu/java/security/provider/DefaultPolicy.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/EncodedKeyFactory.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/Gnu.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/GnuDHPublicKey.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/GnuDSAPrivateKey.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/GnuDSAPublicKey.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/GnuRSAPrivateKey.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/GnuRSAPublicKey.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/MD2withRSA.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/MD4withRSA.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/MD5.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/MD5withRSA.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/PKIXCertPathValidatorImpl.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/RSA.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/RSAKeyFactory.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/SHA.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/SHA1PRNG.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/provider/SHA1withRSA.lo:  \\\n+\tgnu/java/security/provider/$(am__dirstamp) \\\n+\tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/provider/X509CertificateFactory.lo:  \\\n \tgnu/java/security/provider/$(am__dirstamp) \\\n \tgnu/java/security/provider/$(DEPDIR)/$(am__dirstamp)\n@@ -9461,6 +9596,15 @@ gnu/java/security/x509/$(am__dirstamp):\n gnu/java/security/x509/$(DEPDIR)/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/security/x509/$(DEPDIR)\n \t@: > gnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/GnuPKIExtension.lo:  \\\n+\tgnu/java/security/x509/$(am__dirstamp) \\\n+\tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/PolicyNodeImpl.lo:  \\\n+\tgnu/java/security/x509/$(am__dirstamp) \\\n+\tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/Util.lo:  \\\n+\tgnu/java/security/x509/$(am__dirstamp) \\\n+\tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/x509/X500DistinguishedName.lo:  \\\n \tgnu/java/security/x509/$(am__dirstamp) \\\n \tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n@@ -9470,9 +9614,69 @@ gnu/java/security/x509/X509CRL.lo:  \\\n gnu/java/security/x509/X509CRLEntry.lo:  \\\n \tgnu/java/security/x509/$(am__dirstamp) \\\n \tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/X509CRLSelectorImpl.lo:  \\\n+\tgnu/java/security/x509/$(am__dirstamp) \\\n+\tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n gnu/java/security/x509/X509Certificate.lo:  \\\n \tgnu/java/security/x509/$(am__dirstamp) \\\n \tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/X509CertPath.lo:  \\\n+\tgnu/java/security/x509/$(am__dirstamp) \\\n+\tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/X509CertSelectorImpl.lo:  \\\n+\tgnu/java/security/x509/$(am__dirstamp) \\\n+\tgnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/security/x509/ext\n+\t@: > gnu/java/security/x509/ext/$(am__dirstamp)\n+gnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/java/security/x509/ext/$(DEPDIR)\n+\t@: > gnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/AuthorityKeyIdentifier.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/BasicConstraints.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/CRLNumber.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/CertificatePolicies.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/ExtendedKeyUsage.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/Extension.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/GeneralNames.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/IssuerAlternativeNames.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/KeyUsage.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/PolicyConstraint.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/PolicyMappings.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/PrivateKeyUsagePeriod.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/ReasonCode.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/SubjectAlternativeNames.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+gnu/java/security/x509/ext/SubjectKeyIdentifier.lo:  \\\n+\tgnu/java/security/x509/ext/$(am__dirstamp) \\\n+\tgnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n gnu/java/text/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/text\n \t@: > gnu/java/text/$(am__dirstamp)\n@@ -15059,6 +15263,8 @@ mostlyclean-compile:\n \t-rm -f gnu/java/security/der/DERValue.lo\n \t-rm -f gnu/java/security/der/DERWriter.$(OBJEXT)\n \t-rm -f gnu/java/security/der/DERWriter.lo\n+\t-rm -f gnu/java/security/provider/CollectionCertStoreImpl.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/CollectionCertStoreImpl.lo\n \t-rm -f gnu/java/security/provider/DSAKeyFactory.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/DSAKeyFactory.lo\n \t-rm -f gnu/java/security/provider/DSAKeyPairGenerator.$(OBJEXT)\n@@ -15071,30 +15277,94 @@ mostlyclean-compile:\n \t-rm -f gnu/java/security/provider/DSASignature.lo\n \t-rm -f gnu/java/security/provider/DefaultPolicy.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/DefaultPolicy.lo\n+\t-rm -f gnu/java/security/provider/EncodedKeyFactory.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/EncodedKeyFactory.lo\n \t-rm -f gnu/java/security/provider/Gnu.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/Gnu.lo\n+\t-rm -f gnu/java/security/provider/GnuDHPublicKey.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/GnuDHPublicKey.lo\n \t-rm -f gnu/java/security/provider/GnuDSAPrivateKey.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/GnuDSAPrivateKey.lo\n \t-rm -f gnu/java/security/provider/GnuDSAPublicKey.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/GnuDSAPublicKey.lo\n+\t-rm -f gnu/java/security/provider/GnuRSAPrivateKey.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/GnuRSAPrivateKey.lo\n+\t-rm -f gnu/java/security/provider/GnuRSAPublicKey.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/GnuRSAPublicKey.lo\n+\t-rm -f gnu/java/security/provider/MD2withRSA.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/MD2withRSA.lo\n+\t-rm -f gnu/java/security/provider/MD4withRSA.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/MD4withRSA.lo\n \t-rm -f gnu/java/security/provider/MD5.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/MD5.lo\n+\t-rm -f gnu/java/security/provider/MD5withRSA.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/MD5withRSA.lo\n+\t-rm -f gnu/java/security/provider/PKIXCertPathValidatorImpl.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/PKIXCertPathValidatorImpl.lo\n+\t-rm -f gnu/java/security/provider/RSA.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/RSA.lo\n+\t-rm -f gnu/java/security/provider/RSAKeyFactory.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/RSAKeyFactory.lo\n \t-rm -f gnu/java/security/provider/SHA.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/SHA.lo\n \t-rm -f gnu/java/security/provider/SHA1PRNG.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/SHA1PRNG.lo\n+\t-rm -f gnu/java/security/provider/SHA1withRSA.$(OBJEXT)\n+\t-rm -f gnu/java/security/provider/SHA1withRSA.lo\n \t-rm -f gnu/java/security/provider/X509CertificateFactory.$(OBJEXT)\n \t-rm -f gnu/java/security/provider/X509CertificateFactory.lo\n \t-rm -f gnu/java/security/util/Prime.$(OBJEXT)\n \t-rm -f gnu/java/security/util/Prime.lo\n+\t-rm -f gnu/java/security/x509/GnuPKIExtension.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/GnuPKIExtension.lo\n+\t-rm -f gnu/java/security/x509/PolicyNodeImpl.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/PolicyNodeImpl.lo\n+\t-rm -f gnu/java/security/x509/Util.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/Util.lo\n \t-rm -f gnu/java/security/x509/X500DistinguishedName.$(OBJEXT)\n \t-rm -f gnu/java/security/x509/X500DistinguishedName.lo\n \t-rm -f gnu/java/security/x509/X509CRL.$(OBJEXT)\n \t-rm -f gnu/java/security/x509/X509CRL.lo\n \t-rm -f gnu/java/security/x509/X509CRLEntry.$(OBJEXT)\n \t-rm -f gnu/java/security/x509/X509CRLEntry.lo\n+\t-rm -f gnu/java/security/x509/X509CRLSelectorImpl.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/X509CRLSelectorImpl.lo\n+\t-rm -f gnu/java/security/x509/X509CertPath.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/X509CertPath.lo\n+\t-rm -f gnu/java/security/x509/X509CertSelectorImpl.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/X509CertSelectorImpl.lo\n \t-rm -f gnu/java/security/x509/X509Certificate.$(OBJEXT)\n \t-rm -f gnu/java/security/x509/X509Certificate.lo\n+\t-rm -f gnu/java/security/x509/ext/AuthorityKeyIdentifier.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/AuthorityKeyIdentifier.lo\n+\t-rm -f gnu/java/security/x509/ext/BasicConstraints.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/BasicConstraints.lo\n+\t-rm -f gnu/java/security/x509/ext/CRLNumber.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/CRLNumber.lo\n+\t-rm -f gnu/java/security/x509/ext/CertificatePolicies.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/CertificatePolicies.lo\n+\t-rm -f gnu/java/security/x509/ext/ExtendedKeyUsage.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/ExtendedKeyUsage.lo\n+\t-rm -f gnu/java/security/x509/ext/Extension.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/Extension.lo\n+\t-rm -f gnu/java/security/x509/ext/GeneralNames.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/GeneralNames.lo\n+\t-rm -f gnu/java/security/x509/ext/IssuerAlternativeNames.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/IssuerAlternativeNames.lo\n+\t-rm -f gnu/java/security/x509/ext/KeyUsage.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/KeyUsage.lo\n+\t-rm -f gnu/java/security/x509/ext/PolicyConstraint.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/PolicyConstraint.lo\n+\t-rm -f gnu/java/security/x509/ext/PolicyMappings.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/PolicyMappings.lo\n+\t-rm -f gnu/java/security/x509/ext/PrivateKeyUsagePeriod.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/PrivateKeyUsagePeriod.lo\n+\t-rm -f gnu/java/security/x509/ext/ReasonCode.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/ReasonCode.lo\n+\t-rm -f gnu/java/security/x509/ext/SubjectAlternativeNames.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/SubjectAlternativeNames.lo\n+\t-rm -f gnu/java/security/x509/ext/SubjectKeyIdentifier.$(OBJEXT)\n+\t-rm -f gnu/java/security/x509/ext/SubjectKeyIdentifier.lo\n \t-rm -f gnu/java/text/AttributedFormatBuffer.$(OBJEXT)\n \t-rm -f gnu/java/text/AttributedFormatBuffer.lo\n \t-rm -f gnu/java/text/BaseBreakIterator.$(OBJEXT)\n@@ -19629,24 +19899,57 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DERReader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DERValue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/der/$(DEPDIR)/DERWriter.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/CollectionCertStoreImpl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DSAKeyFactory.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DSAKeyPairGenerator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DSAParameterGenerator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DSAParameters.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DSASignature.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/DefaultPolicy.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/EncodedKeyFactory.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/Gnu.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/GnuDHPublicKey.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/GnuDSAPrivateKey.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/GnuDSAPublicKey.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/GnuRSAPrivateKey.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/GnuRSAPublicKey.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/MD2withRSA.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/MD4withRSA.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/MD5.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/MD5withRSA.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/PKIXCertPathValidatorImpl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/RSA.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/RSAKeyFactory.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/SHA.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/SHA1PRNG.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/SHA1withRSA.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/provider/$(DEPDIR)/X509CertificateFactory.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/util/$(DEPDIR)/Prime.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/GnuPKIExtension.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/PolicyNodeImpl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/Util.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/X500DistinguishedName.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/X509CRL.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/X509CRLEntry.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/X509CRLSelectorImpl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/X509CertPath.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/X509CertSelectorImpl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/$(DEPDIR)/X509Certificate.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/AuthorityKeyIdentifier.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/BasicConstraints.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/CRLNumber.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/CertificatePolicies.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/ExtendedKeyUsage.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/Extension.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/GeneralNames.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/IssuerAlternativeNames.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/KeyUsage.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/PolicyConstraint.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/PolicyMappings.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/PrivateKeyUsagePeriod.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/ReasonCode.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/SubjectAlternativeNames.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/java/security/x509/ext/$(DEPDIR)/SubjectKeyIdentifier.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/text/$(DEPDIR)/AttributedFormatBuffer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/text/$(DEPDIR)/BaseBreakIterator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/java/text/$(DEPDIR)/CharacterBreakIterator.Plo@am__quote@\n@@ -22547,6 +22850,7 @@ clean-libtool:\n \t-rm -rf gnu/java/security/provider/.libs gnu/java/security/provider/_libs\n \t-rm -rf gnu/java/security/util/.libs gnu/java/security/util/_libs\n \t-rm -rf gnu/java/security/x509/.libs gnu/java/security/x509/_libs\n+\t-rm -rf gnu/java/security/x509/ext/.libs gnu/java/security/x509/ext/_libs\n \t-rm -rf gnu/java/text/.libs gnu/java/text/_libs\n \t-rm -rf gnu/java/util/.libs gnu/java/util/_libs\n \t-rm -rf gnu/java/util/prefs/.libs gnu/java/util/prefs/_libs\n@@ -23079,6 +23383,8 @@ distclean-generic:\n \t-rm -f gnu/java/security/util/$(am__dirstamp)\n \t-rm -f gnu/java/security/x509/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/security/x509/$(am__dirstamp)\n+\t-rm -f gnu/java/security/x509/ext/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f gnu/java/security/x509/ext/$(am__dirstamp)\n \t-rm -f gnu/java/text/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/java/text/$(am__dirstamp)\n \t-rm -f gnu/java/util/$(DEPDIR)/$(am__dirstamp)\n@@ -23297,7 +23603,7 @@ clean-am: clean-binPROGRAMS clean-generic clean-libtool clean-local \\\n \n distclean: distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-local distclean-tags\n@@ -23327,7 +23633,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "}, {"sha": "1b22cc891e55fc0d8f9e7f9809813b47f960671d", "filename": "libjava/gnu/java/security/provider/CollectionCertStoreImpl.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FCollectionCertStoreImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FCollectionCertStoreImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FCollectionCertStoreImpl.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,103 @@\n+/* CollectionCertStore.java -- Collection-based cert store.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertSelector;\n+import java.security.cert.CRL;\n+import java.security.cert.CRLSelector;\n+import java.security.cert.CertStoreException;\n+import java.security.cert.CertStoreParameters;\n+import java.security.cert.CertStoreSpi;\n+import java.security.cert.CollectionCertStoreParameters;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+public final class CollectionCertStoreImpl extends CertStoreSpi\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private final Collection store;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public CollectionCertStoreImpl(CertStoreParameters params)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    super(params);\n+    if (! (params instanceof CollectionCertStoreParameters))\n+      throw new InvalidAlgorithmParameterException(\"not a CollectionCertStoreParameters object\");\n+    store = ((CollectionCertStoreParameters) params).getCollection();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public Collection engineGetCertificates(CertSelector selector)\n+    throws CertStoreException\n+  {\n+    LinkedList result = new LinkedList();\n+    for (Iterator it = store.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if ((o instanceof Certificate) && selector.match((Certificate) o))\n+          result.add(o);\n+      }\n+    return result;\n+  }\n+\n+  public Collection engineGetCRLs(CRLSelector selector)\n+    throws CertStoreException\n+  {\n+    LinkedList result = new LinkedList();\n+    for (Iterator it = store.iterator(); it.hasNext(); )\n+      {\n+        Object o = it.next();\n+        if ((o instanceof CRL) && selector.match((CRL) o))\n+          result.add(o);\n+      }\n+    return result;\n+  }\n+}"}, {"sha": "e308d443fc6cc7b3795a8944c68c999efbb27f6b", "filename": "libjava/gnu/java/security/provider/EncodedKeyFactory.java", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FEncodedKeyFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FEncodedKeyFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FEncodedKeyFactory.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,310 @@\n+/* EncodedKeyFactory.java -- encoded key factory.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactory;\n+import java.security.KeyFactorySpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+\n+import java.security.spec.DSAParameterSpec;\n+import java.security.spec.DSAPrivateKeySpec;\n+import java.security.spec.DSAPublicKeySpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.RSAPrivateCrtKeySpec;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+import javax.crypto.spec.DHParameterSpec;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+/**\n+ * A factory for keys encoded in either the X.509 format (for public\n+ * keys) or the PKCS#8 format (for private keys).\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class EncodedKeyFactory extends KeyFactorySpi\n+{\n+\n+  // Constants.\n+  // ------------------------------------------------------------------------\n+\n+  private static final OID ID_DSA = new OID(\"1.2.840.10040.4.1\");\n+  private static final OID ID_RSA = new OID(\"1.2.840.113549.1.1.1\");\n+  private static final OID ID_DH  = new OID(\"1.2.840.10046.2.1\");\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public PublicKey engineGeneratePublic(KeySpec spec)\n+    throws InvalidKeySpecException\n+  {\n+    if (!(spec instanceof X509EncodedKeySpec))\n+      throw new InvalidKeySpecException(\"only supports X.509 key specs\");\n+    DERReader der = new DERReader(((X509EncodedKeySpec) spec).getEncoded());\n+    try\n+      {\n+        DERValue spki = der.read();\n+        if (!spki.isConstructed())\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        DERValue alg = der.read();\n+        if (!alg.isConstructed())\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        DERValue val = der.read();\n+        if (!(val.getValue() instanceof OID))\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        OID algId = (OID) val.getValue();\n+        byte[] algParams = null;\n+        if (alg.getLength() > val.getEncodedLength())\n+          {\n+            val = der.read();\n+            algParams = val.getEncoded();\n+            if (val.isConstructed())\n+              der.skip(val.getLength());\n+          }\n+        val = der.read();\n+        if (!(val.getValue() instanceof BitString))\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        byte[] publicKey = ((BitString) val.getValue()).toByteArray();\n+        if (algId.equals(ID_DSA))\n+          {\n+            BigInteger p = null, g = null, q = null, Y;\n+            if (algParams != null)\n+              {\n+                DERReader dsaParams = new DERReader(algParams);\n+                val = dsaParams.read();\n+                if (!val.isConstructed())\n+                  throw new InvalidKeySpecException(\"malformed DSA parameters\");\n+                val = dsaParams.read();\n+                if (!(val.getValue() instanceof BigInteger))\n+                  throw new InvalidKeySpecException(\"malformed DSA parameters\");\n+                p = (BigInteger) val.getValue();\n+                val = dsaParams.read();\n+                if (!(val.getValue() instanceof BigInteger))\n+                  throw new InvalidKeySpecException(\"malformed DSA parameters\");\n+                q = (BigInteger) val.getValue();\n+                val = dsaParams.read();\n+                if (!(val.getValue() instanceof BigInteger))\n+                  throw new InvalidKeySpecException(\"malformed DSA parameters\");\n+                g = (BigInteger) val.getValue();\n+              }\n+            DERReader dsaPub = new DERReader(publicKey);\n+            val = dsaPub.read();\n+            if (!(val.getValue() instanceof BigInteger))\n+              throw new InvalidKeySpecException(\"malformed DSA parameters\");\n+            Y = (BigInteger) val.getValue();\n+            return new GnuDSAPublicKey(Y, p, q, g);\n+          }\n+        else if (algId.equals(ID_RSA))\n+          {\n+            DERReader rsaParams = new DERReader(publicKey);\n+            if (!rsaParams.read().isConstructed())\n+              {\n+                throw new InvalidKeySpecException(\"malformed encoded key\");\n+              }\n+            return new GnuRSAPublicKey(new RSAPublicKeySpec(\n+              (BigInteger) rsaParams.read().getValue(),\n+              (BigInteger) rsaParams.read().getValue()));\n+          }\n+        else if (algId.equals(ID_DH))\n+          {\n+            if (algParams == null)\n+              throw new InvalidKeySpecException(\"missing DH parameters\");\n+            DERReader dhParams = new DERReader(algParams);\n+            val = dhParams.read();\n+            BigInteger p, g, q, Y;\n+            if (!val.isConstructed())\n+              throw new InvalidKeySpecException(\"malformed DH parameters\");\n+            val = dhParams.read();\n+            if (!(val.getValue() instanceof BigInteger))\n+              throw new InvalidKeySpecException(\"malformed DH parameters\");\n+            p = (BigInteger) val.getValue();\n+            val = dhParams.read();\n+            if (!(val.getValue() instanceof BigInteger))\n+              throw new InvalidKeySpecException(\"malformed DH parameters\");\n+            g = (BigInteger) val.getValue();\n+            val = dhParams.read();\n+            if (!(val.getValue() instanceof BigInteger))\n+              throw new InvalidKeySpecException(\"malformed DH parameters\");\n+            q = (BigInteger) val.getValue();\n+            DERReader dhPub = new DERReader(publicKey);\n+            val = dhPub.read();\n+            if (!(val.getValue() instanceof BigInteger))\n+              throw new InvalidKeySpecException(\"malformed DH parameters\");\n+            Y = (BigInteger) val.getValue();\n+            return (PublicKey) new GnuDHPublicKey(new DHParameterSpec(p, g), Y, q);\n+          }\n+        else\n+          throw new InvalidKeySpecException(\"unknown algorithm: \" + algId);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new InvalidKeySpecException(ioe.getMessage());\n+      }\n+  }\n+\n+  public PrivateKey engineGeneratePrivate(KeySpec spec)\n+    throws InvalidKeySpecException\n+  {\n+    if (!(spec instanceof PKCS8EncodedKeySpec))\n+      {\n+        throw new InvalidKeySpecException(\"only supports PKCS8 key specs\");\n+      }\n+    DERReader der = new DERReader(((PKCS8EncodedKeySpec) spec).getEncoded());\n+    try\n+      {\n+        DERValue pki = der.read();\n+        if (!pki.isConstructed())\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        DERValue val = der.read();\n+        if (!(val.getValue() instanceof BigInteger))\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        DERValue alg = der.read();\n+        if (!alg.isConstructed())\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        val = der.read();\n+        if (!(val.getValue() instanceof OID))\n+          {\n+            throw new InvalidKeySpecException(\"malformed encoded key\");\n+          }\n+        OID algId = (OID) val.getValue();\n+        byte[] algParams = null;\n+        if (alg.getLength() > val.getEncodedLength())\n+          {\n+            val = der.read();\n+            algParams = val.getEncoded();\n+            if (val.isConstructed())\n+              der.skip(val.getLength());\n+          }\n+        byte[] privateKey = (byte[]) der.read().getValue();\n+        if (algId.equals(ID_DSA))\n+          {\n+            if (algParams == null)\n+              {\n+                throw new InvalidKeySpecException(\"missing DSA parameters\");\n+              }\n+            AlgorithmParameters params = AlgorithmParameters.getInstance(\"DSA\");\n+            params.init(algParams);\n+            DSAParameterSpec dsaSpec = (DSAParameterSpec)\n+              params.getParameterSpec(DSAParameterSpec.class);\n+            DERReader dsaPriv = new DERReader(privateKey);\n+            return new GnuDSAPrivateKey((BigInteger) dsaPriv.read().getValue(),\n+              dsaSpec.getP(), dsaSpec.getQ(), dsaSpec.getG());\n+          }\n+        else if (algId.equals(ID_RSA))\n+          {\n+            DERReader rsaParams = new DERReader(privateKey);\n+            if (!rsaParams.read().isConstructed())\n+              throw new InvalidKeySpecException(\"malformed encoded key\");\n+            return new GnuRSAPrivateKey(new RSAPrivateCrtKeySpec(\n+              (BigInteger) rsaParams.read().getValue(), // n\n+              (BigInteger) rsaParams.read().getValue(), // e\n+              (BigInteger) rsaParams.read().getValue(), // d\n+              (BigInteger) rsaParams.read().getValue(), // p\n+              (BigInteger) rsaParams.read().getValue(), // q\n+              (BigInteger) rsaParams.read().getValue(), // d mod (p - 1)\n+              (BigInteger) rsaParams.read().getValue(), // d mod (q - 1)\n+              (BigInteger) rsaParams.read().getValue())); // (inv q) mod p\n+          }\n+        else\n+          throw new InvalidKeySpecException(\"unknown algorithm: \" + algId);\n+      }\n+    catch (InvalidParameterSpecException iapse)\n+      {\n+        throw new InvalidKeySpecException(iapse.getMessage());\n+      }\n+    catch (NoSuchAlgorithmException nsae)\n+      {\n+        throw new InvalidKeySpecException(nsae.getMessage());\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new InvalidKeySpecException(ioe.getMessage());\n+      }\n+  }\n+\n+  public KeySpec engineGetKeySpec(Key key, Class speClass)\n+    throws InvalidKeySpecException\n+  {\n+    if ((key instanceof PrivateKey) && key.getFormat().equals(\"PKCS#8\")\n+        && speClass.isAssignableFrom(PKCS8EncodedKeySpec.class))\n+      return new PKCS8EncodedKeySpec(key.getEncoded());\n+    else if ((key instanceof PublicKey) && key.getFormat().equals(\"X.509\")\n+        && speClass.isAssignableFrom(X509EncodedKeySpec.class))\n+      return new X509EncodedKeySpec(key.getEncoded());\n+    else\n+      throw new InvalidKeySpecException();\n+  }\n+\n+  public Key engineTranslateKey(Key key) throws InvalidKeyException\n+  {\n+    throw new InvalidKeyException(\"translating keys not supported\");\n+  }\n+}"}, {"sha": "02f509dc2d58625e9cb8f44ca8e4dc1ccfecc3dd", "filename": "libjava/gnu/java/security/provider/Gnu.java", "status": "modified", "additions": 121, "deletions": 65, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnu.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,75 +37,131 @@\n \n \n package gnu.java.security.provider;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n import java.security.Provider;\n \n public final class Gnu extends Provider\n {\n   public Gnu()\n   {\n-    super(\"GNU\", 1.0, \"GNU provider v1.0 implementing SHA-1, MD5, DSA, X.509 Certificates\");\n-\n-    // Note that all implementation class names are referenced by using\n-    // Class.getName(). That way when we staticly link the Gnu provider\n-    // we automatically get all the implementation classes.\n-\n-    // Signature\n-    put(\"Signature.SHA1withDSA\",\n-        gnu.java.security.provider.DSASignature.class.getName());\n-\n-    put(\"Alg.Alias.Signature.DSS\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.DSA\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.SHAwithDSA\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.DSAwithSHA\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.DSAwithSHA1\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.SHA/DSA\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.SHA-1/DSA\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.SHA1/DSA\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.OID.1.2.840.10040.4.3\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.1.2.840.10040.4.3\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.1.3.14.3.2.13\", \"SHA1withDSA\");\n-    put(\"Alg.Alias.Signature.1.3.14.3.2.27\", \"SHA1withDSA\");\n-\n-    // Key Pair Generator\n-    put(\"KeyPairGenerator.DSA\",\n-        gnu.java.security.provider.DSAKeyPairGenerator.class.getName());\n-\n-    put(\"Alg.Alias.KeyPairGenerator.OID.1.2.840.10040.4.1\", \"DSA\");\n-    put(\"Alg.Alias.KeyPairGenerator.1.2.840.10040.4.1\", \"DSA\");\n-    put(\"Alg.Alias.KeyPairGenerator.1.3.14.3.2.12\", \"DSA\");\n-\n-    // Key Factory\n-    put(\"KeyFactory.DSA\",\n-        gnu.java.security.provider.DSAKeyFactory.class.getName());\n-\n-    put(\"Alg.Alias.KeyFactory.OID.1.2.840.10040.4.1\", \"DSA\");\n-    put(\"Alg.Alias.KeyFactory.1.2.840.10040.4.1\", \"DSA\");\n-    put(\"Alg.Alias.KeyFactory.1.3.14.3.2.12\", \"DSA\");\n-\n-    // Message Digests\n-    put(\"MessageDigest.SHA\", gnu.java.security.provider.SHA.class.getName());\n-    put(\"MessageDigest.MD5\", gnu.java.security.provider.MD5.class.getName());\n-\n-    // Format \"Alias\", \"Actual Name\"\n-    put(\"Alg.Alias.MessageDigest.SHA1\", \"SHA\");\n-    put(\"Alg.Alias.MessageDigest.SHA-1\", \"SHA\");\n-\n-    // Algorithm Parameters\n-    put(\"AlgorithmParameters.DSA\",\n-        gnu.java.security.provider.DSAParameters.class.getName());\n-\n-    // Algorithm Parameter Generator\n-    put(\"AlgorithmParameterGenerator.DSA\",\n-        gnu.java.security.provider.DSAParameterGenerator.class.getName());\n-\n-    // SecureRandom\n-    put(\"SecureRandom.SHA1PRNG\",\n-        gnu.java.security.provider.SHA1PRNG.class.getName());\n-\n-    // CertificateFactory\n-    put(\"CertificateFactory.X.509\",\n-        gnu.java.security.provider.X509CertificateFactory.class.getName());\n-\n-    put(\"Alg.Alias.CertificateFactory.X509\", \"X.509\");\n+    super(\"GNU\", 1.0, \"GNU provider v1.0 implementing SHA-1, MD5, DSA, RSA, X.509 Certificates and CRLs, PKIX certificate path validators, Collection cert stores\");\n+\n+    AccessController.doPrivileged (new PrivilegedAction()\n+    {\n+      public Object run()\n+      {\n+        // Note that all implementation class names are referenced by using\n+        // Class.getName(). That way when we staticly link the Gnu provider\n+        // we automatically get all the implementation classes.\n+\n+        // Signature\n+        put(\"Signature.SHA1withDSA\",\n+            gnu.java.security.provider.DSASignature.class.getName());\n+\n+        put(\"Alg.Alias.Signature.DSS\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.DSA\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.SHAwithDSA\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.DSAwithSHA\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.DSAwithSHA1\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.SHA/DSA\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.SHA-1/DSA\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.SHA1/DSA\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.OID.1.2.840.10040.4.3\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.1.2.840.10040.4.3\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.1.3.14.3.2.13\", \"SHA1withDSA\");\n+        put(\"Alg.Alias.Signature.1.3.14.3.2.27\", \"SHA1withDSA\");\n+\n+        put(\"Signature.MD2withRSA\", MD2withRSA.class.getName());\n+        put(\"Signature.MD2withRSA ImplementedIn\", \"Software\");\n+        put(\"Alg.Alias.Signature.md2WithRSAEncryption\", \"MD2withRSA\");\n+        put(\"Alg.Alias.Signature.OID.1.2.840.113549.1.1.2\", \"MD2withRSA\");\n+        put(\"Alg.Alias.Signature.1.2.840.113549.1.1.2\", \"MD2withRSA\");\n+\n+        put(\"Signature.MD4withRSA\", MD4withRSA.class.getName());\n+        put(\"Signature.MD4withRSA ImplementedIn\", \"Software\");\n+        put(\"Alg.Alias.Signature.md4WithRSAEncryption\", \"MD4withRSA\");\n+        put(\"Alg.Alias.Signature.OID.1.2.840.113549.1.1.3\", \"MD4withRSA\");\n+        put(\"Alg.Alias.Signature.1.2.840.113549.1.1.3\", \"MD4withRSA\");\n+\n+        put(\"Signature.MD5withRSA\", MD5withRSA.class.getName());\n+        put(\"Signature.MD5withRSA ImplementedIn\", \"Software\");\n+        put(\"Alg.Alias.Signature.md5WithRSAEncryption\", \"MD5withRSA\");\n+        put(\"Alg.Alias.Signature.OID.1.2.840.113549.1.1.4\", \"MD5withRSA\");\n+        put(\"Alg.Alias.Signature.1.2.840.113549.1.1.4\", \"MD5withRSA\");\n+\n+        put(\"Signature.SHA1withRSA\", SHA1withRSA.class.getName());\n+        put(\"Signature.SHA1withRSA ImplementedIn\", \"Software\");\n+        put(\"Alg.Alias.Signature.sha-1WithRSAEncryption\", \"SHA1withRSA\");\n+        put(\"Alg.Alias.Signature.OID.1.2.840.113549.1.1.5\", \"SHA1withRSA\");\n+        put(\"Alg.Alias.Signature.1.2.840.113549.1.1.5\", \"SHA1withRSA\");\n+\n+        // Key Pair Generator\n+        put(\"KeyPairGenerator.DSA\",\n+            gnu.java.security.provider.DSAKeyPairGenerator.class.getName());\n+\n+        put(\"Alg.Alias.KeyPairGenerator.OID.1.2.840.10040.4.1\", \"DSA\");\n+        put(\"Alg.Alias.KeyPairGenerator.1.2.840.10040.4.1\", \"DSA\");\n+        put(\"Alg.Alias.KeyPairGenerator.1.3.14.3.2.12\", \"DSA\");\n+\n+        // Key Factory\n+        put(\"KeyFactory.DSA\",\n+            gnu.java.security.provider.DSAKeyFactory.class.getName());\n+\n+        put(\"KeyFactory.Encoded\", EncodedKeyFactory.class.getName());\n+        put(\"KeyFactory.Encoded ImplementedIn\", \"Software\");\n+        put(\"Alg.Alias.KeyFactory.X.509\", \"Encoded\");\n+        put(\"Alg.Alias.KeyFactory.X509\", \"Encoded\");\n+        put(\"Alg.Alias.KeyFactory.PKCS#8\", \"Encoded\");\n+        put(\"Alg.Alias.KeyFactory.PKCS8\", \"Encoded\");\n+\n+        put(\"KeyFactory.RSA\", RSAKeyFactory.class.getName());\n+\n+        put(\"Alg.Alias.KeyFactory.OID.1.2.840.10040.4.1\", \"DSA\");\n+        put(\"Alg.Alias.KeyFactory.1.2.840.10040.4.1\", \"DSA\");\n+        put(\"Alg.Alias.KeyFactory.1.3.14.3.2.12\", \"DSA\");\n+\n+        // Message Digests\n+        put(\"MessageDigest.SHA\", gnu.java.security.provider.SHA.class.getName());\n+        put(\"MessageDigest.MD5\", gnu.java.security.provider.MD5.class.getName());\n+\n+        // Format \"Alias\", \"Actual Name\"\n+        put(\"Alg.Alias.MessageDigest.SHA1\", \"SHA\");\n+        put(\"Alg.Alias.MessageDigest.SHA-1\", \"SHA\");\n+\n+        // Algorithm Parameters\n+        put(\"AlgorithmParameters.DSA\",\n+            gnu.java.security.provider.DSAParameters.class.getName());\n+\n+        put(\"Alg.Alias.AlgorithmParameters.DSS\", \"DSA\");\n+        put(\"Alg.Alias.AlgorithmParameters.SHAwithDSA\", \"DSA\");\n+        put(\"Alg.Alias.AlgorithmParameters.OID.1.2.840.10040.4.3\", \"DSA\");\n+        put(\"Alg.Alias.AlgorithmParameters.1.2.840.10040.4.3\", \"DSA\");\n+\n+        // Algorithm Parameter Generator\n+        put(\"AlgorithmParameterGenerator.DSA\",\n+            gnu.java.security.provider.DSAParameterGenerator.class.getName());\n+\n+        // SecureRandom\n+        put(\"SecureRandom.SHA1PRNG\",\n+            gnu.java.security.provider.SHA1PRNG.class.getName());\n+\n+        // CertificateFactory\n+        put(\"CertificateFactory.X509\", X509CertificateFactory.class.getName());\n+\n+        put(\"CertificateFactory.X509 ImplementedIn\", \"Software\");\n+        put(\"Alg.Alias.CertificateFactory.X.509\", \"X509\");\n+\n+        // CertPathValidator\n+        put(\"CertPathValidator.PKIX\", PKIXCertPathValidatorImpl.class.getName());\n+        put(\"CertPathValidator.PKIX ImplementedIn\", \"Software\");\n+\n+        // CertStore\n+        put(\"CertStore.Collection\", CollectionCertStoreImpl.class.getName());\n+\n+        return null;\n+      }\n+    });\n   }\n }"}, {"sha": "a650761dc8f7e136132037172d4c7064a7ff6656", "filename": "libjava/gnu/java/security/provider/GnuDHPublicKey.java", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDHPublicKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDHPublicKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDHPublicKey.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,117 @@\n+/* GnuDHPublicKey.java -- A Diffie-Hellman public key.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.math.BigInteger;\n+\n+import java.util.ArrayList;\n+\n+import javax.crypto.interfaces.DHPublicKey;\n+import javax.crypto.spec.DHParameterSpec;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+public class GnuDHPublicKey implements DHPublicKey\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private byte[] encoded;\n+  private final DHParameterSpec params;\n+  private final BigInteger Y;\n+  private final BigInteger q;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public GnuDHPublicKey(DHParameterSpec params, BigInteger Y, BigInteger q)\n+  {\n+    this.params = params;\n+    this.Y = Y;\n+    this.q = q;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public BigInteger getY()\n+  {\n+    return Y;\n+  }\n+\n+  public DHParameterSpec getParams()\n+  {\n+    return params;\n+  }\n+\n+  public String getAlgorithm()\n+  {\n+    return \"DH\";\n+  }\n+\n+  public String getFormat()\n+  {\n+    return \"X.509\";\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encoded != null)\n+      return (byte[]) encoded.clone();\n+    ArrayList spki = new ArrayList(2);\n+    ArrayList alg = new ArrayList(2);\n+    alg.add(new DERValue(DER.OBJECT_IDENTIFIER, new OID(\"1.2.840.10046.2.1\")));\n+    ArrayList param = new ArrayList(3);\n+    param.add(new DERValue(DER.INTEGER, params.getP()));\n+    param.add(new DERValue(DER.INTEGER, params.getG()));\n+    param.add(new DERValue(DER.INTEGER, q));\n+    alg.add(new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, param));\n+    spki.add(new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, alg));\n+    spki.add(new DERValue(DER.BIT_STRING, new BitString(Y.toByteArray())));\n+    encoded = new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, spki).getEncoded();\n+    if (encoded != null)\n+      return (byte[]) encoded.clone();\n+    return null;\n+  }\n+}"}, {"sha": "455326dd082a3a5c484a2f9666f1691f08164ee1", "filename": "libjava/gnu/java/security/provider/GnuRSAPrivateKey.java", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuRSAPrivateKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuRSAPrivateKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuRSAPrivateKey.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,166 @@\n+/* GnuRSAPrivateKey.java -- GNU RSA private key.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.math.BigInteger;\n+\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.spec.RSAPrivateCrtKeySpec;\n+\n+import java.util.ArrayList;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERValue;\n+\n+class GnuRSAPrivateKey implements RSAPrivateCrtKey\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private final RSAPrivateCrtKeySpec spec;\n+  private byte[] encodedKey;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public GnuRSAPrivateKey(RSAPrivateCrtKeySpec spec)\n+  {\n+    this.spec = spec;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public BigInteger getModulus()\n+  {\n+    return spec.getModulus();\n+  }\n+\n+  public BigInteger getPrivateExponent()\n+  {\n+    return spec.getPrivateExponent();\n+  }\n+\n+  public BigInteger getCrtCoefficient()\n+  {\n+    return spec.getCrtCoefficient();\n+  }\n+\n+  public BigInteger getPrimeExponentP()\n+  {\n+    return spec.getPrimeExponentP();\n+  }\n+\n+  public BigInteger getPrimeExponentQ()\n+  {\n+    return spec.getPrimeExponentQ();\n+  }\n+\n+  public BigInteger getPrimeP()\n+  {\n+    return spec.getPrimeP();\n+  }\n+\n+  public BigInteger getPrimeQ()\n+  {\n+    return spec.getPrimeQ();\n+  }\n+\n+  public BigInteger getPublicExponent()\n+  {\n+    return spec.getPublicExponent();\n+  }\n+\n+  public String getAlgorithm()\n+  {\n+    return \"RSA\";\n+  }\n+\n+  public String getFormat()\n+  {\n+    return \"PKCS#8\";\n+  }\n+\n+  /**\n+   * The encoded form is:\n+   *\n+   * <pre>\n+   * RSAPrivateKey ::= SEQUENCE {\n+   *   version Version,\n+   *   modulus INTEGER, -- n\n+   *   publicExponent INTEGER, -- e\n+   *   privateExponent INTEGER, -- d\n+   *   prime1 INTEGER, -- p\n+   *   prime2 INTEGER, -- q\n+   *   exponent1 INTEGER, -- d mod (p-1)\n+   *   exponent2 INTEGER, -- d mod (q-1)\n+   *   coefficient INTEGER -- (inverse of q) mod p }\n+   * </pre>\n+   *\n+   * <p>Which is in turn encoded in a PrivateKeyInfo structure from PKCS#8.\n+   */\n+  public byte[] getEncoded()\n+  {\n+    if (encodedKey != null)\n+      return (byte[]) encodedKey.clone();\n+    ArrayList key = new ArrayList(9);\n+    key.add(new DERValue(DER.INTEGER, BigInteger.ZERO));\n+    key.add(new DERValue(DER.INTEGER, getModulus()));\n+    key.add(new DERValue(DER.INTEGER, getPublicExponent()));\n+    key.add(new DERValue(DER.INTEGER, getPrivateExponent()));\n+    key.add(new DERValue(DER.INTEGER, getPrimeP()));\n+    key.add(new DERValue(DER.INTEGER, getPrimeQ()));\n+    key.add(new DERValue(DER.INTEGER, getPrimeExponentP()));\n+    key.add(new DERValue(DER.INTEGER, getPrimeExponentQ()));\n+    key.add(new DERValue(DER.INTEGER, getCrtCoefficient()));\n+    DERValue pk = new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, key);\n+    ArrayList pki = new ArrayList(3);\n+    pki.add(new DERValue(DER.INTEGER, BigInteger.ZERO));\n+    ArrayList alg = new ArrayList(2);\n+    alg.add(new DERValue(DER.OBJECT_IDENTIFIER,\n+                         new OID(\"1.2.840.113549.1.1.1\")));\n+    alg.add(new DERValue(DER.NULL, null));\n+    pki.add(new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, alg));\n+    pki.add(new DERValue(DER.OCTET_STRING, pk.getEncoded()));\n+    encodedKey = new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, pki).getEncoded();\n+    return (byte[]) encodedKey.clone();\n+  }\n+}"}, {"sha": "502fcccbf0f719b02a636b146a600bafaeca0641", "filename": "libjava/gnu/java/security/provider/GnuRSAPublicKey.java", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuRSAPublicKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuRSAPublicKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuRSAPublicKey.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,109 @@\n+/* GnuRSAPublicKey.java -- GNU RSA public key.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.math.BigInteger;\n+import java.security.interfaces.RSAPublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.util.ArrayList;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERValue;\n+\n+class GnuRSAPublicKey implements RSAPublicKey\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private final RSAPublicKeySpec spec;\n+  private byte[] encodedKey;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public GnuRSAPublicKey(RSAPublicKeySpec spec)\n+  {\n+    this.spec = spec;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public BigInteger getModulus()\n+  {\n+    return spec.getModulus();\n+  }\n+\n+  public BigInteger getPublicExponent()\n+  {\n+    return spec.getPublicExponent();\n+  }\n+\n+  public String getAlgorithm()\n+  {\n+    return \"RSA\";\n+  }\n+\n+  public String getFormat()\n+  {\n+    return \"X.509\";\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encodedKey != null)\n+      return (byte[]) encodedKey.clone();\n+    ArrayList key = new ArrayList(2);\n+    key.add(new DERValue(DER.INTEGER, getModulus()));\n+    key.add(new DERValue(DER.INTEGER, getPublicExponent()));\n+    DERValue rsapk = new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, key);\n+    ArrayList alg = new ArrayList(2);\n+    alg.add(new DERValue(DER.OBJECT_IDENTIFIER,\n+                         new OID(\"1.2.840.113549.1.1.1\")));\n+    alg.add(new DERValue(DER.NULL, null));\n+    ArrayList spki = new ArrayList(2);\n+    spki.add(new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, alg));\n+    spki.add(new DERValue(DER.BIT_STRING, new BitString(rsapk.getEncoded())));\n+    encodedKey = new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, spki).getEncoded();\n+    return (byte[]) encodedKey.clone();\n+  }\n+}"}, {"sha": "c43d07adb7ad2f6fbad824c5fb3bb48558b14cde", "filename": "libjava/gnu/java/security/provider/MD2withRSA.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD2withRSA.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD2withRSA.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD2withRSA.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,54 @@\n+/* MD2withRSA.java -- MD2 with RSA encryption signatures.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+\n+public class MD2withRSA extends RSA\n+{\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public MD2withRSA() throws NoSuchAlgorithmException\n+  {\n+    super(MessageDigest.getInstance(\"MD2\"), DIGEST_ALGORITHM.getChild(2));\n+  }\n+}"}, {"sha": "86cd2bed55b7f39aca0e3c34a2f0a853e08e5c2d", "filename": "libjava/gnu/java/security/provider/MD4withRSA.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD4withRSA.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD4withRSA.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD4withRSA.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,54 @@\n+/* MD4withRSA.java -- MD4 with RSA encryption signatures.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+\n+public class MD4withRSA extends RSA\n+{\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public MD4withRSA() throws NoSuchAlgorithmException\n+  {\n+    super(MessageDigest.getInstance(\"MD4\"), DIGEST_ALGORITHM.getChild(4));\n+  }\n+}"}, {"sha": "ec8370def53c0ed2a0b3723859e4cf0e9e4a8afd", "filename": "libjava/gnu/java/security/provider/MD5withRSA.java", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD5withRSA.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD5withRSA.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FMD5withRSA.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,54 @@\n+/* MD5withRSA.java -- MD5 with RSA encryption signatures.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+\n+public class MD5withRSA extends RSA\n+{\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public MD5withRSA() throws NoSuchAlgorithmException\n+  {\n+    super(MessageDigest.getInstance(\"MD5\"), DIGEST_ALGORITHM.getChild(5));\n+  }\n+}"}, {"sha": "7d1d857a0497a7de1098fea707196ae2c2bc962e", "filename": "libjava/gnu/java/security/provider/PKIXCertPathValidatorImpl.java", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FPKIXCertPathValidatorImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FPKIXCertPathValidatorImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FPKIXCertPathValidatorImpl.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,689 @@\n+/* PKIXCertPathValidatorImpl.java -- PKIX certificate path validator.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.io.IOException;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Principal;\n+import java.security.PublicKey;\n+\n+import java.security.cert.*;\n+\n+import java.security.interfaces.DSAParams;\n+import java.security.interfaces.DSAPublicKey;\n+import java.security.spec.DSAParameterSpec;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import gnu.java.security.x509.GnuPKIExtension;\n+import gnu.java.security.x509.PolicyNodeImpl;\n+import gnu.java.security.x509.X509CertSelectorImpl;\n+import gnu.java.security.x509.X509CRLSelectorImpl;\n+import gnu.java.security.x509.ext.*;\n+import gnu.java.security.OID;\n+\n+/**\n+ * An implementation of the Public Key Infrastructure's X.509\n+ * certificate path validation algorithm.\n+ *\n+ * <p>See <a href=\"http://www.ietf.org/rfc/rfc3280.txt\">RFC 3280:\n+ * Internet X.509 Public Key Infrastructure Certificate and\n+ * Certificate Revocation List (CRL) Profile</a>.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class PKIXCertPathValidatorImpl extends CertPathValidatorSpi\n+{\n+\n+  // Constants.\n+  // -------------------------------------------------------------------------\n+\n+  private static final boolean DEBUG = false;\n+  private static void debug (String msg)\n+  {\n+    System.err.print (\">> PKIXCertPathValidatorImpl: \");\n+    System.err.println (msg);\n+  }\n+\n+  public static final String ANY_POLICY = \"2.5.29.32.0\";\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public PKIXCertPathValidatorImpl()\n+  {\n+    super();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public CertPathValidatorResult engineValidate(CertPath path,\n+                                                CertPathParameters params)\n+    throws CertPathValidatorException, InvalidAlgorithmParameterException\n+  {\n+    if (!(params instanceof PKIXParameters))\n+      throw new InvalidAlgorithmParameterException(\"not a PKIXParameters object\");\n+\n+    // First check if the certificate path is valid.\n+    //\n+    // This means that:\n+    //\n+    //   (a)  for all x in {1, ..., n-1}, the subject of certificate x is\n+    //        the issuer of certificate x+1;\n+    //\n+    //   (b)  for all x in {1, ..., n}, the certificate was valid at the\n+    //        time in question.\n+    //\n+    // Because this is the X.509 algorithm, we also check if all\n+    // cerificates are of type X509Certificate.\n+\n+    PolicyNodeImpl rootNode = new PolicyNodeImpl();\n+    Set initPolicies = ((PKIXParameters) params).getInitialPolicies();\n+    rootNode.setValidPolicy(ANY_POLICY);\n+    rootNode.setCritical(false);\n+    rootNode.setDepth(0);\n+    if (initPolicies != null)\n+      rootNode.addAllExpectedPolicies(initPolicies);\n+    else\n+      rootNode.addExpectedPolicy(ANY_POLICY);\n+    List checks = ((PKIXParameters) params).getCertPathCheckers();\n+    List l = path.getCertificates();\n+    if (l == null || l.size() == 0)\n+      throw new CertPathValidatorException();\n+    X509Certificate[] p = null;\n+    try\n+      {\n+        p = (X509Certificate[]) l.toArray(new X509Certificate[l.size()]);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new CertPathValidatorException(\"invalid certificate path\");\n+      }\n+\n+    String sigProvider = ((PKIXParameters) params).getSigProvider();\n+    PublicKey prevKey = null;\n+    Date now = ((PKIXParameters) params).getDate();\n+    if (now == null)\n+      now = new Date();\n+    LinkedList policyConstraints = new LinkedList();\n+    for (int i = p.length - 1; i >= 0; i--)\n+      {\n+        try\n+          {\n+            p[i].checkValidity(now);\n+          }\n+        catch (CertificateException ce)\n+          {\n+            throw new CertPathValidatorException(ce.toString());\n+          }\n+        Set uce = getCritExts(p[i]);\n+        for (Iterator check = checks.iterator(); check.hasNext(); )\n+          {\n+            try\n+              {\n+                ((PKIXCertPathChecker) check.next()).check(p[i], uce);\n+              }\n+            catch (Exception x)\n+              {\n+              }\n+          }\n+\n+        PolicyConstraint constr = null;\n+        if (p[i] instanceof GnuPKIExtension)\n+          {\n+            Extension pcx =\n+              ((GnuPKIExtension) p[i]).getExtension (PolicyConstraint.ID);\n+            if (pcx != null)\n+              constr = (PolicyConstraint) pcx.getValue();\n+          }\n+        else\n+          {\n+            byte[] pcx = p[i].getExtensionValue (PolicyConstraint.ID.toString());\n+            if (pcx != null)\n+              {\n+                try\n+                  {\n+                    constr = new PolicyConstraint (pcx);\n+                  }\n+                catch (Exception x)\n+                  {\n+                  }\n+              }\n+          }\n+        if (constr != null && constr.getRequireExplicitPolicy() >= 0)\n+          {\n+            policyConstraints.add (new int[]\n+              { p.length-i, constr.getRequireExplicitPolicy() });\n+          }\n+\n+        updatePolicyTree(p[i], rootNode, p.length-i, (PKIXParameters) params,\n+                         checkExplicitPolicy (p.length-i, policyConstraints));\n+\n+        // The rest of the tests involve this cert's relationship with the\n+        // next in the path. If this cert is the end entity, we can stop.\n+        if (i == 0)\n+          break;\n+\n+        basicSanity(p, i);\n+        PublicKey pubKey = null;\n+        try\n+          {\n+            pubKey = p[i].getPublicKey();\n+            if (pubKey instanceof DSAPublicKey)\n+              {\n+                DSAParams dsa = ((DSAPublicKey) pubKey).getParams();\n+                // If the DSA public key is missing its parameters, use those\n+                // from the previous cert's key.\n+                if (dsa == null || dsa.getP() == null || dsa.getG() == null\n+                      || dsa.getQ() == null)\n+                  {\n+                    if (prevKey == null)\n+                      throw new InvalidKeyException(\"DSA keys not chainable\");\n+                    if (!(prevKey instanceof DSAPublicKey))\n+                      throw new InvalidKeyException(\"DSA keys not chainable\");\n+                    dsa = ((DSAPublicKey) prevKey).getParams();\n+                    pubKey = new GnuDSAPublicKey(((DSAPublicKey) pubKey).getY(),\n+                      dsa.getP(), dsa.getQ(), dsa.getG());\n+                  }\n+              }\n+            if (sigProvider == null)\n+              p[i-1].verify(pubKey);\n+            else\n+              p[i-1].verify(pubKey, sigProvider);\n+            prevKey = pubKey;\n+          }\n+        catch (Exception e)\n+          {\n+            throw new CertPathValidatorException(e.toString());\n+          }\n+        if (!p[i].getSubjectDN().equals(p[i-1].getIssuerDN()))\n+          throw new CertPathValidatorException(\"issuer DN mismatch\");\n+        boolean[] issuerUid = p[i-1].getIssuerUniqueID();\n+        boolean[] subjectUid = p[i].getSubjectUniqueID();\n+        if (issuerUid != null && subjectUid != null)\n+          if (!Arrays.equals(issuerUid, subjectUid))\n+            throw new CertPathValidatorException(\"UID mismatch\");\n+\n+        // Check the certificate against the revocation lists.\n+        if (((PKIXParameters) params).isRevocationEnabled())\n+          {\n+            X509CRLSelectorImpl selector = new X509CRLSelectorImpl();\n+            try\n+              {\n+                selector.addIssuerName(p[i].getSubjectDN());\n+              }\n+            catch (IOException ioe)\n+              {\n+                throw new CertPathValidatorException(\"error selecting CRLs\");\n+              }\n+            List certStores = ((PKIXParameters) params).getCertStores();\n+            List crls = new LinkedList();\n+            for (Iterator it = certStores.iterator(); it.hasNext(); )\n+              {\n+                CertStore cs = (CertStore) it.next();\n+                try\n+                  {\n+                    Collection c = cs.getCRLs(selector);\n+                    crls.addAll(c);\n+                  }\n+                catch (CertStoreException cse)\n+                  {\n+                  }\n+              }\n+            if (crls.isEmpty())\n+              throw new CertPathValidatorException(\"no CRLs for issuer\");\n+            boolean certOk = false;\n+            for (Iterator it = crls.iterator(); it.hasNext(); )\n+              {\n+                CRL crl = (CRL) it.next();\n+                if (!(crl instanceof X509CRL))\n+                  continue;\n+                X509CRL xcrl = (X509CRL) crl;\n+                if (!checkCRL(xcrl, p, now, p[i], pubKey, certStores))\n+                  continue;\n+                if (xcrl.isRevoked(p[i-1]))\n+                  throw new CertPathValidatorException(\"certificate is revoked\");\n+                else\n+                  certOk = true;\n+              }\n+            if (!certOk)\n+              throw new CertPathValidatorException(\"certificate's validity could not be determined\");\n+          }\n+      }\n+    rootNode.setReadOnly();\n+\n+    // Now ensure that the first certificate in the chain was issued\n+    // by a trust anchor.\n+    Exception cause = null;\n+    Set anchors = ((PKIXParameters) params).getTrustAnchors();\n+    for (Iterator i = anchors.iterator(); i.hasNext(); )\n+      {\n+        TrustAnchor anchor = (TrustAnchor) i.next();\n+        X509Certificate anchorCert = null;\n+        PublicKey anchorKey = null;\n+        if (anchor.getTrustedCert() != null)\n+          {\n+            anchorCert = anchor.getTrustedCert();\n+            anchorKey = anchorCert.getPublicKey();\n+          }\n+        else\n+          anchorKey = anchor.getCAPublicKey();\n+        if (anchorKey == null)\n+          continue;\n+        try\n+          {\n+            if (anchorCert == null)\n+              anchorCert.checkValidity(now);\n+            p[p.length-1].verify(anchorKey);\n+            if (anchorCert != null && anchorCert.getBasicConstraints() >= 0\n+                && anchorCert.getBasicConstraints() < p.length)\n+              continue;\n+\n+            if (((PKIXParameters) params).isRevocationEnabled())\n+              {\n+                X509CRLSelectorImpl selector = new X509CRLSelectorImpl();\n+                if (anchorCert != null)\n+                  try\n+                    {\n+                      selector.addIssuerName(anchorCert.getSubjectDN());\n+                    }\n+                  catch (IOException ioe)\n+                    {\n+                    }\n+                else\n+                  selector.addIssuerName(anchor.getCAName());\n+                List certStores = ((PKIXParameters) params).getCertStores();\n+                List crls = new LinkedList();\n+                for (Iterator it = certStores.iterator(); it.hasNext(); )\n+                  {\n+                    CertStore cs = (CertStore) it.next();\n+                    try\n+                      {\n+                        Collection c = cs.getCRLs(selector);\n+                        crls.addAll(c);\n+                      }\n+                    catch (CertStoreException cse)\n+                      {\n+                      }\n+                  }\n+                if (crls.isEmpty())\n+                  continue;\n+                for (Iterator it = crls.iterator(); it.hasNext(); )\n+                  {\n+                    CRL crl = (CRL) it.next();\n+                    if (!(crl instanceof X509CRL))\n+                      continue;\n+                    X509CRL xcrl = (X509CRL) crl;\n+                    try\n+                      {\n+                        xcrl.verify(anchorKey);\n+                      }\n+                    catch (Exception x)\n+                      {\n+                        continue;\n+                      }\n+                    Date nextUpdate = xcrl.getNextUpdate();\n+                    if (nextUpdate != null && nextUpdate.compareTo(now) < 0)\n+                      continue;\n+                    if (xcrl.isRevoked(p[p.length-1]))\n+                      throw new CertPathValidatorException(\"certificate is revoked\");\n+                  }\n+              }\n+\n+            // The chain is valid; return the result.\n+            return new PKIXCertPathValidatorResult(anchor, rootNode,\n+                                                   p[0].getPublicKey());\n+          }\n+        catch (Exception ignored)\n+          {\n+            cause = ignored;\n+            continue;\n+          }\n+      }\n+\n+    // The path is not valid.\n+    CertPathValidatorException cpve =\n+      new CertPathValidatorException(\"path validation failed\");\n+    if (cause != null)\n+      cpve.initCause (cause);\n+    throw cpve;\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Check if a given CRL is acceptable for checking the revocation status\n+   * of certificates in the path being checked.\n+   *\n+   * <p>The CRL is accepted iff:</p>\n+   *\n+   * <ol>\n+   * <li>The <i>nextUpdate</i> field (if present) is in the future.</li>\n+   * <li>The CRL does not contain any unsupported critical extensions.</li>\n+   * <li>The CRL is signed by one of the certificates in the path, or,</li>\n+   * <li>The CRL is signed by the given public key and was issued by the\n+   * public key's subject, or,</li>\n+   * <li>The CRL is signed by a certificate in the given cert stores, and\n+   * that cert is signed by one of the certificates in the path.</li>\n+   * </ol>\n+   *\n+   * @param crl The CRL being checked.\n+   * @param path The path this CRL is being checked against.\n+   * @param now The value to use as 'now'.\n+   * @param pubKeySubject The subject of the public key.\n+   * @param pubKey The public key to check.\n+   * @return True if the CRL is acceptable.\n+   */\n+  private static boolean checkCRL(X509CRL crl, X509Certificate[] path, Date now,\n+                                  X509Certificate pubKeyCert, PublicKey pubKey,\n+                                  List certStores)\n+  {\n+    Date nextUpdate = crl.getNextUpdate();\n+    if (nextUpdate != null && nextUpdate.compareTo(now) < 0)\n+      return false;\n+    if (crl.hasUnsupportedCriticalExtension())\n+      return false;\n+    for (int i = 0; i < path.length; i++)\n+      {\n+        if (!path[i].getSubjectDN().equals(crl.getIssuerDN()))\n+          continue;\n+        boolean[] keyUsage = path[i].getKeyUsage();\n+        if (keyUsage != null)\n+          {\n+            if (!keyUsage[KeyUsage.CRL_SIGN])\n+              continue;\n+          }\n+        try\n+          {\n+            crl.verify(path[i].getPublicKey());\n+            return true;\n+          }\n+        catch (Exception x)\n+          {\n+          }\n+      }\n+    if (crl.getIssuerDN().equals(pubKeyCert.getSubjectDN()))\n+      {\n+        try\n+          {\n+            boolean[] keyUsage = pubKeyCert.getKeyUsage();\n+            if (keyUsage != null)\n+              {\n+                if (!keyUsage[KeyUsage.CRL_SIGN])\n+                  throw new Exception();\n+              }\n+            crl.verify(pubKey);\n+            return true;\n+          }\n+        catch (Exception x)\n+          {\n+          }\n+      }\n+    try\n+      {\n+        X509CertSelectorImpl select = new X509CertSelectorImpl();\n+        select.addSubjectName(crl.getIssuerDN());\n+        List certs = new LinkedList();\n+        for (Iterator it = certStores.iterator(); it.hasNext(); )\n+          {\n+            CertStore cs = (CertStore) it.next();\n+            try\n+              {\n+                certs.addAll(cs.getCertificates(select));\n+              }\n+            catch (CertStoreException cse)\n+              {\n+              }\n+          }\n+        for (Iterator it = certs.iterator(); it.hasNext(); )\n+          {\n+            X509Certificate c = (X509Certificate) it.next();\n+            for (int i = 0; i < path.length; i++)\n+              {\n+                if (!c.getIssuerDN().equals(path[i].getSubjectDN()))\n+                  continue;\n+                boolean[] keyUsage = c.getKeyUsage();\n+                if (keyUsage != null)\n+                  {\n+                    if (!keyUsage[KeyUsage.CRL_SIGN])\n+                      continue;\n+                  }\n+                try\n+                  {\n+                    c.verify(path[i].getPublicKey());\n+                    crl.verify(c.getPublicKey());\n+                    return true;\n+                  }\n+                catch (Exception x)\n+                  {\n+                  }\n+              }\n+            if (c.getIssuerDN().equals(pubKeyCert.getSubjectDN()))\n+              {\n+                c.verify(pubKey);\n+                crl.verify(c.getPublicKey());\n+              }\n+          }\n+      }\n+    catch (Exception x)\n+      {\n+      }\n+    return false;\n+  }\n+\n+  private static Set getCritExts(X509Certificate cert)\n+  {\n+    HashSet s = new HashSet();\n+    if (cert instanceof GnuPKIExtension)\n+      {\n+        Collection exts = ((GnuPKIExtension) cert).getExtensions();\n+        for (Iterator it = exts.iterator(); it.hasNext(); )\n+          {\n+            Extension ext = (Extension) it.next();\n+            if (ext.isCritical() && !ext.isSupported())\n+              s.add(ext.getOid().toString());\n+          }\n+      }\n+    else\n+      s.addAll(cert.getCriticalExtensionOIDs());\n+    return s;\n+  }\n+\n+  /**\n+   * Perform a basic sanity check on the CA certificate at <code>index</code>.\n+   */\n+  private static void basicSanity(X509Certificate[] path, int index)\n+    throws CertPathValidatorException\n+  {\n+    X509Certificate cert = path[index];\n+    int pathLen = 0;\n+    for (int i = index - 1; i > 0; i--)\n+      {\n+        if (!path[i].getIssuerDN().equals(path[i].getSubjectDN()))\n+          pathLen++;\n+      }\n+    Extension e = null;\n+    if (cert instanceof GnuPKIExtension)\n+      {\n+        e = ((GnuPKIExtension) cert).getExtension(BasicConstraints.ID);\n+      }\n+    else\n+      {\n+        try\n+          {\n+            e = new Extension(cert.getExtensionValue(BasicConstraints.ID.toString()));\n+          }\n+        catch (Exception x)\n+          {\n+          }\n+      }\n+    if (e == null)\n+      throw new CertPathValidatorException(\"no basicConstraints\");\n+    BasicConstraints bc = (BasicConstraints) e.getValue();\n+    if (!bc.isCA())\n+      throw new CertPathValidatorException(\"certificate cannot be used to verify signatures\");\n+    if (bc.getPathLengthConstraint() >= 0 && bc.getPathLengthConstraint() < pathLen)\n+      throw new CertPathValidatorException(\"path is too long\");\n+\n+    boolean[] keyUsage = cert.getKeyUsage();\n+    if (keyUsage != null)\n+      {\n+        if (!keyUsage[KeyUsage.KEY_CERT_SIGN])\n+          throw new CertPathValidatorException(\"certificate cannot be used to sign certificates\");\n+      }\n+  }\n+\n+  private static void updatePolicyTree(X509Certificate cert, PolicyNodeImpl root,\n+                                       int depth, PKIXParameters params,\n+                                       boolean explicitPolicy)\n+    throws CertPathValidatorException\n+  {\n+    if (DEBUG) debug(\"updatePolicyTree depth == \" + depth);\n+    Set nodes = new HashSet();\n+    LinkedList stack = new LinkedList();\n+    Iterator current = null;\n+    stack.addLast(Collections.singleton(root).iterator());\n+    do\n+      {\n+        current = (Iterator) stack.removeLast();\n+        while (current.hasNext())\n+          {\n+            PolicyNodeImpl p = (PolicyNodeImpl) current.next();\n+            if (DEBUG) debug(\"visiting node == \" + p);\n+            if (p.getDepth() == depth - 1)\n+              {\n+                if (DEBUG) debug(\"added node\");\n+                nodes.add(p);\n+              }\n+            else\n+              {\n+                if (DEBUG) debug(\"skipped node\");\n+                stack.addLast(current);\n+                current = p.getChildren();\n+              }\n+          }\n+      }\n+    while (!stack.isEmpty());\n+\n+    Extension e = null;\n+    CertificatePolicies policies = null;\n+    List qualifierInfos = null;\n+    if (cert instanceof GnuPKIExtension)\n+      {\n+        e = ((GnuPKIExtension) cert).getExtension(CertificatePolicies.ID);\n+        if (e != null)\n+          policies = (CertificatePolicies) e.getValue();\n+      }\n+\n+    List cp = null;\n+    if (policies != null)\n+      cp = policies.getPolicies();\n+    else\n+      cp = Collections.EMPTY_LIST;\n+    boolean match = false;\n+    if (DEBUG) debug(\"nodes are == \" + nodes);\n+    if (DEBUG) debug(\"cert policies are == \" + cp);\n+    for (Iterator it = nodes.iterator(); it.hasNext(); )\n+      {\n+        PolicyNodeImpl parent = (PolicyNodeImpl) it.next();\n+        if (DEBUG) debug(\"adding policies to \" + parent);\n+        for (Iterator it2 = cp.iterator(); it2.hasNext(); )\n+          {\n+            OID policy = (OID) it2.next();\n+            if (DEBUG) debug(\"trying to add policy == \" + policy);\n+            if (policy.toString().equals(ANY_POLICY) &&\n+                params.isAnyPolicyInhibited())\n+              continue;\n+            PolicyNodeImpl child = new PolicyNodeImpl();\n+            child.setValidPolicy(policy.toString());\n+            child.addExpectedPolicy(policy.toString());\n+            if (parent.getExpectedPolicies().contains(policy.toString()))\n+              {\n+                parent.addChild(child);\n+                match = true;\n+              }\n+            else if (parent.getExpectedPolicies().contains(ANY_POLICY))\n+              {\n+                parent.addChild(child);\n+                match = true;\n+              }\n+            else if (ANY_POLICY.equals (policy.toString()))\n+              {\n+                parent.addChild (child);\n+                match = true;\n+              }\n+            if (match && policies != null)\n+              {\n+                List qualifiers = policies.getPolicyQualifierInfos (policy);\n+                if (qualifiers != null)\n+                  child.addAllPolicyQualifiers (qualifiers);\n+              }\n+          }\n+      }\n+    if (!match && (params.isExplicitPolicyRequired() || explicitPolicy))\n+      throw new CertPathValidatorException(\"policy tree building failed\");\n+  }\n+\n+  private boolean checkExplicitPolicy (int depth, List explicitPolicies)\n+  {\n+    if (DEBUG) debug (\"checkExplicitPolicy depth=\" + depth);\n+    for (Iterator it = explicitPolicies.iterator(); it.hasNext(); )\n+      {\n+        int[] i = (int[]) it.next();\n+        int caDepth = i[0];\n+        int limit = i[1];\n+        if (DEBUG) debug (\"  caDepth=\" + caDepth + \" limit=\" + limit);\n+        if (depth - caDepth >= limit)\n+          return true;\n+      }\n+    return false;\n+  }\n+}"}, {"sha": "5afa8b740655aaee6058febac8a181d97e8a7428", "filename": "libjava/gnu/java/security/provider/RSA.java", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FRSA.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FRSA.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FRSA.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,314 @@\n+/* RSA.java -- RSA PKCS#1 signatures.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureException;\n+import java.security.SignatureSpi;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+\n+import java.util.ArrayList;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+public abstract class RSA extends SignatureSpi implements Cloneable\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * digestAlgorithm OBJECT IDENTIFIER ::=\n+   *   { iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) }\n+   */\n+  protected static final OID DIGEST_ALGORITHM = new OID(\"1.2.840.113549.2\");\n+\n+  protected final OID digestAlgorithm;\n+  protected final MessageDigest md;\n+  protected RSAPrivateKey signerKey;\n+  protected RSAPublicKey verifierKey;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  protected RSA(MessageDigest md, OID digestAlgorithm)\n+  {\n+    super();\n+    this.md = md;\n+    this.digestAlgorithm = digestAlgorithm;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public Object clone() throws CloneNotSupportedException\n+  {\n+    return super.clone();\n+  }\n+\n+  protected Object engineGetParameter(String param)\n+  {\n+    throw new UnsupportedOperationException(\"deprecated\");\n+  }\n+\n+  protected void engineSetParameter(String param, Object value)\n+  {\n+    throw new UnsupportedOperationException(\"deprecated\");\n+  }\n+\n+  protected void engineInitSign(PrivateKey privateKey)\n+    throws InvalidKeyException\n+  {\n+    if (!(privateKey instanceof RSAPrivateKey))\n+      throw new InvalidKeyException();\n+    verifierKey = null;\n+    signerKey = (RSAPrivateKey) privateKey;\n+  }\n+\n+  protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n+    throws InvalidKeyException\n+  {\n+    // This class does not need random bytes.\n+    engineInitSign(privateKey);\n+  }\n+\n+  protected void engineInitVerify(PublicKey publicKey)\n+    throws InvalidKeyException\n+  {\n+    if (!(publicKey instanceof RSAPublicKey))\n+      throw new InvalidKeyException();\n+    signerKey = null;\n+    verifierKey = (RSAPublicKey) publicKey;\n+  }\n+\n+  protected void engineUpdate(byte b) throws SignatureException\n+  {\n+    if (signerKey == null && verifierKey == null)\n+      throw new SignatureException(\"not initialized\");\n+    md.update(b);\n+  }\n+\n+  protected void engineUpdate(byte[] buf, int off, int len)\n+    throws SignatureException\n+  {\n+    if (signerKey == null && verifierKey == null)\n+      throw new SignatureException(\"not initialized\");\n+    md.update(buf, off, len);\n+  }\n+\n+  protected byte[] engineSign() throws SignatureException\n+  {\n+    if (signerKey == null)\n+      throw new SignatureException(\"not initialized for signing\");\n+    //\n+    // The signature will be the RSA encrypted BER representation of\n+    // the following:\n+    //\n+    //   DigestInfo ::= SEQUENCE {\n+    //     digestAlgorithm  DigestAlgorithmIdentifier,\n+    //     digest           Digest }\n+    //\n+    //   DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n+    //\n+    //   Digest ::= OCTET STRING\n+    //\n+    ArrayList digestAlg = new ArrayList(2);\n+    digestAlg.add(new DERValue(DER.OBJECT_IDENTIFIER, digestAlgorithm));\n+    digestAlg.add(new DERValue(DER.NULL, null));\n+    ArrayList digestInfo = new ArrayList(2);\n+    digestInfo.add(new DERValue(DER.SEQUENCE, digestAlg));\n+    digestInfo.add(new DERValue(DER.OCTET_STRING, md.digest()));\n+    ByteArrayOutputStream out = new ByteArrayOutputStream();\n+    try\n+      {\n+        DERWriter.write(out, new DERValue(DER.SEQUENCE, digestInfo));\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new SignatureException(ioe.toString());\n+      }\n+    byte[] buf = out.toByteArray();\n+    md.reset();\n+\n+    // k = octect length of the modulus.\n+    int k = signerKey.getModulus().bitLength();\n+    k = (k >>> 3) + ((k & 7) == 0 ? 0 : 1);\n+    if (buf.length < k - 3)\n+      {\n+        throw new SignatureException(\"RSA modulus too small\");\n+      }\n+    byte[] d = new byte[k];\n+\n+    // Padding type 1:\n+    //     00 | 01 | FF | ... | FF | 00 | D\n+    d[1] = 0x01;\n+    for (int i = 2; i < k - buf.length - 1; i++)\n+      d[i] = (byte) 0xFF;\n+    System.arraycopy(buf, 0, d, k - buf.length, buf.length);\n+\n+    BigInteger eb = new BigInteger(d);\n+\n+    byte[] ed = eb.modPow(signerKey.getPrivateExponent(),\n+                          signerKey.getModulus()).toByteArray();\n+\n+    // Ensure output is k octets long.\n+    if (ed.length < k)\n+      {\n+        byte[] b = new byte[k];\n+        System.arraycopy(eb, 0, b, k - ed.length, ed.length);\n+        ed = b;\n+      }\n+    else if (ed.length > k)\n+      {\n+        if (ed.length != k + 1)\n+          {\n+            throw new SignatureException(\"modPow result is larger than the modulus\");\n+          }\n+        // Maybe an extra 00 octect.\n+        byte[] b = new byte[k];\n+        System.arraycopy(ed, 1, b, 0, k);\n+        ed = b;\n+      }\n+\n+    return ed;\n+  }\n+\n+  protected int engineSign(byte[] out, int off, int len)\n+    throws SignatureException\n+  {\n+    if (out == null || off < 0 || len < 0 || off+len > out.length)\n+      throw new SignatureException(\"illegal output argument\");\n+    byte[] result = engineSign();\n+    if (result.length > len)\n+      throw new SignatureException(\"not enough space for signature\");\n+    System.arraycopy(result, 0, out, off, result.length);\n+    return result.length;\n+  }\n+\n+  protected boolean engineVerify(byte[] sig) throws SignatureException\n+  {\n+    if (verifierKey == null)\n+      throw new SignatureException(\"not initialized for verifying\");\n+    if (sig == null)\n+      throw new SignatureException(\"no signature specified\");\n+    int k = verifierKey.getModulus().bitLength();\n+    k = (k >>> 3) + ((k & 7) == 0 ? 0 : 1);\n+    if (sig.length != k)\n+      throw new SignatureException(\"signature is the wrong size (expecting \"\n+                                   + k + \" bytes, got \" + sig.length + \")\");\n+    BigInteger ed = new BigInteger(1, sig);\n+    byte[] eb = ed.modPow(verifierKey.getPublicExponent(),\n+                          verifierKey.getModulus()).toByteArray();\n+\n+    int i = 0;\n+    if (eb[0] == 0x00)\n+      {\n+        for (i = 1; i < eb.length && eb[i] == 0x00; i++);\n+        if (i == 1)\n+          throw new SignatureException(\"wrong RSA padding\");\n+        i--;\n+      }\n+    else if (eb[0] == 0x01)\n+      {\n+        for (i = 1; i < eb.length && eb[i] != 0x00; i++)\n+          if (eb[i] != (byte) 0xFF)\n+            throw new IllegalArgumentException(\"wrong RSA padding\");\n+      }\n+    else\n+      throw new SignatureException(\"wrong RSA padding type\");\n+\n+    byte[] d = new byte[eb.length-i-1];\n+    System.arraycopy(eb, i+1, d, 0, eb.length-i-1);\n+\n+    DERReader der = new DERReader(d);\n+    try\n+      {\n+        DERValue val = der.read();\n+        if (val.getTag() != DER.SEQUENCE)\n+          throw new SignatureException(\"failed to parse DigestInfo\");\n+        val = der.read();\n+        if (val.getTag() != DER.SEQUENCE)\n+          throw new SignatureException(\"failed to parse DigestAlgorithmIdentifier\");\n+        boolean sequenceIsBer = val.getLength() == 0;\n+        val = der.read();\n+        if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+          throw new SignatureException(\"failed to parse object identifier\");\n+        if (!val.getValue().equals(digestAlgorithm))\n+          throw new SignatureException(\"digest algorithms do not match\");\n+        val = der.read();\n+        // We should never see parameters here, since they are never used.\n+        if (val.getTag() != DER.NULL)\n+          throw new SignatureException(\"cannot handle digest parameters\");\n+        if (sequenceIsBer)\n+          der.skip(1); // end-of-sequence byte.\n+        val = der.read();\n+        if (val.getTag() != DER.OCTET_STRING)\n+          throw new SignatureException(\"failed to parse Digest\");\n+        return MessageDigest.isEqual(md.digest(), (byte[]) val.getValue());\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new SignatureException(ioe.toString());\n+      }\n+  }\n+\n+  protected boolean engineVerify(byte[] sig, int off, int len)\n+    throws SignatureException\n+  {\n+    if (sig == null || off < 0 || len < 0 || off+len > sig.length)\n+      throw new SignatureException(\"illegal parameter\");\n+    byte[] buf = new byte[len];\n+    System.arraycopy(sig, off, buf, 0, len);\n+    return engineVerify(buf);\n+  }\n+}"}, {"sha": "33c8c2287e4813ed2802bca5b0fc44c9076336cb", "filename": "libjava/gnu/java/security/provider/RSAKeyFactory.java", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FRSAKeyFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FRSAKeyFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FRSAKeyFactory.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,181 @@\n+/* RSAKeyFactory.java -- RSA key factory.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactorySpi;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.RSAPrivateCrtKeySpec;\n+import java.security.spec.RSAPrivateKeySpec;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+public class RSAKeyFactory extends KeyFactorySpi\n+{\n+\n+  // Default constructor.\n+  // -------------------------------------------------------------------------\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  protected PrivateKey engineGeneratePrivate(KeySpec spec)\n+    throws InvalidKeySpecException\n+  {\n+    if (spec instanceof RSAPrivateCrtKeySpec)\n+      {\n+        return new GnuRSAPrivateKey((RSAPrivateCrtKeySpec) spec);\n+      }\n+    if (spec instanceof RSAPrivateKeySpec)\n+      {\n+        return new GnuRSAPrivateKey(new RSAPrivateCrtKeySpec(\n+          ((RSAPrivateKeySpec) spec).getModulus(), null,\n+          ((RSAPrivateKeySpec) spec).getPrivateExponent(), null,\n+          null, null, null, null));\n+      }\n+    if (spec instanceof PKCS8EncodedKeySpec)\n+      {\n+        EncodedKeyFactory ekf = new EncodedKeyFactory();\n+        PrivateKey pk = ekf.engineGeneratePrivate(spec);\n+        if (pk instanceof RSAPrivateKey)\n+          return pk;\n+      }\n+    throw new InvalidKeySpecException();\n+  }\n+\n+  protected PublicKey engineGeneratePublic(KeySpec spec)\n+    throws InvalidKeySpecException\n+  {\n+    if (spec instanceof RSAPublicKeySpec)\n+      {\n+        return new GnuRSAPublicKey((RSAPublicKeySpec) spec);\n+      }\n+    if (spec instanceof X509EncodedKeySpec)\n+      {\n+        EncodedKeyFactory ekf = new EncodedKeyFactory();\n+        PublicKey pk = ekf.engineGeneratePublic(spec);\n+        if (pk instanceof RSAPublicKey)\n+          return pk;\n+      }\n+    throw new InvalidKeySpecException();\n+  }\n+\n+  protected KeySpec engineGetKeySpec(Key key, Class keySpec)\n+    throws InvalidKeySpecException\n+  {\n+    if (keySpec.isAssignableFrom(RSAPrivateCrtKeySpec.class)\n+        && (key instanceof RSAPrivateCrtKey))\n+      {\n+        return new RSAPrivateCrtKeySpec(\n+          ((RSAPrivateCrtKey) key).getModulus(),\n+          ((RSAPrivateCrtKey) key).getPublicExponent(),\n+          ((RSAPrivateCrtKey) key).getPrivateExponent(),\n+          ((RSAPrivateCrtKey) key).getPrimeP(),\n+          ((RSAPrivateCrtKey) key).getPrimeQ(),\n+          ((RSAPrivateCrtKey) key).getPrimeExponentP(),\n+          ((RSAPrivateCrtKey) key).getPrimeExponentQ(),\n+          ((RSAPrivateCrtKey) key).getCrtCoefficient());\n+      }\n+    if (keySpec.isAssignableFrom(RSAPrivateKeySpec.class)\n+        && (key instanceof RSAPrivateKey))\n+      {\n+        return new RSAPrivateKeySpec(\n+          ((RSAPrivateCrtKey) key).getModulus(),\n+          ((RSAPrivateCrtKey) key).getPrivateExponent());\n+      }\n+    if (keySpec.isAssignableFrom(RSAPublicKeySpec.class)\n+        && (key instanceof RSAPublicKey))\n+      {\n+        return new RSAPublicKeySpec(\n+          ((RSAPrivateCrtKey) key).getModulus(),\n+          ((RSAPrivateCrtKey) key).getPublicExponent());\n+      }\n+    if (keySpec.isAssignableFrom(PKCS8EncodedKeySpec.class)\n+        && key.getFormat().equalsIgnoreCase(\"PKCS#8\"))\n+      {\n+        return new PKCS8EncodedKeySpec(key.getEncoded());\n+      }\n+    if (keySpec.isAssignableFrom(X509EncodedKeySpec.class)\n+        && key.getFormat().equalsIgnoreCase(\"X.509\"))\n+      {\n+        return new X509EncodedKeySpec(key.getEncoded());\n+      }\n+    throw new InvalidKeySpecException();\n+  }\n+\n+  protected Key engineTranslateKey(Key key) throws InvalidKeyException\n+  {\n+    if (key instanceof RSAPrivateCrtKey)\n+      {\n+        return new GnuRSAPrivateKey(new RSAPrivateCrtKeySpec(\n+          ((RSAPrivateCrtKey) key).getModulus(),\n+          ((RSAPrivateCrtKey) key).getPublicExponent(),\n+          ((RSAPrivateCrtKey) key).getPrivateExponent(),\n+          ((RSAPrivateCrtKey) key).getPrimeP(),\n+          ((RSAPrivateCrtKey) key).getPrimeQ(),\n+          ((RSAPrivateCrtKey) key).getPrimeExponentP(),\n+          ((RSAPrivateCrtKey) key).getPrimeExponentQ(),\n+          ((RSAPrivateCrtKey) key).getCrtCoefficient()));\n+      }\n+    if (key instanceof RSAPrivateKey)\n+      {\n+        return new GnuRSAPrivateKey(new RSAPrivateCrtKeySpec(\n+          ((RSAPrivateKey) key).getModulus(), null,\n+          ((RSAPrivateKey) key).getPrivateExponent(), null,\n+          null, null, null, null));\n+      }\n+    if (key instanceof RSAPublicKey)\n+      {\n+        return new GnuRSAPublicKey(new RSAPublicKeySpec(\n+          ((RSAPrivateCrtKey) key).getModulus(),\n+          ((RSAPrivateCrtKey) key).getPublicExponent()));\n+      }\n+    throw new InvalidKeyException();\n+  }\n+}"}, {"sha": "64e93f9b0d883aa24b6b0a699f62104c71d6dc7c", "filename": "libjava/gnu/java/security/provider/SHA1withRSA.java", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FSHA1withRSA.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FSHA1withRSA.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FSHA1withRSA.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,61 @@\n+/* SHA1withRSA.java -- SHA-1 with RSA encryption signatures.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+\n+import gnu.java.security.OID;\n+\n+public class SHA1withRSA extends RSA\n+{\n+\n+  // Constant.\n+  // -------------------------------------------------------------------------\n+\n+  private static final OID SHA1 = new OID(\"1.3.14.3.2.26\");\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public SHA1withRSA() throws NoSuchAlgorithmException\n+  {\n+    super(MessageDigest.getInstance(\"SHA-160\"), SHA1);\n+  }\n+}"}, {"sha": "753300651b99add685b9280d40aff639f5383d14", "filename": "libjava/gnu/java/security/provider/X509CertificateFactory.java", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FX509CertificateFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FX509CertificateFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FX509CertificateFactory.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -44,16 +44,21 @@\n import java.io.IOException;\n \n import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n import java.security.cert.CertificateException;\n import java.security.cert.CertificateFactorySpi;\n+import java.security.cert.CertPath;\n import java.security.cert.CRL;\n import java.security.cert.CRLException;\n \n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.LinkedList;\n+import java.util.List;\n \n import gnu.java.io.Base64InputStream;\n import gnu.java.security.x509.X509Certificate;\n+import gnu.java.security.x509.X509CertPath;\n import gnu.java.security.x509.X509CRL;\n \n public class X509CertificateFactory extends CertificateFactorySpi\n@@ -87,7 +92,9 @@ public Certificate engineGenerateCertificate(InputStream inStream)\n       }\n     catch (IOException ioe)\n       {\n-        throw new CertificateException(ioe.toString());\n+        CertificateException ce = new CertificateException(ioe.getMessage());\n+        ce.initCause (ioe);\n+        throw ce;\n       }\n   }\n \n@@ -107,7 +114,9 @@ public Collection engineGenerateCertificates(InputStream inStream)\n           }\n         catch (IOException ioe)\n           {\n-            throw new CertificateException(ioe.toString());\n+            CertificateException ce = new CertificateException(ioe.getMessage());\n+            ce.initCause (ioe);\n+            throw ce;\n           }\n       }\n     return certs;\n@@ -121,7 +130,9 @@ public CRL engineGenerateCRL(InputStream inStream) throws CRLException\n       }\n     catch (IOException ioe)\n       {\n-        throw new CRLException(ioe.toString());\n+        CRLException crle = new CRLException(ioe.getMessage());\n+        crle.initCause (ioe);\n+        throw crle;\n       }\n   }\n \n@@ -141,18 +152,44 @@ public Collection engineGenerateCRLs(InputStream inStream)\n           }\n         catch (IOException ioe)\n           {\n-            throw new CRLException(ioe.toString());\n+            CRLException crle = new CRLException(ioe.getMessage());\n+            crle.initCause (ioe);\n+            throw crle;\n           }\n       }\n     return crls;\n   }\n \n+  public CertPath engineGenerateCertPath(List certs)\n+  {\n+    return new X509CertPath(certs);\n+  }\n+\n+  public CertPath engineGenerateCertPath(InputStream in)\n+    throws CertificateEncodingException\n+  {\n+    return new X509CertPath(in);\n+  }\n+\n+  public CertPath engineGenerateCertPath(InputStream in, String encoding)\n+    throws CertificateEncodingException\n+  {\n+    return new X509CertPath(in, encoding);\n+  }\n+\n+  public Iterator engineGetCertPathEncodings()\n+  {\n+    return X509CertPath.ENCODINGS.iterator();\n+  }\n+\n   // Own methods.\n   // ------------------------------------------------------------------------\n \n   private X509Certificate generateCert(InputStream inStream)\n     throws IOException, CertificateException\n   {\n+    if (inStream == null)\n+      throw new CertificateException(\"missing input stream\");\n     if (!inStream.markSupported())\n       inStream = new BufferedInputStream(inStream, 8192);\n     inStream.mark(20);\n@@ -211,6 +248,8 @@ private X509Certificate generateCert(InputStream inStream)\n   private X509CRL generateCRL(InputStream inStream)\n     throws IOException, CRLException\n   {\n+    if (inStream == null)\n+      throw new CRLException(\"missing input stream\");\n     if (!inStream.markSupported())\n       inStream = new BufferedInputStream(inStream, 8192);\n     inStream.mark(20);\n@@ -265,5 +304,4 @@ private X509CRL generateCRL(InputStream inStream)\n         return new X509CRL(inStream);\n       }\n   }\n-\n }"}, {"sha": "8294e654bc14581055364f2bbea4b6d020889290", "filename": "libjava/gnu/java/security/x509/GnuPKIExtension.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FGnuPKIExtension.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FGnuPKIExtension.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FGnuPKIExtension.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,59 @@\n+/* GnuPKIExtension.java -- interface for GNU PKI extensions.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.security.cert.X509Extension;\n+import java.util.Collection;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.x509.ext.Extension;\n+\n+public interface GnuPKIExtension extends X509Extension\n+{\n+\n+  /**\n+   * Returns the extension object for the given object identifier.\n+   *\n+   * @param oid The OID of the extension to get.\n+   * @return The extension, or null if there is no such extension.\n+   */\n+  Extension getExtension(OID oid);\n+\n+  Collection getExtensions();\n+}"}, {"sha": "d3d4bd9a41a1c63a32eb4ea97d781c9b65cc9db2", "filename": "libjava/gnu/java/security/x509/PolicyNodeImpl.java", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FPolicyNodeImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FPolicyNodeImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FPolicyNodeImpl.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,214 @@\n+/* PolicyNodeImpl.java -- An implementation of a policy tree node.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.security.cert.PolicyNode;\n+import java.security.cert.PolicyQualifierInfo;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+public final class PolicyNodeImpl implements PolicyNode\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private String policy;\n+  private final Set expectedPolicies;\n+  private final Set qualifiers;\n+  private final Set children;\n+  private PolicyNodeImpl parent;\n+  private int depth;\n+  private boolean critical;\n+  private boolean readOnly;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public PolicyNodeImpl()\n+  {\n+    expectedPolicies = new HashSet();\n+    qualifiers = new HashSet();\n+    children = new HashSet();\n+    readOnly = false;\n+    critical = false;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public void addChild(PolicyNodeImpl node)\n+  {\n+    if (readOnly)\n+      throw new IllegalStateException(\"read only\");\n+    if (node.getParent() != null)\n+      throw new IllegalStateException(\"already a child node\");\n+    node.parent = this;\n+    node.setDepth(depth + 1);\n+    children.add(node);\n+  }\n+\n+  public Iterator getChildren()\n+  {\n+    return Collections.unmodifiableSet(children).iterator();\n+  }\n+\n+  public int getDepth()\n+  {\n+    return depth;\n+  }\n+\n+  public void setDepth(int depth)\n+  {\n+    if (readOnly)\n+      throw new IllegalStateException(\"read only\");\n+    this.depth = depth;\n+  }\n+\n+  public void addAllExpectedPolicies(Set policies)\n+  {\n+    if (readOnly)\n+      throw new IllegalStateException(\"read only\");\n+    expectedPolicies.addAll(policies);\n+  }\n+\n+  public void addExpectedPolicy(String policy)\n+  {\n+    if (readOnly)\n+      throw new IllegalStateException(\"read only\");\n+    expectedPolicies.add(policy);\n+  }\n+\n+  public Set getExpectedPolicies()\n+  {\n+    return Collections.unmodifiableSet(expectedPolicies);\n+  }\n+\n+  public PolicyNode getParent()\n+  {\n+    return parent;\n+  }\n+\n+  public void addAllPolicyQualifiers (Collection qualifiers)\n+  {\n+    for (Iterator it = qualifiers.iterator(); it.hasNext(); )\n+      {\n+        if (!(it.next() instanceof PolicyQualifierInfo))\n+          throw new IllegalArgumentException (\"can only add PolicyQualifierInfos\");\n+      }\n+    qualifiers.addAll (qualifiers);\n+  }\n+\n+  public void addPolicyQualifier (PolicyQualifierInfo qualifier)\n+  {\n+    if (readOnly)\n+      throw new IllegalStateException(\"read only\");\n+    qualifiers.add(qualifier);\n+  }\n+\n+  public Set getPolicyQualifiers()\n+  {\n+    return Collections.unmodifiableSet(qualifiers);\n+  }\n+\n+  public String getValidPolicy()\n+  {\n+    return policy;\n+  }\n+\n+  public void setValidPolicy(String policy)\n+  {\n+    if (readOnly)\n+      throw new IllegalStateException(\"read only\");\n+    this.policy = policy;\n+  }\n+\n+  public boolean isCritical()\n+  {\n+    return critical;\n+  }\n+\n+  public void setCritical(boolean critical)\n+  {\n+    if (readOnly)\n+      throw new IllegalStateException(\"read only\");\n+    this.critical = critical;\n+  }\n+\n+  public void setReadOnly()\n+  {\n+    if (readOnly)\n+      return;\n+    readOnly = true;\n+    for (Iterator it = getChildren(); it.hasNext(); )\n+      ((PolicyNodeImpl) it.next()).setReadOnly();\n+  }\n+\n+  public String toString()\n+  {\n+    StringBuffer buf = new StringBuffer();\n+    for (int i = 0; i < depth; i++)\n+      buf.append(\"  \");\n+    buf.append(\"(\");\n+    buf.append(PolicyNodeImpl.class.getName());\n+    buf.append(\" (oid \");\n+    buf.append(policy);\n+    buf.append(\") (depth \");\n+    buf.append(depth);\n+    buf.append(\") (qualifiers \");\n+    buf.append(qualifiers);\n+    buf.append(\") (critical \");\n+    buf.append(critical);\n+    buf.append(\") (expectedPolicies \");\n+    buf.append(expectedPolicies);\n+    buf.append(\") (children (\");\n+    final String nl = System.getProperty(\"line.separator\");\n+    for (Iterator it = getChildren(); it.hasNext(); )\n+      {\n+        buf.append(nl);\n+        buf.append(it.next().toString());\n+      }\n+    buf.append(\")))\");\n+    return buf.toString();\n+  }\n+}"}, {"sha": "3bbbff25b51015a355e3a7132ee253e590390ab7", "filename": "libjava/gnu/java/security/x509/Util.java", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FUtil.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FUtil.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FUtil.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,202 @@\n+/* Util.java -- Miscellaneous utility methods.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+/**\n+ * A collection of useful class methods.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public final class Util\n+{\n+\n+  // Constants.\n+  // -------------------------------------------------------------------------\n+\n+  public static final String HEX = \"0123456789abcdef\";\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Convert a byte array to a hexadecimal string, as though it were a\n+   * big-endian arbitrarily-sized integer.\n+   *\n+   * @param buf The bytes to format.\n+   * @param off The offset to start at.\n+   * @param len The number of bytes to format.\n+   * @return A hexadecimal representation of the specified bytes.\n+   */\n+  public static String toHexString(byte[] buf, int off, int len)\n+  {\n+    StringBuffer str = new StringBuffer();\n+    for (int i = 0; i < len; i++)\n+      {\n+        str.append(HEX.charAt(buf[i+off] >>> 4 & 0x0F));\n+        str.append(HEX.charAt(buf[i+off] & 0x0F));\n+      }\n+    return str.toString();\n+  }\n+\n+  /**\n+   * See {@link #toHexString(byte[],int,int)}.\n+   */\n+  public static String toHexString(byte[] buf)\n+  {\n+    return Util.toHexString(buf, 0, buf.length);\n+  }\n+\n+  /**\n+   * Convert a byte array to a hexadecimal string, separating octets\n+   * with the given character.\n+   *\n+   * @param buf The bytes to format.\n+   * @param off The offset to start at.\n+   * @param len The number of bytes to format.\n+   * @param sep The character to insert between octets.\n+   * @return A hexadecimal representation of the specified bytes.\n+   */\n+  public static String toHexString(byte[] buf, int off, int len, char sep)\n+  {\n+    StringBuffer str = new StringBuffer();\n+    for (int i = 0; i < len; i++)\n+      {\n+        str.append(HEX.charAt(buf[i+off] >>> 4 & 0x0F));\n+        str.append(HEX.charAt(buf[i+off] & 0x0F));\n+        if (i < len - 1)\n+          str.append(sep);\n+      }\n+    return str.toString();\n+  }\n+\n+  /**\n+   * See {@link #toHexString(byte[],int,int,char)}.\n+   */\n+  public static String toHexString(byte[] buf, char sep)\n+  {\n+    return Util.toHexString(buf, 0, buf.length, sep);\n+  }\n+\n+  /**\n+   * Create a representation of the given byte array similar to the\n+   * output of `hexdump -C', which is\n+   *\n+   * <p><pre>OFFSET  SIXTEEN-BYTES-IN-HEX  PRINTABLE-BYTES</pre>\n+   *\n+   * <p>The printable bytes show up as-is if they are printable and\n+   * not a newline character, otherwise showing as '.'.\n+   *\n+   * @param buf The bytes to format.\n+   * @param off The offset to start at.\n+   * @param len The number of bytes to encode.\n+   * @return The formatted string.\n+   */\n+  public static String hexDump(byte[] buf, int off, int len, String prefix)\n+  {\n+    String nl = System.getProperty(\"line.separator\");\n+    StringBuffer str = new StringBuffer();\n+    int i = 0;\n+    while (i < len)\n+      {\n+        str.append(prefix);\n+        str.append(Util.formatInt(i+off, 16, 8));\n+        str.append(\"  \");\n+        String s = Util.toHexString(buf, i+off, Math.min(16, len-i), ' ');\n+        str.append(s);\n+        for (int j = 56 - (56 - s.length()); j < 56; j++)\n+          str.append(\" \");\n+        for (int j = 0; j < Math.min(16, len - i); j++)\n+          {\n+            if ((buf[i+off+j] & 0xFF) < 0x20 || (buf[i+off+j] & 0xFF) > 0x7E)\n+              str.append('.');\n+            else\n+              str.append((char) (buf[i+off+j] & 0xFF));\n+          }\n+        str.append(nl);\n+        i += 16;\n+      }\n+    return str.toString();\n+  }\n+\n+  /**\n+   * See {@link #hexDump(byte[],int,int)}.\n+   */\n+  public static String hexDump(byte[] buf, String prefix)\n+  {\n+    return hexDump(buf, 0, buf.length, prefix);\n+  }\n+\n+  /**\n+   * Format an integer into the specified radix, zero-filled.\n+   *\n+   * @param i The integer to format.\n+   * @param radix The radix to encode to.\n+   * @param len The target length of the string. The string is\n+   *   zero-padded to this length, but may be longer.\n+   * @return The formatted integer.\n+   */\n+  public static String formatInt(int i, int radix, int len)\n+  {\n+    String s = Integer.toString(i, radix);\n+    StringBuffer buf = new StringBuffer();\n+    for (int j = 0; j < len - s.length(); j++)\n+      buf.append(\"0\");\n+    buf.append(s);\n+    return buf.toString();\n+  }\n+\n+  /**\n+   * Convert a hexadecimal string into its byte representation.\n+   *\n+   * @param hex The hexadecimal string.\n+   * @return The converted bytes.\n+   */\n+  public static byte[] toByteArray(String hex)\n+  {\n+    hex = hex.toLowerCase();\n+    byte[] buf = new byte[hex.length() / 2];\n+    int j = 0;\n+    for (int i = 0; i < buf.length; i++)\n+      {\n+        buf[i] = (byte) ((Character.digit(hex.charAt(j++), 16) << 4) |\n+                          Character.digit(hex.charAt(j++), 16));\n+      }\n+    return buf;\n+  }\n+}"}, {"sha": "64e320bef82ebe623efbdbf08c4bd469866d6eeb", "filename": "libjava/gnu/java/security/x509/X500DistinguishedName.java", "status": "modified", "additions": 383, "deletions": 653, "changes": 1036, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX500DistinguishedName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX500DistinguishedName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX500DistinguishedName.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -1,13 +1,13 @@\n-/* X500DistinguishedName.java -- X.500 name.\n-   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+/* X500DistinguishedName.java -- X.500 distinguished name.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -38,121 +38,35 @@\n \n package gnu.java.security.x509;\n \n-import gnu.java.io.ASN1ParsingException;\n-import gnu.java.security.OID;\n-import gnu.java.security.der.DER;\n-import gnu.java.security.der.DERReader;\n-import gnu.java.security.der.DERValue;\n-import gnu.java.security.der.DERWriter;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n import java.io.InputStream;\n import java.io.IOException;\n-import java.io.StreamTokenizer;\n+import java.io.Reader;\n import java.io.StringReader;\n+\n+import java.security.Principal;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n \n-/**\n- * A X.500 distinguished name. Distinguished names are sequences of\n- * ATTRIB=VALUE pairs, where ATTRIB is one of the following:\n- *\n- * <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n- * <tr>\n- * <th bgcolor=\"#CCCCFF\" align=\"left\">Name</th>\n- * <th bgcolor=\"#CCCCFF\" align=\"left\">X.500 AttributeType</th>\n- * <th bgcolor=\"#CCCCFF\" align=\"left\">ObjectIdentifier</th>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">CN</td>\n- * <td align=\"left\">commonName</td>\n- * <td align=\"left\">2.5.4.3</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">C</td>\n- * <td align=\"left\">countryName</td>\n- * <td align=\"left\">2.5.4.6</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">L</td>\n- * <td align=\"left\">localityName</td>\n- * <td align=\"left\">2.5.4.7</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">ST</td>\n- * <td align=\"left\">stateOrProvinceName</td>\n- * <td align=\"left\">2.5.4.8</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">STREET</td>\n- * <td align=\"left\">streetAddress</td>\n- * <td align=\"left\">2.5.4.9</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">O</td>\n- * <td align=\"left\">organizationName</td>\n- * <td align=\"left\">2.5.4.10</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">OU</td>\n- * <td align=\"left\">organizationUnitName</td>\n- * <td align=\"left\">2.5.4.11</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">DC</td>\n- * <td align=\"left\">domainComponent</td>\n- * <td align=\"left\">0.9.2342.19200300.100.1.25</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">UID</td>\n- * <td align=\"left\">userid</td>\n- * <td align=\"left\"0.9.2342.19200300.100.1.1></td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">DNQ or DNQUALIFIER(*)</td>\n- * <td align=\"left\">domainNameQualifier</td>\n- * <td align=\"left\">2.5.4.46</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">SURNAME(*)</td>\n- * <td align=\"left\">name</td>\n- * <td align=\"left\">2.5.4.41</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">GIVENNAME(*)</td>\n- * <td align=\"left\">givenName</td>\n- * <td align=\"left\">2.5.4.42</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">INITIALS(*)</td>\n- * <td align=\"left\">initials</td>\n- * <td align=\"left\">2.5.4.43</td>\n- * </tr>\n- * <tr>\n- * <td align=\"left\">EMAILADDRESS(*)</td>\n- * <td align=\"left\">emailAddress</td>\n- * <td align=\"left\">2.5.4.44</td>\n- * </tr>\n- * </table>\n- *\n- * <p><i>(*) = attributes not specified in RFC1779 or RFC2253, but\n- * recognized anyway.</i>\n- *\n- * <p>Distinguished names of this form are used in the lightweight\n- * directory access protocol (LDAP) and in the issuer and subject fields\n- * of X.509 certificates.\n- *\n- * @author Casey Marshall (rsdio@metastatic.org)\n- * @see javax.security.auth.x500.X500Principal\n- * @status DER decoding/encoding works, RFC1779 and RFC2253 need to be\n- *         made more robust.\n- */\n-public class X500DistinguishedName\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.OID;\n+\n+public class X500DistinguishedName implements Principal\n {\n \n   // Constants and fields.\n-  // ------------------------------------------------------------------------\n+  // -------------------------------------------------------------------------\n \n   public static final OID CN         = new OID(\"2.5.4.3\");\n   public static final OID C          = new OID(\"2.5.4.6\");\n@@ -171,651 +85,467 @@\n   public static final OID DC         = new OID(\"0.9.2342.19200300.100.1.25\");\n   public static final OID UID        = new OID(\"0.9.2342.19200300.100.1.1\");\n \n-  private String commonName;\n-  private String country;\n-  private String locality;\n-  private String orgUnit;\n-  private String organization;\n-  private String street;\n-  private String state;\n-  private String title;\n-  private String dnQualifier;\n-  private String surname;\n-  private String givenName;\n-  private String initials;\n-  private String generation;\n-  private String email;\n-  private String domainComponent;\n-  private String userid;\n-\n-  private String nameRFC1779;\n-  private String nameRFC2253;\n-  private String nameCanonical;\n-\n-  private transient byte[] encoded;\n+  private List components;\n+  private Map currentRdn;\n+  private boolean fixed;\n+  private String stringRep;\n+  private byte[] encoded;\n \n   // Constructors.\n-  // ------------------------------------------------------------------------\n-\n-  /**\n-   * Create a new X500DistinguishedName from the RFC1779 or RFC2253\n-   * encoded form.\n-   *\n-   * @param name The encoded name.\n-   * @throws IllegalArgumentException If the name cannot be parsed.\n-   */\n+  // -------------------------------------------------------------------------\n+\n+  public X500DistinguishedName()\n+  {\n+    components = new LinkedList();\n+    currentRdn = new LinkedHashMap();\n+    components.add(currentRdn);\n+  }\n+\n   public X500DistinguishedName(String name)\n   {\n-    if (name == null)\n-      throw new NullPointerException();\n+    this();\n     try\n       {\n-        parseDN(name, true);\n+        parseString(name);\n       }\n-    catch (Exception e)\n+    catch (IOException ioe)\n       {\n-        parseDN(name, false);\n+        throw new IllegalArgumentException(ioe.toString());\n       }\n   }\n \n-  /**\n-   * Create a new X500DistinguishedName from the DER encoded bytes.\n-   *\n-   * @param encoded The encoded form.\n-   * @throws IOException If the bytes are not a valid DER construct.\n-   */\n   public X500DistinguishedName(byte[] encoded) throws IOException\n   {\n-    this(new ByteArrayInputStream(encoded));\n+    this();\n+    parseDer(new DERReader(encoded));\n   }\n \n-  /**\n-   * Create a new X500DistinguishedName from the DER encoded bytes.\n-   *\n-   * @param encoded The encoded form.\n-   * @throws IOException If the bytes are not a valid DER construct.\n-   */\n   public X500DistinguishedName(InputStream encoded) throws IOException\n   {\n-    parseDER(encoded);\n+    this();\n+    parseDer(new DERReader(encoded));\n   }\n \n   // Instance methods.\n-  // ------------------------------------------------------------------------\n-\n-  public boolean equals(Object o)\n-  {\n-    return \n-      (commonName != null &&\n-       commonName.equals(((X500DistinguishedName) o).commonName)) &&\n-      (country != null &&\n-       country.equals(((X500DistinguishedName) o).country)) &&\n-      (locality != null &&\n-       locality.equals(((X500DistinguishedName) o).locality)) &&\n-      (orgUnit != null &&\n-       orgUnit.equals(((X500DistinguishedName) o).orgUnit)) &&\n-      (organization != null &&\n-       organization.equals(((X500DistinguishedName) o).organization)) &&\n-      (street != null &&\n-       street.equals(((X500DistinguishedName) o).street)) &&\n-      (state != null &&\n-       state.equals(((X500DistinguishedName) o).state)) &&\n-      (domainComponent != null &&\n-       domainComponent.equals(((X500DistinguishedName) o).domainComponent)) &&\n-      (title != null &&\n-       title.equals(((X500DistinguishedName) o).title)) &&\n-      (dnQualifier != null &&\n-       dnQualifier.equals(((X500DistinguishedName) o).dnQualifier)) &&\n-      (surname != null &&\n-       surname.equals(((X500DistinguishedName) o).surname)) &&\n-      (givenName != null &&\n-       givenName.equals(((X500DistinguishedName) o).givenName)) &&\n-      (initials != null &&\n-       initials.equals(((X500DistinguishedName) o).initials)) &&\n-      (generation != null &&\n-       generation.equals(((X500DistinguishedName) o).generation)) &&\n-      (email != null &&\n-       email.equals(((X500DistinguishedName) o).email)) &&\n-      (userid != null &&\n-       userid.equals(((X500DistinguishedName) o).userid));\n-  }\n-\n-  public byte[] getEncoded()\n-  {\n-    if (encoded == null)\n-      encoded = encodeDER();\n-    return (byte[]) encoded.clone();\n-  }\n-\n-  private static String quote(String str)\n-  {\n-    if (str.indexOf(\" \")  > 0 || str.indexOf(\"\\f\") > 0 ||\n-        str.indexOf(\"\\n\") > 0 || str.indexOf(\"\\r\") > 0 ||\n-        str.indexOf(\"\\t\") > 0)\n-      str = '\"' + str + '\"';\n-    // XXX needs regex\n-    //return str.replaceAll(\"([,+\\\"\\\\<>;])\", \"\\\\\\1\");\n-    return str;\n-  }\n-\n-  public String toRFC1779()\n-  {\n-    if (nameRFC1779 != null)\n-      return nameRFC1779;\n-    StringBuffer buf = new StringBuffer();\n-    if (commonName != null)\n-      buf.append(\"CN=\").append(quote(commonName)).append(\", \");\n-    if (country != null)\n-      buf.append(\"C=\").append(quote(country)).append(\", \");\n-    if (locality != null)\n-      buf.append(\"L=\").append(quote(locality)).append(\", \");\n-    if (orgUnit != null)\n-      buf.append(\"OU=\").append(quote(orgUnit)).append(\", \");\n-    if (organization != null)\n-      buf.append(\"O=\").append(quote(organization)).append(\", \");\n-    if (street != null)\n-      buf.append(\"STREET=\").append(quote(street)).append(\", \");\n-    if (state != null)\n-      buf.append(\"ST=\").append(quote(state)).append(\", \");\n-    if (title != null)\n-      buf.append(T).append(\"=\").append(quote(title)).append(\", \");\n-    if (dnQualifier != null)\n-      buf.append(DNQ).append(\"=\").append(quote(dnQualifier)).append(\", \");\n-    if (surname != null)\n-      buf.append(NAME).append(\"=\").append(quote(surname)).append(\", \");\n-    if (givenName != null)\n-      buf.append(GIVENNAME).append(\"=\").append(quote(givenName)).append(\", \");\n-    if (initials != null)\n-      buf.append(INITIALS).append(\"=\").append(quote(initials)).append(\", \");\n-    if (generation != null)\n-      buf.append(GENERATION).append(\"=\").append(quote(generation)).append(\", \");\n-    if (email != null)\n-      buf.append(EMAIL).append(\"=\").append(quote(email)).append(\", \");\n-    if (domainComponent != null)\n-      buf.append(DC).append(\"=\").append(quote(domainComponent)).append(\", \");\n-    if (userid != null)\n-      buf.append(UID).append(\"=\").append(quote(userid)).append(\", \");\n-    // XXX escapes\n-    return (nameRFC1779 = buf.substring(0, buf.length()-2));\n-  }\n-\n-  public String toRFC2253()\n-  {\n-    if (nameRFC2253 != null)\n-      return nameRFC2253;\n-    StringBuffer buf = new StringBuffer();\n-    if (commonName != null)\n-      buf.append(\"CN=\").append(quote(commonName)).append(\",\");\n-    if (country != null)\n-      buf.append(\"C=\").append(quote(country)).append(\",\");\n-    if (locality != null)\n-      buf.append(\"L=\").append(quote(locality)).append(\",\");\n-    if (orgUnit != null)\n-      buf.append(\"OU=\").append(quote(orgUnit)).append(\",\");\n-    if (organization != null)\n-      buf.append(\"O=\").append(quote(organization)).append(\",\");\n-    if (street != null)\n-      buf.append(\"STREET=\").append(quote(street)).append(\",\");\n-    if (state != null)\n-      buf.append(\"ST=\").append(quote(state)).append(\",\");\n-    if (title != null)\n-      buf.append(T).append(\"=\").append(quote(title)).append(\",\");\n-    if (dnQualifier != null)\n-      buf.append(DNQ).append(\"=\").append(quote(dnQualifier)).append(\",\");\n-    if (surname != null)\n-      buf.append(NAME).append(\"=\").append(quote(surname)).append(\",\");\n-    if (givenName != null)\n-      buf.append(GIVENNAME).append(\"=\").append(quote(givenName)).append(\",\");\n-    if (initials != null)\n-      buf.append(INITIALS).append(\"=\").append(quote(initials)).append(\",\");\n-    if (generation != null)\n-      buf.append(GENERATION).append(\"=\").append(quote(generation)).append(\",\");\n-    if (email != null)\n-      buf.append(EMAIL).append(\"=\").append(quote(email)).append(\",\");\n-    if (domainComponent != null)\n-      buf.append(DC).append(\"=\").append(quote(domainComponent)).append(\",\");\n-    if (userid != null)\n-      buf.append(UID).append(\"=\").append(quote(userid)).append(\",\");\n-    // XXX escapes.\n-    return (nameRFC2253 = buf.substring(0, buf.length()-1));\n-  }\n+  // -------------------------------------------------------------------------\n \n-  public String toCanonical()\n+  public String getName()\n   {\n-    if (nameCanonical != null)\n-      return nameCanonical;\n-    nameCanonical = toRFC2253();\n-    return nameCanonical; // XXX canonicalize\n+    return toString();\n   }\n \n-  public String getCommonName()\n+  public void newRelativeDistinguishedName()\n   {\n-    return commonName;\n+    if (fixed || currentRdn.isEmpty()) return;\n+    currentRdn = new LinkedHashMap();\n+    components.add(currentRdn);\n   }\n \n-  public String getCountry()\n+  public int size()\n   {\n-    return country;\n+    return components.size();\n   }\n \n-  public String getLocality()\n+  public int countComponents()\n   {\n-    return locality;\n+    int count = 0;\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        count += ((Map) it.next()).size();\n+      }\n+    return count;\n   }\n \n-  public String getOrganizationalUnit()\n+  public boolean containsComponent(OID oid, String value)\n   {\n-    return orgUnit;\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map rdn = (Map) it.next();\n+        String s = (String) rdn.get(oid);\n+        if (s == null)\n+          continue;\n+        if (compressWS(value).equalsIgnoreCase(compressWS(s)))\n+          return true;\n+      }\n+    return false;\n   }\n \n-  public String getOrganization()\n+  public String getComponent(OID oid)\n   {\n-    return organization;\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map rdn = (Map) it.next();\n+        if (rdn.containsKey(oid))\n+          return (String) rdn.get(oid);\n+      }\n+    return null;\n   }\n \n-  public String getStreet()\n+  public String getComponent(OID oid, int rdn)\n   {\n-    return street;\n+    if (rdn >= size())\n+      return null;\n+    return (String) ((Map) components.get(rdn)).get(oid);\n   }\n \n-  public String getState()\n+  public void putComponent(OID oid, String value)\n   {\n-    return state;\n+    currentRdn.put(oid, value);\n   }\n \n-  public String getTitle()\n+  public void putComponent(String name, String value)\n   {\n-    return title;\n+    name = name.trim().toLowerCase();\n+    if (name.equals(\"cn\"))\n+      putComponent(CN, value);\n+    else if (name.equals(\"c\"))\n+      putComponent(C, value);\n+    else if (name.equals(\"l\"))\n+      putComponent(L, value);\n+    else if (name.equals(\"street\"))\n+      putComponent(STREET, value);\n+    else if (name.equals(\"st\"))\n+      putComponent(ST, value);\n+    else if (name.equals(\"t\"))\n+      putComponent(T, value);\n+    else if (name.equals(\"dnq\"))\n+      putComponent(DNQ, value);\n+    else if (name.equals(\"name\"))\n+      putComponent(NAME, value);\n+    else if (name.equals(\"givenname\"))\n+      putComponent(GIVENNAME, value);\n+    else if (name.equals(\"initials\"))\n+      putComponent(INITIALS, value);\n+    else if (name.equals(\"generation\"))\n+      putComponent(GENERATION, value);\n+    else if (name.equals(\"email\"))\n+      putComponent(EMAIL, value);\n+    else if (name.equals(\"dc\"))\n+      putComponent(DC, value);\n+    else if (name.equals(\"uid\"))\n+      putComponent(UID, value);\n+    else\n+      putComponent(new OID(name), value);\n   }\n \n-  public String getDNQualifier()\n+  public void setUnmodifiable()\n   {\n-    return dnQualifier;\n+    if (fixed) return;\n+    fixed = true;\n+    List newComps = new ArrayList(components.size());\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map rdn = (Map) it.next();\n+        rdn = Collections.unmodifiableMap(rdn);\n+        newComps.add(rdn);\n+      }\n+    components = Collections.unmodifiableList(newComps);\n+    currentRdn = Collections.EMPTY_MAP;\n   }\n \n-  public String getSurname()\n+  public int hashCode()\n   {\n-    return surname;\n+    int sum = 0;\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map m = (Map) it.next();\n+        for (Iterator it2 = m.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry e = (Map.Entry) it2.next();\n+            sum += e.getKey().hashCode();\n+            sum += e.getValue().hashCode();\n+          }\n+      }\n+    return sum;\n   }\n \n-  public String getGivenName()\n+  public boolean equals(Object o)\n   {\n-    return givenName;\n+    if (!(o instanceof X500DistinguishedName))\n+      return false;\n+    if (size() != ((X500DistinguishedName) o).size())\n+      return false;\n+    for (int i = 0; i < size(); i++)\n+      {\n+        Map m = (Map) components.get(i);\n+        for (Iterator it2 = m.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry e = (Map.Entry) it2.next();\n+            OID oid = (OID) e.getKey();\n+            String v1 = (String) e.getValue();\n+            String v2 = ((X500DistinguishedName) o).getComponent(oid, i);\n+            if (!compressWS(v1).equalsIgnoreCase(compressWS(v2)))\n+              return false;\n+          }\n+      }\n+    return true;\n   }\n \n-  public String getInitials()\n+  public String toString()\n   {\n-    return initials;\n+    if (fixed && stringRep != null)\n+      return stringRep;\n+    StringBuffer str = new StringBuffer();\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map m = (Map) it.next();\n+        for (Iterator it2 = m.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry entry = (Map.Entry) it2.next();\n+            OID oid = (OID) entry.getKey();\n+            String value = (String) entry.getValue();\n+            if (oid.equals(CN))\n+              str.append(\"CN\");\n+            else if (oid.equals(C))\n+              str.append(\"C\");\n+            else if (oid.equals(L))\n+              str.append(\"L\");\n+            else if (oid.equals(ST))\n+              str.append(\"ST\");\n+            else if (oid.equals(STREET))\n+              str.append(\"STREET\");\n+            else if (oid.equals(O))\n+              str.append(\"O\");\n+            else if (oid.equals(OU))\n+              str.append(\"OU\");\n+            else if (oid.equals(T))\n+              str.append(\"T\");\n+            else if (oid.equals(DNQ))\n+              str.append(\"DNQ\");\n+            else if (oid.equals(NAME))\n+              str.append(\"NAME\");\n+            else\n+              str.append(oid.toString());\n+            str.append('=');\n+            str.append(value);\n+            if (it2.hasNext())\n+              str.append(\"+\");\n+          }\n+        if (it.hasNext())\n+          str.append(',');\n+      }\n+    return (stringRep = str.toString());\n   }\n \n-  public String getGeneration()\n+  public byte[] getDer()\n   {\n-    return generation;\n+    if (fixed && encoded != null)\n+      return (byte[]) encoded.clone();\n+    ArrayList name = new ArrayList(components.size());\n+    for (Iterator it = components.iterator(); it.hasNext(); )\n+      {\n+        Map m = (Map) it.next();\n+        if (m.isEmpty())\n+          continue;\n+        Set rdn = new HashSet();\n+        for (Iterator it2 = m.entrySet().iterator(); it2.hasNext(); )\n+          {\n+            Map.Entry e = (Map.Entry) it.next();\n+            ArrayList atav = new ArrayList(2);\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, e.getKey()));\n+            atav.add(new DERValue(DER.UTF8_STRING, e.getValue()));\n+            rdn.add(new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, atav));\n+          }\n+        name.add(new DERValue(DER.SET|DER.CONSTRUCTED, rdn));\n+      }\n+    DERValue val = new DERValue(DER.SEQUENCE|DER.CONSTRUCTED, name);\n+    return (byte[]) (encoded = val.getEncoded()).clone();\n   }\n \n-  public String getEmail()\n-  {\n-    return email;\n-  }\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n \n-  public String getDomain()\n-  {\n-    return domainComponent;\n-  }\n+  private int sep;\n \n-  public String getUserID()\n+  private void parseString(String str) throws IOException\n   {\n-    return userid;\n+    Reader in = new StringReader(str);\n+    while (true)\n+      {\n+        String key = readAttributeType(in);\n+        if (key == null)\n+          break;\n+        String value = readAttributeValue(in);\n+        putComponent(key, value);\n+        if (sep == ',')\n+          newRelativeDistinguishedName();\n+      }\n+    setUnmodifiable();\n   }\n \n-  // Own methods.\n-  // ------------------------------------------------------------------------\n-\n-  private static String unquote(String str)\n+  private String readAttributeType(Reader in) throws IOException\n   {\n-    if (str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\"))\n-      str = str.substring(1, str.length()-1);\n-    // XXX needs regex\n-    //return str.replaceAll(\"\\\\([,+\\\"\\\\<>;])\", \"\\1\");\n-    return str;\n+    StringBuffer buf = new StringBuffer();\n+    int ch;\n+    while ((ch = in.read()) != '=')\n+      {\n+        if (ch == -1)\n+          {\n+            if (buf.length() > 0)\n+              throw new EOFException();\n+            return null;\n+          }\n+        if (ch > 127)\n+          throw new IOException(\"Invalid char: \" + (char) ch);\n+        if (Character.isLetterOrDigit((char) ch) || ch == '-' || ch == '.')\n+          buf.append((char) ch);\n+        else\n+          throw new IOException(\"Invalid char: \" + (char) ch);\n+      }\n+    return buf.toString();\n   }\n \n-  private void parseDN(String name, boolean rfc2253)\n+  private String readAttributeValue(Reader in) throws IOException\n   {\n-    if (name.length() == 0)\n-      throw new IllegalArgumentException(\"zero-length distinguished name\");\n-    StreamTokenizer parse = new StreamTokenizer(new StringReader(name));\n-    parse.resetSyntax();\n-    parse.wordChars('\\000', '~');\n-    parse.ordinaryChar('#');\n-    parse.ordinaryChar(',');\n-    parse.ordinaryChar('=');\n-    parse.ordinaryChar('<');\n-    parse.ordinaryChar('>');\n-    parse.ordinaryChar(';');\n-    parse.ordinaryChar('\\\\');\n-    parse.quoteChar('\"');\n-    String attrib = null;\n-    String value = null;\n-    int token, lastToken = ',';\n-    while (true)\n+    StringBuffer buf = new StringBuffer();\n+    int ch = in.read();\n+    if (ch == '#')\n       {\n-        try\n+        while (true)\n           {\n-            token = parse.nextToken();\n+            ch = in.read();\n+            if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                || Character.isDigit((char) ch))\n+              buf.append((char) ch);\n+            else if (ch == '+' || ch == ',')\n+              {\n+                sep = ch;\n+                String hex = buf.toString();\n+                return new String(Util.toByteArray(hex));\n+              }\n+            else\n+              throw new IOException(\"illegal character: \" + (char) ch);\n           }\n-        catch (IOException ioe)\n+      }\n+    else if (ch == '\"')\n+      {\n+        while (true)\n           {\n-            throw new IllegalArgumentException();\n+            ch = in.read();\n+            if (ch == '\"')\n+              break;\n+            else if (ch == '\\\\')\n+              {\n+                ch = in.read();\n+                if (ch == -1)\n+                  throw new EOFException();\n+                if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                    || Character.isDigit((char) ch))\n+                  {\n+                    int i = Character.digit((char) ch, 16) << 4;\n+                    ch = in.read();\n+                    if (!(('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                          || Character.isDigit((char) ch)))\n+                      throw new IOException(\"illegal hex char\");\n+                    i |= Character.digit((char) ch, 16);\n+                    buf.append((char) i);\n+                  }\n+                else\n+                  buf.append((char) ch);\n+              }\n+            else\n+              buf.append((char) ch);\n           }\n-        switch (token)\n+        sep = in.read();\n+        if (sep != '+' || sep != ',')\n+          throw new IOException(\"illegal character: \" + (char) ch);\n+        return buf.toString();\n+      }\n+    else\n+      {\n+        while (true)\n           {\n-            case StreamTokenizer.TT_WORD:\n-              if (lastToken == ',' || lastToken == '+' ||\n-                  (!rfc2253 && lastToken == ';'))\n-                attrib = parse.sval.trim();\n-              else if (lastToken == '=')\n-                value = unquote(parse.sval.trim());\n-              else\n-                throw new IllegalArgumentException();\n-              break;\n-            case '\"':\n-              if (lastToken == '=')\n-                value = parse.sval;\n-              else\n-                throw new IllegalArgumentException();\n-              break;\n-            case ';':\n-              if (rfc2253)\n-                throw new IllegalArgumentException();\n-            case ',':\n-            case '+':\n-              if (attrib == null || value == null)\n-                throw new IllegalArgumentException(\"extraneous separator\");\n-              try\n-                {\n-                  setAttribute(new OID(attrib), value);\n-                }\n-              catch (Exception x)\n-                {\n-                  setAttribute(attrib, value);\n-                }\n-              attrib = null;\n-              value = null;\n-              break;\n-            case '=':\n-              break;\n-            case StreamTokenizer.TT_EOF:\n-              return;\n-            default:\n-              throw new IllegalArgumentException(\"unknown token \" + (char)token\n-                + \" (\" + token + \")\");\n+            switch (ch)\n+              {\n+              case '+':\n+              case ',':\n+                sep = ch;\n+                return buf.toString();\n+              case '\\\\':\n+                ch = in.read();\n+                if (ch == -1)\n+                  throw new EOFException();\n+                if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                    || Character.isDigit((char) ch))\n+                  {\n+                    int i = Character.digit((char) ch, 16) << 4;\n+                    ch = in.read();\n+                    if (!(('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')\n+                          || Character.isDigit((char) ch)))\n+                      throw new IOException(\"illegal hex char\");\n+                    i |= Character.digit((char) ch, 16);\n+                    buf.append((char) i);\n+                  }\n+                else\n+                  buf.append((char) ch);\n+                break;\n+              case '=':\n+              case '<':\n+              case '>':\n+              case '#':\n+              case ';':\n+                throw new IOException(\"illegal character: \" + (char) ch);\n+              case -1:\n+                throw new EOFException();\n+              default:\n+                buf.append((char) ch);\n+              }\n           }\n-        lastToken = token;\n       }\n   }\n \n-  private void parseDER(InputStream in) throws IOException\n+  private void parseDer(DERReader der) throws IOException\n   {\n-    DERReader der = new DERReader(in);\n     DERValue name = der.read();\n     if (!name.isConstructed())\n-      throw new ASN1ParsingException(\"badly formed Name\");\n+      throw new IOException(\"malformed Name\");\n+    encoded = name.getEncoded();\n     int len = 0;\n     while (len < name.getLength())\n       {\n         DERValue rdn = der.read();\n-        if (rdn.getValue() != DER.CONSTRUCTED_VALUE)\n-          throw new ASN1ParsingException(\"badly formed RDNSequence\");\n+        if (!rdn.isConstructed())\n+          throw new IOException(\"badly formed RDNSequence\");\n         int len2 = 0;\n         while (len2 < rdn.getLength())\n           {\n             DERValue atav = der.read();\n-            if (atav.getValue() != DER.CONSTRUCTED_VALUE)\n-              throw new ASN1ParsingException(\n-                \"badly formed AttributeTypeAndValue\");\n-            OID atype = (OID) der.read().getValue();\n-            String aval = (String) der.read().getValue();\n-            setAttribute(atype, aval);\n-            len2 += 1 + atav.getLength()\n-                 + DERWriter.definiteEncodingSize(atav.getLength());\n+            if (!atav.isConstructed())\n+              throw new IOException(\"badly formed AttributeTypeAndValue\");\n+            DERValue val = der.read();\n+            if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+              throw new IOException(\"badly formed AttributeTypeAndValue\");\n+            OID oid = (OID) val.getValue();\n+            val = der.read();\n+            if (!(val.getValue() instanceof String))\n+              throw new IOException(\"badly formed AttributeTypeAndValue\");\n+            String value = (String) val.getValue();\n+            putComponent(oid, value);\n+            len2 += atav.getEncodedLength();\n           }\n-        len += len2 + 1 + DERWriter.definiteEncodingSize(name.getLength());\n+        len += rdn.getEncodedLength();\n+        if (len < name.getLength())\n+          newRelativeDistinguishedName();\n       }\n+    setUnmodifiable();\n   }\n \n-  private byte[] encodeDER()\n+  private static String compressWS(String str)\n   {\n-    try\n+    StringBuffer buf = new StringBuffer();\n+    char lastChar = 0;\n+    for (int i = 0; i < str.length(); i++)\n       {\n-        LinkedList name = new LinkedList();\n-        if (commonName != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, CN));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, commonName));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (country != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, C));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, country));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (locality != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, L));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, locality));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (orgUnit != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, OU));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, orgUnit));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (organization != null)\n+        char c = str.charAt(i);\n+        if (Character.isWhitespace(c))\n           {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, O));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, organization));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+            if (!Character.isWhitespace(lastChar))\n+              buf.append(' ');\n           }\n-        if (street != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, STREET));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, street));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (state != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, ST));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, state));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (title != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, T));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, title));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (dnQualifier != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, DNQ));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, dnQualifier));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (surname != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, NAME));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, surname));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (givenName != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, GIVENNAME));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, givenName));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (initials != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, INITIALS));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, initials));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (generation != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, GENERATION));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, generation));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (email != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, EMAIL));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, email));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (domainComponent != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, DC));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, domainComponent));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        if (userid != null)\n-          {\n-            HashSet rdn = new HashSet();\n-            LinkedList atav = new LinkedList();\n-            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, UID));\n-            atav.add(new DERValue(DER.PRINTABLE_STRING, userid));\n-            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n-            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n-          }\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        DERWriter.write(out, new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, name));\n-        return out.toByteArray();\n-      }\n-    catch (IOException ioe)\n-      {\n-        throw new Error(ioe);\n+        else\n+          buf.append(c);\n+        lastChar = c;\n       }\n-  }\n-\n-  private void setAttribute(String atype, String aval)\n-  {\n-    if (atype.equals(\"CN\"))\n-      commonName = aval;\n-    else if (atype.equals(\"C\"))\n-      country = aval;\n-    else if (atype.equals(\"L\"))\n-      locality = aval;\n-    else if (atype.equals(\"ST\"))\n-      state = aval;\n-    else if (atype.equals(\"STREET\"))\n-      street = aval;\n-    else if (atype.equals(\"O\"))\n-      organization = aval;\n-    else if (atype.equals(\"OU\"))\n-      orgUnit = aval;\n-    else if (atype.equals(\"T\"))\n-      title = aval;\n-    else if (atype.equals(\"DNQ\") || atype.equals(\"DNQUALIFIER\"))\n-      dnQualifier = aval;\n-    else if (atype.equals(\"SURNAME\"))\n-      surname = aval;\n-    else if (atype.equals(\"GIVENNAME\"))\n-      givenName = aval;\n-    else if (atype.equals(\"INITIALS\"))\n-      initials = aval;\n-    else if (atype.equals(\"GENERATION\"))\n-      generation = aval;\n-    else if (atype.equals(\"EMAILADDRESS\"))\n-      email = aval;\n-    else if (atype.equals(\"DC\"))\n-      domainComponent = aval;\n-    else if (atype.equals(\"UID\"))\n-      userid = aval;\n-    else\n-      throw new IllegalArgumentException(\"unknown attribute \" + atype);\n-  }\n-\n-  private void setAttribute(OID atype, String aval)\n-  {\n-    if (atype.equals(CN))\n-      commonName = aval;\n-    else if (atype.equals(C))\n-      country = aval;\n-    else if (atype.equals(L))\n-      locality = aval;\n-    else if (atype.equals(ST))\n-      state = aval;\n-    else if (atype.equals(STREET))\n-      street = aval;\n-    else if (atype.equals(O))\n-      organization = aval;\n-    else if (atype.equals(OU))\n-      orgUnit = aval;\n-    else if (atype.equals(T))\n-      title = aval;\n-    else if (atype.equals(DNQ))\n-      dnQualifier = aval;\n-    else if (atype.equals(NAME))\n-      surname = aval;\n-    else if (atype.equals(GIVENNAME))\n-      givenName = aval;\n-    else if (atype.equals(INITIALS))\n-      initials = aval;\n-    else if (atype.equals(GENERATION))\n-      generation = aval;\n-    else if (atype.equals(EMAIL))\n-      email = aval;\n-    else if (atype.equals(DC))\n-      domainComponent = aval;\n-    else if (atype.equals(UID))\n-      userid = aval;\n-    else\n-      throw new IllegalArgumentException(\"unknown attribute \" + atype);\n+    return buf.toString().trim();\n   }\n }"}, {"sha": "adaa003f3cb3a434f462d3803d93456c59237e02", "filename": "libjava/gnu/java/security/x509/X509CRL.java", "status": "modified", "additions": 123, "deletions": 45, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRL.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -44,6 +44,7 @@\n import gnu.java.security.der.DER;\n import gnu.java.security.der.DERReader;\n import gnu.java.security.der.DERValue;\n+import gnu.java.security.x509.ext.Extension;\n \n import java.io.InputStream;\n import java.io.IOException;\n@@ -57,11 +58,12 @@\n import java.security.SignatureException;\n import java.security.cert.Certificate;\n import java.security.cert.CRLException;\n-import java.security.cert.X509CRLEntry;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n import java.util.HashSet;\n import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.Set;\n \n import javax.security.auth.x500.X500Principal;\n@@ -72,11 +74,22 @@\n  * @author Casey Marshall (rsdio@metastatic.org)\n  */\n public class X509CRL extends java.security.cert.X509CRL\n+  implements GnuPKIExtension\n {\n \n   // Constants and fields.\n   // ------------------------------------------------------------------------\n \n+  private static final boolean DEBUG = false;\n+  private static void debug(String msg)\n+  {\n+    if (DEBUG)\n+      {\n+        System.err.print(\">> X509CRL: \");\n+        System.err.println(msg);\n+      }\n+  }\n+\n   private static final OID ID_DSA = new OID(\"1.2.840.10040.4.1\");\n   private static final OID ID_DSA_WITH_SHA1 = new OID(\"1.2.840.10040.4.3\");\n   private static final OID ID_RSA = new OID(\"1.2.840.113549.1.1.1\");\n@@ -92,12 +105,10 @@ public class X509CRL extends java.security.cert.X509CRL\n   private byte[] algParams;\n   private Date thisUpdate;\n   private Date nextUpdate;\n-  private X500Principal issuerDN;\n+  private X500DistinguishedName issuerDN;\n   private HashMap revokedCerts;\n   private HashMap extensions;\n-  private HashSet critOids;\n-  private HashSet nonCritOids;\n-  \n+\n   private OID sigAlg;\n   private byte[] sigAlgParams;\n   private byte[] rawSig;\n@@ -118,8 +129,6 @@ public X509CRL(InputStream encoded) throws CRLException, IOException\n     super();\n     revokedCerts = new HashMap();\n     extensions = new HashMap();\n-    critOids = new HashSet();\n-    nonCritOids = new HashSet();\n     try\n       {\n         parse(encoded);\n@@ -141,7 +150,9 @@ public X509CRL(InputStream encoded) throws CRLException, IOException\n \n   public boolean equals(Object o)\n   {\n-    return ((X509CRL) o).revokedCerts.equals(revokedCerts);\n+    if (!(o instanceof X509CRL))\n+      return false;\n+    return ((X509CRL) o).getRevokedCertificates().equals(revokedCerts.values());\n   }\n \n   public int hashCode()\n@@ -182,7 +193,7 @@ public Principal getIssuerDN()\n \n   public X500Principal getIssuerX500Principal()\n   {\n-    return issuerDN;\n+    return new X500Principal(issuerDN.getDer());\n   }\n \n   public Date getThisUpdate()\n@@ -197,9 +208,9 @@ public Date getNextUpdate()\n     return null;\n   }\n \n-  public X509CRLEntry getRevokedCertificate(BigInteger serialNo)\n+  public java.security.cert.X509CRLEntry getRevokedCertificate(BigInteger serialNo)\n   {\n-    return (X509CRLEntry) revokedCerts.get(serialNo);\n+    return (java.security.cert.X509CRLEntry) revokedCerts.get(serialNo);\n   }\n \n   public Set getRevokedCertificates()\n@@ -247,33 +258,68 @@ public byte[] getSigAlgParams()\n \n   public boolean hasUnsupportedCriticalExtension()\n   {\n-    return false; // XXX\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (e.isCritical() && !e.isSupported())\n+          return true;\n+      }\n+    return false;\n   }\n \n   public Set getCriticalExtensionOIDs()\n   {\n-    return Collections.unmodifiableSet(critOids);\n+    HashSet s = new HashSet();\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (e.isCritical())\n+          s.add(e.getOid().toString());\n+      }\n+    return Collections.unmodifiableSet(s);\n   }\n \n   public Set getNonCriticalExtensionOIDs()\n   {\n-    return Collections.unmodifiableSet(nonCritOids);\n+    HashSet s = new HashSet();\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (!e.isCritical())\n+          s.add(e.getOid().toString());\n+      }\n+    return Collections.unmodifiableSet(s);\n   }\n \n   public byte[] getExtensionValue(String oid)\n   {\n-    byte[] ext = (byte[]) extensions.get(oid);\n-    if (ext != null)\n-      return (byte[]) ext.clone();\n+    Extension e = getExtension(new OID(oid));\n+    if (e != null)\n+      {\n+        return e.getValue().getEncoded();\n+      }\n     return null;\n   }\n \n+  // GnuPKIExtension method.\n+  // -------------------------------------------------------------------------\n+\n+  public Extension getExtension(OID oid)\n+  {\n+    return (Extension) extensions.get(oid);\n+  }\n+\n+  public Collection getExtensions()\n+  {\n+    return extensions.values();\n+  }\n+\n   // CRL methods.\n-  // ------------------------------------------------------------------------\n+  // -------------------------------------------------------------------------\n \n   public String toString()\n   {\n-    return gnu.java.security.x509.X509CRL.class.getName();\n+    return X509CRL.class.getName();\n   }\n \n   public boolean isRevoked(Certificate cert)\n@@ -302,17 +348,23 @@ private void doVerify(Signature sig, PublicKey key)\n \n   private void parse(InputStream in) throws Exception\n   {\n+    // CertificateList ::= SEQUENCE {\n     DERReader der = new DERReader(in);\n     DERValue val = der.read();\n+    debug(\"start CertificateList len == \" + val.getLength());\n     if (!val.isConstructed())\n-      throw new ASN1ParsingException(\"malformed CertificateList\");\n+      throw new IOException(\"malformed CertificateList\");\n     encoded = val.getEncoded();\n \n+    //   tbsCertList ::= SEQUENCE {  -- TBSCertList\n     val = der.read();\n     if (!val.isConstructed())\n-      throw new ASN1ParsingException(\"malformed TBSCertList\");\n+      throw new IOException(\"malformed TBSCertList\");\n+    debug(\"start tbsCertList  len == \" + val.getLength());\n     tbsCRLBytes = val.getEncoded();\n \n+    //     version    Version OPTIONAL,\n+    //                  -- If present must be v2\n     val = der.read();\n     if (val.getValue() instanceof BigInteger)\n       {\n@@ -321,78 +373,104 @@ private void parse(InputStream in) throws Exception\n       }\n     else\n       version = 1;\n+    debug(\"read version == \" + version);\n \n+    //     signature   AlgorithmIdentifier,\n+    debug(\"start AlgorithmIdentifier len == \" + val.getLength());\n     if (!val.isConstructed())\n-      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+      throw new IOException(\"malformed AlgorithmIdentifier\");\n     DERValue algIdVal = der.read();\n     algId = (OID) algIdVal.getValue();\n+    debug(\"read object identifier == \" + algId);\n     if (val.getLength() > algIdVal.getEncodedLength())\n       {\n         val = der.read();\n+        debug(\"read parameters  len == \" + val.getEncodedLength());\n         algParams = val.getEncoded();\n         if (val.isConstructed())\n           in.skip(val.getLength());\n       }\n \n-    issuerDN = new X500Principal(in);\n+    //     issuer   Name,\n+    val = der.read();\n+    issuerDN = new X500DistinguishedName(val.getEncoded());\n+    der.skip(val.getLength());\n+    debug(\"read issuer == \" + issuerDN);\n \n+    //     thisUpdate   Time,\n     thisUpdate = (Date) der.read().getValue();\n+    debug(\"read thisUpdate == \" + thisUpdate);\n \n+    //     nextUpdate   Time OPTIONAL,\n     val = der.read();\n     if (val.getValue() instanceof Date)\n       {\n         nextUpdate = (Date) val.getValue();\n+        debug(\"read nextUpdate == \" + nextUpdate);\n         val = der.read();\n       }\n+\n+    //     revokedCertificates SEQUENCE OF SEQUENCE {\n+    //       -- X509CRLEntry objects...\n+    //     } OPTIONAL,\n     if (val.getTag() != 0)\n       {\n         int len = 0;\n         while (len < val.getLength())\n           {\n-            X509CRLEntry entry =\n-               new gnu.java.security.x509.X509CRLEntry(version, in);\n+            X509CRLEntry entry = new X509CRLEntry(version, der);\n             revokedCerts.put(entry.getSerialNumber(), entry);\n             len += entry.getEncoded().length;\n           }\n+        val = der.read();\n       }\n-    if (version >= 2 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 0)\n+\n+    //    crlExtensions   [0] EXPLICIT Extensions OPTIONAL\n+    //                        -- if present MUST be v2\n+    if (val.getTagClass() != DER.UNIVERSAL && val.getTag() == 0)\n       {\n-        val = der.read();\n+        if (version < 2)\n+          throw new IOException(\"extra data in CRL\");\n+        DERValue exts = der.read();\n+        if (!exts.isConstructed())\n+          throw new IOException(\"malformed Extensions\");\n+        debug(\"start Extensions  len == \" + exts.getLength());\n         int len = 0;\n-        while (len < val.getLength())\n+        while (len < exts.getLength())\n           {\n             DERValue ext = der.read();\n-            OID extId = (OID) der.read().getValue();\n-            DERValue val2 = der.read();\n-            Boolean crit = Boolean.valueOf(false);\n-            if (val2.getValue() instanceof Boolean)\n-              {\n-                crit = (Boolean) val2.getValue();\n-                val2 = der.read();\n-              }\n-            byte[] extVal = (byte[]) val2.getValue();\n-            extensions.put(extId.toString(), extVal);\n-            if (crit.booleanValue())\n-              critOids.add(extId.toString());\n-            else\n-              nonCritOids.add(extId.toString());\n+            if (!ext.isConstructed())\n+              throw new IOException(\"malformed Extension\");\n+            Extension e = new Extension(ext.getEncoded());\n+            extensions.put(e.getOid(), e);\n+            der.skip(ext.getLength());\n             len += ext.getEncodedLength();\n+            debug(\"current count == \" + len);\n           }\n+        val = der.read();\n       }\n \n-    val = der.read();\n+    debug(\"read tag == \" + val.getTag());\n     if (!val.isConstructed())\n-      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+      throw new IOException(\"malformed AlgorithmIdentifier\");\n+    debug(\"start AlgorithmIdentifier  len == \" + val.getLength());\n     DERValue sigAlgVal = der.read();\n+    debug(\"read tag == \" + sigAlgVal.getTag());\n+    if (sigAlgVal.getTag() != DER.OBJECT_IDENTIFIER)\n+      throw new IOException(\"malformed AlgorithmIdentifier\");\n     sigAlg = (OID) sigAlgVal.getValue();\n+    debug(\"signature id == \" + sigAlg);\n+    debug(\"sigAlgVal length == \" + sigAlgVal.getEncodedLength());\n     if (val.getLength() > sigAlgVal.getEncodedLength())\n       {\n         val = der.read();\n+        debug(\"sig params tag = \" + val.getTag() + \" len == \" + val.getEncodedLength());\n         sigAlgParams = (byte[]) val.getEncoded();\n         if (val.isConstructed())\n           in.skip(val.getLength());\n       }\n     val = der.read();\n+    debug(\"read tag = \" + val.getTag());\n     rawSig = val.getEncoded();\n     signature = ((BitString) val.getValue()).toByteArray();\n   }"}, {"sha": "252737c0eaa3fb40fa12d4483eadfb50c7b72d19", "filename": "libjava/gnu/java/security/x509/X509CRLEntry.java", "status": "modified", "additions": 97, "deletions": 52, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLEntry.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -1,13 +1,13 @@\n-/* X509CRLEntry.java -- entry in a X.509 CRL.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+/* X509CRLEntry.java -- an entry in a X.509 CRL.\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -45,17 +45,17 @@\n \n import java.security.cert.CRLException;\n \n+import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.Set;\n \n-import gnu.java.io.ASN1ParsingException;\n import gnu.java.security.OID;\n-import gnu.java.security.der.DERReader;\n-import gnu.java.security.der.DERValue;\n-import gnu.java.security.der.DERWriter;\n+import gnu.java.security.der.*;\n+import gnu.java.security.x509.ext.*;\n \n /**\n  * A single entry in a X.509 certificate revocation list.\n@@ -64,11 +64,22 @@\n  * @author Casey Marshall\n  */\n class X509CRLEntry extends java.security.cert.X509CRLEntry\n+  implements GnuPKIExtension\n {\n \n   // Constants and fields.\n   // ------------------------------------------------------------------------\n \n+  private static final boolean DEBUG = false;\n+  private static void debug(String msg)\n+  {\n+    if (DEBUG)\n+      {\n+        System.err.print(\">> X509CRLEntry: \");\n+        System.err.println(msg);\n+      }\n+  }\n+\n   /** The DER encoded form of this CRL entry. */\n   private byte[] encoded;\n \n@@ -78,15 +89,9 @@ class X509CRLEntry extends java.security.cert.X509CRLEntry\n   /** The date the certificate was revoked. */\n   private Date revocationDate;\n \n-  /** The encoded extensions. */\n+  /** The CRL entry extensions. */\n   private HashMap extensions;\n \n-  /** The set of critical extension OIDs. */\n-  private HashSet critOids;\n-\n-  /** the set of non-critical extension OIDs. */\n-  private HashSet nonCritOids;\n-\n   // Constructor.\n   // ------------------------------------------------------------------------\n \n@@ -99,13 +104,11 @@ class X509CRLEntry extends java.security.cert.X509CRLEntry\n    * @throws CRLException If the ASN.1 structure is invalid.\n    * @throws IOException  If the bytes cannot be read.\n    */\n-  X509CRLEntry(int version, InputStream encoded)\n+  X509CRLEntry(int version, DERReader encoded)\n     throws CRLException, IOException\n   {\n     super();\n     extensions = new HashMap();\n-    critOids = new HashSet();\n-    nonCritOids = new HashSet();\n     try\n       {\n         parse(version, encoded);\n@@ -125,8 +128,10 @@ class X509CRLEntry extends java.security.cert.X509CRLEntry\n \n   public boolean equals(Object o)\n   {\n-    return ((X509CRLEntry) o).serialNo.equals(serialNo) &&\n-           ((X509CRLEntry) o).revocationDate.equals(revocationDate);\n+    if (!(o instanceof X509CRLEntry))\n+      return false;\n+    return ((X509CRLEntry) o).getSerialNumber().equals(serialNo) &&\n+           ((X509CRLEntry) o).getRevocationDate().equals(revocationDate);\n   }\n \n   public int hashCode()\n@@ -157,79 +162,119 @@ public boolean hasExtensions()\n   public String toString()\n   {\n     return \"X509CRLEntry serial=\" + serialNo + \" revocation date=\"\n-      + revocationDate + \" critExt=\" + critOids + \" ext=\" + nonCritOids;\n+      + revocationDate + \" ext=\" + extensions;\n   }\n \n   // X509Extension methods.\n-  // ------------------------------------------------------------------------\n+  // -------------------------------------------------------------------------\n \n   public boolean hasUnsupportedCriticalExtension()\n   {\n-    return false; // XXX\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (e.isCritical() && !e.isSupported())\n+          return true;\n+      }\n+    return false;\n   }\n \n   public Set getCriticalExtensionOIDs()\n   {\n-    return Collections.unmodifiableSet(critOids);\n+    HashSet s = new HashSet();\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (e.isCritical())\n+          s.add(e.getOid().toString());\n+      }\n+    return Collections.unmodifiableSet(s);\n   }\n \n   public Set getNonCriticalExtensionOIDs()\n   {\n-    return Collections.unmodifiableSet(nonCritOids);\n+    HashSet s = new HashSet();\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (!e.isCritical())\n+          s.add(e.getOid().toString());\n+      }\n+    return Collections.unmodifiableSet(s);\n   }\n \n   public byte[] getExtensionValue(String oid)\n   {\n-    byte[] ext = (byte[]) extensions.get(oid);\n-    if (ext != null)\n-      return (byte[]) ext.clone();\n+    Extension e = getExtension(new OID(oid));\n+    if (e != null)\n+      {\n+        return e.getValue().getEncoded();\n+      }\n     return null;\n   }\n \n+  // GnuPKIExtension method.\n+  // -------------------------------------------------------------------------\n+\n+  public Extension getExtension(OID oid)\n+  {\n+    return (Extension) extensions.get(oid);\n+  }\n+\n+  public Collection getExtensions()\n+  {\n+    return extensions.values();\n+  }\n+\n   // Own methods.\n-  // ------------------------------------------------------------------------\n+  // -------------------------------------------------------------------------\n \n-  private void parse(int version, InputStream in) throws Exception\n+  private void parse(int version, DERReader der) throws Exception\n   {\n-    DERReader der = new DERReader(in);\n+    // RevokedCertificate ::= SEQUENCE {\n     DERValue entry = der.read();\n+    debug(\"start CRL entry   len == \" + entry.getLength());\n     if (!entry.isConstructed())\n-      throw new ASN1ParsingException(\"malformed revokedCertificate\");\n+      throw new IOException(\"malformed revokedCertificate\");\n     encoded = entry.getEncoded();\n     int len = 0;\n+\n+    debug(\"encoded entry:\\n\" + Util.hexDump(encoded, \">>>> \"));\n+\n+    //   userCertificate   CertificateSerialNumber,\n     DERValue val = der.read();\n     serialNo = (BigInteger) val.getValue();\n-    len += DERWriter.definiteEncodingSize(val.getLength())\n-         + val.getLength() + 1;\n+    len += val.getEncodedLength();\n+    debug(\"userCertificate == \" + serialNo + \"  current count == \" + len);\n+\n+    //   revocationDate   Time,\n     val = der.read();\n     revocationDate = (Date) val.getValue();\n-    len += DERWriter.definiteEncodingSize(val.getLength())\n-         + val.getLength() + 1;\n+    len += val.getEncodedLength();\n+    debug(\"revocationDate == \" + revocationDate + \"  current count == \" + len);\n \n+    //   crlEntryExtensions   Extensions OPTIONAL\n+    //                          -- if present MUST be v2\n     if (len < entry.getLength())\n       {\n         if (version < 2)\n-          throw new ASN1ParsingException(\"extra data in CRL entry\");\n-        while (len < entry.getLength())\n+          throw new IOException(\"extra data in CRL entry\");\n+        DERValue exts = der.read();\n+        if (!exts.isConstructed())\n+          throw new IOException(\"malformed Extensions\");\n+        debug(\"start Extensions  len == \" + exts.getLength());\n+        len = 0;\n+        while (len < exts.getLength())\n           {\n             val = der.read();\n             if (!val.isConstructed())\n-              throw new ASN1ParsingException(\"malformed Extension\");\n-            OID extOid = (OID) der.read().getValue();\n-            Boolean critical = Boolean.valueOf(false);\n-            DERValue val2 = der.read();\n-            if (val2.getValue() instanceof Boolean)\n-              {\n-                critical = (Boolean) val2.getValue();\n-                val2 = der.read();\n-              }\n-            byte[] ext = (byte[]) val2.getValue();\n-            extensions.put(extOid.toString(), ext);\n-            if (critical.booleanValue())\n-              critOids.add(extOid.toString());\n-            else\n-              nonCritOids.add(extOid.toString());\n+              throw new IOException(\"malformed Extension\");\n+            debug(\"start Extension  len == \" + val.getLength());\n+            Extension e = new Extension(val.getEncoded());\n+            extensions.put(e.getOid(), e);\n+            der.skip(val.getLength());\n             len += val.getEncodedLength();\n+            debug(\"current count == \" + len);\n           }\n       }\n   }"}, {"sha": "c409779ec64f318680517c6c8604fe6d6fbbd419", "filename": "libjava/gnu/java/security/x509/X509CRLSelectorImpl.java", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLSelectorImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLSelectorImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLSelectorImpl.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,138 @@\n+/* X509CRLSelectorImpl.java -- implementation of an X509CRLSelector.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.io.IOException;\n+\n+import java.security.Principal;\n+import java.security.cert.CRL;\n+import java.security.cert.CRLSelector;\n+import java.security.cert.X509CRL;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+/**\n+ * Sun's implementation of X509CRLSelector sucks. This one tries to work\n+ * better.\n+ */\n+public class X509CRLSelectorImpl implements CRLSelector\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private Set issuerNames;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public X509CRLSelectorImpl()\n+  {\n+    issuerNames = new HashSet();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public void addIssuerName(byte[] issuerName) throws IOException\n+  {\n+    issuerNames.add(new X500DistinguishedName(issuerName));\n+  }\n+\n+  public void addIssuerName(String issuerName)\n+  {\n+    issuerNames.add(new X500DistinguishedName(issuerName));\n+  }\n+\n+  public void addIssuerName(Principal issuerName) throws IOException\n+  {\n+    if (issuerName instanceof X500DistinguishedName)\n+      issuerNames.add(issuerName);\n+    else if (issuerName instanceof X500Principal)\n+      issuerNames.add(new X500DistinguishedName(((X500Principal) issuerName).getEncoded()));\n+    else\n+      issuerNames.add(new X500DistinguishedName(issuerName.getName()));\n+  }\n+\n+  public Collection getIssuerNames()\n+  {\n+    return Collections.unmodifiableSet(issuerNames);\n+  }\n+\n+  public Object clone()\n+  {\n+    X509CRLSelectorImpl copy = new X509CRLSelectorImpl();\n+    copy.issuerNames.addAll(issuerNames);\n+    return copy;\n+  }\n+\n+  public boolean match(CRL crl)\n+  {\n+    if (!(crl instanceof X509CRL))\n+      return false;\n+    try\n+      {\n+        Principal p = ((X509CRL) crl).getIssuerDN();\n+        X500DistinguishedName thisName = null;\n+        if (p instanceof X500DistinguishedName)\n+          thisName = (X500DistinguishedName) p;\n+        else if (p instanceof X500Principal)\n+          thisName = new X500DistinguishedName(((X500Principal) p).getEncoded());\n+        else\n+          thisName = new X500DistinguishedName(p.getName());\n+        for (Iterator it = issuerNames.iterator(); it.hasNext(); )\n+          {\n+            X500DistinguishedName name = (X500DistinguishedName) it.next();\n+            if (thisName.equals(name))\n+              return true;\n+          }\n+      }\n+    catch (Exception x)\n+      {\n+      }\n+    return false;\n+  }\n+}\n+"}, {"sha": "0990abda0593d7395c9b3afb09db09f178f6b7d8", "filename": "libjava/gnu/java/security/x509/X509CertPath.java", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CertPath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CertPath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CertPath.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,306 @@\n+/* X509CertPath.java -- an X.509 certificate path.\n+   Copyright (C) 2004  Free Software Fonudation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertPath;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DEREncodingException;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+/**\n+ * A certificate path (or certificate chain) of X509Certificates.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class X509CertPath extends CertPath\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final List ENCODINGS = Collections.unmodifiableList(\n+    Arrays.asList(new String[] { \"PkiPath\", \"PKCS7\" }));\n+\n+  private static final OID PKCS7_SIGNED_DATA = new OID(\"1.2.840.113549.1.7.2\");\n+  private static final OID PKCS7_DATA = new OID(\"1.2.840.113549.1.7.1\");\n+\n+  /** The certificate path. */\n+  private List path;\n+\n+  /** The cached PKCS #7 encoded bytes. */\n+  private byte[] pkcs_encoded;\n+\n+  /** The cached PkiPath encoded bytes. */\n+  private byte[] pki_encoded;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public X509CertPath(List path)\n+  {\n+    super(\"X.509\");\n+    this.path = Collections.unmodifiableList(path);\n+  }\n+\n+  public X509CertPath(InputStream in) throws CertificateEncodingException\n+  {\n+    this(in, (String) ENCODINGS.get(0));\n+  }\n+\n+  public X509CertPath(InputStream in, String encoding)\n+    throws CertificateEncodingException\n+  {\n+    super(\"X.509\");\n+    try\n+      {\n+        parse(in, encoding);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new CertificateEncodingException();\n+      }\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public List getCertificates()\n+  {\n+    return path; // already unmodifiable\n+  }\n+\n+  public byte[] getEncoded() throws CertificateEncodingException\n+  {\n+    return getEncoded((String) ENCODINGS.get(0));\n+  }\n+\n+  public byte[] getEncoded(String encoding) throws CertificateEncodingException\n+  {\n+    if (encoding.equalsIgnoreCase(\"PkiPath\"))\n+      {\n+        if (pki_encoded == null)\n+          {\n+            try\n+              {\n+                pki_encoded = encodePki();\n+              }\n+            catch (IOException ioe)\n+              {\n+                throw new CertificateEncodingException();\n+              }\n+          }\n+        return (byte[]) pki_encoded.clone();\n+      }\n+    else if (encoding.equalsIgnoreCase(\"PKCS7\"))\n+      {\n+        if (pkcs_encoded == null)\n+          {\n+            try\n+              {\n+                pkcs_encoded = encodePKCS();\n+              }\n+            catch (IOException ioe)\n+              {\n+                throw new CertificateEncodingException();\n+              }\n+          }\n+        return (byte[]) pkcs_encoded.clone();\n+      }\n+    else\n+      throw new CertificateEncodingException(\"unknown encoding: \" + encoding);\n+  }\n+\n+  public Iterator getEncodings()\n+  {\n+    return ENCODINGS.iterator(); // already unmodifiable\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  private void parse(InputStream in, String encoding)\n+    throws CertificateEncodingException, IOException\n+  {\n+    DERReader der = new DERReader(in);\n+    DERValue path = null;\n+    if (encoding.equalsIgnoreCase(\"PkiPath\"))\n+      {\n+        // PKI encoding is just a SEQUENCE of X.509 certificates.\n+        path = der.read();\n+        if (!path.isConstructed())\n+          throw new DEREncodingException(\"malformed PkiPath\");\n+      }\n+    else if (encoding.equalsIgnoreCase(\"PKCS7\"))\n+      {\n+        // PKCS #7 encoding means that the certificates are contained in a\n+        // SignedData PKCS #7 type.\n+        //\n+        // ContentInfo ::= SEQUENCE {\n+        //   contentType ::= ContentType,\n+        //   content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }\n+        //\n+        // ContentType ::= OBJECT IDENTIFIER\n+        //\n+        // SignedData ::= SEQUENCE {\n+        //   version Version,\n+        //   digestAlgorithms DigestAlgorithmIdentifiers,\n+        //   contentInfo ContentInfo,\n+        //   certificates [0] IMPLICIT ExtendedCertificatesAndCertificates\n+        //                    OPTIONAL,\n+        //   crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,\n+        //   signerInfos SignerInfos }\n+        //\n+        // Version ::= INTEGER\n+        //\n+        DERValue value = der.read();\n+        if (!value.isConstructed())\n+          throw new DEREncodingException(\"malformed ContentInfo\");\n+        value = der.read();\n+        if (!(value.getValue() instanceof OID) ||\n+            ((OID) value.getValue()).equals(PKCS7_SIGNED_DATA))\n+          throw new DEREncodingException(\"not a SignedData\");\n+        value = der.read();\n+        if (!value.isConstructed() || value.getTag() != 0)\n+          throw new DEREncodingException(\"malformed content\");\n+        value = der.read();\n+        if (value.getTag() != DER.INTEGER)\n+          throw new DEREncodingException(\"malformed Version\");\n+        value = der.read();\n+        if (!value.isConstructed() || value.getTag() != DER.SET)\n+          throw new DEREncodingException(\"malformed DigestAlgorithmIdentifiers\");\n+        der.skip(value.getLength());\n+        value = der.read();\n+        if (!value.isConstructed())\n+          throw new DEREncodingException(\"malformed ContentInfo\");\n+        der.skip(value.getLength());\n+        path = der.read();\n+        if (!path.isConstructed() || path.getTag() != 0)\n+          throw new DEREncodingException(\"no certificates\");\n+      }\n+    else\n+      throw new CertificateEncodingException(\"unknown encoding: \" + encoding);\n+\n+    LinkedList certs = new LinkedList();\n+    int len = 0;\n+    while (len < path.getLength())\n+      {\n+        DERValue cert = der.read();\n+        try\n+          {\n+            certs.add(new X509Certificate(new ByteArrayInputStream(cert.getEncoded())));\n+          }\n+        catch (CertificateException ce)\n+          {\n+            throw new CertificateEncodingException(ce.getMessage());\n+          }\n+        len += cert.getEncodedLength();\n+        der.skip(cert.getLength());\n+      }\n+\n+    this.path = Collections.unmodifiableList(certs);\n+  }\n+\n+  private byte[] encodePki()\n+    throws CertificateEncodingException, IOException\n+  {\n+    synchronized (path)\n+      {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        for (Iterator i = path.iterator(); i.hasNext(); )\n+          {\n+            out.write(((Certificate) i.next()).getEncoded());\n+          }\n+        byte[] b = out.toByteArray();\n+        DERValue val = new DERValue(DER.CONSTRUCTED | DER.SEQUENCE,\n+                                    b.length, b, null);\n+        return val.getEncoded();\n+      }\n+  }\n+\n+  private byte[] encodePKCS()\n+    throws CertificateEncodingException, IOException\n+  {\n+    synchronized (path)\n+      {\n+        ArrayList signedData = new ArrayList(5);\n+        signedData.add(new DERValue(DER.INTEGER, BigInteger.ONE));\n+        signedData.add(new DERValue(DER.CONSTRUCTED | DER.SET,\n+                                    Collections.EMPTY_SET));\n+        signedData.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE,\n+          Collections.singletonList(\n+            new DERValue(DER.OBJECT_IDENTIFIER, PKCS7_DATA))));\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        for (Iterator i = path.iterator(); i.hasNext(); )\n+          {\n+            out.write(((Certificate) i.next()).getEncoded());\n+          }\n+        byte[] b = out.toByteArray();\n+        signedData.add(new DERValue(DER.CONSTRUCTED | DER.CONTEXT,\n+                                    b.length, b, null));\n+        DERValue sdValue = new DERValue(DER.CONSTRUCTED | DER.SEQUENCE,\n+                                        signedData);\n+\n+        ArrayList contentInfo = new ArrayList(2);\n+        contentInfo.add(new DERValue(DER.OBJECT_IDENTIFIER, PKCS7_SIGNED_DATA));\n+        contentInfo.add(new DERValue(DER.CONSTRUCTED | DER.CONTEXT, sdValue));\n+        return new DERValue(DER.CONSTRUCTED | DER.SEQUENCE,\n+                            contentInfo).getEncoded();\n+      }\n+  }\n+}"}, {"sha": "4535cce6d7d03fce00c1b28b1d6da10974a487dd", "filename": "libjava/gnu/java/security/x509/X509CertSelectorImpl.java", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CertSelectorImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CertSelectorImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CertSelectorImpl.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,199 @@\n+/* X509CertSelectorImpl.java -- implementation of an X509CertSelector.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.io.IOException;\n+\n+import java.security.Principal;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertSelector;\n+import java.security.cert.X509Certificate;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+/**\n+ * Sun's implementation of X509CertSelector sucks. This one tries to work\n+ * better.\n+ */\n+public class X509CertSelectorImpl implements CertSelector\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private Set issuerNames;\n+  private Set subjectNames;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public X509CertSelectorImpl()\n+  {\n+    issuerNames = new HashSet();\n+    subjectNames = new HashSet();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public void addIssuerName(byte[] issuerName) throws IOException\n+  {\n+    issuerNames.add(new X500DistinguishedName(issuerName));\n+  }\n+\n+  public void addIssuerName(String issuerName)\n+  {\n+    issuerNames.add(new X500DistinguishedName(issuerName));\n+  }\n+\n+  public void addIssuerName(Principal issuerName) throws IOException\n+  {\n+    if (issuerName instanceof X500DistinguishedName)\n+      issuerNames.add(issuerName);\n+    else if (issuerName instanceof X500Principal)\n+      issuerNames.add(new X500DistinguishedName(((X500Principal) issuerName).getEncoded()));\n+    else\n+      issuerNames.add(new X500DistinguishedName(issuerName.getName()));\n+  }\n+\n+  public Collection getIssuerNames()\n+  {\n+    return Collections.unmodifiableSet(issuerNames);\n+  }\n+\n+  public void addSubjectName(byte[] subjectName) throws IOException\n+  {\n+    subjectNames.add(new X500DistinguishedName(subjectName));\n+  }\n+\n+  public void addSubjectName(String subjectName) throws IOException\n+  {\n+    subjectNames.add(new X500DistinguishedName(subjectName));\n+  }\n+\n+  public void addSubjectName(Principal subjectName) throws IOException\n+  {\n+    if (subjectName instanceof X500DistinguishedName)\n+      subjectNames.add(subjectName);\n+    else if (subjectName instanceof X500Principal)\n+      subjectNames.add(new X500DistinguishedName(((X500Principal) subjectName).getEncoded()));\n+    else\n+      subjectNames.add(new X500DistinguishedName(subjectName.getName()));\n+  }\n+\n+  public Collection getSubjectNames()\n+  {\n+    return Collections.unmodifiableSet(subjectNames);\n+  }\n+\n+  public Object clone()\n+  {\n+    X509CertSelectorImpl copy = new X509CertSelectorImpl();\n+    copy.issuerNames.addAll(issuerNames);\n+    copy.subjectNames.addAll(subjectNames);\n+    return copy;\n+  }\n+\n+  public boolean match(Certificate cert)\n+  {\n+    if (!(cert instanceof X509Certificate))\n+      return false;\n+    boolean matchIssuer = false;\n+    boolean matchSubject = false;\n+    try\n+      {\n+        Principal p = ((X509Certificate) cert).getIssuerDN();\n+        X500DistinguishedName thisName = null;\n+        if (p instanceof X500DistinguishedName)\n+          thisName = (X500DistinguishedName) p;\n+        else if (p instanceof X500Principal)\n+          thisName = new X500DistinguishedName(((X500Principal) p).getEncoded());\n+        else\n+          thisName = new X500DistinguishedName(p.getName());\n+        if (issuerNames.isEmpty())\n+          matchIssuer = true;\n+        else\n+          {\n+            for (Iterator it = issuerNames.iterator(); it.hasNext(); )\n+              {\n+                X500DistinguishedName name = (X500DistinguishedName) it.next();\n+                if (thisName.equals(name))\n+                  {\n+                    matchIssuer = true;\n+                    break;\n+                  }\n+              }\n+          }\n+\n+        p = ((X509Certificate) cert).getSubjectDN();\n+        thisName = null;\n+        if (p instanceof X500DistinguishedName)\n+          thisName = (X500DistinguishedName) p;\n+        else if (p instanceof X500Principal)\n+          thisName = new X500DistinguishedName(((X500Principal) p).getEncoded());\n+        else\n+          thisName = new X500DistinguishedName(p.getName());\n+        if (subjectNames.isEmpty())\n+          matchSubject = true;\n+        else\n+          {\n+            for (Iterator it = subjectNames.iterator(); it.hasNext(); )\n+              {\n+                X500DistinguishedName name = (X500DistinguishedName) it.next();\n+                if (thisName.equals(name))\n+                  {\n+                    matchSubject = true;\n+                    break;\n+                  }\n+              }\n+          }\n+      }\n+    catch (Exception x)\n+      {\n+      }\n+    return matchIssuer && matchSubject;\n+  }\n+}\n+"}, {"sha": "25a56d4a8ef343beeb549129fe3be946708b5e14", "filename": "libjava/gnu/java/security/x509/X509Certificate.java", "status": "modified", "additions": 327, "deletions": 277, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509Certificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509Certificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509Certificate.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -1,13 +1,13 @@\n /* X509Certificate.java -- X.509 certificate.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -42,7 +42,9 @@\n import java.io.InputStream;\n import java.io.IOException;\n import java.io.ObjectStreamException;\n+import java.io.PrintWriter;\n import java.io.Serializable;\n+import java.io.StringWriter;\n \n import java.math.BigInteger;\n \n@@ -64,10 +66,12 @@\n import java.security.cert.CertificateNotYetValidException;\n import java.security.cert.CertificateParsingException;\n \n+import java.security.interfaces.DSAParams;\n+import java.security.interfaces.DSAPublicKey;\n import java.security.spec.DSAParameterSpec;\n-import java.security.spec.DSAPublicKeySpec;\n-import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n \n+import java.util.Arrays;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n@@ -77,83 +81,79 @@\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import javax.security.auth.x500.X500Principal;\n \n-import gnu.java.io.ASN1ParsingException;\n import gnu.java.security.OID;\n-import gnu.java.security.der.BitString;\n-import gnu.java.security.der.DER;\n-import gnu.java.security.der.DERReader;\n-import gnu.java.security.der.DERValue;\n-import gnu.java.security.der.DERWriter;\n+import gnu.java.security.der.*;\n+import gnu.java.security.x509.ext.*;\n \n /**\n  * An implementation of X.509 certificates.\n  *\n  * @author Casey Marshall (rsdio@metastatic.org)\n  */\n public class X509Certificate extends java.security.cert.X509Certificate\n-  implements Serializable\n+  implements Serializable, GnuPKIExtension\n {\n \n   // Constants and fields.\n   // ------------------------------------------------------------------------\n \n-  private static final OID ID_DSA = new OID(\"1.2.840.10040.4.1\");\n-  private static final OID ID_DSA_WITH_SHA1 = new OID(\"1.2.840.10040.4.3\");\n-  private static final OID ID_RSA = new OID(\"1.2.840.113549.1.1.1\");\n-  private static final OID ID_RSA_WITH_MD2 = new OID(\"1.2.840.113549.1.1.2\");\n-  private static final OID ID_RSA_WITH_MD5 = new OID(\"1.2.840.113549.1.1.4\");\n-  private static final OID ID_RSA_WITH_SHA1 = new OID(\"1.2.840.113549.1.1.5\");\n-\n-  private static final OID ID_EXTENSION = new OID(\"2.5.29\");\n-  private static final OID ID_KEY_USAGE = ID_EXTENSION.getChild(15);\n-  private static final OID ID_BASIC_CONSTRAINTS = ID_EXTENSION.getChild(19);\n-  private static final OID ID_EXT_KEY_USAGE = ID_EXTENSION.getChild(37);\n-\n-  private static final int OTHER_NAME     = 0;\n-  private static final int RFC882_NAME    = 1;\n-  private static final int DNS_NAME       = 2;\n-  private static final int X400_ADDRESS   = 3;\n-  private static final int DIRECTORY_NAME = 4;\n-  private static final int EDI_PARTY_NAME = 5;\n-  private static final int URI            = 6;\n-  private static final int IP_ADDRESS     = 7;\n-  private static final int REGISTERED_ID  = 8;\n+  private static final boolean DEBUG = false;\n+  private static void debug(String msg)\n+  {\n+    if (DEBUG)\n+      {\n+        System.err.print(\">> X509Certificate: \");\n+        System.err.println(msg);\n+      }\n+  }\n+  private static void debug(Throwable t)\n+  {\n+    if (DEBUG)\n+      {\n+        System.err.print(\">> X509Certificate: \");\n+        t.printStackTrace();\n+      }\n+  }\n+\n+  protected static final OID ID_DSA = new OID (\"1.2.840.10040.4.1\");\n+  protected static final OID ID_DSA_WITH_SHA1 = new OID (\"1.2.840.10040.4.3\");\n+  protected static final OID ID_RSA = new OID (\"1.2.840.113549.1.1.1\");\n+  protected static final OID ID_RSA_WITH_MD2 = new OID (\"1.2.840.113549.1.1.2\");\n+  protected static final OID ID_RSA_WITH_MD5 = new OID (\"1.2.840.113549.1.1.4\");\n+  protected static final OID ID_RSA_WITH_SHA1 = new OID (\"1.2.840.113549.1.1.5\");\n+  protected static final OID ID_ECDSA_WITH_SHA1 = new OID (\"1.2.840.10045.4.1\");\n \n   // This object SHOULD be serialized with an instance of\n   // java.security.cert.Certificate.CertificateRep, thus all fields are\n   // transient.\n \n   // The encoded certificate.\n-  private transient byte[] encoded;\n+  protected transient byte[] encoded;\n \n   // TBSCertificate part.\n-  private transient byte[] tbsCertBytes;\n-  private transient int version;\n-  private transient BigInteger serialNo;\n-  private transient OID algId;\n-  private transient byte[] algVal;\n-  private transient X500Principal issuer;\n-  private transient Date notBefore;\n-  private transient Date notAfter;\n-  private transient X500Principal subject;\n-  private transient PublicKey subjectKey;\n-  private transient BitString issuerUniqueId;\n-  private transient BitString subjectUniqueId;\n-  private transient HashMap extensions;\n-  private transient HashSet critOids;\n-  private transient HashSet nonCritOids;\n-  \n-  private transient BitString keyUsage;\n-  private transient int basicConstraints = -1;\n+  protected transient byte[] tbsCertBytes;\n+  protected transient int version;\n+  protected transient BigInteger serialNo;\n+  protected transient OID algId;\n+  protected transient byte[] algVal;\n+  protected transient X500DistinguishedName issuer;\n+  protected transient Date notBefore;\n+  protected transient Date notAfter;\n+  protected transient X500DistinguishedName subject;\n+  protected transient PublicKey subjectKey;\n+  protected transient BitString issuerUniqueId;\n+  protected transient BitString subjectUniqueId;\n+  protected transient Map extensions;\n \n   // Signature.\n-  private transient OID sigAlgId;\n-  private transient byte[] sigAlgVal;\n-  private transient byte[] signature;\n+  protected transient OID sigAlgId;\n+  protected transient byte[] sigAlgVal;\n+  protected transient byte[] signature;\n \n   // Constructors.\n   // ------------------------------------------------------------------------\n@@ -173,22 +173,29 @@ public X509Certificate(InputStream encoded)\n   {\n     super();\n     extensions = new HashMap();\n-    critOids = new HashSet();\n-    nonCritOids = new HashSet();\n     try\n       {\n         parse(encoded);\n       }\n     catch (IOException ioe)\n       {\n+        debug(ioe);\n         throw ioe;\n       }\n     catch (Exception e)\n       {\n-        throw new CertificateException(e.toString());\n+        debug(e);\n+        CertificateException ce = new CertificateException(e.getMessage());\n+        ce.initCause (e);\n+        throw ce;\n       }\n   }\n \n+  protected X509Certificate()\n+  {\n+    extensions = new HashMap();\n+  }\n+\n   // X509Certificate methods.\n   // ------------------------------------------------------------------------\n \n@@ -202,9 +209,13 @@ public void checkValidity(Date date)\n     throws CertificateExpiredException, CertificateNotYetValidException\n   {\n     if (date.compareTo(notBefore) < 0)\n-      throw new CertificateNotYetValidException();\n+      {\n+        throw new CertificateNotYetValidException();\n+      }\n     if (date.compareTo(notAfter) > 0)\n-      throw new CertificateExpiredException();\n+      {\n+        throw new CertificateExpiredException();\n+      }\n   }\n \n   public int getVersion()\n@@ -219,22 +230,22 @@ public BigInteger getSerialNumber()\n \n   public Principal getIssuerDN()\n   {\n-    return getIssuerX500Principal();\n+    return issuer;\n   }\n \n   public X500Principal getIssuerX500Principal()\n   {\n-    return issuer;\n+    return new X500Principal(issuer.getDer());\n   }\n \n   public Principal getSubjectDN()\n   {\n-    return getSubjectX500Principal();\n+    return subject;\n   }\n \n   public X500Principal getSubjectX500Principal()\n   {\n-    return subject;\n+    return new X500Principal(subject.getDer());\n   }\n \n   public Date getNotBefore()\n@@ -260,15 +271,22 @@ public byte[] getSignature()\n   public String getSigAlgName()\n   {\n     if (sigAlgId.equals(ID_DSA_WITH_SHA1))\n-      return \"SHA1withDSA\";\n-    if (sigAlgId.equals(ID_RSA_WITH_MD2 ))\n-      return \"MD2withRSA\";\n-    if (sigAlgId.equals(ID_RSA_WITH_MD5 ))\n-      return \"MD5withRSA\";\n-    if (sigAlgId.equals(ID_RSA_WITH_SHA1 ))\n-      return \"SHA1withRSA\";\n+      {\n+        return \"SHA1withDSA\";\n+      }\n+    if (sigAlgId.equals(ID_RSA_WITH_MD2))\n+      {\n+        return \"MD2withRSA\";\n+      }\n+    if (sigAlgId.equals(ID_RSA_WITH_MD5))\n+      {\n+        return \"MD5withRSA\";\n+      }\n+    if (sigAlgId.equals(ID_RSA_WITH_SHA1))\n+      {\n+        return \"SHA1withRSA\";\n+      }\n     return \"unknown\";\n-    // return sigAlgId.getShortName();\n   }\n \n   public String getSigAlgOID()\n@@ -284,121 +302,154 @@ public byte[] getSigAlgParams()\n   public boolean[] getIssuerUniqueID()\n   {\n     if (issuerUniqueId != null)\n-      return issuerUniqueId.toBooleanArray();\n+      {\n+        return issuerUniqueId.toBooleanArray();\n+      }\n     return null;\n   }\n \n   public boolean[] getSubjectUniqueID()\n   {\n     if (subjectUniqueId != null)\n-      return subjectUniqueId.toBooleanArray();\n+      {\n+        return subjectUniqueId.toBooleanArray();\n+      }\n     return null;\n   }\n \n   public boolean[] getKeyUsage()\n   {\n-    if (keyUsage != null)\n-      return keyUsage.toBooleanArray();\n+    Extension e = getExtension(KeyUsage.ID);\n+    if (e != null)\n+      {\n+        KeyUsage ku = (KeyUsage) e.getValue();\n+        boolean[] result = new boolean[9];\n+        boolean[] b = ku.getKeyUsage().toBooleanArray();\n+        System.arraycopy(b, 0, result, 0, b.length);\n+        return result;\n+      }\n     return null;\n   }\n \n   public List getExtendedKeyUsage() throws CertificateParsingException\n   {\n-    byte[] ext = (byte[]) extensions.get(\"2.5.29.37\");\n-    if (ext == null)\n-      return null;\n-    LinkedList usages = new LinkedList();\n-    try\n+    Extension e = getExtension(ExtendedKeyUsage.ID);\n+    if (e != null)\n       {\n-        DERReader der = new DERReader(new ByteArrayInputStream(ext));\n-        DERValue seq = der.read();\n-        if (!seq.isConstructed())\n-          throw new CertificateParsingException();\n-        int len = 0;\n-        while (len < seq.getLength())\n+        List a = ((ExtendedKeyUsage) e.getValue()).getPurposeIds();\n+        List b = new ArrayList(a.size());\n+        for (Iterator it = a.iterator(); it.hasNext(); )\n           {\n-            DERValue oid = der.read();\n-            if (!(oid.getValue() instanceof OID))\n-              throw new CertificateParsingException();\n-            usages.add(oid.getValue().toString());\n-            len += DERWriter.definiteEncodingSize(oid.getLength())\n-                 + oid.getLength() + 1;\n+            b.add(it.next().toString());\n           }\n+        return Collections.unmodifiableList(b);\n       }\n-    catch (IOException ioe)\n-      {\n-        throw new CertificateParsingException();\n-      }\n-    return usages;\n+    return null;\n   }\n \n   public int getBasicConstraints()\n   {\n-    return basicConstraints;\n+    Extension e = getExtension(BasicConstraints.ID);\n+    if (e != null)\n+      {\n+        return ((BasicConstraints) e.getValue()).getPathLengthConstraint();\n+      }\n+    return -1;\n   }\n \n   public Collection getSubjectAlternativeNames()\n     throws CertificateParsingException\n   {\n-    byte[] ext = getExtensionValue(\"2.5.29.17\");\n-    if (ext == null)\n-      return null;\n-    return getAltNames(ext);\n+    Extension e = getExtension(SubjectAlternativeNames.ID);\n+    if (e != null)\n+      {\n+        return ((SubjectAlternativeNames) e.getValue()).getNames();\n+      }\n+    return null;\n   }\n \n   public Collection getIssuerAlternativeNames()\n     throws CertificateParsingException\n   {\n-    byte[] ext = getExtensionValue(\"2.5.29.18\");\n-    if (ext == null)\n-      return null;\n-    return getAltNames(ext);\n+    Extension e = getExtension(IssuerAlternativeNames.ID);\n+    if (e != null)\n+      {\n+        return ((IssuerAlternativeNames) e.getValue()).getNames();\n+      }\n+    return null;\n   }\n \n \f// X509Extension methods.\n   // ------------------------------------------------------------------------\n \n   public boolean hasUnsupportedCriticalExtension()\n   {\n-    for (Iterator it = critOids.iterator(); it.hasNext(); )\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n       {\n-        String oid = (String) it.next();\n-        if (!oid.equals(\"2.5.29.15\") && !oid.equals(\"2.5.29.17\") &&\n-            !oid.equals(\"2.5.29.18\") && !oid.equals(\"2.5.29.19\") &&\n-            !oid.equals(\"2.5.29.37\"))\n+        Extension e = (Extension) it.next();\n+        if (e.isCritical() && !e.isSupported())\n           return true;\n       }\n     return false;\n   }\n \n   public Set getCriticalExtensionOIDs()\n   {\n-    return Collections.unmodifiableSet(critOids);\n+    HashSet s = new HashSet();\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (e.isCritical())\n+          s.add(e.getOid().toString());\n+      }\n+    return Collections.unmodifiableSet(s);\n   }\n \n   public Set getNonCriticalExtensionOIDs()\n   {\n-    return Collections.unmodifiableSet(nonCritOids);\n+    HashSet s = new HashSet();\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        Extension e = (Extension) it.next();\n+        if (!e.isCritical())\n+          s.add(e.getOid().toString());\n+      }\n+    return Collections.unmodifiableSet(s);\n   }\n \n   public byte[] getExtensionValue(String oid)\n   {\n-    byte[] ext = (byte[]) extensions.get(oid);\n-    if (ext != null)\n-      return (byte[]) ext.clone();\n+    Extension e = getExtension(new OID(oid));\n+    if (e != null)\n+      {\n+        return e.getValue().getEncoded();\n+      }\n     return null;\n   }\n \n+  // GnuPKIExtension method.\n+  // -------------------------------------------------------------------------\n+\n+  public Extension getExtension(OID oid)\n+  {\n+    return (Extension) extensions.get(oid);\n+  }\n+\n+  public Collection getExtensions()\n+  {\n+    return extensions.values();\n+  }\n+\n   // Certificate methods.\n-  // ------------------------------------------------------------------------\n+  // -------------------------------------------------------------------------\n \n   public byte[] getEncoded() throws CertificateEncodingException\n   {\n     return (byte[]) encoded.clone();\n   }\n \n   public void verify(PublicKey key)\n-    throws CertificateException, NoSuchAlgorithmException, \n+    throws CertificateException, NoSuchAlgorithmException,\n            InvalidKeyException, NoSuchProviderException, SignatureException\n   {\n     Signature sig = Signature.getInstance(sigAlgId.toString());\n@@ -415,20 +466,76 @@ public void verify(PublicKey key, String provider)\n \n   public String toString()\n   {\n-    // XXX say more than this.\n-    return gnu.java.security.x509.X509Certificate.class.getName();\n+    StringWriter str = new StringWriter();\n+    PrintWriter out = new PrintWriter(str);\n+    out.println(X509Certificate.class.getName() + \" {\");\n+    out.println(\"  TBSCertificate {\");\n+    out.println(\"    version = \" + version + \";\");\n+    out.println(\"    serialNo = \" + serialNo + \";\");\n+    out.println(\"    signature = {\");\n+    out.println(\"      algorithm = \" + getSigAlgName() + \";\");\n+    out.print(\"      parameters =\");\n+    if (sigAlgVal != null)\n+      {\n+        out.println();\n+        out.print(Util.hexDump(sigAlgVal, \"        \"));\n+      }\n+    else\n+      {\n+        out.println(\" null;\");\n+      }\n+    out.println(\"    }\");\n+    out.println(\"    issuer = \" + issuer.getName() + \";\");\n+    out.println(\"    validity = {\");\n+    out.println(\"      notBefore = \" + notBefore + \";\");\n+    out.println(\"      notAfter  = \" + notAfter + \";\");\n+    out.println(\"    }\");\n+    out.println(\"    subject = \" + subject.getName() + \";\");\n+    out.println(\"    subjectPublicKeyInfo = {\");\n+    out.println(\"      algorithm = \" + subjectKey.getAlgorithm());\n+    out.println(\"      key =\");\n+    out.print(Util.hexDump(subjectKey.getEncoded(), \"        \"));\n+    out.println(\"    };\");\n+    out.println(\"    issuerUniqueId  = \" + issuerUniqueId + \";\");\n+    out.println(\"    subjectUniqueId = \" + subjectUniqueId + \";\");\n+    out.println(\"    extensions = {\");\n+    for (Iterator it = extensions.values().iterator(); it.hasNext(); )\n+      {\n+        out.println(\"      \" + it.next());\n+      }\n+    out.println(\"    }\");\n+    out.println(\"  }\");\n+    out.println(\"  signatureAlgorithm = \" + getSigAlgName() + \";\");\n+    out.println(\"  signatureValue =\");\n+    out.print(Util.hexDump(signature, \"    \"));\n+    out.println(\"}\");\n+    return str.toString();\n   }\n \n   public PublicKey getPublicKey()\n   {\n     return subjectKey;\n   }\n \n-  protected Object writeReplace() throws ObjectStreamException\n+  public boolean equals(Object other)\n   {\n-    return super.writeReplace();\n+    if (!(other instanceof X509Certificate))\n+      return false;\n+    try\n+      {\n+        if (other instanceof X509Certificate)\n+          return Arrays.equals(encoded, ((X509Certificate) other).encoded);\n+        byte[] enc = ((X509Certificate) other).getEncoded();\n+        if (enc == null)\n+          return false;\n+        return Arrays.equals(encoded, enc);\n+      }\n+    catch (CertificateEncodingException cee)\n+      {\n+        return false;\n+      }\n   }\n-  \n+\n   // Own methods.\n   // ------------------------------------------------------------------------\n \n@@ -438,68 +545,13 @@ protected Object writeReplace() throws ObjectStreamException\n   private void doVerify(Signature sig, PublicKey key)\n     throws CertificateException, InvalidKeyException, SignatureException\n   {\n+    debug(\"verifying sig=\" + sig + \" key=\" + key);\n     sig.initVerify(key);\n     sig.update(tbsCertBytes);\n     if (!sig.verify(signature))\n-      throw new CertificateException(\"signature not validated\");\n-  }\n-\n-  /**\n-   * Read a GeneralNames structure.\n-   */\n-  private List getAltNames(byte[] encoded)\n-    throws CertificateParsingException\n-  {\n-    LinkedList names = new LinkedList();\n-    try\n-      {\n-        ByteArrayInputStream in = new ByteArrayInputStream(encoded);\n-        DERReader der = new DERReader(in);\n-        DERValue seq = der.read();\n-        if (!seq.isConstructed())\n-          throw new CertificateParsingException();\n-        int len = 0;\n-        while (len < seq.getLength())\n-          {\n-            DERValue name = der.read();\n-            ArrayList pair = new ArrayList(2);\n-            Object nameVal = null;\n-            switch (name.getTag())\n-              {\n-                case RFC882_NAME:\n-                case DNS_NAME:\n-                case URI:\n-                  nameVal = new String((byte[]) name.getValue());\n-                  break;\n-                case IP_ADDRESS:\n-                  nameVal = InetAddress.getByAddress(\n-                    (byte[]) name.getValue()).getHostAddress();\n-                  break;\n-                case REGISTERED_ID:\n-                  nameVal = new OID((byte[]) name.getValue());\n-                  break;\n-                case OTHER_NAME:\n-                case X400_ADDRESS:\n-                case DIRECTORY_NAME:\n-                case EDI_PARTY_NAME:\n-                  nameVal = name.getEncoded();\n-                  break;\n-                default:\n-                  throw new CertificateParsingException();\n-              }\n-            pair.add(new Integer(name.getTag()));\n-            pair.add(nameVal);\n-            names.add(pair);\n-            if (name.isConstructed())\n-              in.skip(name.getLength());\n-            len += name.getEncodedLength();\n-          }\n-      }\n-    catch (IOException ioe)\n       {\n-        throw new CertificateParsingException(ioe.toString());\n+        throw new CertificateException(\"signature not validated\");\n       }\n-    return Collections.unmodifiableList(names);\n   }\n \n   /**\n@@ -513,184 +565,182 @@ private void parse(InputStream encoded) throws Exception\n \n     // Certificate ::= SEQUENCE {\n     DERValue cert = der.read();\n+    debug(\"start Certificate  len == \" + cert.getLength());\n+\n     this.encoded = cert.getEncoded();\n     if (!cert.isConstructed())\n-      throw new ASN1ParsingException(\"malformed Certificate\");\n+      {\n+        throw new IOException(\"malformed Certificate\");\n+      }\n \n     // TBSCertificate ::= SEQUENCE {\n     DERValue tbsCert = der.read();\n     if (tbsCert.getValue() != DER.CONSTRUCTED_VALUE)\n-      throw new ASN1ParsingException(\"malformed TBSCertificate\");\n+      {\n+        throw new IOException(\"malformed TBSCertificate\");\n+      }\n     tbsCertBytes = tbsCert.getEncoded();\n+    debug(\"start TBSCertificate  len == \" + tbsCert.getLength());\n \n+    // Version ::= INTEGER [0] { v1(0), v2(1), v3(2) }\n     DERValue val = der.read();\n     if (val.getTagClass() == DER.CONTEXT && val.getTag() == 0)\n       {\n-        // Version ::= INTEGER [0] { v1(0), v2(1), v3(2) }\n         version = ((BigInteger) der.read().getValue()).intValue() + 1;\n         val = der.read();\n       }\n     else\n       {\n         version = 1;\n       }\n+    debug(\"read version == \" + version);\n+\n     // SerialNumber ::= INTEGER\n     serialNo = (BigInteger) val.getValue();\n+    debug(\"read serial number == \" + serialNo);\n \n     // AlgorithmIdentifier ::= SEQUENCE {\n     val = der.read();\n     if (!val.isConstructed())\n-      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+      {\n+        throw new IOException(\"malformed AlgorithmIdentifier\");\n+      }\n     int certAlgLen = val.getLength();\n+    debug(\"start AlgorithmIdentifier  len == \" + certAlgLen);\n     val = der.read();\n+\n+    //   algorithm    OBJECT IDENTIFIER,\n     algId = (OID) val.getValue();\n+    debug(\"read algorithm ID == \" + algId);\n+\n+    //   parameters   ANY DEFINED BY algorithm OPTIONAL }\n     if (certAlgLen > val.getEncodedLength())\n       {\n         val = der.read();\n         if (val == null)\n-          algVal = null;\n+          {\n+            algVal = null;\n+          }\n         else\n-          algVal = val.getEncoded();\n+          {\n+            algVal = val.getEncoded();\n+          }\n         if (val.isConstructed())\n-          encoded.skip(val.getLength());\n+          {\n+            encoded.skip(val.getLength());\n+          }\n+        debug(\"read algorithm parameters == \" + algVal);\n       }\n \n-    issuer = new X500Principal(encoded);\n+    // issuer   Name,\n+    val = der.read();\n+    issuer = new X500DistinguishedName(val.getEncoded());\n+    der.skip(val.getLength());\n+    debug(\"read issuer == \" + issuer);\n \n+    // Validity ::= SEQUENCE {\n+    //   notBefore   Time,\n+    //   notAfter    Time }\n     if (!der.read().isConstructed())\n-      throw new ASN1ParsingException(\"malformed Validity\");\n+      {\n+        throw new IOException(\"malformed Validity\");\n+      }\n     notBefore = (Date) der.read().getValue();\n     notAfter  = (Date) der.read().getValue();\n+    debug(\"read notBefore == \" + notBefore);\n+    debug(\"read notAfter == \" + notAfter);\n \n-    subject = new X500Principal(encoded);\n-\n-    if (!der.read().isConstructed())\n-      throw new ASN1ParsingException(\"malformed SubjectPublicKeyInfo\");\n-   \n-    val = der.read();\n-    if (!val.isConstructed())\n-      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n-    int keyAlgLen = val.getLength();\n+    // subject   Name,\n     val = der.read();\n-    OID keyID = (OID) val.getValue();\n-    byte[] keyParams = null;\n-    if (keyAlgLen > val.getEncodedLength())\n+    subject = new X500DistinguishedName(val.getEncoded());\n+    der.skip(val.getLength());\n+    debug(\"read subject == \" + subject);\n+\n+    // SubjectPublicKeyInfo ::= SEQUENCE {\n+    //   algorithm         AlgorithmIdentifier,\n+    //   subjectPublicKey  BIT STRING }\n+    DERValue spki = der.read();\n+    if (!spki.isConstructed())\n       {\n-        val = der.read();\n-        keyParams = val.getEncoded();\n-        if (algVal == null)\n-          algVal = keyParams;\n-        if (val.isConstructed())\n-          encoded.skip(val.getLength());\n+        throw new IOException(\"malformed SubjectPublicKeyInfo\");\n       }\n-    val = der.read();\n-    byte[] keyVal = ((BitString) val.getValue()).toByteArray();\n+    KeyFactory spkFac = KeyFactory.getInstance(\"X.509\");\n+    subjectKey = spkFac.generatePublic(new X509EncodedKeySpec(spki.getEncoded()));\n+    der.skip(spki.getLength());\n+    debug(\"read subjectPublicKey == \" + subjectKey);\n \n-    if (keyID.equals(ID_DSA))\n-      {\n-        AlgorithmParameters params = AlgorithmParameters.getInstance(\"DSA\");\n-        params.init(keyParams, \"ASN.1\");\n-        KeyFactory keyFac = KeyFactory.getInstance(\"DSA\");\n-        DSAParameterSpec spec = (DSAParameterSpec)\n-          params.getParameterSpec(DSAParameterSpec.class);\n-        subjectKey = keyFac.generatePublic(new DSAPublicKeySpec(\n-          (BigInteger) new DERReader(keyVal).read().getValue(),\n-          spec.getP(), spec.getQ(), spec.getG()));\n-      }\n-    else if (keyID.equals(ID_RSA))\n+    if (version > 1)\n       {\n-        KeyFactory keyFac = KeyFactory.getInstance(\"RSA\");\n-        DERReader rsaKey = new DERReader(keyVal);\n-        if (!rsaKey.read().isConstructed())\n-          throw new ASN1ParsingException(\"malformed RSAPublicKey\");\n-        subjectKey = keyFac.generatePublic(new RSAPublicKeySpec(\n-          (BigInteger) rsaKey.read().getValue(),\n-          (BigInteger) rsaKey.read().getValue()));\n+        val = der.read();\n       }\n-    else\n-      throw new ASN1ParsingException(\"unknown key algorithm \" + keyID);\n-\n-    if (version > 1)\n-      val = der.read();\n     if (version >= 2 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 1)\n       {\n         byte[] b = (byte[]) val.getValue();\n         issuerUniqueId = new BitString(b, 1, b.length-1, b[0] & 0xFF);\n+        debug(\"read issuerUniqueId == \" + issuerUniqueId);\n         val = der.read();\n       }\n     if (version >= 2 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 2)\n       {\n         byte[] b = (byte[]) val.getValue();\n         subjectUniqueId = new BitString(b, 1, b.length-1, b[0] & 0xFF);\n+        debug(\"read subjectUniqueId == \" + subjectUniqueId);\n         val = der.read();\n       }\n     if (version >= 3 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 3)\n       {\n         val = der.read();\n+        debug(\"start Extensions  len == \" + val.getLength());\n         int len = 0;\n         while (len < val.getLength())\n           {\n             DERValue ext = der.read();\n-            OID extId = (OID) der.read().getValue();\n-            DERValue val2 = der.read();\n-            Boolean crit = Boolean.valueOf(false);\n-            if (val2.getValue() instanceof Boolean)\n-              {\n-                crit = (Boolean) val2.getValue();\n-                val2 = der.read();\n-              }\n-            byte[] extVal = (byte[]) val2.getValue();\n-            extensions.put(extId.toString(), extVal);\n-            if (crit.booleanValue())\n-              critOids.add(extId.toString());\n-            else\n-              nonCritOids.add(extId.toString());\n-            if (extId.equals(ID_KEY_USAGE))\n-              {\n-                keyUsage = (BitString) DERReader.read(extVal).getValue();\n-              }\n-            else if (extId.equals(ID_BASIC_CONSTRAINTS))\n-              {\n-                DERReader bc = new DERReader(extVal);\n-                DERValue constraints = bc.read();\n-                if (!constraints.isConstructed())\n-                  throw new ASN1ParsingException(\"malformed BasicConstraints\");\n-                if (constraints.getLength() > 0)\n-                  {\n-                    boolean ca = false;\n-                    int constr = -1;\n-                    val2 = bc.read();\n-                    if (val2.getValue() instanceof Boolean)\n-                      {\n-                        ca = ((Boolean) val2.getValue()).booleanValue();\n-                        if (constraints.getLength() > val2.getEncodedLength())\n-                          val2 = bc.read();\n-                      }\n-                    if (val2.getValue() instanceof BigInteger)\n-                      constr = ((BigInteger) val2.getValue()).intValue();\n-                    basicConstraints = constr;\n-                  }\n-              }\n+            debug(\"start extension  len == \" + ext.getLength());\n+            Extension e = new Extension(ext.getEncoded());\n+            extensions.put(e.getOid(), e);\n+            der.skip(ext.getLength());\n             len += ext.getEncodedLength();\n+            debug(\"count == \" + len);\n           }\n       }\n \n     val = der.read();\n     if (!val.isConstructed())\n-      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+      {\n+        throw new IOException(\"malformed AlgorithmIdentifier\");\n+      }\n     int sigAlgLen = val.getLength();\n+    debug(\"start AlgorithmIdentifier  len == \" + sigAlgLen);\n     val = der.read();\n     sigAlgId = (OID) val.getValue();\n+    debug(\"read algorithm id == \" + sigAlgId);\n     if (sigAlgLen > val.getEncodedLength())\n       {\n         val = der.read();\n         if (val.getValue() == null)\n-          sigAlgVal = keyParams;\n+          {\n+            if (subjectKey instanceof DSAPublicKey)\n+              {\n+                AlgorithmParameters params =\n+                  AlgorithmParameters.getInstance(\"DSA\");\n+                DSAParams dsap = ((DSAPublicKey) subjectKey).getParams();\n+                DSAParameterSpec spec =\n+                  new DSAParameterSpec(dsap.getP(), dsap.getQ(), dsap.getG());\n+                params.init(spec);\n+                sigAlgVal = params.getEncoded();\n+              }\n+          }\n         else\n-          sigAlgVal = (byte[]) val.getEncoded();\n+          {\n+            sigAlgVal = (byte[]) val.getEncoded();\n+          }\n         if (val.isConstructed())\n-          encoded.skip(val.getLength());\n+          {\n+            encoded.skip(val.getLength());\n+          }\n+        debug(\"read parameters == \" + sigAlgVal);\n       }\n     signature = ((BitString) der.read().getValue()).toByteArray();\n+    debug(\"read signature ==\\n\" + Util.hexDump(signature, \">>>> \"));\n   }\n }"}, {"sha": "6f4e00b3f074ff4bfe23477efd5b0747236991d7", "filename": "libjava/gnu/java/security/x509/ext/AuthorityKeyIdentifier.java", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FAuthorityKeyIdentifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FAuthorityKeyIdentifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FAuthorityKeyIdentifier.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,134 @@\n+/* AuthorityKeyIdentifier.java -- Authority key identifier extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.x509.Util;\n+\n+public class AuthorityKeyIdentifier extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.35\");\n+\n+  private final byte[] keyIdentifier;\n+  private final GeneralNames authorityCertIssuer;\n+  private final BigInteger authorityCertSerialNumber;\n+\n+  // Contstructor.\n+  // -------------------------------------------------------------------------\n+\n+  public AuthorityKeyIdentifier(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERReader der = new DERReader(encoded);\n+\n+    // AuthorityKeyIdentifier ::= SEQUENCE {\n+    DERValue val = der.read();\n+    if (!val.isConstructed())\n+      throw new IOException(\"malformed AuthorityKeyIdentifier\");\n+    if (val.getLength() > 0)\n+      val = der.read();\n+\n+    //   keyIdentifier  [0] KeyIdentifier OPTIONAL,\n+    //   KeyIdentifier ::= OCTET STRING\n+    if (val.getTagClass() == DER.APPLICATION && val.getTag() == 0)\n+      {\n+        keyIdentifier = (byte[]) val.getValue();\n+        val = der.read();\n+      }\n+    else\n+      keyIdentifier = null;\n+\n+    //   authorityCertIssuer  [1] GeneralNames OPTIONAL,\n+    if (val.getTagClass() == DER.APPLICATION && val.getTag() == 1)\n+      {\n+        byte[] b = val.getEncoded();\n+        b[0] = (byte) (DER.CONSTRUCTED|DER.SEQUENCE);\n+        authorityCertIssuer = new GeneralNames(b);\n+        der.skip(val.getLength());\n+        val = der.read();\n+      }\n+    else\n+      authorityCertIssuer = null;\n+\n+    //   authorityCertSerialNumber  [2] CertificateSerialNumber OPTIONAL }\n+    if (val.getTagClass() == DER.APPLICATION && val.getTag() == 2)\n+      {\n+        authorityCertSerialNumber = new BigInteger((byte[]) val.getValue());\n+      }\n+    else\n+      authorityCertSerialNumber = null;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public byte[] getKeyIdentifier()\n+  {\n+    return keyIdentifier != null ? (byte[]) keyIdentifier.clone() : null;\n+  }\n+\n+  public GeneralNames getAuthorityCertIssuer()\n+  {\n+    return authorityCertIssuer;\n+  }\n+\n+  public BigInteger getAuthorityCertSerialNumber()\n+  {\n+    return authorityCertSerialNumber;\n+  }\n+\n+  public String toString()\n+  {\n+    return AuthorityKeyIdentifier.class.getName() + \" [ keyId=\" +\n+      (keyIdentifier != null ? Util.toHexString (keyIdentifier, ':') : \"nil\") +\n+      \" authorityCertIssuer=\" + authorityCertIssuer +\n+      \" authorityCertSerialNumbe=\" + authorityCertSerialNumber + \" ]\";\n+  }\n+}"}, {"sha": "f720d22a9c041cd56ae5b33459bf3601ea8a2766", "filename": "libjava/gnu/java/security/x509/ext/BasicConstraints.java", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FBasicConstraints.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FBasicConstraints.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FBasicConstraints.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,129 @@\n+/* BasicConstraints.java -- the basic constraints extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class BasicConstraints extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.19\");\n+\n+  private final boolean ca;\n+  private final int pathLenConstraint;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public BasicConstraints(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERReader der = new DERReader(encoded);\n+    DERValue bc = der.read();\n+    if (!bc.isConstructed())\n+      throw new IOException(\"malformed BasicConstraints\");\n+    DERValue val = bc;\n+    if (bc.getLength() > 0)\n+      val = der.read();\n+    if (val.getTag() == DER.BOOLEAN)\n+      {\n+        ca = ((Boolean) val.getValue()).booleanValue();\n+        if (val.getEncodedLength() < bc.getLength())\n+          val = der.read();\n+      }\n+    else\n+      ca = false;\n+    if (val.getTag() == DER.INTEGER)\n+      {\n+        pathLenConstraint = ((BigInteger) val.getValue()).intValue();\n+      }\n+    else\n+      pathLenConstraint = -1;\n+  }\n+\n+  public BasicConstraints (final boolean ca, final int pathLenConstraint)\n+  {\n+    this.ca = ca;\n+    this.pathLenConstraint = pathLenConstraint;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public boolean isCA()\n+  {\n+    return ca;\n+  }\n+\n+  public int getPathLengthConstraint()\n+  {\n+    return pathLenConstraint;\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encoded == null)\n+      {\n+        List bc = new ArrayList (2);\n+        bc.add (new DERValue (DER.BOOLEAN, new Boolean (ca)));\n+        if (pathLenConstraint >= 0)\n+          bc.add (new DERValue (DER.INTEGER,\n+                                BigInteger.valueOf ((long) pathLenConstraint)));\n+        encoded = new DERValue (DER.CONSTRUCTED|DER.SEQUENCE, bc).getEncoded();\n+      }\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public String toString()\n+  {\n+    return BasicConstraints.class.getName() + \" [ isCA=\" + ca +\n+      \" pathLen=\" + pathLenConstraint + \" ]\";\n+  }\n+}"}, {"sha": "556aa303a3b3f91c58527bbd6ba96bfd474986ed", "filename": "libjava/gnu/java/security/x509/ext/CRLNumber.java", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FCRLNumber.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FCRLNumber.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FCRLNumber.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,97 @@\n+/* CRLNumber.java -- CRL number extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class CRLNumber extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.20\");\n+\n+  private final BigInteger number;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public CRLNumber(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERValue val = DERReader.read(encoded);\n+    if (val.getTag() != DER.INTEGER)\n+      throw new IOException(\"malformed CRLNumber\");\n+    number = (BigInteger) val.getValue();\n+  }\n+\n+  public CRLNumber (final BigInteger number)\n+  {\n+    this.number = number;\n+  }\n+\n+  // Instance method.\n+  // -------------------------------------------------------------------------\n+\n+  public BigInteger getNumber()\n+  {\n+    return number;\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encoded == null)\n+      {\n+        encoded = new DERValue (DER.INTEGER, number).getEncoded();\n+      }\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public String toString()\n+  {\n+    return CRLNumber.class.getName() + \" [ \" + number + \" ]\";\n+  }\n+}"}, {"sha": "206fa7efaf628575f9423860823280d38ccacf4c", "filename": "libjava/gnu/java/security/x509/ext/CertificatePolicies.java", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FCertificatePolicies.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FCertificatePolicies.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FCertificatePolicies.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,191 @@\n+/* CertificatePolicies.java -- certificate policy extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.cert.PolicyQualifierInfo;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class CertificatePolicies extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.32\");\n+\n+  private final List policies;\n+  private final Map policyQualifierInfos;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public CertificatePolicies(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERReader der = new DERReader(encoded);\n+    DERValue pol = der.read();\n+    if (!pol.isConstructed())\n+      throw new IOException(\"malformed CertificatePolicies\");\n+\n+    int len = 0;\n+    LinkedList policyList = new LinkedList();\n+    HashMap qualifierMap = new HashMap();\n+    while (len < pol.getLength())\n+      {\n+        DERValue policyInfo = der.read();\n+        if (!policyInfo.isConstructed())\n+          throw new IOException(\"malformed PolicyInformation\");\n+        DERValue val = der.read();\n+        if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+          throw new IOException(\"malformed CertPolicyId\");\n+        OID policyId = (OID) val.getValue();\n+        policyList.add(policyId);\n+        if (val.getEncodedLength() < policyInfo.getLength())\n+          {\n+            DERValue qual = der.read();\n+            int len2 = 0;\n+            LinkedList quals = new LinkedList();\n+            while (len2 < qual.getLength())\n+              {\n+                val = der.read();\n+                quals.add(new PolicyQualifierInfo(val.getEncoded()));\n+                der.skip(val.getLength());\n+                len2 += val.getEncodedLength();\n+              }\n+            qualifierMap.put(policyId, quals);\n+          }\n+        len += policyInfo.getEncodedLength();\n+      }\n+\n+    policies = Collections.unmodifiableList(policyList);\n+    policyQualifierInfos = Collections.unmodifiableMap(qualifierMap);\n+  }\n+\n+  public CertificatePolicies (final List policies,\n+                              final Map policyQualifierInfos)\n+  {\n+    for (Iterator it = policies.iterator(); it.hasNext(); )\n+      if (!(it.next() instanceof OID))\n+        throw new IllegalArgumentException (\"policies must be OIDs\");\n+    for (Iterator it = policyQualifierInfos.entrySet().iterator(); it.hasNext();)\n+      {\n+        Map.Entry e = (Map.Entry) it.next();\n+        if (!(e.getKey() instanceof OID) || !policies.contains (e.getKey()))\n+          throw new IllegalArgumentException\n+            (\"policyQualifierInfos keys must be OIDs\");\n+        if (!(e.getValue() instanceof List))\n+          throw new IllegalArgumentException\n+            (\"policyQualifierInfos values must be Lists of PolicyQualifierInfos\");\n+        for (Iterator it2 = ((List) e.getValue()).iterator(); it.hasNext(); )\n+          if (!(it2.next() instanceof PolicyQualifierInfo))\n+            throw new IllegalArgumentException\n+              (\"policyQualifierInfos values must be Lists of PolicyQualifierInfos\");\n+      }\n+    this.policies = Collections.unmodifiableList (new ArrayList (policies));\n+    this.policyQualifierInfos = Collections.unmodifiableMap\n+      (new HashMap (policyQualifierInfos));\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public List getPolicies()\n+  {\n+    return policies;\n+  }\n+\n+  public List getPolicyQualifierInfos(OID oid)\n+  {\n+    return (List) policyQualifierInfos.get(oid);\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encoded == null)\n+      {\n+        List pol = new ArrayList (policies.size());\n+        for (Iterator it = policies.iterator(); it.hasNext(); )\n+          {\n+            OID policy = (OID) it.next();\n+            List qualifiers = getPolicyQualifierInfos (policy);\n+            List l = new ArrayList (qualifiers == null ? 1 : 2);\n+            l.add (new DERValue (DER.OBJECT_IDENTIFIER, policy));\n+            if (qualifiers != null)\n+              {\n+                List ll = new ArrayList (qualifiers.size());\n+                for (Iterator it2 = qualifiers.iterator(); it.hasNext(); )\n+                  {\n+                    PolicyQualifierInfo info = (PolicyQualifierInfo) it2.next();\n+                    try\n+                      {\n+                        ll.add (DERReader.read (info.getEncoded()));\n+                      }\n+                    catch (IOException ioe)\n+                      {\n+                      }\n+                  }\n+                l.add (new DERValue (DER.CONSTRUCTED|DER.SEQUENCE, ll));\n+              }\n+            pol.add (new DERValue (DER.CONSTRUCTED|DER.SEQUENCE, l));\n+          }\n+        encoded = new DERValue (DER.CONSTRUCTED|DER.SEQUENCE, pol).getEncoded();\n+      }\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public String toString()\n+  {\n+    return CertificatePolicies.class.getName() + \" [ policies=\" + policies +\n+      \" policyQualifierInfos=\" + policyQualifierInfos + \" ]\";\n+  }\n+}"}, {"sha": "e2a98e0a361b4ba5ffab8a14d192bf55613c8c15", "filename": "libjava/gnu/java/security/x509/ext/ExtendedKeyUsage.java", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FExtendedKeyUsage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FExtendedKeyUsage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FExtendedKeyUsage.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,95 @@\n+/* ExtendedKeyUsage.java -- the extended key usage extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class ExtendedKeyUsage extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.37\");\n+\n+  private final List purposeIds;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public ExtendedKeyUsage(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERReader der = new DERReader(encoded);\n+    DERValue usageList = der.read();\n+    if (!usageList.isConstructed())\n+      throw new IOException(\"malformed ExtKeyUsageSyntax\");\n+    int len = 0;\n+    purposeIds = new LinkedList();\n+    while (len < usageList.getLength())\n+      {\n+        DERValue val = der.read();\n+        if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+          throw new IOException(\"malformed KeyPurposeId\");\n+        purposeIds.add(val.getValue());\n+        len += val.getEncodedLength();\n+      }\n+  }\n+\n+  // Instance method.\n+  // -------------------------------------------------------------------------\n+\n+  public List getPurposeIds()\n+  {\n+    return Collections.unmodifiableList(purposeIds);\n+  }\n+\n+  public String toString()\n+  {\n+    return ExtendedKeyUsage.class.getName() + \" [ \" + purposeIds + \" ]\";\n+  }\n+}"}, {"sha": "ccbd60c15eb2ab80a2e9be7c0c99a4aa52f8533d", "filename": "libjava/gnu/java/security/x509/ext/Extension.java", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FExtension.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FExtension.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FExtension.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,289 @@\n+/* Extension.java -- an X.509 certificate or CRL extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.x509.Util;\n+\n+public class Extension\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  private static final boolean DEBUG = false;\n+  private static void debug(String msg)\n+  {\n+    System.err.print(\">> Extension: \");\n+    System.err.println(msg);\n+  }\n+\n+  /**\n+   * This extension's object identifier.\n+   */\n+  protected final OID oid;\n+\n+  /**\n+   * The criticality flag.\n+   */\n+  protected final boolean critical;\n+\n+  /**\n+   * Whether or not this extension is locally supported.\n+   */\n+  protected boolean isSupported;\n+\n+  /**\n+   * The extension value.\n+   */\n+  protected final Value value;\n+\n+  /**\n+   * The DER encoded form.\n+   */\n+  protected byte[] encoded;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public Extension(byte[] encoded) throws IOException\n+  {\n+    this.encoded = (byte[]) encoded.clone();\n+    DERReader der = new DERReader(encoded);\n+\n+    // Extension ::= SEQUENCE {\n+    DERValue val = der.read();\n+    if (DEBUG) debug(\"read val  tag == \" + val.getTag() + \" len == \" + val.getLength());\n+    if (!val.isConstructed())\n+      throw new IOException(\"malformed Extension\");\n+\n+    //   extnID    OBJECT IDENTIFIER,\n+    val = der.read();\n+    if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+      throw new IOException(\"expecting OBJECT IDENTIFIER\");\n+    oid = (OID) val.getValue();\n+    if (DEBUG) debug(\"read oid == \" + oid);\n+\n+    //   critical  BOOLEAN DEFAULT FALSE,\n+    val = der.read();\n+    if (val.getTag() == DER.BOOLEAN)\n+      {\n+        critical = ((Boolean) val.getValue()).booleanValue();\n+        val = der.read();\n+      }\n+    else\n+      critical = false;\n+    if (DEBUG) debug(\"is critical == \" + critical);\n+\n+    //   extnValue OCTET STRING }\n+    if (val.getTag() != DER.OCTET_STRING)\n+      throw new IOException(\"expecting OCTET STRING\");\n+    byte[] encval = (byte[]) val.getValue();\n+    isSupported = true;\n+    if (oid.equals(AuthorityKeyIdentifier.ID))\n+      {\n+        value = new AuthorityKeyIdentifier(encval);\n+      }\n+    else if (oid.equals(SubjectKeyIdentifier.ID))\n+      {\n+        value = new SubjectKeyIdentifier(encval);\n+      }\n+    else if (oid.equals(KeyUsage.ID))\n+      {\n+        value = new KeyUsage(encval);\n+      }\n+    else if (oid.equals(PrivateKeyUsagePeriod.ID))\n+      {\n+        value = new PrivateKeyUsagePeriod(encval);\n+      }\n+    else if (oid.equals(CertificatePolicies.ID))\n+      {\n+        value = new CertificatePolicies(encval);\n+      }\n+    else if (oid.equals (PolicyConstraint.ID))\n+      {\n+        value = new PolicyConstraint (encval);\n+      }\n+    else if (oid.equals(PolicyMappings.ID))\n+      {\n+        value = new PolicyMappings(encval);\n+      }\n+    else if (oid.equals(SubjectAlternativeNames.ID))\n+      {\n+        value = new SubjectAlternativeNames(encval);\n+      }\n+    else if (oid.equals(IssuerAlternativeNames.ID))\n+      {\n+        value = new IssuerAlternativeNames(encval);\n+      }\n+    else if (oid.equals(BasicConstraints.ID))\n+      {\n+        value = new BasicConstraints(encval);\n+      }\n+    else if (oid.equals(ExtendedKeyUsage.ID))\n+      {\n+        value = new ExtendedKeyUsage(encval);\n+      }\n+    else if (oid.equals(CRLNumber.ID))\n+      {\n+        value = new CRLNumber(encval);\n+      }\n+    else if (oid.equals(ReasonCode.ID))\n+      {\n+        value = new ReasonCode(encval);\n+      }\n+    else\n+      {\n+        value = new Value(encval);\n+        isSupported = false;\n+      }\n+    if (DEBUG) debug(\"read value == \" + value);\n+  }\n+\n+  public Extension (final OID oid, final Value value, final boolean critical)\n+  {\n+    this.oid = oid;\n+    this.value = value;\n+    this.critical = critical;\n+    isSupported = true;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public OID getOid()\n+  {\n+    return oid;\n+  }\n+\n+  public boolean isCritical()\n+  {\n+    return critical;\n+  }\n+\n+  public boolean isSupported()\n+  {\n+    return isSupported;\n+  }\n+\n+  public Value getValue()\n+  {\n+    return value;\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encoded == null)\n+      encode();\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public String toString()\n+  {\n+    return Extension.class.getName() + \" [ id=\" + oid + \" critical=\" +\n+      critical + \" value=\" + value + \" ]\";\n+  }\n+\n+  public DERValue getDerValue()\n+  {\n+    List ext = new ArrayList (3);\n+    ext.add (new DERValue (DER.OBJECT_IDENTIFIER, oid));\n+    ext.add (new DERValue (DER.BOOLEAN, new Boolean (critical)));\n+    ext.add (new DERValue (DER.OCTET_STRING, value.getEncoded()));\n+    return new DERValue (DER.CONSTRUCTED|DER.SEQUENCE, ext);\n+  }\n+\n+  // Own methods.\n+  // -------------------------------------------------------------------------\n+\n+  private void encode()\n+  {\n+    encoded = getDerValue().getEncoded();\n+  }\n+\n+  // Inner class.\n+  // -------------------------------------------------------------------------\n+\n+  public static class Value\n+  {\n+\n+    // Fields.\n+    // -----------------------------------------------------------------------\n+\n+    protected byte[] encoded;\n+\n+    // Constructor.\n+    // -----------------------------------------------------------------------\n+\n+    public Value(byte[] encoded)\n+    {\n+      this.encoded = (byte[]) encoded.clone();\n+    }\n+\n+    protected Value() { }\n+\n+    // Instance methods.\n+    // -----------------------------------------------------------------------\n+\n+    public byte[] getEncoded()\n+    {\n+      return (byte[]) encoded;\n+    }\n+\n+    public boolean equals(Object o)\n+    {\n+      if (!(o instanceof Value))\n+        return false;\n+      return Arrays.equals(encoded, ((Value) o).encoded);\n+    }\n+\n+    public String toString()\n+    {\n+      return Util.toHexString(encoded, ':');\n+    }\n+  }\n+}"}, {"sha": "fc9a73ba3dcfa651cf83812f5a15f6eb2eaec694", "filename": "libjava/gnu/java/security/x509/ext/GeneralNames.java", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FGeneralNames.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FGeneralNames.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FGeneralNames.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,157 @@\n+/* GeneralNames.java -- the GeneralNames object.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+\n+import java.net.InetAddress;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.x509.X500DistinguishedName;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class GeneralNames\n+{\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public static final int OTHER_NAME     = 0;\n+  public static final int RFC822_NAME    = 1;\n+  public static final int DNS_NAME       = 2;\n+  public static final int X400_ADDRESS   = 3;\n+  public static final int DIRECTORY_NAME = 4;\n+  public static final int EDI_PARTY_NAME = 5;\n+  public static final int URI            = 6;\n+  public static final int IP_ADDRESS     = 7;\n+  public static final int REGISTERED_ID  = 8;\n+\n+  private List names;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public GeneralNames(final byte[] encoded) throws IOException\n+  {\n+    names = new LinkedList();\n+    DERReader der = new DERReader(encoded);\n+    DERValue nameList = der.read();\n+    if (!nameList.isConstructed())\n+      throw new IOException(\"malformed GeneralNames\");\n+    int len = 0;\n+    while (len < nameList.getLength())\n+      {\n+        DERValue name = der.read();\n+        List namePair = new ArrayList(2);\n+        if (name.getTagClass() != DER.APPLICATION)\n+          throw new IOException(\"malformed GeneralName\");\n+        namePair.add(new Integer(name.getTag()));\n+        DERValue val = null;\n+        switch (name.getTag())\n+          {\n+          case RFC822_NAME:\n+          case DNS_NAME:\n+          case X400_ADDRESS:\n+          case URI:\n+            namePair.add(new String((byte[]) name.getValue()));\n+            break;\n+\n+          case OTHER_NAME:\n+          case EDI_PARTY_NAME:\n+            namePair.add(name.getValue());\n+            break;\n+\n+          case DIRECTORY_NAME:\n+            byte[] b = name.getEncoded();\n+            b[0] = (byte) (DER.CONSTRUCTED|DER.SEQUENCE);\n+            namePair.add(new X500DistinguishedName(b).toString());\n+            break;\n+\n+          case IP_ADDRESS:\n+            namePair.add(InetAddress.getByAddress((byte[]) name.getValue())\n+                         .getHostAddress());\n+            break;\n+\n+          case REGISTERED_ID:\n+            byte[] bb = name.getEncoded();\n+            bb[0] = (byte) DER.OBJECT_IDENTIFIER;\n+            namePair.add(new OID(bb).toString());\n+            break;\n+\n+          default:\n+            throw new IOException(\"unknown tag \" + name.getTag());\n+          }\n+        names.add(namePair);\n+        len += name.getEncodedLength();\n+      }\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public List getNames()\n+  {\n+    List l = new ArrayList(names.size());\n+    for (Iterator it = names.iterator(); it.hasNext(); )\n+      {\n+        List ll = (List) it.next();\n+        List pair = new ArrayList(2);\n+        pair.add(ll.get(0));\n+        if (ll.get(1) instanceof byte[])\n+          pair.add(((byte[]) ll.get(1)).clone());\n+        else\n+          pair.add(ll.get(1));\n+        l.add(Collections.unmodifiableList(pair));\n+      }\n+    return Collections.unmodifiableList(l);\n+  }\n+\n+  public String toString()\n+  {\n+    return GeneralNames.class.getName() + \" [ \" + names + \" ]\";\n+  }\n+}"}, {"sha": "0d0beb04bc519d0cb50a6d7526b2f331aefb5b23", "filename": "libjava/gnu/java/security/x509/ext/IssuerAlternativeNames.java", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FIssuerAlternativeNames.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FIssuerAlternativeNames.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FIssuerAlternativeNames.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,76 @@\n+/* IssuerAlternatuveNames.java -- issuer alternative names extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import gnu.java.security.OID;\n+\n+public class IssuerAlternativeNames extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.18\");\n+\n+  private final GeneralNames names;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public IssuerAlternativeNames(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    names = new GeneralNames(encoded);\n+  }\n+\n+  // Instance method.\n+  // -------------------------------------------------------------------------\n+\n+  public List getNames()\n+  {\n+    return names.getNames();\n+  }\n+\n+  public String toString()\n+  {\n+    return IssuerAlternativeNames.class.getName() + \" [ \" + names + \" ]\";\n+  }\n+}"}, {"sha": "7d5d7c62c4c1a8b25251bad49f4a1370bd1b66ac", "filename": "libjava/gnu/java/security/x509/ext/KeyUsage.java", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FKeyUsage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FKeyUsage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FKeyUsage.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,92 @@\n+/* KeyUsage.java -- the key usage extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class KeyUsage extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.15\");\n+  public static final int DIGITAL_SIGNATURE = 0;\n+  public static final int NON_REPUDIATION   = 1;\n+  public static final int KEY_ENCIPHERMENT  = 2;\n+  public static final int DATA_ENCIPHERMENT = 3;\n+  public static final int KEY_AGREEMENT     = 4;\n+  public static final int KEY_CERT_SIGN     = 5;\n+  public static final int CRL_SIGN          = 6;\n+  public static final int ENCIPHER_ONLY     = 7;\n+  public static final int DECIPHER_ONLY     = 8;\n+\n+  private final BitString keyUsage;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public KeyUsage(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERValue val = DERReader.read(encoded);\n+    if (val.getTag() != DER.BIT_STRING)\n+      throw new IOException(\"malformed KeyUsage\");\n+    keyUsage = (BitString) val.getValue();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public BitString getKeyUsage()\n+  {\n+    return keyUsage;\n+  }\n+\n+  public String toString()\n+  {\n+    return KeyUsage.class.getName() + \" [ \" + keyUsage + \" ]\";\n+  }\n+}"}, {"sha": "0949b5000aeeb3c97545d558175221458682935c", "filename": "libjava/gnu/java/security/x509/ext/PolicyConstraint.java", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPolicyConstraint.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPolicyConstraint.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPolicyConstraint.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,109 @@\n+/* PolicyConstraint.java -- policyConstraint extension\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.x509.Util;\n+\n+public class PolicyConstraint extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID (\"2.5.29.36\");\n+\n+  private final int requireExplicitPolicy;\n+  private final int inhibitPolicyMapping;\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  public PolicyConstraint (final byte[] encoded) throws IOException\n+  {\n+    super (encoded);\n+    int rpc = -1, ipm = -1;\n+    DERReader der = new DERReader(encoded);\n+    DERValue pc = der.read();\n+    if (!pc.isConstructed())\n+      throw new IOException(\"malformed PolicyConstraints\");\n+    DERValue val;\n+    int len = pc.getLength();\n+    while (len > 0)\n+      {\n+        val = der.read();\n+        if (val.getTag() == 0)\n+          rpc = new BigInteger ((byte[]) val.getValue()).intValue();\n+        else if (val.getTag() == 1)\n+          ipm = new BigInteger ((byte[]) val.getValue()).intValue();\n+        else\n+          throw new IOException (\"invalid policy constraint\");\n+        len -= val.getEncodedLength();\n+      }\n+\n+    requireExplicitPolicy = rpc;\n+    inhibitPolicyMapping = ipm;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public int getRequireExplicitPolicy()\n+  {\n+    return requireExplicitPolicy;\n+  }\n+\n+  public int getInhibitPolicyMapping()\n+  {\n+    return inhibitPolicyMapping;\n+  }\n+\n+  public String toString()\n+  {\n+    return PolicyConstraint.class.getName() + \" [ requireExplicitPolicy=\" +\n+      requireExplicitPolicy + \" inhibitPolicyMapping=\" + inhibitPolicyMapping\n+      + \" ]\";\n+  }\n+}"}, {"sha": "827e83fe0a3a80df54a6df3a2ae174b608a574aa", "filename": "libjava/gnu/java/security/x509/ext/PolicyMappings.java", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPolicyMappings.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPolicyMappings.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPolicyMappings.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,104 @@\n+/* PolicyMappings.java -- policy mappings extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class PolicyMappings extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.33\");\n+\n+  private final Map mappings;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public PolicyMappings(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERReader der = new DERReader(encoded);\n+    DERValue maps = der.read();\n+    if (!maps.isConstructed())\n+      throw new IOException(\"malformed PolicyMappings\");\n+    int len = 0;\n+    HashMap _mappings = new HashMap();\n+    while (len < maps.getLength())\n+      {\n+        DERValue map = der.read();\n+        if (!map.isConstructed())\n+          throw new IOException(\"malformed PolicyMapping\");\n+        DERValue val = der.read();\n+        if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+          throw new IOException(\"malformed PolicyMapping\");\n+        OID issuerPolicy = (OID) val.getValue();\n+        val = der.read();\n+        if (val.getTag() != DER.OBJECT_IDENTIFIER)\n+          throw new IOException(\"malformed PolicyMapping\");\n+        OID subjectPolicy = (OID) val.getValue();\n+        _mappings.put(issuerPolicy, subjectPolicy);\n+        len += map.getEncodedLength();\n+      }\n+    mappings = Collections.unmodifiableMap(_mappings);\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public OID getSubjectDomainPolicy(OID issuerDomainPolicy)\n+  {\n+    return (OID) mappings.get(issuerDomainPolicy);\n+  }\n+\n+  public String toString()\n+  {\n+    return PolicyMappings.class.getName() + \" [ \" + mappings + \" ]\";\n+  }\n+}"}, {"sha": "108af4bcf90dc4c05ffea818180369cf05b5637d", "filename": "libjava/gnu/java/security/x509/ext/PrivateKeyUsagePeriod.java", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPrivateKeyUsagePeriod.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPrivateKeyUsagePeriod.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FPrivateKeyUsagePeriod.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,105 @@\n+/* PrivateKeyUsagePeriod.java -- private key usage period extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class PrivateKeyUsagePeriod extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.16\");\n+\n+  private final Date notBefore;\n+  private final Date notAfter;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public PrivateKeyUsagePeriod(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERReader der = new DERReader(encoded);\n+    DERValue val = der.read();\n+    if (!val.isConstructed())\n+      throw new IOException(\"malformed PrivateKeyUsagePeriod\");\n+    if (val.getLength() > 0)\n+      val = der.read();\n+    if (val.getTagClass() == DER.APPLICATION || val.getTag() == 0)\n+      {\n+        notBefore = (Date) val.getValue();\n+        val = der.read();\n+      }\n+    else\n+      notBefore = null;\n+    if (val.getTagClass() == DER.APPLICATION || val.getTag() == 1)\n+      {\n+        notAfter = (Date) val.getValue();\n+      }\n+    else\n+      notAfter = null;\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public Date getNotBefore()\n+  {\n+    return notBefore != null ? (Date) notBefore.clone() : null;\n+  }\n+\n+  public Date getNotAfter()\n+  {\n+    return notAfter != null ? (Date) notAfter.clone() : null;\n+  }\n+\n+  public String toString()\n+  {\n+    return PrivateKeyUsagePeriod.class.getName() + \" [ notBefore=\" + notBefore\n+      + \" notAfter=\" + notAfter + \" ]\";\n+  }\n+}"}, {"sha": "779611de1fa4bbc155791bf00fb1c363fb09ad8b", "filename": "libjava/gnu/java/security/x509/ext/ReasonCode.java", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FReasonCode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FReasonCode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FReasonCode.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,85 @@\n+/* ReasonCode.java -- a reason code for a certificate revocation.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+\n+public class ReasonCode extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.21\");\n+\n+  public final int reason;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public ReasonCode(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERValue val = DERReader.read(encoded);\n+    if (val.getTag() != DER.ENUMERATED)\n+      throw new IOException(\"malformed CRLReason\");\n+    reason = ((BigInteger) val.getValue()).intValue();\n+    if (reason < 0 || reason == 7 || reason > 10)\n+      throw new IOException(\"illegal reason: \" + reason);\n+  }\n+\n+  // Instance method.\n+  // -------------------------------------------------------------------------\n+\n+  public int getReasonCode()\n+  {\n+    return reason;\n+  }\n+\n+  public String toString()\n+  {\n+    return ReasonCode.class.getName() + \" [ \" + reason + \" ]\";\n+  }\n+}"}, {"sha": "19c0bdee8c4fa7b9095050b51290287e8c173fe6", "filename": "libjava/gnu/java/security/x509/ext/SubjectAlternativeNames.java", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FSubjectAlternativeNames.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FSubjectAlternativeNames.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FSubjectAlternativeNames.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,77 @@\n+/* SubjectAlternatuveNames.java -- subject alternative names extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import gnu.java.security.OID;\n+\n+public class SubjectAlternativeNames extends Extension.Value\n+{\n+\n+  // Constants and fields.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.17\");\n+\n+  private final GeneralNames names;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public SubjectAlternativeNames(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    names = new GeneralNames(encoded);\n+  }\n+\n+  // Instance method.\n+  // -------------------------------------------------------------------------\n+\n+  public List getNames()\n+  {\n+    return names.getNames();\n+  }\n+\n+  public String toString()\n+  {\n+    return SubjectAlternativeNames.class.getName() + \" [ \" + names + \" ]\";\n+  }\n+}"}, {"sha": "2d48f7c368e6ff85ae7a6a79c0918dadd61a5e1c", "filename": "libjava/gnu/java/security/x509/ext/SubjectKeyIdentifier.java", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FSubjectKeyIdentifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FSubjectKeyIdentifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2Fext%2FSubjectKeyIdentifier.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -0,0 +1,84 @@\n+/* SubjectKeyIdentifier.java -- subject key identifier extension.\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509.ext;\n+\n+import java.io.IOException;\n+\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.x509.Util;\n+\n+public class SubjectKeyIdentifier extends Extension.Value\n+{\n+\n+  // Constant.\n+  // -------------------------------------------------------------------------\n+\n+  public static final OID ID = new OID(\"2.5.29.14\");\n+\n+  private final byte[] keyIdentifier;\n+\n+  // Constructor.\n+  // -------------------------------------------------------------------------\n+\n+  public SubjectKeyIdentifier(final byte[] encoded) throws IOException\n+  {\n+    super(encoded);\n+    DERValue val = DERReader.read(encoded);\n+    if (val.getTag() != DER.OCTET_STRING)\n+      throw new IOException(\"malformed SubjectKeyIdentifier\");\n+    keyIdentifier = (byte[]) val.getValue();\n+  }\n+\n+  // Instance methods.\n+  // -------------------------------------------------------------------------\n+\n+  public byte[] getKeyIdentifier()\n+  {\n+    return (byte[]) keyIdentifier.clone();\n+  }\n+\n+  public String toString()\n+  {\n+    return SubjectKeyIdentifier.class.getName() + \" [ \" +\n+      Util.toHexString (keyIdentifier, ':') + \" ]\";\n+  }\n+}"}, {"sha": "448b855b16fd8c1120a8f53eea04184e5efdcc83", "filename": "libjava/java/security/cert/TrustAnchor.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fjava%2Fsecurity%2Fcert%2FTrustAnchor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507148866c2116c2d15dadc4b1609eb21ce88a45/libjava%2Fjava%2Fsecurity%2Fcert%2FTrustAnchor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FTrustAnchor.java?ref=507148866c2116c2d15dadc4b1609eb21ce88a45", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -140,7 +140,7 @@ public final X509Certificate getTrustedCert()\n   public final String getCAName()\n   {\n     if (caName != null)\n-      return caName.toRFC2253();\n+      return caName.toString();\n     return null;\n   }\n \n@@ -179,7 +179,7 @@ public String toString()\n   {\n     if (trustedCert == null)\n       return \"[ Trusted CA Public Key=\" + caKey + \", Trusted CA Issuer Name=\"\n-        + caName.toRFC2253() + \" ]\";\n+        + caName.toString() + \" ]\";\n     return \"[ Trusted CA Certificate=\" + trustedCert + \" ]\";\n   }\n }"}]}