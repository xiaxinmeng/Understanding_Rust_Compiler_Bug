{"sha": "f3678bfb504a9787fda6b560f15c6192a8597387", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM2NzhiZmI1MDRhOTc4N2ZkYTZiNTYwZjE1YzYxOTJhODU5NzM4Nw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2011-06-29T12:15:08Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2011-06-29T12:15:08Z"}, "message": "re PR rtl-optimization/49114 ([x32] Reload failed to handle (set reg:X (plus:X (subreg:X (reg:Y) 0) (const_int))))\n\n\tPR rtl-optimization/49114\n\t* reload.c (struct replacement): Remove SUBREG_LOC member.\n\t(push_reload): Do not set it.\n\t(push_replacement): Likewise.\n\t(subst_reload): Remove dead code.\n\t(copy_replacements): Remove assertion.\n\t(copy_replacements_1): Do not handle SUBREG_LOC.\n\t(move_replacements): Likewise.\n\t(find_replacement): Remove dead code.  Use reload_adjust_reg_for_mode.\n\tDetect subregs via recursive descent instead of via SUBREG_LOC.\n\nFrom-SVN: r175631", "tree": {"sha": "adb0058892895b52648b4cc0ff77c056f048b5ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adb0058892895b52648b4cc0ff77c056f048b5ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3678bfb504a9787fda6b560f15c6192a8597387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3678bfb504a9787fda6b560f15c6192a8597387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3678bfb504a9787fda6b560f15c6192a8597387", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3678bfb504a9787fda6b560f15c6192a8597387/comments", "author": null, "committer": null, "parents": [{"sha": "433ba0a57b5be5a1292122405c0b928e1223c37d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/433ba0a57b5be5a1292122405c0b928e1223c37d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/433ba0a57b5be5a1292122405c0b928e1223c37d"}], "stats": {"total": 119, "additions": 32, "deletions": 87}, "files": [{"sha": "40ccb736b16e7bcd4d067db2622bb204d75be88b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3678bfb504a9787fda6b560f15c6192a8597387/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3678bfb504a9787fda6b560f15c6192a8597387/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3678bfb504a9787fda6b560f15c6192a8597387", "patch": "@@ -1,3 +1,16 @@\n+2011-06-29  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\tPR rtl-optimization/49114\n+\t* reload.c (struct replacement): Remove SUBREG_LOC member.\n+\t(push_reload): Do not set it.\n+\t(push_replacement): Likewise.\n+\t(subst_reload): Remove dead code.\n+\t(copy_replacements): Remove assertion.\n+\t(copy_replacements_1): Do not handle SUBREG_LOC.\n+\t(move_replacements): Likewise.\n+\t(find_replacement): Remove dead code.  Use reload_adjust_reg_for_mode.\n+\tDetect subregs via recursive descent instead of via SUBREG_LOC.\n+\n 2011-06-29  Georg-Johann Lay  <avr@gjlay.de>\n \t\n \t* config/avr/avr.c (avr_encode_section_info): Dispatch to"}, {"sha": "fa314548719619c48fdc2e92d9c81ae9327837b1", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 87, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3678bfb504a9787fda6b560f15c6192a8597387/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3678bfb504a9787fda6b560f15c6192a8597387/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f3678bfb504a9787fda6b560f15c6192a8597387", "patch": "@@ -158,8 +158,6 @@ static int replace_reloads;\n struct replacement\n {\n   rtx *where;\t\t\t/* Location to store in */\n-  rtx *subreg_loc;\t\t/* Location of SUBREG if WHERE is inside\n-\t\t\t\t   a SUBREG; 0 otherwise.  */\n   int what;\t\t\t/* which reload this is for */\n   enum machine_mode mode;\t/* mode it must have */\n };\n@@ -1496,7 +1494,6 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t{\n \t  struct replacement *r = &replacements[n_replacements++];\n \t  r->what = i;\n-\t  r->subreg_loc = in_subreg_loc;\n \t  r->where = inloc;\n \t  r->mode = inmode;\n \t}\n@@ -1505,7 +1502,6 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  struct replacement *r = &replacements[n_replacements++];\n \t  r->what = i;\n \t  r->where = outloc;\n-\t  r->subreg_loc = out_subreg_loc;\n \t  r->mode = outmode;\n \t}\n     }\n@@ -1634,7 +1630,6 @@ push_replacement (rtx *loc, int reloadnum, enum machine_mode mode)\n       struct replacement *r = &replacements[n_replacements++];\n       r->what = reloadnum;\n       r->where = loc;\n-      r->subreg_loc = 0;\n       r->mode = mode;\n     }\n }\n@@ -6287,33 +6282,7 @@ subst_reloads (rtx insn)\n \t  if (GET_MODE (reloadreg) != r->mode && r->mode != VOIDmode)\n \t    reloadreg = reload_adjust_reg_for_mode (reloadreg, r->mode);\n \n-\t  /* If we are putting this into a SUBREG and RELOADREG is a\n-\t     SUBREG, we would be making nested SUBREGs, so we have to fix\n-\t     this up.  Note that r->where == &SUBREG_REG (*r->subreg_loc).  */\n-\n-\t  if (r->subreg_loc != 0 && GET_CODE (reloadreg) == SUBREG)\n-\t    {\n-\t      if (GET_MODE (*r->subreg_loc)\n-\t\t  == GET_MODE (SUBREG_REG (reloadreg)))\n-\t\t*r->subreg_loc = SUBREG_REG (reloadreg);\n-\t      else\n-\t\t{\n-\t\t  int final_offset =\n-\t\t    SUBREG_BYTE (*r->subreg_loc) + SUBREG_BYTE (reloadreg);\n-\n-\t\t  /* When working with SUBREGs the rule is that the byte\n-\t\t     offset must be a multiple of the SUBREG's mode.  */\n-\t\t  final_offset = (final_offset /\n-\t\t\t\t  GET_MODE_SIZE (GET_MODE (*r->subreg_loc)));\n-\t\t  final_offset = (final_offset *\n-\t\t\t\t  GET_MODE_SIZE (GET_MODE (*r->subreg_loc)));\n-\n-\t\t  *r->where = SUBREG_REG (reloadreg);\n-\t\t  SUBREG_BYTE (*r->subreg_loc) = final_offset;\n-\t\t}\n-\t    }\n-\t  else\n-\t    *r->where = reloadreg;\n+\t  *r->where = reloadreg;\n \t}\n       /* If reload got no reg and isn't optional, something's wrong.  */\n       else\n@@ -6327,10 +6296,6 @@ subst_reloads (rtx insn)\n void\n copy_replacements (rtx x, rtx y)\n {\n-  /* We can't support X being a SUBREG because we might then need to know its\n-     location if something inside it was replaced.  */\n-  gcc_assert (GET_CODE (x) != SUBREG);\n-\n   copy_replacements_1 (&x, &y, n_replacements);\n }\n \n@@ -6344,24 +6309,13 @@ copy_replacements_1 (rtx *px, rtx *py, int orig_replacements)\n   const char *fmt;\n \n   for (j = 0; j < orig_replacements; j++)\n-    {\n-      if (replacements[j].subreg_loc == px)\n-\t{\n-\t  r = &replacements[n_replacements++];\n-\t  r->where = replacements[j].where;\n-\t  r->subreg_loc = py;\n-\t  r->what = replacements[j].what;\n-\t  r->mode = replacements[j].mode;\n-\t}\n-      else if (replacements[j].where == px)\n-\t{\n-\t  r = &replacements[n_replacements++];\n-\t  r->where = py;\n-\t  r->subreg_loc = 0;\n-\t  r->what = replacements[j].what;\n-\t  r->mode = replacements[j].mode;\n-\t}\n-    }\n+    if (replacements[j].where == px)\n+      {\n+\tr = &replacements[n_replacements++];\n+\tr->where = py;\n+\tr->what = replacements[j].what;\n+\tr->mode = replacements[j].mode;\n+      }\n \n   x = *px;\n   y = *py;\n@@ -6387,13 +6341,8 @@ move_replacements (rtx *x, rtx *y)\n   int i;\n \n   for (i = 0; i < n_replacements; i++)\n-    if (replacements[i].subreg_loc == x)\n-      replacements[i].subreg_loc = y;\n-    else if (replacements[i].where == x)\n-      {\n-\treplacements[i].where = y;\n-\treplacements[i].subreg_loc = 0;\n-      }\n+    if (replacements[i].where == x)\n+      replacements[i].where = y;\n }\n \f\n /* If LOC was scheduled to be replaced by something, return the replacement.\n@@ -6411,36 +6360,19 @@ find_replacement (rtx *loc)\n       if (reloadreg && r->where == loc)\n \t{\n \t  if (r->mode != VOIDmode && GET_MODE (reloadreg) != r->mode)\n-\t    reloadreg = gen_rtx_REG (r->mode, REGNO (reloadreg));\n+\t    reloadreg = reload_adjust_reg_for_mode (reloadreg, r->mode);\n \n \t  return reloadreg;\n \t}\n-      else if (reloadreg && r->subreg_loc == loc)\n+      else if (reloadreg && GET_CODE (*loc) == SUBREG\n+\t       && r->where == &SUBREG_REG (*loc))\n \t{\n-\t  /* RELOADREG must be either a REG or a SUBREG.\n-\n-\t     ??? Is it actually still ever a SUBREG?  If so, why?  */\n-\n-\t  if (REG_P (reloadreg))\n-\t    return gen_rtx_REG (GET_MODE (*loc),\n-\t\t\t\t(REGNO (reloadreg) +\n-\t\t\t\t subreg_regno_offset (REGNO (SUBREG_REG (*loc)),\n-\t\t\t\t\t\t      GET_MODE (SUBREG_REG (*loc)),\n-\t\t\t\t\t\t      SUBREG_BYTE (*loc),\n-\t\t\t\t\t\t      GET_MODE (*loc))));\n-\t  else if (GET_MODE (reloadreg) == GET_MODE (*loc))\n-\t    return reloadreg;\n-\t  else\n-\t    {\n-\t      int final_offset = SUBREG_BYTE (reloadreg) + SUBREG_BYTE (*loc);\n-\n-\t      /* When working with SUBREGs the rule is that the byte\n-\t\t offset must be a multiple of the SUBREG's mode.  */\n-\t      final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (*loc)));\n-\t      final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (*loc)));\n-\t      return gen_rtx_SUBREG (GET_MODE (*loc), SUBREG_REG (reloadreg),\n-\t\t\t\t     final_offset);\n-\t    }\n+\t  if (r->mode != VOIDmode && GET_MODE (reloadreg) != r->mode)\n+\t    reloadreg = reload_adjust_reg_for_mode (reloadreg, r->mode);\n+\n+\t  return simplify_gen_subreg (GET_MODE (*loc), reloadreg,\n+\t\t\t\t      GET_MODE (SUBREG_REG (*loc)),\n+\t\t\t\t      SUBREG_BYTE (*loc));\n \t}\n     }\n "}]}