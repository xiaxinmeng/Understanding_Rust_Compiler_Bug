{"sha": "f46f58e61db3b1e71beb21443c0ca9387bc836e2", "node_id": "C_kwDOANBUbNoAKGY0NmY1OGU2MWRiM2IxZTcxYmViMjE0NDNjMGNhOTM4N2JjODM2ZTI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-24T20:38:45Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-24T20:38:45Z"}, "message": "libstdc++: Fix fallout from P2321R2 std::pair/tuple enhancements\n\nr13-2159-g72886fcc626953 caused some testsuite regressions in C++23 mode:\n\n  FAIL: 20_util/pair/requirements/explicit_instantiation/1.cc (test for excess errors)\n  FAIL: 20_util/tuple/53648.cc (test for excess errors)\n  FAIL: 20_util/tuple/cons/noexcept_specs.cc (test for excess errors)\n  FAIL: 20_util/tuple/requirements/explicit_instantiation.cc (test for excess errors)\n\nThe test noexcept_specs.cc just needs to be updated to consider the\nadditional converting constructors of tuple in C++23 mode, which happen\nto improve constructing from a const tuple rvalue that has an rvalue\nreference element (for the better, as far as I can tell).\n\nThe other three tests fail because they explicitly instantiate a\nspecialization of pair/tuple whose elements are not all const swappable,\nwhich in C++23 mode now results in a hard error due to the new const\nswap member function.  Rather than XFAILing the tests in C++23 mode,\nthis patch adds non-standard constraints to this member function so that\nwe continue to accept such explicit instantiations.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/stl_pair.h (pair::swap const): Add non-standard\n\tis_swappable_v constraints.\n\t* include/std/tuple (tuple::swap const): Likewise.\n\t* testsuite/20_util/tuple/cons/noexcept_specs.cc: Correct some\n\tasserts in C++23 mode.", "tree": {"sha": "076b8e305f025c5d2a86f8ffe71e79340c507746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/076b8e305f025c5d2a86f8ffe71e79340c507746"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f46f58e61db3b1e71beb21443c0ca9387bc836e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46f58e61db3b1e71beb21443c0ca9387bc836e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46f58e61db3b1e71beb21443c0ca9387bc836e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46f58e61db3b1e71beb21443c0ca9387bc836e2/comments", "author": null, "committer": null, "parents": [{"sha": "df5204ddd4b8e3a2d02bb3ad5bcdb9d636b02537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df5204ddd4b8e3a2d02bb3ad5bcdb9d636b02537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df5204ddd4b8e3a2d02bb3ad5bcdb9d636b02537"}], "stats": {"total": 56, "additions": 56, "deletions": 0}, "files": [{"sha": "d0f07b09d347c17e9561e9b092acb5130b12825c", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46f58e61db3b1e71beb21443c0ca9387bc836e2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46f58e61db3b1e71beb21443c0ca9387bc836e2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=f46f58e61db3b1e71beb21443c0ca9387bc836e2", "patch": "@@ -213,10 +213,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n #if __cplusplus > 202002L\n+      // As an extension, we constrain the const swap member function in order\n+      // to continue accepting explicit instantiation of pairs whose elements\n+      // are not all const swappable.  Without this constraint, such an\n+      // explicit instantiation would also instantiate the ill-formed body of\n+      // this function and yield a hard error.  This constraint shouldn't\n+      // affect the behavior of valid programs.\n       constexpr void\n       swap(const pair& __p) const\n       noexcept(__and_v<__is_nothrow_swappable<const _T1>,\n \t\t       __is_nothrow_swappable<const _T2>>)\n+      requires is_swappable_v<const _T1> && is_swappable_v<const _T2>\n       {\n \tusing std::swap;\n \tswap(first, __p.first);"}, {"sha": "ddd7c226d80fc4ea3a9b77b0152ef9f512fe2c8a", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46f58e61db3b1e71beb21443c0ca9387bc836e2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46f58e61db3b1e71beb21443c0ca9387bc836e2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=f46f58e61db3b1e71beb21443c0ca9387bc836e2", "patch": "@@ -1176,9 +1176,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { _Inherited::_M_swap(__in); }\n \n #if __cplusplus > 202002L\n+      // As an extension, we constrain the const swap member function in order\n+      // to continue accepting explicit instantiation of tuples whose elements\n+      // are not all const swappable.  Without this constraint, such an\n+      // explicit instantiation would also instantiate the ill-formed body of\n+      // this function and yield a hard error.  This constraint shouldn't\n+      // affect the behavior of valid programs.\n       constexpr void\n       swap(const tuple& __in) const\n       noexcept(__and_v<__is_nothrow_swappable<const _Elements>...>)\n+      requires (is_swappable_v<const _Elements> && ...)\n       { _Inherited::_M_swap(__in); }\n #endif // C++23\n     };\n@@ -1730,6 +1737,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       swap(const tuple& __in) const\n       noexcept(__and_v<__is_nothrow_swappable<const _T1>,\n \t\t       __is_nothrow_swappable<const _T2>>)\n+      requires is_swappable_v<const _T1> && is_swappable_v<const _T2>\n       { _Inherited::_M_swap(__in); }\n #endif // C++23\n     };"}, {"sha": "a326d1bc228989ac5130d1a23411821ec161e621", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/noexcept_specs.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46f58e61db3b1e71beb21443c0ca9387bc836e2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnoexcept_specs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46f58e61db3b1e71beb21443c0ca9387bc836e2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnoexcept_specs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnoexcept_specs.cc?ref=f46f58e61db3b1e71beb21443c0ca9387bc836e2", "patch": "@@ -503,7 +503,17 @@ namespace NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion\n   static_assert(!std::is_nothrow_constructible<BT, IT&>::value, \"\");\n   static_assert(!std::is_nothrow_constructible<BT, const IT &>::value, \"\");\n   static_assert(!std::is_nothrow_constructible<BT, std::tuple<int&>>::value, \"\");\n+#if __cplusplus > 202002L\n+  // C++23 extended tuple's constructor overload set as part of P2321R2, after\n+  // which its converting constructors more accurately forward the elements\n+  // from a non-const tuple lvalue and from a const tuple rvalue.  In particular\n+  // for the below test we now forward int&& as an rvalue reference instead of\n+  // as an lvalue reference, which means we now select the noexcept B(int&&)\n+  // ctor instead of the non-noexcept B(const int&) ctor.\n+  static_assert(std::is_nothrow_constructible<BT, const std::tuple<int&&>>::value, \"\");\n+#else\n   static_assert(!std::is_nothrow_constructible<BT, const std::tuple<int&&>>::value, \"\");\n+#endif\n \n   static_assert(test_trait::is_nothrow_convertible<int,BT>::value,\"\");\n   static_assert(!test_trait::is_nothrow_convertible<const int,BT>::value,\"\");\n@@ -515,7 +525,13 @@ namespace NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion\n   static_assert(!test_trait::is_nothrow_convertible<IT&,BT>::value,\"\");\n   static_assert(!test_trait::is_nothrow_convertible<const IT &,BT>::value,\"\");\n   static_assert(!test_trait::is_nothrow_convertible<std::tuple<int&>,BT>::value,\"\");\n+#if __cplusplus > 202002L\n+  // See the note about P2321R2 above.\n+  static_assert(test_trait::is_nothrow_convertible<const std::tuple<int&&>,BT>::value,\"\");\n+#else\n   static_assert(!test_trait::is_nothrow_convertible<const std::tuple<int&&>,BT>::value,\"\");\n+#endif\n+\n \n \n   static_assert(!std::is_nothrow_constructible<BT, B>::value, \"\");\n@@ -528,7 +544,12 @@ namespace NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion\n   static_assert(std::is_nothrow_constructible<BT, BT&>::value, \"\");\n   static_assert(std::is_nothrow_constructible<BT, const BT &>::value, \"\");\n   static_assert(std::is_nothrow_constructible<BT, std::tuple<B&>>::value, \"\");\n+#if __cplusplus > 202002L\n+  // See the note about P2321R2 above.\n+  static_assert(!std::is_nothrow_constructible<BT, const std::tuple<B&&>>::value, \"\");\n+#else\n   static_assert(std::is_nothrow_constructible<BT, const std::tuple<B&&>>::value, \"\");\n+#endif\n \n   static_assert(!test_trait::is_nothrow_convertible<B,BT>::value,\"\");\n   static_assert(test_trait::is_nothrow_convertible<const B,BT>::value,\"\");\n@@ -540,7 +561,12 @@ namespace NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion\n   static_assert(test_trait::is_nothrow_convertible<BT&,BT>::value,\"\");\n   static_assert(test_trait::is_nothrow_convertible<const BT &,BT>::value,\"\");\n   static_assert(test_trait::is_nothrow_convertible<std::tuple<B&>,BT>::value,\"\");\n+#if __cplusplus > 202002L\n+  // See the note about P2321R2 above.\n+  static_assert(!test_trait::is_nothrow_convertible<const std::tuple<B&&>,BT>::value,\"\");\n+#else\n   static_assert(test_trait::is_nothrow_convertible<const std::tuple<B&&>,BT>::value,\"\");\n+#endif\n \n /* explicit */\n   static_assert(std::is_nothrow_constructible<DT, int>::value, \"\");\n@@ -553,7 +579,12 @@ namespace NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion\n   static_assert(!std::is_nothrow_constructible<DT, IT&>::value, \"\");\n   static_assert(!std::is_nothrow_constructible<DT, const IT &>::value, \"\");\n   static_assert(!std::is_nothrow_constructible<DT, std::tuple<int&>>::value, \"\");\n+#if __cplusplus > 202002L\n+  // See the note about P2321R2 above.\n+  static_assert(std::is_nothrow_constructible<DT, const std::tuple<int&&>>::value, \"\");\n+#else\n   static_assert(!std::is_nothrow_constructible<DT, const std::tuple<int&&>>::value, \"\");\n+#endif\n \n   static_assert(!std::is_nothrow_constructible<DT, D>::value, \"\");\n   static_assert(std::is_nothrow_constructible<DT,const D>::value, \"\");\n@@ -565,7 +596,12 @@ namespace NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion\n   static_assert(std::is_nothrow_constructible<DT, DT&>::value, \"\");\n   static_assert(std::is_nothrow_constructible<DT, const DT &>::value, \"\");\n   static_assert(std::is_nothrow_constructible<DT, std::tuple<D&>>::value, \"\");\n+#if __cplusplus > 202002L\n+  // See note about P2321R2 above.\n+  static_assert(!std::is_nothrow_constructible<DT, const std::tuple<D&&>>::value, \"\");\n+#else\n   static_assert(std::is_nothrow_constructible<DT, const std::tuple<D&&>>::value, \"\");\n+#endif\n \n   static_assert(!test_trait::is_nothrow_convertible<DT,DT>::value,\"\");\n   static_assert(test_trait::is_nothrow_convertible<const DT,DT>::value,\"\");\n@@ -884,7 +920,12 @@ namespace ThrowMoveNothrowConversion\n   static_assert(std::is_nothrow_constructible<DT, IT&>::value, \"\");\n   static_assert(std::is_nothrow_constructible<DT, const IT &>::value, \"\");\n   static_assert(std::is_nothrow_constructible<DT, std::tuple<int&>>::value, \"\");\n+#if __cplusplus > 202002L\n+  // See the note about P2321R2 above.\n+  static_assert(!std::is_nothrow_constructible<DT, const std::tuple<int&&>>::value, \"\");\n+#else\n   static_assert(std::is_nothrow_constructible<DT, const std::tuple<int&&>>::value, \"\");\n+#endif\n \n   static_assert(test_trait::is_nothrow_convertible<DT,DT>::value,\"\");\n   static_assert(test_trait::is_nothrow_convertible<D,DT>::value,\"\");"}]}