{"sha": "e9eba25540d02efc8ccbf450be20d3d874c36846", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllYmEyNTU0MGQwMmVmYzhjY2JmNDUwYmUyMGQzZDg3NGMzNjg0Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-04T18:50:24Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-04T18:50:24Z"}, "message": "* config/h8300/h8300.c: Put a comment for every function.\n\nFrom-SVN: r78924", "tree": {"sha": "71a9a9a3838047a1cb5195fd3a00b74f9441a050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71a9a9a3838047a1cb5195fd3a00b74f9441a050"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9eba25540d02efc8ccbf450be20d3d874c36846", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9eba25540d02efc8ccbf450be20d3d874c36846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9eba25540d02efc8ccbf450be20d3d874c36846", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9eba25540d02efc8ccbf450be20d3d874c36846/comments", "author": null, "committer": null, "parents": [{"sha": "f90e600a4edb2c28f62ec4ee73039f9e1491a7da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90e600a4edb2c28f62ec4ee73039f9e1491a7da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90e600a4edb2c28f62ec4ee73039f9e1491a7da"}], "stats": {"total": 52, "additions": 50, "deletions": 2}, "files": [{"sha": "03a47a36e80d43843060f88262ef91ac4f5278c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eba25540d02efc8ccbf450be20d3d874c36846/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eba25540d02efc8ccbf450be20d3d874c36846/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9eba25540d02efc8ccbf450be20d3d874c36846", "patch": "@@ -1,3 +1,7 @@\n+2004-03-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.c: Put a comment for every function.\n+\n 2004-03-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md: Add comments about peephole2's."}, {"sha": "6bf3bfcfa683cb931de0d1f7f31072a955c8f427", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9eba25540d02efc8ccbf450be20d3d874c36846/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9eba25540d02efc8ccbf450be20d3d874c36846/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=e9eba25540d02efc8ccbf450be20d3d874c36846", "patch": "@@ -330,6 +330,10 @@ h8300_init_once (void)\n     }\n }\n \n+/* Return the byte register name for a register rtx X.  B should be 0\n+   if you want a lower byte register.  B should be 1 if you want an\n+   upper byte register.  */\n+\n static const char *\n byte_reg (rtx x, int b)\n {\n@@ -568,6 +572,9 @@ h8300_expand_prologue (void)\n   h8300_emit_stack_adjustment (-1, round_frame_size (get_frame_size ()));\n }\n \n+/* Return nonzero if we can use \"rts\" for the function currently being\n+   compiled.  */\n+\n int\n h8300_can_use_return_insn_p (void)\n {\n@@ -913,6 +920,8 @@ bit_operand (rtx op, enum machine_mode mode)\n \t  && EXTRA_CONSTRAINT (op, 'U'));\n }\n \n+/* Return nonzero if OP is a MEM suitable for bit manipulation insns.  */\n+\n int\n bit_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -1014,6 +1023,8 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   return result;\n }\n \f\n+/* Compute the cost of an and insn.  */\n+\n static int\n h8300_and_costs (rtx x)\n {\n@@ -1033,6 +1044,8 @@ h8300_and_costs (rtx x)\n   return compute_logical_op_length (GET_MODE (x), operands) / 2;\n }\n \n+/* Compute the cost of a shift insn.  */\n+\n static int\n h8300_shift_costs (rtx x)\n {\n@@ -1050,6 +1063,8 @@ h8300_shift_costs (rtx x)\n   return compute_a_shift_length (NULL, operands) / 2;\n }\n \n+/* Worker function for TARGET_RTX_COSTS.  */\n+\n static bool\n h8300_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n@@ -1642,6 +1657,8 @@ h8300_initial_elimination_offset (int from, int to)\n     abort ();\n }\n \n+/* Worker function for RETURN_ADDR_RTX.  */\n+\n rtx\n h8300_return_addr_rtx (int count, rtx frame)\n {\n@@ -2089,6 +2106,8 @@ compute_mov_length (rtx *operands)\n     }\n }\n \f\n+/* Output an addition insn.  */\n+\n const char *\n output_plussi (rtx *operands)\n {\n@@ -2162,6 +2181,8 @@ output_plussi (rtx *operands)\n     }\n }\n \n+/* Compute the length of an addition insn.  */\n+\n unsigned int\n compute_plussi_length (rtx *operands)\n {\n@@ -2230,6 +2251,8 @@ compute_plussi_length (rtx *operands)\n     }\n }\n \n+/* Compute which flag bits are valid after an addition insn.  */\n+\n int\n compute_plussi_cc (rtx *operands)\n {\n@@ -2283,6 +2306,8 @@ compute_plussi_cc (rtx *operands)\n     }\n }\n \f\n+/* Output a logical insn.  */\n+\n const char *\n output_logical_op (enum machine_mode mode, rtx *operands)\n {\n@@ -2457,6 +2482,8 @@ output_logical_op (enum machine_mode mode, rtx *operands)\n   return \"\";\n }\n \n+/* Compute the length of a logical insn.  */\n+\n unsigned int\n compute_logical_op_length (enum machine_mode mode, rtx *operands)\n {\n@@ -2600,6 +2627,8 @@ compute_logical_op_length (enum machine_mode mode, rtx *operands)\n   return length;\n }\n \n+/* Compute which flag bits are valid after a logical insn.  */\n+\n int\n compute_logical_op_cc (enum machine_mode mode, rtx *operands)\n {\n@@ -3457,7 +3486,7 @@ h8300_shift_needs_scratch_p (int count, enum machine_mode mode)\n \t  || (TARGET_H8300H && mode == SImode && count == 8));\n }\n \n-/* Emit the assembler code for doing shifts.  */\n+/* Output the assembler code for doing shifts.  */\n \n const char *\n output_a_shift (rtx *operands)\n@@ -3611,6 +3640,8 @@ output_a_shift (rtx *operands)\n     }\n }\n \n+/* Count the number of assembly instructions in a string TEMPLATE.  */\n+\n static unsigned int\n h8300_asm_insn_count (const char *template)\n {\n@@ -3623,6 +3654,8 @@ h8300_asm_insn_count (const char *template)\n   return count;\n }\n \n+/* Compute the length of a shift insn.  */\n+\n unsigned int\n compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n {\n@@ -3771,6 +3804,8 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n     }\n }\n \n+/* Compute which flag bits are valid after a shift insn.  */\n+\n int\n compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n {\n@@ -3943,7 +3978,7 @@ expand_a_rotate (rtx operands[])\n   return 1;\n }\n \n-/* Output rotate insns.  */\n+/* Output a rotate insn.  */\n \n const char *\n output_a_rotate (enum rtx_code code, rtx *operands)\n@@ -4052,6 +4087,8 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n   return \"\";\n }\n \n+/* Compute the length of a rotate insn.  */\n+\n unsigned int\n compute_a_rotate_length (rtx *operands)\n {\n@@ -4416,6 +4453,8 @@ h8300_encode_section_info (tree decl, rtx rtl, int first)\n     SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= extra_flags;\n }\n \n+/* Output a single-bit extraction.  */\n+\n const char *\n output_simode_bld (int bild, rtx operands[])\n {\n@@ -4543,6 +4582,9 @@ h8300_tiny_constant_address_p (rtx x)\n \n }\n \n+/* Return nonzero if ADDR1 and ADDR2 point to consecutive memory\n+   locations that can be accessed as a 16-bit word.  */\n+\n int\n byte_accesses_mergeable_p (rtx addr1, rtx addr2)\n {\n@@ -4758,6 +4800,8 @@ h8300_init_libfuncs (void)\n   set_optab_libfunc (umod_optab, HImode, \"__umodhi3\");\n }\n \f\n+/* Worker function for TARGET_RETURN_IN_MEMORY.  */\n+\n static bool\n h8300_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n {"}]}