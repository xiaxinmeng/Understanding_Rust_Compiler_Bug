{"sha": "e3969868d63b2930a0714ca3cb466831fd4be634", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM5Njk4NjhkNjNiMjkzMGEwNzE0Y2EzY2I0NjY4MzFmZDRiZTYzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-12-31T08:28:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-12-31T08:28:24Z"}, "message": "Fix SSA update when vectorisation adds a vdef to a read-only loop\n\nThis patch fixes an awkward corner case in which:\n\n(a) we apply if-conversion to a loop;\n\n(b) the original scalar loop doesn't have a vdef, and thus doesn't\n    need a virtual phi;\n\n(c) the vectorised main loop does need a vdef and a virtual phi (see below);\n\n(d) we also vectorise the epilogue; and\n\n(e) the vectorised epilogue still needs a scalar epilogue\n\nThe specific case in which (c) applies is if a read-only loop is\nvectorised using IFN_LOAD_LANES, which uses clobber statements to\nmark the lifetime of the temporary array.\n\nThe vectoriser relies on the SSA renamer to update virtual operands.\nAll would probably be well if it postponed this update until after\nit had vectorised both the main loop and the epilogue loop.  However,\nwhen vectorising the epilogue, vect_do_peeling does:\n\n  create_lcssa_for_virtual_phi (loop);\n  update_ssa (TODO_update_ssa_only_virtuals);\n\n(with \"loop\" in this case being the to-be-vectorised epilogue loop).\nSo the vectoriser puts the virtual operand into SSA form for the\nvectorised main loop as a separate step, during the early stages\nof vectorising the epilogue.\n\nI wasn't sure at first why that update_ssa was there.  It looked\ninitially like it was related to create_lcssa_for_virtual_phi,\nwhich seemed strange when create_lcssa_for_virtual_phi keeps the\nSSA form up-to-date.  But before r241099 it had the following comment,\nwhich AFAICT is still the reason:\n\n  /* We might have a queued need to update virtual SSA form.  As we\n     delete the update SSA machinery below after doing a regular\n     incremental SSA update during loop copying make sure we don't\n     lose that fact.\n     ???  Needing to update virtual SSA form by renaming is unfortunate\n     but not all of the vectorizer code inserting new loads / stores\n     properly assigns virtual operands to those statements.  */\n\nThe patch restores that comment since IMO it's helpful.\n\n(a), (d) and (e) mean that we copy the original un-if-converted scalar\nloop to act as the scalar epilogue.  The update_ssa above means that this\ncopying needs to cope with any new virtual SSA names in the main loop.\nThe code to do that (reasonably) assumed that one of two things was true:\n\n(1) the scalar loop and the vector loops don't have vdefs, and so no\n    virtual operand update is needed.  The definition that applies\n    on entry to the loops is the same in all cases.\n\n(2) the scalar loop and the vector loops have virtual phis, and so --\n    after applying create_lcssa_for_virtual_phi on the to-be-vectorised\n    epilogue loop -- the virtual operand update can be handled in the\n    same way as for normal SSA names.\n\nBut (b) and (c) together mean that the scalar loop and the\nstill-to-be-vectorised epilogue loop have no virtual phi that (2)\ncan use.  We'd therefore keep the original vuses when duplicating,\nrather than updating them to the definition that applies on exit\nfrom the epilogue loop.  (Since the epilogue is still unvectorised\nand has no vdefs, the definition that applies on exit is the same\nas the one that applies on entry.)\n\nThis patch therefore adds a third case: the scalar loop and\nto-be-vectorised epilogue have no virtual defs, but the main loop does.\n\n2019-12-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-loop-manip.c (create_lcssa_for_virtual_phi): Return\n\tthe incoming virtual operand definition.\n\t(vect_do_peeling): When vectorizing an epilogue loop, handle the\n\tcase in which the main loop has a virtual phi and the epilogue\n\tand scalar loops don't.  Restore an earlier comment about the\n\tupdate_ssa call.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-epilogues-2.c: New test.\n\nFrom-SVN: r279802", "tree": {"sha": "0a14f29f42cfefab7ebf765c9368be07062d29b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a14f29f42cfefab7ebf765c9368be07062d29b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3969868d63b2930a0714ca3cb466831fd4be634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3969868d63b2930a0714ca3cb466831fd4be634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3969868d63b2930a0714ca3cb466831fd4be634", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3969868d63b2930a0714ca3cb466831fd4be634/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "657ccd4d5bf675a3998aa5329cad35732b6262f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/657ccd4d5bf675a3998aa5329cad35732b6262f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/657ccd4d5bf675a3998aa5329cad35732b6262f9"}], "stats": {"total": 136, "additions": 132, "deletions": 4}, "files": [{"sha": "a75b9012e58158c3562bc1592838dfeb188a757c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3969868d63b2930a0714ca3cb466831fd4be634", "patch": "@@ -1,3 +1,12 @@\n+2020-12-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-loop-manip.c (create_lcssa_for_virtual_phi): Return\n+\tthe incoming virtual operand definition.\n+\t(vect_do_peeling): When vectorizing an epilogue loop, handle the\n+\tcase in which the main loop has a virtual phi and the epilogue\n+\tand scalar loops don't.  Restore an earlier comment about the\n+\tupdate_ssa call.\n+\n 2019-12-30  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/vxworks/stdint.h: New file.  Include _yvals.h"}, {"sha": "097c61d6f7dae20483e2cfa3e1537f09c95cd7e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e3969868d63b2930a0714ca3cb466831fd4be634", "patch": "@@ -1,3 +1,7 @@\n+2020-12-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/vect-epilogues-2.c: New test.\n+\n 2019-12-30  Olivier Hainque  <hainque@adacore.com>\n \n \t* gcc.dg/vect/tree-vect.h: #undef OFFSET."}, {"sha": "b251e1f2dfd2c0490c9eb826ec9717c10eaf7b34", "filename": "gcc/testsuite/gcc.dg/vect/vect-epilogues-2.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-epilogues-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-epilogues-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-epilogues-2.c?ref=e3969868d63b2930a0714ca3cb466831fd4be634", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+\n+int\n+f1 (int *x, int n)\n+{\n+  int res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res += x[i * 2] == 1 ? 2 : 3;\n+  return res;\n+}\n+\n+int\n+f2 (int *x)\n+{\n+  int res = 0;\n+  for (int i = 0; i < 0x83; ++i)\n+    res += x[i * 2] == 1 ? 2 : 3;\n+  return res;\n+}\n+\n+int\n+f3 (int *x, int n)\n+{\n+  int res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res += x[i * 2] == 1 ? 2 : 3;\n+  return res + x[0x100];\n+}\n+\n+int\n+f4 (int *x)\n+{\n+  int res = 0;\n+  for (int i = 0; i < 0x83; ++i)\n+    res += x[i * 2] == 1 ? 2 : 3;\n+  return res + x[0x100];\n+}\n+\n+int\n+f5 (int *x, int n, int a)\n+{\n+  int res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res += x[i * 2] == 1 ? 2 : 3;\n+  x[a] += 1;\n+  return res;\n+}\n+\n+int\n+f6 (int *x, int a)\n+{\n+  int res = 0;\n+  for (int i = 0; i < 0x83; ++i)\n+    res += x[i * 2] == 1 ? 2 : 3;\n+  x[a] += 1;\n+  return res;\n+}"}, {"sha": "dd2d943f167172d1d35ee29e9f0f912bdbe3d51a", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3969868d63b2930a0714ca3cb466831fd4be634/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=e3969868d63b2930a0714ca3cb466831fd4be634", "patch": "@@ -1249,9 +1249,12 @@ slpeel_can_duplicate_loop_p (const class loop *loop, const_edge e)\n    the *guard[12] routines, which assume loop closed SSA form for all PHIs\n    (but normally loop closed SSA form doesn't require virtual PHIs to be\n    in the same form).  Doing this early simplifies the checking what\n-   uses should be renamed.  */\n+   uses should be renamed.\n \n-static void\n+   If we create a new phi after the loop, return the definition that\n+   applies on entry to the loop, otherwise return null.  */\n+\n+static tree\n create_lcssa_for_virtual_phi (class loop *loop)\n {\n   gphi_iterator gsi;\n@@ -1283,10 +1286,12 @@ create_lcssa_for_virtual_phi (class loop *loop)\n \t\t  && !flow_bb_inside_loop_p (loop, gimple_bb (stmt)))\n \t\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t\t  SET_USE (use_p, new_vop);\n+\n+\t    return PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n \t  }\n \tbreak;\n       }\n-\n+  return NULL_TREE;\n }\n \n /* Function vect_get_loop_location.\n@@ -2483,9 +2488,42 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   class loop *prolog, *epilog = NULL, *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   class loop *first_loop = loop;\n   bool irred_flag = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n-  create_lcssa_for_virtual_phi (loop);\n+\n+  /* We might have a queued need to update virtual SSA form.  As we\n+     delete the update SSA machinery below after doing a regular\n+     incremental SSA update during loop copying make sure we don't\n+     lose that fact.\n+     ???  Needing to update virtual SSA form by renaming is unfortunate\n+     but not all of the vectorizer code inserting new loads / stores\n+     properly assigns virtual operands to those statements.  */\n   update_ssa (TODO_update_ssa_only_virtuals);\n \n+  create_lcssa_for_virtual_phi (loop);\n+\n+  /* If we're vectorizing an epilogue loop, the update_ssa above will\n+     have ensured that the virtual operand is in SSA form throughout the\n+     vectorized main loop.  Normally it is possible to trace the updated\n+     vector-stmt vdefs back to scalar-stmt vdefs and vector-stmt vuses\n+     back to scalar-stmt vuses, meaning that the effect of the SSA update\n+     remains local to the main loop.  However, there are rare cases in\n+     which the vectorized loop has vdefs even when the original scalar\n+     loop didn't.  For example, vectorizing a load with IFN_LOAD_LANES\n+     introduces clobbers of the temporary vector array, which in turn\n+     needs new vdefs.  If the scalar loop doesn't write to memory, these\n+     new vdefs will be the only ones in the vector loop.\n+\n+     In that case, update_ssa will have added a new virtual phi to the\n+     main loop, which previously didn't need one.  Ensure that we (locally)\n+     maintain LCSSA form for the virtual operand, just as we would have\n+     done if the virtual phi had existed from the outset.  This makes it\n+     easier to duplicate the scalar epilogue loop below.  */\n+  tree vop_to_rename = NULL_TREE;\n+  if (loop_vec_info orig_loop_vinfo = LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo))\n+    {\n+      class loop *orig_loop = LOOP_VINFO_LOOP (orig_loop_vinfo);\n+      vop_to_rename = create_lcssa_for_virtual_phi (orig_loop);\n+    }\n+\n   if (MAY_HAVE_DEBUG_BIND_STMTS)\n     {\n       gcc_assert (!adjust_vec.exists ());\n@@ -2706,6 +2744,26 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t as the transformations mentioned above make less or no sense when not\n \t vectorizing.  */\n       epilog = vect_epilogues ? get_loop_copy (loop) : scalar_loop;\n+      if (vop_to_rename)\n+\t{\n+\t  /* Vectorizing the main loop can sometimes introduce a vdef to\n+\t     a loop that previously didn't have one; see the comment above\n+\t     the definition of VOP_TO_RENAME for details.  The definition\n+\t     D that holds on E will then be different from the definition\n+\t     VOP_TO_RENAME that holds during SCALAR_LOOP, so we need to\n+\t     rename VOP_TO_RENAME to D when copying the loop.\n+\n+\t     The virtual operand is in LCSSA form for the main loop,\n+\t     and no stmt between the main loop and E needs a vdef,\n+\t     so we know that D is provided by a phi rather than by a\n+\t     vdef on a normal gimple stmt.  */\n+\t  basic_block vdef_bb = e->src;\n+\t  gphi *vphi;\n+\t  while (!(vphi = get_virtual_phi (vdef_bb)))\n+\t    vdef_bb = get_immediate_dominator (CDI_DOMINATORS, vdef_bb);\n+\t  gcc_assert (vop_to_rename != gimple_phi_result (vphi));\n+\t  set_current_def (vop_to_rename, gimple_phi_result (vphi));\n+\t}\n       epilog = slpeel_tree_duplicate_loop_to_edge_cfg (loop, epilog, e);\n       if (!epilog)\n \t{"}]}