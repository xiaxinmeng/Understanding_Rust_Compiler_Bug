{"sha": "f700c7caef3feffdadcac957ac92f8c5d8470270", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcwMGM3Y2FlZjNmZWZmZGFkY2FjOTU3YWM5MmY4YzVkODQ3MDI3MA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-09-25T13:09:04Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-09-25T13:09:04Z"}, "message": "re PR target/67675 ([SH] Improve __builtin_strcmp alignment test)\n\ngcc/\n\tPR target/67675\n\t* config/sh/sh-mem.cc (sh_expand_cmpstr): Check alignment of addr1 and\n\taddr2 individually.  Don't emit logical or insn if one is known to\n\tbe aligned approriately.\n\t(sh_expand_cmpnstr): Likewise.\n\ngcc/testsuite/\n\tPR target/67675\n\t* gcc.target/sh/pr67675.c: New.\n\nFrom-SVN: r228118", "tree": {"sha": "3c86b2d2f88c9494b6dd64f20b22561056c759e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c86b2d2f88c9494b6dd64f20b22561056c759e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f700c7caef3feffdadcac957ac92f8c5d8470270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f700c7caef3feffdadcac957ac92f8c5d8470270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f700c7caef3feffdadcac957ac92f8c5d8470270", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f700c7caef3feffdadcac957ac92f8c5d8470270/comments", "author": null, "committer": null, "parents": [{"sha": "e6cf8d65b5839c8964588deb807eda6314a07640", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cf8d65b5839c8964588deb807eda6314a07640", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6cf8d65b5839c8964588deb807eda6314a07640"}], "stats": {"total": 112, "additions": 106, "deletions": 6}, "files": [{"sha": "1fe4e933737e8b6ba1fc40bd7d70fb4bb832fb50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f700c7caef3feffdadcac957ac92f8c5d8470270", "patch": "@@ -1,3 +1,11 @@\n+2015-09-25  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/67675\n+\t* config/sh/sh-mem.cc (sh_expand_cmpstr): Check alignment of addr1 and\n+\taddr2 individually.  Don't emit logical or insn if one is known to\n+\tbe aligned approriately.\n+\t(sh_expand_cmpnstr): Likewise.\n+\n 2015-09-25  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (aarch64_expand_builtin): Force"}, {"sha": "23a7287ef27c242a4ea21615841e1da0b750b23b", "filename": "gcc/config/sh/sh-mem.cc", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-mem.cc?ref=f700c7caef3feffdadcac957ac92f8c5d8470270", "patch": "@@ -224,17 +224,28 @@ sh_expand_cmpstr (rtx *operands)\n   rtx_code_label *L_loop_long = gen_label_rtx ();\n   rtx_code_label *L_end_loop_long = gen_label_rtx ();\n \n-  int align = INTVAL (operands[3]);\n-\n-  emit_move_insn (tmp0, const0_rtx);\n+  const unsigned int addr1_alignment = MEM_ALIGN (operands[1]) / BITS_PER_UNIT;\n+  const unsigned int addr2_alignment = MEM_ALIGN (operands[2]) / BITS_PER_UNIT;\n \n-  if (align < 4)\n+  if (addr1_alignment < 4 && addr2_alignment < 4)\n     {\n       emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));\n       emit_insn (gen_tstsi_t (tmp1, GEN_INT (3)));\n       jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n       add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n     }\n+  else if (addr1_alignment < 4 && addr2_alignment >= 4)\n+    {\n+      emit_insn (gen_tstsi_t (s1_addr, GEN_INT (3)));\n+      jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+    }\n+  else if (addr1_alignment >= 4 && addr2_alignment < 4)\n+    {\n+      emit_insn (gen_tstsi_t (s2_addr, GEN_INT (3)));\n+      jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+    }\n \n   addr1 = adjust_automodify_address (addr1, SImode, s1_addr, 0);\n   addr2 = adjust_automodify_address (addr2, SImode, s2_addr, 0);\n@@ -352,6 +363,9 @@ sh_expand_cmpnstr (rtx *operands)\n   rtx len = force_reg (SImode, operands[3]);\n   int constp = CONST_INT_P (operands[3]);\n \n+  const unsigned int addr1_alignment = MEM_ALIGN (operands[1]) / BITS_PER_UNIT;\n+  const unsigned int addr2_alignment = MEM_ALIGN (operands[2]) / BITS_PER_UNIT;\n+\n   /* Loop on a register count.  */\n   if (constp)\n     {\n@@ -362,7 +376,6 @@ sh_expand_cmpnstr (rtx *operands)\n       rtx_code_label *L_loop_long = gen_label_rtx ();\n       rtx_code_label *L_end_loop_long = gen_label_rtx ();\n \n-      int align = INTVAL (operands[4]);\n       int bytes = INTVAL (operands[3]);\n       int witers = bytes / 4;\n \n@@ -373,13 +386,25 @@ sh_expand_cmpnstr (rtx *operands)\n \n \t  emit_move_insn (tmp0, const0_rtx);\n \n-\t  if (align < 4)\n+\t  if (addr1_alignment < 4 && addr2_alignment < 4)\n \t    {\n \t      emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));\n \t      emit_insn (gen_tstsi_t (tmp1, GEN_INT (3)));\n \t      jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n \t      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n \t    }\n+\t  else if (addr1_alignment < 4 && addr2_alignment >= 4)\n+\t    {\n+\t      emit_insn (gen_tstsi_t (s1_addr, GEN_INT (3)));\n+\t      jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+\t      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+\t    }\n+\t  else if (addr1_alignment >= 4 && addr2_alignment < 4)\n+\t    {\n+\t      emit_insn (gen_tstsi_t (s2_addr, GEN_INT (3)));\n+\t      jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+\t      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+\t    }\n \n \t  /* word count. Do we have iterations ?  */\n \t  emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));"}, {"sha": "30bd3a264b43df2d8ae5980f6badb06f23a4ac11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f700c7caef3feffdadcac957ac92f8c5d8470270", "patch": "@@ -1,3 +1,8 @@\n+2015-09-25  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/67675\n+\t* gcc.target/sh/pr67675.c: New.\n+\n 2015-09-25  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/fpcr_fpsr_1.c: New file."}, {"sha": "e6c5d0d9b9f8752f546269dc825eb8066b134018", "filename": "gcc/testsuite/gcc.target/sh/pr67675.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr67675.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f700c7caef3feffdadcac957ac92f8c5d8470270/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr67675.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr67675.c?ref=f700c7caef3feffdadcac957ac92f8c5d8470270", "patch": "@@ -0,0 +1,62 @@\n+/* Check that run time alignment tests are generated only for inputs of\n+   unknown alignment.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-final { scan-assembler-not \"jmp|bsr|jsr\" } }  */\n+/* { dg-final { scan-assembler-times {tst\t#3,r0} 6 } }  */\n+/* { dg-final { scan-assembler-times {or\tr[0-9],r[0-9]} 1 } }  */\n+\n+int\n+test_00 (const char* x, const char* y)\n+{\n+  /* 1x or reg,reg, 1x tst #3,r0  */\n+  return __builtin_strcmp (x, y);\n+}\n+\n+int\n+test_01 (const char* x, const char* y)\n+{\n+  /* 1x tst #3,r0  */\n+  return __builtin_strcmp (__builtin_assume_aligned (x, 4), y);\n+}\n+\n+int\n+test_02 (const char* x, const char* y)\n+{\n+  /* 1x tst #3,r0  */\n+  return __builtin_strcmp (x, __builtin_assume_aligned (y, 4));\n+}\n+\n+int\n+test_03 (const char* x, const char* y)\n+{\n+  return __builtin_strcmp (__builtin_assume_aligned (x, 4),\n+\t\t\t   __builtin_assume_aligned (y, 4));\n+}\n+\n+int\n+test_04 (const char* x, const char* y)\n+{\n+  /* 1x tst #3,r0  */\n+  return __builtin_strcmp (x, \"1234567\");\n+}\n+\n+int\n+test_05 (const char* x, const char* y)\n+{\n+  /* 1x tst #3,r0  */\n+  return __builtin_strcmp (\"1234567\", y);\n+}\n+\n+int\n+test_06 (const char* s1)\n+{\n+  /* 1x tst #3,r0  */\n+  return __builtin_strncmp (s1, \"abcdabcd\", 8);\n+}\n+\n+int\n+test_07 (const char* s1)\n+{\n+  return __builtin_strncmp (__builtin_assume_aligned (s1, 4), \"abcdabcd\", 8);\n+}"}]}