{"sha": "3434c119a309db4ff991d50b6ebe25a017b58cd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQzNGMxMTlhMzA5ZGI0ZmY5OTFkNTBiNmViZTI1YTAxN2I1OGNkNw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-02-08T15:13:32Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-02-08T15:13:32Z"}, "message": "re PR fortran/54107 ([F03] Memory hog with abstract interface)\n\nfortran/\n\tPR fortran/54107\n\t* trans-types.c (gfc_get_function_type): Change a NULL backend_decl\n\tto error_mark_node on entry.  Detect recursive types.  Build a variadic\n\tprocedure type if the type is recursive.  Restore the initial\n\tbackend_decl.\n\ntestsuite/\n\tPR fortran/54107\n\t* gfortran.dg/recursive_interface_2.f90: New test.\n\nFrom-SVN: r195890", "tree": {"sha": "396927675c70a031f01648aeeee123668f8c7712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/396927675c70a031f01648aeeee123668f8c7712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3434c119a309db4ff991d50b6ebe25a017b58cd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3434c119a309db4ff991d50b6ebe25a017b58cd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3434c119a309db4ff991d50b6ebe25a017b58cd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3434c119a309db4ff991d50b6ebe25a017b58cd7/comments", "author": null, "committer": null, "parents": [{"sha": "600a5961b24faccf68ef5287fb3a6ed3c6b79224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600a5961b24faccf68ef5287fb3a6ed3c6b79224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600a5961b24faccf68ef5287fb3a6ed3c6b79224"}], "stats": {"total": 67, "additions": 59, "deletions": 8}, "files": [{"sha": "6505704a9652bbe211fe83e03fc391ef00c3f387", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3434c119a309db4ff991d50b6ebe25a017b58cd7", "patch": "@@ -1,3 +1,11 @@\n+2013-02-08  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/54107\n+\t* trans-types.c (gfc_get_function_type): Change a NULL backend_decl\n+\tto error_mark_node on entry.  Detect recursive types.  Build a variadic\n+\tprocedure type if the type is recursive.  Restore the initial\n+\tbackend_decl.\n+\n 2013-02-07  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/54339 "}, {"sha": "30561ee7ecfe6465bd3a3269e0dc3ddc15275936", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=3434c119a309db4ff991d50b6ebe25a017b58cd7", "patch": "@@ -2711,19 +2711,23 @@ gfc_get_function_type (gfc_symbol * sym)\n   gfc_formal_arglist *f;\n   gfc_symbol *arg;\n   int alternate_return;\n-  bool is_varargs = true;\n+  bool is_varargs = true, recursive_type = false;\n \n   /* Make sure this symbol is a function, a subroutine or the main\n      program.  */\n   gcc_assert (sym->attr.flavor == FL_PROCEDURE\n \t      || sym->attr.flavor == FL_PROGRAM);\n \n-  if (sym->backend_decl)\n-    {\n-      if (sym->attr.proc_pointer)\n-\treturn TREE_TYPE (TREE_TYPE (sym->backend_decl));\n-      return TREE_TYPE (sym->backend_decl);\n-    }\n+  /* To avoid recursing infinitely on recursive types, we use error_mark_node\n+     so that they can be detected here and handled further down.  */\n+  if (sym->backend_decl == NULL)\n+    sym->backend_decl = error_mark_node;\n+  else if (sym->backend_decl == error_mark_node)\n+    recursive_type = true;\n+  else if (sym->attr.proc_pointer)\n+    return TREE_TYPE (TREE_TYPE (sym->backend_decl));\n+  else\n+    return TREE_TYPE (sym->backend_decl);\n \n   alternate_return = 0;\n   typelist = NULL;\n@@ -2775,6 +2779,13 @@ gfc_get_function_type (gfc_symbol * sym)\n \n \t  if (arg->attr.flavor == FL_PROCEDURE)\n \t    {\n+\t      /* We don't know in the general case which argument causes\n+\t\t recursion.  But we know that it is a procedure.  So we give up\n+\t\t creating the procedure argument type list at the first\n+\t\t procedure argument.  */\n+\t      if (recursive_type)\n+\t        goto arg_type_list_done;\n+\n \t      type = gfc_get_function_type (arg);\n \t      type = build_pointer_type (type);\n \t    }\n@@ -2828,6 +2839,11 @@ gfc_get_function_type (gfc_symbol * sym)\n       || sym->attr.if_source != IFSRC_UNKNOWN)\n     is_varargs = false;\n \n+arg_type_list_done:\n+\n+  if (!recursive_type && sym->backend_decl == error_mark_node)\n+    sym->backend_decl = NULL_TREE;\n+\n   if (alternate_return)\n     type = integer_type_node;\n   else if (!sym->attr.function || gfc_return_by_reference (sym))\n@@ -2865,7 +2881,7 @@ gfc_get_function_type (gfc_symbol * sym)\n   else\n     type = gfc_sym_type (sym);\n \n-  if (is_varargs)\n+  if (is_varargs || recursive_type)\n     type = build_varargs_function_type_vec (type, typelist);\n   else\n     type = build_function_type_vec (type, typelist);"}, {"sha": "60fc9289f2bbdd32ad5ad45ff929e2c95c091b4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3434c119a309db4ff991d50b6ebe25a017b58cd7", "patch": "@@ -1,3 +1,8 @@\n+2013-02-08  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/54107\n+\t* gfortran.dg/recursive_interface_2.f90: New test.\n+\n 2013-02-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/56250"}, {"sha": "9726a0ef7ee4eb3b7bcd88a853857a95c7bde5f5", "filename": "gcc/testsuite/gfortran.dg/recursive_interface_2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_interface_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3434c119a309db4ff991d50b6ebe25a017b58cd7/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_interface_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_interface_2.f90?ref=3434c119a309db4ff991d50b6ebe25a017b58cd7", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+!\n+! PR fortran/54107\n+! Recursive interfaces used to lead to an infinite recursion during\n+! translation.\n+\n+module m\n+ contains\n+  subroutine foo (arg) \n+    procedure(foo) :: arg \n+  end subroutine \n+  function foo2 (arg) result(r)\n+    procedure(foo2) :: arg\n+    procedure(foo2), pointer :: r\n+  end function \n+  subroutine bar (arg) \n+    procedure(baz) :: arg \n+  end subroutine \n+  subroutine baz (arg) \n+    procedure(bar) :: arg \n+  end subroutine \n+end module m"}]}