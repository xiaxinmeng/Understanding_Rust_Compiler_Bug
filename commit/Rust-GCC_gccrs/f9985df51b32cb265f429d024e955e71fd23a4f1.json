{"sha": "f9985df51b32cb265f429d024e955e71fd23a4f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk5ODVkZjUxYjMyY2IyNjVmNDI5ZDAyNGU5NTVlNzFmZDIzYTRmMQ==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2008-04-07T08:27:34Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2008-04-07T08:27:34Z"}, "message": "re PR libstdc++/35588 ([parallel mode] parallel std::sort and bind())\n\n2008-04-07  Johannes Singler  <singler@ira.uka.de>\n\n         * include/parallel/multiway_merge.h:\n           Moved decisions to compiletime instead of runtime.\n         * include/parallel/losertree.h:\n           Removed obsolete variants, added variant that uses pointers\n           in the loser tree.\n         * include/parallel/types.h:\n           Remove obsolete settings options from enum.\n         * include/parallel/features.h:\n           Remove obsolete compile-time switches.\n         * include/parallel/compiletime_settings.h:\n           Remove obsolete variant that copies back *after* sorting.\n         * include/parallel/tags.h:\n           Add one new tag for compile-time switch.\n         * include/parallel/merge.h:\n           Adapt to changes in multiway_merge.h.\n         * include/parallel/multiway_mergesort.h:\n           Adapt to changes in multiway_merge.h.\n           Factor out splitting variants.\n           Remove obsolete variant that copies back *after* sorting.\n         * include/parallel/sort.h:\n           Adapt to changes in multiway_mergesort.h.\n         * testsuite/25_algorithms/sort/35588.cc:\n           Added test case from / for PR 35588.\n\nFrom-SVN: r133975", "tree": {"sha": "e2e44f1d16ae320c57bc274b9ec59d0eb8838d7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e44f1d16ae320c57bc274b9ec59d0eb8838d7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9985df51b32cb265f429d024e955e71fd23a4f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9985df51b32cb265f429d024e955e71fd23a4f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9985df51b32cb265f429d024e955e71fd23a4f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9985df51b32cb265f429d024e955e71fd23a4f1/comments", "author": null, "committer": null, "parents": [{"sha": "1d4cd3d0b5e866a6b0ce1bea8dbf0526f794dffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d4cd3d0b5e866a6b0ce1bea8dbf0526f794dffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d4cd3d0b5e866a6b0ce1bea8dbf0526f794dffe"}], "stats": {"total": 4927, "additions": 2538, "deletions": 2389}, "files": [{"sha": "e452aaab6a82c319855fd28433234f48b4e79ef5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -1,3 +1,29 @@\n+2008-04-07  Johannes Singler  <singler@ira.uka.de>\n+\n+         * include/parallel/multiway_merge.h:\n+           Moved decisions to compiletime instead of runtime.\n+         * include/parallel/losertree.h:\n+           Removed obsolete variants, added variant that uses pointers\n+           in the loser tree.\n+         * include/parallel/types.h:\n+           Remove obsolete settings options from enum.\n+         * include/parallel/features.h:\n+           Remove obsolete compile-time switches.\n+         * include/parallel/compiletime_settings.h:\n+           Remove obsolete variant that copies back *after* sorting.\n+         * include/parallel/tags.h:\n+           Add one new tag for compile-time switch.\n+         * include/parallel/merge.h:\n+           Adapt to changes in multiway_merge.h.\n+         * include/parallel/multiway_mergesort.h:\n+           Adapt to changes in multiway_merge.h.\n+           Factor out splitting variants.\n+           Remove obsolete variant that copies back *after* sorting.\n+         * include/parallel/sort.h:\n+           Adapt to changes in multiway_mergesort.h.\n+         * testsuite/25_algorithms/sort/35588.cc:\n+           Added test case from / for PR 35588. \n+\n 2008-03-29  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/35725"}, {"sha": "8ab89aa8ee94edd6dd4a654ca06eb139e652dafa", "filename": "libstdc++-v3/include/parallel/compiletime_settings.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -73,17 +73,9 @@\n  *  __gnu_parallel::parallel_random_shuffle(). */\n #define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1 0\n #endif\n-#ifndef _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB \n+#ifndef _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n /** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n  *  Consider the size of the TLB for\n  *  __gnu_parallel::parallel_random_shuffle(). */\n #define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB 0\n #endif\n-\n-#ifndef _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n-/** @brief First copy the data, sort it locally, and merge it back\n- * (0); or copy it back after everything is done (1).\n- *\n- *  Recommendation: 0 */\n-#define _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST 0\n-#endif"}, {"sha": "7150c20affcd9c620f94ec77fda36d00fac4aec4", "filename": "libstdc++-v3/include/parallel/features.h", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -61,66 +61,6 @@\n #define _GLIBCXX_BAL_QUICKSORT 1\n #endif\n \n-#ifndef _GLIBCXX_LOSER_TREE\n-/** @def _GLIBCXX_LOSER_TREE\n- *  @brief Include guarded (sequences may run empty) loser tree,\n- *  moving objects.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE 1\n-#endif\n-\n-#ifndef _GLIBCXX_LOSER_TREE_EXPLICIT\n-/** @def _GLIBCXX_LOSER_TREE_EXPLICIT\n- *  @brief Include standard loser tree, storing two flags for infimum\n- *  and supremum.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE_EXPLICIT 0\n-#endif\n-\n-#ifndef _GLIBCXX_LOSER_TREE_REFERENCE\n-/** @def _GLIBCXX_LOSER_TREE_REFERENCE\n- *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE_REFERENCE 0\n-#endif\n-\n-#ifndef _GLIBCXX_LOSER_TREE_POINTER\n-/** @def _GLIBCXX_LOSER_TREE_POINTER\n- *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE_POINTER 1\n-#endif\n-\n-#ifndef _GLIBCXX_LOSER_TREE_UNGUARDED\n-/** @def _GLIBCXX_LOSER_TREE_UNGUARDED\n- *  @brief Include unguarded (sequences must not run empty) loser\n- *  tree, moving objects.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE_UNGUARDED 0\n-#endif\n-\n-#ifndef _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n-/** @def _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n- *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED 1\n-#endif\n-\n-#ifndef _GLIBCXX_LOSER_TREE_COMBINED\n-/** @def _GLIBCXX_LOSER_TREE_COMBINED\n- *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE_COMBINED 0\n-#endif\n-\n-#ifndef _GLIBCXX_LOSER_TREE_SENTINEL\n-/** @def _GLIBCXX_LOSER_TREE_SENTINEL\n- *  @brief Include some loser tree variant.\n- *  @see __gnu_parallel::_Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE_SENTINEL 0\n-#endif\n-\n-\n #ifndef _GLIBCXX_FIND_GROWING_BLOCKS\n /** @brief Include the growing blocks variant for std::find.\n  *  @see __gnu_parallel::_Settings::find_algorithm */"}, {"sha": "cae15c0826eca6d6b33f4c4624aaf3a73a336bda", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 894, "deletions": 989, "changes": 1883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -47,1054 +47,959 @@\n namespace __gnu_parallel\n {\n \n-#if _GLIBCXX_LOSER_TREE_EXPLICIT\n-\n-/** @brief Guarded loser tree, copying the whole element into the\n-* tree structure.\n-*\n-*  Guarding is done explicitly through two flags per element, inf\n-*  and sup This is a quite slow variant.\n-*/\n-template<typename T, typename Comparator = std::less<T> >\n-  class LoserTreeExplicit\n+/**\n+ * @brief Guarded loser/tournament tree.\n+ *\n+ * The smallest element is at the top.\n+ *\n+ * Guarding is done explicitly through one flag sup per element,\n+ * inf is not needed due to a better initialization routine.  This\n+ * is a well-performing variant.\n+ *\n+ * @param T the element type\n+ * @param Comparator the comparator to use, defaults to std::less<T>\n+ */\n+template<typename T, typename Comparator>\n+class LoserTreeBase\n+{\n+protected:\n+  /** @brief Internal representation of a LoserTree element. */\n+  struct Loser\n   {\n-  private:\n-    struct Loser\n-    {\n-      // The relevant element.\n-      T key;\n-\n-      // Is this an infimum or supremum element?\n-      bool inf, sup;\n-\n-      // Number of the sequence the element comes from.\n-      int source;\n-    };\n-\n-    unsigned int size, offset;\n-    Loser* losers;\n-    Comparator comp;\n-\n-  public:\n-    LoserTreeExplicit(unsigned int _size, Comparator _comp = std::less<T>())\n-    : comp(_comp)\n-    {\n-      size = _size;\n-      offset = size;\n-      losers = new Loser[size];\n-      for (unsigned int l = 0; l < size; ++l)\n-        {\n-          //losers[l].key = ... \tstays unset\n-          losers[l].inf = true;\n-          losers[l].sup = false;\n-          //losers[l].source = -1;\t//sentinel\n-        }\n-    }\n-\n-    ~LoserTreeExplicit()\n-    { delete[] losers; }\n+    /** @brief flag, true iff this is a \"maximum\" sentinel. */\n+    bool sup;\n+    /** @brief index of the source sequence. */\n+    int source;\n+    /** @brief key of the element in the LoserTree. */\n+    T key;\n+  };\n \n-    int\n-    get_min_source()\n-    { return losers[0].source; }\n+  unsigned int ik, k, offset;\n+\n+  /** log_2{k} */\n+  unsigned int _M_log_k;\n+\n+  /** @brief LoserTree elements. */\n+  Loser* losers;\n+\n+  /** @brief Comparator to use. */\n+  Comparator comp;\n+\n+  /**\n+   * @brief State flag that determines whether the LoserTree is empty.\n+   *\n+   * Only used for building the LoserTree.\n+   */\n+  bool first_insert;\n+\n+public:\n+  /**\n+   * @brief The constructor.\n+   *\n+   * @param _k The number of sequences to merge.\n+   * @param _comp The comparator to use.\n+   */\n+  LoserTreeBase(unsigned int _k, Comparator _comp)\n+  : comp(_comp)\n+  {\n+    ik = _k;\n+\n+    // Compute log_2{k} for the Loser Tree\n+    _M_log_k = log2(ik - 1) + 1;\n+\n+    // Next greater power of 2.\n+    k = 1 << _M_log_k;\n+    offset = k;\n+\n+    // Avoid default-constructing losers[].key\n+    losers = static_cast<Loser*>(::operator new(2 * k * sizeof(Loser)));\n+    for (unsigned int i = ik - 1; i < k; ++i)\n+      losers[i + k].sup = true;\n+\n+    first_insert = true;\n+  }\n+\n+  /**\n+   * @brief The destructor.\n+   */\n+  ~LoserTreeBase()\n+  { ::operator delete(losers); }\n+\n+  /**\n+   * @brief Initializes the sequence \"source\" with the element \"key\".\n+   *\n+   * @param key the element to insert\n+   * @param source index of the source sequence\n+   * @param sup flag that determines whether the value to insert is an\n+   *   explicit supremum.\n+   */\n+  inline void\n+  insert_start(const T& key, int source, bool sup)\n+  {\n+    unsigned int pos = k + source;\n+\n+    if(first_insert)\n+      {\n+        // Construct all keys, so we can easily deconstruct them.\n+        for (unsigned int i = 0; i < (2 * k); ++i)\n+          new(&(losers[i].key)) T(key);\n+        first_insert = false;\n+      }\n+    else\n+      new(&(losers[pos].key)) T(key);\n+\n+    losers[pos].sup = sup;\n+    losers[pos].source = source;\n+  }\n+\n+  /**\n+   * @return the index of the sequence with the smallest element.\n+   */\n+  int get_min_source()\n+  { return losers[0].source; }\n+};\n+\n+/**\n+ * @brief Stable LoserTree variant.\n+ *\n+ * Provides the stable implementations of insert_start, init_winner,\n+ * init and delete_min_insert.\n+ *\n+ * Unstable variant is done using partial specialisation below.\n+ */\n+template<bool stable/* default == true */, typename T, typename Comparator>\n+class LoserTree : public LoserTreeBase<T, Comparator>\n+{\n+  typedef LoserTreeBase<T, Comparator> Base;\n+  using Base::k;\n+  using Base::losers;\n+  using Base::first_insert;\n+\n+public:\n+  LoserTree(unsigned int _k, Comparator _comp)\n+  : Base::LoserTreeBase(_k, _comp)\n+  {}\n+\n+  unsigned int\n+  init_winner(unsigned int root)\n+  {\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+        if (losers[right].sup\n+            || (!losers[left].sup\n+              && !comp(losers[right].key, losers[left].key)))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  void init()\n+  { losers[0] = losers[init_winner(1)]; }\n+\n+  /**\n+   * @brief Delete the smallest element and insert a new element from\n+   *   the previously smallest element's sequence.\n+   *\n+   * This implementation is stable.\n+   */\n+  // Do not pass a const reference since key will be used as local variable.\n+  void delete_min_insert(T key, bool sup)\n+  {\n+    int source = losers[0].source;\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+      {\n+        // The smaller one gets promoted, ties are broken by source.\n+        if ((sup && (!losers[pos].sup || losers[pos].source < source))\n+              || (!sup && !losers[pos].sup\n+                && ((comp(losers[pos].key, key))\n+                  || (!comp(key, losers[pos].key)\n+                    && losers[pos].source < source))))\n+          {\n+            // The other one is smaller.\n+            std::swap(losers[pos].sup, sup);\n+            std::swap(losers[pos].source, source);\n+            std::swap(losers[pos].key, key);\n+          }\n+      }\n+\n+    losers[0].sup = sup;\n+    losers[0].source = source;\n+    losers[0].key = key;\n+  }\n+};\n+\n+/**\n+ * @brief Unstable LoserTree variant.\n+ *\n+ * Stability (non-stable here) is selected with partial specialization.\n+ */\n+template<typename T, typename Comparator>\n+class LoserTree</* stable == */false, T, Comparator> :\n+    public LoserTreeBase<T, Comparator>\n+{\n+  typedef LoserTreeBase<T, Comparator> Base;\n+  using Base::_M_log_k;\n+  using Base::k;\n+  using Base::losers;\n+  using Base::first_insert;\n+\n+public:\n+  LoserTree(unsigned int _k, Comparator _comp)\n+  : Base::LoserTreeBase(_k, _comp)\n+  {}\n+\n+  /**\n+   * Computes the winner of the competition at position \"root\".\n+   *\n+   * Called recursively (starting at 0) to build the initial tree.\n+   *\n+   * @param root index of the \"game\" to start.\n+   */\n+  unsigned int\n+  init_winner (unsigned int root)\n+  {\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+        if (losers[right].sup ||\n+            (!losers[left].sup\n+              && !comp(losers[right].key, losers[left].key)))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  inline void\n+  init()\n+  { losers[0] = losers[init_winner(1)]; }\n+\n+  /**\n+   * Delete the key smallest element and insert the element key instead.\n+   *\n+   * @param key the key to insert\n+   * @param sup true iff key is an explicitly marked supremum\n+   */\n+  // Do not pass a const reference since key will be used as local variable.\n+  inline void\n+  delete_min_insert(T key, bool sup)\n+  {\n+#if _GLIBCXX_ASSERTIONS\n+    // loser trees are only used for at least 2 sequences\n+    _GLIBCXX_PARALLEL_ASSERT(_M_log_k > 1);\n+#endif\n \n-    void\n-    insert_start(T key, int source, bool sup)\n+    int source = losers[0].source;\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n     {\n-      bool inf = false;\n-      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-        {\n-          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n-               && comp(losers[pos].key, key)) || losers[pos].inf || sup)\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].key, key);\n-              std::swap(losers[pos].inf, inf);\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-            }\n-        }\n-\n-      losers[0].key = key;\n-      losers[0].inf = inf;\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n+        // The smaller one gets promoted.\n+      if (sup || (!losers[pos].sup && comp(losers[pos].key, key)))\n+      {\n+            // The other one is smaller.\n+        std::swap(losers[pos].sup, sup);\n+        std::swap(losers[pos].source, source);\n+        std::swap(losers[pos].key, key);\n+      }\n     }\n \n-    void\n-    init() { }\n+    losers[0].sup = sup;\n+    losers[0].source = source;\n+    losers[0].key = key;\n+  }\n+};\n \n-    void\n-    delete_min_insert(T key, bool sup)\n-    {\n-      bool inf = false;\n-      int source = losers[0].source;\n-      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted.\n-          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n-              && comp(losers[pos].key, key))\n-              || losers[pos].inf || sup)\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].key, key);\n-              std::swap(losers[pos].inf, inf);\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-            }\n-        }\n-\n-      losers[0].key = key;\n-      losers[0].inf = inf;\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-    }\n-\n-    void\n-    insert_start_stable(T key, int source, bool sup)\n-    {\n-      bool inf = false;\n-      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-        {\n-          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n-\t       && ((comp(losers[pos].key, key))\n-\t\t   || (!comp(key, losers[pos].key)\n-\t\t       && losers[pos].source < source)))\n-              || losers[pos].inf || sup)\n-            {\n-              // Take next key.\n-              std::swap(losers[pos].key, key);\n-              std::swap(losers[pos].inf, inf);\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-            }\n-        }\n-\n-      losers[0].key = key;\n-      losers[0].inf = inf;\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-    }\n \n-    void\n-    init_stable() { }\n-\n-    void\n-    delete_min_insert_stable(T key, bool sup)\n-    {\n-      bool inf = false;\n-      int source = losers[0].source;\n-      for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-        {\n-          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n-              && ((comp(losers[pos].key, key))\n-\t\t  || (!comp(key, losers[pos].key)\n-\t\t      && losers[pos].source < source)))\n-              || losers[pos].inf || sup)\n-            {\n-              std::swap(losers[pos].key, key);\n-              std::swap(losers[pos].inf, inf);\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-            }\n-        }\n-\n-      losers[0].key = key;\n-      losers[0].inf = inf;\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-    }\n+/**\n+ * @brief Base class of Loser Tree implementation using pointers.\n+ */\n+template<typename T, typename Comparator>\n+class LoserTreePointerBase\n+{\n+protected:\n+  /** @brief Internal representation of LoserTree elements. */\n+  struct Loser\n+  {\n+    bool sup;\n+    int source;\n+    const T* keyp;\n   };\n \n-#endif\n-\n-#if _GLIBCXX_LOSER_TREE\n+  unsigned int ik, k, offset;\n+  Loser* losers;\n+  Comparator comp;\n \n-/** @brief Guarded loser tree, either copying the whole element into\n-* the tree structure, or looking up the element via the index.\n-*\n-*  Guarding is done explicitly through one flag sup per element,\n-*  inf is not needed due to a better initialization routine.  This\n-*  is a well-performing variant.\n-*/\n-template<typename T, typename Comparator = std::less<T> >\n-  class LoserTree\n-  {\n-  private:\n-    struct Loser\n-    {\n-      bool sup;\n-      int source;\n-      T key;\n-    };\n-\n-    unsigned int ik, k, offset;\n-    Loser* losers;\n-    Comparator comp;\n-    bool first_insert;\n-\n-  public:\n-    LoserTree(unsigned int _k, Comparator _comp = std::less<T>())\n+public:\n+  LoserTreePointerBase(unsigned int _k, Comparator _comp = std::less<T>())\n     : comp(_comp)\n-    {\n-      ik = _k;\n-\n-      // Next greater power of 2.\n-      k = 1 << (log2(ik - 1) + 1);\n-      offset = k;\n-      // Avoid default-constructing losers[].key\n-      losers = static_cast<Loser*>(::operator new(2 * k * sizeof(Loser)));\n-      for (unsigned int i = ik - 1; i < k; ++i)\n-        losers[i + k].sup = true;\n-\n-      first_insert = true;\n-    }\n+  {\n+    ik = _k;\n \n-    ~LoserTree()\n-    { ::operator delete(losers); }\n+    // Next greater power of 2.\n+    k = 1 << (log2(ik - 1) + 1);\n+    offset = k;\n+    losers = new Loser[k * 2];\n+    for (unsigned int i = ik - 1; i < k; i++)\n+      losers[i + k].sup = true;\n+  }\n \n-    int\n-    get_min_source()\n-    { return losers[0].source; }\n+  ~LoserTreePointerBase()\n+  { ::operator delete(losers); }\n \n-    void\n-    insert_start(const T& key, int source, bool sup)\n-    {\n-      unsigned int pos = k + source;\n-\n-      if(first_insert)\n-        {\n-          // Construct all keys, so we can easily deconstruct them.\n-          for (unsigned int i = 0; i < (2 * k); ++i)\n-            ::new(&(losers[i].key)) T(key);\n-          first_insert = false;\n-        }\n-      else\n-        ::new(&(losers[pos].key)) T(key);\n-\n-      losers[pos].sup = sup;\n-      losers[pos].source = source;\n-    }\n+  int get_min_source()\n+  { return losers[0].source; }\n \n-    unsigned int\n-    init_winner (unsigned int root)\n-    {\n-      if (root >= k)\n-        {\n-          return root;\n-        }\n-      else\n-        {\n-          unsigned int left = init_winner (2 * root);\n-          unsigned int right = init_winner (2 * root + 1);\n-          if (losers[right].sup\n-\t      || (!losers[left].sup\n-\t\t  && !comp(losers[right].key, losers[left].key)))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n+  void insert_start(const T& key, int source, bool sup)\n+  {\n+    unsigned int pos = k + source;\n+\n+    losers[pos].sup = sup;\n+    losers[pos].source = source;\n+    losers[pos].keyp = &key;\n+  }\n+};\n+\n+/**\n+ * @brief Stable LoserTree implementation.\n+ *\n+ * The unstable variant is implemented using partial instantiation below.\n+ */\n+template<bool stable/* default == true */, typename T, typename Comparator>\n+class LoserTreePointer : public LoserTreePointerBase<T, Comparator>\n+{\n+  typedef LoserTreePointerBase<T, Comparator> Base;\n+  using Base::k;\n+  using Base::losers;\n \n-    void\n-    init()\n-    { losers[0] = losers[init_winner(1)]; }\n+public:\n+  LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>())\n+    : Base::LoserTreePointerBase(_k, _comp)\n+  {}\n \n-    // Do not pass const reference since key will be used as local variable.\n-    void\n-    delete_min_insert(T key, bool sup)\n-    {\n-      int source = losers[0].source;\n-      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted.\n-          if (sup || (!losers[pos].sup && comp(losers[pos].key, key)))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].key, key);\n-            }\n-        }\n-\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-      losers[0].key = key;\n-    }\n+  unsigned int\n+  init_winner(unsigned int root)\n+  {\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+        if (losers[right].sup\n+            || (!losers[left].sup && !comp(*losers[right].keyp,\n+                                          *losers[left].keyp)))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  void init()\n+  { losers[0] = losers[init_winner(1)]; }\n+\n+  void delete_min_insert(const T& key, bool sup)\n+  {\n+    const T* keyp = &key;\n+    int source = losers[0].source;\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+      {\n+        // The smaller one gets promoted, ties are broken by source.\n+        if ((sup && (!losers[pos].sup || losers[pos].source < source)) ||\n+              (!sup && !losers[pos].sup &&\n+              ((comp(*losers[pos].keyp, *keyp)) ||\n+                (!comp(*keyp, *losers[pos].keyp)\n+                && losers[pos].source < source))))\n+          {\n+            // The other one is smaller.\n+            std::swap(losers[pos].sup, sup);\n+            std::swap(losers[pos].source, source);\n+            std::swap(losers[pos].keyp, keyp);\n+          }\n+      }\n+\n+    losers[0].sup = sup;\n+    losers[0].source = source;\n+    losers[0].keyp = keyp;\n+  }\n+};\n+\n+/**\n+ * @brief Unstable LoserTree implementation.\n+ *\n+ * The stable variant is above.\n+ */\n+template<typename T, typename Comparator>\n+class LoserTreePointer</* stable == */false, T, Comparator> :\n+    public LoserTreePointerBase<T, Comparator>\n+{\n+  typedef LoserTreePointerBase<T, Comparator> Base;\n+  using Base::k;\n+  using Base::losers;\n \n-    void\n-    insert_start_stable(const T& key, int source, bool sup)\n-    { return insert_start(key, source, sup); }\n+public:\n+  LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>())\n+    : Base::LoserTreePointerBase(_k, _comp)\n+  {}\n \n-    unsigned int\n-    init_winner_stable (unsigned int root)\n-    {\n-      if (root >= k)\n-        {\n-          return root;\n-        }\n-      else\n-        {\n-          unsigned int left = init_winner (2 * root);\n-          unsigned int right = init_winner (2 * root + 1);\n-          if (losers[right].sup\n+  unsigned int\n+  init_winner(unsigned int root)\n+  {\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+        if (losers[right].sup\n               || (!losers[left].sup\n-\t\t  && !comp(losers[right].key, losers[left].key)))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n-\n-    void\n-    init_stable()\n-    { losers[0] = losers[init_winner_stable(1)]; }\n-\n-    // Do not pass const reference since key will be used as local variable.\n-    void\n-    delete_min_insert_stable(T key, bool sup)\n-    {\n-      int source = losers[0].source;\n-      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted, ties are broken by source.\n-          if (\t(sup && (!losers[pos].sup || losers[pos].source < source))\n-                || (!sup && !losers[pos].sup\n-                  && ((comp(losers[pos].key, key))\n-                    || (!comp(key, losers[pos].key)\n-                      && losers[pos].source < source))))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].key, key);\n-            }\n-        }\n-\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-      losers[0].key = key;\n-    }\n-  };\n-\n-#endif\n-\n-#if _GLIBCXX_LOSER_TREE_REFERENCE\n-\n-/** @brief Guarded loser tree, either copying the whole element into\n-* the tree structure, or looking up the element via the index.\n-*\n-*  Guarding is done explicitly through one flag sup per element,\n-*  inf is not needed due to a better initialization routine.  This\n-*  is a well-performing variant.\n-*/\n-template<typename T, typename Comparator = std::less<T> >\n-  class LoserTreeReference\n+                && !comp(*losers[right].keyp, *losers[left].keyp)))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  void init()\n+  { losers[0] = losers[init_winner(1)]; }\n+\n+  void delete_min_insert(const T& key, bool sup)\n   {\n-#undef COPY\n-#ifdef COPY\n-#define KEY(i) losers[i].key\n-#define KEY_SOURCE(i) key\n-#else\n-#define KEY(i) keys[losers[i].source]\n-#define KEY_SOURCE(i) keys[i]\n-#endif\n-  private:\n-    struct Loser\n-    {\n-      bool sup;\n-      int source;\n-#ifdef COPY\n-      T key;\n-#endif\n-    };\n+    const T* keyp = &key;\n+    int source = losers[0].source;\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+      {\n+        // The smaller one gets promoted.\n+        if (sup || (!losers[pos].sup && comp(*losers[pos].keyp, *keyp)))\n+          {\n+            // The other one is smaller.\n+            std::swap(losers[pos].sup, sup);\n+            std::swap(losers[pos].source, source);\n+            std::swap(losers[pos].keyp, keyp);\n+          }\n+      }\n+\n+    losers[0].sup = sup;\n+    losers[0].source = source;\n+    losers[0].keyp = keyp;\n+  }\n+};\n+\n+/** @brief Base class for unguarded LoserTree implementation.\n+ * \n+ * The whole element is copied into the tree structure.\n+ *\n+ * No guarding is done, therefore not a single input sequence must\n+ * run empty.  Unused sequence heads are marked with a sentinel which\n+ * is &gt; all elements that are to be merged.\n+ *\n+ * This is a very fast variant.\n+ */\n+template<typename T, typename Comparator>\n+class LoserTreeUnguardedBase\n+{\n+protected:\n+  struct Loser\n+  {\n+    int source;\n+    T key;\n+  };\n \n-    unsigned int ik, k, offset;\n-    Loser* losers;\n-#ifndef COPY\n-    T* keys;\n-#endif\n-    Comparator comp;\n+  unsigned int ik, k, offset;\n+  Loser* losers;\n+  Comparator comp;\n \n-  public:\n-    LoserTreeReference(unsigned int _k, Comparator _comp = std::less<T>())\n+public:\n+  inline\n+  LoserTreeUnguardedBase(unsigned int _k, const T _sentinel,\n+                         Comparator _comp = std::less<T>())\n     : comp(_comp)\n-    {\n-      ik = _k;\n-\n-      // Next greater power of 2.\n-      k = 1 << (log2(ik - 1) + 1);\n-      offset = k;\n-      losers = new Loser[k * 2];\n-#ifndef COPY\n-      keys = new T[ik];\n-#endif\n-      for (unsigned int i = ik - 1; i < k; ++i)\n-        losers[i + k].sup = true;\n-    }\n-\n-    ~LoserTreeReference()\n-    {\n-      delete[] losers;\n-#ifndef COPY\n-      delete[] keys;\n-#endif\n-    }\n-\n-    int\n-    get_min_source()\n-    { return losers[0].source; }\n-\n-    void\n-    insert_start(T key, int source, bool sup)\n-    {\n-      unsigned int pos = k + source;\n-\n-      losers[pos].sup = sup;\n-      losers[pos].source = source;\n-      KEY(pos) = key;\n-    }\n-\n-    unsigned int\n-    init_winner(unsigned int root)\n-    {\n-      if (root >= k)\n-        {\n-          return root;\n-        }\n-      else\n-        {\n-          unsigned int left = init_winner (2 * root);\n-          unsigned int right = init_winner (2 * root + 1);\n-          if (\tlosers[right].sup ||\n-                (!losers[left].sup && !comp(KEY(right), KEY(left))))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n-\n-    void\n-    init()\n-    {\n-      losers[0] = losers[init_winner(1)];\n-    }\n-\n-    void\n-    delete_min_insert(T key, bool sup)\n-    {\n-      int source = losers[0].source;\n-      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted.\n-          if (sup || (!losers[pos].sup && comp(KEY(pos), KEY_SOURCE(source))))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-#ifdef COPY\n-              std::swap(KEY(pos), KEY_SOURCE(source));\n-#endif\n-            }\n-        }\n-\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-#ifdef COPY\n-      KEY(0) = KEY_SOURCE(source);\n+  {\n+    ik = _k;\n+\n+    // Next greater power of 2.\n+    k = 1 << (log2(ik - 1) + 1);\n+    offset = k;\n+    // Avoid default-constructing losers[].key\n+    losers = static_cast<Loser*>(::operator new(2 * k * sizeof(Loser)));\n+\n+    for (unsigned int i = /*k + ik - 1*/0; i < (2 * k); ++i)\n+      {\n+        losers[i].key = _sentinel;\n+        losers[i].source = -1;\n+      }\n+  }\n+\n+  inline ~LoserTreeUnguardedBase()\n+  { ::operator delete(losers); }\n+\n+  inline int\n+  get_min_source()\n+  {\n+    // no dummy sequence can ever be at the top!\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n #endif\n-    }\n+    return losers[0].source;\n+  }\n \n-    void\n-    insert_start_stable(T key, int source, bool sup)\n-    { return insert_start(key, source, sup); }\n-\n-    unsigned int\n-    init_winner_stable(unsigned int root)\n-    {\n-      if (root >= k)\n-        {\n-          return root;\n-        }\n-      else\n-        {\n-          unsigned int left = init_winner (2 * root);\n-          unsigned int right = init_winner (2 * root + 1);\n-          if (losers[right].sup\n-              || (!losers[left].sup && !comp(KEY(right), KEY(left))))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n-\n-    void\n-    init_stable()\n-    { losers[0] = losers[init_winner_stable(1)]; }\n-\n-    void\n-    delete_min_insert_stable(T key, bool sup)\n-    {\n-      int source = losers[0].source;\n-      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted, ties are broken by source.\n-          if ((sup && (!losers[pos].sup || losers[pos].source < source))\n-\t      || (!sup && !losers[pos].sup\n-\t\t  && ((comp(KEY(pos), KEY_SOURCE(source)))\n-\t\t      || (!comp(KEY_SOURCE(source), KEY(pos))\n-\t\t\t  && losers[pos].source < source))))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-#ifdef COPY\n-              std::swap(KEY(pos), KEY_SOURCE(source));\n-#endif\n-            }\n-        }\n+  inline void\n+  insert_start(const T& key, int source, bool)\n+  {\n+    unsigned int pos = k + source;\n+\n+    new(&(losers[pos].key)) T(key);\n+    losers[pos].source = source;\n+  }\n+};\n+\n+/**\n+ * @brief Stable implementation of unguarded LoserTree.\n+ *\n+ * Unstable variant is selected below with partial specialization.\n+ */\n+template<bool stable/* default == true */, typename T, typename Comparator>\n+class LoserTreeUnguarded : public LoserTreeUnguardedBase<T, Comparator>\n+{\n+  typedef LoserTreeUnguardedBase<T, Comparator> Base;\n+  using Base::k;\n+  using Base::losers;\n+\n+public:\n+  LoserTreeUnguarded(unsigned int _k, const T _sentinel,\n+                     Comparator _comp = std::less<T>())\n+    : Base::LoserTreeUnguardedBase(_k, _sentinel, _comp)\n+  {}\n+\n+  unsigned int\n+  init_winner(unsigned int root)\n+  {\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+        if (!comp(losers[right].key, losers[left].key))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  inline void\n+  init()\n+  {\n+    losers[0] = losers[init_winner(1)];\n \n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-#ifdef COPY\n-      KEY(0) = KEY_SOURCE(source);\n+    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n #endif\n-    }\n-  };\n-#undef KEY\n-#undef KEY_SOURCE\n+  }\n \n+  // Do not pass a const reference since key will be used as local variable.\n+  inline void\n+  delete_min_insert(T key, bool)\n+  {\n+    // No dummy sequence can ever be at the top and be retrieved!\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n #endif\n \n-#if _GLIBCXX_LOSER_TREE_POINTER\n-\n-/** @brief Guarded loser tree, either copying the whole element into\n-    the tree structure, or looking up the element via the index.\n-*  Guarding is done explicitly through one flag sup per element,\n-*  inf is not needed due to a better initialization routine.\n-*  This is a well-performing variant.\n-*/\n-template<typename T, typename Comparator = std::less<T> >\n-  class LoserTreePointer\n+    int source = losers[0].source;\n+    printf(\"%d\\n\", source);\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+      {\n+        // The smaller one gets promoted, ties are broken by source.\n+        if (comp(losers[pos].key, key)\n+              || (!comp(key, losers[pos].key) && losers[pos].source < source))\n+          {\n+            // The other one is smaller.\n+            std::swap(losers[pos].source, source);\n+            std::swap(losers[pos].key, key);\n+          }\n+      }\n+\n+    losers[0].source = source;\n+    losers[0].key = key;\n+  }\n+};\n+\n+/**\n+ * @brief Non-Stable implementation of unguarded LoserTree.\n+ *\n+ * Stable implementation is above.\n+ */\n+template<typename T, typename Comparator>\n+class LoserTreeUnguarded</* stable == */false, T, Comparator> :\n+    public LoserTreeUnguardedBase<T, Comparator>\n+{\n+  typedef LoserTreeUnguardedBase<T, Comparator> Base;\n+  using Base::k;\n+  using Base::losers;\n+\n+public:\n+  LoserTreeUnguarded(unsigned int _k, const T _sentinel,\n+                     Comparator _comp = std::less<T>())\n+    : Base::LoserTreeUnguardedBase(_k, _sentinel, _comp)\n+  {}\n+\n+  unsigned int\n+  init_winner (unsigned int root)\n   {\n-  private:\n-    struct Loser\n-    {\n-      bool sup;\n-      int source;\n-      const T* keyp;\n-    };\n-\n-    unsigned int ik, k, offset;\n-    Loser* losers;\n-    Comparator comp;\n-\n-  public:\n-    LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>())\n-      : comp(_comp)\n-    {\n-      ik = _k;\n-\n-      // Next greater power of 2.\n-      k = 1 << (log2(ik - 1) + 1);\n-      offset = k;\n-      losers = new Loser[k * 2];\n-      for (unsigned int i = ik - 1; i < k; ++i)\n-        losers[i + k].sup = true;\n-    }\n-\n-    ~LoserTreePointer()\n-    { delete[] losers; }\n-\n-    int\n-    get_min_source()\n-    { return losers[0].source; }\n-\n-    void\n-    insert_start(const T& key, int source, bool sup)\n-    {\n-      unsigned int pos = k + source;\n-\n-      losers[pos].sup = sup;\n-      losers[pos].source = source;\n-      losers[pos].keyp = &key;\n-    }\n-\n-    unsigned int\n-    init_winner(unsigned int root)\n-    {\n-      if (root >= k)\n-\treturn root;\n-      else\n-        {\n-          unsigned int left = init_winner (2 * root);\n-          unsigned int right = init_winner (2 * root + 1);\n-          if (losers[right].sup\n-                || (!losers[left].sup\n-                  && !comp(*losers[right].keyp, *losers[left].keyp)))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n-\n-    void\n-    init()\n-    { losers[0] = losers[init_winner(1)]; }\n-\n-    void\n-    delete_min_insert(const T& key, bool sup)\n-    {\n-      const T* keyp = &key;\n-      int source = losers[0].source;\n-      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted.\n-          if (sup || (!losers[pos].sup && comp(*losers[pos].keyp, *keyp)))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].keyp, keyp);\n-            }\n-        }\n-\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-      losers[0].keyp = keyp;\n-    }\n-\n-    void\n-    insert_start_stable(const T& key, int source, bool sup)\n-    { return insert_start(key, source, sup); }\n-\n-    unsigned int\n-    init_winner_stable(unsigned int root)\n-    {\n-      if (root >= k)\n-        {\n-          return root;\n-        }\n-      else\n-        {\n-          unsigned int left = init_winner (2 * root);\n-          unsigned int right = init_winner (2 * root + 1);\n-          if (losers[right].sup\n-              || (!losers[left].sup && !comp(*losers[right].keyp,\n-                                            *losers[left].keyp)))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n-\n-    void\n-    init_stable()\n-    { losers[0] = losers[init_winner_stable(1)]; }\n-\n-    void\n-    delete_min_insert_stable(const T& key, bool sup)\n-    {\n-      const T* keyp = &key;\n-      int source = losers[0].source;\n-      for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted, ties are broken by source.\n-          if (\t(sup && (!losers[pos].sup || losers[pos].source < source))\n-\t\t|| (!sup && !losers[pos].sup &&\n-\t\t    ((comp(*losers[pos].keyp, *keyp))\n-\t\t     || (!comp(*keyp, *losers[pos].keyp)\n-\t\t\t && losers[pos].source < source))))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].sup, sup);\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].keyp, keyp);\n-            }\n-        }\n-\n-      losers[0].sup = sup;\n-      losers[0].source = source;\n-      losers[0].keyp = keyp;\n-    }\n-  };\n-\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+\n+#if _GLIBCXX_ASSERTIONS\n+        // If left one is sentinel then right one must be, too.\n+        if (losers[left].source == -1)\n+          _GLIBCXX_PARALLEL_ASSERT(losers[right].source == -1);\n #endif\n \n-#if _GLIBCXX_LOSER_TREE_UNGUARDED\n-\n-/** @brief Unguarded loser tree, copying the whole element into the\n-* tree structure.\n-*\n-*  No guarding is done, therefore not a single input sequence must\n-*  run empty.  This is a very fast variant.\n-*/\n-template<typename T, typename Comparator = std::less<T> >\n-  class LoserTreeUnguarded\n+        if (!comp(losers[right].key, losers[left].key))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  inline void\n+  init()\n   {\n-  private:\n-    struct Loser\n-    {\n-      int source;\n-      T key;\n-    };\n-\n-    unsigned int ik, k, offset;\n-    unsigned int* mapping;\n-    Loser* losers;\n-    Comparator comp;\n-\n-    void\n-    map(unsigned int root, unsigned int begin, unsigned int end)\n-    {\n-      if (begin + 1 == end)\n-        mapping[begin] = root;\n-      else\n-        {\n-          // Next greater or equal power of 2.\n-          unsigned int left = 1 << (log2(end - begin - 1));\n-          map(root * 2, begin, begin + left);\n-          map(root * 2 + 1, begin + left, end);\n-        }\n-    }\n-\n-  public:\n-    LoserTreeUnguarded(unsigned int _k, Comparator _comp = std::less<T>())\n-    : comp(_comp)\n-    {\n-      ik = _k;\n-      // Next greater or equal power of 2.\n-      k = 1 << (log2(ik - 1) + 1);\n-      offset = k;\n-      losers = new Loser[k + ik];\n-      mapping = new unsigned int[ik];\n-      map(1, 0, ik);\n-    }\n-\n-    ~LoserTreeUnguarded()\n-    {\n-      delete[] losers;\n-      delete[] mapping;\n-    }\n-\n-    int\n-    get_min_source()\n-    { return losers[0].source; }\n-\n-    void\n-    insert_start(const T& key, int source, bool)\n-    {\n-      unsigned int pos = mapping[source];\n-      losers[pos].source = source;\n-      losers[pos].key = key;\n-    }\n-\n-    unsigned int\n-    init_winner(unsigned int root, unsigned int begin, unsigned int end)\n-    {\n-      if (begin + 1 == end)\n-        return mapping[begin];\n-      else\n-        {\n-          // Next greater or equal power of 2.\n-          unsigned int division = 1 << (log2(end - begin - 1));\n-          unsigned int left = init_winner(2 * root, begin, begin + division);\n-          unsigned int right =\n-                          init_winner(2 * root + 1, begin + division, end);\n-          if (!comp(losers[right].key, losers[left].key))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n-\n-    void\n-    init()\n-    { losers[0] = losers[init_winner(1, 0, ik)]; }\n-\n-    // Do not pass const reference since key will be used as local variable.\n-    void\n-    delete_min_insert(const T& key, bool)\n-    {\n-      losers[0].key = key;\n-      T& keyr = losers[0].key;\n-      int& source = losers[0].source;\n-      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted.\n-          if (comp(losers[pos].key, keyr))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].key, keyr);\n-            }\n-        }\n-    }\n-\n-    void\n-    insert_start_stable(const T& key, int source, bool)\n-    { return insert_start(key, source, false); }\n-\n-    void\n-    init_stable()\n-    { init(); }\n-\n-    void\n-    delete_min_insert_stable(const T& key, bool)\n-    {\n-      losers[0].key = key;\n-      T& keyr = losers[0].key;\n-      int& source = losers[0].source;\n-      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted, ties are broken by source.\n-          if (comp(losers[pos].key, keyr)\n-              || (!comp(keyr, losers[pos].key)\n-                && losers[pos].source < source))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].key, keyr);\n-            }\n-        }\n-    }\n-  };\n+    losers[0] = losers[init_winner(1)];\n \n+    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n #endif\n+  }\n \n-#if _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n+  // Do not pass a const reference since key will be used as local variable.\n+  inline void\n+  delete_min_insert(T key, bool)\n+  {\n+    printf(\"wrong\\n\");\n+    int source = losers[0].source;\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+      {\n+        // The smaller one gets promoted.\n+        if (comp(losers[pos].key, key))\n+          {\n+            // The other one is smaller.\n+            std::swap(losers[pos].source, source);\n+            std::swap(losers[pos].key, key);\n+          }\n+      }\n+\n+    losers[0].source = source;\n+    losers[0].key = key;\n+  }\n+};\n \n /** @brief Unguarded loser tree, keeping only pointers to the\n * elements in the tree structure.\n *\n *  No guarding is done, therefore not a single input sequence must\n *  run empty.  This is a very fast variant.\n */\n-template<typename T, typename Comparator = std::less<T> >\n-  class LoserTreePointerUnguarded\n+template<typename T, typename Comparator>\n+class LoserTreePointerUnguardedBase\n+{\n+protected:\n+  struct Loser\n   {\n-  private:\n-    struct Loser\n-    {\n-      int source;\n-      const T* keyp;\n-    };\n-\n-    unsigned int ik, k, offset;\n-    unsigned int* mapping;\n-    Loser* losers;\n-    Comparator comp;\n-\n-    void map(unsigned int root, unsigned int begin, unsigned int end)\n-    {\n-      if (begin + 1 == end)\n-        mapping[begin] = root;\n-      else\n-        {\n-          // Next greater or equal power of 2.\n-          unsigned int left = 1 << (log2(end - begin - 1));\n-          map(root * 2, begin, begin + left);\n-          map(root * 2 + 1, begin + left, end);\n-        }\n-    }\n-\n-  public:\n-    LoserTreePointerUnguarded(unsigned int _k,\n-                              Comparator _comp = std::less<T>())\n-    : comp(_comp)\n-    {\n-      ik = _k;\n-\n-      // Next greater power of 2.\n-      k = 1 << (log2(ik - 1) + 1);\n-      offset = k;\n-      losers = new Loser[k + ik];\n-      mapping = new unsigned int[ik];\n-      map(1, 0, ik);\n-    }\n-\n-    ~LoserTreePointerUnguarded()\n-    {\n-      delete[] losers;\n-      delete[] mapping;\n-    }\n-\n-    int\n-    get_min_source()\n-    { return losers[0].source; }\n-\n-    void\n-    insert_start(const T& key, int source, bool)\n-    {\n-      unsigned int pos = mapping[source];\n-      losers[pos].source = source;\n-      losers[pos].keyp = &key;\n-    }\n-\n-    unsigned int\n-    init_winner(unsigned int root, unsigned int begin, unsigned int end)\n-    {\n-      if (begin + 1 == end)\n-        return mapping[begin];\n-      else\n-        {\n-          // Next greater or equal power of 2.\n-          unsigned int division = 1 << (log2(end - begin - 1));\n-          unsigned int left = init_winner(2 * root, begin, begin + division);\n-          unsigned int right = init_winner(2 * root + 1,\n-\t\t\t\t\t   begin + division, end);\n-          if (!comp(*losers[right].keyp, *losers[left].keyp))\n-            {\n-              // Left one is less or equal.\n-              losers[root] = losers[right];\n-              return left;\n-            }\n-          else\n-            {\n-              // Right one is less.\n-              losers[root] = losers[left];\n-              return right;\n-            }\n-        }\n-    }\n+    int source;\n+    const T* keyp;\n+  };\n \n-    void\n-    init()\n-    { losers[0] = losers[init_winner(1, 0, ik)]; }\n+  unsigned int ik, k, offset;\n+  Loser* losers;\n+  const T sentinel;\n+  Comparator comp;\n \n-    void\n-    delete_min_insert(const T& key, bool)\n-    {\n-      const T* keyp = &key;\n-      int& source = losers[0].source;\n-      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted.\n-          if (comp(*losers[pos].keyp, *keyp))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].keyp, keyp);\n-            }\n-        }\n-\n-      losers[0].keyp = keyp;\n-    }\n+public:\n \n-    void\n-    insert_start_stable(const T& key, int source, bool)\n-    { return insert_start(key, source, false); }\n+  inline\n+  LoserTreePointerUnguardedBase(unsigned int _k, const T _sentinel,\n+      Comparator _comp = std::less<T>())\n+    : sentinel(_sentinel), comp(_comp)\n+  {\n+    ik = _k;\n+\n+    // Next greater power of 2.\n+    k = 1 << (log2(ik - 1) + 1);\n+    offset = k;\n+    // Avoid default-constructing losers[].key\n+    losers = new Loser[2 * k];\n+\n+    for (unsigned int i = /*k + ik - 1*/0; i < (2 * k); ++i)\n+      {\n+        losers[i].keyp = &sentinel;\n+        losers[i].source = -1;\n+      }\n+  }\n+\n+  inline ~LoserTreePointerUnguardedBase()\n+  { delete[] losers; }\n+\n+  inline int\n+  get_min_source()\n+  {\n+    // no dummy sequence can ever be at the top!\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+#endif\n+    return losers[0].source;\n+  }\n \n-    void\n-    init_stable()\n-    { init(); }\n+  inline void\n+  insert_start(const T& key, int source, bool)\n+  {\n+    unsigned int pos = k + source;\n+\n+    losers[pos].keyp = &key;\n+    losers[pos].source = source;\n+  }\n+};\n+\n+/**\n+ * @brief Stable unguarded LoserTree variant storing pointers.\n+ *\n+ * Unstable variant is implemented below using partial specialization.\n+ */\n+template<bool stable/* default == true */, typename T, typename Comparator>\n+class LoserTreePointerUnguarded :\n+    public LoserTreePointerUnguardedBase<T, Comparator>\n+{\n+  typedef LoserTreePointerUnguardedBase<T, Comparator> Base;\n+  using Base::k;\n+  using Base::losers;\n+\n+public:\n+  LoserTreePointerUnguarded(unsigned int _k, const T _sentinel,\n+      Comparator _comp = std::less<T>())\n+    : Base::LoserTreePointerUnguardedBase(_k, _sentinel, _comp)\n+  {}\n+\n+  unsigned int\n+  init_winner(unsigned int root)\n+  {\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+        if (!comp(*losers[right].keyp, *losers[left].keyp))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  inline void\n+  init()\n+  {\n+    losers[0] = losers[init_winner(1)];\n \n-    void\n-    delete_min_insert_stable(const T& key, bool)\n-    {\n-      int& source = losers[0].source;\n-      const T* keyp = &key;\n-      for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-        {\n-          // The smaller one gets promoted, ties are broken by source.\n-          if (comp(*losers[pos].keyp, *keyp)\n-              || (!comp(*keyp, *losers[pos].keyp)\n-                  && losers[pos].source < source))\n-            {\n-              // The other one is smaller.\n-              std::swap(losers[pos].source, source);\n-              std::swap(losers[pos].keyp, keyp);\n-            }\n-        }\n-      losers[0].keyp = keyp;\n-    }\n-  };\n+    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n #endif\n+  }\n \n-template<typename _ValueTp, class Comparator>\n-  struct loser_tree_traits\n+  inline void\n+  delete_min_insert(const T& key, bool sup)\n   {\n-#if _GLIBCXX_LOSER_TREE\n-    typedef LoserTree<_ValueTp, Comparator> LT;\n-#else\n-#  if _GLIBCXX_LOSER_TREE_POINTER\n-    typedef LoserTreePointer<_ValueTp, Comparator> LT;\n-#  else\n-#    error Must define some type in losertree.h.\n-#  endif\n+    const T* keyp = &key;\n+    int source = losers[0].source;\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+      {\n+        // The smaller one gets promoted, ties are broken by source.\n+        if (comp(*losers[pos].keyp, *keyp)\n+          || (!comp(*keyp, *losers[pos].keyp) && losers[pos].source < source))\n+          {\n+            // The other one is smaller.\n+            std::swap(losers[pos].source, source);\n+            std::swap(losers[pos].keyp, keyp);\n+          }\n+      }\n+\n+    losers[0].source = source;\n+    losers[0].keyp = keyp;\n+\n+    // no dummy sequence can ever be at the top!\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+#endif\n+  }\n+};\n+\n+/**\n+ * @brief Unstable unguarded LoserTree variant storing pointers.\n+ *\n+ * Stable variant is above.\n+ */\n+template<typename T, typename Comparator>\n+class LoserTreePointerUnguarded</* stable == */false, T, Comparator> :\n+    public LoserTreePointerUnguardedBase<T, Comparator>\n+{\n+  typedef LoserTreePointerUnguardedBase<T, Comparator> Base;\n+  using Base::k;\n+  using Base::losers;\n+\n+public:\n+  LoserTreePointerUnguarded(unsigned int _k, const T _sentinel,\n+      Comparator _comp = std::less<T>())\n+    : Base::LoserTreePointerUnguardedBase(_k, _sentinel, _comp)\n+  {}\n+\n+  unsigned int\n+  init_winner(unsigned int root)\n+  {\n+    if (root >= k)\n+      {\n+        return root;\n+      }\n+    else\n+      {\n+        unsigned int left = init_winner (2 * root);\n+        unsigned int right = init_winner (2 * root + 1);\n+\n+#if _GLIBCXX_ASSERTIONS\n+        // If left one is sentinel then right one must be, too.\n+        if (losers[left].source == -1)\n+          _GLIBCXX_PARALLEL_ASSERT(losers[right].source == -1);\n #endif\n-  };\n \n-template<typename _ValueTp, class Comparator>\n-  struct loser_tree_unguarded_traits\n+        if (!comp(*losers[right].keyp, *losers[left].keyp))\n+          {\n+            // Left one is less or equal.\n+            losers[root] = losers[right];\n+            return left;\n+          }\n+        else\n+          {\n+            // Right one is less.\n+            losers[root] = losers[left];\n+            return right;\n+          }\n+      }\n+  }\n+\n+  inline void\n+  init()\n   {\n-#if _GLIBCXX_LOSER_TREE_UNGUARDED\n-    typedef LoserTreeUnguarded<_ValueTp, Comparator> LT;\n-#else\n-#  if _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n-    typedef LoserTreePointerUnguarded<_ValueTp, Comparator> LT;\n-#  else\n-#    error Must define some unguarded type in losertree.h.\n-#  endif\n+    losers[0] = losers[init_winner(1)];\n+\n+    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n+#if _GLIBCXX_ASSERTIONS\n+    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n #endif\n-  };\n+  }\n \n-}\n+  inline void\n+  delete_min_insert(const T& key, bool sup)\n+  {\n+    const T* keyp = &key;\n+    int source = losers[0].source;\n+    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+      {\n+        // The smaller one gets promoted.\n+        if (comp(*(losers[pos].keyp), *keyp))\n+          {\n+            // The other one is smaller.\n+            std::swap(losers[pos].source, source);\n+            std::swap(losers[pos].keyp, keyp);\n+          }\n+      }\n+\n+    losers[0].source = source;\n+    losers[0].keyp = keyp;\n+  }\n+};\n+\n+} // namespace __gnu_parallel\n \n #endif"}, {"sha": "6e0f2e382c3cd81041117daeaeaa47f5dd5cfc5b", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -239,19 +239,26 @@ namespace __gnu_parallel\n \t\t\t   std::iterator_traits<RandomAccessIterator1>::\n \t\t\t   difference_type max_length, Comparator comp)\n     {\n-      typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n-\tvalue_type;\n+      typedef typename\n+          std::iterator_traits<RandomAccessIterator1>::value_type value_type;\n       typedef typename std::iterator_traits<RandomAccessIterator1>::\n \tdifference_type difference_type1 /* == difference_type2 */;\n       typedef typename std::iterator_traits<RandomAccessIterator3>::\n \tdifference_type difference_type3;\n+      typedef typename std::pair<RandomAccessIterator1, RandomAccessIterator1>\n+        iterator_pair;\n \n       std::pair<RandomAccessIterator1, RandomAccessIterator1>\n \tseqs[2] = { std::make_pair(begin1, end1),\n \t\t    std::make_pair(begin2, end2) };\n-      RandomAccessIterator3 \n-\ttarget_end = parallel_multiway_merge(seqs, seqs + 2, target,\n-\t\t\t\t\t     comp, max_length, true, false);\n+      RandomAccessIterator3\n+        target_end = parallel_multiway_merge\n+          < /* stable = */ true, /* sentinels = */ false>(\n+            seqs, seqs + 2, target, comp,\n+            multiway_merge_exact_splitting\n+              < /* stable = */ true, iterator_pair*,\n+                Comparator, difference_type1>,\n+            max_length);\n \n       return target_end;\n     }"}, {"sha": "40a2f1bc6af55533c5601a2ff3e4b9cc4000f5d4", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 1297, "deletions": 1124, "changes": 2421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -40,7 +40,7 @@\n *  This file is a GNU parallel extension to the Standard C++ Library.\n */\n \n-// Written by Johannes Singler.\n+// Written by Johannes Singler and Manuel Holtgrewe.\n \n #ifndef _GLIBCXX_PARALLEL_MULTIWAY_MERGE_H\n #define _GLIBCXX_PARALLEL_MULTIWAY_MERGE_H\n@@ -50,7 +50,6 @@\n #include <bits/stl_algo.h>\n #include <parallel/features.h>\n #include <parallel/parallel.h>\n-#include <parallel/merge.h>\n #include <parallel/losertree.h>\n #if _GLIBCXX_ASSERTIONS\n #include <parallel/checkers.h>\n@@ -59,27 +58,34 @@\n /** @brief Length of a sequence described by a pair of iterators. */\n #define _GLIBCXX_PARALLEL_LENGTH(s) ((s).second - (s).first)\n \n-// XXX need iterator typedefs\n namespace __gnu_parallel\n {\n+\n+// Announce guarded and unguarded iterator.\n+\n template<typename RandomAccessIterator, typename Comparator>\n   class guarded_iterator;\n \n+// Making the arguments const references seems to dangerous,\n+// the user-defined comparator might not be const.\n template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-            guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+             guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+              guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n-  /** @brief Iterator wrapper supporting an implicit supremum at the end\n-      of the sequence, dominating all comparisons.\n-      *  Deriving from RandomAccessIterator is not possible since\n-      *  RandomAccessIterator need not be a class.\n-      */\n+/** @brief Iterator wrapper supporting an implicit supremum at the end\n+ *         of the sequence, dominating all comparisons.\n+ *\n+ * The implicit supremum comes with a performance cost.\n+ *\n+ * Deriving from RandomAccessIterator is not possible since\n+ * RandomAccessIterator need not be a class.\n+ */\n template<typename RandomAccessIterator, typename Comparator>\n   class guarded_iterator\n   {\n@@ -100,7 +106,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     *  @param comp Comparator provided for associated overloaded\n     *  compare operators. */\n     guarded_iterator(RandomAccessIterator begin,\n-\t\t     RandomAccessIterator end, Comparator& comp)\n+                     RandomAccessIterator end, Comparator& comp)\n     : current(begin), end(end), comp(comp)\n     { }\n \n@@ -115,7 +121,7 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     /** @brief Dereference operator.\n     *  @return Referenced element. */\n-    typename std::iterator_traits<RandomAccessIterator>::value_type\n+    typename std::iterator_traits<RandomAccessIterator>::value_type&\n     operator*()\n     { return *current; }\n \n@@ -158,7 +164,7 @@ template<typename RandomAccessIterator, typename Comparator>\n template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+               guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n   {\n     if (bi2.current == bi2.end)\t//bi1 is sup\n       return bi1.current != bi1.end;\t//bi2 is not sup\n@@ -185,7 +191,7 @@ template<typename RandomAccessIterator, typename Comparator>\n   {\n   private:\n     /** @brief Current iterator position. */\n-    RandomAccessIterator& current;\n+    RandomAccessIterator current;\n     /** @brief Comparator. */\n     mutable Comparator& comp;\n \n@@ -195,7 +201,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     *  @param end Unused, only for compatibility.\n     *  @param comp Unused, only for compatibility. */\n     unguarded_iterator(RandomAccessIterator begin,\n-\t\t       RandomAccessIterator end, Comparator& comp)\n+                       RandomAccessIterator end, Comparator& comp)\n     : current(begin), comp(comp)\n     { }\n \n@@ -210,7 +216,7 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     /** @brief Dereference operator.\n     *  @return Referenced element. */\n-    typename std::iterator_traits<RandomAccessIterator>::value_type\n+    typename std::iterator_traits<RandomAccessIterator>::value_type&\n     operator*()\n     { return *current; }\n \n@@ -256,159 +262,41 @@ template<typename RandomAccessIterator, typename Comparator>\n     return !(bi1.comp)(*bi2, *bi1);\n   }\n \n-/** Prepare a set of sequences to be merged without a (end) guard\n- *  @param seqs_begin\n- *  @param seqs_end\n- *  @param comp\n- *  @param min_sequence\n- *  @param stable\n- *  @pre (seqs_end - seqs_begin > 0) */\n-template<typename RandomAccessIteratorIterator, typename Comparator>\n-  typename std::iterator_traits<\n-      typename std::iterator_traits<RandomAccessIteratorIterator>::value_type\n-      ::first_type>::difference_type\n-  prepare_unguarded(RandomAccessIteratorIterator seqs_begin,\n-                    RandomAccessIteratorIterator seqs_end, Comparator comp,\n-                    int& min_sequence, bool stable)\n-  {\n-    _GLIBCXX_CALL(seqs_end - seqs_begin)\n-\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n-        ::value_type::first_type\n-      RandomAccessIterator1;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n-      value_type;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>\n-      ::difference_type\n-      difference_type;\n-\n-    if ((*seqs_begin).first == (*seqs_begin).second)\n-      {\n-        // Empty sequence found, it's the first one.\n-        min_sequence = 0;\n-        return -1;\n-      }\n-\n-    // Last element in sequence.\n-    value_type min = *((*seqs_begin).second - 1);\n-    min_sequence = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin + 1; s != seqs_end; ++s)\n-      {\n-        if ((*s).first == (*s).second)\n-          {\n-            // Empty sequence found.\n-            min_sequence = static_cast<int>(s - seqs_begin);\n-            return -1;\n-          }\n-\n-        // Last element in sequence.\n-        const value_type& v = *((*s).second - 1);\n-        if (comp(v, min))\t//strictly smaller\n-          {\n-            min = v;\n-            min_sequence = static_cast<int>(s - seqs_begin);\n-          }\n-      }\n-\n-    difference_type overhang_size = 0;\n-\n-    int s = 0;\n-    for (s = 0; s <= min_sequence; ++s)\n-      {\n-        RandomAccessIterator1 split;\n-        if (stable)\n-          split = std::upper_bound(seqs_begin[s].first, seqs_begin[s].second,\n-                                  min, comp);\n-        else\n-          split = std::lower_bound(seqs_begin[s].first, seqs_begin[s].second,\n-                                  min, comp);\n-\n-        overhang_size += seqs_begin[s].second - split;\n-      }\n-\n-    for (; s < (seqs_end - seqs_begin); ++s)\n-      {\n-        RandomAccessIterator1 split = std::lower_bound(\n-            seqs_begin[s].first, seqs_begin[s].second, min, comp);\n-        overhang_size += seqs_begin[s].second - split;\n-      }\n-\n-    // So many elements will be left over afterwards.\n-    return overhang_size;\n-  }\n-\n-/** Prepare a set of sequences to be merged with a (end) guard (sentinel)\n- *  @param seqs_begin\n- *  @param seqs_end\n- *  @param comp */\n-template<typename RandomAccessIteratorIterator, typename Comparator>\n-  typename std::iterator_traits<typename std::iterator_traits<\n-      RandomAccessIteratorIterator>::value_type::first_type>::difference_type\n-  prepare_unguarded_sentinel(RandomAccessIteratorIterator seqs_begin,\n-                            RandomAccessIteratorIterator seqs_end,\n-                            Comparator comp)\n-  {\n-    _GLIBCXX_CALL(seqs_end - seqs_begin)\n-\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n-      ::value_type::first_type\n-      RandomAccessIterator1;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>\n-      ::value_type\n-      value_type;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>\n-      ::difference_type\n-      difference_type;\n-\n-    // Last element in sequence.\n-    value_type* max = NULL;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      {\n-        if ((*s).first == (*s).second)\n-          continue;\n-\n-        // Last element in sequence.\n-        value_type& v = *((*s).second - 1);\n-\n-        // Strictly greater.\n-        if (!max || comp(*max, v))\n-          max = &v;\n-      }\n-\n-    difference_type overhang_size = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      {\n-        RandomAccessIterator1 split =\n-            std::lower_bound((*s).first, (*s).second, *max, comp);\n-        overhang_size += (*s).second - split;\n-\n-        // Set sentinel.\n-        *((*s).second) = *max;\n-      }\n-\n-    // So many elements will be left over afterwards.\n-    return overhang_size;\n-  }\n-\n /** @brief Highly efficient 3-way merging procedure.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *  @param stable Unused, stable anyway.\n- *  @return End iterator of output sequence. */\n+ *\n+ * Merging is done with the algorithm implementation described by Peter\n+ * Sanders.  Basically, the idea is to minimize the number of necessary\n+ * comparison after merging out an element.  The implementation trick\n+ * that makes this fast is that the order of the sequences is stored\n+ * in the instruction pointer (translated into labels in C++).\n+ *\n+ * This works well for merging up to 4 sequences.\n+ *\n+ * Note that making the merging stable does <em>not</em> come at a\n+ * performance hit.\n+ *\n+ * Whether the merging is done guarded or unguarded is selected by the\n+ * used iterator class.\n+ *\n+ * @param seqs_begin Begin iterator of iterator pair input sequence.\n+ * @param seqs_end End iterator of iterator pair input sequence.\n+ * @param target Begin iterator out output sequence.\n+ * @param comp Comparator.\n+ * @param length Maximum length to merge.\n+ *\n+ * @return End iterator of output sequence.\n+ */\n template<template<typename RAI, typename C> class iterator,\n \t typename RandomAccessIteratorIterator,\n \t typename RandomAccessIterator3,\n \t typename _DifferenceTp,\n \t typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_3_variant(RandomAccessIteratorIterator seqs_begin,\n-\t\t\t   RandomAccessIteratorIterator seqs_end,\n-\t\t\t   RandomAccessIterator3 target,\n-\t\t\t   Comparator comp, _DifferenceTp length,\n-\t\t\t   bool stable)\n+  multiway_merge_3_variant(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length)\n   {\n     _GLIBCXX_CALL(length);\n \n@@ -423,6 +311,10 @@ template<template<typename RAI, typename C> class iterator,\n     if (length == 0)\n       return target;\n \n+#if _GLIBCXX_ASSERTIONS\n+    _DifferenceTp orig_length = length;\n+#endif\n+\n     iterator<RandomAccessIterator1, Comparator>\n       seq0(seqs_begin[0].first, seqs_begin[0].second, comp),\n       seq1(seqs_begin[1].first, seqs_begin[1].second, comp),\n@@ -450,17 +342,16 @@ template<template<typename RAI, typename C> class iterator,\n         else\n           goto s210;\n       }\n-\n-#define _GLIBCXX_PARALLEL_MERGE_3_CASE(a,b,c,c0,c1)\\\n+#define _GLIBCXX_PARALLEL_MERGE_3_CASE(a,b,c,c0,c1)     \\\n     s ## a ## b ## c :                                  \\\n       *target = *seq ## a;                              \\\n-    ++target;                                           \\\n-    --length;                                           \\\n-    ++seq ## a;                                         \\\n-    if (length == 0) goto finish;                       \\\n-    if (seq ## a c0 seq ## b) goto s ## a ## b ## c;    \\\n-    if (seq ## a c1 seq ## c) goto s ## b ## a ## c;    \\\n-    goto s ## b ## c ## a;\n+      ++target;                                         \\\n+      --length;                                         \\\n+      ++seq ## a;                                       \\\n+      if (length == 0) goto finish;                     \\\n+      if (seq ## a c0 seq ## b) goto s ## a ## b ## c;  \\\n+      if (seq ## a c1 seq ## c) goto s ## b ## a ## c;  \\\n+      goto s ## b ## c ## a;\n \n     _GLIBCXX_PARALLEL_MERGE_3_CASE(0, 1, 2, <=, <=);\n     _GLIBCXX_PARALLEL_MERGE_3_CASE(1, 2, 0, <=, < );\n@@ -474,102 +365,46 @@ template<template<typename RAI, typename C> class iterator,\n   finish:\n     ;\n \n+#if _GLIBCXX_ASSERTIONS\n+  _GLIBCXX_PARALLEL_ASSERT(\n+      ((RandomAccessIterator1)seq0 - seqs_begin[0].first) +\n+      ((RandomAccessIterator1)seq1 - seqs_begin[1].first) +\n+      ((RandomAccessIterator1)seq2 - seqs_begin[2].first)\n+      == orig_length);\n+#endif\n+\n     seqs_begin[0].first = seq0;\n     seqs_begin[1].first = seq1;\n     seqs_begin[2].first = seq2;\n \n     return target;\n   }\n \n-template<typename RandomAccessIteratorIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n-  RandomAccessIterator3\n-  multiway_merge_3_combined(RandomAccessIteratorIterator seqs_begin,\n-                            RandomAccessIteratorIterator seqs_end,\n-                            RandomAccessIterator3 target,\n-                            Comparator comp,\n-                            _DifferenceTp length, bool stable)\n-  {\n-    _GLIBCXX_CALL(length);\n-\n-    typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n-      ::value_type::first_type\n-      RandomAccessIterator1;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n-      value_type;\n-\n-    int min_seq;\n-    RandomAccessIterator3 target_end;\n-\n-    // Stable anyway.\n-    difference_type overhang =\n-        prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n-\n-    difference_type total_length = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n-\n-    if (overhang != -1)\n-      {\n-        difference_type unguarded_length =\n-            std::min(length, total_length - overhang);\n-        target_end = multiway_merge_3_variant<unguarded_iterator>\n-          (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n-        overhang = length - unguarded_length;\n-      }\n-    else\n-      {\n-        // Empty sequence found.\n-        overhang = length;\n-        target_end = target;\n-      }\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n-\n-    switch (min_seq)\n-      {\n-      case 0:\n-        // Iterators will be advanced accordingly.\n-        target_end = merge_advance(seqs_begin[1].first, seqs_begin[1].second,\n-                                  seqs_begin[2].first, seqs_begin[2].second,\n-                                  target_end, overhang, comp);\n-        break;\n-      case 1:\n-        target_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n-                                  seqs_begin[2].first, seqs_begin[2].second,\n-                                  target_end, overhang, comp);\n-        break;\n-      case 2:\n-        target_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n-                                  seqs_begin[1].first, seqs_begin[1].second,\n-                                  target_end, overhang, comp);\n-        break;\n-      default:\n-        _GLIBCXX_PARALLEL_ASSERT(false);\n-      }\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n-\n-    return target_end;\n-  }\n-\n-/** @brief Highly efficient 4-way merging procedure.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *  @param stable Unused, stable anyway.\n- *  @return End iterator of output sequence. */\n+/**\n+ * @brief Highly efficient 4-way merging procedure.\n+ *\n+ * Merging is done with the algorithm implementation described by Peter\n+ * Sanders. Basically, the idea is to minimize the number of necessary\n+ * comparison after merging out an element.  The implementation trick\n+ * that makes this fast is that the order of the sequences is stored\n+ * in the instruction pointer (translated into goto labels in C++).\n+ *\n+ * This works well for merging up to 4 sequences.\n+ *\n+ * Note that making the merging stable does <em>not</em> come at a\n+ * performance hit.\n+ *\n+ * Whether the merging is done guarded or unguarded is selected by the\n+ * used iterator class.\n+ *\n+ * @param seqs_begin Begin iterator of iterator pair input sequence.\n+ * @param seqs_end End iterator of iterator pair input sequence.\n+ * @param target Begin iterator out output sequence.\n+ * @param comp Comparator.\n+ * @param length Maximum length to merge.\n+ *\n+ * @return End iterator of output sequence.\n+ */\n template<template<typename RAI, typename C> class iterator,\n \t typename RandomAccessIteratorIterator,\n \t typename RandomAccessIterator3,\n@@ -579,7 +414,7 @@ template<template<typename RAI, typename C> class iterator,\n   multiway_merge_4_variant(RandomAccessIteratorIterator seqs_begin,\n                            RandomAccessIteratorIterator seqs_end,\n                            RandomAccessIterator3 target,\n-                           Comparator comp, _DifferenceTp length, bool stable)\n+                           Comparator comp, _DifferenceTp length)\n   {\n     _GLIBCXX_CALL(length);\n     typedef _DifferenceTp difference_type;\n@@ -676,651 +511,467 @@ template<template<typename RAI, typename C> class iterator,\n     return target;\n   }\n \n-template<typename RandomAccessIteratorIterator,\n+/** @brief Multi-way merging procedure for a high branching factor,\n+ *         guarded case.\n+ *\n+ * This merging variant uses a LoserTree class as selected by <tt>LT</tt>.\n+ *\n+ * Stability is selected through the used LoserTree class <tt>LT</tt>.\n+ *\n+ * @param seqs_begin Begin iterator of iterator pair input sequence.\n+ * @param seqs_end End iterator of iterator pair input sequence.\n+ * @param target Begin iterator out output sequence.\n+ * @param comp Comparator.\n+ * @param length Maximum length to merge.\n+ *\n+ * @return End iterator of output sequence.\n+ */\n+template<typename LT,\n+\t typename RandomAccessIteratorIterator,\n \t typename RandomAccessIterator3,\n \t typename _DifferenceTp,\n \t typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_4_combined(RandomAccessIteratorIterator seqs_begin,\n+  multiway_merge_loser_tree(RandomAccessIteratorIterator seqs_begin,\n                             RandomAccessIteratorIterator seqs_end,\n                             RandomAccessIterator3 target,\n                             Comparator comp,\n-                            _DifferenceTp length, bool stable)\n+                            _DifferenceTp length)\n   {\n-    _GLIBCXX_CALL(length);\n-    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(length)\n \n+    typedef _DifferenceTp difference_type;\n     typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n       ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n-    int min_seq;\n-    RandomAccessIterator3 target_end;\n+    int k = static_cast<int>(seqs_end - seqs_begin);\n \n-    // Stable anyway.\n-    difference_type overhang =\n-        prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n+    LT lt(k, comp);\n \n     difference_type total_length = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n \n-    if (overhang != -1)\n+    // Default value for potentially non-default-constructible types.\n+    value_type* arbitrary_element = NULL;\n+\n+    for (int t = 0; t < k; ++t)\n       {\n-        difference_type unguarded_length =\n-            std::min(length, total_length - overhang);\n-        target_end = multiway_merge_4_variant<unguarded_iterator>\n-          (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n-        overhang = length - unguarded_length;\n+        if(arbitrary_element == NULL\n+\t   && _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]) > 0)\n+          arbitrary_element = &(*seqs_begin[t].first);\n+        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n       }\n-    else\n+\n+    if(total_length == 0)\n+      return target;\n+\n+    for (int t = 0; t < k; ++t)\n       {\n-        // Empty sequence found.\n-        overhang = length;\n-        target_end = target;\n+        if (seqs_begin[t].first == seqs_begin[t].second)\n+          lt.insert_start(*arbitrary_element, t, true);\n+        else\n+          lt.insert_start(*seqs_begin[t].first, t, false);\n       }\n \n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n+    lt.init();\n \n-    std::vector<std::pair<RandomAccessIterator1, RandomAccessIterator1> >\n-        one_missing(seqs_begin, seqs_end);\n-    one_missing.erase(one_missing.begin() + min_seq);\t//remove\n+    const difference_type const_total_length(std::min(total_length, length));\n \n-    target_end = multiway_merge_3_variant<guarded_iterator>(\n-        one_missing.begin(), one_missing.end(),\n-        target_end, comp, overhang, stable);\n+    int source;\n \n-    // Insert back again.\n-    one_missing.insert(one_missing.begin() + min_seq, seqs_begin[min_seq]);\n-    // Write back modified iterators.\n-    copy(one_missing.begin(), one_missing.end(), seqs_begin);\n+    for (difference_type i = 0; i < const_total_length; ++i)\n+      {\n+        //take out\n+        source = lt.get_min_source();\n \n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n+        *(target++) = *(seqs_begin[source].first++);\n \n-    return target_end;\n+        // Feed.\n+        if (seqs_begin[source].first == seqs_begin[source].second)\n+          lt.delete_min_insert(*arbitrary_element, true);\n+        else\n+          // Replace from same source.\n+          lt.delete_min_insert(*seqs_begin[source].first, false);\n+      }\n+\n+    return target;\n   }\n \n-/** @brief Basic multi-way merging procedure.\n+/** @brief Multi-way merging procedure for a high branching factor,\n+ *         unguarded case.\n  *\n- *  The head elements are kept in a sorted array, new heads are\n- *  inserted linearly.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *  @param stable Stable merging incurs a performance penalty.\n- *  @return End iterator of output sequence.\n+ * Merging is done using the LoserTree class <tt>LT</tt>.\n+ *\n+ * Stability is selected by the used LoserTrees.\n+ *\n+ * @pre No input will run out of elements during the merge.\n+ *\n+ * @param seqs_begin Begin iterator of iterator pair input sequence.\n+ * @param seqs_end End iterator of iterator pair input sequence.\n+ * @param target Begin iterator out output sequence.\n+ * @param comp Comparator.\n+ * @param length Maximum length to merge.\n+ *\n+ * @return End iterator of output sequence.\n  */\n-template<typename RandomAccessIteratorIterator,\n+template<typename LT,\n+\t typename RandomAccessIteratorIterator,\n \t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n+\t typename _DifferenceTp, typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_bubble(RandomAccessIteratorIterator seqs_begin,\n-                        RandomAccessIteratorIterator seqs_end,\n-                        RandomAccessIterator3 target,\n-                        Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_loser_tree_unguarded(RandomAccessIteratorIterator seqs_begin,\n+                                      RandomAccessIteratorIterator seqs_end,\n+                                      RandomAccessIterator3 target,\n+                                      int min_seq, Comparator comp,\n+                                      _DifferenceTp length)\n   {\n     _GLIBCXX_CALL(length)\n-\n     typedef _DifferenceTp difference_type;\n+\n     typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n       ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n-    int k = static_cast<int>(seqs_end - seqs_begin);\n-    int nrs;  // Number of remaining sequences.\n+    int k = seqs_end - seqs_begin;\n+\n+    // Determine the sentinel.  The sentinel is largest/last element of the\n+    // sequences with the smallest largest/last element.\n+    value_type sentinel = *(seqs_begin[min_seq].second - 1);\n+\n+    LT lt(k, sentinel, comp);\n \n-    // Avoid default constructor.\n-    value_type* fe = static_cast<value_type*>(\n-      ::operator new(sizeof(value_type) * k));  // Front elements.\n-    int* source = new int[k];\n     difference_type total_length = 0;\n \n-    // Write entries into queue.\n-    nrs = 0;\n-    for (int pi = 0; pi < k; ++pi)\n+    for (int t = 0; t < k; ++t)\n       {\n-        if (seqs_begin[pi].first != seqs_begin[pi].second)\n-          {\n-            ::new(&(fe[nrs])) value_type(*(seqs_begin[pi].first));\n-            source[nrs] = pi;\n-            ++nrs;\n-            total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[pi]);\n-          }\n-      }\n+#if _GLIBCXX_ASSERTIONS\n+        _GLIBCXX_PARALLEL_ASSERT(seqs_begin[t].first != seqs_begin[t].second);\n+#endif\n+        lt.insert_start(*seqs_begin[t].first, t, false);\n \n-    if (stable)\n-      {\n-        // Bubble sort fe and source by fe.\n-        for (int k = 0; k < nrs - 1; ++k)\n-          for (int pi = nrs - 1; pi > k; --pi)\n-            if (comp(fe[pi], fe[pi - 1]) ||\n-                (!comp(fe[pi - 1], fe[pi]) && source[pi] < source[pi - 1]))\n-              {\n-                std::swap(fe[pi - 1], fe[pi]);\n-                std::swap(source[pi - 1], source[pi]);\n-              }\n-      }\n-    else\n-      {\n-        for (int k = 0; k < nrs - 1; ++k)\n-          for (int pi = nrs - 1; pi > k; --pi)\n-            if (comp(fe[pi], fe[pi-1]))\n-              {\n-                std::swap(fe[pi-1], fe[pi]);\n-                std::swap(source[pi-1], source[pi]);\n-              }\n+        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n       }\n \n-    // Iterate.\n-    if (stable)\n-      {\n-        int j;\n-        while (nrs > 0 && length > 0)\n-          {\n-            if (source[0] < source[1])\n-              {\n-                // fe[0] <= fe[1]\n-                while ((nrs == 1 || !comp(fe[1], fe[0])) && length > 0)\n-                  {\n-                    *target = fe[0];\n-                    ++target;\n-                    ++(seqs_begin[source[0]].first);\n-                    --length;\n-                    if (seqs_begin[source[0]].first\n-\t\t\t== seqs_begin[source[0]].second)\n-                      {\n-                        // Move everything to the left.\n-                        for (int s = 0; s < nrs - 1; ++s)\n-                          {\n-                            fe[s] = fe[s + 1];\n-                            source[s] = source[s + 1];\n-                          }\n-                        fe[nrs - 1].~value_type();  //Destruct explicitly.\n-                        --nrs;\n-                        break;\n-                      }\n-                    else\n-                      fe[0] = *(seqs_begin[source[0]].first);\n-                  }\n-              }\n-            else\n-              {\n-                // fe[0] < fe[1]\n-                while ((nrs == 1 || comp(fe[0], fe[1])) && length > 0)\n-                  {\n-                    *target = fe[0];\n-                    ++target;\n-                    ++(seqs_begin[source[0]].first);\n-                    --length;\n-                    if (seqs_begin[source[0]].first\n-\t\t\t== seqs_begin[source[0]].second)\n-                      {\n-                        for (int s = 0; s < nrs - 1; ++s)\n-                          {\n-                            fe[s] = fe[s + 1];\n-                            source[s] = source[s + 1];\n-                          }\n-                        fe[nrs - 1].~value_type();  //Destruct explicitly.\n-                        --nrs;\n-                        break;\n-                      }\n-                    else\n-                      fe[0] = *(seqs_begin[source[0]].first);\n-                  }\n-              }\n-\n-            // Sink down.\n-            j = 1;\n-            while ((j < nrs) && (comp(fe[j], fe[j - 1])\n-\t\t\t\t || (!comp(fe[j - 1], fe[j])\n-\t\t\t\t     && (source[j] < source[j - 1]))))\n-              {\n-                std::swap(fe[j - 1], fe[j]);\n-                std::swap(source[j - 1], source[j]);\n-                ++j;\n-              }\n-          }\n-      }\n-    else\n+    lt.init();\n+\n+    // Do not go past end.\n+    length = std::min(total_length, length);\n+\n+    int source;\n+\n+#if _GLIBCXX_ASSERTIONS\n+    difference_type i = 0;\n+#endif\n+\n+    RandomAccessIterator3 target_end = target + length;\n+    while (target < target_end)\n       {\n-        int j;\n-        while (nrs > 0 && length > 0)\n-          {\n-            // fe[0] <= fe[1]\n-            while (nrs == 1 || (!comp(fe[1], fe[0])) && length > 0)\n-              {\n-                *target = fe[0];\n-                ++target;\n-                ++seqs_begin[source[0]].first;\n-                --length;\n-                if (seqs_begin[source[0]].first\n-\t\t    == seqs_begin[source[0]].second)\n-                  {\n-                    for (int s = 0; s < (nrs - 1); ++s)\n-                      {\n-                        fe[s] = fe[s + 1];\n-                        source[s] = source[s + 1];\n-                      }\n-                    fe[nrs - 1].~value_type();  //Destruct explicitly.\n-                    --nrs;\n-                    break;\n-                  }\n-                else\n-                  fe[0] = *(seqs_begin[source[0]].first);\n-              }\n-\n-            // Sink down.\n-            j = 1;\n-            while ((j < nrs) && comp(fe[j], fe[j - 1]))\n-              {\n-                std::swap(fe[j - 1], fe[j]);\n-                std::swap(source[j - 1], source[j]);\n-                ++j;\n-              }\n-          }\n-      }\n+        // Take out.\n+        source = lt.get_min_source();\n \n-    ::operator delete(fe);  //Destructors already called.\n-    delete[] source;\n+#if _GLIBCXX_ASSERTIONS\n+        _GLIBCXX_PARALLEL_ASSERT(0 <= source && source < k);\n+        _GLIBCXX_PARALLEL_ASSERT(i == 0\n+            || !comp(*(seqs_begin[source].first), *(target - 1)));\n+#endif\n \n-    return target;\n-  }\n+        // Feed.\n+        *(target++) = *(seqs_begin[source].first++);\n \n-/** @brief Multi-way merging procedure for a high branching factor,\n- * guarded case.\n- *\n- *  The head elements are kept in a loser tree.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *   @param stable Stable merging incurs a performance penalty.\n- *  @return End iterator of output sequence.\n- */\n-template<typename LT,\n-\t typename RandomAccessIteratorIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n-  RandomAccessIterator3\n-  multiway_merge_loser_tree(RandomAccessIteratorIterator seqs_begin,\n-                            RandomAccessIteratorIterator seqs_end,\n-                            RandomAccessIterator3 target,\n-                            Comparator comp,\n-                            _DifferenceTp length, bool stable)\n-  {\n-    _GLIBCXX_CALL(length)\n-\n-    typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n-      ::value_type::first_type\n-      RandomAccessIterator1;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n-      value_type;\n-\n-    int k = static_cast<int>(seqs_end - seqs_begin);\n-\n-    LT lt(k, comp);\n-\n-    difference_type total_length = 0;\n-\n-    // Default value for potentially non-default-constructible types.\n-    value_type* arbitrary_element = NULL;\n-\n-    for (int t = 0; t < k; ++t)\n-      {\n-        if(arbitrary_element == NULL\n-\t   && _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]) > 0)\n-          arbitrary_element = &(*seqs_begin[t].first);\n-        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n-      }\n-\n-    if(total_length == 0)\n-      return target;\n-\n-    for (int t = 0; t < k; ++t)\n-      {\n-        if (stable)\n-          {\n-            if (seqs_begin[t].first == seqs_begin[t].second)\n-              lt.insert_start_stable(*arbitrary_element, t, true);\n-            else\n-              lt.insert_start_stable(*seqs_begin[t].first, t, false);\n-          }\n-        else\n-          {\n-            if (seqs_begin[t].first == seqs_begin[t].second)\n-              lt.insert_start(*arbitrary_element, t, true);\n-            else\n-              lt.insert_start(*seqs_begin[t].first, t, false);\n-          }\n-      }\n-\n-    if (stable)\n-      lt.init_stable();\n-    else\n-      lt.init();\n-\n-    total_length = std::min(total_length, length);\n-\n-    int source;\n-\n-    if (stable)\n-      {\n-        for (difference_type i = 0; i < total_length; ++i)\n-          {\n-            // Take out.\n-            source = lt.get_min_source();\n-\n-            *(target++) = *(seqs_begin[source].first++);\n-\n-            // Feed.\n-            if (seqs_begin[source].first == seqs_begin[source].second)\n-              lt.delete_min_insert_stable(*arbitrary_element, true);\n-            else\n-              // Replace from same source.\n-              lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n-\n-          }\n-      }\n-    else\n-      {\n-        for (difference_type i = 0; i < total_length; ++i)\n-          {\n-            //take out\n-            source = lt.get_min_source();\n-\n-            *(target++) = *(seqs_begin[source].first++);\n-\n-            // Feed.\n-            if (seqs_begin[source].first == seqs_begin[source].second)\n-              lt.delete_min_insert(*arbitrary_element, true);\n-            else\n-              // Replace from same source.\n-              lt.delete_min_insert(*seqs_begin[source].first, false);\n-          }\n+#if _GLIBCXX_ASSERTIONS\n+        _GLIBCXX_PARALLEL_ASSERT(\n+            (seqs_begin[source].first != seqs_begin[source].second)\n+            || (i >= length - 1));\n+        ++i;\n+#endif\n+        // Replace from same source.\n+        lt.delete_min_insert(*seqs_begin[source].first, false);\n       }\n \n     return target;\n   }\n \n+\n /** @brief Multi-way merging procedure for a high branching factor,\n- * unguarded case.\n+ *         requiring sentinels to exist.\n+ * @param stable The value must the same as for the used LoserTrees.\n+ * @param UnguardedLoserTree Loser Tree variant to use for the unguarded\n+ *   merging.\n+ * @param GuardedLoserTree Loser Tree variant to use for the guarded\n+ *   merging.\n  *\n- *  The head elements are kept in a loser tree.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *  @param stable Stable merging incurs a performance penalty.\n- *  @return End iterator of output sequence.\n- *  @pre No input will run out of elements during the merge.\n+ * @param seqs_begin Begin iterator of iterator pair input sequence.\n+ * @param seqs_end End iterator of iterator pair input sequence.\n+ * @param target Begin iterator out output sequence.\n+ * @param comp Comparator.\n+ * @param length Maximum length to merge.\n+ *\n+ * @return End iterator of output sequence.\n  */\n-template<typename LT,\n-\t typename RandomAccessIteratorIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp, typename Comparator>\n+template<\n+    typename UnguardedLoserTree,\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_loser_tree_unguarded(RandomAccessIteratorIterator seqs_begin,\n-                                      RandomAccessIteratorIterator seqs_end,\n-                                      RandomAccessIterator3 target,\n-                                      Comparator comp,\n-                                      _DifferenceTp length, bool stable)\n+  multiway_merge_loser_tree_sentinel(RandomAccessIteratorIterator seqs_begin,\n+                                     RandomAccessIteratorIterator seqs_end,\n+                                     RandomAccessIterator3 target,\n+                                     Comparator comp,\n+                                     _DifferenceTp length)\n   {\n     _GLIBCXX_CALL(length)\n-    typedef _DifferenceTp difference_type;\n \n+    typedef _DifferenceTp difference_type;\n+    typedef std::iterator_traits<RandomAccessIteratorIterator> traits_type;\n     typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n       ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n-    int k = seqs_end - seqs_begin;\n-\n-    LT lt(k, comp);\n+    RandomAccessIterator3 target_end;\n \n     difference_type total_length = 0;\n-\n-    for (int t = 0; t < k; ++t)\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n       {\n-#if _GLIBCXX_ASSERTIONS\n-        _GLIBCXX_PARALLEL_ASSERT(seqs_begin[t].first != seqs_begin[t].second);\n-#endif\n-        if (stable)\n-          lt.insert_start_stable(*seqs_begin[t].first, t, false);\n-        else\n-          lt.insert_start(*seqs_begin[t].first, t, false);\n+        total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n \n-        total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n+        // Move the sequends end behind the sentinel spots.  This has the\n+        // effect that the sentinel appears to be within the sequence. Then,\n+        // we can use the unguarded variant if we merge out as many\n+        // non-sentinel elements as we have.\n+        ++((*s).second);\n       }\n \n-    if (stable)\n-      lt.init_stable();\n-    else\n-      lt.init();\n-\n-    // Do not go past end.\n-    length = std::min(total_length, length);\n-\n-    int source;\n-\n-#if _GLIBCXX_ASSERTIONS\n-    difference_type i = 0;\n-#endif\n-\n-    if (stable)\n-      {\n-        RandomAccessIterator3 target_end = target + length;\n-        while (target < target_end)\n-          {\n-            // Take out.\n-            source = lt.get_min_source();\n-\n-#if _GLIBCXX_ASSERTIONS\n-            _GLIBCXX_PARALLEL_ASSERT(i == 0\n-                || !comp(*(seqs_begin[source].first), *(target - 1)));\n-#endif\n-\n-            *(target++) = *(seqs_begin[source].first++);\n+    difference_type unguarded_length =\n+         std::min(length, total_length);\n+    target_end = multiway_merge_loser_tree_unguarded\n+        <UnguardedLoserTree>\n+      (seqs_begin, seqs_end, target, 0, comp, unguarded_length);\n \n #if _GLIBCXX_ASSERTIONS\n-            _GLIBCXX_PARALLEL_ASSERT(\n-                (seqs_begin[source].first != seqs_begin[source].second)\n-                || (i == length - 1));\n-            ++i;\n+    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n+    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n #endif\n-            // Feed.\n-            // Replace from same source.\n-            lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n \n-          }\n-      }\n-    else\n-      {\n-        RandomAccessIterator3 target_end = target + length;\n-        while (target < target_end)\n-          {\n-            // Take out.\n-            source = lt.get_min_source();\n+    // Restore the sequence ends so the sentinels are not contained in the\n+    // sequence any more (see comment in loop above).\n+    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n+      { --((*s).second); }\n \n-#if _GLIBCXX_ASSERTIONS\n-            if (i > 0 && comp(*(seqs_begin[source].first), *(target - 1)))\n-              printf(\"         %i %i %i\\n\", length, i, source);\n-            _GLIBCXX_PARALLEL_ASSERT(i == 0\n-                || !comp(*(seqs_begin[source].first), *(target - 1)));\n-#endif\n+    return target_end;\n+  }\n \n-            *(target++) = *(seqs_begin[source].first++);\n+/**\n+ * @brief Traits for determining whether the loser tree should\n+ *   use pointers or copies.\n+ *\n+ * The field \"use_pointer\" is used to determine whether to use pointers in\n+ * the loser trees or whether to copy the values into the loser tree.\n+ *\n+ * The default behavior is to use pointers if the data type is 4 times as\n+ * big as the pointer to it.\n+ *\n+ * Specialize for your data type to customize the behavior.\n+ *\n+ * Example:\n+ *\n+ *   template<>\n+ *   struct loser_tree_traits<int>\n+ *   { static const bool use_pointer = false; };\n+ *\n+ *   template<>\n+ *   struct loser_tree_traits<heavyweight_type>\n+ *   { static const bool use_pointer = true; };\n+ *\n+ * @param T type to give the loser tree traits for.\n+ */\n+template <typename T>\n+struct loser_tree_traits\n+{\n+  /**\n+   * @brief True iff to use pointers instead of values in loser trees.\n+   *\n+   * The default behavior is to use pointers if the data type is four\n+   * times as big as the pointer to it.\n+   */\n+  static const bool use_pointer = (sizeof(T) > 4 * sizeof(T*));\n+};\n \n-#if _GLIBCXX_ASSERTIONS\n-            if (!((seqs_begin[source].first != seqs_begin[source].second)\n-                || (i >= length - 1)))\n-              printf(\"         %i %i %i\\n\", length, i, source);\n-            _GLIBCXX_PARALLEL_ASSERT(\n-                (seqs_begin[source].first != seqs_begin[source].second)\n-                || (i >= length - 1));\n-            ++i;\n-#endif\n-            // Feed.\n-            // Replace from same source.\n-            lt.delete_min_insert(*seqs_begin[source].first, false);\n-          }\n-      }\n+/**\n+ * @brief Switch for 3-way merging with sentinels turned off.\n+ *\n+ * Note that 3-way merging is always stable!\n+ */\n+template<\n+  bool sentinels /*default == false*/,\n+  typename RandomAccessIteratorIterator,\n+  typename RandomAccessIterator3,\n+  typename _DifferenceTp,\n+  typename Comparator>\n+struct multiway_merge_3_variant_sentinel_switch\n+{\n+  RandomAccessIterator3 operator()(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length)\n+  {\n+    return multiway_merge_3_variant<guarded_iterator>(\n+        seqs_begin, seqs_end, target, comp, length);\n+  }\n+};\n \n-    return target;\n+/**\n+ * @brief Switch for 3-way merging with sentinels turned on.\n+ *\n+ * Note that 3-way merging is always stable!\n+ */\n+template<\n+  typename RandomAccessIteratorIterator,\n+  typename RandomAccessIterator3,\n+  typename _DifferenceTp,\n+  typename Comparator>\n+struct multiway_merge_3_variant_sentinel_switch\n+    <true, RandomAccessIteratorIterator, RandomAccessIterator3,\n+     _DifferenceTp, Comparator>\n+{\n+  RandomAccessIterator3 operator()(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length)\n+  {\n+    return multiway_merge_3_variant<unguarded_iterator>(\n+        seqs_begin, seqs_end, target, comp, length);\n   }\n+};\n \n-template<typename RandomAccessIteratorIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n-  RandomAccessIterator3\n-  multiway_merge_loser_tree_combined(RandomAccessIteratorIterator seqs_begin,\n-                                     RandomAccessIteratorIterator seqs_end,\n-                                     RandomAccessIterator3 target,\n-                                     Comparator comp,\n-                                     _DifferenceTp length, bool stable)\n+/**\n+ * @brief Switch for 4-way merging with sentinels turned off.\n+ *\n+ * Note that 4-way merging is always stable!\n+ */\n+template<\n+  bool sentinels /*default == false*/,\n+  typename RandomAccessIteratorIterator,\n+  typename RandomAccessIterator3,\n+  typename _DifferenceTp,\n+  typename Comparator>\n+struct multiway_merge_4_variant_sentinel_switch\n+{\n+  RandomAccessIterator3 operator()(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length)\n   {\n-    _GLIBCXX_CALL(length)\n+    return multiway_merge_4_variant<guarded_iterator>(\n+        seqs_begin, seqs_end, target, comp, length);\n+  }\n+};\n \n-    typedef _DifferenceTp difference_type;\n+/**\n+ * @brief Switch for 4-way merging with sentinels turned on.\n+ *\n+ * Note that 4-way merging is always stable!\n+ */\n+template<\n+  typename RandomAccessIteratorIterator,\n+  typename RandomAccessIterator3,\n+  typename _DifferenceTp,\n+  typename Comparator>\n+struct multiway_merge_4_variant_sentinel_switch\n+    <true, RandomAccessIteratorIterator, RandomAccessIterator3,\n+     _DifferenceTp, Comparator>\n+{\n+  RandomAccessIterator3 operator()(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length)\n+  {\n+    return multiway_merge_4_variant<unguarded_iterator>(\n+        seqs_begin, seqs_end, target, comp, length);\n+  }\n+};\n \n+/**\n+ * @brief Switch for k-way merging with sentinels turned on.\n+ */\n+template<\n+  bool sentinels,\n+  bool stable,\n+  typename RandomAccessIteratorIterator,\n+  typename RandomAccessIterator3,\n+  typename _DifferenceTp,\n+  typename Comparator>\n+struct multiway_merge_k_variant_sentinel_switch\n+{\n+  RandomAccessIterator3 operator()(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length)\n+  {\n     typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n       ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n-    int min_seq;\n-    RandomAccessIterator3 target_end;\n-    difference_type overhang = prepare_unguarded(seqs_begin, seqs_end,\n-                                          comp, min_seq, stable);\n-\n-    difference_type total_length = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n-\n-    if (overhang != -1)\n-      {\n-        difference_type unguarded_length =\n-            std::min(length, total_length - overhang);\n-        target_end = multiway_merge_loser_tree_unguarded\n-          <typename loser_tree_unguarded_traits<value_type, Comparator>::LT>\n-          (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n-        overhang = length - unguarded_length;\n-      }\n-    else\n-      {\n-        // Empty sequence found.\n-        overhang = length;\n-        target_end = target;\n-      }\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n-\n-    target_end = multiway_merge_loser_tree\n-      <typename loser_tree_traits<value_type, Comparator>::LT>\n-      (seqs_begin, seqs_end, target_end, comp, overhang, stable);\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n-\n-    return target_end;\n+    return multiway_merge_loser_tree_sentinel<\n+        typename __gnu_cxx::__conditional_type<\n+            loser_tree_traits<value_type>::use_pointer\n+          , LoserTreePointerUnguarded<stable, value_type, Comparator>\n+          , LoserTreeUnguarded<stable, value_type, Comparator>\n+        >::__type>(seqs_begin, seqs_end, target, comp, length);\n   }\n+};\n \n-template<typename RandomAccessIteratorIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n-  RandomAccessIterator3\n-  multiway_merge_loser_tree_sentinel(RandomAccessIteratorIterator seqs_begin,\n-                                     RandomAccessIteratorIterator seqs_end,\n-\t\t\t\t     RandomAccessIterator3 target,\n-\t\t\t\t     Comparator comp,\n-\t\t\t\t     _DifferenceTp length, bool stable)\n+/**\n+ * @brief Switch for k-way merging with sentinels turned off.\n+ */\n+template<\n+  bool stable,\n+  typename RandomAccessIteratorIterator,\n+  typename RandomAccessIterator3,\n+  typename _DifferenceTp,\n+  typename Comparator>\n+struct multiway_merge_k_variant_sentinel_switch\n+    <false, stable, RandomAccessIteratorIterator, RandomAccessIterator3,\n+     _DifferenceTp, Comparator>\n+{\n+  RandomAccessIterator3 operator()(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length)\n   {\n-    _GLIBCXX_CALL(length)\n-\n-    typedef _DifferenceTp difference_type;\n-    typedef std::iterator_traits<RandomAccessIteratorIterator> traits_type;\n     typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n       ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n-    RandomAccessIterator3 target_end;\n-    difference_type overhang =\n-        prepare_unguarded_sentinel(seqs_begin, seqs_end, comp);\n-\n-    difference_type total_length = 0;\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      {\n-        total_length += _GLIBCXX_PARALLEL_LENGTH(*s);\n-\n-        // Sentinel spot.\n-        ++((*s).second);\n-      }\n-\n-    difference_type unguarded_length =\n-        std::min(length, total_length - overhang);\n-    target_end = multiway_merge_loser_tree_unguarded\n-      <typename loser_tree_unguarded_traits<value_type, Comparator>::LT>\n-      (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n-    overhang = length - unguarded_length;\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n-\n-    // Copy rest stable.\n-    for (RandomAccessIteratorIterator s = seqs_begin;\n-         s != seqs_end && overhang > 0; ++s)\n-      {\n-        // Restore.\n-        --((*s).second);\n-        difference_type local_length =\n-            std::min<difference_type>(overhang, _GLIBCXX_PARALLEL_LENGTH(*s));\n-        target_end = std::copy((*s).first, (*s).first + local_length,\n-                               target_end);\n-        (*s).first += local_length;\n-        overhang -= local_length;\n-      }\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(overhang == 0);\n-    _GLIBCXX_PARALLEL_ASSERT(target_end == target + length);\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n-#endif\n-\n-    return target_end;\n+    return multiway_merge_loser_tree<\n+        typename __gnu_cxx::__conditional_type<\n+            loser_tree_traits<value_type>::use_pointer\n+          , LoserTreePointer<stable, value_type, Comparator>\n+          , LoserTree<stable, value_type, Comparator>\n+        >::__type >(seqs_begin, seqs_end, target, comp, length);\n   }\n+};\n \n /** @brief Sequential multi-way merging switch.\n  *\n- *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor and\n+ *  The _GLIBCXX_PARALLEL_DECISION is based on the branching factor and\n  *  runtime settings.\n  *  @param seqs_begin Begin iterator of iterator pair input sequence.\n  *  @param seqs_end End iterator of iterator pair input sequence.\n@@ -1330,17 +981,18 @@ template<typename RandomAccessIteratorIterator,\n  *  @param stable Stable merging incurs a performance penalty.\n  *  @param sentinel The sequences have a sentinel element.\n  *  @return End iterator of output sequence. */\n-template<typename RandomAccessIteratorIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n+template<\n+    bool stable,\n+    bool sentinels,\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge(RandomAccessIteratorIterator seqs_begin,\n+  sequential_multiway_merge(RandomAccessIteratorIterator seqs_begin,\n                  RandomAccessIteratorIterator seqs_end,\n                  RandomAccessIterator3 target,\n-                 Comparator comp, _DifferenceTp length,\n-                 bool stable, bool sentinel,\n-                 sequential_tag)\n+                 Comparator comp, _DifferenceTp length)\n   {\n     _GLIBCXX_CALL(length)\n \n@@ -1353,17 +1005,14 @@ template<typename RandomAccessIteratorIterator,\n \n #if _GLIBCXX_ASSERTIONS\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n-      _GLIBCXX_PARALLEL_ASSERT(is_sorted((*s).first, (*s).second, comp));\n+      {\n+        _GLIBCXX_PARALLEL_ASSERT(is_sorted((*s).first, (*s).second, comp));\n+      }\n #endif\n \n-    RandomAccessIterator3 return_target = target;\n+      RandomAccessIterator3 return_target = target;\n     int k = static_cast<int>(seqs_end - seqs_begin);\n \n-    _MultiwayMergeAlgorithm mwma = _Settings::get().multiway_merge_algorithm;\n-\n-    if (!sentinel && mwma == LOSER_TREE_SENTINEL)\n-      mwma = LOSER_TREE_COMBINED;\n-\n     switch (k)\n       {\n       case 0:\n@@ -1382,113 +1031,30 @@ template<typename RandomAccessIteratorIterator,\n                                       target, length, comp);\n         break;\n       case 3:\n-        switch (mwma)\n-          {\n-          case LOSER_TREE_COMBINED:\n-            return_target = multiway_merge_3_combined(seqs_begin,\n-\t\t\t\t\t\t      seqs_end,\n-\t\t\t\t\t\t      target,\n-\t\t\t\t\t\t      comp, length,\n-\t\t\t\t\t\t      stable);\n-            break;\n-          case LOSER_TREE_SENTINEL:\n-            return_target =\n-\t      multiway_merge_3_variant<unguarded_iterator>(seqs_begin,\n-\t\t\t\t\t\t\t   seqs_end,\n-\t\t\t\t\t\t\t   target,\n-\t\t\t\t\t\t\t   comp, length,\n-\t\t\t\t\t\t\t   stable);\n-            break;\n-          default:\n-            return_target = \n-\t      multiway_merge_3_variant<guarded_iterator>(seqs_begin,\n-\t\t\t\t\t\t\t seqs_end,\n-\t\t\t\t\t\t\t target,\n-\t\t\t\t\t\t\t comp, length,\n-\t\t\t\t\t\t\t stable);\n-            break;\n-          }\n+        return_target = multiway_merge_3_variant_sentinel_switch<\n+            sentinels\n+          , RandomAccessIteratorIterator\n+          , RandomAccessIterator3\n+          , _DifferenceTp\n+          , Comparator>()(seqs_begin, seqs_end, target, comp, length);\n         break;\n       case 4:\n-        switch (mwma)\n-          {\n-          case LOSER_TREE_COMBINED:\n-            return_target = multiway_merge_4_combined(seqs_begin,\n-\t\t\t\t\t\t      seqs_end,\n-\t\t\t\t\t\t      target,\n-\t\t\t\t\t\t      comp, length, stable);\n-            break;\n-          case LOSER_TREE_SENTINEL:\n-            return_target = \n-\t      multiway_merge_4_variant<unguarded_iterator>(seqs_begin,\n-\t\t\t\t\t\t\t   seqs_end,\n-\t\t\t\t\t\t\t   target,\n-\t\t\t\t\t\t\t   comp, length,\n-\t\t\t\t\t\t\t   stable);\n-            break;\n-          default:\n-            return_target = multiway_merge_4_variant<guarded_iterator>(\n-\t      seqs_begin,\n-\t      seqs_end,\n-\t      target,\n-\t      comp, length, stable);\n-            break;\n-          }\n+        return_target = multiway_merge_4_variant_sentinel_switch<\n+            sentinels\n+          , RandomAccessIteratorIterator\n+          , RandomAccessIterator3\n+          , _DifferenceTp\n+          , Comparator>()(seqs_begin, seqs_end, target, comp, length);\n         break;\n       default:\n-        {\n-          switch (mwma)\n-            {\n-            case BUBBLE:\n-              return_target = multiway_merge_bubble(seqs_begin,\n-\t\t\t\t\t\t    seqs_end,\n-\t\t\t\t\t\t    target,\n-\t\t\t\t\t\t    comp, length, stable);\n-              break;\n-#if _GLIBCXX_LOSER_TREE_EXPLICIT\n-            case LOSER_TREE_EXPLICIT:\n-              return_target = multiway_merge_loser_tree<\n-\t      LoserTreeExplicit<value_type, Comparator> >(seqs_begin,\n-\t\t\t\t\t\t\t  seqs_end,\n-\t\t\t\t\t\t\t  target,\n-\t\t\t\t\t\t\t  comp, length,\n-\t\t\t\t\t\t\t  stable);\n-              break;\n-#endif\n-#if _GLIBCXX_LOSER_TREE\n-            case LOSER_TREE:\n-              return_target = multiway_merge_loser_tree<\n-                    LoserTree<value_type, Comparator> >(seqs_begin,\n-\t\t\t\t\t\t\tseqs_end,\n-\t\t\t\t\t\t\ttarget,\n-\t\t\t\t\t\t\tcomp, length,\n-\t\t\t\t\t\t\tstable);\n-              break;\n-#endif\n-#if _GLIBCXX_LOSER_TREE_COMBINED\n-            case LOSER_TREE_COMBINED:\n-              return_target = multiway_merge_loser_tree_combined(seqs_begin,\n-\t\t\t\t\t\t\t\t seqs_end,\n-\t\t\t\t\t\t\t\t target,\n-\t\t\t\t\t\t\t\t comp, length,\n-\t\t\t\t\t\t\t\t stable);\n-              break;\n-#endif\n-#if _GLIBCXX_LOSER_TREE_SENTINEL\n-            case LOSER_TREE_SENTINEL:\n-              return_target = multiway_merge_loser_tree_sentinel(seqs_begin,\n-\t\t\t\t\t\t\t\t seqs_end,\n-\t\t\t\t\t\t\t\t target,\n-\t\t\t\t\t\t\t\t comp, length,\n-\t\t\t\t\t\t\t\t stable);\n-              break;\n-#endif\n-            default:\n-              // multiway_merge algorithm not implemented.\n-              _GLIBCXX_PARALLEL_ASSERT(0);\n-              break;\n-            }\n-        }\n+          return_target = multiway_merge_k_variant_sentinel_switch<\n+              sentinels\n+            , stable\n+            , RandomAccessIteratorIterator\n+            , RandomAccessIterator3\n+            , _DifferenceTp\n+            , Comparator>()(seqs_begin, seqs_end, target, comp, length);\n+          break;\n       }\n #if _GLIBCXX_ASSERTIONS\n     _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n@@ -1497,38 +1063,246 @@ template<typename RandomAccessIteratorIterator,\n     return return_target;\n   }\n \n+/**\n+ * @brief Stable sorting functor.\n+ *\n+ * Used to reduce code instanciation in multiway_merge_sampling_splitting.\n+ */\n+template<bool stable, class RandomAccessIterator, class StrictWeakOrdering>\n+struct sampling_sorter\n+{\n+  void operator()(RandomAccessIterator first, RandomAccessIterator last,\n+                  StrictWeakOrdering comp)\n+  { __gnu_sequential::stable_sort(first, last, comp); }\n+};\n+\n+/**\n+ * @brief Non-stable sorting functor.\n+ *\n+ * Used to reduce code instanciation in multiway_merge_sampling_splitting.\n+ */\n+template<class RandomAccessIterator, class StrictWeakOrdering>\n+struct sampling_sorter<false, RandomAccessIterator, StrictWeakOrdering>\n+{\n+  void operator()(RandomAccessIterator first, RandomAccessIterator last,\n+                  StrictWeakOrdering comp)\n+  { __gnu_sequential::sort(first, last, comp); }\n+};\n+\n+/**\n+ * @brief Sampling based splitting for parallel multiway-merge routine.\n+ */\n+template<\n+    bool stable\n+  , typename RandomAccessIteratorIterator\n+  , typename Comparator\n+  , typename difference_type>\n+void multiway_merge_sampling_splitting(\n+    RandomAccessIteratorIterator seqs_begin,\n+    RandomAccessIteratorIterator seqs_end,\n+    Comparator comp, difference_type length,\n+    difference_type total_length,\n+    std::vector<std::pair<difference_type, difference_type> > *pieces)\n+{\n+  typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+    ::value_type::first_type\n+    RandomAccessIterator1;\n+  typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+    value_type;\n+\n+  // k sequences.\n+  int k = static_cast<int>(seqs_end - seqs_begin);\n+\n+  int num_threads = omp_get_num_threads();\n+\n+  difference_type num_samples =\n+      __gnu_parallel::_Settings::get().merge_oversampling * num_threads;\n+\n+  value_type* samples = static_cast<value_type*>(\n+    ::operator new(sizeof(value_type) * k * num_samples));\n+  // Sample.\n+  for (int s = 0; s < k; ++s)\n+    for (difference_type i = 0; i < num_samples; ++i)\n+      {\n+        difference_type sample_index =\n+            static_cast<difference_type>(\n+                _GLIBCXX_PARALLEL_LENGTH(seqs_begin[s]) * (double(i + 1) /\n+                (num_samples + 1)) * (double(length)\n+                / total_length));\n+        new(&(samples[s * num_samples + i])) value_type(\n+            seqs_begin[s].first[sample_index]);\n+      }\n+\n+  // Sort stable or non-stable, depending on value of template parameter\n+  // \"stable\".\n+  sampling_sorter<stable, value_type*, Comparator>()(\n+      samples, samples + (num_samples * k), comp);\n+\n+  for (int slab = 0; slab < num_threads; ++slab)\n+    // For each slab / processor.\n+    for (int seq = 0; seq < k; ++seq)\n+      {\n+        // For each sequence.\n+        if (slab > 0)\n+          pieces[slab][seq].first =\n+              std::upper_bound(\n+                seqs_begin[seq].first,\n+                seqs_begin[seq].second,\n+                samples[num_samples * k * slab / num_threads],\n+                  comp)\n+              - seqs_begin[seq].first;\n+        else\n+          {\n+            // Absolute beginning.\n+            pieces[slab][seq].first = 0;\n+          }\n+        if ((slab + 1) < num_threads)\n+          pieces[slab][seq].second =\n+              std::upper_bound(\n+                  seqs_begin[seq].first,\n+                  seqs_begin[seq].second,\n+                  samples[num_samples * k * (slab + 1) /\n+                      num_threads], comp)\n+              - seqs_begin[seq].first;\n+        else\n+        pieces[slab][seq].second = _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n+      }\n+    ::operator delete(samples);\n+}\n+\n+/**\n+ * @brief Exact splitting for parallel multiway-merge routine.\n+ */\n+template<\n+    bool stable\n+  , typename RandomAccessIteratorIterator\n+  , typename Comparator\n+  , typename difference_type>\n+void multiway_merge_exact_splitting(\n+    RandomAccessIteratorIterator seqs_begin,\n+    RandomAccessIteratorIterator seqs_end,\n+    Comparator comp,\n+    difference_type length,\n+    difference_type total_length,\n+    std::vector<std::pair<difference_type, difference_type> > *pieces)\n+{\n+  typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+    ::value_type::first_type\n+    RandomAccessIterator1;\n+\n+  const bool tight = (total_length == length);\n+\n+  // k sequences.\n+  const int k = static_cast<int>(seqs_end - seqs_begin);\n+\n+  const int num_threads = omp_get_num_threads();\n+\n+  // (Settings::multiway_merge_splitting == __gnu_parallel::_Settings::EXACT).\n+  std::vector<RandomAccessIterator1>* offsets =\n+      new std::vector<RandomAccessIterator1>[num_threads];\n+  std::vector<\n+      std::pair<RandomAccessIterator1, RandomAccessIterator1>\n+      > se(k);\n+\n+  copy(seqs_begin, seqs_end, se.begin());\n+\n+  difference_type* borders =\n+      new difference_type[num_threads + 1];\n+  equally_split(length, num_threads, borders);\n+\n+  for (int s = 0; s < (num_threads - 1); ++s)\n+    {\n+      offsets[s].resize(k);\n+      multiseq_partition(\n+          se.begin(), se.end(), borders[s + 1],\n+          offsets[s].begin(), comp);\n+\n+      // Last one also needed and available.\n+      if (!tight)\n+        {\n+          offsets[num_threads - 1].resize(k);\n+          multiseq_partition(se.begin(), se.end(),\n+                difference_type(length),\n+                offsets[num_threads - 1].begin(),  comp);\n+        }\n+    }\n+\n+\n+  for (int slab = 0; slab < num_threads; ++slab)\n+    {\n+      // For each slab / processor.\n+      for (int seq = 0; seq < k; ++seq)\n+        {\n+          // For each sequence.\n+          if (slab == 0)\n+            {\n+              // Absolute beginning.\n+              pieces[slab][seq].first = 0;\n+            }\n+          else\n+            pieces[slab][seq].first =\n+                pieces[slab - 1][seq].second;\n+          if (!tight || slab < (num_threads - 1))\n+            pieces[slab][seq].second =\n+                offsets[slab][seq] - seqs_begin[seq].first;\n+          else\n+            {\n+              // slab == num_threads - 1\n+              pieces[slab][seq].second =\n+                  _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n+            }\n+        }\n+    }\n+  delete[] offsets;\n+}\n+\n /** @brief Parallel multi-way merge routine.\n  *\n- *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor\n- *  and runtime settings.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *  @param stable Stable merging incurs a performance penalty.\n- *  @param sentinel Ignored.\n- *  @return End iterator of output sequence.\n+ * The _GLIBCXX_PARALLEL_DECISION is based on the branching factor\n+ * and runtime settings.\n+ *\n+ * Must not be called if the number of sequences is 1.\n+ *\n+ * @param Splitter functor to split input (either exact or sampling based)\n+ *\n+ * @param seqs_begin Begin iterator of iterator pair input sequence.\n+ * @param seqs_end End iterator of iterator pair input sequence.\n+ * @param target Begin iterator out output sequence.\n+ * @param comp Comparator.\n+ * @param length Maximum length to merge.\n+ * @param stable Stable merging incurs a performance penalty.\n+ * @param sentinel Ignored.\n+ * @return End iterator of output sequence.\n  */\n-template<typename RandomAccessIteratorIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n+template<\n+    bool stable,\n+    bool sentinels,\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Splitter,\n+    typename Comparator\n+    >\n   RandomAccessIterator3\n   parallel_multiway_merge(RandomAccessIteratorIterator seqs_begin,\n                           RandomAccessIteratorIterator seqs_end,\n-                           RandomAccessIterator3 target,\n-                           Comparator comp,\n-                           _DifferenceTp length, bool stable, bool sentinel)\n+                          RandomAccessIterator3 target,\n+                          Comparator comp,\n+                          Splitter splitter,\n+                          _DifferenceTp length)\n     {\n+#if _GLIBCXX_ASSERTIONS\n+      _GLIBCXX_PARALLEL_ASSERT(seqs_end - seqs_begin > 1);\n+#endif\n+\n       _GLIBCXX_CALL(length)\n \n       typedef _DifferenceTp difference_type;\n       typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n         ::value_type::first_type\n         RandomAccessIterator1;\n-      typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n-        value_type;\n+      typedef typename\n+        std::iterator_traits<RandomAccessIterator1>::value_type value_type;\n \n       // k sequences.\n       int k = static_cast<int>(seqs_end - seqs_begin);\n@@ -1543,13 +1317,10 @@ template<typename RandomAccessIteratorIterator,\n       if (total_length == 0 || k == 0)\n         return target;\n \n-      bool tight = (total_length == length);\n-\n       std::vector<std::pair<difference_type, difference_type> >* pieces;\n \n       thread_index_t num_threads = static_cast<thread_index_t>(\n-\tstd::min<difference_type>(get_max_threads(), total_length));\n-      const _Settings& __s = _Settings::get();\n+      \tstd::min<difference_type>(get_max_threads(), total_length));\n \n #     pragma omp parallel num_threads (num_threads)\n         {\n@@ -1562,126 +1333,12 @@ template<typename RandomAccessIteratorIterator,\n               for (int s = 0; s < num_threads; ++s)\n                 pieces[s].resize(k);\n \n-              difference_type num_samples = __s.merge_oversampling \n-\t\t\t\t\t    * num_threads;\n+              difference_type num_samples =\n+                  __gnu_parallel::_Settings::get().merge_oversampling *\n+                    num_threads;\n \n-              if (__s.multiway_merge_splitting == SAMPLING)\n-                {\n-                  value_type* samples = static_cast<value_type*>(\n-                    ::operator new(sizeof(value_type) * k * num_samples));\n-                  // Sample.\n-                  for (int s = 0; s < k; ++s)\n-                    for (difference_type i = 0; i < num_samples; ++i)\n-                      {\n-                        difference_type sample_index =\n-\t\t\t  static_cast<difference_type>(\n-\t\t\t    _GLIBCXX_PARALLEL_LENGTH(seqs_begin[s])\n-\t\t\t    * (double(i + 1) / (num_samples + 1))\n-\t\t\t    * (double(length) / total_length));\n-                        ::new(&(samples[s * num_samples + i]))\n-\t\t\t    value_type(seqs_begin[s].first[sample_index]);\n-                      }\n-\n-                  if (stable)\n-                    __gnu_sequential::stable_sort(samples, samples\n-\t\t\t\t\t\t  + (num_samples * k), comp);\n-                  else\n-                    __gnu_sequential::sort(samples, samples\n-\t\t\t\t\t   + (num_samples * k), comp);\n-\n-                  for (int slab = 0; slab < num_threads; ++slab)\n-                    // For each slab / processor.\n-                    for (int seq = 0; seq < k; ++seq)\n-                      {\n-                        // For each sequence.\n-                        if (slab > 0)\n-                          pieces[slab][seq].first =\n-                              std::upper_bound(seqs_begin[seq].first,\n-\t\t\t\t\t       seqs_begin[seq].second,\n-\t\t\t\t\t       samples[num_samples * k\n-\t\t\t\t\t\t       * slab / num_threads],\n-\t\t\t\t\t       comp)\n-\t\t\t    - seqs_begin[seq].first;\n-                        else\n-                          {\n-                            // Absolute beginning.\n-                            pieces[slab][seq].first = 0;\n-                          }\n-                        if ((slab + 1) < num_threads)\n-                          pieces[slab][seq].second =\n-\t\t\t    std::upper_bound(seqs_begin[seq].first,\n-\t\t\t\t\t     seqs_begin[seq].second,\n-\t\t\t\t\t     samples[num_samples * k\n-\t\t\t\t\t\t     * (slab + 1)\n-\t\t\t\t\t\t     / num_threads], comp)\n-\t\t\t    - seqs_begin[seq].first;\n-                        else\n-\t\t\t  pieces[slab][seq].second \n-\t\t\t    = _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n-                      }\n-\t\t  ::operator delete(samples);\n-                }\n-              else\n-                {\n-                  // (_Settings::multiway_merge_splitting == _Settings::EXACT).\n-                  std::vector<RandomAccessIterator1>* offsets =\n-                      new std::vector<RandomAccessIterator1>[num_threads];\n-                  std::vector<\n-                      std::pair<RandomAccessIterator1, RandomAccessIterator1>\n-                      > se(k);\n-\n-                  copy(seqs_begin, seqs_end, se.begin());\n-\n-                  difference_type* borders =\n-                      new difference_type[num_threads + 1];\n-                  equally_split(length, num_threads, borders);\n-\n-                  for (int s = 0; s < (num_threads - 1); ++s)\n-                    {\n-                      offsets[s].resize(k);\n-                      multiseq_partition(\n-                          se.begin(), se.end(), borders[s + 1],\n-                          offsets[s].begin(), comp);\n-\n-                      // Last one also needed and available.\n-                      if (!tight)\n-                        {\n-                          offsets[num_threads - 1].resize(k);\n-                          multiseq_partition(se.begin(), se.end(),\n-\t\t\t\t\t     difference_type(length),\n-\t\t\t\t\t     offsets[num_threads - 1].begin(),\n-\t\t\t\t\t     comp);\n-                        }\n-                    }\n-\n-\n-                  for (int slab = 0; slab < num_threads; ++slab)\n-                    {\n-                      // For each slab / processor.\n-                      for (int seq = 0; seq < k; ++seq)\n-                        {\n-                          // For each sequence.\n-                          if (slab == 0)\n-                            {\n-                              // Absolute beginning.\n-                              pieces[slab][seq].first = 0;\n-                            }\n-                          else\n-                            pieces[slab][seq].first =\n-                                pieces[slab - 1][seq].second;\n-                          if (!tight || slab < (num_threads - 1))\n-                            pieces[slab][seq].second =\n-\t\t\t      offsets[slab][seq] - seqs_begin[seq].first;\n-                          else\n-                            {\n-                              // slab == num_threads - 1\n-                              pieces[slab][seq].second =\n-\t\t\t\t_GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n-                            }\n-                        }\n-                    }\n-                  delete[] offsets;\n-                }\n+              splitter(seqs_begin, seqs_end, comp, length, total_length,\n+                       pieces);\n             } //single\n \n           thread_index_t iam = omp_get_thread_num();\n@@ -1701,15 +1358,14 @@ template<typename RandomAccessIteratorIterator,\n               for (int s = 0; s < k; ++s)\n                 {\n                   chunks[s] = std::make_pair(\n-\t\t    seqs_begin[s].first + pieces[iam][s].first,\n-\t\t    seqs_begin[s].first + pieces[iam][s].second);\n+                  seqs_begin[s].first + pieces[iam][s].first,\n+                  seqs_begin[s].first + pieces[iam][s].second);\n                   local_length += _GLIBCXX_PARALLEL_LENGTH(chunks[s]);\n                 }\n \n-              multiway_merge(\n+              sequential_multiway_merge<stable, sentinels>(\n                     chunks, chunks + k, target + target_position, comp,\n-                    std::min(local_length, length - target_position),\n-                    stable, false, sequential_tag());\n+                    std::min(local_length, length - target_position));\n \n               delete[] chunks;\n             }\n@@ -1727,7 +1383,7 @@ template<typename RandomAccessIteratorIterator,\n \t\t\t    (pieces[iam][1].second - pieces[iam][1].first),\n \t\t\t    comp);\n             }\n-        } //parallel\n+        } // parallel\n \n #if _GLIBCXX_ASSERTIONS\n       _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n@@ -1743,88 +1399,605 @@ template<typename RandomAccessIteratorIterator,\n     }\n \n /**\n- *  @brief Multi-way merging front-end.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *  @param stable Stable merging incurs a performance penalty.\n- *  @return End iterator of output sequence.\n+ * @brief Multiway Merge Frontend.\n+ *\n+ * Merge the sequences specified by seqs_begin and seqs_end into\n+ * target.  seqs_begin and seqs_end must point to a sequence of\n+ * pairs.  These pairs must contain an iterator to the beginning\n+ * of a sequence in their first entry and an iterator the end of\n+ * the same sequence in their second entry.\n+ *\n+ * Ties are broken arbitrarily.  See stable_multiway_merge for a variant\n+ * that breaks ties by sequence number but is slower.\n+ *\n+ * The first entries of the pairs (i.e. the begin iterators) will be moved\n+ * forward.\n+ *\n+ * The output sequence has to provide enough space for all elements\n+ * that are written to it.\n+ *\n+ * This function will merge the input sequences:\n+ *\n+ * - not stable\n+ * - parallel, depending on the input size and Settings\n+ * - using sampling for splitting\n+ * - not using sentinels\n+ *\n+ * Example:\n+ *\n+ * <pre>\n+ *   int sequences[10][10];\n+ *   for (int i = 0; i < 10; ++i)\n+ *     for (int j = 0; i < 10; ++j)\n+ *       sequences[i][j] = j;\n+ *   \n+ *   int out[33];\n+ *   std::vector<std::pair<int*> > seqs;\n+ *   for (int i = 0; i < 10; ++i)\n+ *     { seqs.push(std::make_pair<int*>(sequences[i], sequences[i] + 10)) }\n+ *   \n+ *   multiway_merge(seqs.begin(), seqs.end(), target, std::less<int>(), 33);\n+ * </pre>\n+ *\n+ * @see stable_multiway_merge\n+ *\n+ * @pre All input sequences must be sorted.\n+ * @pre Target must provide enough space to merge out length elements or\n+ *    the number of elements in all sequences, whichever is smaller.\n+ *\n+ * @post [target, return value) contains merged elements from the\n+ *    input sequences.\n+ * @post return value - target = min(length, number of elements in all\n+ *    sequences).\n+ *\n+ * @param RandomAccessIteratorPairIterator iterator over sequence\n+ *    of pairs of iterators\n+ * @param RandomAccessIteratorOut iterator over target sequence\n+ * @param _DifferenceTp difference type for the sequence\n+ * @param Comparator strict weak ordering type to compare elements\n+ *    in sequences\n+ *\n+ * @param seqs_begin  begin of sequence sequence\n+ * @param seqs_end    end of sequence sequence\n+ * @param target      target sequence to merge to.\n+ * @param comp        strict weak ordering to use for element comparison.\n+ * @param length      the number of elements to merge into target.\n+ *\n+ * @return end iterator of output sequence\n  */\n-template<typename RandomAccessIteratorPairIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n-  RandomAccessIterator3\n-  multiway_merge(RandomAccessIteratorPairIterator seqs_begin,\n-                RandomAccessIteratorPairIterator seqs_end,\n-                RandomAccessIterator3 target, Comparator comp,\n-                _DifferenceTp length, bool stable)\n-  {\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length)\n+{\n+  typedef _DifferenceTp difference_type;\n+  _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+  // catch special case: no sequences\n+  if (seqs_begin == seqs_end)\n+    return target;\n+\n+  // Execute merge; maybe parallel, depending on the number of merged\n+  // elements and the number of sequences and global thresholds in\n+  // Settings.\n+  RandomAccessIteratorOut target_end;\n+  if ((seqs_end - seqs_begin > 1) &&\n+        _GLIBCXX_PARALLEL_CONDITION(\n+        ((seqs_end - seqs_begin) >=\n+        __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+        && ((sequence_index_t)length >=\n+        __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+    target_end = parallel_multiway_merge\n+      </* stable = */ false, /* sentinels = */ false>\n+        (seqs_begin, seqs_end, target, comp,\n+        multiway_merge_sampling_splitting</* stable = */ false,\n+          RandomAccessIteratorPairIterator, Comparator, _DifferenceTp>,\n+        static_cast<difference_type>(length));\n+  else\n+    target_end = sequential_multiway_merge\n+      </* stable = */false, /* sentinels = */ false>(\n+        seqs_begin, seqs_end,\n+        target, comp, length);\n+\n+  return target_end;\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::sequential_tag)\n+{\n+  typedef _DifferenceTp difference_type;\n+  _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+  // catch special case: no sequences\n+  if (seqs_begin == seqs_end)\n+    return target;\n+\n+  // Execute multiway merge *sequentially*.\n+  return sequential_multiway_merge\n+    </* stable = */ false, /* sentinels = */ false>\n+      (seqs_begin, seqs_end, target, comp, length);\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::exact_tag)\n+{\n     typedef _DifferenceTp difference_type;\n     _GLIBCXX_CALL(seqs_end - seqs_begin)\n \n+    // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n       return target;\n \n-    const _Settings& __s = _Settings::get();\n-\n-    RandomAccessIterator3 target_end;\n-    if (_GLIBCXX_PARALLEL_CONDITION(\n-        ((seqs_end - seqs_begin) >= __s.multiway_merge_minimal_k)\n-        && ((sequence_index_t)length >= __s.multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge(seqs_begin, seqs_end,\n-\t\t\t\t\t   target, comp,\n-\t\t\t\t\t  static_cast<difference_type>(length),\n-\t\t\t\t\t   stable, false);\n+    // Execute merge; maybe parallel, depending on the number of merged\n+    // elements and the number of sequences and global thresholds in\n+    // Settings.\n+    RandomAccessIteratorOut target_end;\n+    if ((seqs_end - seqs_begin > 1) &&\n+          _GLIBCXX_PARALLEL_CONDITION(\n+          ((seqs_end - seqs_begin) >=\n+             __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+          && ((sequence_index_t)length >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge\n+                    </* stable = */ false, /* sentinels = */ false>(\n+          seqs_begin, seqs_end,\n+          target, comp,\n+          multiway_merge_exact_splitting</* stable = */ false,\n+            RandomAccessIteratorPairIterator, Comparator, _DifferenceTp>,\n+          static_cast<difference_type>(length));\n     else\n-      target_end = multiway_merge(seqs_begin, seqs_end, target, comp, length,\n-\t\t\t\t  stable, false, sequential_tag());\n+      target_end = sequential_multiway_merge\n+                      </* stable = */ false, /* sentinels = */ false>(\n+          seqs_begin, seqs_end,\n+          target, comp, length);\n \n     return target_end;\n-  }\n+}\n \n-/** @brief Multi-way merging front-end.\n- *  @param seqs_begin Begin iterator of iterator pair input sequence.\n- *  @param seqs_end End iterator of iterator pair input sequence.\n- *  @param target Begin iterator out output sequence.\n- *  @param comp Comparator.\n- *  @param length Maximum length to merge.\n- *  @param stable Stable merging incurs a performance penalty.\n- *  @return End iterator of output sequence.\n- *  @pre For each @c i, @c seqs_begin[i].second must be the end\n- *  marker of the sequence, but also reference the one more sentinel\n- *  element. */\n-template<typename RandomAccessIteratorPairIterator,\n-\t typename RandomAccessIterator3,\n-\t typename _DifferenceTp,\n-\t typename Comparator>\n-  RandomAccessIterator3\n-  multiway_merge_sentinel(RandomAccessIteratorPairIterator seqs_begin,\n-                          RandomAccessIteratorPairIterator seqs_end,\n-                          RandomAccessIterator3 target,\n-                          Comparator comp,\n-                          _DifferenceTp length,\n-                          bool stable)\n-  {\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length)\n+{\n     typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n \n+    // catch special case: no sequences\n     if (seqs_begin == seqs_end)\n       return target;\n \n+    // Execute merge; maybe parallel, depending on the number of merged\n+    // elements and the number of sequences and global thresholds in\n+    // Settings.\n+    RandomAccessIteratorOut target_end;\n+    if ((seqs_end - seqs_begin > 1) &&\n+          _GLIBCXX_PARALLEL_CONDITION(\n+          ((seqs_end - seqs_begin) >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+          && ((sequence_index_t)length >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge\n+        </* stable = */ true, /* sentinels = */ false>(\n+          seqs_begin, seqs_end,\n+          target, comp,\n+          multiway_merge_sampling_splitting</* stable = */ true,\n+          RandomAccessIteratorPairIterator, Comparator, _DifferenceTp>,\n+          static_cast<difference_type>(length));\n+    else\n+      target_end = sequential_multiway_merge\n+        </* stable = */ true, /* sentinels = */ false>(\n+          seqs_begin, seqs_end,\n+          target, comp, length);\n+\n+    return target_end;\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::sequential_tag)\n+{\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute multiway merge *sequentially*.\n+    return sequential_multiway_merge\n+      </* stable = */ true, /* sentinels = */ false>\n+        (seqs_begin, seqs_end, target, comp, length);\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+stable_multiway_merge(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::exact_tag)\n+{\n+    typedef _DifferenceTp difference_type;\n     _GLIBCXX_CALL(seqs_end - seqs_begin)\n \n-    const _Settings& __s = _Settings::get();\n-    const bool cond1 = seqs_end - seqs_begin >= __s.multiway_merge_minimal_k;\n-    const bool cond2 = sequence_index_t(length) >= __s.multiway_merge_minimal_n;\n-    if (_GLIBCXX_PARALLEL_CONDITION(cond1 && cond2))\n-      return parallel_multiway_merge(seqs_begin, seqs_end, target, comp, \n-\t\t\t\t     length, stable, true);\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute merge; maybe parallel, depending on the number of merged\n+    // elements and the number of sequences and global thresholds in\n+    // Settings.\n+    RandomAccessIteratorOut target_end;\n+    if ((seqs_end - seqs_begin > 1) &&\n+          _GLIBCXX_PARALLEL_CONDITION(\n+          ((seqs_end - seqs_begin) >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+          && ((sequence_index_t)length >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge\n+        </* stable = */ true, /* sentinels = */ false>(\n+          seqs_begin, seqs_end,\n+          target, comp, \n+          multiway_merge_exact_splitting\n+            </* stable = */ true, RandomAccessIteratorPairIterator,\n+             Comparator, _DifferenceTp>,\n+          static_cast<difference_type>(length));\n     else\n-      return multiway_merge(seqs_begin, seqs_end, target, comp, length, stable,\n-\t\t\t    true, sequential_tag());\n-  }\n+      target_end = sequential_multiway_merge</* stable = */ true,\n+        /* sentinels = */ false>(\n+          seqs_begin, seqs_end,\n+          target, comp, length);\n+\n+    return target_end;\n }\n \n+/**\n+ * @brief Multiway Merge Frontend.\n+ *\n+ * Merge the sequences specified by seqs_begin and seqs_end into\n+ * target.  seqs_begin and seqs_end must point to a sequence of\n+ * pairs.  These pairs must contain an iterator to the beginning\n+ * of a sequence in their first entry and an iterator the end of\n+ * the same sequence in their second entry.\n+ *\n+ * Ties are broken arbitrarily.  See stable_multiway_merge for a variant\n+ * that breaks ties by sequence number but is slower.\n+ *\n+ * The first entries of the pairs (i.e. the begin iterators) will be moved\n+ * forward.\n+ *\n+ * The output sequence has to provide enough space for all elements\n+ * that are written to it.\n+ *\n+ * This function will merge the input sequences:\n+ *\n+ * - not stable\n+ * - parallel, depending on the input size and Settings\n+ * - using sampling for splitting\n+ * - using sentinels\n+ *\n+ * You have to take care that the element the end iterator points to is\n+ * readable and contains a value that is greater than any other non-sentinel\n+ * value in all sequences.\n+ *\n+ * Example:\n+ *\n+ * <pre>\n+ *   int sequences[10][11];\n+ *   for (int i = 0; i < 10; ++i)\n+ *     for (int j = 0; i < 11; ++j)\n+ *       sequences[i][j] = j; // last one is sentinel!\n+ *\n+ *   int out[33];\n+ *   std::vector<std::pair<int*> > seqs;\n+ *   for (int i = 0; i < 10; ++i)\n+ *     { seqs.push(std::make_pair<int*>(sequences[i], sequences[i] + 10)) }\n+ *\n+ *   multiway_merge(seqs.begin(), seqs.end(), target, std::less<int>(), 33);\n+ * </pre>\n+ *\n+ * @pre All input sequences must be sorted.\n+ * @pre Target must provide enough space to merge out length elements or\n+ *    the number of elements in all sequences, whichever is smaller.\n+ * @pre For each @c i, @c seqs_begin[i].second must be the end\n+ *    marker of the sequence, but also reference the one more sentinel\n+ *    element.\n+ *\n+ * @post [target, return value) contains merged elements from the\n+ *    input sequences.\n+ * @post return value - target = min(length, number of elements in all\n+ *    sequences).\n+ *\n+ * @see stable_multiway_merge_sentinels\n+ *\n+ * @param RandomAccessIteratorPairIterator iterator over sequence\n+ *    of pairs of iterators\n+ * @param RandomAccessIteratorOut iterator over target sequence\n+ * @param _DifferenceTp difference type for the sequence\n+ * @param Comparator strict weak ordering type to compare elements\n+ *    in sequences\n+ *\n+ * @param seqs_begin  begin of sequence sequence\n+ * @param seqs_end    end of sequence sequence\n+ * @param target      target sequence to merge to.\n+ * @param comp        strict weak ordering to use for element comparison.\n+ * @param length      the number of elements to merge into target.\n+ *\n+ * @return end iterator of output sequence\n+ */\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length)\n+{\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute merge; maybe parallel, depending on the number of merged\n+    // elements and the number of sequences and global thresholds in\n+    // Settings.\n+    RandomAccessIteratorOut target_end;\n+    if ((seqs_end - seqs_begin > 1) &&\n+          _GLIBCXX_PARALLEL_CONDITION(\n+          ((seqs_end - seqs_begin) >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+          && ((sequence_index_t)length >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge\n+        </* stable = */ false, /* sentinels = */ true>\n+          (seqs_begin, seqs_end, target, comp,\n+          multiway_merge_sampling_splitting\n+            </* stable = */ false, RandomAccessIteratorPairIterator,\n+             Comparator, _DifferenceTp>,\n+          static_cast<difference_type>(length));\n+    else\n+      target_end = sequential_multiway_merge\n+        </* stable = */false, /* sentinels = */ true>(\n+          seqs_begin, seqs_end,\n+          target, comp, length);\n+\n+    return target_end;\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::sequential_tag)\n+{\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute multiway merge *sequentially*.\n+    return sequential_multiway_merge\n+      </* stable = */ false, /* sentinels = */ true>\n+        (seqs_begin, seqs_end, target, comp, length);\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::exact_tag)\n+{\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute merge; maybe parallel, depending on the number of merged\n+    // elements and the number of sequences and global thresholds in\n+    // Settings.\n+    RandomAccessIteratorOut target_end;\n+    if ((seqs_end - seqs_begin > 1) &&\n+          _GLIBCXX_PARALLEL_CONDITION(\n+          ((seqs_end - seqs_begin) >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+          && ((sequence_index_t)length >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge\n+        </* stable = */ false, /* sentinels = */ true>(\n+          seqs_begin, seqs_end,\n+          target, comp,\n+          multiway_merge_exact_splitting\n+            </* stable = */ false, RandomAccessIteratorPairIterator,\n+              Comparator, _DifferenceTp>,\n+          static_cast<difference_type>(length));\n+    else\n+      target_end = sequential_multiway_merge\n+        </* stable = */ false, /* sentinels = */ true>(\n+          seqs_begin, seqs_end,\n+          target, comp, length);\n+\n+    return target_end;\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length)\n+{\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute merge; maybe parallel, depending on the number of merged\n+    // elements and the number of sequences and global thresholds in\n+    // Settings.\n+    RandomAccessIteratorOut target_end;\n+    if ((seqs_end - seqs_begin > 1) &&\n+          _GLIBCXX_PARALLEL_CONDITION(\n+          ((seqs_end - seqs_begin) >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+          && ((sequence_index_t)length >=\n+            __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge\n+        </* stable = */ true, /* sentinels = */ true>(\n+          seqs_begin, seqs_end,\n+          target, comp,\n+          multiway_merge_sampling_splitting\n+            </* stable = */ true, RandomAccessIteratorPairIterator,\n+            Comparator, _DifferenceTp>,\n+          static_cast<difference_type>(length));\n+    else\n+      target_end = sequential_multiway_merge\n+        </* stable = */ true, /* sentinels = */ true>(\n+          seqs_begin, seqs_end,\n+          target, comp, length);\n+\n+    return target_end;\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::sequential_tag)\n+{\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute multiway merge *sequentially*.\n+    return sequential_multiway_merge\n+      </* stable = */ true, /* sentinels = */ true>\n+        (seqs_begin, seqs_end, target, comp, length);\n+}\n+\n+template<\n+    typename RandomAccessIteratorPairIterator\n+  , typename RandomAccessIteratorOut\n+  , typename _DifferenceTp\n+  , typename Comparator>\n+RandomAccessIteratorOut\n+stable_multiway_merge_sentinels(RandomAccessIteratorPairIterator seqs_begin\n+    , RandomAccessIteratorPairIterator seqs_end\n+    , RandomAccessIteratorOut target\n+    , Comparator comp, _DifferenceTp length\n+    , __gnu_parallel::exact_tag)\n+{\n+    typedef _DifferenceTp difference_type;\n+    _GLIBCXX_CALL(seqs_end - seqs_begin)\n+\n+    // catch special case: no sequences\n+    if (seqs_begin == seqs_end)\n+      { return target; }\n+\n+    // Execute merge; maybe parallel, depending on the number of merged\n+    // elements and the number of sequences and global thresholds in\n+    // Settings.\n+    RandomAccessIteratorOut target_end;\n+    if ((seqs_end - seqs_begin > 1) &&\n+          _GLIBCXX_PARALLEL_CONDITION(\n+          ((seqs_end - seqs_begin) >=\n+          __gnu_parallel::_Settings::get().multiway_merge_minimal_k)\n+          && ((sequence_index_t)length >=\n+          __gnu_parallel::_Settings::get().multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge\n+        </* stable = */ true, /* sentinels = */ true>(\n+          seqs_begin, seqs_end,\n+          target, comp, \n+          multiway_merge_exact_splitting\n+            </* stable = */ true, RandomAccessIteratorPairIterator,\n+            Comparator, _DifferenceTp>,\n+          static_cast<difference_type>(length));\n+    else\n+      target_end = sequential_multiway_merge\n+        </* stable = */ true, /* sentinels = */ true>(\n+          seqs_begin, seqs_end,\n+          target, comp, length);\n+\n+    return target_end;\n+}\n+\n+}; // namespace __gnu_parallel\n+\n #endif"}, {"sha": "3791a144d53a088895204dd4e20494a3a775b729", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 239, "deletions": 181, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -80,26 +80,9 @@ template<typename RandomAccessIterator>\n     /** @brief Start indices, per thread. */\n     difference_type* starts;\n \n-    /** @brief Temporary arrays for each thread.\n-     *\n-     *  Indirection Allows using the temporary storage in different\n-     *  ways, without code duplication.\n-     *  @see _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST */\n-    value_type** temporaries;\n-\n-#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n     /** @brief Storage in which to sort. */\n-    RandomAccessIterator* sorting_places;\n+    value_type** temporary;\n \n-    /** @brief Storage into which to merge. */\n-    value_type** merging_places;\n-#else\n-    /** @brief Storage in which to sort. */\n-    value_type** sorting_places;\n-\n-    /** @brief Storage into which to merge. */\n-    RandomAccessIterator* merging_places;\n-#endif\n     /** @brief Samples. */\n     value_type* samples;\n \n@@ -108,9 +91,6 @@ template<typename RandomAccessIterator>\n \n     /** @brief Pieces of data to merge @c [thread][sequence] */\n     std::vector<Piece<difference_type> >* pieces;\n-\n-    /** @brief Stable sorting desired. */\n-    bool stable;\n };\n \n /**\n@@ -122,16 +102,14 @@ template<typename RandomAccessIterator>\n template<typename RandomAccessIterator, typename _DifferenceTp>\n   void \n   determine_samples(PMWMSSortingData<RandomAccessIterator>* sd,\n-                    _DifferenceTp& num_samples)\n+                    _DifferenceTp num_samples)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef _DifferenceTp difference_type;\n \n     thread_index_t iam = omp_get_thread_num();\n \n-    num_samples = _Settings::get().sort_mwms_oversampling * sd->num_threads - 1;\n-\n     difference_type* es = new difference_type[num_samples + 2];\n \n     equally_split(sd->starts[iam + 1] - sd->starts[iam], \n@@ -144,11 +122,201 @@ template<typename RandomAccessIterator, typename _DifferenceTp>\n     delete[] es;\n   }\n \n+/** @brief Split consistently. */\n+template<bool exact, typename RandomAccessIterator,\n+          typename Comparator, typename SortingPlacesIterator>\n+  struct split_consistently\n+  {\n+  };\n+\n+/** @brief Split by exact splitting. */\n+template<typename RandomAccessIterator, typename Comparator,\n+          typename SortingPlacesIterator>\n+  struct split_consistently\n+    <true, RandomAccessIterator, Comparator, SortingPlacesIterator>\n+  {\n+    void operator()(\n+      const thread_index_t iam,\n+      PMWMSSortingData<RandomAccessIterator>* sd,\n+      Comparator& comp,\n+      const typename\n+        std::iterator_traits<RandomAccessIterator>::difference_type\n+          num_samples)\n+      const\n+  {\n+#   pragma omp barrier\n+\n+    std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n+        seqs(sd->num_threads);\n+    for (thread_index_t s = 0; s < sd->num_threads; s++)\n+      seqs[s] = std::make_pair(sd->temporary[s],\n+                                sd->temporary[s]\n+                                    + (sd->starts[s + 1] - sd->starts[s]));\n+\n+    std::vector<SortingPlacesIterator> offsets(sd->num_threads);\n+\n+    // if not last thread\n+    if (iam < sd->num_threads - 1)\n+      multiseq_partition(seqs.begin(), seqs.end(),\n+                          sd->starts[iam + 1], offsets.begin(), comp);\n+\n+    for (int seq = 0; seq < sd->num_threads; seq++)\n+      {\n+        // for each sequence\n+        if (iam < (sd->num_threads - 1))\n+          sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n+        else\n+          // very end of this sequence\n+          sd->pieces[iam][seq].end =\n+              sd->starts[seq + 1] - sd->starts[seq];\n+      }\n+\n+#   pragma omp barrier\n+\n+    for (thread_index_t seq = 0; seq < sd->num_threads; seq++)\n+      {\n+        // For each sequence.\n+        if (iam > 0)\n+          sd->pieces[iam][seq].begin = sd->pieces[iam - 1][seq].end;\n+        else\n+          // Absolute beginning.\n+          sd->pieces[iam][seq].begin = 0;\n+      }\n+  }   \n+  };\n+\n+/** @brief Split by sampling. */ \n+template<typename RandomAccessIterator, typename Comparator,\n+          typename SortingPlacesIterator>\n+  struct split_consistently<false, RandomAccessIterator, Comparator,\n+                             SortingPlacesIterator>\n+  {\n+    void operator()(\n+        const thread_index_t iam,\n+        PMWMSSortingData<RandomAccessIterator>* sd,\n+        Comparator& comp,\n+        const typename\n+          std::iterator_traits<RandomAccessIterator>::difference_type\n+            num_samples)\n+        const\n+    {\n+      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+      typedef typename traits_type::value_type value_type;\n+      typedef typename traits_type::difference_type difference_type;\n+\n+      determine_samples(sd, num_samples);\n+\n+#     pragma omp barrier\n+\n+#     pragma omp single\n+      __gnu_sequential::sort(sd->samples,\n+                             sd->samples + (num_samples * sd->num_threads),\n+                             comp);\n+\n+#     pragma omp barrier\n+\n+      for (thread_index_t s = 0; s < sd->num_threads; ++s)\n+        {\n+          // For each sequence.\n+          if (num_samples * iam > 0)\n+            sd->pieces[iam][s].begin =\n+                std::lower_bound(sd->temporary[s],\n+                    sd->temporary[s]\n+                        + (sd->starts[s + 1] - sd->starts[s]),\n+                    sd->samples[num_samples * iam],\n+                    comp)\n+                - sd->temporary[s];\n+          else\n+            // Absolute beginning.\n+            sd->pieces[iam][s].begin = 0;\n+\n+          if ((num_samples * (iam + 1)) < (num_samples * sd->num_threads))\n+            sd->pieces[iam][s].end =\n+                std::lower_bound(sd->temporary[s],\n+                        sd->temporary[s]\n+                            + (sd->starts[s + 1] - sd->starts[s]),\n+                        sd->samples[num_samples * (iam + 1)],\n+                        comp)\n+                - sd->temporary[s];\n+          else\n+            // Absolute end.\n+            sd->pieces[iam][s].end = sd->starts[s + 1] - sd->starts[s];\n+        }\n+    }\n+  };\n+  \n+template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  struct possibly_stable_sort\n+  {\n+  };\n+\n+template<typename RandomAccessIterator, typename Comparator>\n+  struct possibly_stable_sort<true, RandomAccessIterator, Comparator>\n+  {\n+    void operator()(const RandomAccessIterator& begin,\n+                     const RandomAccessIterator& end, Comparator& comp) const\n+    {\n+      __gnu_sequential::stable_sort(begin, end, comp); \n+    }\n+  };\n+\n+template<typename RandomAccessIterator, typename Comparator>\n+  struct possibly_stable_sort<false, RandomAccessIterator, Comparator>\n+  {\n+    void operator()(const RandomAccessIterator begin,\n+                     const RandomAccessIterator end, Comparator& comp) const\n+    {\n+      __gnu_sequential::sort(begin, end, comp); \n+    }\n+  };\n+\n+template<bool stable, typename SeqRandomAccessIterator,\n+          typename RandomAccessIterator, typename Comparator,\n+          typename DiffType>\n+  struct possibly_stable_multiway_merge\n+  {\n+  };\n+\n+template<typename SeqRandomAccessIterator, typename RandomAccessIterator,\n+          typename Comparator, typename DiffType>\n+  struct possibly_stable_multiway_merge\n+    <true, SeqRandomAccessIterator, RandomAccessIterator, Comparator,\n+    DiffType>\n+  {\n+    void operator()(const SeqRandomAccessIterator& seqs_begin,\n+                      const SeqRandomAccessIterator& seqs_end,\n+                      const RandomAccessIterator& target,\n+                      Comparator& comp,\n+                      DiffType length_am) const\n+    {\n+      stable_multiway_merge(seqs_begin, seqs_end, target, comp,\n+                       length_am, sequential_tag());\n+    }\n+  };\n+\n+template<typename SeqRandomAccessIterator, typename RandomAccessIterator,\n+          typename Comparator, typename DiffType>\n+  struct possibly_stable_multiway_merge\n+    <false, SeqRandomAccessIterator, RandomAccessIterator, Comparator,\n+    DiffType>\n+  {\n+    void operator()(const SeqRandomAccessIterator& seqs_begin,\n+                      const SeqRandomAccessIterator& seqs_end,\n+                      const RandomAccessIterator& target,\n+                      Comparator& comp,\n+                      DiffType length_am) const\n+    {\n+      multiway_merge(seqs_begin, seqs_end, target, comp,\n+                       length_am, sequential_tag());\n+    }\n+  };\n+\n /** @brief PMWMS code executed by each thread.\n   *  @param sd Pointer to algorithm data.\n   *  @param comp Comparator.\n   */\n-template<typename RandomAccessIterator, typename Comparator>\n+template<bool stable, bool exact, typename RandomAccessIterator,\n+          typename Comparator>\n   void \n   parallel_sort_mwms_pu(PMWMSSortingData<RandomAccessIterator>* sd,\n                         Comparator& comp)\n@@ -162,165 +330,65 @@ template<typename RandomAccessIterator, typename Comparator>\n     // Length of this thread's chunk, before merging.\n     difference_type length_local = sd->starts[iam + 1] - sd->starts[iam];\n \n-#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n-    typedef RandomAccessIterator SortingPlacesIterator;\n+    // Sort in temporary storage, leave space for sentinel.\n \n-    // Sort in input storage.\n-    sd->sorting_places[iam] = sd->source + sd->starts[iam];\n-#else\n     typedef value_type* SortingPlacesIterator;\n \n-    // Sort in temporary storage, leave space for sentinel.\n-    sd->sorting_places[iam] = sd->temporaries[iam] = \n+    sd->temporary[iam] =\n         static_cast<value_type*>(\n         ::operator new(sizeof(value_type) * (length_local + 1)));\n \n     // Copy there.\n     std::uninitialized_copy(sd->source + sd->starts[iam],\n                             sd->source + sd->starts[iam] + length_local,\n-                            sd->sorting_places[iam]);\n-#endif\n-\n-    // Sort locally.\n-    if (sd->stable)\n-      __gnu_sequential::stable_sort(sd->sorting_places[iam],\n-                                    sd->sorting_places[iam] + length_local,\n-                                    comp);\n-    else\n-      __gnu_sequential::sort(sd->sorting_places[iam],\n-                             sd->sorting_places[iam] + length_local,\n-                             comp);\n-\n-    // Invariant: locally sorted subsequence in sd->sorting_places[iam],\n-    // sd->sorting_places[iam] + length_local.\n-    const _Settings& __s = _Settings::get();\n-    if (__s.sort_splitting == SAMPLING)\n-      {\n-        difference_type num_samples;\n-        determine_samples(sd, num_samples);\n-\n-#       pragma omp barrier\n-\n-#       pragma omp single\n-        __gnu_sequential::sort(sd->samples,\n-                               sd->samples + (num_samples * sd->num_threads),\n-                               comp);\n-\n-#       pragma omp barrier\n-\n-        for (int s = 0; s < sd->num_threads; ++s)\n-          {\n-            // For each sequence.\n-              if (num_samples * iam > 0)\n-                sd->pieces[iam][s].begin = \n-                    std::lower_bound(sd->sorting_places[s],\n-                        sd->sorting_places[s]\n-                            + (sd->starts[s + 1] - sd->starts[s]),\n-                        sd->samples[num_samples * iam],\n-                        comp)\n-                    - sd->sorting_places[s];\n-            else\n-              // Absolute beginning.\n-              sd->pieces[iam][s].begin = 0;\n-\n-            if ((num_samples * (iam + 1)) < (num_samples * sd->num_threads))\n-              sd->pieces[iam][s].end =\n-                  std::lower_bound(sd->sorting_places[s],\n-                          sd->sorting_places[s]\n-                              + (sd->starts[s + 1] - sd->starts[s]),\n-                          sd->samples[num_samples * (iam + 1)],\n-                          comp)\n-                  - sd->sorting_places[s];\n-            else\n-              // Absolute end.\n-              sd->pieces[iam][s].end = sd->starts[s + 1] - sd->starts[s];\n-            }\n-      }\n-    else if (__s.sort_splitting == EXACT)\n-      {\n-#       pragma omp barrier\n+                            sd->temporary[iam]);\n \n-        std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n-            seqs(sd->num_threads);\n-        for (int s = 0; s < sd->num_threads; ++s)\n-          seqs[s] = std::make_pair(sd->sorting_places[s],\n-                                   sd->sorting_places[s]\n-                                       + (sd->starts[s + 1] - sd->starts[s]));\n+    possibly_stable_sort<stable, SortingPlacesIterator, Comparator>()\n+        (sd->temporary[iam], sd->temporary[iam] + length_local, comp);\n \n-        std::vector<SortingPlacesIterator> offsets(sd->num_threads);\n+    // Invariant: locally sorted subsequence in sd->temporary[iam],\n+    // sd->temporary[iam] + length_local.\n \n-        // if not last thread\n-        if (iam < sd->num_threads - 1)\n-          multiseq_partition(seqs.begin(), seqs.end(),\n-                             sd->starts[iam + 1], offsets.begin(), comp);\n+    // No barrier here: Synchronization is done by the splitting routine.\n \n-        for (int seq = 0; seq < sd->num_threads; ++seq)\n-          {\n-            // for each sequence\n-            if (iam < (sd->num_threads - 1))\n-              sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n-            else\n-              // very end of this sequence\n-              sd->pieces[iam][seq].end = (sd->starts[seq + 1]\n-\t\t\t\t\t  - sd->starts[seq]);\n-          }\n-\n-#       pragma omp barrier\n-\n-        for (int seq = 0; seq < sd->num_threads; ++seq)\n-          {\n-            // For each sequence.\n-            if (iam > 0)\n-              sd->pieces[iam][seq].begin = sd->pieces[iam - 1][seq].end;\n-            else\n-              // Absolute beginning.\n-              sd->pieces[iam][seq].begin = 0;\n-          }\n-      }\n+    difference_type num_samples =\n+        _Settings::get().sort_mwms_oversampling * sd->num_threads - 1;\n+    split_consistently\n+      <exact, RandomAccessIterator, Comparator, SortingPlacesIterator>()\n+        (iam, sd, comp, num_samples);\n \n     // Offset from target begin, length after merging.\n     difference_type offset = 0, length_am = 0;\n-    for (int s = 0; s < sd->num_threads; ++s)\n+    for (thread_index_t s = 0; s < sd->num_threads; s++)\n       {\n         length_am += sd->pieces[iam][s].end - sd->pieces[iam][s].begin;\n         offset += sd->pieces[iam][s].begin;\n       }\n \n-#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n-    // Merge to temporary storage, uninitialized creation not possible\n-    // since there is no multiway_merge calling the placement new\n-    // instead of the assignment operator.\n-    // XXX incorrect (de)construction\n-    sd->merging_places[iam] = sd->temporaries[iam] =\n-        static_cast<value_type*>(::operator new(sizeof(value_type)\n-\t\t\t\t\t\t* length_am));\n-#else\n-    // Merge directly to target.\n-    sd->merging_places[iam] = sd->source + offset;\n-#endif\n-    std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n-        seqs(sd->num_threads);\n+    typedef std::vector<\n+      std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n+        seq_vector_type;\n+    seq_vector_type seqs(sd->num_threads);\n \n     for (int s = 0; s < sd->num_threads; ++s)\n       {\n         seqs[s] =\n-\t  std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin,\n-\t\t\t sd->sorting_places[s] + sd->pieces[iam][s].end);\n+          std::make_pair(sd->temporary[s] + sd->pieces[iam][s].begin,\n+        sd->temporary[s] + sd->pieces[iam][s].end);\n       }\n \n-    multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp,\n-                   length_am, sd->stable, false, sequential_tag());\n+    possibly_stable_multiway_merge<\n+        stable,\n+        typename seq_vector_type::iterator,\n+        RandomAccessIterator,\n+        Comparator, difference_type>()\n+          (seqs.begin(), seqs.end(),\n+           sd->source + offset, comp,\n+           length_am);\n \n #   pragma omp barrier\n \n-#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n-    // Write back.\n-    std::copy(sd->merging_places[iam],\n-              sd->merging_places[iam] + length_am,\n-              sd->source + offset);\n-#endif\n-\n-    ::operator delete(sd->temporaries[iam]);\n+    ::operator delete(sd->temporary[iam]);\n   }\n \n /** @brief PMWMS main call.\n@@ -329,21 +397,22 @@ template<typename RandomAccessIterator, typename Comparator>\n   *  @param comp Comparator.\n   *  @param n Length of sequence.\n   *  @param num_threads Number of threads to use.\n-  *  @param stable Stable sorting.\n   */\n-template<typename RandomAccessIterator, typename Comparator>\n+template<bool stable, bool exact, typename RandomAccessIterator,\n+           typename Comparator>\n   void\n   parallel_sort_mwms(RandomAccessIterator begin, RandomAccessIterator end,\n-                     Comparator comp, typename\n-\t\t     std::iterator_traits<RandomAccessIterator>::\n-\t\t     difference_type n, int num_threads, bool stable)\n+                     Comparator comp,\n+                     thread_index_t num_threads)\n   {\n-    _GLIBCXX_CALL(n)\n+    _GLIBCXX_CALL(end - begin)\n \n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n+    difference_type n = end - begin;\n+\n     if (n <= 1)\n       return;\n \n@@ -354,7 +423,6 @@ template<typename RandomAccessIterator, typename Comparator>\n     // shared variables\n     PMWMSSortingData<RandomAccessIterator> sd;\n     difference_type* starts;\n-    const _Settings& __s = _Settings::get();\n \n #   pragma omp parallel num_threads(num_threads)\n       {\n@@ -364,23 +432,16 @@ template<typename RandomAccessIterator, typename Comparator>\n           {\n             sd.num_threads = num_threads;\n             sd.source = begin;\n-            sd.temporaries = new value_type*[num_threads];\n-\n-#if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n-            sd.sorting_places = new RandomAccessIterator[num_threads];\n-            sd.merging_places = new value_type*[num_threads];\n-#else\n-            sd.sorting_places = new value_type*[num_threads];\n-            sd.merging_places = new RandomAccessIterator[num_threads];\n-#endif\n \n-            if (__s.sort_splitting == SAMPLING)\n+            sd.temporary = new value_type*[num_threads];\n+\n+            if (!exact)\n               {\n-                unsigned int size = \n-                    (__s.sort_mwms_oversampling * num_threads - 1)\n+                difference_type size =\n+                    (_Settings::get().sort_mwms_oversampling * num_threads - 1)\n                         * num_threads;\n                 sd.samples = static_cast<value_type*>(\n-\t\t  ::operator new(size * sizeof(value_type)));\n+                              ::operator new(size * sizeof(value_type)));\n               }\n             else\n               sd.samples = NULL;\n@@ -390,7 +451,6 @@ template<typename RandomAccessIterator, typename Comparator>\n             for (int s = 0; s < num_threads; ++s)\n               sd.pieces[s].resize(num_threads);\n             starts = sd.starts = new difference_type[num_threads + 1];\n-            sd.stable = stable;\n \n             difference_type chunk_length = n / num_threads;\n             difference_type split = n % num_threads;\n@@ -401,18 +461,16 @@ template<typename RandomAccessIterator, typename Comparator>\n                 pos += (i < split) ? (chunk_length + 1) : chunk_length;\n               }\n             starts[num_threads] = pos;\n-          }\n+          } //single\n \n         // Now sort in parallel.\n-        parallel_sort_mwms_pu(&sd, comp);\n+        parallel_sort_mwms_pu<stable, exact>(&sd, comp);\n       } //parallel\n \n     delete[] starts;\n-    delete[] sd.temporaries;\n-    delete[] sd.sorting_places;\n-    delete[] sd.merging_places;\n+    delete[] sd.temporary;\n \n-    if (__s.sort_splitting == SAMPLING)\n+    if (!exact)\n       ::operator delete(sd.samples);\n \n     delete[] sd.offsets;"}, {"sha": "83aa2df1b1108aad1ae226c1affa07f3b4374e10", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -71,33 +71,51 @@ namespace __gnu_parallel\n   template<typename RandomAccessIterator, typename Comparator>\n     inline void\n     parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\t  Comparator comp, bool stable)\n+                  Comparator comp, bool stable)\n     {\n       _GLIBCXX_CALL(end - begin)\n       typedef std::iterator_traits<RandomAccessIterator> traits_type;\n       typedef typename traits_type::value_type value_type;\n       typedef typename traits_type::difference_type difference_type;\n \n       if (begin != end)\n-\t{\n-\t  difference_type n = end - begin;\n+      {\n+        difference_type n = end - begin;\n \n-\t  if (false) ;\n+        if (false) ;\n #if _GLIBCXX_MERGESORT\n-\t  else if (stable || _Settings::get().sort_algorithm == MWMS)\n-\t    parallel_sort_mwms(begin, end, comp, n, get_max_threads(), stable);\n+        else if (stable)\n+          {\n+            if(_Settings::get().sort_splitting == EXACT)\n+              parallel_sort_mwms<true, true>\n+                (begin, end, comp, get_max_threads());\n+            else\n+              parallel_sort_mwms<true, false>\n+                (begin, end, comp, get_max_threads());\n+          }\n+        else if (_Settings::get().sort_algorithm == MWMS)\n+          {\n+            if(_Settings::get().sort_splitting == EXACT)\n+              parallel_sort_mwms<false, true>\n+                (begin, end, comp, get_max_threads());\n+            else\n+              parallel_sort_mwms<false, false>\n+                (begin, end, comp, get_max_threads());\n+          }\n #endif\n #if _GLIBCXX_QUICKSORT\n-\t  else if (!stable && _Settings::get().sort_algorithm == QS)\n-\t    parallel_sort_qs(begin, end, comp, n, get_max_threads());\n+        else if (!stable && _Settings::get().sort_algorithm == QS)\n+          parallel_sort_qs(begin, end, comp, n, get_max_threads());\n #endif\n #if _GLIBCXX_BAL_QUICKSORT\n-\t  else if (!stable && _Settings::get().sort_algorithm == QS_BALANCED)\n-\t    parallel_sort_qsb(begin, end, comp, n, get_max_threads());\n+        else if (!stable && _Settings::get().sort_algorithm == QS_BALANCED)\n+          parallel_sort_qsb(begin, end, comp, n, get_max_threads());\n #endif\n-\t  else\n-\t    __gnu_sequential::sort(begin, end, comp);\n-\t}\n+        else if(stable)\n+          __gnu_sequential::stable_sort(begin, end, comp);\n+        else\n+          __gnu_sequential::sort(begin, end, comp);\n+      }\n     }\n } // end namespace __gnu_parallel\n "}, {"sha": "f57add97c7b0e18324525b0a26eec2d1f1edc7d3", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -44,6 +44,9 @@ namespace __gnu_parallel\n   /** @brief Forces sequential execution at compile time. */\n   struct sequential_tag { };\n \n+  /** @brief Forces exact splitting in multiway merge at compile time. */\n+  struct exact_tag { };\n+\n   /** @brief Recommends parallel execution at compile time. */\n   struct parallel_tag { };\n "}, {"sha": "1b646b02084e82d7bdcd1b769b74cb44bbb1856a", "filename": "libstdc++-v3/include/parallel/types.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -87,15 +87,10 @@ namespace __gnu_parallel\n   /// Merging algorithms: \n   // bubblesort-alike, loser-tree variants, enum sentinel.\n   enum _MultiwayMergeAlgorithm\n-    { \n-      BUBBLE, \n-      LOSER_TREE_EXPLICIT, \n-      LOSER_TREE, \n-      LOSER_TREE_COMBINED, \n-      LOSER_TREE_SENTINEL, \n-      ENUM_SENTINEL \n+    {\n+      LOSER_TREE\n     };\n-  \n+\n   /// Partial sum algorithms: recursive, linear.\n   enum _PartialSumAlgorithm \n     { "}, {"sha": "715fa3b93d26687237cf75f8b625a916f2b4b5dd", "filename": "libstdc++-v3/testsuite/25_algorithms/sort/35588.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2F35588.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9985df51b32cb265f429d024e955e71fd23a4f1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2F35588.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort%2F35588.cc?ref=f9985df51b32cb265f429d024e955e71fd23a4f1", "patch": "@@ -0,0 +1,32 @@\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <algorithm>\n+#include <functional>\n+#include <tr1/functional>\n+\n+// libstdc++/35588\n+int main()\n+{\n+  using namespace std;\n+  using namespace tr1;\n+  using namespace placeholders;\n+\n+  int t[10];\n+  sort(t, t+10, bind(less<int>(), _1, _2));\n+}"}]}