{"sha": "83ae86f5b7671f22d7fc3581c3632f92537eb539", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNhZTg2ZjViNzY3MWYyMmQ3ZmMzNTgxYzM2MzJmOTI1MzdlYjUzOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-09-19T12:49:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-09-19T12:49:30Z"}, "message": "tree-ssa-dom.c (record_temporary_equivalences): New function split out of dom_opt_dom_walker::after_dom_children.\n\n       * tree-ssa-dom.c (record_temporary_equivalences): New function\n        split out of dom_opt_dom_walker::after_dom_children.\n        (dom_opt_dom_walker::thread_across_edge): Move common code\n        in here from dom_opt_dom_walker::after_dom_children.\n        (dom_opt_dom_walker::after_dom_children): Corresponding simplifictions.\n\nFrom-SVN: r202742", "tree": {"sha": "d9966b2e81e1393d616bc1fd828dce5251d36415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9966b2e81e1393d616bc1fd828dce5251d36415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83ae86f5b7671f22d7fc3581c3632f92537eb539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ae86f5b7671f22d7fc3581c3632f92537eb539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83ae86f5b7671f22d7fc3581c3632f92537eb539", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ae86f5b7671f22d7fc3581c3632f92537eb539/comments", "author": null, "committer": null, "parents": [{"sha": "9d5321624b105f7f265254568ecab29e330e1ec7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5321624b105f7f265254568ecab29e330e1ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d5321624b105f7f265254568ecab29e330e1ec7"}], "stats": {"total": 124, "additions": 54, "deletions": 70}, "files": [{"sha": "0f73b072dea1614c621cb16b94298501ba7fb3dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ae86f5b7671f22d7fc3581c3632f92537eb539/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ae86f5b7671f22d7fc3581c3632f92537eb539/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83ae86f5b7671f22d7fc3581c3632f92537eb539", "patch": "@@ -1,3 +1,11 @@\n+2013-09-17  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (record_temporary_equivalences): New function\n+\tsplit out of dom_opt_dom_walker::after_dom_children.\n+\t(dom_opt_dom_walker::thread_across_edge): Move common code\n+\tin here from dom_opt_dom_walker::after_dom_children.\n+\t(dom_opt_dom_walker::after_dom_children): Corresponding simplifictions.\n+\n 2013-09-19  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (TARGET_GENERIC32, TARGET_GENERIC64): Remove."}, {"sha": "f5613862dcfe88ed81724f15ae90ca997fef4b6b", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 46, "deletions": 70, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ae86f5b7671f22d7fc3581c3632f92537eb539/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ae86f5b7671f22d7fc3581c3632f92537eb539/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=83ae86f5b7671f22d7fc3581c3632f92537eb539", "patch": "@@ -1070,6 +1070,31 @@ simplify_stmt_for_jump_threading (gimple stmt,\n   return lookup_avail_expr (stmt, false);\n }\n \n+static void\n+record_temporary_equivalences (edge e)\n+{\n+  int i;\n+  struct edge_info *edge_info = (struct edge_info *) e->aux;\n+\n+  /* If we have info associated with this edge, record it into\n+     our equivalence tables.  */\n+  if (edge_info)\n+    {\n+      cond_equivalence *eq;\n+      tree lhs = edge_info->lhs;\n+      tree rhs = edge_info->rhs;\n+\n+      /* If we have a simple NAME = VALUE equivalence, record it.  */\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\trecord_const_or_copy (lhs, rhs);\n+\n+      /* If we have 0 = COND or 1 = COND equivalences, record them\n+\t into our expression hash tables.  */\n+      for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n+\trecord_cond (eq);\n+    }\n+}\n+\n /* Wrapper for common code to attempt to thread an edge.  For example,\n    it handles lazily building the dummy condition and the bookkeeping\n    when jump threading is successful.  */\n@@ -1083,9 +1108,27 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n                            integer_zero_node, integer_zero_node,\n                            NULL, NULL);\n \n+  /* Push a marker on both stacks so we can unwind the tables back to their\n+     current state.  */\n+  avail_exprs_stack.safe_push (NULL);\n+  const_and_copies_stack.safe_push (NULL_TREE);\n+\n+  /* Traversing E may result in equivalences we can utilize.  */\n+  record_temporary_equivalences (e);\n+\n+  /* With all the edge equivalences in the tables, go ahead and attempt\n+     to thread through E->dest.  */\n   ::thread_across_edge (dummy_cond_, e, false,\n \t\t        &const_and_copies_stack,\n \t\t        simplify_stmt_for_jump_threading);\n+\n+  /* And restore the various tables to their state before\n+     we threaded this edge. \n+\n+     XXX The code in tree-ssa-threadedge.c will restore the state of\n+     the const_and_copies table.  We we just have to restore the expression\n+     table.  */\n+  remove_local_expressions_from_table ();\n }\n \n /* PHI nodes can create equivalences too.\n@@ -1905,9 +1948,6 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n       && (single_succ_edge (bb)->flags & EDGE_ABNORMAL) == 0\n       && potentially_threadable_block (single_succ (bb)))\n     {\n-      /* Push a marker on the stack, which thread_across_edge expects\n-\t and will remove.  */\n-      const_and_copies_stack.safe_push (NULL_TREE);\n       thread_across_edge (single_succ_edge (bb));\n     }\n   else if ((last = last_stmt (bb))\n@@ -1923,79 +1963,15 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n       /* Only try to thread the edge if it reaches a target block with\n \t more than one predecessor and more than one successor.  */\n       if (potentially_threadable_block (true_edge->dest))\n-\t{\n-\t  struct edge_info *edge_info;\n-\t  unsigned int i;\n-\n-\t  /* Push a marker onto the available expression stack so that we\n-\t     unwind any expressions related to the TRUE arm before processing\n-\t     the false arm below.  */\n-          avail_exprs_stack.safe_push (NULL);\n-\t  const_and_copies_stack.safe_push (NULL_TREE);\n-\n-\t  edge_info = (struct edge_info *) true_edge->aux;\n-\n-\t  /* If we have info associated with this edge, record it into\n-\t     our equivalence tables.  */\n-\t  if (edge_info)\n-\t    {\n-\t      cond_equivalence *eq;\n-\t      tree lhs = edge_info->lhs;\n-\t      tree rhs = edge_info->rhs;\n-\n-\t      /* If we have a simple NAME = VALUE equivalence, record it.  */\n-\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t\trecord_const_or_copy (lhs, rhs);\n-\n-\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n-\t\t into our expression hash tables.  */\n-\t      for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n-\t\trecord_cond (eq);\n-\t    }\n-\n-\t  thread_across_edge (true_edge);\n-\n-\t  /* And restore the various tables to their state before\n-\t     we threaded this edge.  */\n-\t  remove_local_expressions_from_table ();\n-\t}\n+\tthread_across_edge (true_edge);\n \n       /* Similarly for the ELSE arm.  */\n       if (potentially_threadable_block (false_edge->dest))\n-\t{\n-\t  struct edge_info *edge_info;\n-\t  unsigned int i;\n-\n-\t  const_and_copies_stack.safe_push (NULL_TREE);\n-\t  edge_info = (struct edge_info *) false_edge->aux;\n-\n-\t  /* If we have info associated with this edge, record it into\n-\t     our equivalence tables.  */\n-\t  if (edge_info)\n-\t    {\n-\t      cond_equivalence *eq;\n-\t      tree lhs = edge_info->lhs;\n-\t      tree rhs = edge_info->rhs;\n-\n-\t      /* If we have a simple NAME = VALUE equivalence, record it.  */\n-\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t\trecord_const_or_copy (lhs, rhs);\n-\n-\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n-\t\t into our expression hash tables.  */\n-\t      for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n-\t\trecord_cond (eq);\n-\t    }\n+\tthread_across_edge (false_edge);\n \n-\t  /* Now thread the edge.  */\n-\t  thread_across_edge (false_edge);\n-\n-\t  /* No need to remove local expressions from our tables\n-\t     or restore vars to their original value as that will\n-\t     be done immediately below.  */\n-\t}\n     }\n \n+  /* These remove expressions local to BB from the tables.  */\n   remove_local_expressions_from_table ();\n   restore_vars_to_original_value ();\n }"}]}