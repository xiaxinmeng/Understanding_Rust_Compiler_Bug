{"sha": "1b6c95c49fdf70bbeed275351896b734bb80950f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI2Yzk1YzQ5ZmRmNzBiYmVlZDI3NTM1MTg5NmI3MzRiYjgwOTUwZg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-08-14T08:41:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:41:15Z"}, "message": "sem_ch5.adb: Improve warnings on redundant assignments\n\n2007-08-14  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb: Improve warnings on redundant assignments\n\n\t* sem_util.ads, sem_util.adb: (Is_Variable): Add defense against junk\n\tparameter\n\t(Is_Synchronized_Tagged_Type): New subprogram that returns true\n\tin case of synchronized tagged types (AARM 3.9.4 (6/2)).\n\t(Safe_To_Capture_Value): Can now return True for constants, even if Cond\n\tis set to False. Improves handling of Known_[Not_]Null.\n\t(Wrong_Type): Special case address arithmetic attempt\n\t(Collect_Abstract_Interfaces): Add new formal to allow collecting\n\tabstract interfaces just using the partial view of private types.\n\t(Has_Abstract_Interfaces): Add new formal to allow checking types\n\tcovering interfaces using the partial view of private types.\n\t(Is_Fully_Initialized_Type): Special VM case for uTag component. This\n\tcomponent still needs to be defined in this case, but is never\n\tinitialized as VMs are using other dispatching mechanisms.\n\t(Abstract_Interface_List): For a protected type, use base type to get\n\tproper declaration.\n\tImprove warnings on redundant assignments\n\t(Is_Variable): Handle properly an implicit dereference of a prefixed\n\tfunction call.\n\t(Build_Actual_Subtype): If this is an actual subtype for an\n\tunconstrained formal parameter, use the sloc of the body for the new\n\tdeclaration, to prevent anomalises in the debugger.\n\nFrom-SVN: r127427", "tree": {"sha": "227eeff78cb66e8b799a3a6e10d95757baeed195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/227eeff78cb66e8b799a3a6e10d95757baeed195"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b6c95c49fdf70bbeed275351896b734bb80950f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b6c95c49fdf70bbeed275351896b734bb80950f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b6c95c49fdf70bbeed275351896b734bb80950f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b6c95c49fdf70bbeed275351896b734bb80950f/comments", "author": null, "committer": null, "parents": [{"sha": "dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230"}], "stats": {"total": 603, "additions": 493, "deletions": 110}, "files": [{"sha": "abc3d8231b1d6f2c906e6b48e5ee0fd2a9d70d8e", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b6c95c49fdf70bbeed275351896b734bb80950f/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b6c95c49fdf70bbeed275351896b734bb80950f/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=1b6c95c49fdf70bbeed275351896b734bb80950f", "patch": "@@ -250,7 +250,8 @@ package body Sem_Ch5 is\n    --  Start of processing for Analyze_Assignment\n \n    begin\n-      Mark_Static_Coextensions (Rhs);\n+      Mark_Coextensions (N, Rhs);\n+\n       Analyze (Rhs);\n       Analyze (Lhs);\n \n@@ -579,10 +580,10 @@ package body Sem_Ch5 is\n         and then Can_Never_Be_Null (T1)\n         and then not Assignment_OK (Lhs)\n       then\n-         if Nkind (Rhs) = N_Null then\n+         if Known_Null (Rhs) then\n             Apply_Compile_Time_Constraint_Error\n               (N   => Rhs,\n-               Msg => \"(Ada 2005) NULL not allowed in null-excluding objects?\",\n+               Msg => \"(Ada 2005) null not allowed in null-excluding objects?\",\n                Reason => CE_Null_Not_Allowed);\n             return;\n \n@@ -640,11 +641,9 @@ package body Sem_Ch5 is\n \n          and then Comes_From_Source (N)\n \n-         --  Where the entity is the same on both sides\n+         --  Where the object is the same on both sides\n \n-         and then Is_Entity_Name (Lhs)\n-         and then Is_Entity_Name (Original_Node (Rhs))\n-         and then Entity (Lhs) = Entity (Original_Node (Rhs))\n+         and then Same_Object (Lhs, Original_Node (Rhs))\n \n          --  But exclude the case where the right side was an operation\n          --  that got rewritten (e.g. JUNK + K, where K was known to be\n@@ -654,8 +653,13 @@ package body Sem_Ch5 is\n \n         and then Nkind (Original_Node (Rhs)) not in N_Op\n       then\n-         Error_Msg_NE\n-           (\"?useless assignment of & to itself\", N, Entity (Lhs));\n+         if Nkind (Lhs) in N_Has_Entity then\n+            Error_Msg_NE\n+              (\"?useless assignment of & to itself!\", N, Entity (Lhs));\n+         else\n+            Error_Msg_N\n+              (\"?useless assignment of object to itself!\", N);\n+         end if;\n       end if;\n \n       --  Check for non-allowed composite assignment\n@@ -1071,7 +1075,6 @@ package body Sem_Ch5 is\n \n          begin\n             Alt := First (Alternatives (N));\n-\n             while Present (Alt) loop\n                if Alt /= Chosen then\n                   Remove_Warning_Messages (Statements (Alt));\n@@ -1341,7 +1344,6 @@ package body Sem_Ch5 is\n \n             if Present (Elsif_Parts (N)) then\n                E := First (Elsif_Parts (N));\n-\n                while Present (E) loop\n                   Remove_Warning_Messages (Then_Statements (E));\n                   Next (E);\n@@ -2035,7 +2037,7 @@ package body Sem_Ch5 is\n                --  the Ada RM annoyingly requires a useless return here!\n \n                if Nkind (Original_Node (N)) /= N_Raise_Statement\n-                 or else Nkind (Nxt) /= N_Return_Statement\n+                 or else Nkind (Nxt) /= N_Simple_Return_Statement\n                then\n                   --  The rather strange shenanigans with the warning message\n                   --  here reflects the fact that Kill_Dead_Code is very good\n@@ -2077,7 +2079,7 @@ package body Sem_Ch5 is\n \n                   --  Now issue the warning\n \n-                  Error_Msg (\"?unreachable code\", Error_Loc);\n+                  Error_Msg (\"?unreachable code!\", Error_Loc);\n                end if;\n \n             --  If the unconditional transfer of control instruction is"}, {"sha": "04fe93c4ae15bc269fc149ad7f9772a61adf3e02", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 404, "deletions": 76, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b6c95c49fdf70bbeed275351896b734bb80950f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b6c95c49fdf70bbeed275351896b734bb80950f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1b6c95c49fdf70bbeed275351896b734bb80950f", "patch": "@@ -37,7 +37,6 @@ with Freeze;   use Freeze;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n with Output;   use Output;\n with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n@@ -63,6 +62,8 @@ with Uname;    use Uname;\n \n package body Sem_Util is\n \n+   use Nmake;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -94,7 +95,13 @@ package body Sem_Util is\n \n    begin\n       if Is_Concurrent_Type (Typ) then\n-         Nod := Parent (Typ);\n+\n+         --  If we are dealing with a synchronized subtype, go to the base\n+         --  type, whose declaration has the interface list.\n+\n+         --  Shouldn't this be Declaration_Node???\n+\n+         Nod := Parent (Base_Type (Typ));\n \n       elsif Ekind (Typ) = E_Record_Type_With_Private then\n          if Nkind (Parent (Typ)) = N_Full_Type_Declaration then\n@@ -245,7 +252,9 @@ package body Sem_Util is\n      (T : Entity_Id;\n       N : Node_Or_Entity_Id) return Node_Id\n    is\n-      Loc         : constant Source_Ptr := Sloc (N);\n+      Loc : Source_Ptr;\n+      --  Normally Sloc (N), but may point to corresponding body in some cases\n+\n       Constraints : List_Id;\n       Decl        : Node_Id;\n       Discr       : Entity_Id;\n@@ -256,8 +265,28 @@ package body Sem_Util is\n       Obj         : Node_Id;\n \n    begin\n+      Loc := Sloc (N);\n+\n       if Nkind (N) = N_Defining_Identifier then\n          Obj := New_Reference_To (N, Loc);\n+\n+         --  If this is a formal parameter of a subprogram declaration, and\n+         --  we are compiling the body, we want the declaration for the\n+         --  actual subtype to carry the source position of the body, to\n+         --  prevent anomalies in gdb when stepping through the code.\n+\n+         if Is_Formal (N) then\n+            declare\n+               Decl : constant Node_Id := Unit_Declaration_Node (Scope (N));\n+            begin\n+               if Nkind (Decl) = N_Subprogram_Declaration\n+                 and then Present (Corresponding_Body (Decl))\n+               then\n+                  Loc := Sloc (Corresponding_Body (Decl));\n+               end if;\n+            end;\n+         end if;\n+\n       else\n          Obj := N;\n       end if;\n@@ -1082,7 +1111,8 @@ package body Sem_Util is\n    procedure Collect_Abstract_Interfaces\n      (T                         : Entity_Id;\n       Ifaces_List               : out Elist_Id;\n-      Exclude_Parent_Interfaces : Boolean := False)\n+      Exclude_Parent_Interfaces : Boolean := False;\n+      Use_Full_View             : Boolean := True)\n    is\n       procedure Add_Interface (Iface : Entity_Id);\n       --  Add the interface it if is not already in the list\n@@ -1121,20 +1151,34 @@ package body Sem_Util is\n       -------------\n \n       procedure Collect (Typ : Entity_Id) is\n-         Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n          Ancestor   : Entity_Id;\n+         Full_T     : Entity_Id;\n+         Iface_List : List_Id;\n          Id         : Node_Id;\n          Iface      : Entity_Id;\n \n       begin\n+         Full_T := Typ;\n+\n+         --  Handle private types\n+\n+         if Use_Full_View\n+           and then Is_Private_Type (Typ)\n+           and then Present (Full_View (Typ))\n+         then\n+            Full_T := Full_View (Typ);\n+         end if;\n+\n+         Iface_List := Abstract_Interface_List (Full_T);\n+\n          --  Include the ancestor if we are generating the whole list of\n          --  abstract interfaces.\n \n          --  In concurrent types the ancestor interface (if any) is the\n          --  first element of the list of interface types.\n \n-         if Is_Concurrent_Type (Typ)\n-           or else Is_Concurrent_Record_Type (Typ)\n+         if Is_Concurrent_Type (Full_T)\n+           or else Is_Concurrent_Record_Type (Full_T)\n          then\n             if Is_Non_Empty_List (Iface_List) then\n                Ancestor := Etype (First (Iface_List));\n@@ -1145,7 +1189,7 @@ package body Sem_Util is\n                end if;\n             end if;\n \n-         elsif Etype (Typ) /= Typ\n+         elsif Etype (Full_T) /= Typ\n \n             --  Protect the frontend against wrong sources. For example:\n \n@@ -1158,9 +1202,9 @@ package body Sem_Util is\n             --      type C is new B with null record;\n             --    end P;\n \n-           and then Etype (Typ) /= T\n+           and then Etype (Full_T) /= T\n          then\n-            Ancestor := Etype (Typ);\n+            Ancestor := Etype (Full_T);\n             Collect (Ancestor);\n \n             if Is_Interface (Ancestor)\n@@ -1179,8 +1223,8 @@ package body Sem_Util is\n             --  first element of the list of interface types and we have\n             --  already processed them while climbing to the root type.\n \n-            if Is_Concurrent_Type (Typ)\n-              or else Is_Concurrent_Record_Type (Typ)\n+            if Is_Concurrent_Type (Full_T)\n+              or else Is_Concurrent_Record_Type (Full_T)\n             then\n                Next (Id);\n             end if;\n@@ -1303,6 +1347,94 @@ package body Sem_Util is\n       Collect (Tagged_Type);\n    end Collect_Interface_Components;\n \n+   -----------------------------\n+   -- Collect_Interfaces_Info --\n+   -----------------------------\n+\n+   procedure Collect_Interfaces_Info\n+     (T               : Entity_Id;\n+      Ifaces_List     : out Elist_Id;\n+      Components_List : out Elist_Id;\n+      Tags_List       : out Elist_Id)\n+   is\n+      Comps_List : Elist_Id;\n+      Comp_Elmt  : Elmt_Id;\n+      Comp_Iface : Entity_Id;\n+      Iface_Elmt : Elmt_Id;\n+      Iface      : Entity_Id;\n+\n+      function Search_Tag (Iface : Entity_Id) return Entity_Id;\n+      --  Search for the secondary tag associated with the interface type\n+      --  Iface that is implemented by T.\n+\n+      ----------------\n+      -- Search_Tag --\n+      ----------------\n+\n+      function Search_Tag (Iface : Entity_Id) return Entity_Id is\n+         ADT : Elmt_Id;\n+\n+      begin\n+         ADT := Next_Elmt (First_Elmt (Access_Disp_Table (T)));\n+         while Present (ADT)\n+            and then Ekind (Node (ADT)) = E_Constant\n+            and then Related_Interface (Node (ADT)) /= Iface\n+         loop\n+            Next_Elmt (ADT);\n+         end loop;\n+\n+         pragma Assert (Ekind (Node (ADT)) = E_Constant);\n+         return Node (ADT);\n+      end Search_Tag;\n+\n+   --  Start of processing for Collect_Interfaces_Info\n+\n+   begin\n+      Collect_Abstract_Interfaces  (T, Ifaces_List);\n+      Collect_Interface_Components (T, Comps_List);\n+\n+      --  Search for the record component and tag associated with each\n+      --  interface type of T.\n+\n+      Components_List := New_Elmt_List;\n+      Tags_List       := New_Elmt_List;\n+\n+      Iface_Elmt := First_Elmt (Ifaces_List);\n+      while Present (Iface_Elmt) loop\n+         Iface := Node (Iface_Elmt);\n+\n+         --  Associate the primary tag component and the primary dispatch table\n+         --  with all the interfaces that are parents of T\n+\n+         if Is_Parent (Iface, T) then\n+            Append_Elmt (First_Tag_Component (T), Components_List);\n+            Append_Elmt (Node (First_Elmt (Access_Disp_Table (T))), Tags_List);\n+\n+         --  Otherwise search for the tag component and secondary dispatch\n+         --  table of Iface\n+\n+         else\n+            Comp_Elmt := First_Elmt (Comps_List);\n+            while Present (Comp_Elmt) loop\n+               Comp_Iface := Related_Interface (Node (Comp_Elmt));\n+\n+               if Comp_Iface = Iface\n+                 or else Is_Parent (Iface, Comp_Iface)\n+               then\n+                  Append_Elmt (Node (Comp_Elmt), Components_List);\n+                  Append_Elmt (Search_Tag (Comp_Iface), Tags_List);\n+                  exit;\n+               end if;\n+\n+               Next_Elmt (Comp_Elmt);\n+            end loop;\n+            pragma Assert (Present (Comp_Elmt));\n+         end if;\n+\n+         Next_Elmt (Iface_Elmt);\n+      end loop;\n+   end Collect_Interfaces_Info;\n+\n    ----------------------------------\n    -- Collect_Primitive_Operations --\n    ----------------------------------\n@@ -1449,6 +1581,8 @@ package body Sem_Util is\n       Warn : Boolean    := False) return Node_Id\n    is\n       Msgc : String (1 .. Msg'Length + 2);\n+      --  Copy of message, with room for possible ? and ! at end\n+\n       Msgl : Natural;\n       Wmsg : Boolean;\n       P    : Node_Id;\n@@ -1471,11 +1605,8 @@ package body Sem_Util is\n             Eloc := Sloc (N);\n          end if;\n \n-         --  Make all such messages unconditional\n-\n          Msgc (1 .. Msg'Length) := Msg;\n-         Msgc (Msg'Length + 1) := '!';\n-         Msgl := Msg'Length + 1;\n+         Msgl := Msg'Length;\n \n          --  Message is a warning, even in Ada 95 case\n \n@@ -1499,9 +1630,15 @@ package body Sem_Util is\n             Wmsg := True;\n \n          --  Otherwise we have a real error message (Ada 95 static case)\n+         --  and we make this an unconditional message. Note that in the\n+         --  warning case we do not make the message unconditional, it seems\n+         --  quite reasonable to delete messages like this (about exceptions\n+         --  that will be raised) in dead code.\n \n          else\n             Wmsg := False;\n+            Msgl := Msgl + 1;\n+            Msgc (Msgl) := '!';\n          end if;\n \n          --  Should we generate a warning? The answer is not quite yes. The\n@@ -2549,7 +2686,7 @@ package body Sem_Util is\n      (Def_Id      : Entity_Id;\n       First_Hom   : Entity_Id;\n       Ifaces_List : Elist_Id;\n-      In_Scope    : Boolean := True) return Entity_Id\n+      In_Scope    : Boolean) return Entity_Id\n    is\n       Candidate : Entity_Id := Empty;\n       Hom       : Entity_Id := Empty;\n@@ -2823,7 +2960,7 @@ package body Sem_Util is\n \n       --  After examining all candidates for overriding, we are left with\n       --  the best match which is a mode incompatible interface routine.\n-      --  Do not emit an error of the Expander is active since this error\n+      --  Do not emit an error if the Expander is active since this error\n       --  will be detected later on after all concurrent types are expanded\n       --  and all wrappers are built. This check is meant for spec-only\n       --  compilations.\n@@ -2833,23 +2970,26 @@ package body Sem_Util is\n       then\n          Iface_Typ := Find_Parameter_Type (Parent (First_Formal (Candidate)));\n \n-         --  Def_Id is primitive of a protected type, the candidate is\n-         --  primitive of a limited or synchronized interface.\n+         --  Def_Id is primitive of a protected type, declared inside the type,\n+         --  and the candidate is primitive of a limited or synchronized\n+         --  interface.\n \n-         if Is_Protected_Type (Tag_Typ)\n+         if In_Scope\n+           and then Is_Protected_Type (Tag_Typ)\n            and then\n              (Is_Limited_Interface (Iface_Typ)\n                 or else Is_Protected_Interface (Iface_Typ)\n                 or else Is_Synchronized_Interface (Iface_Typ)\n                 or else Is_Task_Interface (Iface_Typ))\n          then\n+            --  Must reword this message, comma before to in -gnatj mode ???\n+\n             Error_Msg_NE\n               (\"first formal of & must be of mode `OUT`, `IN OUT` or \" &\n                \"access-to-variable\", Tag_Typ, Candidate);\n-\n             Error_Msg_N\n               (\"\\to be overridden by protected procedure or entry \" &\n-               \"(`R`M 9.4(11))\", Tag_Typ);\n+               \"(RM 9.4(11.9/2))\", Tag_Typ);\n          end if;\n       end if;\n \n@@ -3630,7 +3770,10 @@ package body Sem_Util is\n    -- Has_Abstract_Interfaces --\n    -----------------------------\n \n-   function Has_Abstract_Interfaces (Tagged_Type : Entity_Id) return Boolean is\n+   function Has_Abstract_Interfaces\n+     (Tagged_Type   : Entity_Id;\n+      Use_Full_View : Boolean := True) return Boolean\n+   is\n       Typ : Entity_Id;\n \n    begin\n@@ -3645,19 +3788,22 @@ package body Sem_Util is\n          return True;\n       end if;\n \n+      Typ := Tagged_Type;\n+\n       --  Handle private types\n \n-      if Present (Full_View (Tagged_Type)) then\n+      if Use_Full_View\n+        and then Present (Full_View (Tagged_Type))\n+      then\n          Typ := Full_View (Tagged_Type);\n-      else\n-         Typ := Tagged_Type;\n       end if;\n \n       loop\n          if Is_Interface (Typ)\n-           or else (Present (Abstract_Interfaces (Typ))\n-                      and then\n-                        not Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n+           or else\n+             (Is_Record_Type (Typ)\n+               and then Present (Abstract_Interfaces (Typ))\n+               and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n          then\n             return True;\n          end if;\n@@ -4276,7 +4422,7 @@ package body Sem_Util is\n                   --  Or if expression obeys rules for preelaboration. For\n                   --  now we approximate this by testing if the default\n                   --  expression is a static expression or if it is an\n-                  --  access attribute reference.\n+                  --  access attribute reference, or the literal null.\n \n                   --  This is an approximation, it is probably incomplete???\n \n@@ -4292,6 +4438,9 @@ package body Sem_Util is\n                then\n                   null;\n \n+               elsif Nkind (Exp) = N_Null then\n+                  null;\n+\n                else\n                   Has_PE := False;\n                   exit;\n@@ -5020,7 +5169,7 @@ package body Sem_Util is\n          --  Anonymous access discriminants carry a list of all nested\n          --  controlled coextensions.\n \n-          and then not Is_Coextension (N)\n+          and then not Is_Dynamic_Coextension (N)\n           and then not Is_Static_Coextension (N);\n    end Is_Coextension_Root;\n \n@@ -5361,7 +5510,7 @@ package body Sem_Util is\n                         Indx_Typ := Full_View (Indx_Typ);\n                      end if;\n \n-                     if No (Indx_Typ) then\n+                     if No (Indx_Typ) or else Etype (Indx_Typ) = Any_Type then\n                         return False;\n                      else\n                         Lbd := Type_Low_Bound  (Indx_Typ);\n@@ -5449,6 +5598,14 @@ package body Sem_Util is\n                  and then (No (Parent (Ent))\n                              or else No (Expression (Parent (Ent))))\n                  and then not Is_Fully_Initialized_Type (Etype (Ent))\n+\n+                  --  Special VM case for uTag component, which needs to be\n+                  --  defined in this case, but is never initialized as VMs\n+                  --  are using other dispatching mechanisms. Ignore this\n+                  --  uninitialized case.\n+\n+                 and then (VM_Target = No_VM\n+                            or else Chars (Ent) /= Name_uTag)\n                then\n                   return False;\n                end if;\n@@ -5593,10 +5750,10 @@ package body Sem_Util is\n \n    function Is_Library_Level_Entity (E : Entity_Id) return Boolean is\n    begin\n-      --  The following is a small optimization, and it also handles\n-      --  properly discriminals, which in task bodies might appear in\n-      --  expressions before the corresponding procedure has been\n-      --  created, and which therefore do not have an assigned scope.\n+      --  The following is a small optimization, and it also properly handles\n+      --  discriminals, which in task bodies might appear in expressions before\n+      --  the corresponding procedure has been created, and which therefore do\n+      --  not have an assigned scope.\n \n       if Ekind (E) in Formal_Kind then\n          return False;\n@@ -5640,7 +5797,7 @@ package body Sem_Util is\n    function Is_Object_Reference (N : Node_Id) return Boolean is\n    begin\n       if Is_Entity_Name (N) then\n-         return Is_Object (Entity (N));\n+         return Present (Entity (N)) and then Is_Object (Entity (N));\n \n       else\n          case Nkind (N) is\n@@ -6233,6 +6390,31 @@ package body Sem_Util is\n           or else Nkind (N) = N_Procedure_Call_Statement;\n    end Is_Statement;\n \n+   ---------------------------------\n+   -- Is_Synchronized_Tagged_Type --\n+   ---------------------------------\n+\n+   function Is_Synchronized_Tagged_Type (E : Entity_Id) return Boolean is\n+      Kind : constant Entity_Kind := Ekind (Base_Type (E));\n+\n+   begin\n+      --  A task or protected type derived from an interface is a tagged type.\n+      --  Such a tagged type is called a synchronized tagged type, as are\n+      --  synchronized interfaces and private extensions whose declaration\n+      --  includes the reserved word synchronized.\n+\n+      return (Is_Tagged_Type (E)\n+                and then (Kind = E_Task_Type\n+                           or else Kind = E_Protected_Type))\n+            or else\n+             (Is_Interface (E)\n+                and then Is_Synchronized_Interface (E))\n+            or else\n+             (Ekind (E) = E_Record_Type_With_Private\n+                and then (Synchronized_Present (Parent (E))\n+                           or else Is_Synchronized_Interface (Etype (E))));\n+   end Is_Synchronized_Tagged_Type;\n+\n    -----------------\n    -- Is_Transfer --\n    -----------------\n@@ -6241,7 +6423,7 @@ package body Sem_Util is\n       Kind : constant Node_Kind := Nkind (N);\n \n    begin\n-      if Kind = N_Return_Statement\n+      if Kind = N_Simple_Return_Statement\n            or else\n          Kind = N_Extended_Return_Statement\n            or else\n@@ -6384,12 +6566,19 @@ package body Sem_Util is\n       --  variable, even though the original node may not be (since it could\n       --  be a constant of the access type).\n \n+      --  In Ada 2005 we have a further case to consider: the prefix may be\n+      --  a function call given in prefix notation. The original node appears\n+      --  to be a selected component, but we need to examine the call.\n+\n       elsif Nkind (N) = N_Explicit_Dereference\n         and then Nkind (Orig_Node) /= N_Explicit_Dereference\n         and then Present (Etype (Orig_Node))\n         and then Is_Access_Type (Etype (Orig_Node))\n       then\n-         return Is_Variable_Prefix (Original_Node (Prefix (N)));\n+         return Is_Variable_Prefix (Original_Node (Prefix (N)))\n+           or else\n+             (Nkind (Orig_Node) = N_Function_Call\n+               and then not Is_Access_Constant (Etype (Prefix (N))));\n \n       --  A function call is never a variable\n \n@@ -6398,7 +6587,9 @@ package body Sem_Util is\n \n       --  All remaining checks use the original node\n \n-      elsif Is_Entity_Name (Orig_Node) then\n+      elsif Is_Entity_Name (Orig_Node)\n+        and then Present (Entity (Orig_Node))\n+      then\n          declare\n             E : constant Entity_Id := Entity (Orig_Node);\n             K : constant Entity_Kind := Ekind (E);\n@@ -6782,7 +6973,7 @@ package body Sem_Util is\n \n          when N_Attribute_Reference =>\n             return N = Prefix (P)\n-              and then Name_Modifies_Prefix (Attribute_Name (P));\n+              and then Name_Implies_Lvalue_Prefix (Attribute_Name (P));\n \n          when N_Expanded_Name        |\n               N_Explicit_Dereference |\n@@ -6897,13 +7088,15 @@ package body Sem_Util is\n       end case;\n    end May_Be_Lvalue;\n \n-   ------------------------------\n-   -- Mark_Static_Coextensions --\n-   ------------------------------\n+   -----------------------\n+   -- Mark_Coextensions --\n+   -----------------------\n+\n+   procedure Mark_Coextensions (Context_Nod : Node_Id; Root_Nod : Node_Id) is\n+      Is_Dynamic : Boolean := False;\n \n-   procedure Mark_Static_Coextensions (Root_Node : Node_Id) is\n       function Mark_Allocator (N : Node_Id) return Traverse_Result;\n-      --  Recognize an allocator node and label it as a static coextension\n+      --  Recognize an allocator node and label it as a dynamic coextension\n \n       --------------------\n       -- Mark_Allocator --\n@@ -6912,24 +7105,38 @@ package body Sem_Util is\n       function Mark_Allocator (N : Node_Id) return Traverse_Result is\n       begin\n          if Nkind (N) = N_Allocator then\n-            Set_Is_Static_Coextension (N);\n+            if Is_Dynamic then\n+               Set_Is_Dynamic_Coextension (N);\n+            else\n+               Set_Is_Static_Coextension (N);\n+            end if;\n          end if;\n \n          return OK;\n       end Mark_Allocator;\n \n       procedure Mark_Allocators is new Traverse_Proc (Mark_Allocator);\n \n-   --  Start of processing for Mark_Static_Coextensions\n+   --  Start of processing Mark_Coextensions\n \n    begin\n-      --  Do not mark allocators that stem from an initial allocator because\n-      --  these will never be static.\n+      case Nkind (Context_Nod) is\n+         when N_Assignment_Statement    |\n+              N_Simple_Return_Statement =>\n+            Is_Dynamic := Nkind (Expression (Context_Nod)) = N_Allocator;\n \n-      if Nkind (Root_Node) /= N_Allocator then\n-         Mark_Allocators (Root_Node);\n-      end if;\n-   end Mark_Static_Coextensions;\n+         when N_Object_Declaration =>\n+            Is_Dynamic := Nkind (Root_Nod) = N_Allocator;\n+\n+         --  This routine should not be called for constructs which may not\n+         --  contain coextensions.\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+      Mark_Allocators (Root_Nod);\n+   end Mark_Coextensions;\n \n    ----------------------\n    -- Needs_One_Actual --\n@@ -7082,7 +7289,7 @@ package body Sem_Util is\n       Success : out Boolean)\n    is\n       Actuals     : constant List_Id := Parameter_Associations (N);\n-      Actual      : Node_Id   := Empty;\n+      Actual      : Node_Id := Empty;\n       Formal      : Entity_Id;\n       Last        : Node_Id := Empty;\n       First_Named : Node_Id := Empty;\n@@ -8089,26 +8296,30 @@ package body Sem_Util is\n       Cond : Boolean := False) return Boolean\n    is\n    begin\n-      --  The only entities for which we track constant values are variables,\n-      --  which are not renamings, out parameters and in out parameters, so\n-      --  check if we have this case.\n+      --  The only entities for which we track constant values are variables\n+      --  which are not renamings, constants, out parameters, and in out\n+      --  parameters, so check if we have this case.\n+\n+      --  Note: it may seem odd to track constant values for constants, but in\n+      --  fact this routine is used for other purposes than simply capturing\n+      --  the value. In particular, the setting of Known[_Non]_Null.\n \n       if (Ekind (Ent) = E_Variable and then No (Renamed_Object (Ent)))\n-           or else\n-         Ekind (Ent) = E_Out_Parameter\n-           or else\n-         Ekind (Ent) = E_In_Out_Parameter\n+            or else\n+          Ekind (Ent) = E_Constant\n+            or else\n+          Ekind (Ent) = E_Out_Parameter\n+            or else\n+          Ekind (Ent) = E_In_Out_Parameter\n       then\n          null;\n \n-      --  For conditionals, we also allow constants, loop parameters and all\n-      --  formals, including in parameters.\n+      --  For conditionals, we also allow loop parameters and all formals,\n+      --  including in parameters.\n \n       elsif Cond\n         and then\n-          (Ekind (Ent) = E_Constant\n-             or else\n-           Ekind (Ent) = E_Loop_Parameter\n+          (Ekind (Ent) = E_Loop_Parameter\n              or else\n            Ekind (Ent) = E_In_Parameter)\n       then\n@@ -8122,10 +8333,9 @@ package body Sem_Util is\n          return False;\n       end if;\n \n-      --  Skip volatile and aliased variables, since funny things might\n-      --  be going on in these cases which we cannot necessarily track.\n-      --  Also skip any variable for which an address clause is given,\n-      --  or whose address is taken\n+      --  Skip if volatile or aliased, since funny things might be going on in\n+      --  these cases which we cannot necessarily track. Also skip any variable\n+      --  for which an address clause is given, or whose address is taken.\n \n       if Treat_As_Volatile (Ent)\n         or else Is_Aliased (Ent)\n@@ -8135,9 +8345,9 @@ package body Sem_Util is\n          return False;\n       end if;\n \n-      --  OK, all above conditions are met. We also require that the scope\n-      --  of the reference be the same as the scope of the entity, not\n-      --  counting packages and blocks and loops.\n+      --  OK, all above conditions are met. We also require that the scope of\n+      --  the reference be the same as the scope of the entity, not counting\n+      --  packages and blocks and loops.\n \n       declare\n          E_Scope : constant Entity_Id := Scope (Ent);\n@@ -8227,6 +8437,84 @@ package body Sem_Util is\n       end if;\n    end Same_Name;\n \n+   -----------------\n+   -- Same_Object --\n+   -----------------\n+\n+   function Same_Object (Node1, Node2 : Node_Id) return Boolean is\n+      N1 : constant Node_Id := Original_Node (Node1);\n+      N2 : constant Node_Id := Original_Node (Node2);\n+      --  We do the tests on original nodes, since we are most interested\n+      --  in the original source, not any expansion that got in the way.\n+\n+      K1 : constant Node_Kind := Nkind (N1);\n+      K2 : constant Node_Kind := Nkind (N2);\n+\n+   begin\n+      --  First case, both are entities with same entity\n+\n+      if K1 in N_Has_Entity\n+        and then K2 in N_Has_Entity\n+        and then Present (Entity (N1))\n+        and then Present (Entity (N2))\n+        and then (Ekind (Entity (N1)) = E_Variable\n+                    or else\n+                  Ekind (Entity (N1)) = E_Constant)\n+        and then Entity (N1) = Entity (N2)\n+      then\n+         return True;\n+\n+      --  Second case, selected component with same selector, same record\n+\n+      elsif K1 = N_Selected_Component\n+        and then K2 = N_Selected_Component\n+        and then Chars (Selector_Name (N1)) = Chars (Selector_Name (N2))\n+      then\n+         return Same_Object (Prefix (N1), Prefix (N2));\n+\n+      --  Third case, indexed component with same subscripts, same array\n+\n+      elsif K1 = N_Indexed_Component\n+        and then K2 = N_Indexed_Component\n+        and then Same_Object (Prefix (N1), Prefix (N2))\n+      then\n+         declare\n+            E1, E2 : Node_Id;\n+         begin\n+            E1 := First (Expressions (N1));\n+            E2 := First (Expressions (N2));\n+            while Present (E1) loop\n+               if not Same_Value (E1, E2) then\n+                  return False;\n+               else\n+                  Next (E1);\n+                  Next (E2);\n+               end if;\n+            end loop;\n+\n+            return True;\n+         end;\n+\n+      --  Fourth case, slice of same array with same bounds\n+\n+      elsif K1 = N_Slice\n+        and then K2 = N_Slice\n+        and then Nkind (Discrete_Range (N1)) = N_Range\n+        and then Nkind (Discrete_Range (N2)) = N_Range\n+        and then Same_Value (Low_Bound (Discrete_Range (N1)),\n+                             Low_Bound (Discrete_Range (N2)))\n+        and then Same_Value (High_Bound (Discrete_Range (N1)),\n+                             High_Bound (Discrete_Range (N2)))\n+      then\n+         return Same_Name (Prefix (N1), Prefix (N2));\n+\n+      --  All other cases, not clearly the same object\n+\n+      else\n+         return False;\n+      end if;\n+   end Same_Object;\n+\n    ---------------\n    -- Same_Type --\n    ---------------\n@@ -8251,6 +8539,24 @@ package body Sem_Util is\n       end if;\n    end Same_Type;\n \n+   ----------------\n+   -- Same_Value --\n+   ----------------\n+\n+   function Same_Value (Node1, Node2 : Node_Id) return Boolean is\n+   begin\n+      if Compile_Time_Known_Value (Node1)\n+        and then Compile_Time_Known_Value (Node2)\n+        and then Expr_Value (Node1) = Expr_Value (Node2)\n+      then\n+         return True;\n+      elsif Same_Object (Node1, Node2) then\n+         return True;\n+      else\n+         return False;\n+      end if;\n+   end Same_Value;\n+\n    ------------------------\n    -- Scope_Is_Transient --\n    ------------------------\n@@ -8886,7 +9192,6 @@ package body Sem_Util is\n       --  There is no simple way to insure that it is consistent ???\n \n       elsif In_Instance then\n-\n          if Etype (Etype (Expr)) = Etype (Expected_Type)\n            and then\n              (Has_Private_Declaration (Expected_Type)\n@@ -8924,6 +9229,29 @@ package body Sem_Util is\n          Error_Msg_N (\"result must be general access type!\", Expr);\n          Error_Msg_NE (\"add ALL to }!\", Expr, Expec_Type);\n \n+      --  Another special check, if the expected type is an integer type,\n+      --  but the expression is of type System.Address, and the parent is\n+      --  an addition or subtraction operation whose left operand is the\n+      --  expression in question and whose right operand is of an integral\n+      --  type, then this is an attempt at address arithmetic, so give\n+      --  appropriate message.\n+\n+      elsif Is_Integer_Type (Expec_Type)\n+        and then Is_RTE (Found_Type, RE_Address)\n+        and then (Nkind (Parent (Expr)) = N_Op_Add\n+                    or else\n+                  Nkind (Parent (Expr)) = N_Op_Subtract)\n+        and then Expr = Left_Opnd (Parent (Expr))\n+        and then Is_Integer_Type (Etype (Right_Opnd (Parent (Expr))))\n+      then\n+         Error_Msg_N\n+           (\"address arithmetic not predefined in package System\",\n+            Parent (Expr));\n+         Error_Msg_N\n+           (\"\\possible missing with/use of System.Storage_Elements\",\n+            Parent (Expr));\n+         return;\n+\n       --  If the expected type is an anonymous access type, as for access\n       --  parameters and discriminants, the error is on the designated types.\n "}, {"sha": "42cd17ddb6f58da42de633452da088b8d4e670ec", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 74, "deletions": 21, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b6c95c49fdf70bbeed275351896b734bb80950f/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b6c95c49fdf70bbeed275351896b734bb80950f/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=1b6c95c49fdf70bbeed275351896b734bb80950f", "patch": "@@ -28,6 +28,7 @@\n \n with Einfo;  use Einfo;\n with Namet;  use Namet;\n+with Nmake;\n with Types;  use Types;\n with Uintp;  use Uintp;\n with Urealp; use Urealp;\n@@ -147,17 +148,31 @@ package Sem_Util is\n    procedure Collect_Abstract_Interfaces\n      (T                         : Entity_Id;\n       Ifaces_List               : out Elist_Id;\n-      Exclude_Parent_Interfaces : Boolean := False);\n+      Exclude_Parent_Interfaces : Boolean := False;\n+      Use_Full_View             : Boolean := True);\n    --  Ada 2005 (AI-251): Collect whole list of abstract interfaces that are\n    --  directly or indirectly implemented by T. Exclude_Parent_Interfaces is\n    --  used to avoid addition of inherited interfaces to the generated list.\n+   --  Use_Full_View is used to collect the interfaces using the full-view\n+   --  (if available).\n \n    procedure Collect_Interface_Components\n      (Tagged_Type     : Entity_Id;\n       Components_List : out Elist_Id);\n    --  Ada 2005 (AI-251): Collect all the tag components associated with the\n    --  secondary dispatch tables of a tagged type.\n \n+   procedure Collect_Interfaces_Info\n+     (T               : Entity_Id;\n+      Ifaces_List     : out Elist_Id;\n+      Components_List : out Elist_Id;\n+      Tags_List       : out Elist_Id);\n+   --  Ada 2005 (AI-251): Collect all the interfaces associated with T plus\n+   --  the record component and tag associated with each of these interfaces.\n+   --  On exit Ifaces_List, Components_List and Tags_List have the same number\n+   --  of elements, and elements at the same position on these tables provide\n+   --  information on the same interface type.\n+\n    function Collect_Primitive_Operations (T : Entity_Id) return Elist_Id;\n    --  Called upon type derivation and extension. We scan the declarative\n    --  part in  which the type appears, and collect subprograms that have\n@@ -282,7 +297,7 @@ package Sem_Util is\n      (Def_Id      : Entity_Id;\n       First_Hom   : Entity_Id;\n       Ifaces_List : Elist_Id;\n-      In_Scope    : Boolean := True) return Entity_Id;\n+      In_Scope    : Boolean) return Entity_Id;\n    --  Determine whether entry or subprogram Def_Id overrides a primitive\n    --  operation that belongs to one of the interfaces in Ifaces_List. A\n    --  specific homonym chain can be specified by setting First_Hom. Flag\n@@ -443,8 +458,12 @@ package Sem_Util is\n    --  Result of Has_Compatible_Alignment test, description found below. Note\n    --  that the values are arranged in increasing order of problematicness.\n \n-   function Has_Abstract_Interfaces (Tagged_Type : Entity_Id) return Boolean;\n-   --  Returns true if Tagged_Type implements some abstract interface\n+   function Has_Abstract_Interfaces\n+     (Tagged_Type   : Entity_Id;\n+      Use_Full_View : Boolean := True) return Boolean;\n+   --  Returns true if Tagged_Type implements some abstract interface. In case\n+   --  private types the argument Use_Full_View controls if the check is done\n+   --  using its full view (if available).\n \n    function Has_Compatible_Alignment\n      (Obj  : Entity_Id;\n@@ -689,6 +708,9 @@ package Sem_Util is\n    --  the N_Statement_Other_Than_Procedure_Call subtype from Sinfo).\n    --  Note that a label is *not* a statement, and will return False.\n \n+   function Is_Synchronized_Tagged_Type (E : Entity_Id) return Boolean;\n+   --  Returns True if E is a synchronized tagged type (AARM 3.9.4 (6/2))\n+\n    function Is_Transfer (N : Node_Id) return Boolean;\n    --  Returns True if the node N is a statement which is known to cause\n    --  an unconditional transfer of control at runtime, i.e. the following\n@@ -723,17 +745,16 @@ package Sem_Util is\n    procedure Kill_Current_Values;\n    --  This procedure is called to clear all constant indications from all\n    --  entities in the current scope and in any parent scopes if the current\n-   --  scope is a block or a package (and that recursion continues to the\n-   --  top scope that is not a block or a package). This is used when the\n-   --  sequential flow-of-control assumption is violated (occurence of a\n-   --  label, head of a loop, or start of an exception handler). The effect\n-   --  of the call is to clear the Constant_Value field (but we do not need\n-   --  to clear the Is_True_Constant flag, since that only gets reset if\n-   --  there really is an assignment somewhere in the entity scope). This\n-   --  procedure also calls Kill_All_Checks, since this is a special case\n-   --  of needing to forget saved values. This procedure also clears any\n-   --  Is_Known_Non_Null flags in variables, constants or parameters\n-   --  since these are also not known to be valid.\n+   --  scope is a block or a package (and that recursion continues to the top\n+   --  scope that is not a block or a package). This is used when the\n+   --  sequential flow-of-control assumption is violated (occurence of a label,\n+   --  head of a loop, or start of an exception handler). The effect of the\n+   --  call is to clear the Constant_Value field (but we do not need to clear\n+   --  the Is_True_Constant flag, since that only gets reset if there really is\n+   --  an assignment somewhere in the entity scope). This procedure also calls\n+   --  Kill_All_Checks, since this is a special case of needing to forget saved\n+   --  values. This procedure also clears Is_Known_Non_Null flags in variables,\n+   --  constants or parameters since these are also not known to be valid.\n \n    procedure Kill_Current_Values (Ent : Entity_Id);\n    --  This performs the same processing as described above for the form with\n@@ -753,10 +774,27 @@ package Sem_Util is\n    --  direction. Cases which may possibly be assignments but are not known to\n    --  be may return True from May_Be_Lvalue, but False from this function.\n \n-   procedure Mark_Static_Coextensions (Root_Node : Node_Id);\n-   --  Perform a tree traversal starting from Root_Node while marking every\n-   --  allocator as a static coextension. Cleanup for this action is performed\n-   --  in Resolve_Allocator.\n+   function Make_Simple_Return_Statement\n+     (Sloc       : Source_Ptr;\n+      Expression : Node_Id := Empty) return Node_Id\n+     renames Nmake.Make_Return_Statement;\n+   --  See Sinfo. We rename Make_Return_Statement to the correct Ada 2005\n+   --  terminology here. Clients should use Make_Simple_Return_Statement.\n+\n+   Make_Return_Statement : constant := -2 ** 33;\n+   --  Attempt to prevent accidental uses of Make_Return_Statement. If this\n+   --  and the one in Nmake are both potentially use-visible, it will cause\n+   --  a compilation error. Note that type and value are irrelevant.\n+\n+   N_Return_Statement : constant := -2**33;\n+   --  Attempt to prevent accidental uses of N_Return_Statement; similar to\n+   --  Make_Return_Statement above.\n+\n+   procedure Mark_Coextensions (Context_Nod : Node_Id; Root_Nod : Node_Id);\n+   --  Given a node which designates the context of analysis and an origin in\n+   --  the tree, traverse from Root_Nod and mark all allocators as either\n+   --  dynamic or static depending on Context_Nod. Any erroneous marking is\n+   --  cleaned up during resolution.\n \n    function May_Be_Lvalue (N : Node_Id) return Boolean;\n    --  Determines if N could be an lvalue (e.g. an assignment left hand side).\n@@ -911,7 +949,15 @@ package Sem_Util is\n    --  capture actual value information, but we can capture conditional tests.\n \n    function Same_Name (N1, N2 : Node_Id) return Boolean;\n-   --  Determine if two (possibly expanded) names are the same name\n+   --  Determine if two (possibly expanded) names are the same name. This is\n+   --  a purely syntactic test, and N1 and N2 need not be analyzed.\n+\n+   function Same_Object (Node1, Node2 : Node_Id) return Boolean;\n+   --  Determine if Node1 and Node2 are known to designate the same object.\n+   --  This is a semantic test and both nodesmust be fully analyzed. A result\n+   --  of True is decisively correct. A result of False does not necessarily\n+   --  mean that different objects are designated, just that this could not\n+   --  be reliably determined at compile time.\n \n    function Same_Type (T1, T2 : Entity_Id) return Boolean;\n    --  Determines if T1 and T2 represent exactly the same type. Two types\n@@ -922,6 +968,13 @@ package Sem_Util is\n    --  False is indecisive (e.g. the compiler may not be able to tell that\n    --  two constraints are identical).\n \n+   function Same_Value (Node1, Node2 : Node_Id) return Boolean;\n+   --  Determines if Node1 and Node2 are known to be the same value, which is\n+   --  true if they are both compile time known values and have the same value,\n+   --  or if they are the same object (in the sense of function Same_Object).\n+   --  A result of False does not necessarily mean they have different values,\n+   --  just that it is not possible to determine they have the same value.\n+\n    function Scope_Within_Or_Same (Scope1, Scope2 : Entity_Id) return Boolean;\n    --  Determines if the entity Scope1 is the same as Scope2, or if it is\n    --  inside it, where both entities represent scopes. Note that scopes\n@@ -967,7 +1020,7 @@ package Sem_Util is\n    --  value from T2 to T1. It does NOT copy the RM_Size field, which must be\n    --  separately set if this is required to be copied also.\n \n-   function Scope_Is_Transient  return Boolean;\n+   function Scope_Is_Transient return Boolean;\n    --  True if the current scope is transient\n \n    function Static_Integer (N : Node_Id) return Uint;"}]}