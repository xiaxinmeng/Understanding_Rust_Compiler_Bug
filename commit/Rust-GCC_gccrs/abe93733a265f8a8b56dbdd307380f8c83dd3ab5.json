{"sha": "abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlOTM3MzNhMjY1ZjhhOGI1NmRiZGQzMDczODBmOGM4M2RkM2FiNQ==", "commit": {"author": {"name": "Yang Yang", "email": "yangyang305@huawei.com", "date": "2020-11-03T16:13:47Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-11-03T16:13:47Z"}, "message": "PR target/96342 Change field \"simdlen\" into poly_uint64\n\nThis is the first patch of PR96342. In order to add support for\n\"omp declare simd\", change the type of the field \"simdlen\" of\nstruct cgraph_simd_clone from unsigned int to poly_uint64 and\nrelated adaptation. Since the length might be variable for the\nSVE cases.\n\n2020-11-03  Yang Yang  <yangyang305@huawei.com>\n\ngcc/ChangeLog:\n\n\t* cgraph.h (struct cgraph_simd_clone): Change field \"simdlen\" of\n\tstruct cgraph_simd_clone from unsigned int to poly_uint64.\n\t* config/aarch64/aarch64.c\n\t(aarch64_simd_clone_compute_vecsize_and_simdlen): adaptation of\n\toperations on \"simdlen\".\n\t* config/i386/i386.c (ix86_simd_clone_compute_vecsize_and_simdlen):\n\tPrintf formats update.\n\t* gengtype.c (main): Handle poly_uint64.\n\t* omp-simd-clone.c (simd_clone_mangle): Likewise.Re\n\t(simd_clone_adjust_return_type): Likewise.\n\t(create_tmp_simd_array): Likewise.\n\t(simd_clone_adjust_argument_types): Likewise.\n\t(simd_clone_init_simd_arrays): Likewise.\n\t(ipa_simd_modify_function_body): Likewise.\n\t(simd_clone_adjust): Likewise.\n\t(expand_simd_clones): Likewise.\n\t* poly-int-types.h (vector_unroll_factor): New macro.\n\t* poly-int.h (constant_multiple_p): Add two-argument versions.\n\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Likewise.", "tree": {"sha": "70b03a6cc0e248726a9056c8b3a3a90a36d0b119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70b03a6cc0e248726a9056c8b3a3a90a36d0b119"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/comments", "author": null, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5b49c3e092c0de5cd684b0acd244129dfaae324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b49c3e092c0de5cd684b0acd244129dfaae324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b49c3e092c0de5cd684b0acd244129dfaae324"}], "stats": {"total": 223, "additions": 159, "deletions": 64}, "files": [{"sha": "cd22676ff9ed20de510ea45d025096f4279b3c05", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -759,17 +759,17 @@ struct GTY(()) cgraph_simd_clone_arg {\n \n struct GTY(()) cgraph_simd_clone {\n   /* Number of words in the SIMD lane associated with this clone.  */\n-  unsigned int simdlen;\n+  poly_uint64 simdlen;\n \n   /* Number of annotated function arguments in `args'.  This is\n      usually the number of named arguments in FNDECL.  */\n   unsigned int nargs;\n \n   /* Max hardware vector size in bits for integral vectors.  */\n-  unsigned int vecsize_int;\n+  poly_uint64 vecsize_int;\n \n   /* Max hardware vector size in bits for floating point vectors.  */\n-  unsigned int vecsize_float;\n+  poly_uint64 vecsize_float;\n \n   /* Machine mode of the mask argument(s), if they are to be passed\n      as bitmasks in integer argument(s).  VOIDmode if masks are passed"}, {"sha": "27f587be7e7483093f1fd381d8fa14a6c6581ccf", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -22960,18 +22960,23 @@ aarch64_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \t\t\t\t\ttree base_type, int num)\n {\n   tree t, ret_type, arg_type;\n-  unsigned int elt_bits, vec_bits, count;\n+  unsigned int elt_bits, count;\n+  unsigned HOST_WIDE_INT const_simdlen;\n+  poly_uint64 vec_bits;\n \n   if (!TARGET_SIMD)\n     return 0;\n \n-  if (clonei->simdlen\n-      && (clonei->simdlen < 2\n-\t  || clonei->simdlen > 1024\n-\t  || (clonei->simdlen & (clonei->simdlen - 1)) != 0))\n+  /* For now, SVE simdclones won't produce illegal simdlen, So only check\n+     const simdlens here.  */\n+  if (maybe_ne (clonei->simdlen, 0U)\n+      && clonei->simdlen.is_constant (&const_simdlen)\n+      && (const_simdlen < 2\n+\t  || const_simdlen > 1024\n+\t  || (const_simdlen & (const_simdlen - 1)) != 0))\n     {\n       warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t  \"unsupported simdlen %d\", clonei->simdlen);\n+\t\t  \"unsupported simdlen %wd\", const_simdlen);\n       return 0;\n     }\n \n@@ -23015,21 +23020,24 @@ aarch64_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n   clonei->vecsize_mangle = 'n';\n   clonei->mask_mode = VOIDmode;\n   elt_bits = GET_MODE_BITSIZE (SCALAR_TYPE_MODE (base_type));\n-  if (clonei->simdlen == 0)\n+  if (known_eq (clonei->simdlen, 0U))\n     {\n       count = 2;\n       vec_bits = (num == 0 ? 64 : 128);\n-      clonei->simdlen = vec_bits / elt_bits;\n+      clonei->simdlen = exact_div (vec_bits, elt_bits);\n     }\n   else\n     {\n       count = 1;\n       vec_bits = clonei->simdlen * elt_bits;\n-      if (vec_bits != 64 && vec_bits != 128)\n+      /* For now, SVE simdclones won't produce illegal simdlen, So only check\n+\t const simdlens here.  */\n+      if (clonei->simdlen.is_constant (&const_simdlen)\n+\t  && maybe_ne (vec_bits, 64U) && maybe_ne (vec_bits, 128U))\n \t{\n \t  warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t      \"GCC does not currently support simdlen %d for type %qT\",\n-\t\t      clonei->simdlen, base_type);\n+\t\t      \"GCC does not currently support simdlen %wd for type %qT\",\n+\t\t      const_simdlen, base_type);\n \t  return 0;\n \t}\n     }"}, {"sha": "df47a53d701dcd328009df4fcef6d445d10029ae", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -22485,7 +22485,7 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \t  || (clonei->simdlen & (clonei->simdlen - 1)) != 0))\n     {\n       warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t  \"unsupported simdlen %d\", clonei->simdlen);\n+\t\t  \"unsupported simdlen %wd\", clonei->simdlen.to_constant ());\n       return 0;\n     }\n \n@@ -22590,7 +22590,8 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n \tclonei->simdlen = clonei->vecsize_int;\n       else\n \tclonei->simdlen = clonei->vecsize_float;\n-      clonei->simdlen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));\n+      clonei->simdlen = clonei->simdlen\n+\t\t\t/ GET_MODE_BITSIZE (TYPE_MODE (base_type));\n     }\n   else if (clonei->simdlen > 16)\n     {\n@@ -22612,7 +22613,8 @@ ix86_simd_clone_compute_vecsize_and_simdlen (struct cgraph_node *node,\n       if (cnt > (TARGET_64BIT ? 16 : 8))\n \t{\n \t  warning_at (DECL_SOURCE_LOCATION (node->decl), 0,\n-\t\t      \"unsupported simdlen %d\", clonei->simdlen);\n+\t\t      \"unsupported simdlen %wd\",\n+\t\t      clonei->simdlen.to_constant ());\n \t  return 0;\n \t}\n       }"}, {"sha": "b21eeacdbe2fdd0f13e8e3f5bbf750b156c7a3d6", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -5200,6 +5200,7 @@ main (int argc, char **argv)\n       POS_HERE (do_scalar_typedef (\"widest_int\", &pos));\n       POS_HERE (do_scalar_typedef (\"int64_t\", &pos));\n       POS_HERE (do_scalar_typedef (\"poly_int64\", &pos));\n+      POS_HERE (do_scalar_typedef (\"poly_uint64\", &pos));\n       POS_HERE (do_scalar_typedef (\"uint64_t\", &pos));\n       POS_HERE (do_scalar_typedef (\"uint8\", &pos));\n       POS_HERE (do_scalar_typedef (\"uintptr_t\", &pos));"}, {"sha": "cbd58c8987be84f1fb7dfbb6cc4a50b5b2133ae0", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -338,16 +338,18 @@ simd_clone_mangle (struct cgraph_node *node,\n {\n   char vecsize_mangle = clone_info->vecsize_mangle;\n   char mask = clone_info->inbranch ? 'M' : 'N';\n-  unsigned int simdlen = clone_info->simdlen;\n+  poly_uint64 simdlen = clone_info->simdlen;\n   unsigned int n;\n   pretty_printer pp;\n \n-  gcc_assert (vecsize_mangle && simdlen);\n+  gcc_assert (vecsize_mangle && maybe_ne (simdlen, 0U));\n \n   pp_string (&pp, \"_ZGV\");\n   pp_character (&pp, vecsize_mangle);\n   pp_character (&pp, mask);\n-  pp_decimal_int (&pp, simdlen);\n+  /* For now, simdlen is always constant, while variable simdlen pp 'n'.  */\n+  unsigned int len = simdlen.to_constant ();\n+  pp_decimal_int (&pp, (len));\n \n   for (n = 0; n < clone_info->nargs; ++n)\n     {\n@@ -491,7 +493,7 @@ simd_clone_adjust_return_type (struct cgraph_node *node)\n {\n   tree fndecl = node->decl;\n   tree orig_rettype = TREE_TYPE (TREE_TYPE (fndecl));\n-  unsigned int veclen;\n+  poly_uint64 veclen;\n   tree t;\n \n   /* Adjust the function return type.  */\n@@ -502,17 +504,18 @@ simd_clone_adjust_return_type (struct cgraph_node *node)\n     veclen = node->simdclone->vecsize_int;\n   else\n     veclen = node->simdclone->vecsize_float;\n-  veclen /= GET_MODE_BITSIZE (SCALAR_TYPE_MODE (t));\n-  if (veclen > node->simdclone->simdlen)\n+  veclen = exact_div (veclen, GET_MODE_BITSIZE (SCALAR_TYPE_MODE (t)));\n+  if (multiple_p (veclen, node->simdclone->simdlen))\n     veclen = node->simdclone->simdlen;\n   if (POINTER_TYPE_P (t))\n     t = pointer_sized_int_node;\n-  if (veclen == node->simdclone->simdlen)\n+  if (known_eq (veclen, node->simdclone->simdlen))\n     t = build_vector_type (t, node->simdclone->simdlen);\n   else\n     {\n       t = build_vector_type (t, veclen);\n-      t = build_array_type_nelts (t, node->simdclone->simdlen / veclen);\n+      t = build_array_type_nelts (t, exact_div (node->simdclone->simdlen,\n+\t\t\t\t\t\tveclen));\n     }\n   TREE_TYPE (TREE_TYPE (fndecl)) = t;\n   if (!node->definition)\n@@ -526,7 +529,7 @@ simd_clone_adjust_return_type (struct cgraph_node *node)\n \n   tree atype = build_array_type_nelts (orig_rettype,\n \t\t\t\t       node->simdclone->simdlen);\n-  if (veclen != node->simdclone->simdlen)\n+  if (maybe_ne (veclen, node->simdclone->simdlen))\n     return build1 (VIEW_CONVERT_EXPR, atype, t);\n \n   /* Set up a SIMD array to use as the return value.  */\n@@ -546,7 +549,7 @@ simd_clone_adjust_return_type (struct cgraph_node *node)\n    SIMDLEN is the number of elements.  */\n \n static tree\n-create_tmp_simd_array (const char *prefix, tree type, int simdlen)\n+create_tmp_simd_array (const char *prefix, tree type, poly_uint64 simdlen)\n {\n   tree atype = build_array_type_nelts (type, simdlen);\n   tree avar = create_tmp_var_raw (atype, prefix);\n@@ -578,7 +581,8 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n   struct cgraph_simd_clone *sc = node->simdclone;\n   vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n   vec_safe_reserve (new_params, sc->nargs);\n-  unsigned i, j, veclen;\n+  unsigned i, j, k;\n+  poly_uint64 veclen;\n \n   for (i = 0; i < sc->nargs; ++i)\n     {\n@@ -614,8 +618,9 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t    veclen = sc->vecsize_int;\n \t  else\n \t    veclen = sc->vecsize_float;\n-\t  veclen /= GET_MODE_BITSIZE (SCALAR_TYPE_MODE (parm_type));\n-\t  if (veclen > sc->simdlen)\n+\t  veclen = exact_div (veclen,\n+\t\t\t      GET_MODE_BITSIZE (SCALAR_TYPE_MODE (parm_type)));\n+\t  if (multiple_p (veclen, sc->simdlen))\n \t    veclen = sc->simdlen;\n \t  adj.op = IPA_PARAM_OP_NEW;\n \t  adj.param_prefix_index = IPA_PARAM_PREFIX_SIMD;\n@@ -624,10 +629,11 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t  else\n \t    adj.type = build_vector_type (parm_type, veclen);\n \t  sc->args[i].vector_type = adj.type;\n-\t  for (j = veclen; j < sc->simdlen; j += veclen)\n+\t  k = vector_unroll_factor (sc->simdlen, veclen);\n+\t  for (j = 1; j < k; j++)\n \t    {\n \t      vec_safe_push (new_params, adj);\n-\t      if (j == veclen)\n+\t      if (j == 1)\n \t\t{\n \t\t  memset (&adj, 0, sizeof (adj));\n \t\t  adj.op = IPA_PARAM_OP_NEW;\n@@ -663,8 +669,9 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \tveclen = sc->vecsize_int;\n       else\n \tveclen = sc->vecsize_float;\n-      veclen /= GET_MODE_BITSIZE (SCALAR_TYPE_MODE (base_type));\n-      if (veclen > sc->simdlen)\n+      veclen = exact_div (veclen,\n+\t\t\t  GET_MODE_BITSIZE (SCALAR_TYPE_MODE (base_type)));\n+      if (multiple_p (veclen, sc->simdlen))\n \tveclen = sc->simdlen;\n       if (sc->mask_mode != VOIDmode)\n \tadj.type\n@@ -675,7 +682,8 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \tadj.type = build_vector_type (base_type, veclen);\n       vec_safe_push (new_params, adj);\n \n-      for (j = veclen; j < sc->simdlen; j += veclen)\n+      k = vector_unroll_factor (sc->simdlen, veclen);\n+      for (j = 1; j < k; j++)\n \tvec_safe_push (new_params, adj);\n \n       /* We have previously allocated one extra entry for the mask.  Use\n@@ -690,9 +698,9 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t  if (sc->mask_mode == VOIDmode)\n \t    sc->args[i].simd_array\n \t      = create_tmp_simd_array (\"mask\", base_type, sc->simdlen);\n-\t  else if (veclen < sc->simdlen)\n+\t  else if (k > 1)\n \t    sc->args[i].simd_array\n-\t      = create_tmp_simd_array (\"mask\", adj.type, sc->simdlen / veclen);\n+\t      = create_tmp_simd_array (\"mask\", adj.type, k);\n \t  else\n \t    sc->args[i].simd_array = NULL_TREE;\n \t}\n@@ -783,7 +791,8 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,\n \t    }\n \t  continue;\n \t}\n-      if (simd_clone_subparts (TREE_TYPE (arg)) == node->simdclone->simdlen)\n+      if (known_eq (simd_clone_subparts (TREE_TYPE (arg)),\n+\t\t    node->simdclone->simdlen))\n \t{\n \t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n \t  tree ptr = build_fold_addr_expr (array);\n@@ -795,8 +804,10 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,\n       else\n \t{\n \t  unsigned int simdlen = simd_clone_subparts (TREE_TYPE (arg));\n+\t  unsigned int times = vector_unroll_factor (node->simdclone->simdlen,\n+\t\t\t\t\t\t     simdlen);\n \t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n-\t  for (k = 0; k < node->simdclone->simdlen; k += simdlen)\n+\t  for (k = 0; k < times; k++)\n \t    {\n \t      tree ptr = build_fold_addr_expr (array);\n \t      int elemsize;\n@@ -808,7 +819,7 @@ simd_clone_init_simd_arrays (struct cgraph_node *node,\n \t      tree elemtype = TREE_TYPE (TREE_TYPE (arg));\n \t      elemsize = GET_MODE_SIZE (SCALAR_TYPE_MODE (elemtype));\n \t      tree t = build2 (MEM_REF, TREE_TYPE (arg), ptr,\n-\t\t\t       build_int_cst (ptype, k * elemsize));\n+\t\t\t       build_int_cst (ptype, k * elemsize * simdlen));\n \t      t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n \t      gimplify_and_add (t, &seq);\n \t    }\n@@ -981,8 +992,9 @@ ipa_simd_modify_function_body (struct cgraph_node *node,\n \t\t  iter, NULL_TREE, NULL_TREE);\n       adjustments->register_replacement (&(*adjustments->m_adj_params)[j], r);\n \n-      if (simd_clone_subparts (vectype) < node->simdclone->simdlen)\n-\tj += node->simdclone->simdlen / simd_clone_subparts (vectype) - 1;\n+      if (multiple_p (node->simdclone->simdlen, simd_clone_subparts (vectype)))\n+\tj += vector_unroll_factor (node->simdclone->simdlen,\n+\t\t\t\t   simd_clone_subparts (vectype)) - 1;\n     }\n \n   tree name;\n@@ -1249,7 +1261,8 @@ simd_clone_adjust (struct cgraph_node *node)\n \t below).  */\n       loop = alloc_loop ();\n       cfun->has_force_vectorize_loops = true;\n-      loop->safelen = node->simdclone->simdlen;\n+      /* For now, simlen is always constant.  */\n+      loop->safelen = node->simdclone->simdlen.to_constant ();\n       loop->force_vectorize = true;\n       loop->header = body_bb;\n     }\n@@ -1275,7 +1288,8 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    {\n \t      tree maskt = TREE_TYPE (mask_array);\n \t      int c = tree_to_uhwi (TYPE_MAX_VALUE (TYPE_DOMAIN (maskt)));\n-\t      c = node->simdclone->simdlen / (c + 1);\n+\t      /* For now, c must be constant here.  */\n+\t      c = exact_div (node->simdclone->simdlen, c + 1).to_constant ();\n \t      int s = exact_log2 (c);\n \t      gcc_assert (s > 0);\n \t      c--;\n@@ -1683,7 +1697,7 @@ expand_simd_clones (struct cgraph_node *node)\n       if (clone_info == NULL)\n \tcontinue;\n \n-      int orig_simdlen = clone_info->simdlen;\n+      poly_uint64 orig_simdlen = clone_info->simdlen;\n       tree base_type = simd_clone_compute_base_data_type (node, clone_info);\n       /* The target can return 0 (no simd clones should be created),\n \t 1 (just one ISA of simd clones should be created) or higher"}, {"sha": "302e5bfd97d8d9d9ecd187d64ccb1154225ca177", "filename": "gcc/poly-int-types.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fpoly-int-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fpoly-int-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int-types.h?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -81,6 +81,14 @@ typedef poly_int<NUM_POLY_INT_COEFFS, widest_int> poly_widest_int;\n #define vector_element_size(SIZE, NELTS) \\\n   (exact_div (SIZE, NELTS).to_constant ())\n \n+/* Return the number of unroll times when a vector that has NELTS1 elements\n+   is unrolled to vectors that have NELTS2 elements.\n+\n+   to_constant () is safe in this situation because the multiples of the\n+   NELTS of two vectors are always constant-size scalars.  */\n+#define vector_unroll_factor(NELTS1, NELTS2) \\\n+  (exact_div (NELTS1, NELTS2).to_constant ())\n+\n /* Wrapper for poly_int arguments to target macros, so that if a target\n    doesn't need polynomial-sized modes, its header file can continue to\n    treat the argument as a normal constant.  This should go away once"}, {"sha": "96a763daedfe1696626d450b8676c9dcdd647d97", "filename": "gcc/poly-int.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -2044,6 +2044,63 @@ constant_multiple_p (const poly_int_pod<N, Ca> &a,\n   return true;\n }\n \n+/* Return true if A is a constant multiple of B.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Cb, bool>::type\n+constant_multiple_p (const poly_int_pod<N, Ca> &a, Cb b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+\n+  /* Do the modulus before the constant check, to catch divide by\n+     zero errors.  */\n+  if (NCa (a.coeffs[0]) % NCb (b) != 0 || !a.is_constant ())\n+    return false;\n+  return true;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Ca, bool>::type\n+constant_multiple_p (Ca a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_INT_TYPE (Ca) int_type;\n+\n+  /* Do the modulus before the constant check, to catch divide by\n+     zero errors.  */\n+  if (NCa (a) % NCb (b.coeffs[0]) != 0\n+      || (a != int_type (0) && !b.is_constant ()))\n+    return false;\n+  return true;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+constant_multiple_p (const poly_int_pod<N, Ca> &a,\n+\t\t     const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_INT_TYPE (Ca) ICa;\n+  typedef POLY_INT_TYPE (Cb) ICb;\n+  typedef POLY_BINARY_COEFF (Ca, Cb) C;\n+\n+  if (NCa (a.coeffs[0]) % NCb (b.coeffs[0]) != 0)\n+    return false;\n+\n+  C r = NCa (a.coeffs[0]) / NCb (b.coeffs[0]);\n+  for (unsigned int i = 1; i < N; ++i)\n+    if (b.coeffs[i] == ICb (0)\n+\t? a.coeffs[i] != ICa (0)\n+\t: (NCa (a.coeffs[i]) % NCb (b.coeffs[i]) != 0\n+\t   || NCa (a.coeffs[i]) / NCb (b.coeffs[i]) != r))\n+      return false;\n+  return true;\n+}\n+\n+\n /* Return true if A is a multiple of B.  */\n \n template<typename Ca, typename Cb>"}, {"sha": "9cf85a0cd51856bfd2516996d9a7bb2dfc89d37d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe93733a265f8a8b56dbdd307380f8c83dd3ab5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=abe93733a265f8a8b56dbdd307380f8c83dd3ab5", "patch": "@@ -3707,7 +3707,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n   tree op, type;\n   tree vec_oprnd0 = NULL_TREE;\n   tree vectype;\n-  unsigned int nunits;\n+  poly_uint64 nunits;\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (vinfo);\n   class loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n@@ -3859,8 +3859,8 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n       arginfo.quick_push (thisarginfo);\n     }\n \n-  unsigned HOST_WIDE_INT vf;\n-  if (!LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&vf))\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  if (!vf.is_constant ())\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3878,12 +3878,12 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t n = n->simdclone->next_clone)\n       {\n \tunsigned int this_badness = 0;\n-\tif (n->simdclone->simdlen > vf\n+\tunsigned int num_calls;\n+\tif (!constant_multiple_p (vf, n->simdclone->simdlen, &num_calls)\n \t    || n->simdclone->nargs != nargs)\n \t  continue;\n-\tif (n->simdclone->simdlen < vf)\n-\t  this_badness += (exact_log2 (vf)\n-\t\t\t   - exact_log2 (n->simdclone->simdlen)) * 1024;\n+\tif (num_calls != 1)\n+\t  this_badness += exact_log2 (num_calls) * 1024;\n \tif (n->simdclone->inbranch)\n \t  this_badness += 2048;\n \tint target_badness = targetm.simd_clone.usable (n);\n@@ -3964,19 +3964,19 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \targinfo[i].vectype = get_vectype_for_scalar_type (vinfo, arg_type,\n \t\t\t\t\t\t\t  slp_node);\n \tif (arginfo[i].vectype == NULL\n-\t    || (simd_clone_subparts (arginfo[i].vectype)\n-\t\t> bestn->simdclone->simdlen))\n+\t    || !constant_multiple_p (bestn->simdclone->simdlen,\n+\t\t\t\t     simd_clone_subparts (arginfo[i].vectype)))\n \t  return false;\n       }\n \n   fndecl = bestn->decl;\n   nunits = bestn->simdclone->simdlen;\n-  ncopies = vf / nunits;\n+  ncopies = vector_unroll_factor (vf, nunits);\n \n   /* If the function isn't const, only allow it in simd loops where user\n      has asserted that at least nunits consecutive iterations can be\n      performed using SIMD instructions.  */\n-  if ((loop == NULL || (unsigned) loop->safelen < nunits)\n+  if ((loop == NULL || maybe_lt ((unsigned) loop->safelen, nunits))\n       && gimple_vuse (stmt))\n     return false;\n \n@@ -4054,7 +4054,8 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t    {\n \t    case SIMD_CLONE_ARG_TYPE_VECTOR:\n \t      atype = bestn->simdclone->args[i].vector_type;\n-\t      o = nunits / simd_clone_subparts (atype);\n+\t      o = vector_unroll_factor (nunits,\n+\t\t\t\t\tsimd_clone_subparts (atype));\n \t      for (m = j * o; m < (j + 1) * o; m++)\n \t\t{\n \t\t  if (simd_clone_subparts (atype)\n@@ -4179,7 +4180,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t      ? POINTER_PLUS_EXPR : PLUS_EXPR;\n \t\t  tree type = POINTER_TYPE_P (TREE_TYPE (op))\n \t\t\t      ? sizetype : TREE_TYPE (op);\n-\t\t  widest_int cst\n+\t\t  poly_widest_int cst\n \t\t    = wi::mul (bestn->simdclone->args[i].linear_step,\n \t\t\t       ncopies * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n@@ -4200,7 +4201,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t      ? POINTER_PLUS_EXPR : PLUS_EXPR;\n \t\t  tree type = POINTER_TYPE_P (TREE_TYPE (op))\n \t\t\t      ? sizetype : TREE_TYPE (op);\n-\t\t  widest_int cst\n+\t\t  poly_widest_int cst\n \t\t    = wi::mul (bestn->simdclone->args[i].linear_step,\n \t\t\t       j * nunits);\n \t\t  tree tcst = wide_int_to_tree (type, cst);\n@@ -4226,7 +4227,8 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n       gcall *new_call = gimple_build_call_vec (fndecl, vargs);\n       if (vec_dest)\n \t{\n-\t  gcc_assert (ratype || simd_clone_subparts (rtype) == nunits);\n+\t  gcc_assert (ratype\n+\t\t      || known_eq (simd_clone_subparts (rtype), nunits));\n \t  if (ratype)\n \t    new_temp = create_tmp_var (ratype);\n \t  else if (useless_type_conversion_p (vectype, rtype))\n@@ -4240,12 +4242,13 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \n       if (vec_dest)\n \t{\n-\t  if (simd_clone_subparts (vectype) < nunits)\n+\t  if (!multiple_p (simd_clone_subparts (vectype), nunits))\n \t    {\n \t      unsigned int k, l;\n \t      poly_uint64 prec = GET_MODE_BITSIZE (TYPE_MODE (vectype));\n \t      poly_uint64 bytes = GET_MODE_SIZE (TYPE_MODE (vectype));\n-\t      k = nunits / simd_clone_subparts (vectype);\n+\t      k = vector_unroll_factor (nunits,\n+\t\t\t\t\tsimd_clone_subparts (vectype));\n \t      gcc_assert ((k & (k - 1)) == 0);\n \t      for (l = 0; l < k; l++)\n \t\t{\n@@ -4271,7 +4274,7 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\tvect_clobber_variable (vinfo, stmt_info, gsi, new_temp);\n \t      continue;\n \t    }\n-\t  else if (simd_clone_subparts (vectype) > nunits)\n+\t  else if (!multiple_p (nunits, simd_clone_subparts (vectype)))\n \t    {\n \t      unsigned int k = (simd_clone_subparts (vectype)\n \t\t\t\t/ simd_clone_subparts (rtype));\n@@ -4280,7 +4283,9 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\tvec_alloc (ret_ctor_elts, k);\n \t      if (ratype)\n \t\t{\n-\t\t  unsigned int m, o = nunits / simd_clone_subparts (rtype);\n+\t\t  unsigned int m, o;\n+\t\t  o = vector_unroll_factor (nunits,\n+\t\t\t\t\t    simd_clone_subparts (rtype));\n \t\t  for (m = 0; m < o; m++)\n \t\t    {\n \t\t      tree tem = build4 (ARRAY_REF, rtype, new_temp,"}]}