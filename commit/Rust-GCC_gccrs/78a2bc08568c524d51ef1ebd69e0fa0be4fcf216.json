{"sha": "78a2bc08568c524d51ef1ebd69e0fa0be4fcf216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhhMmJjMDg1NjhjNTI0ZDUxZWYxZWJkNjllMGZhMGJlNGZjZjIxNg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-12-01T10:53:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-12-01T10:53:54Z"}, "message": "reload1.c (emit_reload_insns): Clear spill_reg_store when doing a new non-inherited reload from the same pseudo.\n\n        * reload1.c (emit_reload_insns): Clear spill_reg_store\n        when doing a new non-inherited reload from the same pseudo.\n\nFrom-SVN: r24029", "tree": {"sha": "5174f36b05a4a1e3f7aae1b75c76b6e959575466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5174f36b05a4a1e3f7aae1b75c76b6e959575466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216/comments", "author": null, "committer": null, "parents": [{"sha": "de80f41622d4d3dd30386ca0fd506fc0b7930f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de80f41622d4d3dd30386ca0fd506fc0b7930f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de80f41622d4d3dd30386ca0fd506fc0b7930f95"}], "stats": {"total": 31, "additions": 31, "deletions": 0}, "files": [{"sha": "1eb7c84d0589646c01122187151ff590734bc3d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78a2bc08568c524d51ef1ebd69e0fa0be4fcf216", "patch": "@@ -9,6 +9,9 @@ Tue Dec  1 10:22:18 1998  Nick Clifton  <nickc@cygnus.com>\n \n Tue Dec  1 17:58:26 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n+\t* reload1.c (emit_reload_insns): Clear spill_reg_store\n+\twhen doing a new non-inherited reload from the same pseudo.\n+\n \t* local-alloc.c (function_invariant_p): New function.\n \t(update_equiv_regs): Use function_invariant_p instead of CONSTANT_P\n \tto decide if an equivalence should be recorded."}, {"sha": "d27663cea7f454adc03386934f6b40b51a50b440", "filename": "gcc/reload1.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a2bc08568c524d51ef1ebd69e0fa0be4fcf216/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=78a2bc08568c524d51ef1ebd69e0fa0be4fcf216", "patch": "@@ -7300,6 +7300,34 @@ emit_reload_insns (chain)\n       register int r = reload_order[j];\n       register int i = reload_spill_index[r];\n \n+      /* If this is a non-inherited input reload from a pseudo, we must\n+         clear any memory of a previous store to the same pseudo.  Only do\n+         something if there will not be an output reload for the pseudo\n+         being reloaded.  */\n+      if (reload_in_reg[r] != 0\n+          && ! (reload_inherited[r] || reload_override_in[r]))\n+        {\n+          rtx reg = reload_in_reg[r];\n+\n+          if (GET_CODE (reg) == SUBREG)\n+\t    reg = SUBREG_REG (reg);\n+\t\n+          if (GET_CODE (reg) == REG\n+\t      && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n+\t      && ! reg_has_output_reload[REGNO (reg)])\n+\t    {\n+\t      int nregno = REGNO (reg);\n+\n+\t      if (reg_last_reload_reg[nregno])\n+\t        {\n+\t          int last_regno = REGNO (reg_last_reload_reg[nregno]);\n+\n+\t          if (reg_reloaded_contents[last_regno] == nregno)\n+\t\t    spill_reg_store[last_regno] = 0;\n+\t        }\n+\t    }\n+\t}\n+\t\t  \n       /* I is nonneg if this reload used a register.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n \t that we opted to ignore.  */"}]}