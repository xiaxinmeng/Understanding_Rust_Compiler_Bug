{"sha": "348c3ae62ec5579323defd9179aa6b870e0b744b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ4YzNhZTYyZWM1NTc5MzIzZGVmZDkxNzlhYTZiODcwZTBiNzQ0Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-09-19T08:12:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-19T08:12:52Z"}, "message": "[Ada] Fix fallout of previous change for bit-packed arrays\n\nThis fixes a regression introduced by the previous change that improved\nthe handling of explicit by-reference mechanism. For the very specific\ncase of a component of a bit-packed array, the front-end still needs to\ninsert a copy around the call because this is where the rewriting into\nthe sequence of mask-and-shifts is done for the code generator.\n\n2019-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Add_Simple_Call_By_Copy_Code): Add\n\tBit_Packed_Array parameter and documet it. Always insert a copy\n\tif it is set True.\n\t(Expand_Actuals): Adjust the calls to\n\tAdd_Simple_Call_By_Copy_Code.\n\ngcc/testsuite/\n\n\t* gnat.dg/pack26.adb: New testcase.\n\nFrom-SVN: r275933", "tree": {"sha": "7c87e2612448a5939978a961e177de85ccd66310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c87e2612448a5939978a961e177de85ccd66310"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/348c3ae62ec5579323defd9179aa6b870e0b744b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348c3ae62ec5579323defd9179aa6b870e0b744b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348c3ae62ec5579323defd9179aa6b870e0b744b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348c3ae62ec5579323defd9179aa6b870e0b744b/comments", "author": null, "committer": null, "parents": [{"sha": "e516702202bcdc26181cf9fab120fcb15ca0c15d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e516702202bcdc26181cf9fab120fcb15ca0c15d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e516702202bcdc26181cf9fab120fcb15ca0c15d"}], "stats": {"total": 67, "additions": 54, "deletions": 13}, "files": [{"sha": "78b1c0b7db5de02727412dd2bf43076ad73ae20f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=348c3ae62ec5579323defd9179aa6b870e0b744b", "patch": "@@ -1,3 +1,11 @@\n+2019-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch6.adb (Add_Simple_Call_By_Copy_Code): Add\n+\tBit_Packed_Array parameter and documet it. Always insert a copy\n+\tif it is set True.\n+\t(Expand_Actuals): Adjust the calls to\n+\tAdd_Simple_Call_By_Copy_Code.\n+\n 2019-09-19  Bob Duff  <duff@adacore.com>\n \n \t* xref_lib.adb (Get_Symbol_Name): If we reach EOF in the first"}, {"sha": "c569ca33af782d8cb0af2c812ef4ae94799bc998", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=348c3ae62ec5579323defd9179aa6b870e0b744b", "patch": "@@ -1252,10 +1252,11 @@ package body Exp_Ch6 is\n       --  also takes care of any constraint checks required for the type\n       --  conversion case (on both the way in and the way out).\n \n-      procedure Add_Simple_Call_By_Copy_Code;\n+      procedure Add_Simple_Call_By_Copy_Code (Bit_Packed_Array : Boolean);\n       --  This is similar to the above, but is used in cases where we know\n       --  that all that is needed is to simply create a temporary and copy\n-      --  the value in and out of the temporary.\n+      --  the value in and out of the temporary. If Bit_Packed_Array is True,\n+      --  the procedure is called for a bit-packed array actual.\n \n       procedure Add_Validation_Call_By_Copy_Code (Act : Node_Id);\n       --  Perform copy-back for actual parameter Act which denotes a validation\n@@ -1269,11 +1270,11 @@ package body Exp_Ch6 is\n \n       function Is_Legal_Copy return Boolean;\n       --  Check that an actual can be copied before generating the temporary\n-      --  to be used in the call. If the actual is of a by_reference type then\n-      --  the program is illegal (this can only happen in the presence of\n-      --  rep. clauses that force an incorrect alignment). If the formal is\n-      --  a by_reference parameter imposed by a DEC pragma, emit a warning to\n-      --  the effect that this might lead to unaligned arguments.\n+      --  to be used in the call. If the formal is of a by_reference type or\n+      --  is aliased, then the program is illegal (this can only happen in\n+      --  the presence of representation clauses that force a misalignment)\n+      --  If the formal is a by_reference parameter imposed by a DEC pragma,\n+      --  emit a warning that this might lead to unaligned arguments.\n \n       function Make_Var (Actual : Node_Id) return Entity_Id;\n       --  Returns an entity that refers to the given actual parameter, Actual\n@@ -1610,7 +1611,7 @@ package body Exp_Ch6 is\n       -- Add_Simple_Call_By_Copy_Code --\n       ----------------------------------\n \n-      procedure Add_Simple_Call_By_Copy_Code is\n+      procedure Add_Simple_Call_By_Copy_Code (Bit_Packed_Array : Boolean) is\n          Decl   : Node_Id;\n          F_Typ  : Entity_Id := Etype (Formal);\n          Incod  : Node_Id;\n@@ -1621,7 +1622,12 @@ package body Exp_Ch6 is\n          Temp   : Entity_Id;\n \n       begin\n-         if not Is_Legal_Copy then\n+         --  ??? We need to do the copy for a bit-packed array because this is\n+         --  where the rewriting into a mask-and-shift sequence is done. But of\n+         --  course this may break the program if it expects bits to be really\n+         --  passed by reference. That's what we have done historically though.\n+\n+         if not Bit_Packed_Array and then not Is_Legal_Copy then\n             return;\n          end if;\n \n@@ -2076,7 +2082,7 @@ package body Exp_Ch6 is\n             --  [in] out parameters.\n \n             elsif Is_Ref_To_Bit_Packed_Array (Actual) then\n-               Add_Simple_Call_By_Copy_Code;\n+               Add_Simple_Call_By_Copy_Code (Bit_Packed_Array => True);\n \n             --  If a nonscalar actual is possibly bit-aligned, we need a copy\n             --  because the back-end cannot cope with such objects. In other\n@@ -2092,7 +2098,7 @@ package body Exp_Ch6 is\n                 Component_May_Be_Bit_Aligned (Entity (Selector_Name (Actual)))\n               and then not Represented_As_Scalar (Etype (Formal))\n             then\n-               Add_Simple_Call_By_Copy_Code;\n+               Add_Simple_Call_By_Copy_Code (Bit_Packed_Array => False);\n \n             --  References to slices of bit-packed arrays are expanded\n \n@@ -2295,14 +2301,14 @@ package body Exp_Ch6 is\n             --  Is this really necessary in all cases???\n \n             elsif Is_Ref_To_Bit_Packed_Array (Actual) then\n-               Add_Simple_Call_By_Copy_Code;\n+               Add_Simple_Call_By_Copy_Code (Bit_Packed_Array => True);\n \n             --  If a nonscalar actual is possibly unaligned, we need a copy\n \n             elsif Is_Possibly_Unaligned_Object (Actual)\n               and then not Represented_As_Scalar (Etype (Formal))\n             then\n-               Add_Simple_Call_By_Copy_Code;\n+               Add_Simple_Call_By_Copy_Code (Bit_Packed_Array => False);\n \n             --  Similarly, we have to expand slices of packed arrays here\n             --  because the result must be byte aligned."}, {"sha": "1e0262892490d50baa99ae00247598ca7d643ab7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=348c3ae62ec5579323defd9179aa6b870e0b744b", "patch": "@@ -1,3 +1,7 @@\n+2019-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/pack26.adb: New testcase.\n+\n 2019-09-19  Hongtao Liu <hongtao.liu@intel.com>\n \n \tPR target/87007"}, {"sha": "636529600d450870c3dc3b756b24193fcc59c4dd", "filename": "gcc/testsuite/gnat.dg/pack26.adb", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Ftestsuite%2Fgnat.dg%2Fpack26.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348c3ae62ec5579323defd9179aa6b870e0b744b/gcc%2Ftestsuite%2Fgnat.dg%2Fpack26.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fpack26.adb?ref=348c3ae62ec5579323defd9179aa6b870e0b744b", "patch": "@@ -0,0 +1,23 @@\n+--  { dg-do run }\n+\n+pragma Extend_System (Aux_DEC);\n+\n+with System;\n+\n+procedure Pack26 is\n+\n+  type Bool_Array is array (1 .. 8) of Boolean;\n+  pragma pack (Bool_Array);\n+\n+  All_True : Bool_Array := (others => True);\n+  Old_Value : Boolean := False;\n+\n+begin\n+\n+  System.Clear_Interlocked (All_True (2), Old_Value);\n+\n+  if not Old_Value then\n+    raise Program_Error;\n+  end if;\n+\n+end;\n\\ No newline at end of file"}]}