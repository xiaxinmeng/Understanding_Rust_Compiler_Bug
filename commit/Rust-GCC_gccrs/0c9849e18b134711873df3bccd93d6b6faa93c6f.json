{"sha": "0c9849e18b134711873df3bccd93d6b6faa93c6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5ODQ5ZTE4YjEzNDcxMTg3M2RmM2JjY2Q5M2Q2YjZmYWE5M2M2Zg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-23T10:22:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-23T10:22:52Z"}, "message": "[Ada] Suspension and elaboration warnings/checks\n\nThis patch modifies the static elaboration model to stop the inspection of\na task body when it contains a synchronous suspension call and restriction\nNo_Entry_Calls_In_Elaboration_Code or switch -gnatd_s is in effect.\n\n------------\n-- Source --\n------------\n\n--  suspension.ads\n\npackage Suspension is\n   procedure ABE;\n\n   task type Barrier_Task_1;\n   task type Barrier_Task_2;\n   task type Object_Task_1;\n   task type Object_Task_2;\nend Suspension;\n\n--  suspension.adb\n\nwith Ada.Synchronous_Barriers;     use Ada.Synchronous_Barriers;\nwith Ada.Synchronous_Task_Control; use Ada.Synchronous_Task_Control;\n\npackage body Suspension is\n   Bar : Synchronous_Barrier (Barrier_Limit'Last);\n   Obj : Suspension_Object;\n\n   task body Barrier_Task_1 is\n      OK : Boolean;\n   begin\n      Wait_For_Release (Bar, OK);\n      ABE;\n   end Barrier_Task_1;\n\n   task body Barrier_Task_2 is\n      procedure Block is\n         OK : Boolean;\n      begin\n         Wait_For_Release (Bar, OK);\n      end Block;\n   begin\n      Block;\n      ABE;\n   end Barrier_Task_2;\n\n   task body Object_Task_1 is\n   begin\n      Suspend_Until_True (Obj);\n      ABE;\n   end Object_Task_1;\n\n   task body Object_Task_2 is\n      procedure Block is\n      begin\n         Suspend_Until_True (Obj);\n      end Block;\n   begin\n      Block;\n      ABE;\n   end Object_Task_2;\n\n   function Elaborator return Boolean is\n      BT_1 : Barrier_Task_1;\n      BT_2 : Barrier_Task_2;\n      OT_1 : Object_Task_1;\n      OT_2 : Object_Task_2;\n   begin\n      return True;\n   end Elaborator;\n\n   Elab : constant Boolean := Elaborator;\n\n   procedure ABE is begin null; end ABE;\nend Suspension;\n\n--  main.adb\n\nwith Suspension;\n\nprocedure Main is begin null; end Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q -gnatd_s main.adb\nsuspension.adb:23:07: warning: cannot call \"ABE\" before body seen\nsuspension.adb:23:07: warning: Program_Error may be raised at run time\nsuspension.adb:23:07: warning:   body of unit \"Suspension\" elaborated\nsuspension.adb:23:07: warning:   function \"Elaborator\" called at line 51\nsuspension.adb:23:07: warning:   local tasks of \"Elaborator\" activated\nsuspension.adb:23:07: warning:   procedure \"ABE\" called at line 23\nsuspension.adb:39:07: warning: cannot call \"ABE\" before body seen\nsuspension.adb:39:07: warning: Program_Error may be raised at run time\nsuspension.adb:39:07: warning:   body of unit \"Suspension\" elaborated\nsuspension.adb:39:07: warning:   function \"Elaborator\" called at line 51\nsuspension.adb:39:07: warning:   local tasks of \"Elaborator\" activated\nsuspension.adb:39:07: warning:   procedure \"ABE\" called at line 39\n\n2018-05-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* debug.adb: Switch -gnatd_s is now used to stop elaboration checks on\n\tsynchronized suspension.\n\t* rtsfind.ads: Add entries for units Ada.Synchronous_Barriers and\n\tAda.Synchronous_Task_Control and routines Suspend_Until_True and\n\tWait_For_Release.\n\t* sem_elab.adb: Document switch -gnatd_s.\n\t(In_Task_Body): New routine.\n\t(Is_Potential_Scenario): Code cleanup. Stop the traversal of a task\n\tbody when the current construct denotes a synchronous suspension call,\n\tand restriction No_Entry_Calls_In_Elaboration_Code or switch -gnatd_s\n\tis in effect.\n\t(Is_Synchronous_Suspension_Call): New routine.\n\t* switch-c.adb (Scan_Front_End_Switches): Switch -gnatJ now sets switch\n\t-gnatd_s.\n\nFrom-SVN: r260585", "tree": {"sha": "c4db8bc4ea28bcc4d537f6ecf823d7d698c20e1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4db8bc4ea28bcc4d537f6ecf823d7d698c20e1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c9849e18b134711873df3bccd93d6b6faa93c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9849e18b134711873df3bccd93d6b6faa93c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9849e18b134711873df3bccd93d6b6faa93c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9849e18b134711873df3bccd93d6b6faa93c6f/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51ab2a39e9baae7fe1552daca02337050b11cfb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51ab2a39e9baae7fe1552daca02337050b11cfb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51ab2a39e9baae7fe1552daca02337050b11cfb6"}], "stats": {"total": 177, "additions": 160, "deletions": 17}, "files": [{"sha": "f24eda6a112cd690e417097f7bbfad96a323ff84", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0c9849e18b134711873df3bccd93d6b6faa93c6f", "patch": "@@ -1,3 +1,20 @@\n+2018-05-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* debug.adb: Switch -gnatd_s is now used to stop elaboration checks on\n+\tsynchronized suspension.\n+\t* rtsfind.ads: Add entries for units Ada.Synchronous_Barriers and\n+\tAda.Synchronous_Task_Control and routines Suspend_Until_True and\n+\tWait_For_Release.\n+\t* sem_elab.adb: Document switch -gnatd_s.\n+\t(In_Task_Body): New routine.\n+\t(Is_Potential_Scenario): Code cleanup. Stop the traversal of a task\n+\tbody when the current construct denotes a synchronous suspension call,\n+\tand restriction No_Entry_Calls_In_Elaboration_Code or switch -gnatd_s\n+\tis in effect.\n+\t(Is_Synchronous_Suspension_Call): New routine.\n+\t* switch-c.adb (Scan_Front_End_Switches): Switch -gnatJ now sets switch\n+\t-gnatd_s.\n+\n 2018-05-23  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_disp.adb (Make_DT): Restrict the initialization of"}, {"sha": "032443309b8ed5be41bb7da8f8b0afa0ecc90da9", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=0c9849e18b134711873df3bccd93d6b6faa93c6f", "patch": "@@ -163,7 +163,7 @@ package body Debug is\n    --  d_p  Ignore assertion pragmas for elaboration\n    --  d_q\n    --  d_r\n-   --  d_s\n+   --  d_s  Stop elaboration checks on synchronous suspension\n    --  d_t\n    --  d_u\n    --  d_v\n@@ -839,6 +839,10 @@ package body Debug is\n    --       semantics of invariants and postconditions in both the static and\n    --       dynamic elaboration models.\n \n+   --  d_s  The compiler stops the examination of a task body once it reaches\n+   --       a call to routine Ada.Synchronous_Task_Control.Suspend_Until_True\n+   --       or Ada.Synchronous_Barriers.Wait_For_Release.\n+\n    --  d_L  Output trace information on elaboration checking. This debug switch\n    --       causes output to be generated showing each call or instantiation as\n    --       it is checked, and the progress of the recursive trace through"}, {"sha": "53852584c3eeeb3acec056d21248244e6235a6eb", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=0c9849e18b134711873df3bccd93d6b6faa93c6f", "patch": "@@ -131,6 +131,8 @@ package Rtsfind is\n       Ada_Real_Time,\n       Ada_Streams,\n       Ada_Strings,\n+      Ada_Synchronous_Barriers,\n+      Ada_Synchronous_Task_Control,\n       Ada_Tags,\n       Ada_Task_Identification,\n       Ada_Task_Termination,\n@@ -609,6 +611,10 @@ package Rtsfind is\n \n      RE_Unbounded_String,                -- Ada.Strings.Unbounded\n \n+     RE_Wait_For_Release,                -- Ada.Synchronous_Barriers\n+\n+     RE_Suspend_Until_True,              -- Ada.Synchronous_Task_Control\n+\n      RE_Access_Level,                    -- Ada.Tags\n      RE_Alignment,                       -- Ada.Tags\n      RE_Address_Array,                   -- Ada.Tags\n@@ -1847,6 +1853,10 @@ package Rtsfind is\n \n      RE_Unbounded_String                 => Ada_Strings_Unbounded,\n \n+     RE_Wait_For_Release                 => Ada_Synchronous_Barriers,\n+\n+     RE_Suspend_Until_True               => Ada_Synchronous_Task_Control,\n+\n      RE_Access_Level                     => Ada_Tags,\n      RE_Alignment                        => Ada_Tags,\n      RE_Address_Array                    => Ada_Tags,"}, {"sha": "0b369ea91f67e916dd0626268e62027b18011e31", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 125, "deletions": 16, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=0c9849e18b134711873df3bccd93d6b6faa93c6f", "patch": "@@ -500,6 +500,14 @@ package body Sem_Elab is\n    --           As a result, the assertion expressions of the pragmas are not\n    --           processed.\n    --\n+   --  -gnatd_s stop elaboration checks on synchronous suspension\n+   --\n+   --           The ABE mechanism stops the traversal of a task body when it\n+   --           encounters a call to one of the following routines:\n+   --\n+   --             Ada.Synchronous_Barriers.Wait_For_Release\n+   --             Ada.Synchronous_Task_Control.Suspend_Until_True\n+   --\n    --  -gnatd.U ignore indirect calls for static elaboration\n    --\n    --           The ABE mechanism does not consider '[Unrestricted_]Access of\n@@ -554,6 +562,7 @@ package body Sem_Elab is\n    --              -gnatd_i\n    --              -gnatdL\n    --              -gnatd_p\n+   --              -gnatd_s\n    --              -gnatd.U\n    --              -gnatd.y\n    --\n@@ -1339,6 +1348,10 @@ package body Sem_Elab is\n    --  context ignoring enclosing library levels. Nested_OK should be set when\n    --  the context of N1 can enclose that of N2.\n \n+   function In_Task_Body (N : Node_Id) return Boolean;\n+   pragma Inline (In_Task_Body);\n+   --  Determine whether arbitrary node N appears within a task body\n+\n    procedure Info_Call\n      (Call      : Node_Id;\n       Target_Id : Entity_Id;\n@@ -1592,6 +1605,14 @@ package body Sem_Elab is\n    --  Determine whether arbitrary node N is a suitable variable reference for\n    --  ABE processing.\n \n+   function Is_Synchronous_Suspension_Call (N : Node_Id) return Boolean;\n+   pragma Inline (Is_Synchronous_Suspension_Call);\n+   --  Determine whether arbitrary node N denotes a call to one the following\n+   --  routines:\n+   --\n+   --    Ada.Synchronous_Barriers.Wait_For_Release\n+   --    Ada.Synchronous_Task_Control.Suspend_Until_True\n+\n    function Is_Task_Entry (Id : Entity_Id) return Boolean;\n    pragma Inline (Is_Task_Entry);\n    --  Determine whether arbitrary entity Id denotes a task entry\n@@ -6170,6 +6191,39 @@ package body Sem_Elab is\n       return False;\n    end In_Same_Context;\n \n+   ------------------\n+   -- In_Task_Body --\n+   ------------------\n+\n+   function In_Task_Body (N : Node_Id) return Boolean is\n+      Par : Node_Id;\n+\n+   begin\n+      --  Climb the parent chain looking for a task body [procedure]\n+\n+      Par := N;\n+      while Present (Par) loop\n+         if Nkind (Par) = N_Task_Body then\n+            return True;\n+\n+         elsif Nkind (Par) = N_Subprogram_Body\n+           and then Is_Task_Body_Procedure (Par)\n+         then\n+            return True;\n+\n+         --  Prevent the search from going too far. Note that this predicate\n+         --  shares nodes with the two cases above, and must come last.\n+\n+         elsif Is_Body_Or_Package_Declaration (Par) then\n+            return False;\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      return False;\n+   end In_Task_Body;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -7553,6 +7607,33 @@ package body Sem_Elab is\n       return Nkind (N) = N_Variable_Reference_Marker;\n    end Is_Suitable_Variable_Reference;\n \n+   ------------------------------------\n+   -- Is_Synchronous_Suspension_Call --\n+   ------------------------------------\n+\n+   function Is_Synchronous_Suspension_Call (N : Node_Id) return Boolean is\n+      Call_Attrs : Call_Attributes;\n+      Target_Id  : Entity_Id;\n+\n+   begin\n+      --  To qualify, the call must invoke one of the runtime routines which\n+      --  perform synchronous suspension.\n+\n+      if Is_Suitable_Call (N) then\n+         Extract_Call_Attributes\n+           (Call      => N,\n+            Target_Id => Target_Id,\n+            Attrs     => Call_Attrs);\n+\n+         return\n+           Is_RTE (Target_Id, RE_Suspend_Until_True)\n+             or else\n+           Is_RTE (Target_Id, RE_Wait_For_Release);\n+      end if;\n+\n+      return False;\n+   end Is_Synchronous_Suspension_Call;\n+\n    -------------------\n    -- Is_Task_Entry --\n    -------------------\n@@ -7770,7 +7851,7 @@ package body Sem_Elab is\n                      return Decl;\n \n                   --  Otherwise the construct terminates the region where the\n-                  --  preelabortion-related pragma may appear.\n+                  --  preelaboration-related pragma may appear.\n \n                   else\n                      exit;\n@@ -11110,24 +11191,52 @@ package body Sem_Elab is\n             if Is_Non_Library_Level_Encapsulator (Nod) then\n                return Skip;\n \n-            --  Terminate the traversal of a task body with an accept statement\n-            --  when no entry calls in elaboration are allowed because the task\n-            --  will block at run-time and the remaining statements will not be\n-            --  executed.\n-\n-            elsif Nkind_In (Original_Node (Nod), N_Accept_Statement,\n-                                                 N_Selective_Accept)\n+            --  Terminate the traversal of a task body when encountering an\n+            --  accept or select statement, and\n+            --\n+            --    * Entry calls during elaboration are not allowed. In this\n+            --      case the accept or select statement will cause the task\n+            --      to block at elaboration time because there are no entry\n+            --      calls to unblock it.\n+            --\n+            --  or\n+            --\n+            --    * Switch -gnatd_a (stop elaboration checks on accept or\n+            --      select statement) is in effect.\n+\n+            elsif (Debug_Flag_Underscore_A\n+                    or else Restriction_Active\n+                              (No_Entry_Calls_In_Elaboration_Code))\n+              and then Nkind_In (Original_Node (Nod), N_Accept_Statement,\n+                                                      N_Selective_Accept)\n             then\n-               if Restriction_Active (No_Entry_Calls_In_Elaboration_Code) then\n-                  return Abandon;\n+               return Abandon;\n \n-               --  The same behavior is achieved when switch -gnatd_a (stop\n-               --  elabortion checks on accept or select statement) is in\n-               --  effect.\n+            --  Terminate the traversal of a task body when encountering a\n+            --  suspension call, and\n+            --\n+            --    * Entry calls during elaboration are not allowed. In this\n+            --      case the suspension call emulates an entry call and will\n+            --      cause the task to block at elaboration time.\n+            --\n+            --  or\n+            --\n+            --    * Switch -gnatd_s (stop elaboration checks on synchronous\n+            --      suspension) is in effect.\n+            --\n+            --  Note that the guard should not be checking the state of flag\n+            --  Within_Task_Body because only suspension calls which appear\n+            --  immediately within the statements of the task are supported.\n+            --  Flag Within_Task_Body carries over to deeper levels of the\n+            --  traversal.\n \n-               elsif Debug_Flag_Underscore_A then\n-                  return Abandon;\n-               end if;\n+            elsif (Debug_Flag_Underscore_S\n+                    or else Restriction_Active\n+                              (No_Entry_Calls_In_Elaboration_Code))\n+              and then Is_Synchronous_Suspension_Call (Nod)\n+              and then In_Task_Body (Nod)\n+            then\n+               return Abandon;\n \n             --  Certain nodes carry semantic lists which act as repositories\n             --  until expansion transforms the node and relocates the contents."}, {"sha": "183d0efaf4fbd3715b6779f58758b104abe3c6c8", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9849e18b134711873df3bccd93d6b6faa93c6f/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=0c9849e18b134711873df3bccd93d6b6faa93c6f", "patch": "@@ -974,6 +974,8 @@ package body Switch.C is\n                --    -gnatd_i (ignore activations and calls to instances for\n                --              elaboration)\n                --    -gnatd_p (ignore assertion pragmas for elaboration)\n+               --    -gnatd_s (stop elaboration checks on synchronous\n+               --              suspension)\n                --    -gnatdL  (ignore external calls from instances for\n                --              elaboration)\n \n@@ -982,6 +984,7 @@ package body Switch.C is\n                   Debug_Flag_Underscore_E := True;\n                   Debug_Flag_Underscore_I := True;\n                   Debug_Flag_Underscore_P := True;\n+                  Debug_Flag_Underscore_S := True;\n                   Debug_Flag_LL           := True;\n                end if;\n "}]}