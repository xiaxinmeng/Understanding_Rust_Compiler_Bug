{"sha": "5d819bb7c82fa999fd4a1da2a3afdf715667859c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ4MTliYjdjODJmYTk5OWZkNGExZGEyYTNhZmRmNzE1NjY3ODU5Yw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2015-11-05T18:11:12Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2015-11-05T18:11:12Z"}, "message": "[Patch ifcvt] Teach RTL ifcvt to handle multiple simple set instructions\n\ngcc/\n\n\t* ifcvt.c (bb_ok_for_noce_convert_multiple_sets): New.\n\t(noce_convert_multiple_sets): Likewise.\n\t(noce_process_if_block): Call them.\n\ngcc/testsuite/\n\n\t* gcc.dg/ifcvt-4.c: New.\n\nFrom-SVN: r229822", "tree": {"sha": "72321ce3630c2bb5ac351b9e1a746d1d5d88340e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72321ce3630c2bb5ac351b9e1a746d1d5d88340e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d819bb7c82fa999fd4a1da2a3afdf715667859c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d819bb7c82fa999fd4a1da2a3afdf715667859c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d819bb7c82fa999fd4a1da2a3afdf715667859c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d819bb7c82fa999fd4a1da2a3afdf715667859c/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e4756e8438892aa362d846c83b91329a904e904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4756e8438892aa362d846c83b91329a904e904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4756e8438892aa362d846c83b91329a904e904"}], "stats": {"total": 278, "additions": 276, "deletions": 2}, "files": [{"sha": "4c37a919236c51854a140b8df22ab7c00d8a75ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d819bb7c82fa999fd4a1da2a3afdf715667859c", "patch": "@@ -1,3 +1,9 @@\n+2015-11-05  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* ifcvt.c (bb_ok_for_noce_convert_multiple_sets): New.\n+\t(noce_convert_multiple_sets): Likewise.\n+\t(noce_process_if_block): Call them.\n+\n 2015-11-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gimple-fold.c: Include omp-low.h."}, {"sha": "1c3328324adf569890beb456668231adecc3e95a", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 250, "deletions": 2, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=5d819bb7c82fa999fd4a1da2a3afdf715667859c", "patch": "@@ -3016,6 +3016,244 @@ bb_valid_for_noce_process_p (basic_block test_bb, rtx cond,\n   return false;\n }\n \n+/* We have something like:\n+\n+     if (x > y)\n+       { i = a; j = b; k = c; }\n+\n+   Make it:\n+\n+     tmp_i = (x > y) ? a : i;\n+     tmp_j = (x > y) ? b : j;\n+     tmp_k = (x > y) ? c : k;\n+     i = tmp_i;\n+     j = tmp_j;\n+     k = tmp_k;\n+\n+   Subsequent passes are expected to clean up the extra moves.\n+\n+   Look for special cases such as writes to one register which are\n+   read back in another SET, as might occur in a swap idiom or\n+   similar.\n+\n+   These look like:\n+\n+   if (x > y)\n+     i = a;\n+     j = i;\n+\n+   Which we want to rewrite to:\n+\n+     tmp_i = (x > y) ? a : i;\n+     tmp_j = (x > y) ? tmp_i : j;\n+     i = tmp_i;\n+     j = tmp_j;\n+\n+   We can catch these when looking at (SET x y) by keeping a list of the\n+   registers we would have targeted before if-conversion and looking back\n+   through it for an overlap with Y.  If we find one, we rewire the\n+   conditional set to use the temporary we introduced earlier.\n+\n+   IF_INFO contains the useful information about the block structure and\n+   jump instructions.  */\n+\n+static int\n+noce_convert_multiple_sets (struct noce_if_info *if_info)\n+{\n+  basic_block test_bb = if_info->test_bb;\n+  basic_block then_bb = if_info->then_bb;\n+  basic_block join_bb = if_info->join_bb;\n+  rtx_insn *jump = if_info->jump;\n+  rtx_insn *cond_earliest;\n+  rtx_insn *insn;\n+\n+  start_sequence ();\n+\n+  /* Decompose the condition attached to the jump.  */\n+  rtx cond = noce_get_condition (jump, &cond_earliest, false);\n+  rtx x = XEXP (cond, 0);\n+  rtx y = XEXP (cond, 1);\n+  rtx_code cond_code = GET_CODE (cond);\n+\n+  /* The true targets for a conditional move.  */\n+  vec<rtx> targets = vNULL;\n+  /* The temporaries introduced to allow us to not consider register\n+     overlap.  */\n+  vec<rtx> temporaries = vNULL;\n+  /* The insns we've emitted.  */\n+  vec<rtx_insn *> unmodified_insns = vNULL;\n+  int count = 0;\n+\n+  FOR_BB_INSNS (then_bb, insn)\n+    {\n+      /* Skip over non-insns.  */\n+      if (!active_insn_p (insn))\n+\tcontinue;\n+\n+      rtx set = single_set (insn);\n+      gcc_checking_assert (set);\n+\n+      rtx target = SET_DEST (set);\n+      rtx temp = gen_reg_rtx (GET_MODE (target));\n+      rtx new_val = SET_SRC (set);\n+      rtx old_val = target;\n+\n+      /* If we were supposed to read from an earlier write in this block,\n+\t we've changed the register allocation.  Rewire the read.  While\n+\t we are looking, also try to catch a swap idiom.  */\n+      for (int i = count - 1; i >= 0; --i)\n+\tif (reg_overlap_mentioned_p (new_val, targets[i]))\n+\t  {\n+\t    /* Catch a \"swap\" style idiom.  */\n+\t    if (find_reg_note (insn, REG_DEAD, new_val) != NULL_RTX)\n+\t      /* The write to targets[i] is only live until the read\n+\t\t here.  As the condition codes match, we can propagate\n+\t\t the set to here.  */\n+\t      new_val = SET_SRC (single_set (unmodified_insns[i]));\n+\t    else\n+\t      new_val = temporaries[i];\n+\t    break;\n+\t  }\n+\n+      /* If we had a non-canonical conditional jump (i.e. one where\n+\t the fallthrough is to the \"else\" case) we need to reverse\n+\t the conditional select.  */\n+      if (if_info->then_else_reversed)\n+\tstd::swap (old_val, new_val);\n+\n+      /* Actually emit the conditional move.  */\n+      rtx temp_dest = noce_emit_cmove (if_info, temp, cond_code,\n+\t\t\t\t       x, y, new_val, old_val);\n+\n+      /* If we failed to expand the conditional move, drop out and don't\n+\t try to continue.  */\n+      if (temp_dest == NULL_RTX)\n+\t{\n+\t  end_sequence ();\n+\t  return FALSE;\n+\t}\n+\n+      /* Bookkeeping.  */\n+      count++;\n+      targets.safe_push (target);\n+      temporaries.safe_push (temp_dest);\n+      unmodified_insns.safe_push (insn);\n+    }\n+\n+  /* We must have seen some sort of insn to insert, otherwise we were\n+     given an empty BB to convert, and we can't handle that.  */\n+  gcc_assert (!unmodified_insns.is_empty ());\n+\n+  /* Now fixup the assignments.  */\n+  for (int i = 0; i < count; i++)\n+    noce_emit_move_insn (targets[i], temporaries[i]);\n+\n+  /* Actually emit the sequence.  */\n+  rtx_insn *seq = get_insns ();\n+\n+  for (insn = seq; insn; insn = NEXT_INSN (insn))\n+    set_used_flags (insn);\n+\n+  /* Mark all our temporaries and targets as used.  */\n+  for (int i = 0; i < count; i++)\n+    {\n+      set_used_flags (temporaries[i]);\n+      set_used_flags (targets[i]);\n+    }\n+\n+  set_used_flags (cond);\n+  set_used_flags (x);\n+  set_used_flags (y);\n+\n+  unshare_all_rtl_in_chain (seq);\n+  end_sequence ();\n+\n+  if (!seq)\n+    return FALSE;\n+\n+  for (insn = seq; insn; insn = NEXT_INSN (insn))\n+    if (JUMP_P (insn)\n+\t|| recog_memoized (insn) == -1)\n+      return FALSE;\n+\n+  emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t   INSN_LOCATION (unmodified_insns.last ()));\n+\n+  /* Clean up THEN_BB and the edges in and out of it.  */\n+  remove_edge (find_edge (test_bb, join_bb));\n+  remove_edge (find_edge (then_bb, join_bb));\n+  redirect_edge_and_branch_force (single_succ_edge (test_bb), join_bb);\n+  delete_basic_block (then_bb);\n+  num_true_changes++;\n+\n+  /* Maybe merge blocks now the jump is simple enough.  */\n+  if (can_merge_blocks_p (test_bb, join_bb))\n+    {\n+      merge_blocks (test_bb, join_bb);\n+      num_true_changes++;\n+    }\n+\n+  num_updated_if_blocks++;\n+  return TRUE;\n+}\n+\n+/* Return true iff basic block TEST_BB is comprised of only\n+   (SET (REG) (REG)) insns suitable for conversion to a series\n+   of conditional moves.  FORNOW: Use II to find the expected cost of\n+   the branch into/over TEST_BB.\n+\n+   TODO: This creates an implicit \"magic number\" for branch_cost.\n+   II->branch_cost now guides the maximum number of set instructions in\n+   a basic block which is considered profitable to completely\n+   if-convert.  */\n+\n+static bool\n+bb_ok_for_noce_convert_multiple_sets (basic_block test_bb,\n+\t\t\t\t      struct noce_if_info *ii)\n+{\n+  rtx_insn *insn;\n+  unsigned count = 0;\n+\n+  FOR_BB_INSNS (test_bb, insn)\n+    {\n+      /* Skip over notes etc.  */\n+      if (!active_insn_p (insn))\n+\tcontinue;\n+\n+      /* We only handle SET insns.  */\n+      rtx set = single_set (insn);\n+      if (set == NULL_RTX)\n+\treturn false;\n+\n+      rtx dest = SET_DEST (set);\n+      rtx src = SET_SRC (set);\n+\n+      /* We can possibly relax this, but for now only handle REG to REG\n+\t moves.  This avoids any issues that might come from introducing\n+\t loads/stores that might violate data-race-freedom guarantees.  */\n+      if (!(REG_P (src) && REG_P (dest)))\n+\treturn false;\n+\n+      /* Destination must be appropriate for a conditional write.  */\n+      if (!noce_operand_ok (dest))\n+\treturn false;\n+\n+      /* We must be able to conditionally move in this mode.  */\n+      if (!can_conditionally_move_p (GET_MODE (dest)))\n+\treturn false;\n+\n+      ++count;\n+    }\n+\n+  /* FORNOW: Our cost model is a count of the number of instructions we\n+     would if-convert.  This is suboptimal, and should be improved as part\n+     of a wider rework of branch_cost.  */\n+  if (count > ii->branch_cost)\n+    return FALSE;\n+\n+  return count > 0;\n+}\n+\n /* Given a simple IF-THEN-JOIN or IF-THEN-ELSE-JOIN block, attempt to convert\n    it without using conditional execution.  Return TRUE if we were successful\n    at converting the block.  */\n@@ -3038,12 +3276,22 @@ noce_process_if_block (struct noce_if_info *if_info)\n      (1) if (...) x = a; else x = b;\n      (2) x = b; if (...) x = a;\n      (3) if (...) x = a;   // as if with an initial x = x.\n-\n+     (4) if (...) { x = a; y = b; z = c; }  // Like 3, for multiple SETS.\n      The later patterns require jumps to be more expensive.\n      For the if (...) x = a; else x = b; case we allow multiple insns\n      inside the then and else blocks as long as their only effect is\n      to calculate a value for x.\n-     ??? For future expansion, look for multiple X in such patterns.  */\n+     ??? For future expansion, further expand the \"multiple X\" rules.  */\n+\n+  /* First look for multiple SETS.  */\n+  if (!else_bb\n+      && HAVE_conditional_move\n+      && !HAVE_cc0\n+      && bb_ok_for_noce_convert_multiple_sets (then_bb, if_info))\n+    {\n+      if (noce_convert_multiple_sets (if_info))\n+\treturn TRUE;\n+    }\n \n   if (! bb_valid_for_noce_process_p (then_bb, cond, &if_info->then_cost,\n \t\t\t\t    &if_info->then_simple))"}, {"sha": "bcf909635b6a9c4d75927a4e5b18a504d84c17d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d819bb7c82fa999fd4a1da2a3afdf715667859c", "patch": "@@ -1,3 +1,7 @@\n+2015-11-05  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.dg/ifcvt-4.c: New.\n+\n 2015-11-05  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/67846"}, {"sha": "16be2b05c47912ad5b38b2d9eda05f725b3633cb", "filename": "gcc/testsuite/gcc.dg/ifcvt-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d819bb7c82fa999fd4a1da2a3afdf715667859c/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c?ref=5d819bb7c82fa999fd4a1da2a3afdf715667859c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-fdump-rtl-ce1 -O2\" } */\n+int\n+foo (int x, int y, int a)\n+{\n+  int i = x;\n+  int j = y;\n+  /* Try to make taking the branch likely.  */\n+  __builtin_expect (x > y, 1);\n+  if (x > y)\n+    {\n+      i = a;\n+      j = i;\n+    }\n+  return i * j;\n+}\n+/* { dg-final { scan-rtl-dump \"2 true changes made\" \"ce1\" } } */"}]}