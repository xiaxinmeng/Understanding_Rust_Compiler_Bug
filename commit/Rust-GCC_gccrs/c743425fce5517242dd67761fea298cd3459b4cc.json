{"sha": "c743425fce5517242dd67761fea298cd3459b4cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0MzQyNWZjZTU1MTcyNDJkZDY3NzYxZmVhMjk4Y2QzNDU5YjRjYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-10-09T15:06:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-10-09T15:06:55Z"}, "message": "[Ada] Fix spurious -Wuninitialized warnings for small records\n\nThis change is aimed at getting rid of spurious -Wuninitialized warnings\nissued for small records passed by copy and containing default values\nfor some of their components.\n\nThe source of the problem is that the _Init parameter of the\ninitialization routine is declared as an in/out parameter, so the\nuninitialized object is passed by copy to it and this can be flagged by\n-Wuninitialized.\n\nThat's why the mode of the parameter is changed to out, except for the\ncases where information really needs to be passed in: unconstrained\narray types, protected and task types.\n\nFor the following record type Rec!\n\n type Rec is record\n    B : Boolean := True;\n  end record;\n\nthe initialization routine must now be:\n\n      procedure r__recIP (_init : out r__rec1) is\n      begin\n         _init.b := true;\n         return;\n      end r__recIP;\n\n2018-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch3.adb (Is_Null_Statement_List): New predicate.\n\t(Build_Array_Init_Proc): Use it to find out whether the\n\tinitialization procedure Is_Null_Init_Proc; if so, set\n\tWarnings_Off on the parameter.\n\t(Build_Init_Procedure): Likewise.\n\t(Init_Formals): Use an in/out first parameter only for\n\tunconstrained arrays and for records either containing or built\n\tfor proteced types or task types; use an out parameter in all\n\tthe other cases.\n\t* fe.h (Is_Init_Proc): Declare.\n\t* gcc-interface/decl.c (type_requires_init_of_formal): Do not\n\treturn true for a discriminant in an unchecked union.\n\t(gnat_to_gnu_param): Do not create a PARM_DECL for the Out\n\tparameter of an initialization procedure.\n\nFrom-SVN: r264984", "tree": {"sha": "8681015a93c746718344e21e388debb458823320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8681015a93c746718344e21e388debb458823320"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c743425fce5517242dd67761fea298cd3459b4cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c743425fce5517242dd67761fea298cd3459b4cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c743425fce5517242dd67761fea298cd3459b4cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c743425fce5517242dd67761fea298cd3459b4cc/comments", "author": null, "committer": null, "parents": [{"sha": "4b9e1bc78110d65377acdf23ee3733f8c69baef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b9e1bc78110d65377acdf23ee3733f8c69baef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b9e1bc78110d65377acdf23ee3733f8c69baef9"}], "stats": {"total": 127, "additions": 99, "deletions": 28}, "files": [{"sha": "3aa9a88a5889adf01859e9069fe805f301086672", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c743425fce5517242dd67761fea298cd3459b4cc", "patch": "@@ -1,3 +1,20 @@\n+2018-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch3.adb (Is_Null_Statement_List): New predicate.\n+\t(Build_Array_Init_Proc): Use it to find out whether the\n+\tinitialization procedure Is_Null_Init_Proc; if so, set\n+\tWarnings_Off on the parameter.\n+\t(Build_Init_Procedure): Likewise.\n+\t(Init_Formals): Use an in/out first parameter only for\n+\tunconstrained arrays and for records either containing or built\n+\tfor proteced types or task types; use an out parameter in all\n+\tthe other cases.\n+\t* fe.h (Is_Init_Proc): Declare.\n+\t* gcc-interface/decl.c (type_requires_init_of_formal): Do not\n+\treturn true for a discriminant in an unchecked union.\n+\t(gnat_to_gnu_param): Do not create a PARM_DECL for the Out\n+\tparameter of an initialization procedure.\n+\n 2018-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: If"}, {"sha": "e116cda4442870205b60bd7854085206407855d1", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 70, "deletions": 25, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=c743425fce5517242dd67761fea298cd3459b4cc", "patch": "@@ -202,6 +202,11 @@ package body Exp_Ch3 is\n    --  Check if E is defined in the RTL (in a child of Ada or System). Used\n    --  to avoid to bring in the overhead of _Input, _Output for tagged types.\n \n+   function Is_Null_Statement_List (Stmts : List_Id) return Boolean;\n+   --  Returns true if Stmts is made of null statements only, possibly wrapped\n+   --  in a case statement, recursively. This latter pattern may occur for the\n+   --  initialization procedure of an unchecked union.\n+\n    function Is_User_Defined_Equality (Prim : Node_Id) return Boolean;\n    --  Returns true if Prim is a user defined equality function\n \n@@ -529,6 +534,7 @@ package body Exp_Ch3 is\n       Has_Default_Init : Boolean;\n       Index_List       : List_Id;\n       Loc              : Source_Ptr;\n+      Parameters       : List_Id;\n       Proc_Id          : Entity_Id;\n \n       function Init_Component return List_Id;\n@@ -722,13 +728,14 @@ package body Exp_Ch3 is\n          end if;\n \n          Body_Stmts := Init_One_Dimension (1);\n+         Parameters := Init_Formals (A_Type);\n \n          Discard_Node (\n            Make_Subprogram_Body (Loc,\n              Specification =>\n                Make_Procedure_Specification (Loc,\n                  Defining_Unit_Name => Proc_Id,\n-                 Parameter_Specifications => Init_Formals (A_Type)),\n+                 Parameter_Specifications => Parameters),\n              Declarations => New_List,\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n@@ -753,18 +760,14 @@ package body Exp_Ch3 is\n          --  where we have to generate a null procedure in case it is called\n          --  by a client with Initialize_Scalars set). Such procedures have\n          --  to be generated, but do not have to be called, so we mark them\n-         --  as null to suppress the call.\n+         --  as null to suppress the call. Kill also warnings for the _Init\n+         --  out parameter, which is left entirely uninitialized.\n \n          Set_Init_Proc (A_Type, Proc_Id);\n \n-         if List_Length (Body_Stmts) = 1\n-\n-           --  We must skip SCIL nodes because they may have been added to this\n-           --  list by Insert_Actions.\n-\n-           and then Nkind (First_Non_SCIL_Node (Body_Stmts)) = N_Null_Statement\n-         then\n+         if Is_Null_Statement_List (Body_Stmts) then\n             Set_Is_Null_Init_Proc (Proc_Id);\n+            Set_Warnings_Off (Defining_Identifier (First (Parameters)));\n \n          else\n             --  Try to build a static aggregate to statically initialize\n@@ -2803,18 +2806,14 @@ package body Exp_Ch3 is\n          --  where we have to generate a null procedure in case it is called\n          --  by a client with Initialize_Scalars set). Such procedures have\n          --  to be generated, but do not have to be called, so we mark them\n-         --  as null to suppress the call.\n+         --  as null to suppress the call. Kill also warnings for the _Init\n+         --  out parameter, which is left entirely uninitialized.\n \n          Set_Init_Proc (Rec_Type, Proc_Id);\n \n-         if List_Length (Body_Stmts) = 1\n-\n-           --  We must skip SCIL nodes because they may have been added to this\n-           --  list by Insert_Actions.\n-\n-           and then Nkind (First_Non_SCIL_Node (Body_Stmts)) = N_Null_Statement\n-         then\n+         if Is_Null_Statement_List (Body_Stmts) then\n             Set_Is_Null_Init_Proc (Proc_Id);\n+            Set_Warnings_Off (Defining_Identifier (First (Parameters)));\n          end if;\n       end Build_Init_Procedure;\n \n@@ -8612,29 +8611,38 @@ package body Exp_Ch3 is\n    ------------------\n \n    function Init_Formals (Typ : Entity_Id) return List_Id is\n+      Unc_Arr : constant Boolean :=\n+        Is_Array_Type (Typ) and then not Is_Constrained (Typ);\n+      With_Prot  : constant Boolean :=\n+        Has_Protected (Typ)\n+          or else (Is_Record_Type (Typ)\n+                     and then Is_Protected_Record_Type (Typ));\n+      With_Task  : constant Boolean :=\n+        Has_Task (Typ)\n+          or else (Is_Record_Type (Typ)\n+                     and then Is_Task_Record_Type (Typ));\n       Loc     : constant Source_Ptr := Sloc (Typ);\n       Formals : List_Id;\n \n    begin\n-      --  First parameter is always _Init : in out typ. Note that we need this\n-      --  to be in/out because in the case of the task record value, there\n-      --  are default record fields (_Priority, _Size, -Task_Info) that may\n-      --  be referenced in the generated initialization routine.\n+      --  The first parameter is always _Init : [in] out Typ. Note that we need\n+      --  it to be in/out in the case of an unconstrained array, because of the\n+      --  need to have the bounds, and in the case of protected or task record\n+      --  value, because there are default record fields that may be referenced\n+      --  in the generated initialization routine.\n \n       Formals := New_List (\n         Make_Parameter_Specification (Loc,\n           Defining_Identifier => Make_Defining_Identifier (Loc, Name_uInit),\n-          In_Present          => True,\n+          In_Present          => Unc_Arr or else With_Prot or else With_Task,\n           Out_Present         => True,\n           Parameter_Type      => New_Occurrence_Of (Typ, Loc)));\n \n       --  For task record value, or type that contains tasks, add two more\n       --  formals, _Master : Master_Id and _Chain : in out Activation_Chain\n       --  We also add these parameters for the task record type case.\n \n-      if Has_Task (Typ)\n-        or else (Is_Record_Type (Typ) and then Is_Task_Record_Type (Typ))\n-      then\n+      if With_Task then\n          Append_To (Formals,\n            Make_Parameter_Specification (Loc,\n              Defining_Identifier =>\n@@ -9022,6 +9030,43 @@ package body Exp_Ch3 is\n       end loop;\n    end Init_Secondary_Tags;\n \n+   ----------------------------\n+   -- Is_Null_Statement_List --\n+   ----------------------------\n+\n+   function Is_Null_Statement_List (Stmts : List_Id) return Boolean is\n+      Stmt : Node_Id;\n+\n+   begin\n+      --  We must skip SCIL nodes because they may have been added to the\n+      --  list by Insert_Actions.\n+\n+      Stmt := First_Non_SCIL_Node (Stmts);\n+      while Present (Stmt) loop\n+         if Nkind (Stmt) = N_Case_Statement then\n+            declare\n+               Alt : Node_Id;\n+            begin\n+               Alt := First (Alternatives (Stmt));\n+               while Present (Alt) loop\n+                  if not Is_Null_Statement_List (Statements (Alt)) then\n+                     return False;\n+                  end if;\n+\n+                  Next (Alt);\n+               end loop;\n+            end;\n+\n+         elsif Nkind (Stmt) /= N_Null_Statement then\n+            return False;\n+         end if;\n+\n+         Stmt := Next_Non_SCIL_Node (Stmt);\n+      end loop;\n+\n+      return True;\n+   end Is_Null_Statement_List;\n+\n    ------------------------------\n    -- Is_User_Defined_Equality --\n    ------------------------------"}, {"sha": "b0ccbdc66d001cb054ea4e19ff28fde855a09c6a", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=c743425fce5517242dd67761fea298cd3459b4cc", "patch": "@@ -156,6 +156,12 @@ extern void Setup_Asm_Outputs\t\t(Node_Id);\n extern void Get_Encoded_Name\t(Entity_Id);\n extern void Get_External_Name\t(Entity_Id, Boolean, String_Pointer);\n \n+/* exp_tss: */\n+\n+#define Is_Init_Proc exp_tss__is_init_proc\n+\n+extern Boolean Is_Init_Proc\t\t(Entity_Id);\n+\n /* exp_util: */\n \n #define Is_Fully_Repped_Tagged_Type exp_util__is_fully_repped_tagged_type"}, {"sha": "c658aace36e78116875777192b274ce52d780f9c", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c743425fce5517242dd67761fea298cd3459b4cc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c743425fce5517242dd67761fea298cd3459b4cc", "patch": "@@ -5153,7 +5153,7 @@ type_requires_init_of_formal (Entity_Id type)\n \t Present (field);\n \t field = Next_Entity (field))\n       {\n-\tif (Ekind (field) == E_Discriminant)\n+\tif (Ekind (field) == E_Discriminant && !Is_Unchecked_Union (type))\n \t  return true;\n \n \tif (Ekind (field) == E_Component\n@@ -5334,11 +5334,14 @@ gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n      type doesn't require the initialization of formals, we don't make a\n      PARM_DECL for it.  Instead, it will be a VAR_DECL created when we\n      process the procedure, so just return its type here.  Likewise for\n-     the special parameter of a valued procedure, never pass it in.  */\n+     the _Init parameter of an initialization procedure or the special\n+     parameter of a valued procedure, never pass them in.  */\n   if (Ekind (gnat_param) == E_Out_Parameter\n       && !by_ref\n       && !by_component_ptr\n-      && (!type_requires_init_of_formal (Etype (gnat_param)) || by_return))\n+      && (!type_requires_init_of_formal (Etype (gnat_param))\n+\t  || Is_Init_Proc (gnat_subprog)\n+\t  || by_return))\n     return gnu_param_type;\n \n   gnu_param = create_param_decl (gnu_param_name, gnu_param_type);"}]}