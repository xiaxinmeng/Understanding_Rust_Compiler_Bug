{"sha": "149052510483ab2ea3cf02d085e1f31ebe5360c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ5MDUyNTEwNDgzYWIyZWEzY2YwMmQwODVlMWYzMWViZTUzNjBjNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-04-19T18:02:39Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-04-19T18:02:39Z"}, "message": "libstdc++/70609 fix filesystem::copy()\n\n\tPR libstdc++/70609\n\t* src/filesystem/ops.cc (close_fd): New function.\n\t(do_copy_file): Set permissions before copying file contents. Check\n\tresult of closing file descriptors. Don't copy streambuf when file\n\tis empty.\n\t(copy(const path&, const path&, copy_options, error_code&)): Use\n\tlstat for source file when copy_symlinks is set.\n\t* testsuite/experimental/filesystem/operations/copy.cc: Test copy().\n\nFrom-SVN: r235215", "tree": {"sha": "969f95aefd9527a1f249ca7155f17f8ec69d9f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/969f95aefd9527a1f249ca7155f17f8ec69d9f1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/149052510483ab2ea3cf02d085e1f31ebe5360c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/149052510483ab2ea3cf02d085e1f31ebe5360c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/149052510483ab2ea3cf02d085e1f31ebe5360c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/149052510483ab2ea3cf02d085e1f31ebe5360c5/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c476ad42618dd03353d8f8ae82b00a945974ecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c476ad42618dd03353d8f8ae82b00a945974ecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c476ad42618dd03353d8f8ae82b00a945974ecd"}], "stats": {"total": 192, "additions": 163, "deletions": 29}, "files": [{"sha": "1607e63d6093094dc15a1a5f37a6f135dc3e6c5c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/149052510483ab2ea3cf02d085e1f31ebe5360c5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/149052510483ab2ea3cf02d085e1f31ebe5360c5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=149052510483ab2ea3cf02d085e1f31ebe5360c5", "patch": "@@ -1,5 +1,14 @@\n 2016-04-19  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/70609\n+\t* src/filesystem/ops.cc (close_fd): New function.\n+\t(do_copy_file): Set permissions before copying file contents. Check\n+\tresult of closing file descriptors. Don't copy streambuf when file\n+\tis empty.\n+\t(copy(const path&, const path&, copy_options, error_code&)): Use\n+\tlstat for source file when copy_symlinks is set.\n+\t* testsuite/experimental/filesystem/operations/copy.cc: Test copy().\n+\n \t* include/experimental/bits/fs_fwd.h (operator&, operator|, operator^,\n \toperator~ operator&=, operator|=, operator^=): Add noexcept to\n \toverloaded operators for copy_options, perms and directory_options."}, {"sha": "aa26cafa1032657e79861a235f4cbbf5c7e48071", "filename": "libstdc++-v3/src/filesystem/ops.cc", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/149052510483ab2ea3cf02d085e1f31ebe5360c5/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/149052510483ab2ea3cf02d085e1f31ebe5360c5/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc?ref=149052510483ab2ea3cf02d085e1f31ebe5360c5", "patch": "@@ -300,6 +300,17 @@ namespace\n     };\n   }\n \n+  // Returns true if the file descriptor was successfully closed,\n+  // otherwise returns false and the reason will be in errno.\n+  inline bool\n+  close_fd(int fd)\n+  {\n+    while (::close(fd))\n+      if (errno != EINTR)\n+\treturn false;\n+    return true;\n+  }\n+\n   bool\n   do_copy_file(const fs::path& from, const fs::path& to,\n \t       fs::copy_options option,\n@@ -376,7 +387,8 @@ namespace\n       }\n \n     struct CloseFD {\n-      ~CloseFD() { if (fd != -1) ::close(fd); }\n+      ~CloseFD() { if (fd != -1) close_fd(fd); }\n+      bool close() { return close_fd(std::exchange(fd, -1)); }\n       int fd;\n     };\n \n@@ -401,34 +413,49 @@ namespace\n \treturn false;\n       }\n \n+#ifdef _GLIBCXX_USE_FCHMOD\n+    if (::fchmod(out.fd, from_st->st_mode))\n+#elif _GLIBCXX_USE_FCHMODAT\n+    if (::fchmodat(AT_FDCWD, to.c_str(), from_st->st_mode, 0))\n+#else\n+    if (::chmod(to.c_str(), from_st->st_mode))\n+#endif\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n+\n #ifdef _GLIBCXX_USE_SENDFILE\n-    auto n = ::sendfile(out.fd, in.fd, nullptr, from_st->st_size);\n+    const auto n = ::sendfile(out.fd, in.fd, nullptr, from_st->st_size);\n     if (n != from_st->st_size)\n       {\n \tec.assign(errno, std::generic_category());\n \treturn false;\n       }\n+    if (!out.close() || !in.close())\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n #else\n     __gnu_cxx::stdio_filebuf<char> sbin(in.fd, std::ios::in);\n     __gnu_cxx::stdio_filebuf<char> sbout(out.fd, std::ios::out);\n-    if ( !(std::ostream(&sbout) << &sbin) )\n+    if (sbin.is_open())\n+      in.fd = -1;\n+    if (sbout.is_open())\n+      out.fd = -1;\n+    if (from_st->st_size && !(std::ostream(&sbout) << &sbin))\n       {\n \tec = std::make_error_code(std::errc::io_error);\n \treturn false;\n       }\n-#endif\n-\n-#ifdef _GLIBCXX_USE_FCHMOD\n-    if (::fchmod(out.fd, from_st->st_mode))\n-#elif _GLIBCXX_USE_FCHMODAT\n-    if (::fchmodat(AT_FDCWD, to.c_str(), from_st->st_mode, 0))\n-#else\n-    if (::chmod(to.c_str(), from_st->st_mode))\n-#endif\n+    if (sbout.close() || sbin.close())\n       {\n \tec.assign(errno, std::generic_category());\n \treturn false;\n       }\n+#endif\n+\n     ec.clear();\n     return true;\n   }\n@@ -439,13 +466,15 @@ void\n fs::copy(const path& from, const path& to, copy_options options,\n \t error_code& ec) noexcept\n {\n-  bool skip_symlinks = is_set(options, copy_options::skip_symlinks);\n-  bool create_symlinks = is_set(options, copy_options::create_symlinks);\n-  bool use_lstat = create_symlinks || skip_symlinks;\n+  const bool skip_symlinks = is_set(options, copy_options::skip_symlinks);\n+  const bool create_symlinks = is_set(options, copy_options::create_symlinks);\n+  const bool copy_symlinks = is_set(options, copy_options::copy_symlinks);\n+  const bool use_lstat = create_symlinks || skip_symlinks;\n \n   file_status f, t;\n   stat_type from_st, to_st;\n-  if (use_lstat\n+  // N4099 doesn't check copy_symlinks here, but I think that's a defect.\n+  if (use_lstat || copy_symlinks\n       ? ::lstat(from.c_str(), &from_st)\n       : ::stat(from.c_str(), &from_st))\n     {\n@@ -488,7 +517,7 @@ fs::copy(const path& from, const path& to, copy_options options,\n     {\n       if (skip_symlinks)\n \tec.clear();\n-      else if (!exists(t) && is_set(options, copy_options::copy_symlinks))\n+      else if (!exists(t) && copy_symlinks)\n \tcopy_symlink(from, to, ec);\n       else\n \t// Not clear what should be done here."}, {"sha": "a5f6a3e861371dab66156b4ff6f681a63f663493", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc", "status": "modified", "additions": 108, "deletions": 12, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/149052510483ab2ea3cf02d085e1f31ebe5360c5/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/149052510483ab2ea3cf02d085e1f31ebe5360c5/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fcopy.cc?ref=149052510483ab2ea3cf02d085e1f31ebe5360c5", "patch": "@@ -21,39 +21,135 @@\n // 15.3 Copy [fs.op.copy]\n \n #include <experimental/filesystem>\n+#include <fstream>\n #include <testsuite_fs.h>\n #include <testsuite_hooks.h>\n \n-using std::experimental::filesystem::path;\n+namespace fs = std::experimental::filesystem;\n \n+// Test error conditions.\n void\n test01()\n {\n   bool test __attribute__((unused)) = false;\n \n-  for (const path& p : __gnu_test::test_paths)\n-    VERIFY( absolute(p).is_absolute() );\n+  auto p = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+  VERIFY( !fs::exists(p) );\n+  fs::copy(p, \".\", fs::copy_options::none, ec);\n+  VERIFY( ec );\n+\n+  ec.clear();\n+  fs::copy(\".\", \".\", fs::copy_options::none, ec);\n+  VERIFY( ec );\n+\n+  std::ofstream{p.native()};\n+  VERIFY( fs::is_directory(\".\") );\n+  VERIFY( fs::is_regular_file(p) );\n+  ec.clear();\n+  fs::copy(\".\", p, fs::copy_options::none, ec);\n+  VERIFY( ec );\n+\n+  remove(p, ec);\n }\n \n+// Test is_symlink(f) case.\n void\n test02()\n {\n   bool test __attribute__((unused)) = false;\n \n-  path p1(\"/\");\n-  VERIFY( absolute(p1) == p1 );\n-  VERIFY( absolute(p1, \"/bar\") == p1 );\n-  path p2(\"/foo\");\n-  VERIFY( absolute(p2) == p2 );\n-  VERIFY( absolute(p2, \"/bar\") == p2 );\n-  path p3(\"foo\");\n-  VERIFY( absolute(p3) != p3 );\n-  VERIFY( absolute(p3, \"/bar\") == \"/bar/foo\" );\n+  auto from = __gnu_test::nonexistent_path();\n+  auto to = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+  fs::create_symlink(\".\", from, ec);\n+  VERIFY( !ec );\n+  VERIFY( fs::exists(from) );\n+\n+  fs::copy(from, to, fs::copy_options::skip_symlinks, ec);\n+  VERIFY( !ec );\n+  VERIFY( !fs::exists(to) );\n+\n+  fs::copy(from, to, fs::copy_options::skip_symlinks, ec);\n+  VERIFY( !ec );\n+  VERIFY( !fs::exists(to) );\n+\n+  fs::copy(from, to,\n+           fs::copy_options::skip_symlinks|fs::copy_options::copy_symlinks,\n+           ec);\n+  VERIFY( !ec );\n+  VERIFY( !fs::exists(to) );\n+\n+  fs::copy(from, to, fs::copy_options::copy_symlinks, ec);\n+  VERIFY( !ec );\n+  VERIFY( fs::exists(to) );\n+\n+  fs::copy(from, to, fs::copy_options::copy_symlinks, ec);\n+  VERIFY( ec );\n+\n+  remove(from, ec);\n+  remove(to, ec);\n+}\n+\n+// Test is_regular_file(f) case.\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto from = __gnu_test::nonexistent_path();\n+  auto to = __gnu_test::nonexistent_path();\n+\n+  // test empty file\n+  std::ofstream{from.native()};\n+  VERIFY( fs::exists(from) );\n+  VERIFY( fs::file_size(from) == 0 );\n+  fs::copy(from, to);\n+  VERIFY( fs::exists(to) );\n+  VERIFY( fs::file_size(to) == 0 );\n+\n+  remove(to);\n+  VERIFY( !fs::exists(to) );\n+  std::ofstream{from.native()} << \"Hello, filesystem!\";\n+  VERIFY( fs::file_size(from) != 0 );\n+  fs::copy(from, to);\n+  VERIFY( fs::exists(to) );\n+  VERIFY( fs::file_size(to) == fs::file_size(from) );\n+}\n+\n+// Test is_directory(f) case.\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto from = __gnu_test::nonexistent_path();\n+  auto to = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+}\n+\n+// Test no-op cases.\n+void\n+test05()\n+{\n+  bool test __attribute__((unused)) = false;\n+\n+  auto to = __gnu_test::nonexistent_path();\n+  std::error_code ec;\n+\n+  fs::copy(\"/\", to, fs::copy_options::create_symlinks, ec);\n+  VERIFY( !ec );\n }\n \n int\n main()\n {\n   test01();\n   test02();\n+  test03();\n+  test04();\n+  test05();\n }"}]}