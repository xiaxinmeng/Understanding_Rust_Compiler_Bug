{"sha": "742dff159687a0713938506aafe7ea1fdefcdab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQyZGZmMTU5Njg3YTA3MTM5Mzg1MDZhYWZlN2VhMWZkZWZjZGFiMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-05-25T16:41:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-25T16:41:30Z"}, "message": "Jan Hubicka  <jh@suse.cz>\n\n        * jump.c (invert_exp_1): Remove first argument, use pc_set\n        to get the expression.\n        (redirect_exp): Make static; redirect only the pc_set expression,\n        remove first argument.\n        (invert_exp): Remove first argument, make static.\n        (jump_optimize): Use any_condjump_p, any_uncondjump_p and\n        any_onlyjump at most places where we originaly did condjump_p\n        and simplejump_p.\n        (jump_back_p, follow_jumps, thread_jumps): Likewise.\n        (delete_barrier_succesors): Use pc_set.\n        (invert_jump_1, invert_jump, redirect_jump_1, redirect_jump): Update\n        calls of invert_exp and redirect_exp.\n        * rtl.h (redirect_exp, invert_exp): Remove.\n        * unroll.c (copy_loop_body): Use invert_jump and redirect_jump.\n\nFrom-SVN: r34171", "tree": {"sha": "033e4bf58540b4e1762fda92cd81e4dbf8e56e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/033e4bf58540b4e1762fda92cd81e4dbf8e56e49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/742dff159687a0713938506aafe7ea1fdefcdab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742dff159687a0713938506aafe7ea1fdefcdab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/742dff159687a0713938506aafe7ea1fdefcdab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742dff159687a0713938506aafe7ea1fdefcdab2/comments", "author": null, "committer": null, "parents": [{"sha": "d1ee23e5c3d22613ea7a5c2807b7f12045bd6883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ee23e5c3d22613ea7a5c2807b7f12045bd6883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1ee23e5c3d22613ea7a5c2807b7f12045bd6883"}], "stats": {"total": 227, "additions": 125, "deletions": 102}, "files": [{"sha": "06186fba3838164054c0f31d4a3b12c12d46dd27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=742dff159687a0713938506aafe7ea1fdefcdab2", "patch": "@@ -1,9 +1,26 @@\n+2000-05-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* jump.c (invert_exp_1): Remove first argument, use pc_set\n+\tto get the expression.\n+\t(redirect_exp): Make static; redirect only the pc_set expression,\n+\tremove first argument.\n+\t(invert_exp): Remove first argument, make static.\n+\t(jump_optimize): Use any_condjump_p, any_uncondjump_p and\n+\tany_onlyjump at most places where we originaly did condjump_p\n+\tand simplejump_p.\n+\t(jump_back_p, follow_jumps, thread_jumps): Likewise.\n+\t(delete_barrier_succesors): Use pc_set.\n+\t(invert_jump_1, invert_jump, redirect_jump_1, redirect_jump): Update\n+\tcalls of invert_exp and redirect_exp.\n+\t* rtl.h (redirect_exp, invert_exp): Remove.\n+\t* unroll.c (copy_loop_body): Use invert_jump and redirect_jump.\n+\n 2000-05-25  Richard Henderson  <rth@cygnus.com>\n \n \t* stmt.c (expand_end_bindings): Fix thinko last change.\n \n 2000-05-25  Andrew MacLeod  <amacleod@cygnus.com>\n-            Andrew Haley  <aph@cygnus.com>\n+\t    Andrew Haley  <aph@cygnus.com>\n \n \t* except.c  (func_eh_entry): Add emitted field.\n \t(new_eh_region_entry): Set emitted field to 0;\n@@ -143,12 +160,12 @@ Thu May 25 02:19:27 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* Back out this patch:\n \tTue Dec  7 19:22:06 1999  Richard Henderson  <rth@cygnus.com>\n-          * loop.h (struct induction): Add multi_insn_incr.\n-          * loop.c (basic_induction_var): New multi_insn_incr argument.\n-          Set it if we search back through previous insns for the biv.\n-          (record_biv): New multi_insn_incr argument; fill in struct induction.\n-          (strength_reduce): Discard an iv with multiple bivs, any of\n-          which require multiple insns to increment.\n+\t  * loop.h (struct induction): Add multi_insn_incr.\n+\t  * loop.c (basic_induction_var): New multi_insn_incr argument.\n+\t  Set it if we search back through previous insns for the biv.\n+\t  (record_biv): New multi_insn_incr argument; fill in struct induction.\n+\t  (strength_reduce): Discard an iv with multiple bivs, any of\n+\t  which require multiple insns to increment.\n \n \t* loop.c (check_insn_for_bivs): Remove bits copied from above patch.\n "}, {"sha": "cf4d78d87415a420f32f3313ad56a8d921d8dcdb", "filename": "gcc/jump.c", "status": "modified", "additions": 94, "deletions": 77, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=742dff159687a0713938506aafe7ea1fdefcdab2", "patch": "@@ -122,7 +122,9 @@ static int tension_vector_labels\tPARAMS ((rtx, int));\n static void mark_jump_label\t\tPARAMS ((rtx, rtx, int, int));\n static void delete_computation\t\tPARAMS ((rtx));\n static void redirect_exp_1\t\tPARAMS ((rtx *, rtx, rtx, rtx));\n-static void invert_exp_1\t\tPARAMS ((rtx, rtx));\n+static int redirect_exp\t\t\tPARAMS ((rtx, rtx, rtx));\n+static void invert_exp_1\t\tPARAMS ((rtx));\n+static int invert_exp\t\t\tPARAMS ((rtx));\n static void delete_from_jump_chain\tPARAMS ((rtx));\n static int delete_labelref_insn\t\tPARAMS ((rtx, rtx, int));\n static void mark_modified_reg\t\tPARAMS ((rtx, rtx, void *));\n@@ -303,8 +305,9 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t  rtx temp, temp1, temp2 = NULL_RTX;\n \t  rtx temp4 ATTRIBUTE_UNUSED;\n \t  rtx nlabel;\n-\t  int this_is_simplejump, this_is_condjump;\n-\t  int this_is_condjump_in_parallel;\n+\t  int this_is_any_uncondjump;\n+\t  int this_is_any_condjump;\n+\t  int this_is_onlyjump;\n \n \t  next = NEXT_INSN (insn);\n \n@@ -315,7 +318,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t  if (after_regscan && GET_CODE (insn) == NOTE\n \t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n \t      && (temp1 = next_nonnote_insn (insn)) != 0\n-\t      && simplejump_p (temp1))\n+\t      && any_uncondjump_p (temp1)\n+\t      && onlyjump_p (temp1))\n \t    {\n \t      temp = PREV_INSN (insn);\n \t      if (duplicate_loop_exit_test (insn))\n@@ -329,9 +333,9 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t  if (GET_CODE (insn) != JUMP_INSN)\n \t    continue;\n \n-\t  this_is_simplejump = simplejump_p (insn);\n-\t  this_is_condjump = condjump_p (insn);\n-\t  this_is_condjump_in_parallel = condjump_in_parallel_p (insn);\n+\t  this_is_any_condjump = any_condjump_p (insn);\n+\t  this_is_any_uncondjump = any_uncondjump_p (insn);\n+\t  this_is_onlyjump = onlyjump_p (insn);\n \n \t  /* Tension the labels in dispatch tables.  */\n \n@@ -387,7 +391,9 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t  reallabelprev = prev_active_insn (JUMP_LABEL (insn));\n \n \t  /* Detect jump to following insn.  */\n-\t  if (reallabelprev == insn && this_is_condjump)\n+\t  if (reallabelprev == insn\n+\t      && (this_is_any_condjump || this_is_any_uncondjump)\n+\t      && this_is_onlyjump)\n \t    {\n \t      next = next_real_insn (JUMP_LABEL (insn));\n \t      delete_jump (insn);\n@@ -404,7 +410,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \n \t  /* Detect a conditional jump going to the same place\n \t     as an immediately following unconditional jump.  */\n-\t  else if (this_is_condjump\n+\t  else if (this_is_any_condjump && this_is_onlyjump\n \t\t   && (temp = next_active_insn (insn)) != 0\n \t\t   && simplejump_p (temp)\n \t\t   && (next_active_insn (JUMP_LABEL (insn))\n@@ -427,13 +433,13 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \n \t  /* Detect a conditional jump jumping over an unconditional jump.  */\n \n-\t  else if ((this_is_condjump || this_is_condjump_in_parallel)\n-\t\t   && ! this_is_simplejump\n+\t  else if (this_is_any_condjump\n \t\t   && reallabelprev != 0\n \t\t   && GET_CODE (reallabelprev) == JUMP_INSN\n \t\t   && prev_active_insn (reallabelprev) == insn\n \t\t   && no_labels_between_p (insn, reallabelprev)\n-\t\t   && simplejump_p (reallabelprev))\n+\t\t   && any_uncondjump_p (reallabelprev)\n+\t\t   && onlyjump_p (reallabelprev))\n \t    {\n \t      /* When we invert the unconditional jump, we will be\n \t\t decrementing the usage count of its old label.\n@@ -484,7 +490,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t     being branch to already has the identical USE or if code\n \t     never falls through to that label.  */\n \n-\t  else if (this_is_simplejump\n+\t  else if (this_is_any_uncondjump\n \t\t   && (temp = prev_nonnote_insn (insn)) != 0\n \t\t   && GET_CODE (temp) == INSN\n \t\t   && GET_CODE (PATTERN (temp)) == USE\n@@ -517,7 +523,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n #ifdef HAVE_trap\n \t  /* Detect a conditional jump jumping over an unconditional trap.  */\n \t  if (HAVE_trap\n-\t      && this_is_condjump && ! this_is_simplejump\n+\t      && this_is_any_condjump && this_is_onlyjump\n \t      && reallabelprev != 0\n \t      && GET_CODE (reallabelprev) == INSN\n \t      && GET_CODE (PATTERN (reallabelprev)) == TRAP_IF\n@@ -541,21 +547,22 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t\t}\n \t    }\n \t  /* Detect a jump jumping to an unconditional trap.  */\n-\t  else if (HAVE_trap && this_is_condjump\n+\t  else if (HAVE_trap && this_is_onlyjump\n \t\t   && (temp = next_active_insn (JUMP_LABEL (insn)))\n \t\t   && GET_CODE (temp) == INSN\n \t\t   && GET_CODE (PATTERN (temp)) == TRAP_IF\n-\t\t   && (this_is_simplejump\n-\t\t       || (temp2 = get_condition (insn, &temp4))))\n+\t\t   && (this_is_any_uncondjump\n+\t\t       || (this_is_any_condjump\n+\t\t\t   && temp2 = get_condition (insn, &temp4))))\n \t    {\n \t      rtx tc = TRAP_CONDITION (PATTERN (temp));\n \n \t      if (tc == const_true_rtx\n-\t\t  || (! this_is_simplejump && rtx_equal_p (temp2, tc)))\n+\t\t  || (! this_is_uncondjump && rtx_equal_p (temp2, tc)))\n \t\t{\n \t\t  rtx new;\n \t\t  /* Replace an unconditional jump to a trap with a trap.  */\n-\t\t  if (this_is_simplejump)\n+\t\t  if (this_is_uncondjump)\n \t\t    {\n \t\t      emit_barrier_after (emit_insn_before (gen_trap (), insn));\n \t\t      delete_jump (insn);\n@@ -576,7 +583,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t      /* If the trap condition and jump condition are mutually\n \t\t exclusive, redirect the jump to the following insn.  */\n \t      else if (GET_RTX_CLASS (GET_CODE (tc)) == '<'\n-\t\t       && ! this_is_simplejump\n+\t\t       && this_is_any_condjump\n \t\t       && swap_condition (GET_CODE (temp2)) == GET_CODE (tc)\n \t\t       && rtx_equal_p (XEXP (tc, 0), XEXP (temp2, 0))\n \t\t       && rtx_equal_p (XEXP (tc, 1), XEXP (temp2, 1))\n@@ -797,6 +804,7 @@ delete_barrier_successors (f)\n      rtx f;\n {\n   rtx insn;\n+  rtx set;\n \n   for (insn = f; insn;)\n     {\n@@ -821,9 +829,10 @@ delete_barrier_successors (f)\n \t gcse.  We eliminate such insns now to avoid having them\n \t cause problems later.  */\n       else if (GET_CODE (insn) == JUMP_INSN\n-\t       && GET_CODE (PATTERN (insn)) == SET\n-\t       && SET_SRC (PATTERN (insn)) == pc_rtx\n-\t       && SET_DEST (PATTERN (insn)) == pc_rtx)\n+\t       && (set = pc_set (insn)) != NULL\n+\t       && SET_SRC (set) == pc_rtx\n+\t       && SET_DEST (set) == pc_rtx\n+\t       && onlyjump_p (insn))\n \tinsn = delete_insn (insn);\n \n       else\n@@ -1707,26 +1716,29 @@ jump_back_p (insn, target)\n {\n   rtx cinsn, ctarget;\n   enum rtx_code codei, codet;\n+  rtx set, tset;\n \n-  if (simplejump_p (insn) || ! condjump_p (insn)\n-      || simplejump_p (target)\n+  if (! any_condjump_p (insn)\n+      || any_uncondjump_p (target)\n       || target != prev_real_insn (JUMP_LABEL (insn)))\n     return 0;\n+  set = pc_set (insn);\n+  tset = pc_set (target);\n \n-  cinsn = XEXP (SET_SRC (PATTERN (insn)), 0);\n-  ctarget = XEXP (SET_SRC (PATTERN (target)), 0);\n+  cinsn = XEXP (SET_SRC (set), 0);\n+  ctarget = XEXP (SET_SRC (tset), 0);\n \n   codei = GET_CODE (cinsn);\n   codet = GET_CODE (ctarget);\n \n-  if (XEXP (SET_SRC (PATTERN (insn)), 1) == pc_rtx)\n+  if (XEXP (SET_SRC (set), 1) == pc_rtx)\n     {\n       if (! can_reverse_comparison_p (cinsn, insn))\n \treturn 0;\n       codei = reverse_condition (codei);\n     }\n \n-  if (XEXP (SET_SRC (PATTERN (target)), 2) == pc_rtx)\n+  if (XEXP (SET_SRC (tset), 2) == pc_rtx)\n     {\n       if (! can_reverse_comparison_p (ctarget, target))\n \treturn 0;\n@@ -2351,7 +2363,8 @@ follow_jumps (label)\n        (depth < 10\n \t&& (insn = next_active_insn (value)) != 0\n \t&& GET_CODE (insn) == JUMP_INSN\n-\t&& ((JUMP_LABEL (insn) != 0 && simplejump_p (insn))\n+\t&& ((JUMP_LABEL (insn) != 0 && any_uncondjump_p (insn)\n+\t     && onlyjump_p (insn))\n \t    || GET_CODE (PATTERN (insn)) == RETURN)\n \t&& (next = NEXT_INSN (insn))\n \t&& GET_CODE (next) == BARRIER);\n@@ -3148,12 +3161,18 @@ redirect_exp_1 (loc, olabel, nlabel, insn)\n \n /* Similar, but apply the change group and report success or failure.  */\n \n-int\n-redirect_exp (loc, olabel, nlabel, insn)\n-     rtx *loc;\n+static int\n+redirect_exp (olabel, nlabel, insn)\n      rtx olabel, nlabel;\n      rtx insn;\n {\n+  rtx *loc;\n+\n+  if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+    loc = &XVECEXP (PATTERN (insn), 0, 0);\n+  else\n+    loc = &PATTERN (insn);\n+\n   redirect_exp_1 (loc, olabel, nlabel, insn);\n   if (num_validated_changes () == 0)\n     return 0;\n@@ -3170,7 +3189,14 @@ redirect_jump_1 (jump, nlabel)\n      rtx jump, nlabel;\n {\n   int ochanges = num_validated_changes ();\n-  redirect_exp_1 (&PATTERN (jump), JUMP_LABEL (jump), nlabel, jump);\n+  rtx *loc;\n+\n+  if (GET_CODE (PATTERN (jump)) == PARALLEL)\n+    loc = &XVECEXP (PATTERN (jump), 0, 0);\n+  else\n+    loc = &PATTERN (jump);\n+\n+  redirect_exp_1 (loc, JUMP_LABEL (jump), nlabel, jump);\n   return num_validated_changes () > ochanges;\n }\n \n@@ -3194,7 +3220,7 @@ redirect_jump (jump, nlabel, delete_unused)\n   if (nlabel == olabel)\n     return 1;\n \n-  if (! redirect_exp (&PATTERN (jump), olabel, nlabel, jump))\n+  if (! redirect_exp (olabel, nlabel, jump))\n     return 0;\n \n   /* If this is an unconditional branch, delete it from the jump_chain of\n@@ -3235,13 +3261,15 @@ redirect_jump (jump, nlabel, delete_unused)\n    Accrue the modifications into the change group.  */\n \n static void\n-invert_exp_1 (x, insn)\n-     rtx x;\n+invert_exp_1 (insn)\n      rtx insn;\n {\n   register RTX_CODE code;\n-  register int i;\n-  register const char *fmt;\n+  rtx x = pc_set (insn);\n+\n+  if (!x)\n+    abort();\n+  x = SET_SRC (x);\n \n   code = GET_CODE (x);\n \n@@ -3268,34 +3296,21 @@ invert_exp_1 (x, insn)\n       tem = XEXP (x, 1);\n       validate_change (insn, &XEXP (x, 1), XEXP (x, 2), 1);\n       validate_change (insn, &XEXP (x, 2), tem, 1);\n-      return;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tinvert_exp_1 (XEXP (x, i), insn);\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    invert_exp_1 (XVECEXP (x, i, j), insn);\n-\t}\n     }\n+  else\n+    abort ();\n }\n \n-/* Invert the jump condition of rtx X contained in jump insn, INSN. \n+/* Invert the jump condition of conditional jump insn, INSN. \n \n    Return 1 if we can do so, 0 if we cannot find a way to do so that\n    matches a pattern.  */\n \n-int\n-invert_exp (x, insn)\n-     rtx x;\n+static int\n+invert_exp (insn)\n      rtx insn;\n {\n-  invert_exp_1 (x, insn);\n+  invert_exp_1 (insn);\n   if (num_validated_changes () == 0)\n     return 0;\n \n@@ -3314,7 +3329,7 @@ invert_jump_1 (jump, nlabel)\n   int ochanges;\n \n   ochanges = num_validated_changes ();\n-  invert_exp_1 (PATTERN (jump), jump);\n+  invert_exp_1 (jump);\n   if (num_validated_changes () == ochanges)\n     return 0;\n \n@@ -3334,7 +3349,7 @@ invert_jump (jump, nlabel, delete_unused)\n      the jump. If that succeeds, we try changing the label.  If that fails,\n      we invert the jump back to what it was.  */\n \n-  if (! invert_exp (PATTERN (jump), jump))\n+  if (! invert_exp (jump))\n     return 0;\n \n   if (redirect_jump (jump, nlabel, delete_unused))\n@@ -3350,7 +3365,7 @@ invert_jump (jump, nlabel, delete_unused)\n       return 1;\n     }\n \n-  if (! invert_exp (PATTERN (jump), jump))\n+  if (! invert_exp (jump))\n     /* This should just be putting it back the way it was.  */\n     abort ();\n \n@@ -3788,10 +3803,11 @@ thread_jumps (f, max_reg, flag_before_loop)\n \n       for (b1 = f; b1; b1 = NEXT_INSN (b1))\n \t{\n+\t  rtx set;\n+\t  rtx set2;\n \t  /* Get to a candidate branch insn.  */\n \t  if (GET_CODE (b1) != JUMP_INSN\n-\t      || ! condjump_p (b1) || simplejump_p (b1)\n-\t      || JUMP_LABEL (b1) == 0)\n+\t      || ! any_condjump_p (b1) || JUMP_LABEL (b1) == 0)\n \t    continue;\n \n \t  bzero (modified_regs, max_reg * sizeof (char));\n@@ -3815,7 +3831,8 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t\t{\n \t\t  /* If this is an unconditional jump and is the only use of\n \t\t     its target label, we can follow it.  */\n-\t\t  if (simplejump_p (b2)\n+\t\t  if (any_uncondjump_p (b2)\n+\t\t      && onlyjump_p (b2)\n \t\t      && JUMP_LABEL (b2) != 0\n \t\t      && LABEL_NUSES (JUMP_LABEL (b2)) == 1)\n \t\t    {\n@@ -3849,23 +3866,25 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t  if (b2 == 0\n \t      || GET_CODE (b2) != JUMP_INSN\n \t      || b2 == b1\n-\t      || ! condjump_p (b2)\n-\t      || simplejump_p (b2))\n+\t      || !any_condjump_p (b2)\n+\t      || !onlyjump_p (b2))\n \t    continue;\n+\t  set = pc_set (b1);\n+\t  set2 = pc_set (b2);\n \n \t  /* Get the comparison codes and operands, reversing the\n \t     codes if appropriate.  If we don't have comparison codes,\n \t     we can't do anything.  */\n-\t  b1op0 = XEXP (XEXP (SET_SRC (PATTERN (b1)), 0), 0);\n-\t  b1op1 = XEXP (XEXP (SET_SRC (PATTERN (b1)), 0), 1);\n-\t  code1 = GET_CODE (XEXP (SET_SRC (PATTERN (b1)), 0));\n-\t  if (XEXP (SET_SRC (PATTERN (b1)), 1) == pc_rtx)\n+\t  b1op0 = XEXP (XEXP (SET_SRC (set), 0), 0);\n+\t  b1op1 = XEXP (XEXP (SET_SRC (set), 0), 1);\n+\t  code1 = GET_CODE (XEXP (SET_SRC (set), 0));\n+\t  if (XEXP (SET_SRC (set), 1) == pc_rtx)\n \t    code1 = reverse_condition (code1);\n \n-\t  b2op0 = XEXP (XEXP (SET_SRC (PATTERN (b2)), 0), 0);\n-\t  b2op1 = XEXP (XEXP (SET_SRC (PATTERN (b2)), 0), 1);\n-\t  code2 = GET_CODE (XEXP (SET_SRC (PATTERN (b2)), 0));\n-\t  if (XEXP (SET_SRC (PATTERN (b2)), 1) == pc_rtx)\n+\t  b2op0 = XEXP (XEXP (SET_SRC (set2), 0), 0);\n+\t  b2op1 = XEXP (XEXP (SET_SRC (set2), 0), 1);\n+\t  code2 = GET_CODE (XEXP (SET_SRC (set2), 0));\n+\t  if (XEXP (SET_SRC (set2), 1) == pc_rtx)\n \t    code2 = reverse_condition (code2);\n \n \t  /* If they test the same things and knowing that B1 branches\n@@ -3874,9 +3893,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t  if (rtx_equal_for_thread_p (b1op0, b2op0, b2)\n \t      && rtx_equal_for_thread_p (b1op1, b2op1, b2)\n \t      && (comparison_dominates_p (code1, code2)\n-\t\t  || (can_reverse_comparison_p (XEXP (SET_SRC (PATTERN (b1)),\n-\t\t\t\t\t\t      0),\n-\t\t\t\t\t\tb1)\n+\t\t  || (can_reverse_comparison_p (XEXP (SET_SRC (set), 0), b1)\n \t\t      && comparison_dominates_p (code1, reverse_condition (code2)))))\n \n \t    {"}, {"sha": "de0c37da6d44fd10584541f79decf8e72817f583", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=742dff159687a0713938506aafe7ea1fdefcdab2", "patch": "@@ -1532,9 +1532,7 @@ extern void jump_optimize\t\tPARAMS ((rtx, int, int, int));\n extern void jump_optimize_minimal\tPARAMS ((rtx));\n extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n extern void thread_jumps\t\tPARAMS ((rtx, int, int));\n-extern int redirect_exp\t\t\tPARAMS ((rtx *, rtx, rtx, rtx));\n extern int rtx_equal_for_thread_p\tPARAMS ((rtx, rtx, rtx));\n-extern int invert_exp\t\t\tPARAMS ((rtx, rtx));\n extern int can_reverse_comparison_p\tPARAMS ((rtx, rtx));\n extern void delete_for_peephole\t\tPARAMS ((rtx, rtx));\n extern int condjump_in_parallel_p\tPARAMS ((rtx));"}, {"sha": "b33fb65e2b49f72e8b563cf6efd63c176f46f5d7", "filename": "gcc/unroll.c", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/742dff159687a0713938506aafe7ea1fdefcdab2/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=742dff159687a0713938506aafe7ea1fdefcdab2", "patch": "@@ -2037,22 +2037,17 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t  if (JUMP_LABEL (insn) == start_label && insn == copy_end\n \t      && ! last_iteration)\n \t    {\n+\t      /* Update JUMP_LABEL correctly to make invert_jump working.  */\n+\t      JUMP_LABEL (copy) = get_label_from_map (map,\n+\t\t\t\t\t\t      CODE_LABEL_NUMBER\n+\t\t\t\t\t\t      (JUMP_LABEL (insn)));\n \t      /* This is a branch to the beginning of the loop; this is the\n \t\t last insn being copied; and this is not the last iteration.\n \t\t In this case, we want to change the original fall through\n \t\t case to be a branch past the end of the loop, and the\n \t\t original jump label case to fall_through.  */\n \n-\t      if (invert_exp (pattern, copy))\n-\t\t{\n-\t\t  if (! redirect_exp (&pattern,\n-\t\t\t\t      get_label_from_map (map,\n-\t\t\t\t\t\t\t  CODE_LABEL_NUMBER\n-\t\t\t\t\t\t\t  (JUMP_LABEL (insn))),\n-\t\t\t\t      exit_label, copy))\n-\t\t    abort ();\n-\t\t}\n-\t      else\n+\t      if (!invert_jump (copy, exit_label, 0))\n \t\t{\n \t\t  rtx jmp;\n \t\t  rtx lab = gen_label_rtx ();\n@@ -2064,12 +2059,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t  jmp = emit_barrier_after (jmp);\n \t\t  emit_label_after (lab, jmp);\n \t\t  LABEL_NUSES (lab) = 0;\n-\t\t  if (! redirect_exp (&pattern,\n-\t\t\t\t      get_label_from_map (map,\n-\t\t\t\t\t\t\t  CODE_LABEL_NUMBER\n-\t\t\t\t\t\t\t  (JUMP_LABEL (insn))),\n-\t\t\t\t      lab, copy))\n-\t\t    abort ();\n+\t\t  if (!redirect_jump (copy, lab, 0))\n+\t\t    abort();\n \t\t}\n \t    }\n "}]}