{"sha": "1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "node_id": "C_kwDOANBUbNoAKDFiNzRiNWNiNGU5ZDcxOTFmMjk4MjQ1MDYzYThmOWMzYTFiYmVmZjQ", "commit": {"author": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-09-25T16:23:59Z"}, "committer": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-09-26T13:40:41Z"}, "message": "[RFA] Minor improvement to coremark, avoid unconditional jump to return\n\ngcc/\n\t* cfgcleanup.cc (bb_is_just_return): No longer static.\n\t* cfgcleanup.h (bb_is_just_return): Add prototype.\n\t* cfgrtl.cc (fixup_reorder_chain): Do not create an\n\tunconditional jump to a return block.  Conditionally\n\tremove unreachable blocks.\n\ngcc/testsuite/\n\n\t* gcc.target/riscv/ret-1.c: New test.", "tree": {"sha": "49bc167265f9dd5ef9e7fa564d63d0ad64227712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49bc167265f9dd5ef9e7fa564d63d0ad64227712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/comments", "author": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "386ebf75f4c0342b1f823f4e4aba07abda3288d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/386ebf75f4c0342b1f823f4e4aba07abda3288d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/386ebf75f4c0342b1f823f4e4aba07abda3288d1"}], "stats": {"total": 73, "additions": 71, "deletions": 2}, "files": [{"sha": "a363e0b4da3cc1bda23efd3d3ddd5f47da0e050d", "filename": "gcc/cfgcleanup.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Fcfgcleanup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Fcfgcleanup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.cc?ref=1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "patch": "@@ -2599,7 +2599,7 @@ trivially_empty_bb_p (basic_block bb)\n    return value.  Fill in *RET and *USE with the return and use insns\n    if any found, otherwise NULL.  All CLOBBERs are ignored.  */\n \n-static bool\n+bool\n bb_is_just_return (basic_block bb, rtx_insn **ret, rtx_insn **use)\n {\n   *ret = *use = NULL;"}, {"sha": "f1021ca835fff8e023b79ae9f1a18d7ac5de8922", "filename": "gcc/cfgcleanup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Fcfgcleanup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Fcfgcleanup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.h?ref=1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "patch": "@@ -30,5 +30,6 @@ extern int flow_find_head_matching_sequence (basic_block, basic_block,\n extern bool delete_unreachable_blocks (void);\n extern void delete_dead_jumptables (void);\n extern bool cleanup_cfg (int);\n+extern bool bb_is_just_return (basic_block, rtx_insn **, rtx_insn **);\n \n #endif /* GCC_CFGCLEANUP_H */"}, {"sha": "90cd6ee56a7bdda2d6b06b7580e5ec6f3db32db3", "filename": "gcc/cfgrtl.cc", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Fcfgrtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Fcfgrtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.cc?ref=1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "patch": "@@ -3901,6 +3901,7 @@ fixup_reorder_chain (void)\n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n \n+  bool remove_unreachable_blocks = false;\n   for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb ; bb = (basic_block)\n        bb->aux)\n     {\n@@ -4043,10 +4044,30 @@ fixup_reorder_chain (void)\n \t    continue;\n \t}\n \n+      /* If E_FALL->dest is just a return block, then we can emit a\n+\t return rather than a jump to the return block.  */\n+      rtx_insn *ret, *use;\n+      basic_block dest;\n+      if (bb_is_just_return (e_fall->dest, &ret, &use)\n+\t  && (PATTERN (ret) == simple_return_rtx || PATTERN (ret) == ret_rtx))\n+\t{\n+\t  ret_label = PATTERN (ret);\n+\t  dest = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+\n+\t  /* E_FALL->dest might become unreachable as a result of\n+\t     replacing the jump with a return.  So arrange to remove\n+\t     unreachable blocks.  */\n+\t  remove_unreachable_blocks = true;\n+\t}\n+      else\n+\t{\n+\t  dest = e_fall->dest;\n+\t}\n+\n       /* We got here if we need to add a new jump insn. \n \t Note force_nonfallthru can delete E_FALL and thus we have to\n \t save E_FALL->src prior to the call to force_nonfallthru.  */\n-      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);\n+      nb = force_nonfallthru_and_redirect (e_fall, dest, ret_label);\n       if (nb)\n \t{\n \t  nb->aux = bb->aux;\n@@ -4134,6 +4155,12 @@ fixup_reorder_chain (void)\n \t\t  ei_next (&ei2);\n \t    }\n       }\n+\n+  /* Replacing a jump with a return may have exposed an unreachable\n+     block.  Conditionally remove them if such transformations were\n+     made.  */\n+  if (remove_unreachable_blocks)\n+    delete_unreachable_blocks ();\n }\n \f\n /* Perform sanity checks on the insn chain."}, {"sha": "28133aa4226eedbef6e5de9aa39db4d62af8db5b", "filename": "gcc/testsuite/gcc.target/riscv/ret-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fret-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fret-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fret-1.c?ref=1b74b5cb4e9d7191f298245063a8f9c3a1bbeff4", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -dp\" } */\n+/* This was extracted from coremark.  */\n+\n+\n+typedef signed short ee_s16;\n+typedef struct list_data_s\n+{\n+    ee_s16 data16;\n+    ee_s16 idx;\n+} list_data;\n+\n+typedef struct list_head_s\n+{\n+    struct list_head_s *next;\n+    struct list_data_s *info;\n+} list_head;\n+\n+\n+list_head *\n+core_list_find(list_head *list, list_data *info)\n+{\n+    if (info->idx >= 0)\n+    {\n+        while (list && (list->info->idx != info->idx))\n+            list = list->next;\n+        return list;\n+    }\n+    else\n+    {\n+        while (list && ((list->info->data16 & 0xff) != info->data16))\n+            list = list->next;\n+        return list;\n+    }\n+}\n+\n+/* There is only one legitimate unconditional jump, so test for that,\n+   which will catch the case where bb-reorder leaves a jump to a ret\n+   in the IL.  */\n+/* { dg-final { scan-assembler-times \"jump\" 1 } } */\n+"}]}