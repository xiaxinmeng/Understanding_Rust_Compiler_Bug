{"sha": "4b0d3cbe3ef315a363ce89a3264d4791090227fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIwZDNjYmUzZWYzMTVhMzYzY2U4OWEzMjY0ZDQ3OTEwOTAyMjdmYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-08-20T07:06:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-08-20T07:06:47Z"}, "message": "re PR c++/11946 (fun and merriment with enums as function arguments)\n\n\tPR c++/11946\n\t* convert.c (convert_to_integer): Use CONVERT_EXPR (instead of\n\tNOP_EXPR) when necessary.\n\t* c-common.c (c_common_signed_or_unsigned_type): Correctly handle\n\ttypes with precisions other than those given by native machine\n\tmodes.\n\n\tPR c++/11684\n\t* cp-tree.h (grok_op_properties): Change prototype.\n\t* decl.c (grok_op_properties): Add complain parameter.\n\t(grokfndecl): Pass it.\n\t* pt.c (tsubst_decl): Adjust accordingly.\n\n\tPR c++/10926\n\t* decl.c (start_method): Return immediately if push_template_decl\n\tdoes not like the declaration.\n\t* pt.c (push_template_decl_real): Disallow member template\n\tdestructors.\n\n\tPR c++/11036.C\n\t* cp-tree.h (add_binding): Add prototype.\n\t* class.c (add_method): Set TYPE_HAS_DESTRUCTOR if appropriate.\n\t(maybe_warn_about_overly_private_class): Use\n\tCLASSTYPE_DESTRUCTORS.\n\t(pushclass): Adjust call to set_identifier_type_value.\n\t* decl.c (add_binding): Give it external linkage.\n\t(push_local_binding): Adjust call to add_binding.\n\t(push_class_binding): Likewise.\n\t(set_identifier_type_value_with_scope): Change prototype.  Use\n\tadd_binding for global bindings.\n\t(set_identifier_type_value): Adjust accordingly.\n\t(pushtag): Likewise.\n\t(pushdecl): Use set_identifier_type_value, not\n\tset_identifier_type_value_with_scope.\n\t(pushdecl_namespace_level): Adjust calls to\n\tSET_IDENTIFIER_TYPE_VALUE to pass a DECL.\n\t(pushdecl_class_level): Likewise.\n\t(lookup_tag): Use select_decl.\n\t(select_decl): Improve comment.\n\t(record_builtin_type): Do not call pushdecl.\n\t(cxx_init_decl_processing): Do not call xref_tag for bad_alloc.\n\t(cp_finish_decl): Adjust call to set_identifier_type_value.\n\t(check_elaborated_type_specifier): Improve checks for invalid uses\n\tof typedefs.\n\t(xref_tag): Adjust call to check_elaborated_type_specifier.\n\t* decl2.c (grokclassfn): Do not set TYPE_HAS_DESTRUCTOR.\n\t* name-lookup.c (set_namespace_binding): Use add_binding.\n\t* parser.c (cp_parser_simple_type_specifier): Return a TYPE_DECL,\n\trather than an IDENTIFIER_NODE, to represent built-in types, if\n\trequested by the caller.\n\t(cp_parser_postfix_expression): Adjust call.\n\t(cp_parser_type_specifier): Likewise.\n\t(cp_parser_elaborated_type_specifier): Adjust call to\n\tcheck_elaborated_type_specifier.\n\t* typeck2.c (build_functional_cast): Do not perform name lookups.\n\n\tPR c++/10717\n\t* decl.c (expand_static_init): Remove unncessary code.\n\n\tPR c++/10926\n\t* g++.dg/template/dtor2.C: New test.\n\n\tPR c++/11684\n\t* g++.dg/template/operator1.C: New test.\n\t* g++.dg/parse/operator4.C: New test.\n\n\tPR c++/11946.C\n\t* g++.dg/expr/enum1.C: New test.\n\t* gcc.dg/c99-bool-1.c: Remove bogus warning.\n\n\tPR c++/11036.C\n\t* g++.dg/parse/elab2.C: New test.\n\t* g++.dg/parse/typedef4.C: Change error message.\n\t* g++.old-deja/g++.robertl/eb133.C: Remove bogus error markers.\n\t* g++.old-deja/g++.robertl/eb133a.C: Remove bogus error markers.\n\t* g++.old-deja/g++.robertl/eb133b.C: Remove bogus error markers.\n\nFrom-SVN: r70593", "tree": {"sha": "aa2d4a7cd3cb10db4c73c55192e37867c0a5455b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa2d4a7cd3cb10db4c73c55192e37867c0a5455b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b0d3cbe3ef315a363ce89a3264d4791090227fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b0d3cbe3ef315a363ce89a3264d4791090227fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b0d3cbe3ef315a363ce89a3264d4791090227fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b0d3cbe3ef315a363ce89a3264d4791090227fb/comments", "author": null, "committer": null, "parents": [{"sha": "ccc014442a6731846c6e852a8ebbdc889d5c113b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc014442a6731846c6e852a8ebbdc889d5c113b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc014442a6731846c6e852a8ebbdc889d5c113b"}], "stats": {"total": 599, "additions": 421, "deletions": 178}, "files": [{"sha": "bd92e1966de6fa45055ecacd4d95057e2c39d197", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -1,3 +1,12 @@\n+2003-08-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11946\n+\t* convert.c (convert_to_integer): Use CONVERT_EXPR (instead of\n+\tNOP_EXPR) when necessary.\n+\t* c-common.c (c_common_signed_or_unsigned_type): Correctly handle\n+\ttypes with precisions other than those given by native machine\n+\tmodes.\n+\n 2003-08-19  Geoffrey Keating  <geoffk@apple.com>\n \n \t* cpppch.c (cpp_valid_state): Re-add warning about PCH not used"}, {"sha": "8f9e0bfb5fcd76ebe462428f75a97318f4d84109", "filename": "gcc/c-common.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -1969,6 +1969,8 @@ c_common_signed_type (tree type)\n tree\n c_common_signed_or_unsigned_type (int unsignedp, tree type)\n {\n+  tree new_type;\n+\n   if (! INTEGRAL_TYPE_P (type)\n       || TREE_UNSIGNED (type) == unsignedp)\n     return type;\n@@ -2001,7 +2003,14 @@ c_common_signed_or_unsigned_type (int unsignedp, tree type)\n   if (TYPE_PRECISION (type) == TYPE_PRECISION (intQI_type_node))\n     return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n \n-  return type;\n+  new_type = (unsignedp \n+\t      ? make_unsigned_type (TYPE_PRECISION (type))\n+\t      : make_signed_type (TYPE_PRECISION (type)));\n+  TYPE_SIZE (new_type) = TYPE_SIZE (type);\n+  TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);\n+  TYPE_MODE (new_type) = TYPE_MODE (type);\n+\n+  return new_type;\n }\n \f\n /* Return the minimum number of bits needed to represent VALUE in a"}, {"sha": "1f281d5ba1b96249a16d460cd2237308a63d485a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -654,10 +654,14 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n     && REGNO (IN) < FIRST_PSEUDO_REGISTER)\t\t\t\\\n    ? NO_REGS : secondary_reload_class (CLASS, MODE, IN))\n \n+#define MAYBE_FP_REG_CLASS_P(CLASS) \\\n+  reg_classes_intersect_p ((CLASS), FP_REGS)\n+\n /* On the PA it is not possible to directly move data between\n    GENERAL_REGS and FP_REGS.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)  \\\n-  (FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2))\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\\\n+  (MAYBE_FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)\t\\\n+   || MAYBE_FP_REG_CLASS_P (CLASS2) != FP_REG_CLASS_P (CLASS1))\n \n /* Return the stack location to use for secondary memory needed reloads.  */\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\"}, {"sha": "0d3a46c05d4bb86068856d41fb183d34146058d6", "filename": "gcc/convert.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -349,7 +349,27 @@ convert_to_integer (tree type, tree expr)\n \t we are truncating EXPR.  */\n \n       else if (outprec >= inprec)\n-\treturn build1 (NOP_EXPR, type, expr);\n+\t{\n+\t  enum tree_code code;\n+\n+\t  /* If the precision of the EXPR's type is K bits and the\n+\t     destination mode has more bits, and the sign is changing,\n+\t     it is not safe to use a NOP_EXPR.  For example, suppose\n+\t     that EXPR's type is a 3-bit unsigned integer type, the\n+\t     TYPE is a 3-bit signed integer type, and the machine mode\n+\t     for the types is 8-bit QImode.  In that case, the\n+\t     conversion necessitates an explicit sign-extension.  In\n+\t     the signed-to-unsigned case the high-order bits have to\n+\t     be cleared.  */\n+\t  if (TREE_UNSIGNED (type) != TREE_UNSIGNED (TREE_TYPE (expr))\n+\t      && (TYPE_PRECISION (TREE_TYPE (expr))\n+\t\t  != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (expr)))))\n+\t    code = CONVERT_EXPR;\n+\t  else\n+\t    code = NOP_EXPR;\n+\n+\t  return build1 (code, type, expr);\n+\t}\n \n       /* If TYPE is an enumeral type or a type with a precision less\n \t than the number of bits in its mode, do the conversion to the"}, {"sha": "fbb96a806e902d80a73815ff6e96ea0ebb0db633", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -1,3 +1,57 @@\n+2003-08-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11684\n+\t* cp-tree.h (grok_op_properties): Change prototype.\n+\t* decl.c (grok_op_properties): Add complain parameter.\n+\t(grokfndecl): Pass it.\n+\t* pt.c (tsubst_decl): Adjust accordingly.\n+\n+\tPR c++/10926\n+\t* decl.c (start_method): Return immediately if push_template_decl\n+\tdoes not like the declaration.\n+\t* pt.c (push_template_decl_real): Disallow member template\n+\tdestructors.\n+\n+\tPR c++/11036.C\n+\t* cp-tree.h (add_binding): Add prototype.\n+\t* class.c (add_method): Set TYPE_HAS_DESTRUCTOR if appropriate.\n+\t(maybe_warn_about_overly_private_class): Use\n+\tCLASSTYPE_DESTRUCTORS.\n+\t(pushclass): Adjust call to set_identifier_type_value.\n+\t* decl.c (add_binding): Give it external linkage.\n+\t(push_local_binding): Adjust call to add_binding.\n+\t(push_class_binding): Likewise.\n+\t(set_identifier_type_value_with_scope): Change prototype.  Use\n+\tadd_binding for global bindings.\n+\t(set_identifier_type_value): Adjust accordingly.\n+\t(pushtag): Likewise.\n+\t(pushdecl): Use set_identifier_type_value, not\n+\tset_identifier_type_value_with_scope.\n+\t(pushdecl_namespace_level): Adjust calls to\n+\tSET_IDENTIFIER_TYPE_VALUE to pass a DECL.\n+\t(pushdecl_class_level): Likewise.\n+\t(lookup_tag): Use select_decl.\n+\t(select_decl): Improve comment.\n+\t(record_builtin_type): Do not call pushdecl.\n+\t(cxx_init_decl_processing): Do not call xref_tag for bad_alloc.\n+\t(cp_finish_decl): Adjust call to set_identifier_type_value.\n+\t(check_elaborated_type_specifier): Improve checks for invalid uses\n+\tof typedefs.\n+\t(xref_tag): Adjust call to check_elaborated_type_specifier.\n+\t* decl2.c (grokclassfn): Do not set TYPE_HAS_DESTRUCTOR.\n+\t* name-lookup.c (set_namespace_binding): Use add_binding.\n+\t* parser.c (cp_parser_simple_type_specifier): Return a TYPE_DECL,\n+\trather than an IDENTIFIER_NODE, to represent built-in types, if\n+\trequested by the caller.\n+\t(cp_parser_postfix_expression): Adjust call.\n+\t(cp_parser_type_specifier): Likewise.\n+\t(cp_parser_elaborated_type_specifier): Adjust call to\n+\tcheck_elaborated_type_specifier.\n+\t* typeck2.c (build_functional_cast): Do not perform name lookups.\n+\t\n+\tPR c++/10717\n+\t* decl.c (expand_static_init): Remove unncessary code.\n+\n 2003-08-19  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/10538, PR c/5582"}, {"sha": "302b714f30c0a719fa2934155419d04e79b1daa8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -750,7 +750,10 @@ add_method (tree type, tree method, int error_p)\n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (method))\n     slot = CLASSTYPE_CONSTRUCTOR_SLOT;\n   else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n-    slot = CLASSTYPE_DESTRUCTOR_SLOT;\n+    {\n+      slot = CLASSTYPE_DESTRUCTOR_SLOT;\n+      TYPE_HAS_DESTRUCTOR (type) = 1;\n+    }\n   else\n     {\n       int have_template_convs_p = 0;\n@@ -1646,16 +1649,12 @@ maybe_warn_about_overly_private_class (tree t)\n   /* Even if some of the member functions are non-private, the class\n      won't be useful for much if all the constructors or destructors\n      are private: such an object can never be created or destroyed.  */\n-  if (TYPE_HAS_DESTRUCTOR (t))\n+  if (TYPE_HAS_DESTRUCTOR (t)\n+      && TREE_PRIVATE (CLASSTYPE_DESTRUCTORS (t)))\n     {\n-      tree dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1);\n-\n-      if (TREE_PRIVATE (dtor))\n-\t{\n-\t  warning (\"`%#T' only defines a private destructor and has no friends\",\n-\t\t      t);\n-\t  return;\n-\t}\n+      warning (\"`%#T' only defines a private destructor and has no friends\",\n+\t       t);\n+      return;\n     }\n \n   if (TYPE_HAS_CONSTRUCTOR (t))\n@@ -5485,7 +5484,7 @@ pushclass (tree type)\n \t  \n \t  push_class_binding (id, decl);\n \t  if (TREE_CODE (decl) == TYPE_DECL)\n-\t    set_identifier_type_value (id, TREE_TYPE (decl));\n+\t    set_identifier_type_value (id, decl);\n \t}\n       unuse_fields (type);\n     }"}, {"sha": "396dc0fe0d4982b9fcbc92a8e751bf35baf08d7f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -3695,7 +3695,7 @@ extern int copy_fn_p\t\t\t\t(tree);\n extern tree get_scope_of_declarator             (tree);\n extern void grok_special_member_properties\t(tree);\n extern int grok_ctor_properties\t\t\t(tree, tree);\n-extern void grok_op_properties\t\t\t(tree, int);\n+extern bool grok_op_properties\t\t\t(tree, int, bool);\n extern tree xref_tag\t\t\t\t(enum tag_types, tree, tree, bool, bool);\n extern tree xref_tag_from_type\t\t\t(tree, tree, int);\n extern void xref_basetypes\t\t\t(tree, tree);\n@@ -3744,6 +3744,7 @@ extern void register_dtor_fn                    (tree);\n extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n extern tree cp_fname_init\t\t\t(const char *);\n extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n+extern int add_binding                          (cxx_binding *, tree);\n extern bool have_extern_spec;\n \n /* in decl2.c */"}, {"sha": "1a4dcb2537f4246abf5d015e2b9268d14ce71b96", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 147, "deletions": 115, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -92,7 +92,6 @@ static void check_for_uninitialized_const_var (tree);\n static hashval_t typename_hash (const void *);\n static int typename_compare (const void *, const void *);\n static void push_binding (tree, tree, struct cp_binding_level*);\n-static int add_binding (tree, tree);\n static void pop_binding (tree, tree);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n static tree select_decl (cxx_binding *, int);\n@@ -918,10 +917,10 @@ push_binding (tree id, tree decl, cxx_scope* level)\n    bound at the same level as some other kind of entity.  It's the\n    responsibility of the caller to check that inserting this name is\n    valid here.  Returns nonzero if the new binding was successful.  */\n-static int\n-add_binding (tree id, tree decl)\n+\n+int\n+add_binding (cxx_binding *binding, tree decl)\n {\n-  cxx_binding *binding = IDENTIFIER_BINDING (id);\n   tree bval = BINDING_VALUE (binding);\n   int ok = 1;\n \n@@ -1041,7 +1040,7 @@ push_local_binding (tree id, tree decl, int flags)\n   if (lookup_name_current_level (id))\n     {\n       /* Supplement the existing binding.  */\n-      if (!add_binding (id, decl))\n+      if (!add_binding (IDENTIFIER_BINDING (id), decl))\n \t/* It didn't work.  Something else must be bound at this\n \t   level.  Do not add DECL to the list of things to pop\n \t   later.  */\n@@ -1080,7 +1079,7 @@ push_class_binding (tree id, tree decl)\n \n   if (binding && BINDING_SCOPE (binding) == class_binding_level)\n     /* Supplement the existing binding.  */\n-    result = add_binding (id, decl);\n+    result = add_binding (IDENTIFIER_BINDING (id), decl);\n   else\n     /* Create a new binding.  */\n     push_binding (id, decl, class_binding_level);\n@@ -2310,37 +2309,39 @@ pop_from_top_level (void)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \f\n-/* Push a definition of struct, union or enum tag \"name\".\n-   into binding_level \"b\".   \"type\" should be the type node,\n-   We assume that the tag \"name\" is not already defined.\n-\n-   Note that the definition may really be just a forward reference.\n-   In that case, the TYPE_SIZE will be a NULL_TREE.\n-\n-   C++ gratuitously puts all these tags in the name space.  */\n-\n-/* When setting the IDENTIFIER_TYPE_VALUE field of an identifier ID,\n-   record the shadowed value for this binding contour.  TYPE is\n-   the type that ID maps to.  */\n+/* Push a definition of struct, union or enum tag named ID.  into\n+   binding_level B.  DECL is a TYPE_DECL for the type.  We assume that\n+   the tag ID is not already defined.  */\n \n static void\n set_identifier_type_value_with_scope (tree id, \n-                                      tree type, \n+                                      tree decl,\n                                       struct cp_binding_level* b)\n {\n+  tree type;\n+\n   if (!b->namespace_p)\n     {\n       /* Shadow the marker, not the real thing, so that the marker\n \t gets restored later.  */\n       tree old_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n       b->type_shadowed\n \t= tree_cons (id, old_type_value, b->type_shadowed);\n+      type = decl ? TREE_TYPE (decl) : NULL_TREE;\n     }\n   else\n     {\n       cxx_binding *binding =\n-         binding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n-      BINDING_TYPE (binding) = type;\n+\tbinding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n+      if (decl)\n+\t{\n+\t  if (BINDING_VALUE (binding))\n+\t    add_binding (binding, decl);\n+\t  else\n+\t    BINDING_VALUE (binding) = decl;\n+\t}\n+      else\n+\tabort ();\n       /* Store marker instead of real type.  */\n       type = global_type_node;\n     }\n@@ -2350,9 +2351,9 @@ set_identifier_type_value_with_scope (tree id,\n /* As set_identifier_type_value_with_scope, but using current_binding_level.  */\n \n void\n-set_identifier_type_value (tree id, tree type)\n+set_identifier_type_value (tree id, tree decl)\n {\n-  set_identifier_type_value_with_scope (id, type, current_binding_level);\n+  set_identifier_type_value_with_scope (id, decl, current_binding_level);\n }\n \n /* Return the type associated with id.  */\n@@ -2586,7 +2587,7 @@ pushtag (tree name, tree type, int globalize)\n \t  d = create_implicit_typedef (name, type);\n \t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n \t  if (! in_class)\n-\t    set_identifier_type_value_with_scope (name, type, b);\n+\t    set_identifier_type_value_with_scope (name, d, b);\n \n \t  d = maybe_process_template_type_declaration (type,\n \t\t\t\t\t\t       globalize, b);\n@@ -3852,9 +3853,7 @@ pushdecl (tree x)\n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n \t      && TYPE_IDENTIFIER (type))\n-            set_identifier_type_value_with_scope (DECL_NAME (x), type,\n-\t\t\t\t\t\t  current_binding_level);\n-\n+            set_identifier_type_value (DECL_NAME (x), x);\n \t}\n \n       /* Multiple external decls of the same identifier ought to match.\n@@ -3944,15 +3943,13 @@ pushdecl (tree x)\n \n \t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n \t  if (TREE_CODE (x) == TYPE_DECL)\n-\t    set_identifier_type_value_with_scope (name, TREE_TYPE (x),\n-\t\t\t\t\t\t  current_binding_level);\n+\t    set_identifier_type_value (name, x);\n \n \t  /* Clear out any TYPE_DECL shadowed by a namespace so that\n \t     we won't think this is a type.  The C struct hack doesn't\n \t     go through namespaces.  */\n \t  if (TREE_CODE (x) == NAMESPACE_DECL)\n-\t    set_identifier_type_value_with_scope (name, NULL_TREE,\n-\t\t\t\t\t\t  current_binding_level);\n+\t    set_identifier_type_value (name, NULL_TREE);\n \n \t  if (oldlocal)\n \t    {\n@@ -4133,7 +4130,7 @@ pushdecl_namespace_level (tree x)\n         {\n           /* @@ This shouldn't be needed.  My test case \"zstring.cc\" trips\n              up here if this is changed to an assertion.  --KR  */\n-\t  SET_IDENTIFIER_TYPE_VALUE (name, newval);\n+\t  SET_IDENTIFIER_TYPE_VALUE (name, x);\n \t}\n       else\n         {\n@@ -4196,7 +4193,7 @@ pushdecl_class_level (tree x)\n     {\n       is_valid = push_class_level_binding (name, x);\n       if (TREE_CODE (x) == TYPE_DECL)\n-\tset_identifier_type_value (name, TREE_TYPE (x));\n+\tset_identifier_type_value (name, x);\n     }\n   else if (ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n     {\n@@ -5192,9 +5189,9 @@ lookup_tag (enum tree_code form, tree name,\n \t    if (thislevel_only && !allow_template_parms_p\n \t\t&& binding && BINDING_VALUE (binding)\n \t\t&& DECL_CLASS_TEMPLATE_P (BINDING_VALUE (binding)))\n-\t      old = TREE_TYPE (BINDING_VALUE (binding));\n+\t      old = BINDING_VALUE (binding);\n \t    else if (binding)\n-\t      old = BINDING_TYPE (binding);\n+\t      old = select_decl (binding, LOOKUP_PREFER_TYPES);\n             else\n               old = NULL_TREE;\n \n@@ -5203,6 +5200,7 @@ lookup_tag (enum tree_code form, tree name,\n \t\t/* We've found something at this binding level.  If it is\n \t\t   a typedef, extract the tag it refers to.  Lookup fails\n \t\t   if the typedef doesn't refer to a taggable type.  */\n+\t\told = TREE_TYPE (old);\n \t\told = follow_tag_typedef (old);\n \t\tif (!old)\n \t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n@@ -5645,12 +5643,11 @@ select_decl (cxx_binding *binding, int flags)\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n     }\n \n-  /* If we could have a type and\n-     we have nothing or we need a type and have none.  */\n-  if (BINDING_TYPE (binding)\n-      && (!val || ((flags & LOOKUP_PREFER_TYPES)\n-                   && TREE_CODE (val) != TYPE_DECL)))\n-    val = TYPE_STUB_DECL (BINDING_TYPE (binding));\n+  /* If looking for a type, or if there is no non-type binding, select\n+     the value binding.  */\n+  if (BINDING_TYPE (binding) \n+      && (!val || (flags & LOOKUP_PREFER_TYPES)))\n+    val = BINDING_TYPE (binding);\n   /* Don't return non-types if we really prefer types.  */\n   else if (val && LOOKUP_TYPES_ONLY (flags)  && TREE_CODE (val) != TYPE_DECL\n \t   && (TREE_CODE (val) != TEMPLATE_DECL\n@@ -6045,9 +6042,9 @@ lookup_type_current_level (tree name)\n \n \f\n /* Push the declarations of builtin types into the namespace.\n-   RID_INDEX is the index of the builtin type\n-   in the array RID_POINTERS.  NAME is the name used when looking\n-   up the builtin type.  TYPE is the _TYPE node for the builtin type.  */\n+   RID_INDEX is the index of the builtin type in the array\n+   RID_POINTERS.  NAME is the name used when looking up the builtin\n+   type.  TYPE is the _TYPE node for the builtin type.  */\n \n void\n record_builtin_type (enum rid rid_index, \n@@ -6062,27 +6059,30 @@ record_builtin_type (enum rid rid_index,\n   if (name)\n     tname = get_identifier (name);\n \n+  /* The calls to SET_IDENTIFIER_GLOBAL_VALUE below should be\n+     eliminated.  Built-in types should not be looked up name; their\n+     names are keywords that the parser can recognize.  However, there\n+     is code in c-common.c that uses identifier_global_value to look\n+     up built-in types by name.  */\n   if (tname)\n     {\n-      tdecl = pushdecl (build_decl (TYPE_DECL, tname, type));\n-      set_identifier_type_value (tname, NULL_TREE);\n-      if ((int) rid_index < (int) RID_MAX)\n-\t/* Built-in types live in the global namespace.  */\n+      tdecl = build_decl (TYPE_DECL, tname, type);\n+      DECL_ARTIFICIAL (tdecl) = 1;\n+      if (tname)\n \tSET_IDENTIFIER_GLOBAL_VALUE (tname, tdecl);\n     }\n-  if (rname != NULL_TREE)\n+  if (rname)\n     {\n-      if (tname != NULL_TREE)\n-\t{\n-\t  set_identifier_type_value (rname, NULL_TREE);\n-\t  SET_IDENTIFIER_GLOBAL_VALUE (rname, tdecl);\n-\t}\n-      else\n+      if (!tdecl)\n \t{\n-\t  tdecl = pushdecl (build_decl (TYPE_DECL, rname, type));\n-\t  set_identifier_type_value (rname, NULL_TREE);\n+\t  tdecl = build_decl (TYPE_DECL, rname, type);\n+\t  DECL_ARTIFICIAL (tdecl) = 1;\n \t}\n+      SET_IDENTIFIER_GLOBAL_VALUE (rname, tdecl);\n     }\n+\n+  if (!TYPE_NAME (type))\n+    TYPE_NAME (type) = tdecl;\n }\n \n /* Record one of the standard Java types.\n@@ -6334,14 +6334,22 @@ cxx_init_decl_processing (void)\n   current_lang_name = lang_name_cplusplus;\n \n   {\n-    tree bad_alloc_type_node, newtype, deltype;\n+    tree bad_alloc_id;\n+    tree bad_alloc_type_node;\n+    tree bad_alloc_decl;\n+    tree newtype, deltype;\n     tree ptr_ftype_sizetype;\n \n     push_namespace (std_identifier);\n-    bad_alloc_type_node \n-      = xref_tag (class_type, get_identifier (\"bad_alloc\"), \n-\t\t  /*attributes=*/NULL_TREE, true, false);\n+    bad_alloc_id = get_identifier (\"bad_alloc\");\n+    bad_alloc_type_node = make_aggr_type (RECORD_TYPE);\n+    TYPE_CONTEXT (bad_alloc_type_node) = current_namespace;\n+    bad_alloc_decl \n+      = create_implicit_typedef (bad_alloc_id, bad_alloc_type_node);\n+    DECL_CONTEXT (bad_alloc_decl) = current_namespace;\n+    TYPE_STUB_DECL (bad_alloc_type_node) = bad_alloc_decl;\n     pop_namespace ();\n+ \n     ptr_ftype_sizetype \n       = build_function_type (ptr_type_node,\n \t\t\t     tree_cons (NULL_TREE,\n@@ -8064,7 +8072,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t{\n \t  if (TREE_TYPE (DECL_NAME (decl)) && TREE_TYPE (decl) != type)\n \t    warning (\"shadowing previous type declaration of `%#D'\", decl);\n-\t  set_identifier_type_value (DECL_NAME (decl), type);\n+\t  set_identifier_type_value (DECL_NAME (decl), decl);\n \t}\n \n       /* If we have installed this as the canonical typedef for this\n@@ -8495,8 +8503,6 @@ register_dtor_fn (tree decl)\n static void\n expand_static_init (tree decl, tree init)\n {\n-  tree oldstatic;\n-\n   my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 20021010);\n   my_friendly_assert (TREE_STATIC (decl), 20021010);\n \n@@ -8506,14 +8512,7 @@ expand_static_init (tree decl, tree init)\n       && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n \n-  oldstatic = value_member (decl, static_aggregates);\n-\n-  if (oldstatic)\n-    {\n-      if (TREE_PURPOSE (oldstatic) && init != NULL_TREE)\n-\terror (\"multiple initializations given for `%D'\", decl);\n-    }\n-  else if (! toplevel_bindings_p ())\n+  if (! toplevel_bindings_p ())\n     {\n       /* Emit code to perform this initialization but once.  */\n       tree if_stmt;\n@@ -8901,7 +8900,7 @@ grokfndecl (tree ctype,\n     }\n \n   if (IDENTIFIER_OPNAME_P (DECL_NAME (decl)))\n-    grok_op_properties (decl, friendp);\n+    grok_op_properties (decl, friendp, /*complain=*/true);\n \n   if (ctype && decl_function_context (decl))\n     DECL_NO_STATIC_CHAIN (decl) = 1;\n@@ -12184,17 +12183,23 @@ unary_op_p (enum tree_code code)\n \t  || code == TYPE_EXPR);\n }\n \n-/* Do a little sanity-checking on how they declared their operator.  */\n+/* DECL is a declaration for an overloaded operator.  Returns true if\n+   the declaration is valid; false otherwise.  If COMPLAIN is true,\n+   errors are issued for invalid declarations.  */\n \n-void\n-grok_op_properties (tree decl, int friendp)\n+bool\n+grok_op_properties (tree decl, int friendp, bool complain)\n {\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n   tree argtype;\n   int methodp = (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n   tree name = DECL_NAME (decl);\n   enum tree_code operator_code;\n   int arity;\n+  bool ok;\n+\n+  /* Assume that the declaration is valid.  */\n+  ok = true;\n \n   /* Count the number of arguments.  */\n   for (argtype = argtypes, arity = 0;\n@@ -12288,33 +12293,38 @@ grok_op_properties (tree decl, int friendp)\n \t    error (\"`%D' must be a nonstatic member function\", decl);\n \t  else\n \t    {\n-\t      tree p = argtypes;\n+\t      tree p;\n \n \t      if (DECL_STATIC_FUNCTION_P (decl))\n \t\terror (\"`%D' must be either a non-static member function or a non-member function\", decl);\n \n-\t      if (p)\n-\t\tfor (; TREE_CODE (TREE_VALUE (p)) != VOID_TYPE ; p = TREE_CHAIN (p))\n-\t\t  {\n-\t\t    tree arg = non_reference (TREE_VALUE (p));\n-\n-\t\t    /* This lets bad template code slip through.  */\n-\t\t    if (IS_AGGR_TYPE (arg)\n-\t\t\t|| TREE_CODE (arg) == ENUMERAL_TYPE\n-\t\t\t|| TREE_CODE (arg) == TEMPLATE_TYPE_PARM\n-\t\t\t|| TREE_CODE (arg) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-\t\t      goto foundaggr;\n-\t\t  }\n-\t      error\n-\t\t(\"`%D' must have an argument of class or enumerated type\",\n-\t\t decl);\n-\t    foundaggr:\n-\t      ;\n+\t      for (p = argtypes; p && p != void_list_node; p = TREE_CHAIN (p))\n+\t\t{\n+\t\t  tree arg = non_reference (TREE_VALUE (p));\n+\t\t  /* IS_AGGR_TYPE, rather than CLASS_TYPE_P, is used\n+\t\t     because these checks are performed even on\n+\t\t     template functions.  */\n+\t\t  if (IS_AGGR_TYPE (arg) || TREE_CODE (arg) == ENUMERAL_TYPE)\n+\t\t    break;\n+\t\t}\n+\n+\t      if (!p || p == void_list_node)\n+\t\t{\n+\t\t  if (!complain)\n+\t\t    return false;\n+\n+\t\t  error (\"`%D' must have an argument of class or \"\n+\t\t\t \"enumerated type\",\n+\t\t\t decl);\n+\t\t  ok = false;\n+\t\t}\n \t    }\n \t}\n \n+      /* There are no restrictions on the arguments to an overloaded\n+\t \"operator ()\".  */\n       if (operator_code == CALL_EXPR)\n-\treturn;\t\t\t/* No restrictions on args.  */\n+\treturn ok;\n \n       if (IDENTIFIER_TYPENAME_P (name) && ! DECL_TEMPLATE_INFO (decl))\n \t{\n@@ -12497,6 +12507,8 @@ grok_op_properties (tree decl, int friendp)\n           }\n \n     }\n+\n+  return ok;\n }\n \f\n static const char *\n@@ -12518,45 +12530,61 @@ tag_name (enum tag_types code)\n }\n \n /* Name lookup in an elaborated-type-specifier (after the keyword\n-   indicated by TAG_CODE) has found TYPE.  If the\n+   indicated by TAG_CODE) has found the TYPE_DECL DECL.  If the\n    elaborated-type-specifier is invalid, issue a diagnostic and return\n-   error_mark_node; otherwise, return TYPE itself.  \n+   error_mark_node; otherwise, return the *_TYPE to which it referred.\n    If ALLOW_TEMPLATE_P is true, TYPE may be a class template.  */\n \n tree\n check_elaborated_type_specifier (enum tag_types tag_code,\n-\t\t\t\t tree type,\n+\t\t\t\t tree decl,\n \t\t\t\t bool allow_template_p)\n {\n-  tree t = follow_tag_typedef (type);\n+  tree type;\n \n-  /* [dcl.type.elab] If the identifier resolves to a typedef-name or a\n-     template type-parameter, the elaborated-type-specifier is\n-     ill-formed.  */\n-  if (!t)\n+  /* In the case of:\n+\n+       struct S { struct S *p; };\n+\n+     name lookup will find the TYPE_DECL for the implicit \"S::S\"\n+     typedef.  Adjust for that here.  */\n+  if (DECL_SELF_REFERENCE_P (decl))\n+    decl = TYPE_NAME (TREE_TYPE (decl));\n+\n+  type = TREE_TYPE (decl);\n+\n+  /*   [dcl.type.elab] \n+\n+       If the identifier resolves to a typedef-name or a template\n+       type-parameter, the elaborated-type-specifier is ill-formed.\n+\n+     In other words, the only legitimate declaration to use in the\n+     elaborated type specifier is the implicit typedef created when\n+     the type is declared.  */\n+  if (!DECL_IMPLICIT_TYPEDEF_P (decl))\n     {\n-      error (\"using typedef-name `%T' after `%s'\",\n-\t     type, tag_name (tag_code));\n-      t = error_mark_node;\n+      error (\"using typedef-name `%D' after `%s'\", decl, tag_name (tag_code));\n+      return IS_AGGR_TYPE (type) ? type : error_mark_node;\n     }\n-  else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+    \n+  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n     {\n       error (\"using template type parameter `%T' after `%s'\",\n \t     type, tag_name (tag_code));\n-      t = error_mark_node;\n+      return error_mark_node;\n     }\n   else if (TREE_CODE (type) != RECORD_TYPE\n \t   && TREE_CODE (type) != UNION_TYPE\n \t   && tag_code != enum_type)\n     {\n       error (\"`%T' referred to as `%s'\", type, tag_name (tag_code));\n-      t = error_mark_node;\n+      return error_mark_node;\n     }\n   else if (TREE_CODE (type) != ENUMERAL_TYPE\n \t   && tag_code == enum_type)\n     {\n       error (\"`%T' referred to as enum\", type);\n-      t = error_mark_node;\n+      return error_mark_node;\n     }\n   else if (!allow_template_p\n \t   && TREE_CODE (type) == RECORD_TYPE\n@@ -12573,10 +12601,10 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n       error (\"template argument required for `%s %T'\",\n \t     tag_name (tag_code),\n \t     DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)));\n-      t = error_mark_node;\n+      return error_mark_node;\n     }\n \n-  return t;\n+  return type;\n }\n \n /* Get the struct, enum or union (TAG_CODE says which) with tag NAME.\n@@ -12653,8 +12681,8 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n \t\t class C *c2;\t\t// DECL_SELF_REFERENCE_P is true\n \t       };  */\n \n-\t  t = check_elaborated_type_specifier (tag_code, \n-\t\t\t\t\t       TREE_TYPE (decl),\n+\t  t = check_elaborated_type_specifier (tag_code,\n+\t\t\t\t\t       decl,\n \t\t\t\t\t       template_header_p\n \t\t\t\t\t       | DECL_SELF_REFERENCE_P (decl));\n \t  if (t == error_mark_node)\n@@ -14216,7 +14244,11 @@ start_method (tree declspecs, tree declarator, tree attrlist)\n \n   /* We process method specializations in finish_struct_1.  */\n   if (processing_template_decl && !DECL_TEMPLATE_SPECIALIZATION (fndecl))\n-    fndecl = push_template_decl (fndecl);\n+    {\n+      fndecl = push_template_decl (fndecl);\n+      if (fndecl == error_mark_node)\n+\treturn fndecl;\n+    }\n \n   if (! DECL_FRIEND_P (fndecl))\n     {"}, {"sha": "a38d993e0670b98aee60bf345041476e964f5d9e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -387,12 +387,6 @@ grokclassfn (tree ctype, tree function, enum overload_flags flags, tree quals)\n \n   if (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function))\n     maybe_retrofit_in_chrg (function);\n-\n-  if (flags == DTOR_FLAG)\n-    {\n-      DECL_DESTRUCTOR_P (function) = 1;\n-      TYPE_HAS_DESTRUCTOR (ctype) = 1;\n-    }\n }\n \n /* Create an ARRAY_REF, checking for the user doing things backwards"}, {"sha": "c07b5ff56bb0efa9a904564f2cbaba2e4921efb3", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -377,7 +377,12 @@ set_namespace_binding (tree name, tree scope, tree val)\n   if (scope == NULL_TREE)\n     scope = global_namespace;\n   b = binding_for_name (NAMESPACE_LEVEL (scope), name);\n-  BINDING_VALUE (b) = val;\n+  if (!BINDING_VALUE (b)\n+      || TREE_CODE (val) == OVERLOAD \n+      || val == error_mark_node)\n+    BINDING_VALUE (b) = val;\n+  else\n+    add_binding (b, val);\n   timevar_pop (TV_NAME_LOOKUP);\n }\n "}, {"sha": "b2a111314634e15d1191b27d11e63ca25dae85b8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -1413,7 +1413,7 @@ static tree cp_parser_function_specifier_opt\n static tree cp_parser_type_specifier\n   (cp_parser *, cp_parser_flags, bool, bool, int *, bool *);\n static tree cp_parser_simple_type_specifier\n-  (cp_parser *, cp_parser_flags);\n+  (cp_parser *, cp_parser_flags, bool);\n static tree cp_parser_type_name\n   (cp_parser *);\n static tree cp_parser_elaborated_type_specifier\n@@ -3361,7 +3361,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \tcp_parser_parse_tentatively (parser);\n \t/* Look for the simple-type-specifier.  */\n \ttype = cp_parser_simple_type_specifier (parser, \n-\t\t\t\t\t\tCP_PARSER_FLAGS_NONE);\n+\t\t\t\t\t\tCP_PARSER_FLAGS_NONE,\n+\t\t\t\t\t\t/*identifier_p=*/false);\n \t/* Parse the cast itself.  */\n \tif (!cp_parser_error_occurred (parser))\n \t  postfix_expression \n@@ -8181,7 +8182,8 @@ cp_parser_type_specifier (cp_parser* parser,\n \n   /* If we do not already have a type-specifier, assume we are looking\n      at a simple-type-specifier.  */\n-  type_spec = cp_parser_simple_type_specifier (parser, flags);\n+  type_spec = cp_parser_simple_type_specifier (parser, flags, \n+\t\t\t\t\t       /*identifier_p=*/true);\n \n   /* If we didn't find a type-specifier, and a type-specifier was not\n      optional in this context, issue an error message.  */\n@@ -8218,11 +8220,13 @@ cp_parser_type_specifier (cp_parser* parser,\n      __typeof__ ( type-id )\n \n    For the various keywords, the value returned is simply the\n-   TREE_IDENTIFIER representing the keyword.  For the first two\n-   productions, the value returned is the indicated TYPE_DECL.  */\n+   TREE_IDENTIFIER representing the keyword if IDENTIFIER_P is true.\n+   For the first two productions, and if IDENTIFIER_P is false, the\n+   value returned is the indicated TYPE_DECL.  */\n \n static tree\n-cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags)\n+cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n+\t\t\t\t bool identifier_p)\n {\n   tree type = NULL_TREE;\n   cp_token *token;\n@@ -8234,18 +8238,38 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags)\n   switch (token->keyword)\n     {\n     case RID_CHAR:\n+      type = char_type_node;\n+      break;\n     case RID_WCHAR:\n+      type = wchar_type_node;\n+      break;\n     case RID_BOOL:\n+      type = boolean_type_node;\n+      break;\n     case RID_SHORT:\n+      type = short_integer_type_node;\n+      break;\n     case RID_INT:\n+      type = integer_type_node;\n+      break;\n     case RID_LONG:\n+      type = long_integer_type_node;\n+      break;\n     case RID_SIGNED:\n+      type = integer_type_node;\n+      break;\n     case RID_UNSIGNED:\n+      type = unsigned_type_node;\n+      break;\n     case RID_FLOAT:\n+      type = float_type_node;\n+      break;\n     case RID_DOUBLE:\n+      type = double_type_node;\n+      break;\n     case RID_VOID:\n-      /* Consume the token.  */\n-      return cp_lexer_consume_token (parser->lexer)->value;\n+      type = void_type_node;\n+      break;\n \n     case RID_TYPEOF:\n       {\n@@ -8266,6 +8290,16 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags)\n       break;\n     }\n \n+  /* If the type-specifier was for a built-in type, we're done.  */\n+  if (type)\n+    {\n+      tree id;\n+\n+      /* Consume the token.  */\n+      id = cp_lexer_consume_token (parser->lexer)->value;\n+      return identifier_p ? id : TYPE_NAME (type);\n+    }\n+\n   /* The type-specifier must be a user-defined type.  */\n   if (!(flags & CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES)) \n     {\n@@ -8549,8 +8583,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \n \t  if (TREE_CODE (TREE_TYPE (decl)) != TYPENAME_TYPE)\n \t    check_elaborated_type_specifier \n-\t      (tag_type, \n-\t       TREE_TYPE (decl),\n+\t      (tag_type, decl,\n \t       (parser->num_template_parameter_lists\n \t\t|| DECL_SELF_REFERENCE_P (decl)));\n "}, {"sha": "863ab86ad19b0810d6af49519f0287270f289226", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -2674,6 +2674,15 @@ push_template_decl_real (tree decl, int is_friend)\n       else if (TREE_CODE (decl) == TYPE_DECL \n \t       && ANON_AGGRNAME_P (DECL_NAME (decl))) \n \terror (\"template class without a name\");\n+      else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t       && DECL_DESTRUCTOR_P (decl))\n+\t{\n+\t  /* [temp.mem]\n+\t     \n+\t      A destructor shall not be a member template.  */\n+\t  error (\"destructor `%D' declared as member template\", decl);\n+\t  return error_mark_node;\n+\t}\n       else if ((DECL_IMPLICIT_TYPEDEF_P (decl)\n \t\t&& CLASS_TYPE_P (TREE_TYPE (decl)))\n \t       || (TREE_CODE (decl) == VAR_DECL && ctx && CLASS_TYPE_P (ctx))\n@@ -5996,7 +6005,8 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t      clone_function_decl (r, /*update_method_vec_p=*/0);\n \t  }\n \telse if (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n-\t  grok_op_properties (r, DECL_FRIEND_P (r));\n+\t  grok_op_properties (r, DECL_FRIEND_P (r),\n+\t\t\t      (complain & tf_error) != 0);\n       }\n       break;\n "}, {"sha": "8b5af5ef4af7efa0974587e352f39bec08b15556", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -1114,23 +1114,7 @@ build_functional_cast (tree exp, tree parms)\n   if (exp == error_mark_node || parms == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (exp) == IDENTIFIER_NODE)\n-    {\n-      if (IDENTIFIER_HAS_TYPE_VALUE (exp))\n-\t/* Either an enum or an aggregate type.  */\n-\ttype = IDENTIFIER_TYPE_VALUE (exp);\n-      else\n-\t{\n-\t  type = lookup_name (exp, 1);\n-\t  if (!type || TREE_CODE (type) != TYPE_DECL)\n-\t    {\n-\t      error (\"`%T' fails to be a typedef or built-in type\", exp);\n-\t      return error_mark_node;\n-\t    }\n-\t  type = TREE_TYPE (type);\n-\t}\n-    }\n-  else if (TREE_CODE (exp) == TYPE_DECL)\n+  if (TREE_CODE (exp) == TYPE_DECL)\n     type = TREE_TYPE (exp);\n   else\n     type = exp;"}, {"sha": "1020020022bffc2c93f576d82e5c2633f82e36cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -1,3 +1,23 @@\n+2003-08-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10926\n+\t* g++.dg/template/dtor2.C: New test.\n+\n+\tPR c++/11684\n+\t* g++.dg/template/operator1.C: New test.\n+\t* g++.dg/parse/operator4.C: New test.\n+\n+\tPR c++/11946.C\n+\t* g++.dg/expr/enum1.C: New test.\n+\t* gcc.dg/c99-bool-1.c: Remove bogus warning.\n+\n+\tPR c++/11036.C\n+\t* g++.dg/parse/elab2.C: New test.\n+\t* g++.dg/parse/typedef4.C: Change error message.\n+\t* g++.old-deja/g++.robertl/eb133.C: Remove bogus error markers.\n+\t* g++.old-deja/g++.robertl/eb133a.C: Remove bogus error markers.\n+\t* g++.old-deja/g++.robertl/eb133b.C: Remove bogus error markers.\n+\n 2003-08-19  Geoffrey Keating  <geoffk@apple.com>\n \n \t* gcc.dg/pch/warn-1.c: New."}, {"sha": "df2a823d5513c4e2f1b562ad88f3bd40d522c667", "filename": "gcc/testsuite/g++.dg/expr/enum1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fenum1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fenum1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fenum1.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do run }\n+\n+void abort();\n+int main()\n+{\n+    enum { shelf = 4 } t = shelf;\n+    if (!(t & shelf))\n+\tabort ();\n+}\n+"}, {"sha": "69273a3fc3173a59cf9125bb570d7ac1a2a3a143", "filename": "gcc/testsuite/g++.dg/parse/elab2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Felab2.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -0,0 +1,7 @@\n+struct A {};\n+\n+struct B\n+{\n+  typedef A T;\n+  friend struct T; // { dg-error \"\" }\n+};"}, {"sha": "9395ccdd1b231b8d4538718a1c2a023b95f346dd", "filename": "gcc/testsuite/g++.dg/parse/operator4.C", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator4.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -0,0 +1 @@\n+int operator *(int, ...); // { dg-error \"class\" }"}, {"sha": "03f709a184d17c05602d028226450328634c6a61", "filename": "gcc/testsuite/g++.dg/parse/typedef4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypedef4.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -8,5 +8,5 @@ template<class T> class smart_ptr2 {\n     T* real_ptr;\n  public:\n     typedef typename T::subT  td;\n-    friend class td; // { dg-error \"typename|not name a class\" }\n+    friend class td; // { dg-error \"typedef\" }\n };"}, {"sha": "04bea9cb640cd0323a701fe4c00aef97f029b869", "filename": "gcc/testsuite/g++.dg/template/dtor2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor2.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -0,0 +1,10 @@\n+struct Foo\n+{\n+    template <int i>\n+    ~Foo() {} // { dg-error \"\" }\n+};\n+\n+int main()\n+{\n+   Foo f;\n+}"}, {"sha": "402e607d1e4fd789b9eebe7033cc25733e0f16b7", "filename": "gcc/testsuite/g++.dg/template/operator1.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator1.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -0,0 +1,49 @@\n+class test\n+{\n+public:\n+ float operator[]( int index )\n+ {\n+  return testFloat[index];\n+ }\n+private:\n+ float testFloat[3];\n+};\n+\n+template < class typeA > float\n+operator*(\n+ typeA a,\n+ float b\n+)\n+{\n+ return a[0] * b;\n+}\n+\n+template < class typeB > float\n+operator*(\n+ float a,\n+ typeB b\n+)\n+{\n+ return a * b[0];\n+}\n+\n+template < class typeA, class typeB > float\n+operator*(\n+ typeA a,\n+ typeB b\n+)\n+{\n+ return a[0] * b[0];\n+}\n+\n+int main( void )\n+{\n+ test aTest;\n+ float bTest;\n+ float result;\n+\n+ result = aTest * bTest;\n+ result = bTest * aTest;\n+\n+ return 0;\n+}"}, {"sha": "419a36efd4be2052b8c80be8ba51c0f1eac6b32e", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb133.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -3,15 +3,13 @@\n // From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de> \n // Reported against EGCS snaps 98/06/28.\n \n-// { dg-error \"forward declaration\" \"\" { target *-*-* } 0 }\n-\n using namespace std;\n \n int main()\n {\n \ttry {\n \t}\n-\tcatch (bad_alloc) { // { dg-error \"invalid use\" }\n+\tcatch (bad_alloc) { // { dg-error \"\" }\n \t\treturn 1;\n \t}\n \treturn 0;"}, {"sha": "eb6c72d20a606fe709619ab92cb4d466dff7c366", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb133a.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133a.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -3,8 +3,6 @@\n // From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de> \n // Reported against EGCS snaps 98/06/28.\n \n-// { dg-error \"forward declaration\" \"\" { target *-*-* } 0 }\n-\n int main()\n {\n \ttry {"}, {"sha": "9885031004b91e0c7ccc9cadd649b8e688cd3258", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb133b.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb133b.C?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -3,15 +3,13 @@\n // From: Klaus-Georg Adams <Klaus-Georg.Adams@chemie.uni-karlsruhe.de> \n // Reported against EGCS snaps 98/06/28.\n \n-// { dg-error \"forward declaration\" \"\" { target *-*-* } 0 }\n-\n using namespace std;\n \n int main()\n {\n \ttry {\n \t}\n-\tcatch (bad_alloc) { // { dg-error \"invalid use\" }\n+\tcatch (bad_alloc) { // { dg-error \"\" }\n \t\treturn 1;\n \t}\n \treturn 0;"}, {"sha": "710219620b7e334b86ef12980be9fe13b14cbdd5", "filename": "gcc/testsuite/gcc.dg/c99-bool-1.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-bool-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0d3cbe3ef315a363ce89a3264d4791090227fb/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-bool-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-bool-1.c?ref=4b0d3cbe3ef315a363ce89a3264d4791090227fb", "patch": "@@ -228,9 +228,7 @@ main (void)\n     abort ();\n   if ((u |= 2) != 1)\n     abort ();\n-  /* ??? A bit queer, since this gets optimized to ((u = (u != 3)) != 1)\n-     early in semantic analysis, which then yields the warning below.  */\n-  if ((u ^= 3) != 1)\t/* { dg-warning \"always true due to limited range\" } */\n+  if ((u ^= 3) != 1)\n     abort ();\n   /* Test comma expressions.  */\n   u = 1;"}]}