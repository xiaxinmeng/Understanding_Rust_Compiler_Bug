{"sha": "ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY4NmQyYTY2NzVjZmNlOTljZjIyY2YzMGEzZTJlYTlhODMzZjJiNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-02T01:53:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-02T01:53:23Z"}, "message": "Use DECL_C_BIT_FIELD, not DECL_BIT_FIELD in all tests.\n\nFrom-SVN: r10933", "tree": {"sha": "8baf98095c9b41531ca0d4161920eec11b283279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8baf98095c9b41531ca0d4161920eec11b283279"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6/comments", "author": null, "committer": null, "parents": [{"sha": "2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19"}], "stats": {"total": 18, "additions": 10, "deletions": 8}, "files": [{"sha": "b981a9fd9c9601b4a87698242dc45a7bb1b0c90c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ef86d2a6675cfce99cf22cf30a3e2ea9a833f2b6", "patch": "@@ -1,5 +1,5 @@\n /* Build expressions with type checking for C compiler.\n-   Copyright (C) 1987, 88, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 92-5, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -945,7 +945,7 @@ c_alignof_expr (expr)\n     return size_int (DECL_ALIGN (expr) / BITS_PER_UNIT);\n  \n   if (TREE_CODE (expr) == COMPONENT_REF\n-      && DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))\n+      && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n     {\n       error (\"`__alignof' applied to a bit-field\");\n       return size_int (1);\n@@ -3075,7 +3075,7 @@ build_unary_op (code, xarg, noconvert)\n \n \t    addr = build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 0);\n \n-\t    if (DECL_BIT_FIELD (field))\n+\t    if (DECL_C_BIT_FIELD (field))\n \t      {\n \t\terror (\"attempt to take address of bit-field structure member `%s'\",\n \t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n@@ -5261,7 +5261,7 @@ really_start_incremental_init (type)\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       /* Skip any nameless bit fields at the beginning.  */\n-      while (constructor_fields != 0 && DECL_BIT_FIELD (constructor_fields)\n+      while (constructor_fields != 0 && DECL_C_BIT_FIELD (constructor_fields)\n \t     && DECL_NAME (constructor_fields) == 0)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n       constructor_unfilled_fields = constructor_fields;\n@@ -5433,7 +5433,7 @@ push_init_level (implicit)\n     {\n       constructor_fields = TYPE_FIELDS (constructor_type);\n       /* Skip any nameless bit fields at the beginning.  */\n-      while (constructor_fields != 0 && DECL_BIT_FIELD (constructor_fields)\n+      while (constructor_fields != 0 && DECL_C_BIT_FIELD (constructor_fields)\n \t     && DECL_NAME (constructor_fields) == 0)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n       constructor_unfilled_fields = constructor_fields;\n@@ -5475,7 +5475,7 @@ check_init_type_bitfields (type)\n       for (tail = TYPE_FIELDS (type); tail;\n \t   tail = TREE_CHAIN (tail))\n \t{\n-\t  if (DECL_BIT_FIELD (tail)\n+\t  if (DECL_C_BIT_FIELD (tail)\n \t      /* This catches cases like `int foo : 8;'.  */\n \t      || DECL_MODE (tail) != TYPE_MODE (TREE_TYPE (tail)))\n \t    {\n@@ -5827,7 +5827,8 @@ output_init_element (value, type, field, pending)\n   else if (initializer_constant_valid_p (value, TREE_TYPE (value)) == 0\n \t   || ((TREE_CODE (constructor_type) == RECORD_TYPE\n \t\t|| TREE_CODE (constructor_type) == UNION_TYPE)\n-\t       && DECL_BIT_FIELD (field) && TREE_CODE (value) != INTEGER_CST))\n+\t       && DECL_C_BIT_FIELD (field)\n+\t       && TREE_CODE (value) != INTEGER_CST))\n     constructor_simple = 0;\n \n   if (require_constant_value && ! TREE_CONSTANT (value))\n@@ -6251,7 +6252,8 @@ process_init_element (value)\n \n \t  constructor_fields = TREE_CHAIN (constructor_fields);\n \t  /* Skip any nameless bit fields at the beginning.  */\n-\t  while (constructor_fields != 0 && DECL_BIT_FIELD (constructor_fields)\n+\t  while (constructor_fields != 0\n+\t\t && DECL_C_BIT_FIELD (constructor_fields)\n \t\t && DECL_NAME (constructor_fields) == 0)\n \t    constructor_fields = TREE_CHAIN (constructor_fields);\n \t  break;"}]}