{"sha": "1ccf251f9751554268b356b21bf452cf7f686f09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNjZjI1MWY5NzUxNTU0MjY4YjM1NmIyMWJmNDUyY2Y3ZjY4NmYwOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-05T19:14:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-05T19:14:50Z"}, "message": "Include <ctype.h>; avoid home-grown ISDIGIT.\n\n(decl_attributes): Call record_function_format with DECL_NAME and also\nDECL_ASSEMBLER_NAME.\n(struct format_char_info): Moved here from c-typeck.c.\n(print_char_table): Likewise; renamed from print_table.\n(scan_char_table): Likewise; renamed from scan_table.\n(struct function_format_info): Likewise; add assembler_name.\n(function_format_list): Make list, not array.\n(init_function_format_info): Likewise; renamed from init_format_info_table.\n(record_function_format): Likewise; renamed from record_format_info;\nrecord assembler_name.\n(check_format_info): Likewise; renamed from check_format.\n(check_function_format): New interface that does not require knowledge of\nstruct function_format_info.\n\nFrom-SVN: r5607", "tree": {"sha": "d09baedfa3395fb44bf2be6b21ee3cc4be34808d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d09baedfa3395fb44bf2be6b21ee3cc4be34808d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ccf251f9751554268b356b21bf452cf7f686f09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccf251f9751554268b356b21bf452cf7f686f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccf251f9751554268b356b21bf452cf7f686f09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccf251f9751554268b356b21bf452cf7f686f09/comments", "author": null, "committer": null, "parents": [{"sha": "561d994ff66e664197918057620f50e7a7316707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561d994ff66e664197918057620f50e7a7316707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561d994ff66e664197918057620f50e7a7316707"}], "stats": {"total": 572, "additions": 569, "deletions": 3}, "files": [{"sha": "bd70adc821cd42c7151a5d282e018e09ca541b83", "filename": "gcc/c-common.c", "status": "modified", "additions": 569, "deletions": 3, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccf251f9751554268b356b21bf452cf7f686f09/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccf251f9751554268b356b21bf452cf7f686f09/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1ccf251f9751554268b356b21bf452cf7f686f09", "patch": "@@ -24,6 +24,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"flags.h\"\n #include \"obstack.h\"\n #include <stdio.h>\n+#include <ctype.h>\n \n extern struct obstack permanent_obstack;\n \n@@ -335,12 +336,577 @@ decl_attributes (decl, attributes)\n \t\treturn;\n \t      }\n \t  }\n-\t\n-\trecord_format_info (DECL_NAME (decl), is_scan, format_num,\n-\t\t\t    first_arg_num);\n+\n+\trecord_function_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n+\t\t\t\tis_scan, format_num, first_arg_num);\n       }\n }\n \f\n+/* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against\n+   a parameter list.  */\n+\n+#define T_I\t&integer_type_node\n+#define T_L\t&long_integer_type_node\n+#define T_S\t&short_integer_type_node\n+#define T_UI\t&unsigned_type_node\n+#define T_UL\t&long_unsigned_type_node\n+#define T_US\t&short_unsigned_type_node\n+#define T_F\t&float_type_node\n+#define T_D\t&double_type_node\n+#define T_LD\t&long_double_type_node\n+#define T_C\t&char_type_node\n+#define T_V\t&void_type_node\n+#define T_W\t&wchar_type_node\n+\n+typedef struct {\n+  char *format_chars;\n+  int pointer_count;\n+  /* Type of argument if no length modifier is used.  */\n+  tree *nolen;\n+  /* Type of argument if length modifier for shortening is used.\n+     If NULL, then this modifier is not allowed.  */\n+  tree *hlen;\n+  /* Type of argument if length modifier `l' is used.\n+     If NULL, then this modifier is not allowed.  */\n+  tree *llen;\n+  /* Type of argument if length modifier `L' is used.\n+     If NULL, then this modifier is not allowed.  */\n+  tree *bigllen;\n+  /* List of other modifier characters allowed with these options.  */\n+  char *flag_chars;\n+} format_char_info;\n+\n+static format_char_info print_char_table[] = {\n+  { \"di\",\t0,\tT_I,\tT_I,\tT_L,\tNULL,\t\"-wp0 +\"\t},\n+  { \"oxX\",\t0,\tT_UI,\tT_UI,\tT_UL,\tNULL,\t\"-wp0#\"\t\t},\n+  { \"u\",\t0,\tT_UI,\tT_UI,\tT_UL,\tNULL,\t\"-wp0\"\t\t},\n+  { \"feEgG\",\t0,\tT_D,\tNULL,\tNULL,\tT_LD,\t\"-wp0 +#\"\t},\n+  { \"c\",\t0,\tT_I,\tNULL,\tT_W,\tNULL,\t\"-w\"\t\t},\n+  { \"C\",\t0,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n+  { \"s\",\t1,\tT_C,\tNULL,\tT_W,\tNULL,\t\"-wp\"\t\t},\n+  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-wp\"\t\t},\n+  { \"p\",\t1,\tT_V,\tNULL,\tNULL,\tNULL,\t\"-w\"\t\t},\n+  { \"n\",\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"\"\t\t},\n+  { NULL }\n+};\n+\n+static format_char_info scan_char_table[] = {\n+  { \"di\",\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"*\"\t},\n+  { \"ouxX\",\t1,\tT_UI,\tT_US,\tT_UL,\tNULL,\t\"*\"\t},\t\n+  { \"efgEG\",\t1,\tT_F,\tNULL,\tT_D,\tT_LD,\t\"*\"\t},\n+  { \"sc\",\t1,\tT_C,\tNULL,\tT_W,\tNULL,\t\"*\"\t},\n+  { \"[\",\t1,\tT_C,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n+  { \"C\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n+  { \"S\",\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n+  { \"p\",\t2,\tT_V,\tNULL,\tNULL,\tNULL,\t\"*\"\t},\n+  { \"n\",\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"\"\t},\n+  { NULL }\n+};\n+\n+typedef struct function_format_info {\n+  struct function_format_info *next;  /* next structure on the list */\n+  tree name;\t\t\t/* identifier such as \"printf\" */\n+  tree assembler_name;\t\t/* optional mangled identifier (for C++) */\n+  int is_scan;\t\t\t/* TRUE if *scanf */\n+  int format_num;\t\t/* number of format argument */\n+  int first_arg_num;\t\t/* number of first arg (zero for varargs) */\n+} function_format_info;\n+\n+static function_format_info *function_format_list = NULL;\n+\n+static void check_format_info PROTO((function_format_info *, tree));\n+\n+/* Initialize the table of functions to perform format checking on.\n+   The ANSI functions are always checked (whether <stdio.h> is\n+   included or not), since it is common to call printf without\n+   including <stdio.h>.  There shouldn't be a problem with this,\n+   since ANSI reserves these function names whether you include the\n+   header file or not.  In any case, the checking is harmless.  */\n+\n+void\n+init_function_format_info ()\n+{\n+  record_function_format (get_identifier (\"printf\"), NULL_TREE, 0, 1, 2);\n+  record_function_format (get_identifier (\"fprintf\"), NULL_TREE, 0, 2, 3);\n+  record_function_format (get_identifier (\"sprintf\"), NULL_TREE, 0, 2, 3);\n+  record_function_format (get_identifier (\"scanf\"), NULL_TREE, 1, 1, 2);\n+  record_function_format (get_identifier (\"fscanf\"), NULL_TREE, 1, 2, 3);\n+  record_function_format (get_identifier (\"sscanf\"), NULL_TREE, 1, 2, 3);\n+  record_function_format (get_identifier (\"vprintf\"), NULL_TREE, 0, 1, 0);\n+  record_function_format (get_identifier (\"vfprintf\"), NULL_TREE, 0, 2, 0);\n+  record_function_format (get_identifier (\"vsprintf\"), NULL_TREE, 0, 2, 0);\n+}\n+\n+/* Record information for argument format checking.  FUNCTION_IDENT is\n+   the identifier node for the name of the function to check (its decl\n+   need not exist yet).  IS_SCAN is true for scanf-type format checking;\n+   false indicates printf-style format checking.  FORMAT_NUM is the number\n+   of the argument which is the format control string (starting from 1).\n+   FIRST_ARG_NUM is the number of the first actual argument to check\n+   against teh format string, or zero if no checking is not be done\n+   (e.g. for varargs such as vfprintf).  */\n+\n+void\n+record_function_format (name, assembler_name, is_scan,\n+\t\t\tformat_num, first_arg_num)\n+      tree name;\n+      tree assembler_name;\n+      int is_scan;\n+      int format_num;\n+      int first_arg_num;\n+{\n+  function_format_info *info;\n+\n+  /* Re-use existing structure if it's there.  */\n+\n+  for (info = function_format_list; info; info = info->next)\n+    {\n+      if (info->name == name && info->assembler_name == assembler_name)\n+\tbreak;\n+    }\n+  if (! info)\n+    {\n+      info = (function_format_info *) xmalloc (sizeof (function_format_info));\n+      info->next = function_format_list;\n+      function_format_list = info;\n+\n+      info->name = name;\n+      info->assembler_name = assembler_name;\n+    }\n+\n+  info->is_scan = is_scan;\n+  info->format_num = format_num;\n+  info->first_arg_num = first_arg_num;\n+}\n+\n+static char\ttfaff[] = \"too few arguments for format\";\n+\f\n+/* Check the argument list of a call to printf, scanf, etc.\n+   NAME is the function identifier.\n+   ASSEMBLER_NAME is the function's assembler identifier.\n+   (Either NAME or ASSEMBLER_NAME, but not both, may be NULL_TREE.)\n+   PARAMS is the list of argument values.  */\n+\n+void\n+check_function_format (name, assembler_name, params)\n+     tree name;\n+     tree assembler_name;\n+     tree params;\n+{\n+  function_format_info *info;\n+\n+  /* See if this function is a format function.  */\n+  for (info = function_format_list; info; info = info->next)\n+    {\n+      if ((info->assembler_name || assembler_name)\n+\t  ? (info->assembler_name == assembler_name)\n+\t  : (info->name == name))\n+\t{\n+\t  /* Yup; check it.  */\n+\t  check_format_info (info, params);\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Check the argument list of a call to printf, scanf, etc.\n+   INFO points to the function_format_info structure.\n+   PARAMS is the list of argument values.  */\n+\n+static void\n+check_format_info (info, params)\n+     function_format_info *info;\n+     tree params;\n+{\n+  int i;\n+  int arg_num;\n+  int suppressed, wide, precise;\n+  int length_char;\n+  int format_char;\n+  int format_length;\n+  tree format_tree;\n+  tree cur_param;\n+  tree cur_type;\n+  tree wanted_type;\n+  char *format_chars;\n+  format_char_info *fci;\n+  static char message[132];\n+  char flag_chars[8];\n+\n+  /* Skip to format argument.  If the argument isn't available, there's\n+     no work for us to do; prototype checking will catch the problem.  */\n+  for (arg_num = 1; ; ++arg_num)\n+    {\n+      if (params == 0)\n+\treturn;\n+      if (arg_num == info->format_num)\n+\tbreak;\n+      params = TREE_CHAIN (params);\n+    }\n+  format_tree = TREE_VALUE (params);\n+  params = TREE_CHAIN (params);\n+  if (format_tree == 0)\n+    return;\n+  /* We can only check the format if it's a string constant.  */\n+  while (TREE_CODE (format_tree) == NOP_EXPR)\n+    format_tree = TREE_OPERAND (format_tree, 0); /* strip coercion */\n+  if (format_tree == null_pointer_node)\n+    {\n+      warning (\"null format string\");\n+      return;\n+    }\n+  if (TREE_CODE (format_tree) != ADDR_EXPR)\n+    return;\n+  format_tree = TREE_OPERAND (format_tree, 0);\n+  if (TREE_CODE (format_tree) != STRING_CST)\n+    return;\n+  format_chars = TREE_STRING_POINTER (format_tree);\n+  format_length = TREE_STRING_LENGTH (format_tree);\n+  if (format_length <= 1)\n+    warning (\"zero-length format string\");\n+  if (format_chars[--format_length] != 0)\n+    {\n+      warning (\"unterminated format string\");\n+      return;\n+    }\n+  /* Skip to first argument to check.  */\n+  while (arg_num + 1 < info->first_arg_num)\n+    {\n+      if (params == 0)\n+\treturn;\n+      params = TREE_CHAIN (params);\n+      ++arg_num;\n+    }\n+  while (1)\n+    {\n+      if (*format_chars == 0)\n+\t{\n+\t  if (format_chars - TREE_STRING_POINTER (format_tree) != format_length)\n+\t    warning (\"embedded `\\\\0' in format\");\n+\t  if (info->first_arg_num != 0 && params != 0)\n+\t    warning (\"too many arguments for format\");\n+\t  return;\n+\t}\n+      if (*format_chars++ != '%')\n+\tcontinue;\n+      if (*format_chars == 0)\n+\t{\n+\t  warning (\"spurious trailing `%%' in format\");\n+\t  continue;\n+\t}\n+      if (*format_chars == '%')\n+\t{\n+\t  ++format_chars;\n+\t  continue;\n+\t}\n+      flag_chars[0] = 0;\n+      suppressed = wide = precise = FALSE;\n+      if (info->is_scan)\n+\t{\n+\t  suppressed = *format_chars == '*';\n+\t  if (suppressed)\n+\t    ++format_chars;\n+\t  while (isdigit (*format_chars))\n+\t    ++format_chars;\n+\t}\n+      else\n+\t{\n+\t  while (*format_chars != 0 && index (\" +#0-\", *format_chars) != 0)\n+\t    {\n+\t      if (index (flag_chars, *format_chars) != 0)\n+\t\t{\n+\t\t  sprintf (message, \"repeated `%c' flag in format\",\n+\t\t\t   *format_chars);\n+\t\t  warning (message);\n+\t\t}\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = *format_chars++;\n+\t      flag_chars[i] = 0;\n+\t    }\n+\t  /* \"If the space and + flags both appear, \n+\t     the space flag will be ignored.\"  */\n+\t  if (index (flag_chars, ' ') != 0\n+\t      && index (flag_chars, '+') != 0)\n+\t    warning (\"use of both ` ' and `+' flags in format\");\n+\t  /* \"If the 0 and - flags both appear,\n+\t     the 0 flag will be ignored.\"  */\n+\t  if (index (flag_chars, '0') != 0\n+\t      && index (flag_chars, '-') != 0)\n+\t    warning (\"use of both `0' and `-' flags in format\");\n+\t  if (*format_chars == '*')\n+\t    {\n+\t      wide = TRUE;\n+\t      /* \"...a field width...may be indicated by an asterisk.\n+\t\t In this case, an int argument supplies the field width...\"  */\n+\t      ++format_chars;\n+\t      if (params == 0)\n+\t\t{\n+\t\t  warning (tfaff);\n+\t\t  return;\n+\t\t}\n+\t      if (info->first_arg_num != 0)\n+\t\t{\n+\t\t  cur_param = TREE_VALUE (params);\n+\t\t  params = TREE_CHAIN (params);\n+\t\t  ++arg_num;\n+\t\t  /* size_t is generally not valid here.\n+\t\t     It will work on most machines, because size_t and int\n+\t\t     have the same mode.  But might as well warn anyway,\n+\t\t     since it will fail on other machines.  */\n+\t\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n+\t\t      != integer_type_node)\n+\t\t    {\n+\t\t      sprintf (message,\n+\t\t\t       \"field width is not type int (arg %d)\",\n+\t\t\t       arg_num);\n+\t\t      warning (message);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      while (isdigit (*format_chars))\n+\t\t{\n+\t\t  wide = TRUE;\n+\t\t  ++format_chars;\n+\t\t}\n+\t    }\n+\t  if (*format_chars == '.')\n+\t    {\n+\t      precise = TRUE;\n+\t      ++format_chars;\n+\t      if (*format_chars != '*' && !isdigit (*format_chars))\n+\t\twarning (\"`.' not followed by `*' or digit in format\");\n+\t      /* \"...a...precision...may be indicated by an asterisk.\n+\t\t In this case, an int argument supplies the...precision.\"  */\n+\t      if (*format_chars == '*')\n+\t\t{\n+\t\t  if (info->first_arg_num != 0)\n+\t\t    {\n+\t\t      ++format_chars;\n+\t\t      if (params == 0)\n+\t\t        {\n+\t\t\t  warning (tfaff);\n+\t\t\t  return;\n+\t\t\t}\n+\t\t      cur_param = TREE_VALUE (params);\n+\t\t      params = TREE_CHAIN (params);\n+\t\t      ++arg_num;\n+\t\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n+\t\t\t  != integer_type_node)\n+\t\t        {\n+\t\t          sprintf (message,\n+\t\t\t\t   \"field width is not type int (arg %d)\",\n+\t\t\t\t   arg_num);\n+\t\t          warning (message);\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  while (isdigit (*format_chars))\n+\t\t    ++format_chars;\n+\t\t}\n+\t    }\n+\t}\n+      if (*format_chars == 'h' || *format_chars == 'l' || *format_chars == 'L')\n+\tlength_char = *format_chars++;\n+      else\n+\tlength_char = 0;\n+      if (suppressed && length_char != 0)\n+\t{\n+\t  sprintf (message,\n+\t\t   \"use of `*' and `%c' together in format\",\n+\t\t   length_char);\n+\t  warning (message);\n+\t}\n+      format_char = *format_chars;\n+      if (format_char == 0)\n+\t{\n+\t  warning (\"conversion lacks type at end of format\");\n+\t  continue;\n+\t}\n+      format_chars++;\n+      fci = info->is_scan ? scan_char_table : print_char_table;\n+      while (fci->format_chars != 0\n+\t     && index (fci->format_chars, format_char) == 0)\n+\t  ++fci;\n+      if (fci->format_chars == 0)\n+\t{\n+\t  if (format_char >= 040 && format_char < 0177)\n+\t    sprintf (message,\n+\t\t     \"unknown conversion type character `%c' in format\",\n+\t\t     format_char);\n+\t  else\n+\t    sprintf (message,\n+\t\t     \"unknown conversion type character 0x%x in format\",\n+\t\t     format_char);\n+\t  warning (message);\n+\t  continue;\n+\t}\n+      if (wide && index (fci->flag_chars, 'w') == 0)\n+\t{\n+\t  sprintf (message, \"width used with `%c' format\",\n+\t\t   format_char);\n+\t  warning (message);\n+\t}\n+      if (precise && index (fci->flag_chars, 'p') == 0)\n+\t{\n+\t  sprintf (message, \"precision used with `%c' format\",\n+\t\t   format_char);\n+\t  warning (message);\n+\t}\n+      if (info->is_scan && format_char == '[')\n+\t{\n+\t  /* Skip over scan set, in case it happens to have '%' in it.  */\n+\t  if (*format_chars == '^')\n+\t    ++format_chars;\n+\t  /* Find closing bracket; if one is hit immediately, then\n+\t     it's part of the scan set rather than a terminator.  */\n+\t  if (*format_chars == ']')\n+\t    ++format_chars;\n+\t  while (*format_chars && *format_chars != ']')\n+\t    ++format_chars;\n+\t  if (*format_chars != ']')\n+\t      /* The end of the format string was reached.  */\n+\t      warning (\"no closing `]' for `%%[' format\");\n+\t}\n+      if (suppressed)\n+\t{\n+\t  if (index (fci->flag_chars, '*') == 0)\n+\t    {\n+\t      sprintf (message,\n+\t\t       \"suppression of `%c' conversion in format\",\n+\t\t       format_char);\n+\t      warning (message);\n+\t    }\n+\t  continue;\n+\t}\n+      for (i = 0; flag_chars[i] != 0; ++i)\n+\t{\n+\t  if (index (fci->flag_chars, flag_chars[i]) == 0)\n+\t    {\n+\t      sprintf (message, \"flag `%c' used with type `%c'\",\n+\t\t       flag_chars[i], format_char);\n+\t      warning (message);\n+\t    }\n+\t}\n+      if (precise && index (flag_chars, '0') != 0\n+\t  && (format_char == 'd' || format_char == 'i'\n+\t      || format_char == 'o' || format_char == 'u'\n+\t      || format_char == 'x' || format_char == 'x'))\n+\t{\n+\t  sprintf (message,\n+\t\t   \"precision and `0' flag not both allowed with `%c' format\",\n+\t\t   format_char);\n+\t  warning (message);\n+\t}\n+      switch (length_char)\n+\t{\n+\tdefault: wanted_type = fci->nolen ? *(fci->nolen) : 0; break;\n+\tcase 'h': wanted_type = fci->hlen ? *(fci->hlen) : 0; break;\n+\tcase 'l': wanted_type = fci->llen ? *(fci->llen) : 0; break;\n+\tcase 'L': wanted_type = fci->bigllen ? *(fci->bigllen) : 0; break;\n+\t}\n+      if (wanted_type == 0)\n+\t{\n+\t  sprintf (message,\n+\t\t   \"use of `%c' length character with `%c' type character\",\n+\t\t   length_char, format_char);\n+\t  warning (message);\n+\t}\n+\n+      /*\n+       ** XXX -- should kvetch about stuff such as\n+       **\t{\n+       **\t\tconst int\ti;\n+       **\n+       **\t\tscanf (\"%d\", &i);\n+       **\t}\n+       */\n+\n+      /* Finally. . .check type of argument against desired type!  */\n+      if (info->first_arg_num == 0)\n+\tcontinue;\n+      if (params == 0)\n+\t{\n+\t  warning (tfaff);\n+\t  return;\n+\t}\n+      cur_param = TREE_VALUE (params);\n+      params = TREE_CHAIN (params);\n+      ++arg_num;\n+      cur_type = TREE_TYPE (cur_param);\n+\n+      /* Check the types of any additional pointer arguments\n+\t that precede the \"real\" argument.  */\n+      for (i = 0; i < fci->pointer_count; ++i)\n+\t{\n+\t  if (TREE_CODE (cur_type) == POINTER_TYPE)\n+\t    {\n+\t      cur_type = TREE_TYPE (cur_type);\n+\t      continue;\n+\t    }\n+\t  sprintf (message,\n+\t\t   \"format argument is not a %s (arg %d)\",\n+\t\t   ((fci->pointer_count == 1) ? \"pointer\" : \"pointer to a pointer\"),\n+\t\t   arg_num);\n+\t  warning (message);\n+\t  break;\n+\t}\n+\n+      /* Check the type of the \"real\" argument, if there's a type we want.  */\n+      if (i == fci->pointer_count && wanted_type != 0\n+\t  && wanted_type != TYPE_MAIN_VARIANT (cur_type)\n+\t  /* If we want `void *', allow any pointer type.\n+\t     (Anything else would already have got a warning.)  */\n+\t  && ! (wanted_type == void_type_node\n+\t\t&& fci->pointer_count > 0)\n+\t  /* Don't warn about differences merely in signedness.  */\n+\t  && !(TREE_CODE (wanted_type) == INTEGER_TYPE\n+\t       && TREE_CODE (cur_type) == INTEGER_TYPE\n+\t       && (wanted_type == (TREE_UNSIGNED (wanted_type)\n+\t\t\t\t   ? unsigned_type : signed_type) (cur_type))))\n+\t{\n+\t  register char *this;\n+\t  register char *that;\n+  \n+\t  this = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n+\t  that = 0;\n+\t  if (TREE_CODE (cur_type) != ERROR_MARK\n+\t      && TYPE_NAME (cur_type) != 0\n+\t      && TREE_CODE (cur_type) != INTEGER_TYPE\n+\t      && !(TREE_CODE (cur_type) == POINTER_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (cur_type)) == INTEGER_TYPE))\n+\t    {\n+\t      if (TREE_CODE (TYPE_NAME (cur_type)) == TYPE_DECL\n+\t\t  && DECL_NAME (TYPE_NAME (cur_type)) != 0)\n+\t\tthat = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n+\t      else\n+\t\tthat = IDENTIFIER_POINTER (TYPE_NAME (cur_type));\n+\t    }\n+\n+\t  /* A nameless type can't possibly match what the format wants.\n+\t     So there will be a warning for it.\n+\t     Make up a string to describe vaguely what it is.  */\n+\t  if (that == 0)\n+\t    {\n+\t      if (TREE_CODE (cur_type) == POINTER_TYPE)\n+\t\tthat = \"pointer\";\n+\t      else\n+\t\tthat = \"different type\";\n+\t    }\n+\n+\t  if (strcmp (this, that) != 0)\n+\t    {\n+\t      sprintf (message, \"%s format, %s arg (arg %d)\",\n+\t\t\tthis, that, arg_num);\n+\t      warning (message);\n+\t    }\n+\t}\n+    }\n+}\n+\f\n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language\n    requires to be a constant expression."}]}