{"sha": "0b360a07d3a45a1217ba68345601efcb6c118089", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzNjBhMDdkM2E0NWExMjE3YmE2ODM0NTYwMWVmY2I2YzExODA4OQ==", "commit": {"author": {"name": "Momchil Velikov", "email": "momchil.velikov@gmail.com", "date": "2014-05-09T20:07:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-05-09T20:07:45Z"}, "message": "re PR c++/60463 (Lambda function can call a non-const member function with const this)\n\n\tPR c++/60463\n\tPR c++/60755\n\t* lambda.c (lambda_expr_this_capture): Add new parameter\n\tadd_capture_p controlling whether the functions will try to\n\tcapture 'this' via the default capture.\n\t(maybe_resolve_dummy): Likewise.\n\t* cp-tree.h: Adjust prototypes.\n\t* call.c, semantics.c: Change callers of these functions.\n\t* call.c (build_new_method_call_1): Use the actual 'this' that\n\twould be potentially captured for the overload resolution, instead\n\tof the dummy object.\n\nFrom-SVN: r210292", "tree": {"sha": "41b9d15713d8f0e4386d503ec289e72ab4ec967b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41b9d15713d8f0e4386d503ec289e72ab4ec967b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b360a07d3a45a1217ba68345601efcb6c118089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b360a07d3a45a1217ba68345601efcb6c118089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b360a07d3a45a1217ba68345601efcb6c118089", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b360a07d3a45a1217ba68345601efcb6c118089/comments", "author": {"login": "momchil-velikov", "id": 5541560, "node_id": "MDQ6VXNlcjU1NDE1NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5541560?v=4", "gravatar_id": "", "url": "https://api.github.com/users/momchil-velikov", "html_url": "https://github.com/momchil-velikov", "followers_url": "https://api.github.com/users/momchil-velikov/followers", "following_url": "https://api.github.com/users/momchil-velikov/following{/other_user}", "gists_url": "https://api.github.com/users/momchil-velikov/gists{/gist_id}", "starred_url": "https://api.github.com/users/momchil-velikov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/momchil-velikov/subscriptions", "organizations_url": "https://api.github.com/users/momchil-velikov/orgs", "repos_url": "https://api.github.com/users/momchil-velikov/repos", "events_url": "https://api.github.com/users/momchil-velikov/events{/privacy}", "received_events_url": "https://api.github.com/users/momchil-velikov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91b67b5022b44a7eec12364a9e8d26507a6a87d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b67b5022b44a7eec12364a9e8d26507a6a87d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b67b5022b44a7eec12364a9e8d26507a6a87d6"}], "stats": {"total": 64, "additions": 49, "deletions": 15}, "files": [{"sha": "5ddf555923da1ee278ffac661bdeb6d42ab151b4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0b360a07d3a45a1217ba68345601efcb6c118089", "patch": "@@ -1,3 +1,17 @@\n+2014-05-09  Momchil Velikov  <momchil.velikov@gmail.com>\n+\n+\tPR c++/60463\n+\tPR c++/60755\n+\t* lambda.c (lambda_expr_this_capture): Add new parameter\n+\tadd_capture_p controlling whether the functions will try to\n+\tcapture 'this' via the default capture.\n+\t(maybe_resolve_dummy): Likewise.\n+\t* cp-tree.h: Adjust prototypes.\n+\t* call.c, semantics.c: Change callers of these functions.\n+\t* call.c (build_new_method_call_1): Use the actual 'this' that\n+\twould be potentially captured for the overload resolution, instead\n+\tof the dummy object.\n+\n 2014-05-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* pt.c (convert_nontype_argument_function): Add tsubst_flags_t"}, {"sha": "254b43a24279699afe510cece0e50a7228eea104", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0b360a07d3a45a1217ba68345601efcb6c118089", "patch": "@@ -7760,7 +7760,11 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n   if (DECL_DESTRUCTOR_P (fn))\n     name = complete_dtor_identifier;\n \n-  first_mem_arg = instance;\n+  /* For the overload resolution we need to find the actual `this`\n+     that would be captured if the call turns out to be to a\n+     non-static member function.  Do not actually capture it at this\n+     point.  */\n+  first_mem_arg = maybe_resolve_dummy (instance, false);\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n@@ -7898,7 +7902,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t      && !DECL_CONSTRUCTOR_P (fn)\n \t      && is_dummy_object (instance))\n \t    {\n-\t      instance = maybe_resolve_dummy (instance);\n+\t      instance = maybe_resolve_dummy (instance, true);\n \t      if (instance == error_mark_node)\n \t\tcall = error_mark_node;\n \t      else if (!is_dummy_object (instance))"}, {"sha": "ed8d099bda88b21c4f8416be37e3c5deab5d86c6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0b360a07d3a45a1217ba68345601efcb6c118089", "patch": "@@ -5890,8 +5890,8 @@ extern void insert_pending_capture_proxies\t(void);\n extern bool is_capture_proxy\t\t\t(tree);\n extern bool is_normal_capture_proxy             (tree);\n extern void register_capture_members\t\t(tree);\n-extern tree lambda_expr_this_capture            (tree);\n-extern tree maybe_resolve_dummy\t\t\t(tree);\n+extern tree lambda_expr_this_capture            (tree, bool);\n+extern tree maybe_resolve_dummy\t\t\t(tree, bool);\n extern tree nonlambda_method_basetype\t\t(void);\n extern void maybe_add_lambda_conv_op            (tree);\n extern bool is_lambda_ignored_entity            (tree);"}, {"sha": "3ce9ebb7f1f463ef5dd561888559cf731d05210f", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=0b360a07d3a45a1217ba68345601efcb6c118089", "patch": "@@ -624,11 +624,12 @@ add_default_capture (tree lambda_stack, tree id, tree initializer)\n   return var;\n }\n \n-/* Return the capture pertaining to a use of 'this' in LAMBDA, in the form of an\n-   INDIRECT_REF, possibly adding it through default capturing.  */\n+/* Return the capture pertaining to a use of 'this' in LAMBDA, in the\n+   form of an INDIRECT_REF, possibly adding it through default\n+   capturing, if ADD_CAPTURE_P is false.  */\n \n tree\n-lambda_expr_this_capture (tree lambda)\n+lambda_expr_this_capture (tree lambda, bool add_capture_p)\n {\n   tree result;\n \n@@ -648,7 +649,8 @@ lambda_expr_this_capture (tree lambda)\n \n   /* Try to default capture 'this' if we can.  */\n   if (!this_capture\n-      && LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) != CPLD_NONE)\n+      && (!add_capture_p\n+          || LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda) != CPLD_NONE))\n     {\n       tree lambda_stack = NULL_TREE;\n       tree init = NULL_TREE;\n@@ -708,9 +710,14 @@ lambda_expr_this_capture (tree lambda)\n \t}\n \n       if (init)\n-\tthis_capture = add_default_capture (lambda_stack,\n-\t\t\t\t\t    /*id=*/this_identifier,\n-\t\t\t\t\t    init);\n+        {\n+          if (add_capture_p)\n+\t    this_capture = add_default_capture (lambda_stack,\n+\t\t\t\t\t        /*id=*/this_identifier,\n+\t\t\t\t\t        init);\n+          else\n+\t    this_capture = init;\n+        }\n     }\n \n   if (!this_capture)\n@@ -742,7 +749,7 @@ lambda_expr_this_capture (tree lambda)\n    'this' capture.  */\n \n tree\n-maybe_resolve_dummy (tree object)\n+maybe_resolve_dummy (tree object, bool add_capture_p)\n {\n   if (!is_dummy_object (object))\n     return object;\n@@ -758,7 +765,7 @@ maybe_resolve_dummy (tree object)\n     {\n       /* In a lambda, need to go through 'this' capture.  */\n       tree lam = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n-      tree cap = lambda_expr_this_capture (lam);\n+      tree cap = lambda_expr_this_capture (lam, add_capture_p);\n       object = build_x_indirect_ref (EXPR_LOCATION (object), cap,\n \t\t\t\t     RO_NULL, tf_warning_or_error);\n     }"}, {"sha": "d925f5ced40e034b95142918d2678e6c0658aaad", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0b360a07d3a45a1217ba68345601efcb6c118089", "patch": "@@ -1675,7 +1675,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n       object = maybe_dummy_object (scope, NULL);\n     }\n \n-  object = maybe_resolve_dummy (object);\n+  object = maybe_resolve_dummy (object, true);\n   if (object == error_mark_node)\n     return error_mark_node;\n \n@@ -2434,7 +2434,7 @@ finish_this_expr (void)\n \n       /* In a lambda expression, 'this' refers to the captured 'this'.  */\n       if (LAMBDA_TYPE_P (type))\n-        result = lambda_expr_this_capture (CLASSTYPE_LAMBDA_EXPR (type));\n+        result = lambda_expr_this_capture (CLASSTYPE_LAMBDA_EXPR (type), true);\n       else\n         result = current_class_ptr;\n     }"}, {"sha": "2de00d314bef1af58c0ce7c0991ade2fead332ea", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const-this.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-this.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b360a07d3a45a1217ba68345601efcb6c118089/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-this.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-this.C?ref=0b360a07d3a45a1217ba68345601efcb6c118089", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/60463\n+// PR c++/60755\n+// { dg-do compile { target c++11 } }\n+struct S {\n+  void f(); // { dg-message \"no known conversion for implicit 'this' parameter from 'const S\\\\*' to 'S\\\\*'\" }\n+  void g() const {\n+    [=] { f(); } (); // { dg-error \"no matching function for call to 'S::f\\\\(\\\\)'\" }\n+  }\n+};"}]}