{"sha": "c45b6ae00734eed1f2b94db390e326a31169b422", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ1YjZhZTAwNzM0ZWVkMWYyYjk0ZGIzOTBlMzI2YTMxMTY5YjQyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-12-08T10:33:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-12-08T10:33:17Z"}, "message": "[multiple changes]\n\n2003-12-08  Jerome Guitton  <guitton@act-europe.fr>\n\n\t* 5ytiitho.adb, 5zthrini.adb, 5ztiitho.adb, i-vthrea.adb,\n\ti-vthrea.ads, s-tpae65.adb, s-tpae65.ads: Cleanup: Remove a bunch of\n\tobsolete files.\n\n\t* Makefile.in: (rts-ravenscar): Generate an empty libgnat.a.\n\t(rts-zfp): Ditto.\n\n2003-12-08  Robert Dewar  <dewar@gnat.com>\n\n\t* 7sintman.adb: Minor reformatting\n\n\t* bindgen.adb: Configurable_Run_Time mode no longer suppresses the\n\tstandard linker options to get standard libraries linked. We now plan\n\tto provide dummy versions of these libraries to match the appropriate\n\tconfigurable run-time (e.g. if a library is not needed at all, provide\n\ta dummy empty library).\n\n\t* targparm.ads: Configurable_Run_Time mode no longer affects linker\n\toptions (-L parameters and standard libraries). What we plan to do is\n\tto provide dummy libraries where the libraries are not required.\n\n\t* gnatbind.adb: Minor comment improvement\n\n2003-12-08  Javier Miranda  <miranda@gnat.com>\n\n\t* exp_aggr.adb (Build_Record_Aggr_Code): Do not remove the expanded\n\taggregate in the parent. Otherwise constants with limited aggregates\n\tare not supported. Add new formal to pass the component type (Ctype).\n\tIt is required to call the corresponding IP subprogram in case of\n\tdefault initialized components.\n\t(Gen_Assign): In case of default-initialized component, generate a\n\tcall to the IP subprogram associated with the component.\n\t(Build_Record_Aggr_Code): Remove the aggregate from the parent in case\n\tof aggregate with default initialized components.\n\t(Has_Default_Init_Comps): Improve implementation to recursively check\n\tall the present expressions.\n\n\t* exp_ch3.ads, exp_ch3.adb (Build_Initialization_Call): Add new formal\n\tto indicate that the initialization call corresponds to a\n\tdefault-initialized component of an aggregate.\n\tIn case of default initialized aggregate with tasks this parameter is\n\tused to generate a null string (this is just a workaround that must be\n\timproved later). In case of discriminants, this parameter is used to\n\tgenerate a selected component node that gives access to the discriminant\n\tvalue.\n\n\t* exp_ch9.ads, exp_ch9.adb (Build_Task_Allocate_Block_With_Stmts): New\n\tsubprogram, based on Build_Task_Allocate_Block, but adapted to expand\n\tallocated aggregates with default-initialized components.\n\n\t* par-ch4.adb (P_Aggregate_Or_Paren_Expr): Improve error message if\n\tthe box notation is used in positional aggregates.\n\n2003-12-08  Samuel Tardieu  <tardieu@act-europe.fr>\n\n\t* lib.ads: Fix typo in comment\n\n2003-12-08  Vincent Celier  <celier@gnat.com>\n\n\t* prj.adb (Project_Empty): New component Unkept_Comments\n\t(Scan): Remove procedure; moved to Prj.Err.\n\n\t* prj.ads (Project_Data): New Boolean component Unkept_Comments\n\t(Scan): Remove procedure; moved to Prj.Err.\n\n\t* prj-dect.adb: Manage comments for the different declarations.\n\n\t* prj-part.adb (With_Record): New component Node\n\t(Parse): New Boolean parameter Store_Comments, defaulted to False.\n\tSet the scanner to return ends of line and comments as tokens, if\n\tStore_Comments is True.\n\t(Pre_Parse_Context_Clause): Create the N_With_Clause nodes so that\n\tcomments are associated with these nodes. Store the node IDs in the\n\tWith_Records.\n\t(Post_Parse_Context_Clause): Use the N_With_Clause nodes stored in the\n\tWith_Records.\n\t(Parse_Single_Project): Call Pre_Parse_Context_Clause before creating\n\tthe N_Project node. Call Tree.Save and Tree.Reset before scanning the\n\tcurrent project. Call Tree.Restore afterwards. Set the various nodes\n\tfor comment storage (Next_End, End_Of_Line, Previous_Line,\n\tPrevious_End).\n\n\t* prj-part.ads (Parse): New Boolean parameter Store_Comments,\n\tdefaulted to False.\n\n\t* prj-pp.adb (Write_String): New Boolean parameter Truncated, defaulted\n\tto False. When Truncated is True, truncate the string, never go to the\n\tnext line.\n\t(Write_End_Of_Line_Comment): New procedure\n\t(Print): Process comments for nodes N_With_Clause,\n\tN_Package_Declaration, N_String_Type_Declaration,\n\tN_Attribute_Declaration, N_Typed_Variable_Declaration,\n\tN_Variable_Declaration, N_Case_Construction, N_Case_Item.\n\tProcess nodes N_Comment.\n\n\t* prj-tree.ads, prj-tree.adb (Default_Project_Node): If it is a node\n\twithout comments and there are some comments, set the flag\n\tUnkept_Comments to True.\n\t(Scan): If there are comments, set the flag Unkept_Comments to True and\n\tclear the comments.\n\t(Project_Node_Kind): Add enum values N_Comment_Zones, N_Comment\n\t(Next_End_Nodes: New table\n\t(Comment_Zones_Of): New function\n\t(Scan): New procedure; moved from Prj. Accumulate comments in the\n\tComments table and set end of line comments, comments after, after end\n\tand before end.\n\t(Add_Comments): New procedure\n\t(Save, Restore, Seset_State): New procedures\n\t(There_Are_Unkept_Comments): New function\n\t(Set_Previous_Line_Node, Set_Previous_End_Node): New procedures\n\t(Set_End_Of_Line, Set_Next_End_Node, Remove_Next_End_Node): New\n\tprocedures.\n\t(First_Comment_After, First_Comment_After_End): New functions\n\t(First_Comment_Before, First_Comment_Before_End): New functions\n\t(Next_Comment): New function\n\t(End_Of_Line_Comment, Follows_Empty_Line,\n\tIs_Followed_By_Empty_Line): New functions\n\t(Set_First_Comment_After, Set_First_Comment_After_End): New procedures\n\t(Set_First_Comment_Before, Set_First_Comment_Before_End): New procedures\n\t(Set_Next_Comment): New procedure\n\t(Default_Project_Node): Associate comment before if the node can store\n\tcomments.\n\n\t* scans.ads (Token_Type): New enumeration value Tok_Comment\n\t(Comment_Id): New global variable\n\n\t* scng.ads, scng.adb (Comment_Is_Token): New Boolean global variable,\n\tdefaulted to False.\n\t(Scan): Store position of start of comment. If comments are tokens, set\n\tComment_Id and set Token to Tok_Comment when scanning a comment.\n\t(Set_Comment_As_Token): New procedure\n\n\t* sinput-p.adb: Update Copyright notice\n\t(Source_File_Is_Subunit): Call Prj.Err.Scanner.Scan instead of Prj.Scan\n\tthat no longer exists.\n\n2003-12-08  Javier Miranda  <miranda@gnat.com>\n\n\t* sem_aggr.adb: Add dependence on Exp_Tss package\n\tCorrect typo in comment\n\t(Resolve_Aggregate): In case of array aggregates set the estimated\n\ttype of the aggregate before calling resolve. This is needed to know\n\tthe name of the corresponding IP in case of limited array aggregates.\n\t(Resolve_Array_Aggregate): Delay the resolution to the expansion phase\n\tin case of default initialized array components.\n\n\t* sem_ch12.adb (Analyze_Formal_Object_Declaration): Allow limited\n\ttypes. Required to give support to limited aggregates in generic\n\tformals.\n\n2003-12-08  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch3.adb (Check_Initialization): For legality purposes, an\n\tinlined body functions like an instantiation.\n\t(Decimal_Fixed_Point_Declaration): Do not set kind of first subtype\n\tuntil bounds are analyzed, to diagnose premature use of type.\n\n\t* sem_util.adb (Wrong_Type): Improve error message when the type of\n\tthe expression is used prematurely.\n\n2003-12-08  GNAT Script  <nobody@gnat.com>\n\n\t* Make-lang.in: Makefile automatically updated\n\nFrom-SVN: r74414", "tree": {"sha": "c83150f858a1ea22febff15880c94d93b7c3314f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c83150f858a1ea22febff15880c94d93b7c3314f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c45b6ae00734eed1f2b94db390e326a31169b422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45b6ae00734eed1f2b94db390e326a31169b422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c45b6ae00734eed1f2b94db390e326a31169b422", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45b6ae00734eed1f2b94db390e326a31169b422/comments", "author": null, "committer": null, "parents": [{"sha": "8738323373326f9d92d2df3eee27989bcee2044b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8738323373326f9d92d2df3eee27989bcee2044b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8738323373326f9d92d2df3eee27989bcee2044b"}], "stats": {"total": 3571, "additions": 2135, "deletions": 1436}, "files": [{"sha": "ad2924d559d8e1de854bfbb0106ecf539ff5bffa", "filename": "gcc/ada/5ytiitho.adb", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2F5ytiitho.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2F5ytiitho.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ytiitho.adb?ref=8738323373326f9d92d2df3eee27989bcee2044b", "patch": "@@ -1,56 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---       S Y S T E M . T H R E A D S . I N I T I A L I Z A T I O N .        --\n---                I N I T I A L I Z E _ T A S K _ H O O K S                 --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VxWorks AE 653 version of this procedure\n-\n-separate (System.Threads.Initialization)\n-procedure Initialize_Task_Hooks is\n-\n-   --  When defining the following routine for export in an AE 1.1\n-   --  simulation of AE653, Interfaces.C.int may be used for the\n-   --  parameters of FUNCPTR.\n-   type FUNCPTR is access function (T : OSI.Thread_Id) return OSI.STATUS;\n-\n-   --------------------------------\n-   -- Imported vThreads Routines --\n-   --------------------------------\n-\n-   procedure procCreateHookAdd (createHookFunction : FUNCPTR);\n-   pragma Import (C, procCreateHookAdd, \"procCreateHookAdd\");\n-   --  Registers task registration routine for AE653\n-\n-begin\n-   --  Register the exported routine with the vThreads ARINC API\n-   procCreateHookAdd (Register'Access);\n-end Initialize_Task_Hooks;"}, {"sha": "e0bffe09d6c67a55affc317690fb16122094fcdd", "filename": "gcc/ada/5zthrini.adb", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2F5zthrini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2F5zthrini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zthrini.adb?ref=8738323373326f9d92d2df3eee27989bcee2044b", "patch": "@@ -1,129 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---        S Y S T E M . T H R E A D S . I N I T I A L I Z A T I O N         --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---            Copyright (C) 1992-2003 Free Software Foundation, Inc.        --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VxWorks version of this package; to use this implementation,\n---  the task hook libraries should be included in the VxWorks kernel.\n-\n-with System.Secondary_Stack;\n-with System.Storage_Elements;\n-with System.Soft_Links;\n-with Interfaces.C;\n-\n-package body System.Threads.Initialization is\n-\n-   use Interfaces.C;\n-\n-   package SSS renames System.Secondary_Stack;\n-\n-   package SSL renames System.Soft_Links;\n-\n-   procedure Initialize_Task_Hooks;\n-   --  Register the appropriate hooks (Register and Reset_TSD) to the\n-   --  underlying OS, so that they will be called when a task is created\n-   --  or reset.\n-\n-   Current_ATSD : aliased System.Address;\n-   pragma Import (C, Current_ATSD, \"__gnat_current_atsd\");\n-\n-   ---------------------------\n-   -- Initialize_Task_Hooks --\n-   ---------------------------\n-\n-   procedure Initialize_Task_Hooks is separate;\n-   --  Separate, as these hooks are different for AE653 and VxWorks 5.5.\n-\n-   --------------\n-   -- Init_RTS --\n-   --------------\n-\n-   procedure Init_RTS is\n-   begin\n-      SSL.Get_Jmpbuf_Address := Get_Jmpbuf_Address'Access;\n-      SSL.Get_Sec_Stack_Addr := Get_Sec_Stack_Addr'Access;\n-      SSL.Get_Current_Excep  := Get_Current_Excep'Access;\n-      SSL.Set_Jmpbuf_Address := Set_Jmpbuf_Address'Access;\n-      SSL.Set_Sec_Stack_Addr := Set_Sec_Stack_Addr'Access;\n-   end Init_RTS;\n-\n-   --------------\n-   -- Register --\n-   --------------\n-\n-   function Register (T : OSI.Thread_Id) return OSI.STATUS is\n-      Result : OSI.STATUS;\n-   begin\n-      --  It cannot be assumed that the caller of this routine has a ATSD;\n-      --  so neither this procedure nor the procedures that it calls should\n-      --  raise or handle exceptions, or make use of a secondary stack.\n-\n-      --  This routine is only necessary because taskVarAdd cannot be\n-      --  executed once an AE653 partition has entered normal mode\n-      --  (depending on configRecord.c, allocation could be disabled).\n-      --  Otherwise, everything could have been done in Thread_Body_Enter.\n-\n-      if OSI.taskIdVerify (T) = OSI.ERROR then\n-         return OSI.ERROR;\n-      end if;\n-\n-      Result := OSI.taskVarAdd (T, Current_ATSD'Access);\n-      pragma Assert (Result /= OSI.ERROR);\n-\n-      return Result;\n-   end Register;\n-\n-   subtype Default_Sec_Stack is\n-     System.Storage_Elements.Storage_Array\n-       (1 .. SSS.Default_Secondary_Stack_Size);\n-\n-   Main_Sec_Stack : aliased Default_Sec_Stack;\n-\n-   --  Secondary stack for environment task\n-\n-   Main_ATSD : aliased ATSD;\n-\n-   --  TSD for environment task\n-\n-begin\n-   Initialize_Task_Hooks;\n-\n-   --  Register the environment task\n-   declare\n-      Result : Interfaces.C.int := Register (OSI.taskIdSelf);\n-      pragma Assert (Result /= OSI.ERROR);\n-   begin\n-      Thread_Body_Enter\n-        (Main_Sec_Stack'Address,\n-         Main_Sec_Stack'Size / System.Storage_Unit,\n-         Main_ATSD'Address);\n-   end;\n-end System.Threads.Initialization;"}, {"sha": "bda356e16a48c77e5caf90e7445305491d648ec0", "filename": "gcc/ada/5ztiitho.adb", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2F5ztiitho.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2F5ztiitho.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ztiitho.adb?ref=8738323373326f9d92d2df3eee27989bcee2044b", "patch": "@@ -1,48 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---       S Y S T E M . T H R E A D S . I N I T I A L I Z A T I O N .        --\n---                I N I T I A L I Z E _ T A S K _ H O O K S                 --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VxWorks 5.5 version of this procedure\n-\n-separate (System.Threads.Initialization)\n-\n-procedure Initialize_Task_Hooks is\n-\n-   type FUNCPTR is access function (T : OSI.Thread_Id) return OSI.STATUS;\n-\n-   procedure taskCreateHookAdd (createHookFunction : FUNCPTR);\n-   pragma Import (C, taskCreateHookAdd, \"taskCreateHookAdd\");\n-\n-begin\n-   taskCreateHookAdd (Register'Access);\n-end Initialize_Task_Hooks;"}, {"sha": "801adac39f2fbfb26224fd373b28c21100372fb0", "filename": "gcc/ada/7sintman.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2F7sintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2F7sintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7sintman.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -152,7 +152,7 @@ begin\n \n       function State (Int : Interrupt_ID) return Character;\n       pragma Import (C, State, \"__gnat_get_interrupt_state\");\n-      --  Get interrupt state.  Defined in a-init.c\n+      --  Get interrupt state. Defined in a-init.c\n       --  The input argument is the interrupt number,\n       --  and the result is one of the following:\n \n@@ -178,9 +178,9 @@ begin\n       act.sa_flags := SA_SIGINFO;\n \n       --  Setting SA_SIGINFO asks the kernel to pass more than just the signal\n-      --  number argument to the handler when it is called.  The set of extra\n+      --  number argument to the handler when it is called. The set of extra\n       --  parameters typically includes a pointer to a structure describing\n-      --  the interrupted context.  Although the Notify_Exception handler does\n+      --  the interrupted context. Although the Notify_Exception handler does\n       --  not use this information, it is actually required for the GCC/ZCX\n       --  exception propagation scheme because on some targets (at least\n       --  alpha-tru64), the structure contents are not even filled when this"}, {"sha": "6d3c2b33436f7e1f0226f836d091aa6c3ce196a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -1,3 +1,169 @@\n+2003-12-08  Jerome Guitton  <guitton@act-europe.fr>\n+\n+\t* 5ytiitho.adb, 5zthrini.adb, 5ztiitho.adb, i-vthrea.adb,\n+\ti-vthrea.ads, s-tpae65.adb, s-tpae65.ads: Cleanup: Remove a bunch of\n+\tobsolete files.\n+\n+\t* Makefile.in: (rts-ravenscar): Generate an empty libgnat.a.\n+\t(rts-zfp): Ditto.\n+\n+2003-12-08  Robert Dewar  <dewar@gnat.com>\n+\n+\t* 7sintman.adb: Minor reformatting\n+\n+\t* bindgen.adb: Configurable_Run_Time mode no longer suppresses the\n+\tstandard linker options to get standard libraries linked. We now plan\n+\tto provide dummy versions of these libraries to match the appropriate\n+\tconfigurable run-time (e.g. if a library is not needed at all, provide\n+\ta dummy empty library).\n+\n+\t* targparm.ads: Configurable_Run_Time mode no longer affects linker\n+\toptions (-L parameters and standard libraries). What we plan to do is\n+\tto provide dummy libraries where the libraries are not required.\n+\n+\t* gnatbind.adb: Minor comment improvement\n+\n+2003-12-08  Javier Miranda  <miranda@gnat.com>\n+\n+\t* exp_aggr.adb (Build_Record_Aggr_Code): Do not remove the expanded\n+\taggregate in the parent. Otherwise constants with limited aggregates\n+\tare not supported. Add new formal to pass the component type (Ctype).\n+\tIt is required to call the corresponding IP subprogram in case of\n+\tdefault initialized components.\n+\t(Gen_Assign): In case of default-initialized component, generate a\n+\tcall to the IP subprogram associated with the component.\n+\t(Build_Record_Aggr_Code): Remove the aggregate from the parent in case\n+\tof aggregate with default initialized components.\n+\t(Has_Default_Init_Comps): Improve implementation to recursively check\n+\tall the present expressions.\n+\n+\t* exp_ch3.ads, exp_ch3.adb (Build_Initialization_Call): Add new formal\n+\tto indicate that the initialization call corresponds to a\n+\tdefault-initialized component of an aggregate.\n+\tIn case of default initialized aggregate with tasks this parameter is\n+\tused to generate a null string (this is just a workaround that must be\n+\timproved later). In case of discriminants, this parameter is used to\n+\tgenerate a selected component node that gives access to the discriminant\n+\tvalue.\n+\n+\t* exp_ch9.ads, exp_ch9.adb (Build_Task_Allocate_Block_With_Stmts): New\n+\tsubprogram, based on Build_Task_Allocate_Block, but adapted to expand\n+\tallocated aggregates with default-initialized components.\n+\n+\t* par-ch4.adb (P_Aggregate_Or_Paren_Expr): Improve error message if\n+\tthe box notation is used in positional aggregates.\n+\n+2003-12-08  Samuel Tardieu  <tardieu@act-europe.fr>\n+\n+\t* lib.ads: Fix typo in comment\n+\n+2003-12-08  Vincent Celier  <celier@gnat.com>\n+\n+\t* prj.adb (Project_Empty): New component Unkept_Comments\n+\t(Scan): Remove procedure; moved to Prj.Err.\n+\n+\t* prj.ads (Project_Data): New Boolean component Unkept_Comments\n+\t(Scan): Remove procedure; moved to Prj.Err.\n+\n+\t* prj-dect.adb: Manage comments for the different declarations.\n+\n+\t* prj-part.adb (With_Record): New component Node\n+\t(Parse): New Boolean parameter Store_Comments, defaulted to False.\n+\tSet the scanner to return ends of line and comments as tokens, if\n+\tStore_Comments is True.\n+\t(Pre_Parse_Context_Clause): Create the N_With_Clause nodes so that\n+\tcomments are associated with these nodes. Store the node IDs in the\n+\tWith_Records.\n+\t(Post_Parse_Context_Clause): Use the N_With_Clause nodes stored in the\n+\tWith_Records.\n+\t(Parse_Single_Project): Call Pre_Parse_Context_Clause before creating\n+\tthe N_Project node. Call Tree.Save and Tree.Reset before scanning the\n+\tcurrent project. Call Tree.Restore afterwards. Set the various nodes\n+\tfor comment storage (Next_End, End_Of_Line, Previous_Line,\n+\tPrevious_End).\n+\n+\t* prj-part.ads (Parse): New Boolean parameter Store_Comments,\n+\tdefaulted to False.\n+\n+\t* prj-pp.adb (Write_String): New Boolean parameter Truncated, defaulted\n+\tto False. When Truncated is True, truncate the string, never go to the\n+\tnext line.\n+\t(Write_End_Of_Line_Comment): New procedure\n+\t(Print): Process comments for nodes N_With_Clause,\n+\tN_Package_Declaration, N_String_Type_Declaration,\n+\tN_Attribute_Declaration, N_Typed_Variable_Declaration,\n+\tN_Variable_Declaration, N_Case_Construction, N_Case_Item.\n+\tProcess nodes N_Comment.\n+\n+\t* prj-tree.ads, prj-tree.adb (Default_Project_Node): If it is a node\n+\twithout comments and there are some comments, set the flag\n+\tUnkept_Comments to True.\n+\t(Scan): If there are comments, set the flag Unkept_Comments to True and\n+\tclear the comments.\n+\t(Project_Node_Kind): Add enum values N_Comment_Zones, N_Comment\n+\t(Next_End_Nodes: New table\n+\t(Comment_Zones_Of): New function\n+\t(Scan): New procedure; moved from Prj. Accumulate comments in the\n+\tComments table and set end of line comments, comments after, after end\n+\tand before end.\n+\t(Add_Comments): New procedure\n+\t(Save, Restore, Seset_State): New procedures\n+\t(There_Are_Unkept_Comments): New function\n+\t(Set_Previous_Line_Node, Set_Previous_End_Node): New procedures\n+\t(Set_End_Of_Line, Set_Next_End_Node, Remove_Next_End_Node): New\n+\tprocedures.\n+\t(First_Comment_After, First_Comment_After_End): New functions\n+\t(First_Comment_Before, First_Comment_Before_End): New functions\n+\t(Next_Comment): New function\n+\t(End_Of_Line_Comment, Follows_Empty_Line,\n+\tIs_Followed_By_Empty_Line): New functions\n+\t(Set_First_Comment_After, Set_First_Comment_After_End): New procedures\n+\t(Set_First_Comment_Before, Set_First_Comment_Before_End): New procedures\n+\t(Set_Next_Comment): New procedure\n+\t(Default_Project_Node): Associate comment before if the node can store\n+\tcomments.\n+\n+\t* scans.ads (Token_Type): New enumeration value Tok_Comment\n+\t(Comment_Id): New global variable\n+\n+\t* scng.ads, scng.adb (Comment_Is_Token): New Boolean global variable,\n+\tdefaulted to False.\n+\t(Scan): Store position of start of comment. If comments are tokens, set\n+\tComment_Id and set Token to Tok_Comment when scanning a comment.\n+\t(Set_Comment_As_Token): New procedure\n+\n+\t* sinput-p.adb: Update Copyright notice\n+\t(Source_File_Is_Subunit): Call Prj.Err.Scanner.Scan instead of Prj.Scan\n+\tthat no longer exists.\n+\n+2003-12-08  Javier Miranda  <miranda@gnat.com>\n+\n+\t* sem_aggr.adb: Add dependence on Exp_Tss package\n+\tCorrect typo in comment\n+\t(Resolve_Aggregate): In case of array aggregates set the estimated\n+\ttype of the aggregate before calling resolve. This is needed to know\n+\tthe name of the corresponding IP in case of limited array aggregates.\n+\t(Resolve_Array_Aggregate): Delay the resolution to the expansion phase\n+\tin case of default initialized array components.\n+\n+\t* sem_ch12.adb (Analyze_Formal_Object_Declaration): Allow limited\n+\ttypes. Required to give support to limited aggregates in generic\n+\tformals.\n+\n+2003-12-08  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch3.adb (Check_Initialization): For legality purposes, an\n+\tinlined body functions like an instantiation.\n+\t(Decimal_Fixed_Point_Declaration): Do not set kind of first subtype\n+\tuntil bounds are analyzed, to diagnose premature use of type.\n+\n+\t* sem_util.adb (Wrong_Type): Improve error message when the type of\n+\tthe expression is used prematurely.\n+\n+2003-12-08  GNAT Script  <nobody@gnat.com>\n+\n+\t* Make-lang.in: Makefile automatically updated\n+\n 2003-12-08  Arnaud Charlet  <charlet@act-europe.fr>\n \n \t* sinfo.h, einfo.h, nmake.ads, treeprs.ads: Removed, since they"}, {"sha": "e165cdb96efa41cdb22ca92d5026147c0d5dd0ad", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -915,8 +915,8 @@ ada.distclean:\n \t-$(RM) ada/tools/*\n \t-$(RMDIR) ada/tools\n ada.maintainer-clean:\n-\t-$(RM) ada/a-sinfo.h\n-\t-$(RM) ada/a-einfo.h\n+\t-$(RM) ada/sinfo.h\n+\t-$(RM) ada/einfo.h\n \t-$(RM) ada/nmake.adb\n \t-$(RM) ada/nmake.ads\n \t-$(RM) ada/treeprs.ads\n@@ -1213,6 +1213,11 @@ ada/a-charac.o : ada/ada.ads ada/a-charac.ads ada/system.ads\n ada/a-chlat1.o : ada/ada.ads ada/a-charac.ads ada/a-chlat1.ads \\\n    ada/system.ads \n \n+ada/a-elchha.o : ada/ada.ads ada/a-except.ads ada/a-elchha.ads \\\n+   ada/a-elchha.adb ada/system.ads ada/s-secsta.ads ada/s-soflin.ads \\\n+   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-traent.ads ada/unchconv.ads \n+\n ada/a-except.o : ada/ada.ads ada/a-except.ads ada/a-except.adb \\\n    ada/a-excach.adb ada/a-exexda.adb ada/a-exexpr.adb ada/a-exextr.adb \\\n    ada/a-excpol.adb ada/a-exstat.adb ada/a-unccon.ads ada/a-uncdea.ads \\\n@@ -1525,26 +1530,26 @@ ada/exp_aggr.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\\n    ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads ada/elists.adb \\\n    ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/eval_fat.ads \\\n    ada/exp_aggr.ads ada/exp_aggr.adb ada/exp_ch11.ads ada/exp_ch2.ads \\\n-   ada/exp_ch3.ads ada/exp_ch7.ads ada/exp_tss.ads ada/exp_util.ads \\\n-   ada/exp_util.adb ada/expander.ads ada/fname.ads ada/freeze.ads \\\n-   ada/get_targ.ads ada/gnat.ads ada/g-hesora.ads ada/g-htable.ads \\\n-   ada/g-os_lib.ads ada/g-string.ads ada/gnatvsn.ads ada/hostparm.ads \\\n-   ada/inline.ads ada/itypes.ads ada/lib.ads ada/lib.adb ada/lib-list.adb \\\n-   ada/lib-sort.adb ada/namet.ads ada/nlists.ads ada/nlists.adb \\\n-   ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n-   ada/rident.ads ada/rtsfind.ads ada/sem.ads ada/sem_cat.ads \\\n-   ada/sem_ch3.ads ada/sem_ch8.ads ada/sem_eval.ads ada/sem_eval.adb \\\n-   ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads \\\n-   ada/sprint.ads ada/stand.ads ada/stringt.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads ada/s-imgenu.ads \\\n-   ada/s-memory.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n-   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n-   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/validsw.ads \n+   ada/exp_ch3.ads ada/exp_ch7.ads ada/exp_ch9.ads ada/exp_tss.ads \\\n+   ada/exp_util.ads ada/exp_util.adb ada/expander.ads ada/fname.ads \\\n+   ada/freeze.ads ada/get_targ.ads ada/gnat.ads ada/g-hesora.ads \\\n+   ada/g-htable.ads ada/g-os_lib.ads ada/g-string.ads ada/gnatvsn.ads \\\n+   ada/hostparm.ads ada/inline.ads ada/itypes.ads ada/lib.ads ada/lib.adb \\\n+   ada/lib-list.adb ada/lib-sort.adb ada/namet.ads ada/nlists.ads \\\n+   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n+   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/sem.ads \\\n+   ada/sem_cat.ads ada/sem_ch3.ads ada/sem_ch8.ads ada/sem_eval.ads \\\n+   ada/sem_eval.adb ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads \\\n+   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n+   ada/snames.ads ada/sprint.ads ada/stand.ads ada/stringt.ads \\\n+   ada/system.ads ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads \\\n+   ada/s-imgenu.ads ada/s-memory.ads ada/s-rident.ads ada/s-secsta.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n+   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n+   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \n \n ada/exp_attr.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\\n    ada/atree.adb ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads \\\n@@ -1679,13 +1684,13 @@ ada/exp_ch3.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\\n    ada/sem_intr.ads ada/sem_mech.ads ada/sem_res.ads ada/sem_res.adb \\\n    ada/sem_type.ads ada/sem_util.ads ada/sem_warn.ads ada/sinfo.ads \\\n    ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/sprint.ads \\\n-   ada/stand.ads ada/stringt.ads ada/system.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-imgenu.ads ada/s-memory.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n-   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/stand.ads ada/stringt.ads ada/stringt.adb ada/system.ads \\\n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imgenu.ads ada/s-memory.ads \\\n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n+   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/validsw.ads \n \n ada/exp_ch4.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\"}, {"sha": "4d5b44330fa3b7fb61e36af9c25b091aef11d45d", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -1843,6 +1843,8 @@ rts-zfp: force\n \t-$(GNATMAKE) -Prts-zfp/zfp.gpr --GCC=\"../../../xgcc -B../../../\"\n \t$(RM) rts-zfp/adalib/*.o\n \t$(CHMOD) a-wx rts-zfp/adalib/*.ali\n+\t$(AR) r rts-zfp/adalib/libgnat.a\n+\t$(CHMOD) a-wx rts-zfp/adalib/libgnat.a\n \n rts-none: force\n \t$(MAKE) $(FLAGS_TO_PASS) prepare-rts \\\n@@ -1861,6 +1863,8 @@ rts-ravenscar: force\n \t-$(GNATMAKE) -Prts-ravenscar/ravenscar.gpr \\\n \t   --GCC=\"../../../xgcc -B../../../\"\n \t$(CHMOD) a-wx rts-ravenscar/adalib/*.ali\n+\t$(AR) r rts-ravenscar/adalib/libgnat.a\n+\t$(CHMOD) a-wx rts-ravenscar/adalib/libgnat.a\n \n # Warning: this target assumes that LIBRARY_VERSION has been set correctly.\n gnatlib-shared-default:"}, {"sha": "56b2915ef6f82a4f09b781cb0dc92b7c6c62cf82", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -1774,22 +1774,18 @@ package body Bindgen is\n          end if;\n       end loop;\n \n-      --  Add a \"-Ldir\" for each directory in the object path. We skip this\n-      --  in Configurable_Run_Time mode, where we want more precise control\n-      --  of exactly what goes into the resulting object file\n+      --  Add a \"-Ldir\" for each directory in the object path\n \n-      if not Configurable_Run_Time_Mode then\n-         for J in 1 .. Nb_Dir_In_Obj_Search_Path loop\n-            declare\n-               Dir : constant String_Ptr := Dir_In_Obj_Search_Path (J);\n-            begin\n-               Name_Len := 0;\n-               Add_Str_To_Name_Buffer (\"-L\");\n-               Add_Str_To_Name_Buffer (Dir.all);\n-               Write_Linker_Option;\n-            end;\n-         end loop;\n-      end if;\n+      for J in 1 .. Nb_Dir_In_Obj_Search_Path loop\n+         declare\n+            Dir : constant String_Ptr := Dir_In_Obj_Search_Path (J);\n+         begin\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer (\"-L\");\n+            Add_Str_To_Name_Buffer (Dir.all);\n+            Write_Linker_Option;\n+         end;\n+      end loop;\n \n       --  Sort linker options\n \n@@ -1845,7 +1841,7 @@ package body Bindgen is\n       --  files. The reason for this decision is that libraries referenced\n       --  by internal routines may reference these standard library entries.\n \n-      if not (Configurable_Run_Time_Mode or else Opt.No_Stdlib) then\n+      if not Opt.No_Stdlib then\n          Name_Len := 0;\n \n          if Opt.Shared_Libgnat then"}, {"sha": "9c233995c8f931bd44b67974897566ce4b07c3e7", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 315, "deletions": 122, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -33,6 +33,7 @@ with Expander; use Expander;\n with Exp_Util; use Exp_Util;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch7;  use Exp_Ch7;\n+with Exp_Ch9;  use Exp_Ch9;\n with Freeze;   use Freeze;\n with Hostparm; use Hostparm;\n with Itypes;   use Itypes;\n@@ -170,6 +171,7 @@ package body Exp_Aggr is\n \n    function Build_Array_Aggr_Code\n      (N           : Node_Id;\n+      Ctype       : Entity_Id;\n       Index       : Node_Id;\n       Into        : Node_Id;\n       Scalar_Comp : Boolean;\n@@ -397,6 +399,7 @@ package body Exp_Aggr is\n \n    function Build_Array_Aggr_Code\n      (N           : Node_Id;\n+      Ctype       : Entity_Id;\n       Index       : Node_Id;\n       Into        : Node_Id;\n       Scalar_Comp : Boolean;\n@@ -430,6 +433,9 @@ package body Exp_Aggr is\n       --     Into (Indices, Ind) := Expr;\n       --\n       --  Otherwise we call Build_Code recursively.\n+      --\n+      --  Ada0Y (AI-287): In case of default initialized component, Expr is\n+      --  empty and we generate a call to the corresponding IP subprogram.\n \n       function Gen_Loop (L, H : Node_Id; Expr : Node_Id) return List_Id;\n       --  Nodes L and H must be side-effect free expressions.\n@@ -656,7 +662,13 @@ package body Exp_Aggr is\n             Res : List_Id;\n \n          begin\n-            if Nkind (Parent (Expr)) = N_Component_Association\n+            --  Ada0Y (AI-287): Do nothing else in case of default initialized\n+            --  component\n+\n+            if not Present (Expr) then\n+               return Lis;\n+\n+            elsif Nkind (Parent (Expr)) = N_Component_Association\n               and then Present (Loop_Actions (Parent (Expr)))\n             then\n                Append_List (Lis, Loop_Actions (Parent (Expr)));\n@@ -692,15 +704,20 @@ package body Exp_Aggr is\n                F := Find_Final_List (Current_Scope);\n             end if;\n          else\n-            F := 0;\n+            F := Empty;\n          end if;\n \n          if Present (Next_Index (Index)) then\n             return\n               Add_Loop_Actions (\n                 Build_Array_Aggr_Code\n-                  (Expr, Next_Index (Index),\n-                   Into, Scalar_Comp, New_Indices, F));\n+                  (N           => Expr,\n+                   Ctype       => Ctype,\n+                   Index       => Next_Index (Index),\n+                   Into        => Into,\n+                   Scalar_Comp => Scalar_Comp,\n+                   Indices     => New_Indices,\n+                   Flist       => F));\n          end if;\n \n          --  If we get here then we are at a bottom-level (sub-)aggregate\n@@ -713,7 +730,12 @@ package body Exp_Aggr is\n \n          Set_Assignment_OK (Indexed_Comp);\n \n-         if Nkind (Expr) = N_Qualified_Expression then\n+         --  Ada0Y (AI-287): In case of default initialized component, Expr\n+         --  is not present (and therefore we also initialize Expr_Q to empty)\n+\n+         if not Present (Expr) then\n+            Expr_Q := Empty;\n+         elsif Nkind (Expr) = N_Qualified_Expression then\n             Expr_Q := Expression (Expr);\n          else\n             Expr_Q := Expr;\n@@ -723,34 +745,49 @@ package body Exp_Aggr is\n            and then Etype (N) /= Any_Composite\n          then\n             Comp_Type := Component_Type (Etype (N));\n+            pragma Assert (Comp_Type = Ctype); --  AI-287\n \n          elsif Present (Next (First (New_Indices))) then\n \n-            --  This is a multidimensional array. Recover the component\n-            --  type from the outermost aggregate, because subaggregates\n-            --  do not have an assigned type.\n+            --  Ada0Y (AI-287): Do nothing in case of default initialized\n+            --  component because we have received the component type in\n+            --  the formal parameter Ctype.\n+            --  ??? I have added some assert pragmas to check if this new\n+            --      formal can be used to replace this code in all cases.\n \n-            declare\n-               P : Node_Id := Parent (Expr);\n+            if Present (Expr) then\n \n-            begin\n-               while Present (P) loop\n+               --  This is a multidimensional array. Recover the component\n+               --  type from the outermost aggregate, because subaggregates\n+               --  do not have an assigned type.\n \n-                  if Nkind (P) = N_Aggregate\n-                    and then Present (Etype (P))\n-                  then\n-                     Comp_Type := Component_Type (Etype (P));\n-                     exit;\n+               declare\n+                  P : Node_Id := Parent (Expr);\n \n-                  else\n-                     P := Parent (P);\n-                  end if;\n-               end loop;\n-            end;\n+               begin\n+                  while Present (P) loop\n+\n+                     if Nkind (P) = N_Aggregate\n+                       and then Present (Etype (P))\n+                     then\n+                        Comp_Type := Component_Type (Etype (P));\n+                        exit;\n+\n+                     else\n+                        P := Parent (P);\n+                     end if;\n+                  end loop;\n+                  pragma Assert (Comp_Type = Ctype); --  AI-287\n+               end;\n+            end if;\n          end if;\n \n-         if Nkind (Expr_Q) = N_Aggregate\n-           or else Nkind (Expr_Q) = N_Extension_Aggregate\n+         --  Ada0Y (AI-287): We only analyze the expression in case of non\n+         --  default initialized components (otherwise Expr_Q is not present)\n+\n+         if Present (Expr_Q)\n+           and then (Nkind (Expr_Q) = N_Aggregate\n+                     or else Nkind (Expr_Q) = N_Extension_Aggregate)\n          then\n             --  At this stage the Expression may not have been\n             --  analyzed yet because the array aggregate code has not\n@@ -771,59 +808,73 @@ package body Exp_Aggr is\n             end if;\n          end if;\n \n-         --  Now generate the assignment with no associated controlled\n-         --  actions since the target of the assignment may not have\n-         --  been initialized, it is not possible to Finalize it as\n-         --  expected by normal controlled assignment. The rest of the\n-         --  controlled actions are done manually with the proper\n-         --  finalization list coming from the context.\n+         --  Ada0Y (AI-287): In case of default initialized component, call\n+         --  the initialization subprogram associated with the component type\n \n-         A :=\n-           Make_OK_Assignment_Statement (Loc,\n-             Name       => Indexed_Comp,\n-             Expression => New_Copy_Tree (Expr));\n+         if not Present (Expr) then\n \n-         if Present (Comp_Type) and then Controlled_Type (Comp_Type) then\n-            Set_No_Ctrl_Actions (A);\n-         end if;\n+            Append_List_To (L,\n+                 Build_Initialization_Call (Loc,\n+                   Id_Ref            => Indexed_Comp,\n+                   Typ               => Ctype,\n+                   With_Default_Init => True));\n \n-         Append_To (L, A);\n+         else\n \n-         --  Adjust the tag if tagged (because of possible view\n-         --  conversions), unless compiling for the Java VM\n-         --  where tags are implicit.\n+            --  Now generate the assignment with no associated controlled\n+            --  actions since the target of the assignment may not have\n+            --  been initialized, it is not possible to Finalize it as\n+            --  expected by normal controlled assignment. The rest of the\n+            --  controlled actions are done manually with the proper\n+            --  finalization list coming from the context.\n \n-         if Present (Comp_Type)\n-           and then Is_Tagged_Type (Comp_Type)\n-           and then not Java_VM\n-         then\n             A :=\n               Make_OK_Assignment_Statement (Loc,\n-                Name =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>  New_Copy_Tree (Indexed_Comp),\n-                    Selector_Name =>\n-                      New_Reference_To (Tag_Component (Comp_Type), Loc)),\n+                Name       => Indexed_Comp,\n+                Expression => New_Copy_Tree (Expr));\n \n-                Expression =>\n-                  Unchecked_Convert_To (RTE (RE_Tag),\n-                    New_Reference_To (\n-                      Access_Disp_Table (Comp_Type), Loc)));\n+            if Present (Comp_Type) and then Controlled_Type (Comp_Type) then\n+               Set_No_Ctrl_Actions (A);\n+            end if;\n \n             Append_To (L, A);\n-         end if;\n \n-         --  Adjust and Attach the component to the proper final list\n-         --  which can be the controller of the outer record object or\n-         --  the final list associated with the scope\n+            --  Adjust the tag if tagged (because of possible view\n+            --  conversions), unless compiling for the Java VM\n+            --  where tags are implicit.\n \n-         if Present (Comp_Type)  and then Controlled_Type (Comp_Type) then\n-            Append_List_To (L,\n-              Make_Adjust_Call (\n-                Ref         => New_Copy_Tree (Indexed_Comp),\n-                Typ         => Comp_Type,\n-                Flist_Ref   => F,\n-                With_Attach => Make_Integer_Literal (Loc, 1)));\n+            if Present (Comp_Type)\n+              and then Is_Tagged_Type (Comp_Type)\n+              and then not Java_VM\n+            then\n+               A :=\n+                 Make_OK_Assignment_Statement (Loc,\n+                   Name =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix =>  New_Copy_Tree (Indexed_Comp),\n+                       Selector_Name =>\n+                         New_Reference_To (Tag_Component (Comp_Type), Loc)),\n+\n+                   Expression =>\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (\n+                         Access_Disp_Table (Comp_Type), Loc)));\n+\n+               Append_To (L, A);\n+            end if;\n+\n+            --  Adjust and Attach the component to the proper final list\n+            --  which can be the controller of the outer record object or\n+            --  the final list associated with the scope\n+\n+            if Present (Comp_Type)  and then Controlled_Type (Comp_Type) then\n+               Append_List_To (L,\n+                 Make_Adjust_Call (\n+                   Ref         => New_Copy_Tree (Indexed_Comp),\n+                   Typ         => Comp_Type,\n+                   Flist_Ref   => F,\n+                   With_Attach => Make_Integer_Literal (Loc, 1)));\n+            end if;\n          end if;\n \n          return Add_Loop_Actions (L);\n@@ -857,21 +908,29 @@ package body Exp_Aggr is\n          if Empty_Range (L, H) then\n             Append_To (S, Make_Null_Statement (Loc));\n \n-            --  The expression must be type-checked even though no component\n-            --  of the aggregate will have this value. This is done only for\n-            --  actual components of the array, not for subaggregates. Do the\n-            --  check on a copy, because the expression may be shared among\n-            --  several choices, some of which might be non-null.\n+            --  Ada0Y (AI-287): Nothing else need to be done in case of\n+            --  default initialized component\n \n-            if Present (Etype (N))\n-              and then Is_Array_Type (Etype (N))\n-              and then No (Next_Index (Index))\n-            then\n-               Expander_Mode_Save_And_Set (False);\n-               Tcopy := New_Copy_Tree (Expr);\n-               Set_Parent (Tcopy, N);\n-               Analyze_And_Resolve (Tcopy, Component_Type (Etype (N)));\n-               Expander_Mode_Restore;\n+            if not Present (Expr) then\n+               null;\n+\n+            else\n+               --  The expression must be type-checked even though no component\n+               --  of the aggregate will have this value. This is done only for\n+               --  actual components of the array, not for subaggregates. Do\n+               --  the check on a copy, because the expression may be shared\n+               --  among several choices, some of which might be non-null.\n+\n+               if Present (Etype (N))\n+                 and then Is_Array_Type (Etype (N))\n+                 and then No (Next_Index (Index))\n+               then\n+                  Expander_Mode_Save_And_Set (False);\n+                  Tcopy := New_Copy_Tree (Expr);\n+                  Set_Parent (Tcopy, N);\n+                  Analyze_And_Resolve (Tcopy, Component_Type (Etype (N)));\n+                  Expander_Mode_Restore;\n+               end if;\n             end if;\n \n             return S;\n@@ -891,6 +950,7 @@ package body Exp_Aggr is\n            and then Local_Compile_Time_Known_Value (H)\n            and then Local_Expr_Value (H) - Local_Expr_Value (L) <= 2\n          then\n+\n             Append_List_To (S, Gen_Assign (New_Copy_Tree (L), Expr));\n             Append_List_To (S, Gen_Assign (Add (1, To => L), Expr));\n \n@@ -1084,7 +1144,8 @@ package body Exp_Aggr is\n       Expr   : Node_Id;\n       Typ    : Entity_Id;\n \n-      Others_Expr : Node_Id   := Empty;\n+      Others_Expr         : Node_Id := Empty;\n+      Others_Mbox_Present : Boolean := False;\n \n       Aggr_L : constant Node_Id := Low_Bound (Aggregate_Bounds (N));\n       Aggr_H : constant Node_Id := High_Bound (Aggregate_Bounds (N));\n@@ -1096,8 +1157,8 @@ package body Exp_Aggr is\n       Aggr_High : constant Node_Id := Duplicate_Subexpr_No_Checks (Aggr_H);\n       --  After Duplicate_Subexpr these are side-effect free.\n \n-      Low  : Node_Id;\n-      High : Node_Id;\n+      Low        : Node_Id;\n+      High       : Node_Id;\n \n       Nb_Choices : Nat := 0;\n       Table      : Case_Table_Type (1 .. Number_Of_Choices (N));\n@@ -1144,7 +1205,12 @@ package body Exp_Aggr is\n             while Present (Choice) loop\n                if Nkind (Choice) = N_Others_Choice then\n                   Set_Loop_Actions (Assoc, New_List);\n-                  Others_Expr := Expression (Assoc);\n+\n+                  if Box_Present (Assoc) then\n+                     Others_Mbox_Present := True;\n+                  else\n+                     Others_Expr := Expression (Assoc);\n+                  end if;\n                   exit;\n                end if;\n \n@@ -1155,9 +1221,15 @@ package body Exp_Aggr is\n                end if;\n \n                Nb_Choices := Nb_Choices + 1;\n-               Table (Nb_Choices) := (Choice_Lo   => Low,\n-                                      Choice_Hi   => High,\n-                                      Choice_Node => Expression (Assoc));\n+               if Box_Present (Assoc) then\n+                  Table (Nb_Choices) := (Choice_Lo   => Low,\n+                                         Choice_Hi   => High,\n+                                         Choice_Node => Empty);\n+               else\n+                  Table (Nb_Choices) := (Choice_Lo   => Low,\n+                                         Choice_Hi   => High,\n+                                         Choice_Node => Expression (Assoc));\n+               end if;\n                Next (Choice);\n             end loop;\n \n@@ -1185,7 +1257,7 @@ package body Exp_Aggr is\n          --  We don't need to generate loops over empty gaps, but if there is\n          --  a single empty range we must analyze the expression for semantics\n \n-         if Present (Others_Expr) then\n+         if Present (Others_Expr) or else Others_Mbox_Present then\n             declare\n                First : Boolean := True;\n \n@@ -1254,12 +1326,21 @@ package body Exp_Aggr is\n \n          if Present (Component_Associations (N)) then\n             Assoc := Last (Component_Associations (N));\n-            Expr  := Expression (Assoc);\n \n-            Append_List (Gen_While (Add (Nb_Elements, To => Aggr_L),\n-                                    Aggr_High,\n-                                    Expr),\n-                         To => New_Code);\n+            --  Ada0Y (AI-287)\n+            if Box_Present (Assoc) then\n+               Append_List (Gen_While (Add (Nb_Elements, To => Aggr_L),\n+                                       Aggr_High,\n+                                       Empty),\n+                            To => New_Code);\n+            else\n+               Expr  := Expression (Assoc);\n+\n+               Append_List (Gen_While (Add (Nb_Elements, To => Aggr_L),\n+                                       Aggr_High,\n+                                       Expr), --  AI-287\n+                            To => New_Code);\n+            end if;\n          end if;\n       end if;\n \n@@ -1544,11 +1625,19 @@ package body Exp_Aggr is\n          --  types and components\n \n          if (Nkind (Target) = N_Identifier\n+             and then Present (Etype (Target))\n              and then Is_Limited_Type (Etype (Target)))\n            or else (Nkind (Target) = N_Selected_Component\n+                    and then Present (Etype (Selector_Name (Target)))\n                     and then Is_Limited_Type (Etype (Selector_Name (Target))))\n            or else (Nkind (Target) = N_Unchecked_Type_Conversion\n+                    and then Present (Etype (Target))\n                     and then Is_Limited_Type (Etype (Target)))\n+           or else (Nkind (Target) = N_Unchecked_Expression\n+                    and then Nkind (Expression (Target)) = N_Indexed_Component\n+                    and then Present (Etype (Prefix (Expression (Target))))\n+                    and then Is_Limited_Type\n+                               (Etype (Prefix (Expression (Target)))))\n          then\n \n             if Init_Pr then\n@@ -1666,11 +1755,22 @@ package body Exp_Aggr is\n                Ref := Convert_To (Init_Typ, New_Copy_Tree (Target));\n                Set_Assignment_OK (Ref);\n \n-               Append_List_To (Start_L,\n-                 Build_Initialization_Call (Loc,\n-                   Id_Ref => Ref,\n-                   Typ    => Init_Typ,\n-                   In_Init_Proc => Within_Init_Proc));\n+               if Has_Default_Init_Comps (N)\n+                 or else Has_Task (Base_Type (Init_Typ))\n+               then\n+                  Append_List_To (Start_L,\n+                    Build_Initialization_Call (Loc,\n+                      Id_Ref       => Ref,\n+                      Typ          => Init_Typ,\n+                      In_Init_Proc => Within_Init_Proc,\n+                      With_Default_Init => True));\n+               else\n+                  Append_List_To (Start_L,\n+                    Build_Initialization_Call (Loc,\n+                      Id_Ref       => Ref,\n+                      Typ          => Init_Typ,\n+                      In_Init_Proc => Within_Init_Proc));\n+               end if;\n \n                if Is_Constrained (Entity (A))\n                  and then Has_Discriminants (Entity (A))\n@@ -1812,18 +1912,48 @@ package body Exp_Aggr is\n       while Present (Comp) loop\n          Selector  := Entity (First (Choices (Comp)));\n \n-         --  Default initialization of a limited component\n+         --  Ada0Y (AI-287): Default initialization of a limited component\n \n          if Box_Present (Comp)\n             and then Is_Limited_Type (Etype (Selector))\n          then\n+\n+            --  Ada0Y (AI-287): If the component type has tasks then generate\n+            --  the activation chain and master entities (except in case of an\n+            --  allocator because in that case these entities are generated\n+            --  by Build_Task_Allocate_Block_With_Init_Stmts)\n+\n+            declare\n+               Ctype            : Entity_Id := Etype (Selector);\n+               Inside_Allocator : Boolean   := False;\n+               P                : Node_Id   := Parent (N);\n+\n+            begin\n+               if Is_Task_Type (Ctype) or else Has_Task (Ctype) then\n+                  while Present (P) loop\n+                     if Nkind (P) = N_Allocator then\n+                        Inside_Allocator := True;\n+                        exit;\n+                     end if;\n+\n+                     P := Parent (P);\n+                  end loop;\n+\n+                  if not Inside_Init_Proc and not Inside_Allocator then\n+                     Build_Activation_Chain_Entity (N);\n+                     Build_Master_Entity (Etype (N));\n+                  end if;\n+               end if;\n+            end;\n+\n             Append_List_To (L,\n               Build_Initialization_Call (Loc,\n                 Id_Ref => Make_Selected_Component (Loc,\n                             Prefix => New_Copy_Tree (Target),\n                             Selector_Name => New_Occurrence_Of (Selector,\n-                                                                Loc)),\n-                Typ    => Etype (Selector)));\n+                                                                   Loc)),\n+                Typ    => Etype (Selector),\n+                With_Default_Init => True));\n \n             goto Next_Comp;\n          end if;\n@@ -2200,10 +2330,26 @@ package body Exp_Aggr is\n       Access_Type : constant Entity_Id := Etype (Temp);\n \n    begin\n-      Insert_Actions_After (Decl,\n-        Late_Expansion (Aggr, Typ, Occ,\n-          Find_Final_List (Access_Type),\n-          Associated_Final_Chain (Base_Type (Access_Type))));\n+      if Has_Default_Init_Comps (Aggr) then\n+         declare\n+            L          : constant List_Id := New_List;\n+            Init_Stmts : List_Id;\n+\n+         begin\n+            Init_Stmts := Late_Expansion (Aggr, Typ, Occ,\n+                            Find_Final_List (Access_Type),\n+                            Associated_Final_Chain (Base_Type (Access_Type)));\n+\n+            Build_Task_Allocate_Block_With_Init_Stmts (L, Aggr, Init_Stmts);\n+            Insert_Actions_After (Decl, L);\n+         end;\n+\n+      else\n+         Insert_Actions_After (Decl,\n+           Late_Expansion (Aggr, Typ, Occ,\n+             Find_Final_List (Access_Type),\n+             Associated_Final_Chain (Base_Type (Access_Type))));\n+      end if;\n    end Convert_Aggr_In_Allocator;\n \n    --------------------------------\n@@ -2706,6 +2852,14 @@ package body Exp_Aggr is\n    --  Start of processing for Convert_To_Positional\n \n    begin\n+      --  Ada0Y (AI-287): Do not convert in case of default initialized\n+      --  components because in this case will need to call the corresponding\n+      --  IP procedure.\n+\n+      if Has_Default_Init_Comps (N) then\n+         return;\n+      end if;\n+\n       if Is_Flat (N, Number_Dimensions (Typ)) then\n          return;\n       end if;\n@@ -3827,14 +3981,19 @@ package body Exp_Aggr is\n            (N, Sec_Stack => Has_Controlled_Component (Typ));\n       end if;\n \n-      Maybe_In_Place_OK :=\n-        Comes_From_Source (N)\n-          and then Nkind (Parent (N)) = N_Assignment_Statement\n-          and then not Is_Bit_Packed_Array (Typ)\n-          and then not Has_Controlled_Component (Typ)\n-          and then In_Place_Assign_OK;\n+      if Has_Default_Init_Comps (N) then\n+         Maybe_In_Place_OK := False;\n+      else\n+         Maybe_In_Place_OK :=\n+           Comes_From_Source (N)\n+             and then Nkind (Parent (N)) = N_Assignment_Statement\n+             and then not Is_Bit_Packed_Array (Typ)\n+             and then not Has_Controlled_Component (Typ)\n+             and then In_Place_Assign_OK;\n+      end if;\n \n-      if Comes_From_Source (Parent (N))\n+      if not Has_Default_Init_Comps (N)\n+         and then Comes_From_Source (Parent (N))\n          and then Nkind (Parent (N)) = N_Object_Declaration\n          and then not Must_Slide (N, Typ)\n          and then N = Expression (Parent (N))\n@@ -3938,13 +4097,23 @@ package body Exp_Aggr is\n             Target := New_Reference_To (Tmp, Loc);\n \n          else\n+\n+            if Has_Default_Init_Comps (N) then\n+\n+               --  Ada0Y (AI-287): This case has not been analyzed???\n+\n+               pragma Assert (False);\n+               null;\n+            end if;\n+\n             --  Name in assignment is explicit dereference.\n \n             Target := New_Copy (Tmp);\n          end if;\n \n          Aggr_Code :=\n            Build_Array_Aggr_Code (N,\n+             Ctype       => Ctyp,\n              Index       => First_Index (Typ),\n              Into        => Target,\n              Scalar_Comp => Is_Scalar_Type (Ctyp));\n@@ -4478,14 +4647,17 @@ package body Exp_Aggr is\n    function Has_Default_Init_Comps (N : Node_Id) return Boolean is\n       Comps : constant List_Id := Component_Associations (N);\n       C     : Node_Id;\n-\n+      Expr  : Node_Id;\n    begin\n       pragma Assert (Nkind (N) = N_Aggregate\n-                     or else Nkind (N) = N_Extension_Aggregate);\n+         or else Nkind (N) = N_Extension_Aggregate);\n+\n       if No (Comps) then\n          return False;\n       end if;\n \n+      --  Check if any direct component has default initialized components\n+\n       C := First (Comps);\n       while Present (C) loop\n          if Box_Present (C) then\n@@ -4494,6 +4666,24 @@ package body Exp_Aggr is\n \n          Next (C);\n       end loop;\n+\n+      --  Recursive call in case of aggregate expression\n+\n+      C := First (Comps);\n+      while Present (C) loop\n+         Expr := Expression (C);\n+\n+         if Present (Expr)\n+           and then (Nkind (Expr) = N_Aggregate\n+                     or else Nkind (Expr) = N_Extension_Aggregate)\n+           and then Has_Default_Init_Comps (Expr)\n+         then\n+            return True;\n+         end if;\n+\n+         Next (C);\n+      end loop;\n+\n       return False;\n    end Has_Default_Init_Comps;\n \n@@ -4527,20 +4717,23 @@ package body Exp_Aggr is\n       Typ    : Entity_Id;\n       Target : Node_Id;\n       Flist  : Node_Id   := Empty;\n-      Obj    : Entity_Id := Empty) return List_Id\n-   is\n+      Obj    : Entity_Id := Empty) return List_Id is\n    begin\n       if Is_Record_Type (Etype (N)) then\n          return Build_Record_Aggr_Code (N, Typ, Target, Flist, Obj);\n-      else\n+      elsif Is_Array_Type (Etype (N)) then\n          return\n            Build_Array_Aggr_Code\n-             (N,\n-              First_Index (Typ),\n-              Target,\n-              Is_Scalar_Type (Component_Type (Typ)),\n-              No_List,\n-              Flist);\n+             (N           => N,\n+              Ctype       => Component_Type (Etype (N)),\n+              Index       => First_Index (Typ),\n+              Into        => Target,\n+              Scalar_Comp => Is_Scalar_Type (Component_Type (Typ)),\n+              Indices     => No_List,\n+              Flist       => Flist);\n+      else\n+         pragma Assert (False);\n+         return New_List;\n       end if;\n    end Late_Expansion;\n "}, {"sha": "1cb9328655c10366052168d23444e66860834246", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -56,6 +56,7 @@ with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -1032,13 +1033,14 @@ package body Exp_Ch3 is\n    --  end;\n \n    function Build_Initialization_Call\n-     (Loc          : Source_Ptr;\n-      Id_Ref       : Node_Id;\n-      Typ          : Entity_Id;\n-      In_Init_Proc : Boolean := False;\n-      Enclos_Type  : Entity_Id := Empty;\n-      Discr_Map    : Elist_Id := New_Elmt_List)\n-      return         List_Id\n+     (Loc               : Source_Ptr;\n+      Id_Ref            : Node_Id;\n+      Typ               : Entity_Id;\n+      In_Init_Proc      : Boolean := False;\n+      Enclos_Type       : Entity_Id := Empty;\n+      Discr_Map         : Elist_Id := New_Elmt_List;\n+      With_Default_Init : Boolean := False)\n+      return              List_Id\n    is\n       First_Arg      : Node_Id;\n       Args           : List_Id;\n@@ -1076,7 +1078,6 @@ package body Exp_Ch3 is\n       --  honest. Actually it isn't quite type honest, because there can be\n       --  conflicts of views in the private type case. That is why we set\n       --  Conversion_OK in the conversion node.\n-\n       if (Is_Record_Type (Typ)\n            or else Is_Array_Type (Typ)\n            or else Is_Private_Type (Typ))\n@@ -1110,12 +1111,28 @@ package body Exp_Ch3 is\n \n          Append_To (Args, Make_Identifier (Loc, Name_uChain));\n \n-         Decls := Build_Task_Image_Decls (Loc, Id_Ref, Enclos_Type);\n-         Decl  := Last (Decls);\n+         --  Ada0Y (AI-287): In case of default initialized components\n+         --  with tasks, we generate a null string actual parameter.\n+         --  This is just a workaround that must be improved later???\n+\n+         if With_Default_Init then\n+            declare\n+               S           : String_Id;\n+               Null_String : Node_Id;\n+            begin\n+               Start_String;\n+               S := End_String;\n+               Null_String := Make_String_Literal (Loc, Strval => S);\n+               Append_To (Args, Null_String);\n+            end;\n+         else\n+            Decls := Build_Task_Image_Decls (Loc, Id_Ref, Enclos_Type);\n+            Decl  := Last (Decls);\n \n-         Append_To (Args,\n-           New_Occurrence_Of (Defining_Identifier (Decl), Loc));\n-         Append_List (Decls, Res);\n+            Append_To (Args,\n+              New_Occurrence_Of (Defining_Identifier (Decl), Loc));\n+            Append_List (Decls, Res);\n+         end if;\n \n       else\n          Decls := No_List;\n@@ -1202,7 +1219,22 @@ package body Exp_Ch3 is\n                end if;\n             end if;\n \n-            Append_To (Args, Arg);\n+            --  Ada0Y (AI-287) In case of default initialized components, we\n+            --  need to generate the corresponding selected component node\n+            --  to access the discriminant value. In other cases this is not\n+            --  required because we are inside the init proc and we use the\n+            --  corresponding formal.\n+\n+            if With_Default_Init\n+              and then Nkind (Id_Ref) = N_Selected_Component\n+            then\n+               Append_To (Args,\n+                 Make_Selected_Component (Loc,\n+                   Prefix => New_Copy_Tree (Prefix (Id_Ref)),\n+                   Selector_Name => Arg));\n+            else\n+               Append_To (Args, Arg);\n+            end if;\n \n             Next_Discriminant (Discr);\n          end loop;"}, {"sha": "7de6498a696abb2c81fe1b97e84f487c18c23b55", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -52,13 +52,14 @@ package Exp_Ch3 is\n    --  and the discriminant checking functions are inserted after this node.\n \n    function Build_Initialization_Call\n-     (Loc          : Source_Ptr;\n-      Id_Ref       : Node_Id;\n-      Typ          : Entity_Id;\n-      In_Init_Proc : Boolean := False;\n-      Enclos_Type  : Entity_Id := Empty;\n-      Discr_Map    : Elist_Id := New_Elmt_List)\n-      return         List_Id;\n+     (Loc               : Source_Ptr;\n+      Id_Ref            : Node_Id;\n+      Typ               : Entity_Id;\n+      In_Init_Proc      : Boolean := False;\n+      Enclos_Type       : Entity_Id := Empty;\n+      Discr_Map         : Elist_Id := New_Elmt_List;\n+      With_Default_Init : Boolean := False)\n+      return              List_Id;\n    --  Builds a call to the initialization procedure of the Id entity. Id_Ref\n    --  is either a new reference to Id (for record fields), or an indexed\n    --  component (for array elements). Loc is the source location for the\n@@ -76,6 +77,10 @@ package Exp_Ch3 is\n    --  entry families bounded by discriminants, protected type discriminants\n    --  can appear within expressions in array bounds (not as stand-alone\n    --  identifiers) and a general replacement is necessary.\n+   --\n+   --  Ada0Y (AI-287): With_Default_Init is used to indicate that the initia-\n+   --  lization call corresponds to a default initialized component of an\n+   --  aggregate.\n \n    procedure Freeze_Type (N : Node_Id);\n    --  This procedure executes the freezing actions associated with the given"}, {"sha": "f8bf7f80a6c69476ad4b6c05521eaaa799416245", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 108, "deletions": 107, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -69,8 +69,7 @@ package body Exp_Ch9 is\n      (Sloc  : Source_Ptr;\n       Ent   : Entity_Id;\n       Index : Node_Id;\n-      Tsk   : Entity_Id)\n-      return  Node_Id;\n+      Tsk   : Entity_Id) return Node_Id;\n    --  Compute the index position for an entry call. Tsk is the target\n    --  task. If the bounds of some entry family depend on discriminants,\n    --  the expression computed by this function uses the discriminants\n@@ -79,8 +78,7 @@ package body Exp_Ch9 is\n    function Index_Constant_Declaration\n      (N        : Node_Id;\n       Index_Id : Entity_Id;\n-      Prot     : Entity_Id)\n-      return     List_Id;\n+      Prot     : Entity_Id) return List_Id;\n    --  For an entry family and its barrier function, we define a local entity\n    --  that maps the index in the call into the entry index into the object:\n    --\n@@ -105,64 +103,54 @@ package body Exp_Ch9 is\n    function Build_Barrier_Function\n      (N    : Node_Id;\n       Ent  : Entity_Id;\n-      Pid  : Node_Id)\n-      return Node_Id;\n+      Pid  : Node_Id) return Node_Id;\n    --  Build the function body returning the value of the barrier expression\n    --  for the specified entry body.\n \n    function Build_Barrier_Function_Specification\n      (Def_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return   Node_Id;\n+      Loc    : Source_Ptr) return Node_Id;\n    --  Build a specification for a function implementing\n    --  the protected entry barrier of the specified entry body.\n \n    function Build_Corresponding_Record\n      (N    : Node_Id;\n       Ctyp : Node_Id;\n-      Loc  : Source_Ptr)\n-      return Node_Id;\n+      Loc  : Source_Ptr) return Node_Id;\n    --  Common to tasks and protected types. Copy discriminant specifications,\n    --  build record declaration. N is the type declaration, Ctyp is the\n    --  concurrent entity (task type or protected type).\n \n    function Build_Entry_Count_Expression\n      (Concurrent_Type : Node_Id;\n       Component_List  : List_Id;\n-      Loc             : Source_Ptr)\n-      return            Node_Id;\n+      Loc             : Source_Ptr) return Node_Id;\n    --  Compute number of entries for concurrent object. This is a count of\n    --  simple entries, followed by an expression that computes the length\n    --  of the range of each entry family. A single array with that size is\n    --  allocated for each concurrent object of the type.\n \n-   function Build_Find_Body_Index\n-     (Typ  : Entity_Id)\n-      return Node_Id;\n+   function Build_Find_Body_Index (Typ : Entity_Id) return Node_Id;\n    --  Build the function that translates the entry index in the call\n    --  (which depends on the size of entry families) into an index into the\n    --  Entry_Bodies_Array, to determine the body and barrier function used\n    --  in a protected entry call. A pointer to this function appears in every\n    --  protected object.\n \n-   function Build_Find_Body_Index_Spec\n-     (Typ  : Entity_Id)\n-      return Node_Id;\n-   --  Build subprogram declaration for previous one.\n+   function Build_Find_Body_Index_Spec (Typ : Entity_Id) return Node_Id;\n+   --  Build subprogram declaration for previous one\n \n    function Build_Protected_Entry\n-     (N         : Node_Id;\n-      Ent       : Entity_Id;\n-      Pid       : Node_Id)\n-      return Node_Id;\n+     (N   : Node_Id;\n+      Ent : Entity_Id;\n+      Pid : Node_Id) return Node_Id;\n    --  Build the procedure implementing the statement sequence of\n    --  the specified entry body.\n \n    function Build_Protected_Entry_Specification\n      (Def_Id : Entity_Id;\n       Ent_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return Node_Id;\n+      Loc    : Source_Ptr) return Node_Id;\n    --  Build a specification for a procedure implementing\n    --  the statement sequence of the specified entry body.\n    --  Add attributes associating it with the entry defining identifier\n@@ -171,8 +159,7 @@ package body Exp_Ch9 is\n    function Build_Protected_Subprogram_Body\n      (N         : Node_Id;\n       Pid       : Node_Id;\n-      N_Op_Spec : Node_Id)\n-      return      Node_Id;\n+      N_Op_Spec : Node_Id) return Node_Id;\n    --  This function is used to construct the protected version of a protected\n    --  subprogram. Its statement sequence first defers abortion, then locks\n    --  the associated protected object, and then enters a block that contains\n@@ -185,8 +172,7 @@ package body Exp_Ch9 is\n      (N           : Node_Id;\n       Obj_Type    : Entity_Id;\n       Unprotected : Boolean := False;\n-      Ident       : Entity_Id)\n-      return        List_Id;\n+      Ident       : Entity_Id) return List_Id;\n    --  Utility shared by Build_Protected_Sub_Spec and Expand_Access_Protected_\n    --  Subprogram_Type. Builds signature of protected subprogram, adding the\n    --  formal that corresponds to the object itself. For an access to protected\n@@ -197,8 +183,7 @@ package body Exp_Ch9 is\n \n    function Build_Selected_Name\n      (Prefix, Selector : Name_Id;\n-      Append_Char      : Character := ' ')\n-      return             Name_Id;\n+      Append_Char      : Character := ' ') return Name_Id;\n    --  Build a name in the form of Prefix__Selector, with an optional\n    --  character appended. This is used for internal subprograms generated\n    --  for operations of protected types, including barrier functions. In\n@@ -227,9 +212,8 @@ package body Exp_Ch9 is\n    --  value type that is associated with the task type.\n \n    function Build_Unprotected_Subprogram_Body\n-     (N    : Node_Id;\n-      Pid  : Node_Id)\n-      return Node_Id;\n+     (N   : Node_Id;\n+      Pid : Node_Id) return Node_Id;\n    --  This routine constructs the unprotected version of a protected\n    --  subprogram body, which is contains all of the code in the\n    --  original, unexpanded body. This is the version of the protected\n@@ -248,8 +232,7 @@ package body Exp_Ch9 is\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id)\n-      return Node_Id;\n+      Ttyp : Entity_Id) return Node_Id;\n    --  Compute (Hi - Lo) for two entry family indices. Hi is the index in\n    --  an accept statement, or the upper bound in the discrete subtype of\n    --  an entry declaration. Lo is the corresponding lower bound. Ttyp is\n@@ -259,8 +242,7 @@ package body Exp_Ch9 is\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id)\n-      return Node_Id;\n+      Ttyp : Entity_Id) return Node_Id;\n    --  Compute (Hi - Lo) + 1 Max 0, to determine the number of entries in\n    --  a family, and handle properly the superflat case. This is equivalent\n    --  to the use of 'Length on the index type, but must use Family_Offset\n@@ -275,9 +257,8 @@ package body Exp_Ch9 is\n    --  the entry name, and the entry family index.\n \n    function Find_Task_Or_Protected_Pragma\n-     (T    : Node_Id;\n-      P    : Name_Id)\n-      return Node_Id;\n+     (T : Node_Id;\n+      P : Name_Id) return Node_Id;\n    --  Searches the task or protected definition T for the first occurrence\n    --  of the pragma whose name is given by P. The caller has ensured that\n    --  the pragma is present in the task definition. A special case is that\n@@ -302,8 +283,7 @@ package body Exp_Ch9 is\n      (Sloc  : Source_Ptr;\n       Ent   : Entity_Id;\n       Index : Node_Id;\n-      Tsk   : Entity_Id)\n-      return  Node_Id\n+      Tsk   : Entity_Id) return Node_Id\n    is\n       Ttyp : constant Entity_Id := Etype (Tsk);\n       Expr : Node_Id;\n@@ -746,8 +726,7 @@ package body Exp_Ch9 is\n    function Build_Barrier_Function\n      (N    : Node_Id;\n       Ent  : Entity_Id;\n-      Pid  : Node_Id)\n-      return Node_Id\n+      Pid  : Node_Id) return Node_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Ent_Formals : constant Node_Id    := Entry_Body_Formal_Part (N);\n@@ -816,8 +795,7 @@ package body Exp_Ch9 is\n \n    function Build_Barrier_Function_Specification\n      (Def_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return   Node_Id\n+      Loc    : Source_Ptr) return Node_Id\n    is\n    begin\n       return Make_Function_Specification (Loc,\n@@ -841,9 +819,8 @@ package body Exp_Ch9 is\n    --------------------------\n \n    function Build_Call_With_Task\n-     (N    : Node_Id;\n-      E    : Entity_Id)\n-      return Node_Id\n+     (N : Node_Id;\n+      E : Entity_Id) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (N);\n \n@@ -861,8 +838,7 @@ package body Exp_Ch9 is\n    function Build_Corresponding_Record\n     (N    : Node_Id;\n      Ctyp : Entity_Id;\n-     Loc  : Source_Ptr)\n-     return Node_Id\n+     Loc  : Source_Ptr) return Node_Id\n    is\n       Rec_Ent  : constant Entity_Id :=\n                    Make_Defining_Identifier\n@@ -941,8 +917,7 @@ package body Exp_Ch9 is\n    function Build_Entry_Count_Expression\n      (Concurrent_Type : Node_Id;\n       Component_List  : List_Id;\n-      Loc             : Source_Ptr)\n-      return            Node_Id\n+      Loc             : Source_Ptr) return Node_Id\n    is\n       Eindx  : Nat;\n       Ent    : Entity_Id;\n@@ -999,10 +974,7 @@ package body Exp_Ch9 is\n    -- Build_Find_Body_Index --\n    ---------------------------\n \n-   function Build_Find_Body_Index\n-      (Typ : Entity_Id)\n-      return Node_Id\n-   is\n+   function Build_Find_Body_Index (Typ : Entity_Id) return Node_Id is\n       Loc   : constant Source_Ptr := Sloc (Typ);\n       Ent   : Entity_Id;\n       E_Typ : Entity_Id;\n@@ -1192,10 +1164,7 @@ package body Exp_Ch9 is\n    -- Build_Find_Body_Index_Spec --\n    --------------------------------\n \n-   function Build_Find_Body_Index_Spec\n-      (Typ : Entity_Id)\n-      return Node_Id\n-   is\n+   function Build_Find_Body_Index_Spec (Typ : Entity_Id) return Node_Id is\n       Loc   : constant Source_Ptr := Sloc (Typ);\n       Id    : constant Entity_Id :=\n                Make_Defining_Identifier (Loc,\n@@ -1285,10 +1254,9 @@ package body Exp_Ch9 is\n    ---------------------------\n \n    function Build_Protected_Entry\n-     (N    : Node_Id;\n-      Ent  : Entity_Id;\n-      Pid  : Node_Id)\n-      return Node_Id\n+     (N   : Node_Id;\n+      Ent : Entity_Id;\n+      Pid : Node_Id) return Node_Id\n    is\n       Loc      : constant Source_Ptr := Sloc (N);\n       Op_Decls : constant List_Id    := New_List;\n@@ -1401,8 +1369,7 @@ package body Exp_Ch9 is\n    function Build_Protected_Entry_Specification\n      (Def_Id : Entity_Id;\n       Ent_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return   Node_Id\n+      Loc    : Source_Ptr) return Node_Id\n    is\n       P : Entity_Id;\n \n@@ -1440,8 +1407,7 @@ package body Exp_Ch9 is\n      (N           : Node_Id;\n       Obj_Type    : Entity_Id;\n       Unprotected : Boolean := False;\n-      Ident       : Entity_Id)\n-      return        List_Id\n+      Ident       : Entity_Id) return List_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Formal      : Entity_Id;\n@@ -1494,8 +1460,7 @@ package body Exp_Ch9 is\n    function Build_Protected_Sub_Specification\n      (N           : Node_Id;\n       Prottyp     : Entity_Id;\n-      Unprotected : Boolean := False)\n-      return        Node_Id\n+      Unprotected : Boolean := False) return Node_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Decl        : Node_Id;\n@@ -1556,8 +1521,7 @@ package body Exp_Ch9 is\n    function Build_Protected_Subprogram_Body\n      (N         : Node_Id;\n       Pid       : Node_Id;\n-      N_Op_Spec : Node_Id)\n-      return      Node_Id\n+      N_Op_Spec : Node_Id) return Node_Id\n    is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Op_Spec      : Node_Id;\n@@ -1573,9 +1537,8 @@ package body Exp_Ch9 is\n       Service_Name : Node_Id;\n       Service_Stmt : Node_Id;\n       R            : Node_Id;\n-      Return_Stmt  : Node_Id := Empty;\n-      Pre_Stmts    : List_Id := No_List;\n-      --   Initializations to avoid spurious warnings from GCC3.\n+      Return_Stmt  : Node_Id := Empty;    -- init to avoid gcc 3 warning\n+      Pre_Stmts    : List_Id := No_List;  -- init to avoid gcc 3 warning\n       Stmts        : List_Id;\n       Object_Parm  : Node_Id;\n       Exc_Safe     : Boolean;\n@@ -1906,7 +1869,6 @@ package body Exp_Ch9 is\n       then\n          Add_Shared_Var_Lock_Procs (N);\n       end if;\n-\n    end Build_Protected_Subprogram_Call;\n \n    -------------------------\n@@ -1915,8 +1877,7 @@ package body Exp_Ch9 is\n \n    function Build_Selected_Name\n      (Prefix, Selector : Name_Id;\n-      Append_Char      : Character := ' ')\n-      return             Name_Id\n+      Append_Char      : Character := ' ') return Name_Id\n    is\n       Select_Buffer : String (1 .. Hostparm.Max_Name_Length);\n       Select_Len    : Natural;\n@@ -2336,7 +2297,6 @@ package body Exp_Ch9 is\n \n          Analyze (N);\n       end;\n-\n    end Build_Simple_Entry_Call;\n \n    --------------------------------\n@@ -2352,7 +2312,7 @@ package body Exp_Ch9 is\n \n    begin\n       --  Get the activation chain entity. Except in the case of a package\n-      --  body, this is in the node that was passed. For a package body, we\n+      --  body, this is in the node that w as passed. For a package body, we\n       --  have to find the corresponding package declaration node.\n \n       if Nkind (N) = N_Package_Body then\n@@ -2424,7 +2384,6 @@ package body Exp_Ch9 is\n          Analyze (Call);\n          Check_Task_Activation (N);\n       end if;\n-\n    end Build_Task_Activation_Call;\n \n    -------------------------------\n@@ -2492,9 +2451,63 @@ package body Exp_Ch9 is\n       Append_To (Actions, Block);\n \n       Set_Activation_Chain_Entity (Block, Chain);\n-\n    end Build_Task_Allocate_Block;\n \n+   -----------------------------------------------\n+   -- Build_Task_Allocate_Block_With_Init_Stmts --\n+   -----------------------------------------------\n+\n+   procedure Build_Task_Allocate_Block_With_Init_Stmts\n+     (Actions    : List_Id;\n+      N          : Node_Id;\n+      Init_Stmts : List_Id)\n+   is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Chain  : constant Entity_Id  :=\n+                 Make_Defining_Identifier (Loc, Name_uChain);\n+      Blkent : Entity_Id;\n+      Block  : Node_Id;\n+\n+   begin\n+      Blkent := Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+\n+      Append_To (Init_Stmts,\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Reference_To (RTE (RE_Activate_Tasks), Loc),\n+          Parameter_Associations => New_List (\n+            Make_Attribute_Reference (Loc,\n+              Prefix => New_Reference_To (Chain, Loc),\n+              Attribute_Name => Name_Unchecked_Access))));\n+\n+      Block :=\n+        Make_Block_Statement (Loc,\n+          Identifier => New_Reference_To (Blkent, Loc),\n+          Declarations => New_List (\n+\n+            --  _Chain  : Activation_Chain;\n+\n+            Make_Object_Declaration (Loc,\n+              Defining_Identifier => Chain,\n+              Aliased_Present => True,\n+              Object_Definition   =>\n+                New_Reference_To (RTE (RE_Activation_Chain), Loc))),\n+\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc, Init_Stmts),\n+\n+          Has_Created_Identifier => True,\n+          Is_Task_Allocation_Block => True);\n+\n+      Append_To (Actions,\n+        Make_Implicit_Label_Declaration (Loc,\n+          Defining_Identifier => Blkent,\n+          Label_Construct     => Block));\n+\n+      Append_To (Actions, Block);\n+\n+      Set_Activation_Chain_Entity (Block, Chain);\n+   end Build_Task_Allocate_Block_With_Init_Stmts;\n+\n    -----------------------------------\n    -- Build_Task_Proc_Specification --\n    -----------------------------------\n@@ -2531,17 +2544,15 @@ package body Exp_Ch9 is\n                     Subtype_Mark =>\n                       New_Reference_To\n                         (Corresponding_Record_Type (T), Loc)))));\n-\n    end Build_Task_Proc_Specification;\n \n    ---------------------------------------\n    -- Build_Unprotected_Subprogram_Body --\n    ---------------------------------------\n \n    function Build_Unprotected_Subprogram_Body\n-     (N    : Node_Id;\n-      Pid  : Node_Id)\n-      return Node_Id\n+     (N   : Node_Id;\n+      Pid : Node_Id) return Node_Id\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n       N_Op_Spec : Node_Id;\n@@ -2563,7 +2574,6 @@ package body Exp_Ch9 is\n           Declarations => Op_Decls,\n           Handled_Statement_Sequence =>\n             Handled_Statement_Sequence (N));\n-\n    end Build_Unprotected_Subprogram_Body;\n \n    ----------------------------\n@@ -2800,9 +2810,8 @@ package body Exp_Ch9 is\n    ------------------------\n \n    function Convert_Concurrent\n-     (N    : Node_Id;\n-      Typ  : Entity_Id)\n-      return Node_Id\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Node_Id\n    is\n    begin\n       if not Is_Concurrent_Type (Typ) then\n@@ -2822,8 +2831,7 @@ package body Exp_Ch9 is\n      (Sloc  : Source_Ptr;\n       Ent   : Entity_Id;\n       Index : Node_Id;\n-      Ttyp  : Entity_Id)\n-      return  Node_Id\n+      Ttyp  : Entity_Id) return Node_Id\n    is\n       Expr : Node_Id;\n       Num  : Node_Id;\n@@ -4550,7 +4558,6 @@ package body Exp_Ch9 is\n          Set_Privals (Dec, Next_Op, Loc);\n          Set_Discriminals (Dec);\n       end if;\n-\n    end Expand_N_Entry_Body;\n \n    -----------------------------------\n@@ -6049,7 +6056,6 @@ package body Exp_Ch9 is\n            Make_Aggregate (Loc, Expressions => New_List (Null_Body, Expr)));\n \n          Num_Accept := Num_Accept + 1;\n-\n       end Add_Accept;\n \n       ----------------------------\n@@ -7716,8 +7722,7 @@ package body Exp_Ch9 is\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id)\n-      return Node_Id\n+      Ttyp : Entity_Id) return Node_Id\n    is\n       function Convert_Discriminant_Ref (Bound : Node_Id) return Node_Id;\n       --  If one of the bounds is a reference to a discriminant, replace\n@@ -7790,8 +7795,7 @@ package body Exp_Ch9 is\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id)\n-      return Node_Id\n+      Ttyp : Entity_Id) return Node_Id\n    is\n       Ityp : Entity_Id;\n \n@@ -7820,9 +7824,8 @@ package body Exp_Ch9 is\n    -----------------------------------\n \n    function Find_Task_Or_Protected_Pragma\n-     (T    : Node_Id;\n-      P    : Name_Id)\n-      return Node_Id\n+     (T : Node_Id;\n+      P : Name_Id) return Node_Id\n    is\n       N : Node_Id;\n \n@@ -7898,8 +7901,7 @@ package body Exp_Ch9 is\n    function Index_Constant_Declaration\n      (N        : Node_Id;\n       Index_Id : Entity_Id;\n-      Prot     : Entity_Id)\n-      return     List_Id\n+      Prot     : Entity_Id) return List_Id\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Decls     : constant List_Id    := New_List;\n@@ -8003,8 +8005,7 @@ package body Exp_Ch9 is\n    --------------------------------\n \n    function Make_Initialize_Protection\n-     (Protect_Rec : Entity_Id)\n-      return        List_Id\n+     (Protect_Rec : Entity_Id) return List_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (Protect_Rec);\n       P_Arr       : Entity_Id;"}, {"sha": "7206078147039288fde46bedcf7a22f1b6aabf9f", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -164,6 +164,15 @@ package Exp_Ch9 is\n    --  the Master_Id of the access type as the _Master parameter, and _Chain\n    --  (defined above) as the _Chain parameter.\n \n+   procedure Build_Task_Allocate_Block_With_Init_Stmts\n+     (Actions    : List_Id;\n+      N          : Node_Id;\n+      Init_Stmts : List_Id);\n+   --  Ada0Y (AI-287): Similar to previous routine, but used to expand alloca-\n+   --  ted aggregates with default initialized components. Init_Stmts contains\n+   --  the list of statements required to initialize the allocated aggregate.\n+   --  It replaces the call to Init (Args) done by Build_Task_Allocate_Block.\n+\n    function Concurrent_Ref (N : Node_Id) return Node_Id;\n    --  Given the name of a concurrent object (task or protected object), or\n    --  the name of an access to a concurrent object, this function returns an"}, {"sha": "d23786308254d22ff507cf35659c98f5418d84d2", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -471,7 +471,7 @@ begin\n \n       --  Add System.Standard_Library to list to ensure that these files are\n       --  included in the bind, even if not directly referenced from Ada code\n-      --  This is suppressed if the configurable run-time requests it.\n+      --  This is suppressed if the appropriate targparm switch is set.\n \n       if not Suppress_Standard_Library_On_Target then\n          Name_Buffer (1 .. 12) := \"s-stalib.ali\";"}, {"sha": "049e1c4bf684979897c1385dc12a0bac1d7370e0", "filename": "gcc/ada/i-vthrea.adb", "status": "removed", "additions": 0, "deletions": 386, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fi-vthrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fi-vthrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-vthrea.adb?ref=8738323373326f9d92d2df3eee27989bcee2044b", "patch": "@@ -1,386 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n---                                                                          --\n---                   I N T E R F A C E S . V T H R E A D S                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---        Copyright (C) 2002-2003, Free Software Foundation, Inc.           --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Implement APEX process registration for AE653\n-\n-with Ada.Exceptions;                  use Ada.Exceptions;\n-with Ada.Unchecked_Conversion;\n-\n-with Interfaces.C;\n-\n-with System.Secondary_Stack;\n-with System.Soft_Links;\n-with System.Task_Primitives.Ae_653;\n-with System.Task_Primitives.Operations; use System.Task_Primitives.Operations;\n-with System.Tasking;                    use System.Tasking;\n-with System.Task_Info;\n-with System.Tasking.Initialization;\n-\n-package body Interfaces.Vthreads is\n-\n-   use System.OS_Interface;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Enter_Task (T : Task_ID; Thread : Thread_Id);\n-   --  Duplicate and generalize\n-   --  System.Task_Primitives.Operations.Enter_Task\n-\n-   procedure GNAT_Error_Handler (Sig : Signal);\n-   --  Signal handler for ARINC processes\n-\n-   procedure Init_Float;\n-   pragma Import (C, Init_Float, \"__gnat_init_float\");\n-   --  Properly initializes the FPU for PPC systems.\n-\n-   procedure Install_Handler;\n-   --  Install signal handlers for the calling ARINC process\n-\n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n-   --  Duplicate and generalize\n-   --  System.Task_Primitives.Operations.Register_Foreign_Thread\n-\n-   -----------------------------\n-   -- Install_Signal_Handlers --\n-   -----------------------------\n-\n-   function Install_Signal_Handlers return Interfaces.C.int is\n-   begin\n-      Install_Handler;\n-      Init_Float;\n-      return 0;\n-   end Install_Signal_Handlers;\n-\n-   ----------------------\n-   -- Register_Foreign --\n-   ----------------------\n-\n-   --  Create Ada task data structures for an ARINC process. All dynamic\n-   --  allocation of related data structures must be done via this routine.\n-\n-   function Register_Foreign (T : OSI.Thread_Id) return OSI.STATUS is\n-      use Interfaces.C;\n-      use System.Task_Primitives.Ae_653;\n-\n-      pragma Assert (taskVarGet (T, ATCB_Key_Addr) = ERROR);\n-      --  \"T\" is not yet registered\n-\n-      Result  : OSI.STATUS := taskIdVerify (T);\n-      Status  : OSI.STATUS := OK;\n-      Temp_Id : Task_ID;\n-\n-   begin\n-      if Result = OK then\n-         Status := taskVarGet (T, ATCB_Key_Addr);\n-\n-         --  Error of already registered\n-\n-         if Status /= ERROR then\n-            Result := ERROR;\n-\n-         else\n-            --  Create a TCB\n-\n-            declare\n-               --  Make sure the caller has a TCB, since it's possible to have\n-               --  pure C APEX processes that create ones calling Ada code\n-\n-               Caller : Task_ID;\n-\n-            begin\n-               Status := taskVarGet (taskIdSelf, ATCB_Key_Addr);\n-\n-               if Status = ERROR then\n-                  Caller := Register_Foreign_Thread (taskIdSelf);\n-               end if;\n-            end;\n-\n-            if taskIdSelf /= T then\n-               Temp_Id := Register_Foreign_Thread (T);\n-            end if;\n-\n-            Result := OK;\n-         end if;\n-      end if;\n-\n-      return Result;\n-   end Register_Foreign;\n-\n-   -------------------\n-   -- Reset_Foreign --\n-   -------------------\n-\n-   --  Reinitialize Ada task data structures. No dynamic allocation\n-   --  may occur via this routine.\n-\n-   function Reset_Foreign (T : Thread_Id) return STATUS is\n-      use Interfaces.C;\n-      use System.Secondary_Stack;\n-      use System.Task_Primitives.Ae_653;\n-      use type System.Address;\n-\n-      pragma Assert (taskVarGet (T, ATCB_Key_Addr) /= ERROR);\n-      --  \"T\" has already been registered\n-\n-      Result : STATUS := taskVarGet (T, ATCB_Key_Addr);\n-      function To_Address is new Ada.Unchecked_Conversion\n-        (Interfaces.C.int, System.Address);\n-\n-      pragma Assert (\n-                     To_Task_Id\n-                     (To_Address (Result)).Common.Compiler_Data.Sec_Stack_Addr\n-                       /= System.Null_Address);\n-      --  \"T\" already has a secondary stack\n-\n-   begin\n-      if  Result /= ERROR then\n-\n-         --  Just reset the secondary stack pointer.  The implementation here\n-         --  assumes that the fixed secondary stack implementation is used.\n-         --  If not, there will be a memory leak (along with allocation, which\n-         --  is prohibited for ARINC processes once the system enters \"normal\"\n-         --  mode).\n-\n-         SS_Init\n-           (To_Task_Id\n-              (To_Address (Result)).Common.Compiler_Data.Sec_Stack_Addr);\n-         Result := OK;\n-      end if;\n-\n-      return Result;\n-   end Reset_Foreign;\n-\n-   ------------------\n-   -- Setup_Thread --\n-   ------------------\n-\n-   function Setup_Thread return System.Address is\n-      Result : System.Address := System.Null_Address;\n-      Status : OSI.STATUS;\n-\n-   begin\n-      if Is_Valid_Task then\n-         Status := Reset_Foreign (taskIdSelf);\n-         Result :=\n-           To_Address (System.Task_Primitives.Operations.Self);\n-      else\n-         Status := Register_Foreign (taskIdSelf);\n-         Install_Handler;\n-         Init_Float;\n-         Result :=\n-           To_Address (System.Task_Primitives.Operations.Self);\n-      end if;\n-\n-      return Result;\n-   end Setup_Thread;\n-\n-   ----------------\n-   -- Enter_Task --\n-   ----------------\n-\n-   procedure Enter_Task (T : Task_ID; Thread : Thread_Id) is\n-      use System.Task_Primitives.Ae_653;\n-\n-   begin\n-      Set_Task_Thread (T, Thread);\n-   end Enter_Task;\n-\n-   ------------------------\n-   -- GNAT_Error_Handler --\n-   ------------------------\n-\n-   procedure GNAT_Error_Handler (Sig : Signal) is\n-      Mask   : aliased sigset_t;\n-      Result : int;\n-\n-   begin\n-      --  This code is the Ada replacement for init.c in the\n-      --  AE653 level B runtime.\n-\n-      --  VxWorks will always mask out the signal during the signal\n-      --  handler and will reenable it on a longjmp.  GNAT does not\n-      --  generate a longjmp to return from a signal handler so the\n-      --  signal will still be masked unless we unmask it.\n-\n-      Result := pthread_sigmask (SIG_SETMASK, null, Mask'Unchecked_Access);\n-      Result := sigdelset (Mask'Access, Sig);\n-      Result := pthread_sigmask (SIG_SETMASK, Mask'Unchecked_Access, null);\n-\n-      case Sig is\n-         when SIGFPE =>\n-            Raise_Exception (Constraint_Error'Identity, \"SIGFPE\");\n-         when SIGILL =>\n-            Raise_Exception (Constraint_Error'Identity, \"SIGILL\");\n-         when SIGSEGV =>\n-            Raise_Exception\n-              (Program_Error'Identity,\n-               \"erroneous memory access\");\n-         when SIGBUS =>\n-            --  SIGBUS indicates stack overflow when it occurs\n-            --  in an application domain (but not in the Core\n-            --  OS under AE653, or in the kernel domain under\n-            --  AE 1.1).\n-            Raise_Exception\n-              (Storage_Error'Identity,\n-               \"stack overflow or SIGBUS\");\n-         when others =>\n-            Raise_Exception (Program_Error'Identity, \"unhandled signal\");\n-      end case;\n-   end GNAT_Error_Handler;\n-\n-   ---------------------\n-   -- Install_Handler --\n-   ---------------------\n-\n-   procedure Install_Handler is\n-      Mask          : aliased sigset_t;\n-      Signal_Action : aliased struct_sigaction;\n-      Result        : Interfaces.C.int;\n-\n-   begin\n-      --  Set up signal handler to map synchronous signals to appropriate\n-      --  exceptions. Make sure that the handler isn't interrupted by\n-      --  another signal that might cause a scheduling event!\n-\n-      --  This code is the Ada replacement for init.c in the\n-      --  AE653 level B runtime.\n-      Signal_Action.sa_handler := GNAT_Error_Handler'Address;\n-      Signal_Action.sa_flags := SA_ONSTACK;\n-      Result := sigemptyset (Mask'Access);\n-      Signal_Action.sa_mask := Mask;\n-\n-      Result := sigaction\n-        (Signal (SIGFPE), Signal_Action'Unchecked_Access, null);\n-\n-      Result := sigaction\n-        (Signal (SIGILL), Signal_Action'Unchecked_Access, null);\n-\n-      Result := sigaction\n-        (Signal (SIGSEGV), Signal_Action'Unchecked_Access, null);\n-\n-      Result := sigaction\n-        (Signal (SIGBUS), Signal_Action'Unchecked_Access, null);\n-\n-   end Install_Handler;\n-\n-   -----------------------------\n-   -- Register_Foreign_Thread --\n-   -----------------------------\n-\n-   Foreign_Task_Elaborated : aliased Boolean := True;\n-\n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID is\n-      pragma Assert (Thread = taskIdSelf or else Is_Valid_Task);\n-      --  Ensure that allocation will work\n-\n-      Local_ATCB : aliased Ada_Task_Control_Block (0);\n-      New_Id    : Task_ID;\n-      Succeeded  : Boolean;\n-\n-      use type Interfaces.C.unsigned;\n-      use type System.Address;\n-      use System.Task_Info;\n-      use System.Task_Primitives.Ae_653;\n-\n-   begin\n-      if taskIdSelf = Thread then\n-         declare\n-            Self : Task_ID := Local_ATCB'Unchecked_Access;\n-            --  Temporarily record this as the Task_ID for the thread\n-\n-         begin\n-            Set_Current_Priority (Self, System.Priority'First);\n-            Set_Task_Thread (Self, Thread);\n-         end;\n-      end if;\n-\n-      pragma Assert (Is_Valid_Task);\n-      --  It is now safe to use an allocator for the real TCB\n-\n-      New_Id := new Ada_Task_Control_Block (0);\n-\n-      --  Finish initialization\n-\n-      System.Tasking.Initialize_ATCB\n-        (New_Id, null, System.Null_Address, Null_Task,\n-         Foreign_Task_Elaborated'Access,\n-         System.Priority'First,\n-         System.Task_Info.Unspecified_Task_Info, 0, New_Id,\n-         Succeeded);\n-      pragma Assert (Succeeded);\n-\n-      New_Id.Master_of_Task := 0;\n-      New_Id.Master_Within := New_Id.Master_of_Task + 1;\n-\n-      for L in New_Id.Entry_Calls'Range loop\n-         New_Id.Entry_Calls (L).Self := New_Id;\n-         New_Id.Entry_Calls (L).Level := L;\n-      end loop;\n-\n-      New_Id.Common.State := Runnable;\n-      New_Id.Awake_Count := 1;\n-\n-      --  Since this is not an ordinary Ada task, we will start out undeferred\n-\n-      New_Id.Deferral_Level := 0;\n-\n-      System.Soft_Links.Create_TSD (New_Id.Common.Compiler_Data);\n-\n-      --  Allocate a fixed secondary stack\n-\n-      pragma Assert\n-        (New_Id.Common.Compiler_Data.Sec_Stack_Addr = System.Null_Address);\n-      System.Secondary_Stack.SS_Init\n-        (New_Id.Common.Compiler_Data.Sec_Stack_Addr);\n-\n-      Enter_Task (New_Id, Thread);\n-\n-      return New_Id;\n-   end Register_Foreign_Thread;\n-\n-   --  Force use of tasking versions of secondary stack routines:\n-\n-   procedure Force_Closure renames\n-     System.Tasking.Initialization.Defer_Abortion;\n-   pragma Unreferenced (Force_Closure);\n-\n---  Package elaboration code\n-\n-begin\n-   --  Register the exported routines with the vThreads ARINC API\n-\n-   procCreateHookAdd (Register_Foreign'Access);\n-   procStartHookAdd (Reset_Foreign'Access);\n-end Interfaces.Vthreads;"}, {"sha": "d4a79757cfef2e461c2185ad8a57dfa52a5d1756", "filename": "gcc/ada/i-vthrea.ads", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fi-vthrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fi-vthrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-vthrea.ads?ref=8738323373326f9d92d2df3eee27989bcee2044b", "patch": "@@ -1,93 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n---                                                                          --\n---                   I N T E R F A C E S . V T H R E A D S                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---       Copyright (C) 2002-2003, Free Software Foundation, Inc.            --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Implement APEX process registration for AE653. The routines exported\n---  by this package are only called from the APEX CREATE and START routines\n---  in the AE653 vThreads API. A context clause for this unit must appear in\n---  the Ada APEX binding.\n---\n---  If this package appears in a context clause for an application that will\n---  be run in a non-AE653 version of VxWorks, or in a non-vThreads AE653\n---  partition, link or load errors for the symbols procCreateHookAdd and\n---  procStartHookAdd will occur, unless these routines are defined\n---  in the application. This is used when simulating AE653 in AE 1.1.\n-\n-with System.OS_Interface;\n-with Interfaces.C;\n-\n-package Interfaces.Vthreads is\n-\n-   function Setup_Thread return System.Address;\n-   --  Register an existing vxWorks task. This routine is used\n-   --  under AE 1.1 when simulating AE 653.\n-\n-   function Install_Signal_Handlers return Interfaces.C.int;\n-   pragma Export (C, Install_Signal_Handlers,\n-                  \"__gnat_install_signal_handlers\");\n-   --  Map the synchronous signals SIGSEGV, SIGFPE, SIGILL and\n-   --  SIGBUS to Ada exceptions for the calling ARINC process.\n-   --  This routine should be called as early as possible in\n-   --  each ARINC process body.\n-   --  C declaration:\n-   --  extern int __gnat_install_signal_handlers ();\n-   --  This call is unnecessary on AE 1.1.\n-\n-private\n-   package OSI renames System.OS_Interface;\n-\n-   function Register_Foreign (T : OSI.Thread_Id) return OSI.STATUS;\n-   --  Create runtime structures necessary for Ada language support for\n-   --  an ARINC process. Called from APEX CREATE routine.\n-\n-   function Reset_Foreign (T : OSI.Thread_Id) return OSI.STATUS;\n-   --  Reset runtime structures upon an AE653 process restart. Called from\n-   --  APEX START routine.\n-\n-   --  When defining the following routines for export in an AE 1.1\n-   --  simulation of AE653, Interfaces.C.int may be used for the\n-   --  parameters of FUNCPTR.\n-   type FUNCPTR is access function (T : OSI.Thread_Id) return OSI.STATUS;\n-\n-   --------------------------------\n-   -- Imported vThreads Routines --\n-   --------------------------------\n-\n-   procedure procCreateHookAdd (createHookFunction : FUNCPTR);\n-   pragma Import (C, procCreateHookAdd, \"procCreateHookAdd\");\n-   --  Registers task registration routine for AE653\n-\n-   procedure procStartHookAdd (StartHookFunction : FUNCPTR);\n-   pragma Import (C, procStartHookAdd, \"procStartHookAdd\");\n-   --  Registers task restart routine for AE653\n-\n-end Interfaces.Vthreads;"}, {"sha": "82eaeb6301d6b36b372ba8d44eb13c2e6983a8bc", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -587,7 +587,7 @@ package Lib is\n    --  function returns True if the given generic unit entity E is for a\n    --  generic unit that should be separately compiled, and false otherwise.\n    --\n-   --  Now GNAT can compile any generic unit including predefifined ones, but\n+   --  Now GNAT can compile any generic unit including predefined ones, but\n    --  because of the backward compatibility (to keep the ability to use old\n    --  compiler versions to build GNAT) compiling library generics is an\n    --  option. That is, now GNAT compiles a library generic as an ordinary"}, {"sha": "838738c9bd94691b311011fe1e3265db7a4c1482", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -1167,6 +1167,20 @@ package body Ch4 is\n             end if;\n          end if;\n \n+         --  Ada0Y (AI-287): The box notation is allowed only with named\n+         --  notation because positional notation might be error prone. For\n+         --  example, in \"(X, <>, Y, <>)\", there is no type associated with\n+         --  the boxes, so you might not be leaving out the components you\n+         --  thought you were leaving out.\n+\n+         if Extensions_Allowed and then Token = Tok_Box then\n+            Error_Msg_SC (\"(Ada 0Y) box notation only allowed with \"\n+                          & \"named notation\");\n+            Scan; --  past BOX\n+            Aggregate_Node := New_Node (N_Aggregate, Lparen_Sloc);\n+            return Aggregate_Node;\n+         end if;\n+\n          Expr_Node := P_Expression_Or_Range_Attribute;\n \n          --  Extension aggregate case\n@@ -1390,9 +1404,13 @@ package body Ch4 is\n       TF_Arrow;\n \n       if Token = Tok_Box then\n+\n+         --  Ada0Y (AI-287): The box notation is used to indicate the default\n+         --  initialization of limited aggregate components\n+\n          if not Extensions_Allowed then\n             Error_Msg_SP\n-              (\"Limited aggregates are an Ada0X extension\");\n+              (\"(Ada 0Y) limited aggregates are an Ada0X extension\");\n \n             if OpenVMS then\n                Error_Msg_SP"}, {"sha": "ac39eeda369a21316120d6c020dc02c623bb4caa", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -125,6 +125,7 @@ package body Prj.Dect is\n    begin\n       Attribute := Default_Project_Node (Of_Kind => N_Attribute_Declaration);\n       Set_Location_Of (Attribute, To => Token_Ptr);\n+      Set_Previous_Line_Node (Attribute);\n \n       --  Scan past \"for\"\n \n@@ -467,6 +468,9 @@ package body Prj.Dect is\n       if Current_Attribute = Empty_Attribute then\n          Attribute := Empty_Node;\n       end if;\n+\n+      Set_End_Of_Line (Attribute);\n+      Set_Previous_Line_Node (Attribute);\n    end Parse_Attribute_Declaration;\n \n    -----------------------------\n@@ -535,6 +539,9 @@ package body Prj.Dect is\n       Expect (Tok_Is, \"IS\");\n \n       if Token = Tok_Is then\n+         Set_End_Of_Line (Case_Construction);\n+         Set_Previous_Line_Node (Case_Construction);\n+         Set_Next_End_Node (Case_Construction);\n \n          --  Scan past \"is\"\n \n@@ -571,6 +578,8 @@ package body Prj.Dect is\n             Scan;\n \n             Expect (Tok_Arrow, \"`=>`\");\n+            Set_End_Of_Line (Current_Item);\n+            Set_Previous_Line_Node (Current_Item);\n \n             --  Empty_Node in Field1 of a Case_Item indicates\n             --  the \"when others =>\" branch.\n@@ -596,6 +605,8 @@ package body Prj.Dect is\n             Set_First_Choice_Of (Current_Item, To => First_Choice);\n \n             Expect (Tok_Arrow, \"`=>`\");\n+            Set_End_Of_Line (Current_Item);\n+            Set_Previous_Line_Node (Current_Item);\n \n             Parse_Declarative_Items\n               (Declarations    => First_Declarative_Item,\n@@ -613,6 +624,7 @@ package body Prj.Dect is\n       End_Case_Construction;\n \n       Expect (Tok_End, \"`END CASE`\");\n+      Remove_Next_End_Node;\n \n       if Token = Tok_End then\n \n@@ -629,6 +641,7 @@ package body Prj.Dect is\n       Scan;\n \n       Expect (Tok_Semicolon, \"`;`\");\n+      Set_Previous_End_Node (Case_Construction);\n \n    end Parse_Case_Construction;\n \n@@ -673,6 +686,9 @@ package body Prj.Dect is\n                   Current_Project => Current_Project,\n                   Current_Package => Current_Package);\n \n+               Set_End_Of_Line (Current_Declaration);\n+               Set_Previous_Line_Node (Current_Declaration);\n+\n             when Tok_For =>\n \n                Parse_Attribute_Declaration\n@@ -681,6 +697,9 @@ package body Prj.Dect is\n                   Current_Project => Current_Project,\n                   Current_Package => Current_Package);\n \n+               Set_End_Of_Line (Current_Declaration);\n+               Set_Previous_Line_Node (Current_Declaration);\n+\n             when Tok_Package =>\n \n                --  Package declaration\n@@ -693,6 +712,8 @@ package body Prj.Dect is\n                  (Package_Declaration => Current_Declaration,\n                   Current_Project     => Current_Project);\n \n+               Set_Previous_End_Node (Current_Declaration);\n+\n             when Tok_Type =>\n \n                --  Type String Declaration\n@@ -706,6 +727,9 @@ package body Prj.Dect is\n                  (String_Type     => Current_Declaration,\n                   Current_Project => Current_Project);\n \n+               Set_End_Of_Line (Current_Declaration);\n+               Set_Previous_Line_Node (Current_Declaration);\n+\n             when Tok_Case =>\n \n                --  Case construction\n@@ -716,6 +740,8 @@ package body Prj.Dect is\n                   Current_Project   => Current_Project,\n                   Current_Package   => Current_Package);\n \n+               Set_Previous_End_Node (Current_Declaration);\n+\n             when others =>\n                exit;\n \n@@ -928,8 +954,13 @@ package body Prj.Dect is\n          end if;\n \n          Expect (Tok_Semicolon, \"`;`\");\n+         Set_End_Of_Line (Package_Declaration);\n+         Set_Previous_Line_Node (Package_Declaration);\n \n       elsif Token = Tok_Is then\n+         Set_End_Of_Line (Package_Declaration);\n+         Set_Previous_Line_Node (Package_Declaration);\n+         Set_Next_End_Node (Package_Declaration);\n \n          Parse_Declarative_Items\n            (Declarations    => First_Declarative_Item,\n@@ -970,6 +1001,7 @@ package body Prj.Dect is\n          end if;\n \n          Expect (Tok_Semicolon, \"`;`\");\n+         Remove_Next_End_Node;\n \n       else\n          Error_Msg (\"expected IS or RENAMES\", Token_Ptr);"}, {"sha": "1aa4725e46ca6ac82518412c05843c90fb82b9be", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -81,6 +81,7 @@ package body Prj.Part is\n       Path         : Name_Id;\n       Location     : Source_Ptr;\n       Limited_With : Boolean;\n+      Node         : Project_Node_Id;\n       Next         : With_Id;\n    end record;\n    --  Information about an imported project, to be put in table Withs below\n@@ -426,7 +427,8 @@ package body Prj.Part is\n      (Project                : out Project_Node_Id;\n       Project_File_Name      : String;\n       Always_Errout_Finalize : Boolean;\n-      Packages_To_Check      : String_List_Access := All_Packages)\n+      Packages_To_Check      : String_List_Access := All_Packages;\n+      Store_Comments         : Boolean := False)\n    is\n       Current_Directory : constant String := Get_Current_Dir;\n \n@@ -451,6 +453,8 @@ package body Prj.Part is\n \n       begin\n          Prj.Err.Initialize;\n+         Prj.Err.Scanner.Set_Comment_As_Token (Store_Comments);\n+         Prj.Err.Scanner.Set_End_Of_Line_As_Token (Store_Comments);\n \n          --  Parse the main project file\n \n@@ -578,6 +582,8 @@ package body Prj.Part is\n \n       Current_With : With_Record;\n \n+      Current_With_Node : Project_Node_Id := Empty_Node;\n+\n    begin\n       --  Assume no context clause\n \n@@ -588,6 +594,7 @@ package body Prj.Part is\n       --  or we have exhausted the with clauses.\n \n       while Token = Tok_With or else Token = Tok_Limited loop\n+         Current_With_Node := Default_Project_Node (Of_Kind => N_With_Clause);\n          Limited_With := Token = Tok_Limited;\n \n          if Limited_With then\n@@ -612,6 +619,7 @@ package body Prj.Part is\n               (Path         => Token_Name,\n                Location     => Token_Ptr,\n                Limited_With => Limited_With,\n+               Node         => Current_With_Node,\n                Next         => No_With);\n \n             Withs.Increment_Last;\n@@ -629,6 +637,8 @@ package body Prj.Part is\n             Scan;\n \n             if Token = Tok_Semicolon then\n+               Set_End_Of_Line (Current_With_Node);\n+               Set_Previous_Line_Node (Current_With_Node);\n \n                --  End of (possibly multiple) with clause;\n \n@@ -639,6 +649,9 @@ package body Prj.Part is\n                Error_Msg (\"expected comma or semi colon\", Token_Ptr);\n                exit Comma_Loop;\n             end if;\n+\n+            Current_With_Node :=\n+              Default_Project_Node (Of_Kind => N_With_Clause);\n          end loop Comma_Loop;\n       end loop With_Loop;\n    end Pre_Parse_Context_Clause;\n@@ -714,13 +727,11 @@ package body Prj.Part is\n \n                   --  First with clause of the context clause\n \n-                  Current_Project := Default_Project_Node\n-                                           (Of_Kind => N_With_Clause);\n+                  Current_Project := Current_With.Node;\n                   Imported_Projects := Current_Project;\n \n                else\n-                  Next_Project := Default_Project_Node\n-                                        (Of_Kind => N_With_Clause);\n+                  Next_Project := Current_With.Node;\n                   Set_Next_With_Clause_Of (Current_Project, Next_Project);\n                   Current_Project := Next_Project;\n                end if;\n@@ -829,6 +840,8 @@ package body Prj.Part is\n \n       use Tree_Private_Part;\n \n+      Project_Comment_State : Tree.Comment_State;\n+\n    begin\n       declare\n          Normed : String := Normalize_Pathname (Path_Name);\n@@ -868,6 +881,8 @@ package body Prj.Part is\n          end if;\n       end loop;\n \n+      --  Put the new path name on the stack\n+\n       Project_Stack.Increment_Last;\n       Project_Stack.Table (Project_Stack.Last).Name := Canonical_Path_Name;\n \n@@ -933,6 +948,7 @@ package body Prj.Part is\n \n       Save_Project_Scan_State (Project_Scan_State);\n       Source_Index := Load_Project_File (Path_Name);\n+      Tree.Save (Project_Comment_State);\n \n       --  if we cannot find it, we stop\n \n@@ -943,6 +959,7 @@ package body Prj.Part is\n       end if;\n \n       Prj.Err.Scanner.Initialize_Scanner (Types.No_Unit, Source_Index);\n+      Tree.Reset_State;\n       Scan;\n \n       if Name_From_Path = No_Name then\n@@ -962,17 +979,17 @@ package body Prj.Part is\n          Write_Eol;\n       end if;\n \n+      --  Is there any imported project?\n+\n+      Pre_Parse_Context_Clause (First_With);\n+\n       Project_Directory := Immediate_Directory_Of (Normed_Path_Name);\n       Project := Default_Project_Node (Of_Kind => N_Project);\n       Project_Stack.Table (Project_Stack.Last).Id := Project;\n       Set_Directory_Of (Project, Project_Directory);\n       Set_Path_Name_Of (Project, Normed_Path_Name);\n       Set_Location_Of (Project, Token_Ptr);\n \n-      --  Is there any imported project?\n-\n-      Pre_Parse_Context_Clause (First_With);\n-\n       Expect (Tok_Project, \"PROJECT\");\n \n       --  Mark location of PROJECT token if present\n@@ -1276,6 +1293,9 @@ package body Prj.Part is\n       end if;\n \n       Expect (Tok_Is, \"IS\");\n+      Set_End_Of_Line (Project);\n+      Set_Previous_Line_Node (Project);\n+      Set_Next_End_Node (Project);\n \n       declare\n          Project_Declaration : Project_Node_Id := Empty_Node;\n@@ -1296,6 +1316,7 @@ package body Prj.Part is\n       end;\n \n       Expect (Tok_End, \"END\");\n+      Remove_Next_End_Node;\n \n       --  Skip \"end\" if present\n \n@@ -1353,6 +1374,7 @@ package body Prj.Part is\n       --  source.\n \n       if Token = Tok_Semicolon then\n+         Set_Previous_End_Node (Project);\n          Scan;\n \n          if Token /= Tok_EOF then\n@@ -1368,6 +1390,15 @@ package body Prj.Part is\n       --  And remove the project from the project stack\n \n       Project_Stack.Decrement_Last;\n+\n+      --  Indicate if there are unkept comments\n+\n+      Tree.Set_Project_File_Includes_Unkept_Comments\n+        (Node => Project, To => Tree.There_Are_Unkept_Comments);\n+\n+      --  And restore the comment state that was saved\n+\n+      Tree.Restore (Project_Comment_State);\n    end Parse_Single_Project;\n \n    -----------------------"}, {"sha": "5b8f3921928466c186da60feb0f168cec9761449", "filename": "gcc/ada/prj-part.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-part.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-part.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -34,13 +34,15 @@ package Prj.Part is\n      (Project                : out Project_Node_Id;\n       Project_File_Name      : String;\n       Always_Errout_Finalize : Boolean;\n-      Packages_To_Check      : String_List_Access := All_Packages);\n+      Packages_To_Check      : String_List_Access := All_Packages;\n+      Store_Comments         : Boolean := False);\n    --  Parse project file and all its imported project files and create a tree.\n    --  Return the node for the project (or Empty_Node if parsing failed). If\n    --  Always_Errout_Finalize is True, Errout.Finalize is called in all cases,\n    --  Otherwise, Errout.Finalize is only called if there are errors (but not\n    --  if there are only warnings). Packages_To_Check indicates the packages\n    --  where any unknown attribute produces an error. For other packages, an\n-   --  unknown attribute produces a warning.\n+   --  unknown attribute produces a warning. When Store_Comments is True,\n+   --  comments are stored in the parse tree.\n \n end Prj.Part;"}, {"sha": "1ac45ed28e3379ba5438618c16238c7039ecf0b3", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 110, "deletions": 23, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -27,8 +27,8 @@\n with Ada.Characters.Handling; use Ada.Characters.Handling;\n \n with Hostparm;\n-with Namet;     use Namet;\n-with Output;    use Output;\n+with Namet;    use Namet;\n+with Output;   use Output;\n with Snames;\n \n package body Prj.PP is\n@@ -47,7 +47,6 @@ package body Prj.PP is\n    procedure Indicate_Tested (Kind : Project_Node_Kind);\n    --  Set the corresponding component of array Not_Tested to False.\n    --  Only called by pragmas Debug.\n-   --\n \n    ---------------------\n    -- Indicate_Tested --\n@@ -98,9 +97,13 @@ package body Prj.PP is\n       procedure Write_Line (S : String);\n       --  Outputs S followed by a new line\n \n-      procedure Write_String (S : String);\n+      procedure Write_String (S : String; Truncated : Boolean := False);\n       --  Outputs S using Write_Str, starting a new line if line would\n-      --  become too long.\n+      --  become too long, when Truncated = False.\n+      --  When Truncated = True, only the part of the string that can fit on\n+      --  the line is output.\n+\n+      procedure Write_End_Of_Line_Comment (Node : Project_Node_Id);\n \n       Write_Char : Write_Char_Ap := Output.Write_Char'Access;\n       Write_Eol  : Write_Eol_Ap  := Output.Write_Eol'Access;\n@@ -246,6 +249,21 @@ package body Prj.PP is\n          end if;\n       end Write_Empty_Line;\n \n+      -------------------------------\n+      -- Write_End_Of_Line_Comment --\n+      -------------------------------\n+\n+      procedure Write_End_Of_Line_Comment (Node : Project_Node_Id) is\n+         Value : Name_Id := End_Of_Line_Comment (Node);\n+      begin\n+         if Value /= No_Name then\n+            Write_String (\" --\");\n+            Write_String (Get_Name_String (Value), Truncated => True);\n+         end if;\n+\n+         Write_Line (\"\");\n+      end Write_End_Of_Line_Comment;\n+\n       ----------------\n       -- Write_Line --\n       ----------------\n@@ -262,18 +280,24 @@ package body Prj.PP is\n       -- Write_String --\n       ------------------\n \n-      procedure Write_String (S : String) is\n+      procedure Write_String (S : String; Truncated : Boolean := False) is\n+         Length : Natural := S'Length;\n       begin\n          --  If the string would not fit on the line,\n          --  start a new line.\n \n-         if Column + S'Length > Max_Line_Length then\n-            Write_Eol.all;\n-            Column := 0;\n+         if Column + Length > Max_Line_Length then\n+            if Truncated then\n+               Length := Max_Line_Length - Column;\n+\n+            else\n+               Write_Eol.all;\n+               Column := 0;\n+            end if;\n          end if;\n \n-         Write_Str (S);\n-         Column := Column + S'Length;\n+         Write_Str (S (S'First .. S'First + Length - 1));\n+         Column := Column + Length;\n       end Write_String;\n \n       -----------\n@@ -296,6 +320,7 @@ package body Prj.PP is\n                      Write_Empty_Line (Always => True);\n                   end if;\n \n+                  Print (First_Comment_Before (Node), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"project \");\n                   Output_Name (Name_Of (Node));\n@@ -307,21 +332,26 @@ package body Prj.PP is\n                      Output_String (Extended_Project_Path_Of (Node));\n                   end if;\n \n-                  Write_Line (\" is\");\n+                  Write_String (\" is\");\n+                  Write_End_Of_Line_Comment (Node);\n+                  Print (First_Comment_After (Node), Indent + Increment);\n                   Write_Empty_Line (Always => True);\n \n                   --  Output all of the declarations in the project\n \n                   Print (Project_Declaration_Of (Node), Indent);\n+                  Print (First_Comment_Before_End (Node), Indent + Increment);\n                   Start_Line (Indent);\n                   Write_String (\"end \");\n                   Output_Name (Name_Of (Node));\n                   Write_Line (\";\");\n+                  Print (First_Comment_After_End (Node), Indent);\n \n                when N_With_Clause =>\n                   pragma Debug (Indicate_Tested (N_With_Clause));\n \n                   if Name_Of (Node) /= No_Name then\n+                     Print (First_Comment_Before (Node), Indent);\n                      Start_Line (Indent);\n \n                      if Non_Limited_Project_Node_Of (Node) = Empty_Node then\n@@ -330,7 +360,9 @@ package body Prj.PP is\n \n                      Write_String (\"with \");\n                      Output_String (String_Value_Of (Node));\n-                     Write_Line (\";\");\n+                     Write_String (\";\");\n+                     Write_End_Of_Line_Comment (Node);\n+                     Print (First_Comment_After (Node), Indent);\n                   end if;\n \n                   Print (Next_With_Clause_Of (Node), Indent);\n@@ -352,6 +384,7 @@ package body Prj.PP is\n                when N_Package_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Package_Declaration));\n                   Write_Empty_Line (Always => True);\n+                  Print (First_Comment_Before (Node), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"package \");\n                   Output_Name (Name_Of (Node));\n@@ -362,26 +395,34 @@ package body Prj.PP is\n                        (Name_Of (Project_Of_Renamed_Package_Of (Node)));\n                      Write_String (\".\");\n                      Output_Name (Name_Of (Node));\n-                     Write_Line (\";\");\n+                     Write_String (\";\");\n+                     Write_End_Of_Line_Comment (Node);\n+                     Print (First_Comment_After_End (Node), Indent);\n \n                   else\n-                     Write_Line (\" is\");\n+                     Write_String (\" is\");\n+                     Write_End_Of_Line_Comment (Node);\n+                     Print (First_Comment_After (Node), Indent + Increment);\n \n                      if First_Declarative_Item_Of (Node) /= Empty_Node then\n                         Print\n                           (First_Declarative_Item_Of (Node),\n                            Indent + Increment);\n                      end if;\n \n+                     Print (First_Comment_Before_End (Node),\n+                            Indent + Increment);\n                      Start_Line (Indent);\n                      Write_String (\"end \");\n                      Output_Name (Name_Of (Node));\n                      Write_Line (\";\");\n+                     Print (First_Comment_After_End (Node), Indent);\n                      Write_Empty_Line;\n                   end if;\n \n                when N_String_Type_Declaration =>\n                   pragma Debug (Indicate_Tested (N_String_Type_Declaration));\n+                  Print (First_Comment_Before (Node), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"type \");\n                   Output_Name (Name_Of (Node));\n@@ -404,14 +445,17 @@ package body Prj.PP is\n                      end loop;\n                   end;\n \n-                  Write_Line (\");\");\n+                  Write_String (\");\");\n+                  Write_End_Of_Line_Comment (Node);\n+                  Print (First_Comment_After (Node), Indent);\n \n                when N_Literal_String =>\n                   pragma Debug (Indicate_Tested (N_Literal_String));\n                   Output_String (String_Value_Of (Node));\n \n                when N_Attribute_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Attribute_Declaration));\n+                  Print (First_Comment_Before (Node), Indent);\n                   Start_Line (Indent);\n                   Write_String (\"for \");\n                   Output_Attribute_Name (Name_Of (Node));\n@@ -424,26 +468,34 @@ package body Prj.PP is\n \n                   Write_String (\" use \");\n                   Print (Expression_Of (Node), Indent);\n-                  Write_Line (\";\");\n+                  Write_String (\";\");\n+                  Write_End_Of_Line_Comment (Node);\n+                  Print (First_Comment_After (Node), Indent);\n \n                when N_Typed_Variable_Declaration =>\n                   pragma Debug\n                     (Indicate_Tested (N_Typed_Variable_Declaration));\n+                  Print (First_Comment_Before (Node), Indent);\n                   Start_Line (Indent);\n                   Output_Name (Name_Of (Node));\n                   Write_String (\" : \");\n                   Output_Name (Name_Of (String_Type_Of (Node)));\n                   Write_String (\" := \");\n                   Print (Expression_Of (Node), Indent);\n-                  Write_Line (\";\");\n+                  Write_String (\";\");\n+                  Write_End_Of_Line_Comment (Node);\n+                  Print (First_Comment_After (Node), Indent);\n \n                when N_Variable_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Variable_Declaration));\n+                  Print (First_Comment_Before (Node), Indent);\n                   Start_Line (Indent);\n                   Output_Name (Name_Of (Node));\n                   Write_String (\" := \");\n                   Print (Expression_Of (Node), Indent);\n-                  Write_Line (\";\");\n+                  Write_String (\";\");\n+                  Write_End_Of_Line_Comment (Node);\n+                  Print (First_Comment_After (Node), Indent);\n \n                when N_Expression =>\n                   pragma Debug (Indicate_Tested (N_Expression));\n@@ -566,10 +618,13 @@ package body Prj.PP is\n \n                      if Is_Non_Empty then\n                         Write_Empty_Line;\n+                        Print (First_Comment_Before (Node), Indent);\n                         Start_Line (Indent);\n                         Write_String (\"case \");\n                         Print (Case_Variable_Reference_Of (Node), Indent);\n-                        Write_Line (\" is\");\n+                        Write_String (\" is\");\n+                        Write_End_Of_Line_Comment (Node);\n+                        Print (First_Comment_After (Node), Indent + Increment);\n \n                         declare\n                            Case_Item : Project_Node_Id :=\n@@ -584,8 +639,11 @@ package body Prj.PP is\n                            end loop;\n                         end;\n \n+                        Print (First_Comment_Before_End (Node),\n+                               Indent + Increment);\n                         Start_Line (Indent);\n                         Write_Line (\"end case;\");\n+                        Print (First_Comment_After_End (Node), Indent);\n                      end if;\n                   end;\n \n@@ -596,6 +654,7 @@ package body Prj.PP is\n                     or else not Eliminate_Empty_Case_Constructions\n                   then\n                      Write_Empty_Line;\n+                     Print (First_Comment_Before (Node), Indent);\n                      Start_Line (Indent);\n                      Write_String (\"when \");\n \n@@ -618,21 +677,49 @@ package body Prj.PP is\n                         end;\n                      end if;\n \n-                     Write_Line (\" =>\");\n+                     Write_String (\" =>\");\n+                     Write_End_Of_Line_Comment (Node);\n+                     Print (First_Comment_After (Node), Indent + Increment);\n \n                      declare\n                         First : constant Project_Node_Id :=\n                                   First_Declarative_Item_Of (Node);\n \n                      begin\n                         if First = Empty_Node then\n-                           Write_Eol.all;\n+                           Write_Empty_Line;\n \n                         else\n                            Print (First, Indent + Increment);\n                         end if;\n                      end;\n                   end if;\n+\n+               when N_Comment_Zones =>\n+\n+               --  Nothing to do, because it will not be processed directly\n+\n+                  null;\n+\n+               when N_Comment =>\n+                  pragma Debug (Indicate_Tested (N_Comment));\n+\n+                  if Follows_Empty_Line (Node) then\n+                     Write_Empty_Line;\n+                  end if;\n+\n+                  Start_Line (Indent);\n+                  Write_String (\"--\");\n+                  Write_String\n+                    (Get_Name_String (String_Value_Of (Node)),\n+                     Truncated => True);\n+                  Write_Line (\"\");\n+\n+                  if Is_Followed_By_Empty_Line (Node) then\n+                     Write_Empty_Line;\n+                  end if;\n+\n+                  Print (Next_Comment (Node), Indent);\n             end case;\n          end if;\n       end Print;\n@@ -674,7 +761,7 @@ package body Prj.PP is\n       Output.Write_Line (\"Project_Node_Kinds not tested:\");\n \n       for Kind in Project_Node_Kind loop\n-         if Not_Tested (Kind) then\n+         if Kind /= N_Comment_Zones and then Not_Tested (Kind) then\n             Output.Write_Str (\"   \");\n             Output.Write_Line (Project_Node_Kind'Image (Kind));\n          end if;"}, {"sha": "7e548e8ce2e63c4330897564d02d51f431c63fae", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 853, "deletions": 107, "changes": 960, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -24,17 +24,193 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Prj.Err;\n+\n package body Prj.Tree is\n \n+   Node_With_Comments : constant array (Project_Node_Kind) of Boolean :=\n+     (N_Project                    => True,\n+      N_With_Clause                => True,\n+      N_Project_Declaration        => False,\n+      N_Declarative_Item           => False,\n+      N_Package_Declaration        => True,\n+      N_String_Type_Declaration    => True,\n+      N_Literal_String             => False,\n+      N_Attribute_Declaration      => True,\n+      N_Typed_Variable_Declaration => True,\n+      N_Variable_Declaration       => True,\n+      N_Expression                 => False,\n+      N_Term                       => False,\n+      N_Literal_String_List        => False,\n+      N_Variable_Reference         => False,\n+      N_External_Value             => False,\n+      N_Attribute_Reference        => False,\n+      N_Case_Construction          => True,\n+      N_Case_Item                  => True,\n+      N_Comment_Zones              => True,\n+      N_Comment                    => True);\n+   --  Indicates the kinds of node that may have associated comments\n+\n+   package Next_End_Nodes is new Table.Table\n+     (Table_Component_Type => Project_Node_Id,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Next_End_Nodes\");\n+   --  A stack of nodes to indicates to what node the next \"end\" is associated\n+\n    use Tree_Private_Part;\n \n+   End_Of_Line_Node   : Project_Node_Id := Empty_Node;\n+   --  The node an end of line comment may be associated with\n+\n+   Previous_Line_Node : Project_Node_Id := Empty_Node;\n+   --  The node an immediately following comment may be associated with\n+\n+   Previous_End_Node  : Project_Node_Id := Empty_Node;\n+   --  The node comments immediately following an \"end\" line may be\n+   --  associated with.\n+\n+   Unkept_Comments    : Boolean := False;\n+   --  Set to True when some comments may not be associated with any node\n+\n+   function Comment_Zones_Of\n+     (Node : Project_Node_Id) return Project_Node_Id;\n+   --  Returns the ID of the N_Comment_Zones node associated with node Node.\n+   --  If there is not already an N_Comment_Zones node, create one and\n+   --  associate it with node Node.\n+\n+   ------------------\n+   -- Add_Comments --\n+   ------------------\n+\n+   procedure Add_Comments (To : Project_Node_Id; Where : Comment_Location) is\n+      Zone     : Project_Node_Id := Empty_Node;\n+      Previous : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      pragma Assert\n+        (To /= Empty_Node\n+          and then\n+         Project_Nodes.Table (To).Kind /= N_Comment);\n+\n+      Zone := Project_Nodes.Table (To).Comments;\n+\n+      if Zone = Empty_Node then\n+\n+         --  Create new N_Comment_Zones node\n+\n+         Project_Nodes.Increment_Last;\n+         Project_Nodes.Table (Project_Nodes.Last) :=\n+           (Kind             => N_Comment_Zones,\n+            Expr_Kind        => Undefined,\n+            Location         => No_Location,\n+            Directory        => No_Name,\n+            Variables        => Empty_Node,\n+            Packages         => Empty_Node,\n+            Pkg_Id           => Empty_Package,\n+            Name             => No_Name,\n+            Path_Name        => No_Name,\n+            Value            => No_Name,\n+            Field1           => Empty_Node,\n+            Field2           => Empty_Node,\n+            Field3           => Empty_Node,\n+            Flag1            => False,\n+            Flag2            => False,\n+            Comments         => Empty_Node);\n+\n+         Zone := Project_Nodes.Last;\n+         Project_Nodes.Table (To).Comments := Zone;\n+      end if;\n+\n+      if Where = End_Of_Line then\n+         Project_Nodes.Table (Zone).Value := Comments.Table (1).Value;\n+\n+      else\n+         --  Get each comments in the Comments table and link them to node To\n+\n+         for J in 1 .. Comments.Last loop\n+\n+            --  Create new N_Comment node\n+\n+            if (Where = After or else Where = After_End) and then\n+              Token /= Tok_EOF and then\n+              Comments.Table (J).Follows_Empty_Line\n+            then\n+               Comments.Table (1 .. Comments.Last - J + 1) :=\n+                 Comments.Table (J .. Comments.Last);\n+               Comments.Set_Last (Comments.Last - J + 1);\n+               return;\n+            end if;\n+\n+            Project_Nodes.Increment_Last;\n+            Project_Nodes.Table (Project_Nodes.Last) :=\n+              (Kind             => N_Comment,\n+               Expr_Kind        => Undefined,\n+               Flag1            => Comments.Table (J).Follows_Empty_Line,\n+               Flag2            =>\n+                 Comments.Table (J).Is_Followed_By_Empty_Line,\n+               Location         => No_Location,\n+               Directory        => No_Name,\n+               Variables        => Empty_Node,\n+               Packages         => Empty_Node,\n+               Pkg_Id           => Empty_Package,\n+               Name             => No_Name,\n+               Path_Name        => No_Name,\n+               Value            => Comments.Table (J).Value,\n+               Field1           => Empty_Node,\n+               Field2           => Empty_Node,\n+               Field3           => Empty_Node,\n+               Comments         => Empty_Node);\n+\n+            --  If this is the first comment, put it in the right field of\n+            --  the node Zone.\n+\n+            if Previous = Empty_Node then\n+               case Where is\n+                  when Before =>\n+                     Project_Nodes.Table (Zone).Field1 := Project_Nodes.Last;\n+\n+                  when After =>\n+                     Project_Nodes.Table (Zone).Field2 := Project_Nodes.Last;\n+\n+                  when Before_End =>\n+                     Project_Nodes.Table (Zone).Field3 := Project_Nodes.Last;\n+\n+                  when After_End =>\n+                     Project_Nodes.Table (Zone).Comments := Project_Nodes.Last;\n+\n+                  when End_Of_Line =>\n+                     null;\n+               end case;\n+\n+            else\n+               --  When it is not the first, link it to the previous one\n+\n+               Project_Nodes.Table (Previous).Comments := Project_Nodes.Last;\n+            end if;\n+\n+            --  This node becomes the previous one for the next comment, if\n+            --  there is one.\n+\n+            Previous := Project_Nodes.Last;\n+         end loop;\n+      end if;\n+\n+      --  Empty the Comments table, so that there is no risk to link the same\n+      --  comments to another node.\n+\n+      Comments.Set_Last (0);\n+   end Add_Comments;\n+\n+\n    --------------------------------\n    -- Associative_Array_Index_Of --\n    --------------------------------\n \n    function Associative_Array_Index_Of\n-     (Node : Project_Node_Id)\n-      return Name_Id\n+     (Node : Project_Node_Id) return Name_Id\n    is\n    begin\n       pragma Assert\n@@ -51,8 +227,7 @@ package body Prj.Tree is\n    ----------------------------\n \n    function Associative_Package_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -67,8 +242,7 @@ package body Prj.Tree is\n    ----------------------------\n \n    function Associative_Project_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -90,16 +264,15 @@ package body Prj.Tree is\n             (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n              Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      return Project_Nodes.Table (Node).Case_Insensitive;\n+      return Project_Nodes.Table (Node).Flag1;\n    end Case_Insensitive;\n \n    --------------------------------\n    -- Case_Variable_Reference_Of --\n    --------------------------------\n \n    function Case_Variable_Reference_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -109,13 +282,54 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Field1;\n    end Case_Variable_Reference_Of;\n \n+   ----------------------\n+   -- Comment_Zones_Of --\n+   ----------------------\n+\n+   function Comment_Zones_Of\n+     (Node : Project_Node_Id) return Project_Node_Id\n+   is\n+      Zone : Project_Node_Id;\n+\n+   begin\n+      pragma Assert (Node /= Empty_Node);\n+      Zone := Project_Nodes.Table (Node).Comments;\n+\n+      --  If there is not already an N_Comment_Zones associated, create a new\n+      --  one and associate it with node Node.\n+\n+      if Zone = Empty_Node then\n+         Project_Nodes.Increment_Last;\n+         Zone := Project_Nodes.Last;\n+         Project_Nodes.Table (Zone) :=\n+        (Kind             => N_Comment_Zones,\n+         Location         => No_Location,\n+         Directory        => No_Name,\n+         Expr_Kind        => Undefined,\n+         Variables        => Empty_Node,\n+         Packages         => Empty_Node,\n+         Pkg_Id           => Empty_Package,\n+         Name             => No_Name,\n+         Path_Name        => No_Name,\n+         Value            => No_Name,\n+         Field1           => Empty_Node,\n+         Field2           => Empty_Node,\n+         Field3           => Empty_Node,\n+         Flag1            => False,\n+         Flag2            => False,\n+         Comments         => Empty_Node);\n+         Project_Nodes.Table (Node).Comments := Zone;\n+      end if;\n+\n+      return Zone;\n+   end Comment_Zones_Of;\n+\n    -----------------------\n    -- Current_Item_Node --\n    -----------------------\n \n    function Current_Item_Node\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -130,8 +344,7 @@ package body Prj.Tree is\n    ------------------\n \n    function Current_Term\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -147,28 +360,118 @@ package body Prj.Tree is\n \n    function Default_Project_Node\n      (Of_Kind       : Project_Node_Kind;\n-      And_Expr_Kind : Variable_Kind := Undefined)\n-      return          Project_Node_Id\n+      And_Expr_Kind : Variable_Kind := Undefined) return Project_Node_Id\n    is\n+      Result   : Project_Node_Id;\n+      Zone     : Project_Node_Id;\n+      Previous : Project_Node_Id;\n+\n    begin\n+      --  Create new node with specified kind and expression kind\n+\n       Project_Nodes.Increment_Last;\n       Project_Nodes.Table (Project_Nodes.Last) :=\n-           (Kind             => Of_Kind,\n-            Location         => No_Location,\n-            Directory        => No_Name,\n-            Expr_Kind        => And_Expr_Kind,\n-            Variables        => Empty_Node,\n-            Packages         => Empty_Node,\n-            Pkg_Id           => Empty_Package,\n-            Name             => No_Name,\n-            Path_Name        => No_Name,\n-            Value            => No_Name,\n-            Field1           => Empty_Node,\n-            Field2           => Empty_Node,\n-            Field3           => Empty_Node,\n-            Case_Insensitive => False,\n-            Extending_All    => False);\n-      return Project_Nodes.Last;\n+        (Kind             => Of_Kind,\n+         Location         => No_Location,\n+         Directory        => No_Name,\n+         Expr_Kind        => And_Expr_Kind,\n+         Variables        => Empty_Node,\n+         Packages         => Empty_Node,\n+         Pkg_Id           => Empty_Package,\n+         Name             => No_Name,\n+         Path_Name        => No_Name,\n+         Value            => No_Name,\n+         Field1           => Empty_Node,\n+         Field2           => Empty_Node,\n+         Field3           => Empty_Node,\n+         Flag1            => False,\n+         Flag2            => False,\n+         Comments         => Empty_Node);\n+\n+      --  Save the new node for the returned value\n+\n+      Result := Project_Nodes.Last;\n+\n+      if Comments.Last > 0 then\n+\n+         --  If this is not a node with comments, then set the flag\n+\n+         if not Node_With_Comments (Of_Kind) then\n+            Unkept_Comments := True;\n+\n+         elsif Of_Kind /= N_Comment and then Of_Kind /= N_Comment_Zones then\n+\n+            Project_Nodes.Increment_Last;\n+            Project_Nodes.Table (Project_Nodes.Last) :=\n+              (Kind             => N_Comment_Zones,\n+               Expr_Kind        => Undefined,\n+               Location         => No_Location,\n+               Directory        => No_Name,\n+               Variables        => Empty_Node,\n+               Packages         => Empty_Node,\n+               Pkg_Id           => Empty_Package,\n+               Name             => No_Name,\n+               Path_Name        => No_Name,\n+               Value            => No_Name,\n+               Field1           => Empty_Node,\n+               Field2           => Empty_Node,\n+               Field3           => Empty_Node,\n+               Flag1            => False,\n+               Flag2            => False,\n+               Comments         => Empty_Node);\n+\n+            Zone := Project_Nodes.Last;\n+            Project_Nodes.Table (Result).Comments := Zone;\n+            Previous := Empty_Node;\n+\n+            for J in 1 .. Comments.Last loop\n+\n+               --  Create a new N_Comment node\n+\n+               Project_Nodes.Increment_Last;\n+               Project_Nodes.Table (Project_Nodes.Last) :=\n+                 (Kind             => N_Comment,\n+                  Expr_Kind        => Undefined,\n+                  Flag1            => Comments.Table (J).Follows_Empty_Line,\n+                  Flag2            =>\n+                    Comments.Table (J).Is_Followed_By_Empty_Line,\n+                  Location         => No_Location,\n+                  Directory        => No_Name,\n+                  Variables        => Empty_Node,\n+                  Packages         => Empty_Node,\n+                  Pkg_Id           => Empty_Package,\n+                  Name             => No_Name,\n+                  Path_Name        => No_Name,\n+                  Value            => Comments.Table (J).Value,\n+                  Field1           => Empty_Node,\n+                  Field2           => Empty_Node,\n+                  Field3           => Empty_Node,\n+                  Comments         => Empty_Node);\n+\n+               --  Link it to the N_Comment_Zones node, if it is the first,\n+               --  otherwise to the previous one.\n+\n+               if Previous = Empty_Node then\n+                  Project_Nodes.Table (Zone).Field1 := Project_Nodes.Last;\n+\n+               else\n+                  Project_Nodes.Table (Previous).Comments :=\n+                    Project_Nodes.Last;\n+               end if;\n+\n+               --  This new node will be the previous one for the next\n+               --  N_Comment node, if there is one.\n+\n+               Previous := Project_Nodes.Last;\n+            end loop;\n+\n+            --  Empty the Comments table after all comments have been processed\n+\n+            Comments.Set_Last (0);\n+         end if;\n+      end if;\n+\n+      return Result;\n    end Default_Project_Node;\n \n    ------------------\n@@ -184,6 +487,24 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Directory;\n    end Directory_Of;\n \n+   -------------------------\n+   -- End_Of_Line_Comment --\n+   -------------------------\n+\n+   function End_Of_Line_Comment (Node : Project_Node_Id) return Name_Id is\n+      Zone : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      pragma Assert (Node /= Empty_Node);\n+      Zone := Project_Nodes.Table (Node).Comments;\n+\n+      if Zone = Empty_Node then\n+         return No_Name;\n+      else\n+         return Project_Nodes.Table (Zone).Value;\n+      end if;\n+   end End_Of_Line_Comment;\n+\n    ------------------------\n    -- Expression_Kind_Of --\n    ------------------------\n@@ -219,8 +540,7 @@ package body Prj.Tree is\n    -------------------\n \n    function Expression_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -240,8 +560,7 @@ package body Prj.Tree is\n    -------------------------\n \n    function Extended_Project_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -256,8 +575,7 @@ package body Prj.Tree is\n    ------------------------------\n \n    function Extended_Project_Path_Of\n-     (Node : Project_Node_Id)\n-      return Name_Id\n+     (Node : Project_Node_Id) return Name_Id\n    is\n    begin\n       pragma Assert\n@@ -271,8 +589,7 @@ package body Prj.Tree is\n    -- Extending_Project_Of --\n    --------------------------\n    function Extending_Project_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -287,8 +604,7 @@ package body Prj.Tree is\n    ---------------------------\n \n    function External_Reference_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -319,8 +635,7 @@ package body Prj.Tree is\n    ------------------------\n \n    function First_Case_Item_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -346,13 +661,96 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Field1;\n    end First_Choice_Of;\n \n+   -------------------------\n+   -- First_Comment_After --\n+   -------------------------\n+\n+   function First_Comment_After\n+     (Node : Project_Node_Id) return Project_Node_Id\n+   is\n+      Zone : Project_Node_Id := Empty_Node;\n+   begin\n+      pragma Assert (Node /= Empty_Node);\n+      Zone := Project_Nodes.Table (Node).Comments;\n+\n+      if Zone = Empty_Node then\n+         return Empty_Node;\n+\n+      else\n+         return Project_Nodes.Table (Zone).Field2;\n+      end if;\n+   end First_Comment_After;\n+\n+   -----------------------------\n+   -- First_Comment_After_End --\n+   -----------------------------\n+\n+   function First_Comment_After_End\n+     (Node : Project_Node_Id)\n+      return Project_Node_Id\n+   is\n+      Zone : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      pragma Assert (Node /= Empty_Node);\n+      Zone := Project_Nodes.Table (Node).Comments;\n+\n+      if Zone = Empty_Node then\n+         return Empty_Node;\n+\n+      else\n+         return Project_Nodes.Table (Zone).Comments;\n+      end if;\n+   end First_Comment_After_End;\n+\n+   --------------------------\n+   -- First_Comment_Before --\n+   --------------------------\n+\n+   function First_Comment_Before\n+     (Node : Project_Node_Id) return Project_Node_Id\n+   is\n+      Zone : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      pragma Assert (Node /= Empty_Node);\n+      Zone := Project_Nodes.Table (Node).Comments;\n+\n+      if Zone = Empty_Node then\n+         return Empty_Node;\n+\n+      else\n+         return Project_Nodes.Table (Zone).Field1;\n+      end if;\n+   end First_Comment_Before;\n+\n+   ------------------------------\n+   -- First_Comment_Before_End --\n+   ------------------------------\n+\n+   function First_Comment_Before_End\n+     (Node : Project_Node_Id) return Project_Node_Id\n+   is\n+      Zone : Project_Node_Id := Empty_Node;\n+\n+   begin\n+      pragma Assert (Node /= Empty_Node);\n+      Zone := Project_Nodes.Table (Node).Comments;\n+\n+      if Zone = Empty_Node then\n+         return Empty_Node;\n+\n+      else\n+         return Project_Nodes.Table (Zone).Field3;\n+      end if;\n+   end First_Comment_Before_End;\n+\n    -------------------------------\n    -- First_Declarative_Item_Of --\n    -------------------------------\n \n    function First_Declarative_Item_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -376,8 +774,7 @@ package body Prj.Tree is\n    ------------------------------\n \n    function First_Expression_In_List\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -392,8 +789,7 @@ package body Prj.Tree is\n    --------------------------\n \n    function First_Literal_String\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -408,8 +804,7 @@ package body Prj.Tree is\n    ----------------------\n \n    function First_Package_Of\n-     (Node : Project_Node_Id)\n-      return Package_Declaration_Id\n+     (Node : Project_Node_Id) return Package_Declaration_Id\n    is\n    begin\n       pragma Assert\n@@ -424,8 +819,7 @@ package body Prj.Tree is\n    --------------------------\n \n    function First_String_Type_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -440,8 +834,7 @@ package body Prj.Tree is\n    ----------------\n \n    function First_Term\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -456,8 +849,7 @@ package body Prj.Tree is\n    -----------------------\n \n    function First_Variable_Of\n-     (Node : Project_Node_Id)\n-      return Variable_Node_Id\n+     (Node : Project_Node_Id) return Variable_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -475,8 +867,7 @@ package body Prj.Tree is\n    --------------------------\n \n    function First_With_Clause_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -486,18 +877,18 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Field1;\n    end First_With_Clause_Of;\n \n-   ----------------------\n-   -- Is_Extending_All --\n-   ----------------------\n+   ------------------------\n+   -- Follows_Empty_Line --\n+   ------------------------\n \n-   function Is_Extending_All (Node  : Project_Node_Id) return Boolean is\n+   function Follows_Empty_Line (Node : Project_Node_Id) return Boolean is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n-          and then\n-            Project_Nodes.Table (Node).Kind = N_Project);\n-      return Project_Nodes.Table (Node).Extending_All;\n-   end Is_Extending_All;\n+         and then\n+         Project_Nodes.Table (Node).Kind = N_Comment);\n+      return Project_Nodes.Table (Node).Flag1;\n+   end Follows_Empty_Line;\n \n    ----------\n    -- Hash --\n@@ -508,14 +899,51 @@ package body Prj.Tree is\n       return Header_Num (N mod Project_Node_Id (Header_Num'Last));\n    end Hash;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Project_Nodes.Set_Last (Empty_Node);\n+      Projects_Htable.Reset;\n+   end Initialize;\n+\n+   -------------------------------\n+   -- Is_Followed_By_Empty_Line --\n+   -------------------------------\n+\n+   function Is_Followed_By_Empty_Line\n+     (Node : Project_Node_Id) return Boolean\n+   is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+            Project_Nodes.Table (Node).Kind = N_Comment);\n+      return Project_Nodes.Table (Node).Flag2;\n+   end Is_Followed_By_Empty_Line;\n+\n+   ----------------------\n+   -- Is_Extending_All --\n+   ----------------------\n+\n+   function Is_Extending_All (Node  : Project_Node_Id) return Boolean is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+            Project_Nodes.Table (Node).Kind = N_Project);\n+      return Project_Nodes.Table (Node).Flag2;\n+   end Is_Extending_All;\n+\n    -------------------------------------\n    -- Imported_Or_Extended_Project_Of --\n    -------------------------------------\n \n    function Imported_Or_Extended_Project_Of\n      (Project   : Project_Node_Id;\n-      With_Name : Name_Id)\n-      return      Project_Node_Id\n+      With_Name : Name_Id) return Project_Node_Id\n    is\n       With_Clause : Project_Node_Id := First_With_Clause_Of (Project);\n       Result      : Project_Node_Id := Empty_Node;\n@@ -548,16 +976,6 @@ package body Prj.Tree is\n       return Result;\n    end Imported_Or_Extended_Project_Of;\n \n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-   begin\n-      Project_Nodes.Set_Last (Empty_Node);\n-      Projects_Htable.Reset;\n-   end Initialize;\n-\n    -------------\n    -- Kind_Of --\n    -------------\n@@ -593,8 +1011,7 @@ package body Prj.Tree is\n    --------------------\n \n    function Next_Case_Item\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -604,13 +1021,25 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Field3;\n    end Next_Case_Item;\n \n+   ------------------\n+   -- Next_Comment --\n+   ------------------\n+\n+   function Next_Comment (Node : Project_Node_Id) return Project_Node_Id is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+            Project_Nodes.Table (Node).Kind = N_Comment);\n+      return Project_Nodes.Table (Node).Comments;\n+   end Next_Comment;\n+\n    ---------------------------\n    -- Next_Declarative_Item --\n    ---------------------------\n \n    function Next_Declarative_Item\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -625,8 +1054,7 @@ package body Prj.Tree is\n    -----------------------------\n \n    function Next_Expression_In_List\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -657,8 +1085,7 @@ package body Prj.Tree is\n    -----------------------------\n \n    function Next_Package_In_Project\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -689,8 +1116,7 @@ package body Prj.Tree is\n    ---------------\n \n    function Next_Term\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -724,8 +1150,7 @@ package body Prj.Tree is\n    -------------------------\n \n    function Next_With_Clause_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -740,8 +1165,7 @@ package body Prj.Tree is\n    ---------------------------------\n \n    function Non_Limited_Project_Node_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -750,6 +1174,7 @@ package body Prj.Tree is\n            (Project_Nodes.Table (Node).Kind = N_With_Clause));\n       return Project_Nodes.Table (Node).Field3;\n    end Non_Limited_Project_Node_Of;\n+\n    -------------------\n    -- Package_Id_Of --\n    -------------------\n@@ -768,8 +1193,7 @@ package body Prj.Tree is\n    ---------------------\n \n    function Package_Node_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -801,8 +1225,7 @@ package body Prj.Tree is\n    ----------------------------\n \n    function Project_Declaration_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -812,13 +1235,25 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Field2;\n    end Project_Declaration_Of;\n \n+   -------------------------------------------\n+   -- Project_File_Includes_Unkept_Comments --\n+   -------------------------------------------\n+\n+   function Project_File_Includes_Unkept_Comments\n+     (Node : Project_Node_Id) return Boolean\n+   is\n+      Declaration : constant Project_Node_Id :=\n+        Project_Declaration_Of (Node);\n+   begin\n+      return Project_Nodes.Table (Declaration).Flag1;\n+   end Project_File_Includes_Unkept_Comments;\n+\n    ---------------------\n    -- Project_Node_Of --\n    ---------------------\n \n    function Project_Node_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -837,8 +1272,7 @@ package body Prj.Tree is\n    -----------------------------------\n \n    function Project_Of_Renamed_Package_Of\n-     (Node : Project_Node_Id)\n-      return Project_Node_Id\n+     (Node : Project_Node_Id) return Project_Node_Id\n    is\n    begin\n       pragma Assert\n@@ -848,6 +1282,181 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Field1;\n    end Project_Of_Renamed_Package_Of;\n \n+   --------------------------\n+   -- Remove_Next_End_Node --\n+   --------------------------\n+\n+   procedure Remove_Next_End_Node is\n+   begin\n+      Next_End_Nodes.Decrement_Last;\n+   end Remove_Next_End_Node;\n+\n+   -----------------\n+   -- Reset_State --\n+   -----------------\n+\n+   procedure Reset_State is\n+   begin\n+      End_Of_Line_Node   := Empty_Node;\n+      Previous_Line_Node := Empty_Node;\n+      Previous_End_Node  := Empty_Node;\n+      Unkept_Comments    := False;\n+      Comments.Set_Last (0);\n+   end Reset_State;\n+\n+   -------------\n+   -- Restore --\n+   -------------\n+\n+   procedure Restore (S : in Comment_State) is\n+   begin\n+      End_Of_Line_Node   := S.End_Of_Line_Node;\n+      Previous_Line_Node := S.Previous_Line_Node;\n+      Previous_End_Node  := S.Previous_End_Node;\n+      Next_End_Nodes.Set_Last (0);\n+      Unkept_Comments    := S.Unkept_Comments;\n+\n+      Comments.Set_Last (0);\n+\n+      for J in S.Comments'Range loop\n+         Comments.Increment_Last;\n+         Comments.Table (Comments.Last) := S.Comments (J);\n+      end loop;\n+   end Restore;\n+\n+   ----------\n+   -- Save --\n+   ----------\n+\n+   procedure Save (S : out Comment_State) is\n+      Cmts : Comments_Ptr := new Comment_Array (1 .. Comments.Last);\n+   begin\n+      for J in 1 .. Comments.Last loop\n+         Cmts (J) := Comments.Table (J);\n+      end loop;\n+\n+      S :=\n+        (End_Of_Line_Node   => End_Of_Line_Node,\n+         Previous_Line_Node => Previous_Line_Node,\n+         Previous_End_Node  => Previous_End_Node,\n+         Unkept_Comments    => Unkept_Comments,\n+         Comments           => Cmts);\n+   end Save;\n+\n+   ----------\n+   -- Scan --\n+   ----------\n+\n+   procedure Scan is\n+      Empty_Line : Boolean := False;\n+   begin\n+      --  If there are comments, then they will not be kept. Set the flag and\n+      --  clear the comments.\n+\n+      if Comments.Last > 0 then\n+         Unkept_Comments := True;\n+         Comments.Set_Last (0);\n+      end if;\n+\n+      --  Loop until a token other that End_Of_Line or Comment is found\n+\n+      loop\n+         Prj.Err.Scanner.Scan;\n+\n+         case Token is\n+            when Tok_End_Of_Line =>\n+               if Prev_Token = Tok_End_Of_Line then\n+                  Empty_Line := True;\n+\n+                  if Comments.Last > 0 then\n+                     Comments.Table (Comments.Last).Is_Followed_By_Empty_Line\n+                     := True;\n+                  end if;\n+               end if;\n+\n+            when Tok_Comment =>\n+               --  If this is a line comment, add it to the comment table\n+\n+               if Prev_Token = Tok_End_Of_Line\n+                 or else Prev_Token = No_Token\n+               then\n+                  Comments.Increment_Last;\n+                  Comments.Table (Comments.Last) :=\n+                    (Value                     => Comment_Id,\n+                     Follows_Empty_Line        => Empty_Line,\n+                     Is_Followed_By_Empty_Line => False);\n+\n+               --  Otherwise, it is an end of line comment. If there is\n+               --  an end of line node specified, associate the comment with\n+               --  this node.\n+\n+               elsif End_Of_Line_Node /= Empty_Node then\n+                  declare\n+                     Zones : constant Project_Node_Id :=\n+                       Comment_Zones_Of (End_Of_Line_Node);\n+                  begin\n+                     Project_Nodes.Table (Zones).Value := Comment_Id;\n+                  end;\n+\n+               --  Otherwise, this end of line node cannot be kept\n+\n+               else\n+                  Unkept_Comments := True;\n+                  Comments.Set_Last (0);\n+               end if;\n+\n+               Empty_Line := False;\n+\n+            when others =>\n+               --  If there are comments, where the first comment is not\n+               --  following an empty line, put the initial uninterrupted\n+               --  comment zone with the node of the preceding line (either\n+               --  a Previous_Line or a Previous_End node), if any.\n+\n+               if Comments.Last > 0 and then\n+                 not Comments.Table (1).Follows_Empty_Line then\n+                  if Previous_Line_Node /= Empty_Node then\n+                     Add_Comments\n+                       (To => Previous_Line_Node, Where => After);\n+\n+                  elsif Previous_End_Node /= Empty_Node then\n+                     Add_Comments\n+                       (To => Previous_End_Node, Where => After_End);\n+                  end if;\n+               end if;\n+\n+               --  If there are still comments and the token is \"end\", then\n+               --  put these comments with the Next_End node, if any;\n+               --  otherwise, these comments cannot be kept. Always clear\n+               --  the comments.\n+\n+               if Comments.Last > 0 and then Token = Tok_End then\n+                  if Next_End_Nodes.Last > 0 then\n+                     Add_Comments\n+                       (To => Next_End_Nodes.Table (Next_End_Nodes.Last),\n+                        Where => Before_End);\n+\n+                  else\n+                     Unkept_Comments := True;\n+                  end if;\n+\n+                  Comments.Set_Last (0);\n+               end if;\n+\n+               --  Reset the End_Of_Line, Previous_Line and Previous_End nodes\n+               --  so that they are not used again.\n+\n+               End_Of_Line_Node   := Empty_Node;\n+               Previous_Line_Node := Empty_Node;\n+               Previous_End_Node  := Empty_Node;\n+\n+               --  And return\n+\n+               exit;\n+         end case;\n+      end loop;\n+   end Scan;\n+\n    ------------------------------------\n    -- Set_Associative_Array_Index_Of --\n    ------------------------------------\n@@ -913,7 +1522,7 @@ package body Prj.Tree is\n            (Project_Nodes.Table (Node).Kind = N_Attribute_Declaration\n                or else\n             Project_Nodes.Table (Node).Kind = N_Attribute_Reference));\n-      Project_Nodes.Table (Node).Case_Insensitive := To;\n+      Project_Nodes.Table (Node).Flag1 := To;\n    end Set_Case_Insensitive;\n \n    ------------------------------------\n@@ -980,6 +1589,15 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Directory := To;\n    end Set_Directory_Of;\n \n+   ---------------------\n+   -- Set_End_Of_Line --\n+   ---------------------\n+\n+   procedure Set_End_Of_Line (To : Project_Node_Id) is\n+   begin\n+      End_Of_Line_Node := To;\n+   end Set_End_Of_Line;\n+\n    ----------------------------\n    -- Set_Expression_Kind_Of --\n    ----------------------------\n@@ -1096,6 +1714,63 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Field1 := To;\n    end Set_First_Choice_Of;\n \n+   -----------------------------\n+   -- Set_First_Comment_After --\n+   -----------------------------\n+\n+   procedure Set_First_Comment_After\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id)\n+   is\n+      Zone : constant Project_Node_Id :=\n+                Comment_Zones_Of (Node);\n+   begin\n+      Project_Nodes.Table (Zone).Field2 := To;\n+   end Set_First_Comment_After;\n+\n+   ---------------------------------\n+   -- Set_First_Comment_After_End --\n+   ---------------------------------\n+\n+   procedure Set_First_Comment_After_End\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id)\n+   is\n+      Zone : constant Project_Node_Id :=\n+                Comment_Zones_Of (Node);\n+   begin\n+      Project_Nodes.Table (Zone).Comments := To;\n+   end Set_First_Comment_After_End;\n+\n+   ------------------------------\n+   -- Set_First_Comment_Before --\n+   ------------------------------\n+\n+   procedure Set_First_Comment_Before\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id)\n+\n+   is\n+      Zone : constant Project_Node_Id :=\n+                Comment_Zones_Of (Node);\n+   begin\n+      Project_Nodes.Table (Zone).Field1 := To;\n+   end Set_First_Comment_Before;\n+\n+   ----------------------------------\n+   -- Set_First_Comment_Before_End --\n+   ----------------------------------\n+\n+   procedure Set_First_Comment_Before_End\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id)\n+   is\n+      Zone : constant Project_Node_Id :=\n+                Comment_Zones_Of (Node);\n+   begin\n+      Project_Nodes.Table (Zone).Field2 := To;\n+   end Set_First_Comment_Before_End;\n+\n    ------------------------\n    -- Set_Next_Case_Item --\n    ------------------------\n@@ -1112,6 +1787,22 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Field3 := To;\n    end Set_Next_Case_Item;\n \n+   ----------------------\n+   -- Set_Next_Comment --\n+   ----------------------\n+\n+   procedure Set_Next_Comment\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id)\n+   is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+            Project_Nodes.Table (Node).Kind = N_Comment);\n+      Project_Nodes.Table (Node).Comments := To;\n+   end Set_Next_Comment;\n+\n    -----------------------------------\n    -- Set_First_Declarative_Item_Of --\n    -----------------------------------\n@@ -1261,7 +1952,7 @@ package body Prj.Tree is\n         (Node /= Empty_Node\n           and then\n             Project_Nodes.Table (Node).Kind = N_Project);\n-      Project_Nodes.Table (Node).Extending_All := True;\n+      Project_Nodes.Table (Node).Flag2 := True;\n    end Set_Is_Extending_All;\n \n    -----------------\n@@ -1367,6 +2058,16 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Field2 := To;\n    end Set_Next_Declarative_Item;\n \n+   -----------------------\n+   -- Set_Next_End_Node --\n+   -----------------------\n+\n+   procedure Set_Next_End_Node (To : Project_Node_Id) is\n+   begin\n+      Next_End_Nodes.Increment_Last;\n+      Next_End_Nodes.Table (Next_End_Nodes.Last) := To;\n+   end Set_Next_End_Node;\n+\n    ---------------------------------\n    -- Set_Next_Expression_In_List --\n    ---------------------------------\n@@ -1533,6 +2234,23 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Path_Name := To;\n    end Set_Path_Name_Of;\n \n+   ---------------------------\n+   -- Set_Previous_End_Node --\n+   ---------------------------\n+   procedure Set_Previous_End_Node (To : Project_Node_Id) is\n+   begin\n+      Previous_End_Node := To;\n+   end Set_Previous_End_Node;\n+\n+   ----------------------------\n+   -- Set_Previous_Line_Node --\n+   ----------------------------\n+\n+   procedure Set_Previous_Line_Node (To : Project_Node_Id) is\n+   begin\n+      Previous_Line_Node := To;\n+   end Set_Previous_Line_Node;\n+\n    --------------------------------\n    -- Set_Project_Declaration_Of --\n    --------------------------------\n@@ -1549,6 +2267,20 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Field2 := To;\n    end Set_Project_Declaration_Of;\n \n+   -----------------------------------------------\n+   -- Set_Project_File_Includes_Unkept_Comments --\n+   -----------------------------------------------\n+\n+   procedure Set_Project_File_Includes_Unkept_Comments\n+     (Node : Project_Node_Id;\n+      To   : Boolean)\n+   is\n+      Declaration : constant Project_Node_Id :=\n+        Project_Declaration_Of (Node);\n+   begin\n+      Project_Nodes.Table (Declaration).Flag1 := To;\n+   end Set_Project_File_Includes_Unkept_Comments;\n+\n    -------------------------\n    -- Set_Project_Node_Of --\n    -------------------------\n@@ -1631,6 +2363,8 @@ package body Prj.Tree is\n           and then\n             (Project_Nodes.Table (Node).Kind = N_With_Clause\n                or else\n+             Project_Nodes.Table (Node).Kind = N_Comment\n+               or else\n              Project_Nodes.Table (Node).Kind = N_Literal_String));\n       Project_Nodes.Table (Node).Value := To;\n    end Set_String_Value_Of;\n@@ -1639,8 +2373,9 @@ package body Prj.Tree is\n    -- String_Type_Of --\n    --------------------\n \n-   function String_Type_Of  (Node : Project_Node_Id)\n-                            return Project_Node_Id is\n+   function String_Type_Of\n+     (Node : Project_Node_Id) return Project_Node_Id\n+   is\n    begin\n       pragma Assert\n         (Node /= Empty_Node\n@@ -1667,6 +2402,8 @@ package body Prj.Tree is\n           and then\n            (Project_Nodes.Table (Node).Kind = N_With_Clause\n               or else\n+            Project_Nodes.Table (Node).Kind = N_Comment\n+               or else\n             Project_Nodes.Table (Node).Kind = N_Literal_String));\n       return Project_Nodes.Table (Node).Value;\n    end String_Value_Of;\n@@ -1677,8 +2414,7 @@ package body Prj.Tree is\n \n    function Value_Is_Valid\n      (For_Typed_Variable : Project_Node_Id;\n-      Value              : Name_Id)\n-      return               Boolean\n+      Value              : Name_Id) return Boolean\n    is\n    begin\n       pragma Assert\n@@ -1706,4 +2442,14 @@ package body Prj.Tree is\n \n    end Value_Is_Valid;\n \n+   -------------------------------\n+   -- There_Are_Unkept_Comments --\n+   -------------------------------\n+\n+   function There_Are_Unkept_Comments return Boolean is\n+   begin\n+      return Unkept_Comments;\n+   end There_Are_Unkept_Comments;\n+\n+\n end Prj.Tree;"}, {"sha": "942c10be0b91601f65aecd2ed1c1181fa397600d", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 247, "deletions": 90, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -30,8 +30,8 @@ with GNAT.HTable;\n \n with Prj.Attr; use Prj.Attr;\n with Prj.Com;  use Prj.Com;\n+with Table;    use Table;\n with Types;    use Types;\n-with Table;\n \n package Prj.Tree is\n \n@@ -79,7 +79,9 @@ package Prj.Tree is\n       N_External_Value,\n       N_Attribute_Reference,\n       N_Case_Construction,\n-      N_Case_Item);\n+      N_Case_Item,\n+      N_Comment_Zones,\n+      N_Comment);\n    --  Each node in the tree is of a Project_Node_Kind\n    --  For the signification of the fields in each node of a\n    --  Project_Node_Kind, look at package Tree_Private_Part.\n@@ -90,8 +92,7 @@ package Prj.Tree is\n \n    function Default_Project_Node\n      (Of_Kind       : Project_Node_Kind;\n-      And_Expr_Kind : Variable_Kind := Undefined)\n-      return          Project_Node_Id;\n+      And_Expr_Kind : Variable_Kind := Undefined) return Project_Node_Id;\n    --  Returns a Project_Node_Record with the specified Kind and\n    --  Expr_Kind; all the other components have default nil values.\n \n@@ -100,11 +101,85 @@ package Prj.Tree is\n \n    function Imported_Or_Extended_Project_Of\n      (Project   : Project_Node_Id;\n-      With_Name : Name_Id)\n-      return      Project_Node_Id;\n+      With_Name : Name_Id) return Project_Node_Id;\n    --  Return the node of a project imported or extended by project Project and\n    --  whose name is With_Name. Return Empty_Node if there is no such project.\n \n+   --------------\n+   -- Comments --\n+   --------------\n+\n+   type Comment_State is private;\n+   --  A type to store the values of several global variables related to\n+   --  comments.\n+\n+   procedure Save (S : out Comment_State);\n+   --  Save in variable S the comment state. Called before scanning a new\n+   --  project file.\n+\n+   procedure Restore (S : in Comment_State);\n+   --  Restore the comment state to a previously saved value. Called after\n+   --  scanning a project file.\n+\n+   procedure Reset_State;\n+   --  Set the comment state to its initial value. Called before scanning a\n+   --  new project file.\n+\n+   function There_Are_Unkept_Comments return Boolean;\n+   --  Indicates that some of the comments in a project file could not be\n+   --  stored in the parse tree.\n+\n+   procedure Set_Previous_Line_Node (To : Project_Node_Id);\n+   --  Indicate the node on the previous line. If there are comments\n+   --  immediately following this line, then they should be associated with\n+   --  this node.\n+\n+   procedure Set_Previous_End_Node (To : Project_Node_Id);\n+   --  Indicate that on the previous line the \"end\" belongs to node To.\n+   --  If there are comments immediately following this \"end\" line, they\n+   --  should be associated with this node.\n+\n+   procedure Set_End_Of_Line (To : Project_Node_Id);\n+   --  Indicate the node on the current line. If there is an end of line\n+   --  comment, then it should be associated with this node.\n+\n+   procedure Set_Next_End_Node (To : Project_Node_Id);\n+   --  Put node To on the top of the end node stack. When an \"end\" line\n+   --  is found with this node on the top of the end node stack, the comments,\n+   --  if any, immediately preceding this \"end\" line will be associated with\n+   --  this node.\n+\n+   procedure Remove_Next_End_Node;\n+   --  Remove the top of the end node stack.\n+\n+   ------------------------\n+   -- Comment Processing --\n+   ------------------------\n+\n+   type Comment_Data is record\n+      Value                     : Name_Id := No_Name;\n+      Follows_Empty_Line        : Boolean := False;\n+      Is_Followed_By_Empty_Line : Boolean := False;\n+   end record;\n+\n+   package Comments is new Table.Table\n+     (Table_Component_Type => Comment_Data,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Tree.Comments\");\n+   --  A table to store the comments that may be stored is the tree\n+\n+   procedure Scan;\n+   --  Scan the tokens and accumulate comments.\n+\n+   type Comment_Location is\n+     (Before, After, Before_End, After_End, End_Of_Line);\n+\n+   procedure Add_Comments (To : Project_Node_Id; Where : Comment_Location);\n+   --  Add comments to this node.\n+\n    ----------------------\n    -- Access Functions --\n    ----------------------\n@@ -125,6 +200,39 @@ package Prj.Tree is\n    pragma Inline (Location_Of);\n    --  Valid for all non empty nodes\n \n+   function First_Comment_After\n+     (Node : Project_Node_Id) return Project_Node_Id;\n+   --  Valid only for N_Comment_Zones nodes\n+\n+   function First_Comment_After_End\n+     (Node : Project_Node_Id) return Project_Node_Id;\n+   --  Valid only for N_Comment_Zones nodes\n+\n+   function First_Comment_Before\n+     (Node : Project_Node_Id) return Project_Node_Id;\n+   --  Valid only for N_Comment_Zones nodes\n+\n+   function First_Comment_Before_End\n+     (Node : Project_Node_Id) return Project_Node_Id;\n+   --  Valid only for N_Comment_Zones nodes\n+\n+   function Next_Comment (Node : Project_Node_Id) return Project_Node_Id;\n+   --  Valid only for N_Comment nodes\n+\n+   function End_Of_Line_Comment (Node : Project_Node_Id) return Name_Id;\n+   --  Valid only for non empty nodes\n+\n+   function Follows_Empty_Line (Node : Project_Node_Id) return Boolean;\n+   --  Valid only for N_Comment nodes\n+\n+   function Is_Followed_By_Empty_Line (Node : Project_Node_Id) return Boolean;\n+   --  Valid only for N_Comment nodes\n+\n+   function Project_File_Includes_Unkept_Comments\n+     (Node : Project_Node_Id)\n+      return Boolean;\n+   --  Valid only for N_Project nodes\n+\n    function Directory_Of (Node : Project_Node_Id) return Name_Id;\n    pragma Inline (Directory_Of);\n    --  Only valid for N_Project nodes.\n@@ -140,138 +248,118 @@ package Prj.Tree is\n    --  Only valid for N_Project\n \n    function First_Variable_Of\n-     (Node  : Project_Node_Id)\n-      return  Variable_Node_Id;\n+     (Node : Project_Node_Id) return Variable_Node_Id;\n    pragma Inline (First_Variable_Of);\n    --  Only valid for N_Project or N_Package_Declaration nodes\n \n    function First_Package_Of\n-     (Node  : Project_Node_Id)\n-      return  Package_Declaration_Id;\n+     (Node : Project_Node_Id) return Package_Declaration_Id;\n    pragma Inline (First_Package_Of);\n    --  Only valid for N_Project nodes\n \n    function Package_Id_Of (Node  : Project_Node_Id) return Package_Node_Id;\n    pragma Inline (Package_Id_Of);\n    --  Only valid for N_Package_Declaration nodes\n \n-   function Path_Name_Of (Node  : Project_Node_Id) return Name_Id;\n+   function Path_Name_Of (Node : Project_Node_Id) return Name_Id;\n    pragma Inline (Path_Name_Of);\n    --  Only valid for N_Project and N_With_Clause nodes.\n \n-   function String_Value_Of (Node  : Project_Node_Id) return Name_Id;\n+   function String_Value_Of (Node : Project_Node_Id) return Name_Id;\n    pragma Inline (String_Value_Of);\n-   --  Only valid for N_With_Clause or N_Literal_String nodes.\n+   --  Only valid for N_With_Clause, N_Literal_String nodes or N_Comment\n \n    function First_With_Clause_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_With_Clause_Of);\n    --  Only valid for N_Project nodes\n \n    function Project_Declaration_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Project_Declaration_Of);\n    --  Only valid for N_Project nodes\n \n    function Extending_Project_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Extending_Project_Of);\n    --  Only valid for N_Project_Declaration nodes\n \n    function First_String_Type_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_String_Type_Of);\n    --  Only valid for N_Project nodes\n \n    function Extended_Project_Path_Of\n-     (Node  : Project_Node_Id)\n-      return  Name_Id;\n+     (Node : Project_Node_Id) return Name_Id;\n    pragma Inline (Extended_Project_Path_Of);\n    --  Only valid for N_With_Clause nodes\n \n    function Project_Node_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Project_Node_Of);\n    --  Only valid for N_With_Clause, N_Variable_Reference and\n    --  N_Attribute_Reference nodes.\n \n    function Non_Limited_Project_Node_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Non_Limited_Project_Node_Of);\n    --  Only valid for N_With_Clause nodes. Returns Empty_Node for limited\n    --  imported project files, otherwise returns the same result as\n    --  Project_Node_Of.\n \n    function Next_With_Clause_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_With_Clause_Of);\n    --  Only valid for N_With_Clause nodes\n \n    function First_Declarative_Item_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_Declarative_Item_Of);\n    --  Only valid for N_With_Clause nodes\n \n    function Extended_Project_Of\n-     (Node  : Project_Node_Id)\n-      return Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Extended_Project_Of);\n    --  Only valid for N_Project_Declaration nodes\n \n    function Current_Item_Node\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Current_Item_Node);\n    --  Only valid for N_Declarative_Item nodes\n \n    function Next_Declarative_Item\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_Declarative_Item);\n    --  Only valid for N_Declarative_Item node\n \n    function Project_Of_Renamed_Package_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Project_Of_Renamed_Package_Of);\n    --  Only valid for N_Package_Declaration nodes.\n    --  May return Empty_Node.\n \n    function Next_Package_In_Project\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_Package_In_Project);\n    --  Only valid for N_Package_Declaration nodes\n \n    function First_Literal_String\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_Literal_String);\n    --  Only valid for N_String_Type_Declaration nodes\n \n    function Next_String_Type\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_String_Type);\n    --  Only valid for N_String_Type_Declaration nodes\n \n    function Next_Literal_String\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_Literal_String);\n    --  Only valid for N_Literal_String nodes\n \n    function Expression_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Expression_Of);\n    --  Only valid for N_Attribute_Declaration, N_Typed_Variable_Declaration\n    --  or N_Variable_Declaration nodes\n@@ -290,104 +378,88 @@ package Prj.Tree is\n \n    function Value_Is_Valid\n      (For_Typed_Variable : Project_Node_Id;\n-      Value              : Name_Id)\n-      return               Boolean;\n+      Value              : Name_Id) return Boolean;\n    pragma Inline (Value_Is_Valid);\n    --  Only valid for N_Typed_Variable_Declaration. Returns True if Value is\n    --  in the list of allowed strings for For_Typed_Variable. False otherwise.\n \n    function Associative_Array_Index_Of\n-     (Node  : Project_Node_Id)\n-      return  Name_Id;\n+     (Node : Project_Node_Id) return Name_Id;\n    pragma Inline (Associative_Array_Index_Of);\n    --  Only valid for N_Attribute_Declaration and N_Attribute_Reference.\n    --  Returns No_String for non associative array attributes.\n \n    function Next_Variable\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_Variable);\n    --  Only valid for N_Typed_Variable_Declaration or N_Variable_Declaration\n    --  nodes.\n \n    function First_Term\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_Term);\n    --  Only valid for N_Expression nodes\n \n    function Next_Expression_In_List\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_Expression_In_List);\n    --  Only valid for N_Expression nodes\n \n    function Current_Term\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Current_Term);\n    --  Only valid for N_Term nodes\n \n    function Next_Term\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_Term);\n    --  Only valid for N_Term nodes\n \n    function First_Expression_In_List\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_Expression_In_List);\n    --  Only valid for N_Literal_String_List nodes\n \n    function Package_Node_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Package_Node_Of);\n    --  Only valid for N_Variable_Reference or N_Attribute_Reference nodes.\n    --  May return Empty_Node.\n \n    function String_Type_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (String_Type_Of);\n    --  Only valid for N_Variable_Reference or N_Typed_Variable_Declaration\n    --  nodes.\n \n    function External_Reference_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (External_Reference_Of);\n    --  Only valid for N_External_Value nodes\n \n    function External_Default_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (External_Default_Of);\n    --  Only valid for N_External_Value nodes\n \n    function Case_Variable_Reference_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Case_Variable_Reference_Of);\n    --  Only valid for N_Case_Construction nodes\n \n    function First_Case_Item_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_Case_Item_Of);\n    --  Only valid for N_Case_Construction nodes\n \n    function First_Choice_Of\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (First_Choice_Of);\n    --  Return the first choice in a N_Case_Item, or Empty_Node if\n    --  this is when others.\n \n    function Next_Case_Item\n-     (Node  : Project_Node_Id)\n-      return  Project_Node_Id;\n+     (Node : Project_Node_Id) return Project_Node_Id;\n    pragma Inline (Next_Case_Item);\n    --  Only valid for N_Case_Item nodes\n \n@@ -419,6 +491,35 @@ package Prj.Tree is\n       To   : Source_Ptr);\n    pragma Inline (Set_Location_Of);\n \n+   procedure Set_First_Comment_After\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id);\n+   pragma Inline (Set_First_Comment_After);\n+\n+   procedure Set_First_Comment_After_End\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id);\n+   pragma Inline (Set_First_Comment_After_End);\n+\n+   procedure Set_First_Comment_Before\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id);\n+   pragma Inline (Set_First_Comment_Before);\n+\n+   procedure Set_First_Comment_Before_End\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id);\n+   pragma Inline (Set_First_Comment_Before_End);\n+\n+   procedure Set_Next_Comment\n+     (Node : Project_Node_Id;\n+      To   : Project_Node_Id);\n+   pragma Inline (Set_Next_Comment);\n+\n+   procedure Set_Project_File_Includes_Unkept_Comments\n+     (Node : Project_Node_Id;\n+      To   : Boolean);\n+\n    procedure Set_Directory_Of\n      (Node : Project_Node_Id;\n       To   : Name_Id);\n@@ -687,14 +788,32 @@ package Prj.Tree is\n          Field3 : Project_Node_Id := Empty_Node;\n          --  See below the meaning for each Project_Node_Kind\n \n-         Case_Insensitive : Boolean := False;\n-         --  This flag is significant only for N_Attribute_Declaration and\n-         --  N_Atribute_Reference. It indicates for an associative array\n-         --  attribute, that the index is case insensitive.\n-\n-         Extending_All : Boolean := False;\n-         --  This flag is significant only for N_Project. It indicates that\n-         --  the project \"extends all\" another project.\n+         Flag1 : Boolean := False;\n+         --  This flag is significant only for:\n+         --    N_Attribute_Declaration and N_Atribute_Reference\n+         --      It indicates for an associative array attribute, that the\n+         --      index is case insensitive.\n+         --    N_Comment - it indicates that the comment is preceded by an\n+         --                empty line.\n+         --    N_Project - it indicates that there are comments in the project\n+         --                source that cannot be kept in the tree.\n+         --    N_Project_Declaration\n+         --              - it indixates that there are unkept comment in the\n+         --                project.\n+\n+         Flag2 : Boolean := False;\n+         --  This flag is significant only for:\n+         --    N_Project - it indicates that the project \"extends all\" another\n+         --                project.\n+         --    N_Comment - it indicates that the comment is followed by an\n+         --                empty line.\n+\n+         Comments : Project_Node_Id := Empty_Node;\n+         --  For nodes other that N_Comment_Zones or N_Comment, designates the\n+         --  comment zones associated with the node.\n+         --  for N_Comment_Zones, designates the comment after the \"end\" of\n+         --  the construct.\n+         --  For N_Comment, designates the next comment, if any.\n \n       end record;\n \n@@ -862,7 +981,7 @@ package Prj.Tree is\n       --    --  Field3:    not used\n       --    --  Value:     not used\n \n-      --    N_Case_Item);\n+      --    N_Case_Item\n       --    --  Name:      not used\n       --    --  Path_Name: not used\n       --    --  Expr_Kind: not used\n@@ -872,6 +991,28 @@ package Prj.Tree is\n       --    --  Field3:    next case item\n       --    --  Value:     not used\n \n+      --    N_Comment_zones\n+      --    --  Name:      not used\n+      --    --  Path_Name: not used\n+      --    --  Expr_Kind: not used\n+      --    --  Field1:    comment before the construct\n+      --    --  Field2:    comment after the construct\n+      --    --  Field3:    comment before the \"end\" of the construct\n+      --    --  Value:     end of line comment\n+      --    --  Comments:  comment after the \"end\" of the construct\n+\n+      --    N_Comment\n+      --    --  Name:      not used\n+      --    --  Path_Name: not used\n+      --    --  Expr_Kind: not used\n+      --    --  Field1:    not used\n+      --    --  Field2:    not used\n+      --    --  Field3:    not used\n+      --    --  Value:     comment\n+      --    --  Flag1:     comment is preceded by an empty line\n+      --    --  Flag2:     comment is followed by an empty line\n+      --    --  Comments:  next comment\n+\n       package Project_Nodes is\n          new Table.Table (Table_Component_Type => Project_Node_Record,\n                           Table_Index_Type     => Project_Node_Id,\n@@ -911,4 +1052,20 @@ package Prj.Tree is\n \n    end Tree_Private_Part;\n \n+private\n+   type Comment_Array is array (Positive range <>) of Comment_Data;\n+   type Comments_Ptr is access Comment_Array;\n+\n+   type Comment_State is record\n+      End_Of_Line_Node   : Project_Node_Id := Empty_Node;\n+\n+      Previous_Line_Node : Project_Node_Id := Empty_Node;\n+\n+      Previous_End_Node  : Project_Node_Id := Empty_Node;\n+\n+      Unkept_Comments    : Boolean := False;\n+\n+      Comments           : Comments_Ptr := null;\n+   end record;\n+\n end Prj.Tree;"}, {"sha": "6594b8782aceed7e4e4e4c7874b4b02f138ea76d", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -123,7 +123,8 @@ package body Prj is\n       Seen                           => False,\n       Flag1                          => False,\n       Flag2                          => False,\n-      Depth                          => 0);\n+      Depth                          => 0,\n+      Unkept_Comments                => False);\n \n    -------------------\n    -- Add_To_Buffer --\n@@ -387,15 +388,6 @@ package body Prj is\n         and then Left.Separate_Suffix = Right.Separate_Suffix;\n    end Same_Naming_Scheme;\n \n-   ----------\n-   -- Scan --\n-   ----------\n-\n-   procedure Scan is\n-   begin\n-      Scanner.Scan;\n-   end Scan;\n-\n    --------------------------\n    -- Standard_Naming_Data --\n    --------------------------"}, {"sha": "3f9033c7b3c0734f305e2f7250d87e542a6c1cd6", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -554,6 +554,10 @@ package Prj is\n       --  The maximum depth of a project in the project graph.\n       --  Depth of main project is 0.\n \n+      Unkept_Comments : Boolean := False;\n+      --  True if there are comments in the project sources that cannot\n+      --  be kept in the project tree.\n+\n    end record;\n \n    function Empty_Project return Project_Data;\n@@ -610,10 +614,6 @@ package Prj is\n    --  it is called for B. With_State may be used by Action to choose a\n    --  behavior or to report some global result.\n \n-   procedure Scan;\n-   pragma Inline (Scan);\n-   --  Scan a token. Change all operator symbols to literal strings.\n-\n private\n \n    Initial_Buffer_Size : constant := 100;"}, {"sha": "b0438b00fa345e3783dc9c6605c837f19b65101d", "filename": "gcc/ada/s-tpae65.adb", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fs-tpae65.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fs-tpae65.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpae65.adb?ref=8738323373326f9d92d2df3eee27989bcee2044b", "patch": "@@ -1,87 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n---                                                                          --\n---           S Y S T E M . T A S K _ P R I M I T I V E S . A E _ 6 5 3      --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---       Copyright (C) 2002-2003, Free Software Foundation, Inc.            --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Export certain tasking-related routines for use by Interfaces.Vthreads\n-\n-with Interfaces.C;\n-package body System.Task_Primitives.Ae_653 is\n-\n-   -------------------\n-   -- ATCB_Key_Addr --\n-   -------------------\n-\n-   function ATCB_Key_Addr return Address_Access is\n-      Key_Addr : Address_Access;\n-      pragma Import (Ada, Key_Addr, \"__gnat_ATCB_key_addr\");\n-      --  Done this way to minimize impact on other targets. This\n-      --  implementation is temporary, and specific to AE653\n-   begin\n-      return Key_Addr;\n-   end ATCB_Key_Addr;\n-\n-   --------------------------\n-   -- Set_Current_Priority --\n-   --------------------------\n-\n-   procedure Set_Current_Priority\n-     (T : System.Tasking.Task_ID;\n-      Prio : System.Priority)\n-   is\n-   begin\n-      T.Common.Current_Priority := Prio;\n-   end Set_Current_Priority;\n-\n-   ---------------------\n-   -- Set_Task_Thread --\n-   ---------------------\n-\n-   procedure Set_Task_Thread\n-     (T : System.Tasking.Task_ID;\n-      Thread : System.OS_Interface.Thread_Id)\n-   is\n-      use System.OS_Interface;\n-      use System.Tasking;\n-      use type Interfaces.C.int;\n-      Result : STATUS;\n-   begin\n-      T.Common.LL.Thread := Thread;\n-      if taskVarGet (Thread, ATCB_Key_Addr) = ERROR then\n-         Result := taskVarAdd (Thread, ATCB_Key_Addr);\n-         pragma Assert (Result = OK);\n-      end if;\n-\n-      Result := taskVarSet (Thread, ATCB_Key_Addr, To_Address (T));\n-      pragma Assert (Result = OK);\n-   end Set_Task_Thread;\n-\n-end System.Task_Primitives.Ae_653;"}, {"sha": "641f17187d8767cb25def029b5dfad1ff23f2068", "filename": "gcc/ada/s-tpae65.ads", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fs-tpae65.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8738323373326f9d92d2df3eee27989bcee2044b/gcc%2Fada%2Fs-tpae65.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpae65.ads?ref=8738323373326f9d92d2df3eee27989bcee2044b", "patch": "@@ -1,54 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n---                                                                          --\n---           S Y S T E M . T A S K _ P R I M I T I V E S . A E _ 6 5 3      --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---       Copyright (C) 2002-2003, Free Software Foundation, Inc.            --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Export certain tasking-related routines for use by Interfaces.Vthreads\n-\n-with System.Tasking;\n-with System.OS_Interface;\n-package System.Task_Primitives.Ae_653 is\n-   type Address_Access is access System.Address;\n-\n-   function ATCB_Key_Addr return Address_Access;\n-   pragma Inline (ATCB_Key_Addr);\n-   --  Address of ATCB_Key taskvar\n-\n-   procedure Set_Current_Priority\n-     (T : System.Tasking.Task_ID; Prio : System.Priority);\n-   --  Set priority\n-\n-   procedure Set_Task_Thread\n-     (T : System.Tasking.Task_ID;\n-      Thread : System.OS_Interface.Thread_Id);\n-   --  Set \"Thread\" as the underlying OS thread implementing \"T\"\n-\n-end System.Task_Primitives.Ae_653;"}, {"sha": "b8f5c397654a4c55fe101169ca74ad40d94b2203", "filename": "gcc/ada/scans.ads", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -187,15 +187,21 @@ package Scans is\n \n       Tok_Dot_Dot,         -- ..           Sterm, Chtok\n \n-      --  The following three entries are used only when scanning\n-      --  project files.\n+      --  The following three entries are used only when scanning project\n+      --  files.\n \n       Tok_Project,\n       Tok_Extends,\n       Tok_External,\n+      Tok_Comment,\n+\n+      --  The following entry is used by the preprocessor and when scanning\n+      --  project files.\n \n-      --  The following two entries are used by the preprocessor\n       Tok_End_Of_Line,\n+\n+      --  The following entry is used by the preprocessor\n+\n       Tok_Special,\n \n       No_Token);\n@@ -404,6 +410,10 @@ package Scans is\n    Special_Character : Character;\n    --  Valid only when Token = Tok_Special\n \n+   Comment_Id : Name_Id := No_Name;\n+   --  Valid only when Token = Tok_Comment. Store the string that follows\n+   --  the two '-' of a comment.\n+\n    --------------------------------------------------------\n    -- Procedures for Saving and Restoring the Scan State --\n    --------------------------------------------------------"}, {"sha": "cb46bf189ee90138f42a5218de764dcbfeb73df7", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -49,6 +49,9 @@ package body Scng is\n    Special_Characters : array (Character) of Boolean := (others => False);\n    --  For characters that are Special token, the value is True\n \n+   Comment_Is_Token : Boolean := False;\n+   --  True if comments are tokens\n+\n    End_Of_Line_Is_Token : Boolean := False;\n    --  True if End_Of_Line is a token\n \n@@ -229,6 +232,8 @@ package body Scng is\n \n    procedure Scan is\n \n+      Start_Of_Comment : Source_Ptr;\n+\n       procedure Check_End_Of_Line;\n       --  Called when end of line encountered. Checks that line is not\n       --  too long, and that other style checks for the end of line are met.\n@@ -1394,6 +1399,7 @@ package body Scng is\n             else -- Source (Scan_Ptr + 1) = '-' then\n                if Style_Check then Style.Check_Comment; end if;\n                Scan_Ptr := Scan_Ptr + 2;\n+               Start_Of_Comment := Scan_Ptr;\n \n                --  Loop to scan comment (this loop runs more than once only if\n                --  a horizontal tab or other non-graphic character is scanned)\n@@ -1449,9 +1455,18 @@ package body Scng is\n \n                end loop;\n \n-               --  Note that we do NOT execute a return here, instead we fall\n-               --  through to reexecute the scan loop to look for a token.\n-\n+               --  Note that, except when comments are tokens, we do NOT\n+               --  execute a return here, instead we fall through to reexecute\n+               --  the scan loop to look for a token.\n+\n+               if Comment_Is_Token then\n+                  Name_Len := Integer (Scan_Ptr - Start_Of_Comment);\n+                  Name_Buffer (1 .. Name_Len) :=\n+                    String (Source (Start_Of_Comment .. Scan_Ptr - 1));\n+                  Comment_Id := Name_Find;\n+                  Token := Tok_Comment;\n+                  return;\n+               end if;\n             end if;\n          end Minus_Case;\n \n@@ -2066,6 +2081,14 @@ package body Scng is\n             return;\n          end if;\n    end Scan;\n+   --------------------------\n+   -- Set_Comment_As_Token --\n+   --------------------------\n+\n+   procedure Set_Comment_As_Token (Value : Boolean) is\n+   begin\n+      Comment_Is_Token := Value;\n+   end Set_Comment_As_Token;\n \n    ------------------------------\n    -- Set_End_Of_Line_As_Token --"}, {"sha": "31e81a7cd7fd095a9cbbd16594291d746f2414a7", "filename": "gcc/ada/scng.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fscng.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fscng.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -91,6 +91,10 @@ package Scng is\n    --  Indicate if End_Of_Line is a token or not.\n    --  By default, End_Of_Line is not a token.\n \n+   procedure Set_Comment_As_Token (Value : Boolean);\n+   --  Indicate if a comment is a token or not.\n+   --  By default, a comment is not a token.\n+\n    function Set_Start_Column return Column_Number;\n    --  This routine is called with Scan_Ptr pointing to the first character\n    --  of a line. On exit, Scan_Ptr is advanced to the first non-blank"}, {"sha": "897e9b500afa77a1aea8a1ffb5b4128022ef55e5", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -29,6 +29,7 @@ with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n+with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n@@ -334,7 +335,7 @@ package body Sem_Aggr is\n    --\n    --    Typ is the context type in which N occurs.\n    --\n-   --  This routine creates an implicit array subtype whose bouds are\n+   --  This routine creates an implicit array subtype whose bounds are\n    --  those defined by the aggregate. When this routine is invoked\n    --  Resolve_Array_Aggregate has already processed aggregate N. Thus the\n    --  Aggregate_Bounds of each sub-aggregate, is an N_Range node giving the\n@@ -962,6 +963,8 @@ package body Sem_Aggr is\n             --  formal parameter. Consequently we also need to test for\n             --  N_Procedure_Call_Statement or N_Function_Call.\n \n+            Set_Etype (N, Aggr_Typ);  --  may be overridden later on.\n+\n             if Is_Constrained (Typ) and then\n               (Pkind = N_Assignment_Statement      or else\n                Pkind = N_Parameter_Association     or else\n@@ -1641,9 +1644,27 @@ package body Sem_Aggr is\n                   end if;\n                end loop;\n \n-               if not\n-                 Resolve_Aggr_Expr\n-                   (Expression (Assoc), Single_Elmt => Single_Choice)\n+               --  Ada0Y (AI-287): In case of default initialized component\n+               --  we delay the resolution to the expansion phase\n+\n+               if Box_Present (Assoc) then\n+\n+                  --  Ada0Y (AI-287): In case of default initialization of a\n+                  --  component the expander will generate calls to the\n+                  --  corresponding initialization subprogram.\n+\n+                  if Present (Base_Init_Proc (Etype (Component_Typ)))\n+                    or else Has_Task (Base_Type (Component_Typ))\n+                  then\n+                     null;\n+                  else\n+                     Error_Msg_N\n+                       (\"(Ada 0Y): no value supplied for this component\",\n+                        Assoc);\n+                  end if;\n+\n+               elsif not Resolve_Aggr_Expr (Expression (Assoc),\n+                                            Single_Elmt => Single_Choice)\n                then\n                   return Failure;\n                end if;\n@@ -1764,8 +1785,26 @@ package body Sem_Aggr is\n \n          if Others_Present then\n             Assoc := Last (Component_Associations (N));\n-            if not Resolve_Aggr_Expr (Expression (Assoc),\n-                                      Single_Elmt => False)\n+\n+            --  Ada0Y (AI-287): In case of default initialized component\n+            --  we delay the resolution to the expansion phase.\n+\n+            if Box_Present (Assoc) then\n+\n+               --  Ada0Y (AI-287): In case of default initialization of a\n+               --  component the expander will generate calls to the\n+               --  corresponding initialization subprogram.\n+\n+               if Present (Base_Init_Proc (Etype (Component_Typ))) then\n+                  null;\n+               else\n+                  Error_Msg_N\n+                    (\"(Ada 0Y): no value supplied for these components\",\n+                     Assoc);\n+               end if;\n+\n+            elsif not Resolve_Aggr_Expr (Expression (Assoc),\n+                                         Single_Elmt => False)\n             then\n                return Failure;\n             end if;"}, {"sha": "1676ee85491915543f8f54e4c48db2bb61bbab6a", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -1466,7 +1466,10 @@ package body Sem_Ch12 is\n       end if;\n \n       if K = E_Generic_In_Parameter then\n-         if Is_Limited_Type (T) then\n+\n+         --  Ada0Y (AI-287): Limited aggregates allowed in generic formals\n+\n+         if not Extensions_Allowed and then Is_Limited_Type (T) then\n             Error_Msg_N\n               (\"generic formal of mode IN must not be of limited type\", N);\n             Explain_Limited_Type (T, N);"}, {"sha": "f14e049ec75e8f2278718660382cb226aeaf8dbe", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -6246,6 +6246,7 @@ package body Sem_Ch3 is\n       if (Is_Limited_Type (T)\n            or else Is_Limited_Composite (T))\n         and then not In_Instance\n+        and then not In_Inlined_Body\n       then\n          --  Ada0Y (AI-287): Relax the strictness of the front-end in case of\n          --  limited aggregates and extension aggregates.\n@@ -8438,18 +8439,6 @@ package body Sem_Ch3 is\n \n       Init_Size_Align (Implicit_Base);\n \n-      --  Complete entity for first subtype\n-\n-      Set_Ekind          (T, E_Decimal_Fixed_Point_Subtype);\n-      Set_Etype          (T, Implicit_Base);\n-      Set_Size_Info      (T, Implicit_Base);\n-      Set_First_Rep_Item (T, First_Rep_Item (Implicit_Base));\n-      Set_Digits_Value   (T, Digs_Val);\n-      Set_Delta_Value    (T, Delta_Val);\n-      Set_Small_Value    (T, Delta_Val);\n-      Set_Scale_Value    (T, Scale_Val);\n-      Set_Is_Constrained (T);\n-\n       --  If there are bounds given in the declaration use them as the\n       --  bounds of the first named subtype.\n \n@@ -8492,6 +8481,18 @@ package body Sem_Ch3 is\n          Set_Fixed_Range (T, Loc, -Bound_Val, Bound_Val);\n       end if;\n \n+      --  Complete entity for first subtype\n+\n+      Set_Ekind          (T, E_Decimal_Fixed_Point_Subtype);\n+      Set_Etype          (T, Implicit_Base);\n+      Set_Size_Info      (T, Implicit_Base);\n+      Set_First_Rep_Item (T, First_Rep_Item (Implicit_Base));\n+      Set_Digits_Value   (T, Digs_Val);\n+      Set_Delta_Value    (T, Delta_Val);\n+      Set_Small_Value    (T, Delta_Val);\n+      Set_Scale_Value    (T, Scale_Val);\n+      Set_Is_Constrained (T);\n+\n    end Decimal_Fixed_Point_Type_Declaration;\n \n    -----------------------"}, {"sha": "6183c0cc1a1e535f31eff2b030b984dc19aedf88", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -6371,6 +6371,9 @@ package body Sem_Util is\n             Error_Msg_N (\n               \"operator of the type is not directly visible!\", Expr);\n \n+         elsif Ekind (Found_Type) = E_Void then\n+            Error_Msg_NE (\"found premature usage of}!\", Expr, Found_Type);\n+\n          else\n             Error_Msg_NE (\"found}!\", Expr, Found_Type);\n          end if;"}, {"sha": "89befb6a0c687a74089a850a50ea0c5de7dc13e5", "filename": "gcc/ada/sinput-p.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsinput-p.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Fsinput-p.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.adb?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,7 +24,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Prj;         use Prj;\n with Prj.Err;\n with Sinput.C;\n \n@@ -97,7 +96,7 @@ package body Sinput.P is\n         or else Token = Tok_Private\n         or else (Token not in Token_Class_Cunit and then Token /= Tok_EOF)\n       loop\n-         Scan;\n+         Prj.Err.Scanner.Scan;\n       end loop;\n \n       return Token = Tok_Separate;"}, {"sha": "942b501af182e4a9f5adb44e2639ea8eee85cc07", "filename": "gcc/ada/targparm.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45b6ae00734eed1f2b94db390e326a31169b422/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=c45b6ae00734eed1f2b94db390e326a31169b422", "patch": "@@ -322,12 +322,6 @@ package Targparm is\n    --\n    --    The variable __gnat_exit_status is generated within the binder file\n    --    instead of being imported from the run-time library.\n-   --\n-   --    No -Ldir switches are added for the linker step\n-   --\n-   --    No standard switches are added after user file entries to the\n-   --    linker line. All such switches must be explicit. In other words\n-   --    the option -nostdlib is implicit with a configurable run-time.\n \n    Suppress_Standard_Library_On_Target : Boolean;\n    --  If this flag is True, then the standard library is not included by"}]}