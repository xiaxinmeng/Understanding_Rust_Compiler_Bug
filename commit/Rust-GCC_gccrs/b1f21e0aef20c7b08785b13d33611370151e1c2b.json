{"sha": "b1f21e0aef20c7b08785b13d33611370151e1c2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFmMjFlMGFlZjIwYzdiMDg3ODViMTNkMzM2MTEzNzAxNTFlMWMyYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-05-30T18:19:19Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-05-30T18:19:19Z"}, "message": "Use accessor macros to access arrays based on regno; move many of the arrays into a single structure.\n\nFrom-SVN: r14140", "tree": {"sha": "d0a740f7c442c0501cc25e82b00fb98ae4018ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0a740f7c442c0501cc25e82b00fb98ae4018ac5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1f21e0aef20c7b08785b13d33611370151e1c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f21e0aef20c7b08785b13d33611370151e1c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1f21e0aef20c7b08785b13d33611370151e1c2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f21e0aef20c7b08785b13d33611370151e1c2b/comments", "author": null, "committer": null, "parents": [{"sha": "e00737d221dbedf7f176a5c1d09ec3e4d855fc72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e00737d221dbedf7f176a5c1d09ec3e4d855fc72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e00737d221dbedf7f176a5c1d09ec3e4d855fc72"}], "stats": {"total": 680, "additions": 320, "deletions": 360}, "files": [{"sha": "3d1f3a9f30b8241f5c372b42a43c5abd04f930ad", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -66,4 +66,5 @@ extern regset *basic_block_live_at_start;\n \n #define REG_BLOCK_UNKNOWN -1\n #define REG_BLOCK_GLOBAL -2\n-extern int *reg_basic_block;\n+\n+#define REG_BASIC_BLOCK(N) (reg_n_info[(N)].basic_block)"}, {"sha": "f05f3271d9657e49f8a592acebcbafcc29eaa169", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -262,7 +262,7 @@ setup_save_areas (pchanged)\n   /* Find and record all call-used hard-registers in this function.  */\n   CLEAR_HARD_REG_SET (hard_regs_used);\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_renumber[i] >= 0 && reg_n_calls_crossed[i] > 0)\n+    if (reg_renumber[i] >= 0 && REG_N_CALLS_CROSSED (i) > 0)\n       {\n \tint regno = reg_renumber[i];\n \tint endregno "}, {"sha": "12538fd88297e61b6dd728d604bec3782de4ba1a", "filename": "gcc/combine.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -1589,7 +1589,7 @@ try_combine (i3, i2, i1)\n \t  rtx new_dest = gen_rtx (REG, compare_mode, regno);\n \n \t  if (regno < FIRST_PSEUDO_REGISTER\n-\t      || (reg_n_sets[regno] == 1 && ! added_sets_2\n+\t      || (REG_N_SETS (regno) == 1 && ! added_sets_2\n \t\t  && ! REG_USERVAR_P (SET_DEST (newpat))))\n \t    {\n \t      if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -1792,7 +1792,7 @@ try_combine (i3, i2, i1)\n \t      && GET_MODE (SET_DEST (newpat)) != VOIDmode\n \t      && GET_CODE (i2dest) == REG\n \t      && (REGNO (i2dest) < FIRST_PSEUDO_REGISTER\n-\t\t  || (reg_n_sets[REGNO (i2dest)] == 1 && ! added_sets_2\n+\t\t  || (REG_N_SETS (REGNO (i2dest)) == 1 && ! added_sets_2\n \t\t      && ! REG_USERVAR_P (i2dest))))\n \t    ni2dest = gen_rtx (REG, GET_MODE (SET_DEST (newpat)),\n \t\t\t       REGNO (i2dest));\n@@ -1861,7 +1861,7 @@ try_combine (i3, i2, i1)\n \t      if (GET_CODE (new_i3_dest) == REG\n \t\t  && GET_CODE (new_i2_dest) == REG\n \t\t  && REGNO (new_i3_dest) == REGNO (new_i2_dest))\n-\t\treg_n_sets[REGNO (new_i2_dest)]++;\n+\t\tREG_N_SETS (REGNO (new_i2_dest))++;\n \t    }\n \t}\n \n@@ -1877,7 +1877,7 @@ try_combine (i3, i2, i1)\n \t  && (GET_MODE (*split) == GET_MODE (i2dest)\n \t      || GET_MODE (*split) == VOIDmode\n \t      || REGNO (i2dest) < FIRST_PSEUDO_REGISTER\n-\t      || (reg_n_sets[REGNO (i2dest)] == 1 && ! added_sets_2\n+\t      || (REG_N_SETS (REGNO (i2dest)) == 1 && ! added_sets_2\n \t\t  && ! REG_USERVAR_P (i2dest)))\n \t  && (next_real_insn (i2) == i3\n \t      || ! use_crosses_set_p (*split, INSN_CUID (i2)))\n@@ -2113,15 +2113,15 @@ try_combine (i3, i2, i1)\n \t      && ! reg_set_p (XEXP (note, 0), PATTERN (undobuf.other_insn)))\n \t    {\n \t      if (GET_CODE (XEXP (note, 0)) == REG)\n-\t\treg_n_deaths[REGNO (XEXP (note, 0))]--;\n+\t\tREG_N_DEATHS (REGNO (XEXP (note, 0)))--;\n \n \t      remove_note (undobuf.other_insn, note);\n \t    }\n \t}\n \n       for (note = new_other_notes; note; note = XEXP (note, 1))\n \tif (GET_CODE (XEXP (note, 0)) == REG)\n-\t  reg_n_deaths[REGNO (XEXP (note, 0))]++;\n+\t  REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n \n       distribute_notes (new_other_notes, undobuf.other_insn,\n \t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX);\n@@ -2272,7 +2272,7 @@ try_combine (i3, i2, i1)\n       {\n \tfor (temp = new_i2_notes; temp; temp = XEXP (temp, 1))\n \t  if (GET_CODE (XEXP (temp, 0)) == REG)\n-\t    reg_n_deaths[REGNO (XEXP (temp, 0))]++;\n+\t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n \t\n \tdistribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n@@ -2281,7 +2281,7 @@ try_combine (i3, i2, i1)\n       {\n \tfor (temp = new_i3_notes; temp; temp = XEXP (temp, 1))\n \t  if (GET_CODE (XEXP (temp, 0)) == REG)\n-\t    reg_n_deaths[REGNO (XEXP (temp, 0))]++;\n+\t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n \t\n \tdistribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n@@ -2294,7 +2294,7 @@ try_combine (i3, i2, i1)\n     if (i3dest_killed)\n       {\n \tif (GET_CODE (i3dest_killed) == REG)\n-\t  reg_n_deaths[REGNO (i3dest_killed)]++;\n+\t  REG_N_DEATHS (REGNO (i3dest_killed))++;\n \n \tdistribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed,\n \t\t\t\t   NULL_RTX),\n@@ -2309,7 +2309,7 @@ try_combine (i3, i2, i1)\n     if (i2dest_in_i2src)\n       {\n \tif (GET_CODE (i2dest) == REG)\n-\t  reg_n_deaths[REGNO (i2dest)]++;\n+\t  REG_N_DEATHS (REGNO (i2dest))++;\n \n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n \t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i2dest, NULL_RTX),\n@@ -2323,7 +2323,7 @@ try_combine (i3, i2, i1)\n     if (i1dest_in_i1src)\n       {\n \tif (GET_CODE (i1dest) == REG)\n-\t  reg_n_deaths[REGNO (i1dest)]++;\n+\t  REG_N_DEATHS (REGNO (i1dest))++;\n \n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n \t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i1dest, NULL_RTX),\n@@ -2365,11 +2365,11 @@ try_combine (i3, i2, i1)\n \t    && ! i2dest_in_i2src)\n \t  {\n \t    regno = REGNO (i2dest);\n-\t    reg_n_sets[regno]--;\n-\t    if (reg_n_sets[regno] == 0\n+\t    REG_N_SETS (regno)--;\n+\t    if (REG_N_SETS (regno) == 0\n \t\t&& ! (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n \t\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n-\t      reg_n_refs[regno] = 0;\n+\t      REG_N_REFS (regno) = 0;\n \t  }\n       }\n \n@@ -2388,11 +2388,11 @@ try_combine (i3, i2, i1)\n \tregno = REGNO (i1dest);\n \tif (! added_sets_1 && ! i1dest_in_i1src)\n \t  {\n-\t    reg_n_sets[regno]--;\n-\t    if (reg_n_sets[regno] == 0\n+\t    REG_N_SETS (regno)--;\n+\t    if (REG_N_SETS (regno) == 0\n \t\t&& ! (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n \t\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n-\t      reg_n_refs[regno] = 0;\n+\t      REG_N_REFS (regno) = 0;\n \t  }\n       }\n \n@@ -4457,7 +4457,7 @@ simplify_set (x)\n \t  rtx new_dest = gen_rtx (REG, compare_mode, regno);\n \n \t  if (regno < FIRST_PSEUDO_REGISTER\n-\t      || (reg_n_sets[regno] == 1 && ! REG_USERVAR_P (dest)))\n+\t      || (REG_N_SETS (regno) == 1 && ! REG_USERVAR_P (dest)))\n \t    {\n \t      if (regno >= FIRST_PSEUDO_REGISTER)\n \t\tSUBST (regno_reg_rtx[regno], new_dest);\n@@ -7246,7 +7246,7 @@ nonzero_bits (x, mode)\n \n       if (reg_last_set_value[REGNO (x)] != 0\n \t  && reg_last_set_mode[REGNO (x)] == mode\n-\t  && (reg_n_sets[REGNO (x)] == 1\n+\t  && (REG_N_SETS (REGNO (x)) == 1\n \t      || reg_last_set_label[REGNO (x)] == label_tick)\n \t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n \treturn reg_last_set_nonzero_bits[REGNO (x)];\n@@ -7595,7 +7595,7 @@ num_sign_bit_copies (x, mode)\n \n       if (reg_last_set_value[REGNO (x)] != 0\n \t  && reg_last_set_mode[REGNO (x)] == mode\n-\t  && (reg_n_sets[REGNO (x)] == 1\n+\t  && (REG_N_SETS (REGNO (x)) == 1\n \t      || reg_last_set_label[REGNO (x)] == label_tick)\n \t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n \treturn reg_last_set_sign_bit_copies[REGNO (x)];\n@@ -8872,7 +8872,7 @@ gen_lowpart_for_combine (mode, x)\n       && REGNO (SUBREG_REG (result)) >= FIRST_PSEUDO_REGISTER\n       && (GET_MODE_SIZE (GET_MODE (result))\n \t  != GET_MODE_SIZE (GET_MODE (SUBREG_REG (result)))))\n-    reg_changes_size[REGNO (SUBREG_REG (result))] = 1;\n+    REG_CHANGES_SIZE (REGNO (SUBREG_REG (result))) = 1;\n \n   if (result)\n     return result;\n@@ -10351,7 +10351,7 @@ get_last_value_validate (loc, insn, tick, replace)\n \tif (reg_last_set_invalid[j]\n \t    /* If this is a pseudo-register that was only set once, it is\n \t       always valid.  */\n-\t    || (! (regno >= FIRST_PSEUDO_REGISTER && reg_n_sets[regno] == 1)\n+\t    || (! (regno >= FIRST_PSEUDO_REGISTER && REG_N_SETS (regno) == 1)\n \t\t&& reg_last_set_label[j] > tick))\n \t  {\n \t    if (replace)\n@@ -10414,7 +10414,7 @@ get_last_value (x)\n      return 0.  */\n \n   if (value == 0\n-      || (reg_n_sets[regno] != 1\n+      || (REG_N_SETS (regno) != 1\n \t  && reg_last_set_label[regno] != label_tick))\n     return 0;\n \n@@ -10746,7 +10746,7 @@ remove_death (regno, insn)\n \n   if (note)\n     {\n-      reg_n_deaths[regno]--;\n+      REG_N_DEATHS (regno)--;\n       remove_note (insn, note);\n     }\n \n@@ -10864,7 +10864,7 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n \t  else\n \t    *pnotes = gen_rtx (EXPR_LIST, REG_DEAD, x, *pnotes);\n \n-\t  reg_n_deaths[regno]++;\n+\t  REG_N_DEATHS (regno)++;\n \t}\n \n       return;\n@@ -11163,9 +11163,9 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t     special case.  */\n \n \t  if (place == i3 && i2 != 0 && GET_CODE (XEXP (note, 0)) == REG\n-\t      && reg_n_refs[REGNO (XEXP (note, 0))]== 2\n+\t      && REG_N_REFS (REGNO (XEXP (note, 0)))== 2\n \t      && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n-\t    reg_n_refs[REGNO (XEXP (note, 0))] = 3;\n+\t    REG_N_REFS (REGNO (XEXP (note, 0))) = 3;\n \n \t  if (place == 0)\n \t    {\n@@ -11389,14 +11389,14 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n       else if ((REG_NOTE_KIND (note) == REG_DEAD\n \t\t|| REG_NOTE_KIND (note) == REG_UNUSED)\n \t       && GET_CODE (XEXP (note, 0)) == REG)\n-\treg_n_deaths[REGNO (XEXP (note, 0))]--;\n+\tREG_N_DEATHS (REGNO (XEXP (note, 0)))--;\n \n       if (place2)\n \t{\n \t  if ((REG_NOTE_KIND (note) == REG_DEAD\n \t       || REG_NOTE_KIND (note) == REG_UNUSED)\n \t      && GET_CODE (XEXP (note, 0)) == REG)\n-\t    reg_n_deaths[REGNO (XEXP (note, 0))]++;\n+\t    REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n \n \t  REG_NOTES (place2) = gen_rtx (GET_CODE (note), REG_NOTE_KIND (note),\n \t\t\t\t\tXEXP (note, 0), REG_NOTES (place2));"}, {"sha": "540ecdfc50f1cbfad12f979cc122b727cfe22375", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -873,11 +873,11 @@ make_regs_eqv (new, old)\n       && ((new < FIRST_PSEUDO_REGISTER && FIXED_REGNO_P (new))\n \t  || (new >= FIRST_PSEUDO_REGISTER\n \t      && (firstr < FIRST_PSEUDO_REGISTER\n-\t\t  || ((uid_cuid[regno_last_uid[new]] > cse_basic_block_end\n-\t\t       || (uid_cuid[regno_first_uid[new]]\n+\t\t  || ((uid_cuid[REGNO_LAST_UID (new)] > cse_basic_block_end\n+\t\t       || (uid_cuid[REGNO_FIRST_UID (new)]\n \t\t\t   < cse_basic_block_start))\n-\t\t      && (uid_cuid[regno_last_uid[new]]\n-\t\t\t  > uid_cuid[regno_last_uid[firstr]]))))))\n+\t\t      && (uid_cuid[REGNO_LAST_UID (new)]\n+\t\t\t  > uid_cuid[REGNO_LAST_UID (firstr)]))))))\n     {\n       reg_prev_eqv[firstr] = new;\n       reg_next_eqv[new] = firstr;\n@@ -6500,7 +6500,7 @@ cse_insn (insn, in_libcall_block)\n \t  && find_reg_note (insn, REG_EQUIV, src) != 0\n \t  && GET_CODE (dest) == REG\n \t  && REGNO (dest) >= FIRST_PSEUDO_REGISTER\n-\t  && reg_n_sets[REGNO (dest)] != 1)\n+\t  && REG_N_SETS (REGNO (dest)) != 1)\n \tsets[i].src_volatile = 1;\n \n #if 0"}, {"sha": "12a9bf90641ffa88f6f52022fa787c5d380dfe7a", "filename": "gcc/flow.c", "status": "modified", "additions": 48, "deletions": 108, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -164,56 +164,9 @@ int max_scratch;\n \n static int num_scratch;\n \n-/* Indexed by n, gives number of basic block that  (REG n) is used in.\n-   If the value is REG_BLOCK_GLOBAL (-2),\n-   it means (REG n) is used in more than one basic block.\n-   REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.\n-   This information remains valid for the rest of the compilation\n-   of the current function; it is used to control register allocation.  */\n+/* Indexed by n, giving various register information */\n \n-int *reg_basic_block;\n-\n-/* Indexed by n, gives number of times (REG n) is used or set, each\n-   weighted by its loop-depth.\n-   This information remains valid for the rest of the compilation\n-   of the current function; it is used to control register allocation.  */\n-\n-int *reg_n_refs;\n-\n-/* Indexed by N; says whether a pseudo register N was ever used\n-   within a SUBREG that changes the size of the reg.  Some machines prohibit\n-   such objects to be in certain (usually floating-point) registers.  */\n-\n-char *reg_changes_size;\n-\n-/* Indexed by N, gives number of places register N dies.\n-   This information remains valid for the rest of the compilation\n-   of the current function; it is used to control register allocation.  */\n-\n-short *reg_n_deaths;\n-\n-/* Indexed by N, gives 1 if that reg is live across any CALL_INSNs.\n-   This information remains valid for the rest of the compilation\n-   of the current function; it is used to control register allocation.  */\n-\n-int *reg_n_calls_crossed;\n-\n-/* Total number of instructions at which (REG n) is live.\n-   The larger this is, the less priority (REG n) gets for\n-   allocation in a real register.\n-   This information remains valid for the rest of the compilation\n-   of the current function; it is used to control register allocation.\n-\n-   local-alloc.c may alter this number to change the priority.\n-\n-   Negative values are special.\n-   -1 is used to mark a pseudo reg which has a constant or memory equivalent\n-   and is used infrequently enough that it should not get a hard register.\n-   -2 is used to mark a pseudo reg for a parameter, when a frame pointer\n-   is not required.  global.c makes an allocno for this but does\n-   not try to assign a hard register to it.  */\n-\n-int *reg_live_length;\n+reg_info *reg_n_info;\n \n /* Element N is the next insn that uses (hard or pseudo) register number N\n    within the current basic block; or zero, if there is no such insn.\n@@ -1252,7 +1205,7 @@ life_analysis (f, nregs)\n     for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n       if (basic_block_live_at_start[0][i / REGSET_ELT_BITS]\n \t  & ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n-\treg_basic_block[i] = REG_BLOCK_GLOBAL;\n+\tREG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n \n   /* Now the life information is accurate.\n      Make one more pass over each basic block\n@@ -1288,8 +1241,8 @@ life_analysis (f, nregs)\n \t& ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS))\n \t&& regno_reg_rtx[i] != 0 && ! REG_USERVAR_P (regno_reg_rtx[i]))\n       {\n-\treg_live_length[i] = -1;\n-\treg_basic_block[i] = -1;\n+\tREG_LIVE_LENGTH (i) = -1;\n+\tREG_BASIC_BLOCK (i) = -1;\n       }\n #endif\n #endif\n@@ -1308,8 +1261,8 @@ life_analysis (f, nregs)\n \t & ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n \t&& regno_reg_rtx[i] != 0)\n       {\n-\treg_live_length[i] = -1;\n-\treg_basic_block[i] = -1;\n+\tREG_LIVE_LENGTH (i) = -1;\n+\tREG_BASIC_BLOCK (i) = -1;\n       }\n \n   obstack_free (&flow_obstack, NULL_PTR);\n@@ -1329,27 +1282,14 @@ allocate_for_life_analysis ()\n   regset_size = ((max_regno + REGSET_ELT_BITS - 1) / REGSET_ELT_BITS);\n   regset_bytes = regset_size * sizeof (*(regset) 0);\n \n-  reg_n_refs = (int *) oballoc (max_regno * sizeof (int));\n-  bzero ((char *) reg_n_refs, max_regno * sizeof (int));\n-\n-  reg_n_sets = (short *) oballoc (max_regno * sizeof (short));\n-  bzero ((char *) reg_n_sets, max_regno * sizeof (short));\n-\n-  reg_n_deaths = (short *) oballoc (max_regno * sizeof (short));\n-  bzero ((char *) reg_n_deaths, max_regno * sizeof (short));\n-\n-  reg_changes_size = (char *) oballoc (max_regno * sizeof (char));\n-  bzero (reg_changes_size, max_regno * sizeof (char));;\n-\n-  reg_live_length = (int *) oballoc (max_regno * sizeof (int));\n-  bzero ((char *) reg_live_length, max_regno * sizeof (int));\n-\n-  reg_n_calls_crossed = (int *) oballoc (max_regno * sizeof (int));\n-  bzero ((char *) reg_n_calls_crossed, max_regno * sizeof (int));\n+  /* Because both reg_scan and flow_analysis want to set up the REG_N_SETS\n+     information, explicitly reset it here.  The allocation should have\n+     already happened on the previous reg_scan pass.  Make sure in case\n+     some more registers were allocated.  */\n+  allocate_reg_info (max_regno, FALSE);\n \n-  reg_basic_block = (int *) oballoc (max_regno * sizeof (int));\n   for (i = 0; i < max_regno; i++)\n-    reg_basic_block[i] = REG_BLOCK_UNKNOWN;\n+    REG_N_SETS (i) = 0;\n \n   basic_block_live_at_start\n     = (regset *) oballoc (n_basic_blocks * sizeof (regset));\n@@ -1476,7 +1416,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t      break;\n \t    if (old[offset] & bit)\n \t      {\n-\t\treg_basic_block[i] = REG_BLOCK_GLOBAL;\n+\t\tREG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL;\n \t\tregs_sometimes_live[sometimes_max].offset = offset;\n \t\tregs_sometimes_live[sometimes_max].bit = i % REGSET_ELT_BITS;\n \t\tsometimes_max++;\n@@ -1699,7 +1639,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \n \t\t  for (i = 0; i < sometimes_max; i++, p++)\n \t\t    if (old[p->offset] & ((REGSET_ELT_TYPE) 1 << p->bit))\n-\t\t      reg_n_calls_crossed[p->offset * REGSET_ELT_BITS + p->bit]+= 1;\n+\t\t      REG_N_CALLS_CROSSED (p->offset * REGSET_ELT_BITS + p->bit)++;\n \t\t}\n \t    }\n \n@@ -1733,7 +1673,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\tfor (i = 0; i < sometimes_max; i++, p++)\n \t\t  {\n \t\t    if (old[p->offset] & ((REGSET_ELT_TYPE) 1 << p->bit))\n-\t\t      reg_live_length[p->offset * REGSET_ELT_BITS + p->bit]++;\n+\t\t      REG_LIVE_LENGTH (p->offset * REGSET_ELT_BITS + p->bit)++;\n \t\t  }\n \t      }\n \t    }\n@@ -1941,7 +1881,7 @@ regno_clobbered_at_setjmp (regno)\n   if (n_basic_blocks == 0)\n     return 0;\n \n-  return ((reg_n_sets[regno] > 1\n+  return ((REG_N_SETS (regno) > 1\n \t   || (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n \t       & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n \t  && (regs_live_at_setjmp[regno / REGSET_ELT_BITS]\n@@ -2098,7 +2038,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t\t  reg_next_use[i] = 0;\n \n \t\t  regs_ever_live[i] = 1;\n-\t\t  reg_n_sets[i]++;\n+\t\t  REG_N_SETS (i)++;\n \t\t}\n \t    }\n \t  else\n@@ -2109,22 +2049,22 @@ mark_set_1 (needed, dead, x, insn, significant)\n \n \t      /* Keep track of which basic blocks each reg appears in.  */\n \n-\t      if (reg_basic_block[regno] == REG_BLOCK_UNKNOWN)\n-\t\treg_basic_block[regno] = blocknum;\n-\t      else if (reg_basic_block[regno] != blocknum)\n-\t\treg_basic_block[regno] = REG_BLOCK_GLOBAL;\n+\t      if (REG_BASIC_BLOCK (regno) == REG_BLOCK_UNKNOWN)\n+\t\tREG_BASIC_BLOCK (regno) = blocknum;\n+\t      else if (REG_BASIC_BLOCK (regno) != blocknum)\n+\t\tREG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n \n \t      /* Count (weighted) references, stores, etc.  This counts a\n \t\t register twice if it is modified, but that is correct.  */\n-\t      reg_n_sets[regno]++;\n+\t      REG_N_SETS (regno)++;\n \n-\t      reg_n_refs[regno] += loop_depth;\n+\t      REG_N_REFS (regno) += loop_depth;\n \t\t  \n \t      /* The insns where a reg is live are normally counted\n \t\t elsewhere, but we want the count to include the insn\n \t\t where the reg is set, and the normal counting mechanism\n \t\t would not count it.  */\n-\t      reg_live_length[regno]++;\n+\t      REG_LIVE_LENGTH (regno)++;\n \t    }\n \n \t  if (! some_not_needed)\n@@ -2152,7 +2092,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t\t Indicate this by marking the reg being set as dying here.  */\n \t      REG_NOTES (insn)\n \t\t= gen_rtx (EXPR_LIST, REG_UNUSED, reg, REG_NOTES (insn));\n-\t      reg_n_deaths[REGNO (reg)]++;\n+\t      REG_N_DEATHS (REGNO (reg))++;\n \t    }\n \t  else\n \t    {\n@@ -2338,7 +2278,7 @@ find_auto_inc (needed, x, insn)\n \t\t that REGNO now crosses them.  */\n \t      for (temp = insn; temp != incr; temp = NEXT_INSN (temp))\n \t\tif (GET_CODE (temp) == CALL_INSN)\n-\t\t  reg_n_calls_crossed[regno]++;\n+\t\t  REG_N_CALLS_CROSSED (regno)++;\n \t    }\n \t  else\n \t    return;\n@@ -2370,11 +2310,11 @@ find_auto_inc (needed, x, insn)\n \t      /* Count an extra reference to the reg.  When a reg is\n \t\t incremented, spilling it is worse, so we want to make\n \t\t that less likely.  */\n-\t      reg_n_refs[regno] += loop_depth;\n+\t      REG_N_REFS (regno) += loop_depth;\n \n \t      /* Count the increment as a setting of the register,\n \t\t even though it isn't a SET in rtl.  */\n-\t      reg_n_sets[regno]++;\n+\t      REG_N_SETS (regno)++;\n \t    }\n \t}\n     }\n@@ -2447,7 +2387,7 @@ mark_used_regs (needed, live, x, final, insn)\n \t  && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER\n \t  && (GET_MODE_SIZE (GET_MODE (x))\n \t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n-\treg_changes_size[REGNO (SUBREG_REG (x))] = 1;\n+\tREG_CHANGES_SIZE (REGNO (SUBREG_REG (x))) = 1;\n \n       /* While we're here, optimize this case.  */\n       x = SUBREG_REG (x);\n@@ -2549,14 +2489,14 @@ mark_used_regs (needed, live, x, final, insn)\n \n \t\tregister int blocknum = BLOCK_NUM (insn);\n \n-\t\tif (reg_basic_block[regno] == REG_BLOCK_UNKNOWN)\n-\t\t  reg_basic_block[regno] = blocknum;\n-\t\telse if (reg_basic_block[regno] != blocknum)\n-\t\t  reg_basic_block[regno] = REG_BLOCK_GLOBAL;\n+\t\tif (REG_BASIC_BLOCK (regno) == REG_BLOCK_UNKNOWN)\n+\t\t  REG_BASIC_BLOCK (regno) = blocknum;\n+\t\telse if (REG_BASIC_BLOCK (regno) != blocknum)\n+\t\t  REG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n \n \t\t/* Count (weighted) number of uses of each reg.  */\n \n-\t\treg_n_refs[regno] += loop_depth;\n+\t\tREG_N_REFS (regno) += loop_depth;\n \t      }\n \n \t    /* Record and count the insns in which a reg dies.\n@@ -2588,7 +2528,7 @@ mark_used_regs (needed, live, x, final, insn)\n \t\t  {\n \t\t    REG_NOTES (insn)\n \t\t      = gen_rtx (EXPR_LIST, REG_DEAD, x, REG_NOTES (insn));\n-\t\t    reg_n_deaths[regno]++;\n+\t\t    REG_N_DEATHS (regno)++;\n \t\t  }\n \t\telse\n \t\t  {\n@@ -2649,7 +2589,7 @@ mark_used_regs (needed, live, x, final, insn)\n \t\t&& REGNO (SUBREG_REG (testreg)) >= FIRST_PSEUDO_REGISTER\n \t\t&& (GET_MODE_SIZE (GET_MODE (testreg))\n \t\t    != GET_MODE_SIZE (GET_MODE (SUBREG_REG (testreg)))))\n-\t      reg_changes_size[REGNO (SUBREG_REG (testreg))] = 1;\n+\t      REG_CHANGES_SIZE (REGNO (SUBREG_REG (testreg))) = 1;\n \n \t    /* Modifying a single register in an alternate mode\n \t       does not use any of the old value.  But these other\n@@ -2770,8 +2710,8 @@ try_pre_increment_1 (insn)\n \t less likely.  */\n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  reg_n_refs[regno] += loop_depth;\n-\t  reg_n_sets[regno]++;\n+\t  REG_N_REFS (regno) += loop_depth;\n+\t  REG_N_SETS (regno)++;\n \t}\n       return 1;\n     }\n@@ -2944,19 +2884,19 @@ dump_flow_info (file)\n   fprintf (file, \"%d registers.\\n\", max_regno);\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_n_refs[i])\n+    if (REG_N_REFS (i))\n       {\n \tenum reg_class class, altclass;\n \tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t i, reg_n_refs[i], reg_live_length[i]);\n-\tif (reg_basic_block[i] >= 0)\n-\t  fprintf (file, \" in block %d\", reg_basic_block[i]);\n-\tif (reg_n_deaths[i] != 1)\n-\t  fprintf (file, \"; dies in %d places\", reg_n_deaths[i]);\n-\tif (reg_n_calls_crossed[i] == 1)\n+\t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n+\tif (REG_BASIC_BLOCK (i) >= 0)\n+\t  fprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n+\tif (REG_N_DEATHS (i) != 1)\n+\t  fprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n+\tif (REG_N_CALLS_CROSSED (i) == 1)\n \t  fprintf (file, \"; crosses 1 call\");\n-\telse if (reg_n_calls_crossed[i])\n-\t  fprintf (file, \"; crosses %d calls\", reg_n_calls_crossed[i]);\n+\telse if (REG_N_CALLS_CROSSED (i))\n+\t  fprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n \tif (PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n \t  fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n \tclass = reg_preferred_class (i);"}, {"sha": "ed2f9eaa561e26a7dd44fd1c8f2264494c4ed82e", "filename": "gcc/global.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -385,17 +385,17 @@ global_alloc (file)\n     /* Note that reg_live_length[i] < 0 indicates a \"constant\" reg\n        that we are supposed to refrain from putting in a hard reg.\n        -2 means do make an allocno but don't allocate it.  */\n-    if (reg_n_refs[i] != 0 && reg_renumber[i] < 0 && reg_live_length[i] != -1\n+    if (REG_N_REFS (i) != 0 && reg_renumber[i] < 0 && REG_LIVE_LENGTH (i) != -1\n \t/* Don't allocate pseudos that cross calls,\n \t   if this function receives a nonlocal goto.  */\n \t&& (! current_function_has_nonlocal_label\n-\t    || reg_n_calls_crossed[i] == 0))\n+\t    || REG_N_CALLS_CROSSED (i) == 0))\n       {\n \tif (reg_may_share[i] && reg_allocno[reg_may_share[i]] >= 0)\n \t  reg_allocno[i] = reg_allocno[reg_may_share[i]];\n \telse\n \t  reg_allocno[i] = max_allocno++;\n-\tif (reg_live_length[i] == 0)\n+\tif (REG_LIVE_LENGTH (i) == 0)\n \t  abort ();\n       }\n     else\n@@ -417,10 +417,10 @@ global_alloc (file)\n \tint allocno = reg_allocno[i];\n \tallocno_reg[allocno] = i;\n \tallocno_size[allocno] = PSEUDO_REGNO_SIZE (i);\n-\tallocno_calls_crossed[allocno] += reg_n_calls_crossed[i];\n-\tallocno_n_refs[allocno] += reg_n_refs[i];\n-\tif (allocno_live_length[allocno] < reg_live_length[i])\n-\t  allocno_live_length[allocno] = reg_live_length[i];\n+\tallocno_calls_crossed[allocno] += REG_N_CALLS_CROSSED (i);\n+\tallocno_n_refs[allocno] += REG_N_REFS (i);\n+\tif (allocno_live_length[allocno] < REG_LIVE_LENGTH (i))\n+\t  allocno_live_length[allocno] = REG_LIVE_LENGTH (i);\n       }\n \n   /* Calculate amount of usage of each hard reg by pseudos\n@@ -437,8 +437,8 @@ global_alloc (file)\n \n \tfor (j = regno; j < endregno; j++)\n \t  {\n-\t    local_reg_n_refs[j] += reg_n_refs[i];\n-\t    local_reg_live_length[j] += reg_live_length[i];\n+\t    local_reg_n_refs[j] += REG_N_REFS (i);\n+\t    local_reg_live_length[j] += REG_LIVE_LENGTH (i);\n \t  }\n       }\n \n@@ -554,7 +554,7 @@ global_alloc (file)\n \t except for parameters marked with reg_live_length[regno] == -2.  */\n \n       for (i = 0; i < max_allocno; i++)\n-\tif (reg_live_length[allocno_reg[allocno_order[i]]] >= 0)\n+\tif (REG_LIVE_LENGTH (allocno_reg[allocno_order[i]]) >= 0)\n \t  {\n \t    /* If we have more than one register class,\n \t       first try allocating in the class that is cheapest\n@@ -940,7 +940,7 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n   IOR_HARD_REG_SET (used1, hard_reg_conflicts[allocno]);\n \n #ifdef CLASS_CANNOT_CHANGE_SIZE\n-  if (reg_changes_size[allocno_reg[allocno]])\n+  if (REG_CHANGES_SIZE (allocno_reg[allocno]))\n     IOR_HARD_REG_SET (used1,\n \t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE]);\n #endif\n@@ -1127,7 +1127,7 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t      && ! TEST_HARD_REG_BIT (used2, regno)\n \t      && HARD_REGNO_MODE_OK (regno, mode)\n #ifdef CLASS_CANNOT_CHANGE_SIZE\n-\t      && ! (reg_changes_size[allocno_reg[allocno]]\n+\t      && ! (REG_CHANGES_SIZE (allocno_reg[allocno])\n \t\t    && (TEST_HARD_REG_BIT\n \t\t\t(reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE],\n \t\t\t regno)))"}, {"sha": "b27786380a36fb70c7e63b86f4955fc7a1fcf967", "filename": "gcc/jump.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -570,11 +570,11 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \tif (set && GET_CODE (SET_DEST (set)) == REG\n \t    && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n-\t    && regno_first_uid[REGNO (SET_DEST (set))] == INSN_UID (insn)\n+\t    && REGNO_FIRST_UID (REGNO (SET_DEST (set))) == INSN_UID (insn)\n \t    /* We use regno_last_note_uid so as not to delete the setting\n \t       of a reg that's used in notes.  A subsequent optimization\n \t       might arrange to use that reg for real.  */\t       \n-\t    && regno_last_note_uid[REGNO (SET_DEST (set))] == INSN_UID (insn)\n+\t    && REGNO_LAST_NOTE_UID (REGNO (SET_DEST (set))) == INSN_UID (insn)\n \t    && ! side_effects_p (SET_SRC (set))\n \t    && ! find_reg_note (insn, REG_RETVAL, 0))\n \t  delete_insn (insn);\n@@ -1085,8 +1085,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t       && (temp5 = SUBREG_REG (temp5),\n \t\t\t   GET_CODE (temp5) == REG))))\n \t      && REGNO (temp5) >= FIRST_PSEUDO_REGISTER\n-\t      && regno_first_uid[REGNO (temp5)] == INSN_UID (temp)\n-\t      && regno_last_uid[REGNO (temp5)] == INSN_UID (temp3)\n+\t      && REGNO_FIRST_UID (REGNO (temp5)) == INSN_UID (temp)\n+\t      && REGNO_LAST_UID (REGNO (temp5)) == INSN_UID (temp3)\n \t      && ! side_effects_p (SET_SRC (temp1))\n \t      && ! may_trap_p (SET_SRC (temp1))\n \t      && rtx_cost (SET_SRC (temp1), SET) < 10\n@@ -2353,10 +2353,10 @@ duplicate_loop_exit_test (loop_start)\n \t    || (GET_CODE (reg) == SUBREG\n \t\t&& (reg = SUBREG_REG (reg), GET_CODE (reg) == REG)))\n \t&& REGNO (reg) >= FIRST_PSEUDO_REGISTER\n-\t&& regno_first_uid[REGNO (reg)] == INSN_UID (insn))\n+\t&& REGNO_FIRST_UID (REGNO (reg)) == INSN_UID (insn))\n       {\n \tfor (p = NEXT_INSN (insn); p != lastexit; p = NEXT_INSN (p))\n-\t  if (regno_last_uid[REGNO (reg)] == INSN_UID (p))\n+\t  if (REGNO_LAST_UID (REGNO (reg)) == INSN_UID (p))\n \t    break;\n \n \tif (p != lastexit)\n@@ -4592,7 +4592,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n \t  /* If this is the first time we are seeing a register on the `Y'\n \t     side, see if it is the last use.  If not, we can't thread the \n \t     jump, so mark it as not equivalent.  */\n-\t  if (regno_last_uid[REGNO (y)] != INSN_UID (yinsn))\n+\t  if (REGNO_LAST_UID (REGNO (y)) != INSN_UID (yinsn))\n \t    return 0;\n \n \t  return 1;"}, {"sha": "8b36f5f6657eae611bf49ee53f3882ab4764ea7e", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -291,11 +291,11 @@ alloc_qty (regno, mode, size, birth)\n   qty_size[qty] = size;\n   qty_mode[qty] = mode;\n   qty_birth[qty] = birth;\n-  qty_n_calls_crossed[qty] = reg_n_calls_crossed[regno];\n+  qty_n_calls_crossed[qty] = REG_N_CALLS_CROSSED (regno);\n   qty_min_class[qty] = reg_preferred_class (regno);\n   qty_alternate_class[qty] = reg_alternate_class (regno);\n-  qty_n_refs[qty] = reg_n_refs[regno];\n-  qty_changes_size[qty] = reg_changes_size[regno];\n+  qty_n_refs[qty] = REG_N_REFS (regno);\n+  qty_changes_size[qty] = REG_CHANGES_SIZE (regno);\n }\n \f\n /* Similar to `alloc_qty', but allocates a quantity for a SCRATCH rtx\n@@ -469,7 +469,7 @@ local_alloc ()\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n-      if (reg_basic_block[i] >= 0 && reg_n_deaths[i] == 1\n+      if (REG_BASIC_BLOCK (i) >= 0 && REG_N_DEATHS (i) == 1\n \t  && (reg_alternate_class (i) == NO_REGS\n \t      || ! CLASS_LIKELY_SPILLED_P (reg_preferred_class (i))))\n \treg_qty[i] = -2;\n@@ -784,9 +784,9 @@ optimize_reg_copy_1 (insn, dest, src)\n \t\t\t insn in the updates below.  If this is not correct,\n \t\t\t no great harm is done.  */\n \t\t      if (sregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\treg_n_refs[sregno] -= loop_depth;\n+\t\t\tREG_N_REFS (sregno) -= loop_depth;\n \t\t      if (dregno >= FIRST_PSEUDO_REGISTER)\n-\t\t\treg_n_refs[dregno] += loop_depth;\n+\t\t\tREG_N_REFS (dregno) += loop_depth;\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -823,25 +823,25 @@ optimize_reg_copy_1 (insn, dest, src)\n \t    {\n \t      if (sregno >= FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  if (reg_live_length[sregno] >= 0)\n+\t\t  if (REG_LIVE_LENGTH (sregno) >= 0)\n \t\t    {\n-\t\t      reg_live_length[sregno] -= length;\n+\t\t      REG_LIVE_LENGTH (sregno) -= length;\n \t\t      /* reg_live_length is only an approximation after\n \t\t\t combine if sched is not run, so make sure that we\n \t\t\t still have a reasonable value.  */\n-\t\t      if (reg_live_length[sregno] < 2)\n-\t\t\treg_live_length[sregno] = 2;\n+\t\t      if (REG_LIVE_LENGTH (sregno) < 2)\n+\t\t\tREG_LIVE_LENGTH (sregno) = 2;\n \t\t    }\n \n-\t\t  reg_n_calls_crossed[sregno] -= n_calls;\n+\t\t  REG_N_CALLS_CROSSED (sregno) -= n_calls;\n \t\t}\n \n \t      if (dregno >= FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  if (reg_live_length[dregno] >= 0)\n-\t\t    reg_live_length[dregno] += d_length;\n+\t\t  if (REG_LIVE_LENGTH (dregno) >= 0)\n+\t\t    REG_LIVE_LENGTH (dregno) += d_length;\n \n-\t\t  reg_n_calls_crossed[dregno] += d_n_calls;\n+\t\t  REG_N_CALLS_CROSSED (dregno) += d_n_calls;\n \t\t}\n \n \t      /* Move death note of SRC from P to INSN.  */\n@@ -922,28 +922,28 @@ optimize_reg_copy_2 (insn, dest, src)\n \t\t    /* We assume that a register is used exactly once per\n \t\t       insn in the updates below.  If this is not correct,\n \t\t       no great harm is done.  */\n-\t\t    reg_n_refs[dregno] -= loop_depth;\n-\t\t    reg_n_refs[sregno] += loop_depth;\n+\t\t    REG_N_REFS (dregno) -= loop_depth;\n+\t\t    REG_N_REFS (sregno) += loop_depth;\n \t\t  }\n \n \n \t      if (GET_CODE (q) == CALL_INSN)\n \t\t{\n-\t\t  reg_n_calls_crossed[dregno]--;\n-\t\t  reg_n_calls_crossed[sregno]++;\n+\t\t  REG_N_CALLS_CROSSED (dregno)--;\n+\t\t  REG_N_CALLS_CROSSED (sregno)++;\n \t\t}\n \t      }\n \n \t  remove_note (p, find_reg_note (p, REG_DEAD, dest));\n-\t  reg_n_deaths[dregno]--;\n+\t  REG_N_DEATHS (dregno)--;\n \t  remove_note (insn, find_reg_note (insn, REG_DEAD, src));\n-\t  reg_n_deaths[sregno]--;\n+\t  REG_N_DEATHS (sregno)--;\n \t  return;\n \t}\n \n       if (reg_set_p (src, p)\n \t  || find_reg_note (p, REG_DEAD, dest)\n-\t  || (GET_CODE (p) == CALL_INSN && reg_n_calls_crossed[sregno] == 0))\n+\t  || (GET_CODE (p) == CALL_INSN && REG_N_CALLS_CROSSED (sregno) == 0))\n \tbreak;\n     }\n }\n@@ -1010,7 +1010,7 @@ update_equiv_regs ()\n \n       if (GET_CODE (dest) == MEM && GET_CODE (SET_SRC (set)) == REG\n \t  && (regno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER\n-\t  && reg_basic_block[regno] >= 0\n+\t  && REG_BASIC_BLOCK (regno) >= 0\n \t  && reg_equiv_init_insn[regno] != 0\n \t  && validate_equiv_mem (reg_equiv_init_insn[regno], SET_SRC (set),\n \t\t\t\t dest)\n@@ -1040,7 +1040,7 @@ update_equiv_regs ()\n \t in a register class that's likely to be spilled.  */\n       if (GET_CODE (dest) != REG\n \t  || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n-\t  || reg_n_sets[regno] != 1\n+\t  || REG_N_SETS (regno) != 1\n \t  || CLASS_LIKELY_SPILLED_P (reg_preferred_class (REGNO (dest)))\n \t  || (GET_CODE (src) == REG\n \t      && REGNO (src) >= FIRST_PSEUDO_REGISTER\n@@ -1074,7 +1074,7 @@ update_equiv_regs ()\n \t \n       note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \n-      if (note == 0 && reg_basic_block[regno] >= 0\n+      if (note == 0 && REG_BASIC_BLOCK (regno) >= 0\n \t  && GET_CODE (SET_SRC (set)) == MEM\n \t  && validate_equiv_mem (insn, dest, SET_SRC (set)))\n \tREG_NOTES (insn) = note = gen_rtx (EXPR_LIST, REG_EQUIV, SET_SRC (set),\n@@ -1087,11 +1087,11 @@ update_equiv_regs ()\n \t  reg_equiv_replacement[regno] = XEXP (note, 0);\n \n \t  /* Don't mess with things live during setjmp.  */\n-\t  if (reg_live_length[regno] >= 0)\n+\t  if (REG_LIVE_LENGTH (regno) >= 0)\n \t    {\n \t      /* Note that the statement below does not affect the priority\n \t\t in local-alloc!  */\n-\t      reg_live_length[regno] *= 2;\n+\t      REG_LIVE_LENGTH (regno) *= 2;\n \n \n \t      /* If the register is referenced exactly twice, meaning it is\n@@ -1107,8 +1107,8 @@ update_equiv_regs ()\n \t\t This case normally occurs when a parameter is read from\n \t\t memory and then used exactly once, not in a loop.  */\n \n-\t\tif (reg_n_refs[regno] == 2\n-\t\t    && reg_basic_block[regno] < 0\n+\t\tif (REG_N_REFS (regno) == 2\n+\t\t    && REG_BASIC_BLOCK (regno) < 0\n \t\t    && rtx_equal_p (XEXP (note, 0), SET_SRC (set)))\n \t\t  reg_equiv_replace[regno] = 1;\n \t    }\n@@ -1168,7 +1168,7 @@ update_equiv_regs ()\n \t\t\t\t\treg_equiv_replacement[regno], insn))\n \t\t{\n \t\t  remove_death (regno, insn);\n-\t\t  reg_n_refs[regno] = 0;\n+\t\t  REG_N_REFS (regno) = 0;\n \t\t  PUT_CODE (equiv_insn, NOTE);\n \t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n@@ -1180,7 +1180,7 @@ update_equiv_regs ()\n \t      else if (depth == 0\n \t\t       && GET_CODE (equiv_insn) == INSN\n \t\t       && GET_CODE (insn) == INSN\n-\t\t       && reg_basic_block[regno] < 0)\n+\t\t       && REG_BASIC_BLOCK (regno) < 0)\n \t\t{\n \t\t  int l, offset;\n \t\t  REGSET_ELT_TYPE bit;\n@@ -1194,11 +1194,11 @@ update_equiv_regs ()\n \t\t  REG_NOTES (equiv_insn) = 0;\n \n \t\t  if (block < 0)\n-\t\t    reg_basic_block[regno] = 0;\n+\t\t    REG_BASIC_BLOCK (regno) = 0;\n \t\t  else\n-\t\t    reg_basic_block[regno] = block;\n-\t\t  reg_n_calls_crossed[regno] = 0;\n-\t\t  reg_live_length[regno] = 2;\n+\t\t    REG_BASIC_BLOCK (regno) = block;\n+\t\t  REG_N_CALLS_CROSSED (regno) = 0;\n+\t\t  REG_LIVE_LENGTH (regno) = 2;\n \n \t\t  if (block >= 0 && insn == basic_block_head[block])\n \t\t    basic_block_head[block] = PREV_INSN (insn);\n@@ -1902,8 +1902,8 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       /* If we are not going to let any regs live across calls,\n \t don't tie a call-crossing reg to a non-call-crossing reg.  */\n       || (current_function_has_nonlocal_label\n-\t  && ((reg_n_calls_crossed[ureg] > 0)\n-\t      != (reg_n_calls_crossed[sreg] > 0))))\n+\t  && ((REG_N_CALLS_CROSSED (ureg) > 0)\n+\t      != (REG_N_CALLS_CROSSED (sreg) > 0))))\n     return 0;\n \n   /* We don't already know about SREG, so tie it to UREG\n@@ -1924,8 +1924,8 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       update_qty_class (sqty, sreg);\n \n       /* Update info about quantity SQTY.  */\n-      qty_n_calls_crossed[sqty] += reg_n_calls_crossed[sreg];\n-      qty_n_refs[sqty] += reg_n_refs[sreg];\n+      qty_n_calls_crossed[sqty] += REG_N_CALLS_CROSSED (sreg);\n+      qty_n_refs[sqty] += REG_N_REFS (sreg);\n       if (usize < ssize)\n \t{\n \t  register int i;\n@@ -1995,7 +1995,7 @@ update_qty_class (qty, reg)\n   if (reg_class_subset_p (rclass, qty_alternate_class[qty]))\n     qty_alternate_class[qty] = rclass;\n \n-  if (reg_changes_size[reg])\n+  if (REG_CHANGES_SIZE (reg))\n     qty_changes_size[qty] = 1;\n }\n \f"}, {"sha": "fd7c289b781b267ff4a1404be8ebd6f3148a0bf8", "filename": "gcc/loop.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -735,8 +735,8 @@ scan_loop (loop_start, end, nregs)\n \n \t      if (reg_single_usage && reg_single_usage[regno] != 0\n \t\t  && reg_single_usage[regno] != const0_rtx\n-\t\t  && regno_first_uid[regno] == INSN_UID (p)\n-\t\t  && (regno_last_uid[regno]\n+\t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n+\t\t  && (REGNO_LAST_UID (regno)\n \t\t      == INSN_UID (reg_single_usage[regno]))\n \t\t  && n_times_set[REGNO (SET_DEST (set))] == 1\n \t\t  && ! side_effects_p (SET_SRC (set))\n@@ -787,11 +787,11 @@ scan_loop (loop_start, end, nregs)\n \t      /* Set M->cond if either invariant_p or consec_sets_invariant_p\n \t\t returned 2 (only conditionally invariant).  */\n \t      m->cond = ((tem | tem1 | tem2) > 1);\n-\t      m->global = (uid_luid[regno_last_uid[regno]] > INSN_LUID (end)\n-\t\t\t   || uid_luid[regno_first_uid[regno]] < INSN_LUID (loop_start));\n+\t      m->global = (uid_luid[REGNO_LAST_UID (regno)] > INSN_LUID (end)\n+\t\t\t   || uid_luid[REGNO_FIRST_UID (regno)] < INSN_LUID (loop_start));\n \t      m->match = 0;\n-\t      m->lifetime = (uid_luid[regno_last_uid[regno]]\n-\t\t\t     - uid_luid[regno_first_uid[regno]]);\n+\t      m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n+\t\t\t     - uid_luid[REGNO_FIRST_UID (regno)]);\n \t      m->savings = n_times_used[regno];\n \t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n@@ -881,21 +881,21 @@ scan_loop (loop_start, end, nregs)\n \t\t     INSN_LUID and hence must make a conservative\n \t\t     assumption.  */\n \t\t  m->global = (INSN_UID (p) >= max_uid_for_loop\n-\t\t\t       || (uid_luid[regno_last_uid[regno]]\n+\t\t\t       || (uid_luid[REGNO_LAST_UID (regno)]\n \t\t\t\t   > INSN_LUID (end))\n-\t\t\t       || (uid_luid[regno_first_uid[regno]]\n+\t\t\t       || (uid_luid[REGNO_FIRST_UID (regno)]\n \t\t\t\t   < INSN_LUID (p))\n \t\t\t       || (labels_in_range_p\n-\t\t\t\t   (p, uid_luid[regno_first_uid[regno]])));\n+\t\t\t\t   (p, uid_luid[REGNO_FIRST_UID (regno)])));\n \t\t  if (maybe_never && m->global)\n \t\t    m->savemode = GET_MODE (SET_SRC (set1));\n \t\t  else\n \t\t    m->savemode = VOIDmode;\n \t\t  m->regno = regno;\n \t\t  m->cond = 0;\n \t\t  m->match = 0;\n-\t\t  m->lifetime = (uid_luid[regno_last_uid[regno]]\n-\t\t\t\t - uid_luid[regno_first_uid[regno]]);\n+\t\t  m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n+\t\t\t\t - uid_luid[REGNO_FIRST_UID (regno)]);\n \t\t  m->savings = 1;\n \t\t  n_times_set[regno] = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n@@ -1066,7 +1066,7 @@ reg_in_basic_block_p (insn, reg)\n   int regno = REGNO (reg);\n   rtx p;\n \n-  if (regno_first_uid[regno] != INSN_UID (insn))\n+  if (REGNO_FIRST_UID (regno) != INSN_UID (insn))\n     return 0;\n \n   /* Search this basic block for the already recorded last use of the reg.  */\n@@ -1080,13 +1080,13 @@ reg_in_basic_block_p (insn, reg)\n \tcase INSN:\n \tcase CALL_INSN:\n \t  /* Ordinary insn: if this is the last use, we win.  */\n-\t  if (regno_last_uid[regno] == INSN_UID (p))\n+\t  if (REGNO_LAST_UID (regno) == INSN_UID (p))\n \t    return 1;\n \t  break;\n \n \tcase JUMP_INSN:\n \t  /* Jump insn: if this is the last use, we win.  */\n-\t  if (regno_last_uid[regno] == INSN_UID (p))\n+\t  if (REGNO_LAST_UID (regno) == INSN_UID (p))\n \t    return 1;\n \t  /* Otherwise, it's the end of the basic block, so we lose.  */\n \t  return 0;\n@@ -1207,7 +1207,7 @@ force_movables (movables)\n \t     this insn M->insn might not be where it dies.\n \t     But very likely this doesn't matter; what matters is\n \t     that M's reg is computed from M1's reg.  */\n-\t  if (INSN_UID (m->insn) == regno_last_uid[regno]\n+\t  if (INSN_UID (m->insn) == REGNO_LAST_UID (regno)\n \t      && !m->done)\n \t    break;\n \tif (m != 0 && m->set_src == m1->set_dest\n@@ -1304,8 +1304,8 @@ combine_movables (movables, nregs)\n \t    && mode == GET_MODE (SET_SRC (PATTERN (NEXT_INSN (m->insn)))))\n \t  {\n \t    register struct movable *m1;\n-\t    int first = uid_luid[regno_first_uid[m->regno]];\n-\t    int last = uid_luid[regno_last_uid[m->regno]];\n+\t    int first = uid_luid[REGNO_FIRST_UID (m->regno)];\n+\t    int last = uid_luid[REGNO_LAST_UID (m->regno)];\n \n \t    if (m0 == 0)\n \t      {\n@@ -1323,8 +1323,8 @@ combine_movables (movables, nregs)\n \t       already combined together.  */\n \t    for (m1 = movables; m1 != m; m1 = m1->next)\n \t      if (m1 == m0 || (m1->partial && m1->match == m0))\n-\t\tif (! (uid_luid[regno_first_uid[m1->regno]] > last\n-\t\t       || uid_luid[regno_last_uid[m1->regno]] < first))\n+\t\tif (! (uid_luid[REGNO_FIRST_UID (m1->regno)] > last\n+\t\t       || uid_luid[REGNO_LAST_UID (m1->regno)] < first))\n \t\t  goto overlap;\n \n \t    /* No overlap: we can combine this with the others.  */\n@@ -1922,13 +1922,13 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t to say it lives at least the full length of this loop.\n \t\t This will help guide optimizations in outer loops.  */\n \n-\t      if (uid_luid[regno_first_uid[regno]] > INSN_LUID (loop_start))\n+\t      if (uid_luid[REGNO_FIRST_UID (regno)] > INSN_LUID (loop_start))\n \t\t/* This is the old insn before all the moved insns.\n \t\t   We can't use the moved insn because it is out of range\n \t\t   in uid_luid.  Only the old insns have luids.  */\n-\t\tregno_first_uid[regno] = INSN_UID (loop_start);\n-\t      if (uid_luid[regno_last_uid[regno]] < INSN_LUID (end))\n-\t\tregno_last_uid[regno] = INSN_UID (end);\n+\t\tREGNO_FIRST_UID (regno) = INSN_UID (loop_start);\n+\t      if (uid_luid[REGNO_LAST_UID (regno)] < INSN_LUID (end))\n+\t\tREGNO_LAST_UID (regno) = INSN_UID (end);\n \n \t      /* Combine with this moved insn any other matching movables.  */\n \n@@ -3785,10 +3785,10 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t long as init_insn doesn't use the biv itself.\n \t March 14, 1989 -- self@bayes.arc.nasa.gov */\n \n-      if ((uid_luid[regno_last_uid[bl->regno]] < INSN_LUID (loop_end)\n+      if ((uid_luid[REGNO_LAST_UID (bl->regno)] < INSN_LUID (loop_end)\n \t   && bl->init_insn\n \t   && INSN_UID (bl->init_insn) < max_uid_for_loop\n-\t   && uid_luid[regno_first_uid[bl->regno]] >= INSN_LUID (bl->init_insn)\n+\t   && uid_luid[REGNO_FIRST_UID (bl->regno)] >= INSN_LUID (bl->init_insn)\n #ifdef HAVE_decrement_and_branch_until_zero\n \t   && ! bl->nonneg\n #endif\n@@ -3809,8 +3809,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t       bl->regno);\n \t      fprintf (loop_dump_stream,\n \t\t       \"First use: insn %d, last use: insn %d.\\n\",\n-\t\t       regno_first_uid[bl->regno],\n-\t\t       regno_last_uid[bl->regno]);\n+\t\t       REGNO_FIRST_UID (bl->regno),\n+\t\t       REGNO_LAST_UID (bl->regno));\n \t    }\n \t}\n \n@@ -3961,7 +3961,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t\t      other_giv = tv;\n \t\t\t  }\n \t\t      if (! tv && other_giv\n-\t\t\t  && (regno_last_uid[REGNO (other_giv->dest_reg)]\n+\t\t\t  && (REGNO_LAST_UID (REGNO (other_giv->dest_reg))\n \t\t\t      == INSN_UID (v->insn))\n \t\t\t  && INSN_LUID (v->insn) < INSN_LUID (bl->biv->insn))\n \t\t\tauto_inc_opt = 1;\n@@ -4042,12 +4042,12 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t    continue;\n \n \t  if (v->giv_type == DEST_REG\n-\t      && regno_first_uid[REGNO (v->dest_reg)] == INSN_UID (v->insn))\n+\t      && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n \t    {\n \t      struct induction *v1;\n \n \t      for (v1 = bl->giv; v1; v1 = v1->next_iv)\n-\t\tif (regno_last_uid[REGNO (v->dest_reg)] == INSN_UID (v1->insn))\n+\t\tif (REGNO_LAST_UID (REGNO (v->dest_reg)) == INSN_UID (v1->insn))\n \t\t  v->maybe_dead = 1;\n \t    }\n \n@@ -4548,8 +4548,8 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n     {\n       v->mode = GET_MODE (SET_DEST (set));\n \n-      v->lifetime = (uid_luid[regno_last_uid[REGNO (dest_reg)]]\n-\t\t     - uid_luid[regno_first_uid[REGNO (dest_reg)]]);\n+      v->lifetime = (uid_luid[REGNO_LAST_UID (REGNO (dest_reg))]\n+\t\t     - uid_luid[REGNO_FIRST_UID (REGNO (dest_reg))]);\n \n       v->times_used = n_times_used[REGNO (dest_reg)];\n \n@@ -4594,9 +4594,9 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n  \t - the giv is not used outside the loop\n \t - no assignments to the biv occur during the giv's lifetime.  */\n \n-      if (regno_first_uid[REGNO (dest_reg)] == INSN_UID (insn)\n+      if (REGNO_FIRST_UID (REGNO (dest_reg)) == INSN_UID (insn)\n \t  /* Previous line always fails if INSN was moved by loop opt.  */\n-\t  && uid_luid[regno_last_uid[REGNO (dest_reg)]] < INSN_LUID (loop_end)\n+\t  && uid_luid[REGNO_LAST_UID (REGNO (dest_reg))] < INSN_LUID (loop_end)\n \t  && (! not_every_iteration\n \t      || last_use_this_basic_block (dest_reg, insn)))\n  \t{\n@@ -4619,9 +4619,9 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n \t    {\n \t      if (INSN_UID (b->insn) >= max_uid_for_loop\n \t\t  || ((uid_luid[INSN_UID (b->insn)]\n-\t\t       >= uid_luid[regno_first_uid[REGNO (dest_reg)]])\n+\t\t       >= uid_luid[REGNO_FIRST_UID (REGNO (dest_reg))])\n \t\t      && (uid_luid[INSN_UID (b->insn)]\n-\t\t\t  <= uid_luid[regno_last_uid[REGNO (dest_reg)]])))\n+\t\t\t  <= uid_luid[REGNO_LAST_UID (REGNO (dest_reg))])))\n \t\t{\n \t\t  v->replaceable = 0;\n \t\t  v->not_replaceable = 1;\n@@ -6097,10 +6097,10 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \n \t      /* Emit an insn after the end of the loop to set the biv's\n \t\t proper exit value if it is used anywhere outside the loop.  */\n-\t      if ((regno_last_uid[bl->regno]\n+\t      if ((REGNO_LAST_UID (bl->regno)\n \t\t   != INSN_UID (PREV_INSN (PREV_INSN (loop_end))))\n \t\t  || ! bl->init_insn\n-\t\t  || regno_first_uid[bl->regno] != INSN_UID (bl->init_insn))\n+\t\t  || REGNO_FIRST_UID (bl->regno) != INSN_UID (bl->init_insn))\n \t\temit_insn_after (gen_move_insn (reg, final_value),\n \t\t\t\t loop_end);\n \n@@ -6612,7 +6612,7 @@ last_use_this_basic_block (reg, insn)\n        n && GET_CODE (n) != CODE_LABEL && GET_CODE (n) != JUMP_INSN;\n        n = NEXT_INSN (n))\n     {\n-      if (regno_last_uid[REGNO (reg)] == INSN_UID (n))\n+      if (REGNO_LAST_UID (REGNO (reg)) == INSN_UID (n))\n \treturn 1;\n     }\n   return 0;\n@@ -6659,8 +6659,8 @@ update_reg_last_use (x, insn)\n      and hence this insn will never be the last use of x.  */\n   if (GET_CODE (x) == REG && REGNO (x) < max_reg_before_loop\n       && INSN_UID (insn) < max_uid_for_loop\n-      && uid_luid[regno_last_uid[REGNO (x)]] < uid_luid[INSN_UID (insn)])\n-    regno_last_uid[REGNO (x)] = INSN_UID (insn);\n+      && uid_luid[REGNO_LAST_UID (REGNO (x))] < uid_luid[INSN_UID (insn)])\n+    REGNO_LAST_UID (REGNO (x)) = INSN_UID (insn);\n   else\n     {\n       register int i, j;"}, {"sha": "2f73a3d493c94a28d31a8fd0a332e90f2c9fba0d", "filename": "gcc/regclass.c", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -163,15 +163,6 @@ char *reg_names[] = REGISTER_NAMES;\n \n enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n \n-/* Indexed by n, gives number of times (REG n) is set or clobbered.\n-   This information remains valid for the rest of the compilation\n-   of the current function; it is used to control register allocation.\n-\n-   This information applies to both hard registers and pseudo registers,\n-   unlike much of the information above.  */\n-\n-short *reg_n_sets;\n-\n /* Maximum cost of moving from a register in one class to a register in\n    another class.  Based on REGISTER_MOVE_COST.  */\n \n@@ -835,7 +826,7 @@ regclass (f, nregs)\n \t\t\t}\n \n \t\t      /* This makes one more setting of new insns's dest.  */\n-\t\t      reg_n_sets[REGNO (recog_operand[0])]++;\n+\t\t      REG_N_SETS (REGNO (recog_operand[0]))++;\n \n \t\t      *recog_operand_loc[1] = recog_operand[0];\n \t\t      for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n@@ -1657,6 +1648,43 @@ auto_inc_dec_reg_p (reg, mode)\n #endif\n \n #endif /* REGISTER_CONSTRAINTS */\n+\f\n+/* Allocate enough space to hold NUM_REGS registers for the tables used for\n+   reg_scan and flow_analysis that are indexed by the register number.  If\n+   NEW_P is set, initialize all of the registers, otherwise only initialize the\n+   new registers allocated.  The same table is kept from function to function,\n+   only reallocating it when we need more room.  */\n+\n+void\n+allocate_reg_info (num_regs, new_p)\n+     int num_regs;\n+     int new_p;\n+{\n+  static int regno_allocated = 0;\n+  static int regno_max = 0;\n+  int i;\n+  int size;\n+  int min = (new_p) ? 0 : regno_max+1;\n+\n+  if (num_regs > regno_allocated)\n+    {\n+      regno_allocated = num_regs + (num_regs / 20);\t/* add some slop space */\n+      size = regno_allocated * sizeof (reg_info);\n+      reg_n_info = ((reg_n_info)\n+\t\t    ? (reg_info *) xrealloc ((char *)reg_n_info, size)\n+\t\t    : (reg_info *) xmalloc (size));\n+    }\n+\n+  if (min < num_regs)\n+    {\n+      bzero ((char *) &reg_n_info[min], (num_regs - min) * sizeof (reg_info));\n+      for (i = min; i < num_regs; i++)\n+\tREG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n+    }\n+\n+  regno_max = num_regs;\n+}\n+\n \f\n /* This is the `regscan' pass of the compiler, run just before cse\n    and again just before loop.\n@@ -1667,27 +1695,6 @@ auto_inc_dec_reg_p (reg, mode)\n \n    REPEAT is nonzero the second time this is called.  */\n \n-/* Indexed by pseudo register number, gives uid of first insn using the reg\n-   (as of the time reg_scan is called).  */\n-\n-int *regno_first_uid;\n-\n-/* Indexed by pseudo register number, gives uid of last insn using the reg\n-   (as of the time reg_scan is called).  */\n-\n-int *regno_last_uid;\n-\n-/* Indexed by pseudo register number, gives uid of last insn using the reg\n-   or mentioning it in a note (as of the time reg_scan is called).  */\n-\n-int *regno_last_note_uid;\n-\n-/* Record the number of registers we used when we allocated the above two\n-   tables.  If we are called again with more than this, we must re-allocate\n-   the tables.  */\n-\n-static int highest_regno_in_uid_map;\n-\n /* Maximum number of parallel sets and clobbers in any insn in this fn.\n    Always at least 3, since the combiner could put that many together\n    and we want this to remain correct for all the remaining passes.  */\n@@ -1702,26 +1709,7 @@ reg_scan (f, nregs, repeat)\n {\n   register rtx insn;\n \n-  if (!repeat || nregs > highest_regno_in_uid_map)\n-    {\n-      /* Leave some spare space in case more regs are allocated.  */\n-      highest_regno_in_uid_map = nregs + nregs / 20;\n-      regno_first_uid\n-\t= (int *) oballoc (highest_regno_in_uid_map * sizeof (int));\n-      regno_last_uid\n-\t= (int *) oballoc (highest_regno_in_uid_map * sizeof (int));\n-      regno_last_note_uid\n-\t= (int *) oballoc (highest_regno_in_uid_map * sizeof (int));\n-      reg_n_sets\n-\t= (short *) oballoc (highest_regno_in_uid_map * sizeof (short));\n-    }\n-\n-  bzero ((char *) regno_first_uid, highest_regno_in_uid_map * sizeof (int));\n-  bzero ((char *) regno_last_uid, highest_regno_in_uid_map * sizeof (int));\n-  bzero ((char *) regno_last_note_uid,\n-\t highest_regno_in_uid_map * sizeof (int));\n-  bzero ((char *) reg_n_sets, highest_regno_in_uid_map * sizeof (short));\n-\n+  allocate_reg_info (nregs, TRUE);\n   max_parallel = 3;\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n@@ -1769,11 +1757,11 @@ reg_scan_mark_refs (x, insn, note_flag)\n       {\n \tregister int regno = REGNO (x);\n \n-\tregno_last_note_uid[regno] = INSN_UID (insn);\n+\tREGNO_LAST_NOTE_UID (regno) = INSN_UID (insn);\n \tif (!note_flag)\n-\t  regno_last_uid[regno] = INSN_UID (insn);\n-\tif (regno_first_uid[regno] == 0)\n-\t  regno_first_uid[regno] = INSN_UID (insn);\n+\t  REGNO_LAST_UID (regno) = INSN_UID (insn);\n+\tif (REGNO_FIRST_UID (regno) == 0)\n+\t  REGNO_FIRST_UID (regno) = INSN_UID (insn);\n       }\n       break;\n \n@@ -1798,7 +1786,7 @@ reg_scan_mark_refs (x, insn, note_flag)\n \t;\n \n       if (GET_CODE (dest) == REG)\n-\treg_n_sets[REGNO (dest)]++;\n+\tREG_N_SETS (REGNO (dest))++;\n \n       /* If this is setting a pseudo from another pseudo or the sum of a\n \t pseudo and a constant integer and the other pseudo is known to be"}, {"sha": "0091b885d2300f211b193d8ddf32526500a90d2b", "filename": "gcc/regs.h", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -37,28 +37,51 @@ extern int max_regno;\n \n extern int max_scratch;\n \n+/* Register information indexed by register number */\n+typedef struct reg_info_def {\n+\t\t\t\t/* fields set by reg_scan */\n+  int first_uid;\t\t/* UID of first insn to use (REG n) */\n+  int last_uid;\t\t\t/* UID of last insn to use (REG n) */\n+  int last_note_uid;\t\t/* UID of last note to use (REG n) */\n+\n+\t\t\t\t/* fields set by both reg_scan and flow_analysis */\n+  int sets;\t\t\t/* # of times (REG n) is set */\n+\n+\t\t\t\t/* fields set by flow_analysis */\n+  int refs;\t\t\t/* # of times (REG n) is used or set */\n+  int deaths;\t\t\t/* # of times (REG n) dies */\n+  int live_length;\t\t/* # of instructions (REG n) is live */\n+  int calls_crossed;\t\t/* # of calls (REG n) is live across */\n+  int basic_block;\t\t/* # of basic blocks (REG n) is used in */\n+  char changes_size;\t\t/* whether (SUBREG (REG n)) changes size */\n+} reg_info;\n+\n+extern reg_info *reg_n_info;\n+\n /* Indexed by n, gives number of times (REG n) is used or set.\n    References within loops may be counted more times.  */\n \n-extern int *reg_n_refs;\n+#define REG_N_REFS(N) (reg_n_info[(N)].refs)\n \n-/* Indexed by n, gives number of times (REG n) is set.  */\n+/* Indexed by n, gives number of times (REG n) is set.\n+   ??? both regscan and flow allocate space for this.  We should settle\n+   on just copy.  */\n \n-extern short *reg_n_sets;\n+#define REG_N_SETS(N) (reg_n_info[(N)].sets)\n \n /* Indexed by N, gives number of insns in which register N dies.\n    Note that if register N is live around loops, it can die\n    in transitions between basic blocks, and that is not counted here.\n    So this is only a reliable indicator of how many regions of life there are\n    for registers that are contained in one basic block.  */\n \n-extern short *reg_n_deaths;\n+#define REG_N_DEATHS(N) (reg_n_info[(N)].deaths)\n \n /* Indexed by N; says whether a pseudo register N was ever used\n    within a SUBREG that changes the size of the reg.  Some machines prohibit\n    such objects to be in certain (usually floating-point) registers.  */\n \n-extern char *reg_changes_size;\n+#define REG_CHANGES_SIZE(N) (reg_n_info[(N)].changes_size)\n \n /* Get the number of consecutive words required to hold pseudo-reg N.  */\n \n@@ -77,7 +100,7 @@ extern char *reg_changes_size;\n \n /* Indexed by N, gives number of CALL_INSNS across which (REG n) is live.  */\n \n-extern int *reg_n_calls_crossed;\n+#define REG_N_CALLS_CROSSED(N) (reg_n_info[(N)].calls_crossed)\n \n /* Total number of instructions at which (REG n) is live.\n    The larger this is, the less priority (REG n) gets for\n@@ -94,10 +117,14 @@ extern int *reg_n_calls_crossed;\n    is not required.  global.c makes an allocno for this but does\n    not try to assign a hard register to it.  */\n \n-extern int *reg_live_length;\n+#define REG_LIVE_LENGTH(N) (reg_n_info[(N)].live_length)\n \n /* Vector of substitutions of register numbers,\n-   used to map pseudo regs into hardware regs.  */\n+   used to map pseudo regs into hardware regs.\n+\n+   This can't be folded into reg_n_info without changing all of the\n+   machine dependent directories, since the reload functions\n+   access it.  */\n \n extern short *reg_renumber;\n \n@@ -122,19 +149,19 @@ extern enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n    It is sometimes adjusted for subsequent changes during loop,\n    but not adjusted by cse even if cse invalidates it.  */\n \n-extern int *regno_first_uid;\n+#define REGNO_FIRST_UID(N) (reg_n_info[(N)].first_uid)\n \n /* Vector indexed by regno; gives uid of last insn using that reg.\n    This is computed by reg_scan for use by cse and loop.\n    It is sometimes adjusted for subsequent changes during loop,\n    but not adjusted by cse even if cse invalidates it.\n    This is harmless since cse won't scan through a loop end.  */\n \n-extern int *regno_last_uid;\n+#define REGNO_LAST_UID(N) (reg_n_info[(N)].last_uid)\n \n /* Similar, but includes insns that mention the reg in their notes.  */\n \n-extern int *regno_last_note_uid;\n+#define REGNO_LAST_NOTE_UID(N) (reg_n_info[(N)].last_note_uid)\n \n /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n    After rtl generation, it is 1 plus the largest register number used.  */\n@@ -185,3 +212,6 @@ extern rtx *scratch_list;\n extern int *scratch_block;\n /* The length of the arrays pointed to by scratch_block and scratch_list.  */\n extern int scratch_list_length;\n+\n+/* Allocate reg_n_info tables */\n+extern void allocate_reg_info PROTO((int, int));"}, {"sha": "85790f890b2405f20a197f86f1cc434b1cd4ec73", "filename": "gcc/reload1.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -785,7 +785,7 @@ reload (first, global, dumpfile)\n      in that case some pseudos might be in the wrong kind of hard reg.  */\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_renumber[i] == -1 && reg_n_refs[i] != 0)\n+    if (reg_renumber[i] == -1 && REG_N_REFS (i) != 0)\n       break;\n \n   if (i == max_regno && num_eliminable == 0 && ! caller_save_needed)\n@@ -2471,7 +2471,7 @@ alter_reg (i, from_reg)\n      allocate a stack slot for it.  */\n \n   if (reg_renumber[i] < 0\n-      && reg_n_refs[i] > 0\n+      && REG_N_REFS (i) > 0\n       && reg_equiv_constant[i] == 0\n       && reg_equiv_memory_loc[i] == 0)\n     {\n@@ -3659,14 +3659,14 @@ spill_hard_reg (regno, global, dumpfile, cant_eliminate)\n \n \tif (! cant_eliminate\n \t    && basic_block_needs[0]\n-\t    && reg_basic_block[i] >= 0\n-\t    && basic_block_needs[(int) class][reg_basic_block[i]] == 0)\n+\t    && REG_BASIC_BLOCK (i) >= 0\n+\t    && basic_block_needs[(int) class][REG_BASIC_BLOCK (i)] == 0)\n \t  {\n \t    enum reg_class *p;\n \n \t    for (p = reg_class_superclasses[(int) class];\n \t\t *p != LIM_REG_CLASSES; p++)\n-\t      if (basic_block_needs[(int) *p][reg_basic_block[i]] > 0)\n+\t      if (basic_block_needs[(int) *p][REG_BASIC_BLOCK (i)] > 0)\n \t\tbreak;\n \n \t    if (*p == LIM_REG_CLASSES)\n@@ -3827,12 +3827,12 @@ order_regs_for_reload (global)\n \t\t we're not going to be able to reallocate it, but\n \t\t we might if allocated by global alloc.  */\n \t      if (global && reg_allocno[i] < 0)\n-\t\thard_reg_n_uses[regno].uses += (reg_n_refs[i] + 1) / 2;\n+\t\thard_reg_n_uses[regno].uses += (REG_N_REFS (i) + 1) / 2;\n \n-\t      hard_reg_n_uses[regno++].uses += reg_n_refs[i];\n+\t      hard_reg_n_uses[regno++].uses += REG_N_REFS (i);\n \t    }\n \t}\n-      large += reg_n_refs[i];\n+      large += REG_N_REFS (i);\n     }\n \n   /* Now fixed registers (which cannot safely be used for reloading)\n@@ -6241,8 +6241,8 @@ emit_reload_insns (insn)\n \t\t  SET_DEST (PATTERN (temp)) = reloadreg;\n \t\t  /* If these are the only uses of the pseudo reg,\n \t\t     pretend for GDB it lives in the reload reg we used.  */\n-\t\t  if (reg_n_deaths[REGNO (old)] == 1\n-\t\t      && reg_n_sets[REGNO (old)] == 1)\n+\t\t  if (REG_N_DEATHS (REGNO (old)) == 1\n+\t\t      && REG_N_SETS (REGNO (old)) == 1)\n \t\t    {\n \t\t      reg_renumber[REGNO (old)] = REGNO (reload_reg_rtx[j]);\n \t\t      alter_reg (REGNO (old), -1);\n@@ -7280,8 +7280,8 @@ delete_output_reload (insn, j, output_reload_insn)\n   /* See if the pseudo reg has been completely replaced\n      with reload regs.  If so, delete the store insn\n      and forget we had a stack slot for the pseudo.  */\n-  else if (reg_n_deaths[REGNO (reg)] == 1\n-\t   && reg_basic_block[REGNO (reg)] >= 0\n+  else if (REG_N_DEATHS (REGNO (reg)) == 1\n+\t   && REG_BASIC_BLOCK (REGNO (reg)) >= 0\n \t   && find_regno_note (insn, REG_DEAD, REGNO (reg)))\n     {\n       rtx i2;"}, {"sha": "ae873faeb0c83e7d54ba4aa52d40c7819973a3e0", "filename": "gcc/sched.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -438,7 +438,7 @@ init_alias_analysis ()\n \t&& GET_CODE (SET_DEST (set)) == REG\n \t&& REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t&& (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n-\t     && reg_n_sets[REGNO (SET_DEST (set))] == 1)\n+\t     && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n \t    || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n \t&& GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n       {\n@@ -1762,7 +1762,7 @@ sched_analyze_1 (x, insn)\n \n \t  /* Don't let it cross a call after scheduling if it doesn't\n \t     already cross one.  */\n-\t  if (reg_n_calls_crossed[regno] == 0 && last_function_call)\n+\t  if (REG_N_CALLS_CROSSED (regno) == 0 && last_function_call)\n \t    add_dependence (insn, last_function_call, REG_DEP_ANTI);\n \t}\n     }\n@@ -1920,7 +1920,7 @@ sched_analyze_2 (x, insn)\n \t    /* If the register does not already cross any calls, then add this\n \t       insn to the sched_before_next_call list so that it will still\n \t       not cross calls after scheduling.  */\n-\t    if (reg_n_calls_crossed[regno] == 0)\n+\t    if (REG_N_CALLS_CROSSED (regno) == 0)\n \t      add_dependence (sched_before_next_call, insn, REG_DEP_ANTI);\n \t  }\n \treturn;\n@@ -2531,7 +2531,7 @@ birthing_insn_p (pat)\n \t insn.  */\n \n       if (bb_live_regs[offset] & bit)\n-\treturn (reg_n_sets[i] == 1);\n+\treturn (REG_N_SETS (i) == 1);\n \n       return 0;\n     }\n@@ -4373,10 +4373,10 @@ update_n_sets (x, inc)\n \t  int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (dest));\n \t  \n \t  for (i = regno; i < endregno; i++)\n-\t    reg_n_sets[i] += inc;\n+\t    REG_N_SETS (i) += inc;\n \t}\n       else\n-\treg_n_sets[regno] += inc;\n+\tREG_N_SETS (regno) += inc;\n     }\n }\n \n@@ -4832,6 +4832,7 @@ schedule_insns (dump_file)\n {\n   int max_uid = MAX_INSNS_PER_SPLIT * (get_max_uid () + 1);\n   int b;\n+  int i;\n   rtx insn;\n \n   /* Taking care of this degenerate case makes the rest of\n@@ -4878,8 +4879,8 @@ schedule_insns (dump_file)\n       bb_live_regs = (regset) alloca (regset_bytes);\n       bzero ((char *) sched_reg_n_calls_crossed, max_regno * sizeof (int));\n       bzero ((char *) sched_reg_live_length, max_regno * sizeof (int));\n-      bcopy ((char *) reg_n_deaths, (char *) sched_reg_n_deaths,\n-\t     max_regno * sizeof (short));\n+      for (i = 0; i < max_regno; i++)\n+\tsched_reg_n_deaths[i] = REG_N_DEATHS (i);\n       init_alias_analysis ();\n     }\n   else\n@@ -5085,35 +5086,35 @@ schedule_insns (dump_file)\n \t  {\n \t    if (dump_file)\n \t      {\n-\t\tif (reg_live_length[regno] > sched_reg_live_length[regno])\n+\t\tif (REG_LIVE_LENGTH (regno) > sched_reg_live_length[regno])\n \t\t  fprintf (dump_file,\n \t\t\t   \";; register %d life shortened from %d to %d\\n\",\n-\t\t\t   regno, reg_live_length[regno],\n+\t\t\t   regno, REG_LIVE_LENGTH (regno),\n \t\t\t   sched_reg_live_length[regno]);\n \t\t/* Negative values are special; don't overwrite the current\n \t\t   reg_live_length value if it is negative.  */\n-\t\telse if (reg_live_length[regno] < sched_reg_live_length[regno]\n-\t\t\t && reg_live_length[regno] >= 0)\n+\t\telse if (REG_LIVE_LENGTH (regno) < sched_reg_live_length[regno]\n+\t\t\t && REG_LIVE_LENGTH (regno) >= 0)\n \t\t  fprintf (dump_file,\n \t\t\t   \";; register %d life extended from %d to %d\\n\",\n-\t\t\t   regno, reg_live_length[regno],\n+\t\t\t   regno, REG_LIVE_LENGTH (regno),\n \t\t\t   sched_reg_live_length[regno]);\n \n-\t\tif (! reg_n_calls_crossed[regno]\n+\t\tif (! REG_N_CALLS_CROSSED (regno)\n \t\t    && sched_reg_n_calls_crossed[regno])\n \t\t  fprintf (dump_file,\n \t\t\t   \";; register %d now crosses calls\\n\", regno);\n-\t\telse if (reg_n_calls_crossed[regno]\n+\t\telse if (REG_N_CALLS_CROSSED (regno)\n \t\t\t && ! sched_reg_n_calls_crossed[regno]\n-\t\t\t && reg_basic_block[regno] != REG_BLOCK_GLOBAL)\n+\t\t\t && REG_BASIC_BLOCK (regno) != REG_BLOCK_GLOBAL)\n \t\t  fprintf (dump_file,\n \t\t\t   \";; register %d no longer crosses calls\\n\", regno);\n \n \t      }\n \t    /* Negative values are special; don't overwrite the current\n \t       reg_live_length value if it is negative.  */\n-\t    if (reg_live_length[regno] >= 0)\n-\t      reg_live_length[regno] = sched_reg_live_length[regno];\n+\t    if (REG_LIVE_LENGTH (regno) >= 0)\n+\t      REG_LIVE_LENGTH (regno) = sched_reg_live_length[regno];\n \n \t    /* We can't change the value of reg_n_calls_crossed to zero for\n \t       pseudos which are live in more than one block.\n@@ -5129,8 +5130,8 @@ schedule_insns (dump_file)\n \t       Alternatively, we could try to correctly update basic block live\n \t       at start here in sched, but that seems complicated.  */\n \t    if (sched_reg_n_calls_crossed[regno]\n-\t\t|| reg_basic_block[regno] != REG_BLOCK_GLOBAL)\n-\t      reg_n_calls_crossed[regno] = sched_reg_n_calls_crossed[regno];\n+\t\t|| REG_BASIC_BLOCK (regno) != REG_BLOCK_GLOBAL)\n+\t      REG_N_CALLS_CROSSED (regno) = sched_reg_n_calls_crossed[regno];\n \t  }\n     }\n }"}, {"sha": "72e94d609e6576fa14c5f7076e8e01e15c221029", "filename": "gcc/stupid.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -197,7 +197,7 @@ stupid_life_analysis (f, nregs, file)\n   allocate_for_life_analysis ();\n \n   for (i = 0; i < max_regno; i++)\n-    reg_n_deaths[i] = 1;\n+    REG_N_DEATHS (i) = 1;\n \n   bzero (regs_live, nregs);\n \n@@ -277,7 +277,7 @@ stupid_life_analysis (f, nregs, file)\n \n       /* Now find the best hard-register class for this pseudo register */\n       if (N_REG_CLASSES > 1)\n-\treg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r], \n+\treg_renumber[r] = stupid_find_reg (REG_N_CALLS_CROSSED (r), \n \t\t\t\t\t   reg_preferred_class (r),\n \t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n \t\t\t\t\t   reg_where_born[r],\n@@ -286,7 +286,7 @@ stupid_life_analysis (f, nregs, file)\n \n       /* If no reg available in that class, try alternate class.  */\n       if (reg_renumber[r] == -1 && reg_alternate_class (r) != NO_REGS)\n-\treg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r],\n+\treg_renumber[r] = stupid_find_reg (REG_N_CALLS_CROSSED (r),\n \t\t\t\t\t   reg_alternate_class (r),\n \t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n \t\t\t\t\t   reg_where_born[r],\n@@ -315,7 +315,7 @@ stupid_reg_compare (r1p, r2p)\n   if (tem != 0)\n     return tem;\n \n-  tem = reg_n_refs[r1] - reg_n_refs[r2];\n+  tem = REG_N_REFS (r1) - REG_N_REFS (r2);\n   if (tem != 0)\n     return tem;\n \n@@ -509,10 +509,10 @@ stupid_mark_refs (x, insn)\n \t\t}\n \n \t      /* Count the refs of this reg.  */\n-\t      reg_n_refs[regno]++;\n+\t      REG_N_REFS (regno)++;\n \n \t      if (last_call_suid < reg_where_dead[regno])\n-\t\treg_n_calls_crossed[regno] += 1;\n+\t\tREG_N_CALLS_CROSSED (regno) += 1;\n \n \t      if (last_setjmp_suid < reg_where_dead[regno])\n \t\tregs_crosses_setjmp[regno] = 1;\n@@ -560,7 +560,7 @@ stupid_mark_refs (x, insn)\n \t  /* Pseudo reg: record first use, last use and number of uses.  */\n \n \t  reg_where_born[regno] = INSN_SUID (insn);\n-\t  reg_n_refs[regno]++;\n+\t  REG_N_REFS (regno)++;\n \t  if (regs_live[regno] == 0)\n \t    {\n \t      regs_live[regno] = 1;"}, {"sha": "74e54bd94992dc9bc3449148f4e3cd71dd212eaf", "filename": "gcc/unroll.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1f21e0aef20c7b08785b13d33611370151e1c2b/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=b1f21e0aef20c7b08785b13d33611370151e1c2b", "patch": "@@ -769,10 +769,10 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n        can use a different pseudo in each unrolled copy of the loop.  This\n        results in better code.  */\n     for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; ++j)\n-      if (regno_first_uid[j] > 0 && regno_first_uid[j] <= max_uid_for_loop\n-\t  && uid_luid[regno_first_uid[j]] >= copy_start_luid\n-\t  && regno_last_uid[j] > 0 && regno_last_uid[j] <= max_uid_for_loop\n-\t  && uid_luid[regno_last_uid[j]] <= copy_end_luid)\n+      if (REGNO_FIRST_UID (j) > 0 && REGNO_FIRST_UID (j) <= max_uid_for_loop\n+\t  && uid_luid[REGNO_FIRST_UID (j)] >= copy_start_luid\n+\t  && REGNO_LAST_UID (j) > 0 && REGNO_LAST_UID (j) <= max_uid_for_loop\n+\t  && uid_luid[REGNO_LAST_UID (j)] <= copy_end_luid)\n \t{\n \t  /* However, we must also check for loop-carried dependencies.\n \t     If the value the pseudo has at the end of iteration X is\n@@ -783,7 +783,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t     regno_last_uid.  */\n \t  /* ??? This check is simplistic.  We would get better code if\n \t     this check was more sophisticated.  */\n-\t  if (set_dominates_use (j, regno_first_uid[j], regno_last_uid[j],\n+\t  if (set_dominates_use (j, REGNO_FIRST_UID (j), REGNO_LAST_UID (j),\n \t\t\t\t copy_start, copy_end))\n \t    local_regno[j] = 1;\n \n@@ -1375,7 +1375,7 @@ precondition_loop_p (initial_value, final_value, increment, loop_start,\n   /* Fail if loop_iteration_var is not live before loop_start, since we need\n      to test its value in the preconditioning code.  */\n \n-  if (uid_luid[regno_first_uid[REGNO (loop_iteration_var)]]\n+  if (uid_luid[REGNO_FIRST_UID (REGNO (loop_iteration_var))]\n       > INSN_LUID (loop_start))\n     {\n       if (loop_dump_stream)\n@@ -2464,10 +2464,10 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n       if (unroll_type != UNROLL_COMPLETELY\n \t  && (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]]\n \t      || unroll_type == UNROLL_NAIVE)\n-\t  && (uid_luid[regno_last_uid[bl->regno]] >= INSN_LUID (loop_end)\n+\t  && (uid_luid[REGNO_LAST_UID (bl->regno)] >= INSN_LUID (loop_end)\n \t      || ! bl->init_insn\n \t      || INSN_UID (bl->init_insn) >= max_uid_for_loop\n-\t      || (uid_luid[regno_first_uid[bl->regno]]\n+\t      || (uid_luid[REGNO_FIRST_UID (bl->regno)]\n \t\t  < INSN_LUID (bl->init_insn))\n \t      || reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n \t  && ! (biv_final_value = final_biv_value (bl, loop_start, loop_end)))\n@@ -2676,15 +2676,15 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t  && (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]]\n \t      || unroll_type == UNROLL_NAIVE)\n \t  && v->giv_type != DEST_ADDR\n-\t  && ((regno_first_uid[REGNO (v->dest_reg)] != INSN_UID (v->insn)\n+\t  && ((REGNO_FIRST_UID (REGNO (v->dest_reg)) != INSN_UID (v->insn)\n \t       /* Check for the case where the pseudo is set by a shift/add\n \t\t  sequence, in which case the first insn setting the pseudo\n \t\t  is the first insn of the shift/add sequence.  */\n \t       && (! (tem = find_reg_note (v->insn, REG_RETVAL, NULL_RTX))\n-\t\t   || (regno_first_uid[REGNO (v->dest_reg)]\n+\t\t   || (REGNO_FIRST_UID (REGNO (v->dest_reg))\n \t\t       != INSN_UID (XEXP (tem, 0)))))\n \t      /* Line above always fails if INSN was moved by loop opt.  */\n-\t      || (uid_luid[regno_last_uid[REGNO (v->dest_reg)]]\n+\t      || (uid_luid[REGNO_LAST_UID (REGNO (v->dest_reg))]\n \t\t  >= INSN_LUID (loop_end)))\n \t  && ! (final_value = v->final_value))\n \tcontinue;"}]}