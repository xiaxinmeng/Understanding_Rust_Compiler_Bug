{"sha": "0ba227b5a438a9122241085bc79dbdd1fcbfe13e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJhMjI3YjVhNDM4YTkxMjIyNDEwODViYzc5ZGJkZDFmY2JmZTEzZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-10-29T20:41:17Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-10-29T20:41:17Z"}, "message": "ifcvt.c (noce_can_store_speculate_p): New static function.\n\n\t* ifcvt.c (noce_can_store_speculate_p): New static function.\n\t(noce_process_if_block): Call it.\n\t(if_convert): Remove recompute_dominance parameter.  Change all\n\tcallers.\n\nFrom-SVN: r129729", "tree": {"sha": "335dea79c76472cae5c0a89df34c7ffaa6afc4cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/335dea79c76472cae5c0a89df34c7ffaa6afc4cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ba227b5a438a9122241085bc79dbdd1fcbfe13e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba227b5a438a9122241085bc79dbdd1fcbfe13e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ba227b5a438a9122241085bc79dbdd1fcbfe13e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba227b5a438a9122241085bc79dbdd1fcbfe13e/comments", "author": null, "committer": null, "parents": [{"sha": "04d053492e53cbca30abc30fbfa14c4a3e41f3c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04d053492e53cbca30abc30fbfa14c4a3e41f3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04d053492e53cbca30abc30fbfa14c4a3e41f3c9"}], "stats": {"total": 96, "additions": 78, "deletions": 18}, "files": [{"sha": "b5875054707c88f4965d80b90d0afe2e57458a96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba227b5a438a9122241085bc79dbdd1fcbfe13e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba227b5a438a9122241085bc79dbdd1fcbfe13e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ba227b5a438a9122241085bc79dbdd1fcbfe13e", "patch": "@@ -1,3 +1,10 @@\n+2007-10-29  Ian Lance Taylor  <iant@google.com>\n+\n+\t* ifcvt.c (noce_can_store_speculate_p): New static function.\n+\t(noce_process_if_block): Call it.\n+\t(if_convert): Remove recompute_dominance parameter.  Change all\n+\tcallers.\n+\n 2007-10-29  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-flow-inline.h (get_subvar_at): Use binary search."}, {"sha": "549c0995768059993b93c9dae76bf2de410b3887", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ba227b5a438a9122241085bc79dbdd1fcbfe13e/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ba227b5a438a9122241085bc79dbdd1fcbfe13e/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=0ba227b5a438a9122241085bc79dbdd1fcbfe13e", "patch": "@@ -2139,6 +2139,46 @@ noce_mem_write_may_trap_or_fault_p (const_rtx mem)\n   return false;\n }\n \n+/* Return whether we can use store speculation for MEM.  TOP_BB is the\n+   basic block above the conditional block where we are considering\n+   doing the speculative store.  We look for whether MEM is set\n+   unconditionally later in the function.  */\n+\n+static bool\n+noce_can_store_speculate_p (basic_block top_bb, const_rtx mem)\n+{\n+  basic_block dominator;\n+\n+  for (dominator = get_immediate_dominator (CDI_POST_DOMINATORS, top_bb);\n+       dominator != NULL;\n+       dominator = get_immediate_dominator (CDI_POST_DOMINATORS, dominator))\n+    {\n+      rtx insn;\n+\n+      FOR_BB_INSNS (dominator, insn)\n+\t{\n+\t  /* If we see something that might be a memory barrier, we\n+\t     have to stop looking.  Even if the MEM is set later in\n+\t     the function, we still don't want to set it\n+\t     unconditionally before the barrier.  */\n+\t  if (INSN_P (insn)\n+\t      && (volatile_insn_p (PATTERN (insn))\n+\t\t  || (CALL_P (insn)\n+\t\t      && (!CONST_OR_PURE_CALL_P (insn)\n+\t\t\t  || pure_call_p (insn)))))\n+\t    return false;\n+\n+\t  if (memory_modified_in_insn_p (mem, insn))\n+\t    return true;\n+\t  if (modified_in_p (XEXP (mem, 0), insn))\n+\t    return false;\n+\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* Given a simple IF-THEN-JOIN or IF-THEN-ELSE-JOIN block, attempt to convert\n    it without using conditional execution.  Return TRUE if we were successful\n    at converting the block.  */\n@@ -2292,17 +2332,31 @@ noce_process_if_block (struct noce_if_info *if_info)\n       goto success;\n     }\n \n-  /* Disallow the \"if (...) x = a;\" form (with an implicit \"else x = x;\")\n-     for optimizations if writing to x may trap or fault, i.e. it's a memory\n-     other than a static var or a stack slot, is misaligned on strict\n-     aligned machines or is read-only.\n-     If x is a read-only memory, then the program is valid only if we\n-     avoid the store into it.  If there are stores on both the THEN and\n-     ELSE arms, then we can go ahead with the conversion; either the\n-     program is broken, or the condition is always false such that the\n-     other memory is selected.  */\n-  if (!set_b && MEM_P (orig_x) && noce_mem_write_may_trap_or_fault_p (orig_x))\n-    return FALSE;\n+  if (!set_b && MEM_P (orig_x))\n+    {\n+      /* Disallow the \"if (...) x = a;\" form (implicit \"else x = x;\")\n+\t for optimizations if writing to x may trap or fault,\n+\t i.e. it's a memory other than a static var or a stack slot,\n+\t is misaligned on strict aligned machines or is read-only.  If\n+\t x is a read-only memory, then the program is valid only if we\n+\t avoid the store into it.  If there are stores on both the\n+\t THEN and ELSE arms, then we can go ahead with the conversion;\n+\t either the program is broken, or the condition is always\n+\t false such that the other memory is selected.  */\n+      if (noce_mem_write_may_trap_or_fault_p (orig_x))\n+\treturn FALSE;\n+\n+      /* Avoid store speculation: given \"if (...) x = a\" where x is a\n+\t MEM, we only want to do the store if x is always set\n+\t somewhere in the function.  This avoids cases like\n+\t   if (pthread_mutex_trylock(mutex))\n+\t     ++global_variable;\n+\t where we only want global_variable to be changed if the mutex\n+\t is held.  FIXME: This should ideally be expressed directly in\n+\t RTL somehow.  */\n+      if (!noce_can_store_speculate_p (test_bb, orig_x))\n+\treturn FALSE;\n+    }\n \n   if (noce_try_move (if_info))\n     goto success;\n@@ -3957,7 +4011,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n /* Main entry point for all if-conversion.  */\n \n static void\n-if_convert (bool recompute_dominance)\n+if_convert (void)\n {\n   basic_block bb;\n   int pass;\n@@ -3977,9 +4031,8 @@ if_convert (bool recompute_dominance)\n   loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n \n-  /* Compute postdominators if we think we'll use them.  */\n-  if (HAVE_conditional_execution || recompute_dominance)\n-    calculate_dominance_info (CDI_POST_DOMINATORS);\n+  /* Compute postdominators.  */\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   df_set_flags (DF_LR_RUN_DCE);\n \n@@ -4068,7 +4121,7 @@ rest_of_handle_if_conversion (void)\n       if (dump_file)\n         dump_flow_info (dump_file, dump_flags);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n-      if_convert (false);\n+      if_convert ();\n     }\n \n   cleanup_cfg (0);\n@@ -4105,7 +4158,7 @@ gate_handle_if_after_combine (void)\n static unsigned int\n rest_of_handle_if_after_combine (void)\n {\n-  if_convert (true);\n+  if_convert ();\n   return 0;\n }\n \n@@ -4138,7 +4191,7 @@ gate_handle_if_after_reload (void)\n static unsigned int\n rest_of_handle_if_after_reload (void)\n {\n-  if_convert (true);\n+  if_convert ();\n   return 0;\n }\n "}]}