{"sha": "f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRiMGIxZTNiYjRkZDRkODllZmRlZTk5YjVkMDMyMzAyYTVmNDcxNw==", "commit": {"author": {"name": "Adhemerval Zanella", "email": "azanella@linux.vnet.ibm.com", "date": "2014-10-19T13:49:26Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2014-10-19T13:49:26Z"}, "message": "rs6000.c (rs6000_atomic_assign_expand_fenv): New function.\n\n2014-10-19  Adhemerval Zanella  <azanella@linux.vnet.ibm.com>\n            David Edelsohn  <dje.gcc@gmail.com>\n\n        * config/rs6000/rs6000.c (rs6000_atomic_assign_expand_fenv): New\n        function.\n        (TARGET_ATOMIC_ASSIGN_EXPAND_FENV): New define.\n\t* gcc.dg/atomic/c11-atomic-exec-5.c\n\t(test_main_long_double_add_overflow): Define and run only for\n\tLDBL_MANT_DIG != 106.\n\t(test_main_complex_long_double_add_overflow): Likewise.\n\t(test_main_long_double_sub_overflow): Likewise.\n\t(test_main_complex_long_double_sub_overflow): Likewise.\n\nCo-Authored-By: David Edelsohn <dje.gcc@gmail.com>\n\nFrom-SVN: r216437", "tree": {"sha": "7a967801fb194a96aebe241cfc33ac718c2af1ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a967801fb194a96aebe241cfc33ac718c2af1ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/comments", "author": null, "committer": null, "parents": [{"sha": "fad0fe1eda55c19395679cd9cd4180a1c1037f70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad0fe1eda55c19395679cd9cd4180a1c1037f70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad0fe1eda55c19395679cd9cd4180a1c1037f70"}], "stats": {"total": 138, "additions": 134, "deletions": 4}, "files": [{"sha": "9a7f7d2800c9a3b791d7d433e0dea2ea35f9a1d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "patch": "@@ -1,3 +1,10 @@\n+2014-10-19  Adhemerval Zanella  <azanella@linux.vnet.ibm.com>\n+\t    David Edelsohn  <dje.gcc@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_atomic_assign_expand_fenv): New\n+\tfunction.\n+\t(TARGET_ATOMIC_ASSIGN_EXPAND_FENV): New define.\n+\n 2014-10-18  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* doc/invoke.texi (Options to Request or Suppress Warnings):"}, {"sha": "2f14c2b6c3e3335fb065fa6043f7d27a7aae72de", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "patch": "@@ -1647,6 +1647,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n+\n+#undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n+#define TARGET_ATOMIC_ASSIGN_EXPAND_FENV rs6000_atomic_assign_expand_fenv\n \f\n \n /* Processor table.  */\n@@ -34575,6 +34578,117 @@ make_pass_analyze_swaps (gcc::context *ctxt)\n {\n   return new pass_analyze_swaps (ctxt);\n }\n+\n+/* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV hook.  */\n+\n+static void\n+rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n+{\n+  if (!TARGET_HARD_FLOAT || !TARGET_FPRS)\n+    return;\n+\n+  tree mffs = rs6000_builtin_decls[RS6000_BUILTIN_MFFS];\n+  tree mtfsf = rs6000_builtin_decls[RS6000_BUILTIN_MTFSF];\n+  tree call_mffs = build_call_expr (mffs, 0);\n+\n+  /* Generates the equivalent of feholdexcept (&fenv_var)\n+\n+     *fenv_var = __builtin_mffs ();\n+     double fenv_hold;\n+     *(uint64_t*)&fenv_hold = *(uint64_t*)fenv_var & 0xffffffff00000007LL;\n+     __builtin_mtfsf (0xff, fenv_hold);  */\n+\n+  /* Mask to clear everything except for the rounding modes and non-IEEE\n+     arithmetic flag.  */\n+  const unsigned HOST_WIDE_INT hold_exception_mask =\n+    HOST_WIDE_INT_C (0xffffffff00000007);\n+\n+  tree fenv_var = create_tmp_var (double_type_node, NULL);\n+\n+  tree hold_mffs = build2 (MODIFY_EXPR, void_type_node, fenv_var, call_mffs);\n+\n+  tree fenv_llu = build1 (VIEW_CONVERT_EXPR, uint64_type_node, fenv_var);\n+  tree fenv_llu_and = build2 (BIT_AND_EXPR, uint64_type_node, fenv_llu,\n+\t\t\t      build_int_cst (uint64_type_node,\n+\t\t\t\t\t     hold_exception_mask));\n+\n+  tree fenv_hold_mtfsf = build1 (VIEW_CONVERT_EXPR, double_type_node,\n+\t\t\t\t fenv_llu_and);\n+\n+  tree hold_mtfsf = build_call_expr (mtfsf, 2,\n+\t\t\t\t     build_int_cst (unsigned_type_node, 0xff),\n+\t\t\t\t     fenv_hold_mtfsf);\n+\n+  *hold = build2 (COMPOUND_EXPR, void_type_node, hold_mffs, hold_mtfsf);\n+\n+  /* Generates the equivalent of feclearexcept (FE_ALL_EXCEPT):\n+\n+     double fenv_clear = __builtin_mffs ();\n+     *(uint64_t)&fenv_clear &= 0xffffffff00000000LL;\n+     __builtin_mtfsf (0xff, fenv_clear);  */\n+\n+  /* Mask to clear everything except for the rounding modes and non-IEEE\n+     arithmetic flag.  */\n+  const unsigned HOST_WIDE_INT clear_exception_mask =\n+    HOST_WIDE_INT_C (0xffffffff00000000);\n+\n+  tree fenv_clear = create_tmp_var (double_type_node, NULL);\n+\n+  tree clear_mffs = build2 (MODIFY_EXPR, void_type_node, fenv_clear, call_mffs);\n+\n+  tree fenv_clean_llu = build1 (VIEW_CONVERT_EXPR, uint64_type_node, fenv_clear);\n+  tree fenv_clear_llu_and = build2 (BIT_AND_EXPR, uint64_type_node,\n+\t\t\t\t    fenv_clean_llu,\n+\t\t\t\t    build_int_cst (uint64_type_node,\n+\t\t\t\t\t\t   clear_exception_mask));\n+\n+  tree fenv_clear_mtfsf = build1 (VIEW_CONVERT_EXPR, double_type_node,\n+\t\t\t\t  fenv_clear_llu_and);\n+\n+  tree clear_mtfsf = build_call_expr (mtfsf, 2,\n+\t\t\t\t      build_int_cst (unsigned_type_node, 0xff),\n+\t\t\t\t      fenv_clear_mtfsf);\n+\n+  *clear = build2 (COMPOUND_EXPR, void_type_node, clear_mffs, clear_mtfsf);\n+\n+  /* Generates the equivalent of feupdateenv (&fenv_var)\n+\n+     double old_fenv = __builtin_mffs ();\n+     double fenv_update;\n+     *(uint64_t*)&fenv_update = (*(uint64_t*)&old & 0xffffffff1fffff00LL) |\n+                                (*(uint64_t*)fenv_var 0x1ff80fff);\n+     __builtin_mtfsf (0xff, fenv_update);  */\n+\n+  const unsigned HOST_WIDE_INT update_exception_mask =\n+    HOST_WIDE_INT_C (0xffffffff1fffff00);\n+  const unsigned HOST_WIDE_INT new_exception_mask =\n+    HOST_WIDE_INT_C (0x1ff80fff);\n+\n+  tree old_fenv = create_tmp_var (double_type_node, NULL);\n+  tree update_mffs = build2 (MODIFY_EXPR, void_type_node, old_fenv, call_mffs);\n+\n+  tree old_llu = build1 (VIEW_CONVERT_EXPR, uint64_type_node, old_fenv);\n+  tree old_llu_and = build2 (BIT_AND_EXPR, uint64_type_node, old_llu,\n+\t\t\t     build_int_cst (uint64_type_node,\n+\t\t\t\t\t    update_exception_mask));\n+\n+  tree new_llu_and = build2 (BIT_AND_EXPR, uint64_type_node, fenv_llu,\n+\t\t\t     build_int_cst (uint64_type_node,\n+\t\t\t\t\t    new_exception_mask));\n+\n+  tree new_llu_mask = build2 (BIT_IOR_EXPR, uint64_type_node,\n+\t\t\t      old_llu_and, new_llu_and);\n+\n+  tree fenv_update_mtfsf = build1 (VIEW_CONVERT_EXPR, double_type_node,\n+\t\t\t\t   new_llu_mask);\n+\n+  tree update_mtfsf = build_call_expr (mtfsf, 2,\n+\t\t\t\t       build_int_cst (unsigned_type_node, 0xff),\n+\t\t\t\t       fenv_update_mtfsf);\n+\n+  *update = build2 (COMPOUND_EXPR, void_type_node, update_mffs, update_mtfsf);\n+}\n+\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "88b321b07c9164c56eed26cd425895586b49a445", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "patch": "@@ -1,3 +1,12 @@\n+2014-10-19  Adhemerval Zanella  <azanella@linux.vnet.ibm.com>\n+\n+\t* gcc.dg/atomic/c11-atomic-exec-5.c\n+\t(test_main_long_double_add_overflow): Define and run only for\n+\tLDBL_MANT_DIG != 106.\n+\t(test_main_complex_long_double_add_overflow): Likewise.\n+\t(test_main_long_double_sub_overflow): Likewise.\n+\t(test_main_complex_long_double_sub_overflow): Likewise.\n+\n 2014-10-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/63553"}, {"sha": "7166042ba7f47af854f70d787bca41d500829f3e", "filename": "gcc/testsuite/gcc.dg/atomic/c11-atomic-exec-5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fc11-atomic-exec-5.c?ref=f4b0b1e3bb4dd4d89efdee99b5d032302a5f4717", "patch": "@@ -507,23 +507,23 @@ main (void)\n   ret |= test_main_int_div_double_inexact ();\n   ret |= test_main_complex_double_div_overflow ();\n   ret |= test_main_long_double_add_invalid ();\n-  ret |= test_main_long_double_add_overflow ();\n #if LDBL_MANT_DIG != 106\n+  ret |= test_main_long_double_add_overflow ();\n   ret |= test_main_long_double_add_inexact ();\n   ret |= test_main_long_double_add_inexact_int ();\n   ret |= test_main_long_double_preinc_inexact ();\n   ret |= test_main_long_double_postinc_inexact ();\n-#endif\n   ret |= test_main_complex_long_double_add_overflow ();\n+#endif\n   ret |= test_main_long_double_sub_invalid ();\n-  ret |= test_main_long_double_sub_overflow ();\n #if LDBL_MANT_DIG != 106\n+  ret |= test_main_long_double_sub_overflow ();\n   ret |= test_main_long_double_sub_inexact ();\n   ret |= test_main_long_double_sub_inexact_int ();\n   ret |= test_main_long_double_predec_inexact ();\n   ret |= test_main_long_double_postdec_inexact ();\n-#endif\n   ret |= test_main_complex_long_double_sub_overflow ();\n+#endif\n   ret |= test_main_long_double_mul_invalid ();\n   ret |= test_main_long_double_mul_overflow ();\n   ret |= test_main_long_double_mul_overflow_float ();"}]}