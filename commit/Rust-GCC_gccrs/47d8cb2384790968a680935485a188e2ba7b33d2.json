{"sha": "47d8cb2384790968a680935485a188e2ba7b33d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkOGNiMjM4NDc5MDk2OGE2ODA5MzU0ODVhMTg4ZTJiYTdiMzNkMg==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2019-04-16T10:20:52Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2019-04-16T10:20:52Z"}, "message": "[ARC] Refurb eliminate regs.\n\ngcc/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n        * config/arc/arc.c (arc_hard_regno_modes): Add two missing modes\n        for last two fake registers.\n        (arc_conditional_register_usage): Make sure fake frame and arg\n        pointer regs are in general regs class.\n        (FRAME_POINTER_MASK): Remove.\n        (RETURN_ADDR_MASK): Remove.\n        (arc_must_save_register): Use hard frame regnum.\n        (frame_restore_reg): Use hard_frame_pointer_rtx.\n        (arc_save_callee_saves): Likewise.\n        (arc_restore_callee_saves): Likewise.\n        (arc_save_callee_enter): Likewise.\n        (arc_restore_callee_leave): Likewise.\n        (arc_save_callee_milli): Likewise.\n        (arc_eh_return_address_location): Likewise.\n        (arc_check_multi): Use hard frame regnum.\n        (arc_can_eliminate): Likewise.\n        * config/arc/arc.h (FIXED_REGISTERS): Make FP register available\n        for register allocator.\n        (REG_CLASS_CONTENTS): Update GENERAL_REGS.\n        (REGNO_OK_FOR_BASE_P): Consider FRAME_POINTER_REGNUM.\n        (FRAME_POINTER_REGNUM): Change it to a fake register.\n        (HARD_FRAME_POINTER_REGNUM): Defined.\n        (ARG_POINTER_REGNUM): Change it to a new fake register.\n        (ELIMINABLE_REGS): Update.\n        (REGISTER_NAMES): Update names.\n        * config/arc/arc.md (LP_START): Remove.\n        (LP_END): Likewise.\n        (shift_si3_loop): Update pattern.\n\nFrom-SVN: r270385", "tree": {"sha": "6e4f62ffa3e870966c1117cbb0f0624264cfa9ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e4f62ffa3e870966c1117cbb0f0624264cfa9ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47d8cb2384790968a680935485a188e2ba7b33d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d8cb2384790968a680935485a188e2ba7b33d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d8cb2384790968a680935485a188e2ba7b33d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d8cb2384790968a680935485a188e2ba7b33d2/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ec86e1eaa90fb5cbce6a658ebd797f73b4cab6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec86e1eaa90fb5cbce6a658ebd797f73b4cab6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ec86e1eaa90fb5cbce6a658ebd797f73b4cab6d"}], "stats": {"total": 247, "additions": 146, "deletions": 101}, "files": [{"sha": "69e0d0f4014aad2ce6099df73efabf39c720f1eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47d8cb2384790968a680935485a188e2ba7b33d2", "patch": "@@ -1,3 +1,34 @@\n+2019-04-16  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.c (arc_hard_regno_modes): Add two missing modes\n+\tfor last two fake registers.\n+\t(arc_conditional_register_usage): Make sure fake frame and arg\n+\tpointer regs are in general regs class.\n+\t(FRAME_POINTER_MASK): Remove.\n+\t(RETURN_ADDR_MASK): Remove.\n+\t(arc_must_save_register): Use hard frame regnum.\n+\t(frame_restore_reg): Use hard_frame_pointer_rtx.\n+\t(arc_save_callee_saves): Likewise.\n+\t(arc_restore_callee_saves): Likewise.\n+\t(arc_save_callee_enter): Likewise.\n+\t(arc_restore_callee_leave): Likewise.\n+\t(arc_save_callee_milli): Likewise.\n+\t(arc_eh_return_address_location): Likewise.\n+\t(arc_check_multi): Use hard frame regnum.\n+\t(arc_can_eliminate): Likewise.\n+\t* config/arc/arc.h (FIXED_REGISTERS): Make FP register available\n+\tfor register allocator.\n+\t(REG_CLASS_CONTENTS): Update GENERAL_REGS.\n+\t(REGNO_OK_FOR_BASE_P): Consider FRAME_POINTER_REGNUM.\n+\t(FRAME_POINTER_REGNUM): Change it to a fake register.\n+\t(HARD_FRAME_POINTER_REGNUM): Defined.\n+\t(ARG_POINTER_REGNUM): Change it to a new fake register.\n+\t(ELIMINABLE_REGS): Update.\n+\t(REGISTER_NAMES): Update names.\n+\t* config/arc/arc.md (LP_START): Remove.\n+\t(LP_END): Likewise.\n+\t(shift_si3_loop): Update pattern.\n+\n 2019-04-16  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.c (arc_expand_prologue): Emit blockage regardless"}, {"sha": "af8073c7b71dc19d07bc2d2b0a710a150c68f7c2", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 93, "deletions": 80, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=47d8cb2384790968a680935485a188e2ba7b33d2", "patch": "@@ -1654,7 +1654,8 @@ static unsigned int arc_hard_regno_modes[] = {\n   V_MODES, V_MODES, V_MODES, V_MODES, V_MODES, V_MODES, V_MODES, V_MODES,\n \n   S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n-  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES\n+  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n+  S_MODES, S_MODES\n };\n \n static unsigned int arc_mode_class [NUM_MACHINE_MODES];\n@@ -1841,7 +1842,8 @@ arc_conditional_register_usage (void)\n \n   /* Handle Special Registers.  */\n   arc_regno_reg_class[CC_REG] = NO_REGS;      /* CC_REG: must be NO_REGS.  */\n-  arc_regno_reg_class[62] = GENERAL_REGS;\n+  arc_regno_reg_class[FRAME_POINTER_REGNUM] = GENERAL_REGS;\n+  arc_regno_reg_class[ARG_POINTER_REGNUM] = GENERAL_REGS;\n \n   if (TARGET_DPFP)\n     for (i = R40_REG; i < R44_REG; ++i)\n@@ -2568,8 +2570,53 @@ arc_compute_function_type (struct function *fun)\n   return fun->machine->fn_type = fn_type;\n }\n \n-#define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n-#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n+/* Helper function to wrap FRAME_POINTER_NEEDED.  We do this as\n+   FRAME_POINTER_NEEDED will not be true until the IRA (Integrated\n+   Register Allocator) pass, while we want to get the frame size\n+   correct earlier than the IRA pass.\n+\n+   When a function uses eh_return we must ensure that the fp register\n+   is saved and then restored so that the unwinder can restore the\n+   correct value for the frame we are going to jump to.\n+\n+   To do this we force all frames that call eh_return to require a\n+   frame pointer (see arc_frame_pointer_required), this\n+   will ensure that the previous frame pointer is stored on entry to\n+   the function, and will then be reloaded at function exit.\n+\n+   As the frame pointer is handled as a special case in our prologue\n+   and epilogue code it must not be saved and restored using the\n+   MUST_SAVE_REGISTER mechanism otherwise we run into issues where GCC\n+   believes that the function is not using a frame pointer and that\n+   the value in the fp register is the frame pointer, while the\n+   prologue and epilogue are busy saving and restoring the fp\n+   register.\n+\n+   During compilation of a function the frame size is evaluated\n+   multiple times, it is not until the reload pass is complete the the\n+   frame size is considered fixed (it is at this point that space for\n+   all spills has been allocated).  However the frame_pointer_needed\n+   variable is not set true until the register allocation pass, as a\n+   result in the early stages the frame size does not include space\n+   for the frame pointer to be spilled.\n+\n+   The problem that this causes is that the rtl generated for\n+   EH_RETURN_HANDLER_RTX uses the details of the frame size to compute\n+   the offset from the frame pointer at which the return address\n+   lives.  However, in early passes GCC has not yet realised we need a\n+   frame pointer, and so has not included space for the frame pointer\n+   in the frame size, and so gets the offset of the return address\n+   wrong.  This should not be an issue as in later passes GCC has\n+   realised that the frame pointer needs to be spilled, and has\n+   increased the frame size.  However, the rtl for the\n+   EH_RETURN_HANDLER_RTX is not regenerated to use the newer, larger\n+   offset, and the wrong smaller offset is used.  */\n+\n+static bool\n+arc_frame_pointer_needed (void)\n+{\n+  return (frame_pointer_needed || crtl->calls_eh_return);\n+}\n \n /* Tell prologue and epilogue if register REGNO should be saved /\n    restored.  The return address, stack pointer and frame pointer are\n@@ -2607,16 +2654,28 @@ arc_must_save_register (int regno, struct function *func)\n       break;\n     }\n \n-  if ((regno) != RETURN_ADDR_REGNUM\n-      && (regno) != FRAME_POINTER_REGNUM\n-      && (regno) != STACK_POINTER_REGNUM\n-      && df_regs_ever_live_p (regno)\n-      && (!call_used_regs[regno]\n-\t  || ARC_INTERRUPT_P (fn_type))\n-      /* Do not emit code for auto saved regs.  */\n-      && !irq_auto_save_p\n-      && !firq_auto_save_p)\n-    return true;\n+  switch (regno)\n+    {\n+    case RETURN_ADDR_REGNUM:\n+    case STACK_POINTER_REGNUM:\n+      return false;\n+\n+    case HARD_FRAME_POINTER_REGNUM:\n+      /* If we need FP reg as a frame pointer then don't save it as a\n+\t regular reg.  */\n+      if (arc_frame_pointer_needed ())\n+\treturn false;\n+\n+      /* FALLTHRU */\n+    default:\n+      if (df_regs_ever_live_p (regno)\n+\t  && (!call_used_regs[regno]\n+\t      || ARC_INTERRUPT_P (fn_type))\n+\t  /* Do not emit code for auto saved regs.  */\n+\t  && !irq_auto_save_p\n+\t  && !firq_auto_save_p)\n+\treturn true;\n+    }\n \n   return false;\n }\n@@ -2633,54 +2692,6 @@ arc_must_save_return_addr (struct function *func)\n   return false;\n }\n \n-/* Helper function to wrap FRAME_POINTER_NEEDED.  We do this as\n-   FRAME_POINTER_NEEDED will not be true until the IRA (Integrated\n-   Register Allocator) pass, while we want to get the frame size\n-   correct earlier than the IRA pass.\n-\n-   When a function uses eh_return we must ensure that the fp register\n-   is saved and then restored so that the unwinder can restore the\n-   correct value for the frame we are going to jump to.\n-\n-   To do this we force all frames that call eh_return to require a\n-   frame pointer (see arc_frame_pointer_required), this\n-   will ensure that the previous frame pointer is stored on entry to\n-   the function, and will then be reloaded at function exit.\n-\n-   As the frame pointer is handled as a special case in our prologue\n-   and epilogue code it must not be saved and restored using the\n-   MUST_SAVE_REGISTER mechanism otherwise we run into issues where GCC\n-   believes that the function is not using a frame pointer and that\n-   the value in the fp register is the frame pointer, while the\n-   prologue and epilogue are busy saving and restoring the fp\n-   register.\n-\n-   During compilation of a function the frame size is evaluated\n-   multiple times, it is not until the reload pass is complete the the\n-   frame size is considered fixed (it is at this point that space for\n-   all spills has been allocated).  However the frame_pointer_needed\n-   variable is not set true until the register allocation pass, as a\n-   result in the early stages the frame size does not include space\n-   for the frame pointer to be spilled.\n-\n-   The problem that this causes is that the rtl generated for\n-   EH_RETURN_HANDLER_RTX uses the details of the frame size to compute\n-   the offset from the frame pointer at which the return address\n-   lives.  However, in early passes GCC has not yet realised we need a\n-   frame pointer, and so has not included space for the frame pointer\n-   in the frame size, and so gets the offset of the return address\n-   wrong.  This should not be an issue as in later passes GCC has\n-   realised that the frame pointer needs to be spilled, and has\n-   increased the frame size.  However, the rtl for the\n-   EH_RETURN_HANDLER_RTX is not regenerated to use the newer, larger\n-   offset, and the wrong smaller offset is used.  */\n-\n-static bool\n-arc_frame_pointer_needed (void)\n-{\n-  return (frame_pointer_needed || crtl->calls_eh_return);\n-}\n-\n /* Return non-zero if there are registers to be saved or loaded using\n    millicode thunks.  We can only use consecutive sequences starting\n    with r13, and not going beyond r25.\n@@ -2942,7 +2953,7 @@ frame_restore_reg (rtx reg, HOST_WIDE_INT offset)\n   insn = frame_move_inc (reg, addr, stack_pointer_rtx, 0);\n   add_reg_note (insn, REG_CFA_RESTORE, reg);\n \n-  if (reg == frame_pointer_rtx)\n+  if (reg == hard_frame_pointer_rtx)\n     add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t  plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t GET_MODE_SIZE (GET_MODE (reg)) + offset));\n@@ -3028,13 +3039,13 @@ arc_save_callee_saves (unsigned int gmask,\n      registers are saved.  */\n   if (save_fp)\n     {\n-      frame_allocated += frame_save_reg (frame_pointer_rtx, offset);\n+      frame_allocated += frame_save_reg (hard_frame_pointer_rtx, offset);\n       offset = 0;\n     }\n \n   /* Emit mov fp,sp.  */\n   if (arc_frame_pointer_needed ())\n-    frame_move (frame_pointer_rtx, stack_pointer_rtx);\n+    frame_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n \n   return frame_allocated;\n }\n@@ -3057,7 +3068,7 @@ arc_restore_callee_saves (unsigned int gmask,\n   /* Emit mov fp,sp.  */\n   if (arc_frame_pointer_needed () && offset)\n     {\n-      frame_move (stack_pointer_rtx, frame_pointer_rtx);\n+      frame_move (stack_pointer_rtx, hard_frame_pointer_rtx);\n       frame_deallocated += offset;\n       offset = 0;\n     }\n@@ -3066,7 +3077,7 @@ arc_restore_callee_saves (unsigned int gmask,\n     {\n       /* Any offset is taken care by previous if-statement.  */\n       gcc_assert (offset == 0);\n-      frame_deallocated += frame_restore_reg (frame_pointer_rtx, 0);\n+      frame_deallocated += frame_restore_reg (hard_frame_pointer_rtx, 0);\n     }\n \n   if (offset)\n@@ -3211,11 +3222,11 @@ arc_save_callee_enter (unsigned int gmask,\n       mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n \t\t\t\t\t\t stack_pointer_rtx,\n \t\t\t\t\t\t off));\n-      XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, frame_pointer_rtx);\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, hard_frame_pointer_rtx);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n       off -= UNITS_PER_WORD;\n \n-      XVECEXP (insn, 0, indx) = gen_rtx_SET (frame_pointer_rtx,\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (hard_frame_pointer_rtx,\n \t\t\t\t\t     stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n       save_fp = false;\n@@ -3319,7 +3330,7 @@ arc_restore_callee_leave (unsigned int gmask,\n       mem = gen_frame_mem (Pmode, plus_constant (Pmode,\n \t\t\t\t\t\t stack_pointer_rtx,\n \t\t\t\t\t\t off));\n-      XVECEXP (insn, 0, indx) = gen_rtx_SET (frame_pointer_rtx, mem);\n+      XVECEXP (insn, 0, indx) = gen_rtx_SET (hard_frame_pointer_rtx, mem);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx++)) = 1;\n       off -= UNITS_PER_WORD;\n     }\n@@ -3338,7 +3349,7 @@ arc_restore_callee_leave (unsigned int gmask,\n   /* Dwarf related info.  */\n   if (restore_fp)\n     {\n-      add_reg_note (insn, REG_CFA_RESTORE, frame_pointer_rtx);\n+      add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n       add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t    plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t   offset + nregs * UNITS_PER_WORD));\n@@ -3476,11 +3487,11 @@ arc_save_callee_milli (unsigned int gmask,\n      above loop to save fp because our ABI states fp goes aftert all\n      registers are saved.  */\n   if (save_fp)\n-    frame_allocated += frame_save_reg (frame_pointer_rtx, offset);\n+    frame_allocated += frame_save_reg (hard_frame_pointer_rtx, offset);\n \n   /* Emit mov fp,sp.  */\n   if (arc_frame_pointer_needed ())\n-    frame_move (frame_pointer_rtx, stack_pointer_rtx);\n+    frame_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n \n   return frame_allocated;\n }\n@@ -3510,13 +3521,13 @@ arc_restore_callee_milli (unsigned int gmask,\n   /* Emit mov fp,sp.  */\n   if (arc_frame_pointer_needed () && offset)\n     {\n-      frame_move (stack_pointer_rtx, frame_pointer_rtx);\n+      frame_move (stack_pointer_rtx, hard_frame_pointer_rtx);\n       frame_allocated = offset;\n       offset = 0;\n     }\n \n   if (restore_fp)\n-    frame_allocated += frame_restore_reg (frame_pointer_rtx, 0);\n+    frame_allocated += frame_restore_reg (hard_frame_pointer_rtx, 0);\n \n   if (offset)\n     {\n@@ -3826,7 +3837,7 @@ arc_check_multi (rtx op, bool push_p)\n       if (REGNO (reg) == RETURN_ADDR_REGNUM\n \t  && i == start)\n \tregno = 12;\n-      else if (REGNO (reg) == FRAME_POINTER_REGNUM)\n+      else if (REGNO (reg) == HARD_FRAME_POINTER_REGNUM)\n \t++i;\n       else if (REGNO (reg) != regno)\n \treturn false;\n@@ -3873,7 +3884,7 @@ arc_eh_return_address_location (rtx source)\n      included in the 'extra_size' field.  */\n   offset = afi->reg_size + afi->extra_size - 4;\n   mem = gen_frame_mem (Pmode,\n-\t\t       plus_constant (Pmode, frame_pointer_rtx, offset));\n+\t\t       plus_constant (Pmode, hard_frame_pointer_rtx, offset));\n \n   /* The following should not be needed, and is, really a hack.  The\n      issue being worked around here is that the DSE (Dead Store\n@@ -5347,7 +5358,7 @@ arc_final_prescan_insn (rtx_insn *insn, rtx *opvec ATTRIBUTE_UNUSED,\n static bool\n arc_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n {\n-  return ((to == FRAME_POINTER_REGNUM) || !arc_frame_pointer_needed ());\n+  return ((to == HARD_FRAME_POINTER_REGNUM) || (to == STACK_POINTER_REGNUM));\n }\n \n /* Define the offset between two registers, one to be eliminated, and\n@@ -5359,7 +5370,7 @@ arc_initial_elimination_offset (int from, int to)\n   if (!cfun->machine->frame_info.initialized)\n     arc_compute_frame_size ();\n \n-  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+  if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     {\n       return (cfun->machine->frame_info.extra_size\n \t      + cfun->machine->frame_info.reg_size);\n@@ -5378,6 +5389,8 @@ arc_initial_elimination_offset (int from, int to)\n \t      + cfun->machine->frame_info.extra_size\n \t      + cfun->machine->frame_info.reg_size));\n     }\n+  if ((from == FRAME_POINTER_REGNUM) && (to == HARD_FRAME_POINTER_REGNUM))\n+    return 0;\n \n   gcc_unreachable ();\n }\n@@ -10975,7 +10988,7 @@ arc_builtin_setjmp_frame_value (void)\n      frame pointer value for this frame (if the use of the frame pointer\n      had not been removed).  We really do want the raw frame pointer\n      register value.  */\n-  return gen_raw_REG (Pmode, FRAME_POINTER_REGNUM);\n+  return gen_raw_REG (Pmode, HARD_FRAME_POINTER_REGNUM);\n }\n \n /* Return nonzero if a jli call should be generated for a call from"}, {"sha": "77892e67e09d2edcfcd86eac2508a20b0fc878d7", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=47d8cb2384790968a680935485a188e2ba7b33d2", "patch": "@@ -325,7 +325,7 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    argument pointer.  */\n \n /* r63 is pc, r64-r127 = simd vregs, r128-r143 = simd dma config regs\n-   r144, r145 = lp_start, lp_end\n+   r144, r145 = ARG_POINTER, FRAME_POINTER\n    and therefore the pseudo registers start from r146. */\n #define FIRST_PSEUDO_REGISTER 146\n \n@@ -365,7 +365,7 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n { 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 1, 0, 1, 1, 1, 1,\t\\\n \t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   0, 0, 0, 0, 1, 1, 1, 1,\t\\\n@@ -397,7 +397,7 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 1, 0, 1, 1, 1, 1,\t\\\n \t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -532,10 +532,10 @@ enum reg_class\n   {0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'Rsd'.  */ \\\n   {0x0000000f, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'Rcd'.  */ \\\n   {0x0000f00f, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'q'.  */ \\\n-  {0x1c001fff, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'Rsc'.  */ \\\n+  {0x00001fff, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'Rsc'.  */ \\\n   {0x9fffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000}, /* 'h'.  */ \\\n   {0x00000000, 0x00000f00, 0x00000000, 0x00000000, 0x00000000}, /* 'D'.  */ \\\n-  {0xffffffff, 0x8fffffff, 0x00000000, 0x00000000, 0x00000000}, /* 'r'.  */ \\\n+  {0xffffffff, 0x8fffffff, 0x00000000, 0x00000000, 0x00030000}, /* 'r'.  */ \\\n   {0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000}, /* 'v'.  */ \\\n   {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000ffff}, /* 'd'.  */ \\\n   {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x0003ffff} /* ALL_REGS.  */\\\n@@ -583,11 +583,14 @@ extern enum reg_class arc_regno_reg_class[];\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n #define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\t\\\n-  ((REGNO) < 29 || ((REGNO) == ARG_POINTER_REGNUM) || ((REGNO) == 63)\t\\\n+  ((REGNO) < 29\t\t\t\t\t\t\t\t\\\n+   || ((REGNO) == ARG_POINTER_REGNUM)\t\t\t\t\t\\\n+   || ((REGNO) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+   || ((REGNO) == PCL_REG)\t\t\t\t\t\t\\\n    || ((unsigned) reg_renumber[REGNO] < 29)\t\t\t\t\\\n    || ((unsigned) (REGNO) == (unsigned) arc_tp_regno)\t\t\t\\\n    || (fixed_regs[REGNO] == 0 && IN_RANGE (REGNO, 32, 59))\t\t\\\n-   || ((REGNO) == 30 && fixed_regs[REGNO] == 0))\n+   || (fixed_regs[REGNO] == 0 && (REGNO) == R30_REG))\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n \n@@ -673,11 +676,12 @@ arc_return_addr_rtx(COUNT,FRAME)\n #define STACK_POINTER_REGNUM 28\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 27\n+#define FRAME_POINTER_REGNUM 145\n+#define HARD_FRAME_POINTER_REGNUM 27\n \n /* Base register for access to arguments of the function. This register\n    will be eliminated into either fp or sp.  */\n-#define ARG_POINTER_REGNUM 62\n+#define ARG_POINTER_REGNUM 144\n \n #define RETURN_ADDR_REGNUM 31\n \n@@ -787,8 +791,9 @@ arc_return_addr_rtx(COUNT,FRAME)\n \n #define ELIMINABLE_REGS\t\t\t\t\t\\\n {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n- {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+ {ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n+ {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n \n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n@@ -1182,7 +1187,7 @@ extern char rname56[], rname57[], rname58[], rname59[];\n   \"r32\",  \"r33\",  \"r34\",  \"r35\",      \"r36\",    \"r37\",    \"r38\",   \"r39\",\t\\\n    \"d1\",   \"d1\",   \"d2\",   \"d2\",      \"r44\",    \"r45\",    \"r46\",   \"r47\",\t\\\n   \"r48\",  \"r49\",  \"r50\",  \"r51\",      \"r52\",    \"r53\",    \"r54\",   \"r55\",\t\\\n-  rname56,rname57,rname58,rname59,\"lp_count\",    \"cc\",     \"ap\",   \"pcl\",\t\\\n+  rname56,rname57,rname58,rname59,\"lp_count\",    \"cc\",   \"limm\",   \"pcl\",\t\\\n   \"vr0\",  \"vr1\",  \"vr2\",  \"vr3\",      \"vr4\",    \"vr5\",    \"vr6\",   \"vr7\",       \\\n   \"vr8\",  \"vr9\", \"vr10\", \"vr11\",     \"vr12\",   \"vr13\",   \"vr14\",  \"vr15\",\t\\\n  \"vr16\", \"vr17\", \"vr18\", \"vr19\",     \"vr20\",   \"vr21\",   \"vr22\",  \"vr23\",\t\\\n@@ -1193,7 +1198,7 @@ extern char rname56[], rname57[], rname58[], rname59[];\n  \"vr56\", \"vr57\", \"vr58\", \"vr59\",     \"vr60\",   \"vr61\",   \"vr62\",  \"vr63\",\t\\\n   \"dr0\",  \"dr1\",  \"dr2\",  \"dr3\",      \"dr4\",    \"dr5\",    \"dr6\",   \"dr7\",\t\\\n   \"dr0\",  \"dr1\",  \"dr2\",  \"dr3\",      \"dr4\",    \"dr5\",    \"dr6\",   \"dr7\",\t\\\n-  \"lp_start\", \"lp_end\" \\\n+  \"arg\", \"frame\" \\\n }\n \n #define ADDITIONAL_REGISTER_NAMES\t\t\\"}, {"sha": "0bd05fa79b4e5a62221eb9365961c2be10a11005", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8cb2384790968a680935485a188e2ba7b33d2/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=47d8cb2384790968a680935485a188e2ba7b33d2", "patch": "@@ -201,8 +201,6 @@\n    (LP_COUNT 60)\n    (CC_REG 61)\n    (PCL_REG 63)\n-   (LP_START 144)\n-   (LP_END 145)\n   ]\n )\n \n@@ -3466,8 +3464,6 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n \t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"rn,Cal\")]))\n    (clobber (match_scratch:SI 4 \"=X,X\"))\n    (clobber (reg:SI LP_COUNT))\n-   (clobber (reg:SI LP_START))\n-   (clobber (reg:SI LP_END))\n    (clobber (reg:CC CC_REG))\n   ]\n   \"!TARGET_BARREL_SHIFTER\"\n@@ -6509,7 +6505,7 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   {\n    int len = XVECLEN (operands[0], 0);\n    rtx tmp = XVECEXP (operands[0], 0, len - 1);\n-   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+   if (XEXP (tmp, 0) != hard_frame_pointer_rtx)\n      {\n       operands[3] = XEXP (tmp, 0);\n       gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));\n@@ -6539,7 +6535,7 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   {\n    int len = XVECLEN (operands[0], 0);\n    rtx tmp = XVECEXP (operands[0], 0, len - 1);\n-   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+   if (XEXP (tmp, 0) != hard_frame_pointer_rtx)\n      {\n       operands[3] = XEXP (tmp, 0);\n       gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));\n@@ -6570,7 +6566,7 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   {\n    int len = XVECLEN (operands[0], 0);\n    rtx tmp = XVECEXP (operands[0], 0, len - 1);\n-   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+   if (XEXP (tmp, 0) != hard_frame_pointer_rtx)\n      {\n       operands[3] = XEXP (tmp, 0);\n       gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));\n@@ -6601,7 +6597,7 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   {\n    int len = XVECLEN (operands[0], 0);\n    rtx tmp = XVECEXP (operands[0], 0, len - 1);\n-   if (XEXP (tmp, 0) != frame_pointer_rtx)\n+   if (XEXP (tmp, 0) != hard_frame_pointer_rtx)\n      {\n       operands[3] = XEXP (tmp, 0);\n       gcc_assert (INTVAL (operands[1]) == INTVAL (operands[2]));"}]}