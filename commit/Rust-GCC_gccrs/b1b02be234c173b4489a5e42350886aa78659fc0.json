{"sha": "b1b02be234c173b4489a5e42350886aa78659fc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFiMDJiZTIzNGMxNzNiNDQ4OWE1ZTQyMzUwODg2YWE3ODY1OWZjMA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-11-08T21:49:08Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-11-08T21:49:08Z"}, "message": "Makefile.in (tree-ssa-loop-ivopts.o): Add sbitmap.h dependency.\n\n\t* Makefile.in (tree-ssa-loop-ivopts.o): Add sbitmap.h dependency.\n\t* tree-ssa-loop-ivopts.c (struct iv_use): Change semantics of\n\trelated_cands.\n\t(struct iv_ca, struct iv_ca_delta): New types.\n\t(tree_ssa_iv_optimize_init): Allocate important_candidates bitmap.\n\t(record_important_candidates): New.\n\t(find_iv_candidates): Call record_important_candidates.\n\t(alloc_use_cost_map): Derive size only from important candidates.\n\t(set_use_iv_cost, get_use_iv_cost): Use hash-like mechanism to speed\n\tup searches.\n\t(determine_use_iv_cost_generic, determine_use_iv_cost_address,\n\tdetermine_use_iv_cost_condition, determine_use_iv_cost_outer,\n\tdetermine_use_iv_cost): Return whether the use can be expressed by\n\tthe candidate.\n\t(determine_use_iv_costs): Prune useless candidates from relate_cands\n\tbitmaps.\n\t(find_best_candidate, set_cost_up_to, set_cost): Removed.\n\t(cheaper_cost_pair, iv_ca_recount_cost, iv_ca_set_no_cp,\n\tiv_ca_set_cp, iv_ca_add_use, iv_ca_cost, iv_ca_has_deps,\n\tiv_ca_delta_add, iv_ca_cand_for_use, iv_ca_delta_commit,\n\tiv_ca_cand_used_p, iv_ca_delta_free, iv_ca_new, iv_ca_free,\n\tiv_ca_dump, iv_ca_extend, iv_ca_narrow): New functions.\n\t(try_add_cand_for, get_initial_solution, try_improve_iv_set,\n\tfind_optimal_iv_set, create_new_ivs, tree_ssa_iv_optimize_loop):\n\tUse new iv set representation.\n\t(free_loop_data): clear important_candidates bitmap.\n\t(tree_ssa_iv_optimize_finalize): Free important_candidates bitmap.\n\nFrom-SVN: r90306", "tree": {"sha": "6f240dc18d70ac89ed31e42e1ff4b883ff7c4f50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f240dc18d70ac89ed31e42e1ff4b883ff7c4f50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1b02be234c173b4489a5e42350886aa78659fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b02be234c173b4489a5e42350886aa78659fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b02be234c173b4489a5e42350886aa78659fc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b02be234c173b4489a5e42350886aa78659fc0/comments", "author": null, "committer": null, "parents": [{"sha": "3a723ff6e579d130576135c79c69ac4b6e06710b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a723ff6e579d130576135c79c69ac4b6e06710b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a723ff6e579d130576135c79c69ac4b6e06710b"}], "stats": {"total": 995, "additions": 677, "deletions": 318}, "files": [{"sha": "29fe6c1b009ef713e6d994c96c854bb775143b86", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b02be234c173b4489a5e42350886aa78659fc0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b02be234c173b4489a5e42350886aa78659fc0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b1b02be234c173b4489a5e42350886aa78659fc0", "patch": "@@ -1714,7 +1714,7 @@ tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) varray.h $(EXPR_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n-   cfgloop.h $(PARAMS_H)\n+   cfgloop.h $(PARAMS_H) sbitmap.h\n tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "f22525d12282969de5bee14b05c9cc4aa2139d64", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 676, "deletions": 317, "changes": 993, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b02be234c173b4489a5e42350886aa78659fc0/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b02be234c173b4489a5e42350886aa78659fc0/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b1b02be234c173b4489a5e42350886aa78659fc0", "patch": "@@ -158,7 +158,8 @@ struct iv_use\n   struct iv *iv;\t/* The induction variable it is based on.  */\n   tree stmt;\t\t/* Statement in that it occurs.  */\n   tree *op_p;\t\t/* The place where it occurs.  */\n-  bitmap related_cands;\t/* The set of \"related\" iv candidates.  */\n+  bitmap related_cands;\t/* The set of \"related\" iv candidates, plus the common\n+\t\t\t   important ones.  */\n \n   unsigned n_map_members; /* Number of candidates in the cost_map list.  */\n   struct cost_pair *cost_map;\n@@ -227,6 +228,58 @@ struct ivopts_data\n   bool consider_all_candidates;\n };\n \n+/* An assignment of iv candidates to uses.  */\n+\n+struct iv_ca\n+{\n+  /* The number of uses covered by the assignment.  */\n+  unsigned upto;\n+\n+  /* Number of uses that cannot be expressed by the candidates in the set.  */\n+  unsigned bad_uses;\n+\n+  /* Candidate assigned to a use, together with the related costs.  */\n+  struct cost_pair **cand_for_use;\n+\n+  /* Number of times each candidate is used.  */\n+  unsigned *n_cand_uses;\n+\n+  /* The candidates used.  */\n+  bitmap cands;\n+\n+  /* Total number of registers needed.  */\n+  unsigned n_regs;\n+\n+  /* Total cost of expressing uses.  */\n+  unsigned cand_use_cost;\n+\n+  /* Total cost of candidates.  */\n+  unsigned cand_cost;\n+\n+  /* Number of times each invariant is used.  */\n+  unsigned *n_invariant_uses;\n+\n+  /* Total cost of the assignment.  */\n+  unsigned cost;\n+};\n+\n+/* Difference of two iv candidate assignments.  */\n+\n+struct iv_ca_delta\n+{\n+  /* Changed use.  */\n+  struct iv_use *use;\n+\n+  /* An old assignment (for rollback purposes).  */\n+  struct cost_pair *old_cp;\n+\n+  /* A new assignment.  */\n+  struct cost_pair *new_cp;\n+\n+  /* Next change in the list.  */\n+  struct iv_ca_delta *next_change;\n+};\n+\n /* Bound on number of candidates below that all candidates are considered.  */\n \n #define CONSIDER_ALL_CANDIDATES_BOUND \\\n@@ -589,6 +642,7 @@ tree_ssa_iv_optimize_init (struct loops *loops, struct ivopts_data *data)\n   data->version_info = xcalloc (data->version_info_size,\n \t\t\t\tsizeof (struct version_info));\n   data->relevant = BITMAP_XMALLOC ();\n+  data->important_candidates = BITMAP_XMALLOC ();\n   data->max_inv_id = 0;\n \n   for (i = 1; i < loops->num; i++)\n@@ -1889,6 +1943,45 @@ add_derived_ivs_candidates (struct ivopts_data *data)\n     }\n }\n \n+/* Record important candidates and add them to related_cands bitmaps\n+   if needed.  */\n+\n+static void\n+record_important_candidates (struct ivopts_data *data)\n+{\n+  unsigned i;\n+  struct iv_use *use;\n+\n+  for (i = 0; i < n_iv_cands (data); i++)\n+    {\n+      struct iv_cand *cand = iv_cand (data, i);\n+\n+      if (cand->important)\n+\tbitmap_set_bit (data->important_candidates, i);\n+    }\n+\n+  data->consider_all_candidates = (n_iv_cands (data)\n+\t\t\t\t   <= CONSIDER_ALL_CANDIDATES_BOUND);\n+\n+  if (data->consider_all_candidates)\n+    {\n+      /* We will not need \"related_cands\" bitmaps in this case,\n+\t so release them to decrease peak memory consumption.  */\n+      for (i = 0; i < n_iv_uses (data); i++)\n+\t{\n+\t  use = iv_use (data, i);\n+\t  BITMAP_XFREE (use->related_cands);\n+\t}\n+    }\n+  else\n+    {\n+      /* Add important candidates to the related_cands bitmaps.  */\n+      for (i = 0; i < n_iv_uses (data); i++)\n+\tbitmap_ior_into (iv_use (data, i)->related_cands,\n+\t\t\t data->important_candidates);\n+    }\n+}\n+\n /* Finds the candidates for the induction variables.  */\n \n static void\n@@ -1902,6 +1995,9 @@ find_iv_candidates (struct ivopts_data *data)\n \n   /* Add induction variables derived from uses.  */\n   add_derived_ivs_candidates (data);\n+\n+  /* Record the important candidates.  */\n+  record_important_candidates (data);\n }\n \n /* Allocates the data structure mapping the (use, candidate) pairs to costs.\n@@ -1911,38 +2007,29 @@ find_iv_candidates (struct ivopts_data *data)\n static void\n alloc_use_cost_map (struct ivopts_data *data)\n {\n-  unsigned i, n_imp = 0, size, j;\n-\n-  if (!data->consider_all_candidates)\n-    {\n-      for (i = 0; i < n_iv_cands (data); i++)\n-\t{\n-\t  struct iv_cand *cand = iv_cand (data, i);\n-\t  if (cand->important)\n-\t    n_imp++;\n-\t}\n-    }\n+  unsigned i, size, s, j;\n \n   for (i = 0; i < n_iv_uses (data); i++)\n     {\n       struct iv_use *use = iv_use (data, i);\n       bitmap_iterator bi;\n \n       if (data->consider_all_candidates)\n-\t{\n-\t  size = n_iv_cands (data);\n-\t  use->n_map_members = size;\n-\t}\n+\tsize = n_iv_cands (data);\n       else\n \t{\n-\t  size = n_imp;\n+\t  s = 0;\n \t  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, j, bi)\n \t    {\n-\t      size++;\n+\t      s++;\n \t    }\n-\t  use->n_map_members = 0;\n+\n+\t  /* Round up to the power of two, so that moduling by it is fast.  */\n+\t  for (size = 1; size < s; size <<= 1)\n+\t    continue;\n \t}\n \n+      use->n_map_members = size;\n       use->cost_map = xcalloc (size, sizeof (struct cost_pair));\n     }\n }\n@@ -1955,11 +2042,13 @@ set_use_iv_cost (struct ivopts_data *data,\n \t\t struct iv_use *use, struct iv_cand *cand, unsigned cost,\n \t\t bitmap depends_on)\n {\n-  if (cost == INFTY\n-      && depends_on)\n+  unsigned i, s;\n+\n+  if (cost == INFTY)\n     {\n-      BITMAP_XFREE (depends_on);\n-      depends_on = NULL;\n+      if (depends_on)\n+\tBITMAP_XFREE (depends_on);\n+      return;\n     }\n \n   if (data->consider_all_candidates)\n@@ -1970,42 +2059,55 @@ set_use_iv_cost (struct ivopts_data *data,\n       return;\n     }\n \n-  if (cost == INFTY)\n-    return;\n+  /* n_map_members is a power of two, so this computes modulo.  */\n+  s = cand->id & (use->n_map_members - 1);\n+  for (i = s; i < use->n_map_members; i++)\n+    if (!use->cost_map[i].cand)\n+      goto found;\n+  for (i = 0; i < s; i++)\n+    if (!use->cost_map[i].cand)\n+      goto found;\n+\n+  gcc_unreachable ();\n \n-  use->cost_map[use->n_map_members].cand = cand;\n-  use->cost_map[use->n_map_members].cost = cost;\n-  use->cost_map[use->n_map_members].depends_on = depends_on;\n-  use->n_map_members++;\n+found:\n+  use->cost_map[i].cand = cand;\n+  use->cost_map[i].cost = cost;\n+  use->cost_map[i].depends_on = depends_on;\n }\n \n-/* Gets cost of (USE, CANDIDATE) pair.  Stores the bitmap of dependencies to\n-   DEPENDS_ON.  */\n+/* Gets cost of (USE, CANDIDATE) pair.  */\n \n-static unsigned\n-get_use_iv_cost (struct ivopts_data *data,\n-\t\t struct iv_use *use, struct iv_cand *cand, bitmap *depends_on)\n+static struct cost_pair *\n+get_use_iv_cost (struct ivopts_data *data, struct iv_use *use,\n+\t\t struct iv_cand *cand)\n {\n-  unsigned i;\n+  unsigned i, s;\n+  struct cost_pair *ret;\n \n   if (!cand)\n-    return INFTY;\n+    return NULL;\n \n   if (data->consider_all_candidates)\n-    i = cand->id;\n-  else\n     {\n-      for (i = 0; i < use->n_map_members; i++)\n-\tif (use->cost_map[i].cand == cand)\n-\t  break;\n+      ret = use->cost_map + cand->id;\n+      if (!ret->cand)\n+\treturn NULL;\n \n-      if (i == use->n_map_members)\n-\treturn INFTY;\n+      return ret;\n     }\n+      \n+  /* n_map_members is a power of two, so this computes modulo.  */\n+  s = cand->id & (use->n_map_members - 1);\n+  for (i = s; i < use->n_map_members; i++)\n+    if (use->cost_map[i].cand == cand)\n+      return use->cost_map + i;\n \n-  if (depends_on)\n-    *depends_on = use->cost_map[i].depends_on;\n-  return use->cost_map[i].cost;\n+  for (i = 0; i < s; i++)\n+    if (use->cost_map[i].cand == cand)\n+      return use->cost_map + i;\n+\n+  return NULL;\n }\n \n /* Returns estimate on cost of computing SEQ.  */\n@@ -2948,26 +3050,30 @@ get_computation_cost (struct ivopts_data *data,\n /* Determines cost of basing replacement of USE on CAND in a generic\n    expression.  */\n \n-static void\n+static bool\n determine_use_iv_cost_generic (struct ivopts_data *data,\n \t\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   bitmap depends_on;\n   unsigned cost = get_computation_cost (data, use, cand, false, &depends_on);\n \n   set_use_iv_cost (data, use, cand, cost, depends_on);\n+\n+  return cost != INFTY;\n }\n \n /* Determines cost of basing replacement of USE on CAND in an address.  */\n \n-static void\n+static bool\n determine_use_iv_cost_address (struct ivopts_data *data,\n \t\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   bitmap depends_on;\n   unsigned cost = get_computation_cost (data, use, cand, true, &depends_on);\n \n   set_use_iv_cost (data, use, cand, cost, depends_on);\n+\n+  return cost != INFTY;\n }\n \n /* Computes value of induction variable IV in iteration NITER.  */\n@@ -3069,7 +3175,7 @@ may_eliminate_iv (struct loop *loop,\n \n /* Determines cost of basing replacement of USE on CAND in a condition.  */\n \n-static void\n+static bool\n determine_use_iv_cost_condition (struct ivopts_data *data,\n \t\t\t\t struct iv_use *use, struct iv_cand *cand)\n {\n@@ -3080,7 +3186,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   if (!cand->iv)\n     {\n       set_use_iv_cost (data, use, cand, INFTY, NULL);\n-      return;\n+      return false;\n     }\n \n   if (may_eliminate_iv (data->current_loop, use, cand, &compare, &bound))\n@@ -3089,7 +3195,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       unsigned cost = force_var_cost (data, bound, &depends_on);\n \n       set_use_iv_cost (data, use, cand, cost, depends_on);\n-      return;\n+      return cost != INFTY;\n     }\n \n   /* The induction variable elimination failed; just express the original\n@@ -3103,7 +3209,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       record_invariant (data, TREE_OPERAND (*use->op_p, 1), true);\n     }\n \n-  determine_use_iv_cost_generic (data, use, cand);\n+  return determine_use_iv_cost_generic (data, use, cand);\n }\n \n /* Checks whether it is possible to replace the final value of USE by\n@@ -3135,7 +3241,7 @@ may_replace_final_value (struct loop *loop, struct iv_use *use, tree *value)\n \n /* Determines cost of replacing final value of USE using CAND.  */\n \n-static void\n+static bool\n determine_use_iv_cost_outer (struct ivopts_data *data,\n \t\t\t     struct iv_use *use, struct iv_cand *cand)\n {\n@@ -3150,7 +3256,7 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n       if (!may_replace_final_value (loop, use, &value))\n \t{\n \t  set_use_iv_cost (data, use, cand, INFTY, NULL);\n-\t  return;\n+\t  return false;\n \t}\n \n       depends_on = NULL;\n@@ -3159,7 +3265,7 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n       cost /= AVG_LOOP_NITER (loop);\n \n       set_use_iv_cost (data, use, cand, cost, depends_on);\n-      return;\n+      return cost != INFTY;\n     }\n \n   exit = single_dom_exit (loop);\n@@ -3179,31 +3285,30 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n     }\n \t\t\t\t   \n   set_use_iv_cost (data, use, cand, cost, depends_on);\n+\n+  return cost != INFTY;\n }\n \n-/* Determines cost of basing replacement of USE on CAND.  */\n+/* Determines cost of basing replacement of USE on CAND.  Returns false\n+   if USE cannot be based on CAND.  */\n \n-static void\n+static bool\n determine_use_iv_cost (struct ivopts_data *data,\n \t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   switch (use->type)\n     {\n     case USE_NONLINEAR_EXPR:\n-      determine_use_iv_cost_generic (data, use, cand);\n-      break;\n+      return determine_use_iv_cost_generic (data, use, cand);\n \n     case USE_OUTER:\n-      determine_use_iv_cost_outer (data, use, cand);\n-      break;\n+      return determine_use_iv_cost_outer (data, use, cand);\n \n     case USE_ADDRESS:\n-      determine_use_iv_cost_address (data, use, cand);\n-      break;\n+      return determine_use_iv_cost_address (data, use, cand);\n \n     case USE_COMPARE:\n-      determine_use_iv_cost_condition (data, use, cand);\n-      break;\n+      return determine_use_iv_cost_condition (data, use, cand);\n \n     default:\n       gcc_unreachable ();\n@@ -3218,28 +3323,10 @@ determine_use_iv_costs (struct ivopts_data *data)\n   unsigned i, j;\n   struct iv_use *use;\n   struct iv_cand *cand;\n-\n-  data->consider_all_candidates = (n_iv_cands (data)\n-\t\t\t\t   <= CONSIDER_ALL_CANDIDATES_BOUND);\n+  bitmap to_clear = BITMAP_XMALLOC ();\n \n   alloc_use_cost_map (data);\n \n-  if (!data->consider_all_candidates)\n-    {\n-      /* Add the important candidate entries.  */\n-      for (j = 0; j < n_iv_cands (data); j++)\n-\t{\n-\t  cand = iv_cand (data, j);\n-\t  if (!cand->important)\n-\t    continue;\n-\t  for (i = 0; i < n_iv_uses (data); i++)\n-\t    {\n-\t      use = iv_use (data, i);\n-\t      determine_use_iv_cost (data, use, cand);\n-\t    }\n-\t}\n-    }\n-\n   for (i = 0; i < n_iv_uses (data); i++)\n     {\n       use = iv_use (data, i);\n@@ -3259,12 +3346,19 @@ determine_use_iv_costs (struct ivopts_data *data)\n \t  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, j, bi)\n \t    {\n \t      cand = iv_cand (data, j);\n-\t      if (!cand->important)\n-\t        determine_use_iv_cost (data, use, cand);\n+\t      if (!determine_use_iv_cost (data, use, cand))\n+\t\tbitmap_set_bit (to_clear, j);\n \t    }\n+\n+\t  /* Remove the candidates for that the cost is infinite from\n+\t     the list of related candidates.  */\n+\t  bitmap_and_compl_into (use->related_cands, to_clear);\n+\t  bitmap_clear (to_clear);\n \t}\n     }\n \n+  BITMAP_XFREE (to_clear);\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Use-candidate costs:\\n\");\n@@ -3451,159 +3545,476 @@ determine_set_costs (struct ivopts_data *data)\n     }\n }\n \n-/* Finds a best candidate for USE and stores it to CAND.  The candidates are\n-   taken from the set SOL and they may depend on invariants in the set INV.\n-   The really used candidate and invariants are noted to USED_IVS and\n-   USED_INV.  */\n+/* Returns true if A is a cheaper cost pair than B.  */\n \n-static unsigned\n-find_best_candidate (struct ivopts_data *data,\n-\t\t     struct iv_use *use, bitmap sol, bitmap inv,\n-\t\t     bitmap used_ivs, bitmap used_inv, struct iv_cand **cand)\n+static bool\n+cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n {\n-  unsigned c, d;\n-  unsigned best_cost = INFTY, cost;\n-  struct iv_cand *cnd = NULL, *acnd;\n-  bitmap depends_on = NULL, asol;\n-  bitmap_iterator bi, bi1;\n+  if (!a)\n+    return false;\n \n-  if (data->consider_all_candidates)\n-    asol = sol;\n-  else\n+  if (!b)\n+    return true;\n+\n+  if (a->cost < b->cost)\n+    return true;\n+\n+  if (a->cost > b->cost)\n+    return false;\n+\n+  /* In case the costs are the same, prefer the cheaper candidate.  */\n+  if (a->cand->cost < b->cand->cost)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Computes the cost field of IVS structure.  */\n+\n+static void\n+iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n+{\n+  unsigned cost = 0;\n+\n+  cost += ivs->cand_use_cost;\n+  cost += ivs->cand_cost;\n+  cost += ivopts_global_cost_for_size (data, ivs->n_regs);\n+\n+  ivs->cost = cost;\n+}\n+\n+/* Set USE not to be expressed by any candidate in IVS.  */\n+\n+static void\n+iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n+\t\t struct iv_use *use)\n+{\n+  unsigned uid = use->id, cid, iid;\n+  bitmap deps;\n+  struct cost_pair *cp;\n+  bitmap_iterator bi;\n+\n+  cp = ivs->cand_for_use[uid];\n+  if (!cp)\n+    return;\n+  cid = cp->cand->id;\n+\n+  ivs->bad_uses++;\n+  ivs->cand_for_use[uid] = NULL;\n+  ivs->n_cand_uses[cid]--;\n+\n+  if (ivs->n_cand_uses[cid] == 0)\n     {\n-      asol = BITMAP_XMALLOC ();\n+      bitmap_clear_bit (ivs->cands, cid);\n+      /* Do not count the pseudocandidates.  */\n+      if (cp->cand->iv)\n+\tivs->n_regs--;\n+      ivs->cand_cost -= cp->cand->cost;\n+    }\n+\n+  ivs->cand_use_cost -= cp->cost;\n+\n+  deps = cp->depends_on;\n \n-      bitmap_ior (asol, data->important_candidates, use->related_cands);\n-      bitmap_and_into (asol, sol);\n+  if (deps)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (deps, 0, iid, bi)\n+\t{\n+\t  ivs->n_invariant_uses[iid]--;\n+\t  if (ivs->n_invariant_uses[iid] == 0)\n+\t    ivs->n_regs--;\n+\t}\n     }\n \n-  EXECUTE_IF_SET_IN_BITMAP (asol, 0, c, bi)\n+  iv_ca_recount_cost (data, ivs);\n+}\n+\n+/* Set cost pair for USE in set IVS to CP.  */\n+\n+static void\n+iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n+\t      struct iv_use *use, struct cost_pair *cp)\n+{\n+  unsigned uid = use->id, cid, iid;\n+  bitmap deps;\n+  bitmap_iterator bi;\n+\n+  if (ivs->cand_for_use[uid] == cp)\n+    return;\n+\n+  if (ivs->cand_for_use[uid])\n+    iv_ca_set_no_cp (data, ivs, use);\n+\n+  if (cp)\n     {\n-      acnd = iv_cand (data, c);\n-      cost = get_use_iv_cost (data, use, acnd, &depends_on);\n+      cid = cp->cand->id;\n \n-      if (cost == INFTY)\n-\tcontinue;\n-      if (cost > best_cost)\n-\tcontinue;\n-      if (cost == best_cost)\n+      ivs->bad_uses--;\n+      ivs->cand_for_use[uid] = cp;\n+      ivs->n_cand_uses[cid]++;\n+      if (ivs->n_cand_uses[cid] == 1)\n \t{\n-\t  /* Prefer the cheaper iv.  */\n-\t  if (acnd->cost >= cnd->cost)\n-\t    continue;\n+\t  bitmap_set_bit (ivs->cands, cid);\n+\t  /* Do not count the pseudocandidates.  */\n+\t  if (cp->cand->iv)\n+\t    ivs->n_regs++;\n+\t  ivs->cand_cost += cp->cand->cost;\n \t}\n \n-      if (depends_on)\n+      ivs->cand_use_cost += cp->cost;\n+\n+      deps = cp->depends_on;\n+\n+      if (deps)\n \t{\n-\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (depends_on, inv, 0, d, bi1)\n+\t  EXECUTE_IF_SET_IN_BITMAP (deps, 0, iid, bi)\n \t    {\n-\t      goto next_cand;\n+\t      ivs->n_invariant_uses[iid]++;\n+\t      if (ivs->n_invariant_uses[iid] == 1)\n+\t\tivs->n_regs++;\n \t    }\n-\t  if (used_inv)\n-\t    bitmap_ior_into (used_inv, depends_on);\n \t}\n \n-      cnd = acnd;\n-      best_cost = cost;\n-\n-next_cand: ;\n+      iv_ca_recount_cost (data, ivs);\n     }\n+}\n+\n+/* Extend set IVS by expressing USE by some of the candidates in it\n+   if possible.  */\n+\n+static void\n+iv_ca_add_use (struct ivopts_data *data, struct iv_ca *ivs,\n+\t       struct iv_use *use)\n+{\n+  struct cost_pair *best_cp = NULL, *cp;\n+  bitmap_iterator bi;\n+  unsigned i;\n \n-  if (cnd && used_ivs)\n-    bitmap_set_bit (used_ivs, cnd->id);\n+  gcc_assert (ivs->upto >= use->id);\n+\n+  if (ivs->upto == use->id)\n+    {\n+      ivs->upto++;\n+      ivs->bad_uses++;\n+    }\n \n-  if (cand)\n-    *cand = cnd;\n+  EXECUTE_IF_SET_IN_BITMAP (ivs->cands, 0, i, bi)\n+    {\n+      cp = get_use_iv_cost (data, use, iv_cand (data, i));\n \n-  if (!data->consider_all_candidates)\n-    BITMAP_XFREE (asol);\n+      if (cheaper_cost_pair (cp, best_cp))\n+\tbest_cp = cp;\n+    }\n \n-  return best_cost;\n+  iv_ca_set_cp (data, ivs, use, best_cp);\n }\n \n-/* Returns cost of set of ivs SOL + invariants INV.  Removes unnecessary\n-   induction variable candidates and invariants from the sets.  Only\n-   uses 0 .. MAX_USE - 1 are taken into account.  */\n+/* Get cost for assignment IVS.  */\n \n static unsigned\n-set_cost_up_to (struct ivopts_data *data, bitmap sol, bitmap inv,\n-\t\tunsigned max_use)\n+iv_ca_cost (struct iv_ca *ivs)\n+{\n+  return (ivs->bad_uses ? INFTY : ivs->cost);\n+}\n+\n+/* Returns true if all dependences of CP are among invariants in IVS.  */\n+\n+static bool\n+iv_ca_has_deps (struct iv_ca *ivs, struct cost_pair *cp)\n {\n   unsigned i;\n-  unsigned cost = 0, size = 0, acost;\n-  struct iv_use *use;\n-  struct iv_cand *cand;\n-  bitmap used_ivs = BITMAP_XMALLOC (), used_inv = BITMAP_XMALLOC ();\n   bitmap_iterator bi;\n \n-  for (i = 0; i < max_use; i++)\n+  if (!cp->depends_on)\n+    return true;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (cp->depends_on, 0, i, bi)\n     {\n-      use = iv_use (data, i);\n-      acost = find_best_candidate (data, use, sol, inv,\n-\t\t\t\t   used_ivs, used_inv, NULL);\n-      if (acost == INFTY)\n+      if (ivs->n_invariant_uses[i] == 0)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Creates change of expressing USE by NEW_CP instead of OLD_CP and chains\n+   it before NEXT_CHANGE.  */\n+\n+static struct iv_ca_delta *\n+iv_ca_delta_add (struct iv_use *use, struct cost_pair *old_cp,\n+\t\t struct cost_pair *new_cp, struct iv_ca_delta *next_change)\n+{\n+  struct iv_ca_delta *change = xmalloc (sizeof (struct iv_ca_delta));\n+\n+  change->use = use;\n+  change->old_cp = old_cp;\n+  change->new_cp = new_cp;\n+  change->next_change = next_change;\n+\n+  return change;\n+}\n+\n+/* Returns candidate by that USE is expressed in IVS.  */\n+\n+static struct cost_pair *\n+iv_ca_cand_for_use (struct iv_ca *ivs, struct iv_use *use)\n+{\n+  return ivs->cand_for_use[use->id];\n+}\n+\n+/* Commit changes in DELTA to IVS.  If FORWARD is false, the changes are\n+   reverted instead.  */\n+\n+static void\n+iv_ca_delta_commit (struct ivopts_data *data, struct iv_ca *ivs,\n+\t\t    struct iv_ca_delta *delta, bool forward)\n+{\n+  struct cost_pair *from, *to;\n+\n+  for (; delta; delta = delta->next_change)\n+    {\n+      if (forward)\n \t{\n-\t  BITMAP_XFREE (used_ivs);\n-\t  BITMAP_XFREE (used_inv);\n-\t  return INFTY;\n+\t  from = delta->old_cp;\n+\t  to = delta->new_cp;\n+\t}\n+      else\n+\t{\n+\t  from = delta->new_cp;\n+\t  to = delta->old_cp;\n \t}\n-      cost += acost;\n+\n+      gcc_assert (iv_ca_cand_for_use (ivs, delta->use) == from);\n+      iv_ca_set_cp (data, ivs, delta->use, to);\n     }\n+}\n \n-  EXECUTE_IF_SET_IN_BITMAP (used_ivs, 0, i, bi)\n-    {\n-      cand = iv_cand (data, i);\n+/* Returns true if CAND is used in IVS.  */\n \n-      /* Do not count the pseudocandidates.  */\n-      if (cand->iv)\n-\tsize++;\n+static bool\n+iv_ca_cand_used_p (struct iv_ca *ivs, struct iv_cand *cand)\n+{\n+  return ivs->n_cand_uses[cand->id] > 0;\n+}\n \n-      cost += cand->cost;\n-    }\n-  EXECUTE_IF_SET_IN_BITMAP (used_inv, 0, i, bi)\n+/* Free the list of changes DELTA.  */\n+\n+static void\n+iv_ca_delta_free (struct iv_ca_delta **delta)\n+{\n+  struct iv_ca_delta *act, *next;\n+\n+  for (act = *delta; act; act = next)\n     {\n-      size++;\n+      next = act->next_change;\n+      free (act);\n     }\n-  cost += ivopts_global_cost_for_size (data, size);\n \n-  bitmap_copy (sol, used_ivs);\n-  bitmap_copy (inv, used_inv);\n+  *delta = NULL;\n+}\n+\n+/* Allocates new iv candidates assignment.  */\n+\n+static struct iv_ca *\n+iv_ca_new (struct ivopts_data *data)\n+{\n+  struct iv_ca *nw = xmalloc (sizeof (struct iv_ca));\n \n-  BITMAP_XFREE (used_ivs);\n-  BITMAP_XFREE (used_inv);\n+  nw->upto = 0;\n+  nw->bad_uses = 0;\n+  nw->cand_for_use = xcalloc (n_iv_uses (data), sizeof (struct cost_pair *));\n+  nw->n_cand_uses = xcalloc (n_iv_cands (data), sizeof (unsigned));\n+  nw->cands = BITMAP_XMALLOC ();\n+  nw->n_regs = 0;\n+  nw->cand_use_cost = 0;\n+  nw->cand_cost = 0;\n+  nw->n_invariant_uses = xcalloc (data->max_inv_id + 1, sizeof (unsigned));\n+  nw->cost = 0;\n+\n+  return nw;\n+}\n+\n+/* Free memory occupied by the set IVS.  */\n+\n+static void\n+iv_ca_free (struct iv_ca **ivs)\n+{\n+  free ((*ivs)->cand_for_use);\n+  free ((*ivs)->n_cand_uses);\n+  BITMAP_XFREE ((*ivs)->cands);\n+  free ((*ivs)->n_invariant_uses);\n+  free (*ivs);\n+  *ivs = NULL;\n+}\n+\n+/* Dumps IVS to FILE.  */\n+\n+static void\n+iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n+{\n+  const char *pref = \"  invariants \";\n+  unsigned i;\n+\n+  fprintf (file, \"  cost %d\\n\", iv_ca_cost (ivs));\n+  bitmap_print (file, ivs->cands, \"  candidates \",\"\\n\");\n+\n+  for (i = 1; i <= data->max_inv_id; i++)\n+    if (ivs->n_invariant_uses[i])\n+      {\n+\tfprintf (file, \"%s%d\", pref, i);\n+\tpref = \", \";\n+      }\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Try changing candidate in IVS to CAND for each use.  Return cost of the\n+   new set, and store differences in DELTA.  */\n+\n+static unsigned\n+iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n+\t      struct iv_cand *cand, struct iv_ca_delta **delta)\n+{\n+  unsigned i, cost;\n+  struct iv_use *use;\n+  struct cost_pair *old_cp, *new_cp;\n+\n+  *delta = NULL;\n+  for (i = 0; i < ivs->upto; i++)\n+    {\n+      use = iv_use (data, i);\n+      old_cp = iv_ca_cand_for_use (ivs, use);\n+\n+      if (old_cp\n+\t  && old_cp->cand == cand)\n+\tcontinue;\n+\n+      new_cp = get_use_iv_cost (data, use, cand);\n+      if (!new_cp)\n+\tcontinue;\n+\n+      if (!iv_ca_has_deps (ivs, new_cp))\n+\tcontinue;\n+      \n+      if (!cheaper_cost_pair (new_cp, old_cp))\n+\tcontinue;\n+\n+      *delta = iv_ca_delta_add (use, old_cp, new_cp, *delta);\n+    }\n+\n+  iv_ca_delta_commit (data, ivs, *delta, true);\n+  cost = iv_ca_cost (ivs);\n+  iv_ca_delta_commit (data, ivs, *delta, false);\n \n   return cost;\n }\n \n-/* Computes cost of set of ivs SOL + invariants INV.  Removes unnecessary\n-   induction variable candidates and invariants from the sets.  */\n+/* Try narowing set IVS by removing CAND.  Return the cost of\n+   the new set and store the differences in DELTA.  */\n \n static unsigned\n-set_cost (struct ivopts_data *data, bitmap sol, bitmap inv)\n+iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n+\t      struct iv_cand *cand, struct iv_ca_delta **delta)\n {\n-  return set_cost_up_to (data, sol, inv, n_iv_uses (data));\n+  unsigned i, ci;\n+  struct iv_use *use;\n+  struct cost_pair *old_cp, *new_cp, *cp;\n+  bitmap_iterator bi;\n+  struct iv_cand *cnd;\n+  unsigned cost;\n+\n+  *delta = NULL;\n+  for (i = 0; i < n_iv_uses (data); i++)\n+    {\n+      use = iv_use (data, i);\n+\n+      old_cp = iv_ca_cand_for_use (ivs, use);\n+      if (old_cp->cand != cand)\n+\tcontinue;\n+\n+      new_cp = NULL;\n+\n+      if (data->consider_all_candidates)\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (ivs->cands, 0, ci, bi)\n+\t    {\n+\t      if (ci == cand->id)\n+\t\tcontinue;\n+\n+\t      cnd = iv_cand (data, ci);\n+\n+\t      cp = get_use_iv_cost (data, use, cnd);\n+\t      if (!cp)\n+\t\tcontinue;\n+\t      if (!iv_ca_has_deps (ivs, cp))\n+\t\tcontinue;\n+      \n+\t      if (!cheaper_cost_pair (cp, new_cp))\n+\t\tcontinue;\n+\n+\t      new_cp = cp;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  EXECUTE_IF_AND_IN_BITMAP (use->related_cands, ivs->cands, 0, ci, bi)\n+\t    {\n+\t      if (ci == cand->id)\n+\t\tcontinue;\n+\n+\t      cnd = iv_cand (data, ci);\n+\n+\t      cp = get_use_iv_cost (data, use, cnd);\n+\t      if (!cp)\n+\t\tcontinue;\n+\t      if (!iv_ca_has_deps (ivs, cp))\n+\t\tcontinue;\n+      \n+\t      if (!cheaper_cost_pair (cp, new_cp))\n+\t\tcontinue;\n+\n+\t      new_cp = cp;\n+\t    }\n+\t}\n+\n+      if (!new_cp)\n+\t{\n+\t  iv_ca_delta_free (delta);\n+\t  return INFTY;\n+\t}\n+\n+      *delta = iv_ca_delta_add (use, old_cp, new_cp, *delta);\n+    }\n+\n+  iv_ca_delta_commit (data, ivs, *delta, true);\n+  cost = iv_ca_cost (ivs);\n+  iv_ca_delta_commit (data, ivs, *delta, false);\n+\n+  return cost;\n }\n \n-/* Tries to extend the sets IVS and INV in the best possible way in order\n+/* Tries to extend the sets IVS in the best possible way in order\n    to express the USE.  */\n \n static bool\n-try_add_cand_for (struct ivopts_data *data, bitmap ivs, bitmap inv,\n+try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \t\t  struct iv_use *use)\n {\n-  unsigned best_cost = set_cost_up_to (data, ivs, inv, use->id + 1), act_cost;\n-  bitmap best_ivs = BITMAP_XMALLOC ();\n-  bitmap best_inv = BITMAP_XMALLOC ();\n-  bitmap act_ivs = BITMAP_XMALLOC ();\n-  bitmap act_inv = BITMAP_XMALLOC ();\n+  unsigned best_cost, act_cost;\n   unsigned i;\n-  struct cost_pair *cp;\n   bitmap_iterator bi;\n   struct iv_cand *cand;\n-  bitmap depends_on;\n+  struct iv_ca_delta *best_delta = NULL, *act_delta;\n+  struct cost_pair *cp;\n+\n+  iv_ca_add_use (data, ivs, use);\n+  best_cost = iv_ca_cost (ivs);\n \n-  bitmap_copy (best_ivs, ivs);\n-  bitmap_copy (best_inv, inv);\n+  cp = iv_ca_cand_for_use (ivs, use);\n+  if (cp)\n+    {\n+      best_delta = iv_ca_delta_add (use, NULL, cp, NULL);\n+      iv_ca_set_no_cp (data, ivs, use);\n+    }\n \n   /* First try important candidates.  Only if it fails, try the specific ones.\n      Rationale -- in loops with many variables the best choice often is to use\n@@ -3617,224 +4028,171 @@ try_add_cand_for (struct ivopts_data *data, bitmap ivs, bitmap inv,\n     {\n       cand = iv_cand (data, i);\n \n-      if (get_use_iv_cost (data, use, cand, &depends_on) == INFTY)\n+      if (iv_ca_cand_used_p (ivs, cand))\n \tcontinue;\n \n-      bitmap_copy (act_ivs, ivs);\n-      bitmap_set_bit (act_ivs, cand->id);\n-      if (depends_on)\n-\tbitmap_ior (act_inv, inv, depends_on);\n-      else\n-\tbitmap_copy (act_inv, inv);\n-      act_cost = set_cost_up_to (data, act_ivs, act_inv, use->id + 1);\n+      cp = get_use_iv_cost (data, use, cand);\n+      if (!cp)\n+\tcontinue;\n+\n+      iv_ca_set_cp (data, ivs, use, cp);\n+      act_cost = iv_ca_extend (data, ivs, cand, &act_delta);\n+      iv_ca_set_no_cp (data, ivs, use);\n+      act_delta = iv_ca_delta_add (use, NULL, cp, act_delta);\n \n       if (act_cost < best_cost)\n \t{\n \t  best_cost = act_cost;\n-\t  bitmap_copy (best_ivs, act_ivs);\n-\t  bitmap_copy (best_inv, act_inv);\n+\n+\t  iv_ca_delta_free (&best_delta);\n+\t  best_delta = act_delta;\n \t}\n+      else\n+\tiv_ca_delta_free (&act_delta);\n     }\n \n   if (best_cost == INFTY)\n     {\n       for (i = 0; i < use->n_map_members; i++)\n \t{\n \t  cp = use->cost_map + i;\n-\t  if (cp->cost == INFTY)\n+\t  cand = cp->cand;\n+\t  if (!cand)\n \t    continue;\n \n \t  /* Already tried this.  */\n-\t  if (cp->cand->important)\n+\t  if (cand->important)\n+\t    continue;\n+      \n+\t  if (iv_ca_cand_used_p (ivs, cand))\n \t    continue;\n \n-\t  bitmap_copy (act_ivs, ivs);\n-\t  bitmap_set_bit (act_ivs, cp->cand->id);\n-\t  if (cp->depends_on)\n-\t    bitmap_ior (act_inv, inv, cp->depends_on);\n-\t  else\n-\t    bitmap_copy (act_inv, inv);\n-\t  act_cost = set_cost_up_to (data, act_ivs, act_inv, use->id + 1);\n+\t  act_delta = NULL;\n+\t  iv_ca_set_cp (data, ivs, use, cp);\n+\t  act_cost = iv_ca_extend (data, ivs, cand, &act_delta);\n+\t  iv_ca_set_no_cp (data, ivs, use);\n+\t  act_delta = iv_ca_delta_add (use, iv_ca_cand_for_use (ivs, use),\n+\t\t\t\t       cp, act_delta);\n \n \t  if (act_cost < best_cost)\n \t    {\n \t      best_cost = act_cost;\n-\t      bitmap_copy (best_ivs, act_ivs);\n-\t      bitmap_copy (best_inv, act_inv);\n+\n+\t      if (best_delta)\n+\t\tiv_ca_delta_free (&best_delta);\n+\t      best_delta = act_delta;\n \t    }\n+\t  else\n+\t    iv_ca_delta_free (&act_delta);\n \t}\n     }\n \n-  bitmap_copy (ivs, best_ivs);\n-  bitmap_copy (inv, best_inv);\n-\n-  BITMAP_XFREE (best_ivs);\n-  BITMAP_XFREE (best_inv);\n-  BITMAP_XFREE (act_ivs);\n-  BITMAP_XFREE (act_inv);\n+  iv_ca_delta_commit (data, ivs, best_delta, true);\n+  iv_ca_delta_free (&best_delta);\n \n   return (best_cost != INFTY);\n }\n \n-/* Finds an initial set of IVS and invariants INV.  We do this by simply\n-   choosing the best candidate for each use.  */\n+/* Finds an initial assignment of candidates to uses.  */\n \n-static unsigned\n-get_initial_solution (struct ivopts_data *data, bitmap ivs, bitmap inv)\n+static struct iv_ca *\n+get_initial_solution (struct ivopts_data *data)\n {\n+  struct iv_ca *ivs = iv_ca_new (data);\n   unsigned i;\n \n   for (i = 0; i < n_iv_uses (data); i++)\n-    if (!try_add_cand_for (data, ivs, inv, iv_use (data, i)))\n-      return INFTY;\n+    if (!try_add_cand_for (data, ivs, iv_use (data, i)))\n+      {\n+\tiv_ca_free (&ivs);\n+\treturn NULL;\n+      }\n \n-  return set_cost (data, ivs, inv);\n+  return ivs;\n }\n \n-/* Tries to improve set of induction variables IVS and invariants INV to get\n-   it better than COST.  */\n+/* Tries to improve set of induction variables IVS.  */\n \n static bool\n-try_improve_iv_set (struct ivopts_data *data,\n-\t\t    bitmap ivs, bitmap inv, unsigned *cost)\n+try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n {\n-  unsigned i, acost;\n-  bitmap new_ivs = BITMAP_XMALLOC (), new_inv = BITMAP_XMALLOC ();\n-  bitmap best_new_ivs = NULL, best_new_inv = NULL;\n+  unsigned i, acost, best_cost = iv_ca_cost (ivs);\n+  struct iv_ca_delta *best_delta = NULL, *act_delta;\n+  struct iv_cand *cand;\n \n   /* Try altering the set of induction variables by one.  */\n   for (i = 0; i < n_iv_cands (data); i++)\n     {\n-      bitmap_copy (new_ivs, ivs);\n-      bitmap_copy (new_inv, inv);\n-\n-      if (bitmap_bit_p (ivs, i))\n-\tbitmap_clear_bit (new_ivs, i);\n+      cand = iv_cand (data, i);\n+      \n+      if (iv_ca_cand_used_p (ivs, cand))\n+\tacost = iv_ca_narrow (data, ivs, cand, &act_delta);\n       else\n-\tbitmap_set_bit (new_ivs, i);\n-\n-      acost = set_cost (data, new_ivs, new_inv);\n-      if (acost >= *cost)\n-\tcontinue;\n+\tacost = iv_ca_extend (data, ivs, cand, &act_delta);\n \n-      if (!best_new_ivs)\n+      if (acost < best_cost)\n \t{\n-\t  best_new_ivs = BITMAP_XMALLOC ();\n-\t  best_new_inv = BITMAP_XMALLOC ();\n+\t  best_cost = acost;\n+\t  if (best_delta)\n+\t    iv_ca_delta_free (&best_delta);\n+\t  best_delta = act_delta;\n \t}\n-\n-      *cost = acost;\n-      bitmap_copy (best_new_ivs, new_ivs);\n-      bitmap_copy (best_new_inv, new_inv);\n-    }\n-\n-  /* Ditto for invariants.  */\n-  for (i = 1; i <= data->max_inv_id; i++)\n-    {\n-      if (ver_info (data, i)->has_nonlin_use)\n-\tcontinue;\n-\n-      bitmap_copy (new_ivs, ivs);\n-      bitmap_copy (new_inv, inv);\n-\n-      if (bitmap_bit_p (inv, i))\n-\tbitmap_clear_bit (new_inv, i);\n       else\n-\tbitmap_set_bit (new_inv, i);\n-\n-      acost = set_cost (data, new_ivs, new_inv);\n-      if (acost >= *cost)\n-\tcontinue;\n-\n-      if (!best_new_ivs)\n-\t{\n-\t  best_new_ivs = BITMAP_XMALLOC ();\n-\t  best_new_inv = BITMAP_XMALLOC ();\n-\t}\n-\n-      *cost = acost;\n-      bitmap_copy (best_new_ivs, new_ivs);\n-      bitmap_copy (best_new_inv, new_inv);\n+\tiv_ca_delta_free (&act_delta);\n     }\n \n-  BITMAP_XFREE (new_ivs);\n-  BITMAP_XFREE (new_inv);\n-\n-  if (!best_new_ivs)\n+  if (!best_delta)\n     return false;\n \n-  bitmap_copy (ivs, best_new_ivs);\n-  bitmap_copy (inv, best_new_inv);\n-  BITMAP_XFREE (best_new_ivs);\n-  BITMAP_XFREE (best_new_inv);\n+  iv_ca_delta_commit (data, ivs, best_delta, true);\n+  iv_ca_delta_free (&best_delta);\n   return true;\n }\n \n /* Attempts to find the optimal set of induction variables.  We do simple\n    greedy heuristic -- we try to replace at most one candidate in the selected\n    solution and remove the unused ivs while this improves the cost.  */\n \n-static bitmap\n+static struct iv_ca *\n find_optimal_iv_set (struct ivopts_data *data)\n {\n-  unsigned cost, i;\n-  bitmap set = BITMAP_XMALLOC ();\n-  bitmap inv = BITMAP_XMALLOC ();\n+  unsigned i;\n+  struct iv_ca *set;\n   struct iv_use *use;\n \n-  data->important_candidates = BITMAP_XMALLOC ();\n-  for (i = 0; i < n_iv_cands (data); i++)\n-    {\n-      struct iv_cand *cand = iv_cand (data, i);\n-\n-      if (cand->important)\n-\tbitmap_set_bit (data->important_candidates, i);\n-    }\n-\n-  /* Set the upper bound.  */\n-  cost = get_initial_solution (data, set, inv);\n-  if (cost == INFTY)\n+  /* Get the initial solution.  */\n+  set = get_initial_solution (data);\n+  if (!set)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Unable to substitute for ivs, failed.\\n\");\n-      BITMAP_XFREE (inv);\n-      BITMAP_XFREE (set);\n       return NULL;\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"Initial set of candidates (cost %d): \", cost);\n-      bitmap_print (dump_file, set, \"\", \"\");\n-      fprintf (dump_file, \" invariants \");\n-      bitmap_print (dump_file, inv, \"\", \"\");\n-      fprintf (dump_file, \"\\n\");\n+      fprintf (dump_file, \"Initial set of candidates:\\n\");\n+      iv_ca_dump (data, dump_file, set);\n     }\n \n-  while (try_improve_iv_set (data, set, inv, &cost))\n+  while (try_improve_iv_set (data, set))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  fprintf (dump_file, \"Improved to (cost %d): \", cost);\n-\t  bitmap_print (dump_file, set, \"\", \"\");\n-\t  fprintf (dump_file, \" invariants \");\n-\t  bitmap_print (dump_file, inv, \"\", \"\");\n-\t  fprintf (dump_file, \"\\n\");\n+\t  fprintf (dump_file, \"Improved to:\\n\");\n+\t  iv_ca_dump (data, dump_file, set);\n \t}\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Final cost %d\\n\\n\", cost);\n+    fprintf (dump_file, \"Final cost %d\\n\\n\", iv_ca_cost (set));\n \n   for (i = 0; i < n_iv_uses (data); i++)\n     {\n       use = iv_use (data, i);\n-      find_best_candidate (data, use, set, inv, NULL, NULL, &use->selected);\n+      use->selected = iv_ca_cand_for_use (set, use)->cand;\n     }\n \n-  BITMAP_XFREE (inv);\n-  BITMAP_XFREE (data->important_candidates);\n-\n   return set;\n }\n \n@@ -3884,13 +4242,13 @@ create_new_iv (struct ivopts_data *data, struct iv_cand *cand)\n /* Creates new induction variables described in SET.  */\n \n static void\n-create_new_ivs (struct ivopts_data *data, bitmap set)\n+create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n {\n   unsigned i;\n   struct iv_cand *cand;\n   bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (set->cands, 0, i, bi)\n     {\n       cand = iv_cand (data, i);\n       create_new_iv (data, cand);\n@@ -4422,6 +4780,7 @@ free_loop_data (struct ivopts_data *data)\n       info->inv_id = 0;\n     }\n   bitmap_clear (data->relevant);\n+  bitmap_clear (data->important_candidates);\n \n   for (i = 0; i < n_iv_uses (data); i++)\n     {\n@@ -4484,6 +4843,7 @@ tree_ssa_iv_optimize_finalize (struct loops *loops, struct ivopts_data *data)\n   free_loop_data (data);\n   free (data->version_info);\n   BITMAP_XFREE (data->relevant);\n+  BITMAP_XFREE (data->important_candidates);\n \n   VARRAY_FREE (decl_rtl_to_reset);\n   VARRAY_FREE (data->iv_uses);\n@@ -4496,7 +4856,7 @@ static bool\n tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n {\n   bool changed = false;\n-  bitmap iv_set;\n+  struct iv_ca *iv_ca;\n   edge exit;\n \n   data->current_loop = loop;\n@@ -4536,13 +4896,14 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   determine_set_costs (data);\n \n   /* Find the optimal set of induction variables (item 3, part 2).  */\n-  iv_set = find_optimal_iv_set (data);\n-  if (!iv_set)\n+  iv_ca = find_optimal_iv_set (data);\n+  if (!iv_ca)\n     goto finish;\n   changed = true;\n \n   /* Create the new induction variables (item 4, part 1).  */\n-  create_new_ivs (data, iv_set);\n+  create_new_ivs (data, iv_ca);\n+  iv_ca_free (&iv_ca);\n   \n   /* Rewrite the uses (item 4, part 2).  */\n   rewrite_uses (data);\n@@ -4552,8 +4913,6 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n \n   loop_commit_inserts ();\n \n-  BITMAP_XFREE (iv_set);\n-\n   /* We have changed the structure of induction variables; it might happen\n      that definitions in the scev database refer to some of them that were\n      eliminated.  */"}]}