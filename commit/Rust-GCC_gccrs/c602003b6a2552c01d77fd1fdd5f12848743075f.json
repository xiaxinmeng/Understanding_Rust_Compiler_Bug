{"sha": "c602003b6a2552c01d77fd1fdd5f12848743075f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYwMjAwM2I2YTI1NTJjMDFkNzdmZDFmZGQ1ZjEyODQ4NzQzMDc1Zg==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2020-04-10T22:23:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-17T08:14:11Z"}, "message": "[Ada] Ada2020: AI12-0110 Tampering checks are performed first\n\n2020-06-17  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-cbdlli.adb, libgnat/a-cbhama.adb,\n\tlibgnat/a-cbhase.adb, libgnat/a-cbmutr.adb,\n\tlibgnat/a-cborma.adb, libgnat/a-cborse.adb,\n\tlibgnat/a-cdlili.adb, libgnat/a-chtgbk.adb,\n\tlibgnat/a-chtgke.adb, libgnat/a-cidlli.adb,\n\tlibgnat/a-cihama.adb, libgnat/a-cihase.adb,\n\tlibgnat/a-cimutr.adb, libgnat/a-ciorma.adb,\n\tlibgnat/a-ciorse.adb, libgnat/a-cobove.adb,\n\tlibgnat/a-cohama.adb, libgnat/a-cohase.adb,\n\tlibgnat/a-coinve.adb, libgnat/a-comutr.adb,\n\tlibgnat/a-convec.adb, libgnat/a-coorma.adb,\n\tlibgnat/a-coorse.adb, libgnat/a-crbtgk.adb,\n\tlibgnat/a-crbtgo.adb, libgnat/a-rbtgso.adb: Move tampering\n\tchecks earlier.", "tree": {"sha": "1e7cd76cceb0fb154536471344970a65f91fa59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e7cd76cceb0fb154536471344970a65f91fa59c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c602003b6a2552c01d77fd1fdd5f12848743075f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c602003b6a2552c01d77fd1fdd5f12848743075f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c602003b6a2552c01d77fd1fdd5f12848743075f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c602003b6a2552c01d77fd1fdd5f12848743075f/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ea4df3af88f33686813b7db70fbe3e37b7dfecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea4df3af88f33686813b7db70fbe3e37b7dfecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ea4df3af88f33686813b7db70fbe3e37b7dfecc"}], "stats": {"total": 648, "additions": 313, "deletions": 335}, "files": [{"sha": "1b3a88cd60e1b3f129c7f7345f296f2a84fceaed", "filename": "gcc/ada/libgnat/a-cbdlli.adb", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -358,6 +358,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       X : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n@@ -386,8 +388,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       for Index in 1 .. Count loop\n          pragma Assert (Container.Length >= 2);\n \n@@ -427,6 +427,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       X : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Count >= Container.Length then\n          Clear (Container);\n          return;\n@@ -436,8 +438,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       for J in 1 .. Count loop\n          X := Container.First;\n          pragma Assert (N (N (X).Next).Prev = Container.First);\n@@ -463,6 +463,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       X : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Count >= Container.Length then\n          Clear (Container);\n          return;\n@@ -472,8 +474,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       for J in 1 .. Count loop\n          X := Container.Last;\n          pragma Assert (N (N (X).Prev).Next = Container.Last);\n@@ -759,6 +759,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          Source : in out List)\n       is\n       begin\n+         TC_Check (Target.TC);\n+         TC_Check (Source.TC);\n+\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -786,9 +789,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             raise Capacity_Error with \"new length exceeds target capacity\";\n          end if;\n \n-         TC_Check (Target.TC);\n-         TC_Check (Source.TC);\n-\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n@@ -964,6 +964,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       New_Node   : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Container'Unrestricted_Access\n          then\n@@ -983,8 +985,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          raise Capacity_Error with \"capacity exceeded\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       Allocate (Container, New_Item, New_Node);\n       First_Node := New_Node;\n       Insert_Internal (Container, Before.Node, New_Node);\n@@ -1261,6 +1261,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       X : Count_Type;\n \n    begin\n+      TC_Check (Source.TC);\n+\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -1269,8 +1271,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          raise Capacity_Error with \"Source length exceeds Target capacity\";\n       end if;\n \n-      TC_Check (Source.TC);\n-\n       --  Clear target, note that this checks busy bits of Target\n \n       Clear (Target);\n@@ -1579,6 +1579,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -1588,8 +1590,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       Container.Nodes (Position.Node).Element := New_Item;\n@@ -1751,6 +1751,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n@@ -1772,9 +1775,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          raise Capacity_Error with \"new length exceeds target capacity\";\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n@@ -1786,6 +1786,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       N : Node_Array renames Container.Nodes;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n@@ -1815,8 +1817,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n       pragma Assert (Container.Length >= 2);\n \n-      TC_Check (Container.TC);\n-\n       if Before.Node = 0 then\n          pragma Assert (Position.Node /= Container.Last);\n \n@@ -1894,6 +1894,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n@@ -1918,9 +1921,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          raise Capacity_Error with \"Target is full\";\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       Splice_Internal\n         (Target  => Target,\n          Before  => Before.Node,\n@@ -2063,6 +2063,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -2083,8 +2085,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap\");\n \n@@ -2109,6 +2109,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -2129,8 +2131,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n "}, {"sha": "b76bd623cd78234ef8472f6da63a2884fea53165", "filename": "gcc/ada/libgnat/a-cbhama.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbhama.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -311,6 +311,8 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n@@ -322,8 +324,6 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n@@ -1029,13 +1029,13 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          N : Node_Type renames Container.Nodes (Node);\n       begin\n@@ -1054,6 +1054,8 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Position.Container.TC);\n+\n       if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n@@ -1065,8 +1067,6 @@ package body Ada.Containers.Bounded_Hashed_Maps is\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      TE_Check (Position.Container.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       Container.Nodes (Position.Node).Element := New_Item;"}, {"sha": "8a786f1f68e260f743e0208bc53b4f3861f069e7", "filename": "gcc/ada/libgnat/a-cbhase.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbhase.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -309,6 +309,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n@@ -318,8 +320,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n@@ -1179,13 +1179,13 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n \n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       Container.Nodes (Node).Element := New_Item;\n    end Replace;\n "}, {"sha": "f9048b09c2f319f866a8d721b82bab409f4aefc0", "filename": "gcc/ada/libgnat/a-cbmutr.adb", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbmutr.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -366,6 +366,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       First, Last : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -383,8 +385,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Container.Count = 0 then\n          Initialize_Root (Container);\n       end if;\n@@ -985,6 +985,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -993,8 +995,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Container.Count = 0 then\n          pragma Assert (Is_Root (Parent));\n          return;\n@@ -1024,6 +1024,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       X : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -1041,8 +1043,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise Constraint_Error with \"Position cursor does not designate leaf\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       X := Position.Node;\n       Position := No_Element;\n \n@@ -1064,6 +1064,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -1077,8 +1079,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       X := Position.Node;\n       Position := No_Element;\n \n@@ -1506,6 +1506,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Last  : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -1537,8 +1539,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Container.Count = 0 then\n          Initialize_Root (Container);\n       end if;\n@@ -1584,6 +1584,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  OK to reference, see below\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -1615,8 +1617,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Container.Count = 0 then\n          Initialize_Root (Container);\n       end if;\n@@ -2181,6 +2181,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       First, Last : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -2198,8 +2200,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n            with \"requested count exceeds available storage\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Container.Count = 0 then\n          Initialize_Root (Container);\n       end if;\n@@ -2545,6 +2545,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -2558,8 +2560,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       Container.Elements (Position.Node) := New_Item;\n    end Replace_Element;\n \n@@ -2627,6 +2627,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Source_Parent : Cursor)\n    is\n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n@@ -2671,8 +2674,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n             return;\n          end if;\n \n-         TC_Check (Target.TC);\n-\n          if Checks and then Is_Reachable (Container => Target,\n                           From      => Target_Parent.Node,\n                           To        => Source_Parent.Node)\n@@ -2690,9 +2691,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       if Target.Count = 0 then\n          Initialize_Root (Target);\n       end if;\n@@ -2712,6 +2710,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Source_Parent   : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n@@ -2755,8 +2755,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n       pragma Assert (Container.Count > 0);\n \n-      TC_Check (Container.TC);\n-\n       if Checks and then Is_Reachable (Container => Container,\n                        From      => Target_Parent.Node,\n                        To        => Source_Parent.Node)\n@@ -2911,6 +2909,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Position : in out Cursor)\n    is\n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -2957,8 +2958,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n             end if;\n          end if;\n \n-         TC_Check (Target.TC);\n-\n          if Checks and then Is_Reachable (Container => Target,\n                           From      => Parent.Node,\n                           To        => Position.Node)\n@@ -2974,9 +2973,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       if Target.Count = 0 then\n          Initialize_Root (Target);\n       end if;\n@@ -2998,6 +2994,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Position  : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -3048,8 +3046,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          end if;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Checks and then Is_Reachable (Container => Container,\n                        From      => Parent.Node,\n                        To        => Position.Node)\n@@ -3176,6 +3172,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       I, J      : Cursor)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then I = No_Element then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -3204,8 +3202,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise Program_Error with \"J cursor designates root\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          EE : Element_Array renames Container.Elements;\n          EI : constant Element_Type := EE (I.Node);"}, {"sha": "1e384d777e066ff0e9c1d8e56e6276b749f95df5", "filename": "gcc/ada/libgnat/a-cborma.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cborma.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -1418,12 +1418,12 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       Node : constant Count_Type := Key_Ops.Find (Container, Key);\n \n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Node = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          N : Node_Type renames Container.Nodes (Node);\n \n@@ -1443,6 +1443,8 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n@@ -1454,8 +1456,6 @@ package body Ada.Containers.Bounded_Ordered_Maps is\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       pragma Assert (Vet (Container, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n "}, {"sha": "af5efc1f5ca705d03a1a7d077f9566754a63e75f", "filename": "gcc/ada/libgnat/a-cborse.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cborse.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -461,6 +461,8 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n@@ -470,8 +472,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Delete\");\n \n@@ -1682,13 +1682,13 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n \n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       Container.Nodes (Node).Element := New_Item;\n    end Replace;\n "}, {"sha": "73c7980a157a9ffe7cde9a04cc68eb45dd9aa5ea", "filename": "gcc/ada/libgnat/a-cdlili.adb", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -295,6 +295,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n@@ -319,8 +321,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       for Index in 1 .. Count loop\n          X := Position.Node;\n          Container.Length := Container.Length - 1;\n@@ -604,6 +604,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          Source : in out List)\n       is\n       begin\n+         TC_Check (Target.TC);\n+         TC_Check (Source.TC);\n+\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -626,9 +629,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             raise Constraint_Error with \"new length exceeds maximum\";\n          end if;\n \n-         TC_Check (Target.TC);\n-         TC_Check (Source.TC);\n-\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n@@ -796,6 +796,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node   : Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Container'Unrestricted_Access\n          then\n@@ -815,8 +817,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       New_Node   := new Node_Type'(New_Item, null, null);\n       First_Node := New_Node;\n       Insert_Internal (Container, Before.Node, New_Node);\n@@ -851,6 +851,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node   : Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Container'Unrestricted_Access\n          then\n@@ -870,8 +872,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       New_Node   := new Node_Type;\n       First_Node := New_Node;\n       Insert_Internal (Container, Before.Node, New_Node);\n@@ -1372,6 +1372,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -1381,8 +1383,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       Position.Node.Element := New_Item;\n@@ -1543,6 +1543,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n@@ -1560,9 +1563,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n@@ -1572,6 +1572,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position  : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n@@ -1601,8 +1603,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       pragma Assert (Container.Length >= 2);\n \n-      TC_Check (Container.TC);\n-\n       if Before.Node = null then\n          pragma Assert (Position.Node /= Container.Last);\n \n@@ -1678,6 +1678,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n@@ -1702,9 +1705,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Constraint_Error with \"Target is full\";\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       Splice_Internal (Target, Before.Node, Source, Position.Node);\n       Position.Container := Target'Unchecked_Access;\n    end Splice;\n@@ -1862,6 +1862,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -1882,8 +1884,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap\");\n \n@@ -1908,6 +1908,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -1928,8 +1930,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n "}, {"sha": "89358e4f46acd5f177dd89116e9543afcc0294f7", "filename": "gcc/ada/libgnat/a-chtgbk.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-chtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-chtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgbk.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -228,6 +228,8 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       N, M       : Count_Type;\n \n    begin\n+      TC_Check (HT.TC);\n+\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n@@ -250,8 +252,6 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n       --  hash table as this one, a key is mapped to exactly one node.)\n \n       if Checked_Equivalent_Keys (HT, Key, Node) then\n-         TE_Check (HT.TC);\n-\n          --  The new Key value is mapped to this same Node, so Node\n          --  stays in the same bucket.\n \n@@ -292,10 +292,7 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n          return;\n       end if;\n \n-      --  The node is a bucket different from the bucket implied by Key\n-\n-      TC_Check (HT.TC);\n-\n+      --  The node is in a bucket different from the bucket implied by Key.\n       --  Do the assignment first, before moving the node, so that if Assign\n       --  propagates an exception, then the hash table will not have been\n       --  modified (except for any possible side-effect Assign had on Node)."}, {"sha": "fdd62b743b00ddb652211999a900cfac0861f940", "filename": "gcc/ada/libgnat/a-chtgke.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-chtgke.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-chtgke.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgke.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -91,7 +91,6 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n       end if;\n \n       if Checked_Equivalent_Keys (HT, Key, X) then\n-         TC_Check (HT.TC);\n          HT.Buckets (Indx) := Next (X);\n          HT.Length := HT.Length - 1;\n          return;\n@@ -106,7 +105,6 @@ package body Ada.Containers.Hash_Tables.Generic_Keys is\n          end if;\n \n          if Checked_Equivalent_Keys (HT, Key, X) then\n-            TC_Check (HT.TC);\n             Set_Next (Node => Prev, Next => Next (X));\n             HT.Length := HT.Length - 1;\n             return;"}, {"sha": "a086935dd3a6d3b9262e21115ee492b80b234be5", "filename": "gcc/ada/libgnat/a-cidlli.adb", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -320,6 +320,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n@@ -349,8 +351,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       for Index in 1 .. Count loop\n          X := Position.Node;\n          Container.Length := Container.Length - 1;\n@@ -667,6 +667,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n             return;\n          end if;\n \n+         TC_Check (Target.TC);\n+         TC_Check (Source.TC);\n+\n          if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n@@ -677,9 +680,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n             raise Constraint_Error with \"new length exceeds maximum\";\n          end if;\n \n-         TC_Check (Target.TC);\n-         TC_Check (Source.TC);\n-\n          declare\n             Lock_Target : With_Lock (Target.TC'Unchecked_Access);\n             Lock_Source : With_Lock (Source.TC'Unchecked_Access);\n@@ -847,6 +847,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       New_Node   : Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Container'Unrestricted_Access\n          then\n@@ -873,8 +875,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       declare\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n@@ -1420,6 +1420,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -1429,8 +1431,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n            \"Position cursor designates wrong container\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       if Checks and then Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n@@ -1612,6 +1612,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n@@ -1636,9 +1639,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n@@ -1648,6 +1648,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position  : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n@@ -1688,8 +1690,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       pragma Assert (Container.Length >= 2);\n \n-      TC_Check (Container.TC);\n-\n       if Before.Node = null then\n          pragma Assert (Position.Node /= Container.Last);\n \n@@ -1765,6 +1765,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Before.Container /= null then\n          if Checks and then Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n@@ -1801,9 +1804,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          raise Constraint_Error with \"Target is full\";\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       Splice_Internal (Target, Before.Node, Source, Position.Node);\n       Position.Container := Target'Unchecked_Access;\n    end Splice;\n@@ -1960,6 +1960,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -1980,8 +1982,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       pragma Assert (Vet (I), \"bad I cursor in Swap\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap\");\n \n@@ -2003,6 +2003,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then I.Node = null then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -2023,8 +2025,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n       pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n "}, {"sha": "7c4d427ca2475fa86b5db63d9f4e032a3fc4cbcc", "filename": "gcc/ada/libgnat/a-cihama.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cihama.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -327,6 +327,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n+      TC_Check (Container.HT.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n@@ -338,8 +340,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n \n-      TC_Check (Container.HT.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n@@ -1106,13 +1106,13 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       E : Element_Access;\n \n    begin\n+      TE_Check (Container.HT.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n       end if;\n \n-      TE_Check (Container.HT.TC);\n-\n       K := Node.Key;\n       E := Node.Element;\n \n@@ -1148,6 +1148,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Position.Container.HT.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n@@ -1166,8 +1168,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      TE_Check (Position.Container.HT.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       declare"}, {"sha": "3d5af6a1769016ae1f77c59506b651722c17f517", "filename": "gcc/ada/libgnat/a-cihase.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cihase.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -320,6 +320,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n+      TC_Check (Container.HT.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n@@ -333,8 +335,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      TC_Check (Container.HT.TC);\n-\n       pragma Assert (Vet (Position), \"Position cursor is bad\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n@@ -1321,13 +1321,13 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       pragma Warnings (Off, X);\n \n    begin\n+      TE_Check (Container.HT.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      TE_Check (Container.HT.TC);\n-\n       X := Node.Element;\n \n       declare"}, {"sha": "ac7e534380ae40b30b066db481c8c85e07fbc2bf", "filename": "gcc/ada/libgnat/a-cimutr.adb", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cimutr.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -261,6 +261,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Element     : Element_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -273,8 +275,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       declare\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n@@ -738,6 +738,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -746,8 +748,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       --  Deallocate_Children returns a count of the number of nodes\n       --  that it deallocates, but it works by incrementing the\n       --  value that is passed in. We must therefore initialize\n@@ -772,6 +772,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       X : Tree_Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -789,8 +791,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Constraint_Error with \"Position cursor does not designate leaf\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       X := Position.Node;\n       Position := No_Element;\n \n@@ -819,6 +819,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -832,8 +834,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       X := Position.Node;\n       Position := No_Element;\n \n@@ -1191,6 +1191,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Element : Element_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -1215,8 +1217,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       declare\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n@@ -1735,6 +1735,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Element     : Element_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -1747,8 +1749,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       declare\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n@@ -2096,6 +2096,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       E, X : Element_Access;\n \n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -2109,8 +2111,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see\n@@ -2182,6 +2182,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n@@ -2219,8 +2222,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n             return;\n          end if;\n \n-         TC_Check (Target.TC);\n-\n          if Checks and then Is_Reachable (From => Target_Parent.Node,\n                           To   => Source_Parent.Node)\n          then\n@@ -2236,9 +2237,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       --  We cache the count of the nodes we have allocated, so that operation\n       --  Node_Count can execute in O(1) time. But that means we must count the\n       --  nodes in the subtree we remove from Source and insert into Target, in\n@@ -2265,6 +2263,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Source_Parent   : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n@@ -2304,8 +2304,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Checks and then Is_Reachable (From => Target_Parent.Node,\n                        To   => Source_Parent.Node)\n       then\n@@ -2363,6 +2361,9 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Subtree_Count : Count_Type;\n \n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -2404,8 +2405,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n             end if;\n          end if;\n \n-         TC_Check (Target.TC);\n-\n          if Checks and then\n            Is_Reachable (From => Parent.Node, To => Position.Node)\n          then\n@@ -2420,9 +2419,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       --  This is an unfortunate feature of this API: we must count the nodes\n       --  in the subtree that we remove from the source tree, which is an O(n)\n       --  operation. It would have been better if the Tree container did not\n@@ -2455,6 +2451,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Position  : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -2500,8 +2498,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          end if;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Checks and then\n         Is_Reachable (From => Parent.Node, To => Position.Node)\n       then\n@@ -2553,6 +2549,8 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       I, J      : Cursor)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then I = No_Element then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -2581,8 +2579,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n          raise Program_Error with \"J cursor designates root\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          EI : constant Element_Access := I.Node.Element;\n "}, {"sha": "25cf67445f1ec607b0ffea057ec11aa935745a05", "filename": "gcc/ada/libgnat/a-ciorma.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ciorma.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -1435,12 +1435,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       E : Element_Access;\n \n    begin\n+      TE_Check (Container.Tree.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      TE_Check (Container.Tree.TC);\n-\n       K := Node.Key;\n       E := Node.Element;\n \n@@ -1476,6 +1476,8 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.Tree.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n@@ -1494,8 +1496,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      TE_Check (Container.Tree.TC);\n-\n       pragma Assert (Vet (Container.Tree, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n "}, {"sha": "f9647a2cf400d2a3a2c063371fef3aaeb13f4ce3", "filename": "gcc/ada/libgnat/a-ciorse.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ciorse.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -1788,12 +1788,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       pragma Warnings (Off, X);\n \n    begin\n+      TE_Check (Container.Tree.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with \"attempt to replace element not in set\";\n       end if;\n \n-      TE_Check (Container.Tree.TC);\n-\n       declare\n          --  The element allocator may need an accessibility check in the case\n          --  the actual type is class-wide or has access discriminants (see"}, {"sha": "fe94ea58364d0d4412f633b2d4cc7f0476c7e6eb", "filename": "gcc/ada/libgnat/a-cobove.adb", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cobove.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -483,6 +483,8 @@ package body Ada.Containers.Bounded_Vectors is\n       Off      : Count_Type'Base;  -- Index expressed as offset from IT'First\n \n    begin\n+      TC_Check (Container.TC);\n+\n       --  Delete removes items from the vector, the number of which is the\n       --  minimum of the specified Count and the items (if any) that exist from\n       --  Index to Container.Last. There are no constraints on the specified\n@@ -532,8 +534,6 @@ package body Ada.Containers.Bounded_Vectors is\n       --  the count on exit. Delete checks the count to determine whether it is\n       --  being called while the associated callback procedure is executing.\n \n-      TC_Check (Container.TC);\n-\n       --  We first calculate what's available for deletion starting at\n       --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n       --  Count_Type'Base as the type for intermediate values. (See function\n@@ -636,15 +636,6 @@ package body Ada.Containers.Bounded_Vectors is\n       Count     : Count_Type := 1)\n    is\n    begin\n-      --  It is not permitted to delete items while the container is busy (for\n-      --  example, we're in the middle of a passive iteration). However, we\n-      --  always treat deleting 0 items as a no-op, even when we're busy, so we\n-      --  simply return without checking.\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n       --  The tampering bits exist to prevent an item from being deleted (or\n       --  otherwise harmfully manipulated) while it is being visited. Query,\n       --  Update, and Iterate increment the busy count on entry, and decrement\n@@ -654,6 +645,10 @@ package body Ada.Containers.Bounded_Vectors is\n \n       TC_Check (Container.TC);\n \n+      if Count = 0 then\n+         return;\n+      end if;\n+\n       --  There is no restriction on how large Count can be when deleting\n       --  items. If it is equal or greater than the current length, then this\n       --  is equivalent to clearing the vector. (In particular, there's no need\n@@ -882,6 +877,8 @@ package body Ada.Containers.Bounded_Vectors is\n             return;\n          end if;\n \n+         TC_Check (Source.TC);\n+\n          if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n@@ -892,8 +889,6 @@ package body Ada.Containers.Bounded_Vectors is\n             return;\n          end if;\n \n-         TC_Check (Source.TC);\n-\n          I := Target.Length;\n          Target.Set_Length (I + Source.Length);\n \n@@ -1021,6 +1016,14 @@ package body Ada.Containers.Bounded_Vectors is\n       J     : Count_Type'Base;  -- scratch\n \n    begin\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       --  As a precondition on the generic actual Index_Type, the base type\n       --  must include Index_Type'Pred (Index_Type'First); this is the value\n       --  that Container.Last assumes when the vector is empty. However, we do\n@@ -1176,14 +1179,6 @@ package body Ada.Containers.Bounded_Vectors is\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being harmfully\n-      --  manipulated while it is being visited. Query, Update, and Iterate\n-      --  increment the busy count on entry, and decrement the count on\n-      --  exit. Insert checks the count to determine whether it is being called\n-      --  while the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       if Checks and then New_Length > Container.Capacity then\n          raise Capacity_Error with \"New length is larger than capacity\";\n       end if;\n@@ -1491,6 +1486,14 @@ package body Ada.Containers.Bounded_Vectors is\n       J     : Count_Type'Base;  -- scratch\n \n    begin\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       --  As a precondition on the generic actual Index_Type, the base type\n       --  must include Index_Type'Pred (Index_Type'First); this is the value\n       --  that Container.Last assumes when the vector is empty. However, we do\n@@ -1646,14 +1649,6 @@ package body Ada.Containers.Bounded_Vectors is\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being harmfully\n-      --  manipulated while it is being visited. Query, Update, and Iterate\n-      --  increment the busy count on entry, and decrement the count on\n-      --  exit. Insert checks the count to determine whether it is being called\n-      --  while the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       --  An internal array has already been allocated, so we need to check\n       --  whether there is enough unused storage for the new items.\n \n@@ -1937,14 +1932,14 @@ package body Ada.Containers.Bounded_Vectors is\n          return;\n       end if;\n \n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Checks and then Target.Capacity < Source.Length then\n          raise Capacity_Error  -- ???\n            with \"Target capacity is less than Source length\";\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       --  Clear Target now, in case element assignment fails\n \n       Target.Last := No_Index;\n@@ -2222,12 +2217,12 @@ package body Ada.Containers.Bounded_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       Container.Elements (To_Array_Index (Index)) := New_Item;\n    end Replace_Element;\n \n@@ -2237,6 +2232,8 @@ package body Ada.Containers.Bounded_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -2250,8 +2247,6 @@ package body Ada.Containers.Bounded_Vectors is\n          raise Constraint_Error with \"Position cursor is out of range\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       Container.Elements (To_Array_Index (Position.Index)) := New_Item;\n    end Replace_Element;\n \n@@ -2425,6 +2420,8 @@ package body Ada.Containers.Bounded_Vectors is\n       E : Elements_Array renames Container.Elements;\n \n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then I > Container.Last then\n          raise Constraint_Error with \"I index is out of range\";\n       end if;\n@@ -2437,8 +2434,6 @@ package body Ada.Containers.Bounded_Vectors is\n          return;\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          EI_Copy : constant Element_Type := E (To_Array_Index (I));\n       begin"}, {"sha": "f5424623cf74a9a32458c32d31ac564949a9a54d", "filename": "gcc/ada/libgnat/a-cohama.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cohama.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -314,6 +314,8 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n+      TC_Check (Container.HT.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Delete equals No_Element\";\n@@ -325,8 +327,6 @@ package body Ada.Containers.Hashed_Maps is\n            \"Position cursor of Delete designates wrong map\";\n       end if;\n \n-      TC_Check (Container.HT.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n@@ -999,13 +999,13 @@ package body Ada.Containers.Hashed_Maps is\n       Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n \n    begin\n+      TE_Check (Container.HT.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace key not in map\";\n       end if;\n \n-      TE_Check (Container.HT.TC);\n-\n       Node.Key := Key;\n       Node.Element := New_Item;\n    end Replace;\n@@ -1020,6 +1020,8 @@ package body Ada.Containers.Hashed_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Position.Container.HT.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n@@ -1031,8 +1033,6 @@ package body Ada.Containers.Hashed_Maps is\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      TE_Check (Position.Container.HT.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       Position.Node.Element := New_Item;"}, {"sha": "45a1b2e029412a207dba9f377a75245328777508", "filename": "gcc/ada/libgnat/a-cohase.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cohase.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -299,6 +299,8 @@ package body Ada.Containers.Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n+      TC_Check (Container.HT.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with \"Position cursor equals No_Element\";\n       end if;\n@@ -308,8 +310,6 @@ package body Ada.Containers.Hashed_Sets is\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n-      TC_Check (Container.HT.TC);\n-\n       pragma Assert (Vet (Position), \"bad cursor in Delete\");\n \n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n@@ -1204,13 +1204,13 @@ package body Ada.Containers.Hashed_Sets is\n         Element_Keys.Find (Container.HT, New_Item);\n \n    begin\n+      TE_Check (Container.HT.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      TE_Check (Container.HT.TC);\n-\n       Node.Element := New_Item;\n    end Replace;\n "}, {"sha": "85c30fa1832529dc94592c2bec3fa7c107cbec47", "filename": "gcc/ada/libgnat/a-coinve.adb", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coinve.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -408,6 +408,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       J        : Index_Type'Base;  -- first index of items that slide down\n \n    begin\n+      --  The tampering bits exist to prevent an item from being deleted (or\n+      --  otherwise harmfully manipulated) while it is being visited. Query,\n+      --  Update, and Iterate increment the busy count on entry, and decrement\n+      --  the count on exit. Delete checks the count to determine whether it is\n+      --  being called while the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       --  Delete removes items from the vector, the number of which is the\n       --  minimum of the specified Count and the items (if any) that exist from\n       --  Index to Container.Last. There are no constraints on the specified\n@@ -460,14 +468,6 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being deleted (or\n-      --  otherwise harmfully manipulated) while it is being visited. Query,\n-      --  Update, and Iterate increment the busy count on entry, and decrement\n-      --  the count on exit. Delete checks the count to determine whether it is\n-      --  being called while the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       --  We first calculate what's available for deletion starting at\n       --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n       --  Count_Type'Base as the type for intermediate values. (See function\n@@ -942,6 +942,8 @@ package body Ada.Containers.Indefinite_Vectors is\n          I, J : Index_Type'Base;\n \n       begin\n+         TC_Check (Source.TC);\n+\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -964,8 +966,6 @@ package body Ada.Containers.Indefinite_Vectors is\n             return;\n          end if;\n \n-         TC_Check (Source.TC);\n-\n          I := Target.Last;  -- original value (before Set_Length)\n          Target.Set_Length (Length (Target) + Length (Source));\n \n@@ -1128,6 +1128,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       if Checks then\n          --  As a precondition on the generic actual Index_Type, the base type\n          --  must include Index_Type'Pred (Index_Type'First); this is the value\n@@ -1335,14 +1343,6 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being harmfully\n-      --  manipulated while it is being visited. Query, Update, and Iterate\n-      --  increment the busy count on entry, and decrement the count on\n-      --  exit. Insert checks the count to determine whether it is being called\n-      --  while the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       if New_Length <= Container.Elements.EA'Length then\n \n          --  In this case, we're inserting elements into a vector that has\n@@ -1908,6 +1908,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on exit.\n+      --  Insert checks the count to determine whether it is being called while\n+      --  the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       if Checks then\n          --  As a precondition on the generic actual Index_Type, the base type\n          --  must include Index_Type'Pred (Index_Type'First); this is the value\n@@ -2090,14 +2098,6 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being harmfully\n-      --  manipulated while it is being visited. Query, Update, and Iterate\n-      --  increment the busy count on entry, and decrement the count on exit.\n-      --  Insert checks the count to determine whether it is being called while\n-      --  the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       if New_Length <= Container.Elements.EA'Length then\n \n          --  In this case, we are inserting elements into a vector that has\n@@ -2757,12 +2757,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          X : Element_Access := Container.Elements.EA (Index);\n \n@@ -2784,6 +2784,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks then\n          if Position.Container = null then\n             raise Constraint_Error with \"Position cursor has no element\";\n@@ -2798,8 +2800,6 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          X : Element_Access := Container.Elements.EA (Position.Index);\n \n@@ -3258,6 +3258,8 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks then\n          if I > Container.Last then\n             raise Constraint_Error with \"I index is out of range\";\n@@ -3272,8 +3274,6 @@ package body Ada.Containers.Indefinite_Vectors is\n          return;\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          EI : Element_Access renames Container.Elements.EA (I);\n          EJ : Element_Access renames Container.Elements.EA (J);"}, {"sha": "6468839e294409a3419db33ae475ec5b7b02a70e", "filename": "gcc/ada/libgnat/a-comutr.adb", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-comutr.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -263,6 +263,8 @@ package body Ada.Containers.Multiway_Trees is\n       Last  : Tree_Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -275,8 +277,6 @@ package body Ada.Containers.Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       First := new Tree_Node_Type'(Parent  => Parent.Node,\n                                    Element => New_Item,\n                                    others  => <>);\n@@ -699,6 +699,8 @@ package body Ada.Containers.Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -707,8 +709,6 @@ package body Ada.Containers.Multiway_Trees is\n          raise Program_Error with \"Parent cursor not in container\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       --  Deallocate_Children returns a count of the number of nodes that it\n       --  deallocates, but it works by incrementing the value that is passed\n       --  in. We must therefore initialize the count value before calling\n@@ -733,6 +733,8 @@ package body Ada.Containers.Multiway_Trees is\n       X : Tree_Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -750,8 +752,6 @@ package body Ada.Containers.Multiway_Trees is\n          raise Constraint_Error with \"Position cursor does not designate leaf\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       X := Position.Node;\n       Position := No_Element;\n \n@@ -780,6 +780,8 @@ package body Ada.Containers.Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -793,8 +795,6 @@ package body Ada.Containers.Multiway_Trees is\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       X := Position.Node;\n       Position := No_Element;\n \n@@ -1145,6 +1145,8 @@ package body Ada.Containers.Multiway_Trees is\n       Last  : Tree_Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -1169,8 +1171,6 @@ package body Ada.Containers.Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       First := new Tree_Node_Type'(Parent  => Parent.Node,\n                                    Element => New_Item,\n                                    others  => <>);\n@@ -1214,6 +1214,8 @@ package body Ada.Containers.Multiway_Trees is\n       Last  : Tree_Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -1238,8 +1240,6 @@ package body Ada.Containers.Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       First := new Tree_Node_Type'(Parent  => Parent.Node,\n                                    Element => <>,\n                                    others  => <>);\n@@ -1737,6 +1737,8 @@ package body Ada.Containers.Multiway_Trees is\n       First, Last : Tree_Node_Access;\n \n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -1749,8 +1751,6 @@ package body Ada.Containers.Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       First := new Tree_Node_Type'(Parent  => Parent.Node,\n                                    Element => New_Item,\n                                    others  => <>);\n@@ -2073,6 +2073,8 @@ package body Ada.Containers.Multiway_Trees is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Position = No_Element then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -2086,8 +2088,6 @@ package body Ada.Containers.Multiway_Trees is\n          raise Program_Error with \"Position cursor designates root\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       Position.Node.Element := New_Item;\n    end Replace_Element;\n \n@@ -2160,6 +2160,9 @@ package body Ada.Containers.Multiway_Trees is\n       Count : Count_Type;\n \n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n@@ -2197,8 +2200,6 @@ package body Ada.Containers.Multiway_Trees is\n             return;\n          end if;\n \n-         TC_Check (Target.TC);\n-\n          if Checks and then Is_Reachable (From => Target_Parent.Node,\n                           To   => Source_Parent.Node)\n          then\n@@ -2214,9 +2215,6 @@ package body Ada.Containers.Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       --  We cache the count of the nodes we have allocated, so that operation\n       --  Node_Count can execute in O(1) time. But that means we must count the\n       --  nodes in the subtree we remove from Source and insert into Target, in\n@@ -2243,6 +2241,8 @@ package body Ada.Containers.Multiway_Trees is\n       Source_Parent   : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Target_Parent = No_Element then\n          raise Constraint_Error with \"Target_Parent cursor has no element\";\n       end if;\n@@ -2282,8 +2282,6 @@ package body Ada.Containers.Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Checks and then Is_Reachable (From => Target_Parent.Node,\n                        To   => Source_Parent.Node)\n       then\n@@ -2341,6 +2339,9 @@ package body Ada.Containers.Multiway_Trees is\n       Subtree_Count : Count_Type;\n \n    begin\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -2382,8 +2383,6 @@ package body Ada.Containers.Multiway_Trees is\n             end if;\n          end if;\n \n-         TC_Check (Target.TC);\n-\n          if Checks and then\n            Is_Reachable (From => Parent.Node, To => Position.Node)\n          then\n@@ -2398,9 +2397,6 @@ package body Ada.Containers.Multiway_Trees is\n          return;\n       end if;\n \n-      TC_Check (Target.TC);\n-      TC_Check (Source.TC);\n-\n       --  This is an unfortunate feature of this API: we must count the nodes\n       --  in the subtree that we remove from the source tree, which is an O(n)\n       --  operation. It would have been better if the Tree container did not\n@@ -2433,6 +2429,8 @@ package body Ada.Containers.Multiway_Trees is\n       Position  : Cursor)\n    is\n    begin\n+      TC_Check (Container.TC);\n+\n       if Checks and then Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n       end if;\n@@ -2478,8 +2476,6 @@ package body Ada.Containers.Multiway_Trees is\n          end if;\n       end if;\n \n-      TC_Check (Container.TC);\n-\n       if Checks and then\n         Is_Reachable (From => Parent.Node, To => Position.Node)\n       then\n@@ -2531,6 +2527,8 @@ package body Ada.Containers.Multiway_Trees is\n       I, J      : Cursor)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then I = No_Element then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -2559,8 +2557,6 @@ package body Ada.Containers.Multiway_Trees is\n          raise Program_Error with \"J cursor designates root\";\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          EI : constant Element_Type := I.Node.Element;\n "}, {"sha": "197271b87c7daa0423a8328456467d7ca5b315b7", "filename": "gcc/ada/libgnat/a-convec.adb", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-convec.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -377,6 +377,14 @@ package body Ada.Containers.Vectors is\n       J        : Index_Type'Base;  -- first index of items that slide down\n \n    begin\n+      --  The tampering bits exist to prevent an item from being deleted (or\n+      --  otherwise harmfully manipulated) while it is being visited. Query,\n+      --  Update, and Iterate increment the busy count on entry, and decrement\n+      --  the count on exit. Delete checks the count to determine whether it is\n+      --  being called while the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       --  Delete removes items from the vector, the number of which is the\n       --  minimum of the specified Count and the items (if any) that exist from\n       --  Index to Container.Last. There are no constraints on the specified\n@@ -420,14 +428,6 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being deleted (or\n-      --  otherwise harmfully manipulated) while it is being visited. Query,\n-      --  Update, and Iterate increment the busy count on entry, and decrement\n-      --  the count on exit. Delete checks the count to determine whether it is\n-      --  being called while the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       --  We first calculate what's available for deletion starting at\n       --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n       --  Count_Type'Base as the type for intermediate values. (See function\n@@ -781,6 +781,8 @@ package body Ada.Containers.Vectors is\n          J : Index_Type'Base;\n \n       begin\n+         TC_Check (Source.TC);\n+\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -803,8 +805,6 @@ package body Ada.Containers.Vectors is\n             return;\n          end if;\n \n-         TC_Check (Source.TC);\n-\n          Target.Set_Length (Length (Target) + Length (Source));\n \n          --  Per AI05-0022, the container implementation is required to detect\n@@ -861,10 +861,6 @@ package body Ada.Containers.Vectors is\n               \"<\"          => \"<\");\n \n       begin\n-         if Container.Last <= Index_Type'First then\n-            return;\n-         end if;\n-\n          --  The exception behavior for the vector container must match that\n          --  for the list container, so we check for cursor tampering here\n          --  (which will catch more things) instead of for element tampering\n@@ -878,6 +874,10 @@ package body Ada.Containers.Vectors is\n \n          TC_Check (Container.TC);\n \n+         if Container.Last <= Index_Type'First then\n+            return;\n+         end if;\n+\n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n@@ -933,6 +933,14 @@ package body Ada.Containers.Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       if Checks then\n          --  As a precondition on the generic actual Index_Type, the base type\n          --  must include Index_Type'Pred (Index_Type'First); this is the value\n@@ -1124,14 +1132,6 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being harmfully\n-      --  manipulated while it is being visited. Query, Update, and Iterate\n-      --  increment the busy count on entry, and decrement the count on\n-      --  exit. Insert checks the count to determine whether it is being called\n-      --  while the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       --  An internal array has already been allocated, so we must determine\n       --  whether there is enough unused storage for the new items.\n \n@@ -1595,6 +1595,14 @@ package body Ada.Containers.Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n+      --  The tampering bits exist to prevent an item from being harmfully\n+      --  manipulated while it is being visited. Query, Update, and Iterate\n+      --  increment the busy count on entry, and decrement the count on\n+      --  exit. Insert checks the count to determine whether it is being called\n+      --  while the associated callback procedure is executing.\n+\n+      TC_Check (Container.TC);\n+\n       if Checks then\n          --  As a precondition on the generic actual Index_Type, the base type\n          --  must include Index_Type'Pred (Index_Type'First); this is the value\n@@ -1784,14 +1792,6 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      --  The tampering bits exist to prevent an item from being harmfully\n-      --  manipulated while it is being visited. Query, Update, and Iterate\n-      --  increment the busy count on entry, and decrement the count on\n-      --  exit. Insert checks the count to determine whether it is being called\n-      --  while the associated callback procedure is executing.\n-\n-      TC_Check (Container.TC);\n-\n       --  An internal array has already been allocated, so we must determine\n       --  whether there is enough unused storage for the new items.\n \n@@ -2446,11 +2446,12 @@ package body Ada.Containers.Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      TE_Check (Container.TC);\n       Container.Elements.EA (Index) := New_Item;\n    end Replace_Element;\n \n@@ -2460,6 +2461,8 @@ package body Ada.Containers.Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks then\n          if Position.Container = null then\n             raise Constraint_Error with \"Position cursor has no element\";\n@@ -2472,7 +2475,6 @@ package body Ada.Containers.Vectors is\n          end if;\n       end if;\n \n-      TE_Check (Container.TC);\n       Container.Elements.EA (Position.Index) := New_Item;\n    end Replace_Element;\n \n@@ -2940,6 +2942,8 @@ package body Ada.Containers.Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n+      TE_Check (Container.TC);\n+\n       if Checks then\n          if I > Container.Last then\n             raise Constraint_Error with \"I index is out of range\";\n@@ -2954,8 +2958,6 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      TE_Check (Container.TC);\n-\n       declare\n          EI_Copy : constant Element_Type := Container.Elements.EA (I);\n       begin"}, {"sha": "9bad901259aeddb42f147f124189401b45cdbdcd", "filename": "gcc/ada/libgnat/a-coorma.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coorma.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -1349,12 +1349,12 @@ package body Ada.Containers.Ordered_Maps is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n \n    begin\n+      TE_Check (Container.Tree.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      TE_Check (Container.Tree.TC);\n-\n       Node.Key := Key;\n       Node.Element := New_Item;\n    end Replace;\n@@ -1369,6 +1369,8 @@ package body Ada.Containers.Ordered_Maps is\n       New_Item  : Element_Type)\n    is\n    begin\n+      TE_Check (Container.Tree.TC);\n+\n       if Checks and then Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor of Replace_Element equals No_Element\";\n@@ -1380,8 +1382,6 @@ package body Ada.Containers.Ordered_Maps is\n            \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n-      TE_Check (Container.Tree.TC);\n-\n       pragma Assert (Vet (Container.Tree, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n "}, {"sha": "8c37d11248a9be6d8ecd5f48261b4eb08e19c133", "filename": "gcc/ada/libgnat/a-coorse.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coorse.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -1641,13 +1641,13 @@ package body Ada.Containers.Ordered_Sets is\n         Element_Keys.Find (Container.Tree, New_Item);\n \n    begin\n+      TE_Check (Container.Tree.TC);\n+\n       if Checks and then Node = null then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      TE_Check (Container.Tree.TC);\n-\n       Node.Element := New_Item;\n    end Replace;\n "}, {"sha": "a41fcbbc02d7780f128432f99da3cd980b5beafb", "filename": "gcc/ada/libgnat/a-crbtgk.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-crbtgk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-crbtgk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-crbtgk.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -422,12 +422,12 @@ package body Ada.Containers.Red_Black_Trees.Generic_Keys is\n       Z      : out Node_Access)\n    is\n    begin\n+      TC_Check (Tree.TC);\n+\n       if Checks and then Tree.Length = Count_Type'Last then\n          raise Constraint_Error with \"too many elements\";\n       end if;\n \n-      TC_Check (Tree.TC);\n-\n       Z := New_Node;\n       pragma Assert (Z /= null);\n       pragma Assert (Ops.Color (Z) = Red);"}, {"sha": "35727b0d7dd8a8edd130d2c9e22d2b94c81aa82e", "filename": "gcc/ada/libgnat/a-crbtgo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-crbtgo.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -693,12 +693,12 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    procedure Generic_Move (Target, Source : in out Tree_Type) is\n    begin\n+      TC_Check (Source.TC);\n+\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      TC_Check (Source.TC);\n-\n       Clear (Target);\n \n       Target := Source;"}, {"sha": "fcb254d8fe45b9ae8d17eb4aec26fcfac60f2069", "filename": "gcc/ada/libgnat/a-rbtgso.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-rbtgso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c602003b6a2552c01d77fd1fdd5f12848743075f/gcc%2Fada%2Flibgnat%2Fa-rbtgso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-rbtgso.adb?ref=c602003b6a2552c01d77fd1fdd5f12848743075f", "patch": "@@ -94,9 +94,9 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n       Compare : Integer;\n \n    begin\n-      if Target'Address = Source'Address then\n-         TC_Check (Target.TC);\n+      TC_Check (Target.TC);\n \n+      if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n@@ -105,8 +105,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Set_Operations is\n          return;\n       end if;\n \n-      TC_Check (Target.TC);\n-\n       Tgt := Target.First;\n       Src := Source.First;\n       loop"}]}