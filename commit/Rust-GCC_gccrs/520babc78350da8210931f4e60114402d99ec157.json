{"sha": "520babc78350da8210931f4e60114402d99ec157", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwYmFiYzc4MzUwZGE4MjEwOTMxZjRlNjAxMTQ0MDJkOTllYzE1Nw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-04-11T20:02:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-04-11T20:02:46Z"}, "message": "long-double.h (FIX_TRUNCTFSI2_LIBCALL): Tweak for PA64.\n\n\n\t* pa/long-double.h (FIX_TRUNCTFSI2_LIBCALL): Tweak for PA64.\n\t* pa/pa-protos.h (output_call): Add additional argument indicating\n\tif the call is a sibling/tail call.\n\t(compute_zdepdi_operands, output_64bit_and): Prototype new functions.\n\t(compute_64bit_ior, cmpib_comparison_operator): Likewise.\n\t(function_arg, function_arg_partial_nregs): Likewise\n\t* pa/pa.c (override_options): Always set flag_pic for TARGET_64BIT.\n\t(emit_move_sequence): Zero extend certain constants as needed\n\tfor TARGET_64BIT.\n\t(compute_zdepdi_operands, output_64bit_and): New functions.\n\t(output_64bit_ior, function_arg): Likewise.\n\t(cmpib_comparison_operator, function_arg_partial_nregs): Likewise.\n\t(compute_frame_size, hppa_expand_prologue): Handle TARGET_64BIT.\n\t(hppa_expand_epilogue, return_addr_rtx, hppa_va_arg): Likewise.\n\t(hppa_builtin_saveregs, output_cbranch, output_bb): Likewise.\n\t(output_bvb): Likewise.\n\t(output_millicode_call): Return pointer is in %r2 for TARGET_64BIT.\n\t(output_call): New argument 'sibcall'.  Generate sibcall sequences\n\tas needed.\n\t(print_operand); Handle cases 'Q', 'p', and 'z' for TARGET_64BIT.  For\n\t(ouput_arg_descriptor): Do not emit argument descriptors for\n\tTARGET_64BIT.\n\t* pa/pa.h (TARGET_PA_11, TARGET_PA_20): Only define if not already\n\tdefined.\n\t(TARGET_64BIT, PROMOTE_FUNCTION_RETURN): Define.\n\t(FUNCTION_OK_FOR_SIBALL): Define.\n\t(CPP_PA10_SPEC, CPP_PA11_SPEC, CPP_PA20_SPEC): Define.\n\t(CPP_CPU_DEFAULT_SPEC, SUBTARGET_EXTRA_SPECS, EXTRA_SPECS): Likewise.\n\t(CPP_SPEC): Use new spec infrastructure.\n\t(BITS_PER_WORD, UNITS_PER_WORD): Handle TARGET_64BIT.\n\t(STACK_BOUNDARY, FUNCTION_BOUNDARY, PIC_OFFSET_TABLE_REGNUM): Likewise.\n\t(RETURN_IN_MEMORY, EXTRA_CONSTRAINT, FIRST_PARM_OFFSET): Likewise.\n\t(REG_PARM_STACK_SPACE, STACK_POINTER_OFFSET): Likewise.\n\t(STACK_DYNAMIC_OFFSET, FUNCTION_VALUE): Likewise.\n\t(FUNCTION_ARG_PASS_BY_REFERENCE, FUNCTION_ARG_CALLEE_COPIES): Likewise.\n\t(TRAMPOLINE_TEMPLATE, TRAMPOLINE_SIZE): Likewise.\n\t(INITIALIZE_TRAMPOLINE, LEGITIMATE_CONSTANT_P): Likewise.\n\t(CONST_OK_FOR_LETTER_P, MOVE_RATIO): Likewise.\n\t(FUNCTION_ARG); Call out to C code.\n\t(FUNCTION_ARG_PARTIAL_NREGS): Likewise.\n\t(MAX_BITS_PER_WORD, MAX_LONG_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE): Define.\n\t(MIN_UNITS_PER_WORD): Likewise.\n\t* pa/pa.md (cmpdi): New expander.\n\t(scc patterns, movstrsi): Not available for TARGET_64BIT.\n\t(64bit conditional arithmetic): New patterns.\n\t(absdi2, smindi3, umindi3, smaxdi3, umaxdi3): New patterns.\n\t(movsicc): Not available if modes on all the operands to not match.\n\t(movdicc): New expander and associated patterns.\n\t(64bit branches): New patterns.\n\t(pre_load, post_store): Generate appropriate code for TARGET_64BIT.\n\t(pre_ldd, post_std): New patterns.\n\t(64bit addil, load low part): New patterns.\n\t(special movsf constant): Not available for TARGET_64BIT.\n\t(movsf, movdf expanders): Force constants into memory.\n\t(32bit movdf/movdi patterns): Disable for TARGET_64BIT.\n\t(64bit movdf/movdi patterns): New patterns.\n\t(zero_extendqidi2, zero_extendhidi2, zero_extendsidi2): New patterns\n\tfor TARGET_64BIT.\n\t(extendqidi2, extendhidi2, extendsidi2): Similarly.\n\t(adddi3 expander): Allow \"arith_operand\" for second input.\n\t(32bit adddi3, subdi3, uaddcm): Disable for TARGET_64BIT.\n\t(64bit adddi3, subsi3, uaddcm): New patterns for TARGET_64BIT.\n\t(mulsi3 expander): Revamp slightly so it supports TARGET_64BIT too.\n\t(muldi3): New expander for TARGET_64BIT.\n\t(divsi3, udivsi3, modsi3, umodsi3): Fourth operand must be (reg:SI 2)\n\tfor TARGET_64BIT.\n\t(32bit anddi3, iordi3, xordi3, andcm, negdi2, uaddcm): Disable\n\tpatterns for TARGET_64BIT.\n\t(64bit anddi3, iordi3, xordi3, andcm, negdi2, uaddcm, shadd): New\n\tpatterns for TARGET_64BIT.\n\t(64bit bit insertion/extractions): New patterns for TARGET_64BIT.\n\t(64bit shifts/rotates): New patterns/expanders for TARGET_64BIT.\n\t(sibcall_epilogue): New expander.\n\t(casesi): Tweak for TARGET_64BIT.\n\t(call expanders): Set & use the outgoing argument pointer.  Use the\n\t64bit call patterns as needed. Add additional arg to output_call.\n\t(call_internal_reg_64bit, call_value_internal_reg_64bit): New pattern.\n\t(sibcall, sibcall_internal_symref): New expanders.\n\t(sibcall_value, sibcall_value_internal_symref\n\t(interspace_jump): Turn into an expander + matching patterns.\n\t(canonicalize_funcptr_for_compare): Not needed for TARGET_64BIT.\n\t* pa/pa64-regs.h: Eliminate trigraph sequences.\n\t* pa/pa64-start.h (TARGET_PA_20): Fix typo.\n\nFrom-SVN: r33082", "tree": {"sha": "f4ae9c77c443c3961448209fd35398526106468e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4ae9c77c443c3961448209fd35398526106468e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520babc78350da8210931f4e60114402d99ec157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520babc78350da8210931f4e60114402d99ec157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520babc78350da8210931f4e60114402d99ec157", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520babc78350da8210931f4e60114402d99ec157/comments", "author": null, "committer": null, "parents": [{"sha": "cba6a0b29f3a543c4249edd018cdda26ec2c7cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba6a0b29f3a543c4249edd018cdda26ec2c7cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba6a0b29f3a543c4249edd018cdda26ec2c7cf1"}], "stats": {"total": 2696, "additions": 2484, "deletions": 212}, "files": [{"sha": "2cacd99a61969c465f1c739d48537bae46c7230d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -1,3 +1,89 @@\n+Tue Apr 11 09:55:59 2000  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* pa/long-double.h (FIX_TRUNCTFSI2_LIBCALL): Tweak for PA64.\n+\t* pa/pa-protos.h (output_call): Add additional argument indicating\n+\tif the call is a sibling/tail call.\n+\t(compute_zdepdi_operands, output_64bit_and): Prototype new functions.\n+\t(compute_64bit_ior, cmpib_comparison_operator): Likewise.\n+\t(function_arg, function_arg_partial_nregs): Likewise\n+\t* pa/pa.c (override_options): Always set flag_pic for TARGET_64BIT.\n+\t(emit_move_sequence): Zero extend certain constants as needed\n+\tfor TARGET_64BIT.\n+\t(compute_zdepdi_operands, output_64bit_and): New functions.\n+\t(output_64bit_ior, function_arg): Likewise.\n+\t(cmpib_comparison_operator, function_arg_partial_nregs): Likewise.\n+\t(compute_frame_size, hppa_expand_prologue): Handle TARGET_64BIT.\n+\t(hppa_expand_epilogue, return_addr_rtx, hppa_va_arg): Likewise.\n+\t(hppa_builtin_saveregs, output_cbranch, output_bb): Likewise.\n+\t(output_bvb): Likewise.\n+\t(output_millicode_call): Return pointer is in %r2 for TARGET_64BIT.\n+\t(output_call): New argument 'sibcall'.  Generate sibcall sequences\n+\tas needed.\n+\t(print_operand); Handle cases 'Q', 'p', and 'z' for TARGET_64BIT.  For\n+\t(ouput_arg_descriptor): Do not emit argument descriptors for\n+\tTARGET_64BIT.\n+\t* pa/pa.h (TARGET_PA_11, TARGET_PA_20): Only define if not already\n+\tdefined.\n+\t(TARGET_64BIT, PROMOTE_FUNCTION_RETURN): Define.\n+\t(FUNCTION_OK_FOR_SIBALL): Define.\n+\t(CPP_PA10_SPEC, CPP_PA11_SPEC, CPP_PA20_SPEC): Define.\n+\t(CPP_CPU_DEFAULT_SPEC, SUBTARGET_EXTRA_SPECS, EXTRA_SPECS): Likewise.\n+\t(CPP_SPEC): Use new spec infrastructure.\n+\t(BITS_PER_WORD, UNITS_PER_WORD): Handle TARGET_64BIT.\n+\t(STACK_BOUNDARY, FUNCTION_BOUNDARY, PIC_OFFSET_TABLE_REGNUM): Likewise.\n+\t(RETURN_IN_MEMORY, EXTRA_CONSTRAINT, FIRST_PARM_OFFSET): Likewise.\n+\t(REG_PARM_STACK_SPACE, STACK_POINTER_OFFSET): Likewise.\n+\t(STACK_DYNAMIC_OFFSET, FUNCTION_VALUE): Likewise.\n+\t(FUNCTION_ARG_PASS_BY_REFERENCE, FUNCTION_ARG_CALLEE_COPIES): Likewise.\n+\t(TRAMPOLINE_TEMPLATE, TRAMPOLINE_SIZE): Likewise.\n+\t(INITIALIZE_TRAMPOLINE, LEGITIMATE_CONSTANT_P): Likewise.\n+\t(CONST_OK_FOR_LETTER_P, MOVE_RATIO): Likewise.\n+\t(FUNCTION_ARG); Call out to C code.\n+\t(FUNCTION_ARG_PARTIAL_NREGS): Likewise.\n+\t(MAX_BITS_PER_WORD, MAX_LONG_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE): Define.\n+\t(MIN_UNITS_PER_WORD): Likewise.\n+\t* pa/pa.md (cmpdi): New expander.\n+\t(scc patterns, movstrsi): Not available for TARGET_64BIT.\n+\t(64bit conditional arithmetic): New patterns.\n+\t(absdi2, smindi3, umindi3, smaxdi3, umaxdi3): New patterns.\n+\t(movsicc): Not available if modes on all the operands to not match.\t\n+\t(movdicc): New expander and associated patterns.\n+\t(64bit branches): New patterns.\n+\t(pre_load, post_store): Generate appropriate code for TARGET_64BIT.\n+\t(pre_ldd, post_std): New patterns.\n+\t(64bit addil, load low part): New patterns.\n+\t(special movsf constant): Not available for TARGET_64BIT.\n+\t(movsf, movdf expanders): Force constants into memory.\n+\t(32bit movdf/movdi patterns): Disable for TARGET_64BIT.\n+\t(64bit movdf/movdi patterns): New patterns.\n+\t(zero_extendqidi2, zero_extendhidi2, zero_extendsidi2): New patterns\n+\tfor TARGET_64BIT.\n+\t(extendqidi2, extendhidi2, extendsidi2): Similarly.\n+\t(adddi3 expander): Allow \"arith_operand\" for second input.\n+\t(32bit adddi3, subdi3, uaddcm): Disable for TARGET_64BIT.\n+\t(64bit adddi3, subsi3, uaddcm): New patterns for TARGET_64BIT.\n+\t(mulsi3 expander): Revamp slightly so it supports TARGET_64BIT too.\n+\t(muldi3): New expander for TARGET_64BIT.\n+\t(divsi3, udivsi3, modsi3, umodsi3): Fourth operand must be (reg:SI 2)\n+\tfor TARGET_64BIT.\n+\t(32bit anddi3, iordi3, xordi3, andcm, negdi2, uaddcm): Disable\n+\tpatterns for TARGET_64BIT.\n+\t(64bit anddi3, iordi3, xordi3, andcm, negdi2, uaddcm, shadd): New\n+\tpatterns for TARGET_64BIT.\n+\t(64bit bit insertion/extractions): New patterns for TARGET_64BIT.\n+\t(64bit shifts/rotates): New patterns/expanders for TARGET_64BIT.\n+\t(sibcall_epilogue): New expander.\n+\t(casesi): Tweak for TARGET_64BIT.\n+\t(call expanders): Set & use the outgoing argument pointer.  Use the\n+\t64bit call patterns as needed. Add additional arg to output_call.\n+\t(call_internal_reg_64bit, call_value_internal_reg_64bit): New pattern.\n+\t(sibcall, sibcall_internal_symref): New expanders.\n+\t(sibcall_value, sibcall_value_internal_symref\n+\t(interspace_jump): Turn into an expander + matching patterns.\n+\t(canonicalize_funcptr_for_compare): Not needed for TARGET_64BIT.\n+\t* pa/pa64-regs.h: Eliminate trigraph sequences.\n+\t* pa/pa64-start.h (TARGET_PA_20): Fix typo.\n+\n 2000-04-11  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cppexp.c, cpphash.c, cpphash.h, cpplex.c, cpplib.c,"}, {"sha": "ea2b1d3a96a42063e334c2191a1f3948033f7589", "filename": "gcc/config/pa/long_double.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Flong_double.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Flong_double.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flong_double.h?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -48,7 +48,10 @@ do { long value[4];                                                     \\\n #define TRUNCTFDF2_LIBCALL \"_U_Qfcnvff_quad_to_dbl\"\n #define FLOATSITF2_LIBCALL \"_U_Qfcnvxf_sgl_to_quad\"\n #define FLOATDITF2_LIBCALL \"_U_Qfcnvxf_dbl_to_quad\"\n-#define FIX_TRUNCTFSI2_LIBCALL \"_U_Qfcnvfxt_quad_to_sgl\"\n+/* We need to put a wrapper function around _U_Qfcnvfxt_quad_to_sgl so that\n+   we can massage its return value for PA64.  */\n+#define FIX_TRUNCTFSI2_LIBCALL \\\n+  (TARGET_64BIT ? \"__U_Qfcnvfxt_quad_to_sgl\" : \"_U_Qfcnvfxt_quad_to_sgl\")\n #define FIX_TRUNCTFDI2_LIBCALL \"_U_Qfcnvfxt_quad_to_dbl\"\n #define EQTF2_LIBCALL \"_U_Qfeq\"\n #define NETF2_LIBCALL \"_U_Qfne\""}, {"sha": "98ea1bf8fe0906f49e17593abd06a67dfb915507", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -50,7 +50,7 @@ extern const char *output_dbra PARAMS ((rtx *, rtx, int));\n extern const char *output_movb PARAMS ((rtx *, rtx, int, int));\n extern const char *output_parallel_movb PARAMS ((rtx *, int));\n extern const char *output_parallel_addb PARAMS ((rtx *, int));\n-extern const char *output_call PARAMS ((rtx, rtx));\n+extern const char *output_call PARAMS ((rtx, rtx, int));\n extern const char *output_millicode_call PARAMS ((rtx, rtx));\n extern const char *output_mul_insn PARAMS ((int, rtx));\n extern const char *output_div_insn PARAMS ((rtx *, int, rtx));\n@@ -141,7 +141,23 @@ extern void hppa_expand_prologue PARAMS ((void));\n extern void hppa_expand_epilogue PARAMS ((void));\n extern int hppa_can_use_return_insn_p PARAMS ((void));\n extern int ior_mask_p PARAMS ((unsigned HOST_WIDE_INT));\n+extern void compute_zdepdi_operands PARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t     unsigned *));\n+#ifdef RTX_CODE\n+extern char * output_64bit_and PARAMS ((rtx *));\n+extern char * output_64bit_ior PARAMS ((rtx *));\n+extern int cmpib_comparison_operator PARAMS ((rtx, enum machine_mode));\n+#endif\n+\n+\n \n #ifdef TREE_CODE\n extern int reloc_needed PARAMS ((tree));\n+#ifdef RTX_CODE\n+extern rtx function_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t tree, int, int));\n+#endif\n+extern int function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t       enum machine_mode,\n+\t\t\t\t\t       tree, int));\n #endif /* TREE_CODE */"}, {"sha": "d9b7f8e6a263117d38df883eee931b467169cdb9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 610, "deletions": 26, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -189,6 +189,10 @@ override_options ()\n       write_symbols = NO_DEBUG;\n     }\n \n+  /* We always generate PIC code when in 64bit mode.  */\n+  if (TARGET_64BIT)\n+    flag_pic = 2;\n+\n   /* Register global variables with the garbage collector.  */\n   pa_add_gc_roots ();\n }\n@@ -1562,6 +1566,25 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t       || ! cint_ok_for_move (INTVAL (operand1)))\n \t{\n \t  rtx temp;\n+\t  int need_zero_extend = 0;\n+\n+\t  if (TARGET_64BIT && GET_CODE (operand1) == CONST_INT\n+\t      && GET_MODE_BITSIZE (GET_MODE (operand0)) > 32)\n+\t    {\n+\t      HOST_WIDE_INT val = INTVAL (operand1);\n+\t      HOST_WIDE_INT nval = INTVAL (operand1);\n+\n+\t      /* If the value is the same after a 32->64bit sign\n+\t\t extension, then we can use it as-is.  Else we will\n+\t\t need to sign extend the constant from 32->64bits\n+\t\t then zero extend the result from 32->64bits.  */\n+\t      nval = ((val & 0xffffffff) ^ (~0x7fffffff)) + 0x80000000;\n+\t      if (val != nval)\n+\t\t{\n+\t\t  need_zero_extend = 1;\n+\t\t  operand1 = GEN_INT (nval);\n+\t\t}\n+\t    }\n \n \t  if (reload_in_progress || reload_completed)\n \t    temp = operand0;\n@@ -1571,6 +1594,17 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t  emit_insn (gen_rtx_SET (VOIDmode, temp,\n \t\t\t\t  gen_rtx_HIGH (mode, operand1)));\n \t  operands[1] = gen_rtx_LO_SUM (mode, temp, operand1);\n+\t  emit_move_insn (operands[0], operands[1]);\n+\n+\t  if (need_zero_extend)\n+\t    {\n+\t      emit_insn (gen_zero_extendsidi2 (operands[0],\n+\t\t\t\t\t       gen_rtx_SUBREG (SImode,\n+\t\t\t\t\t\t\t       operands[0],\n+\t\t\t\t\t\t\t       0)));\n+\t    }\n+\t\n+\t  return 1;\n \t}\n     }\n   /* Now have insn-emit do whatever it normally does.  */\n@@ -1729,6 +1763,46 @@ compute_zdepwi_operands (imm, op)\n   op[2] = len;\n }\n \n+/* Compute position (in OP[1]) and width (in OP[2])\n+   useful for copying IMM to a register using the depdi,z\n+   instructions.  Store the immediate value to insert in OP[0].  */\n+void\n+compute_zdepdi_operands (imm, op)\n+     unsigned HOST_WIDE_INT imm;\n+     unsigned *op;\n+{\n+  HOST_WIDE_INT lsb, len;\n+\n+  /* Find the least significant set bit in IMM.  */\n+  for (lsb = 0; lsb < HOST_BITS_PER_WIDE_INT; lsb++)\n+    {\n+      if ((imm & 1) != 0)\n+        break;\n+      imm >>= 1;\n+    }\n+\n+  /* Choose variants based on *sign* of the 5-bit field.  */\n+  if ((imm & 0x10) == 0)\n+    len = ((lsb <= HOST_BITS_PER_WIDE_INT - 4)\n+\t   ? 4 : HOST_BITS_PER_WIDE_INT - lsb);\n+  else\n+    {\n+      /* Find the width of the bitstring in IMM.  */\n+      for (len = 5; len < HOST_BITS_PER_WIDE_INT; len++)\n+\t{\n+\t  if ((imm & ((unsigned HOST_WIDE_INT)1 << len)) == 0)\n+\t    break;\n+\t}\n+\n+      /* Sign extend IMM as a 5-bit value.  */\n+      imm = (imm & 0xf) - 0x10;\n+    }\n+\n+  op[0] = imm;\n+  op[1] = 63 - lsb;\n+  op[2] = len;\n+}\n+\n /* Output assembler code to perform a doubleword move insn\n    with operands OPERANDS.  */\n \n@@ -2264,6 +2338,59 @@ output_and (operands)\n     return \"and %1,%2,%0\";\n }\n \n+/* Return a string to perform a bitwise-and of operands[1] with operands[2]\n+   storing the result in operands[0].  */\n+char *\n+output_64bit_and (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n+    {\n+      unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n+      unsigned HOST_WIDE_INT ls0, ls1, ms0, p, len;\n+\n+      for (ls0 = 0; ls0 < HOST_BITS_PER_WIDE_INT; ls0++)\n+\tif ((mask & ((unsigned HOST_WIDE_INT)1 << ls0)) == 0)\n+\t  break;\n+\n+      for (ls1 = ls0; ls1 < HOST_BITS_PER_WIDE_INT; ls1++)\n+\tif ((mask & ((unsigned HOST_WIDE_INT)1 << ls1)) != 0)\n+\t  break;\n+\n+      for (ms0 = ls1; ms0 < HOST_BITS_PER_WIDE_INT; ms0++)\n+\tif ((mask & ((unsigned HOST_WIDE_INT)1 << ms0)) == 0)\n+\t  break;\n+\n+      if (ms0 != HOST_BITS_PER_WIDE_INT)\n+\tabort();\n+\n+      if (ls1 == HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  len = ls0;\n+\n+\t  if (len == 0)\n+\t    abort ();\n+\n+\t  operands[2] = GEN_INT (len);\n+\t  return \"extrd,u %1,63,%2,%0\";\n+\t}\n+      else\n+\t{\n+\t  /* We could use this `depi' for the case above as well, but `depi'\n+\t     requires one more register file access than an `extru'.  */\n+\n+\t  p = 63 - ls0;\n+\t  len = ls1 - ls0;\n+\n+\t  operands[2] = GEN_INT (p);\n+\t  operands[3] = GEN_INT (len);\n+\t  return \"depdi 0,%2,%3,%0\";\n+\t}\n+    }\n+  else\n+    return \"and %1,%2,%0\";\n+}\n+\n const char *\n output_ior (operands)\n      rtx *operands;\n@@ -2292,6 +2419,38 @@ output_ior (operands)\n   operands[3] = GEN_INT (len);\n   return \"{depi|depwi} -1,%2,%3,%0\";\n }\n+\n+/* Return a string to perform a bitwise-and of operands[1] with operands[2]\n+   storing the result in operands[0].  */\n+char *\n+output_64bit_ior (operands)\n+     rtx *operands;\n+{\n+  unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n+  unsigned HOST_WIDE_INT bs0, bs1, p, len;\n+\n+  if (INTVAL (operands[2]) == 0)\n+    return \"copy %1,%0\";\n+\n+  for (bs0 = 0; bs0 < HOST_BITS_PER_WIDE_INT; bs0++)\n+    if ((mask & ((unsigned HOST_WIDE_INT)1 << bs0)) != 0)\n+      break;\n+\n+  for (bs1 = bs0; bs1 < HOST_BITS_PER_WIDE_INT; bs1++)\n+    if ((mask & ((unsigned HOST_WIDE_INT)1 << bs1)) == 0)\n+      break;\n+\n+  if (bs1 != HOST_BITS_PER_WIDE_INT\n+      && ((unsigned HOST_WIDE_INT) 1 << bs1) <= mask)\n+    abort();\n+\n+  p = 63 - bs0;\n+  len = bs1 - bs0;\n+\n+  operands[2] = GEN_INT (p);\n+  operands[3] = GEN_INT (len);\n+  return \"depdi -1,%2,%3,%0\";\n+}\n \f\n /* Output an ascii string.  */\n void\n@@ -2676,7 +2835,8 @@ compute_frame_size (size, fregs_live)\n \n   /* Account for space used by the callee floating point register saves.  */\n   for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n-    if (regs_ever_live[i] || regs_ever_live[i + 1])\n+    if (regs_ever_live[i]\n+\t|| (! TARGET_64BIT && regs_ever_live[i + 1]))\n       {\n \tif (fregs_live)\n \t  *fregs_live = 1;\n@@ -2693,8 +2853,9 @@ compute_frame_size (size, fregs_live)\n   /* Allocate space for the fixed frame marker.  This space must be\n      allocated for any function that makes calls or otherwise allocates\n      stack space.  */\n-  if (! leaf_function_p () || fsize)\n+  if (!current_function_is_leaf || fsize)\n     fsize += 32;\n+\n   return (fsize + STACK_BOUNDARY - 1) & ~(STACK_BOUNDARY - 1);\n }\n \n@@ -2796,8 +2957,12 @@ hppa_expand_prologue()\n   size_rtx = GEN_INT (actual_fsize);\n \n   /* Save RP first.  The calling conventions manual states RP will\n-     always be stored into the caller's frame at sp-20.  */\n-  if (regs_ever_live[2] || profile_flag)\n+     always be stored into the caller's frame at sp-20 or sp - 16\n+     depending on which ABI is in use.  */\n+  if ((regs_ever_live[2] || profile_flag) && TARGET_64BIT)\n+    store_reg (2, -16, STACK_POINTER_REGNUM);\n+\n+  if ((regs_ever_live[2] || profile_flag) && ! TARGET_64BIT)\n     store_reg (2, -20, STACK_POINTER_REGNUM);\n \n   /* Allocate the local frame and set up the frame pointer if needed.  */\n@@ -2856,7 +3021,7 @@ hppa_expand_prologue()\n      for functions which make no calls and allocate no frame?  Do\n      we need to allocate a frame, or can we just omit the save?   For\n      now we'll just omit the save.  */\n-  if (actual_fsize != 0 && flag_pic)\n+  if (actual_fsize != 0 && flag_pic && !TARGET_64BIT)\n     store_reg (PIC_OFFSET_TABLE_REGNUM, -32, STACK_POINTER_REGNUM);\n \n   /* Profiling code.\n@@ -2982,7 +3147,8 @@ hppa_expand_prologue()\n       /* Now actually save the FP registers.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n \t{\n-\t  if (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  if (regs_ever_live[i]\n+\t      || (! TARGET_64BIT && regs_ever_live[i + 1]))\n \t    {\n \t      emit_move_insn (gen_rtx_MEM (DFmode,\n \t\t\t\t           gen_rtx_POST_INC (DFmode, tmpreg)),\n@@ -3066,9 +3232,17 @@ hppa_expand_epilogue ()\n      RP gets used in the return (bv) instruction.  This appears to still\n      be necessary even when we schedule the prologue and epilogue. */\n   if (frame_pointer_needed\n+      && !TARGET_64BIT\n       && (regs_ever_live [2] || profile_flag))\n     load_reg (2, -20, FRAME_POINTER_REGNUM);\n-\n+  else if (TARGET_64BIT && frame_pointer_needed\n+\t   && (regs_ever_live[2] || profile_flag))\n+    load_reg (2, -16, FRAME_POINTER_REGNUM);\n+  else if (TARGET_64BIT\n+\t   && ! frame_pointer_needed\n+\t   && (regs_ever_live[2] || profile_flag)\n+\t   && VAL_14_BITS_P (actual_fsize + 20))\n+    load_reg (2, - (actual_fsize + 16), STACK_POINTER_REGNUM);\n   /* No frame pointer, and stack is smaller than 8k.  */\n   else if (! frame_pointer_needed\n \t   && VAL_14_BITS_P (actual_fsize + 20)\n@@ -3120,7 +3294,8 @@ hppa_expand_epilogue ()\n       /* Actually do the restores now.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n \t{\n-\t  if (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  if (regs_ever_live[i]\n+\t      || (! TARGET_64BIT && regs_ever_live[i + 1]))\n \t    {\n \t      emit_move_insn (gen_rtx_REG (DFmode, i),\n \t\t\t      gen_rtx_MEM (DFmode,\n@@ -3140,6 +3315,7 @@ hppa_expand_epilogue ()\n      as possible.)  */\n   if (! frame_pointer_needed\n       && ! VAL_14_BITS_P (actual_fsize + 20)\n+      && ! TARGET_64BIT\n       && (regs_ever_live[2] || profile_flag))\n     {\n       set_reg_plus_d (STACK_POINTER_REGNUM,\n@@ -3154,6 +3330,23 @@ hppa_expand_epilogue ()\n \t doesn't set %r1, just %r30.  */\n       load_reg (2, - 20, STACK_POINTER_REGNUM);\n     }\n+  else if (! frame_pointer_needed\n+\t   && ! VAL_14_BITS_P (actual_fsize + 20)\n+\t   && TARGET_64BIT\n+\t   && (regs_ever_live[2] || profile_flag))\n+    {\n+      set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t      STACK_POINTER_REGNUM,\n+\t\t      - actual_fsize);\n+\n+      /* This used to try and be clever by not depending on the value in\n+\t %r30 and instead use the value held in %r1 (so that the 2nd insn\n+\t which sets %r30 could be put in the delay slot of the return insn).\n+\t\n+\t That won't work since if the stack is exactly 8k set_reg_plus_d\n+\t doesn't set %r1, just %r30.  */\n+      load_reg (2, - 16, STACK_POINTER_REGNUM);\n+    }\n \n   /* Reset stack pointer (and possibly frame pointer).  The stack \n      pointer is initially set to fp + 64 to avoid a race condition.  */\n@@ -3216,7 +3409,10 @@ return_addr_rtx (count, frameaddr)\n   /* First, we start off with the normal return address pointer from\n      -20[frameaddr].  */\n \n-  emit_move_insn (saved_rp, plus_constant (frameaddr, -5 * UNITS_PER_WORD));\n+  if (TARGET_64BIT)\n+    return gen_rtx_MEM (Pmode, plus_constant (frameaddr, -16));\n+  else\n+    emit_move_insn (saved_rp, plus_constant (frameaddr, -5 * UNITS_PER_WORD));\n \n   /* Get pointer to the instruction stream.  We have to mask out the\n      privilege level from the two low order bits of the return address\n@@ -3824,6 +4020,13 @@ print_operand (file, x, code)\n \t  return;\n \t}\n       abort();\n+    case 'Q':\n+      if (GET_CODE (x) == CONST_INT)\n+\t{\n+\t  fprintf (file, \"%d\", 64 - (INTVAL (x) & 63));\n+\t  return;\n+\t}\n+      abort();\n     case 'L':\n       if (GET_CODE (x) == CONST_INT)\n \t{\n@@ -3838,6 +4041,13 @@ print_operand (file, x, code)\n \t  return;\n \t}\n       abort();\n+    case 'p':\n+      if (GET_CODE (x) == CONST_INT)\n+\t{\n+\t  fprintf (file, \"%d\", 63 - (INTVAL (x) & 63));\n+\t  return;\n+\t}\n+      abort();\n     case 'P':\n       if (GET_CODE (x) == CONST_INT)\n \t{\n@@ -3900,13 +4110,27 @@ print_operand (file, x, code)\n \tfprintf (file, \"%d,%d,%d\", op[0], op[1], op[2]);\n \treturn;\n       }\n+    case 'z':\n+      {\n+\tunsigned op[3];\n+\tcompute_zdepdi_operands (INTVAL (x), op);\n+\tfprintf (file, \"%d,%d,%d\", op[0], op[1], op[2]);\n+\treturn;\n+      }\n     default:\n       abort ();\n     }\n   if (GET_CODE (x) == REG)\n     {\n       fputs (reg_names [REGNO (x)], file);\n-      if (FP_REG_P (x) && GET_MODE_SIZE (GET_MODE (x)) <= 4 && (REGNO (x) & 1) == 0)\n+      if (TARGET_64BIT && FP_REG_P (x) && GET_MODE_SIZE (GET_MODE (x)) <= 4)\n+\t{\n+\t  fputs (\"R\", file);\n+\t  return;\n+\t}\n+      if (FP_REG_P (x)\n+\t  && GET_MODE_SIZE (GET_MODE (x)) <= 4\n+\t  && (REGNO (x) & 1) == 0)\n \tfputs (\"L\", file);\n     }\n   else if (GET_CODE (x) == MEM)\n@@ -3917,12 +4141,12 @@ print_operand (file, x, code)\n \t{\n \tcase PRE_DEC:\n \tcase POST_DEC:\n-\t  base = XEXP (XEXP (x, 0), 0);\n+          base = XEXP (XEXP (x, 0), 0);\n \t  fprintf (file, \"-%d(%s)\", size, reg_names [REGNO (base)]);\n \t  break;\n \tcase PRE_INC:\n \tcase POST_INC:\n-\t  base = XEXP (XEXP (x, 0), 0);\n+          base = XEXP (XEXP (x, 0), 0);\n \t  fprintf (file, \"%d(%s)\", size, reg_names [REGNO (base)]);\n \t  break;\n \tdefault:\n@@ -4221,6 +4445,11 @@ output_arg_descriptor (call_insn)\n   int i, output_flag = 0;\n   int regno;\n \n+  /* We neither need nor want argument location descriptors for the\n+     64bit runtime environment.  */\n+  if (TARGET_64BIT)\n+    return;\n+\n   for (i = 0; i < 4; i++)\n     arg_regs[i] = 0;\n \n@@ -4420,6 +4649,36 @@ hppa_builtin_saveregs ()\n   else\n     offset = current_function_arg_offset_rtx;\n \n+  if (TARGET_64BIT)\n+    {\n+      int i, off;\n+      \n+      /* Adjust for varargs/stdarg differences.  */\n+      if (argadj)\n+\toffset = plus_constant (current_function_arg_offset_rtx, -argadj);\n+      else\n+\toffset = current_function_arg_offset_rtx;\n+\n+      /* We need to save %r26 .. %r19 inclusive starting at offset -64\n+\t from the incoming arg pointer and growing to larger addresses.  */\n+      for (i = 26, off = -64; i >= 19; i--, off += 8)\n+\temit_move_insn (gen_rtx_MEM (word_mode,\n+\t\t\t\t     plus_constant (arg_pointer_rtx, off)),\n+\t\t\tgen_rtx_REG (word_mode, i));\n+\n+      /* The incoming args pointer points just beyond the flushback area;\n+\t normally this is not a serious concern.  Howver, when we are doing\n+\t varargs/stdargs we want to make the arg pointer point to the start\n+\t of the incoming argument area.  */\n+      emit_move_insn (virtual_incoming_args_rtx,\n+\t\t      plus_constant (arg_pointer_rtx, -64));\n+\n+      /* Now return a pointer to the first anonymous argument.  */\n+      return copy_to_reg (expand_binop (Pmode, add_optab,\n+\t\t\t\t\tvirtual_incoming_args_rtx,\n+\t\t\t\t\toffset, 0, 0, OPTAB_LIB_WIDEN));\n+    }\n+\n   /* Store general registers on the stack. */\n   dest = gen_rtx_MEM (BLKmode,\n \t\t      plus_constant (current_function_internal_arg_pointer,\n@@ -4467,6 +4726,25 @@ hppa_va_arg (valist, type)\n   HOST_WIDE_INT align, size, ofs;\n   tree t, ptr, pptr;\n \n+  if (TARGET_64BIT)\n+    {\n+      /* Every argument in PA64 is passed by value (including large structs).\n+         Arguments with size greater than 8 must be aligned 0 MOD 16. */\n+\n+      size = int_size_in_bytes (type);\n+      if (size > UNITS_PER_WORD)\n+        {\n+          t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n+                     build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n+          t = build (BIT_AND_EXPR, TREE_TYPE (t), t, \n+                     build_int_2 (-2 * UNITS_PER_WORD, -1));\n+          t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+          TREE_SIDE_EFFECTS (t) = 1;\n+          expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+        }\n+      return std_expand_builtin_va_arg (valist, type);\n+    }\n+\n   /* Compute the rounded size of the type.  */\n   align = PARM_BOUNDARY / BITS_PER_UNIT;\n   size = int_size_in_bytes (type);\n@@ -4570,6 +4848,8 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  strcpy (buf, \"{com%I2clr,|cmp%I2clr,}\");\n \telse\n \t  strcpy (buf, \"{com%I2b,|cmp%I2b,}\");\n+\tif (GET_MODE (operands[1]) == DImode)\n+\t  strcat (buf, \"*\");\n \tif (negated)\n \t  strcat (buf, \"%B3\");\n \telse\n@@ -4593,6 +4873,8 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t    && nullify)\n \t  {\n \t    strcpy (buf, \"{com%I2b,|cmp%I2b,}\");\n+\t    if (GET_MODE (operands[1]) == DImode)\n+\t      strcat (buf, \"*\");\n \t    if (negated)\n \t      strcat (buf, \"%S3\");\n \t    else\n@@ -4609,6 +4891,8 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t\t\t\t    - insn_addresses[INSN_UID (insn)] - 8))\n \t  {\n \t    strcpy (buf, \"{com%I2b,|cmp%I2b,}\");\n+\t    if (GET_MODE (operands[1]) == DImode)\n+\t      strcat (buf, \"*\");\n \t    if (negated)\n \t      strcat (buf, \"%B3 %2,%r1,%0%#\");\n \t    else\n@@ -4617,6 +4901,8 @@ output_cbranch (operands, nullify, length, negated, insn)\n \telse\n \t  {\n \t    strcpy (buf, \"{com%I2clr,|cmp%I2clr,}\");\n+\t    if (GET_MODE (operands[1]) == DImode)\n+\t      strcat (buf, \"*\");\n \t    if (negated)\n \t      strcat (buf, \"%S3\");\n \t    else\n@@ -4640,6 +4926,15 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  strcpy (buf, \"{com%I2b,%S3,n %2,%r1,.+20|cmp%I2b,%S3,n %2,%r1,.+20}\");\n \telse\n \t  strcpy (buf, \"{com%I2b,%B3,n %2,%r1,.+20|cmp%I2b,%B3,n %2,%r1,.+20}\");\n+\tif (GET_MODE (operands[1]) == DImode)\n+\t  {\n+\t    if (negated)\n+\t      strcpy (buf,\n+\t\t      \"{com%I2b,*%S3,n %2,%r1,.+20|cmp%I2b,*%S3,n %2,%r1,.+20}\");\n+\t    else\n+\t      strcpy (buf,\n+\t\t      \"{com%I2b,*%B3,n %2,%r1,.+20|cmp%I2b,*%B3,n %2,%r1,.+20}\");\n+\t  }\n \toutput_asm_insn (buf, operands);\n \n \t/* Output an insn to save %r1.  */\n@@ -4665,6 +4960,13 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  strcpy (buf, \"{com%I2b,%S3,n %2,%r1,.+28|cmp%I2b,%S3,n %2,%r1,.+28}\");\n \telse\n \t  strcpy (buf, \"{com%I2b,%B3,n %2,%r1,.+28|cmp%I2b,%B3,n %2,%r1,.+28}\");\n+\tif (GET_MODE (operands[1]) == DImode)\n+\t  {\n+\t    if (negated)\n+\t      strcpy (buf, \"{com%I2b,*%S3,n %2,%r1,.+28|cmp%I2b,*%S3,n %2,%r1,.+28}\");\n+\t    else\n+\t      strcpy (buf, \"{com%I2b,*%B3,n %2,%r1,.+28|cmp%I2b,*%B3,n %2,%r1,.+28}\");\n+\t  }\n \toutput_asm_insn (buf, operands);\n \n \t/* Output an insn to save %r1.  */\n@@ -4752,6 +5054,10 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t  strcpy (buf, \"{extrs,|extrw,s,}\");\n \telse\n \t  strcpy (buf, \"bb,\");\n+\tif (useskip && GET_MODE (operands[0]) == DImode)\n+\t  strcpy (buf, \"extrd,s,*\");\n+\telse if (GET_MODE (operands[0]) == DImode)\n+\t  strcpy (buf, \"bb,*\");\n \tif ((which == 0 && negated)\n \t     || (which == 1 && ! negated))\n \t  strcat (buf, \">=\");\n@@ -4780,6 +5086,8 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t    && nullify)\n \t  {\n \t    strcpy (buf, \"bb,\");\n+\t    if (GET_MODE (operands[0]) == DImode)\n+\t      strcat (buf, \"*\");\n \t    if ((which == 0 && negated)\n \t\t|| (which == 1 && ! negated))\n \t      strcat (buf, \"<\");\n@@ -4800,6 +5108,8 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t\t\t\t    - insn_addresses[INSN_UID (insn)] - 8))\n \t  {\n \t    strcpy (buf, \"bb,\");\n+\t    if (GET_MODE (operands[0]) == DImode)\n+\t      strcat (buf, \"*\");\n \t    if ((which == 0 && negated)\n \t\t|| (which == 1 && ! negated))\n \t      strcat (buf, \">=\");\n@@ -4813,6 +5123,8 @@ output_bb (operands, nullify, length, negated, insn, which)\n \telse\n \t  {\n \t    strcpy (buf, \"{extrs,|extrw,s,}\");\n+\t    if (GET_MODE (operands[0]) == DImode)\n+\t      strcpy (buf, \"extrd,s,*\");\n \t    if ((which == 0 && negated)\n \t\t|| (which == 1 && ! negated))\n \t      strcat (buf, \"<\");\n@@ -4890,6 +5202,10 @@ output_bvb (operands, nullify, length, negated, insn, which)\n \t  strcpy (buf, \"{vextrs,|extrw,s,}\");\n \telse\n \t  strcpy (buf, \"{bvb,|bb,}\");\n+\tif (useskip && GET_MODE (operands[0]) == DImode)\n+\t  strcpy (buf, \"extrd,s,*}\");\n+\telse if (GET_MODE (operands[0]) == DImode)\n+\t  strcpy (buf, \"bb,*\");\n \tif ((which == 0 && negated)\n \t     || (which == 1 && ! negated))\n \t  strcat (buf, \">=\");\n@@ -4918,6 +5234,8 @@ output_bvb (operands, nullify, length, negated, insn, which)\n \t    && nullify)\n \t  {\n \t    strcpy (buf, \"{bvb,|bb,}\");\n+\t    if (GET_MODE (operands[0]) == DImode)\n+\t      strcat (buf, \"*\");\n \t    if ((which == 0 && negated)\n \t\t|| (which == 1 && ! negated))\n \t      strcat (buf, \"<\");\n@@ -4938,6 +5256,8 @@ output_bvb (operands, nullify, length, negated, insn, which)\n \t\t\t\t    - insn_addresses[INSN_UID (insn)] - 8))\n \t  {\n \t    strcpy (buf, \"{bvb,|bb,}\");\n+\t    if (GET_MODE (operands[0]) == DImode)\n+\t      strcat (buf, \"*\");\n \t    if ((which == 0 && negated)\n \t\t|| (which == 1 && ! negated))\n \t      strcat (buf, \">=\");\n@@ -4951,6 +5271,8 @@ output_bvb (operands, nullify, length, negated, insn, which)\n \telse\n \t  {\n \t    strcpy (buf, \"{vextrs,|extrw,s,}\");\n+\t    if (GET_MODE (operands[0]) == DImode)\n+\t      strcpy (buf, \"extrd,s,*\");\n \t    if ((which == 0 && negated)\n \t\t|| (which == 1 && ! negated))\n \t      strcat (buf, \"<\");\n@@ -5206,6 +5528,10 @@ output_millicode_call (insn, call_dest)\n   rtx xoperands[4];\n   rtx seq_insn;\n \n+  xoperands[3] = gen_rtx_REG (SImode, 31);\n+  if (TARGET_64BIT)\n+    xoperands[3] = gen_rtx_REG (SImode, 2);\n+\n   /* Handle common case -- empty delay slot or no jump in the delay slot,\n      and we're sure that the branch will reach the beginning of the $CODE$\n      subspace.  */\n@@ -5216,15 +5542,14 @@ output_millicode_call (insn, call_dest)\n \t  && get_attr_length (insn) == 4))\n     {\n       xoperands[0] = call_dest;\n-      output_asm_insn (\"{bl|b,l} %0,%%r31%#\", xoperands);\n+      output_asm_insn (\"{bl|b,l} %0,%3%#\", xoperands);\n       return \"\";\n     }\n \n   /* This call may not reach the beginning of the $CODE$ subspace.  */\n   if (get_attr_length (insn) > 4)\n     {\n       int delay_insn_deleted = 0;\n-      rtx xoperands[2];\n \n       /* We need to emit an inline long-call branch.  */\n       if (dbr_sequence_length () != 0\n@@ -5247,8 +5572,8 @@ output_millicode_call (insn, call_dest)\n \t  || ! (flag_pic  || TARGET_PORTABLE_RUNTIME))\n \t{\n \t  xoperands[0] = call_dest;\n-\t  output_asm_insn (\"ldil L%%%0,%%r31\", xoperands);\n-\t  output_asm_insn (\"{ble|be,l} R%%%0(%%sr4,%%r31)\", xoperands);\n+\t  output_asm_insn (\"ldil L%%%0,%3\", xoperands);\n+\t  output_asm_insn (\"{ble|be,l} R%%%0(%%sr4,%3)\", xoperands);\n \t  output_asm_insn (\"nop\", xoperands);\n \t}\n       /* Pure portable runtime doesn't allow be/ble; we also don't have\n@@ -5261,7 +5586,7 @@ output_millicode_call (insn, call_dest)\n \t  output_asm_insn (\"ldo R%%%0(%%r29),%%r29\", xoperands);\n \n \t  /* Get our return address into %r31.  */\n-\t  output_asm_insn (\"blr %%r0,%%r31\", xoperands);\n+\t  output_asm_insn (\"blr %%r0,%3\", xoperands);\n \n \t  /* Jump to our target address in %r29.  */\n \t  output_asm_insn (\"bv,n %%r0(%%r29)\", xoperands);\n@@ -5286,7 +5611,7 @@ output_millicode_call (insn, call_dest)\n \t  output_asm_insn (\"ldo R%%%0-%1(%%r1),%%r1\", xoperands);\n \n \t  /* Get the return address into %r31.  */\n-\t  output_asm_insn (\"blr 0,%%r31\", xoperands);\n+\t  output_asm_insn (\"blr 0,%3\", xoperands);\n \n \t  /* Branch to our target which is in %r1.  */\n \t  output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n@@ -5330,11 +5655,11 @@ output_millicode_call (insn, call_dest)\n   xoperands[0] = call_dest;\n   xoperands[1] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n   if (! VAL_14_BITS_P (distance))\n-    output_asm_insn (\"{bl|b,l} %0,%%r31\\n\\tnop\\n\\tb,n %1\", xoperands);\n+    output_asm_insn (\"{bl|b,l} %0,%3\\n\\tnop\\n\\tb,n %1\", xoperands);\n   else\n     {\n       xoperands[2] = gen_label_rtx ();\n-      output_asm_insn (\"\\n\\t{bl|b,l} %0,%%r31\\n\\tldo %1-%2(%%r31),%%r31\",\n+      output_asm_insn (\"\\n\\t{bl|b,l} %0,%3\\n\\tldo %1-%2(%3),%3\",\n \t\t       xoperands);\n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t\t CODE_LABEL_NUMBER (xoperands[2]));\n@@ -5358,9 +5683,10 @@ extern struct obstack *current_obstack;\n    CALL_DEST is the routine we are calling.  */\n \n const char *\n-output_call (insn, call_dest)\n+output_call (insn, call_dest, sibcall)\n   rtx insn;\n   rtx call_dest;\n+  int sibcall;\n {\n   int distance;\n   rtx xoperands[4];\n@@ -5376,7 +5702,8 @@ output_call (insn, call_dest)\n \t  && get_attr_length (insn) == 4))\n     {\n       xoperands[0] = call_dest;\n-      output_asm_insn (\"{bl|b,l} %0,%%r2%#\", xoperands);\n+      xoperands[1] = gen_rtx_REG (word_mode, sibcall ? 0 : 2);\n+      output_asm_insn (\"{bl|b,l} %0,%1%#\", xoperands);\n       return \"\";\n     }\n \n@@ -5527,8 +5854,17 @@ output_call (insn, call_dest)\n \t      /* Branch to our target which is in %r1.  */\n \t      output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n \n-\t      /* Copy the return address into %r2 also.  */\n-\t      output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t      if (sibcall)\n+\t\t{\n+\t\t  /* This call never returns, so we do not need to fix the\n+\t\t     return pointer.  */\n+\t\t  output_asm_insn (\"nop\", xoperands);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Copy the return address into %r2 also.  */\n+\t\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -5544,8 +5880,17 @@ output_call (insn, call_dest)\n \t      output_asm_insn (\"{ble|be,l}  R%%$$dyncall(%%sr4,%%r2)\",\n \t\t\t       xoperands);\n \n-\t      /* Copy the return pointer into both %r31 and %r2.  */\n-\t      output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t      if (sibcall)\n+\t\t{\n+\t\t  /* This call never returns, so we do not need to fix the\n+\t\t     return pointer.  */\n+\t\t  output_asm_insn (\"nop\", xoperands);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Copy the return address into %r2 also.  */\n+\t\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t\t}\n \t    }\n \t}\n \n@@ -6593,6 +6938,245 @@ insn_refs_are_delayed (insn)\n \t   && get_attr_type (insn) == TYPE_MILLI));\n }\n \n+/* Return the location of a parameter that is passed in a register or NULL\n+   if the parameter has any component that is passed in memory.\n+\n+   This is new code and will be pushed to into the net sources after\n+   further testing. \n+\n+   ??? We might want to restructure this so that it looks more like other\n+   ports.  */\n+rtx\n+function_arg (cum, mode, type, named, incoming)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+     int incoming;\n+{\n+  int max_arg_words = (TARGET_64BIT ? 8 : 4);\n+  int fpr_reg_base;\n+  int gpr_reg_base;\n+  rtx retval;\n+\n+  if (! TARGET_64BIT)\n+    {\n+      /* If this arg would be passed partially or totally on the stack, then\n+         this routine should return zero.  FUNCTION_ARG_PARTIAL_NREGS will\n+         handle arguments which are split between regs and stack slots if\n+         the ABI mandates split arguments.  */\n+      if (cum->words + FUNCTION_ARG_SIZE (mode, type) > max_arg_words\n+          || mode == VOIDmode)\n+\treturn NULL_RTX;\n+    }\n+  else\n+    {\n+      int offset = 0;\n+      if (FUNCTION_ARG_SIZE (mode, type) > 1 && (cum->words & 1))\n+\toffset = 1;\n+      if (cum->words + offset >= max_arg_words\n+\t  || mode == VOIDmode)\n+\treturn NULL_RTX;\n+    }\n+\n+  /* The 32bit ABIs and the 64bit ABIs are rather different,\n+     particularly in their handling of FP registers.  We might\n+     be able to cleverly share code between them, but I'm not\n+     going to bother in the hope that spltting them up results\n+     in code that is more easily understood. \n+\n+     The 64bit code probably is very wrong for structure passing.  */\n+  if (TARGET_64BIT)\n+    {\n+      /* Advance the base registers to their current locations.\n+\n+         Remember, gprs grow towards smaller register numbers while\n+\t fprs grow to higher register numbers.  Also remember FP regs\n+\t are always 4 bytes wide, while the size of an integer register\n+\t varies based on the size of the target word.  */\n+      gpr_reg_base = 26 - cum->words;\n+      fpr_reg_base = 32 + cum->words;\n+\t  \n+      /* If the argument is more than a word long, then we need to align\n+\t the base registers.  Same caveats as above.  */\n+      if (FUNCTION_ARG_SIZE (mode, type) > 1)\n+\t{\n+\t  if (mode != BLKmode)\n+\t    {\n+\t      /* First deal with alignment of the doubleword.  */\n+\t      gpr_reg_base -= (cum->words & 1);\n+\n+\t      /* This seems backwards, but it is what HP specifies.  We need\n+\t         gpr_reg_base to point to the smaller numbered register of\n+\t         the integer register pair.  So if we have an even register\n+\t          number, then decrement the gpr base.  */\n+\t      gpr_reg_base -= ((gpr_reg_base % 2) == 0);\n+\n+\t      /* FP values behave sanely, except that each FP reg is only\n+\t         half of word.  */\n+\t      fpr_reg_base += ((fpr_reg_base % 2) == 0);\n+            }\n+\t  else\n+\t    {\n+\t      rtx loc[8];\n+\t      int i, offset = 0, ub;\n+              ub = FUNCTION_ARG_SIZE (mode, type); \n+\t      ub = MIN(ub,\n+                       MAX(0, max_arg_words - cum->words - (cum->words & 1)));\n+\t      gpr_reg_base -= (cum->words & 1);\n+\t      for (i = 0; i < ub; i++)\n+\t\t{\n+\t\t  loc[i] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (DImode,\n+\t\t\t\t\t\t\t   gpr_reg_base),\n+\t\t\t\t\t      GEN_INT(offset));\n+\t\t  gpr_reg_base -= 1;\n+\t\t  offset += 8;\n+\t\t}\n+\t      if (ub == 0)\n+\t\treturn NULL_RTX;\n+\t      else if (ub == 1)\n+\t\treturn XEXP (loc[0], 0);\n+\t      else\n+\t\treturn gen_rtx_PARALLEL(mode, gen_rtvec_v(ub, loc));\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* If the argument is larger than a word, then we know precisely\n+\t which registers we must use.  */\n+      if (FUNCTION_ARG_SIZE (mode, type) > 1)\n+\t{\n+\t  if (cum->words)\n+\t    {\n+\t      gpr_reg_base = 23;\n+\t      fpr_reg_base = 38;\n+\t    }\n+\t  else\n+\t    {\n+\t      gpr_reg_base = 25;\n+\t      fpr_reg_base = 34;\n+\t    }\n+\t}\n+      else\n+        {\n+\t   /* We have a single word (32 bits).  A simple computation\n+\t      will get us the register #s we need.  */\n+\t   gpr_reg_base = 26 - cum->words;\n+\t   fpr_reg_base = 32 + 2 * cum->words;\n+\t}\n+    }\n+\n+  if (TARGET_64BIT && mode == TFmode)\n+    {\n+      return\n+\tgen_rtx_PARALLEL\n+\t  (mode,\n+\t   gen_rtvec (2,\n+\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t gen_rtx_REG (DImode, gpr_reg_base + 1),\n+\t\t\t\t\t const0_rtx),\n+\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t gen_rtx_REG (DImode, gpr_reg_base),\n+\t\t\t\t\t GEN_INT (8))));\n+    }\n+  /* Determine if the register needs to be passed in both general and\n+     floating point registers.  */\n+  if ((TARGET_PORTABLE_RUNTIME || TARGET_64BIT)\n+      /* If we are doing soft-float with portable runtime, then there\n+\t is no need to worry about FP regs.  */\n+      && ! TARGET_SOFT_FLOAT\n+      /* The parameter must be some kind of float, else we can just\n+\t pass it in integer registers.  */\n+      && FLOAT_MODE_P (mode)\n+      /* The target function must not have a prototype.  */\n+      && cum->nargs_prototype <= 0\n+      /* libcalls do not need to pass items in both FP and general\n+\t registers.  */\n+      && type != NULL_TREE\n+      /* All this hair applies to outgoing args only.  */\n+      && !incoming)\n+    {\n+      retval\n+\t= gen_rtx_PARALLEL\n+\t    (mode,\n+\t     gen_rtvec (2,\n+\t\t\tgen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t   gen_rtx_REG (mode, fpr_reg_base),\n+\t\t\t\t\t   const0_rtx),\n+\t\t\tgen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t   gen_rtx_REG (mode, gpr_reg_base),\n+\t\t\t\t\t   const0_rtx)));\n+    }\n+  else\n+    {\n+      /* See if we should pass this parameter in a general register.  */\n+      if (TARGET_SOFT_FLOAT\n+\t  /* Indirect calls in the normal 32bit ABI require all arguments\n+\t     to be passed in general registers.  */\n+\t  || (!TARGET_PORTABLE_RUNTIME\n+\t      && !TARGET_64BIT\n+\t      && cum->indirect)\n+\t  /* If the parameter is not a floating point parameter, then\n+\t     it belongs in GPRs.  */\n+\t  || !FLOAT_MODE_P (mode))\n+\tretval = gen_rtx_REG (mode, gpr_reg_base);\n+      else\n+\tretval = gen_rtx_REG (mode, fpr_reg_base);\n+    }\n+  return retval;\n+}\n+\n+\n+/* If this arg would be passed totally in registers or totally on the stack,\n+   then this routine should return zero. It is currently called only for\n+   the 64-bit target. */\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int max_arg_words = 8;\n+  int offset = 0;\n+\n+  if (FUNCTION_ARG_SIZE(mode, type) > 1 && (cum->words & 1))\n+    offset = 1;\n+\n+  if (cum->words + offset + FUNCTION_ARG_SIZE(mode, type) <= max_arg_words)\n+    /* Arg fits fully into registers. */\n+    return 0;\n+  else if (cum->words + offset >= max_arg_words) \n+    /* Arg fully on the stack. */\n+    return 0;\n+  else\n+    /* Arg is split. */\n+    return max_arg_words - cum->words - offset;\n+\n+}\n+\n+\n+/* Return 1 if this is a comparison operator.  This allows the use of\n+   MATCH_OPERATOR to recognize all the branch insns.  */\n+\n+int\n+cmpib_comparison_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+          && (GET_CODE (op) == EQ\n+\t      || GET_CODE (op) == NE\n+\t      || GET_CODE (op) == GT\n+\t      || GET_CODE (op) == GE\n+\t      || GET_CODE (op) == GTU\n+\t      || GET_CODE (op) == LT\n+\t      || GET_CODE (op) == LE\n+\t      || GET_CODE (op) == LEU));\n+}\n+\n /* Mark ARG (which is really a struct deferred_plabel **) for GC.  */\n \n static void"}, {"sha": "bd6cd31464ffa47ba137a2dddb2dda22629f7e9e", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 254, "deletions": 112, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -85,7 +85,10 @@ extern int target_flags;\n /* compile code for HP-PA 1.1 (\"Snake\") */\n \n #define MASK_PA_11 1\n+\n+#ifndef TARGET_PA_11\n #define TARGET_PA_11 (target_flags & MASK_PA_11)\n+#endif\n \n /* Disable all FP registers (they all become fixed).  This may be necessary\n    for compiling kernels which perform lazy context switching of FP regs.\n@@ -150,7 +153,14 @@ extern int target_flags;\n /* Generate code for the HPPA 2.0 architecture.  TARGET_PA_11 should also be\n    true when this is true.  */\n #define MASK_PA_20 4096\n+#ifndef TARGET_PA_20\n #define TARGET_PA_20 (target_flags & MASK_PA_20)\n+#endif\n+\n+/* Generate code for the HPPA 2.0 architecture in 64bit mode.  */\n+#ifndef TARGET_64BIT\n+#define TARGET_64BIT 0\n+#endif\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n@@ -248,17 +258,63 @@ extern int target_flags;\n   ((GET_CODE (X) == PLUS ? OFFSET : 0) \\\n     + (frame_pointer_needed ? 0 : compute_frame_size (get_frame_size (), 0)))\n \n+#define CPP_PA10_SPEC \"\"\n+#define CPP_PA11_SPEC \"-D_PA_RISC1_1 -D__hp9000s700\"\n+#define CPP_PA20_SPEC \"-D_PA_RISC2_0 -D__hp9000s800\"\n+#define CPP_64BIT_SPEC \"-D__LP64__ -D__LONG_MAX__=9223372036854775807L\"\n+\n #if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_PA_11) == 0\n-#define CPP_SPEC \"%{msnake:-D__hp9000s700 -D_PA_RISC1_1}\\\n- %{mpa-risc-1-1:-D__hp9000s700 -D_PA_RISC1_1}\\\n- %{!ansi: -D_HPUX_SOURCE -D_HIUX_SOURCE -D__STDC_EXT__}\\\n- %{threads:-D_REENTRANT -D_DCE_THREADS}\"\n+#define CPP_CPU_DEFAULT_SPEC \"%(cpp_pa10)\"\n+#endif\n+\n+#if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_PA_11) != 0\n+#if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_PA_20) != 0\n+#define CPP_CPU_DEFAULT_SPEC \"%(cpp_pa11) %(cpp_pa20)\"\n #else\n-#define CPP_SPEC \"%{!mpa-risc-1-0:%{!mnosnake:%{!msoft-float:-D__hp9000s700 -D_PA_RISC1_1}}} \\\n- %{!ansi: -D_HPUX_SOURCE -D_HIUX_SOURCE -D__STDC_EXT__}\\\n- %{threads:-D_REENTRANT -D_DCE_THREADS}\"\n+#define CPP_CPU_DEFAULT_SPEC \"%(cpp_pa11)\"\n+#endif\n+#endif\n+\n+#if TARGET_64BIT\n+#define CPP_64BIT_DEFAULT_SPEC \"%(cpp_64bit)\"\n+#else\n+#define CPP_64BIT_DEFAULT_SPEC \"\"\n+#endif\n+\n+/* This macro defines names of additional specifications to put in the\n+   specs that can be used in various specifications like CC1_SPEC.  Its\n+   definition is an initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   specification name, and a string constant that used by the GNU CC driver\n+   program.\n+\n+   Do not define this macro if it does not need to do anything.  */\n+\n+#ifndef SUBTARGET_EXTRA_SPECS\n+#define SUBTARGET_EXTRA_SPECS\n #endif\n \n+#define EXTRA_SPECS\t\t\t\t\t\t\t\\\n+  { \"cpp_pa10\", CPP_PA10_SPEC},\t\t\t\t\t\t\\\n+  { \"cpp_pa11\", CPP_PA11_SPEC},\t\t\t\t\t\t\\\n+  { \"cpp_pa20\", CPP_PA20_SPEC},\t\t\t\t\t\t\\\n+  { \"cpp_64bit\", CPP_64BIT_SPEC},\t\t\t\t\t\\\n+  { \"cpp_cpu_default\",\tCPP_CPU_DEFAULT_SPEC },\t\t\t\t\\\n+  { \"cpp_64bit_default\", CPP_64BIT_DEFAULT_SPEC },\t\t\t\\\n+  SUBTARGET_EXTRA_SPECS\n+\n+#define CPP_SPEC \"\\\n+%{mpa-risc-1-0:%(cpp_pa10)} \\\n+%{mpa-risc-1-1:%(cpp_pa11)} \\\n+%{msnake:%(cpp_pa11)} \\\n+%{mpa-risc-2-0:%(cpp_pa20)} \\\n+%{!mpa-risc-1-0:%{!mpa-risc-1-1:%{!mpa-risc-2-0:%{!msnake:%(cpp_cpu_default)}}}} \\\n+%{m64bit:%(cpp_64bit)} \\\n+%{!m64bit:%(cpp_64bit_default)} \\\n+%{!ansi: -D_HPUX_SOURCE -D_HIUX_SOURCE -D__STDC_EXT__}\\\n+%{threads:-D_REENTRANT -D_DCE_THREADS}\"\n+\n /* Defines for a K&R CC */\n \n #define CC1_SPEC \"%{pg:} %{p:}\"\n@@ -323,10 +379,14 @@ extern int target_flags;\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n+#define BITS_PER_WORD (TARGET_64BIT ? 64 : 32)\n+#define MAX_BITS_PER_WORD 64\n+#define MAX_LONG_TYPE_SIZE 64\n+#define MAX_WCHAR_TYPE_SIZE 32\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n+#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#define MIN_UNITS_PER_WORD 4\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n@@ -344,10 +404,10 @@ extern int target_flags;\n \n    GCC for the PA always rounds its stacks to a 512bit boundary,\n    but that happens late in the compilation process.  */\n-#define STACK_BOUNDARY 64\n+#define STACK_BOUNDARY (TARGET_64BIT ? 128 : 64)\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 32\n+#define FUNCTION_BOUNDARY (TARGET_64BIT ? 64 : 32)\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 32\n@@ -420,17 +480,19 @@ extern int target_flags;\n /* Register which holds offset table for position-independent\n    data references.  */\n \n-#define PIC_OFFSET_TABLE_REGNUM 19\n+#define PIC_OFFSET_TABLE_REGNUM (TARGET_64BIT ? 27 : 19)\n #define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED 1\n \n /* Register into which we save the PIC_OFFEST_TABLE_REGNUM so that it\n    can be restore across function calls.  */\n #define PIC_OFFSET_TABLE_REGNUM_SAVED 4\n \n-/* SOM ABI says that objects larger than 64 bits are returned in memory.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* SOM ABI says that objects larger than 64 bits are returned in memory.\n+   PA64 ABI says that objects larger than 128 bits are returned in memory. */\n #define RETURN_IN_MEMORY(TYPE)\t\\\n-  (int_size_in_bytes (TYPE) > 8)\n+  (TARGET_64BIT ? int_size_in_bytes (TYPE) > 16 : int_size_in_bytes (TYPE) > 8)\n \n /* Register in which address to store a structure value\n    is passed to a function.  */\n@@ -447,7 +509,9 @@ extern int target_flags;\n    `K' is used for values that can be moved with a zdepi insn.\n    `L' is used for the 5 bit constants.\n    `M' is used for 0.\n-   `N' is used for values with the least significant 11 bits equal to zero.\n+   `N' is used for values with the least significant 11 bits equal to zero\n+\t                  and when sign extended from 32 to 64 bits the\n+\t\t\t  value does not change.\n    `O' is used for numbers n such that n+1 is a power of 2.\n    */\n \n@@ -457,8 +521,10 @@ extern int target_flags;\n    : (C) == 'K' ? zdepi_cint_p (VALUE)\t\t\t\t\\\n    : (C) == 'L' ? VAL_5_BITS_P (VALUE)\t\t\t\t\\\n    : (C) == 'M' ? (VALUE) == 0\t\t\t\t\t\\\n-   : (C) == 'N' ? ((VALUE) & 0x7ff) == 0\t\t\t\\\n-   : (C) == 'O' ? (((VALUE) & ((VALUE) + 1)) == 0)\t\t\\\n+   : (C) == 'N' ? (((VALUE) & (unsigned long)0x7ff) == 0\t\\\n+\t\t   && (VALUE) == ((((VALUE) & 0xffffffff) ^ (~0x7fffffff)) \\\n+\t\t\t\t  + 0x80000000))\t\t\\\n+   : (C) == 'O' ? (((VALUE) & ((VALUE) + (long)1)) == 0)\t\\\n    : (C) == 'P' ? and_mask_p (VALUE)\t\t\t\t\\\n    : 0)\n \n@@ -542,11 +608,11 @@ extern int target_flags;\n    argument, not it's beginning.  To get the real offset of the first\n    argument, the size of the argument must be added.  */\n \n-#define FIRST_PARM_OFFSET(FNDECL) -32\n+#define FIRST_PARM_OFFSET(FNDECL) (TARGET_64BIT ? -64 : -32)\n \n /* When a parameter is passed in a register, stack space is still\n    allocated for it.  */\n-#define REG_PARM_STACK_SPACE(DECL) 16\n+#define REG_PARM_STACK_SPACE(DECL) (TARGET_64BIT ? 64 : 16)\n \n /* Define this if the above stack space is to be considered part of the\n    space allocated by the caller.  */\n@@ -562,10 +628,13 @@ extern int target_flags;\n    the stack: 16 bytes for register saves, and 32 bytes for magic.\n    This is the difference between the logical top of stack and the\n    actual sp. */\n-#define STACK_POINTER_OFFSET -32\n+#define STACK_POINTER_OFFSET \\\n+  (TARGET_64BIT ? -(current_function_outgoing_args_size + 16): -32)\n \n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n-  ((STACK_POINTER_OFFSET) - current_function_outgoing_args_size)\n+  (TARGET_64BIT\t\t\t\t\\\n+   ? (STACK_POINTER_OFFSET)\t\t\\\n+   : ((STACK_POINTER_OFFSET) - current_function_outgoing_args_size))\n \n /* Value is 1 if returning from a function call automatically\n    pops the arguments described by the number-of-args field in the call.\n@@ -583,11 +652,14 @@ extern int target_flags;\n /* On the HP-PA the value is found in register(s) 28(-29), unless\n    the mode is SF or DF. Then the value is returned in fr4 (32, ) */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), ((! TARGET_SOFT_FLOAT\t\t     \\\n-\t\t\t\t      && (TYPE_MODE (VALTYPE) == SFmode ||  \\\n-\t\t\t\t\t  TYPE_MODE (VALTYPE) == DFmode)) ? \\\n-\t\t\t\t     32 : 28))\n+/* This must perform the same promotions as PROMOTE_MODE, else\n+   PROMOTE_FUNCTION_RETURN will not work correctly.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n+  gen_rtx_REG (((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\\\n+\t\t && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n+\t\t|| POINTER_TYPE_P (VALTYPE))\t\t\t\\\n+\t       ? word_mode : TYPE_MODE (VALTYPE),\t\t\\\n+\t       TREE_CODE (VALTYPE) == REAL_TYPE && !TARGET_SOFT_FLOAT ? 32 : 28)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n@@ -712,54 +784,20 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n /* Do not expect to understand this without reading it several times.  I'm\n    tempted to try and simply it, but I worry about breaking something.  */\n \n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t      \t\t\\\n-  (4 >= ((CUM).words + FUNCTION_ARG_SIZE ((MODE), (TYPE)))\t\t\\\n-   ? (!TARGET_PORTABLE_RUNTIME || (TYPE) == 0\t\t\t\t\\\n-      || !FLOAT_MODE_P (MODE) || TARGET_SOFT_FLOAT\t\t\t\\\n-      || (CUM).nargs_prototype > 0)\t\t\t\t\t\\\n-      ? gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t\t     (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n-\t\t      ? (((!(CUM).indirect \t\t\t\t\\\n-\t\t\t   || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n-\t\t\t  && (MODE) == DFmode\t\t\t\t\\\n-\t\t\t  && ! TARGET_SOFT_FLOAT)\t\t\t\\\n-\t\t\t ? ((CUM).words ? 38 : 34)\t\t\t\\\n-\t\t\t : ((CUM).words ? 23 : 25))\t\t\t\\\n-\t\t      : (((!(CUM).indirect\t\t\t\t\\\n-\t\t\t   || TARGET_PORTABLE_RUNTIME)\t\t\t\\\n-\t\t\t  && (MODE) == SFmode\t\t\t\t\\\n-\t\t\t  && ! TARGET_SOFT_FLOAT)\t\t\t\\\n-\t\t\t ? (32 + 2 * (CUM).words)\t\t\t\\\n-\t\t\t : (27 - (CUM).words - FUNCTION_ARG_SIZE ((MODE),\\\n-\t\t\t\t\t\t\t\t  (TYPE))))))\\\n-   /* We are calling a non-prototyped function with floating point\t\\\n-      arguments using the portable conventions.  */\t\t\t\\\n-   : (gen_rtx_PARALLEL\t\t\t\t\t\t\t\\\n-      ((MODE),\t\t\t\t\t\t\t\t\\\n-       gen_rtvec\t\t\t\t\t\t\t\\\n-       (2,\t\t\t\t\t\t\t\t\\\n-\tgen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n-\t(VOIDmode,\t\t\t\t\t\t\t\\\n-\t gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t\t      (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1 \t\t\\\n-\t\t       ? ((CUM).words ? 38 : 34) : (32 + 2 * (CUM).words))), \\\n-\t const0_rtx),\t\t\t\t\t\t\t\\\n-\tgen_rtx_EXPR_LIST\t\t\t\t\t\t\\\n-\t(VOIDmode,\t\t\t\t\t\t\t\\\n-\t gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t\t      (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n-\t\t       ? ((CUM).words ? 23 : 25)\t\t\t\\\n-\t\t       : (27 - (CUM).words -\t\t\t\t\\\n-\t\t\t  FUNCTION_ARG_SIZE ((MODE), (TYPE))))),\t\\\n-\t const0_rtx))))\t\t\t\t\t\t\t\\\n-      /* Pass this parameter in the stack.  */\t\t\t\t\\\n-      : 0)\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, NAMED, 0)\n+\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, NAMED, 1)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+/* For PA32 there are never split arguments. PA64, on the other hand, can\n+   pass arguments partially in registers and partially in memory. */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  (TARGET_64BIT ? function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED) : 0)\n \n /* If defined, a C expression that gives the alignment boundary, in\n    bits, of an argument with the specified mode and type.  If it is\n@@ -777,13 +815,21 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n \n /* Arguments larger than eight bytes are passed by invisible reference */\n \n+/* PA64 does not pass anything by invisible reference. */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (((TYPE) && int_size_in_bytes (TYPE) > 8)\t\t\t\t\\\n-   || ((MODE) && GET_MODE_SIZE (MODE) > 8))\n+  (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n+   ? 0\t\t\t\t\t\t\t\t\t\\\n+   : (((TYPE) && int_size_in_bytes (TYPE) > 8)\t\t\t\t\\\n+      || ((MODE) && GET_MODE_SIZE (MODE) > 8)))\n  \n+/* PA64 does not pass anything by invisible reference.\n+   This should be undef'ed for 64bit, but we'll see if this works. The\n+   problem is that we can't test TARGET_64BIT from the preprocessor. */\n #define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n-  (((TYPE) && int_size_in_bytes (TYPE) > 8)\t\t   \\\n-   || ((MODE) && GET_MODE_SIZE (MODE) > 8))\n+  (TARGET_64BIT\t\t\t\t\t\t\t\\\n+   ? 0\t\t\t\t\t\t\t\t\\\n+   : (((TYPE) && int_size_in_bytes (TYPE) > 8)\t\t\t\\\n+      || ((MODE) && GET_MODE_SIZE (MODE) > 8)))\n \n \f\n extern struct rtx_def *hppa_compare_op0, *hppa_compare_op1;\n@@ -869,22 +915,40 @@ extern int may_call_alloca;\n    It is best to keep this as small as possible to avoid having to\n    flush multiple lines in the cache.  */\n \n-#define TRAMPOLINE_TEMPLATE(FILE) \\\n-  {\t\t\t\t\t\t\t\\\n-    fputs (\"\\tldw\t36(%r22),%r21\\n\", FILE);\t\\\n-    fputs (\"\\tbb,>=,n\t%r21,30,.+16\\n\", FILE);\t\\\n-    if (ASSEMBLER_DIALECT == 0)\t\t\t\t\\\n-      fputs (\"\\tdepi\t0,31,2,%r21\\n\", FILE);\t\t\\\n-    else\t\t\t\t\t\t\\\n-      fputs (\"\\tdepwi\t0,31,2,%r21\\n\", FILE);\t\t\\\n-    fputs (\"\\tldw\t4(%r21),%r19\\n\", FILE);\t\\\n-    fputs (\"\\tldw\t0(%r21),%r21\\n\", FILE);\t\\\n-    fputs (\"\\tldsid\t(%r21),%r1\\n\", FILE);\t\\\n-    fputs (\"\\tmtsp\t%r1,%sr0\\n\", FILE);\t\t\\\n-    fputs (\"\\tbe\t0(%sr0,%r21)\\n\", FILE);\t\\\n-    fputs (\"\\tldw\t40(%r22),%r29\\n\", FILE);\t\\\n-    fputs (\"\\t.word\t0\\n\", FILE);\t\t\t\\\n-    fputs (\"\\t.word\t0\\n\", FILE);\t\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE) \t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (! TARGET_64BIT)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfputs (\"\\tldw\t36(%r22),%r21\\n\", FILE);\t\t\t\\\n+\tfputs (\"\\tbb,>=,n\t%r21,30,.+16\\n\", FILE);\t\t\t\\\n+\tif (ASSEMBLER_DIALECT == 0)\t\t\t\t\t\\\n+\t  fputs (\"\\tdepi\t0,31,2,%r21\\n\", FILE);\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  fputs (\"\\tdepwi\t0,31,2,%r21\\n\", FILE);\t\t\t\\\n+\tfputs (\"\\tldw\t4(%r21),%r19\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tldw\t0(%r21),%r21\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tldsid\t(%r21),%r1\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tmtsp\t%r1,%sr0\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tbe\t0(%sr0,%r21)\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tldw\t40(%r22),%r29\\n\", FILE);\t\t\t\\\n+\tfputs (\"\\t.word\t0\\n\", FILE);\t\t\t\t\t\\\n+\tfputs (\"\\t.word\t0\\n\", FILE);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfputs (\"\\t.dword 0\\n\", FILE);\t\t\t\t\t\\\n+\tfputs (\"\\t.dword 0\\n\", FILE);\t\t\t\t\t\\\n+\tfputs (\"\\t.dword 0\\n\", FILE);\t\t\t\t\t\\\n+\tfputs (\"\\t.dword 0\\n\", FILE);\t\t\t\t\t\\\n+\tfputs (\"\\tmfia\t%r31\\n\", FILE);\t\t\t\t\t\\\n+\tfputs (\"\\tldd\t24(%r31),%r1\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tldd\t24(%r1),%r27\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tldd\t16(%r1),%r1\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tbve\t(%r1)\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\tldd\t32(%r31),%r31\\n\", FILE);\t\t\t\\\n+\tfputs (\"\\t.dword 0  ; fptr\\n\", FILE);\t\t\t\t\\\n+\tfputs (\"\\t.dword 0  ; static link\\n\", FILE);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   }\n \n /* Length in units of the trampoline for entering a nested function.\n@@ -896,7 +960,7 @@ extern int may_call_alloca;\n    If the code part of the trampoline ever grows to > 32 bytes, then it\n    will become necessary to hack on the cacheflush pattern in pa.md.  */\n \n-#define TRAMPOLINE_SIZE (11 * 4)\n+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 11 * 4)\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n@@ -905,22 +969,49 @@ extern int may_call_alloca;\n    Move the function address to the trampoline template at offset 12.\n    Move the static chain value to trampoline template at offset 16.  */\n \n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  rtx start_addr, end_addr;\t\t\t\t\t\t\\\n+  if (! TARGET_64BIT)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx start_addr, end_addr;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 36));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (FNADDR));\t\\\n+      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 40));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n+      /* fdc and fic only use registers for the address to flush,\t\\\n+\t they do not accept integer displacements.  */ \t\t\t\\\n+      start_addr = force_reg (Pmode, (TRAMP));\t\t\t\t\\\n+      end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\\\n+      emit_insn (gen_dcacheflush (start_addr, end_addr));\t\t\\\n+      end_addr = force_reg (Pmode, plus_constant (start_addr, 32));\t\\\n+      emit_insn (gen_icacheflush (start_addr, end_addr, start_addr,\t\\\n+\t\t\t\t  gen_reg_rtx (Pmode), gen_reg_rtx (Pmode)));\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx start_addr, end_addr;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  start_addr = memory_address (Pmode, plus_constant ((TRAMP), 36));\t\\\n-  emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (FNADDR));\t\t\\\n-  start_addr = memory_address (Pmode, plus_constant ((TRAMP), 40));\t\\\n-  emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n-  /* fdc and fic only use registers for the address to flush,\t\t\\\n-     they do not accept integer displacements.  */ \t\t\t\\\n-  start_addr = force_reg (Pmode, (TRAMP));\t\t\t\t\\\n-  end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\t\\\n-  emit_insn (gen_dcacheflush (start_addr, end_addr));\t\t\t\\\n-  end_addr = force_reg (Pmode, plus_constant (start_addr, 32));\t\\\n-  emit_insn (gen_icacheflush (start_addr, end_addr, start_addr,\t\t\\\n-\t\t\t      gen_reg_rtx (Pmode), gen_reg_rtx (Pmode)));\\\n+      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 56));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (FNADDR));\t\\\n+      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 64));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n+      /* Create a fat pointer for the trampoline. */\t\t\t\\\n+      end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\\\n+      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 16));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), end_addr);\t\\\n+      end_addr = gen_rtx_REG (Pmode, 27);\t\t\t\t\\\n+      start_addr = memory_address (Pmode, plus_constant ((TRAMP), 24));\t\\\n+      emit_move_insn (gen_rtx_MEM (Pmode, start_addr), end_addr);\t\\\n+      /* fdc and fic only use registers for the address to flush,\t\\\n+\t they do not accept integer displacements.  */ \t\t\t\\\n+      start_addr = force_reg (Pmode, (TRAMP));\t\t\t\t\\\n+      end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\\\n+      emit_insn (gen_dcacheflush (start_addr, end_addr));\t\t\\\n+      end_addr = force_reg (Pmode, plus_constant (start_addr, 32));\t\\\n+      emit_insn (gen_icacheflush (start_addr, end_addr, start_addr,\t\\\n+\t\t\t\t  gen_reg_rtx (Pmode), gen_reg_rtx (Pmode)));\\\n+    }\t\t\t\t\t\t\t\t\t\\\n }\n \n /* Emit code for a call to builtin_saveregs.  We must emit USE insns which\n@@ -995,17 +1086,30 @@ extern int may_call_alloca;\n /* Include all constant integers and constant doubles, but not\n    floating-point, except for floating-point zero.\n \n-   Reject LABEL_REFs if we're not using gas or the new HP assembler.  */\n+   Reject LABEL_REFs if we're not using gas or the new HP assembler. \n+\n+   ?!? For now also reject CONST_DOUBLES in 64bit mode.  This will need\n+   further work.  */\n #ifdef NEW_HP_ASSEMBLER\n #define LEGITIMATE_CONSTANT_P(X)  \t\t\\\n   ((GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n     || (X) == CONST0_RTX (GET_MODE (X)))\t\\\n+   && !(TARGET_64BIT && GET_CODE (X) == CONST_DOUBLE) \\\n+   && !(TARGET_64BIT && GET_CODE (X) == CONST_INT \\\n+\t&& !(cint_ok_for_move (INTVAL (X))\t\\\n+\t     || ((INTVAL (X) & 0xffffffff80000000L) == 0xffffffff80000000L) \\\n+\t     || ((INTVAL (X) & 0xffffffff00000000L) == 0x0000000000000000L))) \\\n    && !function_label_operand (X, VOIDmode))\n #else\n #define LEGITIMATE_CONSTANT_P(X)  \t\t\\\n   ((GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n     || (X) == CONST0_RTX (GET_MODE (X)))\t\\\n    && (GET_CODE (X) != LABEL_REF || TARGET_GAS)\\\n+   && !(TARGET_64BIT && GET_CODE (X) == CONST_DOUBLE) \\\n+   && !(TARGET_64BIT && GET_CODE (X) == CONST_INT \\\n+\t&& !(cint_ok_for_move (INTVAL (X))\t\\\n+\t     || ((INTVAL (X) & 0xffffffff80000000L) == 0xffffffff80000000L) \\\n+\t     || ((INTVAL (X) & 0xffffffff00000000L) == 0x0000000000000000L))) \\\n    && !function_label_operand (X, VOIDmode))\n #endif\n \n@@ -1064,8 +1168,11 @@ extern int may_call_alloca;\n        && !(GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n \t    && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\\\n \t\t|| GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT)))\\\n+   : ((C) == 'U' ?\t\t\t\t\t\\\n+      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 63)\t\\\n    : ((C) == 'S' ?\t\t\t\t\t\\\n-      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 31) : 0))))\n+      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 31) : 0)))))\n+\t\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -1115,16 +1222,16 @@ extern int may_call_alloca;\n    doing so avoids losing for loading/storing a FP register at an address\n    which will not fit in 5 bits.  */\n \n-#define VAL_5_BITS_P(X) ((unsigned)(X) + 0x10 < 0x20)\n+#define VAL_5_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x10 < 0x20)\n #define INT_5_BITS(X) VAL_5_BITS_P (INTVAL (X))\n \n-#define VAL_U5_BITS_P(X) ((unsigned)(X) < 0x20)\n+#define VAL_U5_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) < 0x20)\n #define INT_U5_BITS(X) VAL_U5_BITS_P (INTVAL (X))\n \n-#define VAL_11_BITS_P(X) ((unsigned)(X) + 0x400 < 0x800)\n+#define VAL_11_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x400 < 0x800)\n #define INT_11_BITS(X) VAL_11_BITS_P (INTVAL (X))\n \n-#define VAL_14_BITS_P(X) ((unsigned)(X) + 0x2000 < 0x4000)\n+#define VAL_14_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x2000 < 0x4000)\n #define INT_14_BITS(X) VAL_14_BITS_P (INTVAL (X))\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n@@ -1414,8 +1521,13 @@ while (0)\n \n /* Higher than the default as we prefer to use simple move insns\n    (better scheduling and delay slot filling) and because our\n-   built-in block move is really a 2X unrolled loop.  */\n-#define MOVE_RATIO 4\n+   built-in block move is really a 2X unrolled loop. \n+\n+   Believe it or not, this has to be big enough to allow for copying all\n+   arguments passed in registers to avoid infinite recursion during argument\n+   setup for a function call.  Why?  Consider how we copy the stack slots\n+   reserved for parameters when they may be trashed by a call.  */\n+#define MOVE_RATIO (TARGET_64BIT ? 8 : 4)\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n@@ -1441,6 +1553,7 @@ while (0)\n \n /* When a prototype says `char' or `short', really pass an `int'.  */\n #define PROMOTE_PROTOTYPES 1\n+#define PROMOTE_FUNCTION_RETURN 1\n \n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n@@ -1867,6 +1980,35 @@ while (0)\n /* The number of Pmode words for the setjmp buffer.  */\n #define JMP_BUF_SIZE 50\n \n+/* Only direct calls to static functions are allowed to be sibling (tail)\n+   call optimized.\n+\n+   This restriction is necessary because some linker generated stubs will\n+   store return pointers into rp' in some cases which might clobber a\n+   live value already in rp'.\n+\n+   In a sibcall the current function and the target function share stack\n+   space.  Thus if the path to the current function and the path to the\n+   target function save a value in rp', they save the value into the\n+   same stack slot, which has undesirable consequences.\n+\n+   Because of the deferred binding nature of shared libraries any function\n+   with external scope could be in a different load module and thus require\n+   rp' to be saved when calling that function.  So sibcall optimizations\n+   can only be safe for static function.\n+\n+   Note that GCC never needs return value relocations, so we don't have to\n+   worry about static calls with return value relocations (which require\n+   saving rp').\n+\n+   It is safe to perform a sibcall optimization when the target function\n+   will never return.  */\n+#define FUNCTION_OK_FOR_SIBCALL(DECL) \\\n+  (DECL \\\n+   && ! TARGET_64BIT \\\n+   && (! TREE_PUBLIC (DECL) \\\n+       || TREE_THIS_VOLATILE (DECL)))\n+\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"call_operand_address\", {LABEL_REF, SYMBOL_REF, CONST_INT,\t\t\\"}, {"sha": "45045875ffb7693dc710b7204bf06d5175d1e491", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 1511, "deletions": 70, "changes": 1581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -409,6 +409,20 @@\n ;; emit RTL for both the compare and the branch.\n ;;\n \n+(define_expand \"cmpdi\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (match_operand:DI 0 \"reg_or_0_operand\" \"\")\n+\t\t    (match_operand:DI 1 \"register_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+\n+  \"\n+{\n+ hppa_compare_op0 = operands[0];\n+ hppa_compare_op1 = operands[1];\n+ hppa_branch_type = CMP_SI;\n+ DONE;\n+}\")\n+\n (define_expand \"cmpsi\"\n   [(set (reg:CC 0)\n \t(compare:CC (match_operand:SI 0 \"reg_or_0_operand\" \"\")\n@@ -474,7 +488,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(eq:SI (match_dup 1)\n \t       (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   /* fp scc patterns rarely match, and are not a win on the PA.  */\n@@ -490,7 +504,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ne:SI (match_dup 1)\n \t       (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   /* fp scc patterns rarely match, and are not a win on the PA.  */\n@@ -504,7 +518,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(lt:SI (match_dup 1)\n \t       (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   /* fp scc patterns rarely match, and are not a win on the PA.  */\n@@ -518,7 +532,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(gt:SI (match_dup 1)\n \t       (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   /* fp scc patterns rarely match, and are not a win on the PA.  */\n@@ -532,7 +546,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(le:SI (match_dup 1)\n \t       (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   /* fp scc patterns rarely match, and are not a win on the PA.  */\n@@ -546,7 +560,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ge:SI (match_dup 1)\n \t       (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   /* fp scc patterns rarely match, and are not a win on the PA.  */\n@@ -560,7 +574,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ltu:SI (match_dup 1)\n \t        (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   if (hppa_branch_type != CMP_SI)\n@@ -573,7 +587,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(gtu:SI (match_dup 1)\n \t        (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   if (hppa_branch_type != CMP_SI)\n@@ -586,7 +600,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(leu:SI (match_dup 1)\n \t        (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   if (hppa_branch_type != CMP_SI)\n@@ -599,7 +613,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(geu:SI (match_dup 1)\n \t        (match_dup 2)))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   if (hppa_branch_type != CMP_SI)\n@@ -621,6 +635,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operator:DI 3 \"comparison_operator\"\n+\t\t\t   [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:DI 2 \"arith11_operand\" \"rI\")]))]\n+  \"TARGET_64BIT\"\n+  \"cmp%I2clr,*%B3 %2,%1,%0\\;ldi 1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"iorscc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ior:SI (match_operator:SI 3 \"comparison_operator\"\n@@ -634,6 +658,19 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"12\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operator:DI 3 \"comparison_operator\"\n+\t\t\t\t   [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:DI 2 \"arith11_operand\" \"rI\")])\n+\t\t(match_operator:DI 6 \"comparison_operator\"\n+\t\t\t\t   [(match_operand:DI 4 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:DI 5 \"arith11_operand\" \"rI\")])))]\n+  \"TARGET_64BIT\"\n+  \"cmp%I2clr,*%S3 %2,%1,%%r0\\;cmp%I5clr,*%B6 %5,%4,%0\\;ldi 1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"12\")])\n+\n ;; Combiner patterns for common operations performed with the output\n ;; from an scc insn (negscc and incscc).\n (define_insn \"negscc\"\n@@ -646,6 +683,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_operator:DI 3 \"comparison_operator\"\n+\t       [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:DI 2 \"arith11_operand\" \"rI\")])))]\n+  \"TARGET_64BIT\"\n+  \"cmp%I2clr,*%B3 %2,%1,%0\\;ldi -1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ;; Patterns for adding/subtracting the result of a boolean expression from\n ;; a register.  First we have special patterns that make use of the carry\n ;; bit, and output only two instructions.  For the cases we can't in\n@@ -662,6 +709,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (leu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t (match_operand:DI 3 \"arith11_operand\" \"rI\"))\n+\t\t (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"sub%I3 %3,%2,%%r0\\;add,dc %%r0,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ; This need only accept registers for op3, since canonicalization\n ; replaces geu with gtu when op3 is an integer.\n (define_insn \"\"\n@@ -674,6 +731,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (geu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t (match_operand:DI 3 \"register_operand\" \"r\"))\n+\t\t (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"sub %2,%3,%%r0\\;add,dc %%r0,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ; Match only integers for op3 here.  This is used as canonical form of the\n ; geu pattern when op3 is an integer.  Don't match registers since we can't\n ; make better code than the general incscc pattern.\n@@ -687,6 +754,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (gtu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t (match_operand:DI 3 \"int11_operand\" \"I\"))\n+\t\t (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"addi %k3,%2,%%r0\\;add,dc %%r0,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"incscc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n  \t(plus:SI (match_operator:SI 4 \"comparison_operator\"\n@@ -700,6 +777,19 @@\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"8,12\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+ \t(plus:DI (match_operator:DI 4 \"comparison_operator\"\n+\t\t    [(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:DI 3 \"arith11_operand\" \"rI,rI\")])\n+\t\t (match_operand:DI 1 \"register_operand\" \"0,?r\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   cmp%I3clr,*%B4 %3,%2,%%r0\\;addi 1,%0,%0\n+   cmp%I3clr,*%B4 %3,%2,%%r0\\;addi,tr 1,%1,%0\\;copy %1,%0\"\n+  [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"length\" \"8,12\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -710,6 +800,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (gtu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"arith11_operand\" \"rI\"))))]\n+  \"TARGET_64BIT\"\n+  \"sub%I3 %3,%2,%%r0\\;sub,db %1,%%r0,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -721,6 +821,17 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t    (gtu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:DI 3 \"arith11_operand\" \"rI\")))\n+\t\t  (match_operand:DI 4 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"sub%I3 %3,%2,%%r0\\;sub,db %1,%4,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ; This need only accept registers for op3, since canonicalization\n ; replaces ltu with leu when op3 is an integer.\n (define_insn \"\"\n@@ -733,6 +844,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (ltu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"register_operand\" \"r\"))))]\n+  \"TARGET_64BIT\"\n+  \"sub %2,%3,%%r0\\;sub,db %1,%%r0,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -744,6 +865,17 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t    (ltu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:DI 3 \"register_operand\" \"r\")))\n+\t\t  (match_operand:DI 4 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"sub %2,%3,%%r0\\;sub,db %1,%4,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ; Match only integers for op3 here.  This is used as canonical form of the\n ; ltu pattern when op3 is an integer.  Don't match registers since we can't\n ; make better code than the general incscc pattern.\n@@ -757,6 +889,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (leu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"int11_operand\" \"I\"))))]\n+  \"TARGET_64BIT\"\n+  \"addi %k3,%2,%%r0\\;sub,db %1,%%r0,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -768,6 +910,17 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t    (leu:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:DI 3 \"int11_operand\" \"I\")))\n+\t\t  (match_operand:DI 4 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"addi %k3,%2,%%r0\\;sub,db %1,%4,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"decscc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,?r\")\n@@ -781,6 +934,19 @@\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"8,12\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,?r\")\n+\t\t  (match_operator:DI 4 \"comparison_operator\"\n+\t\t     [(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t      (match_operand:DI 3 \"arith11_operand\" \"rI,rI\")])))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   cmp%I3clr,*%B4 %3,%2,%%r0\\;addi -1,%0,%0\n+   cmp%I3clr,*%B4 %3,%2,%%r0\\;addi,tr -1,%1,%0\\;copy %1,%0\"\n+  [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"length\" \"8,12\")])\n+\n ; Patterns for max and min.  (There is no need for an earlyclobber in the\n ; last alternative since the middle alternative will match if op0 == op1.)\n \n@@ -796,6 +962,18 @@\n [(set_attr \"type\" \"multi,multi,multi\")\n  (set_attr \"length\" \"8,8,8\")])\n \n+(define_insn \"smindi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(smin:DI (match_operand:DI 1 \"register_operand\" \"%0,0,r\")\n+\t\t (match_operand:DI 2 \"arith11_operand\" \"r,I,M\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+  cmpclr,*> %2,%0,%%r0\\;copy %2,%0\n+  cmpiclr,*> %2,%0,%%r0\\;ldi %2,%0\n+  cmpclr,*> %1,%r2,%0\\;copy %1,%0\"\n+[(set_attr \"type\" \"multi,multi,multi\")\n+ (set_attr \"length\" \"8,8,8\")])\n+\n (define_insn \"uminsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(umin:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n@@ -807,6 +985,17 @@\n [(set_attr \"type\" \"multi,multi\")\n  (set_attr \"length\" \"8,8\")])\n \n+(define_insn \"umindi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(umin:DI (match_operand:DI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:DI 2 \"arith11_operand\" \"r,I\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+  cmpclr,*>> %2,%0,%%r0\\;copy %2,%0\n+  cmpiclr,*>> %2,%0,%%r0\\;ldi %2,%0\"\n+[(set_attr \"type\" \"multi,multi\")\n+ (set_attr \"length\" \"8,8\")])\n+\n (define_insn \"smaxsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(smax:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n@@ -819,6 +1008,18 @@\n [(set_attr \"type\" \"multi,multi,multi\")\n  (set_attr \"length\" \"8,8,8\")])\n \n+(define_insn \"smaxdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(smax:DI (match_operand:DI 1 \"register_operand\" \"%0,0,r\")\n+\t\t (match_operand:DI 2 \"arith11_operand\" \"r,I,M\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+  cmpclr,*< %2,%0,%%r0\\;copy %2,%0\n+  cmpiclr,*< %2,%0,%%r0\\;ldi %2,%0\n+  cmpclr,*< %1,%r2,%0\\;copy %1,%0\"\n+[(set_attr \"type\" \"multi,multi,multi\")\n+ (set_attr \"length\" \"8,8,8\")])\n+\n (define_insn \"umaxsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(umax:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n@@ -830,6 +1031,17 @@\n [(set_attr \"type\" \"multi,multi\")\n  (set_attr \"length\" \"8,8\")])\n \n+(define_insn \"umaxdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(umax:DI (match_operand:DI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:DI 2 \"arith11_operand\" \"r,I\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+  cmpclr,*<< %2,%0,%%r0\\;copy %2,%0\n+  cmpiclr,*<< %2,%0,%%r0\\;ldi %2,%0\"\n+[(set_attr \"type\" \"multi,multi\")\n+ (set_attr \"length\" \"8,8\")])\n+\n (define_insn \"abssi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(abs:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n@@ -838,6 +1050,14 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"absdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(abs:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"or,*>= %%r0,%1,%0\\;subi 0,%0,%0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n ;;; Experimental conditional move patterns\n \n (define_expand \"movsicc\"\n@@ -856,6 +1076,10 @@\n   if (hppa_branch_type != CMP_SI)\n     FAIL;\n \n+  if (GET_MODE (hppa_compare_op0) != GET_MODE (hppa_compare_op1)\n+      || GET_MODE (hppa_compare_op0) != GET_MODE (operands[0]))\n+    FAIL;\n+\n   /* operands[1] is currently the result of compare_from_rtx.  We want to\n      emit a compare of the original operands.  */\n   operands[1] = gen_rtx_fmt_ee (code, SImode, hppa_compare_op0, hppa_compare_op1);\n@@ -909,6 +1133,74 @@\n   [(set_attr \"type\" \"multi,multi,multi,nullshift,multi,multi,multi,nullshift\")\n    (set_attr \"length\" \"8,8,8,8,8,8,8,8\")])\n \n+(define_expand \"movdicc\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(if_then_else:DI\n+\t (match_operator 1 \"comparison_operator\"\n+\t    [(match_dup 4)\n+\t     (match_dup 5)])\n+\t (match_operand:DI 2 \"reg_or_cint_move_operand\" \"\")\n+\t (match_operand:DI 3 \"reg_or_cint_move_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+\n+  if (hppa_branch_type != CMP_SI)\n+    FAIL;\n+\n+  if (GET_MODE (hppa_compare_op0) != GET_MODE (hppa_compare_op1)\n+      || GET_MODE (hppa_compare_op0) != GET_MODE (operands[0]))\n+    FAIL;\n+\n+  /* operands[1] is currently the result of compare_from_rtx.  We want to\n+     emit a compare of the original operands.  */\n+  operands[1] = gen_rtx_fmt_ee (code, DImode, hppa_compare_op0, hppa_compare_op1);\n+  operands[4] = hppa_compare_op0;\n+  operands[5] = hppa_compare_op1;\n+}\")\n+\n+; We need the first constraint alternative in order to avoid\n+; earlyclobbers on all other alternatives.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(if_then_else:DI\n+\t (match_operator 5 \"comparison_operator\"\n+\t    [(match_operand:DI 3 \"register_operand\" \"r,r,r,r,r\")\n+\t     (match_operand:DI 4 \"arith11_operand\" \"rI,rI,rI,rI,rI\")])\n+\t (match_operand:DI 1 \"reg_or_cint_move_operand\" \"0,r,J,N,K\")\n+\t (const_int 0)))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   cmp%I4clr,*%S5 %4,%3,%%r0\\;ldi 0,%0\n+   cmp%I4clr,*%B5 %4,%3,%0\\;copy %1,%0\n+   cmp%I4clr,*%B5 %4,%3,%0\\;ldi %1,%0\n+   cmp%I4clr,*%B5 %4,%3,%0\\;ldil L'%1,%0\n+   cmp%I4clr,*%B5 %4,%3,%0\\;depdi,z %z1,%0\"\n+  [(set_attr \"type\" \"multi,multi,multi,multi,nullshift\")\n+   (set_attr \"length\" \"8,8,8,8,8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r,r,r,r,r\")\n+\t(if_then_else:DI\n+\t (match_operator 5 \"comparison_operator\"\n+\t    [(match_operand:DI 3 \"register_operand\" \"r,r,r,r,r,r,r,r\")\n+\t     (match_operand:DI 4 \"arith11_operand\" \"rI,rI,rI,rI,rI,rI,rI,rI\")])\n+\t (match_operand:DI 1 \"reg_or_cint_move_operand\" \"0,0,0,0,r,J,N,K\")\n+\t (match_operand:DI 2 \"reg_or_cint_move_operand\" \"r,J,N,K,0,0,0,0\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   cmp%I4clr,*%S5 %4,%3,%%r0\\;copy %2,%0\n+   cmp%I4clr,*%S5 %4,%3,%%r0\\;ldi %2,%0\n+   cmp%I4clr,*%S5 %4,%3,%%r0\\;ldil L'%2,%0\n+   cmp%I4clr,*%S5 %4,%3,%%r0\\;depdi,z %z2,%0\n+   cmp%I4clr,*%B5 %4,%3,%%r0\\;copy %1,%0\n+   cmp%I4clr,*%B5 %4,%3,%%r0\\;ldi %1,%0\n+   cmp%I4clr,*%B5 %4,%3,%%r0\\;ldil L'%1,%0\n+   cmp%I4clr,*%B5 %4,%3,%%r0\\;depdi,z %z1,%0\"\n+  [(set_attr \"type\" \"multi,multi,multi,nullshift,multi,multi,multi,nullshift\")\n+   (set_attr \"length\" \"8,8,8,8,8,8,8,8\")])\n+\n ;; Conditional Branches\n \n (define_expand \"beq\"\n@@ -1136,6 +1428,113 @@\n \t   (const_int 20)]\n \t  (const_int 28)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"comparison_operator\"\n+\t\t\t [(match_operand:DI 1 \"reg_or_0_operand\" \"rM\")\n+\t\t\t  (match_operand:DI 2 \"reg_or_0_operand\" \"rM\")])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 0, insn);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n+\n+;; Match the negated branch.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"comparison_operator\"\n+\t\t\t [(match_operand:DI 1 \"reg_or_0_operand\" \"rM\")\n+\t\t\t  (match_operand:DI 2 \"reg_or_0_operand\" \"rM\")])\n+\t (pc)\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 1, insn);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"cmpib_comparison_operator\"\n+\t\t\t [(match_operand:DI 1 \"reg_or_0_operand\" \"rM\")\n+\t\t\t  (match_operand:DI 2 \"arith5_operand\" \"rL\")])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 0, insn);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n+\n+;; Match the negated branch.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"cmpib_comparison_operator\"\n+\t\t\t [(match_operand:DI 1 \"reg_or_0_operand\" \"rM\")\n+\t\t\t  (match_operand:DI 2 \"arith5_operand\" \"rL\")])\n+\t (pc)\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 1, insn);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 8184))\n+\t   (const_int 4)\n+\t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n+\t       (const_int 262100))\n+\t   (const_int 8)\n+\t   (eq (symbol_ref \"flag_pic\") (const_int 0))\n+\t   (const_int 20)]\n+\t  (const_int 28)))])\n+\n ;; Branch on Bit patterns.\n (define_insn \"\"\n   [(set (pc)\n@@ -1159,6 +1558,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"uint32_operand\" \"\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 0, insn, 0);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -1181,6 +1602,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"uint32_operand\" \"\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 1, insn, 0);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -1203,6 +1646,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"uint32_operand\" \"\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 0, insn, 1);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -1225,6 +1690,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"uint32_operand\" \"\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn), 1, insn, 1);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n ;; Branch on Variable Bit patterns.\n (define_insn \"\"\n   [(set (pc)\n@@ -1248,6 +1735,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 0, insn, 0);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -1270,6 +1779,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 1, insn, 0);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -1292,6 +1823,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 0, insn, 1);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -1314,6 +1867,28 @@\n            (const_int 4)\n \t   (const_int 8)))])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:DI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 1, insn, 1);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n ;; Floating point branches\n (define_insn \"\"\n   [(set (pc) (if_then_else (ne (reg:CCFP 0) (const_int 0))\n@@ -1493,6 +2068,11 @@\n   \"\"\n   \"\n {\n+  if (TARGET_64BIT)\n+    {\n+      emit_insn (gen_pre_ldd (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n   emit_insn (gen_pre_ldw (operands[0], operands[1], operands[2]));\n   DONE;\n }\")\n@@ -1513,6 +2093,17 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"pre_ldd\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mem:DI (plus:DI (match_operand:DI 1 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:DI 2 \"pre_cint_operand\" \"\"))))\n+   (set (match_dup 1)\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_64BIT\"\n+  \"ldd,mb %2(%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n \t\t\t (match_operand:SI 1 \"pre_cint_operand\" \"\")))\n@@ -1554,6 +2145,11 @@\n   \"\"\n   \"\n {\n+  if (TARGET_64BIT)\n+    {\n+      emit_insn (gen_post_std (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n   emit_insn (gen_post_stw (operands[0], operands[1], operands[2]));\n   DONE;\n }\")\n@@ -1574,6 +2170,17 @@\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"post_std\"\n+  [(set (mem:DI (match_operand:DI 0 \"register_operand\" \"+r\"))\n+\t(match_operand:DI 1 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_dup 0)\n+\t(plus:DI (match_dup 0)\n+\t\t (match_operand:DI 2 \"post_cint_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"std,ma %r1,%2(%0)\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; For loading the address of a label while generating PIC code.\n ;; Note since this pattern can be created at reload time (via movsi), all\n ;; the same rules for movsi apply here.  (no new pseudos, no temporaries).\n@@ -1617,11 +2224,23 @@\n    (set_attr \"length\" \"16\")])\t\t; 12 or 16\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t (high:SI (match_operand 2 \"\" \"\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (high:SI (match_operand 2 \"\" \"\"))))]\n+  \"symbolic_operand (operands[2], Pmode)\n+   && ! function_label_operand (operands[2], Pmode)\n+   && flag_pic == 2\"\n+  \"addil LT'%G2,%1\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t         (high:DI (match_operand 2 \"\" \"\"))))]\n   \"symbolic_operand (operands[2], Pmode)\n    && ! function_label_operand (operands[2], Pmode)\n+   && TARGET_64BIT\n    && flag_pic == 2\"\n   \"addil LT'%G2,%1\"\n   [(set_attr \"type\" \"binary\")\n@@ -1646,6 +2265,22 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mem:DI\n+\t  (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t     (unspec:DI\n+\t\t\t[(match_operand:DI 2 \"symbolic_operand\" \"\")] 0))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  if (flag_pic != 2)\n+    abort ();\n+  return \\\"ldd RT'%G2(%1),%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; Always use addil rather than ldil;add sequences.  This allows the\n ;; HP linker to eliminate the dp relocation if the symbolic operand\n ;; lives in the TEXT space.\n@@ -1686,6 +2321,17 @@\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"4,8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=!a,*r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t (high:DI (match_operand 2 \"const_int_operand\" \"\"))))]\n+  \"reload_completed && TARGET_64BIT\"\n+  \"@\n+   addil L'%G2,%1\n+   ldil L'%G2,%0\\;{addl|add,l} %0,%1,%0\"\n+  [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"length\" \"4,8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n@@ -1701,6 +2347,23 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(high:DI (match_operand 1 \"const_int_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"ldil L'%G1,%0\";\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"const_int_operand\" \"i\")))]\n+  \"TARGET_64BIT\"\n+  \"ldo R'%G2(%1),%0\";\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -2149,7 +2812,7 @@\n \t      (clobber (match_dup 6))\n \t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"\n {\n   int size, align;\n@@ -2222,7 +2885,7 @@\n    (clobber (match_operand:SI 6 \"register_operand\" \"=&r,&r\"))\t;item tmp2\n    (use (match_operand:SI 4 \"arith_operand\" \"J,2\"))\t ;byte count\n    (use (match_operand:SI 5 \"const_int_operand\" \"n,n\"))] ;alignment\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"* return output_block_move (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \f\n@@ -2242,6 +2905,7 @@\n \t(match_operand:DF 1 \"\" \"?F,m\"))]\n   \"GET_CODE (operands[1]) == CONST_DOUBLE\n    && operands[1] != CONST0_RTX (DFmode)\n+   && !TARGET_64BIT\n    && ! TARGET_SOFT_FLOAT\"\n   \"* return (which_alternative == 0 ? output_move_double (operands)\n \t\t\t\t    : \\\"fldd%F1 %1,%0\\\");\"\n@@ -2254,6 +2918,9 @@\n   \"\"\n   \"\n {\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE && TARGET_64BIT)\n+      operands[1] = force_const_mem (DFmode, operands[1]);\n+\n   if (emit_move_sequence (operands, DFmode, 0))\n     DONE;\n }\")\n@@ -2300,6 +2967,7 @@\n     || reg_or_0_operand (operands[1], DFmode))\n    && ! (GET_CODE (operands[1]) == CONST_DOUBLE\n \t && GET_CODE (operands[0]) == MEM)\n+   && ! TARGET_64BIT\n    && ! TARGET_SOFT_FLOAT\"\n   \"*\n {\n@@ -2318,6 +2986,7 @@\n \t\t\t  \"rG,r,r,o,Q\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n+   && ! TARGET_64BIT\n    && TARGET_SOFT_FLOAT\"\n   \"*\n {\n@@ -2326,6 +2995,29 @@\n   [(set_attr \"type\" \"move,store,store,load,load\")\n    (set_attr \"length\" \"8,8,16,8,16\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t\t\"=r,r,r,r,r,Q,*q,!f,f,*TR\")\n+\t(match_operand:DF 1 \"move_operand\"\n+\t\t\t\t\"r,J,N,K,RQ,rM,rM,!fM,*RT,f\"))]\n+  \"(register_operand (operands[0], DFmode)\n+    || reg_or_0_operand (operands[1], DFmode))\n+   && ! TARGET_SOFT_FLOAT && TARGET_64BIT\"\n+  \"@\n+   copy %1,%0\n+   ldi %1,%0\n+   ldil L'%1,%0\n+   depdi,z %z1,%0\n+   ldd%M1 %1,%0\n+   std%M0 %r1,%0\n+   mtsar %r1\n+   fcpy,dbl %f1,%0\n+   fldd%F1 %1,%0\n+   fstd%F0 %1,%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu,fpload,fpstore\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n \t(mem:DF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n@@ -2408,6 +3100,9 @@\n   \"\"\n   \"\n {\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE && TARGET_64BIT)\n+      operands[1] = force_const_mem (DImode, operands[1]);\n+\n   if (emit_move_sequence (operands, DImode, 0))\n     DONE;\n }\")\n@@ -2445,7 +3140,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(high:DI (match_operand 1 \"\" \"\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   rtx op0 = operands[0];\n@@ -2487,6 +3182,7 @@\n \t\t\t  \"rM,r,r,o*R,Q,i,fM,*TR,f\"))]\n   \"(register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\n+   && ! TARGET_64BIT\n    && ! TARGET_SOFT_FLOAT\"\n   \"*\n {\n@@ -2498,13 +3194,37 @@\n   [(set_attr \"type\" \"move,store,store,load,load,multi,fpalu,fpload,fpstore\")\n    (set_attr \"length\" \"8,8,16,8,16,16,4,4,4\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n+\t\t\t\t\"=r,r,r,r,r,Q,*q,!f,f,*TR\")\n+\t(match_operand:DI 1 \"move_operand\"\n+\t\t\t\t\"r,J,N,K,RQ,rM,rM,!fM,*RT,f\"))]\n+  \"(register_operand (operands[0], DImode)\n+    || reg_or_0_operand (operands[1], DImode))\n+   && ! TARGET_SOFT_FLOAT && TARGET_64BIT\"\n+  \"@\n+   copy %1,%0\n+   ldi %1,%0\n+   ldil L'%1,%0\n+   depdi,z %z1,%0\n+   ldd%M1 %1,%0\n+   std%M0 %r1,%0\n+   mtsar %r1\n+   fcpy,dbl %f1,%0\n+   fldd%F1 %1,%0\n+   fstd%F0 %1,%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu,fpload,fpstore\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n \t\t\t  \"=r,o,Q,r,r,r\")\n \t(match_operand:DI 1 \"general_operand\"\n \t\t\t  \"rM,r,r,o,Q,i\"))]\n   \"(register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\n+   && ! TARGET_64BIT\n    && TARGET_SOFT_FLOAT\"\n   \"*\n {\n@@ -2517,7 +3237,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,&r\")\n \t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"0,r\")\n \t\t   (match_operand:DI 2 \"immediate_operand\" \"i,i\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   /* Don't output a 64 bit constant, since we can't trust the assembler to\n@@ -2766,6 +3486,30 @@\n   [(set_attr \"type\" \"shift,load\")\n    (set_attr \"length\" \"4,4\")])\n \n+(define_insn \"zero_extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,u %1,63,8,%0\"\n+  [(set_attr \"type\" \"shift\") \n+  (set_attr \"length\" \"4\")])\n+\n+(define_insn \"zero_extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,u %1,63,16,%0\"\n+  [(set_attr \"type\" \"shift\") \n+  (set_attr \"length\" \"4\")])\n+\n+(define_insn \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,u %1,63,32,%0\"\n+  [(set_attr \"type\" \"shift\") \n+  (set_attr \"length\" \"4\")])\n+\n ;;- sign extension instructions\n \n (define_insn \"extendhisi2\"\n@@ -2791,6 +3535,31 @@\n   \"{extrs|extrw,s} %1,31,8,%0\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n+\n+(define_insn \"extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,s %1,63,8,%0\"\n+  [(set_attr \"type\" \"shift\") \n+  (set_attr \"length\" \"4\")])\n+\n+(define_insn \"extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,s %1,63,16,%0\"\n+  [(set_attr \"type\" \"shift\") \n+  (set_attr \"length\" \"4\")])\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,s %1,63,32,%0\"\n+  [(set_attr \"type\" \"shift\") \n+  (set_attr \"length\" \"4\")])\n+\n \f\n ;; Conversions between float and double.\n \n@@ -3014,15 +3783,23 @@\n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (match_operand:DI 2 \"arith11_operand\" \"\")))]\n+\t\t (match_operand:DI 2 \"arith_operand\" \"\")))]\n   \"\"\n   \"\")\n \n+;; We allow arith_operand for operands2, even though strictly speaking it\n+;; we would prefer to us arith11_operand since that's what the hardware\n+;; can actually support.\n+;;\n+;; But the price of the extra reload in that case is worth the simplicity\n+;; we get by allowing a trivial adddi3 expander to be used for both\n+;; PA64 and PA32.\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"arith11_operand\" \"rI\")))]\n-  \"\"\n+\t\t (match_operand:DI 2 \"arith_operand\" \"rI\")))]\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -3038,6 +3815,27 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:DI 2 \"arith_operand\" \"r,J\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   {addl|add,l} %1,%2,%0\n+   ldo %2(%1),%0\"\n+  [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"uaddcm %2,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n@@ -3135,11 +3933,23 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"sub %R1,%R2,%R0\\;{subb|sub,b} %1,%2,%0\"\n   [(set_attr \"type\" \"binary\")\n   (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,q\")\n+\t(minus:DI (match_operand:DI 1 \"arith11_operand\" \"r,I,U\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r,r,r\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   sub %1,%2,%0\n+   subi %1,%2,%0\n+   mtsarcm %2\"\n+  [(set_attr \"type\" \"binary,binary,move\")\n+  (set_attr \"length\" \"4,4,4\")])\n+\n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"arith11_operand\" \"\")\n@@ -3193,6 +4003,16 @@\n       operands[1] = force_reg (SImode, operands[1]);\n       operands[2] = force_reg (SImode, operands[2]);\n       emit_insn (gen_umulsidi3 (scratch, operands[1], operands[2]));\n+      /* We do not want (subreg:SI (XX:DI) 1)) for TARGET_64BIT since\n+\t that has no real meaning.  */\n+      if (TARGET_64BIT)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operands[0],\n+\t\t\t\t  gen_rtx_SUBREG (SImode, scratch, 0)));\n+\t  DONE;\n+\t  \n+\t}\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t      gen_rtx_SUBREG (SImode, scratch, 1)));\n       DONE;\n@@ -3213,11 +4033,20 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=f\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"f\"))\n \t\t (match_operand:DI 2 \"uint32_operand\" \"f\")))]\n-  \"TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT\"\n+  \"TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && !TARGET_64BIT\"\n   \"xmpyu %1,%R2,%0\"\n   [(set_attr \"type\" \"fpmuldbl\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=f\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"f\"))\n+\t\t (match_operand:DI 2 \"uint32_operand\" \"f\")))]\n+  \"TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && TARGET_64BIT\"\n+  \"xmpyu %1,%2R,%0\"\n+  [(set_attr \"type\" \"fpmuldbl\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n    (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n@@ -3252,6 +4081,54 @@\n ;; Out of range and either PIC or PORTABLE_RUNTIME\n \t  (const_int 24)))])\n \n+(define_expand \"muldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n+  \"TARGET_64BIT && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT\"\n+  \"\n+{\n+  rtx low_product = gen_reg_rtx (DImode);\n+  rtx cross_product1 = gen_reg_rtx (DImode);\n+  rtx cross_product2 = gen_reg_rtx (DImode);\n+  rtx cross_scratch = gen_reg_rtx (DImode);\n+  rtx cross_product = gen_reg_rtx (DImode);\n+  rtx op1l, op1r, op2l, op2r;\n+  rtx op1shifted, op2shifted;\n+\n+  op1shifted = gen_reg_rtx (DImode);\n+  op2shifted = gen_reg_rtx (DImode);\n+  op1l = gen_reg_rtx (SImode);\n+  op1r = gen_reg_rtx (SImode);\n+  op2l = gen_reg_rtx (SImode);\n+  op2r = gen_reg_rtx (SImode);\n+\n+  emit_move_insn (op1shifted, gen_rtx_LSHIFTRT (DImode, operands[1],\n+\t\t\t\t\t\tGEN_INT (32)));\n+  emit_move_insn (op2shifted, gen_rtx_LSHIFTRT (DImode, operands[2],\n+\t\t\t\t\t\tGEN_INT (32)));\n+  op1r = gen_rtx_SUBREG (SImode, operands[1], 0);\n+  op2r = gen_rtx_SUBREG (SImode, operands[2], 0);\n+  op1l = gen_rtx_SUBREG (SImode, op1shifted, 0);\n+  op2l = gen_rtx_SUBREG (SImode, op2shifted, 0);\n+\n+  /* Emit multiplies for the cross products.  */\n+  emit_insn (gen_umulsidi3 (cross_product1, op2r, op1l));\n+  emit_insn (gen_umulsidi3 (cross_product2, op2l, op1r));\n+\n+  /* Emit a multiply for the low sub-word.  */\n+  emit_insn (gen_umulsidi3 (low_product, op2r, op1r));\n+\n+  /* Sum the cross products and shift them into proper position.  */\n+  emit_insn (gen_adddi3 (cross_scratch, cross_product1, cross_product2));\n+  emit_insn (gen_ashldi3 (cross_product, cross_scratch, GEN_INT (32)));\n+\n+  /* Add the cross product to the low product and store the result\n+     into the output operand .  */\n+  emit_insn (gen_adddi3 (operands[0], cross_product, low_product));\n+  DONE;\n+}\")\n+\n ;;; Division and mod.\n (define_expand \"divsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -3268,6 +4145,8 @@\n {\n   operands[3] = gen_reg_rtx (SImode);\n   operands[4] = gen_reg_rtx (SImode);\n+  if (TARGET_64BIT)\n+    operands[4] = gen_rtx_REG (SImode, 2);\n   if (GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const (operands, 0))\n     DONE;\n }\")\n@@ -3324,6 +4203,8 @@\n {\n   operands[3] = gen_reg_rtx (SImode);\n   operands[4] = gen_reg_rtx (SImode);\n+  if (TARGET_64BIT)\n+    operands[4] = gen_rtx_REG (SImode, 2);\n   if (GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const (operands, 1))\n     DONE;\n }\")\n@@ -3379,6 +4260,8 @@\n   \"\n {\n   operands[4] = gen_reg_rtx (SImode);\n+  if (TARGET_64BIT)\n+    operands[4] = gen_rtx_REG (SImode, 2);\n   operands[3] = gen_reg_rtx (SImode);\n }\")\n \n@@ -3432,6 +4315,8 @@\n   \"\n {\n   operands[4] = gen_reg_rtx (SImode);\n+  if (TARGET_64BIT)\n+    operands[4] = gen_rtx_REG (SImode, 2);\n   operands[3] = gen_reg_rtx (SImode);\n }\")\n \n@@ -3492,11 +4377,20 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"and %1,%2,%0\\;and %R1,%R2,%R0\"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"%?r,0\")\n+\t\t(match_operand:DI 2 \"and_operand\" \"rO,P\")))]\n+  \"TARGET_64BIT\"\n+  \"* return output_64bit_and (operands); \"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n+\n ; The ? for op1 makes reload prefer zdepi instead of loading a huge\n ; constant with ldil;ldo.\n (define_insn \"andsi3\"\n@@ -3512,11 +4406,20 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"andcm %2,%1,%0\\;andcm %R2,%R1,%R0\"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"andcm %2,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n@@ -3543,11 +4446,29 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ior:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"or %1,%2,%0\\;or %R1,%R2,%R0\"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n+\t\t(match_operand:DI 2 \"ior_operand\" \"M,i\")))]\n+  \"TARGET_64BIT\"\n+  \"* return output_64bit_ior (operands); \"\n+  [(set_attr \"type\" \"binary,shift\")\n+   (set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"or %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; Need a define_expand because we've run out of CONST_OK... characters.\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -3596,11 +4517,20 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n \t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"xor %1,%2,%0\\;xor %R1,%R2,%R0\"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"xor %1,%2,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n@@ -3619,11 +4549,19 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"sub %%r0,%R1,%R0\\;{subb|sub,b} %%r0,%1,%0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"sub %%r0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n@@ -3645,11 +4583,19 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"uaddcm %%r0,%1,%0\\;uaddcm %%r0,%R1,%R0\"\n   [(set_attr \"type\" \"unary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"uaddcm %%r0,%1,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n@@ -4210,6 +5156,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (mult:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"shadd_operand\" \"\"))\n+\t\t (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_64BIT\"\n+  \"shladd,l %2,%O3,%1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; This anonymous pattern and splitter wins because it reduces the latency\n ;; of the shadd sequence without increasing the latency of the shift.\n ;;\n@@ -4250,6 +5206,33 @@\n \t\t\t       (match_dup 1)))]\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (mult:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"shadd_operand\" \"\"))\n+\t\t (match_operand:DI 1 \"register_operand\" \"r\")))\n+   (set (match_operand:DI 4 \"register_operand\" \"=&r\")\n+\t(ashift:DI (match_dup 2)\n+\t\t   (match_operand:DI 5 \"const_int_operand\" \"i\")))]\n+  \"TARGET_64BIT && INTVAL (operands[5]) == exact_log2 (INTVAL (operands[3]))\"\n+  \"#\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (mult:DI (match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 3 \"shadd_operand\" \"\"))\n+\t\t (match_operand:DI 1 \"register_operand\" \"r\")))\n+   (set (match_operand:DI 4 \"register_operand\" \"=&r\")\n+\t(ashift:DI (match_dup 2)\n+\t\t   (match_operand:DI 5 \"const_int_operand\" \"i\")))]\n+  \"TARGET_64BIT && INTVAL (operands[5]) == exact_log2 (INTVAL (operands[3]))\"\n+  [(set (match_dup 4) (ashift:DI (match_dup 2) (match_dup 5)))\n+   (set (match_dup 0) (plus:DI (mult:DI (match_dup 2) (match_dup 3))\n+\t\t\t       (match_dup 1)))]\n+  \"\")\n+\n (define_expand \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashift:SI (match_operand:SI 1 \"lhs_lshift_operand\" \"\")\n@@ -4339,12 +5322,111 @@\n \t\t\t\t     (match_operand:SI 2 \"register_operand\" \"q\")))\n \t\t(match_operand:SI 3 \"register_operand\" \"0\")))]\n   ; this can be generalized...!\n-  \"INTVAL (operands[1]) == -2\"\n+  \"INTVAL (operands[1]) == -2\"\n+  \"*\n+{\n+  int x = INTVAL (operands[1]);\n+  operands[2] = GEN_INT (exact_log2 ((~x) + 1));\n+  return \\\"{vdepi 0,%2,%0|depwi 0,%%sar,%2,%0}\\\";\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"lhs_lshift_operand\" \"\")\n+\t\t   (match_operand:DI 2 \"arith32_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      rtx temp = gen_reg_rtx (DImode);\n+      emit_insn (gen_subdi3 (temp, GEN_INT (63), operands[2]));\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\temit_insn (gen_zvdep_imm64 (operands[0], operands[1], temp));\n+      else\n+\temit_insn (gen_zvdep64 (operands[0], operands[1], temp));\n+      DONE;\n+    }\n+  /* Make sure both inputs are not constants,\n+     there are no patterns for that.  */\n+  operands[1] = force_reg (DImode, operands[1]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n+  \"TARGET_64BIT\"\n+  \"depd,z %1,%p2,%Q2,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+; Match cases of op1 a CONST_INT here that zvdep_imm64 doesn't handle.\n+; Doing it like this makes slightly better code since reload can\n+; replace a register with a known value in range -16..15 with a\n+; constant.  Ideally, we would like to merge zvdep64 and zvdep_imm64,\n+; but since we have no more CONST_OK... characters, that is not\n+; possible.\n+(define_insn \"zvdep64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:DI (match_operand:DI 1 \"arith5_operand\" \"r,L\")\n+\t\t   (minus:DI (const_int 63)\n+\t\t\t     (match_operand:DI 2 \"register_operand\" \"q,q\"))))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   depd,z %1,%%sar,64,%0\n+   depdi,z %1,%%sar,64,%0\"\n+  [(set_attr \"type\" \"shift,shift\")\n+   (set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"zvdep_imm64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"lhs_lshift_cint_operand\" \"\")\n+\t\t   (minus:DI (const_int 63)\n+\t\t\t     (match_operand:DI 2 \"register_operand\" \"q\"))))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  int x = INTVAL (operands[1]);\n+  operands[2] = GEN_INT (4 + exact_log2 ((x >> 4) + 1));\n+  operands[1] = GEN_INT ((x & 0x1f) - 0x20);\n+  return \\\"depdi,z %1,%%sar,%2,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (ashift:DI (match_operand:DI 1 \"const_int_operand\" \"\")\n+\t\t\t   (minus:DI (const_int 63)\n+\t\t\t\t     (match_operand:DI 2 \"register_operand\" \"q\")))\n+\t\t(match_operand:DI 3 \"register_operand\" \"0\")))]\n+  ; accept ...0001...1, can this be generalized?\n+  \"TARGET_64BIT && exact_log2 (INTVAL (operands[1]) + 1) >= 0\"\n+  \"*\n+{\n+  int x = INTVAL (operands[1]);\n+  operands[2] = GEN_INT (exact_log2 (x + 1));\n+  return \\\"depdi -1,%%sar,%2,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (rotate:DI (match_operand:DI 1 \"const_int_operand\" \"\")\n+\t\t\t   (minus:DI (const_int 63)\n+\t\t\t\t     (match_operand:DI 2 \"register_operand\" \"q\")))\n+\t\t(match_operand:DI 3 \"register_operand\" \"0\")))]\n+  ; this can be generalized...!\n+  \"TARGET_64BIT && INTVAL (operands[1]) == -2\"\n   \"*\n {\n   int x = INTVAL (operands[1]);\n   operands[2] = GEN_INT (exact_log2 ((~x) + 1));\n-  return \\\"{vdepi 0,%2,%0|depwi 0,%%sar,%2,%0}\\\";\n+  return \\\"depdi 0,%%sar,%2,%0\\\";\n }\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n@@ -4384,6 +5466,41 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_expand \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:DI 2 \"arith32_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      rtx temp = gen_reg_rtx (DImode);\n+      emit_insn (gen_subdi3 (temp, GEN_INT (63), operands[2]));\n+      emit_insn (gen_vextrs64 (operands[0], operands[1], temp));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,s %1,%p2,%Q2,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"vextrs64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t     (minus:DI (const_int 63)\n+\t\t\t       (match_operand:DI 2 \"register_operand\" \"q\"))))]\n+  \"TARGET_64BIT\"\n+  \"extrd,s %1,%%sar,64,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n@@ -4395,6 +5512,17 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:DI 2 \"arith32_operand\" \"q,n\")))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   shrpd %%r0,%1,%%sar,%0\n+   extrd,u %1,%p2,%Q2,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"rotrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n@@ -4517,6 +5645,15 @@\n   \"\"\n   \"hppa_expand_prologue ();DONE;\")\n \n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  hppa_expand_epilogue ();\n+  DONE;\n+}\")\n+\n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n@@ -4660,6 +5797,16 @@\n       operands[0] = reg;\n     }\n \n+  /* In 64bit mode we must make sure to wipe the upper bits of the register\n+     just in case the addition overflowed or we had random bits in the\n+     high part of the register.  */\n+  if (TARGET_64BIT)\n+    {\n+      rtx reg = gen_reg_rtx (DImode);\n+      emit_insn (gen_extendsidi2 (reg, operands[0]));\n+      operands[0] = gen_rtx_SUBREG (SImode, reg, 0);\n+    }\n+\n   if (!INT_5_BITS (operands[2]))\n     operands[2] = force_reg (SImode, operands[2]);\n \n@@ -4704,13 +5851,24 @@\n   else\n     op = XEXP (operands[0], 0);\n \n+  if (TARGET_64BIT)\n+    emit_move_insn (arg_pointer_rtx,\n+\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t  GEN_INT (64)));\n+\n   /* Use two different patterns for calls to explicitly named functions\n      and calls through function pointers.  This is necessary as these two\n      types of calls use different calling conventions, and CSE might try\n      to change the named call into an indirect call in some cases (using\n      two patterns keeps CSE from performing this optimization).  */\n   if (GET_CODE (op) == SYMBOL_REF)\n     call_insn = emit_call_insn (gen_call_internal_symref (op, operands[1]));\n+  else if (TARGET_64BIT)\n+    {\n+      rtx tmpreg = force_reg (word_mode, op);\n+      call_insn = emit_call_insn (gen_call_internal_reg_64bit (tmpreg,\n+\t\t\t\t\t\t\t       operands[1]));\n+    }\n   else\n     {\n       rtx tmpreg = gen_rtx_REG (word_mode, 22);\n@@ -4723,6 +5881,8 @@\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n \t       gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+      if (TARGET_64BIT)\n+\tuse_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n \n       /* After each call we must restore the PIC register, even if it\n \t doesn't appear to be used.\n@@ -4744,7 +5904,7 @@\n   \"*\n {\n   output_arg_descriptor (insn);\n-  return output_call (insn, operands[0]);\n+  return output_call (insn, operands[0], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n@@ -4762,6 +5922,23 @@\n \t\t\t\t  (const_int 52)\n \t\t\t\t  (const_int 68))))])\n \n+(define_insn \"call_internal_reg_64bit\"\n+  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 2))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  rtx xoperands[2];\n+\n+  /* ??? Needs more work.  Length computation, split into multiple insns,\n+     do not use %r22 directly, expose delay slot.  */\n+  return \\\"ldd 16(%0),%%r2\\;ldd 24(%0),%%r27\\;bve,l (%%r2),%%r2\\;nop\\\";\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\") (const_int 16))])\n+\n (define_insn \"call_internal_reg\"\n   [(call (mem:SI (reg:SI 22))\n \t (match_operand 0 \"\" \"i\"))\n@@ -4850,6 +6027,11 @@\n   else\n     op = XEXP (operands[1], 0);\n \n+  if (TARGET_64BIT)\n+    emit_move_insn (arg_pointer_rtx,\n+\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t  GEN_INT (64)));\n+\n   /* Use two different patterns for calls to explicitly named functions\n      and calls through function pointers.  This is necessary as these two\n      types of calls use different calling conventions, and CSE might try\n@@ -4859,6 +6041,14 @@\n     call_insn = emit_call_insn (gen_call_value_internal_symref (operands[0],\n \t\t\t\t\t\t\t\top,\n \t\t\t\t\t\t\t\toperands[2]));\n+  else if (TARGET_64BIT)\n+    {\n+      rtx tmpreg = force_reg (word_mode, op);\n+      call_insn\n+\t= emit_call_insn (gen_call_value_internal_reg_64bit (operands[0],\n+\t\t\t\t\t\t\t     tmpreg,\n+\t\t\t\t\t\t\t     operands[2]));\n+    }\n   else\n     {\n       rtx tmpreg = gen_rtx_REG (word_mode, 22);\n@@ -4871,6 +6061,8 @@\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n \t       gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+      if (TARGET_64BIT)\n+\tuse_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n \n       /* After each call we must restore the PIC register, even if it\n \t doesn't appear to be used.\n@@ -4894,7 +6086,7 @@\n   \"*\n {\n   output_arg_descriptor (insn);\n-  return output_call (insn, operands[1]);\n+  return output_call (insn, operands[1], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n@@ -4912,6 +6104,22 @@\n \t\t\t\t  (const_int 52)\n \t\t\t\t  (const_int 68))))])\n \n+(define_insn \"call_value_internal_reg_64bit\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+         (call (mem:SI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t       (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 2))\n+   (use (const_int 1))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  /* ??? Needs more work.  Length computation, split into multiple insns,\n+     do not use %r22 directly, expose delay slot.  */\n+  return \\\"ldd 16(%1),%%r2\\;ldd 24(%1),%%r27\\;bve,l (%%r2),%%r2\\;nop\\\";\n+}\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set (attr \"length\") (const_int 16))])\n+\n (define_insn \"call_value_internal_reg\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (reg:SI 22))\n@@ -5013,6 +6221,131 @@\n \n   DONE;\n }\")\n+\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 0))])]\n+  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"\n+{\n+  rtx op;\n+  rtx call_insn;\n+\n+  op = XEXP (operands[0], 0);\n+\n+  /* We do not allow indirect sibling calls.  */\n+  call_insn = emit_call_insn (gen_sibcall_internal_symref (op, operands[1]));\n+\n+  if (flag_pic)\n+    {\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n+\t       gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+\n+      /* After each call we must restore the PIC register, even if it\n+\t doesn't appear to be used.\n+\n+         This will set regs_ever_live for the callee saved register we\n+\t stored the PIC register in.  */\n+      emit_move_insn (pic_offset_table_rtx,\n+\t\t      gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+    }\n+  DONE;\n+}\")\n+\n+(define_insn \"sibcall_internal_symref\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 0))\n+   (use (reg:SI 2))\n+   (use (const_int 0))]\n+  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[0], 1);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+;;       If we're sure that we can either reach the target or that the\n+;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\n+;;\t For long-calls the length will be either 52 bytes (non-pic)\n+;;\t or 68 bytes (pic).  */\n+;;\t Else we have to use a long-call;\n+      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+\t\t\t(const_int 240000))\n+\t\t    (const_int 4)\n+\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n+\t\t\t\t      (const_int 0))\n+\t\t\t\t  (const_int 52)\n+\t\t\t\t  (const_int 68))))])\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand:SI 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 0))])]\n+  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"\n+{\n+  rtx op;\n+  rtx call_insn;\n+\n+  op = XEXP (operands[1], 0);\n+\n+  /* We do not allow indirect sibling calls.  */\n+  call_insn = emit_call_insn (gen_sibcall_value_internal_symref (operands[0],\n+\t\t\t\t\t\t\t\t op,\n+\t\t\t\t\t\t\t\t operands[2]));\n+  if (flag_pic)\n+    {\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn),\n+\t       gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+\n+      /* After each call we must restore the PIC register, even if it\n+\t doesn't appear to be used.\n+\n+         This will set regs_ever_live for the callee saved register we\n+\t stored the PIC register in.  */\n+      emit_move_insn (pic_offset_table_rtx,\n+\t\t      gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n+    }\n+  DONE;\n+}\")\n+\n+(define_insn \"sibcall_value_internal_symref\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 0))\n+   (use (reg:SI 2))\n+   (use (const_int 0))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[1], 1);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\")\n+;;       If we're sure that we can either reach the target or that the\n+;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\n+;;\t For long-calls the length will be either 52 bytes (non-pic)\n+;;\t or 68 bytes (pic).  */\n+;;\t Else we have to use a long-call;\n+      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+\t\t\t(const_int 240000))\n+\t\t    (const_int 4)\n+\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n+\t\t\t\t      (const_int 0))\n+\t\t\t\t  (const_int 52)\n+\t\t\t\t  (const_int 68))))])\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n@@ -5050,22 +6383,32 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"0\")])\n \n-;;; Hope this is only within a function...\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand 0 \"register_operand\" \"r\"))]\n-  \"GET_MODE (operands[0]) == word_mode\"\n-  \"bv%* %%r0(%0)\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4\")])\n-\n ;;; EH does longjmp's from and within the data section.  Thus,\n ;;; an interspace branch is required for the longjmp implementation.\n ;;; Registers r1 and r2 are not saved in the jmpbuf environment.\n ;;; Thus, they can be used as scratch registers for the jump.\n-(define_insn \"interspace_jump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n-  (clobber (reg:SI 2))]\n+(define_expand \"interspace_jump\"\n+  [(parallel\n+     [(set (pc) (match_operand 0 \"pmode_register_operand\" \"a\"))\n+      (clobber (match_dup 1))])]\n   \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx_REG (word_mode, 2);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc) (match_operand 0 \"pmode_register_operand\" \"a\"))\n+  (clobber (reg:SI 2))]\n+  \"!TARGET_64BIT\"\n+  \"ldsid (%%sr0,%0),%%r2\\; mtsp %%r2,%%sr0\\; be%* 0(%%sr0,%0)\"\n+   [(set_attr \"type\" \"branch\")\n+    (set_attr \"length\" \"12\")])\n+\n+(define_insn \"\"\n+  [(set (pc) (match_operand 0 \"pmode_register_operand\" \"a\"))\n+  (clobber (reg:DI 2))]\n+  \"TARGET_64BIT\"\n   \"ldsid (%%sr0,%0),%%r2\\; mtsp %%r2,%%sr0\\; be%* 0(%%sr0,%0)\"\n    [(set_attr \"type\" \"branch\")\n     (set_attr \"length\" \"12\")])\n@@ -5095,21 +6438,32 @@\n   emit_barrier ();\n   DONE;\n }\")\n+;;; Hope this is only within a function...\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"r\"))]\n+  \"GET_MODE (operands[0]) == word_mode\"\n+  \"bv%* %%r0(%0)\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"extzv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(zero_extract (match_operand 1 \"register_operand\" \"\")\n+\t\t      (match_operand 2 \"uint32_operand\" \"\")\n+\t\t      (match_operand 3 \"uint32_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! uint5_operand (operands[2], SImode)\n-      ||  ! uint5_operand (operands[3], SImode))\n-  FAIL;\n+  if (TARGET_64BIT)\n+    emit_insn (gen_extzv_64 (operands[0], operands[1],\n+\t\t\t     operands[2], operands[3]));\n+  else\n+    emit_insn (gen_extzv_32 (operands[0], operands[1],\n+\t\t\t     operands[2], operands[3]));\n+  DONE;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"extzv_32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n@@ -5129,20 +6483,44 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"extzv_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"uint32_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,u %1,%3+%2-1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:DI 3 \"register_operand\" \"q\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,u %1,%%sar,1,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_expand \"extv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"uint5_operand\" \"\")))]\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(sign_extract (match_operand 1 \"register_operand\" \"\")\n+\t\t      (match_operand 2 \"uint32_operand\" \"\")\n+\t\t      (match_operand 3 \"uint32_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! uint5_operand (operands[2], SImode)\n-      ||  ! uint5_operand (operands[3], SImode))\n-  FAIL;\n+  if (TARGET_64BIT)\n+    emit_insn (gen_extv_64 (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]));\n+  else\n+    emit_insn (gen_extv_32 (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]));\n+  DONE;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"extv_32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\")\n@@ -5157,25 +6535,50 @@\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand:SI 3 \"register_operand\" \"q\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"{vextrs %1,1,%0|extrw,s %1,%%sar,1,%0}\"\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"extv_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"uint32_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,s %1,%3+%2-1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:DI 3 \"register_operand\" \"q\")))]\n+  \"TARGET_64BIT\"\n+  \"extrd,s %1,%%sar,1,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; Only specify the mode operands 0, the rest are assumed to be word_mode.\n (define_expand \"insv\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"uint5_operand\" \"\"))\n-\t(match_operand:SI 3 \"arith5_operand\" \"r,L\"))]\n+  [(set (zero_extract (match_operand 0 \"register_operand\" \"\")\n+                      (match_operand 1 \"uint32_operand\" \"\")\n+                      (match_operand 2 \"uint32_operand\" \"\"))\n+        (match_operand 3 \"arith5_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (! uint5_operand (operands[1], SImode)\n-      ||  ! uint5_operand (operands[2], SImode))\n-  FAIL;\n+  if (TARGET_64BIT)\n+    emit_insn (gen_insv_64 (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]));\n+  else\n+    emit_insn (gen_insv_32 (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]));\n+  DONE;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"insv_32\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r,r\")\n \t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n \t\t\t (match_operand:SI 2 \"uint5_operand\" \"\"))\n@@ -5203,6 +6606,44 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"insv_64\"\n+  [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"+r,r\")\n+\t\t\t (match_operand:DI 1 \"uint32_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\"))\n+\t(match_operand:DI 3 \"arith32_operand\" \"r,L\"))]\n+  \"TARGET_64BIT\"\n+  \"@\n+   depd %3,%2+%1-1,%1,%0\n+   depdi %3,%2+%1-1,%1,%0\"\n+  [(set_attr \"type\" \"shift,shift\")\n+   (set_attr \"length\" \"4,4\")])\n+\n+;; Optimize insertion of const_int values of type 1...1xxxx.\n+(define_insn \"\"\n+  [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:DI 1 \"uint32_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"uint32_operand\" \"\"))\n+\t(match_operand:DI 3 \"const_int_operand\" \"\"))]\n+  \"(INTVAL (operands[3]) & 0x10) != 0\n+   && TARGET_64BIT\n+   && (~INTVAL (operands[3]) & ((1L << INTVAL (operands[1])) - 1) & ~0xf) == 0\"\n+  \"*\n+{\n+  operands[3] = GEN_INT ((INTVAL (operands[3]) & 0xf) - 0x10);\n+  return \\\"depdi %3,%2+%1-1,%1,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t   (const_int 32)))]\n+  \"TARGET_64BIT\"\n+  \"depd,z %1,31,32,%0\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; This insn is used for some loop tests, typically loops reversed when\n ;; strength reduction is used.  It is actually created when the instruction\n ;; combination phase combines the special loop test.  Since this insn\n@@ -5751,7 +7192,7 @@\n \t      (clobber (reg:SI 31))])\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n \t(reg:SI 29))]\n-  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"! TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"\n {\n   operands[2] = gen_reg_rtx (SImode);\n@@ -5769,7 +7210,7 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 22))\n    (clobber (reg:SI 31))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   /* Must import the magic millicode routine.  */"}, {"sha": "5e99ad3d0356af7e93fdbc38a1b38c1a340153b6", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -56,7 +56,7 @@ Boston, MA 02111-1307, USA.  */\n    Reg 20-22\t= Temporary Registers\n    Reg 23-26\t= Temporary/Parameter Registers\n    Reg 27\t= Global Data Pointer (hp)\n-   Reg 28\t= Temporary/???/Return Value register\n+   Reg 28\t= Temporary/Return Value register\n    Reg 29\t= Temporary/Static Chain/Return Value register #2\n    Reg 30\t= stack pointer\n    Reg 31\t= Temporary/Millicode Return Pointer (hp)"}, {"sha": "e307382ad0c2be6bdc66b171ca255a5daa3e52bf", "filename": "gcc/config/pa/pa64-start.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa64-start.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520babc78350da8210931f4e60114402d99ec157/gcc%2Fconfig%2Fpa%2Fpa64-start.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-start.h?ref=520babc78350da8210931f4e60114402d99ec157", "patch": "@@ -3,4 +3,4 @@\n    checking for TARGET_64BIT.  */\n #define TARGET_64BIT 1\n #define TARGET_PA_11 1\n-#defien TARGET_PA_20 1\n+#define TARGET_PA_20 1"}]}