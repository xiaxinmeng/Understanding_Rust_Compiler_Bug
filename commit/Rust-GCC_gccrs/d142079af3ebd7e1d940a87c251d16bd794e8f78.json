{"sha": "d142079af3ebd7e1d940a87c251d16bd794e8f78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE0MjA3OWFmM2ViZDdlMWQ5NDBhODdjMjUxZDE2YmQ3OTRlOGY3OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-11-24T16:15:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-11-24T16:15:46Z"}, "message": "re PR ipa/63671 (21% tramp3d-v4 performance hit due to -fdevirtualize)\n\n\tPR ipa/63671\n\t* ipa-inline-transform.c (can_remove_node_now_p_1): Handle alises\n\tand -fno-devirtualize more carefully.\n\t(can_remove_node_now_p): Update.\n\nFrom-SVN: r218024", "tree": {"sha": "43174ebb8202281dbb77d8e7f7ce4901d574c71a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43174ebb8202281dbb77d8e7f7ce4901d574c71a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d142079af3ebd7e1d940a87c251d16bd794e8f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d142079af3ebd7e1d940a87c251d16bd794e8f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d142079af3ebd7e1d940a87c251d16bd794e8f78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d142079af3ebd7e1d940a87c251d16bd794e8f78/comments", "author": null, "committer": null, "parents": [{"sha": "3f2012e4950247046107f0576259660fab1203bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2012e4950247046107f0576259660fab1203bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f2012e4950247046107f0576259660fab1203bd"}], "stats": {"total": 34, "additions": 27, "deletions": 7}, "files": [{"sha": "1ed780ca8558e3e398042ea5a88f48629e84af50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d142079af3ebd7e1d940a87c251d16bd794e8f78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d142079af3ebd7e1d940a87c251d16bd794e8f78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d142079af3ebd7e1d940a87c251d16bd794e8f78", "patch": "@@ -1,3 +1,10 @@\n+2014-11-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/63671\n+\t* ipa-inline-transform.c (can_remove_node_now_p_1): Handle alises\n+\tand -fno-devirtualize more carefully.\n+\t(can_remove_node_now_p): Update.\n+\n 2014-11-24  Andrew Pinski  <apinski@cavium.com>\n \n \tPR rtl-opt/63972"}, {"sha": "063cd94cda67ac6e1a63e7332a8b0aa363249e28", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d142079af3ebd7e1d940a87c251d16bd794e8f78/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d142079af3ebd7e1d940a87c251d16bd794e8f78/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=d142079af3ebd7e1d940a87c251d16bd794e8f78", "patch": "@@ -93,19 +93,28 @@ update_noncloned_frequencies (struct cgraph_node *node,\n    copy of function was removed.  */\n \n static bool\n-can_remove_node_now_p_1 (struct cgraph_node *node)\n+can_remove_node_now_p_1 (struct cgraph_node *node, struct cgraph_edge *e)\n {\n+  ipa_ref *ref;\n+\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      if ((alias->callers && alias->callers != e)\n+          || !can_remove_node_now_p_1 (alias, e))\n+\treturn false;\n+    }\n   /* FIXME: When address is taken of DECL_EXTERNAL function we still\n      can remove its offline copy, but we would need to keep unanalyzed node in\n      the callgraph so references can point to it.  */\n   return (!node->address_taken\n-\t  && !node->has_aliases_p ()\n \t  && node->can_remove_if_no_direct_calls_p ()\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed.\n \t     Lacking may edges in callgraph we just preserve them post\n \t     inlining.  */\n-\t  && !DECL_VIRTUAL_P (node->decl)\n+\t  && (!DECL_VIRTUAL_P (node->decl)\n+\t      || !opt_for_fn (node->decl, flag_devirtualize))\n \t  /* During early inlining some unanalyzed cgraph nodes might be in the\n \t     callgraph and they might reffer the function in question.  */\n \t  && !cgraph_new_nodes.exists ());\n@@ -119,7 +128,7 @@ static bool\n can_remove_node_now_p (struct cgraph_node *node, struct cgraph_edge *e)\n {\n   struct cgraph_node *next;\n-  if (!can_remove_node_now_p_1 (node))\n+  if (!can_remove_node_now_p_1 (node, e))\n     return false;\n \n   /* When we see same comdat group, we need to be sure that all\n@@ -128,9 +137,13 @@ can_remove_node_now_p (struct cgraph_node *node, struct cgraph_edge *e)\n     return true;\n   for (next = dyn_cast<cgraph_node *> (node->same_comdat_group);\n        next != node; next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n-    if ((next->callers && next->callers != e)\n-\t|| !can_remove_node_now_p_1 (next))\n-      return false;\n+    {\n+      if (next->alias)\n+\tcontinue;\n+      if ((next->callers && next->callers != e)\n+\t  || !can_remove_node_now_p_1 (next, e))\n+        return false;\n+    }\n   return true;\n }\n "}]}