{"sha": "9ded41a39c1bb29f356485a9ec3a573fb75ded12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlZDQxYTM5YzFiYjI5ZjM1NjQ4NWE5ZWMzYTU3M2ZiNzVkZWQxMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-08-25T12:31:17Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-08-25T12:31:17Z"}, "message": "aarch64: Tweaks to the handling of fixed-length SVE types\n\nThis patch is really four things rolled into one, since separating\nthem seemed artificial:\n\n- Update the mangling of the fixed-length SVE ACLE types to match\n  the upcoming spec.  The idea is to mangle:\n\n    VLAT __attribute__((arm_sve_vector_bits(N)))\n\n  as an instance __SVE_VLS<VLAT, N> of the template:\n\n    __SVE_VLS<typename, unsigned>\n\n- Give the fixed-length types their own TYPE_DECL.  This is needed\n  to make the above mangling fix work, but should also be a minor\n  QoI improvement for error reporting.  Unfortunately, the names are\n  quite verbose, e.g.:\n\n    svint8_t __attribute__((arm_sve_vector_bits(512)))\n\n  but anything shorter would be ad-hoc syntax and so might be more\n  confusing.\n\n- Improve the error message reported when arm_sve_vector_bits is\n  applied to tuples, such as:\n\n    svint32x2_t __attribute__((arm_sve_vector_bits(N)))\n\n  Previously we would complain that the type isn't an SVE type;\n  now we complain that it isn't a vector type.\n\n- Don't allow arm_sve_vector_bits(N) to be applied to existing\n  fixed-length SVE types.\n\ngcc/\n\t* config/aarch64/aarch64-sve-builtins.cc (add_sve_type_attribute):\n\tTake the ACLE name of the type as a parameter and add it as fourth\n\targument to the \"SVE type\" attribute.\n\t(register_builtin_types): Update call accordingly.\n\t(register_tuple_type): Likewise.  Construct the name of the type\n\tearlier in order to do this.\n\t(get_arm_sve_vector_bits_attributes): New function.\n\t(handle_arm_sve_vector_bits_attribute): Report a more sensible\n\terror message if the attribute is applied to an SVE tuple type.\n\tDon't allow the attribute to be applied to an existing fixed-length\n\tSVE type.  Mangle the new type as __SVE_VLS<type, vector-bits>.\n\tAdd a dummy TYPE_DECL to the new type.\n\ngcc/testsuite/\n\t* g++.target/aarch64/sve/acle/general-c++/attributes_2.C: New test.\n\t* g++.target/aarch64/sve/acle/general-c++/mangle_6.C: Likewise.\n\t* g++.target/aarch64/sve/acle/general-c++/mangle_7.C: Likewise.\n\t* g++.target/aarch64/sve/acle/general-c++/mangle_8.C: Likewise.\n\t* g++.target/aarch64/sve/acle/general-c++/mangle_9.C: Likewise.\n\t* g++.target/aarch64/sve/acle/general-c++/mangle_10.C: Likewise.\n\t* gcc.target/aarch64/sve/acle/general/attributes_7.c: Check the\n\terror messages reported when arm_sve_vector_bits is applied to\n\tSVE tuple types or to existing fixed-length SVE types.", "tree": {"sha": "92e2c333a5be0ba32da131fc8cfc02e73c78eb5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92e2c333a5be0ba32da131fc8cfc02e73c78eb5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ded41a39c1bb29f356485a9ec3a573fb75ded12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ded41a39c1bb29f356485a9ec3a573fb75ded12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ded41a39c1bb29f356485a9ec3a573fb75ded12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ded41a39c1bb29f356485a9ec3a573fb75ded12/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcb043351307001a85fc1e7d56669f5adc9628f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcb043351307001a85fc1e7d56669f5adc9628f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcb043351307001a85fc1e7d56669f5adc9628f7"}], "stats": {"total": 312, "additions": 295, "deletions": 17}, "files": [{"sha": "e753966efba70c0ce77e796b8a7a4dc5f77a2181", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 113, "deletions": 17, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -564,15 +564,16 @@ static bool reported_missing_registers_p;\n \n /* Record that TYPE is an ABI-defined SVE type that contains NUM_ZR SVE vectors\n    and NUM_PR SVE predicates.  MANGLED_NAME, if nonnull, is the ABI-defined\n-   mangling of the type.  */\n+   mangling of the type.  ACLE_NAME is the <arm_sve.h> name of the type.  */\n static void\n add_sve_type_attribute (tree type, unsigned int num_zr, unsigned int num_pr,\n-\t\t\tconst char *mangled_name)\n+\t\t\tconst char *mangled_name, const char *acle_name)\n {\n   tree mangled_name_tree\n     = (mangled_name ? get_identifier (mangled_name) : NULL_TREE);\n \n-  tree value = tree_cons (NULL_TREE, mangled_name_tree, NULL_TREE);\n+  tree value = tree_cons (NULL_TREE, get_identifier (acle_name), NULL_TREE);\n+  value = tree_cons (NULL_TREE, mangled_name_tree, value);\n   value = tree_cons (NULL_TREE, size_int (num_pr), value);\n   value = tree_cons (NULL_TREE, size_int (num_zr), value);\n   TYPE_ATTRIBUTES (type) = tree_cons (get_identifier (\"SVE type\"), value,\n@@ -3363,7 +3364,8 @@ register_builtin_types ()\n       TYPE_ARTIFICIAL (vectype) = 1;\n       TYPE_INDIVISIBLE_P (vectype) = 1;\n       add_sve_type_attribute (vectype, num_zr, num_pr,\n-\t\t\t      vector_types[i].mangled_name);\n+\t\t\t      vector_types[i].mangled_name,\n+\t\t\t      vector_types[i].acle_name);\n       make_type_sizeless (vectype);\n       abi_vector_types[i] = vectype;\n       lang_hooks.types.register_builtin_type (vectype,\n@@ -3409,6 +3411,13 @@ register_tuple_type (unsigned int num_vectors, vector_type_index type)\n {\n   tree tuple_type = lang_hooks.types.make_type (RECORD_TYPE);\n \n+  /* Work out the structure name.  */\n+  char buffer[sizeof (\"svbfloat16x4_t\")];\n+  const char *vector_type_name = vector_types[type].acle_name;\n+  snprintf (buffer, sizeof (buffer), \"%.*sx%d_t\",\n+\t    (int) strlen (vector_type_name) - 2, vector_type_name,\n+\t    num_vectors);\n+\n   /* The contents of the type are opaque, so we can define them in any\n      way that maps to the correct ABI type.\n \n@@ -3432,20 +3441,13 @@ register_tuple_type (unsigned int num_vectors, vector_type_index type)\n \t\t\t   get_identifier (\"__val\"), array_type);\n   DECL_FIELD_CONTEXT (field) = tuple_type;\n   TYPE_FIELDS (tuple_type) = field;\n-  add_sve_type_attribute (tuple_type, num_vectors, 0, NULL);\n+  add_sve_type_attribute (tuple_type, num_vectors, 0, NULL, buffer);\n   make_type_sizeless (tuple_type);\n   layout_type (tuple_type);\n   gcc_assert (VECTOR_MODE_P (TYPE_MODE (tuple_type))\n \t      && TYPE_MODE_RAW (tuple_type) == TYPE_MODE (tuple_type)\n \t      && TYPE_ALIGN (tuple_type) == 128);\n \n-  /* Work out the structure name.  */\n-  char buffer[sizeof (\"svbfloat16x4_t\")];\n-  const char *vector_type_name = vector_types[type].acle_name;\n-  snprintf (buffer, sizeof (buffer), \"%.*sx%d_t\",\n-\t    (int) strlen (vector_type_name) - 2, vector_type_name,\n-\t    num_vectors);\n-\n   tree decl = build_decl (input_location, TYPE_DECL,\n \t\t\t  get_identifier (buffer), tuple_type);\n   TYPE_NAME (tuple_type) = decl;\n@@ -3646,6 +3648,29 @@ builtin_type_p (const_tree type, unsigned int *num_zr, unsigned int *num_pr)\n   return false;\n }\n \n+/* ATTRS is the attribute list for a sizeless SVE type.  Return the\n+   attributes of the associated fixed-length SVE type, taking the\n+   \"SVE type\" attributes from NEW_SVE_TYPE_ARGS.  */\n+static tree\n+get_arm_sve_vector_bits_attributes (tree old_attrs, tree new_sve_type_args)\n+{\n+  tree new_attrs = NULL_TREE;\n+  tree *ptr = &new_attrs;\n+  for (tree attr = old_attrs; attr; attr = TREE_CHAIN (attr))\n+    {\n+      tree name = get_attribute_name (attr);\n+      if (is_attribute_p (\"SVE sizeless type\", name))\n+\tcontinue;\n+\n+      tree args = TREE_VALUE (attr);\n+      if (is_attribute_p (\"SVE type\", name))\n+\targs = new_sve_type_args;\n+      *ptr = tree_cons (TREE_PURPOSE (attr), args, NULL_TREE);\n+      ptr = &TREE_CHAIN (*ptr);\n+    }\n+  return new_attrs;\n+}\n+\n /* An attribute callback for the \"arm_sve_vector_bits\" attribute.  */\n tree\n handle_arm_sve_vector_bits_attribute (tree *node, tree, tree args, int,\n@@ -3654,12 +3679,27 @@ handle_arm_sve_vector_bits_attribute (tree *node, tree, tree args, int,\n   *no_add_attrs = true;\n \n   tree type = *node;\n-  if (!VECTOR_TYPE_P (type) || !builtin_type_p (type))\n+  tree attr = lookup_sve_type_attribute (type);\n+  if (!attr)\n     {\n       error (\"%qs applied to non-SVE type %qT\", \"arm_sve_vector_bits\", type);\n       return NULL_TREE;\n     }\n \n+  if (!VECTOR_TYPE_P (type))\n+    {\n+      error (\"%qs applied to non-vector type %qT\",\n+\t     \"arm_sve_vector_bits\", type);\n+      return NULL_TREE;\n+    }\n+\n+  if (!sizeless_type_p (type))\n+    {\n+      error (\"%qs applied to type %qT, which already has a size\",\n+\t     \"arm_sve_vector_bits\", type);\n+      return NULL_TREE;\n+    }\n+\n   tree size = TREE_VALUE (args);\n   if (TREE_CODE (size) != INTEGER_CST)\n     {\n@@ -3675,6 +3715,23 @@ handle_arm_sve_vector_bits_attribute (tree *node, tree, tree args, int,\n       return NULL_TREE;\n     }\n \n+  /* Construct a new list of \"SVE type\" attribute arguments.  */\n+  tree new_sve_type_args = copy_list (TREE_VALUE (attr));\n+\n+  /* Mangle the type as an instance of the imaginary template:\n+\n+       __SVE_VLS<typename, unsigned>\n+\n+     where the first parameter is the SVE type and where the second\n+     parameter is the SVE vector length in bits.  */\n+  tree mangled_name_node = chain_index (2, new_sve_type_args);\n+  const char *old_mangled_name\n+    = IDENTIFIER_POINTER (TREE_VALUE (mangled_name_node));\n+  char *new_mangled_name\n+    = xasprintf (\"9__SVE_VLSI%sLj%dEE\", old_mangled_name, (int) value);\n+  TREE_VALUE (mangled_name_node) = get_identifier (new_mangled_name);\n+  free (new_mangled_name);\n+\n   /* FIXME: The type ought to be a distinct copy in all cases, but\n      currently that makes the C frontend reject conversions between\n      svbool_t and its fixed-length variants.  Using a type variant\n@@ -3687,6 +3744,44 @@ handle_arm_sve_vector_bits_attribute (tree *node, tree, tree args, int,\n   else\n     new_type = build_distinct_type_copy (base_type);\n \n+  /* Construct a TYPE_DECL for the new type.  This serves two purposes:\n+\n+     - It ensures we don't print the original TYPE_DECL in error messages.\n+       Printing the original name would be confusing because there are\n+       situations in which the distinction between the original type and\n+       the new type matters.  For example:\n+\n+\t   __SVInt8_t __attribute__((arm_sve_vector_bits(512))) *a;\n+\t   __SVInt8_t *b;\n+\n+\t   a = b;\n+\n+       is invalid in C++, but without this, we'd print both types in\n+       the same way.\n+\n+     - Having a separate TYPE_DECL is necessary to ensure that C++\n+       mangling works correctly.  See mangle_builtin_type for details.\n+\n+     The name of the decl is something like:\n+\n+       svint8_t __attribute__((arm_sve_vector_bits(512)))\n+\n+     This is a compromise.  It would be more accurate to use something like:\n+\n+       __SVInt8_t __attribute__((arm_sve_vector_bits(512)))\n+\n+     but the <arm_sve.h> name is likely to be more meaningful.  */\n+  tree acle_name_node = TREE_CHAIN (mangled_name_node);\n+  const char *old_type_name = IDENTIFIER_POINTER (TREE_VALUE (acle_name_node));\n+  char *new_type_name\n+    = xasprintf (\"%s __attribute__((arm_sve_vector_bits(%d)))\",\n+\t\t old_type_name, (int) value);\n+  tree decl = build_decl (BUILTINS_LOCATION, TYPE_DECL,\n+\t\t\t  get_identifier (new_type_name), new_type);\n+  DECL_ARTIFICIAL (decl) = 1;\n+  TYPE_NAME (new_type) = decl;\n+  free (new_type_name);\n+\n   /* Allow the GNU vector extensions to be applied to vectors.\n      The extensions aren't yet defined for packed predicates,\n      so continue to treat them as abstract entities for now.  */\n@@ -3696,16 +3791,17 @@ handle_arm_sve_vector_bits_attribute (tree *node, tree, tree args, int,\n   /* The new type is a normal sized type; it doesn't have the same\n      restrictions as sizeless types.  */\n   TYPE_ATTRIBUTES (new_type)\n-    = remove_attribute (\"SVE sizeless type\",\n-\t\t\tcopy_list (TYPE_ATTRIBUTES (new_type)));\n+    = get_arm_sve_vector_bits_attributes (TYPE_ATTRIBUTES (new_type),\n+\t\t\t\t\t  new_sve_type_args);\n \n   /* Apply the relevant attributes, qualifiers and alignment of TYPE,\n      if they differ from the original (sizeless) BASE_TYPE.  */\n   if (TYPE_ATTRIBUTES (base_type) != TYPE_ATTRIBUTES (type)\n       || TYPE_QUALS (base_type) != TYPE_QUALS (type))\n     {\n-      tree attrs = remove_attribute (\"SVE sizeless type\",\n-\t\t\t\t     copy_list (TYPE_ATTRIBUTES (type)));\n+      tree attrs\n+\t= get_arm_sve_vector_bits_attributes (TYPE_ATTRIBUTES (type),\n+\t\t\t\t\t      new_sve_type_args);\n       new_type = build_type_attribute_qual_variant (new_type, attrs,\n \t\t\t\t\t\t    TYPE_QUALS (type));\n     }"}, {"sha": "b55be02ecca264e2d2104f9f6932cdc8464e334c", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/attributes_2.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fattributes_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fattributes_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fattributes_2.C?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -0,0 +1,66 @@\n+// { dg-compile }\n+// { dg-additional-options \"-msve-vector-bits=512\" }\n+\n+#include <arm_sve.h>\n+\n+typedef svint8_t vec8 __attribute__((arm_sve_vector_bits(512)));\n+typedef vec8 *vec8_ptr;\n+\n+typedef svint8_t my_vec;\n+\n+typedef vec8 bad_vec8_a __attribute__((arm_sve_vector_bits(512))); // { dg-error {'arm_sve_vector_bits' applied to type 'vec8' {aka 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)'}, which already has a size} }\n+typedef svint8_t bad_vec8_b __attribute__((arm_sve_vector_bits(512))) __attribute__((arm_sve_vector_bits(512))); // { dg-error {'arm_sve_vector_bits' applied to type 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)', which already has a size} }\n+\n+svint8_t *vla1;\n+__SVInt8_t *vla2;\n+\n+vec8 *vls1;\n+svint8_t (__attribute__((arm_sve_vector_bits(512))) *vls2);\n+__SVInt8_t (__attribute__((arm_sve_vector_bits(512))) *vls3);\n+vec8_ptr vls4;\n+my_vec (__attribute__((arm_sve_vector_bits(512))) *vls5);\n+\n+void\n+f (void)\n+{\n+  vls1 = vla1; // { dg-error {invalid conversion from 'svint8_t\\*' to 'vec8\\*' {aka 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'}} }\n+  vls1 = vla2; // { dg-error {invalid conversion from '__SVInt8_t\\*' to 'vec8\\*' {aka 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'}} }\n+\n+  vls2 = vla1; // { dg-error {invalid conversion from 'svint8_t\\*' to 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'} }\n+  vls2 = vla2; // { dg-error {invalid conversion from '__SVInt8_t\\*' to 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'} }\n+\n+  vls3 = vla1; // { dg-error {invalid conversion from 'svint8_t\\*' to 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'} }\n+  vls3 = vla2; // { dg-error {invalid conversion from '__SVInt8_t\\*' to 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'} }\n+\n+  vls4 = vla1; // { dg-error {invalid conversion from 'svint8_t\\*' to 'vec8_ptr' {aka 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'}} }\n+  vls4 = vla2; // { dg-error {invalid conversion from '__SVInt8_t\\*' to 'vec8_ptr' {aka 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'}} }\n+\n+  vls5 = vla1; // { dg-error {invalid conversion from 'svint8_t\\*' to 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'} }\n+  vls5 = vla2; // { dg-error {invalid conversion from '__SVInt8_t\\*' to 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\(512\\)\\)\\)\\*'} }\n+\n+  vla1 = vla1;\n+  vla1 = vla2;\n+\n+  vla2 = vla1;\n+  vla2 = vla2;\n+\n+  vls1 = vls1;\n+  vls1 = vls2;\n+  vls1 = vls3;\n+  vls1 = vls4;\n+\n+  vls2 = vls1;\n+  vls2 = vls2;\n+  vls2 = vls3;\n+  vls2 = vls4;\n+\n+  vls3 = vls1;\n+  vls3 = vls2;\n+  vls3 = vls3;\n+  vls3 = vls4;\n+\n+  vls4 = vls1;\n+  vls4 = vls2;\n+  vls4 = vls3;\n+  vls4 = vls4;\n+}"}, {"sha": "5ff2d2e552281e8fa298e33b3009a4bbc0ff3c6e", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_10.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_10.C?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target aarch64_little_endian } */\n+/* { dg-additional-options \"-msve-vector-bits=2048\" } */\n+\n+#include \"mangle_6.C\"\n+\n+/* { dg-final { scan-assembler \"_Z2f19__SVE_VLSIu10__SVBool_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f29__SVE_VLSIu10__SVInt8_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f39__SVE_VLSIu11__SVInt16_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f49__SVE_VLSIu11__SVInt32_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f59__SVE_VLSIu11__SVInt64_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f69__SVE_VLSIu11__SVUint8_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f79__SVE_VLSIu12__SVUint16_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f89__SVE_VLSIu12__SVUint32_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f99__SVE_VLSIu12__SVUint64_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f109__SVE_VLSIu13__SVFloat16_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f119__SVE_VLSIu13__SVFloat32_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f129__SVE_VLSIu13__SVFloat64_tLj2048EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f139__SVE_VLSIu14__SVBfloat16_tLj2048EE:\" } } */"}, {"sha": "50009b67f939be5ccc3555e952fde979cd0a2ddd", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_6.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_6.C?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target aarch64_little_endian } */\n+/* { dg-additional-options \"-msve-vector-bits=128\" } */\n+\n+#include <arm_sve.h>\n+\n+#define N __ARM_FEATURE_SVE_BITS\n+#define FIXED_ATTR __attribute__ ((arm_sve_vector_bits (N)))\n+\n+void f1(svbool_t FIXED_ATTR) {}\n+void f2(svint8_t FIXED_ATTR) {}\n+void f3(svint16_t FIXED_ATTR) {}\n+void f4(svint32_t FIXED_ATTR) {}\n+void f5(svint64_t FIXED_ATTR) {}\n+void f6(svuint8_t FIXED_ATTR) {}\n+void f7(svuint16_t FIXED_ATTR) {}\n+void f8(svuint32_t FIXED_ATTR) {}\n+void f9(svuint64_t FIXED_ATTR) {}\n+void f10(svfloat16_t FIXED_ATTR) {}\n+void f11(svfloat32_t FIXED_ATTR) {}\n+void f12(svfloat64_t FIXED_ATTR) {}\n+void f13(svbfloat16_t FIXED_ATTR) {}\n+\n+/* { dg-final { scan-assembler \"_Z2f19__SVE_VLSIu10__SVBool_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f29__SVE_VLSIu10__SVInt8_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f39__SVE_VLSIu11__SVInt16_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f49__SVE_VLSIu11__SVInt32_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f59__SVE_VLSIu11__SVInt64_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f69__SVE_VLSIu11__SVUint8_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f79__SVE_VLSIu12__SVUint16_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f89__SVE_VLSIu12__SVUint32_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f99__SVE_VLSIu12__SVUint64_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f109__SVE_VLSIu13__SVFloat16_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f119__SVE_VLSIu13__SVFloat32_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f129__SVE_VLSIu13__SVFloat64_tLj128EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f139__SVE_VLSIu14__SVBfloat16_tLj128EE:\" } } */"}, {"sha": "45cc1d2f31e7e3a73a15f5559a3860f86339a46a", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_7.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_7.C?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target aarch64_little_endian } */\n+/* { dg-additional-options \"-msve-vector-bits=256\" } */\n+\n+#include \"mangle_6.C\"\n+\n+/* { dg-final { scan-assembler \"_Z2f19__SVE_VLSIu10__SVBool_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f29__SVE_VLSIu10__SVInt8_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f39__SVE_VLSIu11__SVInt16_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f49__SVE_VLSIu11__SVInt32_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f59__SVE_VLSIu11__SVInt64_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f69__SVE_VLSIu11__SVUint8_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f79__SVE_VLSIu12__SVUint16_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f89__SVE_VLSIu12__SVUint32_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f99__SVE_VLSIu12__SVUint64_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f109__SVE_VLSIu13__SVFloat16_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f119__SVE_VLSIu13__SVFloat32_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f129__SVE_VLSIu13__SVFloat64_tLj256EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f139__SVE_VLSIu14__SVBfloat16_tLj256EE:\" } } */"}, {"sha": "96e03c577cc4c9d4de3032a853aba457c12af8a8", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_8.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_8.C?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target aarch64_little_endian } */\n+/* { dg-additional-options \"-msve-vector-bits=512\" } */\n+\n+#include \"mangle_6.C\"\n+\n+/* { dg-final { scan-assembler \"_Z2f19__SVE_VLSIu10__SVBool_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f29__SVE_VLSIu10__SVInt8_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f39__SVE_VLSIu11__SVInt16_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f49__SVE_VLSIu11__SVInt32_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f59__SVE_VLSIu11__SVInt64_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f69__SVE_VLSIu11__SVUint8_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f79__SVE_VLSIu12__SVUint16_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f89__SVE_VLSIu12__SVUint32_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f99__SVE_VLSIu12__SVUint64_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f109__SVE_VLSIu13__SVFloat16_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f119__SVE_VLSIu13__SVFloat32_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f129__SVE_VLSIu13__SVFloat64_tLj512EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f139__SVE_VLSIu14__SVBfloat16_tLj512EE:\" } } */"}, {"sha": "3f432af469ad48bcd317d47c8e599e9b5ff3b5ae", "filename": "gcc/testsuite/g++.target/aarch64/sve/acle/general-c++/mangle_9.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Facle%2Fgeneral-c%2B%2B%2Fmangle_9.C?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target aarch64_little_endian } */\n+/* { dg-additional-options \"-msve-vector-bits=1024\" } */\n+\n+#include \"mangle_6.C\"\n+\n+/* { dg-final { scan-assembler \"_Z2f19__SVE_VLSIu10__SVBool_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f29__SVE_VLSIu10__SVInt8_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f39__SVE_VLSIu11__SVInt16_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f49__SVE_VLSIu11__SVInt32_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f59__SVE_VLSIu11__SVInt64_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f69__SVE_VLSIu11__SVUint8_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f79__SVE_VLSIu12__SVUint16_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f89__SVE_VLSIu12__SVUint32_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z2f99__SVE_VLSIu12__SVUint64_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f109__SVE_VLSIu13__SVFloat16_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f119__SVE_VLSIu13__SVFloat32_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f129__SVE_VLSIu13__SVFloat64_tLj1024EE:\" } } */\n+/* { dg-final { scan-assembler \"_Z3f139__SVE_VLSIu14__SVBfloat16_tLj1024EE:\" } } */"}, {"sha": "e2e74700a011790e836f5b6278d63d27afe7e7ed", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/attributes_7.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ded41a39c1bb29f356485a9ec3a573fb75ded12/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fattributes_7.c?ref=9ded41a39c1bb29f356485a9ec3a573fb75ded12", "patch": "@@ -23,6 +23,10 @@ typedef svbool_t bad_type_2 __attribute__ ((arm_sve_vector_bits)); // { dg-error\n typedef svbool_t bad_type_3 __attribute__ ((arm_sve_vector_bits (N, N))); // { dg-error {wrong number of arguments specified for 'arm_sve_vector_bits' attribute} }\n typedef svbool_t bad_type_4 __attribute__ ((arm_sve_vector_bits (\"256\"))); // { dg-error {'arm_sve_vector_bits' requires an integer constant expression} }\n typedef svbool_t bad_type_5 __attribute__ ((arm_sve_vector_bits (100))); // { dg-warning {unsupported SVE vector size} }\n+typedef svint32x2_t bad_type_6 __attribute__ ((arm_sve_vector_bits (N))); // { dg-error {'arm_sve_vector_bits' applied to non-vector type 'svint32x2_t'} }\n+typedef svint8_t bad_type_7 __attribute__ ((arm_sve_vector_bits (N))) __attribute__ ((arm_sve_vector_bits (N))); // { dg-error {'arm_sve_vector_bits' applied to type 'svint8_t __attribute__\\(\\(arm_sve_vector_bits\\([0-9]+\\)\\)\\)', which already has a size} }\n+typedef fixed_bool_t bad_type_8 __attribute__ ((arm_sve_vector_bits (N))) __attribute__ ((arm_sve_vector_bits (N))); // { dg-error {'arm_sve_vector_bits' applied to type 'fixed_bool_t' {aka 'svbool_t __attribute__\\(\\(arm_sve_vector_bits\\([0-9]+\\)\\)\\)'}, which already has a size} }\n+typedef gnu_int8_t bad_type_9 __attribute__ ((arm_sve_vector_bits (N))) __attribute__ ((arm_sve_vector_bits (N))); // { dg-error {'arm_sve_vector_bits' applied to non-SVE type 'gnu_int8_t'} }\n \n void\n f (int c)"}]}