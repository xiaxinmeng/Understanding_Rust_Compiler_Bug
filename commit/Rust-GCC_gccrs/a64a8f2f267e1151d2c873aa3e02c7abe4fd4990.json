{"sha": "a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY0YThmMmYyNjdlMTE1MWQyYzg3M2FhM2UwMmM3YWJlNGZkNDk5MA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-09-01T10:55:50Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-09-01T10:55:50Z"}, "message": "gfc-internals.texi (F2003 OOP), [...]): New chapter and section to document the internals of type-bound procedures.\n\n2008-09-01  Daniel Kraft  <d@domob.eu>\n\n\t* gfc-internals.texi (F2003 OOP), (Type-bound Procedures): New chapter\n\tand section to document the internals of type-bound procedures.\n\t(gfc_expr): Document EXPR_COMPCALL.\n\t* gfortran.h (struct gfc_expr): Remove unused `derived' from compcall.\n\t* dump-parse-tree.c (show_compcall): New method.\n\t(show_expr): Call it for EXPR_COMPCALL.\n\t(show_typebound), (show_f2k_derived): New methods.\n\t(show_symbol): Call show_f2k_derived.\n\t(show_code_node): Handle EXEC_COMPCALL.\n\t* primary.c (gfc_match_varspec): Don't initialize removed `derived' in\n\tprimary->value.compcall.\n\nFrom-SVN: r139857", "tree": {"sha": "66c5e272b10868f7048d89734fa754d3d8f51f9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66c5e272b10868f7048d89734fa754d3d8f51f9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f69bbb461b3a00afe8156ae949fb7014332bb3a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f69bbb461b3a00afe8156ae949fb7014332bb3a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f69bbb461b3a00afe8156ae949fb7014332bb3a1"}], "stats": {"total": 216, "additions": 214, "deletions": 2}, "files": [{"sha": "92a0d356fab7bd6d71a9e4a57af0e5b73159ddad", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "patch": "@@ -1,3 +1,17 @@\n+2008-09-01  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfc-internals.texi (F2003 OOP), (Type-bound Procedures): New chapter\n+\tand section to document the internals of type-bound procedures.\n+\t(gfc_expr): Document EXPR_COMPCALL.\n+\t* gfortran.h (struct gfc_expr): Remove unused `derived' from compcall.\n+\t* dump-parse-tree.c (show_compcall): New method.\n+\t(show_expr): Call it for EXPR_COMPCALL.\n+\t(show_typebound), (show_f2k_derived): New methods.\n+\t(show_symbol): Call show_f2k_derived.\n+\t(show_code_node): Handle EXEC_COMPCALL.\n+\t* primary.c (gfc_match_varspec): Don't initialize removed `derived' in\n+\tprimary->value.compcall.\n+\n 2008-08-31  Richard Guenther  <rguenther@suse.de>\n \n \t* trans-expr.c (gfc_trans_string_copy): Use the correct types"}, {"sha": "05d32c29a76b298a52db4317f97ff9a26c00d988", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "patch": "@@ -316,6 +316,22 @@ show_char_const (const gfc_char_t *c, int length)\n   fputc ('\\'', dumpfile);\n }\n \n+\n+/* Show a component-call expression.  */\n+\n+static void\n+show_compcall (gfc_expr* p)\n+{\n+  gcc_assert (p->expr_type == EXPR_COMPCALL);\n+\n+  fprintf (dumpfile, \"%s\", p->symtree->n.sym->name);\n+  show_ref (p->ref);\n+  fprintf (dumpfile, \"%s\", p->value.compcall.name);\n+\n+  show_actual_arglist (p->value.compcall.actual);\n+}\n+\n+\n /* Show an expression.  */\n \n static void\n@@ -539,6 +555,10 @@ show_expr (gfc_expr *p)\n \n       break;\n \n+    case EXPR_COMPCALL:\n+      show_compcall (p);\n+      break;\n+\n     default:\n       gfc_internal_error (\"show_expr(): Don't know how to show expr\");\n     }\n@@ -646,6 +666,76 @@ show_components (gfc_symbol *sym)\n }\n \n \n+/* Show the f2k_derived namespace with procedure bindings.  */\n+\n+static void\n+show_typebound (gfc_symtree* st)\n+{\n+  if (!st->typebound)\n+    return;\n+\n+  show_indent ();\n+\n+  if (st->typebound->is_generic)\n+    fputs (\"GENERIC\", dumpfile);\n+  else\n+    {\n+      fputs (\"PROCEDURE, \", dumpfile);\n+      if (st->typebound->nopass)\n+\tfputs (\"NOPASS\", dumpfile);\n+      else\n+\t{\n+\t  if (st->typebound->pass_arg)\n+\t    fprintf (dumpfile, \"PASS(%s)\", st->typebound->pass_arg);\n+\t  else\n+\t    fputs (\"PASS\", dumpfile);\n+\t}\n+      if (st->typebound->non_overridable)\n+\tfputs (\", NON_OVERRIDABLE\", dumpfile);\n+    }\n+\n+  if (st->typebound->access == ACCESS_PUBLIC)\n+    fputs (\", PUBLIC\", dumpfile);\n+  else\n+    fputs (\", PRIVATE\", dumpfile);\n+\n+  fprintf (dumpfile, \" :: %s => \", st->n.sym->name);\n+\n+  if (st->typebound->is_generic)\n+    {\n+      gfc_tbp_generic* g;\n+      for (g = st->typebound->u.generic; g; g = g->next)\n+\t{\n+\t  fputs (g->specific_st->name, dumpfile);\n+\t  if (g->next)\n+\t    fputs (\", \", dumpfile);\n+\t}\n+    }\n+  else\n+    fputs (st->typebound->u.specific->n.sym->name, dumpfile);\n+}\n+\n+static void\n+show_f2k_derived (gfc_namespace* f2k)\n+{\n+  gfc_finalizer* f;\n+\n+  ++show_level;\n+\n+  /* Finalizer bindings.  */\n+  for (f = f2k->finalizers; f; f = f->next)\n+    {\n+      show_indent ();\n+      fprintf (dumpfile, \"FINAL %s\", f->proc_sym->name);\n+    }\n+\n+  /* Type-bound procedures.  */\n+  gfc_traverse_symtree (f2k->sym_root, &show_typebound);\n+\n+  --show_level;\n+}\n+\n+\n /* Show a symbol.  If a symbol is an ENTRY, SUBROUTINE or FUNCTION, we\n    show the interface.  Information needed to reconstruct the list of\n    specific interfaces associated with a generic symbol is done within\n@@ -701,6 +791,13 @@ show_symbol (gfc_symbol *sym)\n       show_components (sym);\n     }\n \n+  if (sym->f2k_derived)\n+    {\n+      show_indent ();\n+      fputs (\"Procedure bindings:\\n\", dumpfile);\n+      show_f2k_derived (sym->f2k_derived);\n+    }\n+\n   if (sym->formal)\n     {\n       show_indent ();\n@@ -1110,6 +1207,11 @@ show_code_node (int level, gfc_code *c)\n       show_actual_arglist (c->ext.actual);\n       break;\n \n+    case EXEC_COMPCALL:\n+      fputs (\"CALL \", dumpfile);\n+      show_compcall (c->expr);\n+      break;\n+\n     case EXEC_RETURN:\n       fputs (\"RETURN \", dumpfile);\n       if (c->expr)"}, {"sha": "9cb5a54e4b47cc0ac5ce95804694619571aa1b21", "filename": "gcc/fortran/gfc-internals.texi", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fgfc-internals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fgfc-internals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfc-internals.texi?ref=a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "patch": "@@ -118,6 +118,7 @@ not accurately reflect the status of the most recent GNU Fortran compiler.\n * User Interface::         Code that Interacts with the User.\n * Frontend Data Structures::\n                            Data structures used by the frontend\n+* Object Orientation::     Internals of Fortran 2003 OOP features.\n * LibGFortran::            The LibGFortran Runtime Library.\n * GNU Free Documentation License::\n                            How you can copy and share this manual.\n@@ -466,6 +467,13 @@ function symbol if the call is to an intrinsic or external function,\n respectively.  These values are determined during resolution-phase from the\n structure's @code{symtree} member.\n \n+A special case of function calls are ``component calls'' to type-bound\n+procedures; those have the @code{expr_type} @code{EXPR_COMPCALL} with\n+@code{value.compcall} containing the argument list and the procedure called,\n+while @code{symtree} and @code{ref} describe the object on which the procedure\n+was called in the same way as a @code{EXPR_VARIABLE} expression would.\n+@xref{Type-bound Procedures}.\n+\n \n @subsection Array- and Structure-Constructors\n \n@@ -551,6 +559,96 @@ was a string constant, but the @code{ref} member is also set and points to a\n substring reference as described in the subsection above.\n \n \n+@c ---------------------------------------------------------------------\n+@c F2003 OOP\n+@c ---------------------------------------------------------------------\n+\n+@node Object Orientation\n+@chapter Internals of Fortran 2003 OOP Features\n+\n+@menu\n+* Type-bound Procedures:: Type-bound procedures.\n+@end menu\n+\n+\n+@c Type-bound procedures\n+@c ---------------------\n+\n+@node Type-bound Procedures\n+@section Type-bound Procedures\n+\n+Type-bound procedures are stored in the @code{sym_root} of the namespace\n+@code{f2k_derived} associated with the derived-type symbol as @code{gfc_symtree}\n+nodes.  The name and symbol of these symtrees corresponds to the binding-name\n+of the procedure, i.e. the name that is used to call it from the context of an\n+object of the derived-type.\n+\n+In addition, those and only those symtrees representing a type-bound procedure\n+have their @code{typebound} member set; @code{typebound} points to a struct of\n+type @code{gfc_typebound_proc} containing the additional data needed:  The\n+binding attributes (like @code{PASS} and @code{NOPASS}, @code{NON_OVERRIDABLE} \n+or the access-specifier), the binding's target(s) and, if the current binding\n+overrides or extends an inherited binding of the same name, @code{overridden}\n+points to this binding's @code{gfc_typebound_proc} structure.\n+\n+\n+@subsection Specific Bindings\n+@c --------------------------\n+\n+For specific bindings (declared with @code{PROCEDURE}), if they have a\n+passed-object argument, the passed-object dummy argument is first saved by its\n+name, and later during resolution phase the corresponding argument is looked for\n+and its position remembered as @code{pass_arg_num} in @code{gfc_typebound_proc}.\n+The binding's target procedure is pointed-to by @code{u.specific}.\n+\n+At the moment, all type-bound procedure calls are statically dispatched and\n+transformed into ordinary procedure calls at resolution time; their actual\n+argument list is updated to include at the right position the passed-object\n+argument, if applicable, and then a simple procedure call to the binding's\n+target procedure is built.  To handle dynamic dispatch in the future, this will\n+be extended to allow special code generation during the trans-phase to dispatch\n+based on the object's dynamic type.\n+\n+\n+@subsection Generic Bindings\n+@c -------------------------\n+\n+Bindings declared as @code{GENERIC} store the specific bindings they target as\n+a linked list using nodes of type @code{gfc_tbp_generic} in @code{u.generic}.\n+For each specific target, the parser records its symtree and during resolution\n+this symtree is bound to the corresponding @code{gfc_typebound_proc} structure\n+of the specific target.\n+\n+Calls to generic bindings are handled entirely in the resolution-phase, where\n+for the actual argument list present the matching specific binding is found\n+and the call's target procedure (@code{value.compcall.tbp}) is re-pointed to\n+the found specific binding and this call is subsequently handled by the logic\n+for specific binding calls.\n+\n+\n+@subsection Calls to Type-bound Procedures\n+@c ---------------------------------------\n+\n+Calls to type-bound procedures are stored in the parse-tree as @code{gfc_expr}\n+nodes of type @code{EXPR_COMPCALL}.  Their @code{value.compcall.actual} saves\n+the actual argument list of the call and @code{value.compcall.tbp} points to the\n+@code{gfc_typebound_proc} structure of the binding to be called.  The object\n+in whose context the procedure was called is saved by combination of\n+@code{symtree} and @code{ref}, as if the expression was of type\n+@code{EXPR_VARIABLE}.\n+\n+For code like this:\n+@smallexample\n+CALL myobj%procedure (arg1, arg2)\n+@end smallexample\n+@noindent\n+the @code{CALL} is represented in the parse-tree as a @code{gfc_code} node of\n+type @code{EXEC_COMPCALL}.  The @code{expr} member of this node holds an\n+expression of type @code{EXPR_COMPCALL} of the same structure as mentioned above\n+except that its target procedure is of course a @code{SUBROUTINE} and not a\n+@code{FUNCTION}.\n+\n+\n @c ---------------------------------------------------------------------\n @c LibGFortran\n @c ---------------------------------------------------------------------"}, {"sha": "400ef3950050ac16b0c8b424a7b753671cfe375f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "patch": "@@ -1593,7 +1593,6 @@ typedef struct gfc_expr\n     {\n       gfc_actual_arglist* actual;\n       gfc_typebound_proc* tbp;\n-      gfc_symbol* derived;\n       const char* name;\n     }\n     compcall;"}, {"sha": "c18774962fcede273d9b680eaf95f94a511915c9", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a64a8f2f267e1151d2c873aa3e02c7abe4fd4990/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=a64a8f2f267e1151d2c873aa3e02c7abe4fd4990", "patch": "@@ -1779,7 +1779,6 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n \n \t  primary->expr_type = EXPR_COMPCALL;\n \t  primary->value.compcall.tbp = tbp->typebound;\n-\t  primary->value.compcall.derived = sym;\n \t  primary->value.compcall.name = tbp->name;\n \t  gcc_assert (primary->symtree->n.sym->attr.referenced);\n \t  if (tbp_sym)"}]}