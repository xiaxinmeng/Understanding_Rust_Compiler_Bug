{"sha": "a36c54fabab4595c4161a79e26e045cd1597c971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2YzU0ZmFiYWI0NTk1YzQxNjFhNzllMjZlMDQ1Y2QxNTk3Yzk3MQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-12T19:33:08Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-12T19:33:08Z"}, "message": "cppfiles.c: Update comments.\n\n        * cppfiles.c: Update comments.\n\t(destroy_include_file_node): Rename destroy_node.\n\t(find_or_create_entry): New function.\n\t(open_file, _cpp_fake_include): Use it.\n\t(handle_missing_header): New function, broken out of\n\t_cpp_execute include.  Don't segfault if there is no\n\tsystem or quoted path.\n\t(_cpp_execute_include): Use handle_missing_header.\n\nFrom-SVN: r40423", "tree": {"sha": "3888ea0f212aaf4b34b075ff3e0afebc5629539e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3888ea0f212aaf4b34b075ff3e0afebc5629539e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a36c54fabab4595c4161a79e26e045cd1597c971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a36c54fabab4595c4161a79e26e045cd1597c971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a36c54fabab4595c4161a79e26e045cd1597c971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a36c54fabab4595c4161a79e26e045cd1597c971/comments", "author": null, "committer": null, "parents": [{"sha": "e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae"}], "stats": {"total": 232, "additions": 127, "deletions": 105}, "files": [{"sha": "5870db9119c90ae33a1803ccde880b8b6a966112", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a36c54fabab4595c4161a79e26e045cd1597c971/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a36c54fabab4595c4161a79e26e045cd1597c971/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a36c54fabab4595c4161a79e26e045cd1597c971", "patch": "@@ -1,3 +1,14 @@\n+2001-03-12  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * cppfiles.c: Update comments.\n+\t(destroy_include_file_node): Rename destroy_node.\n+\t(find_or_create_entry): New function.\n+\t(open_file, _cpp_fake_include): Use it.\n+\t(handle_missing_header): New function, broken out of\n+\t_cpp_execute include.  Don't segfault if there is no\n+\tsystem or quoted path.\n+\t(_cpp_execute_include): Use handle_missing_header.\n+\n 2001-03-12  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* jump.c (reversed_comparison_code_parts): Reverse Jan Hubricka's"}, {"sha": "197a8bcaa4118029d657957d68b3684740f65f61", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 116, "deletions": 105, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a36c54fabab4595c4161a79e26e045cd1597c971/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a36c54fabab4595c4161a79e26e045cd1597c971/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=a36c54fabab4595c4161a79e26e045cd1597c971", "patch": "@@ -97,44 +97,56 @@ static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n static void read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void purge_cache \tPARAMS ((struct include_file *));\n-static void destroy_include_file_node\tPARAMS ((splay_tree_value));\n+static void destroy_node\tPARAMS ((splay_tree_value));\n static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n-\n-/* We use a splay tree to store information about all the include\n-   files seen in this compilation.  The key of each tree node is the\n-   physical path to the file.  The value is 0 if the file does not\n-   exist, or a struct include_file pointer.  */\n-\n-static void\n-destroy_include_file_node (v)\n-     splay_tree_value v;\n-{\n-  struct include_file *f = (struct include_file *)v;\n-\n-  if (f)\n-    {\n-      purge_cache (f);\n-      free (f);  /* The tree is registered with free to free f->name.  */\n-    }\n-}\n-\n+static splay_tree_node find_or_create_entry PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t     const char *));\n+static void handle_missing_header PARAMS ((cpp_reader *, const char *, int));\n+\n+/* Set up the splay tree we use to store information about all the\n+   file names seen in this compilation.  We also have entries for each\n+   file we tried to open but failed; this saves system calls since we\n+   don't try to open it again in future.\n+\n+   The key of each node is the file name, after processing by\n+   _cpp_simplify_pathname.  The path name may or may not be absolute.\n+   The path string has been malloced, as is automatically freed by\n+   registering free () as the splay tree key deletion function.\n+\n+   A node's value is a pointer to a struct include_file, and is never\n+   NULL.  */\n void\n _cpp_init_includes (pfile)\n      cpp_reader *pfile;\n {\n   pfile->all_include_files\n     = splay_tree_new ((splay_tree_compare_fn) strcmp,\n \t\t      (splay_tree_delete_key_fn) free,\n-\t\t      destroy_include_file_node);\n+\t\t      destroy_node);\n }\n \n+/* Tear down the splay tree.  */\n void\n _cpp_cleanup_includes (pfile)\n      cpp_reader *pfile;\n {\n   splay_tree_delete (pfile->all_include_files);\n }\n \n+/* Free a node.  The path string is automatically freed.  */\n+static void\n+destroy_node (v)\n+     splay_tree_value v;\n+{\n+  struct include_file *f = (struct include_file *)v;\n+\n+  if (f)\n+    {\n+      purge_cache (f);\n+      free (f);\n+    }\n+}\n+\n /* Mark a file to not be reread (e.g. #import, read failure).  */\n void\n _cpp_never_reread (file)\n@@ -143,24 +155,36 @@ _cpp_never_reread (file)\n   file->cmacro = NEVER_REREAD;\n }\n \n-/* Put a file name in the splay tree, for the sake of cpp_included ().\n-   Assume that FNAME has already had its path simplified.  */\n-void\n-_cpp_fake_include (pfile, fname)\n+/* Lookup a simplified filename, and create an entry if none exists.  */\n+static splay_tree_node\n+find_or_create_entry (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  splay_tree_node nd;\n+  splay_tree_node node;\n+  struct include_file *file;\n \n-  nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) fname);\n-  if (! nd)\n+  node = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) fname);\n+  if (! node)\n     {\n-      struct include_file *file = xcnew (struct include_file);\n+      file = xcnew (struct include_file);\n       file->name = xstrdup (fname);\n-      splay_tree_insert (pfile->all_include_files,\n-\t\t\t (splay_tree_key) file->name,\n-\t\t\t (splay_tree_value) file);\n+      node = splay_tree_insert (pfile->all_include_files,\n+\t\t\t\t(splay_tree_key) file->name,\n+\t\t\t\t(splay_tree_value) file);\n     }\n+\n+  return node;\n+}\n+\n+/* Enter a simplified file name in the splay tree, for the sake of\n+   cpp_included ().  */\n+void\n+_cpp_fake_include (pfile, fname)\n+     cpp_reader *pfile;\n+     const char *fname;\n+{\n+  find_or_create_entry (pfile, fname);\n }\n \n /* Given a file name, look it up in the cache; if there is no entry,\n@@ -178,36 +202,20 @@ open_file (pfile, filename)\n      cpp_reader *pfile;\n      const char *filename;\n {\n-  splay_tree_node nd;\n-  struct include_file *file;\n-\n-  nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) filename);\n-\n-  if (nd)\n-    {\n-      file = (struct include_file *) nd->value;\n+  splay_tree_node nd = find_or_create_entry (pfile, filename);\n+  struct include_file *file = (struct include_file *) nd->value;\n \n-      /* Don't retry opening if we failed previously.  */\n-      if (file->fd == -2)\n-\treturn 0;\n+  /* Don't retry opening if we failed previously.  */\n+  if (file->fd == -2)\n+    return 0;\n \n-      /* Don't reopen an idempotent file. */\n-      if (DO_NOT_REREAD (file))\n-        return file;\n+  /* Don't reopen an idempotent file. */\n+  if (DO_NOT_REREAD (file))\n+    return file;\n       \n-      /* Don't reopen one which is already loaded. */\n-      if (file->buffer != NULL)\n-        return file;\n-    }\n-  else\n-    {\n-      /* In particular, this clears foundhere.  */\n-      file = xcnew (struct include_file);\n-      file->name = xstrdup (filename);\n-      splay_tree_insert (pfile->all_include_files,\n-\t\t\t (splay_tree_key) file->name,\n-\t\t\t (splay_tree_value) file);\n-    }\n+  /* Don't reopen one which is already loaded. */\n+  if (file->buffer != NULL)\n+    return file;\n \n   /* We used to open files in nonblocking mode, but that caused more\n      problems than it solved.  Do take care not to acquire a\n@@ -568,6 +576,54 @@ report_missing_guard (n, b)\n   return 0;\n }\n \n+/* Create a dependency, or issue an error message as appropriate.   */\n+static void\n+handle_missing_header (pfile, fname, angle_brackets)\n+     cpp_reader *pfile;\n+     const char *fname;\n+     int angle_brackets;\n+{\n+  /* We will try making the RHS pfile->buffer->sysp after 3.0.  */\n+  int print_dep = CPP_PRINT_DEPS(pfile) > (angle_brackets\n+\t\t\t\t\t   || pfile->system_include_depth);\n+  if (CPP_OPTION (pfile, print_deps_missing_files) && print_dep)\n+    {\n+      if (!angle_brackets || IS_ABSOLUTE_PATHNAME (fname))\n+\tdeps_add_dep (pfile->deps, fname);\n+      else\n+\t{\n+\t  /* If requested as a system header, assume it belongs in\n+\t     the first system header directory.  */\n+\t  struct search_path *ptr = CPP_OPTION (pfile, bracket_include);\n+\t  char *p;\n+\t  int len = 0, fname_len = strlen (fname);\n+\n+\t  if (ptr)\n+\t    len = ptr->len;\n+\n+\t  p = (char *) alloca (len + fname_len + 2);\n+\t  if (len)\n+\t    {\n+\t      memcpy (p, ptr->name, len);\n+\t      p[len++] = '/';\n+\t    }\n+\t  memcpy (p + len, fname, fname_len + 1);\n+\t  _cpp_simplify_pathname (p);\n+\t  deps_add_dep (pfile->deps, p);\n+\t}\n+    }\n+  /* If -M was specified, and this header file won't be added to\n+     the dependency list, then don't count this as an error,\n+     because we can still produce correct output.  Otherwise, we\n+     can't produce correct output, because there may be\n+     dependencies we need inside the missing file, and we don't\n+     know what directory this missing file exists in. */\n+  else if (CPP_PRINT_DEPS (pfile) && ! print_dep)\n+    cpp_warning (pfile, \"No include path in which to find %s\", fname);\n+  else\n+    cpp_error_from_errno (pfile, fname);\n+}\n+\n void\n _cpp_execute_include (pfile, header, no_reinclude, include_next)\n      cpp_reader *pfile;\n@@ -579,7 +635,6 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n   unsigned int angle_brackets = header->type == CPP_HEADER_NAME;\n   const char *fname = (const char *) header->val.str.text;\n   struct include_file *inc;\n-  int print_dep;\n \n   /* Help protect #include or similar from recursion.  */\n   if (pfile->buffer_stack_depth >= CPP_STACK_MAX)\n@@ -652,53 +707,9 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n \t      fprintf (stderr, \" %s\\n\", inc->name);\n \t    }\n \t}\n-\n-      return;\n     }\n-      \n-  /* We will try making the RHS pfile->buffer->sysp after 3.0.  */\n-  print_dep = CPP_PRINT_DEPS(pfile) > (angle_brackets\n-\t\t\t\t       || pfile->system_include_depth);\n-  if (CPP_OPTION (pfile, print_deps_missing_files) && print_dep)\n-    {\n-      if (!angle_brackets || IS_ABSOLUTE_PATHNAME (fname))\n-\tdeps_add_dep (pfile->deps, fname);\n-      else\n-\t{\n-\t  char *p;\n-\t  struct search_path *ptr;\n-\t  int len;\n-\n-\t  /* If requested as a system header, assume it belongs in\n-\t     the first system header directory.  */\n-\t  if (CPP_OPTION (pfile, bracket_include))\n-\t    ptr = CPP_OPTION (pfile, bracket_include);\n-\t  else\n-\t    ptr = CPP_OPTION (pfile, quote_include);\n-\n-\t  /* FIXME: ptr can be null, no?  */\n-\t  len = ptr->len;\n-\t  p = (char *) alloca (len + header->val.str.len + 2);\n-\t  if (len)\n-\t    {\n-\t      memcpy (p, ptr->name, len);\n-\t      p[len++] = '/';\n-\t    }\n-\t  memcpy (p + len, fname, header->val.str.len + 1);\n-\t  _cpp_simplify_pathname (p);\n-\t  deps_add_dep (pfile->deps, p);\n-\t}\n-    }\n-  /* If -M was specified, and this header file won't be added to\n-     the dependency list, then don't count this as an error,\n-     because we can still produce correct output.  Otherwise, we\n-     can't produce correct output, because there may be\n-     dependencies we need inside the missing file, and we don't\n-     know what directory this missing file exists in. */\n-  else if (CPP_PRINT_DEPS (pfile) && ! print_dep)\n-    cpp_warning (pfile, \"No include path in which to find %s\", fname);\n   else\n-    cpp_error_from_errno (pfile, fname);\n+    handle_missing_header (pfile, fname, angle_brackets);\n }\n \n /* Locate file F, and determine whether it is newer than PFILE. Return -1,"}]}