{"sha": "83737db21d7e440fe1332a23b9bbd6eaea85135a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM3MzdkYjIxZDdlNDQwZmUxMzMyYTIzYjliYmQ2ZWFlYTg1MTM1YQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-10-30T01:58:42Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-10-30T01:58:42Z"}, "message": "tree.h (tree_value_handle): Remove struct value_set declaration.\n\n2006-10-29  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree.h (tree_value_handle): Remove struct value_set declaration.\t\n\tChange value_set to bitmap_set.\n\t* tree-pretty-print.c (dump_generic_node): Use has_stmt_ann.\n\t* tree-vn.c (get_value_handle): Made inline and moved to\n\ttree-flow-inline.h.\n\t* tree-flow-inline.h: (has_stmt_ann): New function.\n\t* tree-ssa-pre.c (expressions): New variable.\n\t(next_expression_id): Ditto.\n\t(alloc_expression_id): New function.\n\t(struct value_set): Remove.\n\t(get_expression_id): New function.\n\t(get_or_alloc_expression_id): Ditto.\n\t(expression_for_id): Ditto.\n\t(clear_expression_ids): Ditto.\n\t(FOR_EACH_EXPR_ID_IN_SET): New macro.\n\t(bb_value_sets): Renamed to bb_bitmap_sets.\n\tAll value sets replaced with bitmap_sets.\n\tAdd visited member.\n\t(BB_VISITED): New macro.\n\t(postorder): New variable.\n\t(add_to_value): Removed.\n\t(value_exists_in_set_bitmap): Ditto.\n\t(value_insert_into_set_bitmap): Ditto.\n\t(set_new): Ditto.\n\t(set_copy): Ditto.\n\t(set_remove): Ditto.\n\t(set_contains_value): Ditto.\n\t(insert_into_set): Ditto.\n\t(set_equal): Ditto.\n\t(find_leader): Ditto.\n\t(bitmap_set_subtract_from_value_set): Ditto.\n\t(value_insert_into_set): Ditto.\n\t(print_value_set): Ditto.\n\t(debug_value_set): Ditto.\n\t(constant_expr_p): New function.\n\t(bitmap_remove_from_set): Ditto.\n\t(bitmap_insert_into_set): Ditto.\n\t(bitmap_set_free): Ditto.\n\t(vh_compare): Ditto.\n\t(sorted_array_from_bitmap_set): Ditto.\n\t(bitmap_set_subtract): Ditto.\n\t(bitmap_set_equal): Ditto.\n\t(debug_bitmap_set): Ditto.\n\t(find_leader_in_sets): Ditto.\n\t(bitmap_set_replace_value): Modify for bitmapped sets.\n\t(phi_translate): Ditto.\n\t(phi_translate_set): Ditto.\n\t(bitmap_find_leader): Ditto.\n\t(valid_in_sets): Ditto.\n\t(union_contains_value): Ditto.\n\t(clean): Ditto.\n\t(compute_antic_aux): Ditto.  Mark changed blocks.\n\t(compute_antic): Ditto. Iterate in postorder and only over\n\tchanging blocks.\n\t(compute_rvuse_and_antic_safe): Reuse postorder.\n\t(create_component_ref_by_pieces): Modify for bitmapped sets.\n\t(find_or_generate_expression): Ditto.\n\t(create_expression_by_pieces): Ditto.\n\t(insert_into_preds_of_block): Ditto.\n\t(changed_blocks): New variable.\n\t(do_regular_insertion): Broken out from insert_aux.\n\t(insert_aux): Modified for bitmapped sets.\n\t(find_existing_value_expr): New function.\n\t(create_value_expr_from): Use it.\n\t(insert_extra_phis): Removed.\n\t(print_bitmap_set): Renamed from bitmap_print_value_set.\n\t(compute_avail): Handle RETURN_EXPR.\n\t(init_pre): Modify for bitmapped sets.\n\t* tree-flow.h (has_stmt_ann): New function.\n\nFrom-SVN: r118169", "tree": {"sha": "a2c95dc5885e49e3d61cf5b9b0df8c0b651b00bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2c95dc5885e49e3d61cf5b9b0df8c0b651b00bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83737db21d7e440fe1332a23b9bbd6eaea85135a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83737db21d7e440fe1332a23b9bbd6eaea85135a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83737db21d7e440fe1332a23b9bbd6eaea85135a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83737db21d7e440fe1332a23b9bbd6eaea85135a/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c73bdc185341485061329f6eab27fd82450c593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c73bdc185341485061329f6eab27fd82450c593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c73bdc185341485061329f6eab27fd82450c593"}], "stats": {"total": 1689, "additions": 836, "deletions": 853}, "files": [{"sha": "91dc9e81aabfd5f30a840d973a12e638c73f784d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83737db21d7e440fe1332a23b9bbd6eaea85135a", "patch": "@@ -1,3 +1,75 @@\n+2006-10-29  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree.h (tree_value_handle): Remove struct value_set declaration.\t\n+\tChange value_set to bitmap_set.\n+\t* tree-pretty-print.c (dump_generic_node): Use has_stmt_ann.\n+\t* tree-vn.c (get_value_handle): Made inline and moved to\n+\ttree-flow-inline.h.\n+\t* tree-flow-inline.h: (has_stmt_ann): New function.\n+\t* tree-ssa-pre.c (expressions): New variable.\n+\t(next_expression_id): Ditto.\n+\t(alloc_expression_id): New function.\n+\t(struct value_set): Remove.\n+\t(get_expression_id): New function.\n+\t(get_or_alloc_expression_id): Ditto.\n+\t(expression_for_id): Ditto.\n+\t(clear_expression_ids): Ditto.\n+\t(FOR_EACH_EXPR_ID_IN_SET): New macro.\n+\t(bb_value_sets): Renamed to bb_bitmap_sets.\n+\tAll value sets replaced with bitmap_sets.\n+\tAdd visited member.\n+\t(BB_VISITED): New macro.\n+\t(postorder): New variable.\n+\t(add_to_value): Removed.\n+\t(value_exists_in_set_bitmap): Ditto.\n+\t(value_insert_into_set_bitmap): Ditto.\n+\t(set_new): Ditto.\n+\t(set_copy): Ditto.\n+\t(set_remove): Ditto.\n+\t(set_contains_value): Ditto.\n+\t(insert_into_set): Ditto.\n+\t(set_equal): Ditto.\n+\t(find_leader): Ditto.\n+\t(bitmap_set_subtract_from_value_set): Ditto.\n+\t(value_insert_into_set): Ditto.\n+\t(print_value_set): Ditto.\n+\t(debug_value_set): Ditto.\n+\t(constant_expr_p): New function.\n+\t(bitmap_remove_from_set): Ditto.\n+\t(bitmap_insert_into_set): Ditto.\n+\t(bitmap_set_free): Ditto.\n+\t(vh_compare): Ditto.\n+\t(sorted_array_from_bitmap_set): Ditto.\n+\t(bitmap_set_subtract): Ditto.\n+\t(bitmap_set_equal): Ditto.\n+\t(debug_bitmap_set): Ditto.\n+\t(find_leader_in_sets): Ditto.\n+\t(bitmap_set_replace_value): Modify for bitmapped sets.\n+\t(phi_translate): Ditto.\n+\t(phi_translate_set): Ditto.\n+\t(bitmap_find_leader): Ditto.\n+\t(valid_in_sets): Ditto.\n+\t(union_contains_value): Ditto.\n+\t(clean): Ditto.\n+\t(compute_antic_aux): Ditto.  Mark changed blocks.\n+\t(compute_antic): Ditto. Iterate in postorder and only over\n+\tchanging blocks.\n+\t(compute_rvuse_and_antic_safe): Reuse postorder.\n+\t(create_component_ref_by_pieces): Modify for bitmapped sets.\n+\t(find_or_generate_expression): Ditto.\n+\t(create_expression_by_pieces): Ditto.\n+\t(insert_into_preds_of_block): Ditto.\n+\t(changed_blocks): New variable.\n+\t(do_regular_insertion): Broken out from insert_aux.\n+\t(insert_aux): Modified for bitmapped sets.\n+\t(find_existing_value_expr): New function.\n+\t(create_value_expr_from): Use it.\n+\t(insert_extra_phis): Removed.\n+\t(print_bitmap_set): Renamed from bitmap_print_value_set.\n+\t(compute_avail): Handle RETURN_EXPR.\n+\t(init_pre): Modify for bitmapped sets.\n+\t* tree-flow.h (has_stmt_ann): New function.\n+\t\n 2006-10-29  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (fold_builtin_floor): Check for the availability of"}, {"sha": "ceb1bc918690e6d8dddfac99bb9907aee8e812b9", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=83737db21d7e440fe1332a23b9bbd6eaea85135a", "patch": "@@ -163,6 +163,17 @@ get_function_ann (tree var)\n   return (ann) ? ann : create_function_ann (var);\n }\n \n+/* Return true if T has a statement annotation attached to it.  */\n+\n+static inline bool\n+has_stmt_ann (tree t)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (is_gimple_stmt (t));\n+#endif\n+  return t->common.ann && t->common.ann->common.type == STMT_ANN;\n+}\n+\n /* Return the statement annotation for T, which must be a statement\n    node.  Return NULL if the statement annotation doesn't exist.  */\n static inline stmt_ann_t\n@@ -1620,4 +1631,32 @@ overlap_subvar (unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n \n }\n \n+/* Get the value handle of EXPR.  This is the only correct way to get\n+   the value handle for a \"thing\".  If EXPR does not have a value\n+   handle associated, it returns NULL_TREE.  \n+   NB: If EXPR is min_invariant, this function is *required* to return\n+   EXPR.  */\n+\n+static inline tree\n+get_value_handle (tree expr)\n+{\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    return SSA_NAME_VALUE (expr);\n+  else if (DECL_P (expr) || TREE_CODE (expr) == TREE_LIST\n+\t   || TREE_CODE (expr) == CONSTRUCTOR)\n+    {\n+      tree_ann_common_t ann = tree_common_ann (expr);\n+      return ((ann) ? ann->value_handle : NULL_TREE);\n+    }\n+  else if (is_gimple_min_invariant (expr))\n+    return expr;\n+  else if (EXPR_P (expr))\n+    {\n+      tree_ann_common_t ann = tree_common_ann (expr);\n+      return ((ann) ? ann->value_handle : NULL_TREE);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n #endif /* _TREE_FLOW_INLINE_H  */"}, {"sha": "daa19d4f823ca603ee433ab14dbad807ce8b0e83", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=83737db21d7e440fe1332a23b9bbd6eaea85135a", "patch": "@@ -344,6 +344,7 @@ static inline var_ann_t get_var_ann (tree);\n static inline function_ann_t function_ann (tree);\n static inline function_ann_t get_function_ann (tree);\n static inline stmt_ann_t stmt_ann (tree);\n+static inline bool has_stmt_ann (tree);\n static inline stmt_ann_t get_stmt_ann (tree);\n static inline enum tree_ann_type ann_type (tree_ann_t);\n static inline basic_block bb_for_stmt (tree);\n@@ -920,7 +921,7 @@ void print_value_expressions (FILE *, tree);\n \n /* In tree-vn.c  */\n bool expressions_equal_p (tree, tree);\n-tree get_value_handle (tree);\n+static inline tree get_value_handle (tree);\n hashval_t vn_compute (tree, hashval_t);\n void sort_vuses (VEC (tree, gc) *);\n tree vn_lookup_or_add (tree, tree);"}, {"sha": "0ef4e85554f27ff8549f1d846e98417a305746e1", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=83737db21d7e440fe1332a23b9bbd6eaea85135a", "patch": "@@ -421,10 +421,14 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n   is_expr = EXPR_P (node);\n \n+  /* We use has_stmt_ann because CALL_EXPR can be both an expression\n+     and a statement, and we have no guarantee that it will have a\n+     stmt_ann when it is used as an RHS expression.  stmt_ann will assert\n+     if you call it on something with a non-stmt annotation attached.  */\n   if (TREE_CODE (node) != ERROR_MARK\n       && is_gimple_stmt (node)\n       && (flags & TDF_VOPS)\n-      && stmt_ann (node)\n+      && has_stmt_ann (node)\n       && TREE_CODE (node) != PHI_NODE)\n     dump_vops (buffer, node, spc, flags);\n "}, {"sha": "d2d42316601c45cc19a8a9d954eca55bb36d96f4", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 717, "deletions": 821, "changes": 1538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=83737db21d7e440fe1332a23b9bbd6eaea85135a", "patch": "@@ -115,16 +115,16 @@ Boston, MA 02110-1301, USA.  */\n    Value numbers are represented using the \"value handle\" approach.\n    This means that each SSA_NAME (and for other reasons to be\n    disclosed in a moment, expression nodes) has a value handle that\n-   can be retrieved through get_value_handle.  This value handle, *is*\n+   can be retrieved through get_value_handle.  This value handle *is*\n    the value number of the SSA_NAME.  You can pointer compare the\n    value handles for equivalence purposes.\n \n    For debugging reasons, the value handle is internally more than\n-   just a number, it is a VAR_DECL named \"value.x\", where x is a\n+   just a number, it is a VALUE_HANDLE named \"VH.x\", where x is a\n    unique number for each value number in use.  This allows\n    expressions with SSA_NAMES replaced by value handles to still be\n-   pretty printed in a sane way.  They simply print as \"value.3 *\n-   value.5\", etc.\n+   pretty printed in a sane way.  They simply print as \"VH.3 *\n+   VH.5\", etc.\n \n    Expression nodes have value handles associated with them as a\n    cache.  Otherwise, we'd have to look them up again in the hash\n@@ -148,7 +148,7 @@ Boston, MA 02110-1301, USA.  */\n    this pass.\n \n    All of this also means that if you print the EXP_GEN or ANTIC sets,\n-   you will see \"value.5 + value.7\" in the set, instead of \"a_55 +\n+   you will see \"VH.5 + VH.7\" in the set, instead of \"a_55 +\n    b_66\" or something.  The only thing that actually cares about\n    seeing the value leaders is phi translation, and it needs to be\n    able to find the leader for a value in an arbitrary block, so this\n@@ -178,48 +178,82 @@ Boston, MA 02110-1301, USA.  */\n    useful only for debugging, since we don't do identity lookups.  */\n \n \n-static bool in_fre = false;\n+/* Next global expression id number.  */\n+static unsigned int next_expression_id;\n+\n+/* Mapping from expression to id number we can use in bitmap sets.  */\n+static VEC(tree, heap) *expressions;\n \n-/* A value set element.  Basically a single linked list of\n-   expressions/values.  */\n-typedef struct value_set_node\n+/* Allocate an expression id for EXPR.  */\n+\n+static inline unsigned int\n+alloc_expression_id (tree expr)\n {\n-  /* An expression.  */\n-  tree expr;\n+  tree_ann_common_t ann;\n \n-  /* A pointer to the next element of the value set.  */\n-  struct value_set_node *next;\n-} *value_set_node_t;\n+  ann = get_tree_common_ann (expr);\n \n+  /* Make sure we won't overflow. */\n+  gcc_assert (next_expression_id + 1 > next_expression_id);\n \n-/* A value set.  This is a singly linked list of value_set_node\n-   elements with a possible bitmap that tells us what values exist in\n-   the set.  This set must be kept in topologically sorted order.  */\n-typedef struct value_set\n+  ann->aux = XNEW (unsigned int);\n+  * ((unsigned int *)ann->aux) = next_expression_id++;\n+  VEC_safe_push (tree, heap, expressions, expr);\n+  return next_expression_id - 1;\n+}\n+\n+/* Return the expression id for tree EXPR.  */\n+\n+static inline unsigned int\n+get_expression_id (tree expr)\n {\n-  /* The head of the list.  Used for iterating over the list in\n-     order.  */\n-  value_set_node_t head;\n+  tree_ann_common_t ann = tree_common_ann (expr);\n+  gcc_assert (ann);\n+  gcc_assert (ann->aux);\n \n-  /* The tail of the list.  Used for tail insertions, which are\n-     necessary to keep the set in topologically sorted order because\n-     of how the set is built.  */\n-  value_set_node_t tail;\n+  return  *((unsigned int *)ann->aux);\n+}\n \n-  /* The length of the list.  */\n-  size_t length;\n+/* Return the existing expression id for EXPR, or create one if one\n+   does not exist yet.  */\n \n-  /* True if the set is indexed, which means it contains a backing\n-     bitmap for quick determination of whether certain values exist in the\n-     set.  */\n-  bool indexed;\n+static inline unsigned int\n+get_or_alloc_expression_id (tree expr)\n+{\n+  tree_ann_common_t ann = tree_common_ann (expr);\n \n-  /* The bitmap of values that exist in the set.  May be NULL in an\n-     empty or non-indexed set.  */\n-  bitmap values;\n+  if (ann == NULL || !ann->aux)\n+    return alloc_expression_id (expr);\n+\n+  return get_expression_id (expr);\n+}\n+\n+/* Return the expression that has expression id ID */\n+\n+static inline tree\n+expression_for_id (unsigned int id)\n+{\n+  return VEC_index (tree, expressions, id);\n+}\n \n-} *value_set_t;\n+/* Free the expression id field in all of our expressions,\n+   and then destroy the expressions array.  */\n \n+static void\n+clear_expression_ids (void)\n+{\n+  int i;\n+  tree expr;\n+\n+  for (i = 0; VEC_iterate (tree, expressions, i, expr); i++)\n+    {\n+      free (tree_common_ann (expr)->aux);\n+      tree_common_ann (expr)->aux = NULL;\n+    }\n+  VEC_free (tree, heap, expressions);\n+}\n+\n+static bool in_fre = false;\n \n /* An unordered bitmap set.  One bitmap tracks values, the other,\n    expressions.  */\n@@ -229,12 +263,15 @@ typedef struct bitmap_set\n   bitmap values;\n } *bitmap_set_t;\n \n+#define FOR_EACH_EXPR_ID_IN_SET(set, id, bi)\t\t\\\n+  EXECUTE_IF_SET_IN_BITMAP(set->expressions, 0, id, bi)\n+\n /* Sets that we need to keep track of.  */\n-typedef struct bb_value_sets\n+typedef struct bb_bitmap_sets\n {\n   /* The EXP_GEN set, which represents expressions/values generated in\n      a basic block.  */\n-  value_set_t exp_gen;\n+  bitmap_set_t exp_gen;\n \n   /* The PHI_GEN set, which represents PHI results generated in a\n      basic block.  */\n@@ -250,7 +287,7 @@ typedef struct bb_value_sets\n \n   /* The ANTIC_IN set, which represents which values are anticipatable\n      in a given basic block.  */\n-  value_set_t antic_in;\n+  bitmap_set_t antic_in;\n \n   /* The NEW_SETS set, which is used during insertion to augment the\n      AVAIL_OUT set of blocks with the new insertions performed during\n@@ -267,20 +304,27 @@ typedef struct bb_value_sets\n   /* For actually occurring loads, as long as they occur before all the\n      other stores in the block, we know they are antic at the top of\n      the block, regardless of RVUSE_KILL.  */\n-  value_set_t antic_safe_loads;\n-} *bb_value_sets_t;\n-\n-#define EXP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->exp_gen\n-#define PHI_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->phi_gen\n-#define TMP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->tmp_gen\n-#define AVAIL_OUT(BB)\t((bb_value_sets_t) ((BB)->aux))->avail_out\n-#define ANTIC_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->antic_in\n-#define RVUSE_IN(BB)    ((bb_value_sets_t) ((BB)->aux))->rvuse_in\n-#define RVUSE_GEN(BB)   ((bb_value_sets_t) ((BB)->aux))->rvuse_gen\n-#define RVUSE_KILL(BB)   ((bb_value_sets_t) ((BB)->aux))->rvuse_kill\n-#define RVUSE_OUT(BB)    ((bb_value_sets_t) ((BB)->aux))->rvuse_out\n-#define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n-#define ANTIC_SAFE_LOADS(BB) ((bb_value_sets_t) ((BB)->aux))->antic_safe_loads\n+  bitmap_set_t antic_safe_loads;\n+\n+  /* True if we have visited this block during antic calculation.  */\n+  unsigned int visited:1;\n+} *bb_bitmap_sets_t;\n+\n+#define EXP_GEN(BB)\t((bb_bitmap_sets_t) ((BB)->aux))->exp_gen\n+#define PHI_GEN(BB)\t((bb_bitmap_sets_t) ((BB)->aux))->phi_gen\n+#define TMP_GEN(BB)\t((bb_bitmap_sets_t) ((BB)->aux))->tmp_gen\n+#define AVAIL_OUT(BB)\t((bb_bitmap_sets_t) ((BB)->aux))->avail_out\n+#define ANTIC_IN(BB)\t((bb_bitmap_sets_t) ((BB)->aux))->antic_in\n+#define RVUSE_IN(BB)    ((bb_bitmap_sets_t) ((BB)->aux))->rvuse_in\n+#define RVUSE_GEN(BB)   ((bb_bitmap_sets_t) ((BB)->aux))->rvuse_gen\n+#define RVUSE_KILL(BB)   ((bb_bitmap_sets_t) ((BB)->aux))->rvuse_kill\n+#define RVUSE_OUT(BB)    ((bb_bitmap_sets_t) ((BB)->aux))->rvuse_out\n+#define NEW_SETS(BB)\t((bb_bitmap_sets_t) ((BB)->aux))->new_sets\n+#define ANTIC_SAFE_LOADS(BB) ((bb_bitmap_sets_t) ((BB)->aux))->antic_safe_loads\n+#define BB_VISITED(BB) ((bb_bitmap_sets_t) ((BB)->aux))->visited\n+\n+/* Basic block list in postorder.  */\n+static int *postorder;\n \n /* This structure is used to keep track of statistics on what\n    optimization PRE was able to perform.  */\n@@ -300,28 +344,21 @@ static struct\n \n } pre_stats;\n \n-\n static tree bitmap_find_leader (bitmap_set_t, tree);\n-static tree find_leader (value_set_t, tree);\n-static void value_insert_into_set (value_set_t, tree);\n static void bitmap_value_insert_into_set (bitmap_set_t, tree);\n static void bitmap_value_replace_in_set (bitmap_set_t, tree);\n-static void insert_into_set (value_set_t, tree);\n static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);\n static bool bitmap_set_contains_value (bitmap_set_t, tree);\n+static void bitmap_insert_into_set (bitmap_set_t, tree);\n static bitmap_set_t bitmap_set_new (void);\n-static value_set_t set_new  (bool);\n static bool is_undefined_value (tree);\n static tree create_expression_by_pieces (basic_block, tree, tree);\n static tree find_or_generate_expression (basic_block, tree, tree);\n \n-\n /* We can add and remove elements and entries to and from sets\n    and hash tables, so we use alloc pools for them.  */\n \n-static alloc_pool value_set_pool;\n static alloc_pool bitmap_set_pool;\n-static alloc_pool value_set_node_pool;\n static alloc_pool binary_node_pool;\n static alloc_pool unary_node_pool;\n static alloc_pool reference_node_pool;\n@@ -366,7 +403,6 @@ typedef struct expr_pred_trans_d\n   /* The value that resulted from the translation.  */\n   tree v;\n \n-\n   /* The hashcode for the expression, pred pair. This is cached for\n      speed reasons.  */\n   hashval_t hashcode;\n@@ -465,63 +501,31 @@ phi_trans_add (tree e, tree v, basic_block pred, VEC (tree, gc) *vuses)\n }\n \n \n-/* Add expression E to the expression set of value V.  */\n-\n-void\n-add_to_value (tree v, tree e)\n-{\n-  /* Constants have no expression sets.  */\n-  if (is_gimple_min_invariant (v))\n-    return;\n-\n-  if (VALUE_HANDLE_EXPR_SET (v) == NULL)\n-    VALUE_HANDLE_EXPR_SET (v) = set_new (false);\n-\n-  insert_into_set (VALUE_HANDLE_EXPR_SET (v), e);\n-}\n-\n-\n-/* Return true if value V exists in the bitmap for SET.  */\n+/* Return true if V is a value expression that represents itself.\n+   In our world, this is *only* non-value handles.  */\n \n static inline bool\n-value_exists_in_set_bitmap (value_set_t set, tree v)\n+constant_expr_p (tree v)\n {\n-  if (!set->values)\n-    return false;\n-\n-  return bitmap_bit_p (set->values, VALUE_HANDLE_ID (v));\n+  return TREE_CODE (v) != VALUE_HANDLE && is_gimple_min_invariant (v);\n+/*   return TREE_CODE (v) != VALUE_HANDLE; */\n }\n \n+/* Add expression E to the expression set of value V.  */\n \n-/* Remove value V from the bitmap for SET.  */\n-\n-static void\n-value_remove_from_set_bitmap (value_set_t set, tree v)\n+void\n+add_to_value (tree v, tree e)\n {\n-  gcc_assert (set->indexed);\n-\n-  if (!set->values)\n+  /* Constants have no expression sets.  */\n+  if (constant_expr_p (v))\n     return;\n \n-  bitmap_clear_bit (set->values, VALUE_HANDLE_ID (v));\n-}\n-\n-\n-/* Insert the value number V into the bitmap of values existing in\n-   SET.  */\n-\n-static inline void\n-value_insert_into_set_bitmap (value_set_t set, tree v)\n-{\n-  gcc_assert (set->indexed);\n-\n-  if (set->values == NULL)\n-    set->values = BITMAP_ALLOC (&grand_bitmap_obstack);\n+  if (VALUE_HANDLE_EXPR_SET (v) == NULL)\n+    VALUE_HANDLE_EXPR_SET (v) = bitmap_set_new ();\n \n-  bitmap_set_bit (set->values, VALUE_HANDLE_ID (v));\n+  bitmap_insert_into_set (VALUE_HANDLE_EXPR_SET (v), e);\n }\n \n-\n /* Create a new bitmap set and return it.  */\n \n static bitmap_set_t\n@@ -533,67 +537,33 @@ bitmap_set_new (void)\n   return ret;\n }\n \n-/* Create a new set.  */\n-\n-static value_set_t\n-set_new  (bool indexed)\n-{\n-  value_set_t ret;\n-  ret = (value_set_t) pool_alloc (value_set_pool);\n-  ret->head = ret->tail = NULL;\n-  ret->length = 0;\n-  ret->indexed = indexed;\n-  ret->values = NULL;\n-  return ret;\n-}\n-\n-/* Insert an expression EXPR into a bitmapped set.  */\n+/* Remove an expression EXPR from a bitmapped set.  */\n \n static void\n-bitmap_insert_into_set (bitmap_set_t set, tree expr)\n+bitmap_remove_from_set (bitmap_set_t set, tree expr)\n {\n-  tree val;\n-  /* XXX: For now, we only let SSA_NAMES into the bitmap sets.  */\n-  gcc_assert (TREE_CODE (expr) == SSA_NAME);\n-  val = get_value_handle (expr);\n+  tree val = get_value_handle (expr);\n \n   gcc_assert (val);\n-  if (!is_gimple_min_invariant (val))\n-  {\n-    bitmap_set_bit (set->values, VALUE_HANDLE_ID (val));\n-    bitmap_set_bit (set->expressions, SSA_NAME_VERSION (expr));\n-  }\n+  if (!constant_expr_p (val))\n+    {\n+      bitmap_clear_bit (set->values, VALUE_HANDLE_ID (val));\n+      bitmap_clear_bit (set->expressions, get_expression_id (expr));\n+    }\n }\n \n-/* Insert EXPR into SET.  */\n+/* Insert an expression EXPR into a bitmapped set.  */\n \n static void\n-insert_into_set (value_set_t set, tree expr)\n+bitmap_insert_into_set (bitmap_set_t set, tree expr)\n {\n-  value_set_node_t newnode = (value_set_node_t) pool_alloc (value_set_node_pool);\n   tree val = get_value_handle (expr);\n-  gcc_assert (val);\n-\n-  if (is_gimple_min_invariant (val))\n-    return;\n \n-  /* For indexed sets, insert the value into the set value bitmap.\n-     For all sets, add it to the linked list and increment the list\n-     length.  */\n-  if (set->indexed)\n-    value_insert_into_set_bitmap (set, val);\n-\n-  newnode->next = NULL;\n-  newnode->expr = expr;\n-  set->length ++;\n-  if (set->head == NULL)\n-    {\n-      set->head = set->tail = newnode;\n-    }\n-  else\n+  gcc_assert (val);\n+  if (!constant_expr_p (val))\n     {\n-      set->tail->next = newnode;\n-      set->tail = newnode;\n+      bitmap_set_bit (set->values, VALUE_HANDLE_ID (val));\n+      bitmap_set_bit (set->expressions, get_or_alloc_expression_id (expr));\n     }\n }\n \n@@ -606,142 +576,110 @@ bitmap_set_copy (bitmap_set_t dest, bitmap_set_t orig)\n   bitmap_copy (dest->values, orig->values);\n }\n \n-/* Perform bitmapped set operation DEST &= ORIG.  */\n \n+/* Free memory used up by SET.  */\n static void\n-bitmap_set_and (bitmap_set_t dest, bitmap_set_t orig)\n+bitmap_set_free (bitmap_set_t set)\n {\n-  bitmap_iterator bi;\n-  unsigned int i;\n-  bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n-\n-  bitmap_and_into (dest->values, orig->values);\n-  bitmap_copy (temp, dest->expressions);\n-  EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n-    {\n-      tree name = ssa_name (i);\n-      tree val = get_value_handle (name);\n-      if (!bitmap_bit_p (dest->values, VALUE_HANDLE_ID (val)))\n-\tbitmap_clear_bit (dest->expressions, i);\n-    }\n-  BITMAP_FREE (temp);\n+  BITMAP_FREE (set->expressions);\n+  BITMAP_FREE (set->values);\n }\n \n-/* Perform bitmapped value set operation DEST = DEST & ~ORIG.  */\n \n-static void\n-bitmap_set_and_compl (bitmap_set_t dest, bitmap_set_t orig)\n+/* A comparison function for use in qsort to top sort a bitmap set.  Simply\n+   subtracts value handle ids, since they are created in topo-order.  */\n+\n+static int\n+vh_compare (const void *pa, const void *pb)\n {\n-  bitmap_iterator bi;\n-  unsigned int i;\n-  bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n+  const tree vha = get_value_handle (*((const tree *)pa));\n+  const tree vhb = get_value_handle (*((const tree *)pb));\n \n-  bitmap_and_compl_into (dest->values, orig->values);\n-  bitmap_copy (temp, dest->expressions);\n-  EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n+  /* This can happen when we constify things.  */\n+  if (constant_expr_p (vha))\n     {\n-      tree name = ssa_name (i);\n-      tree val = get_value_handle (name);\n-      if (!bitmap_bit_p (dest->values, VALUE_HANDLE_ID (val)))\n-\tbitmap_clear_bit (dest->expressions, i);\n+      if (constant_expr_p (vhb))\n+\treturn -1;\n+      return -1;\n     }\n-  BITMAP_FREE (temp);\n+  else if (constant_expr_p (vhb))\n+    return 1;\n+  return VALUE_HANDLE_ID (vha) - VALUE_HANDLE_ID (vhb);\n }\n \n-/* Return true if the bitmap set SET is empty.  */\n+/* Generate an topological-ordered array of bitmap set SET.  */\n \n-static bool\n-bitmap_set_empty_p (bitmap_set_t set)\n+static VEC(tree, heap) *\n+sorted_array_from_bitmap_set (bitmap_set_t set)\n {\n-  return bitmap_empty_p (set->values);\n-}\n+  unsigned int i;\n+  bitmap_iterator bi;\n+  VEC(tree, heap) *result = NULL;\n \n-/* Copy the set ORIG to the set DEST.  */\n+  FOR_EACH_EXPR_ID_IN_SET (set, i, bi)\n+    VEC_safe_push (tree, heap, result, expression_for_id (i));\n \n-static void\n-set_copy (value_set_t dest, value_set_t orig)\n-{\n-  value_set_node_t node;\n-\n-  if (!orig || !orig->head)\n-    return;\n+  qsort (VEC_address (tree, result), VEC_length (tree, result),\n+\t sizeof (tree), vh_compare);\n \n-  for (node = orig->head;\n-       node;\n-       node = node->next)\n-    {\n-      insert_into_set (dest, node->expr);\n-    }\n+  return result;\n }\n \n-/* Remove EXPR from SET.  */\n+/* Perform bitmapped set operation DEST &= ORIG.  */\n \n static void\n-set_remove (value_set_t set, tree expr)\n+bitmap_set_and (bitmap_set_t dest, bitmap_set_t orig)\n {\n-  value_set_node_t node, prev;\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  bitmap temp = BITMAP_ALLOC (&grand_bitmap_obstack);\n \n-  /* Remove the value of EXPR from the bitmap, decrement the set\n-     length, and remove it from the actual double linked list.  */\n-  value_remove_from_set_bitmap (set, get_value_handle (expr));\n-  set->length--;\n-  prev = NULL;\n-  for (node = set->head;\n-       node != NULL;\n-       prev = node, node = node->next)\n-    {\n-      if (node->expr == expr)\n-\t{\n-\t  if (prev == NULL)\n-\t    set->head = node->next;\n-\t  else\n-\t    prev->next= node->next;\n+  bitmap_and_into (dest->values, orig->values);\n \n-\t  if (node == set->tail)\n-\t    set->tail = prev;\n-\t  pool_free (value_set_node_pool, node);\n-\t  return;\n-\t}\n+  bitmap_copy (temp, dest->expressions);\n+  EXECUTE_IF_SET_IN_BITMAP (temp, 0, i, bi)\n+    {\n+      tree expr = expression_for_id (i);\n+      tree val = get_value_handle (expr);\n+      if (!bitmap_bit_p (dest->values, VALUE_HANDLE_ID (val)))\n+\tbitmap_clear_bit (dest->expressions, i);\n     }\n+  BITMAP_FREE (temp);\n }\n \n-/* Return true if SET contains the value VAL.  */\n+/* Subtract all values and expressions contained in ORIG from DEST.  */\n \n-static bool\n-set_contains_value (value_set_t set, tree val)\n+static bitmap_set_t\n+bitmap_set_subtract (bitmap_set_t dest, bitmap_set_t orig)\n {\n-  /* All constants are in every set.  */\n-  if (is_gimple_min_invariant (val))\n-    return true;\n-\n-  if (!set || set->length == 0)\n-    return false;\n+  bitmap_set_t result = bitmap_set_new ();\n+  bitmap_iterator bi;\n+  unsigned int i;\n \n-  return value_exists_in_set_bitmap (set, val);\n-}\n+  bitmap_and_compl (result->expressions, dest->expressions,\n+\t\t    orig->expressions);\n \n-/* Return true if bitmapped set SET contains the expression EXPR.  */\n-static bool\n-bitmap_set_contains (bitmap_set_t set, tree expr)\n-{\n-  /* All constants are in every set.  */\n-  if (is_gimple_min_invariant (get_value_handle (expr)))\n-    return true;\n+  FOR_EACH_EXPR_ID_IN_SET (result, i, bi)\n+    {\n+      tree expr = expression_for_id (i);\n+      tree val = get_value_handle (expr);\n+      bitmap_set_bit (result->values, VALUE_HANDLE_ID (val));\n+    }\n \n-  /* XXX: Bitmapped sets only contain SSA_NAME's for now.  */\n-  if (TREE_CODE (expr) != SSA_NAME)\n-    return false;\n-  return bitmap_bit_p (set->expressions, SSA_NAME_VERSION (expr));\n+  return result;\n }\n \n-\n /* Return true if bitmapped set SET contains the value VAL.  */\n \n static bool\n bitmap_set_contains_value (bitmap_set_t set, tree val)\n {\n-  if (is_gimple_min_invariant (val))\n+  if (constant_expr_p (val))\n     return true;\n+\n+  if (!set || bitmap_empty_p (set->expressions))\n+    return false;\n+\n   return bitmap_bit_p (set->values, VALUE_HANDLE_ID (val));\n }\n \n@@ -750,10 +688,13 @@ bitmap_set_contains_value (bitmap_set_t set, tree val)\n static void\n bitmap_set_replace_value (bitmap_set_t set, tree lookfor, tree expr)\n {\n-  value_set_t exprset;\n-  value_set_node_t node;\n-  if (is_gimple_min_invariant (lookfor))\n+  bitmap_set_t exprset;\n+  unsigned int i;\n+  bitmap_iterator bi;\n+\n+  if (constant_expr_p (lookfor))\n     return;\n+\n   if (!bitmap_set_contains_value (set, lookfor))\n     return;\n \n@@ -767,55 +708,23 @@ bitmap_set_replace_value (bitmap_set_t set, tree lookfor, tree expr)\n      significant lose for some cases, we can choose which set to walk\n      based on the set size.  */\n   exprset = VALUE_HANDLE_EXPR_SET (lookfor);\n-  for (node = exprset->head; node; node = node->next)\n+  FOR_EACH_EXPR_ID_IN_SET (exprset, i, bi)\n     {\n-      if (TREE_CODE (node->expr) == SSA_NAME)\n+      if (bitmap_bit_p (set->expressions, i))\n \t{\n-\t  if (bitmap_bit_p (set->expressions, SSA_NAME_VERSION (node->expr)))\n-\t    {\n-\t      bitmap_clear_bit (set->expressions, SSA_NAME_VERSION (node->expr));\n-\t      bitmap_set_bit (set->expressions, SSA_NAME_VERSION (expr));\n-\t      return;\n-\t    }\n+\t  bitmap_clear_bit (set->expressions, i);\n+\t  bitmap_set_bit (set->expressions, get_expression_id (expr));\n+\t  return;\n \t}\n     }\n }\n \n-/* Subtract bitmapped set B from value set A, and return the new set.  */\n-\n-static value_set_t\n-bitmap_set_subtract_from_value_set (value_set_t a, bitmap_set_t b,\n-\t\t\t\t    bool indexed)\n-{\n-  value_set_t ret = set_new (indexed);\n-  value_set_node_t node;\n-  for (node = a->head;\n-       node;\n-       node = node->next)\n-    {\n-      if (!bitmap_set_contains (b, node->expr))\n-\tinsert_into_set (ret, node->expr);\n-    }\n-  return ret;\n-}\n-\n-/* Return true if two sets are equal.  */\n+/* Return true if two bitmap sets are equal.  */\n \n static bool\n-set_equal (value_set_t a, value_set_t b)\n+bitmap_set_equal (bitmap_set_t a, bitmap_set_t b)\n {\n-  value_set_node_t node;\n-\n-  if (a->length != b->length)\n-    return false;\n-  for (node = a->head;\n-       node;\n-       node = node->next)\n-    {\n-      if (!set_contains_value (b, get_value_handle (node->expr)))\n-\treturn false;\n-    }\n-  return true;\n+  return bitmap_equal_p (a->values, b->values);\n }\n \n /* Replace an instance of EXPR's VALUE with EXPR in SET if it exists,\n@@ -825,6 +734,7 @@ static void\n bitmap_value_replace_in_set (bitmap_set_t set, tree expr)\n {\n   tree val = get_value_handle (expr);\n+\n   if (bitmap_set_contains_value (set, val))\n     bitmap_set_replace_value (set, val, expr);\n   else\n@@ -839,35 +749,18 @@ bitmap_value_insert_into_set (bitmap_set_t set, tree expr)\n {\n   tree val = get_value_handle (expr);\n \n-  if (is_gimple_min_invariant (val))\n+  if (constant_expr_p (val))\n     return;\n \n   if (!bitmap_set_contains_value (set, val))\n     bitmap_insert_into_set (set, expr);\n }\n \n-/* Insert the value for EXPR into SET, if it doesn't exist already.  */\n-\n-static void\n-value_insert_into_set (value_set_t set, tree expr)\n-{\n-  tree val = get_value_handle (expr);\n-\n-  /* Constant and invariant values exist everywhere, and thus,\n-     actually keeping them in the sets is pointless.  */\n-  if (is_gimple_min_invariant (val))\n-    return;\n-\n-  if (!set_contains_value (set, val))\n-    insert_into_set (set, expr);\n-}\n-\n-\n /* Print out SET to OUTFILE.  */\n \n static void\n-bitmap_print_value_set (FILE *outfile, bitmap_set_t set,\n-\t\t\tconst char *setname, int blockindex)\n+print_bitmap_set (FILE *outfile, bitmap_set_t set,\n+\t\t  const char *setname, int blockindex)\n {\n   fprintf (outfile, \"%s[%d] := { \", setname, blockindex);\n   if (set)\n@@ -876,46 +769,29 @@ bitmap_print_value_set (FILE *outfile, bitmap_set_t set,\n       unsigned i;\n       bitmap_iterator bi;\n \n-      EXECUTE_IF_SET_IN_BITMAP (set->expressions, 0, i, bi)\n+      FOR_EACH_EXPR_ID_IN_SET (set, i, bi)\n \t{\n+\t  tree expr = expression_for_id (i);\n+\n \t  if (!first)\n \t    fprintf (outfile, \", \");\n \t  first = false;\n-\t  print_generic_expr (outfile, ssa_name (i), 0);\n+\t  print_generic_expr (outfile, expr, 0);\n \n \t  fprintf (outfile, \" (\");\n-\t  print_generic_expr (outfile, get_value_handle (ssa_name (i)), 0);\n+\t  print_generic_expr (outfile, get_value_handle (expr), 0);\n \t  fprintf (outfile, \") \");\n \t}\n     }\n   fprintf (outfile, \" }\\n\");\n }\n-/* Print out the value_set SET to OUTFILE.  */\n \n-static void\n-print_value_set (FILE *outfile, value_set_t set,\n-\t\t const char *setname, int blockindex)\n-{\n-  value_set_node_t node;\n-  fprintf (outfile, \"%s[%d] := { \", setname, blockindex);\n-  if (set)\n-    {\n-      for (node = set->head;\n-\t   node;\n-\t   node = node->next)\n-\t{\n-\t  print_generic_expr (outfile, node->expr, 0);\n-\n-\t  fprintf (outfile, \" (\");\n-\t  print_generic_expr (outfile, get_value_handle (node->expr), 0);\n-\t  fprintf (outfile, \") \");\n-\n-\t  if (node->next)\n-\t    fprintf (outfile, \", \");\n-\t}\n-    }\n+void debug_bitmap_set (bitmap_set_t);\n \n-  fprintf (outfile, \" }\\n\");\n+void\n+debug_bitmap_set (bitmap_set_t set)\n+{\n+  print_bitmap_set (stderr, set, \"debug\", 0);\n }\n \n /* Print out the expressions that have VAL to OUTFILE.  */\n@@ -927,7 +803,7 @@ print_value_expressions (FILE *outfile, tree val)\n     {\n       char s[10];\n       sprintf (s, \"VH.%04d\", VALUE_HANDLE_ID (val));\n-      print_value_set (outfile, VALUE_HANDLE_EXPR_SET (val), s, 0);\n+      print_bitmap_set (outfile, VALUE_HANDLE_EXPR_SET (val), s, 0);\n     }\n }\n \n@@ -938,15 +814,6 @@ debug_value_expressions (tree val)\n   print_value_expressions (stderr, val);\n }\n \n-\n-void debug_value_set (value_set_t, const char *, int);\n-\n-void\n-debug_value_set (value_set_t set, const char *setname, int blockindex)\n-{\n-  print_value_set (stderr, set, setname, blockindex);\n-}\n-\n /* Return the folded version of T if T, when folded, is a gimple\n    min_invariant.  Otherwise, return T.  */\n \n@@ -1016,6 +883,9 @@ translate_vuses_through_block (VEC (tree, gc) *vuses, basic_block block)\n \t    }\n \t}\n     }\n+\n+  /* We avoid creating a new copy of the vuses unless something\n+     actually changed, so result can be NULL.  */\n   if (result)\n     {\n       sort_vuses (result);\n@@ -1024,16 +894,33 @@ translate_vuses_through_block (VEC (tree, gc) *vuses, basic_block block)\n   return vuses;\n \n }\n+\n+/* Like find_leader, but checks for the value existing in SET1 *or*\n+   SET2.  This is used to avoid making a set consisting of the union\n+   of PA_IN and ANTIC_IN during insert.  */\n+\n+static inline tree\n+find_leader_in_sets (tree expr, bitmap_set_t set1, bitmap_set_t set2)\n+{\n+  tree result;\n+\n+  result = bitmap_find_leader (set1, expr);\n+  if (!result && set2)\n+    result = bitmap_find_leader (set2, expr);\n+  return result;\n+}\n+\n /* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n    the phis in PRED.  Return NULL if we can't find a leader for each\n    part of the translated expression.  */\n \n static tree\n-phi_translate (tree expr, value_set_t set, basic_block pred,\n-\t       basic_block phiblock)\n+phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n+\t       basic_block pred, basic_block phiblock)\n {\n   tree phitrans = NULL;\n   tree oldexpr = expr;\n+\n   if (expr == NULL)\n     return NULL;\n \n@@ -1066,8 +953,10 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \telse\n \t  {\n \t    tree oldop0 = TREE_OPERAND (expr, 0);\n+\t    tree oldval0 = oldop0;\n \t    tree oldarglist = TREE_OPERAND (expr, 1);\n \t    tree oldop2 = TREE_OPERAND (expr, 2);\n+\t    tree oldval2 = oldop2;\n \t    tree newop0;\n \t    tree newarglist;\n \t    tree newop2 = NULL;\n@@ -1086,15 +975,14 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t       sense, and just breaks the support functions we call,\n \t       which expect TREE_OPERAND (call_expr, 2) to be a\n \t       TREE_LIST. */\n-\n-\t    newop0 = phi_translate (find_leader (set, oldop0),\n-\t\t\t\t    set, pred, phiblock);\n+\t    oldval0 = find_leader_in_sets (oldop0, set1, set2);\n+\t    newop0 = phi_translate (oldval0, set1, set2, pred, phiblock);\n \t    if (newop0 == NULL)\n \t      return NULL;\n \t    if (oldop2)\n \t      {\n-\t\tnewop2 = phi_translate (find_leader (set, oldop2),\n-\t\t\t\t\tset, pred, phiblock);\n+\t\toldop2 = find_leader_in_sets (oldop2, set1, set2);\n+\t\tnewop2 = phi_translate (oldop2, set1, set2, pred, phiblock);\n \t\tif (newop2 == NULL)\n \t\t  return NULL;\n \t      }\n@@ -1128,8 +1016,9 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t\t       it occurs in the argument list.  */\n \t\t    if (AGGREGATE_TYPE_P (TREE_TYPE (oldval)))\n \t\t      return NULL;\n-\t\t    newval = phi_translate (find_leader (set, oldval),\n-\t\t\t\t\t    set, pred, phiblock);\n+\t\t    oldval = find_leader_in_sets (oldval, set1, set2);\n+\t\t    newval = phi_translate (oldval, set1, set2, pred,\n+\t\t\t\t\t    phiblock);\n \t\t    if (newval == NULL)\n \t\t      return NULL;\n \t\t    if (newval != oldval)\n@@ -1165,9 +1054,9 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t      {\n \t\tnewexpr = (tree) pool_alloc (expression_node_pool);\n \t\tmemcpy (newexpr, expr, tree_size (expr));\n-\t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldop0 : get_value_handle (newop0);\n+\t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldval0 : get_value_handle (newop0);\n \t\tTREE_OPERAND (newexpr, 1) = listchanged ? newarglist : oldarglist;\n-\t\tTREE_OPERAND (newexpr, 2) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n+\t\tTREE_OPERAND (newexpr, 2) = newop2 == oldop2 ? oldval2 : get_value_handle (newop2);\n \t\tnewexpr->common.ann = NULL;\n \t\tvn_lookup_or_add_with_vuses (newexpr, tvuses);\n \t\texpr = newexpr;\n@@ -1212,33 +1101,34 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t    && TREE_CODE (expr) != ARRAY_REF)\n \t  return NULL;\n \n-\tnewop0 = phi_translate (find_leader (set, oldop0),\n-\t\t\t\tset, pred, phiblock);\n+\toldop0 = find_leader_in_sets (oldop0, set1, set2);\n+\tnewop0 = phi_translate (oldop0, set1, set2, pred, phiblock);\n \tif (newop0 == NULL)\n \t  return NULL;\n \n \tif (TREE_CODE (expr) == ARRAY_REF)\n \t  {\n \t    oldop1 = TREE_OPERAND (expr, 1);\n-\t    newop1 = phi_translate (find_leader (set, oldop1),\n-\t\t\t\t    set, pred, phiblock);\n+\t    oldop1 = find_leader_in_sets (oldop1, set1, set2);\n+\t    newop1 = phi_translate (oldop1, set1, set2, pred, phiblock);\n \n \t    if (newop1 == NULL)\n \t      return NULL;\n+\n \t    oldop2 = TREE_OPERAND (expr, 2);\n \t    if (oldop2)\n \t      {\n-\t\tnewop2 = phi_translate (find_leader (set, oldop2),\n-\t\t\t\t\tset, pred, phiblock);\n+\t\toldop2 = find_leader_in_sets (oldop2, set1, set2);\n+\t\tnewop2 = phi_translate (oldop2, set1, set2, pred, phiblock);\n \n \t\tif (newop2 == NULL)\n \t\t  return NULL;\n \t      }\n \t    oldop3 = TREE_OPERAND (expr, 3);\n \t    if (oldop3)\n \t      {\n-\t\tnewop3 = phi_translate (find_leader (set, oldop3),\n-\t\t\t\t\tset, pred, phiblock);\n+\t\toldop3 = find_leader_in_sets (oldop3, set1, set2);\n+\t\tnewop3 = phi_translate (oldop3, set1, set2, pred, phiblock);\n \n \t\tif (newop3 == NULL)\n \t\t  return NULL;\n@@ -1256,7 +1146,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t  {\n \t    tree t;\n \n-\t    newexpr = pool_alloc (reference_node_pool);\n+\t    newexpr = (tree) pool_alloc (reference_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n \t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop0);\n \t    if (TREE_CODE (expr) == ARRAY_REF)\n@@ -1291,26 +1181,29 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n     case tcc_comparison:\n       {\n \ttree oldop1 = TREE_OPERAND (expr, 0);\n+\ttree oldval1 = oldop1;\n \ttree oldop2 = TREE_OPERAND (expr, 1);\n+\ttree oldval2 = oldop2;\n \ttree newop1;\n \ttree newop2;\n \ttree newexpr;\n \n-\tnewop1 = phi_translate (find_leader (set, oldop1),\n-\t\t\t\tset, pred, phiblock);\n+\toldop1 = find_leader_in_sets (oldop1, set1, set2);\n+\tnewop1 = phi_translate (oldop1, set1, set2, pred, phiblock);\n \tif (newop1 == NULL)\n \t  return NULL;\n-\tnewop2 = phi_translate (find_leader (set, oldop2),\n-\t\t\t\tset, pred, phiblock);\n+\n+\toldop2 = find_leader_in_sets (oldop2, set1, set2);\n+\tnewop2 = phi_translate (oldop2, set1, set2, pred, phiblock);\n \tif (newop2 == NULL)\n \t  return NULL;\n \tif (newop1 != oldop1 || newop2 != oldop2)\n \t  {\n \t    tree t;\n \t    newexpr = (tree) pool_alloc (binary_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n-\t    TREE_OPERAND (newexpr, 0) = newop1 == oldop1 ? oldop1 : get_value_handle (newop1);\n-\t    TREE_OPERAND (newexpr, 1) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n+\t    TREE_OPERAND (newexpr, 0) = newop1 == oldop1 ? oldval1 : get_value_handle (newop1);\n+\t    TREE_OPERAND (newexpr, 1) = newop2 == oldop2 ? oldval2 : get_value_handle (newop2);\n \t    t = fully_constant_expression (newexpr);\n \t    if (t != newexpr)\n \t      {\n@@ -1334,8 +1227,8 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \ttree newop1;\n \ttree newexpr;\n \n-\tnewop1 = phi_translate (find_leader (set, oldop1),\n-\t\t\t\tset, pred, phiblock);\n+\toldop1 = find_leader_in_sets (oldop1, set1, set2);\n+\tnewop1 = phi_translate (oldop1, set1, set2, pred, phiblock);\n \tif (newop1 == NULL)\n \t  return NULL;\n \tif (newop1 != oldop1)\n@@ -1392,17 +1285,24 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n    expressions in DEST.  */\n \n static void\n-phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n+phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n \t\t   basic_block phiblock)\n {\n-  value_set_node_t node;\n-  for (node = set->head;\n-       node;\n-       node = node->next)\n+  VEC (tree, heap) *exprs;\n+  tree expr;\n+  int i;\n+\n+  if (!phi_nodes (phiblock))\n     {\n-      tree translated;\n+      bitmap_set_copy (dest, set);\n+      return;\n+    }\n \n-      translated = phi_translate (node->expr, set, pred, phiblock);\n+  exprs = sorted_array_from_bitmap_set (set);\n+  for (i = 0; VEC_iterate (tree, exprs, i, expr); i++)\n+    {\n+      tree translated;\n+      translated = phi_translate (expr, set, NULL, pred, phiblock);\n \n       /* Don't add constants or empty translations to the cache, since\n \t we won't look them up that way, or use the result, anyway.  */\n@@ -1415,12 +1315,13 @@ phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n \t     which case, it has no vuses.  */\n \t  vuses = !is_gimple_min_invariant (vh)\n \t    ? VALUE_HANDLE_VUSES (vh) : NULL;\n-\t  phi_trans_add (node->expr, translated, pred, vuses);\n+\t  phi_trans_add (expr, translated, pred, vuses);\n \t}\n \n       if (translated != NULL)\n-\tvalue_insert_into_set (dest, translated);\n+\tbitmap_value_insert_into_set (dest, translated);\n     }\n+  VEC_free (tree, heap, exprs);\n }\n \n /* Find the leader for a value (i.e., the name representing that\n@@ -1433,8 +1334,9 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n   if (val == NULL)\n     return NULL;\n \n-  if (is_gimple_min_invariant (val))\n+  if (constant_expr_p (val))\n     return val;\n+\n   if (bitmap_set_contains_value (set, val))\n     {\n       /* Rather than walk the entire bitmap of expressions, and see\n@@ -1448,53 +1350,14 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n \t than walking the bitmap.\n \t If this is somehow a significant lose for some cases, we can\n \t choose which set to walk based on which set is smaller.  */\n-      value_set_t exprset;\n-      value_set_node_t node;\n-      exprset = VALUE_HANDLE_EXPR_SET (val);\n-      for (node = exprset->head; node; node = node->next)\n-\t{\n-\t  if (TREE_CODE (node->expr) == SSA_NAME)\n-\t    {\n-\t      if (bitmap_bit_p (set->expressions,\n-\t\t\t\tSSA_NAME_VERSION (node->expr)))\n-\t\treturn node->expr;\n-\t    }\n-\t}\n-    }\n-  return NULL;\n-}\n-\n-\n-/* Find the leader for a value (i.e., the name representing that\n-   value) in a given set, and return it.  Return NULL if no leader is\n-   found.  */\n-\n-static tree\n-find_leader (value_set_t set, tree val)\n-{\n-  value_set_node_t node;\n-\n-  if (val == NULL)\n-    return NULL;\n-\n-  /* Constants represent themselves.  */\n-  if (is_gimple_min_invariant (val))\n-    return val;\n-\n-  if (set->length == 0)\n-    return NULL;\n+      unsigned int i;\n+      bitmap_iterator bi;\n+      bitmap_set_t exprset = VALUE_HANDLE_EXPR_SET (val);\n \n-  if (value_exists_in_set_bitmap (set, val))\n-    {\n-      for (node = set->head;\n-\t   node;\n-\t   node = node->next)\n-\t{\n-\t  if (get_value_handle (node->expr) == val)\n-\t    return node->expr;\n-\t}\n+      EXECUTE_IF_AND_IN_BITMAP (exprset->expressions,\n+\t\t\t\tset->expressions, 0, i, bi)\n+\treturn expression_for_id (i);\n     }\n-\n   return NULL;\n }\n \n@@ -1533,17 +1396,23 @@ vuses_dies_in_block_x (VEC (tree, gc) *vuses, basic_block block)\n   return false;\n }\n \n-/* Determine if the expression EXPR is valid in SET.  This means that\n-   we have a leader for each part of the expression (if it consists of\n-   values), or the expression is an SSA_NAME.\n+/* Determine if the expression EXPR is valid in SET1 U SET2.\n+   ONLY SET2 CAN BE NULL.\n+   This means that we have a leader for each part of the expression\n+   (if it consists of values), or the expression is an SSA_NAME.\n \n    NB: We never should run into a case where we have SSA_NAME +\n-   SSA_NAME or SSA_NAME + value.  The sets valid_in_set is called on,\n+   SSA_NAME or SSA_NAME + value.  The sets valid_in_sets is called on,\n    the ANTIC sets, will only ever have SSA_NAME's or value expressions\n    (IE VALUE1 + VALUE2, *VALUE1, VALUE1 < VALUE2)  */\n \n+#define union_contains_value(SET1, SET2, VAL)\t\t\t\\\n+  (bitmap_set_contains_value ((SET1), (VAL))\t\t\t\\\n+   || ((SET2) && bitmap_set_contains_value ((SET2), (VAL))))\n+\n static bool\n-valid_in_set (value_set_t set, tree expr, basic_block block)\n+valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n+\t       basic_block block)\n {\n  tree vh = get_value_handle (expr);\n  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n@@ -1553,13 +1422,15 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n \ttree op2 = TREE_OPERAND (expr, 1);\n-\treturn set_contains_value (set, op1) && set_contains_value (set, op2);\n+\n+\treturn union_contains_value (set1, set2, op1)\n+\t  && union_contains_value (set1, set2, op2);\n       }\n \n     case tcc_unary:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n-\treturn set_contains_value (set, op1);\n+\treturn union_contains_value (set1, set2, op1);\n       }\n \n     case tcc_expression:\n@@ -1571,14 +1442,15 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n \t    tree op2 = TREE_OPERAND (expr, 2);\n \n \t    /* Check the non-list operands first.  */\n-\t    if (!set_contains_value (set, op0)\n-\t\t|| (op2 && !set_contains_value (set, op2)))\n+\t    if (!union_contains_value (set1, set2, op0)\n+\t\t|| (op2 && !union_contains_value (set1, set2, op2)))\n \t      return false;\n \n \t    /* Now check the operands.  */\n \t    for (; arglist; arglist = TREE_CHAIN (arglist))\n \t      {\n-\t\tif (!set_contains_value (set, TREE_VALUE (arglist)))\n+\t\ttree arg = TREE_VALUE (arglist);\n+\t\tif (!union_contains_value (set1, set2, arg))\n \t\t  return false;\n \t      }\n \t    return !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh), block);\n@@ -1590,43 +1462,42 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n       {\n \tif (TREE_CODE (expr) == INDIRECT_REF\n \t    || TREE_CODE (expr) == COMPONENT_REF\n-            || TREE_CODE (expr) == ARRAY_REF)\n+\t    || TREE_CODE (expr) == ARRAY_REF)\n \t  {\n \t    tree op0 = TREE_OPERAND (expr, 0);\n \t    gcc_assert (is_gimple_min_invariant (op0)\n \t\t\t|| TREE_CODE (op0) == VALUE_HANDLE);\n-\t    if (!set_contains_value (set, op0))\n+\t    if (!union_contains_value (set1, set2, op0))\n \t      return false;\n \t    if (TREE_CODE (expr) == ARRAY_REF)\n \t      {\n \t\ttree op1 = TREE_OPERAND (expr, 1);\n \t\ttree op2 = TREE_OPERAND (expr, 2);\n \t\ttree op3 = TREE_OPERAND (expr, 3);\n \t\tgcc_assert (is_gimple_min_invariant (op1)\n-\t\t            || TREE_CODE (op1) == VALUE_HANDLE);\n-\t\tif (!set_contains_value (set, op1))\n+\t\t\t    || TREE_CODE (op1) == VALUE_HANDLE);\n+\t\tif (!union_contains_value (set1, set2, op1))\n \t\t  return false;\n \t\tgcc_assert (!op2 || is_gimple_min_invariant (op2)\n-\t\t            || TREE_CODE (op2) == VALUE_HANDLE);\n+\t\t\t    || TREE_CODE (op2) == VALUE_HANDLE);\n \t\tif (op2\n-\t\t    && !set_contains_value (set, op2))\n+\t\t    && !union_contains_value (set1, set2, op2))\n \t\t  return false;\n \t\tgcc_assert (!op3 || is_gimple_min_invariant (op3)\n-\t\t            || TREE_CODE (op3) == VALUE_HANDLE);\n+\t\t\t    || TREE_CODE (op3) == VALUE_HANDLE);\n \t\tif (op3\n-\t\t    && !set_contains_value (set, op3))\n+\t\t    && !union_contains_value (set1, set2, op3))\n \t\t  return false;\n \t    }\n-\t  return set_contains_value (ANTIC_SAFE_LOADS (block),\n-\t\t\t\t     vh)\n+\t  return bitmap_set_contains_value (ANTIC_SAFE_LOADS (block),\n+\t\t\t\t\t    vh)\n \t    || !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh),\n \t\t\t\t       block);\n \t  }\n       }\n       return false;\n \n     case tcc_exceptional:\n-      gcc_assert (TREE_CODE (expr) == SSA_NAME);\n       return true;\n \n     case tcc_declaration:\n@@ -1643,22 +1514,27 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n    in SET.  */\n \n static void\n-clean (value_set_t set, basic_block block)\n+clean (bitmap_set_t set, basic_block block)\n {\n-  value_set_node_t node;\n-  value_set_node_t next;\n-  node = set->head;\n-  while (node)\n+  VEC (tree, heap) *exprs = sorted_array_from_bitmap_set (set);\n+  tree expr;\n+  int i;\n+\n+  for (i = 0; VEC_iterate (tree, exprs, i, expr); i++)\n     {\n-      next = node->next;\n-      if (!valid_in_set (set, node->expr, block))\n-\tset_remove (set, node->expr);\n-      node = next;\n+      if (!valid_in_sets (set, NULL, expr, block))\n+\tbitmap_remove_from_set (set, expr);\n     }\n+  VEC_free (tree, heap, exprs);\n }\n \n static sbitmap has_abnormal_preds;\n \n+\n+/* List of blocks that may have changed during ANTIC computation and\n+   thus need to be iterated over.  */\n+\n+static sbitmap changed_blocks;\n /* Compute the ANTIC set for BLOCK.\n \n    If succs(BLOCK) > 1 then\n@@ -1667,30 +1543,28 @@ static sbitmap has_abnormal_preds;\n      ANTIC_OUT[BLOCK] = phi_translate (ANTIC_IN[succ(BLOCK)])\n \n    ANTIC_IN[BLOCK] = clean(ANTIC_OUT[BLOCK] U EXP_GEN[BLOCK] - TMP_GEN[BLOCK])\n-\n-   XXX: It would be nice to either write a set_clear, and use it for\n-   ANTIC_OUT, or to mark the antic_out set as deleted at the end\n-   of this routine, so that the pool can hand the same memory back out\n-   again for the next ANTIC_OUT.  */\n+*/\n \n static bool\n compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n {\n-  basic_block son;\n   bool changed = false;\n-  value_set_t S, old, ANTIC_OUT;\n-  value_set_node_t node;\n+  bitmap_set_t S, old, ANTIC_OUT;\n+  bitmap_iterator bi;\n+  unsigned int bii;\n+  edge e;\n+  edge_iterator ei;\n \n-  ANTIC_OUT = S = NULL;\n+  old = ANTIC_OUT = S = NULL;\n \n   /* If any edges from predecessors are abnormal, antic_in is empty,\n      so do nothing.  */\n   if (block_has_abnormal_pred_edge)\n     goto maybe_dump_sets;\n \n-  old = set_new (false);\n-  set_copy (old, ANTIC_IN (block));\n-  ANTIC_OUT = set_new (true);\n+  old = ANTIC_IN (block);\n+  ANTIC_OUT = bitmap_set_new ();\n+  BB_VISITED (block) = 1;\n \n   /* If the block has no successors, ANTIC_OUT is empty.  */\n   if (EDGE_COUNT (block->succs) == 0)\n@@ -1699,129 +1573,159 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n      translate through.  */\n   else if (single_succ_p (block))\n     {\n-      phi_translate_set (ANTIC_OUT, ANTIC_IN (single_succ (block)),\n-\t\t\t block, single_succ (block));\n+      basic_block succ_bb = single_succ (block);\n+      phi_translate_set (ANTIC_OUT, ANTIC_IN (succ_bb),\n+\t\t\t block, succ_bb);\n     }\n   /* If we have multiple successors, we take the intersection of all of\n      them.  */\n   else\n     {\n       VEC(basic_block, heap) * worklist;\n-      edge e;\n       size_t i;\n       basic_block bprime, first;\n-      edge_iterator ei;\n+      bool any_visited = false;\n \n       worklist = VEC_alloc (basic_block, heap, EDGE_COUNT (block->succs));\n       FOR_EACH_EDGE (e, ei, block->succs)\n-\tVEC_quick_push (basic_block, worklist, e->dest);\n-      first = VEC_index (basic_block, worklist, 0);\n-      set_copy (ANTIC_OUT, ANTIC_IN (first));\n+\t{\n+\t  any_visited |= BB_VISITED (e->dest);\n+\t  VEC_quick_push (basic_block, worklist, e->dest);\n+\t}\n \n-      for (i = 1; VEC_iterate (basic_block, worklist, i, bprime); i++)\n+      if (any_visited)\n \t{\n-\t  node = ANTIC_OUT->head;\n-\t  while (node)\n+\t  first = VEC_index (basic_block, worklist, 0);\n+\n+\t  bitmap_set_copy (ANTIC_OUT, ANTIC_IN (first));\n+\n+\t  for (i = 1; VEC_iterate (basic_block, worklist, i, bprime); i++)\n \t    {\n-\t      tree val;\n-\t      value_set_node_t next = node->next;\n+\t      if (!BB_VISITED (bprime))\n+\t\tcontinue;\n \n-\t      val = get_value_handle (node->expr);\n-\t      if (!set_contains_value (ANTIC_IN (bprime), val))\n-\t\tset_remove (ANTIC_OUT, node->expr);\n-\t      node = next;\n+\t      bitmap_set_and (ANTIC_OUT, ANTIC_IN (bprime));\n \t    }\n+\t  VEC_free (basic_block, heap, worklist);\n \t}\n-      VEC_free (basic_block, heap, worklist);\n     }\n \n   /* Generate ANTIC_OUT - TMP_GEN.  */\n-  S = bitmap_set_subtract_from_value_set (ANTIC_OUT, TMP_GEN (block), false);\n+  S = bitmap_set_subtract (ANTIC_OUT, TMP_GEN (block));\n \n   /* Start ANTIC_IN with EXP_GEN - TMP_GEN */\n-  ANTIC_IN (block) = bitmap_set_subtract_from_value_set (EXP_GEN (block),\n-\t\t\t\t\t\t\t TMP_GEN (block),\n-\t\t\t\t\t\t\t true);\n+  ANTIC_IN (block) = bitmap_set_subtract (EXP_GEN (block),\n+\t\t\t\t\t  TMP_GEN (block));\n \n   /* Then union in the ANTIC_OUT - TMP_GEN values,\n      to get ANTIC_OUT U EXP_GEN - TMP_GEN */\n-  for (node = S->head; node; node = node->next)\n-    value_insert_into_set (ANTIC_IN (block), node->expr);\n+  FOR_EACH_EXPR_ID_IN_SET (S, bii, bi)\n+    bitmap_value_insert_into_set (ANTIC_IN (block),\n+\t\t\t\t  expression_for_id (bii));\n \n   clean (ANTIC_IN (block), block);\n-  if (!set_equal (old, ANTIC_IN (block)))\n-    changed = true;\n+  if (!bitmap_set_equal (old, ANTIC_IN (block)))\n+    {\n+      changed = true;\n+      SET_BIT (changed_blocks, block->index);\n+      FOR_EACH_EDGE (e, ei, block->preds)\n+\tSET_BIT (changed_blocks, e->src->index);\n+    }\n+  else\n+    RESET_BIT (changed_blocks, block->index);\n \n  maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       if (ANTIC_OUT)\n-\tprint_value_set (dump_file, ANTIC_OUT, \"ANTIC_OUT\", block->index);\n+\tprint_bitmap_set (dump_file, ANTIC_OUT, \"ANTIC_OUT\", block->index);\n \n       if (ANTIC_SAFE_LOADS (block))\n-\tprint_value_set (dump_file, ANTIC_SAFE_LOADS (block),\n+\tprint_bitmap_set (dump_file, ANTIC_SAFE_LOADS (block),\n \t\t\t \"ANTIC_SAFE_LOADS\", block->index);\n-      print_value_set (dump_file, ANTIC_IN (block), \"ANTIC_IN\", block->index);\n+      print_bitmap_set (dump_file, ANTIC_IN (block), \"ANTIC_IN\", block->index);\n \n       if (S)\n-\tprint_value_set (dump_file, S, \"S\", block->index);\n-    }\n-\n-  for (son = first_dom_son (CDI_POST_DOMINATORS, block);\n-       son;\n-       son = next_dom_son (CDI_POST_DOMINATORS, son))\n-    {\n-      changed |= compute_antic_aux (son,\n-\t\t\t\t    TEST_BIT (has_abnormal_preds, son->index));\n-    }\n+\tprint_bitmap_set (dump_file, S, \"S\", block->index);\n+    }\n+  if (old)\n+    bitmap_set_free (old);\n+  if (S)\n+    bitmap_set_free (S);\n+  if (ANTIC_OUT)\n+    bitmap_set_free (ANTIC_OUT);\n   return changed;\n }\n \n-/* Compute ANTIC sets.  */\n+/* Compute ANTIC and partial ANTIC sets.  */\n \n static void\n compute_antic (void)\n {\n   bool changed = true;\n   int num_iterations = 0;\n   basic_block block;\n+  int i;\n \n   /* If any predecessor edges are abnormal, we punt, so antic_in is empty.\n      We pre-build the map of blocks with incoming abnormal edges here.  */\n   has_abnormal_preds = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (has_abnormal_preds);\n+\n   FOR_EACH_BB (block)\n     {\n       edge_iterator ei;\n       edge e;\n \n       FOR_EACH_EDGE (e, ei, block->preds)\n-\tif (e->flags & EDGE_ABNORMAL)\n-\t  {\n-\t    SET_BIT (has_abnormal_preds, block->index);\n-\t    break;\n-\t  }\n+\t{\n+\t  e->flags &= ~EDGE_DFS_BACK;\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    {\n+\t      SET_BIT (has_abnormal_preds, block->index);\n+\t      break;\n+\t    }\n+\t}\n \n+      BB_VISITED (block) = 0;\n       /* While we are here, give empty ANTIC_IN sets to each block.  */\n-      ANTIC_IN (block) = set_new (true);\n+      ANTIC_IN (block) = bitmap_set_new ();\n     }\n+\n   /* At the exit block we anticipate nothing.  */\n-  ANTIC_IN (EXIT_BLOCK_PTR) = set_new (true);\n+  ANTIC_IN (EXIT_BLOCK_PTR) = bitmap_set_new ();\n+  BB_VISITED (EXIT_BLOCK_PTR) = 1;\n \n+  changed_blocks = sbitmap_alloc (last_basic_block + 1);\n+  sbitmap_ones (changed_blocks);\n   while (changed)\n     {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Starting iteration %d\\n\", num_iterations);\n       num_iterations++;\n       changed = false;\n-      changed = compute_antic_aux (EXIT_BLOCK_PTR, false);\n+      for (i = 0; i < last_basic_block - NUM_FIXED_BLOCKS; i++)\n+\t{\n+\t  if (TEST_BIT (changed_blocks, postorder[i]))\n+\t    {\n+\t      basic_block block = BASIC_BLOCK (postorder[i]);\n+\t      changed |= compute_antic_aux (block,\n+\t\t\t\t\t    TEST_BIT (has_abnormal_preds,\n+\t\t\t\t\t\t      block->index));\n+\t    }\n+\t}\n     }\n \n-  sbitmap_free (has_abnormal_preds);\n-\n   if (dump_file && (dump_flags & TDF_STATS))\n-    fprintf (dump_file, \"compute_antic required %d iterations\\n\", num_iterations);\n+    fprintf (dump_file, \"compute_antic required %d iterations\\n\",\n+\t     num_iterations);\n+\n+  sbitmap_free (has_abnormal_preds);\n+  sbitmap_free (changed_blocks);\n }\n \n /* Print the names represented by the bitmap NAMES, to the file OUT.  */\n+\n static void\n dump_bitmap_of_names (FILE *out, bitmap names)\n {\n@@ -1949,10 +1853,9 @@ static void\n compute_rvuse_and_antic_safe (void)\n {\n \n-  size_t i;\n+  unsigned int i;\n   tree phi;\n   basic_block bb;\n-  int *postorder;\n   bool changed = true;\n   unsigned int *first_store_uid;\n \n@@ -2053,15 +1956,13 @@ compute_rvuse_and_antic_safe (void)\n      RVUSE_IN[BB] = Union of RVUSE_OUT of predecessors.\n      RVUSE_OUT[BB] = RVUSE_GEN[BB] U (RVUSE_IN[BB] - RVUSE_KILL[BB])\n   */\n-  postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n-  pre_and_rev_post_order_compute (NULL, postorder, false);\n \n   changed = true;\n   while (changed)\n     {\n       int j;\n       changed = false;\n-      for (j = 0; j < n_basic_blocks - NUM_FIXED_BLOCKS; j++)\n+      for (j = n_basic_blocks - NUM_FIXED_BLOCKS - 1; j >= 0; j--)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n@@ -2076,7 +1977,6 @@ compute_rvuse_and_antic_safe (void)\n \t\t\t\t\t   RVUSE_KILL (bb));\n \t}\n     }\n-  free (postorder);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2098,15 +1998,17 @@ compute_rvuse_and_antic_safe (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      value_set_node_t node;\n+      bitmap_iterator bi;\n+\n       if (bitmap_empty_p (RVUSE_KILL (bb)))\n \tcontinue;\n \n-      for (node = EXP_GEN (bb)->head; node; node = node->next)\n+      FOR_EACH_EXPR_ID_IN_SET (EXP_GEN (bb), i, bi)\n \t{\n-\t  if (REFERENCE_CLASS_P (node->expr))\n+\t  tree expr = expression_for_id (i);\n+\t  if (REFERENCE_CLASS_P (expr))\n \t    {\n-\t      tree vh = get_value_handle (node->expr);\n+\t      tree vh = get_value_handle (expr);\n \t      tree maybe = bitmap_find_leader (AVAIL_OUT (bb), vh);\n \n \t      if (maybe)\n@@ -2120,9 +2022,9 @@ compute_rvuse_and_antic_safe (void)\n \t\t      || stmt_ann (def)->uid < first_store_uid[bb->index])\n \t\t    {\n \t\t      if (ANTIC_SAFE_LOADS (bb) == NULL)\n-\t\t\tANTIC_SAFE_LOADS (bb) = set_new (true);\n-\t\t      value_insert_into_set (ANTIC_SAFE_LOADS (bb),\n-\t\t\t\t\t     node->expr);\n+\t\t\tANTIC_SAFE_LOADS (bb) = bitmap_set_new ();\n+\t\t      bitmap_value_insert_into_set (ANTIC_SAFE_LOADS (bb),\n+\t\t\t\t\t     expr);\n \t\t    }\n \t\t}\n \t    }\n@@ -2213,7 +2115,11 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n     }\n \n   if (TREE_CODE (genop) == VALUE_HANDLE)\n-    genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n+    {\n+      bitmap_set_t exprset = VALUE_HANDLE_EXPR_SET (expr);\n+      unsigned int firstbit = bitmap_first_set_bit (exprset->expressions);\n+      genop = expression_for_id (firstbit);\n+    }\n \n   switch TREE_CODE (genop)\n     {\n@@ -2239,12 +2145,16 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n       }\n     case COMPONENT_REF:\n       {\n+\tbitmap_set_t exprset;\n+\tunsigned int firstbit;\n \ttree op0;\n \ttree op1;\n \top0 = create_component_ref_by_pieces (block,\n \t\t\t\t\t      TREE_OPERAND (genop, 0),\n \t\t\t\t\t      stmts);\n-\top1 = VALUE_HANDLE_EXPR_SET (TREE_OPERAND (genop, 1))->head->expr;\n+\texprset = VALUE_HANDLE_EXPR_SET (TREE_OPERAND (genop, 1));\n+\tfirstbit = bitmap_first_set_bit (exprset->expressions);\n+\top1 = expression_for_id (firstbit);\n \tfolded = fold_build3 (COMPONENT_REF, TREE_TYPE (genop), op0, op1,\n \t\t\t      NULL_TREE);\n \treturn folded;\n@@ -2291,8 +2201,10 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n      it recursively.  */\n   if (genop == NULL)\n     {\n-      genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n+      bitmap_set_t exprset = VALUE_HANDLE_EXPR_SET (expr);\n+      unsigned int firstbit = bitmap_first_set_bit (exprset->expressions);\n \n+      genop = expression_for_id (firstbit);\n       gcc_assert (can_PRE_operation (genop));\n       genop = create_expression_by_pieces (block, genop, stmts);\n     }\n@@ -2407,7 +2319,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n      We have to call unshare_expr because force_gimple_operand may\n      modify the tree we pass to it.  */\n   newexpr = force_gimple_operand (unshare_expr (folded), &forced_stmts,\n-                                  false, NULL);\n+\t\t\t\t  false, NULL);\n \n   /* If we have any intermediate expressions to the value sets, add them\n      to the value sets and chain them on in the instruction stream.  */\n@@ -2462,6 +2374,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n      here.  */\n   v = get_value_handle (expr);\n   vn_add (name, v);\n+  get_or_alloc_expression_id (name);\n   bitmap_value_replace_in_set (NEW_SETS (block), name);\n   bitmap_value_replace_in_set (AVAIL_OUT (block), name);\n \n@@ -2476,16 +2389,17 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   return name;\n }\n \n-/* Insert the to-be-made-available values of NODE for each\n+/* Insert the to-be-made-available values of expression EXPRNUM for each\n    predecessor, stored in AVAIL, into the predecessors of BLOCK, and\n    merge the result with a phi node, given the same value handle as\n    NODE.  Return true if we have inserted new stuff.  */\n \n static bool\n-insert_into_preds_of_block (basic_block block, value_set_node_t node,\n+insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t\t    tree *avail)\n {\n-  tree val = get_value_handle (node->expr);\n+  tree expr = expression_for_id (exprnum);\n+  tree val = get_value_handle (expr);\n   edge pred;\n   bool insertions = false;\n   bool nophi = false;\n@@ -2498,7 +2412,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Found partial redundancy for expression \");\n-      print_generic_expr (dump_file, node->expr, 0);\n+      print_generic_expr (dump_file, expr, 0);\n       fprintf (dump_file, \" (\");\n       print_generic_expr (dump_file, val, 0);\n       fprintf (dump_file, \")\");\n@@ -2507,7 +2421,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n \n   /* Make sure we aren't creating an induction variable.  */\n   if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2\n-      && TREE_CODE_CLASS (TREE_CODE (node->expr)) != tcc_reference )\n+      && TREE_CODE_CLASS (TREE_CODE (expr)) != tcc_reference )\n     {\n       bool firstinsideloop = false;\n       bool secondinsideloop = false;\n@@ -2561,6 +2475,7 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n \t  builtexpr = create_expression_by_pieces (bprime,\n \t\t\t\t\t\t   eprime,\n \t\t\t\t\t\t   stmts);\n+\t  gcc_assert (!(pred->flags & EDGE_ABNORMAL));\n \t  bsi_insert_on_edge (pred, stmts);\n \t  avail[bprime->index] = builtexpr;\n \t  insertions = true;\n@@ -2634,16 +2549,149 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n    1.  Propagate the NEW_SETS of the dominator into the current block.\n    If the block has multiple predecessors,\n        2a. Iterate over the ANTIC expressions for the block to see if\n-           any of them are partially redundant.\n+\t   any of them are partially redundant.\n        2b. If so, insert them into the necessary predecessors to make\n-           the expression fully redundant.\n+\t   the expression fully redundant.\n        2c. Insert a new PHI merging the values of the predecessors.\n        2d. Insert the new PHI, and the new expressions, into the\n-           NEW_SETS set.\n+\t   NEW_SETS set.\n    3. Recursively call ourselves on the dominator children of BLOCK.\n \n+   Steps 1, 2a, and 3 are done by insert_aux. 2b, 2c and 2d are done by\n+   do_regular_insertion.  \n+\n */\n \n+static bool\n+do_regular_insertion (basic_block block, basic_block dom)\n+{\n+  bool new_stuff = false;\n+  VEC (tree, heap) *exprs = sorted_array_from_bitmap_set (ANTIC_IN (block));\n+  tree expr;\n+  int i;\n+\n+  for (i = 0; VEC_iterate (tree, exprs, i, expr); i++)\n+    {\n+      if (can_PRE_operation (expr) && !AGGREGATE_TYPE_P (TREE_TYPE (expr)))\n+\t{\n+\t  tree *avail;\n+\t  tree val;\n+\t  bool by_some = false;\n+\t  bool cant_insert = false;\n+\t  bool all_same = true;\n+\t  tree first_s = NULL;\n+\t  edge pred;\n+\t  basic_block bprime;\n+\t  tree eprime = NULL_TREE;\n+\t  edge_iterator ei;\n+\n+\t  val = get_value_handle (expr);\n+\t  if (bitmap_set_contains_value (PHI_GEN (block), val))\n+\t    continue;\n+\t  if (bitmap_set_contains_value (AVAIL_OUT (dom), val))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Found fully redundant value\\n\");\n+\t      continue;\n+\t    }\n+\n+\t  avail = XCNEWVEC (tree, last_basic_block);\n+\t  FOR_EACH_EDGE (pred, ei, block->preds)\n+\t    {\n+\t      tree vprime;\n+\t      tree edoubleprime;\n+\n+\t      /* This can happen in the very weird case\n+\t\t that our fake infinite loop edges have caused a\n+\t\t critical edge to appear.  */\n+\t      if (EDGE_CRITICAL_P (pred))\n+\t\t{\n+\t\t  cant_insert = true;\n+\t\t  break;\n+\t\t}\n+\t      bprime = pred->src;\n+\t      eprime = phi_translate (expr, ANTIC_IN (block), NULL,\n+\t\t\t\t      bprime, block);\n+\n+\t      /* eprime will generally only be NULL if the\n+\t\t value of the expression, translated\n+\t\t through the PHI for this predecessor, is\n+\t\t undefined.  If that is the case, we can't\n+\t\t make the expression fully redundant,\n+\t\t because its value is undefined along a\n+\t\t predecessor path.  We can thus break out\n+\t\t early because it doesn't matter what the\n+\t\t rest of the results are.  */\n+\t      if (eprime == NULL)\n+\t\t{\n+\t\t  cant_insert = true;\n+\t\t  break;\n+\t\t}\n+\n+\t      eprime = fully_constant_expression (eprime);\n+\t      vprime = get_value_handle (eprime);\n+\t      gcc_assert (vprime);\n+\t      edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n+\t\t\t\t\t\t vprime);\n+\t      if (edoubleprime == NULL)\n+\t\t{\n+\t\t  avail[bprime->index] = eprime;\n+\t\t  all_same = false;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  avail[bprime->index] = edoubleprime;\n+\t\t  by_some = true;\n+\t\t  if (first_s == NULL)\n+\t\t    first_s = edoubleprime;\n+\t\t  else if (!operand_equal_p (first_s, edoubleprime,\n+\t\t\t\t\t     0))\n+\t\t    all_same = false;\n+\t\t}\n+\t    }\n+\t  /* If we can insert it, it's not the same value\n+\t     already existing along every predecessor, and\n+\t     it's defined by some predecessor, it is\n+\t     partially redundant.  */\n+\t  if (!cant_insert && !all_same && by_some)\n+\t    {\n+\t      if (insert_into_preds_of_block (block, get_expression_id (expr),\n+\t\t\t\t\t      avail))\n+\t\tnew_stuff = true;\n+\t    }\n+\t  /* If all edges produce the same value and that value is\n+\t     an invariant, then the PHI has the same value on all\n+\t     edges.  Note this.  */\n+\t  else if (!cant_insert && all_same && eprime\n+\t\t   && is_gimple_min_invariant (eprime)\n+\t\t   && !is_gimple_min_invariant (val))\n+\t    {\n+\t      unsigned int j;\n+\t      bitmap_iterator bi;\n+\n+\t      bitmap_set_t exprset = VALUE_HANDLE_EXPR_SET (val);\n+\t      FOR_EACH_EXPR_ID_IN_SET (exprset, j, bi)\n+\t\t{\n+\t\t  tree expr = expression_for_id (j);\n+\t\t  if (TREE_CODE (expr) == SSA_NAME)\n+\t\t    {\n+\t\t      vn_add (expr, eprime);\n+\t\t      pre_stats.constified++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  free (avail);\n+\t}\n+    }\n+\n+  VEC_free (tree, heap, exprs);\n+  return new_stuff;\n+}\n+\n+\n+/* Perform insertion of partially redundant expressions for block\n+   BLOCK.  */\n+\n static bool\n insert_aux (basic_block block)\n {\n@@ -2665,129 +2713,16 @@ insert_aux (basic_block block)\n \t\t AVAIL_OUT. For both the case of NEW_SETS, the value may be\n \t\t represented by some non-simple expression here that we want\n \t\t to replace it with.  */\n-\t      EXECUTE_IF_SET_IN_BITMAP (newset->expressions, 0, i, bi)\n+\t      FOR_EACH_EXPR_ID_IN_SET (newset, i, bi)\n \t\t{\n-\t\t  bitmap_value_replace_in_set (NEW_SETS (block), ssa_name (i));\n-\t\t  bitmap_value_replace_in_set (AVAIL_OUT (block), ssa_name (i));\n+\t\t  tree expr = expression_for_id (i);\n+\t\t  bitmap_value_replace_in_set (NEW_SETS (block), expr);\n+\t\t  bitmap_value_replace_in_set (AVAIL_OUT (block), expr);\n \t\t}\n \t    }\n \t  if (!single_pred_p (block))\n \t    {\n-\t      value_set_node_t node;\n-\t      for (node = ANTIC_IN (block)->head;\n-\t\t   node;\n-\t\t   node = node->next)\n-\t\t{\n-\t\t  if (can_PRE_operation (node->expr)\n-\t\t      && !AGGREGATE_TYPE_P (TREE_TYPE (node->expr)))\n-\t\t    {\n-\t\t      tree *avail;\n-\t\t      tree val;\n-\t\t      bool by_some = false;\n-\t\t      bool cant_insert = false;\n-\t\t      bool all_same = true;\n-\t\t      tree first_s = NULL;\n-\t\t      edge pred;\n-\t\t      basic_block bprime;\n-\t\t      tree eprime = NULL_TREE;\n-\t\t      edge_iterator ei;\n-\n-\t\t      val = get_value_handle (node->expr);\n-\t\t      if (bitmap_set_contains_value (PHI_GEN (block), val))\n-\t\t\tcontinue;\n-\t\t      if (bitmap_set_contains_value (AVAIL_OUT (dom), val))\n-\t\t\t{\n-\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t    fprintf (dump_file, \"Found fully redundant value\\n\");\n-\t\t\t  continue;\n-\t\t\t}\n-\n-\t\t      avail = XCNEWVEC (tree, last_basic_block);\n-\t\t      FOR_EACH_EDGE (pred, ei, block->preds)\n-\t\t\t{\n-\t\t\t  tree vprime;\n-\t\t\t  tree edoubleprime;\n-\n-\t\t\t  /* This can happen in the very weird case\n-\t\t\t     that our fake infinite loop edges have caused a\n-\t\t\t     critical edge to appear.  */\n-\t\t\t  if (EDGE_CRITICAL_P (pred))\n-\t\t\t    {\n-\t\t\t      cant_insert = true;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t  bprime = pred->src;\n-\t\t\t  eprime = phi_translate (node->expr,\n-\t\t\t\t\t\t  ANTIC_IN (block),\n-\t\t\t\t\t\t  bprime, block);\n-\n-\t\t\t  /* eprime will generally only be NULL if the\n-\t\t\t     value of the expression, translated\n-\t\t\t     through the PHI for this predecessor, is\n-\t\t\t     undefined.  If that is the case, we can't\n-\t\t\t     make the expression fully redundant,\n-\t\t\t     because its value is undefined along a\n-\t\t\t     predecessor path.  We can thus break out\n-\t\t\t     early because it doesn't matter what the\n-\t\t\t     rest of the results are.  */\n-\t\t\t  if (eprime == NULL)\n-\t\t\t    {\n-\t\t\t      cant_insert = true;\n-\t\t\t      break;\n-\t\t\t    }\n-\n-\t\t\t  eprime = fully_constant_expression (eprime);\n-\t\t\t  vprime = get_value_handle (eprime);\n-\t\t\t  gcc_assert (vprime);\n-\t\t\t  edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t\t     vprime);\n-\t\t\t  if (edoubleprime == NULL)\n-\t\t\t    {\n-\t\t\t      avail[bprime->index] = eprime;\n-\t\t\t      all_same = false;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      avail[bprime->index] = edoubleprime;\n-\t\t\t      by_some = true;\n-\t\t\t      if (first_s == NULL)\n-\t\t\t\tfirst_s = edoubleprime;\n-\t\t\t      else if (!operand_equal_p (first_s, edoubleprime,\n-\t\t\t\t\t\t\t 0))\n-\t\t\t\tall_same = false;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      /* If we can insert it, it's not the same value\n-\t\t\t already existing along every predecessor, and\n-\t\t\t it's defined by some predecessor, it is\n-\t\t\t partially redundant.  */\n-\t\t      if (!cant_insert && !all_same && by_some)\n-\t\t\t{\n-\t\t\t  if (insert_into_preds_of_block (block, node, avail))\n- \t\t\t    new_stuff = true;\n-\t\t\t}\n-\t\t      /* If all edges produce the same value and that value is\n-\t\t\t an invariant, then the PHI has the same value on all\n-\t\t\t edges.  Note this.  */\n-\t\t      else if (!cant_insert && all_same && eprime\n-\t\t\t       && is_gimple_min_invariant (eprime)\n-\t\t\t       && !is_gimple_min_invariant (val))\n-\t\t\t{\n-\t\t\t  value_set_t exprset = VALUE_HANDLE_EXPR_SET (val);\n-\t\t\t  value_set_node_t node;\n-\n-\t\t\t  for (node = exprset->head; node; node = node->next)\n- \t\t\t    {\n-\t\t\t      if (TREE_CODE (node->expr) == SSA_NAME)\n-\t\t\t\t{\n-\t\t\t\t  vn_add (node->expr, eprime);\n-\t\t\t\t  pre_stats.constified++;\n-\t\t\t\t}\n- \t\t\t    }\n-\t\t\t}\n-\t\t      free (avail);\n-\t\t    }\n-\t\t}\n+\t      new_stuff |= do_regular_insertion (block, dom);\n \t    }\n \t}\n     }\n@@ -2831,7 +2766,7 @@ static bool\n is_undefined_value (tree expr)\n {\n   return (TREE_CODE (expr) == SSA_NAME\n-          && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (expr))\n+\t  && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (expr))\n \t  /* PARM_DECLs and hard registers are always defined.  */\n \t  && TREE_CODE (SSA_NAME_VAR (expr)) != PARM_DECL);\n }\n@@ -2840,7 +2775,8 @@ is_undefined_value (tree expr)\n /* Given an SSA variable VAR and an expression EXPR, compute the value\n    number for EXPR and create a value handle (VAL) for it.  If VAR and\n    EXPR are not the same, associate VAL with VAR.  Finally, add VAR to\n-   S1 and its value handle to S2.\n+   S1 and its value handle to S2, and to the maximal set if\n+   ADD_TO_MAXIMAL is true.\n \n    VUSES represent the virtual use operands associated with EXPR (if\n    any).  */\n@@ -2860,9 +2796,37 @@ add_to_sets (tree var, tree expr, tree stmt, bitmap_set_t s1,\n \n   if (s1)\n     bitmap_insert_into_set (s1, var);\n+\n   bitmap_value_insert_into_set (s2, var);\n }\n \n+/* Find existing value expression that is the same as T,\n+   and return it if it exists.  */\n+\n+static inline tree\n+find_existing_value_expr (tree t, tree stmt)\n+{\n+  bitmap_iterator bi;\n+  unsigned int bii;\n+  tree vh;\n+  bitmap_set_t exprset;\n+\n+  if (REFERENCE_CLASS_P (t))\n+    vh = vn_lookup (t, stmt);\n+  else\n+    vh = vn_lookup (t, NULL);\n+\n+  if (!vh)\n+    return NULL;\n+  exprset = VALUE_HANDLE_EXPR_SET (vh);\n+  FOR_EACH_EXPR_ID_IN_SET (exprset, bii, bi)\n+    {\n+      tree efi = expression_for_id (bii);\n+      if (expressions_equal_p (t, efi))\n+\treturn efi;\n+    }\n+  return NULL;\n+}\n \n /* Given a unary or binary expression EXPR, create and return a new\n    expression with the same structure as EXPR but with its operands\n@@ -2878,6 +2842,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n   enum tree_code code = TREE_CODE (expr);\n   tree vexpr;\n   alloc_pool pool;\n+  tree efi;\n \n   gcc_assert (TREE_CODE_CLASS (code) == tcc_unary\n \t      || TREE_CODE_CLASS (code) == tcc_binary\n@@ -2912,7 +2877,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n   /* This case is only for TREE_LIST's that appear as part of\n      CALL_EXPR's.  Anything else is a bug, but we can't easily verify\n      this, hence this comment.  TREE_LIST is not handled by the\n-     general case below is because they don't have a fixed length, or\n+     general case below because they don't have a fixed length, or\n      operands, so you can't access purpose/value/chain through\n      TREE_OPERAND macros.  */\n \n@@ -2943,8 +2908,12 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n       /* This is the equivalent of inserting op into EXP_GEN like we\n \t do below */\n       if (!is_undefined_value (op))\n-\tvalue_insert_into_set (EXP_GEN (block), op);\n+\tbitmap_value_insert_into_set (EXP_GEN (block), op);\n \n+      efi = find_existing_value_expr (vexpr, stmt);\n+      if (efi)\n+\treturn efi;\n+      get_or_alloc_expression_id (vexpr);\n       return vexpr;\n     }\n \n@@ -2982,110 +2951,20 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \tval = vn_lookup_or_add (op, NULL);\n \n       if (!is_undefined_value (op) && TREE_CODE (op) != TREE_LIST)\n-\tvalue_insert_into_set (EXP_GEN (block), op);\n+\tbitmap_value_insert_into_set (EXP_GEN (block), op);\n \n       if (TREE_CODE (val) == VALUE_HANDLE)\n \tTREE_TYPE (val) = TREE_TYPE (TREE_OPERAND (vexpr, i));\n \n       TREE_OPERAND (vexpr, i) = val;\n     }\n-\n+  efi = find_existing_value_expr (vexpr, stmt);\n+  if (efi)\n+    return efi;\n+  get_or_alloc_expression_id (vexpr);\n   return vexpr;\n }\n \n-\n-\n-/* Insert extra phis to merge values that are fully available from\n-   preds of BLOCK, but have no dominating representative coming from\n-   block DOM.   */\n-\n-static void\n-insert_extra_phis (basic_block block, basic_block dom)\n-{\n-\n-  if (!single_pred_p (block))\n-    {\n-      edge e;\n-      edge_iterator ei;\n-      bool first = true;\n-      bitmap_set_t tempset = bitmap_set_new ();\n-\n-      FOR_EACH_EDGE (e, ei, block->preds)\n-\t{\n-\t  /* We cannot handle abnormal incoming edges correctly.  */\n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    return;\n-\n-\t  if (first)\n-\t    {\n-\t      bitmap_set_copy (tempset, AVAIL_OUT (e->src));\n-\t      first = false;\n-\t    }\n-\t  else\n-\t    bitmap_set_and (tempset, AVAIL_OUT (e->src));\n-\t}\n-\n-      if (dom)\n-\tbitmap_set_and_compl (tempset, AVAIL_OUT (dom));\n-\n-      if (!bitmap_set_empty_p (tempset))\n-\t{\n-\t  unsigned int i;\n-\t  bitmap_iterator bi;\n-\n-\t  EXECUTE_IF_SET_IN_BITMAP (tempset->expressions, 0, i, bi)\n-\t    {\n-\t      tree name = ssa_name (i);\n-\t      tree val = get_value_handle (name);\n-\t      tree temp;\n-\n-\t      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n-\t\tcontinue;\n-\n-\t      if (!mergephitemp\n-\t\t  || TREE_TYPE (name) != TREE_TYPE (mergephitemp))\n-\t\t{\n-\t\t  mergephitemp = create_tmp_var (TREE_TYPE (name),\n-\t\t\t\t\t\t \"mergephitmp\");\n-\t\t  get_var_ann (mergephitemp);\n-\t\t}\n-\t      temp = mergephitemp;\n-\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"Creating phi \");\n-\t\t  print_generic_expr (dump_file, temp, 0);\n-\t\t  fprintf (dump_file, \" to merge available but not dominating values \");\n-\t\t}\n-\n-\t      add_referenced_var (temp);\n-\t      temp = create_phi_node (temp, block);\n-\t      NECESSARY (temp) = 0;\n-\t      VEC_safe_push (tree, heap, inserted_exprs, temp);\n-\n-\t      FOR_EACH_EDGE (e, ei, block->preds)\n-\t\t{\n-\t\t  tree leader = bitmap_find_leader (AVAIL_OUT (e->src), val);\n-\n-\t\t  gcc_assert (leader);\n-\t\t  add_phi_arg (temp, leader, e);\n-\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      print_generic_expr (dump_file, leader, 0);\n-\t\t      fprintf (dump_file, \" in block %d,\", e->src->index);\n-\t\t    }\n-\t\t}\n-\n-\t      vn_add (PHI_RESULT (temp), val);\n-\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"\\n\");\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Given a statement STMT and its right hand side which is a load, try\n    to look for the expression stored in the location for the load, and\n    return true if a useful equivalence was recorded for LHS.  */\n@@ -3145,12 +3024,12 @@ try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n     {\n \n       /* Yay!  Compute a value number for the RHS of the statement and\n- \t add its value to the AVAIL_OUT set for the block.  Add the LHS\n+\t add its value to the AVAIL_OUT set for the block.  Add the LHS\n \t to TMP_GEN.  */\n       add_to_sets (lhs, rhs, store_stmt, TMP_GEN (block), AVAIL_OUT (block));\n       if (TREE_CODE (rhs) == SSA_NAME\n \t  && !is_undefined_value (rhs))\n-\tvalue_insert_into_set (EXP_GEN (block), rhs);\n+\tbitmap_value_insert_into_set (EXP_GEN (block), rhs);\n       return true;\n     }\n \n@@ -3168,15 +3047,15 @@ poolify_tree (tree node)\n     {\n     case INDIRECT_REF:\n       {\n-\ttree temp = pool_alloc (reference_node_pool);\n+\ttree temp = (tree) pool_alloc (reference_node_pool);\n \tmemcpy (temp, node, tree_size (node));\n \tTREE_OPERAND (temp, 0) = poolify_tree (TREE_OPERAND (temp, 0));\n \treturn temp;\n       }\n       break;\n     case MODIFY_EXPR:\n       {\n-\ttree temp = pool_alloc (modify_expr_node_pool);\n+\ttree temp = (tree) pool_alloc (modify_expr_node_pool);\n \tmemcpy (temp, node, tree_size (node));\n \tTREE_OPERAND (temp, 0) = poolify_tree (TREE_OPERAND (temp, 0));\n \tTREE_OPERAND (temp, 1) = poolify_tree (TREE_OPERAND (temp, 1));\n@@ -3339,15 +3218,19 @@ try_combine_conversion (tree *expr_p)\n {\n   tree expr = *expr_p;\n   tree t;\n+  bitmap_set_t exprset;\n+  unsigned int firstbit;\n \n   if (!((TREE_CODE (expr) == NOP_EXPR\n \t || TREE_CODE (expr) == CONVERT_EXPR)\n \t&& TREE_CODE (TREE_OPERAND (expr, 0)) == VALUE_HANDLE\n \t&& !VALUE_HANDLE_VUSES (TREE_OPERAND (expr, 0))))\n     return false;\n \n+  exprset = VALUE_HANDLE_EXPR_SET (TREE_OPERAND (expr, 0));\n+  firstbit = bitmap_first_set_bit (exprset->expressions);\n   t = fold_unary (TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t  VALUE_HANDLE_EXPR_SET (TREE_OPERAND (expr, 0))->head->expr);\n+\t\t  expression_for_id (firstbit));\n   if (!t)\n     return false;\n \n@@ -3395,6 +3278,7 @@ compute_avail (void)\n       if (default_def (param) != NULL)\n \t{\n \t  tree def = default_def (param);\n+\n \t  vn_lookup_or_add (def, NULL);\n \t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n \t  bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), def);\n@@ -3406,12 +3290,13 @@ compute_avail (void)\n     {\n       param = cfun->static_chain_decl;\n       if (default_def (param) != NULL)\n-        {\n-          tree def = default_def (param);\n-          vn_lookup_or_add (def, NULL);\n-          bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n-          bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), def);\n-        }\n+\t{\n+\t  tree def = default_def (param);\n+\n+\t  vn_lookup_or_add (def, NULL);\n+\t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n+\t  bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), def);\n+\t}\n     }\n \n   /* Allocate the worklist.  */\n@@ -3441,16 +3326,17 @@ compute_avail (void)\n       if (dom)\n \tbitmap_set_copy (AVAIL_OUT (block), AVAIL_OUT (dom));\n \n-      if (!in_fre)\n-\tinsert_extra_phis (block, dom);\n-\n       /* Generate values for PHI nodes.  */\n       for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n-\t/* We have no need for virtual phis, as they don't represent\n-\t   actual computations.  */\n-\tif (is_gimple_reg (PHI_RESULT (phi)))\n-\t  add_to_sets (PHI_RESULT (phi), PHI_RESULT (phi), NULL,\n-\t\t       PHI_GEN (block), AVAIL_OUT (block));\n+\t{\n+\t  /* We have no need for virtual phis, as they don't represent\n+\t     actual computations.  */\n+\t  if (is_gimple_reg (PHI_RESULT (phi)))\n+\t    {\n+\t      add_to_sets (PHI_RESULT (phi), PHI_RESULT (phi), NULL,\n+\t\t\t   PHI_GEN (block), AVAIL_OUT (block));\n+\t    }\n+\t}\n \n       /* Now compute value numbers and populate value sets with all\n \t the expressions computed in BLOCK.  */\n@@ -3469,7 +3355,30 @@ compute_avail (void)\n \t     assignments of the form X_i = EXPR, where EXPR represents\n \t     an \"interesting\" computation, it has no volatile operands\n \t     and X_i doesn't flow through an abnormal edge.  */\n-\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t  if (TREE_CODE (stmt) == RETURN_EXPR\n+\t      && !ann->has_volatile_ops)\n+\t    {\n+\t      tree realstmt = stmt;\n+\t      tree lhs;\n+\t      tree rhs;\n+\n+\t      stmt = TREE_OPERAND (stmt, 0);\n+\t      if (stmt && TREE_CODE (stmt) == MODIFY_EXPR)\n+\t\t{\n+\t\t  lhs  = TREE_OPERAND (stmt, 0);\n+\t\t  rhs = TREE_OPERAND (stmt, 1);\n+\t\t  if (TREE_CODE (rhs) == SSA_NAME\n+\t\t      && !is_undefined_value (rhs))\n+\t\t    bitmap_value_insert_into_set (EXP_GEN (block), rhs);\n+\n+\t\t  FOR_EACH_SSA_TREE_OPERAND (op, realstmt, iter, SSA_OP_DEF)\n+\t\t    add_to_sets (op, op, NULL, TMP_GEN (block),\n+\t\t\t\t AVAIL_OUT (block));\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  else if (TREE_CODE (stmt) == MODIFY_EXPR\n \t      && !ann->has_volatile_ops\n \t      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (stmt, 0)))\n@@ -3501,7 +3410,7 @@ compute_avail (void)\n \t\t\t{\n \t\t\t  tree val = vn_lookup_or_add (newt, stmt);\n \t\t\t  vn_add (lhs, val);\n-\t\t\t  value_insert_into_set (EXP_GEN (block), newt);\n+\t\t\t  bitmap_value_insert_into_set (EXP_GEN (block), newt);\n \t\t\t}\n \t\t      bitmap_insert_into_set (TMP_GEN (block), lhs);\n \t\t      bitmap_value_insert_into_set (AVAIL_OUT (block), lhs);\n@@ -3523,7 +3432,7 @@ compute_avail (void)\n \n \t\t  if (TREE_CODE (rhs) == SSA_NAME\n \t\t      && !is_undefined_value (rhs))\n-\t\t    value_insert_into_set (EXP_GEN (block), rhs);\n+\t\t    bitmap_value_insert_into_set (EXP_GEN (block), rhs);\n \t\t  continue;\n \t\t}\n \t    }\n@@ -3562,8 +3471,8 @@ eliminate (void)\n       block_stmt_iterator i;\n \n       for (i = bsi_start (b); !bsi_end_p (i); bsi_next (&i))\n-        {\n-          tree stmt = bsi_stmt (i);\n+\t{\n+\t  tree stmt = bsi_stmt (i);\n \n \t  /* Lookup the RHS of the expression, see if we have an\n \t     available computation for it.  If so, replace the RHS with\n@@ -3622,7 +3531,7 @@ eliminate (void)\n \t\t    }\n \t\t}\n \t    }\n-        }\n+\t}\n     }\n }\n \n@@ -3686,7 +3595,7 @@ remove_dead_inserted_code (void)\n \n \t  VEC_reserve (tree, heap, worklist, PHI_NUM_ARGS (t));\n \t  for (k = 0; k < PHI_NUM_ARGS (t); k++)\n-            {\n+\t    {\n \t      tree arg = PHI_ARG_DEF (t, k);\n \t      if (TREE_CODE (arg) == SSA_NAME)\n \t\t{\n@@ -3752,6 +3661,8 @@ init_pre (bool do_fre)\n {\n   basic_block bb;\n \n+  next_expression_id = 0;\n+  expressions = NULL;\n   in_fre = do_fre;\n \n   inserted_exprs = NULL;\n@@ -3768,33 +3679,21 @@ init_pre (bool do_fre)\n   connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n \n-  /* If block 0 has more than one predecessor, it means that its PHI\n-     nodes will have arguments coming from block -1.  This creates\n-     problems for several places in PRE that keep local arrays indexed\n-     by block number.  To prevent this, we split the edge coming from\n-     ENTRY_BLOCK_PTR (FIXME, if ENTRY_BLOCK_PTR had an index number\n-     different than -1 we wouldn't have to hack this.  tree-ssa-dce.c\n-     needs a similar change).  */\n-  if (!single_pred_p (single_succ (ENTRY_BLOCK_PTR)))\n-    if (!(single_succ_edge (ENTRY_BLOCK_PTR)->flags & EDGE_ABNORMAL))\n-      split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+  postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+  post_order_compute (postorder, false);\n \n   FOR_ALL_BB (bb)\n-    bb->aux = xcalloc (1, sizeof (struct bb_value_sets));\n+    bb->aux = xcalloc (1, sizeof (struct bb_bitmap_sets));\n \n   bitmap_obstack_initialize (&grand_bitmap_obstack);\n-  phi_translate_table = htab_create (511, expr_pred_trans_hash,\n+  phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n \t\t\t\t     expr_pred_trans_eq, free);\n-  value_set_pool = create_alloc_pool (\"Value sets\",\n-\t\t\t\t      sizeof (struct value_set), 30);\n   bitmap_set_pool = create_alloc_pool (\"Bitmap sets\",\n \t\t\t\t       sizeof (struct bitmap_set), 30);\n-  value_set_node_pool = create_alloc_pool (\"Value set nodes\",\n-\t\t\t\t           sizeof (struct value_set_node), 30);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n   binary_node_pool = create_alloc_pool (\"Binary tree nodes\",\n-\t\t\t\t        tree_code_size (PLUS_EXPR), 30);\n+\t\t\t\t\ttree_code_size (PLUS_EXPR), 30);\n   unary_node_pool = create_alloc_pool (\"Unary tree nodes\",\n \t\t\t\t       tree_code_size (NEGATE_EXPR), 30);\n   reference_node_pool = create_alloc_pool (\"Reference tree nodes\",\n@@ -3804,20 +3703,19 @@ init_pre (bool do_fre)\n   list_node_pool = create_alloc_pool (\"List tree nodes\",\n \t\t\t\t      tree_code_size (TREE_LIST), 30);\n   comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n-      \t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n+\t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n   modify_expr_node_pool = create_alloc_pool (\"MODIFY_EXPR nodes\",\n \t\t\t\t\t     tree_code_size (MODIFY_EXPR),\n \t\t\t\t\t     30);\n   modify_expr_template = NULL;\n \n   FOR_ALL_BB (bb)\n     {\n-      EXP_GEN (bb) = set_new (true);\n+      EXP_GEN (bb) = bitmap_set_new ();\n       PHI_GEN (bb) = bitmap_set_new ();\n       TMP_GEN (bb) = bitmap_set_new ();\n       AVAIL_OUT (bb) = bitmap_set_new ();\n     }\n-\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n }\n \n@@ -3830,12 +3728,11 @@ fini_pre (bool do_fre)\n   basic_block bb;\n   unsigned int i;\n \n+  free (postorder);\n   VEC_free (tree, heap, inserted_exprs);\n   VEC_free (tree, heap, need_creation);\n   bitmap_obstack_release (&grand_bitmap_obstack);\n-  free_alloc_pool (value_set_pool);\n   free_alloc_pool (bitmap_set_pool);\n-  free_alloc_pool (value_set_node_pool);\n   free_alloc_pool (binary_node_pool);\n   free_alloc_pool (reference_node_pool);\n   free_alloc_pool (unary_node_pool);\n@@ -3889,6 +3786,7 @@ fini_pre (bool do_fre)\n static void\n execute_pre (bool do_fre)\n {\n+\n   init_pre (do_fre);\n \n   if (!do_fre)\n@@ -3903,10 +3801,10 @@ execute_pre (bool do_fre)\n \n       FOR_ALL_BB (bb)\n \t{\n-\t  print_value_set (dump_file, EXP_GEN (bb), \"exp_gen\", bb->index);\n-\t  bitmap_print_value_set (dump_file, TMP_GEN (bb), \"tmp_gen\",\n+\t  print_bitmap_set (dump_file, EXP_GEN (bb), \"exp_gen\", bb->index);\n+\t  print_bitmap_set (dump_file, TMP_GEN (bb), \"tmp_gen\",\n \t\t\t\t  bb->index);\n-\t  bitmap_print_value_set (dump_file, AVAIL_OUT (bb), \"avail_out\",\n+\t  print_bitmap_set (dump_file, AVAIL_OUT (bb), \"avail_out\",\n \t\t\t\t  bb->index);\n \t}\n     }\n@@ -3928,25 +3826,23 @@ execute_pre (bool do_fre)\n   /* Remove all the redundant expressions.  */\n   eliminate ();\n \n-\n   if (dump_file && (dump_flags & TDF_STATS))\n     {\n       fprintf (dump_file, \"Insertions: %d\\n\", pre_stats.insertions);\n       fprintf (dump_file, \"New PHIs: %d\\n\", pre_stats.phis);\n       fprintf (dump_file, \"Eliminated: %d\\n\", pre_stats.eliminations);\n       fprintf (dump_file, \"Constified: %d\\n\", pre_stats.constified);\n     }\n-\n   bsi_commit_edge_inserts ();\n \n+  clear_expression_ids ();\n   if (!do_fre)\n     {\n       remove_dead_inserted_code ();\n       realify_fake_stores ();\n     }\n \n   fini_pre (do_fre);\n-\n }\n \n /* Gate and execute functions for PRE.  */"}, {"sha": "bf47acfd37098f1e04518fd9359c95333e086a32", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=83737db21d7e440fe1332a23b9bbd6eaea85135a", "patch": "@@ -419,33 +419,6 @@ vn_lookup_or_add_with_vuses (tree expr, VEC (tree, gc) *vuses)\n   return v;\n }\n \n-\n-\n-/* Get the value handle of EXPR.  This is the only correct way to get\n-   the value handle for a \"thing\".  If EXPR does not have a value\n-   handle associated, it returns NULL_TREE.  \n-   NB: If EXPR is min_invariant, this function is *required* to return EXPR.  */\n-\n-tree\n-get_value_handle (tree expr)\n-{\n-\n-  if (is_gimple_min_invariant (expr))\n-    return expr;\n-\n-  if (TREE_CODE (expr) == SSA_NAME)\n-    return SSA_NAME_VALUE (expr);\n-  else if (EXPR_P (expr) || DECL_P (expr) || TREE_CODE (expr) == TREE_LIST\n-\t   || TREE_CODE (expr) == CONSTRUCTOR)\n-    {\n-      tree_ann_common_t ann = tree_common_ann (expr);\n-      return ((ann) ? ann->value_handle : NULL_TREE);\n-    }\n-  else\n-    gcc_unreachable ();\n-}\n-\n-\n /* Initialize data structures used in value numbering.  */\n \n void\n@@ -456,7 +429,6 @@ vn_init (void)\n   shared_lookup_vuses = NULL;\n }\n \n-\n /* Delete data used for value numbering.  */\n \n void"}, {"sha": "ce9daa647053ee06919340787cd6420ac0befe8c", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83737db21d7e440fe1332a23b9bbd6eaea85135a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=83737db21d7e440fe1332a23b9bbd6eaea85135a", "patch": "@@ -3140,14 +3140,13 @@ struct tree_statement_list\n   (VALUE_HANDLE_CHECK (NODE)->value_handle.vuses)\n \n /* Defined and used in tree-ssa-pre.c.  */\n-struct value_set;\n \n struct tree_value_handle GTY(())\n {\n   struct tree_common common;\n \n   /* The set of expressions represented by this handle.  */\n-  struct value_set * GTY ((skip)) expr_set;\n+  struct bitmap_set * GTY ((skip)) expr_set;\n \n   /* Unique ID for this value handle.  IDs are handed out in a\n      conveniently dense form starting at 0, so that we can make"}]}