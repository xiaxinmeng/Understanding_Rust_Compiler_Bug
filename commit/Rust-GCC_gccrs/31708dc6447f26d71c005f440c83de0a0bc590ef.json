{"sha": "31708dc6447f26d71c005f440c83de0a0bc590ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE3MDhkYzY0NDdmMjZkNzFjMDA1ZjQ0MGM4M2RlMGEwYmM1OTBlZg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-03-25T01:28:11Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-03-25T01:28:11Z"}, "message": "gfortran.h (gfc_symbol): Add a new \"forall_index\" bit field.\n\n\n\t* gfortran.h (gfc_symbol): Add a new \"forall_index\" bit field.\n\t* match.c (match_forall_iterator): Set forall_index field on\n\tthe iteration variable's symbol.\n\t* dependency.c (contains_forall_index_p): New function to\n\ttraverse a gfc_expr to check whether it contains a variable\n\twith forall_index set in it's symbol.\n\t(gfc_check_element_vs_element): Return GFC_DEP_EQUAL for scalar\n\tconstant expressions that don't variables used as FORALL indices.\n\n\t* gfortran.dg/dependency_9.f90: New (resurected) test case.\n\nFrom-SVN: r112373", "tree": {"sha": "8535c89df5c94aed2fd99466c926796da843b79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8535c89df5c94aed2fd99466c926796da843b79c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31708dc6447f26d71c005f440c83de0a0bc590ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31708dc6447f26d71c005f440c83de0a0bc590ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31708dc6447f26d71c005f440c83de0a0bc590ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31708dc6447f26d71c005f440c83de0a0bc590ef/comments", "author": null, "committer": null, "parents": [{"sha": "9e51ddaa6e4902e734b803b9ede861eb499b3bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e51ddaa6e4902e734b803b9ede861eb499b3bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e51ddaa6e4902e734b803b9ede861eb499b3bd0"}], "stats": {"total": 129, "additions": 127, "deletions": 2}, "files": [{"sha": "9bb4edccf5487566be6848fabf6ae78e89c25449", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=31708dc6447f26d71c005f440c83de0a0bc590ef", "patch": "@@ -1,3 +1,14 @@\n+2006-03-24  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.h (gfc_symbol): Add a new \"forall_index\" bit field.\n+\t* match.c (match_forall_iterator): Set forall_index field on\n+\tthe iteration variable's symbol.\n+\t* dependency.c (contains_forall_index_p): New function to\n+\ttraverse a gfc_expr to check whether it contains a variable\n+\twith forall_index set in it's symbol.\n+\t(gfc_check_element_vs_element): Return GFC_DEP_EQUAL for scalar\n+\tconstant expressions that don't variables used as FORALL indices.\n+\n 2006-03-22  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR driver/22600"}, {"sha": "2c52882405561f969ee3292c53829ad18cb7384b", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=31708dc6447f26d71c005f440c83de0a0bc590ef", "patch": "@@ -794,6 +794,84 @@ gfc_check_element_vs_section( gfc_ref * lref, gfc_ref * rref, int n)\n }\n \n \n+/* Traverse expr, checking all EXPR_VARIABLE symbols for their\n+   forall_index attribute.  Return true if any variable may be\n+   being used as a FORALL index.  Its safe to pessimistically\n+   return true, and assume a dependency.  */\n+\n+static bool\n+contains_forall_index_p (gfc_expr * expr)\n+{\n+  gfc_actual_arglist *arg;\n+  gfc_constructor *c;\n+  gfc_ref *ref;\n+  int i;\n+\n+  if (!expr)\n+    return false;\n+\n+  switch (expr->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+      if (expr->symtree->n.sym->forall_index)\n+\treturn true;\n+      break;\n+\n+    case EXPR_OP:\n+      if (contains_forall_index_p (expr->value.op.op1)\n+\t  || contains_forall_index_p (expr->value.op.op2))\n+\treturn true;\n+      break;\n+\n+    case EXPR_FUNCTION:\n+      for (arg = expr->value.function.actual; arg; arg = arg->next)\n+\tif (contains_forall_index_p (arg->expr))\n+\t  return true;\n+      break;\n+\n+    case EXPR_CONSTANT:\n+    case EXPR_NULL:\n+    case EXPR_SUBSTRING:\n+      break;\n+\n+    case EXPR_STRUCTURE:\n+    case EXPR_ARRAY:\n+      for (c = expr->value.constructor; c; c = c->next)\n+\tif (contains_forall_index_p (c->expr))\n+\t  return true;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    switch (ref->type)\n+      {\n+      case REF_ARRAY:\n+\tfor (i = 0; i < ref->u.ar.dimen; i++)\n+\t  if (contains_forall_index_p (ref->u.ar.start[i])\n+\t      || contains_forall_index_p (ref->u.ar.end[i])\n+\t      || contains_forall_index_p (ref->u.ar.stride[i]))\n+\t    return true;\n+\tbreak;\n+\n+      case REF_COMPONENT:\n+\tbreak;\n+\n+      case REF_SUBSTRING:\n+\tif (contains_forall_index_p (ref->u.ss.start)\n+\t    || contains_forall_index_p (ref->u.ss.end))\n+\t  return true;\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  return false;\n+}\n+\n /* Determines overlapping for two single element array references.  */\n \n static gfc_dependency\n@@ -812,9 +890,23 @@ gfc_check_element_vs_element (gfc_ref * lref, gfc_ref * rref, int n)\n   i = gfc_dep_compare_expr (r_start, l_start);\n   if (i == 0)\n     return GFC_DEP_EQUAL;\n-  if (i == -2)\n+  if (i != -2)\n+    return GFC_DEP_NODEP;\n+\n+  /* Treat two scalar variables as potentially equal.  This allows\n+     us to prove that a(i,:) and a(j,:) have no dependency.  See\n+     Gerald Roth, \"Evaluation of Array Syntax Dependence Analysis\",\n+     Proceedings of the International Conference on Parallel and\n+     Distributed Processing Techniques and Applications (PDPTA2001),\n+     Las Vegas, Nevada, June 2001.  */\n+  /* However, we need to be careful when either scalar expression\n+     contains a FORALL index, as these can potentially change value\n+     during the scalarization/traversal of this array reference.  */\n+  if (contains_forall_index_p (r_start)\n+      || contains_forall_index_p (l_start))\n     return GFC_DEP_OVERLAP;\n-  return GFC_DEP_NODEP;\n+\n+  return GFC_DEP_EQUAL;\n }\n \n "}, {"sha": "a7b84b1a2e3827b4de5239a0c1d4647043462628", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=31708dc6447f26d71c005f440c83de0a0bc590ef", "patch": "@@ -852,6 +852,8 @@ typedef struct gfc_symbol\n   /* Nonzero if all equivalences associated with this symbol have been\n      processed.  */\n   unsigned equiv_built:1;\n+  /* Set if this variable is used as an index name in a FORALL.  */\n+  unsigned forall_index:1;\n   int refs;\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n "}, {"sha": "865781f9f865f5ad75dfb6ccdb3bf4462740a89e", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=31708dc6447f26d71c005f440c83de0a0bc590ef", "patch": "@@ -3370,6 +3370,9 @@ match_forall_iterator (gfc_forall_iterator ** result)\n \tgoto cleanup;\n     }\n \n+  /* Mark the iteration variable's symbol as used as a FORALL index.  */\n+  iter->var->symtree->n.sym->forall_index = true;\n+\n   *result = iter;\n   return MATCH_YES;\n "}, {"sha": "aa61c522aa4c4fd57ec6e11ee5f5a7eee6c358c7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=31708dc6447f26d71c005f440c83de0a0bc590ef", "patch": "@@ -1,3 +1,7 @@\n+2006-03-24  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gfortran.dg/dependency_9.f90: New (resurected) test case.\n+\n 2006-03-24  Jeff Law  <law@redhat.com>\n \n \t* gcc.c-torture/pr26840.c: New test."}, {"sha": "d1f6f5e3fed267fd189edc480db7365b68fd9d9f", "filename": "gcc/testsuite/gfortran.dg/dependency_9.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31708dc6447f26d71c005f440c83de0a0bc590ef/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_9.f90?ref=31708dc6447f26d71c005f440c83de0a0bc590ef", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+subroutine foo(a,i,j)\n+  integer, dimension (4,4) :: a\n+  integer :: i\n+  integer :: j\n+\n+  where (a(i,:) .ne. 0)\n+    a(j,:) = 1\n+  endwhere\n+end subroutine\n+! { dg-final { scan-tree-dump-times \"malloc\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}