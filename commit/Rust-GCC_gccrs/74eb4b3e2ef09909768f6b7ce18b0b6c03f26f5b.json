{"sha": "74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRlYjRiM2UyZWYwOTkwOTc2OGY2YjdjZTE4YjBiNmMwM2YyNmY1Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-04-21T19:21:59Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-04-21T19:21:59Z"}, "message": "c-ppoutput.c (cb_include): Don't take a cpp_token.\n\n\t* c-ppoutput.c (cb_include): Don't take a cpp_token.\n\t* cppfiles.c: Don't undef strcmp.\n\t(find_include_file): Don't take a cpp_token.  Check for empty\n\tfile names.\n\t(_cpp_execute_include, _cpp_compare_file_date): Don't take a cpp_token.\n\t(cpp_push_include): Simplify.\n\t* cpphash.h (_cpp_execute_include, _cpp_compare_file_date): Update.\n\t* cpplib.c (glue_header_name): Return the file name, not a cpp_token.\n\t(parse_include): Similary.  Don't check for zero-length filenames.\n\t(do_include_common, do_pragma_dependency): Update accordingly.\n\t* cpplib.h (struct cpp_callbacks): Change prototype of include.\n\nFrom-SVN: r65894", "tree": {"sha": "18ec4d7a6b4b870f1e5aa394f9a86c0a58ffc185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18ec4d7a6b4b870f1e5aa394f9a86c0a58ffc185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65085aa3eff4cbaf515a4fcbb16d2692ecb1ab74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65085aa3eff4cbaf515a4fcbb16d2692ecb1ab74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65085aa3eff4cbaf515a4fcbb16d2692ecb1ab74"}], "stats": {"total": 230, "additions": 121, "deletions": 109}, "files": [{"sha": "27e72286eef843a5bde101a570bf7e3eb0613e8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "patch": "@@ -1,3 +1,17 @@\n+2003-04-21  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* c-ppoutput.c (cb_include): Don't take a cpp_token.\n+\t* cppfiles.c: Don't undef strcmp.\n+\t(find_include_file): Don't take a cpp_token.  Check for empty\n+\tfile names.\n+\t(_cpp_execute_include, _cpp_compare_file_date): Don't take a cpp_token.\n+\t(cpp_push_include): Simplify.\n+\t* cpphash.h (_cpp_execute_include, _cpp_compare_file_date): Update.\n+\t* cpplib.c (glue_header_name): Return the file name, not a cpp_token.\n+\t(parse_include): Similary.  Don't check for zero-length filenames.\n+\t(do_include_common, do_pragma_dependency): Update accordingly.\n+\t* cpplib.h (struct cpp_callbacks): Change prototype of include.\n+\n 2003-04-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* expr.c (store_constructor): Set RTX_UNCHANGING_P if readonly_field_p"}, {"sha": "2c1835def7182e3cc7b694e45a2e304442a358b6", "filename": "gcc/c-ppoutput.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-ppoutput.c?ref=74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "patch": "@@ -55,7 +55,7 @@ static void cb_line_change PARAMS ((cpp_reader *, const cpp_token *, int));\n static void cb_define\tPARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n static void cb_undef\tPARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n static void cb_include\tPARAMS ((cpp_reader *, unsigned int,\n-\t\t\t\t const unsigned char *, const cpp_token *));\n+\t\t\t\t const unsigned char *, const char *, int));\n static void cb_ident\t  PARAMS ((cpp_reader *, unsigned int,\n \t\t\t\t   const cpp_string *));\n static void cb_def_pragma PARAMS ((cpp_reader *, unsigned int));\n@@ -345,15 +345,18 @@ cb_undef (pfile, line, node)\n }\n \n static void\n-cb_include (pfile, line, dir, header)\n-     cpp_reader *pfile;\n+cb_include (pfile, line, dir, header, angle_brackets)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n      unsigned int line;\n      const unsigned char *dir;\n-     const cpp_token *header;\n+     const char *header;\n+     int angle_brackets;\n {\n   maybe_print_line (print.map, line);\n-  fprintf (print.outf, \"#%s %s\\n\", dir,\n-\t   cpp_token_as_text (pfile, header));\n+  if (angle_brackets)\n+    fprintf (print.outf, \"#%s <%s>\\n\", dir, header);\n+  else\n+    fprintf (print.outf, \"#%s \\\"%s\\\"\\n\", dir, header);\n   print.line++;\n }\n "}, {"sha": "c7a4f9c87dc83ff4ae1ab82a7316ead96f297f16", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "patch": "@@ -44,10 +44,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n # define ENOTDIR 0\n #endif\n \n-/* Suppress warning about function macros used w/o arguments in traditional\n-   C.  It is unlikely that glibc's strcmp macro helps this file at all.  */\n-#undef strcmp\n-\n /* This structure is used for the table of all includes.  */\n struct include_file {\n   const char *name;\t\t/* actual path name of file */\n@@ -98,7 +94,7 @@ static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n static struct cpp_path *search_from PARAMS ((cpp_reader *,\n \t\t\t\t\t\tenum include_type));\n static struct include_file *\n-\tfind_include_file PARAMS ((cpp_reader *, const cpp_token *,\n+\tfind_include_file PARAMS ((cpp_reader *, const char *, int,\n \t\t\t\t   enum include_type));\n static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n static struct include_file *validate_pch PARAMS ((cpp_reader *,\n@@ -597,22 +593,28 @@ cpp_included (pfile, fname)\n   return 0;\n }\n \n-/* Search for HEADER.  Return 0 if there is no such file (or it's\n+/* Search for FNAME.  Return 0 if there is no such file (or it's\n    un-openable), in which case an error code will be in errno.  If\n    there is no include path to use it returns NO_INCLUDE_PATH,\n    otherwise an include_file structure.  If this request originates\n    from a directive of TYPE #include_next, set INCLUDE_NEXT to true.  */\n static struct include_file *\n-find_include_file (pfile, header, type)\n+find_include_file (pfile, fname, angle_brackets, type)\n      cpp_reader *pfile;\n-     const cpp_token *header;\n+     const char *fname;\n+     int angle_brackets;\n      enum include_type type;\n {\n-  const char *fname = (const char *) header->val.str.text;\n   struct cpp_path *path;\n   struct include_file *file;\n   char *name, *n;\n \n+  if (*fname == '\\0')\n+    {\n+      cpp_error (pfile, DL_ERROR, \"empty file name\");\n+      return NO_INCLUDE_PATH;\n+    }\n+\n   if (IS_ABSOLUTE_PATHNAME (fname))\n     return open_file_pch (pfile, fname);\n \n@@ -621,7 +623,7 @@ find_include_file (pfile, header, type)\n      path use the normal search logic.  */\n   if (type == IT_INCLUDE_NEXT && pfile->buffer->inc->foundhere)\n     path = pfile->buffer->inc->foundhere->next;\n-  else if (header->type == CPP_HEADER_NAME)\n+  else if (angle_brackets)\n     path = pfile->bracket_include;\n   else\n     path = search_from (pfile, type);\n@@ -751,17 +753,18 @@ handle_missing_header (pfile, fname, angle_brackets)\n    including HEADER, and the command line -imacros and -include.\n    Returns true if a buffer was stacked.  */\n bool\n-_cpp_execute_include (pfile, header, type)\n+_cpp_execute_include (pfile, fname, angle_brackets, type)\n      cpp_reader *pfile;\n-     const cpp_token *header;\n+     const char *fname;\n+     int angle_brackets;\n      enum include_type type;\n {\n   bool stacked = false;\n-  struct include_file *inc = find_include_file (pfile, header, type);\n+  struct include_file *inc;\n \n+  inc = find_include_file (pfile, fname, angle_brackets, type);\n   if (inc == 0)\n-    handle_missing_header (pfile, (const char *) header->val.str.text,\n-\t\t\t   header->type == CPP_HEADER_NAME);\n+    handle_missing_header (pfile, fname, angle_brackets);\n   else if (inc != NO_INCLUDE_PATH)\n     {\n       stacked = stack_include_file (pfile, inc);\n@@ -777,12 +780,14 @@ _cpp_execute_include (pfile, header, type)\n    file.  If it cannot be located or dated, return -1, if it is newer\n    newer, return 1, otherwise 0.  */\n int\n-_cpp_compare_file_date (pfile, header)\n+_cpp_compare_file_date (pfile, fname, angle_brackets)\n      cpp_reader *pfile;\n-     const cpp_token *header;\n+     const char *fname;\n+     int angle_brackets;\n {\n-  struct include_file *inc = find_include_file (pfile, header, 0);\n+  struct include_file *inc;\n \n+  inc = find_include_file (pfile, fname, angle_brackets, IT_INCLUDE);\n   if (inc == NULL || inc == NO_INCLUDE_PATH)\n     return -1;\n \n@@ -825,15 +830,9 @@ cpp_push_include (pfile, filename)\n      cpp_reader *pfile;\n      const char *filename;\n {\n-  cpp_token header;\n-\n-  header.type = CPP_STRING;\n-  header.val.str.text = (const unsigned char *) filename;\n-  header.val.str.len = strlen (filename);\n   /* Make the command line directive take up a line.  */\n   pfile->line++;\n-\n-  return _cpp_execute_include (pfile, &header, IT_CMDLINE);\n+  return _cpp_execute_include (pfile, filename, false, IT_CMDLINE);\n }\n \n /* Do appropriate cleanup when a file INC's buffer is popped off the"}, {"sha": "210380ed0c209ad926e0a644214cbe28ab8b3a65", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "patch": "@@ -498,11 +498,10 @@ extern void _cpp_destroy_hashtable\tPARAMS ((cpp_reader *));\n extern void _cpp_fake_include\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_never_reread\t\tPARAMS ((struct include_file *));\n extern bool _cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n-extern bool _cpp_execute_include\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const cpp_token *,\n-\t\t\t\t\t\t enum include_type));\n-extern int _cpp_compare_file_date       PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const cpp_token *));\n+extern bool _cpp_execute_include\tPARAMS ((cpp_reader *, const char *,\n+\t\t\t\t\t\t int, enum include_type));\n+extern int _cpp_compare_file_date       PARAMS ((cpp_reader *, const char *,\n+\t\t\t\t\t\t int));\n extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\n extern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));"}, {"sha": "2829953abbdba82e3fa91b56deea40d506814a3a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 69, "deletions": 72, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "patch": "@@ -104,8 +104,8 @@ static void directive_diagnostics\n \tPARAMS ((cpp_reader *, const directive *, int));\n static void run_directive\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t const char *, size_t));\n-static const cpp_token *glue_header_name PARAMS ((cpp_reader *));\n-static const cpp_token *parse_include PARAMS ((cpp_reader *));\n+static char *glue_header_name\tPARAMS ((cpp_reader *));\n+static const char *parse_include PARAMS ((cpp_reader *, int *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t const cpp_hashnode *));\n static unsigned int read_flag\tPARAMS ((cpp_reader *, unsigned int));\n@@ -570,96 +570,89 @@ do_undef (pfile)\n \n /* Helper routine used by parse_include.  Reinterpret the current line\n    as an h-char-sequence (< ... >); we are looking at the first token\n-   after the <.  Returns the header as a token, or NULL on failure.  */\n-static const cpp_token *\n+   after the <.  Returns a malloced filename.  */\n+static char *\n glue_header_name (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_token *header = NULL;\n   const cpp_token *token;\n-  unsigned char *buffer;\n+  char *buffer;\n   size_t len, total_len = 0, capacity = 1024;\n \n   /* To avoid lexed tokens overwriting our glued name, we can only\n      allocate from the string pool once we've lexed everything.  */\n-  buffer = (unsigned char *) xmalloc (capacity);\n+  buffer = xmalloc (capacity);\n   for (;;)\n     {\n       token = get_token_no_padding (pfile);\n \n-      if (token->type == CPP_GREATER || token->type == CPP_EOF)\n+      if (token->type == CPP_GREATER)\n \tbreak;\n+      if (token->type == CPP_EOF)\n+\t{\n+\t  cpp_error (pfile, DL_ERROR, \"missing terminating > character\");\n+\t  break;\n+\t}\n \n       len = cpp_token_len (token);\n       if (total_len + len > capacity)\n \t{\n \t  capacity = (capacity + len) * 2;\n-\t  buffer = (unsigned char *) xrealloc (buffer, capacity);\n+\t  buffer = xrealloc (buffer, capacity);\n \t}\n \n       if (token->flags & PREV_WHITE)\n \tbuffer[total_len++] = ' ';\n \n-      total_len = cpp_spell_token (pfile, token, &buffer[total_len]) - buffer;\n-    }\n-\n-  if (token->type == CPP_EOF)\n-    cpp_error (pfile, DL_ERROR, \"missing terminating > character\");\n-  else\n-    {\n-      unsigned char *token_mem = _cpp_unaligned_alloc (pfile, total_len + 1);\n-      memcpy (token_mem, buffer, total_len);\n-      token_mem[total_len] = '\\0';\n-\n-      header = _cpp_temp_token (pfile);\n-      header->type = CPP_HEADER_NAME;\n-      header->flags = 0;\n-      header->val.str.len = total_len;\n-      header->val.str.text = token_mem;\n+      total_len = (cpp_spell_token (pfile, token, (uchar *) &buffer[total_len])\n+\t\t   - (uchar *) buffer);\n     }\n \n-  free ((PTR) buffer);\n-  return header;\n+  buffer[total_len] = '\\0';\n+  return buffer;\n }\n \n-/* Returns the header string of #include, #include_next, #import and\n-   #pragma dependency.  Returns NULL on error.  */\n-static const cpp_token *\n-parse_include (pfile)\n+/* Returns the file name of #include, #include_next, #import and\n+   #pragma dependency.  The string is malloced and the caller should\n+   free it.  Returns NULL on error.  */\n+static const char *\n+parse_include (pfile, pangle_brackets)\n      cpp_reader *pfile;\n+     int *pangle_brackets;\n {\n-  const unsigned char *dir;\n+  char *fname;\n   const cpp_token *header;\n \n-  if (pfile->directive == &dtable[T_PRAGMA])\n-    dir = U\"pragma dependency\";\n-  else\n-    dir = pfile->directive->name;\n-\n   /* Allow macro expansion.  */\n   header = get_token_no_padding (pfile);\n-  if (header->type != CPP_STRING && header->type != CPP_HEADER_NAME)\n+  if (header->type == CPP_STRING || header->type == CPP_HEADER_NAME)\n     {\n-      if (header->type != CPP_LESS)\n-\t{\n-\t  cpp_error (pfile, DL_ERROR,\n-\t\t     \"#%s expects \\\"FILENAME\\\" or <FILENAME>\", dir);\n-\t  return NULL;\n-\t}\n-\n-      header = glue_header_name (pfile);\n-      if (header == NULL)\n-\treturn header;\n+      fname = xmalloc (header->val.str.len + 1);\n+      memcpy (fname, header->val.str.text, header->val.str.len);\n+      fname[header->val.str.len] = '\\0';\n+      *pangle_brackets = header->type == CPP_HEADER_NAME;\n     }\n-\n-  if (header->val.str.len == 0)\n+  else if (header->type == CPP_LESS)\n     {\n-      cpp_error (pfile, DL_ERROR, \"empty file name in #%s\", dir);\n+      fname = glue_header_name (pfile);\n+      *pangle_brackets = 1;\n+    }\n+  else\n+    {\n+      const unsigned char *dir;\n+\n+      if (pfile->directive == &dtable[T_PRAGMA])\n+\tdir = U\"pragma dependency\";\n+      else\n+\tdir = pfile->directive->name;\n+      cpp_error (pfile, DL_ERROR, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\",\n+\t\t dir);\n+\n       return NULL;\n     }\n \n   check_eol (pfile);\n-  return header;\n+  return fname;\n }\n \n /* Handle #include, #include_next and #import.  */\n@@ -668,25 +661,29 @@ do_include_common (pfile, type)\n      cpp_reader *pfile;\n      enum include_type type;\n {\n-  const cpp_token *header = parse_include (pfile);\n-  if (!header)\n+  const char *fname;\n+  int angle_brackets;\n+\n+  fname = parse_include (pfile, &angle_brackets);\n+  if (!fname)\n     return;\n \n   /* Prevent #include recursion.  */\n   if (pfile->line_maps.depth >= CPP_STACK_MAX)\n+    cpp_error (pfile, DL_ERROR, \"#include nested too deeply\");\n+  else\n     {\n-      cpp_error (pfile, DL_ERROR, \"#include nested too deeply\");\n-      return;\n-    }\n+      /* Get out of macro context, if we are.  */\n+      skip_rest_of_line (pfile);\n \n-  /* Get out of macro context, if we are.  */\n-  skip_rest_of_line (pfile);\n+      if (pfile->cb.include)\n+\t(*pfile->cb.include) (pfile, pfile->directive_line,\n+\t\t\t      pfile->directive->name, fname, angle_brackets);\n \n-  if (pfile->cb.include)\n-    (*pfile->cb.include) (pfile, pfile->directive_line,\n-\t\t\t  pfile->directive->name, header);\n+      _cpp_execute_include (pfile, fname, angle_brackets, type);\n+    }\n \n-  _cpp_execute_include (pfile, header, type);\n+  free ((PTR) fname);\n }\n \n static void\n@@ -1305,27 +1302,27 @@ static void\n do_pragma_dependency (pfile)\n      cpp_reader *pfile;\n {\n-  const cpp_token *header;\n-  int ordering;\n+  const char *fname;\n+  int angle_brackets, ordering;\n \n-  header = parse_include (pfile);\n-  if (!header)\n+  fname = parse_include (pfile, &angle_brackets);\n+  if (!fname)\n     return;\n \n-  ordering = _cpp_compare_file_date (pfile, header);\n+  ordering = _cpp_compare_file_date (pfile, fname, angle_brackets);\n   if (ordering < 0)\n-    cpp_error (pfile, DL_WARNING, \"cannot find source %s\",\n-\t       cpp_token_as_text (pfile, header));\n+    cpp_error (pfile, DL_WARNING, \"cannot find source file %s\", fname);\n   else if (ordering > 0)\n     {\n-      cpp_error (pfile, DL_WARNING, \"current file is older than %s\",\n-\t\t cpp_token_as_text (pfile, header));\n+      cpp_error (pfile, DL_WARNING, \"current file is older than %s\", fname);\n       if (cpp_get_token (pfile)->type != CPP_EOF)\n \t{\n \t  _cpp_backup_tokens (pfile, 1);\n \t  do_diagnostic (pfile, DL_WARNING, 0);\n \t}\n     }\n+\n+  free ((PTR) fname);\n }\n \n /* Get a token but skip padding.  */"}, {"sha": "a9bdb1d8e858cc0a0e119ac5e5b36090d1c8308a", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=74eb4b3e2ef09909768f6b7ce18b0b6c03f26f5b", "patch": "@@ -375,7 +375,7 @@ struct cpp_callbacks\n   void (*line_change) PARAMS ((cpp_reader *, const cpp_token *, int));\n   void (*file_change) PARAMS ((cpp_reader *, const struct line_map *));\n   void (*include) PARAMS ((cpp_reader *, unsigned int,\n-\t\t\t   const unsigned char *, const cpp_token *));\n+\t\t\t   const unsigned char *, const char *, int));\n   void (*define) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n   void (*undef) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n   void (*ident) PARAMS ((cpp_reader *, unsigned int, const cpp_string *));"}]}