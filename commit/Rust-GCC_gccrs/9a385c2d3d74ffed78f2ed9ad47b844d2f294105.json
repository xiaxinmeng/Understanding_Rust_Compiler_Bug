{"sha": "9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEzODVjMmQzZDc0ZmZlZDc4ZjJlZDlhZDQ3Yjg0NGQyZjI5NDEwNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-05-20T14:20:03Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-05-20T14:20:03Z"}, "message": "Implement CALL_EXPR_MUST_TAIL_CALL\n\nThis patch implements support for marking CALL_EXPRs\nas being mandatory for tail-call-optimization. expand_call\ntries harder to perform the optimization on such CALL_EXPRs,\nand issues an error if it fails.\n\nCurrently this flag isn't accessible from any frontend,\nso the patch uses a plugin for testing the functionality.\n\ngcc/ChangeLog:\n\t* calls.c (maybe_complain_about_tail_call): New function.\n\t(initialize_argument_information): Call\n\tmaybe_complain_about_tail_call when clearing *may_tailcall.\n\t(can_implement_as_sibling_call_p): Call\n\tmaybe_complain_about_tail_call when returning false.\n\t(expand_call): Read CALL_EXPR_MUST_TAIL_CALL and, if set,\n\tensure try_tail_call is set.  Call maybe_complain_about_tail_call\n\tif tail-call optimization fails.\n\t* cfgexpand.c (expand_call_stmt): Initialize\n\tCALL_EXPR_MUST_TAIL_CALL from gimple_call_must_tail_p.\n\t* gimple-pretty-print.c (dump_gimple_call): Dump\n\tgimple_call_must_tail_p.\n\t* gimple.c (gimple_build_call_from_tree): Call\n\tgimple_call_set_must_tail with the value of\n\tCALL_EXPR_MUST_TAIL_CALL.\n\t* gimple.h (enum gf_mask): Add GF_CALL_MUST_TAIL_CALL.\n\t(gimple_call_set_must_tail): New function.\n\t(gimple_call_must_tail_p): New function.\n\t* print-tree.c (print_node): Update printing of TREE_STATIC\n\tto reflect its use for CALL_EXPR_MUST_TAIL_CALL.\n\t* tree-core.h (struct tree_base): Add MUST_TAIL_CALL to the\n\ttrailing comment listing applicable flags.\n\t* tree.h (CALL_EXPR_MUST_TAIL_CALL): New macro.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/must-tail-call-1.c: New test case.\n\t* gcc.dg/plugin/must-tail-call-2.c: New test case.\n\t* gcc.dg/plugin/must_tail_call_plugin.c: New file.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n\nFrom-SVN: r236514", "tree": {"sha": "d8d972fbd4d22fa989496efe8ce39275409a0d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8d972fbd4d22fa989496efe8ce39275409a0d3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b40d90e6c569c434002f968a197d58eed0d2aaa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40d90e6c569c434002f968a197d58eed0d2aaa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40d90e6c569c434002f968a197d58eed0d2aaa3"}], "stats": {"total": 349, "additions": 332, "deletions": 17}, "files": [{"sha": "67d7bf86439373a29cdbc6a2065e2bc6bb281266", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -1,3 +1,29 @@\n+2016-05-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* calls.c (maybe_complain_about_tail_call): New function.\n+\t(initialize_argument_information): Call\n+\tmaybe_complain_about_tail_call when clearing *may_tailcall.\n+\t(can_implement_as_sibling_call_p): Call\n+\tmaybe_complain_about_tail_call when returning false.\n+\t(expand_call): Read CALL_EXPR_MUST_TAIL_CALL and, if set,\n+\tensure try_tail_call is set.  Call maybe_complain_about_tail_call\n+\tif tail-call optimization fails.\n+\t* cfgexpand.c (expand_call_stmt): Initialize\n+\tCALL_EXPR_MUST_TAIL_CALL from gimple_call_must_tail_p.\n+\t* gimple-pretty-print.c (dump_gimple_call): Dump\n+\tgimple_call_must_tail_p.\n+\t* gimple.c (gimple_build_call_from_tree): Call\n+\tgimple_call_set_must_tail with the value of\n+\tCALL_EXPR_MUST_TAIL_CALL.\n+\t* gimple.h (enum gf_mask): Add GF_CALL_MUST_TAIL_CALL.\n+\t(gimple_call_set_must_tail): New function.\n+\t(gimple_call_must_tail_p): New function.\n+\t* print-tree.c (print_node): Update printing of TREE_STATIC\n+\tto reflect its use for CALL_EXPR_MUST_TAIL_CALL.\n+\t* tree-core.h (struct tree_base): Add MUST_TAIL_CALL to the\n+\ttrailing comment listing applicable flags.\n+\t* tree.h (CALL_EXPR_MUST_TAIL_CALL): New macro.\n+\n 2016-05-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* calls.c (expand_call): Move \"Rest of purposes for tail call"}, {"sha": "1b12ecaa7b9b895d089c9c3c8848e124d73ef8a4", "filename": "gcc/calls.c", "status": "modified", "additions": 107, "deletions": 16, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -1102,6 +1102,19 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n       }\n }\n \n+/* Issue an error if CALL_EXPR was flagged as requiring\n+   tall-call optimization.  */\n+\n+static void\n+maybe_complain_about_tail_call (tree call_expr, const char *reason)\n+{\n+  gcc_assert (TREE_CODE (call_expr) == CALL_EXPR);\n+  if (!CALL_EXPR_MUST_TAIL_CALL (call_expr))\n+    return;\n+\n+  error_at (EXPR_LOCATION (call_expr), \"cannot tail-call: %s\", reason);\n+}\n+\n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n    CALL_EXPR EXP.\n \n@@ -1343,7 +1356,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t      /* We can't use sibcalls if a callee-copied argument is\n \t\t stored in the current function's frame.  */\n \t      if (!call_from_thunk_p && DECL_P (base) && !TREE_STATIC (base))\n-\t\t*may_tailcall = false;\n+\t\t{\n+\t\t  *may_tailcall = false;\n+\t\t  maybe_complain_about_tail_call (exp,\n+\t\t\t\t\t\t  \"a callee-copied argument is\"\n+\t\t\t\t\t\t  \" stored in the current \"\n+\t\t\t\t\t\t  \" function's frame\");\n+\t\t}\n \n \t      args[i].tree_value = build_fold_addr_expr_loc (loc,\n \t\t\t\t\t\t\t args[i].tree_value);\n@@ -1406,6 +1425,9 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t= build_fold_addr_expr_loc (loc, make_tree (type, copy));\n \t      type = TREE_TYPE (args[i].tree_value);\n \t      *may_tailcall = false;\n+\t      maybe_complain_about_tail_call (exp,\n+\t\t\t\t\t      \"argument must be passed\"\n+\t\t\t\t\t      \" by copying\");\n \t    }\n \t}\n \n@@ -2358,59 +2380,107 @@ can_implement_as_sibling_call_p (tree exp,\n \t\t\t\t const args_size &args_size)\n {\n   if (!targetm.have_sibcall_epilogue ())\n-    return false;\n+    {\n+      maybe_complain_about_tail_call\n+\t(exp,\n+\t \"machine description does not have\"\n+\t \" a sibcall_epilogue instruction pattern\");\n+      return false;\n+    }\n \n   /* Doing sibling call optimization needs some work, since\n      structure_value_addr can be allocated on the stack.\n      It does not seem worth the effort since few optimizable\n      sibling calls will return a structure.  */\n   if (structure_value_addr != NULL_RTX)\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp, \"callee returns a structure\");\n+      return false;\n+    }\n \n #ifdef REG_PARM_STACK_SPACE\n   /* If outgoing reg parm stack space changes, we can not do sibcall.  */\n   if (OUTGOING_REG_PARM_STACK_SPACE (funtype)\n       != OUTGOING_REG_PARM_STACK_SPACE (TREE_TYPE (current_function_decl))\n       || (reg_parm_stack_space != REG_PARM_STACK_SPACE (current_function_decl)))\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp,\n+\t\t\t\t      \"inconsistent size of stack space\"\n+\t\t\t\t      \" allocated for arguments which are\"\n+\t\t\t\t      \" passed in registers\");\n+      return false;\n+    }\n #endif\n \n   /* Check whether the target is able to optimize the call\n      into a sibcall.  */\n   if (!targetm.function_ok_for_sibcall (fndecl, exp))\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp,\n+\t\t\t\t      \"target is not able to optimize the\"\n+\t\t\t\t      \" call into a sibling call\");\n+      return false;\n+    }\n \n   /* Functions that do not return exactly once may not be sibcall\n      optimized.  */\n-  if (flags & (ECF_RETURNS_TWICE | ECF_NORETURN))\n-    return false;\n+  if (flags & ECF_RETURNS_TWICE)\n+    {\n+      maybe_complain_about_tail_call (exp, \"callee returns twice\");\n+      return false;\n+    }\n+  if (flags & ECF_NORETURN)\n+    {\n+      maybe_complain_about_tail_call (exp, \"callee does not return\");\n+      return false;\n+    }\n \n   if (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (addr))))\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp, \"volatile function type\");\n+      return false;\n+    }\n \n   /* If the called function is nested in the current one, it might access\n      some of the caller's arguments, but could clobber them beforehand if\n      the argument areas are shared.  */\n   if (fndecl && decl_function_context (fndecl) == current_function_decl)\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp, \"nested function\");\n+      return false;\n+    }\n \n   /* If this function requires more stack slots than the current\n      function, we cannot change it into a sibling call.\n      crtl->args.pretend_args_size is not part of the\n      stack allocated by our caller.  */\n   if (args_size.constant > (crtl->args.size - crtl->args.pretend_args_size))\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp,\n+\t\t\t\t      \"callee required more stack slots\"\n+\t\t\t\t      \" than the caller\");\n+      return false;\n+    }\n \n   /* If the callee pops its own arguments, then it must pop exactly\n      the same number of arguments as the current function.  */\n   if (targetm.calls.return_pops_args (fndecl, funtype, args_size.constant)\n       != targetm.calls.return_pops_args (current_function_decl,\n \t\t\t\t\t TREE_TYPE (current_function_decl),\n \t\t\t\t\t crtl->args.size))\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp,\n+\t\t\t\t      \"inconsistent number of\"\n+\t\t\t\t      \" popped arguments\");\n+      return false;\n+    }\n \n   if (!lang_hooks.decls.ok_for_sibcall (fndecl))\n-    return false;\n+    {\n+      maybe_complain_about_tail_call (exp, \"frontend does not support\"\n+\t\t\t\t\t    \" sibling call\");\n+      return false;\n+    }\n \n   /* All checks passed.  */\n   return true;\n@@ -2444,6 +2514,7 @@ expand_call (tree exp, rtx target, int ignore)\n   /* The type of the function being called.  */\n   tree fntype;\n   bool try_tail_call = CALL_EXPR_TAILCALL (exp);\n+  bool must_tail_call = CALL_EXPR_MUST_TAIL_CALL (exp);\n   int pass;\n \n   /* Register in which non-BLKmode value will be returned,\n@@ -2811,10 +2882,18 @@ expand_call (tree exp, rtx target, int ignore)\n       || dbg_cnt (tail_call) == false)\n     try_tail_call = 0;\n \n+  /* If the user has marked the function as requiring tail-call\n+     optimization, attempt it.  */\n+  if (must_tail_call)\n+    try_tail_call = 1;\n+\n   /*  Rest of purposes for tail call optimizations to fail.  */\n   if (try_tail_call)\n-    try_tail_call = can_implement_as_sibling_call_p (exp, structure_value_addr, funtype,\n-\t\t\t\t\t\t     reg_parm_stack_space, fndecl,\n+    try_tail_call = can_implement_as_sibling_call_p (exp,\n+\t\t\t\t\t\t     structure_value_addr,\n+\t\t\t\t\t\t     funtype,\n+\t\t\t\t\t\t     reg_parm_stack_space,\n+\t\t\t\t\t\t     fndecl,\n \t\t\t\t\t\t     flags, addr, args_size);\n \n   /* Check if caller and callee disagree in promotion of function\n@@ -2845,7 +2924,13 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  && (caller_unsignedp != callee_unsignedp\n \t\t      || GET_MODE_BITSIZE (caller_mode)\n \t\t\t < GET_MODE_BITSIZE (callee_mode)))))\n-\ttry_tail_call = 0;\n+\t{\n+\t  try_tail_call = 0;\n+\t  maybe_complain_about_tail_call (exp,\n+\t\t\t\t\t  \"caller and callee disagree in\"\n+\t\t\t\t\t  \" promotion of function\"\n+\t\t\t\t\t  \" return value\");\n+\t}\n     }\n \n   /* Ensure current function's preferred stack boundary is at least\n@@ -3743,7 +3828,13 @@ expand_call (tree exp, rtx target, int ignore)\n       crtl->tail_call_emit = true;\n     }\n   else\n-    emit_insn (normal_call_insns);\n+    {\n+      emit_insn (normal_call_insns);\n+      if (try_tail_call)\n+\t/* Ideally we'd emit a message for all of the ways that it could\n+\t   have failed.  */\n+\tmaybe_complain_about_tail_call (exp, \"tail call production failed\");\n+    }\n \n   currently_expanding_call--;\n "}, {"sha": "56ef71dfbabb73108b35340a99099e4168a0547e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -2626,6 +2626,7 @@ expand_call_stmt (gcall *stmt)\n     TREE_NOTHROW (exp) = 1;\n \n   CALL_EXPR_TAILCALL (exp) = gimple_call_tail_p (stmt);\n+  CALL_EXPR_MUST_TAIL_CALL (exp) = gimple_call_must_tail_p (stmt);\n   CALL_EXPR_RETURN_SLOT_OPT (exp) = gimple_call_return_slot_opt_p (stmt);\n   if (decl\n       && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL"}, {"sha": "48edacce1483cbdf962e8134a020ec839786086d", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -760,6 +760,8 @@ dump_gimple_call (pretty_printer *buffer, gcall *gs, int spc, int flags)\n     pp_string (buffer, \" [return slot optimization]\");\n   if (gimple_call_tail_p (gs))\n     pp_string (buffer, \" [tail call]\");\n+  if (gimple_call_must_tail_p (gs))\n+    pp_string (buffer, \" [must tail call]\");\n \n   if (fn == NULL)\n     return;"}, {"sha": "226b080107289def522ddfea247c5f6aa3bf9114", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -359,6 +359,7 @@ gimple_build_call_from_tree (tree t)\n   /* Carry all the CALL_EXPR flags to the new GIMPLE_CALL.  */\n   gimple_call_set_chain (call, CALL_EXPR_STATIC_CHAIN (t));\n   gimple_call_set_tail (call, CALL_EXPR_TAILCALL (t));\n+  gimple_call_set_must_tail (call, CALL_EXPR_MUST_TAIL_CALL (t));\n   gimple_call_set_return_slot_opt (call, CALL_EXPR_RETURN_SLOT_OPT (t));\n   if (fndecl\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL"}, {"sha": "063e29d78978f4dad74db05705be1d10856d8607", "filename": "gcc/gimple.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -145,6 +145,7 @@ enum gf_mask {\n     GF_CALL_INTERNAL\t\t= 1 << 6,\n     GF_CALL_CTRL_ALTERING       = 1 << 7,\n     GF_CALL_WITH_BOUNDS \t= 1 << 8,\n+    GF_CALL_MUST_TAIL_CALL\t= 1 << 9,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n     GF_OMP_PARALLEL_GRID_PHONY = 1 << 1,\n     GF_OMP_TASK_TASKLOOP\t= 1 << 0,\n@@ -3209,6 +3210,25 @@ gimple_call_tail_p (gcall *s)\n   return (s->subcode & GF_CALL_TAILCALL) != 0;\n }\n \n+/* Mark (or clear) call statement S as requiring tail call optimization.  */\n+\n+static inline void\n+gimple_call_set_must_tail (gcall *s, bool must_tail_p)\n+{\n+  if (must_tail_p)\n+    s->subcode |= GF_CALL_MUST_TAIL_CALL;\n+  else\n+    s->subcode &= ~GF_CALL_MUST_TAIL_CALL;\n+}\n+\n+/* Return true if call statement has been marked as requiring\n+   tail call optimization.  */\n+\n+static inline bool\n+gimple_call_must_tail_p (const gcall *s)\n+{\n+  return (s->subcode & GF_CALL_MUST_TAIL_CALL) != 0;\n+}\n \n /* If RETURN_SLOT_OPT_P is true mark GIMPLE_CALL S as valid for return\n    slot optimization.  This transformation uses the target of the call"}, {"sha": "58b611891e39ecf24dd46bbe713cda256b5557c9", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -324,7 +324,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   if (TREE_PROTECTED (node))\n     fputs (\" protected\", file);\n   if (TREE_STATIC (node))\n-    fputs (\" static\", file);\n+    fputs (code == CALL_EXPR ? \" must-tail-call\" : \" static\", file);\n   if (TREE_DEPRECATED (node))\n     fputs (\" deprecated\", file);\n   if (TREE_VISITED (node))"}, {"sha": "d5739cbd22f98cce23e89d3898b6b5552b3ad80c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -1,3 +1,10 @@\n+2016-05-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/must-tail-call-1.c: New test case.\n+\t* gcc.dg/plugin/must-tail-call-2.c: New test case.\n+\t* gcc.dg/plugin/must_tail_call_plugin.c: New file.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n+\n 2016-05-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.dg/tree-ssa/prefetch-5.c: xfail."}, {"sha": "6d74955aa80895572c30ccccc00cfb78ed3c24d0", "filename": "gcc/testsuite/gcc.dg/plugin/must-tail-call-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust-tail-call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust-tail-call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust-tail-call-1.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -0,0 +1,22 @@\n+extern void abort (void);\n+\n+int __attribute__((noinline,noclone))\n+callee (int i)\n+{\n+  return i * i;\n+}\n+\n+int __attribute__((noinline,noclone))\n+caller (int i)\n+{\n+  return callee (i + 1);\n+}\n+\n+int\n+main (int argc, const char **argv)\n+{\n+  int result = caller (5);\n+  if (result != 36)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c5504f8eed4c97929a0ada986098712523e0b380", "filename": "gcc/testsuite/gcc.dg/plugin/must-tail-call-2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust-tail-call-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust-tail-call-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust-tail-call-2.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -0,0 +1,58 @@\n+/* Allow nested functions.  */\n+/* { dg-options \"-Wno-pedantic\" } */\n+\n+struct box { char field[64]; int i; };\n+\n+struct box __attribute__((noinline,noclone))\n+returns_struct (int i)\n+{\n+  struct box b;\n+  b.i = i * i;\n+  return b;\n+}\n+\n+int __attribute__((noinline,noclone))\n+test_1 (int i)\n+{\n+  return returns_struct (i * 5).i; /* { dg-error \"cannot tail-call: callee returns a structure\" } */\n+}\n+\n+int __attribute__((noinline,noclone))\n+test_2_callee (int i, struct box b)\n+{\n+  if (b.field[0])\n+    return 5;\n+  return i * i;\n+}\n+\n+int __attribute__((noinline,noclone))\n+test_2_caller (int i)\n+{\n+  struct box b;\n+  return test_2_callee (i + 1, b); /* { dg-error \"cannot tail-call: callee required more stack slots than the caller\" } */\n+}\n+\n+extern void setjmp (void);\n+void\n+test_3 (void)\n+{\n+  setjmp (); /* { dg-error \"cannot tail-call: callee returns twice\" } */\n+}\n+\n+void\n+test_4 (void)\n+{\n+  void nested (void)\n+  {\n+  }\n+  nested (); /* { dg-error \"cannot tail-call: nested function\" } */\n+}\n+\n+typedef void (fn_ptr_t) (void);\n+volatile fn_ptr_t fn_ptr;\n+\n+void\n+test_5 (void)\n+{\n+  fn_ptr (); /* { dg-error \"cannot tail-call: callee does not return\" } */\n+}"}, {"sha": "5294f28abbc44697c752e53703afb9585bbe5f2b", "filename": "gcc/testsuite/gcc.dg/plugin/must_tail_call_plugin.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust_tail_call_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust_tail_call_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fmust_tail_call_plugin.c?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-options \"-O\" } */\n+\n+/* Mark all CALL_EXPRs not within \"main\" as requiring tail-call. */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+tree\n+cb_walk_tree_fn (tree * tp, int * walk_subtrees,\n+\t\t void * data ATTRIBUTE_UNUSED)\n+{\n+  if (TREE_CODE (*tp) != CALL_EXPR)\n+    return NULL_TREE;\n+\n+  tree call_expr = *tp;\n+\n+  /* Forcibly mark the CALL_EXPR as requiring tail-call optimization.  */\n+  CALL_EXPR_MUST_TAIL_CALL (call_expr) = 1;\n+  \n+  return NULL_TREE;\n+}\n+\n+static void\n+callback (void *gcc_data, void *user_data)\n+{\n+  tree fndecl = (tree)gcc_data;\n+  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n+\n+  /* Don't mark calls inside \"main\".  */\n+  tree decl_name = DECL_NAME (fndecl);\n+  if (decl_name)\n+    if (0 == strcmp (IDENTIFIER_POINTER (decl_name), \"main\"))\n+      return;\n+\n+  walk_tree (&DECL_SAVED_TREE (fndecl), cb_walk_tree_fn, NULL, NULL);\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  const char *plugin_name = plugin_info->base_name;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  register_callback (plugin_name,\n+\t\t     PLUGIN_PRE_GENERICIZE,\n+\t\t     callback,\n+\t\t     NULL);\n+\n+  return 0;\n+}"}, {"sha": "62f6797c8139975c102dd8cee9336e6ea2fd8236", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -74,6 +74,9 @@ set plugin_test_list [list \\\n     { location_overflow_plugin.c \\\n \t  location-overflow-test-1.c \\\n \t  location-overflow-test-2.c } \\\n+    { must_tail_call_plugin.c \\\n+\t  must-tail-call-1.c \\\n+\t  must-tail-call-2.c } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}, {"sha": "b0699284e0d2e9ad3e7a9a61328e57cc9aab3847", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -1001,6 +1001,9 @@ struct GTY(()) tree_base {\n        SSA_NAME_ANTI_RANGE_P in\n \t   SSA_NAME\n \n+       MUST_TAIL_CALL in\n+\t   CALL_EXPR\n+\n    public_flag:\n \n        TREE_OVERFLOW in"}, {"sha": "2510d166ea6c456f9863e74c1bcfdb9d43fc676b", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a385c2d3d74ffed78f2ed9ad47b844d2f294105/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "patch": "@@ -661,6 +661,11 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define CALL_EXPR_TAILCALL(NODE) \\\n   (CALL_EXPR_CHECK (NODE)->base.addressable_flag)\n \n+/* Set on a CALL_EXPR if the call has been marked as requiring tail call\n+   optimization for correctness.  */\n+#define CALL_EXPR_MUST_TAIL_CALL(NODE) \\\n+  (CALL_EXPR_CHECK (NODE)->base.static_flag)\n+\n /* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the\n    CASE_LOW operand has been processed.  */\n #define CASE_LOW_SEEN(NODE) \\"}]}