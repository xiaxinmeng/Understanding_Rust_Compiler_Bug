{"sha": "c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRjYTFhMDk2MThmZjc1MTIyMGZkMDFkODFiMGNhNjJlNmNkYjczNQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-04-30T11:42:12Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-04-30T11:42:12Z"}, "message": "Strip \"<built-in>\" loc from displayed expansion context\n\nNow that diagnostics for tokens coming from macro expansions point to\nthe spelling location of the relevant token (and then displays the\ncontext of the expansion), some ugly (not so seldom) corner cases can\nhappen.\n\nWhen the relevant token is a built-in token (which means the location\nof that token is BUILTINS_LOCATION) the location prefix displayed to\nthe user in the diagnostic line is the \"<built-in>:0:0\" string.  For\ninstance:\n\n    <built-in>:0:0: warning: conversion to 'float' alters 'int' constant value\n\nFor the user, I think this is surprising and useless.\n\nA more user-friendly approach would be to refer to the first location\nthat (in the reported macro expansion context) is for a location in\nreal source code, like what is shown in the new test case\ngcc/testsuite/g++.dg/warn/Wconversion-real-integer2.C accompanying\nthis patch.\n\nTo do this, I am making the line-map module provide a new\nlinemap_unwind_to_first_non_reserved_loc function that resolves a\nvirtual location to the first spelling location that is in real source\ncode.\n\nI am then using that facility in the diagnostics printing module and\nin the macro unwinder to avoid printing diagnostics lines that refer\nto the locations for built-ins or more generally for reserved\nlocations.  Note that when I start the dance of skipping a built-in\nlocation I also skip locations that are in system headers, because it\nturned out that a lot of those built-ins are actually used in system\nheaders (e.g, \"#define INT_MAX __INT_MAX__\" where __INT_MAX__ is a\nbuilt-in).\n\nBesides the user-friendliness gain, this patch allows a number of\nregression tests to PASS unchanged with and without\n-ftrack-macro-expansion.\n\nTested and bootstrapped on x86_64-unknown-linux-gnu against trunk.\n\nNote that the bootstrap with -ftrack-macro-expansion exhibits other\nseparate issues that are addressed in subsequent patches.  This patch\njust fixes one class of problems.\n\nThe patch does pass bootstrap with -ftrack-macro-expansion turned off,\nthough.\n\nlibcpp/\n\n\t* include/line-map.h (linemap_unwind_toward_expansion): Fix typo\n\tin comment.\n\t(linemap_unwind_to_first_non_reserved_loc): Declare new function.\n\t* line-map.c (linemap_unwind_to_first_non_reserved_loc): Define\n\tnew function.\n\ngcc/\n\n\t* input.c (expand_location_1): When expanding to spelling location\n\tin a context of a macro expansion, skip reserved system header\n\tlocations.  Update comments.  * tree-diagnostic.c\n\t(maybe_unwind_expanded_macro_loc): Likewise.\n\ngcc/testsuite/\n\n\t* g++.dg/warn/Wconversion-real-integer2.C: New test.\n\t* g++.dg/warn/Wconversion-real-integer-3.C: Likewise.\n\t* g++.dg/warn/conversion-real-integer-3.h: New header used by the\n\tnew test above.\n\nFrom-SVN: r186970", "tree": {"sha": "38dd74c3ec31ffcb6460e6b4189050b796ba31ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38dd74c3ec31ffcb6460e6b4189050b796ba31ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/comments", "author": null, "committer": null, "parents": [{"sha": "7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eb918cc4e9ad3e0c99b2b75843baa4da3c13249"}], "stats": {"total": 192, "additions": 185, "deletions": 7}, "files": [{"sha": "9ec7dde25fd015a3b6fa911d2d0781b7e46b55ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -1,5 +1,11 @@\n 2012-04-30  Dodji Seketeli  <dodji@redhat.com>\n \n+\tStrip \"<built-in>\" loc from displayed expansion context\n+\t* input.c (expand_location_1): When expanding to spelling location\n+\tin a context of a macro expansion, skip reserved system header\n+\tlocations.  Update comments.  * tree-diagnostic.c\n+\t(maybe_unwind_expanded_macro_loc): Likewise.\n+\n \tMake expand_location resolve to locus in main source file\n \t* input.c (expand_location_1): New.  Takes a parameter to choose\n \twhether to resolve the location to spelling or expansion point."}, {"sha": "260be7e7d550c3e402015d77994b3590d233f224", "filename": "gcc/input.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -35,20 +35,44 @@ struct line_maps *line_table;\n    location is set to the string \"<built-in>\". If EXPANSION_POINT_P is\n    TRUE and LOC is virtual, then it is resolved to the expansion\n    point of the involved macro.  Otherwise, it is resolved to the\n-   spelling location of the token.  */\n+   spelling location of the token.\n+\n+   When resolving to the spelling location of the token, if the\n+   resulting location is for a built-in location (that is, it has no\n+   associated line/column) in the context of a macro expansion, the\n+   returned location is the first one (while unwinding the macro\n+   location towards its expansion point) that is in real source\n+   code.  */\n \n static expanded_location\n expand_location_1 (source_location loc,\n \t\t   bool expansion_point_p)\n {\n   expanded_location xloc;\n   const struct line_map *map;\n+  enum location_resolution_kind lrk = LRK_MACRO_EXPANSION_POINT;\n+\n+  memset (&xloc, 0, sizeof (xloc));\n \n-  loc = linemap_resolve_location (line_table, loc,\n-\t\t\t\t  expansion_point_p\n-\t\t\t\t  ? LRK_MACRO_EXPANSION_POINT\n-\t\t\t\t  : LRK_SPELLING_LOCATION, &map);\n-  xloc = linemap_expand_location (line_table, map, loc);\n+  if (loc >= RESERVED_LOCATION_COUNT)\n+    {\n+      if (!expansion_point_p)\n+\t{\n+\t  /* We want to resolve LOC to its spelling location.\n+\n+\t     But if that spelling location is a reserved location that\n+\t     appears in the context of a macro expansion (like for a\n+\t     location for a built-in token), let's consider the first\n+\t     location (toward the expansion point) that is not reserved;\n+\t     that is, the first location that is in real source code.  */\n+\t  loc = linemap_unwind_to_first_non_reserved_loc (line_table,\n+\t\t\t\t\t\t\t  loc, &map);\n+\t  lrk = LRK_SPELLING_LOCATION;\n+\t}\n+      loc = linemap_resolve_location (line_table, loc,\n+\t\t\t\t      lrk, &map);\n+      xloc = linemap_expand_location (line_table, map, loc);\n+    }\n \n   if (loc <= BUILTINS_LOCATION)\n     xloc.file = loc == UNKNOWN_LOCATION ? NULL : _(\"<built-in>\");"}, {"sha": "71948097024eea6ffda61310e4faa1ebb26a2d00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -1,5 +1,11 @@\n 2012-04-30  Dodji Seketeli  <dodji@redhat.com>\n \n+\tStrip \"<built-in>\" loc from displayed expansion context\n+\t* g++.dg/warn/Wconversion-real-integer2.C: New test.\n+\t* g++.dg/warn/Wconversion-real-integer-3.C: Likewise.\n+\t* g++.dg/warn/conversion-real-integer-3.h: New header used by the\n+\tnew test above.\n+\n \tFix expansion point loc for macro-like tokens\n \t* gcc.dg/debug/dwarf2/pr41445-5.c: Adjust.\n     \t* gcc.dg/debug/dwarf2/pr41445-6.c: Likewise."}, {"sha": "a4df0100a712d80c83f00f7a86f555fb6988ca37", "filename": "gcc/testsuite/g++.dg/warn/Wconversion-real-integer-3.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer-3.C?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+// { dg-options \"-Wconversion -ftrack-macro-expansion=2\" }\n+// { dg-require-effective-target int32plus }\n+\n+#include \"conversion-real-integer-3.h\"\n+\n+float  vfloat;\n+\n+void h (void)\n+{\n+    // We want to trigger an error on the token INT_MAX below, that is\n+    // a macro that expands to the built-in __INT_MAX__.  Furthermore,\n+    // INT_MAX is defined inside a system header.\n+    //\n+    // The behaviour we want is that the diagnostic should point to\n+    // the locus that inside the source code here, at the relevant\n+    // line below, even with -ftrack-macro-expansion.  We don't want\n+    // it to point to the any locus that is inside the system header.\n+    vfloat = INT_MAX; // { dg-warning \"conversion to .float. alters .int. constant value\" }\n+}"}, {"sha": "29130f1836f9cc02141e4c839d337203c5a85a1d", "filename": "gcc/testsuite/g++.dg/warn/Wconversion-real-integer2.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile }\n+/* { dg-options \"-Wconversion -ftrack-macro-expansion=2\" } */\n+/* { dg-require-effective-target int32plus } */\n+\n+// Before the fix that came with this test, we'd output an error for\n+// the __INT_MAX__ token.  That token has a BUILTINS_LOCATION\n+// location, so the the location prefix in the warning message would\n+// be:\n+//     <built-in>:0:0: warning: conversion to 'float' alters 'int' constant value\n+//\n+// Note the useless and confusing <built-in>:0:0 prefix.  This is\n+// because '__INT_MAX__' being an internal macro token, it has a\n+// BUILTINS_LOCATION location.\n+//\n+// In this case, we want the error message to refer to the first\n+// location (in the macro expansion context) that is not a location\n+// for a built-in token.  That location would be the one for where (in\n+// real source code) the __INT_MAX__ macro has been expanded.\n+//\n+// That would be something like:\n+//\n+//     gcc/testsuite/g++.dg/warn/Wconversion-real-integer2.C:21:17: warning: conversion to 'float' alters 'int' constant value\n+//\n+// That is more useful.\n+\n+#define INT_MAX __INT_MAX__ // { dg-warning \"conversion to .float. alters .int. constant value\" }\n+\n+float  vfloat;\n+\n+void h (void)\n+{\n+    vfloat = INT_MAX; // { dg-message \"expanded from here\" }\n+}"}, {"sha": "6ed5b2c42ab0a46cdb8f4ad4890cb0fd3d8d9ef4", "filename": "gcc/testsuite/g++.dg/warn/conversion-real-integer-3.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fconversion-real-integer-3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fconversion-real-integer-3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fconversion-real-integer-3.h?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -0,0 +1,3 @@\n+#pragma GCC system_header\n+\n+#define INT_MAX __INT_MAX__"}, {"sha": "0a55925fb313412f8c4a54a5411e6e2ef2afcdf9", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -166,6 +166,18 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n           linemap_resolve_location (line_table, iter->where,\n                                     LRK_MACRO_DEFINITION_LOCATION, NULL);\n \n+\t/* Don't print trace for locations that are reserved or from\n+\t   within a system header.  */\n+\t{\n+\t  const struct line_map *m = NULL;\n+\t  source_location l = linemap_resolve_location (line_table, resolved_def_loc,\n+\t\t\t\t\t\t\tLRK_SPELLING_LOCATION,\n+\t\t\t\t\t\t\t&m);\n+\t  if (l < RESERVED_LOCATION_COUNT\n+\t      || LINEMAP_SYSP (m))\n+\t    continue;\n+\t}\n+\n         /* Resolve the location of the expansion point of the macro\n            which expansion gave the token represented by def_loc.\n            This is the locus 2/ of the earlier comment.  */"}, {"sha": "2c05214d4f7ad0263c17524c732fea61c0eda8aa", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -1,5 +1,12 @@\n 2012-04-30  Dodji Seketeli  <dodji@redhat.com>\n \n+\tStrip \"<built-in>\" loc from displayed expansion context\n+\t* include/line-map.h (linemap_unwind_toward_expansion): Fix typo\n+\tin comment.\n+\t(linemap_unwind_to_first_non_reserved_loc): Declare new function.\n+\t* line-map.c (linemap_unwind_to_first_non_reserved_loc): Define\n+\tnew function.\n+\n \tFix expansion point loc for macro-like tokens\n \t* macro.c (macro_of_context): New static function.\n \t(_cpp_push_token_context, push_extended_tokens_context): If the"}, {"sha": "1c81fc52ad74ca7007f2993718f0555076a5c26f", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -666,12 +666,30 @@ source_location linemap_resolve_location (struct line_maps *,\n    location L of the point where M got expanded.  If L is a spelling\n    location inside a macro expansion M', then this function returns\n    the point where M' was expanded.  LOC_MAP is an output parameter.\n-   When non-NULL, *LOC_MAP is set the the map of the returned\n+   When non-NULL, *LOC_MAP is set to the map of the returned\n    location.  */\n source_location linemap_unwind_toward_expansion (struct line_maps *,\n \t\t\t\t\t\t source_location loc,\n \t\t\t\t\t\t const struct line_map **loc_map);\n \n+/* If LOC is the virtual location of a token coming from the expansion\n+   of a macro M and if its spelling location is reserved (e.g, a\n+   location for a built-in token), then this function unwinds (using\n+   linemap_unwind_toward_expansion) the location until a location that\n+   is not reserved and is not in a system header is reached.  In other\n+   words, this unwinds the reserved location until a location that is\n+   in real source code is reached.\n+\n+   Otherwise, if the spelling location for LOC is not reserved or if\n+   LOC doesn't come from the expansion of a macro, the function\n+   returns LOC as is and *MAP is not touched.\n+\n+   *MAP is set to the map of the returned location if the later is\n+   different from LOC.  */\n+source_location linemap_unwind_to_first_non_reserved_loc (struct line_maps *,\n+\t\t\t\t\t\t\t  source_location loc,\n+\t\t\t\t\t\t\t  const struct line_map **map);\n+\n /* Expand source code location LOC and return a user readable source\n    code location.  LOC must be a spelling (non-virtual) location.  If\n    it's a location < RESERVED_LOCATION_COUNT a zeroed expanded source"}, {"sha": "6e514e5531a40a1905fdca3414581cc2b822b03d", "filename": "libcpp/line-map.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ca1a09618ff751220fd01d81b0ca62e6cdb735/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=c4ca1a09618ff751220fd01d81b0ca62e6cdb735", "patch": "@@ -1114,6 +1114,55 @@ linemap_unwind_toward_expansion (struct line_maps *set,\n   return resolved_location;\n }\n \n+/* If LOC is the virtual location of a token coming from the expansion\n+   of a macro M and if its spelling location is reserved (e.g, a\n+   location for a built-in token), then this function unwinds (using\n+   linemap_unwind_toward_expansion) the location until a location that\n+   is not reserved and is not in a sytem header is reached.  In other\n+   words, this unwinds the reserved location until a location that is\n+   in real source code is reached.\n+\n+   Otherwise, if the spelling location for LOC is not reserved or if\n+   LOC doesn't come from the expansion of a macro, the function\n+   returns LOC as is and *MAP is not touched.\n+\n+   *MAP is set to the map of the returned location if the later is\n+   different from LOC.  */\n+source_location\n+linemap_unwind_to_first_non_reserved_loc (struct line_maps *set,\n+\t\t\t\t\t  source_location loc,\n+\t\t\t\t\t  const struct line_map **map)\n+{\n+  source_location resolved_loc;\n+  const struct line_map *map0 = NULL, *map1 = NULL;\n+\n+  map0 = linemap_lookup (set, loc);\n+  if (!linemap_macro_expansion_map_p (map0))\n+    return loc;\n+\n+  resolved_loc = linemap_resolve_location (set, loc,\n+\t\t\t\t\t   LRK_SPELLING_LOCATION,\n+\t\t\t\t\t   &map1);\n+\n+  if (resolved_loc >= RESERVED_LOCATION_COUNT\n+      && !LINEMAP_SYSP (map1))\n+    return loc;\n+\n+  while (linemap_macro_expansion_map_p (map0)\n+\t && (resolved_loc < RESERVED_LOCATION_COUNT\n+\t     || LINEMAP_SYSP (map1)))\n+    {\n+      loc = linemap_unwind_toward_expansion (set, loc, &map0);\n+      resolved_loc = linemap_resolve_location (set, loc,\n+\t\t\t\t\t       LRK_SPELLING_LOCATION,\n+\t\t\t\t\t       &map1);\n+    }\n+\n+  if (map != NULL)\n+    *map = map0;\n+  return loc;\n+}\n+\n /* Expand source code location LOC and return a user readable source\n    code location.  LOC must be a spelling (non-virtual) location.  If\n    it's a location < RESERVED_LOCATION_COUNT a zeroed expanded source"}]}