{"sha": "e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZmMTQ2ZDIyNmIyMjViMWFhMmZkY2QwYTg2OGNiMjRlODgzMjFmZA==", "commit": {"author": {"name": "Sebastian Peryt", "email": "sebastian.peryt@intel.com", "date": "2017-11-15T12:27:31Z"}, "committer": {"name": "Sebastian Peryt", "email": "speryt@gcc.gnu.org", "date": "2017-11-15T12:27:31Z"}, "message": "Fix PR82941 and PR82942 by adding proper vzeroupper generation on SKX. \n\n2017-11-15  Sebastian Peryt  <sebastian.peryt@intel.com>\n\ngcc/\n\n\tPR target/82941\n\tPR target/82942\n\t* config/i386/i386.c (pass_insert_vzeroupper): Modify gate condition\n\tto return true on Xeon and not on Xeon Phi.\n\t(ix86_check_avx256_register): Changed to ...\n\t(ix86_check_avx_upper_register): ... this. Add extra check for\n\tVALID_AVX512F_REG_OR_XI_MODE.\n\t(ix86_avx_u128_mode_needed): Changed\n\tix86_check_avx256_register to ix86_check_avx_upper_register.\n\t(ix86_check_avx256_stores): Changed to ...\n\t(ix86_check_avx_upper_stores): ... this. Changed\n\tix86_check_avx256_register to ix86_check_avx_upper_register.\n\t(ix86_avx_u128_mode_after): Changed\n\tavx_reg256_found to avx_upper_reg_found. Changed\n\tix86_check_avx256_stores to ix86_check_avx_upper_stores.\n\t(ix86_avx_u128_mode_entry): Changed\n\tix86_check_avx256_register to ix86_check_avx_upper_register.\n\t(ix86_avx_u128_mode_exit): Ditto.\n\t* config/i386/i386.h: (host_detect_local_cpu): New define.\n\n2017-11-15  Sebastian Peryt  <sebastian.peryt@intel.com>\n\t\ngcc/testsuite/\n\n\tPR target/82941\n\tPR target/82942\n\t* gcc.target/i386/pr82941-1.c: New test.\n\t* gcc.target/i386/pr82941-2.c: New test.\n\t* gcc.target/i386/pr82942-1.c: New test.\n\t* gcc.target/i386/pr82942-2.c: New test.\n\nFrom-SVN: r254763", "tree": {"sha": "4ac58fc68cfd734d17108553814b245e1616b1f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ac58fc68cfd734d17108553814b245e1616b1f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/comments", "author": {"login": "speryt", "id": 44768132, "node_id": "MDQ6VXNlcjQ0NzY4MTMy", "avatar_url": "https://avatars.githubusercontent.com/u/44768132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/speryt", "html_url": "https://github.com/speryt", "followers_url": "https://api.github.com/users/speryt/followers", "following_url": "https://api.github.com/users/speryt/following{/other_user}", "gists_url": "https://api.github.com/users/speryt/gists{/gist_id}", "starred_url": "https://api.github.com/users/speryt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/speryt/subscriptions", "organizations_url": "https://api.github.com/users/speryt/orgs", "repos_url": "https://api.github.com/users/speryt/repos", "events_url": "https://api.github.com/users/speryt/events{/privacy}", "received_events_url": "https://api.github.com/users/speryt/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8744c9bf825e2f13934040101d085621135a24fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8744c9bf825e2f13934040101d085621135a24fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8744c9bf825e2f13934040101d085621135a24fe"}], "stats": {"total": 119, "additions": 93, "deletions": 26}, "files": [{"sha": "4bae57c7d3aee9c19e5a628ea4b3b519ca134a8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -1,3 +1,25 @@\n+2017-11-15  Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\tPR target/82941\n+\tPR target/82942\n+\t* config/i386/i386.c (pass_insert_vzeroupper): Modify gate condition\n+\tto return true on Xeon and not on Xeon Phi.\n+\t(ix86_check_avx256_register): Changed to ...\n+\t(ix86_check_avx_upper_register): ... this. Add extra check for\n+\tVALID_AVX512F_REG_OR_XI_MODE.\n+\t(ix86_avx_u128_mode_needed): Changed\n+\tix86_check_avx256_register to ix86_check_avx_upper_register.\n+\t(ix86_check_avx256_stores): Changed to ...\n+\t(ix86_check_avx_upper_stores): ... this. Changed\n+\tix86_check_avx256_register to ix86_check_avx_upper_register.\n+\t(ix86_avx_u128_mode_after): Changed\n+\tavx_reg256_found to avx_upper_reg_found. Changed\n+\tix86_check_avx256_stores to ix86_check_avx_upper_stores.\n+\t(ix86_avx_u128_mode_entry): Changed\n+\tix86_check_avx256_register to ix86_check_avx_upper_register.\n+\t(ix86_avx_u128_mode_exit): Ditto.\n+\t* config/i386/i386.h: (host_detect_local_cpu): New define.\n+\n 2017-11-15  Dominik Infuehr  <dominik.infuehr@theobroma-systems.com>\n \n \t* config/arm/xgene1.md (xgene1): Split into automatons"}, {"sha": "c5e84a09954583b04ab8438cb71039627e8e89ce", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -875,7 +875,7 @@ rest_of_handle_insert_vzeroupper (void)\n   int i;\n \n   /* vzeroupper instructions are inserted immediately after reload to\n-     account for possible spills from 256bit registers.  The pass\n+     account for possible spills from 256bit or 512bit registers.  The pass\n      reuses mode switching infrastructure by re-running mode insertion\n      pass, so disable entities that have already been processed.  */\n   for (i = 0; i < MAX_386_ENTITIES; i++)\n@@ -2497,7 +2497,7 @@ class pass_insert_vzeroupper : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return TARGET_AVX && !TARGET_AVX512F\n+      return TARGET_AVX && !TARGET_AVX512ER\n \t     && TARGET_VZEROUPPER && flag_expensive_optimizations\n \t     && !optimize_size;\n     }\n@@ -18640,16 +18640,17 @@ ix86_dirflag_mode_needed (rtx_insn *insn)\n   return X86_DIRFLAG_ANY;\n }\n \n-/* Check if a 256bit AVX register is referenced inside of EXP.   */\n+/* Check if a 256bit or 512 bit AVX register is referenced inside of EXP.   */\n \n static bool\n-ix86_check_avx256_register (const_rtx exp)\n+ix86_check_avx_upper_register (const_rtx exp)\n {\n   if (SUBREG_P (exp))\n     exp = SUBREG_REG (exp);\n \n   return (REG_P (exp)\n-\t  && VALID_AVX256_REG_OR_OI_MODE (GET_MODE (exp)));\n+\t&& (VALID_AVX256_REG_OR_OI_MODE (GET_MODE (exp))\n+\t|| VALID_AVX512F_REG_OR_XI_MODE (GET_MODE (exp))));\n }\n \n /* Return needed mode for entity in optimize_mode_switching pass.  */\n@@ -18662,7 +18663,7 @@ ix86_avx_u128_mode_needed (rtx_insn *insn)\n       rtx link;\n \n       /* Needed mode is set to AVX_U128_CLEAN if there are\n-\t no 256bit modes used in function arguments.  */\n+\t no 256bit or 512bit modes used in function arguments. */\n       for (link = CALL_INSN_FUNCTION_USAGE (insn);\n \t   link;\n \t   link = XEXP (link, 1))\n@@ -18671,21 +18672,21 @@ ix86_avx_u128_mode_needed (rtx_insn *insn)\n \t    {\n \t      rtx arg = XEXP (XEXP (link, 0), 0);\n \n-\t      if (ix86_check_avx256_register (arg))\n+\t      if (ix86_check_avx_upper_register (arg))\n \t\treturn AVX_U128_DIRTY;\n \t    }\n \t}\n \n       return AVX_U128_CLEAN;\n     }\n \n-  /* Require DIRTY mode if a 256bit AVX register is referenced.  Hardware\n-     changes state only when a 256bit register is written to, but we need\n-     to prevent the compiler from moving optimal insertion point above\n-     eventual read from 256bit register.  */\n+  /* Require DIRTY mode if a 256bit or 512bit AVX register is referenced.\n+     Hardware changes state only when a 256bit register is written to,\n+     but we need to prevent the compiler from moving optimal insertion\n+     point above eventual read from 256bit or 512 bit register.  */\n   subrtx_iterator::array_type array;\n   FOR_EACH_SUBRTX (iter, array, PATTERN (insn), NONCONST)\n-    if (ix86_check_avx256_register (*iter))\n+    if (ix86_check_avx_upper_register (*iter))\n       return AVX_U128_DIRTY;\n \n   return AVX_U128_ANY;\n@@ -18767,12 +18768,12 @@ ix86_mode_needed (int entity, rtx_insn *insn)\n   return 0;\n }\n \n-/* Check if a 256bit AVX register is referenced in stores.   */\n+/* Check if a 256bit or 512bit AVX register is referenced in stores.   */\n  \n static void\n-ix86_check_avx256_stores (rtx dest, const_rtx, void *data)\n+ix86_check_avx_upper_stores (rtx dest, const_rtx, void *data)\n  {\n-   if (ix86_check_avx256_register (dest))\n+   if (ix86_check_avx_upper_register (dest))\n     {\n       bool *used = (bool *) data;\n       *used = true;\n@@ -18791,18 +18792,18 @@ ix86_avx_u128_mode_after (int mode, rtx_insn *insn)\n     return AVX_U128_CLEAN;\n \n   /* We know that state is clean after CALL insn if there are no\n-     256bit registers used in the function return register.  */\n+     256bit or 512bit registers used in the function return register. */\n   if (CALL_P (insn))\n     {\n-      bool avx_reg256_found = false;\n-      note_stores (pat, ix86_check_avx256_stores, &avx_reg256_found);\n+      bool avx_upper_reg_found = false;\n+      note_stores (pat, ix86_check_avx_upper_stores, &avx_upper_reg_found);\n \n-      return avx_reg256_found ? AVX_U128_DIRTY : AVX_U128_CLEAN;\n+      return avx_upper_reg_found ? AVX_U128_DIRTY : AVX_U128_CLEAN;\n     }\n \n   /* Otherwise, return current mode.  Remember that if insn\n-     references AVX 256bit registers, the mode was already changed\n-     to DIRTY from MODE_NEEDED.  */\n+     references AVX 256bit or 512bit registers, the mode was already\n+     changed to DIRTY from MODE_NEEDED.  */\n   return mode;\n }\n \n@@ -18845,13 +18846,13 @@ ix86_avx_u128_mode_entry (void)\n   tree arg;\n \n   /* Entry mode is set to AVX_U128_DIRTY if there are\n-     256bit modes used in function arguments.  */\n+     256bit or 512bit modes used in function arguments.  */\n   for (arg = DECL_ARGUMENTS (current_function_decl); arg;\n        arg = TREE_CHAIN (arg))\n     {\n       rtx incoming = DECL_INCOMING_RTL (arg);\n \n-      if (incoming && ix86_check_avx256_register (incoming))\n+      if (incoming && ix86_check_avx_upper_register (incoming))\n \treturn AVX_U128_DIRTY;\n     }\n \n@@ -18885,9 +18886,9 @@ ix86_avx_u128_mode_exit (void)\n {\n   rtx reg = crtl->return_rtx;\n \n-  /* Exit mode is set to AVX_U128_DIRTY if there are\n-     256bit modes used in the function return register.  */\n-  if (reg && ix86_check_avx256_register (reg))\n+  /* Exit mode is set to AVX_U128_DIRTY if there are 256bit\n+     or 512 bit modes used in the function return register. */\n+  if (reg && ix86_check_avx_upper_register (reg))\n     return AVX_U128_DIRTY;\n \n   return AVX_U128_CLEAN;"}, {"sha": "e3e55da42329fa8f384ef55f4b2f802f5a5eb0af", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -1097,6 +1097,9 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    || (MODE) == V16SImode || (MODE) == V16SFmode || (MODE) == V32HImode \\\n    || (MODE) == V4TImode)\n \n+#define VALID_AVX512F_REG_OR_XI_MODE(MODE)\t\t\t\t\\\n+  (VALID_AVX512F_REG_MODE (MODE) || (MODE) == XImode)\n+\n #define VALID_AVX512VL_128_REG_MODE(MODE)\t\t\t\t\\\n   ((MODE) == V2DImode || (MODE) == V2DFmode || (MODE) == V16QImode\t\\\n    || (MODE) == V4SImode || (MODE) == V4SFmode || (MODE) == V8HImode\t\\"}, {"sha": "28cfd3cbe59d0060872a11fd6a7348c066df902c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -1,3 +1,12 @@\n+2017-11-15  Sebastian Peryt  <sebastian.peryt@intel.com>\n+\t\n+\tPR target/82941\n+\tPR target/82942\n+\t* gcc.target/i386/pr82941-1.c: New test.\n+\t* gcc.target/i386/pr82941-2.c: New test.\n+\t* gcc.target/i386/pr82942-1.c: New test.\n+\t* gcc.target/i386/pr82942-2.c: New test.\n+\n 2017-11-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/cpp0x/rv-trivial-bug.C (test2): Return a value."}, {"sha": "d7e530d511613d384fa9715e9d75074ec9316eb1", "filename": "gcc/testsuite/gcc.target/i386/pr82941-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82941-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82941-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82941-1.c?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=skylake-avx512\" } */\n+\n+#include <immintrin.h>\n+\n+extern __m512d y, z;\n+\n+void\n+pr82941 ()\n+{\n+  z = y;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vzeroupper\" 1 } } */"}, {"sha": "db2f8589ab692b669aa5712d2d536364a3a6afc6", "filename": "gcc/testsuite/gcc.target/i386/pr82941-2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82941-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82941-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82941-2.c?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=knl\" } */\n+\n+#include \"pr82941-1.c\"\n+\n+/* { dg-final { scan-assembler-not \"vzeroupper\" } } */"}, {"sha": "9cdf81a9d6033ff3533b0cc2ea1febbab4cb8e66", "filename": "gcc/testsuite/gcc.target/i386/pr82942-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82942-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82942-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82942-1.c?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512f -mno-avx512er -O2\" } */\n+\n+#include \"pr82941-1.c\"\n+\n+/* { dg-final { scan-assembler-times \"vzeroupper\" 1 } } */"}, {"sha": "cb0e337113e37abab429697343c6efbc3d3b8ddd", "filename": "gcc/testsuite/gcc.target/i386/pr82942-2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82942-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6f146d226b225b1aa2fdcd0a868cb24e88321fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82942-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82942-2.c?ref=e6f146d226b225b1aa2fdcd0a868cb24e88321fd", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mavx512f -mavx512er -O2\" } */\n+\n+#include \"pr82941-1.c\"\n+\n+/* { dg-final { scan-assembler-not \"vzeroupper\" } } */"}]}