{"sha": "b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRhYzU3YWIyOTI1ZTljY2VkY2MwZWE3MmNkN2NlNTViYmNkNmRlZg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:17:01Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-14T05:17:01Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r478", "tree": {"sha": "7becaa9e8ecc06df6386da81506f366d60982698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7becaa9e8ecc06df6386da81506f366d60982698"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/comments", "author": null, "committer": null, "parents": [{"sha": "5e3b99538d552be301a13a7fd552163d9e7dd5ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3b99538d552be301a13a7fd552163d9e7dd5ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e3b99538d552be301a13a7fd552163d9e7dd5ae"}], "stats": {"total": 1511, "additions": 957, "deletions": 554}, "files": [{"sha": "b8e43cc557110129f01876b3f0f01b67bc7493d9", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -99,7 +99,7 @@ extern int target_flags;\n \n #define TARGET_DEFAULT 3\n \n-/* Define this to change the optimizations peformed by default.  */\n+/* Define this to change the optimizations performed by default.  */\n \n #define OPTIMIZATION_OPTIONS(LEVEL)\t\\\n {\t\t\t\t\t\\\n@@ -141,7 +141,7 @@ extern int target_flags;\n    for them.  Might as well be consistent with bytes. */\n #define WORDS_BIG_ENDIAN 1\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -172,6 +172,9 @@ extern int target_flags;\n /* Every structure's size must be a multiple of this.  */\n #define STRUCTURE_SIZE_BOUNDARY 8\n \n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 32\n "}, {"sha": "c5707cd46ff319d604b09052d662083691bbfbc3", "filename": "gcc/config/a29k/a29k.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fa29k%2Fa29k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fa29k%2Fa29k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.md?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -23,7 +23,7 @@\n ;; The insns in this file are presented in the same order as the AMD 29000\n ;; User's Manual (i.e., alphabetical by machine op-code).\n ;;\n-;; DEFINE_EXPAND's are located near the first occurrance of the major insn\n+;; DEFINE_EXPAND's are located near the first occurrence of the major insn\n ;; that they generate.\n \f\n ;; The only attribute we have is the type.  We only care about calls, branches,\n@@ -2025,17 +2025,17 @@\n { if (GET_CODE (operands[1]) == REG\n       && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n     {\n-      operands[2] = operand_subword (operands[0], 1, 1, DFmode);\n-      operands[3] = operand_subword (operands[1], 1, 1, DFmode);\n-      operands[4] = operand_subword (operands[0], 0, 1, DFmode);\n-      operands[5] = operand_subword (operands[1], 0, 1, DFmode);\n+      operands[2] = operand_subword (operands[0], 1, 1, DImode);\n+      operands[3] = operand_subword (operands[1], 1, 1, DImode);\n+      operands[4] = operand_subword (operands[0], 0, 1, DImode);\n+      operands[5] = operand_subword (operands[1], 0, 1, DImode);\n     }\n   else\n     {\n-      operands[2] = operand_subword (operands[0], 0, 1, DFmode);\n-      operands[3] = operand_subword (operands[1], 0, 1, DFmode);\n-      operands[4] = operand_subword (operands[0], 1, 1, DFmode);\n-      operands[5] = operand_subword (operands[1], 1, 1, DFmode);\n+      operands[2] = operand_subword (operands[0], 0, 1, DImode);\n+      operands[3] = operand_subword (operands[1], 0, 1, DImode);\n+      operands[4] = operand_subword (operands[0], 1, 1, DImode);\n+      operands[5] = operand_subword (operands[1], 1, 1, DImode);\n     }\n }\")\n "}, {"sha": "862cc8057323369214df88367e3df61ddb76f2d4", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -88,15 +88,15 @@ extern int target_flags;\n      scheduling.  Note that this only saves compilation time; it doesn't\n      matter for the final code.  */\n #ifdef riscos\n-#define TARGET_WHEN_DEBUGING  3\n+#define TARGET_WHEN_DEBUGGING  3\n #else\n-#define TARGET_WHEN_DEBUGING  1\n+#define TARGET_WHEN_DEBUGGING  1\n #endif\n \n #define OVERRIDE_OPTIONS  \\\n {\t\t\t\t\t\t\t\t\\\n   if (write_symbols != NO_DEBUG)\t\t\t\t\\\n-    target_flags |= TARGET_WHEN_DEBUGING;\t\t\t\\\n+    target_flags |= TARGET_WHEN_DEBUGGING;\t\t\t\\\n   else if (TARGET_POKE_FUNCTION_NAME)\t\t\t\t\\\n     target_flags |= 1;\t\t\t\t\t\t\\\n   if (TARGET_FPE)\t\t\t\t\t\t\\\n@@ -125,7 +125,7 @@ extern int target_flags;\n    numbered.  */\n #define WORDS_BIG_ENDIAN  0\n \n-/* Number of bits in an addressible storage unit */\n+/* Number of bits in an addressable storage unit */\n #define BITS_PER_UNIT  8\n \n #define BITS_PER_WORD  32\n@@ -144,6 +144,9 @@ extern int target_flags;\n \n #define BIGGEST_ALIGNMENT  32\n \n+/* Every structures size must be a multiple of 32 bits.  */\n+#define STRUCTURE_SIZE_BOUNDARY 32\n+\n #define STRICT_ALIGNMENT 1\n \n /* Define number of bits in most basic integer type.\n@@ -329,13 +332,13 @@ enum reg_class\n    This macro defines what the ranges are.\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n-\tI: immediate arithmetic operand (i.e. 8 bits shifted as requried).\n+\tI: immediate arithmetic operand (i.e. 8 bits shifted as required).\n \tJ: valid indexing constants.  */\n #define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n   ((C) == 'I' ? const_ok_for_arm (VALUE) :\t\t\\\n    (C) == 'J' ? (abs (VALUE) < 4096) : 0)\n \n-/* Constaint letter 'G' for the FPU immediate constants. */\n+/* Constant letter 'G' for the FPU immediate constants. */\n #define CONST_DOUBLE_OK_FOR_LETTER_P(X,C)\t\\\n     ((C) == 'G' ? const_double_rtx_ok_for_fpu (X) : 0)\n \n@@ -1163,7 +1166,7 @@ do \\\n     extern char *arm_condition_codes[];\t\t\t\t      \\\n     int i;\t\t\t\t\t\t\t      \\\n \t\t\t\t\t\t\t\t      \\\n-    fflush (STREAM);\t    /* XXX for dubugging only.  */\t      \\\n+    fflush (STREAM);\t    /* XXX for debugging only.  */\t      \\\n     if (arm_ccfsm_state == 1 || arm_ccfsm_state == 2)   \t      \\\n       {\t\t\t\t                        \t      \\\n \tfprintf (STREAM, \"@ \\t\");\t\t\t\t      \\"}, {"sha": "e9169872c09564c2aba98199d282b61cac0c602d", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -112,7 +112,7 @@ extern char *output_call ();\n /* Define this if most significant word of a multiword number is numbered.  */\n #define WORDS_BIG_ENDIAN 1\n \n-/* Number of bits in an addressible storage unit */\n+/* Number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -150,9 +150,9 @@ extern char *output_call ();\n /* beware of doubles in structs -- 64 is incompatible with pcc */\n #define BIGGEST_ALIGNMENT 32\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n-/* #define STRICT_ALIGNMENT */\n+#define STRICT_ALIGNMENT 0\n \n /* Define sizes of basic C types to conform to ordinary usage -- these\n    types depend on BITS_PER_WORD otherwise.  */"}, {"sha": "806c3230b6bb1a9fcb4dcfd795aa18c70ed73074", "filename": "gcc/config/fx80/fx80.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Ffx80%2Ffx80.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Ffx80%2Ffx80.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -138,7 +138,7 @@ extern int target_flags;\n    since there are no machine instructions for them.  */\n #define WORDS_BIG_ENDIAN 0\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -169,9 +169,9 @@ extern int target_flags;\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 16\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \n /* Define number of bits in most basic integer type.\n    (If undefined, default is BITS_PER_WORD).  */"}, {"sha": "8dcb6abc274fd08260cf49730b04dd28185ea5c2", "filename": "gcc/config/gmicro/gmicro.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -136,7 +136,7 @@ extern int target_flags;\n    since there are no machine instructions for them.  ????? */\n #define WORDS_BIG_ENDIAN 0\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register. */\n@@ -167,11 +167,12 @@ extern int target_flags;\n /* This is not necessarily 32 on the Gmicro */\n #define BIGGEST_ALIGNMENT 32\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n-/* Unaligned data is allowed on Gmicro, though the access is slow. */\n-/* But now STRICT is defined */\n-#define STRICT_ALIGNMENT\n+   Unaligned data is allowed on Gmicro, though the access is slow. */\n+\n+#define STRICT_ALIGNMENT 1\n+#define SLOW_UNALIGNED_ACCESS 1\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n@@ -369,7 +370,7 @@ extern enum reg_class regno_reg_class[];\n    We do a trick here to modify the effective constraints on the\n    machine description; we zorch the constraint letters that aren't\n    appropriate for a specific target.  This allows us to guarantee\n-   that a specific kind of register will not be used for a given taget\n+   that a specific kind of register will not be used for a given target\n    without fiddling with the register classes above. */\n \n #define REG_CLASS_FROM_LETTER(C) \\\n@@ -384,7 +385,7 @@ extern enum reg_class regno_reg_class[];\n    Return 1 if VALUE is in the range specified by C.\n \n    For the Gmicro, all immediate value optimizations are done \n-   by assember, so no machine dependent definition is necessary ??? */\n+   by assembler, so no machine dependent definition is necessary ??? */\n \n /* #define CONST_OK_FOR_LETTER_P(VALUE, C) ((C) == 'I') */\n #define CONST_OK_FOR_LETTER_P(VALUE, C) 0\n@@ -402,7 +403,7 @@ extern enum reg_class regno_reg_class[];\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class. */\n-/* On the Gmicro series, there is no restricton on GENERAL_REGS,\n+/* On the Gmicro series, there is no restriction on GENERAL_REGS,\n    so CLASS is returned. I do not know whether I should treat FPU_REGS\n    specially or not (at least, m68k does not). */\n \n@@ -438,7 +439,7 @@ extern enum reg_class regno_reg_class[];\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by. */\n-/* On the Gmicro, sp is decrimented by the exact size of the operand */\n+/* On the Gmicro, sp is decremented by the exact size of the operand */\n #define PUSH_ROUNDING(BYTES) (BYTES)\n \n /* Offset of first parameter from the argument pointer register value.  */\n@@ -1215,7 +1216,7 @@ extern enum reg_class regno_reg_class[];\n \n #define NOTICE_UPDATE_CC(EXP, INSN) {CC_STATUS_INIT;}\n \n-/* The skelton of the next macro is taken from \"vax.h\".\n+/* The skeleton of the next macro is taken from \"vax.h\".\n    FPU-reg manipulation is added.  M.Yuhara */\n /* Now comment out.\n #define NOTICE_UPDATE_CC(EXP, INSN) {\t\\"}, {"sha": "9878b5032875858e0a5211520dec985269d5ab48", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -19,7 +19,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n /* The purpose of this file is to define the characteristics of the i386,\n-   independant of assembler syntax or operating system.\n+   independent of assembler syntax or operating system.\n \n    Three other files build on this one to describe a specific assembler syntax:\n    bsd386.h, att386.h, and sun386.h.\n@@ -91,7 +91,7 @@ extern int target_flags;\n /* Not true for 80386 */\n #define WORDS_BIG_ENDIAN 0\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -129,9 +129,9 @@ extern int target_flags;\n    quantities, but these can be aligned on any 32-bit boundary.  */\n #define BIGGEST_ALIGNMENT 32\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n-/* #define STRICT_ALIGNMENT */\n+#define STRICT_ALIGNMENT 0\n \n /* If bit field type is int, don't let it cross an int,\n    and give entire struct the alignment of an int.  */\n@@ -439,10 +439,12 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n    0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+   Here VALUE is the CONST_DOUBLE rtx itself.  We allow constants even if\n+   TARGET_387 isn't set, because the stack register converter may need to\n+   load 0.0 into the function value register. */\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'G' ? (TARGET_80387 && standard_80387_constant_p (VALUE)) : 0)\n+  ((C) == 'G' ? standard_80387_constant_p (VALUE) : 0)\n \n /* Place additional restrictions on the register class to use when it\n    is necessary to be able to hold a value of mode @var{mode} in a reload\n@@ -992,17 +994,19 @@ do {\t\t\t\t\t\t\\\n    differently depending on something about the variable or\n    function named by the symbol (such as what section it is in).\n \n-   On i386, if using PIC, mark a SYMBOL_REF for a static declaration\n+   On i386, if using PIC, mark a SYMBOL_REF for a non-global symbol\n    so that we may access it directly in the GOT.  */\n \n #define ENCODE_SECTION_INFO(DECL) \\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (flag_pic)\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\trtx decl_rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) == 'c'\t\\\n-\t\t\t? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\\\n-\tSYMBOL_REF_FLAG (XEXP (decl_rtl, 0)) = ! TREE_PUBLIC (DECL);\t\\\n+\trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n+\t\t   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\t\\\n+\tSYMBOL_REF_FLAG (XEXP (rtl, 0))\t\t\t\t\t\\\n+\t  = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\t\\\n+\t     || ! TREE_PUBLIC (DECL));\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n@@ -1205,7 +1209,7 @@ to get gcc to use these, since they want the same but different\n number as al, and ax.\n */\n \n-/* note the last four are not really qi_registsers, but\n+/* note the last four are not really qi_registers, but\n    the md will have to never output movb into one of them\n    only a movw .  There is no movb into the last four regs */\n "}, {"sha": "f532bb7a52e56a6e69b9af344cce7e81c2b93697", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 154, "deletions": 138, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -252,30 +252,60 @@\n \f\n ;; logical compare\n \n-;; ??? What if we are testing one byte of an offsettable memory reference?\n (define_insn \"\"\n   [(set (cc0)\n-\t(and:SI (match_operand:SI 0 \"general_operand\" \"%rm\")\n+\t(and:SI (match_operand:SI 0 \"general_operand\" \"%ro\")\n \t\t(match_operand:SI 1 \"general_operand\" \"ri\")))]\n   \"\"\n   \"*\n {\n   /* For small integers, we may actually use testb. */\n   if (GET_CODE (operands[1]) == CONST_INT\n-      && (INTVAL (operands[1]) & ~0xffff) == 0\n-      && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n+      && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))\n+      && ! NON_QI_REG_P (operands[0]))\n     {\n       /* We may set the sign bit spuriously.  */\n-      cc_status.flags |= CC_NOT_NEGATIVE;\n \n-      if (! NON_QI_REG_P (operands[0]) && (INTVAL (operands[1]) & ~0xff) == 0)\n-        return AS2 (test%B0,%1,%b0);\n+      if ((INTVAL (operands[1]) & ~0xff) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  return AS2 (test%B0,%1,%b0);\n+\t}\n \n-      if (QI_REG_P (operands[0]) && (INTVAL (operands[1]) & ~0xff00) == 0)\n+      if ((INTVAL (operands[1]) & ~0xff00) == 0)\n         {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n \t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t INTVAL (operands[1]) >> 8);\n-\t  return AS2 (test%B0,%1,%h0);\n+\n+\t  if (QI_REG_P (operands[0]))\n+\t    return AS2 (test%B0,%1,%h0);\n+\t  else\n+\t    {\n+\t      operands[0] = adj_offsettable_operand (operands[0], 1);\n+\t      return AS2 (test%B0,%1,%b0);\n+\t    }\n+\t}\n+\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && (INTVAL (operands[1]) & ~0xff0000) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t INTVAL (operands[1]) >> 16);\n+\n+\t  operands[0] = adj_offsettable_operand (operands[0], 2);\n+\t  return AS2 (test%B0,%1,%b0);\n+\t}\n+\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && (INTVAL (operands[1]) & ~0xff000000) == 0)\n+        {\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t (INTVAL (operands[1]) >> 24) & 0xff);\n+\n+\t  operands[0] = adj_offsettable_operand (operands[0], 3);\n+\t  return AS2 (test%B0,%1,%b0);\n \t}\n     }\n \n@@ -287,18 +317,18 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(and:HI (match_operand:HI 0 \"general_operand\" \"%rm\")\n+\t(and:HI (match_operand:HI 0 \"general_operand\" \"%ro\")\n \t\t(match_operand:HI 1 \"general_operand\" \"ri\")))]\n   \"\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT\n-      && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\n+      && ! (GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))\n+      && ! NON_QI_REG_P (operands[0]))\n     {\n-      /* Can we ignore the upper byte? */\n-      if (! NON_QI_REG_P (operands[0])\n-\t  && (INTVAL (operands[1]) & 0xff00) == 0)\n+      if ((INTVAL (operands[1]) & 0xff00) == 0)\n \t{\n+\t  /* ??? This might not be necessary. */\n \t  if (INTVAL (operands[1]) & 0xffff0000)\n \t    operands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t   INTVAL (operands[1]) & 0xff);\n@@ -308,13 +338,18 @@\n \t  return AS2 (test%B0,%1,%b0);\n \t}\n \n-      /* Can we ignore the lower byte? */\n-      /* ??? what about offsettable memory references? */\n-      if (QI_REG_P (operands[0]) && (INTVAL (operands[1]) & 0xff) == 0)\n+      if ((INTVAL (operands[1]) & 0xff) == 0)\n         {\n \t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t (INTVAL (operands[1]) >> 8) & 0xff);\n-\t  return AS2 (test%B0,%1,%h0);\n+\n+\t  if (QI_REG_P (operands[0]))\n+\t    return AS2 (test%B0,%1,%h0);\n+\t  else\n+\t    {\n+\t      operands[0] = adj_offsettable_operand (operands[0], 1);\n+\t      return AS2 (test%B0,%1,%b0);\n+\t    }\n \t}\n     }\n \n@@ -747,47 +782,6 @@\n ;;- conversion instructions\n ;;- NONE\n \n-;;- truncation instructions\n-\n-(define_insn \"truncsiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=q,qm\")\n-\t(truncate:QI\n-\t (match_operand:SI 1 \"general_operand\" \"qim,qn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (CONSTANT_P (operands[1]) && GET_CODE (operands[1]) != CONST_INT)\n-    return AS2 (mov%L0,%1,%k0);\n-\n-  return AS2 (mov%B0,%b1,%0);\n-}\")\n-\n-(define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=q,qm\")\n-\t(truncate:QI\n-\t (match_operand:HI 1 \"general_operand\" \"qim,qn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (CONSTANT_P (operands[1]) && GET_CODE (operands[1]) != CONST_INT)\n-    return AS2 (mov%L0,%1,%k0);\n-\n-  return AS2 (mov%B0,%b1,%0);\n-}\")\n-\n-(define_insn \"truncsihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,rm\")\n-\t(truncate:HI\n-\t (match_operand:SI 1 \"general_operand\" \"rim,rn\")))]\n-  \"\"\n-  \"*\n-{\n-  if (CONSTANT_P (operands[1]) && GET_CODE (operands[1]) != CONST_INT)\n-    return AS2 (mov%L0,%1,%k0);\n-\n-  return AS2 (mov%W0,%w1,%0);\n-}\")\n-\f\n ;;- zero extension instructions\n ;; See comments by `andsi' for when andl is faster than movzx.\n \n@@ -1060,7 +1054,7 @@\n   operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n }\")\n \n-;; These match a signed convertion of either DFmode or SFmode to DImode.\n+;; These match a signed conversion of either DFmode or SFmode to DImode.\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=m,!*r\")\n@@ -1113,7 +1107,7 @@\n ;; Conversion between fixed point and floating point.\n ;; The actual pattern that matches these is at the end of this file.\n \n-;; ??? Possibly repsent floatunssidf2 here in gcc2.\n+;; ??? Possibly represent floatunssidf2 here in gcc2.\n \n (define_expand \"floatsisf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -1860,7 +1854,7 @@\n \t  CC_STATUS_INIT;\n \n \t  if (INTVAL (operands[2]) == 0xff)\n-\t    return AS1 (not%B0,%0);\n+\t    return AS1 (not%B0,%b0);\n \n \t  return AS2 (xor%B0,%2,%b0);\n \t}\n@@ -1901,7 +1895,7 @@\n \t\t\t\t   INTVAL (operands[2]) & 0xffff);\n \n \t  if (INTVAL (operands[2]) == 0xff)\n-\t    return AS1 (not%B0,%0);\n+\t    return AS1 (not%B0,%b0);\n \n \t  return AS2 (xor%B0,%2,%b0);\n \t}\n@@ -2622,6 +2616,10 @@\n ;; i486, it is faster to copy a MEM to REG and then use bt, than to use\n ;; bt on the MEM directly.\n \n+;; ??? The first argument of a zero_extract must not be reloaded, so\n+;; don't allow a MEM in the operand predicate without allowing it in the\n+;; constraint.\n+\n (define_insn \"\"\n   [(set (cc0) (zero_extract (match_operand:QI 0 \"register_operand\" \"q\")\n \t\t\t    (const_int 1)\n@@ -2643,45 +2641,45 @@\n   RET;\n }\")\n \n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))\n-   (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"\"\n-  \"*\n-{\n-  /* Copy memory to scratch register; pretend it was there to start with.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      output_asm_insn (AS2 (mov%L2,%0,%2), operands);\n-      operands[0] = operands[2];\n-    }\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, 1 << INTVAL (operands[1]));\n-      output_asm_insn (AS2 (test%L0,%1,%0), operands);\n-    }\n-  else\n-    {\n-      operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]));\n-      cc_status.flags |= CC_Z_IN_NOT_C;\n-      output_asm_insn (AS2 (bt%L0,%1,%0), operands);\n-    }\n-  RET;\n-}\")\n+;; ??? The first argument of a zero_extract must not be reloaded, so\n+;; don't allow a MEM in the operand predicate without allowing it in the\n+;; constraint.\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:HI 0 \"nonimmediate_operand\" \"r\")\n+  [(set (cc0) (zero_extract (match_operand:HI 0 \"register_operand\" \"r\")\n \t\t\t    (const_int 1)\n \t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))]\n   \"\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, 1 << INTVAL (operands[1]));\n-      output_asm_insn (AS2 (test%W0,%1,%0), operands);\n+      if (QI_REG_P (operands[0]) && INTVAL (operands[1]) < 8)\n+\t{\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t 1 << INTVAL (operands[1]));\n+\n+\t  output_asm_insn (AS2 (test%B0,%1,%b0), operands);\n+\t}\n+      else if (QI_REG_P (operands[0]))\n+        {\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t 1 << (INTVAL (operands[1]) - 8));\n+\n+\t  output_asm_insn (AS2 (test%B0,%1,%h0), operands);\n+\t}\n+      else\n+        {\n+\t  /* ??? This will never set CC to negative, even if we test\n+\t     the sign bit of the HImode reg.  But CC0 is only tested\n+\t     for EQ and NE after this insn.  */\n+\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t 1 << INTVAL (operands[1]));\n+\n+\t  output_asm_insn (AS2 (test%L0,%1,%k0), operands);\n+\t}\n     }\n   else\n     {\n@@ -2691,17 +2689,42 @@\n   RET;\n }\")\n \n+;; ??? The first argument of a zero_extract must not be reloaded, so\n+;; don't allow a MEM in the operand predicate without allowing it in the\n+;; constraint.\n+\n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"nonimmediate_operand\" \"r\")\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t    (const_int 1)\n \t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))]\n   \"\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n-      operands[1] = gen_rtx (CONST_INT, VOIDmode, 1 << INTVAL (operands[1]));\n-      output_asm_insn (AS2 (test%L0,%1,%0), operands);\n+      if (QI_REG_P (operands[0]) && INTVAL (operands[1]) < 8)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t 1 << INTVAL (operands[1]));\n+\n+\t  output_asm_insn (AS2 (test%B0,%1,%b0), operands);\n+        }\n+      else if (QI_REG_P (operands[0]) && INTVAL (operands[1]) < 16)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t 1 << (INTVAL (operands[1]) - 8));\n+\n+\t  output_asm_insn (AS2 (test%B0,%1,%h0), operands);\n+        }\n+      else\n+        {\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t 1 << INTVAL (operands[1]));\n+\n+\t  output_asm_insn (AS2 (test%L0,%1,%0), operands);\n+        }\n     }\n   else\n     {\n@@ -3079,31 +3102,29 @@\n ;; Emit code here to do the range checking and make the index zero based.\n \n (define_expand \"casesi\"\n-  [(parallel\n+  [(set (match_dup 5)\n+\t(minus:SI (match_operand:SI 0 \"general_operand\" \"\")\n+\t\t  (match_operand:SI 1 \"general_operand\" \"\")))\n+   (set (cc0)\n+\t(compare (match_dup 5)\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))\n+   (parallel\n     [(set (pc)\n-\t  (if_then_else (leu (minus:SI\n-\t\t\t      (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"\"))\n-\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t\t(plus:SI (mem:SI (plus:SI (pc)\n-\t\t\t\t\t\t  (minus:SI (match_dup 0)\n-\t\t\t\t\t\t\t    (match_dup 1))))\n-\t\t\t\t (label_ref (match_operand 3 \"\" \"\")))\n-\t\t\t(pc)))\n-     (use (label_ref (match_operand 4 \"\" \"\")))\n-     (clobber (match_scratch:SI 5 \"\"))])]\n+\t  (minus:SI (reg:SI 3)\n+\t\t    (mem:SI (plus:SI (mult:SI (match_dup 5)\n+\t\t\t\t\t      (const_int 4))\n+\t\t\t\t     (label_ref (match_operand 3 \"\" \"\"))))))\n+     (clobber (match_scratch:SI 6 \"\"))])]\n   \"flag_pic\"\n   \"\n {\n-  rtx reg = gen_reg_rtx (SImode);\n-\n+  operands[5] = gen_reg_rtx (SImode);\n   current_function_uses_pic_offset_table = 1;\n-\n-  emit_insn (gen_subsi3 (reg, operands[0], operands[1]));\n-  emit_insn (gen_cmpsi (reg, operands[2]));\n-  emit_jump_insn (gen_bgtu (operands[4]));\n-  operands[0] = reg;\n-  operands[1] = CONST0_RTX (SImode);\n }\")\n \n ;; Implement a casesi insn.\n@@ -3137,30 +3158,25 @@\n \n (define_insn \"\"\n   [(set (pc)\n-\t(if_then_else (leu (minus:SI\n-\t\t\t    (match_operand:SI 0 \"general_operand\" \"r\")\n-\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"i\"))\n-\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t      (plus:SI (mem:SI (plus:SI (pc)\n-\t\t\t\t\t\t(minus:SI (match_dup 0)\n-\t\t\t\t\t\t\t  (match_dup 1))))\n-\t\t\t       (label_ref (match_operand 3 \"\" \"\")))\n-\t\t      (pc)))\n-   (use (label_ref (match_operand 4 \"\" \"\")))\n-   (clobber (match_scratch:SI 5 \"=&r\"))]\n+\t(minus:SI (reg:SI 3)\n+\t\t  (mem:SI (plus:SI\n+\t\t\t   (mult:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t    (const_int 4))\n+\t\t\t   (label_ref (match_operand 1 \"\" \"\"))))))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n   \"\"\n   \"*\n {\n   rtx xops[4];\n \n-  xops[0] = pic_offset_table_rtx;\n-  xops[1] = operands[5];\n-  xops[2] = operands[3];\n-  xops[3] = operands[0];\n+  xops[0] = operands[0];\n+  xops[1] = operands[1];\n+  xops[2] = operands[2];\n+  xops[3] = pic_offset_table_rtx;\n \n-  output_asm_insn (AS2 (mov%L1,%0,%1), xops);\n-  output_asm_insn (\\\"sub%L1 %l2@GOTOFF(%0,%3,4),%1\\\", xops);\n-  output_asm_insn (AS1 (jmp,%*%1), xops);\n+  output_asm_insn (AS2 (mov%L2,%3,%2), xops);\n+  output_asm_insn (\\\"sub%L2 %l1@GOTOFF(%3,%0,4),%2\\\", xops);\n+  output_asm_insn (AS1 (jmp,%*%2), xops);\n   ASM_OUTPUT_ALIGN_CODE (asm_out_file);\n   RET;\n }\")\n@@ -3451,8 +3467,8 @@\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=q\")\n-\t(compare (mem:BLK (match_operand:SI 1 \"general_operand\" \"D\"))\n-\t\t (mem:BLK (match_operand:SI 2 \"general_operand\" \"S\"))))\n+\t(compare (mem:BLK (match_operand:SI 1 \"general_operand\" \"S\"))\n+\t\t (mem:BLK (match_operand:SI 2 \"general_operand\" \"D\"))))\n    (use (match_operand:SI 3 \"general_operand\" \"c\"))\n    (use (match_operand:SI 4 \"immediate_operand\" \"i\"))\n    (clobber (match_dup 1))\n@@ -3478,8 +3494,8 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (mem:BLK (match_operand:SI 0 \"general_operand\" \"D\"))\n-\t\t (mem:BLK (match_operand:SI 1 \"general_operand\" \"S\"))))\n+\t(compare (mem:BLK (match_operand:SI 0 \"general_operand\" \"S\"))\n+\t\t (mem:BLK (match_operand:SI 1 \"general_operand\" \"D\"))))\n    (use (match_operand:SI 2 \"general_operand\" \"c\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_dup 0))"}, {"sha": "8bd3e6929fbe8da876707fbfb2e0ab7001197f53", "filename": "gcc/config/i386/sequent.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi386%2Fsequent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi386%2Fsequent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsequent.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -88,5 +88,29 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define FUNCTION_PROFILER(FILE, LABELNO)  \\\n    fprintf (FILE, \"\\tmovl $LP%d,%%eax\\n\\tcall mcount\\n\", (LABELNO));\n \n-/* Assember pseudo-op for shared data segment. */\n+/* Assembler pseudo-op for shared data segment. */\n #define SHARED_SECTION_ASM_OP \".shdata\"\n+\n+/* A C statement or statements which output an assembler instruction\n+   opcode to the stdio stream STREAM.  The macro-operand PTR is a\n+   variable of type `char *' which points to the opcode name in its\n+   \"internal\" form--the form that is written in the machine description.\n+\n+   The Sequent assembler (identified as \"Balance 8000 Assembler\n+   07/17/85 3.90\" by \"as -v\") does not understand the `movs[bwl]' string\n+   move mnemonics - it uses `smov[bwl]' instead.  Change \"movs\" into\n+   \"smov\", carefully avoiding the sign-extend opcodes.  */\n+\n+#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((PTR)[0] == 'm'\t\t\t\t\t\t\t\\\n+      && (PTR)[1] == 'o'\t\t\t\t\t\t\\\n+      && (PTR)[2] == 'v'\t\t\t\t\t\t\\\n+      && (PTR)[3] == 's'\t\t\t\t\t\t\\\n+      && ((PTR)[4] == 'b' || (PTR)[4] == 'w' || (PTR)[4] == 'l')\t\\\n+      && ((PTR)[5] == ' ' || (PTR)[5] == '\\t'|| (PTR)[5] == '\\0'))\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"smov\");\t\t\t\t\t\t\\\n+      (PTR) += 4;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "51175c78c000337068f356f92a399f3c7373a9f3", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -1347,8 +1347,8 @@ output_block_move (operands)\n   output_asm_insn (\"adds %4,%?r0,%5\", xoperands);\n \n   /* Predecrement the loop counter.  This happens again also in the `bla'\n-     instruction which precceds the loop, but we need to have it done\n-     two times before we enter the loop because of the bizzare semantics\n+     instruction which precedes the loop, but we need to have it done\n+     two times before we enter the loop because of the bizarre semantics\n      of the bla instruction.  */\n \n   output_asm_insn (\"adds %5,%2,%2\", xoperands);\n@@ -1522,7 +1522,7 @@ output_delayed_branch (template, operands, insn)\n       output_asm_insn (template, operands);\n \n       /* Now recognize the insn which we put in its delay slot.\n-\t We must do this after outputing the branch insn,\n+\t We must do this after outputting the branch insn,\n \t since operands may just be a pointer to `recog_operand'.  */\n       INSN_CODE (delay_insn) = insn_code_number = recog (pat, delay_insn);\n       if (insn_code_number == -1)\n@@ -1557,7 +1557,7 @@ output_delay_insn (delay_insn)\n   int i;\n \n   /* Now recognize the insn which we put in its delay slot.\n-     We must do this after outputing the branch insn,\n+     We must do this after outputting the branch insn,\n      since operands may just be a pointer to `recog_operand'.  */\n   insn_code_number = recog_memoized (delay_insn);\n   if (insn_code_number == -1)\n@@ -1567,7 +1567,7 @@ output_delay_insn (delay_insn)\n   INSN_CODE (delay_insn) = insn_code_number;\n   insn_extract (delay_insn);\n \n-  /* It is possible that this insn has not been properly scaned by final\n+  /* It is possible that this insn has not been properly scanned by final\n      yet.  If this insn's operands don't appear in the peephole's\n      actual operands, then they won't be fixed up by final, so we\n      make sure they get fixed up here.  -- This is a kludge.  */\n@@ -1623,7 +1623,7 @@ sfmode_constant_to_ulong (x)\n #if TARGET_FLOAT_FORMAT != HOST_FLOAT_FORMAT\n # error IEEE emulation needed\n #endif\n-  REAL_VALUE_FROM_CONST_DOUBLE (u.d, x);\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n   u2.f = d;\n   return u2.i;\n }\n@@ -1663,7 +1663,7 @@ sfmode_constant_to_ulong (x)\n    offsets from the frame pointer).\n \n    Previous versions of GCC also saved the \"preserved\" registers in the\n-   \"nagative\" part of the frame, but they saved them using positive\n+   \"negative\" part of the frame, but they saved them using positive\n    offsets from the (adjusted) stack pointer (after it had been adjusted\n    to allocate space for the new frame).  That's just plain wrong\n    because if the current function calls alloca(), the stack pointer\n@@ -1702,7 +1702,7 @@ sfmode_constant_to_ulong (x)\n \n    There are two somewhat different ways that you can generate prologues\n    here... i.e. pedantically ABI-compliant, and the \"other\" way.  The\n-   \"other\" way is more consistant with what is currently generated by the\n+   \"other\" way is more consistent with what is currently generated by the\n    \"native\" svr4 C compiler for the i860.  That's important if you want\n    to use the current (as of 8/91) incarnation of svr4 SDB for the i860.\n    The SVR4 SDB for the i860 insists on having function prologues be"}, {"sha": "ac4b64b22a95e2cf0fbea2b40a265b60047156e5", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -77,7 +77,7 @@ extern int target_flags;\n /* For the i860 this goes with BYTES_BIG_ENDIAN.  */\n #define WORDS_BIG_ENDIAN 0\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -117,9 +117,9 @@ extern int target_flags;\n    boundaries.  */\n #define BIGGEST_ALIGNMENT 128\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \n /* If bit field type is int, dont let it cross an int,\n    and give entire struct the alignment of an int.  */\n@@ -1207,7 +1207,7 @@ struct cumulative_args { int ints, floats; };\n \t`H'\tThe operand is a numeric constant, a constant address, or\n \t\ta memory ref to a constant address.  Print the correct\n \t\tnotation to yield the high part of the given value or\n-\t\taddress or the high part of the address of the refered\n+\t\taddress or the high part of the address of the referred\n \t\tto memory object.\n \n \t`h'\tThe operand is a numeric constant, a constant address, or\n@@ -1347,7 +1347,7 @@ extern unsigned long sfmode_constant_to_ulong ();\n    libgcc1.c routines in such a way that they know the actual types\n    of their formal arguments and the actual types of their return\n    values.  Otherwise, gcc will generate calls to the libgcc1.c\n-   routines, passing argumenst in in the floating-point registers,\n+   routines, passing arguments in the floating-point registers,\n    but the libgcc1.c routines will expect their arguments on the\n    stack (where the i860 calling conventions require structs &\n    unions to be passed).  */\n@@ -1361,7 +1361,7 @@ extern unsigned long sfmode_constant_to_ulong ();\n /* Optionally define this if you have added predicates to\n    `MACHINE.c'.  This macro is called within an initializer of an\n    array of structures.  The first field in the structure is the\n-   name of a predicate and the second field is an arrary of rtl\n+   name of a predicate and the second field is an array of rtl\n    codes.  For each predicate, list all rtl codes that can be in\n    expressions matched by the predicate.  The list should have a\n    trailing comma.  Here is an example of two entries in the list"}, {"sha": "f480a571e1784a666b563ab96fa534443622e730", "filename": "gcc/config/i860/x-sysv4", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi860%2Fx-sysv4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fi860%2Fx-sysv4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fx-sysv4?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -9,9 +9,27 @@ INSTALL=cp\n # if we try to link programs with libucb.a before libc.a, those\n # programs tend to crash.\n \n-# More importantly, the alloca() routine supplied in early versions\n-# of svr4 for the i860 (in /usr/ucblib/libucb.a) is broken, so we\n-# should NOT try to use it anyway.\n+# Also, the alloca() routine supplied in early version of svr4 for\n+# the i860 is non-ABI compliant.  It doesn't keep the stack aligned\n+# to a 16-byte boundary as the ABI requires.\n+\n+# More importantly however, even a fully ABI compliant alloca() routine\n+# would fail to work correctly with some versions of the native svr4 C\n+# compiler currently being distributed for the i860 (as of 1/29/92).\n+# The problem is that the native C compiler generates non-ABI-compliant\n+# function epilogues which cut back the stack (upon function exit) in\n+# an incorrect manner.  Specifically, they cut back the stack by adding\n+# the nominal *static* frame size (determined statically at compile-time)\n+# to the stack pointer rather than setting the stack pointer based upon\n+# the current value of the frame pointer (as called for in the i860 ABI).\n+# This can cause serious trouble in cases where you repeatedly call a\n+# routine which itself calls alloca().  In such cases, the stack will\n+# grow continuously until you finally run out of swap space or exceed\n+# the system's process size limit.  To avoid this problem (which can\n+# arise when a stage1 gcc is being used to build a stage2 gcc) you\n+# *must* link in the C language version of alloca() which is supplied\n+# with gcc to your stage1 version of gcc.  The following definition\n+# forces that to happen.\n \n ALLOCA=alloca.o\n \n@@ -23,7 +41,7 @@ ALLOCA=alloca.o\n # i860 recognizes a special -gg option.  Using that option causes *full*\n # Dwarf debugging information to be generated, whereas using only -g\n # causes only limited Dwarf debugging information to be generated.\n-# (This is an undocumented feature of that compiler.)\n+# (This is an undocumented feature of the native svr4 C compiler.)\n \n CCLIBFLAGS=-Bstatic -dn -gg\n GCC_CFLAGS=-static -g -O2 -B./"}, {"sha": "2f0ed4e6efb2d7d66c583943e8068b0cd9a787de", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -82,7 +82,7 @@ extern int target_flags;\n #define TARGET_SKY (target_flags & 0200)\n \n /* Optimize for 68040.\n-   The 68040 will execute all 68030 and 68881/2 instrcutions, but some\n+   The 68040 will execute all 68030 and 68881/2 instructions, but some\n    of them must be emulated in software by the OS.  When TARGET_68040 is\n    turned on, these instructions won't be used.  This code will still\n    run on a 68030 and 68881/2. */\n@@ -158,7 +158,7 @@ extern int target_flags;\n    So let's be consistent.  */\n #define WORDS_BIG_ENDIAN 1\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -189,9 +189,9 @@ extern int target_flags;\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 16\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \n #define SELECT_RTX_SECTION(MODE, X)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1254,11 +1254,6 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS 0\n \n-/* Define if shifts truncate the shift count\n-   which implies one can omit a sign-extension or zero-extension\n-   of a shift count.  */\n-#define SHIFT_COUNT_TRUNCATED\n-\n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n    is done just by pretending it is already truncated.  */\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n@@ -1327,6 +1322,9 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n   case LSHIFT:\t\t\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\t\\\n     /* A shift by a big integer takes an extra instruction.  */ \\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t&& (INTVAL (XEXP (X, 1)) == 16))\t\t\t\\\n+      return COSTS_N_INSNS (2);\t /* clrw;swap */\t\t\\\n     if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n \t&& !(INTVAL (XEXP (X, 1)) > 0\t\t\t\t\\\n \t     && INTVAL (XEXP (X, 1)) <= 8))\t\t\t\\\n@@ -1335,7 +1333,17 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\\\n     if (GET_CODE (XEXP (x, 1)) == CONST_INT\t\t\t\\\n \t&& exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\t\t\\\n-      total = 2;\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t/* A shift by a big integer takes an extra instruction.  */ \\\n+\tif (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t    && (INTVAL (XEXP (X, 1)) == (1 << 16)))\t\t\\\n+\t  return COSTS_N_INSNS (2);\t /* clrw;swap */\t\\\n+\tif (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t    && !(INTVAL (XEXP (X, 1)) > 1\t\t\t\\\n+\t\t && INTVAL (XEXP (X, 1)) <= 256))\t\t\\\n+\t  return COSTS_N_INSNS (3);\t /* lsr #i,dn */\t\\\n+\tbreak;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n     else if (GET_MODE (X) == QImode || GET_MODE (X) == HImode)\t\\\n       return COSTS_N_INSNS (8); /* mul.w */\t\t\t\\\n     else\t\t\t\t\t\t\t\\\n@@ -1565,11 +1573,11 @@ do { union { float f; long l;} tem;\t\t\t\\\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n \n+/* We don't have a way to align to more than a two-byte boundary, so do the\n+   best we can and don't complain.  */\n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) == 1)\t\t\t\\\n-    fprintf (FILE, \"\\t.even\\n\");\t\\\n-  else if ((LOG) != 0)\t\t\t\\\n-    abort ();\n+  if ((LOG) >= 1)\t\t\t\\\n+    fprintf (FILE, \"\\t.even\\n\");\n \n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n   fprintf (FILE, \"\\t.skip %u\\n\", (SIZE))"}, {"sha": "73951269ca7655b1a1052595f3919246d76e9f1d", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 337, "deletions": 73, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -221,7 +221,7 @@\n ;;- \"command register\" mode means that no accessing of memory or the\n ;;- 68000 registers is being done.  This can be expressed easily in\n ;;- constraints, so generally the mode of the instruction is\n-;;- determined by a branch off of which_alternative.  In outputing\n+;;- determined by a branch off of which_alternative.  In outputting\n ;;- instructions, a 'w' means to output an access to the constant ram\n ;;- (if the arg is CONST_DOUBLE and is one of the available\n ;;- constants), and 'x' means to output a register pair (if the arg is\n@@ -691,7 +691,7 @@\n ;;\n ;; This is the main \"hook\" for PIC code.  When generating\n ;; PIC, movsi is responsible for determining when the source address\n-;; needs PIC relocation and appropriatly calling legitimize_pic_address\n+;; needs PIC relocation and appropriately calling legitimize_pic_address\n ;; to perform the actual relocation.\n ;;\n ;; In both the PIC and non-PIC cases the patterns generated will\n@@ -1156,7 +1156,7 @@\n {\n   if (GET_CODE (operands[0]) == REG)\n     {\n-      /* Must clear condition codes, since the mov.l bases them on\n+      /* Must clear condition codes, since the move.l bases them on\n \t the entire 32 bits, not just the desired 8 bits.  */\n       CC_STATUS_INIT;\n       return \\\"move%.l %1,%0\\\";\n@@ -1177,14 +1177,14 @@\n       && (GET_CODE (operands[1]) == MEM\n \t  || GET_CODE (operands[1]) == CONST_INT))\n     {\n-      /* Must clear condition codes, since the mov.w bases them on\n+      /* Must clear condition codes, since the move.w bases them on\n \t the entire 16 bits, not just the desired 8 bits.  */\n       CC_STATUS_INIT;\n       return \\\"move%.w %1,%0\\\";\n     }\n   if (GET_CODE (operands[0]) == REG)\n     {\n-      /* Must clear condition codes, since the mov.l bases them on\n+      /* Must clear condition codes, since the move.l bases them on\n \t the entire 32 bits, not just the desired 8 bits.  */\n       CC_STATUS_INIT;\n       return \\\"move%.l %1,%0\\\";\n@@ -1203,7 +1203,7 @@\n {\n   if (GET_CODE (operands[0]) == REG)\n     {\n-      /* Must clear condition codes, since the mov.l bases them on\n+      /* Must clear condition codes, since the move.l bases them on\n \t the entire 32 bits, not just the desired 8 bits.  */\n       CC_STATUS_INIT;\n       return \\\"move%.l %1,%0\\\";\n@@ -1747,7 +1747,7 @@\n \t\t  : \\\"subq%.l %2,%0\\\");\n \t}\n       /* On everything except the 68000 it is faster to use two\n-\t addqw instuctions to add a small integer (8 < N <= 16)\n+\t addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw.*/\n       if (INTVAL (operands[2]) > 8\n \t  && INTVAL (operands[2]) <= 16\n@@ -1793,6 +1793,15 @@\n #ifndef NO_ADDSUB_Q\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n+      /* If the constant would be a negative number when interpreted as\n+\t HImode, make it negative.  This is usually, but not always, done\n+\t elsewhere in the compiler.  First check for constants out of range,\n+\t which could confuse us.  */\n+\n+      if (INTVAL (operands[2]) >= 32768)\n+\toperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       INTVAL (operands[2]) - 65536);\n+\n       if (INTVAL (operands[2]) > 0\n \t  && INTVAL (operands[2]) <= 8)\n \treturn \\\"addq%.w %2,%0\\\";\n@@ -1804,7 +1813,7 @@\n \t  return \\\"subq%.w %2,%0\\\";\n \t}\n       /* On everything except the 68000 it is faster to use two\n-\t addqw instuctions to add a small integer (8 < N <= 16)\n+\t addqw insttuctions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw. */\n       if (INTVAL (operands[2]) > 8\n \t  && INTVAL (operands[2]) <= 16\n@@ -1839,14 +1848,108 @@\n \t(plus:HI (match_dup 0)\n \t\t (match_operand:HI 1 \"general_operand\" \"dn,rmn\")))]\n   \"\"\n-  \"add%.w %1,%0\")\n+  \"*\n+{\n+#ifndef NO_ADDSUB_Q\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      /* If the constant would be a negative number when interpreted as\n+\t HImode, make it negative.  This is usually, but not always, done\n+\t elsewhere in the compiler.  First check for constants out of range,\n+\t which could confuse us.  */\n+\n+      if (INTVAL (operands[1]) >= 32768)\n+\toperands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       INTVAL (operands[1]) - 65536);\n+\n+      if (INTVAL (operands[1]) > 0\n+\t  && INTVAL (operands[1]) <= 8)\n+\treturn \\\"addq%.w %1,%0\\\";\n+      if (INTVAL (operands[1]) < 0\n+\t  && INTVAL (operands[1]) >= -8)\n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t         - INTVAL (operands[1]));\n+\t  return \\\"subq%.w %1,%0\\\";\n+\t}\n+      /* On everything except the 68000 it is faster to use two\n+\t addqw instuctions to add a small integer (8 < N <= 16)\n+\t to an address register.  Likewise for subqw. */\n+      if (INTVAL (operands[1]) > 8\n+\t  && INTVAL (operands[1]) <= 16\n+\t  && ADDRESS_REG_P (operands[0])\n+\t  && TARGET_68020) \n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) - 8);\n+\t  return \\\"addq%.w %#8,%0; addq%.w %1,%0\\\";\n+\t}\n+      if (INTVAL (operands[1]) < -8\n+\t  && INTVAL (operands[1]) >= -16\n+\t  && ADDRESS_REG_P (operands[0])\n+\t  && TARGET_68020) \n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t\t - INTVAL (operands[1]) - 8);\n+\t  return \\\"subq%.w %#8,%0; subq%.w %1,%0\\\";\n+\t}\n+    }\n+#endif\n+  return \\\"add%.w %1,%0\\\";\n+}\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n \t(plus:HI (match_operand:HI 1 \"general_operand\" \"dn,rmn\")\n \t\t (match_dup 0)))]\n   \"\"\n-  \"add%.w %1,%0\")\n+  \"*\n+{\n+#ifndef NO_ADDSUB_Q\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      /* If the constant would be a negative number when interpreted as\n+\t HImode, make it negative.  This is usually, but not always, done\n+\t elsewhere in the compiler.  First check for constants out of range,\n+\t which could confuse us.  */\n+\n+      if (INTVAL (operands[1]) >= 32768)\n+\toperands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       INTVAL (operands[1]) - 65536);\n+\n+      if (INTVAL (operands[1]) > 0\n+\t  && INTVAL (operands[1]) <= 8)\n+\treturn \\\"addq%.w %1,%0\\\";\n+      if (INTVAL (operands[1]) < 0\n+\t  && INTVAL (operands[1]) >= -8)\n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t         - INTVAL (operands[1]));\n+\t  return \\\"subq%.w %1,%0\\\";\n+\t}\n+      /* On everything except the 68000 it is faster to use two\n+\t addqw instuctions to add a small integer (8 < N <= 16)\n+\t to an address register.  Likewise for subqw. */\n+      if (INTVAL (operands[1]) > 8\n+\t  && INTVAL (operands[1]) <= 16\n+\t  && ADDRESS_REG_P (operands[0])\n+\t  && TARGET_68020) \n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) - 8);\n+\t  return \\\"addq%.w %#8,%0; addq%.w %1,%0\\\";\n+\t}\n+      if (INTVAL (operands[1]) < -8\n+\t  && INTVAL (operands[1]) >= -16\n+\t  && ADDRESS_REG_P (operands[0])\n+\t  && TARGET_68020) \n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t\t - INTVAL (operands[1]) - 8);\n+\t  return \\\"subq%.w %#8,%0; subq%.w %1,%0\\\";\n+\t}\n+    }\n+#endif\n+  return \\\"add%.w %1,%0\\\";\n+}\")\n \n (define_insn \"addqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n@@ -1858,12 +1961,13 @@\n #ifndef NO_ADDSUB_Q\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n+      if (INTVAL (operands[2]) >= 128)\n+\toperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       INTVAL (operands[2]) - 256);\n+\n       if (INTVAL (operands[2]) > 0\n \t  && INTVAL (operands[2]) <= 8)\n \treturn \\\"addq%.b %2,%0\\\";\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n       if (INTVAL (operands[2]) < 0 && INTVAL (operands[2]) >= -8)\n        {\n \t operands[2] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[2]));\n@@ -1879,14 +1983,54 @@\n \t(plus:QI (match_dup 0)\n \t\t (match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n   \"\"\n-  \"add%.b %1,%0\")\n+  \"*\n+{\n+#ifndef NO_ADDSUB_Q\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[1]) >= 128)\n+\toperands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       INTVAL (operands[1]) - 256);\n+\n+      if (INTVAL (operands[1]) > 0\n+\t  && INTVAL (operands[1]) <= 8)\n+\treturn \\\"addq%.b %1,%0\\\";\n+      if (INTVAL (operands[1]) < 0 && INTVAL (operands[1]) >= -8)\n+       {\n+\t operands[1] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[1]));\n+\t return \\\"subq%.b %1,%0\\\";\n+       }\n+    }\n+#endif\n+  return \\\"add%.b %1,%0\\\";\n+}\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n \t(plus:QI (match_operand:QI 1 \"general_operand\" \"dn,dmn\")\n \t\t (match_dup 0)))]\n   \"\"\n-  \"add%.b %1,%0\")\n+  \"*\n+{\n+#ifndef NO_ADDSUB_Q\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[1]) >= 128)\n+\toperands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       INTVAL (operands[1]) - 256);\n+\n+      if (INTVAL (operands[1]) > 0\n+\t  && INTVAL (operands[1]) <= 8)\n+\treturn \\\"addq%.b %1,%0\\\";\n+      if (INTVAL (operands[1]) < 0 && INTVAL (operands[1]) >= -8)\n+       {\n+\t operands[1] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[1]));\n+\t return \\\"subq%.b %1,%0\\\";\n+       }\n+    }\n+#endif\n+  return \\\"add%.b %1,%0\\\";\n+}\")\n \n (define_expand \"adddf3\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n@@ -2542,11 +2686,7 @@\n   /* The swap insn produces cc's that don't correspond to the result.  */\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifdef SGS_SWAP_W\n-  return \\\"ext%.l %0\\;divs%.w %2,%0\\;swap%.w %0\\\";\n-#else\n   return \\\"ext%.l %0\\;divs%.w %2,%0\\;swap %0\\\";\n-#endif\n #else\n   return \\\"extl %0\\;divs %2,%0\\;swap %0\\\";\n #endif\n@@ -2564,11 +2704,7 @@\n   /* The swap insn produces cc's that don't correspond to the result.  */\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifdef SGS_SWAP_W\n-  return \\\"divs%.w %2,%0\\;swap%.w %0\\\";\n-#else\n   return \\\"divs%.w %2,%0\\;swap %0\\\";\n-#endif\n #else\n   return \\\"divs %2,%0\\;swap %0\\\";\n #endif\n@@ -2584,11 +2720,7 @@\n   /* The swap insn produces cc's that don't correspond to the result.  */\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifdef SGS_SWAP_W\n-  return \\\"divs%.w %2,%0\\;swap%.w %0\\\";\n-#else\n   return \\\"divs%.w %2,%0\\;swap %0\\\";\n-#endif\n #else\n   return \\\"divs %2,%0\\;swap %0\\\";\n #endif\n@@ -2604,11 +2736,7 @@\n   /* The swap insn produces cc's that don't correspond to the result.  */\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifdef SGS_SWAP_W\n-  return \\\"and%.l %#0xFFFF,%0\\;divu%.w %2,%0\\;swap%.w %0\\\";\n-#else\n   return \\\"and%.l %#0xFFFF,%0\\;divu%.w %2,%0\\;swap %0\\\";\n-#endif\n #else\n   return \\\"andl %#0xFFFF,%0\\;divu %2,%0\\;swap %0\\\";\n #endif\n@@ -2626,11 +2754,7 @@\n   /* The swap insn produces cc's that don't correspond to the result.  */\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifdef SGS_SWAP_W\n-  return \\\"divu%.w %2,%0\\;swap%.w %0\\\";\n-#else\n   return \\\"divu%.w %2,%0\\;swap %0\\\";\n-#endif\n #else\n   return \\\"divu %2,%0\\;swap %0\\\";\n #endif\n@@ -2646,11 +2770,7 @@\n   /* The swap insn produces cc's that don't correspond to the result.  */\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifdef SGS_SWAP_W\n-  return \\\"divu%.w %2,%0\\;swap%.w %0\\\";\n-#else\n   return \\\"divu%.w %2,%0\\;swap %0\\\";\n-#endif\n #else\n   return \\\"divu %2,%0\\;swap %0\\\";\n #endif\n@@ -2690,7 +2810,7 @@\n \n ;; Prevent AND from being made with sp.  This doesn't exist in the machine\n ;; and reload will cause inefficient code.  Since sp is a FIXED_REG, we\n-;; can't allocate psuedos into it.\n+;; can't allocate pseudos into it.\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"not_sp_operand\" \"=m,d\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n@@ -3094,23 +3214,33 @@\n ;; arithmetic shift instructions\n ;; We don't need the shift memory by 1 bit instruction\n \n+;; On all 68k models, this makes faster code in a special case.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 16)\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"swap %0\\;clr%.w %0\\\";\n+}\")\n+\n ;; On the 68000, this makes faster code in a special case.\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"(! TARGET_68020 && GET_CODE (operands[2]) == CONST_INT\n-    && INTVAL (operands[2]) >= 16 && INTVAL (operands[2]) <= 24)\"\n+    && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n   \"*\n {\n   CC_STATUS_INIT;\n \n-  if (INTVAL (operands[2]) == 16)\n-    return \\\"swap %0\\;clrw %0\\\";\n-\n   operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 16);\n-  return \\\"asl%.w %2,%0\\;swap %0\\;clrw %0\\\";\n+  return \\\"asl%.w %2,%0\\;swap %0\\;clr%.w %0\\\";\n }\")\n \n (define_insn \"ashlsi3\"\n@@ -3153,19 +3283,25 @@\n   \"\"\n   \"asl%.b %1,%0\")\n \n+;; On all 68k models, this makes faster code in a special case.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 16)\" \n+  \"swap %0\\;ext%.l %0\")\n+\n ;; On the 68000, this makes faster code in a special case.\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"(! TARGET_68020 && GET_CODE (operands[2]) == CONST_INT\n-    && INTVAL (operands[2]) >= 16 && INTVAL (operands[2]) <= 24)\"\n+    && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n   \"*\n {\n-  if (INTVAL (operands[2]) == 16)\n-    return \\\"swap %0\\;ext%.l %0\\\";\n-\n   operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 16);\n   return \\\"swap %0\\;asr%.w %2,%0\\;ext%.l %0\\\";\n }\")\n@@ -3210,23 +3346,33 @@\n \f\n ;; logical shift instructions\n \n+;; On all 68k models, this makes faster code in a special case.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 16)\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"swap %0\\;clr%.w %0\\\";\n+}\")\n+\n ;; On the 68000, this makes faster code in a special case.\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"(! TARGET_68020 && GET_CODE (operands[2]) == CONST_INT\n-    && INTVAL (operands[2]) >= 16 && INTVAL (operands[2]) <= 24)\"\n+    && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n   \"*\n {\n   CC_STATUS_INIT;\n \n-  if (INTVAL (operands[2]) == 16)\n-    return \\\"swap %0\\;clrw %0\\\";\n-\n   operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 16);\n-  return \\\"lsl%.w %2,%0\\;swap %0\\;clrw %0\\\";\n+  return \\\"lsl%.w %2,%0\\;swap %0\\;clr%.w %0\\\";\n }\")\n \n (define_insn \"lshlsi3\"\n@@ -3269,25 +3415,32 @@\n   \"\"\n   \"lsl%.b %1,%0\")\n \n+;; On all 68k models, this makes faster code in a special case.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"(GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 16)\" \n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"clr%.w %0\\;swap %0\\\";\n+}\")\n+\n ;; On the 68000, this makes faster code in a special case.\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"(! TARGET_68020 && GET_CODE (operands[2]) == CONST_INT\n-    && INTVAL (operands[2]) >= 16 && INTVAL (operands[2]) <= 24)\"\n+    && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n   \"*\n {\n-  if (INTVAL (operands[2]) == 16)\n-    {\n-      CC_STATUS_INIT;\n-      return \\\"clrw %0\\;swap %0\\\";\n-    }\n-\n   /* I think lsr%.w sets the CC properly.  */\n   operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 16);\n-  return \\\"clrw %0\\;swap %0\\;lsr%.w %2,%0\\\";\n+  return \\\"clr%.w %0\\;swap %0\\;lsr%.w %2,%0\\\";\n }\")\n \n (define_insn \"lshrsi3\"\n@@ -4262,7 +4415,7 @@\n     }\n #ifdef MOTOROLA\n #ifdef SGS_CMP_ORDER\n-#ifndef NO_ADDSUB_Q\n+#ifdef NO_ADDSUB_Q\n   return \\\"sub%.w %#1,%0\\;cmp%.w %0,%#-1\\;jbne %l1\\\";\n #else\n   return \\\"subq%.w %#1,%0\\;cmp%.w %0,%#-1\\;jbne %l1\\\";\n@@ -4290,7 +4443,7 @@\n {\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifndef NO_ADDSUB_Q\n+#ifdef NO_ADDSUB_Q\n   if (DATA_REG_P (operands[0]))\n     return \\\"dbra %0,%l1\\;clr%.w %0\\;sub%.l %#1,%0\\;jbcc %l1\\\";\n   if (GET_CODE (operands[0]) == MEM)\n@@ -4300,9 +4453,9 @@\n     return \\\"dbra %0,%l1\\;clr%.w %0\\;subq%.l %#1,%0\\;jbcc %l1\\\";\n   if (GET_CODE (operands[0]) == MEM)\n     return \\\"subq%.l %#1,%0\\;jbcc %l1\\\";\n-#endif /* not NO_ADDSUB_Q */\n+#endif /* NO_ADDSUB_Q */\n #ifdef SGS_CMP_ORDER\n-#ifndef NO_ADDSUB_Q\n+#ifdef NO_ADDSUB_Q\n   return \\\"sub.l %#1,%0\\;cmp.l %0,%#-1\\;jbne %l1\\\";\n #else\n   return \\\"subq.l %#1,%0\\;cmp.l %0,%#-1\\;jbne %l1\\\";\n@@ -4312,19 +4465,65 @@\n #endif /* not SGS_CMP_ORDER */\n #else /* not MOTOROLA */\n   if (DATA_REG_P (operands[0]))\n-    return \\\"dbra %0,%l1\\;clrw %0\\;subql %#1,%0\\;jcc %l1\\\";\n+    return \\\"dbra %0,%l1\\;clr%.w %0\\;subql %#1,%0\\;jcc %l1\\\";\n   if (GET_CODE (operands[0]) == MEM)\n     return \\\"subql %#1,%0\\;jcc %l1\\\";\n   return \\\"subql %#1,%0\\;cmpl %#-1,%0\\;jne %l1\\\";\n #endif /* not MOTOROLA */\n }\")\n \n-;; dbra patterns that use REG_NOTES info generated by strength_reduce.\n+;; Two dbra patterns that use REG_NOTES info generated by strength_reduce.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (ge (plus:HI (match_operand:HI 0 \"general_operand\" \"+g\")\n+\t\t       (const_int -1))\n+\t      (const_int 0))\n+\t  (label_ref (match_operand 1 \"\" \"\"))\n+\t  (pc)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"find_reg_note (insn, REG_NONNEG, 0)\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+#ifdef MOTOROLA\n+#ifdef NO_ADDSUB_Q\n+  if (DATA_REG_P (operands[0]))\n+    return \\\"dbra %0,%l1\\\";\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"sub%.w %#1,%0\\;jbcc %l1\\\";\n+#else\n+  if (DATA_REG_P (operands[0]))\n+    return \\\"dbra %0,%l1\\\";\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"subq%.w %#1,%0\\;jbcc %l1\\\";\n+#endif\n+#ifdef SGS_CMP_ORDER\n+#ifdef NO_ADDSUB_Q\n+  return \\\"sub.w %#1,%0\\;cmp.w %0,%#-1\\;jbne %l1\\\";\n+#else\n+  return \\\"subq.w %#1,%0\\;cmp.w %0,%#-1\\;jbne %l1\\\";\n+#endif\n+#else /* not SGS_CMP_ORDER */\n+  return \\\"subq.w %#1,%0\\;cmp.w %#-1,%0\\;jbne %l1\\\";\n+#endif /* not SGS_CMP_ORDER */\n+#else /* not MOTOROLA */\n+  if (DATA_REG_P (operands[0]))\n+    return \\\"dbra %0,%l1\\\";\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"subqw %#1,%0\\;jcc %l1\\\";\n+  return \\\"subqw %#1,%0\\;cmpw %#-1,%0\\;jne %l1\\\";\n+#endif /* not MOTOROLA */\n+}\")\n \n (define_insn \"decrement_and_branch_until_zero\"\n   [(set (pc)\n \t(if_then_else\n-\t  (gt (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t  (ge (plus:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t       (const_int -1))\n \t      (const_int 0))\n \t  (label_ref (match_operand 1 \"\" \"\"))\n \t  (pc)))\n@@ -4336,7 +4535,7 @@\n {\n   CC_STATUS_INIT;\n #ifdef MOTOROLA\n-#ifndef NO_ADDSUB_Q\n+#ifdef NO_ADDSUB_Q\n   if (DATA_REG_P (operands[0]))\n     return \\\"dbra %0,%l1\\;clr%.w %0\\;sub%.l %#1,%0\\;jbcc %l1\\\";\n   if (GET_CODE (operands[0]) == MEM)\n@@ -4348,7 +4547,7 @@\n     return \\\"subq%.l %#1,%0\\;jbcc %l1\\\";\n #endif\n #ifdef SGS_CMP_ORDER\n-#ifndef NO_ADDSUB_Q\n+#ifdef NO_ADDSUB_Q\n   return \\\"sub.l %#1,%0\\;cmp.l %0,%#-1\\;jbne %l1\\\";\n #else\n   return \\\"subq.l %#1,%0\\;cmp.l %0,%#-1\\;jbne %l1\\\";\n@@ -4358,7 +4557,7 @@\n #endif /* not SGS_CMP_ORDER */\n #else /* not MOTOROLA */\n   if (DATA_REG_P (operands[0]))\n-    return \\\"dbra %0,%l1\\;clrw %0\\;subql %#1,%0\\;jcc %l1\\\";\n+    return \\\"dbra %0,%l1\\;clr%.w %0\\;subql %#1,%0\\;jcc %l1\\\";\n   if (GET_CODE (operands[0]) == MEM)\n     return \\\"subql %#1,%0\\;jcc %l1\\\";\n   return \\\"subql %#1,%0\\;cmpl %#-1,%0\\;jne %l1\\\";\n@@ -4476,7 +4675,7 @@\n   return \\\"tstl %0\\\";\n }\")\n \n-;; Used for framless functions which save no regs and allocate no locals.\n+;; Used for frameless functions which save no regs and allocate no locals.\n (define_insn \"return\"\n   [(return)]\n   \"USE_RETURN_INSN\"\n@@ -4626,6 +4825,71 @@\n   output_asm_insn (\\\"subq%.w %#4,%3\\;move%.b %1,%2\\\", xoperands);\n   return \\\"\\\";\n }\")\n+\n+;; dbCC peepholes\n+;;\n+;; Turns\n+;;   loop:\n+;;           [ ... ]\n+;;           jCC label\t\t; abnormal loop termination\n+;;           dbra dN, loop\t; normal loop termination\n+;;\n+;; Into\n+;;   loop:\n+;;           [ ... ]\n+;;           dbCC dN, loop\n+;;           jCC label\n+;;\n+;; Which moves the jCC condition outside the inner loop for free.\n+;; \n+(define_peephole\n+  [(set (pc) (if_then_else (match_operator 3 \"valid_dbcc_comparison_p\"\n+                             [(cc0) (const_int 0)])\n+                           (label_ref (match_operand 2 \"\" \"\"))\n+                           (pc)))\n+   (parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (ge (plus:HI (match_operand:HI 0 \"register_operand\" \"+d\")\n+\t\t         (const_int -1))\n+\t        (const_int 0))\n+\t    (label_ref (match_operand 1 \"\" \"\"))\n+\t    (pc)))\n+     (set (match_dup 0)\n+\t  (plus:HI (match_dup 0)\n+\t\t   (const_int -1)))])]\n+  \"DATA_REG_P (operands[0])\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  output_dbcc_and_branch (operands);\n+  return \\\"\\\";\n+}\")\n+\n+(define_peephole\n+  [(set (pc) (if_then_else (match_operator 3 \"valid_dbcc_comparison_p\"\n+                             [(cc0) (const_int 0)])\n+                           (label_ref (match_operand 2 \"\" \"\"))\n+                           (pc)))\n+   (parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (ge (plus:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n+\t\t         (const_int -1))\n+\t        (const_int 0))\n+\t    (label_ref (match_operand 1 \"\" \"\"))\n+\t    (pc)))\n+     (set (match_dup 0)\n+\t  (plus:SI (match_dup 0)\n+\t\t   (const_int -1)))])]\n+  \"DATA_REG_P (operands[0])\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  output_dbcc_and_branch (operands);\n+  return \\\"\\\";\n+}\")\n+\n \f\n ;; FPA multiply and add.\n (define_insn \"\""}, {"sha": "ec11e2011f13fc193e694e0e2bcfd2733d95e019", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -47,7 +47,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.0.2.1 28 Feb 1992 12:36:54\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.0.2.2 02 Mar 1992 13:30:28\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -218,7 +218,7 @@ emit_move_sequence (operands, mode)\n \t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n-      if (! reload_in_progress)\n+      if (! reload_in_progress && ! reload_completed)\n \t{\n \t  operands[0] = validize_mem (operand0);\n \t  operands[1] = operand1 = force_reg (mode, operand1);\n@@ -231,7 +231,8 @@ emit_move_sequence (operands, mode)\n \tif (GET_CODE (operand1) != CONST_INT\n \t    && GET_CODE (operand1) != CONST_DOUBLE)\n \t  {\n-\t    rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (Pmode);\n+\t    rtx temp = ((reload_in_progress || reload_completed)\n+\t\t\t? operand0 : gen_reg_rtx (Pmode));\n \t    operands[1] = legitimize_address (flag_pic\n \t\t\t\t\t      && symbolic_address_p (operand1),\n \t\t\t\t\t      operand1, temp);\n@@ -696,7 +697,7 @@ output_xor (operands)\n \f\n /* Output a call.  Normally this is just bsr or jsr, but this also deals with\n    accomplishing a branch after the call by incrementing r1.  This requires\n-   that various assembler bugs be accomodated.  The 4.30 DG/UX assembler\n+   that various assembler bugs be accommodated.  The 4.30 DG/UX assembler\n    requires that forward references not occur when computing the difference of\n    two labels.  The [version?] Motorola assembler computes a word difference.\n    No doubt there's more to come!\n@@ -819,7 +820,7 @@ output_short_branch_defs (stream)\n \f\n /* Report errors on floating point, if we are given NaN's, or such.  Leave\n    the number as is, though, since we output the number in hex, and the\n-   assemble won't choak on it.  */\n+   assembler won't choke on it.  */\n \n void\n check_float_value (mode, value)\n@@ -1884,7 +1885,7 @@ m88k_output_epilogue (stream, size)\n      int size;\n {\n   rtx insn = get_last_insn ();\n-#if (MONITOR_GCC & 0x4) /* What are interesting prologue/epiloge values?  */\n+#if (MONITOR_GCC & 0x4) /* What are interesting prologue/epilogue values?  */\n   fprintf (stream, \"; size = %d, m88k_fp_offset = %d, m88k_stack_size = %d\\n\",\n \t   size, m88k_fp_offset, m88k_stack_size);\n #endif\n@@ -2727,7 +2728,7 @@ print_operand (file, x, code)\n       fputs (reg_names[REGNO (x) + 1], file);\n       return;\n \n-    case 'r': /* an immediate 0 should be repesented as `r0' */\n+    case 'r': /* an immediate 0 should be represented as `r0' */\n       if (x == const0_rtx)\n \t{\n \t  fputs (reg_names[0], file);"}, {"sha": "92cda86d1e7f51095f05140d93a85cc13a1ec920", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -119,7 +119,7 @@ extern int target_flags;\n    numbered. This is not true on the ns32k.  */\n #define WORDS_BIG_ENDIAN 0\n \n-/* Number of bits in an addressible storage unit */\n+/* Number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -711,10 +711,8 @@ __transfer_from_trampoline ()\t\t\\\n   asm (\"___trampoline:\");\t\t\\\n   asm (\"movd 16(r2),tos\");\t\t\\\n   asm (\"movd 12(r2),r2\");\t\t\\\n-  asm (\"ret\");\t\t\t\t\\\n+  asm (\"ret 0\");\t\t\t\\\n }\n-\n-\n \f\n /* Addressing modes, and classification of registers for them.  */\n "}, {"sha": "f03a0f6a8d6490431685f7010c6e71c4a63f5ea1", "filename": "gcc/config/ns32k/sequent.h", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fns32k%2Fsequent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fns32k%2Fsequent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fsequent.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -18,10 +18,6 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-/* Two flags to control how addresses are printed in assembler insns.  */\n-#define SEQUENT_ADDRESS_BUG 1\n-#define SEQUENT_BASE_REGS\n-\n #include \"ns32k.h\"\n \n /* This is BSD, so it wants DBX format.  */\n@@ -33,7 +29,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Don't split DBX symbols into continuations.  */\n #define DBX_CONTIN_LENGTH 0\n \n-#define TARGET_DEFAULT 9  /* 32332 with 32081 (guessing) */\n+#define TARGET_DEFAULT 9  /* 32332 with 32081 (guessing).  */\n \n /* Print subsidiary information on the compiler version in use.  */\n #undef TARGET_VERSION\n@@ -51,64 +47,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #undef ASM_OUTPUT_ALIGN_CODE\n \n-/* Assember pseudo-op for shared data segment. */\n+/* Assembler pseudo-op for shared data segment. */\n #define SHARED_SECTION_ASM_OP \".shdata\"\n \n /* Control how stack adjust insns are output.  */\n #define SEQUENT_ADJUST_STACK\n \n-/* %$ means print the prefix for an immediate operand.\n-   On the sequent, no prefix is used for such.  */\n-\n-#undef PRINT_OPERAND\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (CODE == '$') ;\t\t\t\t\t\t\t\\\n-  else if (CODE == '?');\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx xfoo;\t\t\t\t\t\t\t\t\\\n-      xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n-      switch (GET_CODE (xfoo))\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\tcase MEM:\t\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (xfoo, 0)) == REG)\t\t\t\t\\\n-\t    if (REGNO (XEXP (xfoo, 0)) == STACK_POINTER_REGNUM)\t\t\\\n-\t      fprintf (FILE, \"0(0(sp))\");\t\t\t\t\\\n-\t    else fprintf (FILE, \"0(0(%s))\",\t\t\t\t\\\n-\t\t\t  reg_names[REGNO (XEXP (xfoo, 0))]);\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      fprintf (FILE, \"0(\");\t\t\t\t\t\\\n-\t      output_address (xfoo);\t\t\t\t\t\\\n-\t      putc (')', FILE);\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tcase REG:\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"0(%s)\", reg_names[REGNO (xfoo)]);\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tcase PRE_DEC:\t\t\t\t\t\t\t\\\n-\tcase POST_INC:\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"tos\");\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tcase CONST_INT:\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"@%d\", INTVAL (xfoo));\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tdefault:\t\t\t\t\t\t\t\\\n-\t  output_address (xfoo);\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n-    if (GET_MODE (X) == DFmode)\t\t\t\t\t\t\\\n-      { union { double d; int i[2]; } u;\t\t\t\t\\\n-\tu.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-\tfprintf (FILE, \"0d%.20e\", u.d); }\t\t\t\t\\\n-    else { union { double d; int i[2]; } u;\t\t\t\t\\\n-\t   u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X); \\\n-\t   fprintf (FILE, \"0f%.20e\", u.d); }\t\t\t\t\\\n-  else output_addr_const (FILE, X); }\n-\n-#undef PRINT_OPERAND_ADDRESS\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address(FILE, ADDR)\n+#define NO_ABSOLUTE_PREFIX_IF_SYMBOLIC\n+\n+#define IMMEDIATE_PREFIX 0\n+\n+#define SEQUENT_ASM"}, {"sha": "b9f8ad9796df947630eb00ad75de0464e8b12879", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on ROMP.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 1991 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@nyu.edu)\n \n This file is part of GNU CC.\n@@ -613,7 +613,7 @@ float_unary (op, mode)\n \t && GET_MODE (XEXP (op, 0)) == GET_MODE (op);\n }\n \n-/* Return 1 if this is a valid floating-point converstion that can be done\n+/* Return 1 if this is a valid floating-point conversion that can be done\n    as part of an operation by the RT floating-point routines.  */\n \n int\n@@ -929,7 +929,7 @@ print_operand (file, x, code)\n       break;\n \n     case '.':\n-      /* Output nothing.  Used as delimeter in, e.g., \"mc%B1%.3 \" */\n+      /* Output nothing.  Used as delimiter in, e.g., \"mc%B1%.3 \" */\n       break;\n \n     case '#':"}, {"sha": "880372843b70e3a1a9bc706ef7d3656a591f21ac", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -70,7 +70,7 @@ extern int target_flags;\n \n #define TARGET_DEFAULT 3\n \n-/* Define this to change the optimizations peformed by default.\n+/* Define this to change the optimizations performed by default.\n \n    This used to depend on the value of write_symbols,\n    but that is contrary to the general plan for GCC options.  */\n@@ -102,7 +102,7 @@ extern int target_flags;\n    for them.  Might as well be consistent with bits and bytes. */\n #define WORDS_BIG_ENDIAN 1\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -150,9 +150,9 @@ extern int target_flags;\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \f\n /* Standard register usage.  */\n "}, {"sha": "3d3dc1236eea9a05ccc64d2f46d0bbe8fc27de04", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -37,13 +37,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n \n-/* Names of bss and data sections.  These should be unique names for each\n-   compilation unit.  */\n-\n-char *rs6000_bss_section_name;\n-char *rs6000_private_data_section_name;\n-char *rs6000_read_only_section_name;\n-\n /* Set to non-zero by \"fix\" operation to indicate that itrunc and\n    uitrunc must be defined.  */\n \n@@ -591,7 +584,7 @@ secondary_reload_class (class, mode, in)\n    SCC_P is 1 if this is for an scc.  That means that %D will have been\n    used instead of %C, so the bits will be in different places.\n \n-   Return -1 if OP isn't a valid compaison for some reason.  */\n+   Return -1 if OP isn't a valid comparison for some reason.  */\n \n int\n ccr_bit (op, scc_p)\n@@ -835,7 +828,7 @@ print_operand (file, x, code)\n       return;\n \n     case 'U':\n-      /* Print `u' is this has an auto-increment or auto-decremement.  */\n+      /* Print `u' is this has an auto-increment or auto-decrement.  */\n       if (GET_CODE (x) == MEM\n \t  && (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC))\n@@ -1008,8 +1001,8 @@ print_operand (file, x, code)\n       return;\n \n     case 'z':\n-      /* X is a SYMBOL_REF.  Write out the name preceeded by a\n-\t period and without any trailing data in backets.  Used for function\n+      /* X is a SYMBOL_REF.  Write out the name preceded by a\n+\t period and without any trailing data in brackets.  Used for function\n \t names.  */\n       if (GET_CODE (x) != SYMBOL_REF)\n \tabort ();\n@@ -1287,45 +1280,45 @@ output_epilog (file, size)\n       else if (must_push)\n \tfprintf (file, \"\\tai 1,1,%d\\n\", total_size);\n \n-      /* Get the old lr if we saved it.  To speed things up, copy it into\n-\t lr here if we don't have to save more than 2 fp regs.  */\n+      /* Get the old lr if we saved it.  */\n       if (regs_ever_live[65])\n-\t{\n-\t  fprintf (file, \"\\tl 0,8(1)\\n\");\n-\t  if (first_fp_reg >= 62)\n-\t    fprintf (file, \"\\tmtlr 0\\n\");\n-\t}\n+\tfprintf (file, \"\\tl 0,8(1)\\n\");\n \n       /* Get the old cr if we saved it.  */\n       if (must_save_cr ())\n \tfprintf (file, \"\\tl 12,4(1)\\n\");\n \n+      /* Set LR here to try to overlap restores below.  */\n+      if (regs_ever_live[65])\n+\tfprintf (file, \"\\tmtlr 0\\n\");\n+\n       /* Restore gpr's.  */\n       if (first_reg == 31)\n \tfprintf (file, \"\\tl 31,%d(1)\\n\", -4 - (64 - first_fp_reg) * 8);\n       else if (first_reg != 32)\n \tfprintf (file, \"\\tlm %d,%d(1)\\n\", first_reg,\n \t\t - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n \n-      /* Restore fpr's.  */\n+      /* Restore fpr's if we can do it without calling a function.  */\n       if (first_fp_reg == 62)\n \tfprintf (file, \"\\tlfd 30,-16(1)\\n\\tlfd 31,-8(1)\\n\");\n       else if (first_fp_reg == 63)\n \tfprintf (file, \"\\tlfd 31,-8(1)\\n\");\n-      else if (first_fp_reg != 64)\n-\tfprintf (file, \"\\tbl ._restf%d\\n\\tcror 15,15,15\\n\", first_fp_reg - 32);\n-\n-      /* If we used the link register, get it from r0 if we haven't\n-\t already.  */\n-      if (regs_ever_live[65] && first_fp_reg < 62)\n-\tfprintf (file, \"\\tmtlr 0\\n\");\n \n       /* If we saved cr, restore it here.  Just set cr2, cr3, and cr4.  */\n       if (must_save_cr ())\n \tfprintf (file, \"\\tmtcrf 0x38,12\\n\");\n \n-      fprintf (file, \"\\tbr\\n\");\n+      /* If we have to restore more than two FP registers, branch to the\n+\t restore function.  It will return to our caller.  */\n+      if (first_fp_reg < 62)\n+\tfprintf (file, \"\\tb ._restf%d\\n\\tcror 15,15,15\\n\", first_fp_reg - 32);\n+      else\n+\tfprintf (file, \"\\tbr\\n\");\n     }\n+\n+  /* ??? Need to output a traceback table here when -g was given for complete\n+     debugging output.  */\n }\n \f\n /* Output a TOC entry.  We derive the entry name from what is"}, {"sha": "c2803ab757ec15e1d753c58304682525525d2cc1", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -406,17 +406,6 @@ arith_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n }\n \n-/* Return truth value of whether OP can be used as an operand in a two\n-   address arithmetic insn (such as set 123456,%o4) of mode MODE.  */\n-\n-int\n-arith32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) || GET_CODE (op) == CONST_INT);\n-}\n-\n /* Return truth value of whether OP is a register or a CONST_DOUBLE.  */\n \n int\n@@ -634,10 +623,20 @@ legitimize_pic_address (orig, mode, reg, scratch)\n \t  rtx temp_reg = ((reload_in_progress || reload_completed)\n \t\t\t  ? reg : gen_reg_rtx (Pmode));\n \n+\t  /* Must put the SYMBOL_REF inside an UNSPEC here so that cse\n+\t     won't get confused into thinking that these two instructions\n+\t     are loading in the true address of the symbol.  If in the\n+\t     future a PIC rtx exists, that should be used instead.  */\n \t  emit_insn (gen_rtx (SET, VOIDmode, temp_reg,\n-\t\t\t      gen_rtx (HIGH, Pmode, orig)));\n+\t\t\t      gen_rtx (HIGH, Pmode,\n+\t\t\t\t       gen_rtx (UNSPEC, Pmode,\n+\t\t\t\t\t\tgen_rtvec (1, orig),\n+\t\t\t\t\t\t0))));\n \t  emit_insn (gen_rtx (SET, VOIDmode, temp_reg,\n-\t\t\t      gen_rtx (LO_SUM, Pmode, temp_reg, orig)));\n+\t\t\t      gen_rtx (LO_SUM, Pmode, temp_reg,\n+\t\t\t\t       gen_rtx (UNSPEC, Pmode,\n+\t\t\t\t\t\tgen_rtvec (1, orig),\n+\t\t\t\t\t\t0))));\n \t  address = temp_reg;\n \t}\n       else\n@@ -1548,7 +1547,7 @@ output_block_move (operands)\n      here.\n \n      The SUN assembler complains about labels in branch delay slots, so we\n-     do this before outputing the load address, so that there will always\n+     do this before outputting the load address, so that there will always\n      be a harmless insn between the branch here and the next label emitted\n      below.  */\n \n@@ -2048,7 +2047,7 @@ output_cbranch (op, label, reversed, annul, noop)\n   enum machine_mode mode = GET_MODE (XEXP (op, 0));\n   static char labelno[] = \" %lX\";\n \n-  /* ??? FP branches can not be preceeded by another floating point insn.\n+  /* ??? FP branches can not be preceded by another floating point insn.\n      Because there is currently no concept of pre-delay slots, we can fix\n      this only by always emitting a nop before a floating point branch.  */\n \n@@ -2284,22 +2283,29 @@ output_arc_profiler (arcno, insert_after)\n \t       gen_rtx (PLUS, Pmode, profiler_label,\n \t\t\tgen_rtx (CONST_INT, VOIDmode, 4 * arcno)));\n   register rtx profiler_reg = gen_reg_rtx (SImode);\n-  register rtx temp = gen_reg_rtx (Pmode);\n-  register rtx profiler_target = gen_rtx (MEM, SImode,\n-\t\t\t\t\t  gen_rtx (LO_SUM, Pmode, temp,\n-\t\t\t\t\t\t   profiler_target_addr));\n-  /* The insns are emitted from last to first after the insn insert_after.\n-     Emit_insn_after is used because sometimes we want to put the\n-     instrumentation code after the last insn of the function.  */\n-  emit_insn_after (gen_rtx (SET, VOIDmode, profiler_target, profiler_reg),\n-\t\t   insert_after);\n-  emit_insn_after (gen_rtx (SET, VOIDmode, profiler_reg,\n-\t\t\t    gen_rtx (PLUS, SImode, profiler_reg, const1_rtx)),\n-\t\t   insert_after);\n-  emit_insn_after (gen_rtx (SET, VOIDmode, profiler_reg, profiler_target),\n-\t\t   insert_after);\n-  emit_insn_after (gen_rtx (SET, VOIDmode, temp,\n-\t\t\t    gen_rtx (HIGH, Pmode, profiler_target_addr)),\n+  register rtx address_reg = gen_reg_rtx (Pmode);\n+  rtx mem_ref;\n+\n+  insert_after = emit_insn_after (gen_rtx (SET, VOIDmode, address_reg,\n+\t\t\t\t\t   gen_rtx (HIGH, Pmode,\n+\t\t\t\t\t\t    profiler_target_addr)),\n+\t\t\t\t  insert_after);\n+\n+  mem_ref = gen_rtx (MEM, SImode, gen_rtx (LO_SUM, Pmode, address_reg,\n+\t\t\t\t\t   profiler_target_addr));\n+  insert_after = emit_insn_after (gen_rtx (SET, VOIDmode, profiler_reg,\n+\t\t\t\t\t   mem_ref),\n+\t\t\t\t  insert_after);\n+\n+  insert_after = emit_insn_after (gen_rtx (SET, VOIDmode, profiler_reg,\n+\t\t\t\t\t   gen_rtx (PLUS, SImode, profiler_reg,\n+\t\t\t\t\t\t    const1_rtx)),\n+\t\t\t\t  insert_after);\n+\n+  /* This is the same rtx as above, but it is not legal to share this rtx.  */\n+  mem_ref = gen_rtx (MEM, SImode, gen_rtx (LO_SUM, Pmode, address_reg,\n+\t\t\t\t\t   profiler_target_addr));\n+  emit_insn_after (gen_rtx (SET, VOIDmode, mem_ref, profiler_reg),\n \t\t   insert_after);\n }\n \f"}, {"sha": "34510830179862ad29cc1563db087c92e1392161", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -122,7 +122,7 @@ extern int target_flags;\n    matters when cross-compiling.  */\n #define WORDS_BIG_ENDIAN 1\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -171,9 +171,9 @@ extern int target_flags;\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \n /* Things that must be doubleword aligned cannot go in the text section,\n    because the linker fails to align the text section enough!\n@@ -422,9 +422,9 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* This is the order in which to allocate registers\n    normally.  */\n #define REG_ALLOC_ORDER \\\n-{ 8, 9, 10, 11, 12, 13, 2, 15,\t\t\\\n-  16, 17, 18, 19, 20, 21, 22, 23,\t\\\n-  24, 25, 26, 27, 28, 29, 3, 31,\t\\\n+{ 8, 9, 10, 11, 12, 13, 2, 3, \t\t\\\n+  15, 16, 17, 18, 19, 20, 21, 22, \t\\\n+  23, 24, 25, 26, 27, 28, 29, 31,\t\\\n   32, 33, 34, 35, 36, 37, 38, 39,\t\\\n   40, 41, 42, 43, 44, 45, 46, 47,\t\\\n   48, 49, 50, 51, 52, 53, 54, 55,\t\\\n@@ -571,7 +571,7 @@ extern char leaf_reg_backmap[];\n #define REG_PARM_STACK_SPACE(DECL) (NPARM_REGS * UNITS_PER_WORD)\n \n /* Keep the stack pointer constant throughout the function.\n-   This is both an optimization and a neccessity: longjmp\n+   This is both an optimization and a necessity: longjmp\n    doesn't behave itself when the stack pointer moves within\n    the function!  */\n #define ACCUMULATE_OUTGOING_ARGS\n@@ -1187,6 +1187,9 @@ extern struct rtx_def *legitimize_pic_address ();\n    between pointers and any other objects of this machine mode.  */\n #define Pmode SImode\n \n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS\n+\n /* Add any extra modes needed to represent the condition code.\n \n    On the Sparc, we have a \"no-overflow\" mode which is used when an add or"}, {"sha": "20cfca86614a5955b539bf0c820322349c57513d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -56,6 +56,8 @@\n \t\t\t    (match_operand 2 \"arith_double_operand\" \"\"))\n \t\t       (const_int 1) (const_int 3))\n \n+\t (eq_attr \"type\" \"multi\") (const_int 2)\n+\n \t (eq_attr \"type\" \"move,unary\")\n \t (if_then_else (ior (match_operand 1 \"arith_operand\" \"\")\n \t\t\t    (match_operand 1 \"arith_double_operand\" \"\"))\n@@ -451,8 +453,7 @@\n    (clobber (reg:CC 0))]\n   \"\"\n   \"subcc %%g0,%1,%%g0\\;addx %2,-1,%0\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"length\" \"2\")])\n+  [(set_attr \"length\" \"2\")])\n \n ;; We can also do GEU and LTU directly, but these operate after a\n ;; compare.\n@@ -518,8 +519,7 @@\n \t\t (plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n   \"\"\n-  \"addx %1,%2,%0\"\n-  [(set_attr \"type\" \"binary\")])\n+  \"addx %1,%2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -536,17 +536,15 @@\n \t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t  (ltu:SI (reg:CC 0) (const_int 0))))]\n   \"\"\n-  \"subx %1,%2,%0\"\n-  [(set_attr \"type\" \"binary\")])\n+  \"subx %1,%2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t  (plus:SI (ltu:SI (reg:CC 0) (const_int 0))\n \t\t\t   (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n   \"\"\n-  \"subx %1,%2,%0\"\n-  [(set_attr \"type\" \"binary\")])\n+  \"subx %1,%2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -572,7 +570,8 @@\n \t(match_operator:SI 1 \"normal_comp_operator\" [(reg 0) (const_int 0)]))]\n   \"\"\n   \"* return output_scc_insn (operands, insn); \"\n-  [(set_attr \"type\" \"multi\")])\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"3\")])\n \f\n ;; These control RTL generation for conditional jump insns\n \n@@ -734,7 +733,7 @@\n ;; subreg sets.\n \n ;; We cannot combine the similar 'r' and 'f' constraints, because it causes\n-;; problems with register allocation.  Reload might try to put an interger\n+;; problems with register allocation.  Reload might try to put an integer\n ;; in an fp register, or an fp number is an integer register.\n \n (define_insn \"\"\n@@ -751,8 +750,8 @@\n    st %r1,%0\n    st %r1,%0\n    st %r1,[%%fp-4]\\;ld [%%fp-4],%0\"\n-  [(set_attr \"type\" \"move,move,load,load,store,store,misc\")\n-   (set_attr \"length\" \"*,1,*,*,*,*,2\")])\n+  [(set_attr \"type\" \"move,move,load,load,store,store,multi\")\n+   (set_attr \"length\" \"*,1,*,*,*,*,*\")])\n \n ;; Special pic pattern, for loading the address of a label into a register.\n ;; It clobbers o7 because the call puts the return address (i.e. pc value)\n@@ -803,6 +802,16 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"2\")])\n \n+;; For PIC, symbol_refs are put inside unspec so that the optimizer won't\n+;; confuse them with real addresses.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (unspec:SI [(match_operand 1 \"\" \"\")] 0)))]\n+  \"check_pic (1)\"\n+  \"sethi %%hi(%a1),%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n@@ -836,6 +845,18 @@\n   ;; is not an \"arith_operand\".\n   [(set_attr \"length\" \"1\")])\n \n+;; For PIC, symbol_refs are put inside unspec so that the optimizer won't\n+;; confuse them with real addresses.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (unspec:SI [(match_operand:SI 2 \"immediate_operand\" \"in\")] 0)))]\n+  \"\"\n+  \"or %1,%%lo(%a2),%0\"\n+  ;; Need to set length for this arith insn because operand2\n+  ;; is not an \"arith_operand\".\n+  [(set_attr \"length\" \"1\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -944,7 +965,7 @@\n (define_expand \"movstrsi\"\n   [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n \t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n-\t      (use (match_operand:SI 2 \"arith32_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n \t      (clobber (match_dup 0))\n \t      (clobber (match_dup 1))\n@@ -967,7 +988,7 @@\n (define_insn \"\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\n \t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\n-   (use (match_operand:SI 2 \"arith32_operand\" \"rn\"))\n+   (use (match_operand:SI 2 \"nonmemory_operand\" \"rn\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))\n@@ -976,7 +997,8 @@\n    (clobber (reg:SI 1))]\n   \"\"\n   \"* return output_block_move (operands);\"\n-  [(set_attr \"type\" \"multi\")])\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")])\n \f\n ;; Floating point move insns\n \n@@ -1071,7 +1093,7 @@\n     return output_fp_move_double (operands);\n   return output_move_double (operands);\n }\"\n-  [(set_attr \"type\" \"move,store,load,misc,multi,fp,fpload,multi,fpstore\")\n+  [(set_attr \"type\" \"move,store,load,multi,multi,fp,fpload,multi,fpstore\")\n    (set_attr \"length\" \"2,3,3,3,3,2,3,3,3\")])\n \n ;; Floating-point move insns.\n@@ -1099,8 +1121,7 @@\n    ld %1,%0\n    st %r1,%0\n    st %r1,%0\"\n-  [(set_attr \"type\" \"fp,move,multi,fpload,load,fpstore,store\")\n-   (set_attr \"length\" \"*,*,2,*,*,*,*\")])\n+  [(set_attr \"type\" \"fp,move,multi,fpload,load,fpstore,store\")])\n \n (define_insn \"\"\n   [(set (mem:SF (match_operand:SI 0 \"symbolic_operand\" \"i\"))\n@@ -1277,6 +1298,27 @@\n   \"ldsb %1,%0\"\n   [(set_attr \"type\" \"load\")])\n \f\n+;; Special pattern for optimizing bit-field compares.  This is needed\n+;; because combine uses this as a canonical form.\n+\n+(define_insn \"\"\n+  [(set (reg:CC 0)\n+\t(compare:CC\n+\t (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"small_int\" \"n\")\n+\t\t\t  (match_operand:SI 2 \"small_int\" \"n\"))\n+\t (const_int 0)))]\n+  \"INTVAL (operands[2]) > 19\"\n+  \"*\n+{\n+  int len = INTVAL (operands[1]);\n+  int pos = 32 - INTVAL (operands[2]) - len;\n+  unsigned mask = ((1 << len) - 1) << pos;\n+\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, mask);\n+  return \\\"andcc %0,%1,%%g0\\\";\n+}\")\n+\f\n ;; Conversions between float and double.\n \n (define_insn \"extendsfdf2\"\n@@ -1372,7 +1414,7 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+  /* If constant is positive, upper bits zeroed, otherwise unchanged\n    * give the assembler a chance to pick the move instruction. */\n   if (GET_CODE (op2) == CONST_INT)\n     {\n@@ -1430,8 +1472,8 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is postive, upper bits zeroed, otherwise unchanged\n-   * give the assembler a chance to pick the move instruction. */\n+  /* If constant is positive, upper bits zeroed, otherwise unchanged\n+  /* If constant is positive, upper bits zeroed, otherwise unchanged\n   if (GET_CODE (op2) == CONST_INT)\n     {\n       int sign = INTVAL (op2);\n@@ -1498,7 +1540,7 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+  /* If constant is positive, upper bits zeroed, otherwise unchanged\n    * give the assembler a chance to pick the move instruction. */\n   if (GET_CODE (op2) == CONST_INT)\n     {\n@@ -1558,7 +1600,7 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is postive, upper bits zeroed, otherwise unchanged\n+  /* If constant is positive, upper bits zeroed, otherwise unchanged\n    * give the assembler a chance to pick the move instruction. */\n   if (GET_CODE (op2) == CONST_INT)\n     {\n@@ -2004,7 +2046,7 @@\n ;; Unconditional and other jump instructions\n ;; Note that for the Sparc, by setting the annul bit on an unconditional\n ;; branch, the following insn is never executed.  This saves us a nop,\n-;; but requires a debugger which can handle annuled branches.\n+;; but requires a debugger which can handle annulled branches.\n (define_insn \"jump\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n@@ -2263,12 +2305,15 @@\n (define_insn \"\"\n   [(unspec_volatile [(const_int 0)] 0)]\n   \"\"\n-  \"ta 3\")\n+  \"ta 3\"\n+  [(set_attr \"type\" \"misc\")])\n \n (define_insn \"\"\n   [(unspec_volatile [(const_int 0)] 1)]\n   \"\"\n-  \"jmp %%o0+0\\;restore\")\n+  \"jmp %%o0+0\\;restore\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"2\")])\n \n ;(define_insn \"tail_call\" ;; tail call\n ;  [(set (pc) (match_operand 0 \"memory_operand\" \"m\"))]\n@@ -2469,8 +2514,7 @@\n \t\t    (const_int 0)))]\n   \"rtx_equal_p (operands[2], operands[0])\n    || rtx_equal_p (operands[2], operands[1])\"\n-  \"orcc %1,%%g0,%0\"\n-  [(set_attr \"type\" \"move\")])\n+  \"orcc %1,%%g0,%0\")\n \n ;; Do {sign,zero}-extended compares somewhat more efficiently.\n ;; ??? Is this now the Right Way to do this?  Or will SCRATCH\n@@ -2604,7 +2648,8 @@\n \t(match_operand:SF 0 \"register_operand\" \"f\"))\n    (return)]\n   \"! TARGET_EPILOGUE\"\n-  \"ret\\;fmovs %0,%%f0\")\n+  \"ret\\;fmovs %0,%%f0\"\n+  [(set_attr \"type\" \"multi\")])\n \n ;; Now peepholes to go a call followed by a jump.\n \n@@ -2638,8 +2683,7 @@\n \t      (clobber (reg:CC 0))])\n    (set (reg:CC 0) (compare (match_dup 0) (const_int 0)))]\n   \"\"\n-  \"subxcc %r1,0,%0\"\n-  [(set_attr \"type\" \"compare\")])\n+  \"subxcc %r1,0,%0\")\n \n ;;- Local variables:\n ;;- mode:emacs-lisp"}, {"sha": "bf6d347d227912a698bcd9ef1b4d041abe138acb", "filename": "gcc/config/spur/spur.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fspur%2Fspur.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fspur%2Fspur.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -83,7 +83,7 @@ extern int target_flags;\n    since there are no machine instructions for them.  */\n #define WORDS_BIG_ENDIAN 0\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -117,9 +117,9 @@ extern int target_flags;\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 64\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \f\n /* Standard register usage.  */\n "}, {"sha": "f49fa69f03a0a811e847e1a34aeeab87e67775b6", "filename": "gcc/config/svr4.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -117,7 +117,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n #undef MD_STARTFILE_PREFIX\n #define MD_STARTFILE_PREFIX \"/usr/ccs/lib/\"\n \n-/* Provide a LIB_SPEC appropropriate for svr4.  Here we tack on the default\n+/* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default\n    standard C library (unless we are building a shared library) followed by\n    our own magical crtend.o file (see crtstuff.c) which provides part of\n    the support for getting C++ file-scope static object constructed before\n@@ -154,11 +154,12 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n    not being done.  */\n \n #undef\tLINK_SPEC\n-#define LINK_SPEC \"%{z*} %{h*} %{V} %{v:%{!V:-V}} \\\n-\t\t   %{b} %{t} %{Wl,*:%*} \\\n+#define LINK_SPEC \"%{h*} %{V} %{v:%{!V:-V}} \\\n+\t\t   %{b} %{Wl,*:%*} \\\n \t\t   %{static:-dn -Bstatic} \\\n \t\t   %{shared:-G -dy} \\\n \t\t   %{symbolic:-Bsymbolic -G -dy} \\\n+\t\t   %{G:-G} \\\n \t\t   %{YP,*} \\\n \t\t   %{!YP,*:%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \\\n \t\t    %{!p:-Y P,/usr/ccs/lib:/usr/lib}} \\\n@@ -173,7 +174,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n    The SVR4 library routines query the value of `_lib_version' at run\n    to decide how they should behave.  Specifically, they decide (based\n    upon the value of `_lib_version') if they will act in a strictly ANSI\n-   conformant manner or not.\n+   conforming manner or not.\n */\n \n #undef\tSTARTFILE_SPEC\n@@ -186,9 +187,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n \t\t\t   %{traditional:values-Xt.o%s} \\\n \t\t\t   %{!traditional:values-Xa.o%s}}}} crtbegin.o%s\"\n \n-/* Attach a sepcial .ident directive to the end of the file to identify\n+/* Attach a special .ident directive to the end of the file to identify\n    the version of GCC which compiled this code.  The format of the\n-   .ident string is patterened after the ones produced by native svr4\n+   .ident string is patterned after the ones produced by native svr4\n    C compilers.  */\n \n #define ASM_FILE_END(FILE)\t\t\t\t\t\\\n@@ -558,7 +559,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n    has such a limitation, you should define STRING_LIMIT to reflect that\n    limit.  Note that at least some svr4 assemblers have a limit on the\n    actual number of bytes in the double-quoted string, and that they\n-   count each chanacter in an escape sequence as one byte.  Thus, an\n+   count each character in an escape sequence as one byte.  Thus, an\n    escape sequence like \\377 would count as four bytes.\n \n    If your target assembler doesn't support the .string directive, you"}, {"sha": "37176c9ded31b9ebfafe16cf04f4ffdebcd7c5f0", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -29,35 +29,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"output.h\"\n #include \"insn-attr.h\"\n \n-/* Return 1 if the operand is a REG, a SUBREG, or a MEM that is does not\n-   have an index.  This is used when we are using an operand in a different\n-   mode than the hardware expects.  See jlbc/jlbs.\n-\n-   This is nonimmedate_operand with a restriction on the type of MEM.  */\n-\n-int\n-reg_or_nxmem_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (! nonimmediate_operand (op, mode))\n-    return 0;\n-\n-  if (GET_CODE (op) != MEM)\n-    return 1;\n-\n-  GO_IF_NONINDEXED_ADDRESS (XEXP (op, 0), nonidx);\n-\n-  return 0;\n-\n- nonidx:\n-  return 1;\n-}\n \n void\n split_quadword_operands (operands, low, n)\n      rtx *operands, *low;\n-     int n;\n+   This is nonimmediate_operand with a restriction on the type of MEM.  */\n {\n   int i;\n   /* Split operands.  */"}, {"sha": "459eb5592dbd33f53a82d490c83010c71d1068d1", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -93,7 +93,7 @@ extern int target_flags;\n /* This is not true on the vax.  */\n #define WORDS_BIG_ENDIAN 0\n \n-/* Number of bits in an addressible storage unit */\n+/* Number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -133,6 +133,9 @@ extern int target_flags;\n /* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n+\n+/* Let's keep the stack somewhat aligned.  */\n+#define STACK_BOUNDARY 32\n \f\n /* Standard register usage.  */\n \n@@ -877,7 +880,7 @@ gen_rtx (PLUS, Pmode, frame, gen_rtx (CONST_INT, VOIDmode, 12))\n \n /* Check a `double' value for validity for a particular machine mode.  */\n \n-/* note that it is very hard to accidently create a number that fits in a\n+/* note that it is very hard to accidentally create a number that fits in a\n    double but not in a float, since their ranges are almost the same */\n #define CHECK_FLOAT_VALUE(mode, d) \\\n   if ((mode) == SFmode) \\"}, {"sha": "13873bd8d14dd4d69b35601c8029838e1b36eb11", "filename": "gcc/config/vax/vms.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fvax%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fconfig%2Fvax%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvms.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -38,6 +38,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* ??? __GNU__ is probably obsolete; delete it for 2.1.  */\n #define CPP_PREDEFINES \"-Dvax -Dvms -DVMS -D__GNU__ -D__GNUC__=2\"\n \n+/* These match the definitions used in VAXCRTL, the VMS C run-time library */\n+\n+#define SIZE_TYPE \"unsigned int\"\n+#define PTRDIFF_TYPE \"int\"\n+#define WCHAR_TYPE\t\"unsigned int\"\n+\n+/* Use memcpy for structure copying, and so forth.  */\n+#define TARGET_MEM_FUNCTIONS\n+\n /* Strictly speaking, VMS does not use DBX at all, but the interpreter built\n    into gas only speaks straight DBX.  */\n \n@@ -172,7 +181,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define NO_DOLLAR_IN_LABEL\n \n-/* Add a \"const\" section.  This is viewed by the assember as being nearly\n+/* Add a \"const\" section.  This is viewed by the assembler as being nearly\n    the same as the \"data\" section, with the only difference being that a\n    flag is set for variables declared while in the const section.  This\n    flag is used to determine whether or not the read/write bit should be"}, {"sha": "be4b3f52fcad8d1fea4e9d0b11f41ced20dfb792", "filename": "gcc/ginclude/va-pyr.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fginclude%2Fva-pyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fginclude%2Fva-pyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-pyr.h?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -9,7 +9,7 @@\n  * C compiler.\n  * As such, it depends strongly on the Pyramid conventions for\n  * parameter passing.ct and indepenent implementation. \n- * These (somewhat bizarre) paramter-passing conventions are described\n+ * These (somewhat bizarre) parameter-passing conventions are described\n  * in the ``OSx Operating System Porting Guide''.\n  * \n  * A quick summary is useful:\n@@ -89,9 +89,12 @@ typedef __va_buf va_list;\n    &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,\t\t\t\\\n         __va0,__va1,__va2,__va3,__va4,__va5,\t\t\t\t\\\n \t__va6,__va7,__va8,__va9,__va10,__va11})\n- \n-  \n-\t \n+\n+\n+/* Avoid errors if compiling GCC v2 with GCC v1.  */\n+#if __GNUC__ == 1\n+#define __extension__\n+#endif\n \n #define va_arg(_AP, _MODE)\t\\\n __extension__\t\t\t\t\t\t\t\t\\"}, {"sha": "4d436931e8105b5a8e20c9b95a2ad549a57ddaaf", "filename": "gcc/sched.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -144,7 +144,7 @@ static int *insn_priority;\n #define DONE_PRIORITY_P(INSN) (INSN_PRIORITY (INSN) < 0)\n #define LOW_PRIORITY_P(INSN) ((INSN_PRIORITY (INSN) & 0x7f000000) == 0)\n \n-/* Vector indexed by INSN_UID giving number of insns refering to this insn.  */\n+/* Vector indexed by INSN_UID giving number of insns referring to this insn.  */\n static int *insn_ref_count;\n #define INSN_REF_COUNT(INSN) (insn_ref_count[INSN_UID (INSN)])\n \n@@ -2324,13 +2324,20 @@ schedule_block (b, file)\n       && GET_CODE (PATTERN (tail)) == USE\n       && next_nonnote_insn (tail) == 0)\n     {\n-      /* If this was the only insn in the block, then there are no insns to\n-\t schedule.  */\n-      if (head == tail)\n-\treturn;\n+      /* Don't try to reorder any USE insns at the end of a function.\n+\t They must be last to ensure proper register allocation.\n+\t Exclude them all from scheduling.  */\n+      do\n+\t{\n+\t  /* If we are down to one USE insn, then there are no insns to\n+\t     schedule.  */\n+\t  if (head == tail)\n+\t    return;\n \n-      /* We don't try to reorder the USE at the end of a function.  */\n-      tail = prev_nonnote_insn (tail);\n+\t  tail = prev_nonnote_insn (tail);\n+\t}\n+      while (GET_CODE (tail) == INSN\n+\t     && GET_CODE (PATTERN (tail)) == USE);\n \n #if 0\n       /* This short-cut does not work.  See comment above.  */\n@@ -3944,7 +3951,10 @@ schedule_insns (dump_file)\n \t\t  fprintf (dump_file,\n \t\t\t   \";; register %d now crosses calls\\n\", regno);\n \t      }\n-\t    reg_live_length[regno] = sched_reg_live_length[regno];\n+\t    /* Negative values are special; don't overwrite the current\n+\t       reg_live_length value if it is negative.  */\n+\t    if (reg_live_length[regno] >= 0)\n+\t      reg_live_length[regno] = sched_reg_live_length[regno];\n \t    reg_n_calls_crossed[regno] = sched_reg_n_calls_crossed[regno];\n \t  }\n     }"}, {"sha": "6a066008bd8bdd9be2f4985b12dd663746c93400", "filename": "gcc/stmt.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -1150,14 +1150,10 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n       for (tail = clobbers; tail; tail = TREE_CHAIN (tail), i++)\n \t{\n-\t  int j;\n \t  char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n+\t  int j = decode_reg_name (regname);\n \n-\t  for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\t    if (!strcmp (regname, reg_names[j]))\n-\t      break;\n-\n-\t  if (j == FIRST_PSEUDO_REGISTER)\n+\t  if (j < 0)\n \t    {\n \t      error (\"unknown register name `%s' in `asm'\", regname);\n \t      return;\n@@ -1270,6 +1266,7 @@ warn_if_unused_value (exp)\n \n     case NOP_EXPR:\n     case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n       /* Don't warn about values cast to void.  */\n       if (TREE_TYPE (exp) == void_type_node)\n \treturn 0;\n@@ -1885,7 +1882,7 @@ expand_end_loop ()\n \t  register rtx newstart_label = gen_label_rtx ();\n \t  register rtx start_move = start_label;\n \n-\t  /* If the start label is preceeded by a NOTE_INSN_LOOP_CONT note,\n+\t  /* If the start label is preceded by a NOTE_INSN_LOOP_CONT note,\n \t     then we want to move this note also.  */\n \t  if (GET_CODE (PREV_INSN (start_move)) == NOTE\n \t      && (NOTE_LINE_NUMBER (PREV_INSN (start_move))\n@@ -2498,7 +2495,10 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \t  if (arg_pointer_save_area == 0)\n \t    arg_pointer_save_area\n \t      = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n-\t  emit_move_insn (virtual_incoming_args_rtx, arg_pointer_save_area);\n+\t  emit_move_insn (virtual_incoming_args_rtx,\n+\t\t\t  /* We need a pseudo here,\n+\t\t\t     or else instantiate_virtual_regs_1 complains.  */\n+\t\t\t  copy_to_reg (arg_pointer_save_area));\n \t}\n #endif\n \n@@ -2779,6 +2779,8 @@ void\n expand_decl_init (decl)\n      tree decl;\n {\n+  int was_used = TREE_USED (decl);\n+\n   if (TREE_STATIC (decl))\n     return;\n \n@@ -2800,6 +2802,9 @@ expand_decl_init (decl)\n       emit_queue ();\n     }\n \n+  /* Don't let the initialization count as \"using\" the variable.  */\n+  TREE_USED (decl) = was_used;\n+\n   /* Free any temporaries we made while initializing the decl.  */\n   free_temp_slots ();\n }\n@@ -3546,11 +3551,13 @@ expand_end_case (orig_index)\n #endif\n \t       || (unsigned) (TREE_INT_CST_LOW (range)) > 10 * count\n \t       || TREE_CODE (index_expr) == INTEGER_CST\n-\t       /* This will reduce to a constant.  */\n+\t       /* These will reduce to a constant.  */\n \t       || (TREE_CODE (index_expr) == CALL_EXPR\n \t\t   && TREE_CODE (TREE_OPERAND (index_expr, 0)) == ADDR_EXPR\n \t\t   && TREE_CODE (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == FUNCTION_DECL\n-\t\t   && DECL_FUNCTION_CODE (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == BUILT_IN_CLASSIFY_TYPE))\n+\t\t   && DECL_FUNCTION_CODE (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == BUILT_IN_CLASSIFY_TYPE)\n+\t       || (TREE_CODE (index_expr) == COMPOUND_EXPR\n+\t\t   && TREE_CODE (TREE_OPERAND (index_expr, 1)) == INTEGER_CST))\n \t{\n \t  index = expand_expr (index_expr, 0, VOIDmode, 0);\n \n@@ -3668,14 +3675,16 @@ expand_end_case (orig_index)\n \t  if (! win && HAVE_tablejump)\n \t    {\n \t      index_expr = convert (thiscase->data.case_stmt.nominal_type,\n-\t\t\t\t    build (MINUS_EXPR, TREE_TYPE (index_expr),\n-\t\t\t\t\t   index_expr, minval));\n+\t\t\t\t    fold (build (MINUS_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (index_expr),\n+\t\t\t\t\t\t index_expr, minval)));\n \t      index = expand_expr (index_expr, 0, VOIDmode, 0);\n \t      emit_queue ();\n \t      index = protect_from_queue (index, 0);\n \t      do_pending_stack_adjust ();\n \n \t      do_tablejump (index,\n+\t\t\t    TYPE_MODE (thiscase->data.case_stmt.nominal_type),\n \t\t\t    gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t     TREE_INT_CST_LOW (range)),\n \t\t\t    table_label, default_label);"}, {"sha": "9485332f538337d67f98a4cfcba10362fc7610b2", "filename": "gcc/tree.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -2168,7 +2168,7 @@ build_type_variant (type, constp, volatilep)\n   constp = !!constp;\n   volatilep = !!volatilep;\n \n-  /* If not generating auxilliary info, search the chain of variants to see\n+  /* If not generating auxiliary info, search the chain of variants to see\n      if there is already one there just like the one we need to have.  If so,\n      use that existing one.\n \n@@ -2199,6 +2199,31 @@ build_type_variant (type, constp, volatilep)\n   current_obstack = ambient_obstack;\n   return t;\n }\n+\n+/* Create a new variant of TYPE, equivalent but distinct.\n+   This is so the caller can modify it.  */\n+\n+tree\n+build_type_copy (type)\n+     tree type;\n+{\n+  register tree t, m = TYPE_MAIN_VARIANT (type);\n+  register struct obstack *ambient_obstack = current_obstack;\n+\n+  current_obstack\n+    = TREE_PERMANENT (type) ? &permanent_obstack : saveable_obstack;\n+\n+  t = copy_node (type);\n+  TYPE_POINTER_TO (t) = 0;\n+  TYPE_REFERENCE_TO (t) = 0;\n+\n+  /* Add this type to the chain of variants of TYPE.  */\n+  TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n+  TYPE_NEXT_VARIANT (m) = t;\n+\n+  current_obstack = ambient_obstack;\n+  return t;\n+}\n \f\n /* Hashing of types so that we don't make duplicates.\n    The entry point is `type_hash_canon'.  */"}, {"sha": "577f47c9515f74ff539007da09361cc4f6664b24", "filename": "gcc/unroll.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -324,12 +324,12 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n       else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n \t{\n #ifdef HAVE_cc0\n-\t  /* The immediately preceeding insn is a compare which must be\n+\t  /* The immediately preceding insn is a compare which must be\n \t     deleted.  */\n \t  delete_insn (last_loop_insn);\n \t  delete_insn (PREV_INSN (last_loop_insn));\n #else\n-\t  /* The immediately preceeding insn may not be the compare, so don't\n+\t  /* The immediately preceding insn may not be the compare, so don't\n \t     delete it.  */\n \t  delete_insn (last_loop_insn);\n #endif\n@@ -883,11 +883,11 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n \t    {\n #ifdef HAVE_cc0\n-\t      /* The immediately preceeding insn is a compare which we do not\n+\t      /* The immediately preceding insn is a compare which we do not\n \t\t want to copy.  */\n \t      copy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n #else\n-\t      /* The immediately preceeding insn may not be a compare, so we\n+\t      /* The immediately preceding insn may not be a compare, so we\n \t\t must copy it.  */\n \t      copy_end = PREV_INSN (last_loop_insn);\n #endif\n@@ -937,12 +937,12 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  else\n \t    {\n #ifdef HAVE_cc0\n-\t      /* The immediately preceeding insn is a compare which we do not\n+\t      /* The immediately preceding insn is a compare which we do not\n \t\t want to copy.  */\n \t      insert_before = PREV_INSN (last_loop_insn);\n \t      copy_end = PREV_INSN (insert_before);\n #else\n-\t      /* The immediately preceeding insn may not be a compare, so we\n+\t      /* The immediately preceding insn may not be a compare, so we\n \t\t must copy it.  */\n \t      insert_before = last_loop_insn;\n \t      copy_end = PREV_INSN (last_loop_insn);\n@@ -2053,7 +2053,7 @@ iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Iteration var not an interger.\\n\");\n+\t\t \"Loop unrolling: Iteration var not an integer.\\n\");\n       return;\n     }\n   else if (reg_iv_type[REGNO (iteration_var)] == BASIC_INDUCT)\n@@ -2240,7 +2240,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t    {\n \t      /* If the initial value of the biv is itself (i.e. it is too\n \t\t complicated for strength_reduce to compute), or is a hard\n-\t\t register, then we must create a new psuedo reg to hold the\n+\t\t register, then we must create a new pseudo reg to hold the\n \t\t initial value of the biv.  */\n \n \t      if (GET_CODE (bl->initial_value) == REG\n@@ -2733,6 +2733,11 @@ final_biv_value (bl, loop_start, loop_end)\n {\n   rtx increment, tem;\n \n+  /* ??? This only works for MODE_INT biv's.  Reject all others for now.  */\n+\n+  if (GET_MODE_CLASS (bl->biv->mode) != MODE_INT)\n+    return 0;\n+\n   /* The final value for reversed bivs must be calculated differently than\n       for ordinary bivs.  In this case, there is already an insn after the\n      loop which sets this biv's final value (if necessary), and there are"}, {"sha": "12afb28a6b792134afe646cd37ddac79baa2fc73", "filename": "gcc/varasm.c", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b4ac57ab2925e9ccedcc0ea72cd7ce55bbcd6def", "patch": "@@ -38,6 +38,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"obstack.h\"\n \n+#ifdef XCOFF_DEBUGGING_INFO\n+#include \"xcoff.h\"\n+#endif\n+\n #ifndef ASM_STABS_OP\n #define ASM_STABS_OP \".stabs\"\n #endif\n@@ -189,10 +193,25 @@ make_function_rtl (decl)\n   function_defined = 1;\n }\n \n+/* Given NAME, a putative register name, discard any customary prefixes.  */\n+\n+static char *\n+strip_reg_name (name)\n+     char *name;\n+{\n+#ifdef REGISTER_PREFIX\n+  if (!strncmp (name, REGISTER_PREFIX, strlen (REGISTER_PREFIX)))\n+    name += strlen (REGISTER_PREFIX);\n+#endif\n+  if (name[0] == '%' || name[0] == '#')\n+    name++;\n+  return name;\n+}\n+\n /* Decode an `asm' spec for a declaration as a register name.\n    Return the register number, or -1 if nothing specified,\n-   or -2 if the name is not a register.  Accept an exact spelling,\n-   a decimal number, or an optional prefix of '%' or '#'.  */\n+   or -2 if the name is not a register.  Accept an exact spelling or\n+   a decimal number.  Prefixes such as % are optional.  */\n \n int\n decode_reg_name (asmspec)\n@@ -202,6 +221,9 @@ decode_reg_name (asmspec)\n     {\n       int i;\n \n+      /* Get rid of confusing prefixes.  */\n+      asmspec = strip_reg_name (asmspec);\n+\t\n       /* Allow a decimal number as a \"register name\".  */\n       for (i = strlen (asmspec) - 1; i >= 0; i--)\n \tif (! (asmspec[i] >= '0' && asmspec[i] <= '9'))\n@@ -216,14 +238,10 @@ decode_reg_name (asmspec)\n \t}\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (reg_names[i][0] && ! strcmp (asmspec, reg_names[i]))\n+\tif (reg_names[i][0]\n+\t    && ! strcmp (asmspec, strip_reg_name (reg_names[i])))\n \t  return i;\n \n-      if (asmspec[0] == '%' || asmspec[0] == '#')\n-\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  if (reg_names[i][0] && ! strcmp (asmspec + 1, reg_names[i]))\n-\t    return i;\n-\n #ifdef ADDITIONAL_REGISTER_NAMES\n       {\n \tstatic struct { char *name; int number; } table[]\n@@ -232,11 +250,6 @@ decode_reg_name (asmspec)\n \tfor (i = 0; i < sizeof (table) / sizeof (table[0]); i++)\n \t  if (! strcmp (asmspec, table[i].name))\n \t    return table[i].number;\n-\n-\tif (asmspec[0] == '%' || asmspec[0] == '#')\n-\t  for (i = 0; i < sizeof (table) / sizeof (table[0]); i++)\n-\t    if (! strcmp (asmspec + 1, table[i].name))\n-\t      return table[i].number;\n       }\n #endif /* ADDITIONAL_REGISTER_NAMES */\n \n@@ -657,9 +670,10 @@ assemble_variable (decl, top_level, at_end)\n \treturn;\n       TREE_ASM_WRITTEN (decl) = 1;\n \n-#ifdef DBX_DEBUGGING_INFO\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n       /* File-scope global variables are output here.  */\n-      if (write_symbols == DBX_DEBUG && top_level)\n+      if ((write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n+\t  && top_level)\n \tdbxout_symbol (decl, 0);\n #endif\n #ifdef SDB_DEBUGGING_INFO\n@@ -746,7 +760,7 @@ assemble_variable (decl, top_level, at_end)\n      Error message was already made.  */\n \n   if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n-    return;\n+    goto finish;\n \n   app_disable ();\n \n@@ -757,7 +771,7 @@ assemble_variable (decl, top_level, at_end)\n   if (TREE_INT_CST_HIGH (size_tree) != 0)\n     {\n       error_with_decl (decl, \"size of variable `%s' is too large\");\n-      return;\n+      goto finish;\n     }\n \n   name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n@@ -816,7 +830,7 @@ assemble_variable (decl, top_level, at_end)\n \t    ASM_OUTPUT_LOCAL (asm_out_file, name, size, rounded);\n #endif\n \t}\n-      return;\n+      goto finish;\n     }\n \n   /* Handle initialized definitions.  */\n@@ -907,6 +921,22 @@ assemble_variable (decl, top_level, at_end)\n   else\n     /* Leave space for it.  */\n     assemble_zeros (int_size_in_bytes (TREE_TYPE (decl)));\n+\n+ finish:\n+#ifdef XCOFF_DEBUGGING_INFO\n+  /* Unfortunately, the IBM assembler cannot handle stabx before the actual\n+     declaration.  When something like \".stabx  \"aa:S-2\",aa,133,0\" is emitted \n+     and `aa' hasn't been output yet, the assembler generates a stab entry with\n+     a value of zero, in addition to creating an unnecessary external entry\n+     for `aa'.  Hence, we must pospone dbxout_symbol to here at the end.  */\n+\n+  /* File-scope global variables are output here.  */\n+  if (write_symbols == XCOFF_DEBUG && top_level)\n+    dbxout_symbol (decl, 0);\n+#else\n+  /* There must be a statement after a label.  */\n+  ;\n+#endif\n }\n \n /* Output something to declare an external symbol to the assembler.\n@@ -2703,7 +2733,7 @@ output_constructor (exp, size)\n \t     separate bytes, and combine each byte with previous or\n \t     following bit-fields.  */\n \n-\t  /* next_offset is the offset n fbits from the begining of\n+\t  /* next_offset is the offset n fbits from the beginning of\n \t     the structure to the next bit of this element to be processed.\n \t     end_offset is the offset of the first bit past the end of\n \t     this element.  */"}]}