{"sha": "bf9d5852a03e2386f84edf6c7396288f2c04305c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY5ZDU4NTJhMDNlMjM4NmY4NGVkZjZjNzM5NjI4OGYyYzA0MzA1Yw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-14T05:43:13Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-14T05:43:13Z"}, "message": "cpphash.h (struct cpp_buffer): Remove saved_line_base.\n\n\t* cpphash.h (struct cpp_buffer): Remove saved_line_base.\n\t* cpptrad.c: Update comments.\n\t(skip_whitespace, copy_comment): Take a new parameter.\n\t(skip_escaped_newlines): Don't duplicate escaped newline test.\n\t(copy_comment): Different location for CUR, decide here how\n\tto copy / replace the comment.\n\t(skip_whitespace): Copy whitespace.\n\t(_cpp_overlay_buffer, _cpp_remove_overlay): Don't play with line_base.\n\t(scan_out_logical_line): Let copy comment handle keeping or\n\treplacing comments.\n\t(scan_parameters, _cpp_create_trad_definition): Update.\n\nFrom-SVN: r54605", "tree": {"sha": "04cbdfa09f14486aae7d7a354d10fe7ccbe07768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04cbdfa09f14486aae7d7a354d10fe7ccbe07768"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf9d5852a03e2386f84edf6c7396288f2c04305c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf9d5852a03e2386f84edf6c7396288f2c04305c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf9d5852a03e2386f84edf6c7396288f2c04305c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf9d5852a03e2386f84edf6c7396288f2c04305c/comments", "author": null, "committer": null, "parents": [{"sha": "57292ec30e534d43e7030eea5c774a75d4e63a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57292ec30e534d43e7030eea5c774a75d4e63a48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57292ec30e534d43e7030eea5c774a75d4e63a48"}], "stats": {"total": 178, "additions": 111, "deletions": 67}, "files": [{"sha": "c86ac9a69176b441a2b3e85c57b8a74f76b20669", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9d5852a03e2386f84edf6c7396288f2c04305c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9d5852a03e2386f84edf6c7396288f2c04305c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf9d5852a03e2386f84edf6c7396288f2c04305c", "patch": "@@ -1,3 +1,17 @@\n+2002-06-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct cpp_buffer): Remove saved_line_base.\n+\t* cpptrad.c: Update comments.\n+\t(skip_whitespace, copy_comment): Take a new parameter.\n+\t(skip_escaped_newlines): Don't duplicate escaped newline test.\n+\t(copy_comment): Different location for CUR, decide here how\n+\tto copy / replace the comment.\n+\t(skip_whitespace): Copy whitespace.\n+\t(_cpp_overlay_buffer, _cpp_remove_overlay): Don't play with line_base.\n+\t(scan_out_logical_line): Let copy comment handle keeping or\n+\treplacing comments.\n+\t(scan_parameters, _cpp_create_trad_definition): Update.\n+\n 2002-06-13  Alan Lehotsky  <apl@alum.mit.edu>\n \n \t* reload.c (get_secondary_mem,find_reloads_address,"}, {"sha": "60340d941e5e874bc0e856fd9b7bd3a2740534e7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9d5852a03e2386f84edf6c7396288f2c04305c/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9d5852a03e2386f84edf6c7396288f2c04305c/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=bf9d5852a03e2386f84edf6c7396288f2c04305c", "patch": "@@ -298,7 +298,7 @@ struct cpp_buffer\n   struct search_path dir;\n \n   /* Used for buffer overlays by cpptrad.c.  */\n-  const uchar *saved_cur, *saved_rlimit, *saved_line_base;\n+  const uchar *saved_cur, *saved_rlimit;\n };\n \n /* A cpp_reader encapsulates the \"state\" of a pre-processor run."}, {"sha": "69b7e178d469bb55a0c98f1c3ae8d0aa51448309", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 96, "deletions": 66, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9d5852a03e2386f84edf6c7396288f2c04305c/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9d5852a03e2386f84edf6c7396288f2c04305c/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=bf9d5852a03e2386f84edf6c7396288f2c04305c", "patch": "@@ -63,16 +63,16 @@ struct fun_macro\n   unsigned int argc;\n };\n \n-/* Lexing TODO: Maybe handle -CC and space in escaped newlines.  Stop\n-   cpplex.c from recognizing comments and directives during its lexing\n-   pass.  Get rid of line_base usage - seems pointless?  */\n+/* Lexing TODO: Maybe handle space in escaped newlines.  Stop cpplex.c\n+   from recognizing comments and directives during its lexing pass.  */\n \n static const uchar *handle_newline PARAMS ((cpp_reader *, const uchar *));\n static const uchar *skip_escaped_newlines PARAMS ((cpp_reader *,\n \t\t\t\t\t\t   const uchar *));\n-static const uchar *skip_whitespace PARAMS ((cpp_reader *, const uchar *));\n+static const uchar *skip_whitespace PARAMS ((cpp_reader *, const uchar *,\n+\t\t\t\t\t     int));\n static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n-static const uchar *copy_comment PARAMS ((cpp_reader *, const uchar *));\n+static const uchar *copy_comment PARAMS ((cpp_reader *, const uchar *, int));\n static void scan_out_logical_line PARAMS ((cpp_reader *pfile, cpp_macro *));\n static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n@@ -95,7 +95,7 @@ check_output_buffer (pfile, n)\n      size_t n;\n {\n   /* We might need two bytes to terminate an unterminated comment, and\n-     one more to terminate with a NUL.  */\n+     one more to terminate the line with a NUL.  */\n   n += 2 + 1;\n \n   if (n > (size_t) (pfile->out.limit - pfile->out.cur))\n@@ -111,8 +111,10 @@ check_output_buffer (pfile, n)\n }\n \n /* To be called whenever a newline character is encountered in the\n-   input file, at CUR.  Handles DOS, MAC and Unix ends of line, and\n-   returns the character after the newline sequence.  */\n+   input file, at CUR.  Handles DOS, Mac and Unix ends of line, and\n+   increments pfile->line.\n+\n+   Returns a pointer the character after the newline sequence.  */\n static const uchar *\n handle_newline (pfile, cur)\n      cpp_reader *pfile;\n@@ -121,58 +123,61 @@ handle_newline (pfile, cur)\n   pfile->line++;\n   if (cur[0] + cur[1] == '\\r' + '\\n')\n     cur++;\n-  pfile->buffer->line_base = cur + 1;\n   return cur + 1;\n }\n \n /* CUR points to any character in the buffer, not necessarily a\n    backslash.  Advances CUR until all escaped newlines are skipped,\n-   and returns the new position.  */\n+   and returns the new position.\n+\n+   Warns if a file buffer ends in an escaped newline.  */\n static const uchar *\n skip_escaped_newlines (pfile, cur)\n      cpp_reader *pfile;\n      const uchar *cur;\n {\n-  if (*cur == '\\\\' && is_vspace (cur[1]))\n-    {\n-      do\n-\tcur = handle_newline (pfile, cur + 1);\n-      while (*cur == '\\\\' && is_vspace (cur[1]));\n+  const uchar *orig_cur = cur;\n \n-      if (cur == RLIMIT (pfile->context))\n-\tcpp_error (pfile, DL_PEDWARN,\n-\t\t   \"backslash-newline at end of file\");\n-    }\n+  while (*cur == '\\\\' && is_vspace (cur[1]))\n+    cur = handle_newline (pfile, cur + 1);\n+\n+  if (cur != orig_cur && cur == RLIMIT (pfile->context) && pfile->buffer->inc)\n+    cpp_error (pfile, DL_PEDWARN, \"backslash-newline at end of file\");\n \n   return cur;\n }\n \n-/* CUR points to the character after the asterisk introducing a\n-   comment in the input buffer.  The remaining comment is copied to\n-   the buffer pointed to by pfile->out.cur, which must be of\n-   sufficient size, and pfile->out.cur is updated.  Unterminated\n-   comments are diagnosed, and correctly terminated in the output.\n+/* CUR points to the asterisk introducing a comment in the input\n+   buffer.  IN_DEFINE is true if we are in the replacement text\n+   of a macro.\n+\n+   The asterisk and following comment is copied to the buffer pointed\n+   to by pfile->out.cur, which must be of sufficient size.\n+   Unterminated comments are diagnosed, and correctly terminated in\n+   the output.  pfile->out.cur is updated depending upon IN_DEFINE,\n+   -C, -CC and pfile->state.in_directive.\n \n    Returns a pointer to the first character after the comment in the\n    input buffer.  */\n static const uchar *\n-copy_comment (pfile, cur)\n+copy_comment (pfile, cur, in_define)\n      cpp_reader *pfile;\n      const uchar *cur;\n+     int in_define;\n {\n   unsigned int from_line = pfile->line;\n   const uchar *limit = RLIMIT (pfile->context);\n   uchar *out = pfile->out.cur;\n \n-  while (cur < limit)\n+  do\n     {\n       unsigned int c = *cur++;\n       *out++ = c;\n \n       if (c == '/')\n \t{\n \t  /* An immediate slash does not terminate the comment.  */\n-\t  if (out[-2] == '*' && out > pfile->out.cur + 1)\n+\t  if (out[-2] == '*' && out - 2 > pfile->out.cur)\n \t    goto done;\n \n \t  if (*cur == '*' && cur[1] != '/'\n@@ -190,55 +195,91 @@ copy_comment (pfile, cur)\n \t    out[-1] = '\\n';\n \t}\n     }\n+  while (cur < limit);\n \n   cpp_error_with_line (pfile, DL_ERROR, from_line, 0, \"unterminated comment\");\n   *out++ = '*';\n   *out++ = '/';\n \n  done:\n-  pfile->out.cur = out;\n+  /* Comments in directives become spaces so that tokens are properly\n+     separated when the ISO preprocessor re-lexes the line.  The\n+     exception is #define.  */\n+  if (pfile->state.in_directive)\n+    {\n+      if (in_define)\n+\t{\n+\t  if (CPP_OPTION (pfile, discard_comments_in_macro_exp))\n+\t    pfile->out.cur--;\n+\t  else\n+\t    pfile->out.cur = out;\n+\t}\n+      else\n+\tpfile->out.cur[-1] = ' ';\n+    }\n+  else if (CPP_OPTION (pfile, discard_comments))\n+    pfile->out.cur--;\n+  else\n+    pfile->out.cur = out;\n+\n   return cur;\n }\n \n-/* Skip any horizontal whitespace and comments beginning at CUR,\n-   returning the following character.  */\n+/* CUR points to any character in the input buffer.  Skips over all\n+   contiguous horizontal white space and NULs, including comments if\n+   SKIP_COMMENTS, until reaching the first non-horizontal-whitespace\n+   character or the end of the current context.  Escaped newlines are\n+   removed.\n+\n+   The whitespace is copied verbatim to the output buffer, except that\n+   comments are handled as described in copy_comment().\n+   pfile->out.cur is updated.\n+\n+   Returns a pointer to the first character after the whitespace in\n+   the input buffer.  */\n static const uchar *\n-skip_whitespace (pfile, cur)\n+skip_whitespace (pfile, cur, skip_comments)\n      cpp_reader *pfile;\n      const uchar *cur;\n+     int skip_comments;\n {\n-  const uchar *tmp;\n+  uchar *out = pfile->out.cur;\n \n   for (;;)\n     {\n-      while (is_nvspace (*cur) && *cur != 0)\n-\tcur++;\n+      unsigned int c = *cur++;\n+      *out++ = c;\n \n-      if (*cur == '\\0' && cur != RLIMIT (pfile->context))\n+      if (is_nvspace (c) && c)\n \tcontinue;\n \n-      if (*cur == '\\\\')\n-\t{\n-\t  tmp = cur;\n-\t  cur = skip_escaped_newlines (pfile, cur);\n-\t  if (tmp != cur)\n-\t    continue;\n-\t}\n+      if (!c && cur != RLIMIT (pfile->context))\n+\tcontinue;\n \n-      if (*cur == '/')\n+      if (*cur == '/' && skip_comments)\n \t{\n-\t  tmp = skip_escaped_newlines (pfile, cur + 1);\n+\t  const uchar *tmp = skip_escaped_newlines (pfile, cur);\n \t  if (*tmp == '*')\n \t    {\n-\t      cur = copy_comment (pfile, tmp + 1);\n+\t      pfile->out.cur = out;\n+\t      cur = copy_comment (pfile, tmp, false /* in_define */);\n+\t      out = pfile->out.cur;\n \t      continue;\n \t    }\n \t}\n \n+      out--;\n+      if (c == '\\\\' && is_vspace (*cur))\n+\t{\n+\t  cur = skip_escaped_newlines (pfile, cur);\n+\t  continue;\n+\t}\n+\n       break;\n     }\n \n-  return cur;\n+  pfile->out.cur = out;\n+  return cur - 1;\n }\n \n /* Lexes and outputs an identifier starting at CUR, which is assumed\n@@ -283,10 +324,8 @@ _cpp_overlay_buffer (pfile, start, len)\n \n   buffer->saved_cur = buffer->cur;\n   buffer->saved_rlimit = buffer->rlimit;\n-  buffer->saved_line_base = buffer->line_base;\n \n   buffer->cur = start;\n-  buffer->line_base = start;\n   buffer->rlimit = start + len;\n \n   pfile->saved_line = pfile->line;\n@@ -301,7 +340,6 @@ _cpp_remove_overlay (pfile)\n \n   buffer->cur = buffer->saved_cur;\n   buffer->rlimit = buffer->saved_rlimit;\n-  buffer->line_base = buffer->saved_line_base;\n \n   pfile->line = pfile->saved_line;\n }\n@@ -474,20 +512,9 @@ scan_out_logical_line (pfile, macro)\n \t      cur = skip_escaped_newlines (pfile, cur);\n \t      if (*cur == '*')\n \t\t{\n-\t\t  *out = '*';\n-\t\t  pfile->out.cur = out + 1;\n-\t\t  cur = copy_comment (pfile, cur + 1);\n-\n-\t\t  /* Comments in directives become spaces so that\n-\t\t     tokens are properly separated when the ISO\n-\t\t     preprocessor re-lexes the line.  The exception\n-\t\t     is #define.  */\n-\t\t  if (pfile->state.in_directive && !macro)\n-\t\t    out[-1] = ' ';\n-\t\t  else if (CPP_OPTION (pfile, discard_comments))\n-\t\t    out -= 1;\n-\t\t  else\n-\t\t    out = pfile->out.cur;\n+\t\t  pfile->out.cur = out;\n+\t\t  cur = copy_comment (pfile, cur, macro != 0);\n+\t\t  out = pfile->out.cur;\n \t\t}\n \t    }\n \t  break;\n@@ -763,14 +790,15 @@ scan_parameters (pfile, macro)\n \n   for (;;)\n     {\n-      cur = skip_whitespace (pfile, cur);\n+      cur = skip_whitespace (pfile, cur, true /* skip_comments */);\n \n       if (is_idstart (*cur))\n \t{\n \t  ok = false;\n \t  if (_cpp_save_parameter (pfile, macro, lex_identifier (pfile, cur)))\n \t    break;\n-\t  cur = skip_whitespace (pfile, CUR (pfile->context));\n+\t  cur = skip_whitespace (pfile, CUR (pfile->context),\n+\t\t\t\t true /* skip_comments */);\n \t  if (*cur == ',')\n \t    {\n \t      cur++;\n@@ -871,7 +899,9 @@ _cpp_create_trad_definition (pfile, macro)\n     }\n \n   /* Skip leading whitespace in the replacement text.  */\n-  CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n+  CUR (pfile->context)\n+    = skip_whitespace (pfile, CUR (pfile->context),\n+\t\t       CPP_OPTION (pfile, discard_comments_in_macro_exp));\n \n   pfile->state.prevent_expansion++;\n   scan_out_logical_line (pfile, macro);"}]}