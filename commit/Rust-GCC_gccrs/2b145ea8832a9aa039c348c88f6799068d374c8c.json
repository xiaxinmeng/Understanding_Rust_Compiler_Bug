{"sha": "2b145ea8832a9aa039c348c88f6799068d374c8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxNDVlYTg4MzJhOWFhMDM5YzM0OGM4OGY2Nzk5MDY4ZDM3NGM4Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-11-11T00:31:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-11-11T00:31:34Z"}, "message": "(global_const_equiv_map_size): New variable.\n\n(expand_inline_function): Set it.\n(expand_inline_function, copy_rtx_and_substitute, try_constants):\nNever access const_equiv_map without checking for out-of-range.\n(mark_stores): Likewise.\n\nFrom-SVN: r6061", "tree": {"sha": "1a1d4a2248db87aacfac3ab68271a4346adb8c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a1d4a2248db87aacfac3ab68271a4346adb8c2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b145ea8832a9aa039c348c88f6799068d374c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b145ea8832a9aa039c348c88f6799068d374c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b145ea8832a9aa039c348c88f6799068d374c8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b145ea8832a9aa039c348c88f6799068d374c8c/comments", "author": null, "committer": null, "parents": [{"sha": "e26f388ad2e5acdfbe8e362d6a6bde680efdb9bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e26f388ad2e5acdfbe8e362d6a6bde680efdb9bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e26f388ad2e5acdfbe8e362d6a6bde680efdb9bf"}], "stats": {"total": 53, "additions": 35, "deletions": 18}, "files": [{"sha": "762cbb3fd51bc97324ca9fad08d7c98cf913b15e", "filename": "gcc/integrate.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b145ea8832a9aa039c348c88f6799068d374c8c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b145ea8832a9aa039c348c88f6799068d374c8c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=2b145ea8832a9aa039c348c88f6799068d374c8c", "patch": "@@ -1105,6 +1105,7 @@ copy_for_inline (orig)\n    is used properly in the presence of recursion.  */\n \n rtx *global_const_equiv_map;\n+int global_const_equiv_map_size;\n \f\n #define FIXED_BASE_PLUS_P(X) \\\n   (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n@@ -1376,7 +1377,8 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t  if (GET_CODE (copy) != REG)\n \t    {\n \t      temp = copy_addr_to_reg (copy);\n-\t      if (CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n+\t      if ((CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n+\t\t  && REGNO (temp) < map->const_equiv_map_size)\n \t\t{\n \t\t  map->const_equiv_map[REGNO (temp)] = copy;\n \t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n@@ -1413,7 +1415,8 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t    {\n \t      temp = copy_to_mode_reg (GET_MODE (loc), copy);\n \t      REG_USERVAR_P (temp) = REG_USERVAR_P (loc);\n-\t      if (CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n+\t      if ((CONSTANT_P (copy) || FIXED_BASE_PLUS_P (copy))\n+\t\t  && REGNO (temp) < map->const_equiv_map_size)\n \t\t{\n \t\t  map->const_equiv_map[REGNO (temp)] = copy;\n \t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n@@ -1447,7 +1450,8 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t    {\n \t      temp = copy_to_mode_reg (GET_MODE (locreal), copyreal);\n \t      REG_USERVAR_P (temp) = REG_USERVAR_P (locreal);\n-\t      if (CONSTANT_P (copyreal) || FIXED_BASE_PLUS_P (copyreal))\n+\t      if ((CONSTANT_P (copyreal) || FIXED_BASE_PLUS_P (copyreal))\n+\t\t  && REGNO (temp) < map->const_equiv_map_size)\n \t\t{\n \t\t  map->const_equiv_map[REGNO (temp)] = copyreal;\n \t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n@@ -1464,7 +1468,8 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t    {\n \t      temp = copy_to_mode_reg (GET_MODE (locimag), copyimag);\n \t      REG_USERVAR_P (temp) = REG_USERVAR_P (locimag);\n-\t      if (CONSTANT_P (copyimag) || FIXED_BASE_PLUS_P (copyimag))\n+\t      if ((CONSTANT_P (copyimag) || FIXED_BASE_PLUS_P (copyimag))\n+\t\t  && REGNO (temp) < map->const_equiv_map_size)\n \t\t{\n \t\t  map->const_equiv_map[REGNO (temp)] = copyimag;\n \t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n@@ -1537,10 +1542,11 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t{\n \t  temp = force_reg (Pmode, structure_value_addr);\n \t  map->reg_map[REGNO (XEXP (loc, 0))] = temp;\n-\t  if (CONSTANT_P (structure_value_addr)\n-\t      || (GET_CODE (structure_value_addr) == PLUS\n-\t\t  && XEXP (structure_value_addr, 0) == virtual_stack_vars_rtx\n-\t\t  && GET_CODE (XEXP (structure_value_addr, 1)) == CONST_INT))\n+\t  if ((CONSTANT_P (structure_value_addr)\n+\t       || (GET_CODE (structure_value_addr) == PLUS\n+\t\t   && XEXP (structure_value_addr, 0) == virtual_stack_vars_rtx\n+\t\t   && GET_CODE (XEXP (structure_value_addr, 1)) == CONST_INT))\n+\t      && REGNO (temp) < map->const_equiv_map_size)\n \t    {\n \t      map->const_equiv_map[REGNO (temp)] = structure_value_addr;\n \t      map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n@@ -1608,6 +1614,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n   /* Save a copy of the location of const_equiv_map for mark_stores, called\n      via note_stores.  */\n   global_const_equiv_map = map->const_equiv_map;\n+  global_const_equiv_map_size = map->const_equiv_map_size;\n \n   /* Now copy the insns one by one.  Do this in two passes, first the insns and\n      then their REG_NOTES, just like save_for_inline.  */\n@@ -2013,8 +2020,12 @@ copy_rtx_and_substitute (orig, map)\n #endif\n \t      map->reg_map[regno] = temp\n \t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n-\t      map->const_equiv_map[REGNO (temp)] = loc;\n-\t      map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\n+\t      if (REGNO (temp) < map->const_equiv_map_size)\n+\t\t{\n+\t\t  map->const_equiv_map[REGNO (temp)] = loc;\n+\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\t\t}\n \n \t      seq = gen_sequence ();\n \t      end_sequence ();\n@@ -2039,8 +2050,12 @@ copy_rtx_and_substitute (orig, map)\n #endif\n \t      map->reg_map[regno] = temp\n \t\t= force_reg (Pmode, force_operand (loc, NULL_RTX));\n-\t      map->const_equiv_map[REGNO (temp)] = loc;\n-\t      map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\n+\t      if (REGNO (temp) < map->const_equiv_map_size)\n+\t\t{\n+\t\t  map->const_equiv_map[REGNO (temp)] = loc;\n+\t\t  map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n+\t\t}\n \n \t      seq = gen_sequence ();\n \t      end_sequence ();\n@@ -2372,11 +2387,12 @@ try_constants (insn, map)\n \t{\n \t  int regno = REGNO (map->equiv_sets[i].dest);\n \n-\t  if (map->const_equiv_map[regno] == 0\n-\t      /* Following clause is a hack to make case work where GNU C++\n-\t\t reassigns a variable to make cse work right.  */\n-\t      || ! rtx_equal_p (map->const_equiv_map[regno],\n-\t\t\t\tmap->equiv_sets[i].equiv))\n+\t  if (regno < map->const_equiv_map_size\n+\t      && (map->const_equiv_map[regno] == 0\n+\t\t  /* Following clause is a hack to make case work where GNU C++\n+\t\t     reassigns a variable to make cse work right.  */\n+\t\t  || ! rtx_equal_p (map->const_equiv_map[regno],\n+\t\t\t\t    map->equiv_sets[i].equiv)))\n \t    {\n \t      map->const_equiv_map[regno] = map->equiv_sets[i].equiv;\n \t      map->const_age_map[regno] = map->const_age;\n@@ -2689,7 +2705,8 @@ mark_stores (dest, x)\n       int i;\n \n       for (i = regno; i <= last_reg; i++)\n-\tglobal_const_equiv_map[i] = 0;\n+\tif (i < global_const_equiv_map_size)\n+\t  global_const_equiv_map[i] = 0;\n     }\n }\n \f"}]}