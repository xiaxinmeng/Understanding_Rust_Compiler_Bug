{"sha": "5aca4c41f72573edb4c22736ac46ff3abf7d625a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFjYTRjNDFmNzI1NzNlZGI0YzIyNzM2YWM0NmZmM2FiZjdkNjI1YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-05-24T17:21:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-05-24T17:21:52Z"}, "message": "re PR libgcj/27729 (Field, Method and Constructor need isSynthetic() implemetation)\n\ngcc/java:\n\tPR libgcj/27729:\n\t* jcf.h (ACC_INVISIBLE): Changed value.\nlibjava:\n\tPR libgcj/27729:\n\t* java/lang/reflect/natField.cc (getAddr): Added parens.\n\t* java/lang/reflect/natConstructor.cc (getModifiersInternal):\n\tRenamed.  Don't mask flags.\n\t* java/lang/reflect/Constructor.java (CONSTRUCTOR_MODIFIERS): New\n\tconstant.\n\t(getModifiersInternal): Renamed.\n\t(getModifiers): Rewrote.\n\t(isSynthetic, isVarArgs): New methods.\n\t(hashCode): Rewrote.\n\t(addTypeParameters, toGenericString): New methods.\n\t(getTypeParameters): Rewrote.\n\t(getSignature): New method.\n\t(getGenericParameterTypes, getGenericExceptionTypes): Likewise.\n\t* java/lang/reflect/natMethod.cc (getModifiersInternal):\n\tRenamed.  Don't mask flags.\n\t* java/lang/reflect/natField.cc (getModifiersInternal): Renamed.\n\tDon't mask flags.\n\t* java/lang/reflect/Modifier.java (BRIDGE, VARARGS, SYNTHETIC,\n\tENUM): New constants.\n\t(INVISIBLE): Changed value.\n\t* java/lang/reflect/Method.java: Mostly merged with Classpath.\n\t(getModifiersInternal): Renamed.\n\t(getModifiers): Rewrote.\n\t(isBridge, isSynthetic, isVarArgs): New methods.\n\t(toGenericString): Likewise.\n\t(getTypeParameters): Likewise.\n\t(getSignature): Likewise.\n\t(getGenericExceptionTypes, getGenericParameterTypes,\n\tgetGenericReturnType): Likewise.\n\t(METHOD_MODIFIERS): New constant.\n\t* java/lang/reflect/Field.java: Mostly merged with Classpath.\n\tAdded javadoc everywhere.\n\t(getModifiersInternal): Renamed.\n\t(getModifiers, isSynthetic, isEnumConstant): Rewrote.\n\t(toGenericString): New method.\n\t(getGenericType, getSignature): Likewise.\n\t(FIELD_MODIFIERS): New constant.\n\nFrom-SVN: r114046", "tree": {"sha": "146a4086fddb5d1c805267e25f1a64634a5ae1a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/146a4086fddb5d1c805267e25f1a64634a5ae1a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aca4c41f72573edb4c22736ac46ff3abf7d625a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aca4c41f72573edb4c22736ac46ff3abf7d625a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aca4c41f72573edb4c22736ac46ff3abf7d625a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aca4c41f72573edb4c22736ac46ff3abf7d625a/comments", "author": null, "committer": null, "parents": [{"sha": "f32f60c997d57ba70a977804cdfb07068557033f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32f60c997d57ba70a977804cdfb07068557033f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32f60c997d57ba70a977804cdfb07068557033f"}], "stats": {"total": 1231, "additions": 1068, "deletions": 163}, "files": [{"sha": "8f2af57bebcb8bf3e0c08b02ee524ab73640d87f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,3 +1,8 @@\n+2006-05-24  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/27729:\n+\t* jcf.h (ACC_INVISIBLE): Changed value.\n+\n 2006-05-24  Andrew Haley  <aph@redhat.com>\n \n \tPR java/27754"}, {"sha": "9c6bc8e16099c46e9b6c5cd5c7bdf00c2e5c3041", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,5 +1,5 @@\n /* Utility macros to read Java(TM) .class files and byte codes.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -231,8 +231,8 @@ typedef struct JCF GTY(()) {\n #define ACC_ABSTRACT 0x0400\n #define ACC_STRICT 0x0800\n /* \"Invisible\" refers to Miranda methods inserted into an abstract\n-   #class.  It is also used in the runtime.  */\n-#define ACC_INVISIBLE 0x1000\n+   class.  It is also used in the runtime.  */\n+#define ACC_INVISIBLE 0x8000\n \n #define ACC_VISIBILITY (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)\n "}, {"sha": "4643064a6fcb62f9edc95296188eeb0f68811a74", "filename": "libjava/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,3 +1,44 @@\n+2006-05-24  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/27729:\n+\t* java/lang/reflect/natField.cc (getAddr): Added parens.\n+\t* java/lang/reflect/natConstructor.cc (getModifiersInternal):\n+\tRenamed.  Don't mask flags.\n+\t* java/lang/reflect/Constructor.java (CONSTRUCTOR_MODIFIERS): New\n+\tconstant.\n+\t(getModifiersInternal): Renamed.\n+\t(getModifiers): Rewrote.\n+\t(isSynthetic, isVarArgs): New methods.\n+\t(hashCode): Rewrote.\n+\t(addTypeParameters, toGenericString): New methods.\n+\t(getTypeParameters): Rewrote.\n+\t(getSignature): New method.\n+\t(getGenericParameterTypes, getGenericExceptionTypes): Likewise.\n+\t* java/lang/reflect/natMethod.cc (getModifiersInternal):\n+\tRenamed.  Don't mask flags.\n+\t* java/lang/reflect/natField.cc (getModifiersInternal): Renamed.\n+\tDon't mask flags.\n+\t* java/lang/reflect/Modifier.java (BRIDGE, VARARGS, SYNTHETIC,\n+\tENUM): New constants.\n+\t(INVISIBLE): Changed value.\n+\t* java/lang/reflect/Method.java: Mostly merged with Classpath.\n+\t(getModifiersInternal): Renamed.\n+\t(getModifiers): Rewrote.\n+\t(isBridge, isSynthetic, isVarArgs): New methods.\n+\t(toGenericString): Likewise.\n+\t(getTypeParameters): Likewise.\n+\t(getSignature): Likewise.\n+\t(getGenericExceptionTypes, getGenericParameterTypes,\n+\tgetGenericReturnType): Likewise.\n+\t(METHOD_MODIFIERS): New constant.\n+\t* java/lang/reflect/Field.java: Mostly merged with Classpath.\n+\tAdded javadoc everywhere.\n+\t(getModifiersInternal): Renamed.\n+\t(getModifiers, isSynthetic, isEnumConstant): Rewrote.\n+\t(toGenericString): New method.\n+\t(getGenericType, getSignature): Likewise.\n+\t(FIELD_MODIFIERS): New constant.\n+\n 2006-05-24  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/27731:"}, {"sha": "68b2d3985cf7e2cd24e30f807111dafe81209ed2", "filename": "libjava/java/lang/reflect/Constructor.java", "status": "modified", "additions": 180, "deletions": 24, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,15 +1,46 @@\n-// Constructor.java - Represents a constructor for a class.\n+/* java.lang.reflect.Constructor - reflection of Java constructors\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n package java.lang.reflect;\n \n+import gnu.java.lang.reflect.MethodSignatureParser;\n+\n /**\n  * The Constructor class represents a constructor of a class. It also allows\n  * dynamic creation of an object, via reflection. Invocation on Constructor\n@@ -37,8 +68,8 @@\n  * @author Tom Tromey <tromey@redhat.com>\n  * @see Member\n  * @see Class\n- * @see java.lang.Class#getConstructor(Object[])\n- * @see java.lang.Class#getDeclaredConstructor(Object[])\n+ * @see java.lang.Class#getConstructor(Class[])\n+ * @see java.lang.Class#getDeclaredConstructor(Class[])\n  * @see java.lang.Class#getConstructors()\n  * @see java.lang.Class#getDeclaredConstructors()\n  * @since 1.1\n@@ -47,6 +78,9 @@\n public final class Constructor extends AccessibleObject\n   implements Member, GenericDeclaration\n {\n+  private static final int CONSTRUCTOR_MODIFIERS\n+    = Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC;\n+\n   /**\n    * This class is uninstantiable except from native code.\n    */\n@@ -58,7 +92,7 @@ private Constructor ()\n    * Gets the class that declared this constructor.\n    * @return the class that declared this member\n    */\n-  public Class getDeclaringClass ()\n+  public Class getDeclaringClass()\n   {\n     return declaringClass;\n   }\n@@ -68,11 +102,18 @@ public Class getDeclaringClass ()\n    * it was declared in).\n    * @return the name of this constructor\n    */\n-  public String getName ()\n+  public String getName()\n   {\n     return declaringClass.getName();\n   }\n \n+  /**\n+   * Return the raw modifiers for this constructor.  In particular\n+   * this will include the synthetic and varargs bits.\n+   * @return the constructor's modifiers\n+   */\n+  private native int getModifiersInternal();\n+\n   /**\n    * Gets the modifiers this constructor uses.  Use the <code>Modifier</code>\n    * class to interpret the values. A constructor can only have a subset of the\n@@ -81,7 +122,31 @@ public String getName ()\n    * @return an integer representing the modifiers to this Member\n    * @see Modifier\n    */\n-  public native int getModifiers ();\n+  public int getModifiers ()\n+  {\n+    return getModifiersInternal() & CONSTRUCTOR_MODIFIERS;\n+  }\n+\n+  /**\n+   * Return true if this constructor is synthetic, false otherwise.\n+   * A synthetic member is one which is created by the compiler,\n+   * and which does not appear in the user's source code.\n+   * @since 1.5\n+   */\n+  public boolean isSynthetic()\n+  {\n+    return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;\n+  }\n+\n+  /**\n+   * Return true if this is a varargs constructor, that is if\n+   * the constructor takes a variable number of arguments.\n+   * @since 1.5\n+   */\n+  public boolean isVarArgs()\n+  {\n+    return (getModifiersInternal() & Modifier.VARARGS) != 0;\n+  }\n \n   /**\n    * Get the parameter list for this constructor, in declaration order. If the\n@@ -127,14 +192,14 @@ public boolean equals (Object obj)\n   }\n \n   /**\n-   * Get the hash code for the Constructor.\n+   * Get the hash code for the Constructor. The Constructor hash code is the\n+   * hash code of the declaring class's name.\n    *\n    * @return the hash code for the object\n    */\n   public int hashCode ()\n   {\n-    // FIXME.\n-    return getName().hashCode() + declaringClass.getName().hashCode();\n+    return declaringClass.getName().hashCode();\n   }\n \n   /**\n@@ -147,7 +212,7 @@ public int hashCode ()\n    *\n    * @return the String representation of the Constructor\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     if (parameter_types == null)\n       getType ();\n@@ -170,6 +235,45 @@ public String toString ()\n     return b.toString();\n   }\n \n+  /* FIXME[GENERICS]: Add X extends GenericDeclaration and TypeVariable<X> */\n+  static void addTypeParameters(StringBuilder sb, TypeVariable[] typeArgs)\n+  {\n+    if (typeArgs.length == 0)\n+      return;\n+    sb.append('<');\n+    for (int i = 0; i < typeArgs.length; ++i)\n+      {\n+        if (i > 0)\n+          sb.append(',');\n+        sb.append(typeArgs[i]);\n+      }\n+    sb.append(\"> \");\n+  }\n+\n+  public String toGenericString()\n+  {\n+    StringBuilder sb = new StringBuilder(128);\n+    Modifier.toString(getModifiers(), sb).append(' ');\n+    addTypeParameters(sb, getTypeParameters());\n+    sb.append(getDeclaringClass().getName()).append('(');\n+    Type[] types = getGenericParameterTypes();\n+    if (types.length > 0)\n+      {\n+        sb.append(types[0]);\n+        for (int i = 1; i < types.length; ++i)\n+          sb.append(',').append(types[i]);\n+      }\n+    sb.append(')');\n+    types = getGenericExceptionTypes();\n+    if (types.length > 0)\n+      {\n+        sb.append(\" throws \").append(types[0]);\n+        for (int i = 1; i < types.length; i++)\n+          sb.append(',').append(types[i]);\n+      }\n+    return sb.toString();\n+  }\n+\n   /**\n    * Create a new instance by invoking the constructor. Arguments are\n    * automatically unwrapped and widened, if needed.<p>\n@@ -204,26 +308,78 @@ public native Object newInstance (Object[] args)\n     throws InstantiationException, IllegalAccessException,\n     IllegalArgumentException, InvocationTargetException;\n \n-  // FIXME - Write a real implementation\n-  public boolean isSynthetic() { return false; }\n-\n   /**\n    * Returns an array of <code>TypeVariable</code> objects that represents\n    * the type variables declared by this constructor, in declaration order.\n-   * An array of size zero is returned if this class has no type\n+   * An array of size zero is returned if this constructor has no type\n    * variables.\n    *\n-   * @return the type variables associated with this class.\n+   * @return the type variables associated with this constructor.\n    * @throws GenericSignatureFormatError if the generic signature does\n    *         not conform to the format specified in the Virtual Machine\n    *         specification, version 3.\n    * @since 1.5\n    */\n-  /* FIXME[GENERICS]: Should be TypeVariable<Method>[] */\n+  /* FIXME[GENERICS]: Add <Constructor<T>> */\n   public TypeVariable[] getTypeParameters()\n   {\n-    // FIXME - write a real implementation\n-    return new TypeVariable[0];\n+    String sig = getSignature();\n+    if (sig == null)\n+      return new TypeVariable[0];\n+    MethodSignatureParser p = new MethodSignatureParser(this, sig);\n+    return p.getTypeParameters();\n+  }\n+\n+  /**\n+   * Return the String in the Signature attribute for this constructor. If there\n+   * is no Signature attribute, return null.\n+   */\n+  private String getSignature()\n+  {\n+    // FIXME: libgcj doesn't record this information yet.\n+    return null;\n+  }\n+\n+  /**\n+   * Returns an array of <code>Type</code> objects that represents\n+   * the exception types declared by this constructor, in declaration order.\n+   * An array of size zero is returned if this constructor declares no\n+   * exceptions.\n+   *\n+   * @return the exception types declared by this constructor. \n+   * @throws GenericSignatureFormatError if the generic signature does\n+   *         not conform to the format specified in the Virtual Machine\n+   *         specification, version 3.\n+   * @since 1.5\n+   */\n+  public Type[] getGenericExceptionTypes()\n+  {\n+    String sig = getSignature();\n+    if (sig == null)\n+      return getExceptionTypes();\n+    MethodSignatureParser p = new MethodSignatureParser(this, sig);\n+    return p.getGenericExceptionTypes();\n+  }\n+\n+  /**\n+   * Returns an array of <code>Type</code> objects that represents\n+   * the parameter list for this constructor, in declaration order.\n+   * An array of size zero is returned if this constructor takes no\n+   * parameters.\n+   *\n+   * @return a list of the types of the constructor's parameters\n+   * @throws GenericSignatureFormatError if the generic signature does\n+   *         not conform to the format specified in the Virtual Machine\n+   *         specification, version 3.\n+   * @since 1.5\n+   */\n+  public Type[] getGenericParameterTypes()\n+  {\n+    String sig = getSignature();\n+    if (sig == null)\n+      return getParameterTypes();\n+    MethodSignatureParser p = new MethodSignatureParser(this, sig);\n+    return p.getGenericParameterTypes();\n   }\n \n   // Update cached values from method descriptor in class."}, {"sha": "134ff132ecf9481c4678c9d720318532b869d091", "filename": "libjava/java/lang/reflect/Field.java", "status": "modified", "additions": 619, "deletions": 88, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FField.java?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,23 +1,85 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n+/* java.lang.reflect.Field - reflection of Java fields\n+   Copyright (C) 1998, 2001, 2005, 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.lang.reflect;\n \n+import gnu.java.lang.ClassHelper;\n+\n+import gnu.java.lang.reflect.FieldSignatureParser;\n+\n /**\n+ * The Field class represents a member variable of a class. It also allows\n+ * dynamic access to a member, via reflection. This works for both\n+ * static and instance fields. Operations on Field objects know how to\n+ * do widening conversions, but throw {@link IllegalArgumentException} if\n+ * a narrowing conversion would be necessary. You can query for information\n+ * on this Field regardless of location, but get and set access may be limited\n+ * by Java language access controls. If you can't do it in the compiler, you\n+ * can't normally do it here either.<p>\n+ *\n+ * <B>Note:</B> This class returns and accepts types as Classes, even\n+ * primitive types; there are Class types defined that represent each\n+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,\n+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,\n+ * byte.class</code>, etc.  These are not to be confused with the\n+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are\n+ * real classes.<p>\n+ *\n+ * Also note that this is not a serializable class.  It is entirely feasible\n+ * to make it serializable using the Externalizable interface, but this is\n+ * on Sun, not me.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  * @author Per Bothner <bothner@cygnus.com>\n- * @date September 1998;  February 1999.\n+ * @see Member\n+ * @see Class\n+ * @see Class#getField(String)\n+ * @see Class#getDeclaredField(String)\n+ * @see Class#getFields()\n+ * @see Class#getDeclaredFields()\n+ * @since 1.1\n+ * @status updated to 1.4\n  */\n-\n-public final class Field extends AccessibleObject implements Member\n+public final class Field\n+  extends AccessibleObject implements Member\n {\n   private Class declaringClass;\n-\n-  // This is filled in by getName.\n   private String name;\n \n   // Offset in bytes from the start of declaringClass's fields array.\n@@ -26,12 +88,87 @@ public final class Field extends AccessibleObject implements Member\n   // The Class (or primitive TYPE) of this field.\n   private Class type;\n \n+  private static final int FIELD_MODIFIERS\n+    = Modifier.FINAL | Modifier.PRIVATE | Modifier.PROTECTED\n+      | Modifier.PUBLIC | Modifier.STATIC | Modifier.TRANSIENT\n+      | Modifier.VOLATILE;\n+\n   // This is instantiated by Class sometimes, but it uses C++ and\n   // avoids the Java protection check.\n   Field ()\n   {\n   }\n \n+  /**\n+   * Gets the class that declared this field, or the class where this field\n+   * is a non-inherited member.\n+   * @return the class that declared this member\n+   */\n+  public Class getDeclaringClass()\n+  {\n+    return declaringClass;\n+  }\n+\n+  /**\n+   * Gets the name of this field.\n+   * @return the name of this field\n+   */\n+  public native String getName();\n+\n+  /**\n+   * Return the raw modifiers for this field.\n+   * @return the field's modifiers\n+   */\n+  private native int getModifiersInternal();\n+\n+  /**\n+   * Gets the modifiers this field uses.  Use the <code>Modifier</code>\n+   * class to interpret the values.  A field can only have a subset of the\n+   * following modifiers: public, private, protected, static, final,\n+   * transient, and volatile.\n+   *\n+   * @return an integer representing the modifiers to this Member\n+   * @see Modifier\n+   */\n+  public int getModifiers()\n+  {\n+    return getModifiersInternal() & FIELD_MODIFIERS;\n+  }\n+\n+  /**\n+   * Return true if this field is synthetic, false otherwise.\n+   * @since 1.5\n+   */\n+  public boolean isSynthetic()\n+  {\n+    return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;\n+  }\n+\n+  /**\n+   * Return true if this field represents an enum constant,\n+   * false otherwise.\n+   * @since 1.5\n+   */\n+  public boolean isEnumConstant()\n+  {\n+    return (getModifiersInternal() & Modifier.ENUM) != 0;\n+  }\n+\n+  /**\n+   * Gets the type of this field.\n+   * @return the type of this field\n+   */\n+  public native Class getType();\n+\n+  /**\n+   * Compare two objects to see if they are semantically equivalent.\n+   * Two Fields are semantically equivalent if they have the same declaring\n+   * class, name, and type. Since you can't creat a Field except through\n+   * the VM, this is just the == relation.\n+   *\n+   * @param o the object to compare to\n+   * @return <code>true</code> if they are equal; <code>false</code> if not\n+   */\n   public boolean equals (Object fld)\n   {\n     if (! (fld instanceof Field))\n@@ -40,75 +177,281 @@ public boolean equals (Object fld)\n     return declaringClass == f.declaringClass && offset == f.offset;\n   }\n \n-  public Class getDeclaringClass ()\n+  /**\n+   * Get the hash code for the Field. The Field hash code is the hash code\n+   * of its name XOR'd with the hash code of its class name.\n+   *\n+   * @return the hash code for the object.\n+   */\n+  public int hashCode()\n   {\n-    return declaringClass;\n+    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n   }\n \n-  public native String getName ();\n-\n-  public native Class getType ();\n+  /**\n+   * Get a String representation of the Field. A Field's String\n+   * representation is \"&lt;modifiers&gt; &lt;type&gt;\n+   * &lt;class&gt;.&lt;fieldname&gt;\".<br> Example:\n+   * <code>public transient boolean gnu.parse.Parser.parseComplete</code>\n+   *\n+   * @return the String representation of the Field\n+   */\n+  public String toString ()\n+  {\n+    StringBuffer sbuf = new StringBuffer ();\n+    int mods = getModifiers();\n+    if (mods != 0)\n+      {\n+\tModifier.toString(mods, sbuf);\n+\tsbuf.append(' ');\n+      }\n+    Method.appendClassName (sbuf, getType ());\n+    sbuf.append(' ');\n+    Method.appendClassName (sbuf, getDeclaringClass());\n+    sbuf.append('.');\n+    sbuf.append(getName());\n+    return sbuf.toString();\n+  }\n \n-  public native int getModifiers ();\n+  public String toGenericString()\n+  {\n+    StringBuilder sb = new StringBuilder(64);\n+    Modifier.toString(getModifiers(), sb).append(' ');\n+    sb.append(getGenericType()).append(' ');\n+    sb.append(getDeclaringClass().getName()).append('.');\n+    sb.append(getName());\n+    return sb.toString();\n+  }\n \n-  public int hashCode()\n+  /**\n+   * Get the value of this Field.  If it is primitive, it will be wrapped\n+   * in the appropriate wrapper type (boolean = java.lang.Boolean).<p>\n+   *\n+   * If the field is static, <code>o</code> will be ignored. Otherwise, if\n+   * <code>o</code> is null, you get a <code>NullPointerException</code>,\n+   * and if it is incompatible with the declaring class of the field, you\n+   * get an <code>IllegalArgumentException</code>.<p>\n+   *\n+   * Next, if this Field enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not access this field in similar compiled code. If the field\n+   * is static, and its class is uninitialized, you trigger class\n+   * initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Finally, the field is accessed, and primitives are wrapped (but not\n+   * necessarily in new objects). This method accesses the field of the\n+   * declaring class, even if the instance passed in belongs to a subclass\n+   * which declares another field to hide this one.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if <code>o</code> is not an instance of\n+   *         the class or interface declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #getBoolean(Object)\n+   * @see #getByte(Object)\n+   * @see #getChar(Object)\n+   * @see #getShort(Object)\n+   * @see #getInt(Object)\n+   * @see #getLong(Object)\n+   * @see #getFloat(Object)\n+   * @see #getDouble(Object)\n+   */\n+  public Object get(Object obj)\n+    throws IllegalAccessException\n   {\n-    return (declaringClass.hashCode() ^ offset);\n+    return get(null, obj);\n   }\n \n-  public boolean getBoolean (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Get the value of this boolean Field. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a boolean field of\n+   *         <code>o</code>, or if <code>o</code> is not an instance of the\n+   *         declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public boolean getBoolean(Object obj)\n+    throws IllegalAccessException\n   {\n     return getBoolean(null, obj);\n   }\n-  public char getChar (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+\n+  /**\n+   * Get the value of this byte Field. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte field of\n+   *         <code>o</code>, or if <code>o</code> is not an instance of the\n+   *         declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public byte getByte(Object obj)\n+    throws IllegalAccessException\n   {\n-    return getChar(null, obj);\n+    return getByte(null, obj);\n   }\n \n-  public byte getByte (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Get the value of this Field as a char. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a char field of\n+   *         <code>o</code>, or if <code>o</code> is not an instance\n+   *         of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public char getChar(Object obj)\n+    throws IllegalAccessException\n   {\n-    return getByte(null, obj);\n+    return getChar(null, obj);\n   }\n \n-  public short getShort (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Get the value of this Field as a short. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte or short\n+   *         field of <code>o</code>, or if <code>o</code> is not an instance\n+   *         of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public short getShort(Object obj)\n+    throws IllegalAccessException\n   {\n     return getShort(null, obj);\n   }\n \n-  public int getInt (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Get the value of this Field as an int. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, or\n+   *         int field of <code>o</code>, or if <code>o</code> is not an\n+   *         instance of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public int getInt(Object obj)\n+    throws IllegalAccessException\n   {\n     return getInt(null, obj);\n   }\n \n-  public long getLong (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Get the value of this Field as a long. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, int,\n+   *         or long field of <code>o</code>, or if <code>o</code> is not an\n+   *         instance of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public long getLong(Object obj)\n+    throws IllegalAccessException\n   {\n     return getLong(null, obj);\n   }\n \n-  public float getFloat (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Get the value of this Field as a float. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, int,\n+   *         long, or float field of <code>o</code>, or if <code>o</code> is\n+   *         not an instance of the declaring class of this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public float getFloat(Object obj)\n+    throws IllegalAccessException\n   {\n     return getFloat(null, obj);\n   }\n \n-  public double getDouble (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Get the value of this Field as a double. If the field is static,\n+   * <code>o</code> will be ignored.\n+   *\n+   * @param o the object to get the value of this Field from\n+   * @return the value of the Field\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, char, int,\n+   *         long, float, or double field of <code>o</code>, or if\n+   *         <code>o</code> is not an instance of the declaring class of this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #get(Object)\n+   */\n+  public double getDouble(Object obj)\n+    throws IllegalAccessException\n   {\n     return getDouble(null, obj);\n   }\n \n-  public Object get (Object obj)\n-    throws IllegalArgumentException, IllegalAccessException\n-  {\n-    return get(null, obj);\n-  }\n-\n   private native boolean getBoolean (Class caller, Object obj)\n     throws IllegalArgumentException, IllegalAccessException;\n \n@@ -136,52 +479,268 @@ private native double getDouble (Class caller, Object obj)\n   private native Object get (Class caller, Object obj)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  public void setByte (Object obj, byte b)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Set the value of this Field.  If it is a primitive field, the value\n+   * will be unwrapped from the passed object (boolean = java.lang.Boolean).<p>\n+   *\n+   * If the field is static, <code>o</code> will be ignored. Otherwise, if\n+   * <code>o</code> is null, you get a <code>NullPointerException</code>,\n+   * and if it is incompatible with the declaring class of the field, you\n+   * get an <code>IllegalArgumentException</code>.<p>\n+   *\n+   * Next, if this Field enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not access this field in similar compiled code. This also\n+   * occurs whether or not there is access control if the field is final.\n+   * If the field is primitive, and unwrapping your argument fails, you will\n+   * get an <code>IllegalArgumentException</code>; likewise, this error\n+   * happens if <code>value</code> cannot be cast to the correct object type.\n+   * If the field is static, and its class is uninitialized, you trigger class\n+   * initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Finally, the field is set with the widened value. This method accesses\n+   * the field of the declaring class, even if the instance passed in belongs\n+   * to a subclass which declares another field to hide this one.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if <code>value</code> cannot be\n+   *         converted by a widening conversion to the underlying type of\n+   *         the Field, or if <code>o</code> is not an instance of the class\n+   *         declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #setBoolean(Object, boolean)\n+   * @see #setByte(Object, byte)\n+   * @see #setChar(Object, char)\n+   * @see #setShort(Object, short)\n+   * @see #setInt(Object, int)\n+   * @see #setLong(Object, long)\n+   * @see #setFloat(Object, float)\n+   * @see #setDouble(Object, double)\n+   */\n+  public void set(Object object, Object value)\n+    throws IllegalAccessException\n+  {\n+    set(null, object, value);\n+  }\n+\n+  /**\n+   * Set this boolean Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a boolean field, or if\n+   *         <code>o</code> is not an instance of the class declaring this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setBoolean(Object obj, boolean b)\n+    throws IllegalAccessException\n+  {\n+    setBoolean(null, obj, b, true);\n+  }\n+\n+  /**\n+   * Set this byte Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a byte, short, int, long,\n+   *         float, or double field, or if <code>o</code> is not an instance\n+   *         of the class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setByte(Object obj, byte b)\n+    throws IllegalAccessException\n   {\n     setByte(null, obj, b, true);\n   }\n \n-  public void setShort (Object obj,  short s)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Set this char Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a char, int, long,\n+   *         float, or double field, or if <code>o</code> is not an instance\n+   *         of the class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setChar(Object obj, char c)\n+    throws IllegalAccessException\n+  {\n+    setChar(null, obj, c, true);\n+  }\n+\n+  /**\n+   * Set this short Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a short, int, long,\n+   *         float, or double field, or if <code>o</code> is not an instance\n+   *         of the class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setShort(Object obj,  short s)\n+    throws IllegalAccessException\n   {\n     setShort(null, obj, s, true);\n   }\n \n-  public void setInt (Object obj, int i)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Set this int Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not an int, long, float, or\n+   *         double field, or if <code>o</code> is not an instance of the\n+   *         class declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setInt(Object obj, int i)\n+    throws IllegalAccessException\n   {\n     setInt(null, obj, i, true);\n   }\n \n-  public void setLong (Object obj, long l)\n+  /**\n+   * Set this long Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a long, float, or double\n+   *         field, or if <code>o</code> is not an instance of the class\n+   *         declaring this field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setLong(Object obj, long l)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n     setLong(null, obj, l, true);\n   }\n \n-  public void setFloat (Object obj, float f)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Set this float Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a float or long field, or\n+   *         if <code>o</code> is not an instance of the class declaring this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setFloat(Object obj, float f)\n+    throws IllegalAccessException\n   {\n     setFloat(null, obj, f, true);\n   }\n \n-  public void setDouble (Object obj, double d)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Set this double Field. If the field is static, <code>o</code> will be\n+   * ignored.\n+   *\n+   * @param o the object to set this Field on\n+   * @param value the value to set this Field to\n+   * @throws IllegalAccessException if you could not normally access this field\n+   *         (i.e. it is not public)\n+   * @throws IllegalArgumentException if this is not a double field, or if\n+   *         <code>o</code> is not an instance of the class declaring this\n+   *         field\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static field triggered\n+   *         class initialization, which then failed\n+   * @see #set(Object, Object)\n+   */\n+  public void setDouble(Object obj, double d)\n+    throws IllegalAccessException\n   {\n     setDouble(null, obj, d, true);\n   }\n \n-  public void setChar (Object obj, char c)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Return the generic type of the field. If the field type is not a generic\n+   * type, the method returns the same as <code>getType()</code>.\n+   *\n+   * @throws GenericSignatureFormatError if the generic signature does\n+   *         not conform to the format specified in the Virtual Machine\n+   *         specification, version 3.\n+   * @since 1.5\n+   */\n+  public Type getGenericType()\n   {\n-    setChar(null, obj, c, true);\n+    String signature = getSignature();\n+    if (signature == null)\n+      return getType();\n+    FieldSignatureParser p = new FieldSignatureParser(getDeclaringClass(),\n+                                                      signature);\n+    return p.getFieldType();\n   }\n \n-  public void setBoolean (Object obj, boolean b)\n-    throws IllegalArgumentException, IllegalAccessException\n+  /**\n+   * Return the String in the Signature attribute for this field. If there\n+   * is no Signature attribute, return null.\n+   */\n+  private String getSignature()\n   {\n-    setBoolean(null, obj, b, true);\n+    // FIXME: libgcj doesn't record Signature attributes yet.\n+    return null;\n   }\n \n   native void setByte (Class caller, Object obj, byte b, boolean checkFinal)\n@@ -214,12 +773,6 @@ native void set (Class caller, Object obj, Object val, Class type,\n \t\t   boolean checkFinal)\n     throws IllegalArgumentException, IllegalAccessException;\n \n-  public void set (Object object, Object value)\n-    throws IllegalArgumentException, IllegalAccessException\n-  {\n-    set(null, object, value);\n-  }\n-\n   private void set (Class caller, Object object, Object value)\n     throws IllegalArgumentException, IllegalAccessException\n   {\n@@ -245,26 +798,4 @@ else if (value instanceof Boolean)\n     else\n       throw new IllegalArgumentException();\n   }\n-\n-  public String toString ()\n-  {\n-    StringBuffer sbuf = new StringBuffer ();\n-    int mods = getModifiers();\n-    if (mods != 0)\n-      {\n-\tModifier.toString(mods, sbuf);\n-\tsbuf.append(' ');\n-      }\n-    Method.appendClassName (sbuf, getType ());\n-    sbuf.append(' ');\n-    Method.appendClassName (sbuf, getDeclaringClass());\n-    sbuf.append('.');\n-    sbuf.append(getName());\n-    return sbuf.toString();\n-  }\n-\n-  // FIXME - Write a real implementations\n-  public boolean isSynthetic() { return false; }\n-  public boolean isEnumConstant() { return false; }\n-\n }"}, {"sha": "3142d64944fb81331c025936e26396966ad2c4dc", "filename": "libjava/java/lang/reflect/Method.java", "status": "modified", "additions": 176, "deletions": 34, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FMethod.java?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,6 +1,6 @@\n // Method.java - Represent method of class or interface.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -11,6 +11,7 @@\n package java.lang.reflect;\n \n import gnu.gcj.RawData;\n+import gnu.java.lang.reflect.MethodSignatureParser;\n \n /**\n  * The Method class represents a member method of a class. It also allows\n@@ -39,16 +40,21 @@\n  * @author Tom Tromey <tromey@redhat.com>\n  * @see Member\n  * @see Class\n- * @see java.lang.Class#getMethod(String,Object[])\n- * @see java.lang.Class#getDeclaredMethod(String,Object[])\n+ * @see java.lang.Class#getMethod(String,Class[])\n+ * @see java.lang.Class#getDeclaredMethod(String,Class[])\n  * @see java.lang.Class#getMethods()\n  * @see java.lang.Class#getDeclaredMethods()\n  * @since 1.1\n  * @status updated to 1.4\n  */\n-public final class Method extends AccessibleObject\n-  implements Member, GenericDeclaration\n+public final class Method\n+  extends AccessibleObject implements Member, GenericDeclaration\n {\n+  private static final int METHOD_MODIFIERS\n+    = Modifier.ABSTRACT | Modifier.FINAL | Modifier.NATIVE\n+      | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC\n+      | Modifier.STATIC | Modifier.STRICT | Modifier.SYNCHRONIZED;\n+\n   /**\n    * This class is uninstantiable.\n    */\n@@ -61,7 +67,7 @@ private Method ()\n    * is a non-inherited member.\n    * @return the class that declared this member\n    */\n-  public Class getDeclaringClass ()\n+  public Class getDeclaringClass()\n   {\n     return declaringClass;\n   }\n@@ -72,6 +78,12 @@ public Class getDeclaringClass ()\n    */\n   public native String getName ();\n \n+  /**\n+   * Return the raw modifiers for this method.\n+   * @return the method's modifiers\n+   */\n+  private native int getModifiersInternal();\n+\n   /**\n    * Gets the modifiers this method uses.  Use the <code>Modifier</code>\n    * class to interpret the values.  A method can only have a subset of the\n@@ -81,7 +93,40 @@ public Class getDeclaringClass ()\n    * @return an integer representing the modifiers to this Member\n    * @see Modifier\n    */\n-  public native int getModifiers ();\n+  public int getModifiers()\n+  {\n+    return getModifiersInternal() & METHOD_MODIFIERS;\n+  }\n+\n+  /**\n+   * Return true if this method is a bridge method.  A bridge method\n+   * is generated by the compiler in some situations involving\n+   * generics and inheritance.\n+   * @since 1.5\n+   */\n+  public boolean isBridge()\n+  {\n+    return (getModifiersInternal() & Modifier.BRIDGE) != 0;\n+  }\n+\n+  /**\n+   * Return true if this method is synthetic, false otherwise.\n+   * @since 1.5\n+   */\n+  public boolean isSynthetic()\n+  {\n+    return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;\n+  }\n+\n+  /**\n+   * Return true if this is a varargs method, that is if\n+   * the method takes a variable number of arguments.\n+   * @since 1.5\n+   */\n+  public boolean isVarArgs()\n+  {\n+    return (getModifiersInternal() & Modifier.VARARGS) != 0;\n+  }\n \n   /**\n    * Gets the return type of this method.\n@@ -139,14 +184,14 @@ public boolean equals (Object obj)\n   }\n \n   /**\n-   * Get the hash code for the Method.\n+   * Get the hash code for the Method. The Method hash code is the hash code\n+   * of its name XOR'd with the hash code of its class name.\n    *\n    * @return the hash code for the object\n    */\n-  public int hashCode ()\n+  public int hashCode()\n   {\n-    // FIXME.\n-    return getName().hashCode() + declaringClass.getName().hashCode();\n+    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n   }\n \n   /**\n@@ -158,7 +203,7 @@ public int hashCode ()\n    *\n    * @return the String representation of the Method\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     if (parameter_types == null)\n       getType ();\n@@ -196,6 +241,33 @@ public String toString ()\n     return b.toString();\n   }\n \n+  public String toGenericString()\n+  {\n+    // 128 is a reasonable buffer initial size for constructor\n+    StringBuilder sb = new StringBuilder(128);\n+    Modifier.toString(getModifiers(), sb).append(' ');\n+    Constructor.addTypeParameters(sb, getTypeParameters());\n+    sb.append(getGenericReturnType()).append(' ');\n+    sb.append(getDeclaringClass().getName()).append('.');\n+    sb.append(getName()).append('(');\n+    Type[] types = getGenericParameterTypes();\n+    if (types.length > 0)\n+      {\n+        sb.append(types[0]);\n+        for (int i = 1; i < types.length; i++)\n+          sb.append(',').append(types[i]);\n+      }\n+    sb.append(')');\n+    types = getGenericExceptionTypes();\n+    if (types.length > 0)\n+      {\n+        sb.append(\" throws \").append(types[0]);\n+        for (int i = 1; i < types.length; i++)\n+          sb.append(',').append(types[i]);\n+      }\n+    return sb.toString();\n+  }\n+\n   /**\n    * Invoke the method. Arguments are automatically unwrapped and widened,\n    * and the result is automatically wrapped, if needed.<p>\n@@ -241,6 +313,98 @@ public native Object invoke (Object obj, Object[] args)\n     throws IllegalAccessException, IllegalArgumentException,\n     InvocationTargetException;\n \n+  /**\n+   * Returns an array of <code>TypeVariable</code> objects that represents\n+   * the type variables declared by this constructor, in declaration order.\n+   * An array of size zero is returned if this class has no type\n+   * variables.\n+   *\n+   * @return the type variables associated with this class. \n+   * @throws GenericSignatureFormatError if the generic signature does\n+   *         not conform to the format specified in the Virtual Machine\n+   *         specification, version 3.\n+   * @since 1.5\n+   */\n+  /* FIXME[GENERICS]: Should be TypeVariable<Method>[] */\n+  public TypeVariable[] getTypeParameters()\n+  {\n+    String sig = getSignature();\n+    if (sig == null)\n+      return new TypeVariable[0];\n+    MethodSignatureParser p = new MethodSignatureParser(this, sig);\n+    return p.getTypeParameters();\n+  }\n+\n+  /**\n+   * Return the String in the Signature attribute for this method. If there\n+   * is no Signature attribute, return null.\n+   */\n+  private String getSignature()\n+  {\n+    // FIXME: libgcj doesn't record this information yet.\n+    return null;\n+  }\n+\n+  /**\n+   * Returns an array of <code>Type</code> objects that represents\n+   * the exception types declared by this method, in declaration order.\n+   * An array of size zero is returned if this method declares no\n+   * exceptions.\n+   *\n+   * @return the exception types declared by this method. \n+   * @throws GenericSignatureFormatError if the generic signature does\n+   *         not conform to the format specified in the Virtual Machine\n+   *         specification, version 3.\n+   * @since 1.5\n+   */\n+  public Type[] getGenericExceptionTypes()\n+  {\n+    String sig = getSignature();\n+    if (sig == null)\n+      return getExceptionTypes();\n+    MethodSignatureParser p = new MethodSignatureParser(this, sig);\n+    return p.getGenericExceptionTypes();\n+  }\n+\n+  /**\n+   * Returns an array of <code>Type</code> objects that represents\n+   * the parameter list for this method, in declaration order.\n+   * An array of size zero is returned if this method takes no\n+   * parameters.\n+   *\n+   * @return a list of the types of the method's parameters\n+   * @throws GenericSignatureFormatError if the generic signature does\n+   *         not conform to the format specified in the Virtual Machine\n+   *         specification, version 3.\n+   * @since 1.5\n+   */\n+  public Type[] getGenericParameterTypes()\n+  {\n+    String sig = getSignature();\n+    if (sig == null)\n+      return getParameterTypes();\n+    MethodSignatureParser p = new MethodSignatureParser(this, sig);\n+    return p.getGenericParameterTypes();\n+  }\n+\n+  /**\n+   * Returns the return type of this method.\n+   *\n+   * @return the return type of this method\n+   * @throws GenericSignatureFormatError if the generic signature does\n+   *         not conform to the format specified in the Virtual Machine\n+   *         specification, version 3.\n+   * @since 1.5\n+   */\n+  public Type getGenericReturnType()\n+  {\n+    String sig = getSignature();\n+    if (sig == null)\n+      return getReturnType();\n+    MethodSignatureParser p = new MethodSignatureParser(this, sig);\n+    return p.getGenericReturnType();\n+  }\n+\n   private native void getType ();\n \n   // Append a class name to a string buffer.  We try to print the\n@@ -263,28 +427,6 @@ static void appendClassName (StringBuffer buf, Class k)\n       }\n   }\n \n-  // FIXME - Write a real implementation\n-  public boolean isSynthetic() { return false; }\n-\n-  /**\n-   * Returns an array of <code>TypeVariable</code> objects that represents\n-   * the type variables declared by this constructor, in declaration order.\n-   * An array of size zero is returned if this class has no type\n-   * variables.\n-   *\n-   * @return the type variables associated with this class.\n-   * @throws GenericSignatureFormatError if the generic signature does\n-   *         not conform to the format specified in the Virtual Machine\n-   *         specification, version 3.\n-   * @since 1.5\n-   */\n-  /* FIXME[GENERICS]: Should be TypeVariable<Method>[] */\n-  public TypeVariable[] getTypeParameters()\n-  {\n-    // FIXME - write a real implementation\n-    return new TypeVariable[0];\n-  }\n-\n   // Declaring class.\n   private Class declaringClass;\n "}, {"sha": "f9a9ca2c909256ce30d0479ed12c5ff13d177966", "filename": "libjava/java/lang/reflect/Modifier.java", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FModifier.java?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,5 +1,5 @@\n /* java.lang.reflect.Modifier\n-   Copyright (C) 1998, 1999, 2001, 2002, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2002, 2005, 2006  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -157,11 +157,31 @@ public Modifier()\n    */\n   static final int ALL_FLAGS = 0xfff;\n \n+  /**\n+   * Flag indicating a bridge method.\n+   */\n+  static final int BRIDGE = 0x40;\n+\n+  /**\n+   * Flag indicating a varargs method.\n+   */\n+  static final int VARARGS = 0x80;\n+\n+  /**\n+   * Flag indicating a synthetic member.\n+   */\n+  static final int SYNTHETIC = 0x1000;\n+\n+  /**\n+   * Flag indicating an enum constant or an enum class.\n+   */\n+  static final int ENUM = 0x4000;\n+\n   /**\n    * GCJ-LOCAL: This access flag is set on methods we declare\n    * internally but which must not be visible to reflection.\n    */\n-  static final int INVISIBLE = 0x1000;\n+  static final int INVISIBLE = 0x8000;\n \n   /**\n    * GCJ-LOCAL: This access flag is set on interpreted classes.\n@@ -302,6 +322,18 @@ public static String toString(int mod)\n     return toString(mod, new StringBuffer()).toString();\n   }\n \n+  /**\n+   * Package helper method that can take a StringBuilder.\n+   * @param mod the modifier\n+   * @param r the StringBuilder to which the String representation is appended\n+   * @return r, with information appended\n+   */\n+  static StringBuilder toString(int mod, StringBuilder r)\n+  {\n+    r.append(toString(mod, new StringBuffer()));\n+    return r;\n+  }\n+\n   /**\n    * Package helper method that can take a StringBuffer.\n    * @param mod the modifier"}, {"sha": "35cf7f817ef0bc4dc94b612f2f8dc92ab585eb90", "filename": "libjava/java/lang/reflect/natConstructor.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,6 +1,6 @@\n // natConstructor.cc - Native code for Constructor class.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -24,10 +24,9 @@ details.  */\n #include <gcj/method.h>\n \n jint\n-java::lang::reflect::Constructor::getModifiers ()\n+java::lang::reflect::Constructor::getModifiersInternal ()\n {\n-  // Ignore all unknown flags.\n-  return _Jv_FromReflectedConstructor (this)->accflags & Modifier::ALL_FLAGS;\n+  return _Jv_FromReflectedConstructor (this)->accflags;\n }\n \n void"}, {"sha": "ae68639065b58f20cb46e7aba31f59b14bd4f758", "filename": "libjava/java/lang/reflect/natField.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,6 +1,6 @@\n // natField.cc - Implementation of java.lang.reflect.Field native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -30,9 +30,9 @@ details.  */\n #include <java/lang/Character.h>\n \n jint\n-java::lang::reflect::Field::getModifiers ()\n+java::lang::reflect::Field::getModifiersInternal ()\n {\n-  return _Jv_FromReflectedField (this)->getModifiers ();\n+  return _Jv_FromReflectedField (this)->flags;\n }\n \n jstring\n@@ -72,7 +72,7 @@ getAddr (java::lang::reflect::Field* field, jclass caller, jobject obj,\n \n   // Setting a final field is usually not allowed.\n   if (checkFinal\n-      && field->getModifiers() & java::lang::reflect::Modifier::FINAL)\n+      && (field->getModifiers() & java::lang::reflect::Modifier::FINAL))\n     throw new java::lang::IllegalAccessException(JvNewStringUTF \n       (\"Field is final\"));\n   "}, {"sha": "eb7170a02be83d357ccec238584a1722da49b0af", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aca4c41f72573edb4c22736ac46ff3abf7d625a/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=5aca4c41f72573edb4c22736ac46ff3abf7d625a", "patch": "@@ -1,6 +1,6 @@\n // natMethod.cc - Native code for Method class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001 , 2002, 2003, 2004, 2005 Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001 , 2002, 2003, 2004, 2005, 2006 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -183,10 +183,9 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n }\n \n jint\n-java::lang::reflect::Method::getModifiers ()\n+java::lang::reflect::Method::getModifiersInternal ()\n {\n-  // Ignore all unknown flags.\n-  return _Jv_FromReflectedMethod (this)->accflags & Modifier::ALL_FLAGS;\n+  return _Jv_FromReflectedMethod (this)->accflags;\n }\n \n jstring"}]}