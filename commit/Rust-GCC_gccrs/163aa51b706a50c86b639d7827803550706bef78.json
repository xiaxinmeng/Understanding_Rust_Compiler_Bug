{"sha": "163aa51b706a50c86b639d7827803550706bef78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYzYWE1MWI3MDZhNTBjODZiNjM5ZDc4Mjc4MDM1NTA3MDZiZWY3OA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-10-12T14:29:45Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-10-12T14:29:45Z"}, "message": "tree-loop-distribution.c: Adjust the general comment.\n\n\t* tree-loop-distribution.c: Adjust the general comment.\n\t(NUM_PARTITION_THRESHOLD): New macro.\n\t(ssa_name_has_uses_outside_loop_p): Support loop nest distribution.\n\t(classify_partition): Skip builtin pattern of loop nest's inner loop.\n\t(merge_dep_scc_partitions): New parameter ignore_alias_p and use it\n\tin call to build_partition_graph.\n\t(finalize_partitions): New parameter.  Make loop distribution more\n\tconservative by fusing more partitions.\n\t(distribute_loop): Don't do runtime alias check in case of loop nest\n\tdistribution.\n\t(find_seed_stmts_for_distribution): New function.\n\t(prepare_perfect_loop_nest): New function.\n\t(pass_loop_distribution::execute): Refactor code finding seed stmts\n\tand loop nest into above functions.  Support loop nest distribution.\n\tAdjust dump information accordingly.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/ldist-7.c: Adjust test string.\n\t* gcc.dg/tree-ssa/ldist-16.c: Ditto.\n\t* gcc.dg/tree-ssa/ldist-25.c: Ditto.\n\t* gcc.dg/tree-ssa/ldist-33.c: New test.\n\nFrom-SVN: r253679", "tree": {"sha": "2a4f5407e6e1119cddfa77c8d7c7ef36907e826d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a4f5407e6e1119cddfa77c8d7c7ef36907e826d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/163aa51b706a50c86b639d7827803550706bef78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/163aa51b706a50c86b639d7827803550706bef78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/163aa51b706a50c86b639d7827803550706bef78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/163aa51b706a50c86b639d7827803550706bef78/comments", "author": null, "committer": null, "parents": [{"sha": "6dc29d3adcadf6f138898a3f43663f806c1a41ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc29d3adcadf6f138898a3f43663f806c1a41ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc29d3adcadf6f138898a3f43663f806c1a41ce"}], "stats": {"total": 335, "additions": 230, "deletions": 105}, "files": [{"sha": "65eb2023b15c788f9c6f3004c02db08244cdfe5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163aa51b706a50c86b639d7827803550706bef78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163aa51b706a50c86b639d7827803550706bef78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=163aa51b706a50c86b639d7827803550706bef78", "patch": "@@ -1,3 +1,21 @@\n+2017-10-12  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c: Adjust the general comment.\n+\t(NUM_PARTITION_THRESHOLD): New macro.\n+\t(ssa_name_has_uses_outside_loop_p): Support loop nest distribution.\n+\t(classify_partition): Skip builtin pattern of loop nest's inner loop.\n+\t(merge_dep_scc_partitions): New parameter ignore_alias_p and use it\n+\tin call to build_partition_graph.\n+\t(finalize_partitions): New parameter.  Make loop distribution more\n+\tconservative by fusing more partitions.\n+\t(distribute_loop): Don't do runtime alias check in case of loop nest\n+\tdistribution.\n+\t(find_seed_stmts_for_distribution): New function.\n+\t(prepare_perfect_loop_nest): New function.\n+\t(pass_loop_distribution::execute): Refactor code finding seed stmts\n+\tand loop nest into above functions.  Support loop nest distribution.\n+\tAdjust dump information accordingly.\n+\n 2017-10-12  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (break_alias_scc_partitions): Add comment"}, {"sha": "ee792a770811a3a22f4a0442f74dff524f3b0bd2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=163aa51b706a50c86b639d7827803550706bef78", "patch": "@@ -1,3 +1,10 @@\n+2017-10-12  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/ldist-7.c: Adjust test string.\n+\t* gcc.dg/tree-ssa/ldist-16.c: Ditto.\n+\t* gcc.dg/tree-ssa/ldist-25.c: Ditto.\n+\t* gcc.dg/tree-ssa/ldist-33.c: New test.\n+\n 2017-10-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69728"}, {"sha": "f4f3a44903c46487185d05029feba88011f5cd15", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-16.c?ref=163aa51b706a50c86b639d7827803550706bef78", "patch": "@@ -16,5 +16,5 @@ void foo (int n)\n \n /* We should not apply loop distribution and not generate a memset (0).  */\n \n-/* { dg-final { scan-tree-dump \"Loop 1 is the same\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"Loop 1 not distributed\" \"ldist\" } } */\n /* { dg-final { scan-tree-dump-times \"generated memset zero\" 0 \"ldist\" } } */"}, {"sha": "c0b95fc38ecba66d25d9708020f529eb5e64800f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-25.c?ref=163aa51b706a50c86b639d7827803550706bef78", "patch": "@@ -22,4 +22,4 @@ foo (void)\n     }\n }\n \n-/* { dg-final { scan-tree-dump \"Loop . is the same\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"Loop . not distributed\" \"ldist\" } } */"}, {"sha": "24d27fde9daa13277f716315f89bbfd2401ad3a1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-33.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-33.c?ref=163aa51b706a50c86b639d7827803550706bef78", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+#define N (1024)\n+double a[N][N], b[N][N], c[N][N];\n+\n+void\n+foo (void)\n+{\n+  unsigned i, j, k;\n+\n+  for (i = 0; i < N; ++i)\n+    for (j = 0; j < N; ++j)\n+      {\n+\tc[i][j] = 0.0;\n+\tfor (k = 0; k < N; ++k)\n+\t  c[i][j] += a[i][k] * b[k][j];\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Loop nest . distributed: split to 1 loops and 1 library\" \"ldist\" } } */"}, {"sha": "2eb1f74d4ab3e66d61c49cdc7a72aeb83b7f01a6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-7.c?ref=163aa51b706a50c86b639d7827803550706bef78", "patch": "@@ -28,4 +28,4 @@ int loop1 (int k)\n   return a[1000-2] + b[1000-1] + c[1000-2] + d[1000-2];\n }\n \n-/* { dg-final { scan-tree-dump-times \"distributed\" 0 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"distributed: \" 0 \"ldist\" } } */"}, {"sha": "49ca9ee8cef17763869d5585efdc7a08f4793b5e", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 181, "deletions": 102, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163aa51b706a50c86b639d7827803550706bef78/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=163aa51b706a50c86b639d7827803550706bef78", "patch": "@@ -83,8 +83,8 @@ along with GCC; see the file COPYING3.  If not see\n \tloops and recover to the original one.\n \n    TODO:\n-     1) We only distribute innermost loops now.  This pass should handle loop\n-\tnests in the future.\n+     1) We only distribute innermost two-level loop nest now.  We should\n+\textend it for arbitrary loop nests in the future.\n      2) We only fuse partitions in SCC now.  A better fusion algorithm is\n \tdesired to minimize loop overhead, maximize parallelism and maximize\n \tdata reuse.  */\n@@ -118,6 +118,11 @@ along with GCC; see the file COPYING3.  If not see\n #define MAX_DATAREFS_NUM \\\n \t((unsigned) PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n \n+/* Threshold controlling number of distributed partitions.  Given it may\n+   be unnecessary if a memory stream cost model is invented in the future,\n+   we define it as a temporary macro, rather than a parameter.  */\n+#define NUM_PARTITION_THRESHOLD (4)\n+\n /* Hashtable helpers.  */\n \n struct ddr_hasher : nofree_ptr_hash <struct data_dependence_relation>\n@@ -714,9 +719,11 @@ ssa_name_has_uses_outside_loop_p (tree def, loop_p loop)\n \n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n     {\n-      gimple *use_stmt = USE_STMT (use_p);\n-      if (!is_gimple_debug (use_stmt)\n-\t  && loop != loop_containing_stmt (use_stmt))\n+      if (is_gimple_debug (USE_STMT (use_p)))\n+\tcontinue;\n+\n+      basic_block use_bb = gimple_bb (USE_STMT (use_p));\n+      if (!flow_bb_inside_loop_p (loop, use_bb))\n \treturn true;\n     }\n \n@@ -1414,6 +1421,22 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n   if (!single_store)\n     return;\n \n+  /* TODO: We don't support memset/memcpy distribution for loop nest yet.  */\n+  if (loop->inner)\n+    {\n+      basic_block bb = gimple_bb (DR_STMT (single_store));\n+\n+      if (bb->loop_father != loop)\n+\treturn;\n+\n+      if (single_load)\n+\t{\n+\t  bb = gimple_bb (DR_STMT (single_load));\n+\t  if (bb->loop_father != loop)\n+\t    return;\n+\t}\n+    }\n+\n   nb_iter = number_of_latch_executions (loop);\n   gcc_assert (nb_iter && nb_iter != chrec_dont_know);\n   if (dominated_by_p (CDI_DOMINATORS, single_exit (loop)->src,\n@@ -1965,16 +1988,18 @@ sort_partitions_by_post_order (struct graph *pg,\n }\n \n /* Given reduced dependence graph RDG merge strong connected components\n-   of PARTITIONS.  In this function, data dependence caused by possible\n-   alias between references is ignored, as if it doesn't exist at all.  */\n+   of PARTITIONS.  If IGNORE_ALIAS_P is true, data dependence caused by\n+   possible alias between references is ignored, as if it doesn't exist\n+   at all; otherwise all depdendences are considered.  */\n \n static void\n merge_dep_scc_partitions (struct graph *rdg,\n-\t\t\t  vec<struct partition *> *partitions)\n+\t\t\t  vec<struct partition *> *partitions,\n+\t\t\t  bool ignore_alias_p)\n {\n   struct partition *partition1, *partition2;\n   struct pg_vdata *data;\n-  graph *pg = build_partition_graph (rdg, partitions, true);\n+  graph *pg = build_partition_graph (rdg, partitions, ignore_alias_p);\n   int i, j, num_sccs = graphds_scc (pg, NULL);\n \n   /* Strong connected compoenent means dependence cycle, we cannot distribute\n@@ -2340,38 +2365,49 @@ version_for_distribution_p (vec<struct partition *> *partitions,\n   return (alias_ddrs->length () > 0);\n }\n \n-/* Fuse all partitions if necessary before finalizing distribution.  */\n+/* Fuse PARTITIONS of LOOP if necessary before finalizing distribution.\n+   ALIAS_DDRS contains ddrs which need runtime alias check.  */\n \n static void\n-finalize_partitions (vec<struct partition *> *partitions,\n+finalize_partitions (struct loop *loop, vec<struct partition *> *partitions,\n \t\t     vec<ddr_p> *alias_ddrs)\n {\n   unsigned i;\n-  struct partition *a, *partition;\n+  struct partition *partition, *a;\n \n   if (partitions->length () == 1\n       || alias_ddrs->length () > 0)\n     return;\n \n-  a = (*partitions)[0];\n-  if (a->kind != PKIND_NORMAL)\n-    return;\n-\n-  for (i = 1; partitions->iterate (i, &partition); ++i)\n+  unsigned num_builtin = 0, num_normal = 0;\n+  bool same_type_p = true;\n+  enum partition_type type = ((*partitions)[0])->type;\n+  for (i = 0; partitions->iterate (i, &partition); ++i)\n     {\n-      /* Don't fuse if partition has different type or it is a builtin.  */\n-      if (partition->type != a->type\n-\t  || partition->kind != PKIND_NORMAL)\n-\treturn;\n+      same_type_p &= (type == partition->type);\n+      if (partition->kind != PKIND_NORMAL)\n+\tnum_builtin++;\n+      else\n+\tnum_normal++;\n     }\n \n-  /* Fuse all partitions.  */\n-  for (i = 1; partitions->iterate (i, &partition); ++i)\n+  /* Don't distribute current loop into too many loops given we don't have\n+     memory stream cost model.  Be even more conservative in case of loop\n+     nest distribution.  */\n+  if ((same_type_p && num_builtin == 0)\n+      || (loop->inner != NULL\n+\t  && i >= NUM_PARTITION_THRESHOLD && num_normal > 1)\n+      || (loop->inner == NULL\n+\t  && i >= NUM_PARTITION_THRESHOLD && num_normal > num_builtin))\n     {\n-      partition_merge_into (NULL, a, partition, FUSE_FINALIZE);\n-      partition_free (partition);\n+      a = (*partitions)[0];\n+      for (i = 1; partitions->iterate (i, &partition); ++i)\n+\t{\n+\t  partition_merge_into (NULL, a, partition, FUSE_FINALIZE);\n+\t  partition_free (partition);\n+\t}\n+      partitions->truncate (1);\n     }\n-  partitions->truncate (1);\n }\n \n /* Distributes the code from LOOP in such a way that producer statements\n@@ -2524,16 +2560,23 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \ti--;\n     }\n \n-  /* Build the partition dependency graph.  */\n+  /* Build the partition dependency graph and fuse partitions in strong\n+     connected component.  */\n   if (partitions.length () > 1)\n     {\n-      merge_dep_scc_partitions (rdg, &partitions);\n-      alias_ddrs.truncate (0);\n-      if (partitions.length () > 1)\n-\tbreak_alias_scc_partitions (rdg, &partitions, &alias_ddrs);\n+      /* Don't support loop nest distribution under runtime alias check\n+\t since it's not likely to enable many vectorization opportunities.  */\n+      if (loop->inner)\n+\tmerge_dep_scc_partitions (rdg, &partitions, false);\n+      else\n+\t{\n+\t  merge_dep_scc_partitions (rdg, &partitions, true);\n+\t  if (partitions.length () > 1)\n+\t    break_alias_scc_partitions (rdg, &partitions, &alias_ddrs);\n+\t}\n     }\n \n-  finalize_partitions (&partitions, &alias_ddrs);\n+  finalize_partitions (loop, &partitions, &alias_ddrs);\n \n   nbp = partitions.length ();\n   if (nbp == 0\n@@ -2614,6 +2657,86 @@ class pass_loop_distribution : public gimple_opt_pass\n \n }; // class pass_loop_distribution\n \n+\n+/* Given LOOP, this function records seed statements for distribution in\n+   WORK_LIST.  Return false if there is nothing for distribution.  */\n+\n+static bool\n+find_seed_stmts_for_distribution (struct loop *loop, vec<gimple *> *work_list)\n+{\n+  basic_block *bbs = get_loop_body_in_dom_order (loop);\n+\n+  /* Initialize the worklist with stmts we seed the partitions with.  */\n+  for (unsigned i = 0; i < loop->num_nodes; ++i)\n+    {\n+      for (gphi_iterator gsi = gsi_start_phis (bbs[i]);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  if (virtual_operand_p (gimple_phi_result (phi)))\n+\t    continue;\n+\t  /* Distribute stmts which have defs that are used outside of\n+\t     the loop.  */\n+\t  if (!stmt_has_scalar_dependences_outside_loop (loop, phi))\n+\t    continue;\n+\t  work_list->safe_push (phi);\n+\t}\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  /* If there is a stmt with side-effects bail out - we\n+\t     cannot and should not distribute this loop.  */\n+\t  if (gimple_has_side_effects (stmt))\n+\t    {\n+\t      free (bbs);\n+\t      return false;\n+\t    }\n+\n+\t  /* Distribute stmts which have defs that are used outside of\n+\t     the loop.  */\n+\t  if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n+\t    ;\n+\t  /* Otherwise only distribute stores for now.  */\n+\t  else if (!gimple_vdef (stmt))\n+\t    continue;\n+\n+\t  work_list->safe_push (stmt);\n+\t}\n+    }\n+  free (bbs);\n+  return work_list->length () > 0;\n+}\n+\n+/* Given innermost LOOP, return the outermost enclosing loop that forms a\n+   perfect loop nest.  */\n+\n+static struct loop *\n+prepare_perfect_loop_nest (struct loop *loop)\n+{\n+  struct loop *outer = loop_outer (loop);\n+  tree niters = number_of_latch_executions (loop);\n+\n+  /* TODO: We only support the innermost 2-level loop nest distribution\n+     because of compilation time issue for now.  This should be relaxed\n+     in the future.  */\n+  while (loop->inner == NULL\n+\t && loop_outer (outer)\n+\t && outer->inner == loop && loop->next == NULL\n+\t && single_exit (outer)\n+\t && optimize_loop_for_speed_p (outer)\n+\t && !chrec_contains_symbols_defined_in_loop (niters, outer->num)\n+\t && (niters = number_of_latch_executions (outer)) != NULL_TREE\n+\t && niters != chrec_dont_know)\n+    {\n+      loop = outer;\n+      outer = loop_outer (loop);\n+    }\n+\n+  return loop;\n+}\n+\n unsigned int\n pass_loop_distribution::execute (function *fun)\n {\n@@ -2656,100 +2779,56 @@ pass_loop_distribution::execute (function *fun)\n      walking to innermost loops.  */\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n-      auto_vec<gimple *> work_list;\n-      basic_block *bbs;\n-      int num = loop->num;\n-      unsigned int i;\n-\n-      /* If the loop doesn't have a single exit we will fail anyway,\n-\t so do that early.  */\n-      if (!single_exit (loop))\n-\tcontinue;\n-\n-      /* Only optimize hot loops.  */\n-      if (!optimize_loop_for_speed_p (loop))\n+      /* Don't distribute multiple exit edges loop, or cold loop.  */\n+      if (!single_exit (loop)\n+\t  || !optimize_loop_for_speed_p (loop))\n \tcontinue;\n \n       /* Don't distribute loop if niters is unknown.  */\n       tree niters = number_of_latch_executions (loop);\n       if (niters == NULL_TREE || niters == chrec_dont_know)\n \tcontinue;\n \n-      /* Initialize the worklist with stmts we seed the partitions with.  */\n-      bbs = get_loop_body_in_dom_order (loop);\n-      for (i = 0; i < loop->num_nodes; ++i)\n+      /* Get the perfect loop nest for distribution.  */\n+      loop = prepare_perfect_loop_nest (loop);\n+      for (; loop; loop = loop->inner)\n \t{\n-\t  for (gphi_iterator gsi = gsi_start_phis (bbs[i]);\n-\t       !gsi_end_p (gsi);\n-\t       gsi_next (&gsi))\n-\t    {\n-\t      gphi *phi = gsi.phi ();\n-\t      if (virtual_operand_p (gimple_phi_result (phi)))\n-\t\tcontinue;\n-\t      /* Distribute stmts which have defs that are used outside of\n-\t\t the loop.  */\n-\t      if (!stmt_has_scalar_dependences_outside_loop (loop, phi))\n-\t\tcontinue;\n-\t      work_list.safe_push (phi);\n-\t    }\n-\t  for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]);\n-\t       !gsi_end_p (gsi);\n-\t       gsi_next (&gsi))\n-\t    {\n-\t      gimple *stmt = gsi_stmt (gsi);\n-\n-\t      /* If there is a stmt with side-effects bail out - we\n-\t\t cannot and should not distribute this loop.  */\n-\t      if (gimple_has_side_effects (stmt))\n-\t\t{\n-\t\t  work_list.truncate (0);\n-\t\t  goto out;\n-\t\t}\n-\n-\t      /* Distribute stmts which have defs that are used outside of\n-\t\t the loop.  */\n-\t      if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n-\t\t;\n-\t      /* Otherwise only distribute stores for now.  */\n-\t      else if (!gimple_vdef (stmt))\n-\t\tcontinue;\n-\n-\t      work_list.safe_push (stmt);\n-\t    }\n-\t}\n-out:\n-      free (bbs);\n+\t  auto_vec<gimple *> work_list;\n+\t  if (!find_seed_stmts_for_distribution (loop, &work_list))\n+\t    break;\n \n-      int nb_generated_loops = 0;\n-      int nb_generated_calls = 0;\n-      location_t loc = find_loop_location (loop);\n-      if (work_list.length () > 0)\n-\t{\n+\t  const char *str = loop->inner ? \" nest\" : \"\";\n+\t  location_t loc = find_loop_location (loop);\n \t  if (!cd)\n \t    {\n \t      calculate_dominance_info (CDI_DOMINATORS);\n \t      calculate_dominance_info (CDI_POST_DOMINATORS);\n \t      cd = new control_dependences ();\n \t      free_dominance_info (CDI_POST_DOMINATORS);\n \t    }\n+\n \t  bool destroy_p;\n+\t  int nb_generated_loops, nb_generated_calls;\n \t  nb_generated_loops = distribute_loop (loop, work_list, cd,\n \t\t\t\t\t\t&nb_generated_calls,\n \t\t\t\t\t\t&destroy_p);\n \t  if (destroy_p)\n \t    loops_to_be_destroyed.safe_push (loop);\n-\t}\n \n-      if (nb_generated_loops + nb_generated_calls > 0)\n-\t{\n-\t  changed = true;\n-\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS,\n-\t\t\t   loc, \"Loop %d distributed: split to %d loops \"\n-\t\t\t   \"and %d library calls.\\n\",\n-\t\t\t   num, nb_generated_loops, nb_generated_calls);\n+\t  if (nb_generated_loops + nb_generated_calls > 0)\n+\t    {\n+\t      changed = true;\n+\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS,\n+\t\t\t       loc, \"Loop%s %d distributed: split to %d loops \"\n+\t\t\t       \"and %d library calls.\\n\", str, loop->num,\n+\t\t\t       nb_generated_loops, nb_generated_calls);\n+\n+\t      break;\n+\t    }\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Loop%s %d not distributed.\\n\", str, loop->num);\n \t}\n-      else if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Loop %d is the same.\\n\", num);\n     }\n \n   if (cd)"}]}