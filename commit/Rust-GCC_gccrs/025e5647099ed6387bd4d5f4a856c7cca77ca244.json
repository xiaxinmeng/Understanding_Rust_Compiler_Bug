{"sha": "025e5647099ed6387bd4d5f4a856c7cca77ca244", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI1ZTU2NDcwOTllZDYzODdiZDRkNWY0YTg1NmM3Y2NhNzdjYTI0NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-02-23T23:02:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-02-23T23:02:50Z"}, "message": "re PR fortran/63427 (hwint.h:250:29: runtime error: shift exponent 64 is too large for 64-bit type 'long int')\n\ngcc/\n\tPR fortran/63427\n\t* wide-int.cc (wi::from_mpz): Cope with unwrapped values that are\n\ttoo big for a wide_int.  Implement missing wrapping operation.\n\ngcc/testsuite/\n\tPR fortran/63427\n\t* gfortran.dg/integer_exponentiation_6.F90: New test.\n\nFrom-SVN: r220921", "tree": {"sha": "d45ea001d353538ed0b73bde01cbc59ecde404cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d45ea001d353538ed0b73bde01cbc59ecde404cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/025e5647099ed6387bd4d5f4a856c7cca77ca244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025e5647099ed6387bd4d5f4a856c7cca77ca244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/025e5647099ed6387bd4d5f4a856c7cca77ca244", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025e5647099ed6387bd4d5f4a856c7cca77ca244/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8628d6e6502c436e94fecbcbe6770ea56757c18e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8628d6e6502c436e94fecbcbe6770ea56757c18e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8628d6e6502c436e94fecbcbe6770ea56757c18e"}], "stats": {"total": 35, "additions": 31, "deletions": 4}, "files": [{"sha": "0bc898e9e8f3aa4149b732208ae722b92170dfcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=025e5647099ed6387bd4d5f4a856c7cca77ca244", "patch": "@@ -1,3 +1,9 @@\n+2015-02-23  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR fortran/63427\n+\t* wide-int.cc (wi::from_mpz): Cope with unwrapped values that are\n+\ttoo big for a wide_int.  Implement missing wrapping operation.\n+\n 2015-02-23  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/65163"}, {"sha": "ff48d0a8bf3097e8ad2452241ee8d3f6cffc6ad5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=025e5647099ed6387bd4d5f4a856c7cca77ca244", "patch": "@@ -1,3 +1,8 @@\n+2015-02-23  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR fortran/63427\n+\t* gfortran.dg/integer_exponentiation_6.F90: New test.\n+\n 2015-02-23  Martin Sebor  <msebor@redhat.com>\n \n \tPR target/65109"}, {"sha": "55c2543e705034532a727724d62841adb9367b66", "filename": "gcc/testsuite/gfortran.dg/integer_exponentiation_6.F90", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_6.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_6.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finteger_exponentiation_6.F90?ref=025e5647099ed6387bd4d5f4a856c7cca77ca244", "patch": "@@ -0,0 +1,4 @@\n+! { dg-options \"-fno-range-check\" }\n+program test\n+  write (*), (2_8 ** 64009999_8) / 2\n+end program test"}, {"sha": "7662648c20ed1a4ea9a5536a0abf04bc13e6edf2", "filename": "gcc/wide-int.cc", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2Fwide-int.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025e5647099ed6387bd4d5f4a856c7cca77ca244/gcc%2Fwide-int.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.cc?ref=025e5647099ed6387bd4d5f4a856c7cca77ca244", "patch": "@@ -237,7 +237,7 @@ wide_int\n wi::from_mpz (const_tree type, mpz_t x, bool wrap)\n {\n   size_t count, numb;\n-  int prec = TYPE_PRECISION (type);\n+  unsigned int prec = TYPE_PRECISION (type);\n   wide_int res = wide_int::create (prec);\n \n   if (!wrap)\n@@ -261,16 +261,28 @@ wi::from_mpz (const_tree type, mpz_t x, bool wrap)\n      for representing the value.  The code to calculate count is\n      extracted from the GMP manual, section \"Integer Import and Export\":\n      http://gmplib.org/manual/Integer-Import-and-Export.html  */\n-  numb = 8 * sizeof(HOST_WIDE_INT);\n+  numb = CHAR_BIT * sizeof (HOST_WIDE_INT);\n   count = (mpz_sizeinbase (x, 2) + numb - 1) / numb;\n   HOST_WIDE_INT *val = res.write_val ();\n-  mpz_export (val, &count, -1, sizeof (HOST_WIDE_INT), 0, 0, x);\n+  /* Write directly to the wide_int storage if possible, otherwise leave\n+     GMP to allocate the memory for us.  It might be slightly more efficient\n+     to use mpz_tdiv_r_2exp for the latter case, but the situation is\n+     pathological and it seems safer to operate on the original mpz value\n+     in all cases.  */\n+  void *valres = mpz_export (count <= WIDE_INT_MAX_ELTS ? val : 0,\n+\t\t\t     &count, -1, sizeof (HOST_WIDE_INT), 0, 0, x);\n   if (count < 1)\n     {\n       val[0] = 0;\n       count = 1;\n     }\n-  res.set_len (count);\n+  count = MIN (count, BLOCKS_NEEDED (prec));\n+  if (valres != val)\n+    {\n+      memcpy (val, valres, count * sizeof (HOST_WIDE_INT));\n+      free (valres);\n+    }\n+  res.set_len (canonize (val, count, prec));\n \n   if (mpz_sgn (x) < 0)\n     res = -res;"}]}