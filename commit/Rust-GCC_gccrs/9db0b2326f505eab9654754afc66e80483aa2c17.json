{"sha": "9db0b2326f505eab9654754afc66e80483aa2c17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiMGIyMzI2ZjUwNWVhYjk2NTQ3NTRhZmM2NmU4MDQ4M2FhMmMxNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T13:43:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T13:43:01Z"}, "message": "[multiple changes]\n\n2010-10-04  Bob Duff  <duff@adacore.com>\n\n\t* sem_res.adb (Resolve_Type_Conversion): If a type conversion is needed\n\tto make a qualified expression into a name (syntax-wise), then do not\n\tconsider it redundant.\n\n2010-10-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_warn.ads: Fix typo.\n\n2010-10-04  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_cg.adb (Is_Predefined_Dispatching_Operation): Handle suffix in\n\tTSS names.\n\t(Write_Call_Info): Add missing support for renamed primitives.\n\n2010-10-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch5.adb (Make_Field_Expr): New subprogram, to factor duplicated\n\tcode between Make_Component_List_Assign and Make_Field_Assign.\n\n2010-10-04  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Get_Directories): For non extending projects that\n\tdeclare that they have no sources, do not create a non existing object\n\tor exec directory if builder switch -p is used.\n\n2010-10-04  Sergey Rybin  <rybin@adacore.com>\n\n\t* gnat_ugn.texi (gnatcheck): Change the description of the report file\n\tformat.\n\n2010-10-04  Ed Falis  <falis@adacore.com>\n\n\t* s-taprop-vxworks.adb (Is_Task_Context): Import VxWorks intContext to\n\tdetermine whether Set_True is called from a task or an ISR.\n\t(Set_True): test for being in a task context before trying to\n\tdereference Defer_Abort or Undefer_Abort.\n\nFrom-SVN: r164936", "tree": {"sha": "f3aea065193d1bb98ed6910790b88da5c91aee3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3aea065193d1bb98ed6910790b88da5c91aee3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9db0b2326f505eab9654754afc66e80483aa2c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db0b2326f505eab9654754afc66e80483aa2c17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db0b2326f505eab9654754afc66e80483aa2c17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db0b2326f505eab9654754afc66e80483aa2c17/comments", "author": null, "committer": null, "parents": [{"sha": "477bd7327382b6ede20880a808945e4e93ce34a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477bd7327382b6ede20880a808945e4e93ce34a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477bd7327382b6ede20880a808945e4e93ce34a5"}], "stats": {"total": 303, "additions": 198, "deletions": 105}, "files": [{"sha": "c06dd652e2a469faf11ce7f460d96e7dfb84a097", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -1,3 +1,42 @@\n+2010-10-04  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Type_Conversion): If a type conversion is needed\n+\tto make a qualified expression into a name (syntax-wise), then do not\n+\tconsider it redundant.\n+\n+2010-10-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_warn.ads: Fix typo.\n+\n+2010-10-04  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_cg.adb (Is_Predefined_Dispatching_Operation): Handle suffix in\n+\tTSS names.\n+\t(Write_Call_Info): Add missing support for renamed primitives.\n+\n+2010-10-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch5.adb (Make_Field_Expr): New subprogram, to factor duplicated\n+\tcode between Make_Component_List_Assign and Make_Field_Assign.\n+\n+2010-10-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Get_Directories): For non extending projects that\n+\tdeclare that they have no sources, do not create a non existing object\n+\tor exec directory if builder switch -p is used.\n+\n+2010-10-04  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* gnat_ugn.texi (gnatcheck): Change the description of the report file\n+\tformat.\n+\n+2010-10-04  Ed Falis  <falis@adacore.com>\n+\n+\t* s-taprop-vxworks.adb (Is_Task_Context): Import VxWorks intContext to\n+\tdetermine whether Set_True is called from a task or an ISR.\n+\t(Set_True): test for being in a task context before trying to\n+\tdereference Defer_Abort or Undefer_Abort.\n+\n 2010-10-04  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_res.adb, sinput-l.adb: Minor reformatting."}, {"sha": "004cf4495722439f58fd69a2f3b64cc409d7025c", "filename": "gcc/ada/exp_cg.adb", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fexp_cg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fexp_cg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_cg.adb?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -213,8 +213,9 @@ package body Exp_CG is\n \n       --  Local variables\n \n-      Full_Name : constant String := Get_Name_String (Chars (E));\n-      TSS_Name  : TSS_Name_Type;\n+      Full_Name     : constant String := Get_Name_String (Chars (E));\n+      Suffix_Length : Natural         := Homonym_Suffix_Length (E);\n+      TSS_Name      : TSS_Name_Type;\n \n    --  Start of processing for Is_Predefined_Dispatching_Operation\n \n@@ -223,14 +224,31 @@ package body Exp_CG is\n          return False;\n       end if;\n \n+      --  Search for and strip suffix for body-nested package entities\n+\n+      for J in reverse Full_Name'First + 2 .. Full_Name'Last loop\n+         if Full_Name (J) = 'X' then\n+\n+            --  Include the \"X\", \"Xb\", \"Xn\", ... in the part of the\n+            --  suffix to be removed.\n+\n+            Suffix_Length := Suffix_Length + Full_Name'Last - J + 1;\n+            exit;\n+         end if;\n+\n+         exit when Full_Name (J) /= 'b' and then Full_Name (J) /= 'n';\n+      end loop;\n+\n       --  Most predefined primitives have internally generated names. Equality\n       --  must be treated differently; the predefined operation is recognized\n       --  as a homogeneous binary operator that returns Boolean.\n \n       if Full_Name'Length > TSS_Name_Type'Length then\n          TSS_Name :=\n-           TSS_Name_Type (Full_Name (Full_Name'Last - TSS_Name'Length + 1\n-                           .. Full_Name'Last));\n+           TSS_Name_Type\n+             (Full_Name\n+               (Full_Name'Last - TSS_Name'Length - Suffix_Length + 1\n+                  .. Full_Name'Last - Suffix_Length));\n \n          if        TSS_Name = TSS_Stream_Read\n            or else TSS_Name = TSS_Stream_Write\n@@ -273,25 +291,7 @@ package body Exp_CG is\n                                     Name_uDisp_Requeue,\n                                     Name_uDisp_Timed_Select);\n \n-               Suffix_Length : Natural;\n-\n             begin\n-               --  Search for and strip suffix for body-nested package entities\n-\n-               Suffix_Length := Homonym_Suffix_Length (E);\n-               for J in reverse Full_Name'First + 2 .. Full_Name'Last loop\n-                  if Full_Name (J) = 'X' then\n-\n-                     --  Include the \"X\", \"Xb\", \"Xn\", ... in the part of the\n-                     --  suffix to be removed.\n-\n-                     Suffix_Length := Suffix_Length + Full_Name'Last - J + 1;\n-                     exit;\n-                  end if;\n-\n-                  exit when Full_Name (J) /= 'b' and then Full_Name (J) /= 'n';\n-               end loop;\n-\n                for J in Predef_Names_95'Range loop\n                   Get_Name_String (Predef_Names_95 (J));\n \n@@ -476,7 +476,12 @@ package body Exp_CG is\n             (Find_Dispatching_Type (Ultimate_Alias (Prim)),\n              Root_Type (Ctrl_Typ))\n       then\n-         Write_Int (UI_To_Int (Slot_Number (Ultimate_Alias (Prim))));\n+         --  This is a special case in which we generate in the ci file the\n+         --  slot number of the renaming primitive (i.e. Base2) but instead of\n+         --  generating the name of this renaming entity we reference directly\n+         --  the renamed entity (i.e. Base).\n+\n+         Write_Int (UI_To_Int (Slot_Number (Prim)));\n          Write_Char (':');\n          Write_Name\n            (Chars (Find_Dispatching_Type (Ultimate_Alias (Prim))));\n@@ -569,9 +574,10 @@ package body Exp_CG is\n       while Present (Elmt) loop\n          Prim := Node (Elmt);\n \n-         --  Display only primitives overriden or defined\n+         --  Skip internal entities associated with overridden interface\n+         --  primitives\n \n-         if Present (Alias (Prim)) then\n+         if Present (Interface_Alias (Prim)) then\n             goto Continue;\n          end if;\n \n@@ -587,7 +593,14 @@ package body Exp_CG is\n \n          Write_Int (UI_To_Int (Slot_Number (Prim)));\n          Write_Char (':');\n-         Write_Name (Chars (Prim));\n+\n+         --  Handle renamed primitives\n+\n+         if Present (Alias (Prim)) then\n+            Write_Name (Chars (Ultimate_Alias (Prim)));\n+         else\n+            Write_Name (Chars (Prim));\n+         end if;\n \n          --  Display overriding of parent primitives\n "}, {"sha": "7eaa30eda58601238ea3725e01ac70f57ff60229", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -1041,7 +1041,7 @@ package body Exp_Ch5 is\n       --  Note that on the last iteration of the loop, the index is increased\n       --  (or decreased) past the corresponding bound. This is consistent with\n       --  the C semantics of the back-end, where such an off-by-one value on a\n-      --  dead index variable is OK.  However, in CodePeer mode this leads to\n+      --  dead index variable is OK. However, in CodePeer mode this leads to\n       --  spurious warnings, and thus we place a guard around the attribute\n       --  reference. For obvious reasons we only do this for CodePeer.\n \n@@ -1223,6 +1223,13 @@ package body Exp_Ch5 is\n          --  declaration for Typ. We need to use the actual entity because the\n          --  type may be private and resolution by identifier alone would fail.\n \n+         function Make_Field_Expr\n+           (Comp_Ent : Entity_Id;\n+            U_U      : Boolean) return Node_Id;\n+         --  Common processing for one component for Make_Component_List_Assign\n+         --  and Make_Field_Assign. Return the expression to be assigned for\n+         --  component Comp_Ent.\n+\n          function Make_Component_List_Assign\n            (CL  : Node_Id;\n             U_U : Boolean := False) return List_Id;\n@@ -1232,7 +1239,7 @@ package body Exp_Ch5 is\n          --  part expression as the switch for the generated case statement.\n \n          function Make_Field_Assign\n-           (C : Entity_Id;\n+           (C   : Entity_Id;\n             U_U : Boolean := False) return Node_Id;\n          --  Given C, the entity for a discriminant or component, build an\n          --  assignment for the corresponding field values. The flag U_U\n@@ -1282,7 +1289,6 @@ package body Exp_Ch5 is\n             Alts   : List_Id;\n             DC     : Node_Id;\n             DCH    : List_Id;\n-            Expr   : Node_Id;\n             Result : List_Id;\n             V      : Node_Id;\n \n@@ -1308,28 +1314,9 @@ package body Exp_Ch5 is\n                   Next_Non_Pragma (V);\n                end loop;\n \n-               --  If we have an Unchecked_Union, use the value of the inferred\n-               --  discriminant of the variant part expression as the switch\n-               --  for the case statement. The case statement may later be\n-               --  folded.\n-\n-               if U_U then\n-                  Expr :=\n-                    New_Copy (Get_Discriminant_Value (\n-                      Entity (Name (VP)),\n-                      Etype (Rhs),\n-                      Discriminant_Constraint (Etype (Rhs))));\n-               else\n-                  Expr :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix => Duplicate_Subexpr (Rhs),\n-                      Selector_Name =>\n-                        Make_Identifier (Loc, Chars (Name (VP))));\n-               end if;\n-\n                Append_To (Result,\n                  Make_Case_Statement (Loc,\n-                   Expression => Expr,\n+                   Expression   => Make_Field_Expr (Entity (Name (VP)), U_U),\n                    Alternatives => Alts));\n             end if;\n \n@@ -1341,36 +1328,23 @@ package body Exp_Ch5 is\n          -----------------------\n \n          function Make_Field_Assign\n-           (C : Entity_Id;\n+           (C   : Entity_Id;\n             U_U : Boolean := False) return Node_Id\n          is\n             A    : Node_Id;\n-            Expr : Node_Id;\n \n          begin\n             --  In the case of an Unchecked_Union, use the discriminant\n             --  constraint value as on the right hand side of the assignment.\n \n-            if U_U then\n-               Expr :=\n-                 New_Copy (Get_Discriminant_Value (C,\n-                   Etype (Rhs),\n-                   Discriminant_Constraint (Etype (Rhs))));\n-            else\n-               Expr :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix => Duplicate_Subexpr (Rhs),\n-                   Selector_Name => New_Occurrence_Of (C, Loc));\n-            end if;\n-\n             A :=\n               Make_Assignment_Statement (Loc,\n-                Name =>\n+                Name       =>\n                   Make_Selected_Component (Loc,\n-                    Prefix => Duplicate_Subexpr (Lhs),\n+                    Prefix        => Duplicate_Subexpr (Lhs),\n                     Selector_Name =>\n                       New_Occurrence_Of (Find_Component (L_Typ, C), Loc)),\n-                Expression => Expr);\n+                Expression => Make_Field_Expr (C, U_U));\n \n             --  Set Assignment_OK, so discriminants can be assigned\n \n@@ -1395,16 +1369,17 @@ package body Exp_Ch5 is\n             Result : List_Id;\n \n          begin\n-            Item := First (CI);\n             Result := New_List;\n+\n+            Item := First (CI);\n             while Present (Item) loop\n \n                --  Look for components, but exclude _tag field assignment if\n                --  the special Componentwise_Assignment flag is set.\n \n                if Nkind (Item) = N_Component_Declaration\n                  and then not (Is_Tag (Defining_Identifier (Item))\n-                                and then Componentwise_Assignment (N))\n+                                 and then Componentwise_Assignment (N))\n                then\n                   Append_To\n                     (Result, Make_Field_Assign (Defining_Identifier (Item)));\n@@ -1416,6 +1391,32 @@ package body Exp_Ch5 is\n             return Result;\n          end Make_Field_Assigns;\n \n+         ---------------------\n+         -- Make_Field_Expr --\n+         ---------------------\n+\n+         function Make_Field_Expr\n+           (Comp_Ent : Entity_Id;\n+            U_U      : Boolean) return Node_Id\n+         is\n+         begin\n+            --  If we have an Unchecked_Union, use the value of the inferred\n+            --  discriminant of the variant part expression.\n+\n+            if U_U then\n+               return\n+                 New_Copy (Get_Discriminant_Value\n+                   (Comp_Ent,\n+                    Etype (Rhs),\n+                    Discriminant_Constraint (Etype (Rhs))));\n+            else\n+               return\n+                 Make_Selected_Component (Loc,\n+                   Prefix        => Duplicate_Subexpr (Rhs),\n+                   Selector_Name => New_Occurrence_Of (Comp_Ent, Loc));\n+            end if;\n+         end Make_Field_Expr;\n+\n       --  Start of processing for Expand_Assign_Record\n \n       begin"}, {"sha": "eb7a9c55b8c7f946bfbd7b48c16247b7277dfae8", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -17291,21 +17291,24 @@ supplied.\n @cindex Report file (for @code{gnatcheck})\n \n @noindent\n-The @command{gnatcheck} tool outputs on @file{stdout} all messages concerning\n-rule violations.\n-It also creates a text file  that\n-contains the complete report of the last gnatcheck run. By default this file\n-is named named @file{^gnatcheck.out^GNATCHECK.OUT^} and it is located in the\n+The @command{gnatcheck} tool outputs on @file{stderr} all messages concerning\n+rule violations except if running in quiet mode.  It also creates a text file\n+that contains the complete report of the last gnatcheck run. By default this file\n+is named @file{^gnatcheck.out^GNATCHECK.OUT^} and it is located in the\n current directory; the @option{^-o^/OUTPUT^} option can be used to change the\n name and/or location of the report file. This report contains:\n+\n @itemize @bullet\n-@item date and time of @command{gnatcheck} run, the version of\n-the tool that has generated this report and the full parameters\n-of the  @command{gnatcheck} invocation;\n-@item list of enabled rules;\n-@item total number of detected violations;\n-@item list of source files where rule violations have been detected;\n-@item list of source files where no violations have been detected.\n+\n+@item general details of the @command{gnatcheck} run: date and time of the run,\n+the version of the tool that has generated this report, full parameters\n+of the  @command{gnatcheck} invocation, reference to the list of checked\n+sources and applied rules (coding standard);\n+@item summary of the run (number of checked sources and detected violations);\n+@item list of exempted coding standard violations;\n+@item list of non-exempted coding standard violations;\n+@item list of problems in the definition of exemption sections;\n+@item of language violations (compile-time errors) detected in processed sources;\n @end itemize\n \n @node General gnatcheck Switches"}, {"sha": "babb17d69b473dd2a6d04ad983864e6061ee04ca", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -5280,10 +5280,18 @@ package body Prj.Nmsc is\n          Recursive_Dirs.Reset (Visited);\n       end Find_Source_Dirs;\n \n-   --  Start of processing for Get_Directories\n-\n       Dir_Exists : Boolean;\n \n+      No_Sources : constant Boolean :=\n+        (((not Source_Files.Default) and then Source_Files.Values = Nil_String)\n+         or else\n+         ((not Source_Dirs.Default) and then Source_Dirs.Values = Nil_String)\n+         or else\n+         ((not Languages.Default) and then Languages.Values = Nil_String))\n+        and then Project.Extends = No_Project;\n+\n+   --  Start of processing for Get_Directories\n+\n    begin\n       if Current_Verbosity = High then\n          Write_Line (\"Starting to look for directories\");\n@@ -5292,14 +5300,7 @@ package body Prj.Nmsc is\n       --  Set the object directory to its default which may be nil, if there\n       --  is no sources in the project.\n \n-      if (((not Source_Files.Default)\n-             and then Source_Files.Values = Nil_String)\n-          or else\n-           ((not Source_Dirs.Default) and then Source_Dirs.Values = Nil_String)\n-              or else\n-           ((not Languages.Default) and then Languages.Values = Nil_String))\n-        and then Project.Extends = No_Project\n-      then\n+      if No_Sources then\n          Project.Object_Directory := No_Path_Information;\n       else\n          Project.Object_Directory := Project.Directory;\n@@ -5316,7 +5317,7 @@ package body Prj.Nmsc is\n                \"Object_Dir cannot be empty\",\n                Object_Dir.Location, Project);\n \n-         else\n+         elsif not No_Sources then\n             --  We check that the specified object directory does exist.\n             --  However, even when it doesn't exist, we set it to a default\n             --  value. This is for the benefit of tools that recover from\n@@ -5348,9 +5349,7 @@ package body Prj.Nmsc is\n             end if;\n          end if;\n \n-      elsif Project.Object_Directory /= No_Path_Information\n-        and then Subdirs /= null\n-      then\n+      elsif not No_Sources and then Subdirs /= null then\n          Name_Len := 1;\n          Name_Buffer (1) := '.';\n          Locate_Directory\n@@ -5389,7 +5388,7 @@ package body Prj.Nmsc is\n                \"Exec_Dir cannot be empty\",\n                Exec_Dir.Location, Project);\n \n-         else\n+         elsif not No_Sources then\n             --  We check that the specified exec directory does exist\n \n             Locate_Directory"}, {"sha": "7380edd46b7265b29b0d54ca3eeb9d843d7ab581", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -163,6 +163,10 @@ package body System.Task_Primitives.Operations is\n    procedure Install_Signal_Handlers;\n    --  Install the default signal handlers for the current task\n \n+   function Is_Task_Context return Boolean;\n+   --  This function returns True if the current execution is in the context\n+   --  of a task, and False if it is an interrupt context.\n+\n    function To_Address is\n      new Ada.Unchecked_Conversion (Task_Id, System.Address);\n \n@@ -1095,7 +1099,12 @@ package body System.Task_Primitives.Operations is\n       Result : STATUS;\n \n    begin\n-      SSL.Abort_Defer.all;\n+\n+      --  Set_True can be called from an interrupt context, in which case\n+      --  Abort_Defer is undefined.\n+      if Is_Task_Context then\n+         SSL.Abort_Defer.all;\n+      end if;\n \n       Result := semTake (S.L, WAIT_FOREVER);\n       pragma Assert (Result = OK);\n@@ -1118,7 +1127,12 @@ package body System.Task_Primitives.Operations is\n       Result := semGive (S.L);\n       pragma Assert (Result = OK);\n \n-      SSL.Abort_Undefer.all;\n+      --  Set_True can be called from an interrupt context, in which case\n+      --  Abort_Undefer is undefined.\n+      if Is_Task_Context then\n+         SSL.Abort_Undefer.all;\n+      end if;\n+\n    end Set_True;\n \n    ------------------------\n@@ -1316,6 +1330,19 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Continue_Task;\n \n+   ---------------------\n+   -- Is_Task_Context --\n+   ---------------------\n+\n+   function Is_Task_Context return Boolean is\n+      function intContext return int;\n+      --  Binding to the C routine intContext. This function returns 1 only\n+      --  if the current execution state is an interrupt context.\n+      pragma Import (C, intContext, \"intContext\");\n+   begin\n+      return intContext /= 1;\n+   end Is_Task_Context;\n+\n    ----------------\n    -- Initialize --\n    ----------------"}, {"sha": "23107cb37bb8aacd9ce3e3ddcee58914345b58cb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -8843,15 +8843,26 @@ package body Sem_Res is\n             then\n                null;\n \n-            --  Finally, the expression may be a qualified expression whose\n-            --  own expression is a possibly overloaded function call. The\n-            --  qualified expression is needed to be disambiguate the call,\n-            --  but it appears in a context in which a name is needed, forcing\n-            --  the use of a conversion. In Ada 2012, a qualified expression is\n-            --  a name, and this idiom is no longer needed.\n+            --  Finally, if this type conversion occurs in a context that\n+            --  requires a prefix, and the expression is a qualified\n+            --  expression, then the type conversion is not redundant,\n+            --  because a qualified expression is not a prefix, whereas a\n+            --  type conversion is. For example, \"X := T'(Funx(...)).Y;\" is\n+            --  illegal. because a selected component requires a prefix, but\n+            --  a type conversion makes it legal: \"X := T(T'(Funx(...))).Y;\"\n+            --  In Ada 2012, a qualified expression is a name, so this idiom is\n+            --  no longer needed, but we still suppress the warning because it\n+            --  seems unfriendly for warnings to pop up when you switch to the\n+            --  newer language version.\n \n             elsif Nkind (Orig_N) = N_Qualified_Expression\n-              and then Nkind (Expression (Orig_N)) = N_Function_Call\n+              and then Nkind_In\n+                         (Parent (N),\n+                          N_Attribute_Reference,\n+                          N_Indexed_Component,\n+                          N_Selected_Component,\n+                          N_Slice,\n+                          N_Explicit_Dereference)\n             then\n                null;\n "}, {"sha": "635629375dc48dbe7807efdcafc7d2bd6147f1bc", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db0b2326f505eab9654754afc66e80483aa2c17/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=9db0b2326f505eab9654754afc66e80483aa2c17", "patch": "@@ -50,7 +50,7 @@ package Sem_Warn is\n    Warn_On_Overridden_Size : Boolean := False;\n    --  Warn when explicit record component clause or array component_size\n    --  clause specifies a size that overrides a size for the typen which was\n-   --  set with an explicit size clause. Off by default, set by -gnatw.sn (but\n+   --  set with an explicit size clause. Off by default, set by -gnatw.s (but\n    --  not -gnatwa).\n \n    ------------------------"}]}