{"sha": "5b281141747654449a2a93689d317743d4743078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIyODExNDE3NDc2NTQ0NDlhMmE5MzY4OWQzMTc3NDNkNDc0MzA3OA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2007-05-29T01:01:32Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2007-05-29T01:01:32Z"}, "message": "constraints.md: New file.\n\n\t* pa/constraints.md: New file.\n\t* pa.md: Include constraints.md.\n\t* pa.c (cint_ok_for_move): Avoid using CONST_OK_FOR_LETTER_P.\n\t(integer_store_memory_operand, ldil_cint_p): New functions.\n\t* pa-protos.h (integer_store_memory_operand, ldil_cint_p): Declare.\n\t* pa.h (CONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_LETTER_P,\n\tIS_RELOADING_PSEUDO_P, EXTRA_CONSTRAINT): Remove.\n\t* pa32-regs.h (REG_CLASS_FROM_LETTER): Remove.\n\t* pa64-regs.h (REG_CLASS_FROM_LETTER): Remove.\n\nFrom-SVN: r125157", "tree": {"sha": "e886e61306c63f3c3000ebd600ac44bebf5462b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e886e61306c63f3c3000ebd600ac44bebf5462b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b281141747654449a2a93689d317743d4743078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b281141747654449a2a93689d317743d4743078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b281141747654449a2a93689d317743d4743078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b281141747654449a2a93689d317743d4743078/comments", "author": null, "committer": null, "parents": [{"sha": "a87db577fbb1b87486527c98b44727991ee998b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87db577fbb1b87486527c98b44727991ee998b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87db577fbb1b87486527c98b44727991ee998b4"}], "stats": {"total": 336, "additions": 193, "deletions": 143}, "files": [{"sha": "7a2f9fc57c396b6fbd711a5ebbbf6517d2c5afd9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -1,3 +1,15 @@\n+2007-05-28  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa/constraints.md: New file.\n+\t* pa.md: Include constraints.md.\n+\t* pa.c (cint_ok_for_move): Avoid using CONST_OK_FOR_LETTER_P.\n+\t(integer_store_memory_operand, ldil_cint_p): New functions.\n+\t* pa-protos.h (integer_store_memory_operand, ldil_cint_p): Declare.\n+\t* pa.h (CONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_LETTER_P,\n+\tIS_RELOADING_PSEUDO_P, EXTRA_CONSTRAINT): Remove.\n+\t* pa32-regs.h (REG_CLASS_FROM_LETTER): Remove.\n+\t* pa64-regs.h (REG_CLASS_FROM_LETTER): Remove.\n+\n 2007-05-28  Andrew Pinski  <Andrew_pinski@playstation.sony.com>\n \n \tPR c/31339"}, {"sha": "d387d040e788ae6fc7942809c9e282918d0f0867", "filename": "gcc/config/pa/constraints.md", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fconstraints.md?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -0,0 +1,141 @@\n+;; Constraint definitions for pa\n+;; Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;;; Unused letters:\n+;;;    ABCDEF H             V XY \n+;;;     bcde ghijklmnop  stuvw  z\n+\n+;; Register constraints.\n+(define_register_constraint \"a\" \"R1_REGS\"\n+  \"General register 1.\")\n+\n+(define_register_constraint \"f\" \"FP_REGS\"\n+  \"Floating-point register.\")\n+\n+(define_register_constraint \"q\" \"SHIFT_REGS\"\n+  \"Shift amount register.\")\n+\n+;; Keep 'x' for backward compatibility with user asm.\n+(define_register_constraint \"x\" \"FP_REGS\"\n+  \"Floating-point register.\")\n+\n+(define_register_constraint \"y\" \"TARGET_64BIT ? FP_REGS : FPUPPER_REGS\"\n+  \"Upper floating-point register.\")\n+\n+(define_register_constraint \"Z\" \"ALL_REGS\"\n+  \"Any register.\")\n+\n+;; Integer constant constraints.\n+(define_constraint \"I\"\n+  \"Signed 11-bit integer constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"VAL_11_BITS_P (ival)\")))\n+\n+(define_constraint \"J\"\n+  \"Signed 14-bit integer constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"VAL_14_BITS_P (ival)\")))\n+\n+(define_constraint \"K\"\n+  \"Integer constant that can be deposited with a zdepi instruction.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"zdepi_cint_p (ival)\")))\n+\n+(define_constraint \"L\"\n+  \"Signed 5-bit integer constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"VAL_5_BITS_P (ival)\")))\n+\n+(define_constraint \"M\"\n+  \"Integer constant 0.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"N\"\n+  \"Integer constant that can be loaded with a ldil instruction.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ldil_cint_p (ival)\")))\n+\n+(define_constraint \"O\"\n+  \"Integer constant such that ival+1 is a power of 2.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & (ival + 1)) == 0\")))\n+\n+(define_constraint \"P\"\n+  \"Integer constant that can be used as an and mask in depi and\n+   extru instructions.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"and_mask_p (ival)\")))\n+\n+(define_constraint \"S\"\n+  \"Integer constant 31.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 31\")))\n+\n+(define_constraint \"U\"\n+  \"Integer constant 63.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 63\")))\n+\n+;; Floating-point constant constraints.\n+(define_constraint \"G\"\n+  \"Floating-point constant 0.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t\t    && op == CONST0_RTX (mode)\")))\n+\n+;; Extra constraints.\n+(define_constraint \"A\"\n+  \"A LO_SUM DLT memory operand.\"\n+  (and (match_code \"mem\")\n+       (match_test \"IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\")))\n+\n+(define_constraint \"Q\"\n+  \"A memory operand that can be used as the destination operand of an\n+   integer store, or the source operand of an integer load.  That is\n+   any memory operand that isn't a symbolic, indexed or lo_sum memory\n+   operand.  Note that an unassigned pseudo register is such a memory\n+   operand.  We accept unassigned pseudo registers because reload\n+   generates them and then doesn't re-recognize the insn, causing\n+   constrain_operands to fail.\"\n+  (match_test \"integer_store_memory_operand (op, mode)\"))\n+\n+(define_constraint \"R\"\n+  \"A scaled or unscaled indexed memory operand that can be used as the\n+   source address in integer and floating-point loads.\"\n+  (and (match_code \"mem\")\n+       (match_test \"IS_INDEX_ADDR_P (XEXP (op, 0))\")))\n+\n+(define_constraint \"T\"\n+  \"A memory operand for floating-point loads and stores.\"\n+  (and (match_code \"mem\")\n+       (match_test \"!IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n+\t\t    && !IS_INDEX_ADDR_P (XEXP (op, 0))\n+\t\t    && memory_address_p ((GET_MODE_SIZE (mode) == 4\n+\t\t\t\t\t  ? SFmode : DFmode),\n+\t\t\t\t\t XEXP (op, 0))\")))\n+\n+;; We could allow short displacements but GO_IF_LEGITIMATE_ADDRESS\n+;; can't tell when a long displacement is valid.\n+(define_constraint \"W\"\n+  \"A register indirect memory operand.\"\n+  (and (match_code \"mem\")\n+       (match_test \"REG_P (XEXP (op, 0))\n+\t\t    && REG_OK_FOR_BASE_P (XEXP (op, 0))\")))"}, {"sha": "8d601828c5dace2c9f2f5c61e0d3295a98eb8320", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -133,7 +133,8 @@ extern int insn_refs_are_delayed (rtx);\n extern rtx get_deferred_plabel (rtx);\n #endif /* RTX_CODE */\n \n-/* Prototype function used in macro CONST_OK_FOR_LETTER_P.  */\n+extern int integer_store_memory_operand (rtx, enum machine_mode);\n+extern int ldil_cint_p (HOST_WIDE_INT);\n extern int zdepi_cint_p (unsigned HOST_WIDE_INT);\n \n extern void override_options (void);"}, {"sha": "f0a894a91ff106cb2d134f8f64b78a118388aa27", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -558,12 +558,12 @@ symbolic_expression_p (rtx x)\n /* Accept any constant that can be moved in one instruction into a\n    general register.  */\n int\n-cint_ok_for_move (HOST_WIDE_INT intval)\n+cint_ok_for_move (HOST_WIDE_INT ival)\n {\n   /* OK if ldo, ldil, or zdepi, can be used.  */\n-  return (CONST_OK_FOR_LETTER_P (intval, 'J')\n-\t  || CONST_OK_FOR_LETTER_P (intval, 'N')\n-\t  || CONST_OK_FOR_LETTER_P (intval, 'K'));\n+  return (VAL_14_BITS_P (ival)\n+\t  || ldil_cint_p (ival)\n+\t  || zdepi_cint_p (ival));\n }\n \f\n /* Return truth value of whether OP can be used as an operand in a\n@@ -576,6 +576,36 @@ adddi3_operand (rtx op, enum machine_mode mode)\n \t      && (TARGET_64BIT ? INT_14_BITS (op) : INT_11_BITS (op))));\n }\n \n+/* True iff the operand OP can be used as the destination operand of\n+   an integer store.  This also implies the operand could be used as\n+   the source operand of an integer load.  Symbolic, lo_sum and indexed\n+   memory operands are not allowed.  We accept reloading pseudos and\n+   other memory operands.  */\n+int\n+integer_store_memory_operand (rtx op, enum machine_mode mode)\n+{\n+  return ((reload_in_progress\n+\t   && REG_P (op)\n+\t   && REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t   && reg_renumber [REGNO (op)] < 0)\n+\t  || (GET_CODE (op) == MEM\n+\t      && (reload_in_progress || memory_address_p (mode, XEXP (op, 0)))\n+\t      && !symbolic_memory_operand (op, VOIDmode)\n+\t      && !IS_LO_SUM_DLT_ADDR_P (XEXP (op, 0))\n+\t      && !IS_INDEX_ADDR_P (XEXP (op, 0))));\n+}\n+\n+/* True iff ldil can be used to load this CONST_INT.  The least\n+   significant 11 bits of the value must be zero and the value must\n+   not change sign when extended from 32 to 64 bits.  */\n+int\n+ldil_cint_p (HOST_WIDE_INT ival)\n+{\n+  HOST_WIDE_INT x = ival & (((HOST_WIDE_INT) -1 << 31) | 0x7ff);\n+\n+  return x == 0 || x == ((HOST_WIDE_INT) -1 << 31);\n+}\n+\n /* True iff zdepi can be used to generate this CONST_INT.\n    zdepi first sign extends a 5-bit signed number to a given field\n    length, then places this field anywhere in a zero.  */"}, {"sha": "d4e31c7df8beac2e6f1a5b18b46e2305be5108e6", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 116, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -481,45 +481,6 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n       }\t\t\t\t\t\t\t\t\t\\\n     } while (0)\n \f\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   `I' is used for the 11-bit constants.\n-   `J' is used for the 14-bit constants.\n-   `K' is used for values that can be moved with a zdepi insn.\n-   `L' is used for the 5-bit constants.\n-   `M' is used for 0.\n-   `N' is used for values with the least significant 11 bits equal to zero\n-\t                  and when sign extended from 32 to 64 bits the\n-\t\t\t  value does not change.\n-   `O' is used for numbers n such that n+1 is a power of 2.\n-   */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? VAL_11_BITS_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'J' ? VAL_14_BITS_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'K' ? zdepi_cint_p (VALUE)\t\t\t\t\t\\\n-   : (C) == 'L' ? VAL_5_BITS_P (VALUE)\t\t\t\t\t\\\n-   : (C) == 'M' ? (VALUE) == 0\t\t\t\t\t\t\\\n-   : (C) == 'N' ? (((VALUE) & (((HOST_WIDE_INT) -1 << 31) | 0x7ff)) == 0 \\\n-\t\t   || (((VALUE) & (((HOST_WIDE_INT) -1 << 31) | 0x7ff))\t\\\n-\t\t       == (HOST_WIDE_INT) -1 << 31))\t\t\t\\\n-   : (C) == 'O' ? (((VALUE) & ((VALUE) + 1)) == 0)\t\t\t\\\n-   : (C) == 'P' ? and_mask_p (VALUE)\t\t\t\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating or large integer constants, and defining letters\n-   G and H.   Here VALUE is the CONST_DOUBLE rtx itself.\n-\n-   For PA, `G' is the floating-point constant zero.  `H' is undefined.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \t\t\t\\\n-  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\\\n-\t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n-   : 0)\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n@@ -1145,15 +1106,7 @@ extern int may_call_alloca;\n #define SYMBOL_REF_REFERENCED_P(RTX) \\\n   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_REFERENCED) != 0)\n \n-/* Subroutines for EXTRA_CONSTRAINT.\n-\n-   Return 1 iff OP is a pseudo which did not get a hard register and\n-   we are running the reload pass.  */\n-#define IS_RELOADING_PSEUDO_P(OP) \\\n-  ((reload_in_progress\t\t\t\t\t\\\n-    && GET_CODE (OP) == REG\t\t\t\t\\\n-    && REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n-    && reg_renumber [REGNO (OP)] < 0))\n+/* Defines for constraints.md.  */\n \n /* Return 1 iff OP is a scaled or unscaled index address.  */\n #define IS_INDEX_ADDR_P(OP) \\\n@@ -1172,74 +1125,6 @@ extern int may_call_alloca;\n    && REG_OK_FOR_BASE_P (XEXP (OP, 0))\t\t\t\\\n    && GET_CODE (XEXP (OP, 1)) == UNSPEC)\n \n-/* Optional extra constraints for this machine. Borrowed from sparc.h.\n-\n-   `A' is a LO_SUM DLT memory operand.\n-\n-   `Q' is any memory operand that isn't a symbolic, indexed or lo_sum\n-       memory operand.  Note that an unassigned pseudo register is such a\n-       memory operand.  Needed because reload will generate these things\n-       and then not re-recognize the insn, causing constrain_operands to\n-       fail.\n-\n-   `R' is a scaled/unscaled indexed memory operand.\n-\n-   `S' is the constant 31.\n-\n-   `T' is for floating-point loads and stores.\n-\n-   `U' is the constant 63.\n-\n-   `W' is a register indirect memory operand.  We could allow short\n-       displacements but GO_IF_LEGITIMATE_ADDRESS can't tell when a\n-       long displacement is valid.  This is only used for prefetch\n-       instructions with the `sl' completer.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C) \\\n-  ((C) == 'Q' ?\t\t\t\t\t\t\t\t\\\n-   (IS_RELOADING_PSEUDO_P (OP)\t\t\t\t\t\t\\\n-    || (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n-\t&& (reload_in_progress\t\t\t\t\t\t\\\n-\t    || memory_address_p (GET_MODE (OP), XEXP (OP, 0)))\t\t\\\n-\t&& !symbolic_memory_operand (OP, VOIDmode)\t\t\t\\\n-\t&& !IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n-\t&& !IS_INDEX_ADDR_P (XEXP (OP, 0))))\t\t\t\t\\\n-   : ((C) == 'W' ?\t\t\t\t\t\t\t\\\n-      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n-       && REG_P (XEXP (OP, 0))\t\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\t\t\\\n-   : ((C) == 'A' ?\t\t\t\t\t\t\t\\\n-      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n-       && IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0)))\t\t\t\t\\\n-   : ((C) == 'R' ?\t\t\t\t\t\t\t\\\n-      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n-       && IS_INDEX_ADDR_P (XEXP (OP, 0)))\t\t\t\t\\\n-   : ((C) == 'T' ? \t\t\t\t\t\t\t\\\n-      (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n-       && !IS_LO_SUM_DLT_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n-       && !IS_INDEX_ADDR_P (XEXP (OP, 0))\t\t\t\t\\\n-       /* Floating-point loads and stores are used to load\t\t\\\n-\t  integer values as well as floating-point values.\t\t\\\n-\t  They don't have the same set of REG+D address modes\t\t\\\n-\t  as integer loads and stores.  PA 1.x supports only\t\t\\\n-\t  short displacements.  PA 2.0 supports long displacements\t\\\n-\t  but the base register needs to be aligned.\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  The checks in GO_IF_LEGITIMATE_ADDRESS for SFmode and\t\t\\\n-\t  DFmode test the validity of an address for use in a\t\t\\\n-\t  floating point load or store.  So, we use SFmode/DFmode\t\\\n-\t  to see if the address is valid for a floating-point\t\t\\\n-\t  load/store operation.  */\t\t\t\t\t\\\n-       && memory_address_p ((GET_MODE_SIZE (GET_MODE (OP)) == 4\t\t\\\n-\t\t\t     ? SFmode\t\t\t\t\t\\\n-\t\t\t     : DFmode),\t\t\t\t\t\\\n-\t\t\t    XEXP (OP, 0)))\t\t\t\t\\\n-   : ((C) == 'S' ?\t\t\t\t\t\t\t\\\n-      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 31)\t\t\t\\\n-   : ((C) == 'U' ?\t\t\t\t\t\t\t\\\n-      (GET_CODE (OP) == CONST_INT && INTVAL (OP) == 63) : 0)))))))\n-\t\n-\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them."}, {"sha": "807e1ce53ff5bec438192c59a5acbeaa29f4d019", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -636,7 +636,10 @@\n    (eq_attr \"cpu\" \"8000\"))\n  \"inm_8000,fdivsqrt_8000*6,rnm_8000\")\n \n+;; Operand and operator predicates and constraints\n+\n (include \"predicates.md\")\n+(include \"constraints.md\")\n \f\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation."}, {"sha": "782ad8d5f5c905b7150718cf1a2a58002101d58a", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -300,16 +300,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n    : (REGNO) < 88 ? FPUPPER_REGS\t\t\t\t\t\\\n    : SHIFT_REGS)\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n-/* Keep 'x' for backward compatibility with user asm.  */\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS :\t\t\t\t\t\\\n-   (C) == 'y' ? FPUPPER_REGS :\t\t\t\t\t\\\n-   (C) == 'x' ? FP_REGS :\t\t\t\t\t\\\n-   (C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n-   (C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n-   (C) == 'Z' ? ALL_REGS : NO_REGS)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\"}, {"sha": "26986e8bedc7ad321f058b5eebc4e1c22dc62616", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b281141747654449a2a93689d317743d4743078/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=5b281141747654449a2a93689d317743d4743078", "patch": "@@ -266,18 +266,6 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n    : (REGNO) < 60 ? FP_REGS\t\t\t\t\t\t\\\n    : SHIFT_REGS)\n \n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-/* Keep 'x' for backward compatibility with user asm.  */\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS :\t\t\t\t\t\\\n-   (C) == 'y' ? FP_REGS :\t\t\t\t\t\\\n-   (C) == 'x' ? FP_REGS :\t\t\t\t\t\\\n-   (C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n-   (C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n-   (C) == 'Z' ? ALL_REGS : NO_REGS)\n-\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\"}]}