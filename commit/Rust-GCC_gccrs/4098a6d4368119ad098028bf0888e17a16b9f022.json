{"sha": "4098a6d4368119ad098028bf0888e17a16b9f022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA5OGE2ZDQzNjgxMTlhZDA5ODAyOGJmMDg4OGUxN2ExNmI5ZjAyMg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2018-12-23T10:43:59Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2018-12-23T10:43:59Z"}, "message": "use simple-object instead of nm to determine if files contain LTO.\n\nThis replaces the use of nm to search for the LTO common symbol marker\nand uses simple object to see if there's a section starting with\n\".gnu.lto_.\" or \".gnu.offload_lto_\"\n\n2018-12-23  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* collect2.c (maybe_run_lto_and_relink): Don\u2019t say we have a temp file\n\tunless we actually did some LTO.\n\t(has_lto_section, is_lto_object_file): New.\n\t(maybe_lto_object_file): Remove.\n\t(scan_prog_file): Use is_lto_object_file() instead of scanning the\n\toutput of nm.\n\nFrom-SVN: r267371", "tree": {"sha": "ffa042a1864822a16b8307e99a6930b3ff94855f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffa042a1864822a16b8307e99a6930b3ff94855f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4098a6d4368119ad098028bf0888e17a16b9f022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4098a6d4368119ad098028bf0888e17a16b9f022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4098a6d4368119ad098028bf0888e17a16b9f022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4098a6d4368119ad098028bf0888e17a16b9f022/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "513825f06b561ceb7040f04fbf138a9e9c23a813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/513825f06b561ceb7040f04fbf138a9e9c23a813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/513825f06b561ceb7040f04fbf138a9e9c23a813"}], "stats": {"total": 129, "additions": 66, "deletions": 63}, "files": [{"sha": "3691e65860e75d2e332163af544d4b21bd6970f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4098a6d4368119ad098028bf0888e17a16b9f022/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4098a6d4368119ad098028bf0888e17a16b9f022/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4098a6d4368119ad098028bf0888e17a16b9f022", "patch": "@@ -1,3 +1,12 @@\n+2018-12-23  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* collect2.c (maybe_run_lto_and_relink): Don\u2019t say we have a temp file\n+\tunless we actually did some LTO.\n+\t(has_lto_section, is_lto_object_file): New.\n+\t(maybe_lto_object_file): Remove.\n+\t(scan_prog_file): Use is_lto_object_file() instead of scanning the\n+\toutput of nm.\n+\n 2018-12-23  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* collect2.c (main): Parse the output file early so we can make nicer"}, {"sha": "dcbd3e18a65776b15c455d291389adeaf8628f1e", "filename": "gcc/collect2.c", "status": "modified", "additions": 57, "deletions": 63, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4098a6d4368119ad098028bf0888e17a16b9f022/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4098a6d4368119ad098028bf0888e17a16b9f022/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=4098a6d4368119ad098028bf0888e17a16b9f022", "patch": "@@ -30,6 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"filenames.h\"\n #include \"file-find.h\"\n+#include \"simple-object.h\"\n+#include \"lto-section-names.h\"\n \n /* TARGET_64BIT may be defined to use driver specific functionality. */\n #undef TARGET_64BIT\n@@ -804,7 +806,9 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n       /* Run the linker again, this time replacing the object files\n          optimized by the LTO with the temporary file generated by the LTO.  */\n       fork_execute (\"ld\", out_lto_ld_argv, HAVE_GNU_LD && at_file_supplied);\n-      post_ld_pass (true);\n+      /* We assume that temp files were created, and therefore we need to take\n+         that into account (maybe run dsymutil).  */\n+      post_ld_pass (/*temp_file*/true);\n       free (lto_ld_argv);\n \n       maybe_unlink_list (lto_o_files);\n@@ -814,10 +818,11 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n       /* Our caller is relying on us to do the link\n          even though there is no LTO back end work to be done.  */\n       fork_execute (\"ld\", lto_ld_argv, HAVE_GNU_LD && at_file_supplied);\n-      post_ld_pass (false);\n+      /* No LTO objects were found, so no new temp file.  */\n+      post_ld_pass (/*temp_file*/false);\n     }\n   else\n-    post_ld_pass (true);\n+    post_ld_pass (false); /* No LTO objects were found, no temp file.  */\n }\n \f\n /* Main program.  */\n@@ -1710,7 +1715,7 @@ main (int argc, char **argv)\n \tif (lto_mode != LTO_MODE_NONE)\n \t  maybe_run_lto_and_relink (ld1_argv, object_lst, object, false);\n \telse\n-\t  post_ld_pass (false);\n+\t  post_ld_pass (/*temp_file*/false);\n \n \treturn 0;\n       }\n@@ -1780,7 +1785,7 @@ main (int argc, char **argv)\n #ifdef COLLECT_EXPORT_LIST\n       maybe_unlink (export_file);\n #endif\n-      post_ld_pass (false);\n+      post_ld_pass (/*temp_file*/false);\n \n       maybe_unlink (c_file);\n       maybe_unlink (o_file);\n@@ -1874,7 +1879,7 @@ main (int argc, char **argv)\n   else\n     {\n       fork_execute (\"ld\", ld2_argv, HAVE_GNU_LD && at_file_supplied);\n-      post_ld_pass (false);\n+      post_ld_pass (/*temp_file*/false);\n     }\n \n   /* Let scan_prog_file do any final mods (OSF/rose needs this for\n@@ -2332,38 +2337,52 @@ write_aix_file (FILE *stream, struct id *list)\n \n /* Check to make sure the file is an LTO object file.  */\n \n+static int\n+has_lto_section (void *data, const char *name ATTRIBUTE_UNUSED,\n+\t\t off_t offset ATTRIBUTE_UNUSED,\n+\t\t off_t length ATTRIBUTE_UNUSED)\n+{\n+  int *found = (int *) data;\n+\n+  if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n+\t       sizeof (LTO_SECTION_NAME_PREFIX) - 1) != 0)\n+    {\n+      if (strncmp (name, OFFLOAD_SECTION_NAME_PREFIX,\n+\t           sizeof (OFFLOAD_SECTION_NAME_PREFIX) - 1) != 0)\n+        return 1;\n+    }\n+\n+  *found = 1;\n+\n+  /* Stop iteration.  */\n+  return 0;\n+}\n+\n static bool\n-maybe_lto_object_file (const char *prog_name)\n+is_lto_object_file (const char *prog_name)\n {\n-  FILE *f;\n-  unsigned char buf[4];\n-  int i;\n+  const char *errmsg;\n+  int err;\n+  int found = 0;\n+  off_t inoff = 0;\n+  int infd = open (prog_name, O_RDONLY | O_BINARY);\n \n-  static unsigned char elfmagic[4] = { 0x7f, 'E', 'L', 'F' };\n-  static unsigned char coffmagic[2] = { 0x4c, 0x01 };\n-  static unsigned char coffmagic_x64[2] = { 0x64, 0x86 };\n-  static unsigned char machomagic[4][4] = {\n-    { 0xcf, 0xfa, 0xed, 0xfe },\n-    { 0xce, 0xfa, 0xed, 0xfe },\n-    { 0xfe, 0xed, 0xfa, 0xcf },\n-    { 0xfe, 0xed, 0xfa, 0xce }\n-  };\n+  if (infd == -1)\n+    return false;\n \n-  f = fopen (prog_name, \"rb\");\n-  if (f == NULL)\n+  simple_object_read *inobj = simple_object_start_read (infd, inoff,\n+\t\t\t\t\t\t\tLTO_SEGMENT_NAME,\n+\t\t\t\t\t\t\t&errmsg, &err);\n+  if (!inobj)\n     return false;\n-  if (fread (buf, sizeof (buf), 1, f) != 1)\n-    buf[0] = 0;\n-  fclose (f);\n \n-  if (memcmp (buf, elfmagic, sizeof (elfmagic)) == 0\n-      || memcmp (buf, coffmagic, sizeof (coffmagic)) == 0\n-      || memcmp (buf, coffmagic_x64, sizeof (coffmagic_x64)) == 0)\n+  errmsg = simple_object_find_sections (inobj, has_lto_section,\n+\t\t\t\t\t(void *) &found, &err);\n+  if (! errmsg && found)\n     return true;\n-  for (i = 0; i < 4; i++)\n-    if (memcmp (buf, machomagic[i], sizeof (machomagic[i])) == 0)\n-      return true;\n \n+  if (errmsg)\n+    fatal_error (0, \"%s: %s\\n\", errmsg, xstrerror (err));\n   return false;\n }\n \n@@ -2386,16 +2405,20 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n   int err;\n   char *p, buf[1024];\n   FILE *inf;\n-  int found_lto = 0;\n \n   if (which_pass == PASS_SECOND)\n     return;\n \n   /* LTO objects must be in a known format.  This check prevents\n      us from accepting an archive containing LTO objects, which\n      gcc cannot currently handle.  */\n-  if (which_pass == PASS_LTOINFO && !maybe_lto_object_file (prog_name))\n-    return;\n+  if (which_pass == PASS_LTOINFO)\n+    {\n+      if(is_lto_object_file (prog_name)) {\n+\tadd_lto_object (&lto_objects, prog_name);\n+      }\n+      return;\n+    }\n \n   /* If we do not have an `nm', complain.  */\n   if (nm_file_name == 0)\n@@ -2450,12 +2473,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n     fatal_error (input_location, \"can't open nm output: %m\");\n \n   if (debug)\n-    {\n-      if (which_pass == PASS_LTOINFO)\n-        fprintf (stderr, \"\\nnm output with LTO info marker symbol.\\n\");\n-      else\n-        fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n-    }\n+    fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n \n   /* Read each line of nm output.  */\n   while (fgets (buf, sizeof buf, inf) != (char *) 0)\n@@ -2466,30 +2484,6 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n       if (debug)\n         fprintf (stderr, \"\\t%s\\n\", buf);\n \n-      if (which_pass == PASS_LTOINFO)\n-        {\n-          if (found_lto)\n-            continue;\n-\n-          /* Look for the LTO info marker symbol, and add filename to\n-             the LTO objects list if found.  */\n-          for (p = buf; (ch = *p) != '\\0' && ch != '\\n'; p++)\n-            if (ch == ' '  && p[1] == '_' && p[2] == '_'\n-\t\t&& (strncmp (p + (p[3] == '_' ? 2 : 1), \"__gnu_lto_v1\", 12) == 0)\n-\t\t&& ISSPACE (p[p[3] == '_' ? 14 : 13]))\n-              {\n-                add_lto_object (&lto_objects, prog_name);\n-\n-                /* We need to read all the input, so we can't just\n-                   return here.  But we can avoid useless work.  */\n-                found_lto = 1;\n-\n-                break;\n-              }\n-\n-\t  continue;\n-        }\n-\n       /* If it contains a constructor or destructor name, add the name\n \t to the appropriate list unless this is a kind of symbol we're\n \t not supposed to even consider.  */"}]}