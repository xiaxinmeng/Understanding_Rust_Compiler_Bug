{"sha": "cd4dd47265f2bff89fbbfb6a12a98a7101fb5280", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q0ZGQ0NzI2NWYyYmZmODlmYmJmYjZhMTJhOThhNzEwMWZiNTI4MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T15:54:45Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T15:56:59Z"}, "message": "Fix issue for nested record types with -fdump-ada-spec\n\nAda does not support anonymous record declarations nested in other record\ndeclarations so -fdump-ada-spec needs to unnest them, and this contains a\nfew fixes for this machinery.\n\ngcc/c-family/\n\t* c-ada-spec.c (dump_ada_macros): Minor tweaks.\n\t(dump_ada_decl_name): Likewise.\n\t(dump_anonymous_type_name): Remove parent parameter and adjust.\n\t(dump_sloc): Minor tweak.\n\t(dump_ada_array_type): Remove type parameter and adjust.\n\t(dump_ada_enum_type): Remove parent parameter and adjust.\n\t(dump_ada_node): Adjust calls to above functions.\n\t(dumped_anonymous_types): New global variable.\n\t(dump_nested_types_1): Rename into...\n\t(dump_nested_types): ...this.\n\t(dump_nested_type): Remove parent and dumped_types parameters.\n\t<ARRAY_TYPE>: Replace dumped_types with dumped_anonymous_types.\n\tAdjust calls to dump_anonymous_type_name and dump_ada_array_type.\n\t(dump_ada_specs): Initialize and free dumped_anonymous_types.", "tree": {"sha": "c49026b2da25ffc9688703b04b3ea096abc1a0d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c49026b2da25ffc9688703b04b3ea096abc1a0d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd4dd47265f2bff89fbbfb6a12a98a7101fb5280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd4dd47265f2bff89fbbfb6a12a98a7101fb5280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd4dd47265f2bff89fbbfb6a12a98a7101fb5280", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd4dd47265f2bff89fbbfb6a12a98a7101fb5280/comments", "author": null, "committer": null, "parents": [{"sha": "517155ceb971d33881cfeecd767406f0801c6512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517155ceb971d33881cfeecd767406f0801c6512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517155ceb971d33881cfeecd767406f0801c6512"}], "stats": {"total": 116, "additions": 52, "deletions": 64}, "files": [{"sha": "a2669c604a9a782c06896853473543bc37373388", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 52, "deletions": 64, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd4dd47265f2bff89fbbfb6a12a98a7101fb5280/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd4dd47265f2bff89fbbfb6a12a98a7101fb5280/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=cd4dd47265f2bff89fbbfb6a12a98a7101fb5280", "patch": "@@ -408,8 +408,8 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  chars_seen = sprintf\n-\t\t\t    ((char *) buffer, \"Character'Val (%d)\", (int) c);\n+\t\t\t  chars_seen = sprintf ((char *) buffer,\n+\t\t\t\t\t\t\"Character'Val (%d)\", (int) c);\n \t\t\t  buffer += chars_seen;\n \t\t\t}\n \t\t    }\n@@ -611,7 +611,7 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \t  pp_string (pp, \";  --  \");\n \t  pp_string (pp, sloc.file);\n \t  pp_colon (pp);\n-\t  pp_scalar (pp, \"%d\", sloc.line);\n+\t  pp_decimal_int (pp, sloc.line);\n \t  pp_newline (pp);\n \t}\n       else\n@@ -1464,28 +1464,21 @@ dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n \t{\n \t  pp_string (buffer, \"anon\");\n \t  if (TREE_CODE (decl) == FIELD_DECL)\n-\t    pp_scalar (buffer, \"%d\", DECL_UID (decl));\n+\t    pp_decimal_int (buffer, DECL_UID (decl));\n \t  else\n-\t    pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (decl)));\n+\t    pp_decimal_int (buffer, TYPE_UID (TREE_TYPE (decl)));\n \t}\n       else if (TREE_CODE (type_name) == IDENTIFIER_NODE)\n \tpp_ada_tree_identifier (buffer, type_name, decl, limited_access);\n     }\n }\n \n-/* Dump in BUFFER a name for the type T, which is a _TYPE without TYPE_NAME.\n-   PARENT is the parent node of T.  */\n+/* Dump in BUFFER a name for the type T, which is a TYPE without TYPE_NAME.  */\n \n static void\n-dump_anonymous_type_name (pretty_printer *buffer, tree t, tree parent)\n+dump_anonymous_type_name (pretty_printer *buffer, tree t)\n {\n-  if (DECL_NAME (parent))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (parent), parent, false);\n-  else\n-    {\n-      pp_string (buffer, \"anon\");\n-      pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (parent)));\n-    }\n+  pp_string (buffer, \"anon\");\n \n   switch (TREE_CODE (t))\n     {\n@@ -1506,7 +1499,7 @@ dump_anonymous_type_name (pretty_printer *buffer, tree t, tree parent)\n       break;\n     }\n \n-  pp_scalar (buffer, \"%d\", TYPE_UID (t));\n+  pp_decimal_int (buffer, TYPE_UID (t));\n }\n \n /* Dump in BUFFER aspect Import on a given node T.  SPC is the current\n@@ -1757,12 +1750,12 @@ dump_sloc (pretty_printer *buffer, tree node)\n {\n   expanded_location xloc;\n \n-  xloc.file = NULL;\n-\n   if (DECL_P (node))\n     xloc = expand_location (DECL_SOURCE_LOCATION (node));\n   else if (EXPR_HAS_LOCATION (node))\n     xloc = expand_location (EXPR_LOCATION (node));\n+  else\n+    xloc.file = NULL;\n \n   if (xloc.file)\n     {\n@@ -1790,11 +1783,11 @@ is_char_array (tree t)\n \t && id_equal (DECL_NAME (TYPE_NAME (t)), \"char\");\n }\n \n-/* Dump in BUFFER an array type NODE of type TYPE in Ada syntax.  SPC is the\n-   indentation level.  */\n+/* Dump in BUFFER an array type NODE in Ada syntax.  SPC is the indentation\n+   level.  */\n \n static void\n-dump_ada_array_type (pretty_printer *buffer, tree node, tree type, int spc)\n+dump_ada_array_type (pretty_printer *buffer, tree node, int spc)\n {\n   const bool char_array = is_char_array (node);\n \n@@ -1823,8 +1816,8 @@ dump_ada_array_type (pretty_printer *buffer, tree node, tree type, int spc)\n \t  || (!RECORD_OR_UNION_TYPE_P (tmp)\n \t      && TREE_CODE (tmp) != ENUMERAL_TYPE))\n \tdump_ada_node (buffer, tmp, node, spc, false, true);\n-      else if (type)\n-\tdump_anonymous_type_name (buffer, tmp, type);\n+      else\n+\tdump_anonymous_type_name (buffer, tmp);\n     }\n }\n \n@@ -1954,11 +1947,10 @@ is_simple_enum (tree node)\n }\n \n /* Dump in BUFFER the declaration of enumeral NODE of type TYPE in Ada syntax.\n-   PARENT is the parent node of NODE.  SPC is the indentation level.  */\n+   SPC is the indentation level.  */\n \n static void\n-dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, tree parent,\n-\t\t    int spc)\n+dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, int spc)\n {\n   if (is_simple_enum (node))\n     {\n@@ -2005,7 +1997,7 @@ dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, tree parent,\n \t  else if (type)\n \t    dump_ada_node (buffer, type, NULL_TREE, spc, false, true);\n \t  else\n-\t    dump_anonymous_type_name (buffer, node, parent);\n+\t    dump_anonymous_type_name (buffer, node);\n \t  pp_underscore (buffer);\n \t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, false);\n \n@@ -2016,7 +2008,7 @@ dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, tree parent,\n \t  else if (type)\n \t    dump_ada_node (buffer, type, NULL_TREE, spc, false, true);\n \t  else\n-\t    dump_anonymous_type_name (buffer, node, parent);\n+\t    dump_anonymous_type_name (buffer, node);\n \n \t  pp_string (buffer, \" := \");\n \t  dump_ada_node (buffer, int_val, node, spc, false, true);\n@@ -2106,7 +2098,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       if (name_only)\n \tdump_ada_node (buffer, TYPE_NAME (node), node, spc, false, true);\n       else\n-\tdump_ada_enum_type (buffer, node, type, NULL_TREE, spc);\n+\tdump_ada_enum_type (buffer, node, type, spc);\n       break;\n \n     case REAL_TYPE:\n@@ -2116,6 +2108,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t  pp_string (buffer, \"Extensions.Float_128\");\n \t  break;\n \t}\n+\n       /* fallthrough */\n \n     case INTEGER_TYPE:\n@@ -2298,7 +2291,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \tdump_ada_node (buffer, TYPE_NAME (node), node, spc, limited_access,\n \t\t       true);\n       else\n-\tdump_ada_array_type (buffer, node, type, spc);\n+\tdump_ada_array_type (buffer, node, spc);\n       break;\n \n     case RECORD_TYPE:\n@@ -2490,7 +2483,12 @@ dump_forward_type (pretty_printer *buffer, tree type, tree t, int spc)\n   TREE_VISITED (decl) = 1;\n }\n \n-static void dump_nested_type (pretty_printer *, tree, tree, tree, bitmap, int);\n+/* Bitmap of anonymous types already dumped.  Anonymous array types are shared\n+   throughout the compilation so it needs to be global.  */\n+\n+static bitmap dumped_anonymous_types;\n+\n+static void dump_nested_type (pretty_printer *, tree, tree, int);\n \n /* Dump in BUFFER anonymous types nested inside T's definition.  PARENT is the\n    parent node of T.  DUMPED_TYPES is the bitmap of already dumped types.  SPC\n@@ -2506,8 +2504,7 @@ static void dump_nested_type (pretty_printer *, tree, tree, tree, bitmap, int);\n    pass on the nested TYPE_DECLs and a second pass on the unnamed types.  */\n \n static void\n-dump_nested_types_1 (pretty_printer *buffer, tree t, tree parent,\n-\t\t     bitmap dumped_types, int spc)\n+dump_nested_types (pretty_printer *buffer, tree t, int spc)\n {\n   tree type, field;\n \n@@ -2521,31 +2518,18 @@ dump_nested_types_1 (pretty_printer *buffer, tree t, tree parent,\n \t&& DECL_NAME (field) != DECL_NAME (t)\n \t&& !DECL_ORIGINAL_TYPE (field)\n \t&& TYPE_NAME (TREE_TYPE (field)) != TYPE_NAME (type))\n-      dump_nested_type (buffer, field, t, parent, dumped_types, spc);\n+      dump_nested_type (buffer, field, t, spc);\n \n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     if (TREE_CODE (field) == FIELD_DECL && !TYPE_NAME (TREE_TYPE (field)))\n-      dump_nested_type (buffer, field, t, parent, dumped_types, spc);\n+      dump_nested_type (buffer, field, t, spc);\n }\n \n-/* Likewise, but to be invoked only at top level.  We dump each anonymous type\n-   nested inside T's definition exactly once, even if it is referenced several\n-   times in it (typically an array type), with a name prefixed by that of T.  */\n+/* Dump in BUFFER the anonymous type of FIELD inside T.  SPC is the indentation\n+   level.  */\n \n static void\n-dump_nested_types (pretty_printer *buffer, tree t, int spc)\n-{\n-  auto_bitmap dumped_types;\n-  dump_nested_types_1 (buffer, t, t, dumped_types, spc);\n-}\n-\n-/* Dump in BUFFER the anonymous type of FIELD inside T.  PARENT is the parent\n-   node of T.  DUMPED_TYPES is the bitmap of already dumped types.  SPC is the\n-   indentation level.  */\n-\n-static void\n-dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n-\t\t  bitmap dumped_types, int spc)\n+dump_nested_type (pretty_printer *buffer, tree field, tree t, int spc)\n {\n   tree field_type = TREE_TYPE (field);\n   tree decl, tmp;\n@@ -2559,7 +2543,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \n     case ARRAY_TYPE:\n       /* Anonymous array types are shared.  */\n-      if (!bitmap_set_bit (dumped_types, TYPE_UID (field_type)))\n+      if (!bitmap_set_bit (dumped_anonymous_types, TYPE_UID (field_type)))\n \treturn;\n \n       /* Recurse on the element type if need be.  */\n@@ -2573,7 +2557,7 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \t  && !TREE_VISITED (decl))\n \t{\n \t  /* Generate full declaration.  */\n-\t  dump_nested_type (buffer, decl, t, parent, dumped_types, spc);\n+\t  dump_nested_type (buffer, decl, t, spc);\n \t  TREE_VISITED (decl) = 1;\n \t}\n       else if (!decl && TREE_CODE (tmp) == POINTER_TYPE)\n@@ -2585,9 +2569,9 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n       else\n \tpp_string (buffer, \"type \");\n \n-      dump_anonymous_type_name (buffer, field_type, parent);\n+      dump_anonymous_type_name (buffer, field_type);\n       pp_string (buffer, \" is \");\n-      dump_ada_array_type (buffer, field_type, parent, spc);\n+      dump_ada_array_type (buffer, field_type, spc);\n       pp_semicolon (buffer);\n       newline_and_indent (buffer, spc);\n       break;\n@@ -2601,23 +2585,23 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n       if (TYPE_NAME (field_type))\n \tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n       else\n-\tdump_anonymous_type_name (buffer, field_type, parent);\n+\tdump_anonymous_type_name (buffer, field_type);\n       pp_string (buffer, \" is \");\n-      dump_ada_enum_type (buffer, field_type, NULL_TREE, parent, spc);\n+      dump_ada_enum_type (buffer, field_type, NULL_TREE, spc);\n       pp_semicolon (buffer);\n       newline_and_indent (buffer, spc);\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n-      dump_nested_types_1 (buffer, field, parent, dumped_types, spc);\n+      dump_nested_types (buffer, field, spc);\n \n       pp_string (buffer, \"type \");\n \n       if (TYPE_NAME (field_type))\n \tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n       else\n-\tdump_anonymous_type_name (buffer, field_type, parent);\n+\tdump_anonymous_type_name (buffer, field_type);\n \n       if (TREE_CODE (field_type) == UNION_TYPE)\n \tpp_string (buffer, \" (discr : unsigned := 0)\");\n@@ -2953,7 +2937,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  if (orig && TYPE_NAME (orig))\n \t    dump_ada_node (buffer, TYPE_NAME (orig), type, spc, false, true);\n \t  else\n-\t    dump_ada_array_type (buffer, TREE_TYPE (t), type, spc);\n+\t    dump_ada_array_type (buffer, TREE_TYPE (t), spc);\n \t}\n       else\n \t{\n@@ -2968,9 +2952,9 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  if (TYPE_NAME (TREE_TYPE (t)))\n \t    dump_ada_node (buffer, TREE_TYPE (t), type, spc, false, true);\n \t  else if (type)\n-\t    dump_anonymous_type_name (buffer, TREE_TYPE (t), type);\n+\t    dump_anonymous_type_name (buffer, TREE_TYPE (t));\n \t  else\n-\t    dump_ada_array_type (buffer, TREE_TYPE (t), type, spc);\n+\t    dump_ada_array_type (buffer, TREE_TYPE (t), spc);\n \t}\n     }\n   else if (TREE_CODE (t) == FUNCTION_DECL)\n@@ -3206,7 +3190,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t\t  && TREE_CODE (TREE_TYPE (t)) != ENUMERAL_TYPE))\n \t    dump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \t  else if (type)\n-\t    dump_anonymous_type_name (buffer, TREE_TYPE (t), type);\n+\t    dump_anonymous_type_name (buffer, TREE_TYPE (t));\n \t}\n     }\n \n@@ -3516,7 +3500,11 @@ dump_ada_specs (void (*collect_all_refs)(const char *),\n \n   /* Iterate over the list of files to dump specs for.  */\n   for (int i = 0; i < source_refs_used; i++)\n-    dump_ads (source_refs[i], collect_all_refs, check);\n+    {\n+      dumped_anonymous_types = BITMAP_ALLOC (NULL);\n+      dump_ads (source_refs[i], collect_all_refs, check);\n+      BITMAP_FREE (dumped_anonymous_types);\n+    }\n \n   /* Free various tables.  */\n   free (source_refs);"}]}