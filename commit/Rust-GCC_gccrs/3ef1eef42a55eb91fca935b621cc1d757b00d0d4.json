{"sha": "3ef1eef42a55eb91fca935b621cc1d757b00d0d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VmMWVlZjQyYTU1ZWI5MWZjYTkzNWI2MjFjYzFkNzU3YjAwZDBkNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-04-14T22:13:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-04-14T22:13:59Z"}, "message": "expr.c (reload.h): Now included.\n\n\t* expr.c (reload.h): Now included.\n\t(emit_block_move): Set volatile_ok when checking for movstr.\n\t(emit_move_1): Check for replacements in addresses in multi-word case.\n\t* Makefile.in (expr.o): Now includes reload.h.\n\nFrom-SVN: r33155", "tree": {"sha": "f817488f7da4ca53cfd69c1691ab84d67ca035ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f817488f7da4ca53cfd69c1691ab84d67ca035ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ef1eef42a55eb91fca935b621cc1d757b00d0d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef1eef42a55eb91fca935b621cc1d757b00d0d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ef1eef42a55eb91fca935b621cc1d757b00d0d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ef1eef42a55eb91fca935b621cc1d757b00d0d4/comments", "author": null, "committer": null, "parents": [{"sha": "314883b80a758453f7f705a0f6c8382509407ae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314883b80a758453f7f705a0f6c8382509407ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/314883b80a758453f7f705a0f6c8382509407ae0"}], "stats": {"total": 39, "additions": 37, "deletions": 2}, "files": [{"sha": "6c8cfb4e8b6dff3422815081b0b15a6116dc4770", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef1eef42a55eb91fca935b621cc1d757b00d0d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef1eef42a55eb91fca935b621cc1d757b00d0d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ef1eef42a55eb91fca935b621cc1d757b00d0d4", "patch": "@@ -1,5 +1,10 @@\n Fri Apr 14 18:07:30 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* expr.c (reload.h): Now included.\n+\t(emit_block_move): Set volatile_ok when checking for movstr.\n+\t(emit_move_1): Check for replacements in addresses in multi-word case.\n+\t* Makefile.in (expr.o): Now includes reload.h.\n+\n \t* flow.c (count_basic_blocks): Remove unused var PREV_CALL.\n \tNever have a LIBCALL end a basic block.\n \t(find_basic_blocks_1): Likewise."}, {"sha": "74e5485eab87b9359b92840d9e5fcd302ddae941", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef1eef42a55eb91fca935b621cc1d757b00d0d4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef1eef42a55eb91fca935b621cc1d757b00d0d4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3ef1eef42a55eb91fca935b621cc1d757b00d0d4", "patch": "@@ -1533,7 +1533,7 @@ except.o : except.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n expr.o : expr.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h \\\n    $(REGS_H) insn-flags.h insn-codes.h $(EXPR_H) insn-config.h $(RECOG_H) \\\n    output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h \\\n-   $(GGC_H) intl.h\n+   reload.h $(GGC_H) intl.h\n builtins.o : builtins.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h $(REGS_H) insn-flags.h insn-codes.h $(EXPR_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\"}, {"sha": "aed82339d3a3b05cef222a36582592f388476630", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ef1eef42a55eb91fca935b621cc1d757b00d0d4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ef1eef42a55eb91fca935b621cc1d757b00d0d4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3ef1eef42a55eb91fca935b621cc1d757b00d0d4", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n /* Include expr.h after insn-config.h so we get HAVE_conditional_move. */\n #include \"expr.h\"\n #include \"recog.h\"\n+#include \"reload.h\"\n #include \"output.h\"\n #include \"typeclass.h\"\n #include \"defaults.h\"\n@@ -1626,6 +1627,9 @@ emit_block_move (x, y, size, align)\n       rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n       enum machine_mode mode;\n \n+      /* Since this is a move insn, we don't care about volatility.  */\n+      volatile_ok = 1;\n+\n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n \t   mode = GET_MODE_WIDER_MODE (mode))\n \t{\n@@ -1661,13 +1665,16 @@ emit_block_move (x, y, size, align)\n \t      if (pat)\n \t\t{\n \t\t  emit_insn (pat);\n+\t\t  volatile_ok = 0;\n \t\t  return 0;\n \t\t}\n \t      else\n \t\tdelete_insns_since (last);\n \t    }\n \t}\n \n+      volatile_ok = 0;\n+\n       /* X, Y, or SIZE may have been passed through protect_from_queue.\n \n \t It is unsafe to save the value generated by protect_from_queue\n@@ -2720,7 +2727,7 @@ emit_move_insn_1 (x, y)\n   else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     {\n       rtx last_insn = 0;\n-      rtx seq;\n+      rtx seq, inner;\n       int need_clobber;\n       \n #ifdef PUSH_ROUNDING\n@@ -2734,6 +2741,29 @@ emit_move_insn_1 (x, y)\n \t}\n #endif\n \t\t\t     \n+      /* If we are in reload, see if either operand is a MEM whose address\n+\t is scheduled for replacement.  */\n+      if (reload_in_progress && GET_CODE (x) == MEM\n+\t  && (inner = find_replacement (&XEXP (x, 0))) != XEXP (x, 0))\n+\t{\n+\t  rtx new = gen_rtx_MEM (GET_MODE (x), inner);\n+\n+\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n+\t  MEM_COPY_ATTRIBUTES (new, x);\n+\t  MEM_ALIAS_SET (new) = MEM_ALIAS_SET (x);\n+\t  x = new;\n+\t}\n+      if (reload_in_progress && GET_CODE (y) == MEM\n+\t  && (inner = find_replacement (&XEXP (y, 0))) != XEXP (y, 0))\n+\t{\n+\t  rtx new = gen_rtx_MEM (GET_MODE (y), inner);\n+\n+\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (y);\n+\t  MEM_COPY_ATTRIBUTES (new, y);\n+\t  MEM_ALIAS_SET (new) = MEM_ALIAS_SET (y);\n+\t  y = new;\n+\t}\n+\n       start_sequence ();\n \n       need_clobber = 0;"}]}