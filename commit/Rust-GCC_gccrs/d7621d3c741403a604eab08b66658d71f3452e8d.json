{"sha": "d7621d3c741403a604eab08b66658d71f3452e8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc2MjFkM2M3NDE0MDNhNjA0ZWFiMDhiNjY2NThkNzFmMzQ1MmU4ZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-06-17T17:47:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-06-17T17:47:47Z"}, "message": "re PR tree-optimization/15991 (phi nodes with identical arguments still remain at t50.tailc)\n\n\tPR tree-optimization/15991\n\t* tree-cfg.c (tree_block_label): Export.\n\t* tree-flow-inline.h (bsi_after_labels): New function.\n\t* tree-flow.h (bsi_after_labels, tree_block_label): Declare.\n\t* tree-ssa.c (propagate_into_addr): New function.\n\t(replace_immediate_uses): Handle propagation of pointer constants.\n\t(raise_value): Do not restrict propagation of pointer constants.\n\t* tree-ssanames.c (duplicate_ssa_name): New function.\n\t* tree.h (duplicate_ssa_name): Declare.\n\nFrom-SVN: r83297", "tree": {"sha": "4fcf2b4a4a942255116e20d36035b7def3cb2457", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fcf2b4a4a942255116e20d36035b7def3cb2457"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7621d3c741403a604eab08b66658d71f3452e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7621d3c741403a604eab08b66658d71f3452e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7621d3c741403a604eab08b66658d71f3452e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7621d3c741403a604eab08b66658d71f3452e8d/comments", "author": null, "committer": null, "parents": [{"sha": "f2b5cf977e5f5cce0434b890cc184872bcf1d5bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b5cf977e5f5cce0434b890cc184872bcf1d5bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2b5cf977e5f5cce0434b890cc184872bcf1d5bc"}], "stats": {"total": 172, "additions": 149, "deletions": 23}, "files": [{"sha": "3e237d1043220341d6b27bb3a05c528a853af341", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7621d3c741403a604eab08b66658d71f3452e8d", "patch": "@@ -1,3 +1,15 @@\n+2004-06-17  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\tPR tree-optimization/15991\n+\t* tree-cfg.c (tree_block_label): Export.\n+\t* tree-flow-inline.h (bsi_after_labels): New function.\n+\t* tree-flow.h (bsi_after_labels, tree_block_label): Declare.\n+\t* tree-ssa.c (propagate_into_addr): New function.\n+\t(replace_immediate_uses): Handle propagation of pointer constants.\n+\t(raise_value): Do not restrict propagation of pointer constants.\n+\t* tree-ssanames.c (duplicate_ssa_name): New function.\n+\t* tree.h (duplicate_ssa_name): Declare.\n+\n 2004-06-17  David Ayers  <d.ayers@inode.at>\n  \n \t* c-parse.in: Unify Objective-C token names."}, {"sha": "4b3ca40d134396e1639b0ef3c43c973d16c8796c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d7621d3c741403a604eab08b66658d71f3452e8d", "patch": "@@ -74,7 +74,6 @@ static void free_blocks_annotations (void);\n static void clear_blocks_annotations (void);\n static void make_blocks (tree);\n static void factor_computed_gotos (void);\n-static tree tree_block_label (basic_block bb);\n \n /* Edges.  */\n static void make_edges (void);\n@@ -3973,7 +3972,7 @@ thread_jumps (void)\n /* Return a non-special label in the head of basic block BLOCK.\n    Create one if it doesn't exist.  */\n \n-static tree\n+tree\n tree_block_label (basic_block bb)\n {\n   block_stmt_iterator i, s = bsi_start (bb);"}, {"sha": "c47ba09c515c7a5c7fcc8ab34aee9245e495d393", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=d7621d3c741403a604eab08b66658d71f3452e8d", "patch": "@@ -629,6 +629,53 @@ bsi_start (basic_block bb)\n   return bsi;\n }\n \n+/* Return a block statement iterator that points to the last label in\n+   block BB.  */\n+\n+static inline block_stmt_iterator\n+bsi_after_labels (basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+  tree_stmt_iterator next;\n+\n+  bsi.bb = bb;\n+\n+  if (!bb->stmt_list)\n+    {\n+#ifdef ENABLE_CHECKING\n+      if (bb->index >= 0)\n+\tabort ();\n+#endif\n+      bsi.tsi.ptr = NULL;\n+      bsi.tsi.container = NULL;\n+      return bsi;\n+    }\n+\n+  bsi.tsi = tsi_start (bb->stmt_list);\n+  if (tsi_end_p (bsi.tsi))\n+    return bsi;\n+\n+  /* Ensure that there are some labels.  The rationale is that we want\n+     to insert after the bsi that is returned, and these insertions should\n+     be placed at the start of the basic block.  This would not work if the\n+     first statement was not label; rather fail here than enable the user\n+     proceed in wrong way.  */\n+  if (TREE_CODE (tsi_stmt (bsi.tsi)) != LABEL_EXPR)\n+    abort ();\n+\n+  next = bsi.tsi;\n+  tsi_next (&next);\n+\n+  while (!tsi_end_p (next)\n+\t && TREE_CODE (tsi_stmt (next)) == LABEL_EXPR)\n+    {\n+      bsi.tsi = next;\n+      tsi_next (&next);\n+    }\n+\n+  return bsi;\n+}\n+\n /* Return a block statement iterator that points to the end of basic\n    block BB.  */\n static inline block_stmt_iterator"}, {"sha": "d9d0b1e33283c6f8d56325f2ad8bf55b5c8f20e0", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d7621d3c741403a604eab08b66658d71f3452e8d", "patch": "@@ -416,6 +416,7 @@ typedef struct {\n \n static inline block_stmt_iterator bsi_start (basic_block);\n static inline block_stmt_iterator bsi_last (basic_block);\n+static inline block_stmt_iterator bsi_after_labels (basic_block);\n static inline bool bsi_end_p (block_stmt_iterator);\n static inline void bsi_next (block_stmt_iterator *);\n static inline void bsi_prev (block_stmt_iterator *);\n@@ -486,6 +487,7 @@ extern void notice_special_calls (tree);\n extern void clear_special_calls (void);\n extern void compute_dominance_frontiers (bitmap *);\n extern void verify_stmts (void);\n+extern tree tree_block_label (basic_block bb);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n \n /* In tree-pretty-print.c.  */"}, {"sha": "7d9e64d338a8a8b180bfa28a4e215df58337b8ab", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=d7621d3c741403a604eab08b66658d71f3452e8d", "patch": "@@ -705,6 +705,52 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data)\n     }\n }\n \n+/* Replaces VAR with REPL in memory reference expression *X in\n+   statement STMT.  */\n+\n+static void\n+propagate_into_addr (tree stmt, tree var, tree *x, tree repl)\n+{\n+  tree new_var, ass_stmt, addr_var;\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+\n+  /* There is nothing special to handle in the other cases.  */\n+  if (TREE_CODE (repl) != ADDR_EXPR)\n+    return;\n+  addr_var = TREE_OPERAND (repl, 0);\n+\n+  while (TREE_CODE (*x) == ARRAY_REF\n+\t || TREE_CODE (*x) == COMPONENT_REF\n+\t || TREE_CODE (*x) == BIT_FIELD_REF)\n+    x = &TREE_OPERAND (*x, 0);\n+\n+  if (TREE_CODE (*x) != INDIRECT_REF\n+      || TREE_OPERAND (*x, 0) != var)\n+    return;\n+\n+  modify_stmt (stmt);\n+  if (TREE_TYPE (*x) == TREE_TYPE (addr_var))\n+    {\n+      *x = addr_var;\n+      mark_new_vars_to_rename (stmt, vars_to_rename);\n+      return;\n+    }\n+\n+  /* Frontends sometimes produce expressions like *&a instead of a[0].\n+     Create a temporary variable to handle this case.  */\n+  ass_stmt = build2 (MODIFY_EXPR, void_type_node, NULL_TREE, repl);\n+  new_var = duplicate_ssa_name (var, ass_stmt);\n+  TREE_OPERAND (*x, 0) = new_var;\n+  TREE_OPERAND (ass_stmt, 0) = new_var;\n+\n+  bb = bb_for_stmt (stmt);\n+  tree_block_label (bb);\n+  bsi = bsi_after_labels (bb);\n+  bsi_insert_after (&bsi, ass_stmt, BSI_NEW_STMT);\n+\n+  mark_new_vars_to_rename (stmt, vars_to_rename);\n+}\n \n /* Replaces immediate uses of VAR by REPL.  */\n \n@@ -718,6 +764,7 @@ replace_immediate_uses (tree var, tree repl)\n   dataflow_t df;\n   tree stmt;\n   stmt_ann_t ann;\n+  bool mark_new_vars;\n \n   df = get_immediate_uses (SSA_NAME_DEF_STMT (var));\n   n = num_immediate_uses (df);\n@@ -742,12 +789,22 @@ replace_immediate_uses (tree var, tree repl)\n \t}\n \n       get_stmt_operands (stmt);\n+      mark_new_vars = false;\n       if (is_gimple_reg (SSA_NAME_VAR (var)))\n \t{\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t    {\n+\t      propagate_into_addr (stmt, var, &TREE_OPERAND (stmt, 0), repl);\n+\t      propagate_into_addr (stmt, var, &TREE_OPERAND (stmt, 1), repl);\n+\t    }\n+\n \t  uses = USE_OPS (ann);\n \t  for (j = 0; j < (int) NUM_USES (uses); j++)\n \t    if (USE_OP (uses, j) == var)\n-\t      propagate_value (USE_OP_PTR (uses, j), repl);\n+\t      {\n+\t\tpropagate_value (USE_OP_PTR (uses, j), repl);\n+\t\tmark_new_vars = POINTER_TYPE_P (TREE_TYPE (repl));\n+\t      }\n \t}\n       else\n \t{\n@@ -762,15 +819,15 @@ replace_immediate_uses (tree var, tree repl)\n \t      propagate_value (V_MAY_DEF_OP_PTR (v_may_defs, j), repl);\n \t}\n \n-      modify_stmt (stmt);\n-\n       /* If REPL is a pointer, it may have different memory tags associated\n \t with it.  For instance, VAR may have had a name tag while REPL\n \t only had a type tag.  In these cases, the virtual operands (if\n \t any) in the statement will refer to different symbols which need\n \t to be renamed.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (repl)))\n+      if (mark_new_vars)\n \tmark_new_vars_to_rename (stmt, vars_to_rename);\n+      else\n+\tmodify_stmt (stmt);\n     }\n }\n \n@@ -788,23 +845,6 @@ raise_value (tree phi, tree val, tree *eq_to)\n   if (eq_to[ver] == var)\n     return;\n \n-  switch (TREE_CODE (val))\n-    {\n-    case SSA_NAME:\n-    case REAL_CST:\n-    case COMPLEX_CST:\n-      break;\n-    case INTEGER_CST:\n-      if (TREE_CODE (TREE_TYPE (var)) != POINTER_TYPE)\n-\tbreak;\n-\n-    default:\n-      /* Do not propagate pointer constants.  This might require folding\n-\t things like *&foo and rewriting the ssa, which is not worth the\n-\t trouble.  */\n-      val = var;\n-    }\n-\n   if (eq_to[ver])\n     {\n       if (operand_equal_p (eq_to[ver], val, 0))"}, {"sha": "d4982706676cccc62146c21fdd6259d5a4847325", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=d7621d3c741403a604eab08b66658d71f3452e8d", "patch": "@@ -191,4 +191,29 @@ release_ssa_name (tree var)\n     }\n }\n \n+/* Creates a duplicate of a ssa name NAME defined in statement STMT.  */\n+\n+tree\n+duplicate_ssa_name (tree name, tree stmt)\n+{\n+  tree new_name = make_ssa_name (SSA_NAME_VAR (name), stmt);\n+  struct ptr_info_def *old_ptr_info = SSA_NAME_PTR_INFO (name);\n+  struct ptr_info_def *new_ptr_info;\n+\n+  if (!old_ptr_info)\n+    return new_name;\n+\n+  new_ptr_info = ggc_alloc (sizeof (struct ptr_info_def));\n+  *new_ptr_info = *old_ptr_info;\n+\n+  if (old_ptr_info->pt_vars)\n+    {\n+      new_ptr_info->pt_vars = BITMAP_GGC_ALLOC ();\n+      bitmap_copy (new_ptr_info->pt_vars, old_ptr_info->pt_vars);\n+    }\n+\n+  SSA_NAME_PTR_INFO (new_name) = new_ptr_info;\n+  return new_name;\n+}\n+\n #include \"gt-tree-ssanames.h\""}, {"sha": "1a0f8545c1301d2dd13cee73d4676d318002100f", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7621d3c741403a604eab08b66658d71f3452e8d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d7621d3c741403a604eab08b66658d71f3452e8d", "patch": "@@ -2537,6 +2537,7 @@ extern void phinodes_print_statistics (void);\n extern void init_ssanames (void);\n extern void fini_ssanames (void);\n extern tree make_ssa_name (tree, tree);\n+extern tree duplicate_ssa_name (tree, tree);\n extern void release_ssa_name (tree);\n #ifdef GATHER_STATISTICS\n extern void ssanames_print_statistics (void);"}]}