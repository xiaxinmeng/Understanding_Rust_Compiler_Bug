{"sha": "3afd514bca6ea572e614b5289c4429ace693311b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FmZDUxNGJjYTZlYTU3MmU2MTRiNTI4OWM0NDI5YWNlNjkzMzExYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-05-06T21:50:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-05-06T21:50:14Z"}, "message": "re PR tree-optimization/88709 (Improve store-merging)\n\n\tPR tree-optimization/88709\n\tPR tree-optimization/90271\n\t* params.def (PARAM_STORE_MERGING_MAX_SIZE): New parameter.\n\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Handle\n\tnon-clobber CONSTRUCTORs with no elts.  Remove useless tmp_int\n\tvariable.\n\t(imm_store_chain_info::coalesce_immediate_stores): Punt if the size\n\tof the store merging group is larger than\n\tPARAM_STORE_MERGING_MAX_SIZE parameter.\n\t(split_group): Add bzero_first argument.  If set, always emit first\n\tthe first store which must be = {} of the whole area and then for the\n\trest of the stores consider all zero bytes as paddings.\n\t(imm_store_chain_info::output_merged_store): Check if first store\n\tis = {} of the whole area and if yes, determine which setting of\n\tbzero_first for split_group gives smaller number of stores.  Adjust\n\tsplit_group callers.\n\t(lhs_valid_for_store_merging_p): Allow decls.\n\t(rhs_valid_for_store_merging_p): Allow non-clobber CONTRUCTORs with\n\tno elts.\n\t(pass_store_merging::process_store): Likewise.\n\n\t* gcc.dg/store_merging_26.c: New test.\n\t* gcc.dg/store_merging_27.c: New test.\n\t* gcc.dg/store_merging_28.c: New test.\n\t* gcc.dg/store_merging_29.c: New test.\n\nFrom-SVN: r270924", "tree": {"sha": "6cf0ff6dfc80988456a14b05c7a9b0581f0a685d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cf0ff6dfc80988456a14b05c7a9b0581f0a685d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3afd514bca6ea572e614b5289c4429ace693311b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3afd514bca6ea572e614b5289c4429ace693311b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3afd514bca6ea572e614b5289c4429ace693311b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3afd514bca6ea572e614b5289c4429ace693311b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "839c480a14f025bdcd73a53d14a19d4cc9a1aea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839c480a14f025bdcd73a53d14a19d4cc9a1aea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/839c480a14f025bdcd73a53d14a19d4cc9a1aea5"}], "stats": {"total": 317, "additions": 296, "deletions": 21}, "files": [{"sha": "95bddb35f7812fdaa63c53088252241b63eb2c84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -1,3 +1,26 @@\n+2019-05-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/88709\n+\tPR tree-optimization/90271\n+\t* params.def (PARAM_STORE_MERGING_MAX_SIZE): New parameter.\n+\t* gimple-ssa-store-merging.c (encode_tree_to_bitpos): Handle\n+\tnon-clobber CONSTRUCTORs with no elts.  Remove useless tmp_int\n+\tvariable.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Punt if the size\n+\tof the store merging group is larger than\n+\tPARAM_STORE_MERGING_MAX_SIZE parameter.\n+\t(split_group): Add bzero_first argument.  If set, always emit first\n+\tthe first store which must be = {} of the whole area and then for the\n+\trest of the stores consider all zero bytes as paddings.\n+\t(imm_store_chain_info::output_merged_store): Check if first store\n+\tis = {} of the whole area and if yes, determine which setting of\n+\tbzero_first for split_group gives smaller number of stores.  Adjust\n+\tsplit_group callers.\n+\t(lhs_valid_for_store_merging_p): Allow decls.\n+\t(rhs_valid_for_store_merging_p): Allow non-clobber CONTRUCTORs with\n+\tno elts.\n+\t(pass_store_merging::process_store): Likewise.\n+\n 2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \tPR target/89424"}, {"sha": "5a93830ab4bf87750e7c4c73f7b9d236ff807780", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 120, "deletions": 21, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -1615,13 +1615,31 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n \t\t       unsigned int total_bytes)\n {\n   unsigned int first_byte = bitpos / BITS_PER_UNIT;\n-  tree tmp_int = expr;\n   bool sub_byte_op_p = ((bitlen % BITS_PER_UNIT)\n \t\t\t|| (bitpos % BITS_PER_UNIT)\n \t\t\t|| !int_mode_for_size (bitlen, 0).exists ());\n+  bool empty_ctor_p\n+    = (TREE_CODE (expr) == CONSTRUCTOR\n+       && CONSTRUCTOR_NELTS (expr) == 0\n+       && TYPE_SIZE_UNIT (TREE_TYPE (expr))\n+\t\t       && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (expr))));\n \n   if (!sub_byte_op_p)\n-    return native_encode_expr (tmp_int, ptr + first_byte, total_bytes) != 0;\n+    {\n+      if (first_byte >= total_bytes)\n+\treturn false;\n+      total_bytes -= first_byte;\n+      if (empty_ctor_p)\n+\t{\n+\t  unsigned HOST_WIDE_INT rhs_bytes\n+\t    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (expr)));\n+\t  if (rhs_bytes > total_bytes)\n+\t    return false;\n+\t  memset (ptr + first_byte, '\\0', rhs_bytes);\n+\t  return true;\n+\t}\n+      return native_encode_expr (expr, ptr + first_byte, total_bytes) != 0;\n+    }\n \n   /* LITTLE-ENDIAN\n      We are writing a non byte-sized quantity or at a position that is not\n@@ -1667,14 +1685,29 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n \n   /* We must be dealing with fixed-size data at this point, since the\n      total size is also fixed.  */\n-  fixed_size_mode mode = as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (expr)));\n+  unsigned int byte_size;\n+  if (empty_ctor_p)\n+    {\n+      unsigned HOST_WIDE_INT rhs_bytes\n+\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (expr)));\n+      if (rhs_bytes > total_bytes)\n+\treturn false;\n+      byte_size = rhs_bytes;\n+    }\n+  else\n+    {\n+      fixed_size_mode mode\n+\t= as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (expr)));\n+      byte_size = GET_MODE_SIZE (mode);\n+    }\n   /* Allocate an extra byte so that we have space to shift into.  */\n-  unsigned int byte_size = GET_MODE_SIZE (mode) + 1;\n+  byte_size++;\n   unsigned char *tmpbuf = XALLOCAVEC (unsigned char, byte_size);\n   memset (tmpbuf, '\\0', byte_size);\n   /* The store detection code should only have allowed constants that are\n-     accepted by native_encode_expr.  */\n-  if (native_encode_expr (expr, tmpbuf, byte_size - 1) == 0)\n+     accepted by native_encode_expr or empty ctors.  */\n+  if (!empty_ctor_p\n+      && native_encode_expr (expr, tmpbuf, byte_size - 1) == 0)\n     gcc_unreachable ();\n \n   /* The native_encode_expr machinery uses TYPE_MODE to determine how many\n@@ -2671,6 +2704,8 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \n   FOR_EACH_VEC_ELT (m_store_info, i, info)\n     {\n+      unsigned HOST_WIDE_INT new_bitregion_start, new_bitregion_end;\n+\n       if (i <= ignore)\n \tgoto done;\n \n@@ -2702,7 +2737,14 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t    }\n \t}\n \n-      if (info->order >= merged_store->first_nonmergeable_order)\n+      new_bitregion_start\n+\t= MIN (merged_store->bitregion_start, info->bitregion_start);\n+      new_bitregion_end\n+\t= MAX (merged_store->bitregion_end, info->bitregion_end);\n+\n+      if (info->order >= merged_store->first_nonmergeable_order\n+\t  || (((new_bitregion_end - new_bitregion_start + 1) / BITS_PER_UNIT)\n+\t      > (unsigned) PARAM_VALUE (PARAM_STORE_MERGING_MAX_SIZE)))\n \t;\n \n       /* |---store 1---|\n@@ -3184,12 +3226,15 @@ count_multiple_uses (store_immediate_info *info)\n    Return number of new stores.\n    If ALLOW_UNALIGNED_STORE is false, then all stores must be aligned.\n    If ALLOW_UNALIGNED_LOAD is false, then all loads must be aligned.\n+   BZERO_FIRST may be true only when the first store covers the whole group\n+   and clears it; if BZERO_FIRST is true, keep that first store in the set\n+   unmodified and emit further stores for the overrides only.\n    If SPLIT_STORES is NULL, it is just a dry run to count number of\n    new stores.  */\n \n static unsigned int\n split_group (merged_store_group *group, bool allow_unaligned_store,\n-\t     bool allow_unaligned_load,\n+\t     bool allow_unaligned_load, bool bzero_first,\n \t     vec<struct split_store *> *split_stores,\n \t     unsigned *total_orig,\n \t     unsigned *total_new)\n@@ -3207,6 +3252,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n   if (group->stores[0]->rhs_code == LROTATE_EXPR\n       || group->stores[0]->rhs_code == NOP_EXPR)\n     {\n+      gcc_assert (!bzero_first);\n       /* For bswap framework using sets of stores, all the checking\n \t has been done earlier in try_coalesce_bswap and needs to be\n \t emitted as a single store.  */\n@@ -3278,10 +3324,26 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n       if (group->load_align[i])\n \tgroup_load_align = MIN (group_load_align, group->load_align[i]);\n \n+  if (bzero_first)\n+    {\n+      first = 1;\n+      ret = 1;\n+      if (split_stores)\n+\t{\n+\t  struct split_store *store\n+\t    = new split_store (bytepos, group->stores[0]->bitsize, align_base);\n+\t  store->orig_stores.safe_push (group->stores[0]);\n+\t  store->orig = true;\n+\t  any_orig = true;\n+\t  split_stores->safe_push (store);\n+\t}\n+    }\n+\n   while (size > 0)\n     {\n       if ((allow_unaligned_store || group_align <= BITS_PER_UNIT)\n-\t  && group->mask[try_pos - bytepos] == (unsigned char) ~0U)\n+\t  && (group->mask[try_pos - bytepos] == (unsigned char) ~0U\n+\t      || (bzero_first && group->val[try_pos - bytepos] == 0)))\n \t{\n \t  /* Skip padding bytes.  */\n \t  ++try_pos;\n@@ -3348,7 +3410,9 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n       /* Now look for whole padding bytes at the end of that bitsize.  */\n       for (nonmasked = try_size / BITS_PER_UNIT; nonmasked > 0; --nonmasked)\n \tif (group->mask[try_pos - bytepos + nonmasked - 1]\n-\t    != (unsigned char) ~0U)\n+\t    != (unsigned char) ~0U\n+\t    && (!bzero_first\n+\t\t|| group->val[try_pos - bytepos + nonmasked - 1] != 0))\n \t  break;\n       if (nonmasked == 0)\n \t{\n@@ -3367,7 +3431,9 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \t  /* Now look for whole padding bytes at the start of that bitsize.  */\n \t  unsigned int try_bytesize = try_size / BITS_PER_UNIT, masked;\n \t  for (masked = 0; masked < try_bytesize; ++masked)\n-\t    if (group->mask[try_pos - bytepos + masked] != (unsigned char) ~0U)\n+\t    if (group->mask[try_pos - bytepos + masked] != (unsigned char) ~0U\n+\t\t&& (!bzero_first\n+\t\t    || group->val[try_pos - bytepos + masked] != 0))\n \t      break;\n \t  masked *= BITS_PER_UNIT;\n \t  gcc_assert (masked < try_size);\n@@ -3583,20 +3649,44 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   bool allow_unaligned_store\n     = !STRICT_ALIGNMENT && PARAM_VALUE (PARAM_STORE_MERGING_ALLOW_UNALIGNED);\n   bool allow_unaligned_load = allow_unaligned_store;\n-  if (allow_unaligned_store)\n+  bool bzero_first = false;\n+  if (group->stores[0]->rhs_code == INTEGER_CST\n+      && TREE_CODE (gimple_assign_rhs1 (group->stores[0]->stmt)) == CONSTRUCTOR\n+      && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (group->stores[0]->stmt)) == 0\n+      && group->start == group->stores[0]->bitpos\n+      && group->width == group->stores[0]->bitsize\n+      && (group->start % BITS_PER_UNIT) == 0\n+      && (group->width % BITS_PER_UNIT) == 0)\n+    bzero_first = true;\n+  if (allow_unaligned_store || bzero_first)\n     {\n       /* If unaligned stores are allowed, see how many stores we'd emit\n \t for unaligned and how many stores we'd emit for aligned stores.\n-\t Only use unaligned stores if it allows fewer stores than aligned.  */\n-      unsigned aligned_cnt\n-\t= split_group (group, false, allow_unaligned_load, NULL, NULL, NULL);\n-      unsigned unaligned_cnt\n-\t= split_group (group, true, allow_unaligned_load, NULL, NULL, NULL);\n-      if (aligned_cnt <= unaligned_cnt)\n+\t Only use unaligned stores if it allows fewer stores than aligned.\n+\t Similarly, if there is a whole region clear first, prefer expanding\n+\t it together compared to expanding clear first followed by merged\n+\t further stores.  */\n+      unsigned cnt[4] = { ~0, ~0, ~0, ~0 };\n+      int pass_min = 0;\n+      for (int pass = 0; pass < 4; ++pass)\n+\t{\n+\t  if (!allow_unaligned_store && (pass & 1) != 0)\n+\t    continue;\n+\t  if (!bzero_first && (pass & 2) != 0)\n+\t    continue;\n+\t  cnt[pass] = split_group (group, (pass & 1) != 0,\n+\t\t\t\t   allow_unaligned_load, (pass & 2) != 0,\n+\t\t\t\t   NULL, NULL, NULL);\n+\t  if (cnt[pass] < cnt[pass_min])\n+\t    pass_min = pass;\n+\t}\n+      if ((pass_min & 1) == 0)\n \tallow_unaligned_store = false;\n+      if ((pass_min & 2) == 0)\n+\tbzero_first = false;\n     }\n   unsigned total_orig, total_new;\n-  split_group (group, allow_unaligned_store, allow_unaligned_load,\n+  split_group (group, allow_unaligned_store, allow_unaligned_load, bzero_first,\n \t       &split_stores, &total_orig, &total_new);\n \n   if (split_stores.length () >= orig_num_stmts)\n@@ -4164,7 +4254,8 @@ lhs_valid_for_store_merging_p (tree lhs)\n   tree_code code = TREE_CODE (lhs);\n \n   if (code == ARRAY_REF || code == ARRAY_RANGE_REF || code == MEM_REF\n-      || code == COMPONENT_REF || code == BIT_FIELD_REF)\n+      || code == COMPONENT_REF || code == BIT_FIELD_REF\n+      || DECL_P (lhs))\n     return true;\n \n   return false;\n@@ -4178,6 +4269,12 @@ static bool\n rhs_valid_for_store_merging_p (tree rhs)\n {\n   unsigned HOST_WIDE_INT size;\n+  if (TREE_CODE (rhs) == CONSTRUCTOR\n+      && !TREE_CLOBBER_P (rhs)\n+      && CONSTRUCTOR_NELTS (rhs) == 0\n+      && TYPE_SIZE_UNIT (TREE_TYPE (rhs))\n+      && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (rhs))))\n+    return true;\n   return (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (rhs))).is_constant (&size)\n \t  && native_encode_expr (rhs, NULL, size) != 0);\n }\n@@ -4363,7 +4460,9 @@ pass_store_merging::process_store (gimple *stmt)\n   bool invalid = (base_addr == NULL_TREE\n \t\t  || (maybe_gt (bitsize,\n \t\t\t\t(unsigned int) MAX_BITSIZE_MODE_ANY_INT)\n-\t\t      && (TREE_CODE (rhs) != INTEGER_CST)));\n+\t\t      && TREE_CODE (rhs) != INTEGER_CST\n+\t\t      && (TREE_CODE (rhs) != CONSTRUCTOR\n+\t\t\t  || CONSTRUCTOR_NELTS (rhs) != 0)));\n   enum tree_code rhs_code = ERROR_MARK;\n   bool bit_not_p = false;\n   struct symbolic_number n;"}, {"sha": "904b3cbdf16251b1cd5bafc91e874d939741ad57", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -1205,6 +1205,11 @@ DEFPARAM (PARAM_MAX_STORES_TO_MERGE,\n \t  \"store merging pass.\",\n \t  64, 2, 0)\n \n+DEFPARAM (PARAM_STORE_MERGING_MAX_SIZE,\n+\t  \"store-merging-max-size\",\n+\t  \"Maximum size of a single store merging region in bytes.\",\n+\t  65536, 1, 1)\n+\n DEFPARAM (PARAM_MAX_TAIL_MERGE_ITERATIONS,\n           \"max-tail-merge-iterations\",\n           \"Maximum amount of iterations of the pass over a function.\","}, {"sha": "51a17474cfb2c57e38afb388a7580927bd69dd90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -1,3 +1,12 @@\n+2019-05-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/88709\n+\tPR tree-optimization/90271\n+\t* gcc.dg/store_merging_26.c: New test.\n+\t* gcc.dg/store_merging_27.c: New test.\n+\t* gcc.dg/store_merging_28.c: New test.\n+\t* gcc.dg/store_merging_29.c: New test.\n+\n 2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \tPR target/89424"}, {"sha": "0a0b949be69782004835413e29890ba1c1e418fb", "filename": "gcc/testsuite/gcc.dg/store_merging_26.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_26.c?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -0,0 +1,36 @@\n+/* PR tree-optimization/90271 */\n+/* { dg-do run { target int32 } } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging-details\" } */\n+/* { dg-final { scan-tree-dump \"New sequence of 1 stores to replace old one of 2 stores\" \"store-merging\" } } */\n+\n+__attribute__((noipa)) void\n+foo (int *x)\n+{\n+  asm volatile (\"\" : : \"r\" (x) : \"memory\");\n+}\n+\n+__attribute__((noipa)) int\n+bar ()\n+{\n+  int x;\n+  foo (&x);\n+  x = 3;\n+  ((char *) &x)[1] = 1;\n+  foo (&x);\n+  return x;\n+}\n+\n+int\n+main ()\n+{\n+  int x;\n+  foo (&x);\n+  x = 3;\n+  foo (&x);\n+  ((char *) &x)[1] = 1;\n+  foo (&x);\n+  if (x != bar ())\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "a691368ad3f8bad263569378421e699a9c9e8880", "filename": "gcc/testsuite/gcc.dg/store_merging_27.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_27.c?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -0,0 +1,26 @@\n+/* PR tree-optimization/88709 */\n+/* { dg-do run } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging-details\" } */\n+/* { dg-final { scan-tree-dump \"New sequence of \\[12] stores to replace old one of 3 stores\" \"store-merging\" } } */\n+\n+struct S { char buf[8]; };\n+\n+__attribute__((noipa)) void\n+bar (struct S *x)\n+{\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    if (x->buf[i] != ((i == 1) + (i == 3) * 2))\n+      __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  struct S s = {};\n+  s.buf[1] = 1;\n+  s.buf[3] = 2;\n+  bar (&s);\n+  return 0;\n+}"}, {"sha": "95a082288d73a904d72090fd1cc22d3f027ad23c", "filename": "gcc/testsuite/gcc.dg/store_merging_28.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_28.c?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -0,0 +1,44 @@\n+/* PR tree-optimization/88709 */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fno-ipa-icf -fdump-tree-store-merging-details\" } */\n+/* { dg-final { scan-tree-dump-times \"New sequence of \\[24] stores to replace old one of 16 stores\" 8 \"store-merging\" { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"New sequence of \\[24] stores to replace old one of 6 stores\" 1 \"store-merging\" } } */\n+\n+typedef struct S { char data[16]; } S;\n+void optimize_me (S);\n+void optimize_me3 (S, S, S);\n+\n+void\n+good ()\n+{\n+  optimize_me ((S) { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 });\n+}\n+\n+void\n+bad ()\n+{\n+  optimize_me ((S) { 1, 2, 3, 4, 5 });\n+}\n+\n+void\n+why ()\n+{\n+  optimize_me ((S) { 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });\n+}\n+\n+void\n+srsly ()\n+{\n+  optimize_me3 ((S) { 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n+\t\t(S) { 11, 12, 13, 14, 15, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },\n+\t\t(S) { 21, 22, 23, 24, 25, 20, 20, 20, 10, 20, 20, 20, 20, 20, 20 });\n+}\n+\n+void\n+srsly_not_one_missing ()\n+{\n+  optimize_me3 ((S) { 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n+\t\t(S) { 11, 12, 13, 14, 15, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },\n+\t\t(S) { 21, 22, 23, 24, 25, 20, 20, 20, 10, 20, 20, 20, 20, 20, 20, 11 });\n+}"}, {"sha": "52dd0f7c7b3cd04db10b23e55588ed5830d44ebf", "filename": "gcc/testsuite/gcc.dg/store_merging_29.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3afd514bca6ea572e614b5289c4429ace693311b/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_29.c?ref=3afd514bca6ea572e614b5289c4429ace693311b", "patch": "@@ -0,0 +1,33 @@\n+/* PR tree-optimization/88709 */\n+/* { dg-do run { target int32 } } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging-details\" } */\n+/* { dg-final { scan-tree-dump \"New sequence of 3 stores to replace old one of 6 stores\" \"store-merging\" { target le } } } */\n+/* { dg-final { scan-tree-dump \"New sequence of \\[34] stores to replace old one of 6 stores\" \"store-merging\" { target be } } } */\n+\n+struct T { char a[1024]; };\n+\n+__attribute__((noipa)) void\n+bar (struct T *t)\n+{\n+  int x = 0x506;\n+  if (__builtin_memcmp (&t->a[97], &x, sizeof (x)))\n+    __builtin_abort ();\n+  __builtin_memset (&t->a[97], '\\0', sizeof (x));\n+  for (int i = 0; i < 8; ++i)\n+    if (t->a[i] != ((i == 54) + 2 * (i == 52) + 3 * (i == 95) + 4 * (i == 96)))\n+      __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  struct T t = {};\n+  t.a[54] = 1;\n+  t.a[52] = 2;\n+  t.a[95] = 3;\n+  t.a[96] = 4;\n+  int x = 0x506;\n+  __builtin_memcpy (&t.a[97], &x, sizeof (x));\n+  bar (&t);\n+}"}]}