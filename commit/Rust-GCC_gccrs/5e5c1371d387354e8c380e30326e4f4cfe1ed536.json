{"sha": "5e5c1371d387354e8c380e30326e4f4cfe1ed536", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU1YzEzNzFkMzg3MzU0ZThjMzgwZTMwMzI2ZTRmNGNmZTFlZDUzNg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-07-20T19:31:16Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-07-20T19:31:16Z"}, "message": "natClassLoader.cc (_Jv_PrepareCompiledClass): Only initialize String fields for interpreted classes.\n\n\t* java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Only\n\tinitialize String fields for interpreted classes.  Fixes bug\n\treported by Hans Boehm.\n\nFrom-SVN: r35150", "tree": {"sha": "a6ab338775210a5f8f4fabe6d876799f7f480823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6ab338775210a5f8f4fabe6d876799f7f480823"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e5c1371d387354e8c380e30326e4f4cfe1ed536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5c1371d387354e8c380e30326e4f4cfe1ed536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e5c1371d387354e8c380e30326e4f4cfe1ed536", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5c1371d387354e8c380e30326e4f4cfe1ed536/comments", "author": null, "committer": null, "parents": [{"sha": "373d3b1863ed6433c288dd87c7892380ec1b671a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/373d3b1863ed6433c288dd87c7892380ec1b671a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/373d3b1863ed6433c288dd87c7892380ec1b671a"}], "stats": {"total": 46, "additions": 29, "deletions": 17}, "files": [{"sha": "fdbefa758f16444d6b4aa61ff89daa08203bba19", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5c1371d387354e8c380e30326e4f4cfe1ed536/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5c1371d387354e8c380e30326e4f4cfe1ed536/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5e5c1371d387354e8c380e30326e4f4cfe1ed536", "patch": "@@ -1,5 +1,9 @@\n 2000-07-20  Tom Tromey  <tromey@cygnus.com>\n \n+\t* java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Only\n+\tinitialize String fields for interpreted classes.  Fixes bug\n+\treported by Hans Boehm.\n+\n \t* java/io/File.java (getParentFile): New method, from Classpath\n \tvia Oskar Liljeblad.\n "}, {"sha": "54ffc42dd55cba0b86679b698d7f1f2c34696e64", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5c1371d387354e8c380e30326e4f4cfe1ed536/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5c1371d387354e8c380e30326e4f4cfe1ed536/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=5e5c1371d387354e8c380e30326e4f4cfe1ed536", "patch": "@@ -165,9 +165,7 @@ java::lang::ClassLoader::linkClass0 (java::lang::Class *klass)\n \n #ifdef INTERPRETER\n   if (_Jv_IsInterpretedClass (klass))\n-    {\n-      _Jv_PrepareClass (klass);\n-    }\n+    _Jv_PrepareClass (klass);\n #endif\n \n   _Jv_PrepareCompiledClass (klass);\n@@ -230,7 +228,7 @@ java::lang::ClassLoader::findLoadedClass (jstring name)\n     lives in resolve.cc which is entirely conditionally compiled.\n  */\n void\n-_Jv_PrepareCompiledClass(jclass klass)\n+_Jv_PrepareCompiledClass (jclass klass)\n {\n   if (klass->state >= JV_STATE_LINKED)\n     return;\n@@ -270,23 +268,33 @@ _Jv_PrepareCompiledClass(jclass klass)\n \t}\n     }\n \n-  jfieldID f = JvGetFirstStaticField (klass);\n-  for (int n = JvNumStaticFields (klass); n > 0; --n)\n+#ifdef INTERPRETER\n+  // FIXME: although the comment up top says that this function is\n+  // only called for compiled classes, it is actually called for every\n+  // class.\n+  if (! _Jv_IsInterpretedClass (klass))\n     {\n-      int mod = f->getModifiers ();\n-      // Maybe the compiler should mark these with\n-      // _Jv_FIELD_CONSTANT_VALUE?  For now we just know that this\n-      // only happens for constant strings.\n-      if (f->getClass () == &StringClass\n-\t  && java::lang::reflect::Modifier::isStatic (mod)\n-\t  && java::lang::reflect::Modifier::isFinal (mod))\n+#endif /* INTERPRETER */\n+      jfieldID f = JvGetFirstStaticField (klass);\n+      for (int n = JvNumStaticFields (klass); n > 0; --n)\n \t{\n-\t  jstring *strp = (jstring *) f->u.addr;\n-\t  if (*strp)\n-\t    *strp = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) *strp);\n+\t  int mod = f->getModifiers ();\n+\t  // Maybe the compiler should mark these with\n+\t  // _Jv_FIELD_CONSTANT_VALUE?  For now we just know that this\n+\t  // only happens for constant strings.\n+\t  if (f->getClass () == &StringClass\n+\t      && java::lang::reflect::Modifier::isStatic (mod)\n+\t      && java::lang::reflect::Modifier::isFinal (mod))\n+\t    {\n+\t      jstring *strp = (jstring *) f->u.addr;\n+\t      if (*strp)\n+\t\t*strp = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) *strp);\n+\t    }\n+\t  f = f->getNextField ();\n \t}\n-      f = f->getNextField ();\n+#ifdef INTERPRETER\n     }\n+#endif /* INTERPRETER */\n \n   klass->notifyAll ();\n }"}]}