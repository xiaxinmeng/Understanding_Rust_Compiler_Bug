{"sha": "b6dd03dd9c48470246b4b47e7471b2cf99c65737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZkZDAzZGQ5YzQ4NDcwMjQ2YjRiNDdlNzQ3MWIyY2Y5OWM2NTczNw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2015-01-30T09:29:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-30T09:29:51Z"}, "message": "sem_disp.adb (Is_Dynamically_Tagged): when applied to an entity or a function call, return True if type is class-wide.\n\n2015-01-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_disp.adb (Is_Dynamically_Tagged): when applied to an entity\n\tor a function call, return True if type is class-wide.\n\t* sem_res.adb (Resolve_Case_Expression, Resolve_If_Expression);\n\tApply RM 4.5.7 (17/3): all or none of the dependent expression\n\tof a conditional expression must be dynamically tagged.\n\nFrom-SVN: r220276", "tree": {"sha": "9de9ba7528c8a2e075365fb8f9362f6be20eb86a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9de9ba7528c8a2e075365fb8f9362f6be20eb86a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6dd03dd9c48470246b4b47e7471b2cf99c65737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6dd03dd9c48470246b4b47e7471b2cf99c65737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6dd03dd9c48470246b4b47e7471b2cf99c65737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6dd03dd9c48470246b4b47e7471b2cf99c65737/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "566d377a296f571eed3af6609f75d57e9bb5eb13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566d377a296f571eed3af6609f75d57e9bb5eb13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/566d377a296f571eed3af6609f75d57e9bb5eb13"}], "stats": {"total": 84, "additions": 72, "deletions": 12}, "files": [{"sha": "a67b7d37ded276a223c11d5c00538bacdfc99973", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6dd03dd9c48470246b4b47e7471b2cf99c65737/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6dd03dd9c48470246b4b47e7471b2cf99c65737/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b6dd03dd9c48470246b4b47e7471b2cf99c65737", "patch": "@@ -1,3 +1,11 @@\n+2015-01-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_disp.adb (Is_Dynamically_Tagged): when applied to an entity\n+\tor a function call, return True if type is class-wide.\n+\t* sem_res.adb (Resolve_Case_Expression, Resolve_If_Expression);\n+\tApply RM 4.5.7 (17/3): all or none of the dependent expression\n+\tof a conditional expression must be dynamically tagged.\n+\n 2015-01-30  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb (Analyze_Function_Return): In an extended return"}, {"sha": "0a9bfba594228997bcddc29f09f5b5ac092c164d", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6dd03dd9c48470246b4b47e7471b2cf99c65737/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6dd03dd9c48470246b4b47e7471b2cf99c65737/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=b6dd03dd9c48470246b4b47e7471b2cf99c65737", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -562,6 +562,12 @@ package body Sem_Disp is\n             then\n                null;\n \n+            elsif Ekind (Current_Scope) = E_Function\n+              and then Nkind (Unit_Declaration_Node (Current_Scope))\n+                 = N_Generic_Subprogram_Declaration\n+            then\n+               null;\n+\n             else\n                --  We need to determine whether the context of the call\n                --  provides a tag to make the call dispatching. This requires\n@@ -2162,8 +2168,24 @@ package body Sem_Disp is\n    begin\n       if Nkind (N) = N_Error then\n          return False;\n+\n+      elsif Present (Find_Controlling_Arg (N)) then\n+         return True;\n+\n+      --  Special cases : entities, and calls that dispatch on result.\n+\n+      elsif Is_Entity_Name (N) then\n+         return Is_Class_Wide_Type (Etype (N));\n+\n+      elsif Nkind (N) = N_Function_Call\n+         and then Is_Class_Wide_Type (Etype (N))\n+      then\n+         return True;\n+\n+      --  Otherwise check whether call has controlling argument.\n+\n       else\n-         return Find_Controlling_Arg (N) /= Empty;\n+         return False;\n       end if;\n    end Is_Dynamically_Tagged;\n "}, {"sha": "5096c6a626423fb58bf7b69471b91a92efc9b9e7", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6dd03dd9c48470246b4b47e7471b2cf99c65737/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6dd03dd9c48470246b4b47e7471b2cf99c65737/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b6dd03dd9c48470246b4b47e7471b2cf99c65737", "patch": "@@ -6416,7 +6416,8 @@ package body Sem_Res is\n    -----------------------------\n \n    procedure Resolve_Case_Expression (N : Node_Id; Typ : Entity_Id) is\n-      Alt : Node_Id;\n+      Alt    : Node_Id;\n+      Is_Dyn : Boolean;\n \n    begin\n       Alt := First (Alternatives (N));\n@@ -6425,6 +6426,23 @@ package body Sem_Res is\n          Next (Alt);\n       end loop;\n \n+      --  Apply RM 4.5.7 (17/3): whether the expression is statically or\n+      --  dynamically tagged must be known statically.\n+\n+      if Is_Tagged_Type (Typ) and then not Is_Class_Wide_Type (Typ) then\n+         Alt := First (Alternatives (N));\n+         Is_Dyn := Is_Dynamically_Tagged (Expression (Alt));\n+\n+         while Present (Alt) loop\n+            if Is_Dynamically_Tagged (Expression (Alt)) /= Is_Dyn then\n+               Error_Msg_N (\"all or none of the dependent expressions \"\n+                            & \"can be dynamically tagged\", N);\n+            end if;\n+\n+            Next (Alt);\n+         end loop;\n+      end if;\n+\n       Set_Etype (N, Typ);\n       Eval_Case_Expression (N);\n    end Resolve_Case_Expression;\n@@ -8061,11 +8079,20 @@ package body Sem_Res is\n          Resolve (Else_Expr, Typ);\n          Else_Typ := Etype (Else_Expr);\n \n-         if Is_Scalar_Type (Else_Typ)\n-           and then Else_Typ /= Typ\n-         then\n+         if Is_Scalar_Type (Else_Typ) and then Else_Typ /= Typ then\n             Rewrite (Else_Expr, Convert_To (Typ, Else_Expr));\n             Analyze_And_Resolve (Else_Expr, Typ);\n+\n+         --  Apply RM 4.5.7 (17/3): whether the expression is statically or\n+         --  dynamically tagged must be known statically.\n+\n+         elsif Is_Tagged_Type (Typ) and then not Is_Class_Wide_Type (Typ) then\n+            if Is_Dynamically_Tagged (Then_Expr) /=\n+               Is_Dynamically_Tagged (Else_Expr)\n+            then\n+               Error_Msg_N (\"all or none of the dependent expressions \"\n+                            & \"can be dynamically tagged\", N);\n+            end if;\n          end if;\n \n       --  If no ELSE expression is present, root type must be Standard.Boolean\n@@ -8232,10 +8259,10 @@ package body Sem_Res is\n                                             (Entity (Prefix (N)))))\n         and then not Is_Atomic (Component_Type (Array_Type))\n       then\n-         Error_Msg_N (\"??access to non-atomic component of atomic array\",\n-                      Prefix (N));\n-         Error_Msg_N (\"??\\may cause unexpected accesses to atomic object\",\n-                      Prefix (N));\n+         Error_Msg_N\n+           (\"??access to non-atomic component of atomic array\", Prefix (N));\n+         Error_Msg_N\n+           (\"??\\may cause unexpected accesses to atomic object\", Prefix (N));\n       end if;\n    end Resolve_Indexed_Component;\n \n@@ -8263,9 +8290,14 @@ package body Sem_Res is\n       --  If the operand is a literal, it cannot be the expression in a\n       --  conversion. Use a qualified expression instead.\n \n+      ---------------------\n+      -- Convert_Operand --\n+      ---------------------\n+\n       function Convert_Operand (Opnd : Node_Id) return Node_Id is\n          Loc : constant Source_Ptr := Sloc (Opnd);\n          Res : Node_Id;\n+\n       begin\n          if Nkind_In (Opnd, N_Integer_Literal, N_Real_Literal) then\n             Res :=\n@@ -8309,8 +8341,6 @@ package body Sem_Res is\n         or else Is_Private_Type (Etype (Right_Opnd (N)))\n       then\n          Arg1 := Convert_Operand (Left_Opnd (N));\n-         --  Unchecked_Convert_To (Btyp, Left_Opnd  (N));\n-         --  What on earth is this commented out fragment of code???\n \n          if Nkind (N) = N_Op_Expon then\n             Arg2 := Unchecked_Convert_To (Standard_Integer, Right_Opnd (N));"}]}