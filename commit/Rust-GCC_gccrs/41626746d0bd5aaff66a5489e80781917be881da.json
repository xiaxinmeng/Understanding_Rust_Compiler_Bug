{"sha": "41626746d0bd5aaff66a5489e80781917be881da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2MjY3NDZkMGJkNWFhZmY2NmE1NDg5ZTgwNzgxOTE3YmU4ODFkYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-01-07T07:49:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-01-07T07:49:10Z"}, "message": "re PR tree-optimization/59643 (Predictive commoning unnecessarily punts on scimark2 SOR)\n\n\tPR tree-optimization/59643\n\t* tree-predcom.c (split_data_refs_to_components): If one dr is\n\tread and one write, determine_offset fails and the write isn't\n\tin the bad component, just put the read into the bad component.\n\n\t* gcc.dg/pr59643.c: New test.\n\t* gcc.c-torture/execute/pr59643.c: New test.\n\nFrom-SVN: r206384", "tree": {"sha": "071e8492cc75475aa723d80b5247b3945695f667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/071e8492cc75475aa723d80b5247b3945695f667"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41626746d0bd5aaff66a5489e80781917be881da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41626746d0bd5aaff66a5489e80781917be881da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41626746d0bd5aaff66a5489e80781917be881da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41626746d0bd5aaff66a5489e80781917be881da/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc349a3901254b334d2ab2bf6eadb35eeb8fdb48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc349a3901254b334d2ab2bf6eadb35eeb8fdb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc349a3901254b334d2ab2bf6eadb35eeb8fdb48"}], "stats": {"total": 102, "additions": 98, "deletions": 4}, "files": [{"sha": "4760b12e0c72023034278babe3e9e31a15a2b506", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41626746d0bd5aaff66a5489e80781917be881da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41626746d0bd5aaff66a5489e80781917be881da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41626746d0bd5aaff66a5489e80781917be881da", "patch": "@@ -1,3 +1,10 @@\n+2014-01-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/59643\n+\t* tree-predcom.c (split_data_refs_to_components): If one dr is\n+\tread and one write, determine_offset fails and the write isn't\n+\tin the bad component, just put the read into the bad component.\n+\n 2014-01-07  Mike Stump  <mikestump@comcast.net>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "629d42011069a18c0c61ddf4c012dcad9a9696e4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=41626746d0bd5aaff66a5489e80781917be881da", "patch": "@@ -1,3 +1,9 @@\n+2014-01-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/59643\n+\t* gcc.dg/pr59643.c: New test.\n+\t* gcc.c-torture/execute/pr59643.c: New test.\n+\n 2014-01-06  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/59589"}, {"sha": "e3e8a6a38fcab03033e413e51461a407bcee874d", "filename": "gcc/testsuite/gcc.c-torture/execute/pr59643.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr59643.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr59643.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr59643.c?ref=41626746d0bd5aaff66a5489e80781917be881da", "patch": "@@ -0,0 +1,39 @@\n+/* PR tree-optimization/59643 */\n+\n+#define N 32\n+\n+__attribute__((noinline, noclone)) void\n+foo (double *a, double *b, double *c, double d, double e, int n)\n+{\n+  int i;\n+  for (i = 1; i < n - 1; i++)\n+    a[i] = d * (b[i] + c[i] + a[i - 1] + a[i + 1]) + e * a[i];\n+}\n+\n+double expected[] = {\n+  0.0, 10.0, 44.0, 110.0, 232.0, 490.0, 1020.0, 2078.0, 4152.0, 8314.0,\n+  16652.0, 33326.0, 66664.0, 133354.0, 266748.0, 533534.0, 1067064.0,\n+  2134138.0, 4268300.0, 8536622.0, 17073256.0, 34146538.0, 68293116.0,\n+  136586270.0, 273172536.0, 546345082.0, 1092690188.0, 2185380398.0,\n+  4370760808.0, 8741521642.0, 17483043324.0, 6.0\n+};\n+\n+int\n+main ()\n+{\n+  int i;\n+  double a[N], b[N], c[N];\n+  if (__DBL_MANT_DIG__ <= 35)\n+    return 0;\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = (i & 3) * 2.0;\n+      b[i] = (i & 7) - 4;\n+      c[i] = i & 7;\n+    }\n+  foo (a, b, c, 2.0, 3.0, N);\n+  for (i = 0; i < N; i++)\n+    if (a[i] != expected[i])\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "f4df5e5b2212f014afbbf58792ec9a972565ed9a", "filename": "gcc/testsuite/gcc.dg/pr59643.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59643.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59643.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59643.c?ref=41626746d0bd5aaff66a5489e80781917be881da", "patch": "@@ -0,0 +1,15 @@\n+/* PR tree-optimization/59643 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-pcom-details\" } */\n+\n+void\n+foo (double *a, double *b, double *c, double d, double e, int n)\n+{\n+  int i;\n+  for (i = 1; i < n - 1; i++)\n+    a[i] = d * (b[i] + c[i] + a[i - 1] + a[i + 1]) + e * a[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Before commoning:\" 1 \"pcom\" } } */\n+/* { dg-final { scan-tree-dump-times \"Unrolling 2 times\" 1 \"pcom\" } } */\n+/* { dg-final { cleanup-tree-dump \"pcom\" } } */"}, {"sha": "7169b2f68f5656560e06fac9ff4e2d22c6853fcf", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41626746d0bd5aaff66a5489e80781917be881da/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=41626746d0bd5aaff66a5489e80781917be881da", "patch": "@@ -772,10 +772,37 @@ split_data_refs_to_components (struct loop *loop,\n       bad = component_of (comp_father, n);\n \n       /* If both A and B are reads, we may ignore unsuitable dependences.  */\n-      if (DR_IS_READ (dra) && DR_IS_READ (drb)\n-\t  && (ia == bad || ib == bad\n-\t      || !determine_offset (dra, drb, &dummy_off)))\n-\tcontinue;\n+      if (DR_IS_READ (dra) && DR_IS_READ (drb))\n+\t{\n+\t  if (ia == bad || ib == bad\n+\t      || !determine_offset (dra, drb, &dummy_off))\n+\t    continue;\n+\t}\n+      /* If A is read and B write or vice versa and there is unsuitable\n+\t dependence, instead of merging both components into a component\n+\t that will certainly not pass suitable_component_p, just put the\n+\t read into bad component, perhaps at least the write together with\n+\t all the other data refs in it's component will be optimizable.  */\n+      else if (DR_IS_READ (dra) && ib != bad)\n+\t{\n+\t  if (ia == bad)\n+\t    continue;\n+\t  else if (!determine_offset (dra, drb, &dummy_off))\n+\t    {\n+\t      merge_comps (comp_father, comp_size, bad, ia);\n+\t      continue;\n+\t    }\n+\t}\n+      else if (DR_IS_READ (drb) && ia != bad)\n+\t{\n+\t  if (ib == bad)\n+\t    continue;\n+\t  else if (!determine_offset (dra, drb, &dummy_off))\n+\t    {\n+\t      merge_comps (comp_father, comp_size, bad, ib);\n+\t      continue;\n+\t    }\n+\t}\n \n       merge_comps (comp_father, comp_size, ia, ib);\n     }"}]}