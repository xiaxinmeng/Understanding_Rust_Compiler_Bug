{"sha": "5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI5ODAyYzQ1YzJjMGNmZTkzZDI2MTUxOGU1Y2E0NjYxOTdjYmY4Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-07-30T20:06:29Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-07-30T20:06:29Z"}, "message": "re PR c++/57397 (Off-by-one error in diagnostic when calling variadic function template with too few arguments)\n\n/cp\n2014-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/57397\n\t* pt.c (unify_arity): Add boolean parameter.\n\t(unify_too_few_arguments): Likewise.\n\t(type_unification_real): Diagnose correctly insufficient\n\targuments in the presence of trailing variadic parameters;\n\tdeducing multiple trailing packs as empty is fine.\n\n/testsuite\n2014-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/57397\n\t* g++.dg/cpp0x/vt-57397-1.C: New.\n\t* g++.dg/cpp0x/vt-57397-2.C: Likewise.\n\nFrom-SVN: r213310", "tree": {"sha": "983a584405e4753faa7111c6c007e8861d2ebb4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/983a584405e4753faa7111c6c007e8861d2ebb4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/comments", "author": null, "committer": null, "parents": [{"sha": "b6d9404508ba1ee03aef9faa8849f554a938ef09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d9404508ba1ee03aef9faa8849f554a938ef09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d9404508ba1ee03aef9faa8849f554a938ef09"}], "stats": {"total": 101, "additions": 89, "deletions": 12}, "files": [{"sha": "f0102077620006156a4c11f5b983afe75caef956", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "patch": "@@ -1,3 +1,12 @@\n+2014-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/57397\n+\t* pt.c (unify_arity): Add boolean parameter.\n+\t(unify_too_few_arguments): Likewise.\n+\t(type_unification_real): Diagnose correctly insufficient\n+\targuments in the presence of trailing variadic parameters;\n+\tdeducing multiple trailing packs as empty is fine.\n+\n 2014-07-30  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/61659"}, {"sha": "33a8bf47151b37e06039edd139a5be7ac3003366", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "patch": "@@ -5527,13 +5527,21 @@ unify_method_type_error (bool explain_p, tree arg)\n }\n \n static int\n-unify_arity (bool explain_p, int have, int wanted)\n+unify_arity (bool explain_p, int have, int wanted, bool least_p = false)\n {\n   if (explain_p)\n-    inform_n (input_location, wanted,\n-\t      \"  candidate expects %d argument, %d provided\",\n-\t      \"  candidate expects %d arguments, %d provided\",\n-\t      wanted, have);\n+    {\n+      if (least_p)\n+\tinform_n (input_location, wanted,\n+\t\t  \"  candidate expects at least %d argument, %d provided\",\n+\t\t  \"  candidate expects at least %d arguments, %d provided\",\n+\t\t  wanted, have);\n+      else\n+\tinform_n (input_location, wanted,\n+\t\t  \"  candidate expects %d argument, %d provided\",\n+\t\t  \"  candidate expects %d arguments, %d provided\",\n+\t\t  wanted, have);\n+    }\n   return 1;\n }\n \n@@ -5544,9 +5552,10 @@ unify_too_many_arguments (bool explain_p, int have, int wanted)\n }\n \n static int\n-unify_too_few_arguments (bool explain_p, int have, int wanted)\n+unify_too_few_arguments (bool explain_p, int have, int wanted,\n+\t\t\t bool least_p = false)\n {\n-  return unify_arity (explain_p, have, wanted);\n+  return unify_arity (explain_p, have, wanted, least_p);\n }\n \n static int\n@@ -16627,18 +16636,26 @@ type_unification_real (tree tparms,\n      are present, and the parm list isn't variadic.  */\n   if (ia < nargs && parms == void_list_node)\n     return unify_too_many_arguments (explain_p, nargs, ia);\n-  /* Fail if parms are left and they don't have default values.  */\n+  /* Fail if parms are left and they don't have default values and\n+     they aren't all deduced as empty packs (c++/57397).  This is\n+     consistent with sufficient_parms_p.  */\n   if (parms && parms != void_list_node\n       && TREE_PURPOSE (parms) == NULL_TREE)\n     {\n       unsigned int count = nargs;\n       tree p = parms;\n-      while (p && p != void_list_node)\n+      bool type_pack_p;\n+      do\n \t{\n-\t  count++;\n+\t  type_pack_p = TREE_CODE (TREE_VALUE (p)) == TYPE_PACK_EXPANSION;\n+\t  if (!type_pack_p)\n+\t    count++;\n \t  p = TREE_CHAIN (p);\n \t}\n-      return unify_too_few_arguments (explain_p, ia, count);\n+      while (p && p != void_list_node);\n+      if (count != nargs)\n+\treturn unify_too_few_arguments (explain_p, ia, count,\n+\t\t\t\t\ttype_pack_p);\n     }\n \n   if (!subr)"}, {"sha": "629e89e6df2d643976fd23b406f64c990203813b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "patch": "@@ -1,3 +1,9 @@\n+2014-07-30  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/57397\n+\t* g++.dg/cpp0x/vt-57397-1.C: New.\n+\t* g++.dg/cpp0x/vt-57397-2.C: Likewise.\n+\n 2014-07-30  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat.dg/case_null.adb, gnat.dg/specs/debug1.ads: Adjust tests.\n@@ -11,7 +17,6 @@\n \n \t* g++.dg/ipa/devirt-34.C: New testcase.\n \n->>>>>>> .r213302\n 2014-07-28  Richard Biener  <rguenther@suse.de>\n \n \tPR rtl-optimization/61801"}, {"sha": "1d9a1e0761922f503d85580a728c9bc11123149a", "filename": "gcc/testsuite/g++.dg/cpp0x/vt-57397-1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-57397-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-57397-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-57397-1.C?ref=5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/57397\n+// { dg-do compile { target c++11 } }\n+\n+template<class T1, class... Tn>\n+void foo(T1, Tn...);\n+\n+template<class T1, class T2, class... Tn>\n+void bar(T1, T2, Tn...);\n+\n+int main()\n+{\n+  foo();   // { dg-error \"no matching\" }\n+  // { dg-message \"candidate expects at least 1 argument, 0 provided\" \"\" { target *-*-* } 12 }\n+  foo(1);\n+  foo(1, 2);\n+  bar();   // { dg-error \"no matching\" }\n+  // { dg-message \"candidate expects at least 2 arguments, 0 provided\" \"\" { target *-*-* } 16 }\n+  bar(1);  // { dg-error \"no matching\" }\n+  // { dg-message \"candidate expects at least 2 arguments, 1 provided\" \"\" { target *-*-* } 18 }\n+  bar(1, 2);\n+  bar(1, 2, 3);\n+}"}, {"sha": "d217008fbfebb133c3a25f884b152ff9f82f1151", "filename": "gcc/testsuite/g++.dg/cpp0x/vt-57397-2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-57397-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9802c45c2c0cfe93d261518e5ca466197cbf8f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-57397-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvt-57397-2.C?ref=5b9802c45c2c0cfe93d261518e5ca466197cbf8f", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/57397\n+// { dg-do compile { target c++11 } }\n+\n+template<class T1, class... Tn, class... Tm>\n+void foo(T1, Tn..., Tm...);\n+\n+template<class T1, class T2, class... Tn, class... Tm>\n+void bar(T1, T2, Tn..., Tm...);\n+\n+int main()\n+{\n+  foo();   // { dg-error \"no matching\" }\n+  // { dg-message \"candidate expects at least 1 argument, 0 provided\" \"\" { target *-*-* } 12 }\n+  foo(1);\n+  foo(1, 2);\n+  foo(1, 2, 3);\n+  bar();   // { dg-error \"no matching\" }\n+  // { dg-message \"candidate expects at least 2 arguments, 0 provided\" \"\" { target *-*-* } 17 }\n+  bar(1);  // { dg-error \"no matching\" }\n+  // { dg-message \"candidate expects at least 2 arguments, 1 provided\" \"\" { target *-*-* } 19 }\n+  bar(1, 2);\n+  bar(1, 2, 3);\n+  bar(1, 2, 3, 4);\n+}"}]}