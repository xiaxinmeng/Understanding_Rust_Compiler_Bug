{"sha": "64fbcc74a336dd37eed05336788188ad9374f6e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRmYmNjNzRhMzM2ZGQzN2VlZDA1MzM2Nzg4MTg4YWQ5Mzc0ZjZlMQ==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2012-11-09T17:04:40Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2012-11-09T17:04:40Z"}, "message": "Add HTM fastpath and use Intel RTM for it on x86.\n\n\t* beginend.cc (htm_fastpath): New.\n\t(gtm_thread::begin_transaction, _ITM_commitTransaction,\n\t_ITM_commitTransactionEH): Add HTM fastpath handling.\n\t* config/linux/rwlock.h (gtm_rwlock.is_write_locked): New.\n\t* config/posix/rwlock.h (gtm_rwlock.is_write_locked): New.\n\t* config/x86/target.h (htm_available, htm_init, htm_begin_success,\n\thtm_begin, htm_commit, htm_abort, htm_abort_should_retry): New.\n\t* configure.tgt: Add -mrtm to XCFLAGS.\n\t* method-serial.cc (htm_mg, o_htm_mg, htm_dispatch, dispatch_htm): New.\n\t(gtm_thread::serialirr_mode): Add HTM fastpath handling.\n\t* libitm_i.h (htm_fastpath, dispatch_htm): Declare.\n\t* retry.cc (parse_default_method): Add HTM method parsing.\n\t(gtm_thread::number_of_threads_changed): Use HTM by default if\n\tavailable.\n\nFrom-SVN: r193369", "tree": {"sha": "9fd7bd08f877808bd7bb4eb601fd7482c9c85d6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fd7bd08f877808bd7bb4eb601fd7482c9c85d6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64fbcc74a336dd37eed05336788188ad9374f6e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64fbcc74a336dd37eed05336788188ad9374f6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64fbcc74a336dd37eed05336788188ad9374f6e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64fbcc74a336dd37eed05336788188ad9374f6e1/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a28e76a78ec4f3bb1219c4ba5795f86dccb43cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a28e76a78ec4f3bb1219c4ba5795f86dccb43cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a28e76a78ec4f3bb1219c4ba5795f86dccb43cd"}], "stats": {"total": 275, "additions": 256, "deletions": 19}, "files": [{"sha": "bad2c8d586af5b92804dcbf6b59225de1b43b436", "filename": "libitm/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -1,3 +1,20 @@\n+2012-11-09  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (htm_fastpath): New.\n+\t(gtm_thread::begin_transaction, _ITM_commitTransaction,\n+\t_ITM_commitTransactionEH): Add HTM fastpath handling.\n+\t* config/linux/rwlock.h (gtm_rwlock.is_write_locked): New.\n+\t* config/posix/rwlock.h (gtm_rwlock.is_write_locked): New.\n+\t* config/x86/target.h (htm_available, htm_init, htm_begin_success,\n+\thtm_begin, htm_commit, htm_abort, htm_abort_should_retry): New.\n+\t* configure.tgt: Add -mrtm to XCFLAGS.\n+\t* method-serial.cc (htm_mg, o_htm_mg, htm_dispatch, dispatch_htm): New.\n+\t(gtm_thread::serialirr_mode): Add HTM fastpath handling.\n+\t* libitm_i.h (htm_fastpath, dispatch_htm): Declare.\n+\t* retry.cc (parse_default_method): Add HTM method parsing.\n+\t(gtm_thread::number_of_threads_changed): Use HTM by default if\n+\tavailable.\n+\n 2012-11-04  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* configure: Regenerate."}, {"sha": "43699469d8325f6affceb82fac9fca558b3246f8", "filename": "libitm/beginend.cc", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -54,6 +54,8 @@ static pthread_mutex_t global_tid_lock = PTHREAD_MUTEX_INITIALIZER;\n static pthread_key_t thr_release_key;\n static pthread_once_t thr_release_once = PTHREAD_ONCE_INIT;\n \n+// See gtm_thread::begin_transaction.\n+uint32_t GTM::htm_fastpath = 0;\n \n /* Allocate a transaction structure.  */\n void *\n@@ -163,6 +165,70 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n   if (unlikely(prop & pr_undoLogCode))\n     GTM_fatal(\"pr_undoLogCode not supported\");\n \n+#if defined(USE_HTM_FASTPATH) && !defined(HTM_CUSTOM_FASTPATH)\n+  // HTM fastpath.  Only chosen in the absence of transaction_cancel to allow\n+  // using an uninstrumented code path.\n+  // The fastpath is enabled only by dispatch_htm's method group, which uses\n+  // serial-mode methods as fallback.  Serial-mode transactions cannot execute\n+  // concurrently with HW transactions because the latter monitor the serial\n+  // lock's writer flag and thus abort if another thread is or becomes a\n+  // serial transaction.  Therefore, if the fastpath is enabled, then a\n+  // transaction is not executing as a HW transaction iff the serial lock is\n+  // write-locked.  This allows us to use htm_fastpath and the serial lock's\n+  // writer flag to reliable determine whether the current thread runs a HW\n+  // transaction, and thus we do not need to maintain this information in\n+  // per-thread state.\n+  // If an uninstrumented code path is not available, we can still run\n+  // instrumented code from a HW transaction because the HTM fastpath kicks\n+  // in early in both begin and commit, and the transaction is not canceled.\n+  // HW transactions might get requests to switch to serial-irrevocable mode,\n+  // but these can be ignored because the HTM provides all necessary\n+  // correctness guarantees.  Transactions cannot detect whether they are\n+  // indeed in serial mode, and HW transactions should never need serial mode\n+  // for any internal changes (e.g., they never abort visibly to the STM code\n+  // and thus do not trigger the standard retry handling).\n+  if (likely(htm_fastpath && (prop & pr_hasNoAbort)))\n+    {\n+      for (uint32_t t = htm_fastpath; t; t--)\n+\t{\n+\t  uint32_t ret = htm_begin();\n+\t  if (htm_begin_success(ret))\n+\t    {\n+\t      // We are executing a transaction now.\n+\t      // Monitor the writer flag in the serial-mode lock, and abort\n+\t      // if there is an active or waiting serial-mode transaction.\n+\t      if (unlikely(serial_lock.is_write_locked()))\n+\t\thtm_abort();\n+\t      else\n+\t\t// We do not need to set a_saveLiveVariables because of HTM.\n+\t\treturn (prop & pr_uninstrumentedCode) ?\n+\t\t    a_runUninstrumentedCode : a_runInstrumentedCode;\n+\t    }\n+\t  // The transaction has aborted.  Don't retry if it's unlikely that\n+\t  // retrying the transaction will be successful.\n+\t  if (!htm_abort_should_retry(ret))\n+\t    break;\n+\t  // Wait until any concurrent serial-mode transactions have finished.\n+\t  // This is an empty critical section, but won't be elided.\n+\t  if (serial_lock.is_write_locked())\n+\t    {\n+\t      tx = gtm_thr();\n+\t      if (unlikely(tx == NULL))\n+\t        {\n+\t          // See below.\n+\t          tx = new gtm_thread();\n+\t          set_gtm_thr(tx);\n+\t        }\n+\t      serial_lock.read_lock(tx);\n+\t      serial_lock.read_unlock(tx);\n+\t      // TODO We should probably reset the retry count t here, unless\n+\t      // we have retried so often that we should go serial to avoid\n+\t      // starvation.\n+\t    }\n+\t}\n+    }\n+#endif\n+\n   tx = gtm_thr();\n   if (unlikely(tx == NULL))\n     {\n@@ -537,6 +603,17 @@ GTM::gtm_thread::restart (gtm_restart_reason r, bool finish_serial_upgrade)\n void ITM_REGPARM\n _ITM_commitTransaction(void)\n {\n+#if defined(USE_HTM_FASTPATH)\n+  // HTM fastpath.  If we are not executing a HW transaction, then we will be\n+  // a serial-mode transaction.  If we are, then there will be no other\n+  // concurrent serial-mode transaction.\n+  // See gtm_thread::begin_transaction.\n+  if (likely(htm_fastpath && !gtm_thread::serial_lock.is_write_locked()))\n+    {\n+      htm_commit();\n+      return;\n+    }\n+#endif\n   gtm_thread *tx = gtm_thr();\n   if (!tx->trycommit ())\n     tx->restart (RESTART_VALIDATE_COMMIT);\n@@ -545,6 +622,14 @@ _ITM_commitTransaction(void)\n void ITM_REGPARM\n _ITM_commitTransactionEH(void *exc_ptr)\n {\n+#if defined(USE_HTM_FASTPATH)\n+  // See _ITM_commitTransaction.\n+  if (likely(htm_fastpath && !gtm_thread::serial_lock.is_write_locked()))\n+    {\n+      htm_commit();\n+      return;\n+    }\n+#endif\n   gtm_thread *tx = gtm_thr();\n   if (!tx->trycommit ())\n     {"}, {"sha": "f13d287a21f1e6f3e5adbce287c9e48bdad41b23", "filename": "libitm/config/linux/rwlock.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfig%2Flinux%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfig%2Flinux%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.h?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2011 Free Software Foundation, Inc.\n+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Torvald Riegel <triegel@redhat.com>.\n \n    This file is part of the GNU Transactional Memory Library (libitm).\n@@ -59,6 +59,14 @@ class gtm_rwlock\n   bool write_upgrade (gtm_thread *tx);\n   void write_upgrade_finish (gtm_thread *tx);\n \n+  // Returns true iff there is a concurrent active or waiting writer.\n+  // This is primarily useful for simple HyTM approaches, and the value being\n+  // checked is loaded with memory_order_relaxed.\n+  bool is_write_locked()\n+  {\n+    return writers.load (memory_order_relaxed) != 0;\n+  }\n+\n  protected:\n   bool write_lock_generic (gtm_thread *tx);\n };"}, {"sha": "79f14296df61eefcf208682cfb2b58e49c8286b7", "filename": "libitm/config/posix/rwlock.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfig%2Fposix%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfig%2Fposix%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.h?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+/* Copyright (C) 2009, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU Transactional Memory Library (libitm).\n@@ -74,6 +74,14 @@ class gtm_rwlock\n   bool write_upgrade (gtm_thread *tx);\n   void write_upgrade_finish (gtm_thread *tx);\n \n+  // Returns true iff there is a concurrent active or waiting writer.\n+  // This is primarily useful for simple HyTM approaches, and the value being\n+  // checked is loaded with memory_order_relaxed.\n+  bool is_write_locked()\n+  {\n+    return summary.load (memory_order_relaxed) & (a_writer | w_writer);\n+  }\n+\n  protected:\n   bool write_lock_generic (gtm_thread *tx);\n };"}, {"sha": "ef959607fb66d109ff43cbf3539ccc46a06c6374", "filename": "libitm/config/x86/target.h", "status": "modified", "additions": 66, "deletions": 15, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfig%2Fx86%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfig%2Fx86%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Ftarget.h?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+/* Copyright (C) 2008, 2009, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU Transactional Memory Library (libitm).\n@@ -22,6 +22,10 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+// We'll be using some of the cpu builtins, and their associated types.\n+#include <x86intrin.h>\n+#include <cpuid.h>\n+\n namespace GTM HIDDEN {\n \n /* ??? This doesn't work for Win64.  */\n@@ -62,19 +66,66 @@ cpu_relax (void)\n   __builtin_ia32_pause ();\n }\n \n-} // namespace GTM\n+// Use Intel RTM if supported by the assembler.\n+// See gtm_thread::begin_transaction for how these functions are used.\n+#ifdef HAVE_AS_RTM\n+#define USE_HTM_FASTPATH\n \n-// We'll be using some of the cpu builtins, and their associated types.\n-#ifndef __cplusplus\n-/* ??? It's broken for C++. */\n-#include <x86intrin.h>\n-#else\n-# ifdef __SSE2__\n-#  include <emmintrin.h>\n-# elif defined(__SSE__)\n-#  include <xmmintrin.h>\n-# endif\n-# ifdef __AVX__\n-#  include <immintrin.h>\n-# endif\n+static inline bool\n+htm_available ()\n+{\n+  const unsigned cpuid_rtm = bit_RTM;\n+  if (__get_cpuid_max (0, NULL) >= 7)\n+    {\n+      unsigned a, b, c, d;\n+      __cpuid_count (7, 0, a, b, c, d);\n+      if (b & cpuid_rtm)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+static inline uint32_t\n+htm_init ()\n+{\n+  // Maximum number of times we try to execute a transaction as a HW\n+  // transaction.\n+  // ??? Why 2?  Any offline or runtime tuning necessary?\n+  return htm_available () ? 2 : 0;\n+}\n+\n+static inline uint32_t\n+htm_begin ()\n+{\n+  return _xbegin();\n+}\n+\n+static inline bool\n+htm_begin_success (uint32_t begin_ret)\n+{\n+  return begin_ret == _XBEGIN_STARTED;\n+}\n+\n+static inline void\n+htm_commit ()\n+{\n+  _xend();\n+}\n+\n+static inline void\n+htm_abort ()\n+{\n+  // ??? According to a yet unpublished ABI rule, 0xff is reserved and\n+  // supposed to signal a busy lock.  Source: andi.kleen@intel.com\n+  _xabort(0xff);\n+}\n+\n+static inline bool\n+htm_abort_should_retry (uint32_t begin_ret)\n+{\n+  return begin_ret & _XABORT_RETRY;\n+}\n #endif\n+\n+\n+} // namespace GTM"}, {"sha": "74cb0b5487666d806bd80058bbd70285c8c5f03f", "filename": "libitm/configure.tgt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure.tgt?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -61,6 +61,7 @@ case \"${target_cpu}\" in\n \t      XCFLAGS=\"${XCFLAGS} -fomit-frame-pointer\"\n \t    fi\n \tesac\n+\tXCFLAGS=\"${XCFLAGS} -mrtm\"\n \tARCH=x86\n \t;;\n \n@@ -101,6 +102,7 @@ case \"${target_cpu}\" in\n \t    XCFLAGS=\"${XCFLAGS} -fomit-frame-pointer\"\n \t    ;;\n \tesac\n+\tXCFLAGS=\"${XCFLAGS} -mrtm\"\n \tARCH=x86\n \t;;\n "}, {"sha": "4dfcda9c7de9b7b5f4ed3cdf0420768f56193f9c", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -332,9 +332,14 @@ extern abi_dispatch *dispatch_serialirr();\n extern abi_dispatch *dispatch_serialirr_onwrite();\n extern abi_dispatch *dispatch_gl_wt();\n extern abi_dispatch *dispatch_ml_wt();\n+extern abi_dispatch *dispatch_htm();\n \n extern gtm_cacheline_mask gtm_mask_stack(gtm_cacheline *, gtm_cacheline_mask);\n \n+// Control variable for the HTM fastpath that uses serial mode as fallback.\n+// Non-zero if the HTM fastpath is enabled. See gtm_thread::begin_transaction.\n+extern uint32_t htm_fastpath;\n+\n } // namespace GTM\n \n #endif // LIBITM_I_H"}, {"sha": "38857dcc80dcbb937f66e7ecf18426ef3d0f9fd3", "filename": "libitm/method-serial.cc", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fmethod-serial.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fmethod-serial.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-serial.cc?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -212,11 +212,46 @@ class serialirr_onwrite_dispatch : public serialirr_dispatch\n   }\n };\n \n+// This group is pure HTM with serial mode as a fallback.  There is no\n+// difference to serial_mg except that we need to enable or disable the HTM\n+// fastpath.  See gtm_thread::begin_transaction.\n+struct htm_mg : public method_group\n+{\n+  virtual void init()\n+  {\n+    // Enable the HTM fastpath if the HW is available.  The fastpath is\n+    // initially disabled.\n+#ifdef USE_HTM_FASTPATH\n+    htm_fastpath = htm_init();\n+#endif\n+  }\n+  virtual void fini()\n+  {\n+    // Disable the HTM fastpath.\n+    htm_fastpath = 0;\n+  }\n+};\n+\n+static htm_mg o_htm_mg;\n+\n+// We just need the subclass to associate it with the HTM method group that\n+// sets up the HTM fast path.  This will use serial_dispatch as fallback for\n+// transactions that might get canceled; it has a different method group, but\n+// this is harmless for serial dispatchs because they never abort.\n+class htm_dispatch : public serialirr_dispatch\n+{\n+ public:\n+  htm_dispatch() : serialirr_dispatch(false, true, false, false,\n+      gtm_thread::STATE_SERIAL | gtm_thread::STATE_IRREVOCABLE, &o_htm_mg)\n+  { }\n+};\n+\n } // anon namespace\n \n static const serialirr_dispatch o_serialirr_dispatch;\n static const serial_dispatch o_serial_dispatch;\n static const serialirr_onwrite_dispatch o_serialirr_onwrite_dispatch;\n+static const htm_dispatch o_htm_dispatch;\n \n abi_dispatch *\n GTM::dispatch_serialirr ()\n@@ -237,13 +272,26 @@ GTM::dispatch_serialirr_onwrite ()\n       const_cast<serialirr_onwrite_dispatch *>(&o_serialirr_onwrite_dispatch);\n }\n \n+abi_dispatch *\n+GTM::dispatch_htm ()\n+{\n+  return const_cast<htm_dispatch *>(&o_htm_dispatch);\n+}\n+\n // Put the transaction into serial-irrevocable mode.\n \n void\n GTM::gtm_thread::serialirr_mode ()\n {\n   struct abi_dispatch *disp = abi_disp ();\n \n+#if defined(USE_HTM_FASTPATH)\n+  // HTM fastpath.  If we are executing a HW transaction, don't go serial but\n+  // continue.  See gtm_thread::begin_transaction.\n+  if (likely(htm_fastpath && !gtm_thread::serial_lock.is_write_locked()))\n+    return;\n+#endif\n+\n   if (this->state & STATE_SERIAL)\n     {\n       if (this->state & STATE_IRREVOCABLE)"}, {"sha": "bb7a1f574a104107f026a330f1fba957a84e8986", "filename": "libitm/retry.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fretry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64fbcc74a336dd37eed05336788188ad9374f6e1/libitm%2Fretry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fretry.cc?ref=64fbcc74a336dd37eed05336788188ad9374f6e1", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+/* Copyright (C) 2008, 2009, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU Transactional Memory Library (libitm).\n@@ -254,6 +254,11 @@ parse_default_method()\n       disp = GTM::dispatch_ml_wt();\n       env += 5;\n     }\n+  else if (strncmp(env, \"htm\", 3) == 0)\n+    {\n+      disp = GTM::dispatch_htm();\n+      env += 3;\n+    }\n   else\n     goto unknown;\n \n@@ -311,7 +316,15 @@ GTM::gtm_thread::number_of_threads_changed(unsigned previous, unsigned now)\n \tset_default_dispatch(default_dispatch_user);\n       else\n \t{\n-\t  abi_dispatch* a = dispatch_ml_wt();\n+\t  // If HTM is available, use it by default with serial mode as\n+\t  // fallback.  Otherwise, use ml_wt because it probably scales best.\n+\t  abi_dispatch* a;\n+#ifdef USE_HTM_FASTPATH\n+\t  if (htm_available())\n+\t    a = dispatch_htm();\n+\t  else\n+#endif\n+\t    a = dispatch_ml_wt();\n \t  if (a->supports(now))\n \t    set_default_dispatch(a);\n \t  else"}]}