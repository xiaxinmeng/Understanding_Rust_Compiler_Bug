{"sha": "1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "node_id": "C_kwDOANBUbNoAKDFjMWRhY2ExY2RmN2JjMDE1NmQ1N2JiMmI5MDgzZWU3MGM2NmIwMDA", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-17T22:12:46Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-18T23:20:15Z"}, "message": "analyzer: add tests of boxed values [PR104943]\n\nThis patch adds various regression tests as preparatory work for\npurging irrelevant local decls from state (PR analyzer/104943)\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/104943\n\t* gcc.dg/analyzer/boxed-malloc-1-29.c: New test.\n\t* gcc.dg/analyzer/boxed-malloc-1.c: New test.\n\t* gcc.dg/analyzer/taint-alloc-5.c: New test.\n\t* gcc.dg/analyzer/torture/boxed-int-1.c: New test.\n\t* gcc.dg/analyzer/torture/boxed-ptr-1.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "4227c05274b7535b5a5f78b311c3caccdf3aec86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4227c05274b7535b5a5f78b311c3caccdf3aec86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c016888ffd569c4b70722cf7df2efcc003f397b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c016888ffd569c4b70722cf7df2efcc003f397b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c016888ffd569c4b70722cf7df2efcc003f397b"}], "stats": {"total": 785, "additions": 785, "deletions": 0}, "files": [{"sha": "9e38f97fc8ec2e0c68c0b35940f839e6ba5f26d0", "filename": "gcc/testsuite/gcc.dg/analyzer/boxed-malloc-1-29.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1-29.c?ref=1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "patch": "@@ -0,0 +1,36 @@\n+/* Isolating this false positive from boxed-malloc-1.c since it's\n+   reported within boxed_malloc.  */\n+\n+#include <stdlib.h>\n+\n+typedef struct boxed_ptr { void *value; } boxed_ptr;\n+\n+boxed_ptr\n+boxed_malloc (size_t sz)\n+{\n+  boxed_ptr result;\n+  result.value = malloc (sz);\n+  return result; /* { dg-bogus \"leak\" \"leak false +ve (PR analyzer/104979)\" { xfail *-*-* } } */\n+}\n+\n+boxed_ptr\n+boxed_free (boxed_ptr ptr)\n+{\n+  free (ptr.value);\n+}\n+\n+const boxed_ptr boxed_null = {NULL};\n+\n+struct link\n+{\n+  boxed_ptr m_ptr;\n+};\n+\n+boxed_ptr test_29 (void)\n+{\n+  boxed_ptr res = boxed_malloc (sizeof (struct link));\n+  if (!res.value)\n+    return boxed_null;\n+  ((struct link *)res.value)->m_ptr = boxed_malloc (sizeof (struct link));\n+  return res;\n+}"}, {"sha": "5428f2baf49fd057207337968ba223add68118d4", "filename": "gcc/testsuite/gcc.dg/analyzer/boxed-malloc-1.c", "status": "added", "additions": 476, "deletions": 0, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1.c?ref=1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "patch": "@@ -0,0 +1,476 @@\n+/* Adapted from malloc-1.c, but wrapping the pointers in a struct.  */\n+\n+/* { dg-require-effective-target alloca } */\n+\n+#include <stdlib.h>\n+\n+extern int foo (void);\n+extern int bar (void);\n+extern void could_free (void *);\n+extern void cant_free (const void *); /* since it's a const void *.  */\n+\n+typedef struct boxed_ptr { void *value; } boxed_ptr;\n+\n+boxed_ptr\n+boxed_malloc (size_t sz)\n+{\n+  boxed_ptr result;\n+  result.value = malloc (sz);\n+  return result;\n+}\n+\n+boxed_ptr\n+boxed_free (boxed_ptr ptr)\n+{\n+  free (ptr.value);\n+}\n+\n+const boxed_ptr boxed_null = {NULL};\n+\n+void test_1 (void)\n+{\n+  boxed_ptr ptr;\n+  ptr.value = malloc (1024);\n+  free (ptr.value);\n+  free (ptr.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */\n+}\n+\n+void test_2 (boxed_ptr ptr)\n+{\n+  free (ptr.value);\n+  free (ptr.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */\n+}\n+\n+boxed_ptr\n+test_3 (void)\n+{\n+  boxed_ptr ptr;\n+  ptr.value = malloc (sizeof (int));\n+  *(int *)ptr.value = 42; /* { dg-warning \"dereference of possibly-NULL 'ptr.value' \\\\\\[CWE-690\\\\\\]\" } */\n+  return ptr;\n+}\n+\n+boxed_ptr\n+test_4 (void)\n+{\n+  boxed_ptr ptr;\n+  ptr.value = malloc (sizeof (int));\n+  int *iptr = (int *)ptr.value;\n+  if (iptr)\n+    *iptr = 42;\n+  else\n+    *iptr = 43; /* { dg-warning \"dereference of NULL 'iptr' \\\\\\[CWE-476\\\\\\]\" } */\n+  return ptr;\n+}\n+\n+int test_5 (boxed_ptr ptr)\n+{\n+  free (ptr.value);\n+  return *(int *)ptr.value; /* { dg-warning \"use after 'free' of 'ptr.value'\" } */\n+}\n+\n+void test_6 (void *ptr)\n+{\n+  boxed_ptr q;\n+  q.value = ptr;\n+  free (ptr);\n+  free (q.value); /* { dg-warning \"double-'free' of 'ptr'\" } */\n+}\n+\n+void test_6a (boxed_ptr ptr)\n+{\n+  boxed_ptr q;\n+  q = ptr;\n+  boxed_free (ptr);\n+  free (q.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */\n+}\n+\n+void test_7 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc(4096);\n+  if (!ptr.value)\n+    return;\n+  __builtin_memset(ptr.value, 0, 4096);\n+  boxed_free(ptr);\n+}\n+\n+boxed_ptr test_8 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc(4096);\n+  if (!ptr.value)\n+    return boxed_null;\n+  __builtin_memset(ptr.value, 0, 4096);\n+  return ptr;\n+}\n+\n+void test_9 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    free (ptr.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */\n+}\n+\n+void test_10 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    foo ();\n+\n+  free (ptr.value);\n+  free (ptr.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */ \n+}\n+\n+void test_11 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+\n+  while (foo ())\n+    bar ();\n+\n+  free (ptr.value);\n+  free (ptr.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */\n+}\n+\n+void test_12 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+\n+  while (1)\n+    {\n+      free (ptr.value);\n+      free (ptr.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */\n+    }\n+}\n+\n+void test_13 (void)\n+{\n+  boxed_ptr p = boxed_malloc (1024);\n+  boxed_ptr q = boxed_malloc (1024);\n+\n+  foo ();\n+  if (!q.value)\n+    {\n+      boxed_free (q);\n+      return; /* { dg-warning \"leak of 'p.value'\" } */ \n+    }\n+  bar ();\n+  boxed_free (q);\n+  boxed_free (p);\n+}\n+\n+void test_14 (void)\n+{\n+  boxed_ptr p, q;\n+  p = boxed_malloc (1024);\n+  if (!p.value)\n+    return;\n+\n+  q = boxed_malloc (1024);\n+  if (!q.value)\n+    {\n+      boxed_free (p);\n+      boxed_free (q);\n+      /* oops: missing \"return\".  */\n+    }\n+  bar ();\n+  boxed_free (q); /* Although this looks like a double-'free' of q,\n+\t       it's known to be NULL for the case where free is\n+\t       called twice on it.  */\n+  free (p.value); /* { dg-warning \"double-'free' of 'p.value'\" } */\n+}\n+\n+void test_15 (void)\n+{\n+  boxed_ptr p, q;\n+  p.value = NULL;\n+  q.value = NULL;\n+\n+  p = boxed_malloc (1024);\n+  if (!p.value)\n+    goto fail;\n+\n+  foo ();\n+\n+  q = boxed_malloc (1024);\n+  if (!q.value)\n+    goto fail;\n+\n+  bar ();\n+\n+ fail:\n+  boxed_free (q);\n+  boxed_free (p);\n+}\n+\n+void test_16 (void)\n+{\n+  boxed_ptr p, q; /* { dg-message \"region created on stack here\" } */\n+\n+  p = boxed_malloc (1024);\n+  if (!p.value)\n+    goto fail;\n+\n+  foo ();\n+\n+  q = boxed_malloc (1024);\n+  if (!q.value)\n+    goto fail;\n+\n+  bar ();\n+\n+ fail:\n+  boxed_free (q); /* { dg-warning \"use of uninitialized value 'q'\" } */\n+  boxed_free (p);\n+}\n+\n+void test_17 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+} /* { dg-warning \"leak of 'ptr.value'\" } */ \n+\n+void test_18 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (64);\n+  ptr = boxed_null; /* { dg-warning \"leak of 'ptr.value'\" } */ \n+}\n+\n+void test_18a (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (64);\n+  ptr.value = NULL; /* { dg-warning \"leak of 'ptr.value'\" } */ \n+}\n+\n+void test_19 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (64);\n+  free (ptr.value);\n+  ptr.value = NULL;\n+  free (ptr.value);\n+}\n+\n+boxed_ptr global_ptr_20;\n+\n+void test_20 (void)\n+{\n+  global_ptr_20 = boxed_malloc (1024);\n+}\n+\n+int *test_21 (int i)\n+{\n+  boxed_ptr ptr = boxed_malloc (sizeof (int));\n+  if (!ptr.value)\n+    abort ();\n+  *(int *)ptr.value = i;\n+  return ptr.value;\n+}\n+\n+boxed_ptr test_21a (int i)\n+{\n+  boxed_ptr ptr = boxed_malloc (sizeof (int));\n+  if (!ptr.value)\n+    abort ();\n+  *(int *)ptr.value = i;\n+  return ptr;\n+}\n+\n+void test_22 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+\n+  int i;\n+  for (i = 5; i < 10; i++)\n+    foo ();\n+\n+  free (ptr.value);\n+  free (ptr.value); /* { dg-warning \"double-'free' of 'ptr.value'\" } */ \n+}\n+\n+int test_24 (void)\n+{\n+  boxed_ptr ptr;\n+  ptr.value = __builtin_alloca (sizeof (int)); /* { dg-message \"region created on stack here\" } */\n+  free (ptr.value); /* { dg-warning \"'free' of 'ptr.value' which points to memory on the stack \\\\\\[CWE-590\\\\\\]\" } */\n+}\n+\n+int test_25 (void)\n+{\n+  char tmp[100]; /* { dg-message \"region created on stack here\" } */\n+  boxed_ptr p;\n+  p.value = tmp;\n+  free (p.value); /* { dg-warning \"'free' of '&tmp' which points to memory on the stack \\\\\\[CWE-590\\\\\\]\" } */\n+}\n+\n+char global_buffer[100]; /* { dg-message \"region created here\" } */\n+\n+int test_26 (void)\n+{\n+  boxed_ptr p;\n+  p.value = global_buffer;\n+  free (p.value); /* { dg-warning \"'free' of '&global_buffer' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n+}\n+\n+struct coord {\n+  float x;\n+  float y;\n+};\n+\n+boxed_ptr test_27 (void)\n+{\n+  boxed_ptr p = boxed_malloc (sizeof (struct coord));\n+  ((struct coord *)p.value)->x = 0.f;  /* { dg-warning \"dereference of possibly-NULL 'p.value' \\\\\\[CWE-690\\\\\\]\" } */\n+\n+  /* Only the first such usage should be reported: */\n+  ((struct coord *)p.value)->y = 0.f;\n+\n+  return p;\n+}\n+\n+struct link\n+{\n+  boxed_ptr m_ptr;\n+};\n+\n+void test_31 (void)\n+{\n+  struct link tmp;\n+  boxed_ptr ptr = boxed_malloc (sizeof (struct link));\n+  tmp.m_ptr = ptr;\n+} /* { dg-warning \"leak\" } */ \n+\n+void test_32 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+  could_free (ptr.value);\n+} /* { dg-bogus \"leak\" } */\n+\n+void test_33 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc (1024);\n+  cant_free (ptr.value);\n+} /* { dg-warning \"leak of 'ptr.value'\" } */ \n+\n+void test_34 (void)\n+{\n+  float *q;\n+  boxed_ptr p = boxed_malloc (sizeof (struct coord));\n+  if (!p.value)\n+    return;\n+  ((struct coord *)p.value)->x = 0.0f;\n+  q = &((struct coord *)p.value)->x;\n+  boxed_free (p);\n+  *q = 1.0f; /* { dg-warning \"use after 'free' of 'q'\" } */\n+};\n+\n+int test_35 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc(4096);\n+  if (!ptr.value)\n+    return -1;\n+  __builtin_memset(ptr.value, 0, 4096);\n+  boxed_free(ptr);\n+  return 0;\n+}\n+\n+void test_36 (void)\n+{\n+  boxed_ptr ptr = boxed_malloc(4096);\n+  if (!ptr.value)\n+    return;\n+  __builtin_memset(ptr.value, 0, 4096);\n+  boxed_free(ptr);\n+}\n+\n+boxed_ptr test_37a (void)\n+{\n+  boxed_ptr ptr = boxed_malloc(4096);\n+  __builtin_memset(ptr.value, 0, 4096); /* { dg-warning \"use of possibly-NULL 'ptr.value' where non-null expected \\\\\\[CWE-690\\\\\\]\" } */\n+  return ptr;\n+}\n+\n+int test_37b (void)\n+{\n+  boxed_ptr p = boxed_malloc(4096);\n+  boxed_ptr q = boxed_malloc(4096);\n+  if (p.value) {\n+    __builtin_memset(p.value, 0, 4096); /* Not a bug: checked */\n+  } else {\n+    __builtin_memset(q.value, 0, 4096); /* { dg-warning \"use of possibly-NULL 'q.value' where non-null expected \\\\\\[CWE-690\\\\\\]\" } */\n+  }\n+  boxed_free(p);\n+  boxed_free(q);\n+  return 0;\n+}\n+\n+extern void might_use_ptr (void *ptr);\n+\n+void test_38(int i)\n+{\n+  boxed_ptr p;\n+\n+  p = boxed_malloc(1024);\n+  if (p.value) {\n+    boxed_free(p);\n+    might_use_ptr(p.value); /* { dg-warning \"use after 'free' of 'p.value'\" \"\" { xfail *-*-* } } */\n+    // TODO: xfail\n+  }\n+}\n+\n+boxed_ptr\n+test_39 (int i)\n+{\n+  boxed_ptr p = boxed_malloc(sizeof(int*));\n+  *(int *)p.value = i; /* { dg-warning \"dereference of possibly-NULL 'p.value' \\\\\\[CWE-690\\\\\\]\" } */\n+  return p;\n+}\n+\n+boxed_ptr\n+test_41 (int flag)\n+{\n+  boxed_ptr buffer;\n+\n+  if (flag) {\n+    buffer = boxed_malloc(4096);\n+  } else {\n+    buffer = boxed_null;\n+  }\n+\n+  ((char *)buffer.value)[0] = 'a'; /* { dg-warning \"dereference of possibly-NULL 'buffer.value' \\\\\\[CWE-690\\\\\\]\" \"possibly-NULL\" } */\n+  /* { dg-warning \"dereference of NULL\" \"NULL\" { target *-*-* } .-1 } */\n+\n+  return buffer;\n+}\n+\n+extern void might_take_ownership (boxed_ptr ptr);\n+\n+void test_45 (void)\n+{\n+  boxed_ptr p = boxed_malloc (1024);\n+  might_take_ownership (p);\n+}\n+\n+/* Free of function, and of label within function.  */\n+\n+void test_50a (void)\n+{\n+}\n+\n+void test_50b (void)\n+{\n+  boxed_ptr ptr;\n+  ptr.value = test_50a;\n+  free (ptr.value); /* { dg-warning \"'free' of '&test_50a' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n+}\n+\n+void test_50c (void)\n+{\n+ my_label:\n+  boxed_ptr ptr;\n+  ptr.value = &&my_label;\n+  free (ptr.value); /* { dg-warning \"'free' of '&my_label' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n+}\n+\n+/* { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" } */"}, {"sha": "9a159800c61971dae1f22f1659e3e730d169f0b9", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-alloc-5.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-5.c?ref=1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "patch": "@@ -0,0 +1,21 @@\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+\n+struct foo\n+{\n+  int num;\n+};\n+\n+/* malloc with tainted size from a field.  */\n+\n+void * __attribute__ ((tainted_args))\n+test_1 (struct foo f)\n+{\n+  __analyzer_dump_state (\"taint\", f.num); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", f.num * 16); /* { dg-warning \"state: 'tainted'\" } */\n+\n+  return __builtin_malloc (f.num * 16); /* { dg-warning \"use of attacker-controlled value 'f\\\\.num \\\\* 16' as allocation size without upper-bounds checking\" \"warning\" } */\n+  /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'f\\\\.num \\\\* 16' as allocation size without upper-bounds checking\" \"final event with expr\" { target *-*-* } .-1 } */\n+}"}, {"sha": "94111e66a8bf896e649324ccdd4ce8431de864cd", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/boxed-int-1.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-int-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-int-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-int-1.c?ref=1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "patch": "@@ -0,0 +1,170 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+#include \"../analyzer-decls.h\"\n+\n+typedef struct boxed_int { int value; } boxed_int;\n+\n+extern boxed_int boxed_int_add (boxed_int a, boxed_int b);\n+extern boxed_int boxed_int_mul (boxed_int a, boxed_int b);\n+\n+boxed_int  __attribute__((noinline))\n+noinline_boxed_int_add (boxed_int a, boxed_int b)\n+{\n+  boxed_int result;\n+  result.value = a.value + b.value;\n+  return result;\n+}\n+\n+static inline boxed_int\n+inline_boxed_int_add (boxed_int a, boxed_int b)\n+{\n+  boxed_int result;\n+  result.value = a.value + b.value;\n+  return result;\n+}\n+\n+boxed_int\n+test_1 (boxed_int a, boxed_int b)\n+{\n+  boxed_int result = boxed_int_add (boxed_int_mul (a, a),\n+\t\t\t\t    boxed_int_mul (b, b));\n+  return result;\n+}\n+\n+void\n+test_2a (void)\n+{\n+  boxed_int arr[4];\n+  arr[0].value = 1;\n+  arr[1].value = 2;\n+  arr[2].value = 3;\n+  arr[3].value = 4;\n+  boxed_int sum;\n+  sum.value = arr[0].value + arr[1].value + arr[2].value + arr[3].value;\n+  __analyzer_eval (sum.value == 10); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void\n+test_2b (void)\n+{\n+  boxed_int a, b, c, d;\n+  a.value = 1;\n+  b.value = 2;\n+  c.value = 3;\n+  d.value = 4;\n+  boxed_int sum;\n+  sum.value = a.value + b.value + c.value + d.value;\n+  __analyzer_eval (sum.value == 10); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void\n+test_2c (void)\n+{\n+  boxed_int a, b, c, d;\n+  a.value = 1;\n+  b.value = 2;\n+  c.value = 3;\n+  d.value = 4;\n+  boxed_int sum = inline_boxed_int_add (inline_boxed_int_add (a, b),\n+\t\t\t\t\tinline_boxed_int_add (c, d));\n+  __analyzer_eval (sum.value == 10); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void\n+test_2d (void)\n+{\n+  boxed_int a, b, c, d;\n+  a.value = 1;\n+  b.value = 2;\n+  c.value = 3;\n+  d.value = 4;\n+  boxed_int sum = noinline_boxed_int_add (noinline_boxed_int_add (a, b),\n+\t\t\t\t\t  noinline_boxed_int_add (c, d));\n+  __analyzer_eval (sum.value == 10); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Pointer to a local.  */\n+\n+void test_4 (void)\n+{\n+  boxed_int i;\n+  int *p = &i.value;\n+  i.value = 1;\n+  *p = 2;\n+  __analyzer_eval (i.value == 2); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Local array.  */\n+\n+void test_5 (void)\n+{\n+  boxed_int a[10];\n+  a[3].value = 5; /* ARRAY_REF.  */\n+  __analyzer_eval (a[3].value == 5); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Local array, but using an unknown index.  */\n+\n+void test_5a (int idx)\n+{\n+  boxed_int a[10];\n+  a[idx].value = 5; /* ARRAY_REF.  */\n+  __analyzer_eval (a[idx].value == 5); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Array passed in as a param.  */\n+\n+void test_6 (boxed_int a[10])\n+{\n+  /* POINTER_PLUS_EXPR then a MEM_REF.  */\n+  __analyzer_eval (a[3].value == 42); /* { dg-warning \"UNKNOWN\" } */\n+  a[3].value = 42;\n+  __analyzer_eval (a[3].value == 42); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Array passed in as a param ptr.  */\n+\n+void test_7 (boxed_int *a)\n+{\n+  __analyzer_eval (a[3].value == 42); /* { dg-warning \"UNKNOWN\" } */\n+  a[3].value = 42;\n+  __analyzer_eval (a[3].value == 42); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Globals.  */\n+\n+boxed_int glob_a;\n+\n+void test_10 (void)\n+{\n+  __analyzer_eval (glob_a.value == 42); /* { dg-warning \"UNKNOWN\" } */\n+  glob_a.value = 42;\n+  __analyzer_eval (glob_a.value == 42); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Use of uninit value.  */\n+int test_12a (void)\n+{\n+  boxed_int i; /* { dg-message \"region created on stack here\" } */\n+  return i.value; /* { dg-warning \"use of uninitialized value 'i.value'\" } */\n+}\n+\n+/* Use of uninit value.  */\n+boxed_int test_12b (void)\n+{\n+  boxed_int i; /* { dg-message \"region created on stack here\" } */\n+  return i; /* { dg-warning \"use of uninitialized value '\\[^\\n\\r\\]*'\" } */\n+}\n+\n+void test_loop (void)\n+{\n+  boxed_int i;\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (i.value=0; i.value<256; i.value++) {\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  }\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "8db93f109c7cae8855b085e7ccb6730b48ec0c9b", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/boxed-ptr-1.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-ptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1daca1cdf7bc0156d57bb2b9083ee70c66b000/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-ptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fboxed-ptr-1.c?ref=1c1daca1cdf7bc0156d57bb2b9083ee70c66b000", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+#include <stdlib.h>\n+#include \"../analyzer-decls.h\"\n+\n+typedef struct boxed_ptr { void *value; } boxed_ptr;\n+\n+boxed_ptr __attribute__((noinline))\n+boxed_malloc (size_t sz)\n+{\n+  boxed_ptr result;\n+  result.value = malloc (sz);\n+  return result;\n+}\n+\n+boxed_ptr __attribute__((noinline))\n+boxed_free (boxed_ptr ptr)\n+{\n+  free (ptr.value);\n+}\n+\n+const boxed_ptr boxed_null = {NULL};\n+\n+boxed_ptr test_1 (int flag)\n+{\n+  boxed_ptr ptr = boxed_malloc (sizeof (int));\n+\n+  if (flag) /* { dg-message \"following 'false' branch\" } */\n+    if (!ptr.value)\n+      return boxed_null;\n+\n+  *((int *)ptr.value) = 42; /* { dg-warning \"dereference of possibly-NULL '\\[^\\n\\r\\]*'\" } */\n+\n+  return ptr;\n+}\n+\n+void test_2 (int flag)\n+{\n+  boxed_ptr ptr;\n+\n+  if (flag)\n+    ptr = boxed_malloc (4096);\n+  else\n+    ptr = boxed_malloc (1024);\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+\n+  boxed_free (ptr);  \n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  /* TODO: ideally we would have purged the state of \"ptr\", and there would be\n+     just 1 enode here (PR analyzer/104943).  */\n+}\n+\n+void test_3 (int kind)\n+{\n+  boxed_ptr ptr;\n+\n+  switch (kind)\n+    {\n+    default:\n+      ptr = boxed_malloc (4096);\n+      break;\n+    case 0:\n+      ptr = boxed_malloc (128);\n+      break;\n+    case 1:\n+      ptr = boxed_malloc (1024);\n+      break;\n+    case 2:\n+      ptr = boxed_malloc (65536);\n+      break;\n+    }\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"4 processed enodes\" } */\n+\n+  boxed_free (ptr);  \n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"4 processed enodes\" } */\n+  /* TODO: ideally we would have purged the state of \"ptr\", and there would be\n+     just 1 enode here (PR analyzer/104943).  */  \n+}"}]}