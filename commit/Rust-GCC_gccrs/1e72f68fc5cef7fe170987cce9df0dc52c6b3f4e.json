{"sha": "1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU3MmY2OGZjNWNlZjdmZTE3MDk4N2NjZTlkZjBkYzUyYzZiM2Y0ZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-01T23:30:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-01T23:30:43Z"}, "message": "(choose_temp_base): Try multiple variables.\n\n(choose_temp_base): Try multiple variables.  Don't\nassume that the variable points to a valid directory.\n\n(pexecute): Handle the MS-DOS return codes correctly.\nAdd .exe to file name when appropriate.\n\nFrom-SVN: r4822", "tree": {"sha": "a6280b897350ef484805b5ad7105000de24f8cd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6280b897350ef484805b5ad7105000de24f8cd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e/comments", "author": null, "committer": null, "parents": [{"sha": "6e6c83178f05b3bf60f5c1801d2c6d06e0c49cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6c83178f05b3bf60f5c1801d2c6d06e0c49cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e6c83178f05b3bf60f5c1801d2c6d06e0c49cfa"}], "stats": {"total": 88, "additions": 57, "deletions": 31}, "files": [{"sha": "972adb735f0bd43b78688e7d56a40677e5d8a1d4", "filename": "gcc/gcc.c", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=1e72f68fc5cef7fe170987cce9df0dc52c6b3f4e", "patch": "@@ -73,7 +73,7 @@ compilation is specified by a string called a \"spec\".  */\n    because there's no place else we can expect to use.  */\n #if __MSDOS__\n #ifndef P_tmpdir\n-#define P_tmpdir \"./\"\n+#define P_tmpdir \".\"\n #endif\n #endif\n \n@@ -1339,26 +1339,43 @@ clear_failure_queue ()\n /* Compute a string to use as the base of all temporary file names.\n    It is substituted for %g.  */\n \n+static char *\n+choose_temp_base_try (try, base)\n+char *try;\n+char *base;\n+{\n+  char *rv;\n+  if (base)\n+    rv = base;\n+  else if (try == (char *)0)\n+    rv = 0;\n+  else if (access (try, R_OK | W_OK) != 0)\n+    rv = 0;\n+  else\n+    rv = try;\n+  return rv;\n+}\n+\n static void\n choose_temp_base ()\n {\n-  char *base = getenv (\"TMPDIR\");\n+  char *base = 0;\n   int len;\n \n-  if (base == (char *)0)\n-    {\n+  base = choose_temp_base_try (getenv (\"TMPDIR\"), base);\n+  base = choose_temp_base_try (getenv (\"TMP\"), base);\n+  base = choose_temp_base_try (getenv (\"TEMP\"), base);\n+\n #ifdef P_tmpdir\n-      if (access (P_tmpdir, R_OK | W_OK) == 0)\n-\tbase = P_tmpdir;\n+  base = choose_temp_base_try (P_tmpdir, base);\n #endif\n-      if (base == (char *)0)\n-\t{\n-\t  if (access (\"/usr/tmp\", R_OK | W_OK) == 0)\n-\t    base = \"/usr/tmp/\";\n-\t  else\n-\t    base = \"/tmp/\";\n-\t}\n-    }\n+\n+  base = choose_temp_base_try (\"/usr/tmp\", base);\n+  base = choose_temp_base_try (\"/tmp\", base);\n+\n+  /* If all else fails, use the current directory! */  \n+  if (base == (char *)0)\n+    base = \"./\";\n \n   len = strlen (base);\n   temp_filename = xmalloc (len + sizeof(\"/ccXXXXXX\"));\n@@ -1727,32 +1744,41 @@ pexecute (search_flag, program, argv, not_last)\n      char *argv[];\n      int not_last;\n {\n-  char *scmd;\n+  char *scmd, *rf;\n   FILE *argfile;\n-  int i;\n+  int i, el = search_flag ? 0 : 4;\n \n-  scmd = (char *)malloc (strlen (program) + strlen (temp_filename) + 6);\n-  sprintf (scmd, \"%s @%s.gp\", program, temp_filename);\n-  argfile = fopen (scmd+strlen (program) + 2, \"w\");\n+  scmd = (char *)malloc (strlen (program) + strlen (temp_filename) + 6 + el);\n+  rf = scmd + strlen(program) + 2 + el;\n+  sprintf (scmd, \"%s%s @%s.gp\", program,\n+\t   (search_flag ? \"\" : \".exe\"), temp_filename);\n+  argfile = fopen (rf, \"w\");\n   if (argfile == 0)\n-    pfatal_with_name (scmd + strlen (program) + 2);\n+    pfatal_with_name (rf);\n \n   for (i=1; argv[i]; i++)\n-  {\n-    char *cp;\n-    for (cp = argv[i]; *cp; cp++)\n-      {\n-\tif (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || isspace (*cp))\n-\t  fputc ('\\\\', argfile);\n-\tfputc (*cp, argfile);\n-      }\n-    fputc ('\\n', argfile);\n-  }\n+    {\n+      char *cp;\n+      for (cp = argv[i]; *cp; cp++)\n+\t{\n+\t  if (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || isspace (*cp))\n+\t    fputc ('\\\\', argfile);\n+\t  fputc (*cp, argfile);\n+\t}\n+      fputc ('\\n', argfile);\n+    }\n   fclose (argfile);\n \n   i = system (scmd);\n \n-  remove (scmd + strlen (program) + 2);\n+  remove (rf);\n+  \n+  if (i == -1)\n+    {\n+      perror_exec (program);\n+      return MIN_FATAL_STATUS << 8;\n+    }\n+\n   return i << 8;\n }\n "}]}