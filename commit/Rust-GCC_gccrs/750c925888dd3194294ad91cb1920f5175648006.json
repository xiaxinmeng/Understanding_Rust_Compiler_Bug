{"sha": "750c925888dd3194294ad91cb1920f5175648006", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUwYzkyNTg4OGRkMzE5NDI5NGFkOTFjYjE5MjBmNTE3NTY0ODAwNg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2001-06-07T07:54:54Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-06-07T07:54:54Z"}, "message": "* emit-rtl.c (operand_subword): Remove unused variable.\n\nFrom-SVN: r42953", "tree": {"sha": "bdbf79e49eb33096889bb5f5ae125be31758f64c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdbf79e49eb33096889bb5f5ae125be31758f64c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/750c925888dd3194294ad91cb1920f5175648006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/750c925888dd3194294ad91cb1920f5175648006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/750c925888dd3194294ad91cb1920f5175648006", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/750c925888dd3194294ad91cb1920f5175648006/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f890c4fd481bcfdd1f6667bd8aabc4f7d67f1638", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f890c4fd481bcfdd1f6667bd8aabc4f7d67f1638", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f890c4fd481bcfdd1f6667bd8aabc4f7d67f1638"}], "stats": {"total": 87, "additions": 45, "deletions": 42}, "files": [{"sha": "fe49c242265a6c70584aa83ef0e753832e92a115", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750c925888dd3194294ad91cb1920f5175648006/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750c925888dd3194294ad91cb1920f5175648006/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=750c925888dd3194294ad91cb1920f5175648006", "patch": "@@ -1,3 +1,7 @@\n+2001-06-07  Andreas Jaeger  <aj@suse.de>\n+\n+\t* emit-rtl.c (operand_subword): Remove unused variable.\n+\n Wed Jun  6 14:51:05 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (floatdi?f): Avoid usinf of SSE instructions"}, {"sha": "bc24f07c4c19cba82b854f39b65ad20d3a8743cf", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/750c925888dd3194294ad91cb1920f5175648006/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/750c925888dd3194294ad91cb1920f5175648006/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=750c925888dd3194294ad91cb1920f5175648006", "patch": "@@ -114,7 +114,7 @@ REAL_VALUE_TYPE dconstm1;\n \n    When to use frame_pointer_rtx and hard_frame_pointer_rtx is a little\n    tricky: until register elimination has taken place hard_frame_pointer_rtx\n-   should be used if it is being set, and frame_pointer_rtx otherwise.  After \n+   should be used if it is being set, and frame_pointer_rtx otherwise.  After\n    register elimination hard_frame_pointer_rtx should always be used.\n    On machines where the two registers are same (most) then these are the\n    same.\n@@ -406,7 +406,7 @@ gen_lowpart_SUBREG (mode, reg)\n **\n **\t\t...would be generated by the following C code:\n **\n-**\t    \tgen_rtx (PLUS, QImode,\n+**\t\tgen_rtx (PLUS, QImode,\n **\t\t    gen_rtx (MEM, QImode,\n **\t\t\tgen_rtx (REG, SImode, 1)),\n **\t\t    gen_rtx (MEM, QImode,\n@@ -724,7 +724,7 @@ subreg_hard_regno (x, check_mode)\n \n /* Return a value representing some low-order bits of X, where the number\n    of low-order bits is given by MODE.  Note that no conversion is done\n-   between floating-point and fixed-point values, rather, the bit \n+   between floating-point and fixed-point values, rather, the bit\n    representation is returned.\n \n    This function handles the cases in common between gen_lowpart, below,\n@@ -810,7 +810,7 @@ gen_lowpart_common (mode, x)\n   /* If X is an integral constant but we want it in floating-point, it\n      must be the case that we have a union of an integer and a floating-point\n      value.  If the machine-parameters allow it, simulate that union here\n-     and return the result.  The two-word and single-word cases are \n+     and return the result.  The two-word and single-word cases are\n      different.  */\n \n   else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n@@ -925,7 +925,7 @@ gen_lowpart_common (mode, x)\n \t}\n       else\n \t{\n-\t  low = CONST_DOUBLE_LOW (x); \n+\t  low = CONST_DOUBLE_LOW (x);\n \t  high = CONST_DOUBLE_HIGH (x);\n \t}\n \n@@ -1110,7 +1110,7 @@ gen_lowpart (mode, x)\n     abort ();\n }\n \n-/* Like `gen_lowpart', but refer to the most significant part. \n+/* Like `gen_lowpart', but refer to the most significant part.\n    This is used to access the imaginary part of a complex number.  */\n \n rtx\n@@ -1374,10 +1374,10 @@ constant_subword (op, offset, mode)\n       return GEN_INT (u.i);\n     }\n #endif /* no REAL_ARITHMETIC */\n-      \n+\n   /* The only remaining cases that we can handle are integers.\n      Convert to proper endianness now since these cases need it.\n-     At this point, offset == 0 means the low-order word.  \n+     At this point, offset == 0 means the low-order word.\n \n      We do not want to handle the case when BITS_PER_WORD <= HOST_BITS_PER_INT\n      in general.  However, if OP is (const_int 0), we can just return\n@@ -1442,7 +1442,6 @@ operand_subword (op, offset, validate_address, mode)\n      int validate_address;\n      enum machine_mode mode;\n {\n-  rtx new;\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n \n@@ -1487,7 +1486,7 @@ operand_subword (op, offset, validate_address, mode)\n \n /* Similar to `operand_subword', but never return 0.  If we can't extract\n    the required subword, put OP into a register and try again.  If that fails,\n-   abort.  We always validate the address in this case.  \n+   abort.  We always validate the address in this case.\n \n    MODE is the mode of OP, in case it is CONST_INT.  */\n \n@@ -1581,7 +1580,7 @@ change_address (memref, mode, addr)\n     }\n   else\n     addr = memory_address (mode, addr);\n-\t\n+\n   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))\n     return memref;\n \n@@ -1675,7 +1674,7 @@ free_emit_status (f)\n   f->emit = NULL;\n }\n \f\n-/* Go through all the RTL insn bodies and copy any invalid shared \n+/* Go through all the RTL insn bodies and copy any invalid shared\n    structure.  This routine should only be called once.  */\n \n void\n@@ -1694,7 +1693,7 @@ unshare_all_rtl (fndecl, insn)\n \n   /* Unshare just about everything else.  */\n   unshare_all_rtl_1 (insn);\n-  \n+\n   /* Make sure the addresses of stack slots found outside the insn chain\n      (such as, in DECL_RTL of a variable) are not shared\n      with the insn chain.\n@@ -1705,7 +1704,7 @@ unshare_all_rtl (fndecl, insn)\n   stack_slot_list = copy_rtx_if_shared (stack_slot_list);\n }\n \n-/* Go through all the RTL insn bodies and copy any invalid shared \n+/* Go through all the RTL insn bodies and copy any invalid shared\n    structure, again.  This is a fairly expensive thing to do so it\n    should be done sparingly.  */\n \n@@ -1842,7 +1841,7 @@ copy_rtx_if_shared (orig)\n     case MEM:\n       /* A MEM is allowed to be shared if its address is constant.\n \n-\t We used to allow sharing of MEMs which referenced \n+\t We used to allow sharing of MEMs which referenced\n \t virtual_stack_vars_rtx or virtual_incoming_args_rtx, but\n \t that can lose.  instantiate_virtual_regs will not unshare\n \t the MEMs, and combine may change the structure of the address\n@@ -1944,7 +1943,7 @@ reset_used_flags (x)\n     case BARRIER:\n       /* The chain of insns is not being copied.  */\n       return;\n-      \n+\n     default:\n       break;\n     }\n@@ -2079,7 +2078,7 @@ renumber_insns (stream)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (stream)\n-\tfprintf (stream, \"Renumbering insn %d to %d\\n\", \n+\tfprintf (stream, \"Renumbering insn %d to %d\\n\",\n \t\t INSN_UID (insn), cur_insn_uid);\n       INSN_UID (insn) = cur_insn_uid++;\n     }\n@@ -2401,13 +2400,13 @@ try_split (pat, trial, last)\n \t{\n \t  int i;\n \t  rtx eh_note;\n-\t  \n-\t  /* Avoid infinite loop if any insn of the result matches \n+\n+\t  /* Avoid infinite loop if any insn of the result matches\n \t     the original pattern.  */\n \t  for (i = 0; i < XVECLEN (seq, 0); i++)\n-  \t    if (GET_CODE (XVECEXP (seq, 0, i)) == INSN \n+\t    if (GET_CODE (XVECEXP (seq, 0, i)) == INSN\n \t\t&& rtx_equal_p (PATTERN (XVECEXP (seq, 0, i)), pat))\n-  \t      return trial;\n+\t      return trial;\n \n \t  /* Mark labels.  */\n \t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n@@ -2429,9 +2428,9 @@ try_split (pat, trial, last)\n \t      {\n \t\trtx insn = XVECEXP (seq, 0, i);\n \t\tif (GET_CODE (insn) == CALL_INSN\n-\t\t    || (flag_non_call_exceptions \n+\t\t    || (flag_non_call_exceptions\n \t\t\t&& may_trap_p (PATTERN (insn))))\n-\t\t  REG_NOTES (insn) \n+\t\t  REG_NOTES (insn)\n \t\t    = gen_rtx_EXPR_LIST (REG_EH_REGION, XEXP (eh_note, 0),\n \t\t\t\t\t REG_NOTES (insn));\n \t      }\n@@ -2470,8 +2469,8 @@ try_split (pat, trial, last)\n \n       /* Return either the first or the last insn, depending on which was\n \t requested.  */\n-      return last \n-\t\t? (after ? prev_active_insn (after) : last_insn) \n+      return last\n+\t\t? (after ? prev_active_insn (after) : last_insn)\n \t\t: next_active_insn (before);\n     }\n \n@@ -2506,7 +2505,7 @@ make_insn_raw (pattern)\n       debug_rtx (insn);\n     }\n #endif\n-  \n+\n   return insn;\n }\n \n@@ -3461,7 +3460,7 @@ force_next_line_note ()\n /* Place a note of KIND on insn INSN with DATUM as the datum. If a\n    note of this type already exists, remove it first. */\n \n-void \n+void\n set_unique_reg_note (insn, kind, datum)\n      rtx insn;\n      enum reg_note kind;\n@@ -3470,7 +3469,7 @@ set_unique_reg_note (insn, kind, datum)\n   rtx note = find_reg_note (insn, kind, NULL_RTX);\n \n   /* First remove the note if there already is one.  */\n-  if (note) \n+  if (note)\n     remove_note (insn, note);\n \n   REG_NOTES (insn) = gen_rtx_EXPR_LIST (kind, datum, REG_NOTES (insn));\n@@ -3650,7 +3649,7 @@ pop_topmost_sequence ()\n /* After emitting to a sequence, restore previous saved state.\n \n    To get the contents of the sequence just made, you must call\n-   `gen_sequence' *before* calling here.  \n+   `gen_sequence' *before* calling here.\n \n    If the compiler might have deferred popping arguments while\n    generating this sequence, and this sequence will not be immediately\n@@ -3714,7 +3713,7 @@ gen_sequence ()\n \n   /* If only one insn, return it rather than a SEQUENCE.\n      (Now that we cache SEQUENCE expressions, it isn't worth special-casing\n-     the case of an empty list.)     \n+     the case of an empty list.)\n      We only return the pattern of an insn if its code is INSN and it\n      has no notes.  This ensures that no information gets lost.  */\n   if (len == 1\n@@ -3822,7 +3821,7 @@ copy_insn_1 (orig)\n \t  && GET_CODE (XEXP (XEXP (orig, 0), 1)) == CONST_INT)\n \treturn orig;\n       break;\n-      \n+\n       /* A MEM with a constant address is not sharable.  The problem is that\n \t the constant address may need to be reloaded.  If the mem is shared,\n \t then reloading one copy of this mem will cause all copies to appear\n@@ -3851,7 +3850,7 @@ copy_insn_1 (orig)\n       copy->call = 0;\n       copy->frame_related = 0;\n     }\n-  \n+\n   format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n \n   for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n@@ -3959,7 +3958,7 @@ init_emit ()\n     = (unsigned char *) xcalloc (f->emit->regno_pointer_align_length,\n \t\t\t\t sizeof (unsigned char));\n \n-  regno_reg_rtx \n+  regno_reg_rtx\n     = (rtx *) xcalloc (f->emit->regno_pointer_align_length * sizeof (rtx),\n \t\t       sizeof (rtx));\n \n@@ -4044,9 +4043,9 @@ init_emit_once (line_numbers)\n   enum machine_mode double_mode;\n \n   /* Initialize the CONST_INT hash table.  */\n-  const_int_htab = htab_create (37, const_int_htab_hash, \n+  const_int_htab = htab_create (37, const_int_htab_hash,\n \t\t\t\tconst_int_htab_eq, NULL);\n-  ggc_add_root (&const_int_htab, 1, sizeof (const_int_htab), \n+  ggc_add_root (&const_int_htab, 1, sizeof (const_int_htab),\n \t\trtx_htab_mark);\n \n   no_line_numbers = ! line_numbers;\n@@ -4088,18 +4087,18 @@ init_emit_once (line_numbers)\n   stack_pointer_rtx = gen_raw_REG (Pmode, STACK_POINTER_REGNUM);\n   frame_pointer_rtx = gen_raw_REG (Pmode, FRAME_POINTER_REGNUM);\n   if (hard_frame_pointer_rtx == 0)\n-    hard_frame_pointer_rtx = gen_raw_REG (Pmode, \n+    hard_frame_pointer_rtx = gen_raw_REG (Pmode,\n \t\t\t\t\t  HARD_FRAME_POINTER_REGNUM);\n   if (arg_pointer_rtx == 0)\n     arg_pointer_rtx = gen_raw_REG (Pmode, ARG_POINTER_REGNUM);\n-  virtual_incoming_args_rtx = \n+  virtual_incoming_args_rtx =\n     gen_raw_REG (Pmode, VIRTUAL_INCOMING_ARGS_REGNUM);\n-  virtual_stack_vars_rtx = \n+  virtual_stack_vars_rtx =\n     gen_raw_REG (Pmode, VIRTUAL_STACK_VARS_REGNUM);\n-  virtual_stack_dynamic_rtx = \n+  virtual_stack_dynamic_rtx =\n     gen_raw_REG (Pmode, VIRTUAL_STACK_DYNAMIC_REGNUM);\n-  virtual_outgoing_args_rtx = \n-    gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM); \n+  virtual_outgoing_args_rtx =\n+    gen_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM);\n   virtual_cfa_rtx = gen_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n \n   /* These rtx must be roots if GC is enabled.  */\n@@ -4118,7 +4117,7 @@ init_emit_once (line_numbers)\n   /* Don't use gen_rtx here since gen_rtx in this case\n      tries to use these variables.  */\n   for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n-    const_int_rtx[i + MAX_SAVED_CONST_INT] = \n+    const_int_rtx[i + MAX_SAVED_CONST_INT] =\n       gen_rtx_raw_CONST_INT (VOIDmode, i);\n   ggc_add_rtx_root (const_int_rtx, 2 * MAX_SAVED_CONST_INT + 1);\n "}]}