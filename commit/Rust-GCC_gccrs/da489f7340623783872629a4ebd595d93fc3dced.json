{"sha": "da489f7340623783872629a4ebd595d93fc3dced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE0ODlmNzM0MDYyMzc4Mzg3MjYyOWE0ZWJkNTk1ZDkzZmMzZGNlZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-03-29T21:54:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-03-29T21:54:35Z"}, "message": "varasm.c (initializer_constant_valid_p): Don't deny DECL_DLLIMPORT_P on functions.\n\n\t* varasm.c (initializer_constant_valid_p): Don't deny\n\tDECL_DLLIMPORT_P on functions.\n\n\t* config/i386/cygming.h: Remove function declarations.\n\t(SUBTARGET_ENCODE_SECTION_INFO): Don't undef first.\n\t(ASM_OUTPUT_LABELREF): Remove.\n\t(COMMON_ASM_OP): Remove.\n\t(ASM_OUTPUT_COMMON): Remove.\n\t(ASM_OUTPUT_ALIGNED_DECL_COMMON): New.\n\t(ASM_DECLARE_OBJECT_NAME): Use i386_pe_maybe_record_exported_symbol.\n\t(ASM_DECLARE_FUNCTION_NAME): Likewise.\n\t* config/i386/i386-interix.h (SUBTARGET_ENCODE_SECTION_INFO):\n\tRename from TARGET_ENCODE_SECTION_INFO.\n\t* config/i386/netware.h: Likewise.\n\t* config/i386/i386-protos.h: Update.\n\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Turn ifdef\n\tof TARGET_DLLIMPORT_DECL_ATTRIBUTES into straight if.\n\t(legitimate_constant_p): Reject dllimports.\n\t(dllimport_map, get_dllimport_decl): New.\n\t(legitimize_dllimport_symbol): New.\n\t(legitimize_address, ix86_expand_move): Use it.\n\t(TARGET_BINDS_LOCAL_P): Redefine for TARGET_DLLIMPORT_DECL_ATTRIBUTES.\n\t* config/i386/i386.h (DLL_IMPORT_EXPORT_PREFIX): Remove.\n\t(SYMBOL_FLAG_DLLIMPORT, SYMBOL_REF_DLLIMPORT_P): New.\n\t(SYMBOL_FLAG_DLLEXPORT, SYMBOL_REF_DLLEXPORT_P): New.\n\t* config/i386/predicates.md (constant_call_address_operand): Only\n\taccept symbols; reject dllimport_p symbols.\n\t* config/i386/uwin.h (ASM_DECLARE_FUNCTION_NAME): Use\n\ti386_pe_maybe_record_exported_symbol.\n\t* config/i386/winnt.c (DLL_IMPORT_PREFIX, DLL_EXPORT_PREFIX): Remove.\n\t(i386_pe_determine_dllexport_p): Rename from i386_pe_dllexport_p.\n\t(i386_pe_determine_dllimport_p): Rename from i386_pe_dllimport_p;\n\ttrust the setting of DECL_DLLIMPORT_P.\n\t(i386_pe_dllexport_name_p, i386_pe_dllimport_name_p): Remove.\n\t(i386_pe_mark_dllexport, i386_pe_mark_dllimport): Remove.\n\t(gen_stdcall_or_fastcall_suffix): Return NULL if no change required;\n\ttidy the argument scanning loop.\n\t(i386_pe_encode_section_info): Set SYMBOL_FLAG_DLLIMPORT and\n\tSYMBOL_FLAG_DLLEXPORT in SYMBOL_REF_FLAGS.\n\t(i386_pe_strip_name_encoding): Remove.\n\t(i386_pe_binds_local_p): New.\n\t(i386_pe_strip_name_encoding_full): Use default_strip_name_encoding.\n\t(i386_pe_output_labelref): Remove.\n\t(i386_pe_asm_output_aligned_decl_common): New.\n\t(i386_pe_maybe_record_exported_symbol): Rename from\n\ti386_pe_record_exported_symbol; check for dllexported symbols.\n\nFrom-SVN: r123344", "tree": {"sha": "eb98f4ede31001adc419d6556b98962ff353afb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb98f4ede31001adc419d6556b98962ff353afb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da489f7340623783872629a4ebd595d93fc3dced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da489f7340623783872629a4ebd595d93fc3dced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da489f7340623783872629a4ebd595d93fc3dced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da489f7340623783872629a4ebd595d93fc3dced/comments", "author": null, "committer": null, "parents": [{"sha": "0c9bce0b5cfe0a037bdabd00cc783a37ff1f159c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9bce0b5cfe0a037bdabd00cc783a37ff1f159c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9bce0b5cfe0a037bdabd00cc783a37ff1f159c"}], "stats": {"total": 748, "additions": 386, "deletions": 362}, "files": [{"sha": "dc59fd773b0a326d57817b6c1e548f044b655303", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -1,3 +1,52 @@\n+2007-03-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* varasm.c (initializer_constant_valid_p): Don't deny\n+\tDECL_DLLIMPORT_P on functions.\n+\n+\t* config/i386/cygming.h: Remove function declarations.\n+\t(SUBTARGET_ENCODE_SECTION_INFO): Don't undef first.\n+\t(ASM_OUTPUT_LABELREF): Remove.\n+\t(COMMON_ASM_OP): Remove.\n+\t(ASM_OUTPUT_COMMON): Remove.\n+\t(ASM_OUTPUT_ALIGNED_DECL_COMMON): New.\n+\t(ASM_DECLARE_OBJECT_NAME): Use i386_pe_maybe_record_exported_symbol.\n+\t(ASM_DECLARE_FUNCTION_NAME): Likewise.\n+\t* config/i386/i386-interix.h (SUBTARGET_ENCODE_SECTION_INFO):\n+\tRename from TARGET_ENCODE_SECTION_INFO.\n+\t* config/i386/netware.h: Likewise.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Turn ifdef\n+\tof TARGET_DLLIMPORT_DECL_ATTRIBUTES into straight if.\n+\t(legitimate_constant_p): Reject dllimports.\n+\t(dllimport_map, get_dllimport_decl): New.\n+\t(legitimize_dllimport_symbol): New.\n+\t(legitimize_address, ix86_expand_move): Use it.\n+\t(TARGET_BINDS_LOCAL_P): Redefine for TARGET_DLLIMPORT_DECL_ATTRIBUTES.\n+\t* config/i386/i386.h (DLL_IMPORT_EXPORT_PREFIX): Remove.\n+\t(SYMBOL_FLAG_DLLIMPORT, SYMBOL_REF_DLLIMPORT_P): New.\n+\t(SYMBOL_FLAG_DLLEXPORT, SYMBOL_REF_DLLEXPORT_P): New.\n+\t* config/i386/predicates.md (constant_call_address_operand): Only\n+\taccept symbols; reject dllimport_p symbols.\n+\t* config/i386/uwin.h (ASM_DECLARE_FUNCTION_NAME): Use\n+\ti386_pe_maybe_record_exported_symbol.\n+\t* config/i386/winnt.c (DLL_IMPORT_PREFIX, DLL_EXPORT_PREFIX): Remove.\n+\t(i386_pe_determine_dllexport_p): Rename from i386_pe_dllexport_p.\n+\t(i386_pe_determine_dllimport_p): Rename from i386_pe_dllimport_p;\n+\ttrust the setting of DECL_DLLIMPORT_P.\n+\t(i386_pe_dllexport_name_p, i386_pe_dllimport_name_p): Remove.\n+\t(i386_pe_mark_dllexport, i386_pe_mark_dllimport): Remove.\n+\t(gen_stdcall_or_fastcall_suffix): Return NULL if no change required;\n+\ttidy the argument scanning loop.\n+\t(i386_pe_encode_section_info): Set SYMBOL_FLAG_DLLIMPORT and\n+\tSYMBOL_FLAG_DLLEXPORT in SYMBOL_REF_FLAGS.\n+\t(i386_pe_strip_name_encoding): Remove.\n+\t(i386_pe_binds_local_p): New.\n+\t(i386_pe_strip_name_encoding_full): Use default_strip_name_encoding.\n+\t(i386_pe_output_labelref): Remove.\n+\t(i386_pe_asm_output_aligned_decl_common): New.\n+\t(i386_pe_maybe_record_exported_symbol): Rename from\n+\ti386_pe_record_exported_symbol; check for dllexported symbols.\n+\n 2007-03-29  Zack Weinberg  <zack@mrtock.ucsd.edu>\n \n \t* gengtype.c (oprintf): Mostly revert changes from 2007-03-26;"}, {"sha": "aa4ca2a925ddfddcbd009e410393ff23de40ba1d", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -148,39 +148,20 @@ do {\t\t\t\t\t\t\t\t\t\\\n    section and we need to set DECL_SECTION_NAME so we do that here.\n    Note that we can be called twice on the same decl.  */\n \n-#undef SUBTARGET_ENCODE_SECTION_INFO\n #define SUBTARGET_ENCODE_SECTION_INFO  i386_pe_encode_section_info\n #undef  TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING  i386_pe_strip_name_encoding_full\n-\f\n-/* Output a reference to a label.  */\n-#undef ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF  i386_pe_output_labelref\n-\n-#undef  COMMON_ASM_OP\n-#define COMMON_ASM_OP\t\"\\t.comm\\t\"\n \n /* Output a common block.  */\n-#undef ASM_OUTPUT_COMMON\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\\\n-do {\t\t\t\t\t\t\t\\\n-  if (i386_pe_dllexport_name_p (NAME))\t\t\t\\\n-    i386_pe_record_exported_symbol (NAME, 1);\t\t\\\n-  if (! i386_pe_dllimport_name_p (NAME))\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf ((STREAM), \"\\t.comm\\t\");\t\t\t\\\n-      assemble_name ((STREAM), (NAME));\t\t\t\\\n-      fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n-\t       (int)(ROUNDED), ASM_COMMENT_START, (int)(SIZE));\t\\\n-    }\t\t\t\t\t\t\t\\\n-} while (0)\n+#undef ASM_OUTPUT_ALIGNED_DECL_COMMON\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON \\\n+  i386_pe_asm_output_aligned_decl_common\n \n /* Output the label for an initialized variable.  */\n #undef ASM_DECLARE_OBJECT_NAME\n #define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)\t\\\n do {\t\t\t\t\t\t\t\\\n-  if (i386_pe_dllexport_name_p (NAME))\t\t\t\\\n-    i386_pe_record_exported_symbol (NAME, 1);\t\t\\\n+  i386_pe_maybe_record_exported_symbol (DECL, NAME, 1);\t\\\n   ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n } while (0)\n \n@@ -210,7 +191,6 @@ do {\t\t\t\t\t\t\t\\\n /* Windows uses explicit import from shared libraries.  */\n #define MULTIPLE_SYMBOL_SPACES 1\n \n-extern void i386_pe_unique_section (TREE, int);\n #define TARGET_ASM_UNIQUE_SECTION i386_pe_unique_section\n #define TARGET_ASM_FUNCTION_RODATA_SECTION default_no_function_rodata_section\n \n@@ -229,8 +209,7 @@ extern void i386_pe_unique_section (TREE, int);\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (i386_pe_dllexport_name_p (NAME))\t\t\t\t\\\n-\ti386_pe_record_exported_symbol (NAME, 0);\t\t\t\\\n+      i386_pe_maybe_record_exported_symbol (DECL, NAME, 0);\t\t\\\n       if (write_symbols != SDB_DEBUG)\t\t\t\t\t\\\n \ti386_pe_declare_function_type (FILE, NAME, TREE_PUBLIC (DECL));\t\\\n       ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n@@ -289,15 +268,6 @@ extern void i386_pe_unique_section (TREE, int);\n \t\t\t       build_tree_list (get_identifier (\"stdcall\"),   \\\n \t\t\t\t\t\tNULL))\n \n-/* External function declarations.  */\n-\n-extern void i386_pe_record_external_function (tree, const char *);\n-extern void i386_pe_declare_function_type (FILE *, const char *, int);\n-extern void i386_pe_record_exported_symbol (const char *, int);\n-extern void i386_pe_file_end (void);\n-extern int i386_pe_dllexport_name_p (const char *);\n-extern int i386_pe_dllimport_name_p (const char *);\n-\n /* For Win32 ABI compatibility */\n #undef DEFAULT_PCC_STRUCT_RETURN\n #define DEFAULT_PCC_STRUCT_RETURN 0\n@@ -315,10 +285,10 @@ extern int i386_pe_dllimport_name_p (const char *);\n    machine.  Use this macro to limit the alignment which can be\n    specified using the `__attribute__ ((aligned (N)))' construct.  If\n    not defined, the default value is `BIGGEST_ALIGNMENT'.  */\n-#undef MAX_OFILE_ALIGNMENT\n /* IMAGE_SCN_ALIGN_8192BYTES is the largest section alignment flag\n    specified in the PECOFF60 spec.  Native MS compiler also limits\n    user-specified alignment to 8192 bytes.  */\n+#undef MAX_OFILE_ALIGNMENT\n #define MAX_OFILE_ALIGNMENT (8192 * 8)\n \n /* Native complier aligns internal doubles in structures on dword boundaries.  */\n@@ -334,6 +304,7 @@ extern int i386_pe_dllimport_name_p (const char *);\n #ifndef SET_ASM_OP\n #define SET_ASM_OP \"\\t.set\\t\"\n #endif\n+\n /* This implements the `alias' attribute, keeping any stdcall or\n    fastcall decoration.  */\n #undef\tASM_OUTPUT_DEF_FROM_DECLS"}, {"sha": "fa75376768746060c8053315068c73022acb5966", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -326,8 +326,7 @@ while (0)\n    differently depending on something about the variable or\n    function named by the symbol (such as what section it is in).  */\n \n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO i386_pe_encode_section_info\n+#define SUBTARGET_ENCODE_SECTION_INFO i386_pe_encode_section_info\n #undef  TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING  i386_pe_strip_name_encoding_full\n "}, {"sha": "a37901156c7e4d39aa1d8bb186706e3dd376f22e", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -191,9 +191,6 @@ extern int ix86_local_alignment (tree, int);\n extern int ix86_constant_alignment (tree, int);\n extern tree ix86_handle_shared_attribute (tree *, tree, tree, int, bool *);\n extern tree ix86_handle_selectany_attribute (tree *, tree, tree, int, bool *);\n-\n-extern unsigned int i386_pe_section_type_flags (tree, const char *, int);\n-extern void i386_pe_asm_named_section (const char *, unsigned int, tree);\n extern int x86_field_alignment (tree, int);\n #endif\n \n@@ -206,18 +203,22 @@ extern void ix86_expand_vector_extract (bool, rtx, rtx, int);\n extern void ix86_expand_reduc_v4sf (rtx (*)(rtx, rtx, rtx), rtx, rtx);\n \n /* In winnt.c  */\n-extern int i386_pe_dllexport_name_p (const char *);\n-extern int i386_pe_dllimport_name_p (const char *);\n extern void i386_pe_unique_section (tree, int);\n extern void i386_pe_declare_function_type (FILE *, const char *, int);\n extern void i386_pe_record_external_function (tree, const char *);\n-extern void i386_pe_record_exported_symbol (const char *, int);\n+extern void i386_pe_maybe_record_exported_symbol (tree, const char *, int);\n extern void i386_pe_asm_file_end (FILE *);\n extern void i386_pe_encode_section_info (tree, rtx, int);\n-extern const char *i386_pe_strip_name_encoding (const char *);\n+extern bool i386_pe_binds_local_p (tree);\n extern const char *i386_pe_strip_name_encoding_full (const char *);\n-extern void i386_pe_output_labelref (FILE *, const char *);\n extern bool i386_pe_valid_dllimport_attribute_p (tree);\n+extern unsigned int i386_pe_section_type_flags (tree, const char *, int);\n+extern void i386_pe_asm_named_section (const char *, unsigned int, tree);\n+extern void i386_pe_asm_output_aligned_decl_common (FILE *, tree,\n+\t\t\t\t\t\t    const char *,\n+\t\t\t\t\t\t    HOST_WIDE_INT,\n+\t\t\t\t\t\t    HOST_WIDE_INT);\n+extern void i386_pe_file_end (void);\n \n /* In winnt-cxx.c and winnt-stubs.c  */\n extern void i386_pe_adjust_class_at_definition (tree);"}, {"sha": "ed25402476a896f71bf0b261ed144d7b1274cb0b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 126, "deletions": 9, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -2569,12 +2569,11 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n \t}\n     }\n \n-#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n   /* Dllimport'd functions are also called indirectly.  */\n-  if (decl && DECL_DLLIMPORT_P (decl)\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+      && decl && DECL_DLLIMPORT_P (decl)\n       && ix86_function_regparm (TREE_TYPE (decl), NULL) >= 3)\n     return false;\n-#endif\n \n   /* If we forced aligned the stack, then sibcalling would unalign the\n      stack, which may break the called function.  */\n@@ -6332,6 +6331,11 @@ legitimate_constant_p (rtx x)\n       /* TLS symbols are never valid.  */\n       if (SYMBOL_REF_TLS_MODEL (x))\n \treturn false;\n+\n+      /* DLLIMPORT symbols are never valid.  */\n+      if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\t  && SYMBOL_REF_DLLIMPORT_P (x))\n+\treturn false;\n       break;\n \n     case CONST_DOUBLE:\n@@ -7189,6 +7193,90 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n   return dest;\n }\n \n+/* Create or return the unique __imp_DECL dllimport symbol corresponding\n+   to symbol DECL.  */\n+\n+static GTY((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n+  htab_t dllimport_map;\n+\n+static tree\n+get_dllimport_decl (tree decl)\n+{\n+  struct tree_map *h, in;\n+  void **loc;\n+  const char *name;\n+  const char *prefix;\n+  size_t namelen, prefixlen;\n+  char *imp_name;\n+  tree to;\n+  rtx rtl;\n+\n+  if (!dllimport_map)\n+    dllimport_map = htab_create_ggc (512, tree_map_hash, tree_map_eq, 0);\n+\n+  in.hash = htab_hash_pointer (decl);\n+  in.base.from = decl;\n+  loc = htab_find_slot_with_hash (dllimport_map, &in, in.hash, INSERT);\n+  h = *loc;\n+  if (h)\n+    return h->to;\n+\n+  *loc = h = ggc_alloc (sizeof (struct tree_map));\n+  h->hash = in.hash;\n+  h->base.from = decl;\n+  h->to = to = build_decl (VAR_DECL, NULL, ptr_type_node);\n+  DECL_ARTIFICIAL (to) = 1;\n+  DECL_IGNORED_P (to) = 1;\n+  DECL_EXTERNAL (to) = 1;\n+  TREE_READONLY (to) = 1;\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  name = targetm.strip_name_encoding (name);\n+  if (name[0] == FASTCALL_PREFIX)\n+    {\n+      name++;\n+      prefix = \"*__imp_\";\n+    }\n+  else\n+    prefix = \"*__imp__\";\n+\n+  namelen = strlen (name);\n+  prefixlen = strlen (prefix);\n+  imp_name = alloca (namelen + prefixlen + 1);\n+  memcpy (imp_name, prefix, prefixlen);\n+  memcpy (imp_name + prefixlen, name, namelen + 1);\n+\n+  name = ggc_alloc_string (imp_name, namelen + prefixlen);\n+  rtl = gen_rtx_SYMBOL_REF (Pmode, name);\n+  SET_SYMBOL_REF_DECL (rtl, to);\n+  SYMBOL_REF_FLAGS (rtl) = SYMBOL_FLAG_LOCAL;\n+\n+  rtl = gen_const_mem (Pmode, rtl);\n+  set_mem_alias_set (rtl, ix86_GOT_alias_set ());\n+\n+  SET_DECL_RTL (to, rtl);\n+\n+  return to;\n+}\n+\n+/* Expand SYMBOL into its corresponding dllimport symbol.  WANT_REG is\n+   true if we require the result be a register.  */\n+\n+static rtx\n+legitimize_dllimport_symbol (rtx symbol, bool want_reg)\n+{\n+  tree imp_decl;\n+  rtx x;\n+\n+  gcc_assert (SYMBOL_REF_DECL (symbol));\n+  imp_decl = get_dllimport_decl (SYMBOL_REF_DECL (symbol));\n+\n+  x = DECL_RTL (imp_decl);\n+  if (want_reg)\n+    x = force_reg (Pmode, x);\n+  return x;\n+}\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n@@ -7231,6 +7319,20 @@ legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, enum machine_mode mode)\n   if (flag_pic && SYMBOLIC_CONST (x))\n     return legitimize_pic_address (x, 0);\n \n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES)\n+    {\n+      if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_DLLIMPORT_P (x))\n+\treturn legitimize_dllimport_symbol (x, true);\n+      if (GET_CODE (x) == CONST\n+\t  && GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+\t  && SYMBOL_REF_DLLIMPORT_P (XEXP (XEXP (x, 0), 0)))\n+\t{\n+\t  rtx t = legitimize_dllimport_symbol (XEXP (XEXP (x, 0), 0), true);\n+\t  return gen_rtx_PLUS (Pmode, t, XEXP (XEXP (x, 0), 1));\n+\t}\n+    }\n+\n   /* Canonicalize shifts by 0, 1, 2, 3 into multiply */\n   if (GET_CODE (x) == ASHIFT\n       && CONST_INT_P (XEXP (x, 1))\n@@ -9236,20 +9338,31 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n \t  if (op1 == op0)\n \t    return;\n \t}\n+      else if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\t       && SYMBOL_REF_DLLIMPORT_P (op1))\n+\top1 = legitimize_dllimport_symbol (op1, false);\n     }\n   else if (GET_CODE (op1) == CONST\n \t   && GET_CODE (XEXP (op1, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (op1, 0), 0)) == SYMBOL_REF)\n     {\n-      model = SYMBOL_REF_TLS_MODEL (XEXP (XEXP (op1, 0), 0));\n+      rtx addend = XEXP (XEXP (op1, 0), 1);\n+      rtx symbol = XEXP (XEXP (op1, 0), 0);\n+      rtx tmp = NULL;\n+\n+      model = SYMBOL_REF_TLS_MODEL (symbol);\n       if (model)\n+\ttmp = legitimize_tls_address (symbol, model, true);\n+      else if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+\t       && SYMBOL_REF_DLLIMPORT_P (symbol))\n+\ttmp = legitimize_dllimport_symbol (symbol, true);\n+\n+      if (tmp)\n \t{\n-\t  rtx addend = XEXP (XEXP (op1, 0), 1);\n-\t  op1 = legitimize_tls_address (XEXP (XEXP (op1, 0), 0), model, true);\n-\t  op1 = force_operand (op1, NULL);\n-\t  op1 = expand_simple_binop (Pmode, PLUS, op1, addend,\n+\t  tmp = force_operand (tmp, NULL);\n+\t  tmp = expand_simple_binop (Pmode, PLUS, tmp, addend,\n \t\t\t\t     op0, 1, OPTAB_DIRECT);\n-\t  if (op1 == op0)\n+\t  if (tmp == op0)\n \t    return;\n \t}\n     }\n@@ -21648,6 +21761,10 @@ static const struct attribute_spec ix86_attribute_table[] =\n #undef TARGET_BINDS_LOCAL_P\n #define TARGET_BINDS_LOCAL_P darwin_binds_local_p\n #endif\n+#if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+#undef TARGET_BINDS_LOCAL_P\n+#define TARGET_BINDS_LOCAL_P i386_pe_binds_local_p\n+#endif\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK x86_output_mi_thunk"}, {"sha": "045741b4c4f0b91435138bc9cee78c31e50970fc", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -2347,8 +2347,6 @@ enum ix86_stack_slot\n   (! IN_RANGE ((SRC), FIRST_STACK_REG, LAST_STACK_REG))\n \n \f\n-#define DLL_IMPORT_EXPORT_PREFIX '#'\n-\n #define FASTCALL_PREFIX '@'\n \f\n struct machine_function GTY(())\n@@ -2398,6 +2396,17 @@ struct machine_function GTY(())\n #define SYMBOL_FLAG_FAR_ADDR\t\t(SYMBOL_FLAG_MACH_DEP << 0)\n #define SYMBOL_REF_FAR_ADDR_P(X)\t\\\n \t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_FAR_ADDR) != 0)\n+\n+/* Flags to mark dllimport/dllexport.  Used by PE ports, but handy to\n+   have defined always, to avoid ifdefing.  */\n+#define SYMBOL_FLAG_DLLIMPORT\t\t(SYMBOL_FLAG_MACH_DEP << 1)\n+#define SYMBOL_REF_DLLIMPORT_P(X) \\\n+\t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_DLLIMPORT) != 0)\n+\n+#define SYMBOL_FLAG_DLLEXPORT\t\t(SYMBOL_FLAG_MACH_DEP << 2)\n+#define SYMBOL_REF_DLLEXPORT_P(X) \\\n+\t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_DLLEXPORT) != 0)\n+\n /*\n Local variables:\n version-control: t"}, {"sha": "ed3ab3cd6a774070b5457467ac722f2194445bf5", "filename": "gcc/config/i386/netware.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fnetware.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fnetware.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetware.h?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -150,7 +150,6 @@ Boston, MA 02110-1301, USA.  */\n    the number of registers used, and an atsign (@). */\n void i386_nlm_encode_section_info (tree, rtx, int);\n const char *i386_nlm_strip_name_encoding (const char *);\n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO  i386_nlm_encode_section_info\n+#define SUBTARGET_ENCODE_SECTION_INFO  i386_nlm_encode_section_info\n #undef  TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING  i386_nlm_strip_name_encoding"}, {"sha": "efa5c98ee79fab36f2b40575e33d653e3acd8d90", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -484,9 +484,14 @@\n \n ;; Test for a pc-relative call operand\n (define_predicate \"constant_call_address_operand\"\n-  (and (ior (match_code \"symbol_ref\")\n-            (match_operand 0 \"local_symbolic_operand\"))\n-       (match_test \"ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\")))\n+  (match_code \"symbol_ref\")\n+{\n+  if (ix86_cmodel == CM_LARGE || ix86_cmodel == CM_LARGE_PIC)\n+    return false;\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES && SYMBOL_REF_DLLIMPORT_P (op))\n+    return false;\n+  return true;\n+})\n \n ;; True for any non-virtual or eliminable register.  Used in places where\n ;; instantiation of such a register may cause the pattern to not be recognized."}, {"sha": "a87d1e7ec8c888cac9dd2cb3ad8c60386a570df7", "filename": "gcc/config/i386/uwin.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fuwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fuwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fuwin.h?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -77,8 +77,7 @@ Boston, MA 02110-1301, USA.  */\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (i386_pe_dllexport_name_p (NAME))\t\t\t\t\\\n-\ti386_pe_record_exported_symbol (NAME, 0);\t\t\t\\\n+      i386_pe_maybe_record_exported_symbol (DECL, NAME, 0);\t\t\\\n       /* UWIN binutils bug workaround.  */\t\t\t\t\\\n       if (0 && write_symbols != SDB_DEBUG)\t\t\t\t\\\n \ti386_pe_declare_function_type (FILE, NAME, TREE_PUBLIC (DECL));\t\\"}, {"sha": "a36fd08399d5a973ac43a7c32abf36a9052396d5", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 171, "deletions": 295, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -34,6 +34,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"toplev.h\"\n #include \"hashtab.h\"\n #include \"ggc.h\"\n+#include \"target.h\"\n \n /* i386/PE specific attribute support.\n \n@@ -46,22 +47,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    multiple times.\n */\n \n-static tree associated_type (tree);\n-static tree gen_stdcall_or_fastcall_suffix (tree, bool);\n-static bool i386_pe_dllexport_p (tree);\n-static bool i386_pe_dllimport_p (tree);\n-static void i386_pe_mark_dllexport (tree);\n-static void i386_pe_mark_dllimport (tree);\n-\n-/* This is we how mark internal identifiers with dllimport or dllexport\n-   attributes.  */\n-#ifndef DLL_IMPORT_PREFIX\n-#define DLL_IMPORT_PREFIX \"#i.\"\n-#endif\n-#ifndef DLL_EXPORT_PREFIX\n-#define DLL_EXPORT_PREFIX \"#e.\"\n-#endif\n-\n /* Handle a \"shared\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n tree\n@@ -108,67 +93,59 @@ ix86_handle_selectany_attribute (tree *node, tree name,\n static tree\n associated_type (tree decl)\n {\n-  return  (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n-            ?  DECL_CONTEXT (decl) : NULL_TREE;\n+  return (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl))\n+          ?  DECL_CONTEXT (decl) : NULL_TREE);\n }\n \n-\n-/* Return true if DECL is a dllexport'd object.  */\n+/* Return true if DECL should be a dllexport'd object.  */\n \n static bool\n-i386_pe_dllexport_p (tree decl)\n+i386_pe_determine_dllexport_p (tree decl)\n {\n-  if (TREE_CODE (decl) != VAR_DECL\n-       && TREE_CODE (decl) != FUNCTION_DECL)\n+  tree assoc;\n+\n+  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n     return false;\n \n   if (lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl)))\n     return true;\n \n   /* Also mark class members of exported classes with dllexport.  */\n-  if (associated_type (decl)\n-      && lookup_attribute (\"dllexport\",\n-\t\t\t    TYPE_ATTRIBUTES (associated_type (decl))))\n+  assoc = associated_type (decl);\n+  if (assoc && lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (assoc)))\n     return i386_pe_type_dllexport_p (decl);\n \n   return false;\n }\n \n+/* Return true if DECL should be a dllimport'd object.  */\n+\n static bool\n-i386_pe_dllimport_p (tree decl)\n+i386_pe_determine_dllimport_p (tree decl)\n {\n-  if (TREE_CODE (decl) != VAR_DECL\n-       && TREE_CODE (decl) != FUNCTION_DECL)\n+  tree assoc;\n+\n+  if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n     return false;\n \n   /* Lookup the attribute in addition to checking the DECL_DLLIMPORT_P flag.\n      We may need to override an earlier decision.  */\n-  if (DECL_DLLIMPORT_P (decl)\n-      && lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl)))\n-    {\n-       /* Make a final check to see if this is a definition before we generate\n-          RTL for an indirect reference.  */   \n-       if (!DECL_EXTERNAL (decl))\n-\t{\n-\t  error (\"%q+D: definition is marked as dllimport\", decl);\n-\t  DECL_DLLIMPORT_P (decl) = 0;\n-          return false;\n-        }\n-      return true;\n-    }\n+  if (DECL_DLLIMPORT_P (decl))\n+    return true;\n+\n   /* The DECL_DLLIMPORT_P flag was set for decls in the class definition\n      by  targetm.cxx.adjust_class_at_definition.  Check again to emit\n      warnings if the class attribute has been overridden by an\n      out-of-class definition.  */\n-  else if (associated_type (decl)\n-           && lookup_attribute (\"dllimport\",\n-\t\t\t\tTYPE_ATTRIBUTES (associated_type (decl))))\n+  assoc = associated_type (decl);\n+  if (assoc && lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (assoc)))\n     return i386_pe_type_dllimport_p (decl);\n \n   return false;\n }\n \n /* Handle the -mno-fun-dllimport target switch.  */\n+\n bool\n i386_pe_valid_dllimport_attribute_p (tree decl)\n {\n@@ -177,247 +154,157 @@ i386_pe_valid_dllimport_attribute_p (tree decl)\n    return true;\n }\n \n-/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n-\n-int\n-i386_pe_dllexport_name_p (const char *symbol)\n-{\n-  return (strncmp (DLL_EXPORT_PREFIX, symbol,\n-\t\t   strlen (DLL_EXPORT_PREFIX)) == 0);\n-}\n-\n-/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n-\n-int\n-i386_pe_dllimport_name_p (const char *symbol)\n-{\n-  return (strncmp (DLL_IMPORT_PREFIX, symbol,\n-\t\t   strlen (DLL_IMPORT_PREFIX)) == 0);\n-}\n-\n-/* Mark a DECL as being dllexport'd.\n-   Note that we override the previous setting (e.g.: dllimport).  */\n-\n-static void\n-i386_pe_mark_dllexport (tree decl)\n-{\n-  const char *oldname;\n-  char  *newname;\n-  rtx rtlname;\n-  rtx symref;\n-  tree idp;\n-\n-  rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (GET_CODE (rtlname) == MEM)\n-    rtlname = XEXP (rtlname, 0);\n-  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n-  oldname = XSTR (rtlname, 0);\n-  if (i386_pe_dllimport_name_p (oldname))\n-    {\n-      warning (0, \"inconsistent dll linkage for %q+D, dllexport assumed\",\n-\t       decl);\n-     /* Remove DLL_IMPORT_PREFIX.  */\n-      oldname += strlen (DLL_IMPORT_PREFIX);\n-    }\n-  else if (i386_pe_dllexport_name_p (oldname))\n-    return;  /*  already done  */\n-\n-  newname = alloca (strlen (DLL_EXPORT_PREFIX) + strlen (oldname) + 1);\n-  sprintf (newname, \"%s%s\", DLL_EXPORT_PREFIX, oldname);\n-\n-  /* We pass newname through get_identifier to ensure it has a unique\n-     address.  RTL processing can sometimes peek inside the symbol ref\n-     and compare the string's addresses to see if two symbols are\n-     identical.  */\n-  idp = get_identifier (newname);\n-\n-  symref = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-  SET_SYMBOL_REF_DECL (symref, decl);\n-  XEXP (DECL_RTL (decl), 0) = symref;\n-}\n-\n-/* Mark a DECL as being dllimport'd.  */\n-\n-static void\n-i386_pe_mark_dllimport (tree decl)\n-{\n-  const char *oldname;\n-  char  *newname;\n-  tree idp;\n-  rtx rtlname, newrtl;\n-  rtx symref;\n-\n-  rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (GET_CODE (rtlname) == MEM)\n-    rtlname = XEXP (rtlname, 0);\n-  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n-  oldname = XSTR (rtlname, 0);\n-  if (i386_pe_dllexport_name_p (oldname))\n-    {\n-      error (\"%qs declared as both exported to and imported from a DLL\",\n-             IDENTIFIER_POINTER (DECL_NAME (decl)));\n-      return;\n-    }\n-  else if (i386_pe_dllimport_name_p (oldname))\n-    {\n-      /* Already done, but do a sanity check to prevent assembler\n-\t errors.  */\n-      gcc_assert (DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)\n-\t\t  && DECL_DLLIMPORT_P (decl));\n-      return;\n-    }\n-\n-  newname = alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);\n-  sprintf (newname, \"%s%s\", DLL_IMPORT_PREFIX, oldname);\n-\n-  /* We pass newname through get_identifier to ensure it has a unique\n-     address.  RTL processing can sometimes peek inside the symbol ref\n-     and compare the string's addresses to see if two symbols are\n-     identical.  */\n-  idp = get_identifier (newname);\n-\n-  symref = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-  SET_SYMBOL_REF_DECL (symref, decl);\n-  newrtl = gen_rtx_MEM (Pmode,symref);\n-  XEXP (DECL_RTL (decl), 0) = newrtl;\n-\n-  DECL_DLLIMPORT_P (decl) = 1;\n-}\n-\n /* Return string which is the former assembler name modified with a\n    suffix consisting of an atsign (@) followed by the number of bytes of\n-   arguments.  If FASTCALL is true, also add the FASTCALL_PREFIX.  */\n+   arguments.  If FASTCALL is true, also add the FASTCALL_PREFIX.\n+   Return NULL if no change required.  */\n \n static tree\n gen_stdcall_or_fastcall_suffix (tree decl, bool fastcall)\n {\n-  int total = 0;\n-  /* ??? This probably should use XSTR (XEXP (DECL_RTL (decl), 0), 0) instead\n-     of DECL_ASSEMBLER_NAME.  */\n-   const char *asmname =  IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  char *newsym;\n-  char *p;\n+  HOST_WIDE_INT total = 0;\n+  const char *asm_str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  char *new_str, *p;\n   tree formal_type;\n \n   /* Do not change the identifier if a verbatim asmspec or already done. */\n-  if (*asmname == '*' || strchr (asmname, '@'))\n-    return DECL_ASSEMBLER_NAME (decl);\n+  if (*asm_str == '*' || strchr (asm_str, '@'))\n+    return NULL_TREE;\n \n   formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n   if (formal_type != NULL_TREE)\n-    {\n-      /* These attributes are ignored for variadic functions in\n-\t i386.c:ix86_return_pops_args. For compatibility with MS\n-         compiler do not add @0 suffix here.  */ \n-      if (TREE_VALUE (tree_last (formal_type)) != void_type_node)\n-        return DECL_ASSEMBLER_NAME (decl);\n-\n-      /* Quit if we hit an incomplete type.  Error is reported\n-         by convert_arguments in c-typeck.c or cp/typeck.c.  */\n-      while (TREE_VALUE (formal_type) != void_type_node\n-\t     && COMPLETE_TYPE_P (TREE_VALUE (formal_type)))\t\n-\t{\n-\t  int parm_size\n-\t    = TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));\n-\t    /* Must round up to include padding.  This is done the same\n-\t       way as in store_one_arg.  */\n-\t  parm_size = ((parm_size + PARM_BOUNDARY - 1)\n-\t\t       / PARM_BOUNDARY * PARM_BOUNDARY);\n-\t  total += parm_size;\n-\t  formal_type = TREE_CHAIN (formal_type);\\\n-\t}\n-     }\n+    while (1)\n+      {\n+\tHOST_WIDE_INT parm_size;\n+\tHOST_WIDE_INT parm_boundary_bytes = PARM_BOUNDARY / BITS_PER_UNIT;\n+\n+\t/* We got to the end of the list without seeing void_list_node,\n+\t   which means the function is variadic.  The suffix is to be\n+\t   ignored in that case.  */\n+\tif (formal_type == NULL_TREE)\n+\t  return NULL_TREE;\n+\n+\t/* End of arguments, non-varargs marker.  */\n+        if (formal_type == void_list_node)\n+\t  break;\n+\n+        /* Quit if we hit an incomplete type.  Error is reported\n+\t   by convert_arguments in c-typeck.c or cp/typeck.c.  */\n+\tparm_size = int_size_in_bytes (TREE_VALUE (formal_type));\n+\tif (parm_size < 0)\n+\t  break;\n+\n+\t/* Must round up to include padding.  This is done the same\n+\t   way as in store_one_arg.  */\n+\tparm_size = ((parm_size + parm_boundary_bytes - 1)\n+\t\t     / parm_boundary_bytes * parm_boundary_bytes);\n+\ttotal += parm_size;\n+\n+\tformal_type = TREE_CHAIN (formal_type);\n+      }\n \n   /* Assume max of 8 base 10 digits in the suffix.  */\n-  newsym = alloca (1 + strlen (asmname) + 1 + 8 + 1);\n-  p = newsym;\n+  p = new_str = alloca (1 + strlen (asm_str) + 1 + 8 + 1);\n   if (fastcall)\n     *p++ = FASTCALL_PREFIX;\n-  sprintf (p, \"%s@%d\", asmname, total/BITS_PER_UNIT);\n-  return get_identifier (newsym);\n+  sprintf (p, \"%s@\" HOST_WIDE_INT_PRINT_DEC, asm_str, total);\n+\n+  return get_identifier (new_str);\n }\n \n void\n i386_pe_encode_section_info (tree decl, rtx rtl, int first)\n {\n+  rtx symbol;\n+  int flags;\n+\n+  /* Do this last, due to our frobbing of DECL_DLLIMPORT_P above.  */\n   default_encode_section_info (decl, rtl, first);\n \n-  if (first && TREE_CODE (decl) == FUNCTION_DECL)\n+  /* Careful not to prod global register variables.  */\n+  if (!MEM_P (rtl))\n+    return;\n+\n+  symbol = XEXP (rtl, 0);\n+  gcc_assert (GET_CODE (symbol) == SYMBOL_REF);\n+\n+  switch (TREE_CODE (decl))\n     {\n-      tree type_attributes = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n-      tree newid = NULL_TREE;\n-\n-      if (lookup_attribute (\"stdcall\", type_attributes))\n-\tnewid = gen_stdcall_or_fastcall_suffix (decl, false);\n-      else if (lookup_attribute (\"fastcall\", type_attributes))\n-\tnewid = gen_stdcall_or_fastcall_suffix (decl, true);\n-      if (newid != NULL_TREE) \t\n+    case FUNCTION_DECL:\n+      if (first)\n \t{\n-\t  rtx rtlname = XEXP (rtl, 0);\n-\t  if (GET_CODE (rtlname) == MEM)\n-\t    rtlname = XEXP (rtlname, 0);\n-\t  XSTR (rtlname, 0) = IDENTIFIER_POINTER (newid);\n-\t  /* These attributes must be present on first declaration,\n-\t     change_decl_assembler_name will warn if they are added\n-\t     later and the decl has been referenced, but duplicate_decls\n-\t     should catch the mismatch before this is called.  */ \n-\t  change_decl_assembler_name (decl, newid);\n+\t  tree type_attributes = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+\t  tree newid = NULL_TREE;\n+\n+\t  if (lookup_attribute (\"stdcall\", type_attributes))\n+\t    newid = gen_stdcall_or_fastcall_suffix (decl, false);\n+\t  else if (lookup_attribute (\"fastcall\", type_attributes))\n+\t    newid = gen_stdcall_or_fastcall_suffix (decl, true);\n+\t  if (newid != NULL_TREE) \t\n+\t    {\n+\t      XSTR (symbol, 0) = IDENTIFIER_POINTER (newid);\n+\t      /* These attributes must be present on first declaration,\n+\t         change_decl_assembler_name will warn if they are added\n+\t         later and the decl has been referenced, but duplicate_decls\n+\t         should catch the mismatch before this is called.  */ \n+\t      change_decl_assembler_name (decl, newid);\n+\t    }\n \t}\n-    }\n+      break;\n \n-  else if (TREE_CODE (decl) == VAR_DECL\n-           && lookup_attribute (\"selectany\", DECL_ATTRIBUTES (decl)))\n-    {\n-      if (DECL_INITIAL (decl)\n- \t  /* If an object is initialized with a ctor, the static\n-\t     initialization and destruction code for it is present in\n-\t     each unit defining the object.  The code that calls the\n-\t     ctor is protected by a link-once guard variable, so that\n-\t     the object still has link-once semantics,  */\n-    \t   || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n-\tmake_decl_one_only (decl);\n-      else\n-\terror (\"%q+D:'selectany' attribute applies only to initialized objects\",\n-\t       decl);\n+    case VAR_DECL:\n+      if (lookup_attribute (\"selectany\", DECL_ATTRIBUTES (decl)))\n+\t{\n+\t  if (DECL_INITIAL (decl)\n+\t      /* If an object is initialized with a ctor, the static\n+\t\t initialization and destruction code for it is present in\n+\t\t each unit defining the object.  The code that calls the\n+\t\t ctor is protected by a link-once guard variable, so that\n+\t\t the object still has link-once semantics,  */\n+\t      || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+\t    make_decl_one_only (decl);\n+\t  else\n+\t    error (\"%q+D:'selectany' attribute applies only to \"\n+\t\t   \"initialized objects\", decl);\n+\t}\n+      break;\n+\n+    default:\n+      return;\n     }\n \n   /* Mark the decl so we can tell from the rtl whether the object is\n      dllexport'd or dllimport'd.  tree.c: merge_dllimport_decl_attributes\n      handles dllexport/dllimport override semantics.  */\n-\n-  if (i386_pe_dllexport_p (decl))\n-    i386_pe_mark_dllexport (decl);\n-  else if (i386_pe_dllimport_p (decl))\n-    i386_pe_mark_dllimport (decl);\n-  /* It might be that DECL has been declared as dllimport, but a\n-     subsequent definition nullified that.  Assert that\n-     tree.c: merge_dllimport_decl_attributes has removed the attribute\n-     before the RTL name was marked with the DLL_IMPORT_PREFIX.  */\n-  else\n-    gcc_assert (!((TREE_CODE (decl) == FUNCTION_DECL\n-\t    \t   || TREE_CODE (decl) == VAR_DECL)\n-\t\t  && rtl != NULL_RTX\n-\t\t  && GET_CODE (rtl) == MEM\n-\t\t  && GET_CODE (XEXP (rtl, 0)) == MEM\n-\t\t  && GET_CODE (XEXP (XEXP (rtl, 0), 0)) == SYMBOL_REF\n-\t\t  && i386_pe_dllimport_name_p (XSTR (XEXP (XEXP (rtl, 0), 0), 0))));\n+  flags = (SYMBOL_REF_FLAGS (symbol) &\n+\t   ~(SYMBOL_FLAG_DLLIMPORT | SYMBOL_FLAG_DLLEXPORT));\n+  if (i386_pe_determine_dllexport_p (decl))\n+    flags |= SYMBOL_FLAG_DLLEXPORT;\n+  else if (i386_pe_determine_dllimport_p (decl))\n+    {\n+      flags |= SYMBOL_FLAG_DLLIMPORT;\n+      /* If we went through the associated_type path, this won't already\n+\t be set.  Though, frankly, this seems wrong, and should be fixed\n+\t elsewhere.  */\n+      if (!DECL_DLLIMPORT_P (decl))\n+\t{\n+\t  DECL_DLLIMPORT_P (decl) = 1;\n+\t  flags &= ~SYMBOL_FLAG_LOCAL;\n+\t}\n+    }\n+  SYMBOL_REF_FLAGS (symbol) = flags;\n }\n \n-/* Strip only the leading encoding, leaving the stdcall suffix and fastcall\n-   prefix if it exists.  */\n-\n-const char *\n-i386_pe_strip_name_encoding (const char *str)\n+bool\n+i386_pe_binds_local_p (tree exp)\n {\n-  if (strncmp (str, DLL_IMPORT_PREFIX, strlen (DLL_IMPORT_PREFIX))\n-      == 0)\n-    str += strlen (DLL_IMPORT_PREFIX);\n-  else if (strncmp (str, DLL_EXPORT_PREFIX, strlen (DLL_EXPORT_PREFIX))\n-\t   == 0)\n-    str += strlen (DLL_EXPORT_PREFIX);\n-  if (*str == '*')\n-    str += 1;\n-  return str;\n+  /* PE does not do dynamic binding.  Indeed, the only kind of\n+     non-local reference comes from a dllimport'd symbol.  */\n+  if ((TREE_CODE (exp) == VAR_DECL || TREE_CODE (exp) == FUNCTION_DECL)\n+      && DECL_DLLIMPORT_P (exp))\n+    return false;\n+\n+  return true;\n }\n \n /* Also strip the fastcall prefix and stdcall suffix.  */\n@@ -426,7 +313,7 @@ const char *\n i386_pe_strip_name_encoding_full (const char *str)\n {\n   const char *p;\n-  const char *name = i386_pe_strip_name_encoding (str);\n+  const char *name = default_strip_name_encoding (str);\n \n   /* Strip leading '@' on fastcall symbols.  */\n   if (*name == '@')\n@@ -440,46 +327,6 @@ i386_pe_strip_name_encoding_full (const char *str)\n   return name;\n }\n \n-/* Output a reference to a label. Fastcall symbols are prefixed with @,\n-   whereas symbols for functions using other calling conventions don't\n-   have a prefix (unless they are marked dllimport or dllexport).  */\n-\n-void i386_pe_output_labelref (FILE *stream, const char *name)\n-{\n-  if (strncmp (name, DLL_IMPORT_PREFIX, strlen (DLL_IMPORT_PREFIX))\n-      == 0)\n-    /* A dll import */\n-    {\n-      if (name[strlen (DLL_IMPORT_PREFIX)] == FASTCALL_PREFIX)\n-      /* A dllimport fastcall symbol.  */\n-        {\n-          fprintf (stream, \"__imp_%s\",\n-                   i386_pe_strip_name_encoding (name));\n-        }\n-      else\n-      /* A dllimport non-fastcall symbol.  */\n-        {\n-          fprintf (stream, \"__imp__%s\",\n-                   i386_pe_strip_name_encoding (name));\n-        }\n-    }\n-  else if ((name[0] == FASTCALL_PREFIX)\n-           || (strncmp (name, DLL_EXPORT_PREFIX, strlen (DLL_EXPORT_PREFIX))\n-\t       == 0\n-\t       && name[strlen (DLL_EXPORT_PREFIX)] == FASTCALL_PREFIX))\n-    /* A fastcall symbol.  */\n-    {\n-      fprintf (stream, \"%s\",\n-               i386_pe_strip_name_encoding (name));\n-    }\n-  else\n-    /* Everything else.  */\n-    {\n-      fprintf (stream, \"%s%s\", USER_LABEL_PREFIX,\n-               i386_pe_strip_name_encoding (name));\n-    }\n-}\n-\n void\n i386_pe_unique_section (tree decl, int reloc)\n {\n@@ -612,6 +459,29 @@ i386_pe_asm_named_section (const char *name, unsigned int flags,\n \t       (discard  ? \"discard\" : \"same_size\"));\n     }\n }\n+\n+void\n+i386_pe_asm_output_aligned_decl_common (FILE *stream, tree decl,\n+\t\t\t\t\tconst char *name, HOST_WIDE_INT size,\n+\t\t\t\t\tHOST_WIDE_INT align ATTRIBUTE_UNUSED)\n+{\n+  HOST_WIDE_INT rounded;\n+\n+  /* Compute as in assemble_noswitch_variable, since we don't actually\n+     support aligned common.  */\n+  rounded = size ? size : 1;\n+  rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n+  rounded = (rounded / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+\t     * (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+  \n+  i386_pe_maybe_record_exported_symbol (decl, name, 1);\n+\n+  fprintf (stream, \"\\t.comm\\t\");\n+  assemble_name (stream, name);\n+  fprintf (stream, \", \" HOST_WIDE_INT_PRINT_DEC \"\\t\" ASM_COMMENT_START\n+\t   \" \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t   rounded, size);\n+}\n \f\n /* The Microsoft linker requires that every function be marked as\n    DT_FCN.  When using gas on cygwin, we must emit appropriate .type\n@@ -682,10 +552,16 @@ static GTY(()) struct export_list *export_head;\n    linkonce.  */\n \n void\n-i386_pe_record_exported_symbol (const char *name, int is_data)\n+i386_pe_maybe_record_exported_symbol (tree decl, const char *name, int is_data)\n {\n+  rtx symbol;\n   struct export_list *p;\n \n+  symbol = XEXP (DECL_RTL (decl), 0);\n+  gcc_assert (GET_CODE (symbol) == SYMBOL_REF);\n+  if (!SYMBOL_REF_DLLEXPORT_P (symbol))\n+    return;\n+\n   p = (struct export_list *) ggc_alloc (sizeof *p);\n   p->next = export_head;\n   p->name = name;\n@@ -727,8 +603,8 @@ i386_pe_file_end (void)\n       for (q = export_head; q != NULL; q = q->next)\n \t{\n \t  fprintf (asm_out_file, \"\\t.ascii \\\" -export:%s%s\\\"\\n\",\n-\t\t   i386_pe_strip_name_encoding (q->name),\n-\t\t   (q->is_data) ? \",data\" : \"\");\n+\t\t   targetm.strip_name_encoding (q->name),\n+\t\t   (q->is_data ? \",data\" : \"\"));\n \t}\n     }\n }"}, {"sha": "1adc4923481b7f5da667383a94f6f574795b4c62", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da489f7340623783872629a4ebd595d93fc3dced/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=da489f7340623783872629a4ebd595d93fc3dced", "patch": "@@ -4063,9 +4063,8 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t    return null_pointer_node;\n \t  /* Taking the address of a nested function involves a trampoline.  */\n \t  if (TREE_CODE (value) == FUNCTION_DECL\n-\t      && ((decl_function_context (value)\n-\t\t   && !DECL_NO_STATIC_CHAIN (value))\n-\t\t  || DECL_DLLIMPORT_P (value)))\n+\t      && decl_function_context (value)\n+\t      && !DECL_NO_STATIC_CHAIN (value))\n \t    return NULL_TREE;\n \t  /* \"&{...}\" requires a temporary to hold the constructed\n \t     object.  */"}]}