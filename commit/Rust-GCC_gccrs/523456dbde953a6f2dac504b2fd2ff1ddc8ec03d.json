{"sha": "523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIzNDU2ZGJkZTk1M2E2ZjJkYWM1MDRiMmZkMmZmMWRkYzhlYzAzZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-15T20:34:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-15T20:34:43Z"}, "message": "[multiple changes]\n\n2004-07-15  Robert Dewar  <dewar@gnat.com>\n\n\t* makegpr.adb, s-secsta.ads, sem_ch3.adb, sem_case.adb: Minor\n\treformatting\n\n\t* gnat_ugn.texi: Add instantiation of direct_io or sequential_io with\n\taccess values as an example of a warning.\n\n\t* gnat_rm.texi: Document new attribute Has_Access_Values\n\n\t* gnat-style.texi: Document that box comments belong on nested\n\tsubprograms\n\n\t* sem_util.ads (Has_Access_Values): Improved documentation\n\n\t* s-finimp.ads, s-finimp.adb: Fix spelling error in comment\n\n\t* sem_prag.adb (Check_Duplicated_Export_Name): New procedure\n\t(Process_Interface_Name): Call to this new procedure\n\t(Set_Extended_Import_Export_External_Name): Call to this new procedure\n\n\t* s-mastop-x86.adb, 9drpc.adb: Fix spelling error in comment\n\n\t* a-direio.ads, a-sequio.ads: Warn if Element_Type has access values\n\n\t* einfo.ads: Minor comment typo fixed\n\n2004-07-15  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* snames.adb: Add _atcb.\n\n\t* snames.ads: Add Name_uATCB.\n\n\t* s-tarest.adb (Create_Restricted_Task): ATCBs are always preallocated\n\t(in the expanded code) when using the restricted run time.\n\n\t* s-tarest.ads (Create_Restricted_Task): Created_Task transformed into\n\ta in parameter in order to allow ATCBs to be preallocated (in the\n\texpanded code).\n\n\t* s-taskin.adb (Initialize_ATCB): T converted into a in parameter in\n\torder to allow ATCBs to be preallocated. In case of error, the ATCB is\n\tdeallocated in System.Tasking.Stages.\n\n\t* s-taskin.ads (Initialize_ATCB): T converted into a in parameter in\n\torder to allow ATCBs to be preallocated.\n\n\t* s-tassta.adb (Create_Task): In case of error the ATCB is deallocated\n\there. It was previously done in Initialize_ATCB.\n\n\t* rtsfind.ads: Make the Ada_Task_Control_Block visible.\n\n\t* exp_ch9.adb: Preallocate the Ada_Task_Control_Block when using the\n\tRestricted run time.\n\n\t* exp_ch3.adb: When using the Restricted run time, pass the\n\tpreallocated Ada_Task_Control_Block when creating a task.\n\n2004-07-15  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_util.adb (Normalize_Actuals): If there are no actuals on a\n\tfunction call that is itself an actual in an enclosing call, diagnose\n\tproblem here rather than assuming that resolution will catch it.\n\n\t* sem_ch7.adb (Analyze_Package_Specification): If the specification is\n\tthe local copy of a generic unit for a formal package, and the generic\n\tis a child unit, install private part of ancestors before compiling\n\tprivate part of spec.\n\n\t* sem_cat.adb (Validate_Categorization_Dependency): Simplify code to\n\tuse scope entities rather than tree structures, to handle properly\n\tparent units that are instances rewritten as bodies for inlining\n\tpurposes.\n\n\t* sem_ch10.adb (Get_Parent_Entity, Implicit_With_On_Parent,\n\tRemove_Parents): Handle properly a parent unit that is an\n\tinstantiation, when the unit has been rewritten as a body for inlining\n\tpurposes.\n\n\t* par.adb (Goto_List): Global variable to collect goto statements in a\n\tgiven unit, for use in detecting natural loops.\n\n\t* par-ch5.adb (P_Goto_Statement): Add goto to global Goto_List, for\n\tuse in detecting natural loops.\n\n\t* par-labl.adb (Find_Natural_Loops): Recognize loops create by\n\tbackwards goto's, and rewrite as a infinite loop, to improve locality\n\tof temporaries.\n\n\t* exp_util.adb (Force_Evaluation): Recognize a left-hand side\n\tsubcomponent that includes an indexed reference, to prevent the\n\tgeneration of copies that would miscompile the desired assignment\n\tstatement.\n\t(Build_Task_Image_Decls): Add a numeric suffix to\n\tgenerated name for string variable, to avoid spurious conflicts with\n\tthe name of the type of a single protected object.\n\n\t* exp_ch4.adb (Expand_Array_Equality): If indices are distinct, use a\n\tloop with an explicit exit statement, to avoid generating an\n\tout-of-range value with 'Succ leading to spurious constraint_errors\n\twhen compiling with -gnatVo.\n\n2004-07-15  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* sem_ch4.adb (Analyze_Slice): Always call Analyze on the prefix: it\n\tmight not be analyzed yet, even if its Etype is already set (case of an\n\tunchecked conversion built using Unchecked_Convert_To, for example).\n\tIf the prefix has already been analyzed, this will be a nop anyway.\n\n\t* exp_ch5.adb (Make_Tag_Ctrl_Assignment): For an assignment of a\n\tcontroller type, or an assignment of a record type with controlled\n\tcomponents, copy only user data, and leave the finalization chain\n\tpointers untouched.\n\n2004-07-15  Vincent Celier  <celier@gnat.com>\n\n\t* make.adb (Collect_Arguments): Improve error message when attempting\n\tto compile a source not part of any project, when -x is not used.\n\n\t* prj.ads: (Defined_Variable_Kind): New subtype\n\n\t* prj-attr.adb (Register_New_Package): Two new procedures to register\n\ta package with or without its attributes.\n\t(Register_New_Attribute): Mew procedure to register a new attribute in a\n\tpackage.\n\tNew attribute oriented subprograms: Attribute_Node_Id_Of,\n\tAttribute_Kind_Of, Set_Attribute_Kind_Of, Attribute_Name_Of,\n\tVariable_Kind_Of, Set_Variable_Kind_Of, Optional_Index_Of,\n\tNext_Attribute.\n\tNew package oriented subprograms: Package_Node_Id_Of,\n\tAdd_Unknown_Package, First_Attribute_Of, Add_Attribute.\n\n\t* prj-attr.ads (Attribute_Node_Id): Now a private, self initialized\n\ttype.\n\t(Package_Node_Id): Now a private, self initialized type\n\t(Register_New_Package): New procedure to register a package with its\n\tattributes.\n\tNew attribute oriented subprograms: Attribute_Node_Id_Of,\n\tAttribute_Kind_Of, Set_Attribute_Kind_Of, Attribute_Name_Of,\n\tVariable_Kind_Of, Set_Variable_Kind_Of, Optional_Index_Of,\n\tNext_Attribute.\n\tNew package oriented subprograms: Package_Node_Id_Of,\n\tAdd_Unknown_Package, First_Attribute_Of, Add_Attribute.\n\n\t* prj-dect.adb (Parse_Attribute_Declaration,\n\tParse_Package_Declaration): Adapt to new spec of Prj.Attr.\n\n\t* prj-makr.adb (Make): Parse existing project file before creating\n\tother files. Fail if there was an error during parsing.\n\n\t* prj-proc.adb (Add_Attributes, Process_Declarative_Items): Adapt to\n\tnew spec of Prj.Attr.\n\n\t* prj-strt.adb (Attribute_Reference, Parse_Variable_Reference): Adapt\n\tto new spec of Prj.Attr.\n\n2004-07-15  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* utils2.c: Fix typo in comment.\n\nFrom-SVN: r84774", "tree": {"sha": "42274aa36e810d3b5f8091bed03b3cb361cda56e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42274aa36e810d3b5f8091bed03b3cb361cda56e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/comments", "author": null, "committer": null, "parents": [{"sha": "0c0df4b3f017b53fb9a0760ce8c68c293a573a76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0df4b3f017b53fb9a0760ce8c68c293a573a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0df4b3f017b53fb9a0760ce8c68c293a573a76"}], "stats": {"total": 3924, "additions": 2683, "deletions": 1241}, "files": [{"sha": "a62a7e0e8214d6a851ee93787e1b9481e5c9b5a6", "filename": "gcc/ada/9drpc.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2F9drpc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2F9drpc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F9drpc.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1009,7 +1009,7 @@ package body System.RPC is\n                Partition_ID'Image (Partition));\n             Garbage_Collector.Allocate (Anonymous);\n \n-            --  We substracted the size of the header from the size of the\n+            --  We subtracted the size of the header from the size of the\n             --  global message in order to provide immediatly Params size\n \n             Anonymous.Element.Start"}, {"sha": "5b5a0e9eade41e884594f241e10d6c0d76f2309b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 161, "deletions": 1, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -1,4 +1,164 @@\n-Wed Jul 14 23:16:59 2004  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+2004-07-15  Robert Dewar  <dewar@gnat.com>\n+\n+\t* makegpr.adb, s-secsta.ads, sem_ch3.adb, sem_case.adb: Minor\n+\treformatting\n+\n+\t* gnat_ugn.texi: Add instantiation of direct_io or sequential_io with\n+\taccess values as an example of a warning.\n+\n+\t* gnat_rm.texi: Document new attribute Has_Access_Values\n+\n+\t* gnat-style.texi: Document that box comments belong on nested\n+\tsubprograms\n+\n+\t* sem_util.ads (Has_Access_Values): Improved documentation\n+\n+\t* s-finimp.ads, s-finimp.adb: Fix spelling error in comment\n+\n+\t* sem_prag.adb (Check_Duplicated_Export_Name): New procedure\n+\t(Process_Interface_Name): Call to this new procedure\n+\t(Set_Extended_Import_Export_External_Name): Call to this new procedure\n+\n+\t* s-mastop-x86.adb, 9drpc.adb: Fix spelling error in comment\n+\n+\t* a-direio.ads, a-sequio.ads: Warn if Element_Type has access values\n+\n+\t* einfo.ads: Minor comment typo fixed\n+\n+2004-07-15  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* snames.adb: Add _atcb.\n+\n+\t* snames.ads: Add Name_uATCB.\n+\n+\t* s-tarest.adb (Create_Restricted_Task): ATCBs are always preallocated\n+\t(in the expanded code) when using the restricted run time.\n+\n+\t* s-tarest.ads (Create_Restricted_Task): Created_Task transformed into\n+\ta in parameter in order to allow ATCBs to be preallocated (in the\n+\texpanded code).\n+\n+\t* s-taskin.adb (Initialize_ATCB): T converted into a in parameter in\n+\torder to allow ATCBs to be preallocated. In case of error, the ATCB is\n+\tdeallocated in System.Tasking.Stages.\n+\n+\t* s-taskin.ads (Initialize_ATCB): T converted into a in parameter in\n+\torder to allow ATCBs to be preallocated.\n+\n+\t* s-tassta.adb (Create_Task): In case of error the ATCB is deallocated\n+\there. It was previously done in Initialize_ATCB.\n+\n+\t* rtsfind.ads: Make the Ada_Task_Control_Block visible.\n+\n+\t* exp_ch9.adb: Preallocate the Ada_Task_Control_Block when using the\n+\tRestricted run time.\n+\n+\t* exp_ch3.adb: When using the Restricted run time, pass the\n+\tpreallocated Ada_Task_Control_Block when creating a task.\n+\n+2004-07-15  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_util.adb (Normalize_Actuals): If there are no actuals on a\n+\tfunction call that is itself an actual in an enclosing call, diagnose\n+\tproblem here rather than assuming that resolution will catch it.\n+\n+\t* sem_ch7.adb (Analyze_Package_Specification): If the specification is\n+\tthe local copy of a generic unit for a formal package, and the generic\n+\tis a child unit, install private part of ancestors before compiling\n+\tprivate part of spec.\n+\n+\t* sem_cat.adb (Validate_Categorization_Dependency): Simplify code to\n+\tuse scope entities rather than tree structures, to handle properly\n+\tparent units that are instances rewritten as bodies for inlining\n+\tpurposes.\n+\n+\t* sem_ch10.adb (Get_Parent_Entity, Implicit_With_On_Parent,\n+\tRemove_Parents): Handle properly a parent unit that is an\n+\tinstantiation, when the unit has been rewritten as a body for inlining\n+\tpurposes.\n+\n+\t* par.adb (Goto_List): Global variable to collect goto statements in a\n+\tgiven unit, for use in detecting natural loops.\n+\n+\t* par-ch5.adb (P_Goto_Statement): Add goto to global Goto_List, for\n+\tuse in detecting natural loops.\n+\n+\t* par-labl.adb (Find_Natural_Loops): Recognize loops create by\n+\tbackwards goto's, and rewrite as a infinite loop, to improve locality\n+\tof temporaries.\n+\n+\t* exp_util.adb (Force_Evaluation): Recognize a left-hand side\n+\tsubcomponent that includes an indexed reference, to prevent the\n+\tgeneration of copies that would miscompile the desired assignment\n+\tstatement.\n+\t(Build_Task_Image_Decls): Add a numeric suffix to\n+\tgenerated name for string variable, to avoid spurious conflicts with\n+\tthe name of the type of a single protected object.\n+\n+\t* exp_ch4.adb (Expand_Array_Equality): If indices are distinct, use a\n+\tloop with an explicit exit statement, to avoid generating an\n+\tout-of-range value with 'Succ leading to spurious constraint_errors\n+\twhen compiling with -gnatVo.\n+\n+2004-07-15  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sem_ch4.adb (Analyze_Slice): Always call Analyze on the prefix: it\n+\tmight not be analyzed yet, even if its Etype is already set (case of an\n+\tunchecked conversion built using Unchecked_Convert_To, for example).\n+\tIf the prefix has already been analyzed, this will be a nop anyway.\n+\n+\t* exp_ch5.adb (Make_Tag_Ctrl_Assignment): For an assignment of a\n+\tcontroller type, or an assignment of a record type with controlled\n+\tcomponents, copy only user data, and leave the finalization chain\n+\tpointers untouched.\n+\n+2004-07-15  Vincent Celier  <celier@gnat.com>\n+\n+\t* make.adb (Collect_Arguments): Improve error message when attempting\n+\tto compile a source not part of any project, when -x is not used.\n+\n+\t* prj.ads: (Defined_Variable_Kind): New subtype\n+\n+\t* prj-attr.adb (Register_New_Package): Two new procedures to register\n+\ta package with or without its attributes.\n+\t(Register_New_Attribute): Mew procedure to register a new attribute in a\n+\tpackage.\n+\tNew attribute oriented subprograms: Attribute_Node_Id_Of,\n+\tAttribute_Kind_Of, Set_Attribute_Kind_Of, Attribute_Name_Of,\n+\tVariable_Kind_Of, Set_Variable_Kind_Of, Optional_Index_Of,\n+\tNext_Attribute.\n+\tNew package oriented subprograms: Package_Node_Id_Of,\n+\tAdd_Unknown_Package, First_Attribute_Of, Add_Attribute.\n+\n+\t* prj-attr.ads (Attribute_Node_Id): Now a private, self initialized\n+\ttype.\n+\t(Package_Node_Id): Now a private, self initialized type\n+\t(Register_New_Package): New procedure to register a package with its\n+\tattributes.\n+\tNew attribute oriented subprograms: Attribute_Node_Id_Of,\n+\tAttribute_Kind_Of, Set_Attribute_Kind_Of, Attribute_Name_Of,\n+\tVariable_Kind_Of, Set_Variable_Kind_Of, Optional_Index_Of,\n+\tNext_Attribute.\n+\tNew package oriented subprograms: Package_Node_Id_Of,\n+\tAdd_Unknown_Package, First_Attribute_Of, Add_Attribute.\n+\n+\t* prj-dect.adb (Parse_Attribute_Declaration,\n+\tParse_Package_Declaration): Adapt to new spec of Prj.Attr.\n+\n+\t* prj-makr.adb (Make): Parse existing project file before creating\n+\tother files. Fail if there was an error during parsing.\n+\n+\t* prj-proc.adb (Add_Attributes, Process_Declarative_Items): Adapt to\n+\tnew spec of Prj.Attr.\n+\n+\t* prj-strt.adb (Attribute_Reference, Parse_Variable_Reference): Adapt\n+\tto new spec of Prj.Attr.\n+\n+2004-07-15  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* utils2.c: Fix typo in comment.\n+\n+2004-07-14  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* trans.c (add_decl_expr): Clear TREE_READONLY if clear DECL_INITIAL.\n \t* utils.c (unchecked_convert): Don't do two VIEW_CONVERT_EXPRs."}, {"sha": "8526d29899722666e509d7ef17ad341708166c89", "filename": "gcc/ada/a-direio.ads", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fa-direio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fa-direio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direio.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1999 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,6 +45,10 @@ generic\n \n package Ada.Direct_IO is\n \n+   pragma Compile_Time_Warning\n+     (Element_Type'Has_Access_Values,\n+      \"?Element_Type for Direct_'I'O instance has access values\");\n+\n    type File_Type is limited private;\n \n    type File_Mode is (In_File, Inout_File, Out_File);\n@@ -54,9 +58,9 @@ package Ada.Direct_IO is\n    --  used in this package and System.File_IO.\n \n    for File_Mode use\n-     (In_File     => 0,   -- System.File_IO.File_Mode'Pos (In_File)\n-      Inout_File  => 1,   -- System.File_IO.File_Mode'Pos (Inout_File);\n-      Out_File    => 2);  -- System.File_IO.File_Mode'Pos (Out_File)\n+     (In_File    => 0,   -- System.File_IO.File_Mode'Pos (In_File)\n+      Inout_File => 1,   -- System.File_IO.File_Mode'Pos (Inout_File);\n+      Out_File   => 2);  -- System.File_IO.File_Mode'Pos (Out_File)\n \n    type Count is range 0 .. System.Direct_IO.Count'Last;\n "}, {"sha": "f3a50b65d9c89a933016dc0ce386d4e6cf799526", "filename": "gcc/ada/a-sequio.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fa-sequio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fa-sequio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sequio.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,6 +44,10 @@ generic\n \n package Ada.Sequential_IO is\n \n+   pragma Compile_Time_Warning\n+     (Element_Type'Has_Access_Values,\n+      \"?Element_Type for Sequential_'I'O instance has access values\");\n+\n    type File_Type is limited private;\n \n    type File_Mode is (In_File, Out_File, Append_File);"}, {"sha": "86de4bc819d4e2be8c694b3db5e38b71a0183dae", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -596,7 +596,7 @@ package Einfo is\n --       If the IF/ELSIF condition has the form \"[NOT] OBJ RELOP VAL\",\n --       where OBJ is a reference to an entity with a Current_Value field,\n --       RELOP is one of the six relational operators, and VAL is a compile-\n---       time known valoue, then the Current_Value field if OBJ is set to\n+--       time known value, then the Current_Value field if OBJ is set to\n --       point to the N_If_Statement or N_Elsif_Part node of the relevant\n --       construct. For more details on this usage, see the procedure\n --       Exp_Util.Get_Current_Value_Condition."}, {"sha": "3fec8c15780f8c15631e3969fe04f5948d050c2e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -2080,6 +2080,25 @@ package body Exp_Ch3 is\n          --  to bind any interrupt (signal) entries.\n \n          if Is_Task_Record_Type (Rec_Type) then\n+\n+            --  In the case of the restricted run time the ATCB has already\n+            --  been preallocated.\n+\n+            if Restricted_Profile then\n+               Append_To (Statement_List,\n+                 Make_Assignment_Statement (Loc,\n+                   Name => Make_Selected_Component (Loc,\n+                     Prefix => Make_Identifier (Loc, Name_uInit),\n+                     Selector_Name => Make_Identifier (Loc, Name_uTask_Id)),\n+                   Expression => Make_Attribute_Reference (Loc,\n+                     Prefix =>\n+                       Make_Selected_Component (Loc,\n+                         Prefix => Make_Identifier (Loc, Name_uInit),\n+                         Selector_Name =>\n+                           Make_Identifier (Loc, Name_uATCB)),\n+                     Attribute_Name => Name_Unchecked_Access)));\n+            end if;\n+\n             Append_To (Statement_List, Make_Task_Create_Call (Rec_Type));\n \n             declare"}, {"sha": "7e51ca3ed9c1cd998ee29fda4ff024fb06ba30fe", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 66, "deletions": 26, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -877,21 +877,27 @@ package body Exp_Ch4 is\n    --     end if;\n \n    --     declare\n-   --        B1 : Index_T1 := B'first (1)\n+   --        A1 : Index_T1 := A'first (1);\n+   --        B1 : Index_T1 := B'first (1);\n    --     begin\n-   --        for A1 in A'range (1) loop\n+   --        loop\n    --           declare\n-   --              B2 : Index_T2 := B'first (2)\n+   --              A2 : Index_T2 := A'first (2);\n+   --              B2 : Index_T2 := B'first (2);\n    --           begin\n-   --              for A2 in A'range (2) loop\n+   --              loop\n    --                 if A (A1, A2) /= B (B1, B2) then\n    --                    return False;\n    --                 end if;\n \n+   --                 exit when A2 = A'last (2);\n+   --                 A2 := Index_T2'succ (A2);\n    --                 B2 := Index_T2'succ (B2);\n    --              end loop;\n    --           end;\n \n+   --           exit when A1 = A'last (1);\n+   --           A1 := Index_T1'succ (A1);\n    --           B1 := Index_T1'succ (B1);\n    --        end loop;\n    --     end;\n@@ -905,6 +911,10 @@ package body Exp_Ch4 is\n    --  has a bound depending on a discriminant, then we use the base type\n    --  since otherwise we have an escaped discriminant in the function.\n \n+   --  If both arrays are constrained and have the same bounds, we can\n+   --  generate a loop with an explicit iteration scheme using a 'Range\n+   --  attribute over the first array.\n+\n    function Expand_Array_Equality\n      (Nod    : Node_Id;\n       Lhs    : Node_Id;\n@@ -949,27 +959,29 @@ package body Exp_Ch4 is\n       --  This procedure returns the following code\n       --\n       --    declare\n-      --       Bn : Index_T := B'First (n);\n+      --       Bn : Index_T := B'First (N);\n       --    begin\n-      --       for An in A'range (n) loop\n+      --       loop\n       --          xxx\n+      --          exit when An = A'Last (N);\n+      --          An := Index_T'Succ (An)\n       --          Bn := Index_T'Succ (Bn)\n       --       end loop;\n       --    end;\n       --\n-      --  Note: we don't need Bn or the declare block when the index types\n-      --  of the two arrays are constrained and identical.\n+      --  If both indices are constrained and identical, the procedure\n+      --  returns a simpler loop:\n+      --\n+      --      for An in A'Range (N) loop\n+      --         xxx\n+      --      end loop\n       --\n-      --  where N is the value of \"n\" in the above code. Index is the\n+      --  N is the dimension for which we are generating a loop. Index is the\n       --  N'th index node, whose Etype is Index_Type_n in the above code.\n       --  The xxx statement is either the loop or declare for the next\n       --  dimension or if this is the last dimension the comparison\n       --  of corresponding components of the arrays.\n       --\n-      --  Note: if the index types are identical and constrained, we\n-      --  need only one index, so we generate only An and we do not\n-      --  need the declare block.\n-      --\n       --  The actual way the code works is to return the comparison\n       --  of corresponding components for the N+1 call. That's neater!\n \n@@ -1119,6 +1131,24 @@ package body Exp_Ch4 is\n            Handle_One_Dimension (N + 1, Next_Index (Index)));\n \n          if Need_Separate_Indexes then\n+            --  Generate guard for loop, followed by increments of indices.\n+\n+            Append_To (Stm_List,\n+               Make_Exit_Statement (Loc,\n+                 Condition =>\n+                   Make_Op_Eq (Loc,\n+                      Left_Opnd => New_Reference_To (An, Loc),\n+                      Right_Opnd => Arr_Attr (A, Name_Last, N))));\n+\n+            Append_To (Stm_List,\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Reference_To (An, Loc),\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => New_Reference_To (Index_T, Loc),\n+                    Attribute_Name => Name_Succ,\n+                    Expressions    => New_List (New_Reference_To (An, Loc)))));\n+\n             Append_To (Stm_List,\n               Make_Assignment_Statement (Loc,\n                 Name       => New_Reference_To (Bn, Loc),\n@@ -1129,34 +1159,44 @@ package body Exp_Ch4 is\n                     Expressions    => New_List (New_Reference_To (Bn, Loc)))));\n          end if;\n \n-         Loop_Stm :=\n-           Make_Implicit_Loop_Statement (Nod,\n-             Statements       => Stm_List,\n-             Iteration_Scheme =>\n-               Make_Iteration_Scheme (Loc,\n-                 Loop_Parameter_Specification =>\n-                   Make_Loop_Parameter_Specification (Loc,\n-                     Defining_Identifier         => An,\n-                     Discrete_Subtype_Definition =>\n-                       Arr_Attr (A, Name_Range, N))));\n-\n-         --  If separate indexes, need a declare block to declare Bn\n+         --  If separate indexes, we need a declare block for An and Bn,\n+         --  and a loop without an iteration scheme.\n \n          if Need_Separate_Indexes then\n+            Loop_Stm :=\n+              Make_Implicit_Loop_Statement (Nod, Statements => Stm_List);\n+\n             return\n               Make_Block_Statement (Loc,\n                 Declarations => New_List (\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => An,\n+                    Object_Definition   => New_Reference_To (Index_T, Loc),\n+                    Expression          => Arr_Attr (A, Name_First, N)),\n+\n                   Make_Object_Declaration (Loc,\n                     Defining_Identifier => Bn,\n                     Object_Definition   => New_Reference_To (Index_T, Loc),\n                     Expression          => Arr_Attr (B, Name_First, N))),\n+\n                 Handled_Statement_Sequence =>\n                   Make_Handled_Sequence_Of_Statements (Loc,\n                     Statements => New_List (Loop_Stm)));\n \n-         --  If no separate indexes, return loop statement on its own\n+         --  If no separate indexes, return loop statement with explicit\n+         --  iteration scheme on its own\n \n          else\n+            Loop_Stm :=\n+              Make_Implicit_Loop_Statement (Nod,\n+                Statements       => Stm_List,\n+                Iteration_Scheme =>\n+                  Make_Iteration_Scheme (Loc,\n+                    Loop_Parameter_Specification =>\n+                      Make_Loop_Parameter_Specification (Loc,\n+                        Defining_Identifier         => An,\n+                        Discrete_Subtype_Definition =>\n+                          Arr_Attr (A, Name_Range, N))));\n             return Loop_Stm;\n          end if;\n       end Handle_One_Dimension;"}, {"sha": "083c6c291a72b37944a93d1ca16a2844888e02c1", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 238, "deletions": 128, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -52,6 +52,7 @@ with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n \n@@ -97,7 +98,7 @@ package body Exp_Ch5 is\n    --  of representation.\n \n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n-   --  Generate the necessary code for controlled and Tagged assignment,\n+   --  Generate the necessary code for controlled and tagged assignment,\n    --  that is to say, finalization of the target before, adjustement of\n    --  the target after and save and restore of the tag and finalization\n    --  pointers which are not 'part of the value' and must not be changed\n@@ -3031,12 +3032,7 @@ package body Exp_Ch5 is\n \n       Res       : List_Id;\n       Tag_Tmp   : Entity_Id;\n-      Prev_Tmp  : Entity_Id;\n-      Next_Tmp  : Entity_Id;\n-      Ctrl_Ref  : Node_Id;\n-      Ctrl_Ref2 : Node_Id   := Empty;\n-      Prev_Tmp2 : Entity_Id := Empty;  -- prevent warning\n-      Next_Tmp2 : Entity_Id := Empty;  -- prevent warning\n+      Original_Size, Range_Type, Opaque_Type : Entity_Id;\n \n    begin\n       Res := New_List;\n@@ -3074,8 +3070,6 @@ package body Exp_Ch5 is\n              With_Detach => New_Reference_To (Standard_False, Loc)));\n       end if;\n \n-      Next_Tmp := Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n-\n       --  Save the Tag in a local variable Tag_Tmp\n \n       if Save_Tag then\n@@ -3097,102 +3091,263 @@ package body Exp_Ch5 is\n          Tag_Tmp := Empty;\n       end if;\n \n-      --  Save the Finalization Pointers in local variables Prev_Tmp and\n-      --  Next_Tmp. For objects with Has_Controlled_Component set, these\n-      --  pointers are in the Record_Controller and if it is also\n-      --  Is_Controlled, we need to save the object pointers as well.\n+      --  We really need a comment here ???\n \n       if Ctrl_Act then\n-         Ctrl_Ref := Duplicate_Subexpr_No_Checks (L);\n \n-         if Has_Controlled_Component (T) then\n-            Ctrl_Ref :=\n-              Make_Selected_Component (Loc,\n-                Prefix => Ctrl_Ref,\n-                Selector_Name =>\n-                  New_Reference_To (Controller_Component (T), Loc));\n+         --  subtype G is Storage_Offset range 1 .. Expr'Size\n \n-            if Is_Controlled (T) then\n-               Ctrl_Ref2 := Duplicate_Subexpr_No_Checks (L);\n-            end if;\n-         end if;\n-\n-         Prev_Tmp := Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n+         Original_Size :=\n+           Make_Defining_Identifier (Loc,\n+             New_Internal_Name ('S'));\n \n          Append_To (Res,\n            Make_Object_Declaration (Loc,\n-             Defining_Identifier => Prev_Tmp,\n+             Defining_Identifier => Original_Size,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (\n+               RTE (RE_Storage_Offset), Loc),\n+             Expression          =>\n+               Make_Op_Divide (Loc,\n+                 Left_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix =>\n+                       Duplicate_Subexpr_No_Checks (L),\n+                     Attribute_Name => Name_Size),\n+                 Right_Opnd => Make_Integer_Literal (Loc,\n+                     Intval => System_Storage_Unit))));\n+\n+         Range_Type :=\n+           Make_Defining_Identifier (Loc,\n+             New_Internal_Name ('G'));\n \n-             Object_Definition =>\n-               New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n+         Append_To (Res,\n+           Make_Subtype_Declaration (Loc,\n+             Defining_Identifier => Range_Type,\n+             Subtype_Indication =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark =>\n+                   New_Reference_To (RTE (RE_Storage_Offset), Loc),\n+                 Constraint   => Make_Range_Constraint (Loc,\n+                   Range_Expression =>\n+                     Make_Range (Loc,\n+                       Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                       High_Bound => New_Occurrence_Of (\n+                         Original_Size, Loc))))));\n+\n+         --  subtype S is Storage_Array (G)\n \n-             Expression =>\n-               Make_Selected_Component (Loc,\n-                 Prefix =>\n-                   Unchecked_Convert_To (RTE (RE_Finalizable), Ctrl_Ref),\n-                 Selector_Name => Make_Identifier (Loc, Name_Prev))));\n+         Append_To (Res,\n+           Make_Subtype_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc,\n+                 New_Internal_Name ('S')),\n+             Subtype_Indication  =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark =>\n+                   New_Reference_To (RTE (RE_Storage_Array), Loc),\n+                 Constraint =>\n+                   Make_Index_Or_Discriminant_Constraint (Loc,\n+                     Constraints =>\n+                       New_List (New_Reference_To (Range_Type, Loc))))));\n+\n+         --  type A is access S\n+\n+         Opaque_Type := Make_Defining_Identifier (Loc,\n+           New_Internal_Name ('A'));\n+         Append_To (Res,\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => Opaque_Type,\n+             Type_Definition     =>\n+               Make_Access_To_Object_Definition (Loc,\n+                 Subtype_Indication =>\n+                   New_Occurrence_Of (\n+                     Defining_Identifier (Last (Res)), Loc))));\n \n-         Next_Tmp := Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n+         --  Give a label name to this declare block, and add comments here???\n \n-         Append_To (Res,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Next_Tmp,\n+         declare\n+            Prev_Ref : Node_Id;\n \n-             Object_Definition =>\n-               New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n+            First_After_Root : Node_Id := Empty;\n+            --  Index of first byte to be copied (used to skip\n+            --  Root_Controlled in controlled objects).\n \n-             Expression =>\n-               Make_Selected_Component (Loc,\n+            Last_Before_Hole : Node_Id := Empty;\n+            --  Index of last byte to be copied before outermost record\n+            --  controller data.\n+\n+            Hole_Length      : Node_Id := Empty;\n+            --  Length of record controller data (Prev and Next pointers)\n+\n+            First_After_Hole : Node_Id := Empty;\n+            --  Index of first byte to be copied after outermost record\n+            --  controller data.\n+\n+            function Build_Slice\n+              (Rec    : Entity_Id;\n+               Lo, Hi : Node_Id) return Node_Id;\n+            --  Function specs must have comments, saying what all the\n+            --  parameters are and what the function does ???\n+\n+            -----------------\n+            -- Build_Slice --\n+            -----------------\n+\n+            function Build_Slice\n+              (Rec    : Node_Id;\n+               Lo, Hi : Node_Id) return Node_Id\n+            is\n+               Lo_Bound, Hi_Bound : Node_Id;\n+\n+               Opaque : constant Node_Id :=\n+                          Unchecked_Convert_To (Opaque_Type,\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix         => Rec,\n+                              Attribute_Name => Name_Address));\n+               --  Comment required, what is this???\n+\n+            begin\n+               --  Comments required in this body ???\n+\n+               if No (Lo) then\n+                  Lo_Bound := Make_Integer_Literal (Loc, 1);\n+               else\n+                  Lo_Bound := Lo;\n+               end if;\n+\n+               if No (Hi) then\n+                  Hi_Bound := Make_Attribute_Reference (Loc,\n+                    Prefix => New_Occurrence_Of (Range_Type, Loc),\n+                    Attribute_Name => Name_Last);\n+               else\n+                  Hi_Bound := Hi;\n+               end if;\n+\n+               return Make_Slice (Loc,\n                  Prefix =>\n-                   Unchecked_Convert_To (RTE (RE_Finalizable),\n-                     New_Copy_Tree (Ctrl_Ref)),\n-                 Selector_Name => Make_Identifier (Loc, Name_Next))));\n+                   Opaque,\n+                 Discrete_Range => Make_Range (Loc,\n+                   Lo_Bound, Hi_Bound));\n+            end Build_Slice;\n \n-         if Present (Ctrl_Ref2) then\n-            Prev_Tmp2 :=\n-              Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n+         --  Start of processing for ??? (name of block)\n \n-            Append_To (Res,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Prev_Tmp2,\n+         begin\n+            First_After_Root := Make_Integer_Literal (Loc, 1);\n \n-                Object_Definition =>\n-                  New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n+            --  Comment ???\n \n-                Expression =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable), Ctrl_Ref2),\n-                    Selector_Name => Make_Identifier (Loc, Name_Prev))));\n+            if Is_Controlled (T) then\n+               First_After_Root :=\n+                 Make_Op_Add (Loc,\n+                   First_After_Root,\n+                   Make_Op_Divide (Loc,\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix =>\n+                         New_Occurrence_Of (RTE (RE_Root_Controlled), Loc),\n+                       Attribute_Name => Name_Size),\n+                     Make_Integer_Literal (Loc, System_Storage_Unit)));\n+            end if;\n \n-            Next_Tmp2 :=\n-              Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n+            if Has_Controlled_Component (T) then\n \n-            Append_To (Res,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Next_Tmp2,\n+               --  The record controller Prev and Next pointers must be left\n+               --  intact in the target object, not copied. Compute the bounds\n+               --  of the hole to be skipped in copying the objecct.\n \n-                Object_Definition =>\n-                  New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n+               Prev_Ref :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => Duplicate_Subexpr_No_Checks (L),\n+                       Selector_Name =>\n+                         New_Reference_To (Controller_Component (T), Loc)),\n+                   Selector_Name =>  Make_Identifier (Loc, Name_Prev));\n \n-                Expression =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable),\n-                        New_Copy_Tree (Ctrl_Ref2)),\n-                    Selector_Name => Make_Identifier (Loc, Name_Next))));\n-         end if;\n+               --  Last index before hole\n \n-      --  If not controlled type, then Prev_Tmp and Ctrl_Ref unused\n+               Last_Before_Hole :=\n+                 Make_Defining_Identifier (Loc,\n+                   New_Internal_Name ('L'));\n \n-      else\n-         Prev_Tmp := Empty;\n-         Ctrl_Ref := Empty;\n-      end if;\n+               Append_To (Res,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Last_Before_Hole,\n+                   Object_Definition   => New_Occurrence_Of (\n+                     RTE (RE_Storage_Offset), Loc),\n+                   Constant_Present    => True,\n+                   Expression          => Make_Op_Add (Loc,\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => Prev_Ref,\n+                         Attribute_Name => Name_Position),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Copy_Tree (Prefix (Prev_Ref)),\n+                         Attribute_Name => Name_Position))));\n \n-      --  Do the Assignment\n+               --  Hole length\n+\n+               Hole_Length :=\n+                 Make_Op_Multiply (Loc,\n+                   Make_Integer_Literal (Loc, Uint_2),\n+                     Make_Op_Divide (Loc,\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix =>\n+                           New_Copy_Tree (Prev_Ref),\n+                         Attribute_Name =>\n+                           Name_Size),\n+                     Make_Integer_Literal (Loc, System_Storage_Unit)));\n+\n+               --  First index after hole\n+\n+               First_After_Hole :=\n+                 Make_Defining_Identifier (Loc,\n+                   New_Internal_Name ('F'));\n+\n+               Append_To (Res,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => First_After_Hole,\n+                   Object_Definition   => New_Occurrence_Of (\n+                     RTE (RE_Storage_Offset), Loc),\n+                   Constant_Present    => True,\n+                   Expression          =>\n+                     Make_Op_Add (Loc,\n+                       Make_Op_Add (Loc,\n+                         New_Occurrence_Of (Last_Before_Hole, Loc),\n+                         Hole_Length),\n+                       Make_Integer_Literal (Loc, 1))));\n+\n+               Last_Before_Hole := New_Occurrence_Of (Last_Before_Hole, Loc);\n+               First_After_Hole := New_Occurrence_Of (First_After_Hole, Loc);\n+            end if;\n \n-      Append_To (Res, Relocate_Node (N));\n+            --  More comments needed everywhere ???\n+\n+            Append_To (Res, Make_Assignment_Statement (Loc,\n+              Name       => Build_Slice (Duplicate_Subexpr_No_Checks (L),\n+                                         First_After_Root,\n+                                         Last_Before_Hole),\n+\n+              Expression => Build_Slice (Expression (N),\n+                                         First_After_Root,\n+                                         New_Copy_Tree (Last_Before_Hole))));\n+\n+\n+            if Present (First_After_Hole) then\n+               Remove_Side_Effects (Expression (N));\n+               Append_To (Res, Make_Assignment_Statement (Loc,\n+                 Name       => Build_Slice (Duplicate_Subexpr_No_Checks (L),\n+                                            First_After_Hole,\n+                                            Empty),\n+                 Expression => Build_Slice (New_Copy_Tree (Expression (N)),\n+                                            New_Copy_Tree (First_After_Hole),\n+                                            Empty)));\n+            end if;\n+         end;\n+\n+      else\n+         Append_To (Res, Relocate_Node (N));\n+      end if;\n \n       --  Restore the Tag\n \n@@ -3206,55 +3361,8 @@ package body Exp_Ch5 is\n              Expression => New_Reference_To (Tag_Tmp, Loc)));\n       end if;\n \n-      --  Restore the finalization pointers\n-\n-      if Ctrl_Act then\n-         Append_To (Res,\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               Make_Selected_Component (Loc,\n-                 Prefix =>\n-                   Unchecked_Convert_To (RTE (RE_Finalizable),\n-                     New_Copy_Tree (Ctrl_Ref)),\n-                 Selector_Name => Make_Identifier (Loc, Name_Prev)),\n-             Expression => New_Reference_To (Prev_Tmp, Loc)));\n-\n-         Append_To (Res,\n-           Make_Assignment_Statement (Loc,\n-             Name =>\n-               Make_Selected_Component (Loc,\n-                 Prefix =>\n-                   Unchecked_Convert_To (RTE (RE_Finalizable),\n-                     New_Copy_Tree (Ctrl_Ref)),\n-                 Selector_Name => Make_Identifier (Loc, Name_Next)),\n-             Expression => New_Reference_To (Next_Tmp, Loc)));\n-\n-         if Present (Ctrl_Ref2) then\n-            Append_To (Res,\n-              Make_Assignment_Statement (Loc,\n-                Name =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable),\n-                        New_Copy_Tree (Ctrl_Ref2)),\n-                    Selector_Name => Make_Identifier (Loc, Name_Prev)),\n-                Expression => New_Reference_To (Prev_Tmp2, Loc)));\n-\n-            Append_To (Res,\n-              Make_Assignment_Statement (Loc,\n-                Name =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      Unchecked_Convert_To (RTE (RE_Finalizable),\n-                        New_Copy_Tree (Ctrl_Ref2)),\n-                    Selector_Name => Make_Identifier (Loc, Name_Next)),\n-                Expression => New_Reference_To (Next_Tmp2, Loc)));\n-         end if;\n-      end if;\n-\n-      --  Adjust the target after the assignment when controlled. (not in\n-      --  the init proc since it is an initialization more than an\n-      --  assignment)\n+      --  Adjust the target after the assignment when controlled (not in the\n+      --  init proc since it is an initialization more than an assignment).\n \n       if Ctrl_Act then\n          Append_List_To (Res,\n@@ -3268,6 +3376,8 @@ package body Exp_Ch5 is\n       return Res;\n \n    exception\n+      --  Could use comment here ???\n+\n       when RE_Not_Available =>\n          return Empty_List;\n    end Make_Tag_Ctrl_Assignment;"}, {"sha": "1b07efaf321e36f9d582e0e30ab630b2b99bc30b", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -7226,6 +7226,29 @@ package body Exp_Ch9 is\n               Subtype_Indication => New_Reference_To (RTE (RO_ST_Task_Id),\n                                     Loc))));\n \n+      --  Declare static ATCB (that is, created by the expander) if we\n+      --  are using the Restricted run time.\n+\n+      if Restricted_Profile then\n+         Append_To (Cdecls,\n+           Make_Component_Declaration (Loc,\n+             Defining_Identifier  =>\n+               Make_Defining_Identifier (Loc, Name_uATCB),\n+\n+             Component_Definition =>\n+               Make_Component_Definition (Loc,\n+                 Aliased_Present     => True,\n+                 Subtype_Indication  => Make_Subtype_Indication (Loc,\n+                   Subtype_Mark => New_Occurrence_Of\n+                     (RTE (RE_Ada_Task_Control_Block), Loc),\n+\n+                   Constraint   =>\n+                     Make_Index_Or_Discriminant_Constraint (Loc,\n+                       Constraints =>\n+                         New_List (Make_Integer_Literal (Loc, 0)))))));\n+\n+      end if;\n+\n       --  Add components for entry families\n \n       Collect_Entry_Families (Loc, Cdecls, Size_Decl, Tasktyp);"}, {"sha": "a823520971a4a4117160241d4aaab2dac5b04619", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -624,12 +624,14 @@ package body Exp_Util is\n          if Nkind (Id_Ref) = N_Identifier\n            or else Nkind (Id_Ref) = N_Defining_Identifier\n          then\n-            --  For a simple variable, the image of the task is the name\n-            --  of the variable.\n+            --  For a simple variable, the image of the task is built from\n+            --  the name of the variable. To avoid possible conflict with\n+            --  the anonymous type created for a single protected object,\n+            --  add a numeric suffix.\n \n             T_Id :=\n               Make_Defining_Identifier (Loc,\n-                New_External_Name (Chars (Id_Ref), 'T'));\n+                New_External_Name (Chars (Id_Ref), 'T', 1));\n \n             Get_Name_String (Chars (Id_Ref));\n \n@@ -1331,7 +1333,10 @@ package body Exp_Util is\n \n       Par := Exp;\n       while Present (Par)\n-        and then Nkind (Par) = N_Selected_Component\n+        and then\n+         (Nkind (Par) = N_Selected_Component\n+            or else\n+          Nkind (Par) = N_Indexed_Component)\n       loop\n          if Nkind (Parent (Par)) = N_Assignment_Statement\n            and then Par = Name (Parent (Par))"}, {"sha": "366650c7431f349a6a9172e320266d63d358fcf1", "filename": "gcc/ada/gnat-style.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fgnat-style.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fgnat-style.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat-style.texi?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -716,7 +716,10 @@ format:\n \n @noindent\n Note that the name in the header is preceded by a single space,\n-not two spaces as for other comments.\n+not two spaces as for other comments. These headers are used on\n+nested subprograms as well as outer level subprograms. They may\n+also be used as headers for sections of comments, or collections\n+of declarations that are related.\n \n @item\n Every subprogram body must have a preceding @syntax{subprogram_declaration}."}, {"sha": "ea278f14cf9cd27900b0fd4280676ebc99ee3657", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -202,6 +202,7 @@ Implementation Defined Attributes\n * Enum_Rep::\n * Epsilon::\n * Fixed_Value::\n+* Has_Access_Values::\n * Has_Discriminants::\n * Img::\n * Integer_Value::\n@@ -4000,6 +4001,7 @@ consideration, you should minimize the use of these attributes.\n * Enum_Rep::\n * Epsilon::\n * Fixed_Value::\n+* Has_Access_Values::\n * Has_Discriminants::\n * Img::\n * Integer_Value::\n@@ -4305,6 +4307,19 @@ that there are full range checks, to ensure that the result is in range.\n This attribute is primarily intended for use in implementation of the\n input-output functions for fixed-point values.\n \n+@node Has_Access_Values\n+@unnumberedsec Has_Access_Values\n+@cindex Access values, testing for\n+@findex Has_Access_Values\n+@noindent\n+The prefix of the @code{Has_Access_Values} attribute is a type.  The result\n+is a Boolean value which is True if the is an access type, or is a composite\n+type with a component (at any nesting depth) that is an access type, and is\n+False otherwise.\n+The intended use of this attribute is in conjunction with generic\n+definitions.  If the attribute is applied to a generic private type, it\n+indicates whether or not the corresponding actual type has access values.\n+\n @node Has_Discriminants\n @unnumberedsec Has_Discriminants\n @cindex Discriminants, testing for"}, {"sha": "4162ea2037e2f3c29af357f62f63f036116f5d9f", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -4418,6 +4418,9 @@ Unreachable code\n @item\n Fixed-point type declarations with a null range\n \n+@item\n+Direct_IO or Sequential_IO instantiated with a type that has access values\n+\n @item\n Variables that are never assigned a value\n "}, {"sha": "8cc960a9bf59275eb199febc9b9439f4362956c2", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -1728,8 +1728,9 @@ package body Make is\n \n             if Arguments_Project = No_Project then\n                if not External_Unit_Compilation_Allowed then\n-                  Make_Failed (\"external source, not part of any projects, \" &\n-                               \"cannot be compiled (\", Source_File_Name, \")\");\n+                  Make_Failed (\"external source (\", Source_File_Name,\n+                               \") is not part of any project; cannot be \" &\n+                               \"compiled without gnatmake switch -x\");\n                end if;\n \n                --  If it is allowed, simply add the saved gcc switches"}, {"sha": "5594bbaa2c0d331f17b90b420d41ee8783cbfe20", "filename": "gcc/ada/makegpr.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fmakegpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fmakegpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakegpr.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -1222,6 +1222,7 @@ package body Makegpr is\n          Global_Archive_Exists := Last_Argument > First_Object;\n \n          if Global_Archive_Exists then\n+\n             --  If the archive is built, then linking will need to occur\n             --  unconditionally.\n \n@@ -1230,9 +1231,7 @@ package body Makegpr is\n             --  Spawn the archive builder (ar)\n \n             Saved_Last_Argument := Last_Argument;\n-\n             Last_Argument := First_Object + Max_In_Archives;\n-\n             loop\n                if Last_Argument > Saved_Last_Argument then\n                   Last_Argument := Saved_Last_Argument;"}, {"sha": "71324884f777f2acebea8fab0396df3750c0ebe0", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -1877,6 +1877,7 @@ package body Ch5 is\n       Goto_Node := New_Node (N_Goto_Statement, Token_Ptr);\n       Scan; -- past GOTO (or TO)\n       Set_Name (Goto_Node, P_Qualified_Simple_Name_Resync);\n+      Append_Elmt (Goto_Node, Goto_List);\n       No_Constraint;\n       TF_Semicolon;\n       return Goto_Node;"}, {"sha": "2fd70e5c09c19b988b8e71bf2da7b399f492f210", "filename": "gcc/ada/par-labl.adb", "status": "modified", "additions": 331, "deletions": 1, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fpar-labl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fpar-labl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-labl.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,6 +51,11 @@ procedure Labl is\n    --  Checks the rule in RM-5.1(11), which requires distinct identifiers\n    --  for all the labels in a given body.\n \n+   procedure Find_Natural_Loops;\n+   --  Recognizes loops created by backward gotos, and rewrites the\n+   --  corresponding statements into a proper loop, for optimization\n+   --  purposes (for example, to control reclaiming local storage).\n+\n    ---------------------------\n    -- Check_Distinct_Labels --\n    ---------------------------\n@@ -145,6 +150,329 @@ procedure Labl is\n       return Result;\n    end Find_Enclosing_Body_Or_Block;\n \n+   ------------------------\n+   -- Find_Natural_Loops --\n+   ------------------------\n+\n+   procedure Find_Natural_Loops is\n+      Node_List : constant Elist_Id := New_Elmt_List;\n+      N         : Elmt_Id;\n+      Succ      : Elmt_Id;\n+\n+      function Goto_Id (Goto_Node : Node_Id) return Name_Id;\n+      --  Find Name_Id of goto statement, which may be an expanded name.\n+\n+      function Matches\n+        (Label_Node : Node_Id;\n+         Goto_Node  : Node_Id) return Boolean;\n+      --  A label and a goto are candidates for a loop if the names match,\n+      --  and both nodes appear in the same body. In addition, both must\n+      --  appear in the same statement list. If they are not in the same\n+      --  statement list, the goto is from within an nested structure, and\n+      --  the label is not a header. We ignore the case where the goto is\n+      --  within a conditional structure, and capture only infinite loops.\n+\n+      procedure Merge;\n+      --  Merge labels and goto statements in order of increasing sloc value.\n+      --  Discard labels of loop and block statements.\n+\n+      procedure No_Header (N : Elmt_Id);\n+      --  The label N is known not to be a loop header. Scan forward and\n+      --  remove all subsequent goto's that may have this node as a target.\n+\n+      procedure Process_Goto (N : Elmt_Id);\n+      --  N is a forward jump. Scan forward and remove all subsequent goto's\n+      --  that may have the same target, to preclude spurious loops.\n+\n+      procedure Rewrite_As_Loop\n+        (Loop_Header : Node_Id;\n+         Loop_End    : Node_Id);\n+      --  Given a label and a backwards goto, rewrite intervening statements\n+      --  as a loop. Remove the label from the node list, and rewrite the\n+      --  goto with the body of the new loop.\n+\n+      procedure Try_Loop (N : Elmt_Id);\n+      --  N is a label that may be a loop header. Scan forward to find some\n+      --  backwards goto with which to make a loop. Do nothing if there is\n+      --  an intervening label that is not part of a loop, or more than one\n+      --  goto with this target.\n+\n+      -------------\n+      -- Goto_Id --\n+      -------------\n+\n+      function Goto_Id (Goto_Node : Node_Id) return Name_Id is\n+      begin\n+         if Nkind (Name (Goto_Node)) = N_Identifier then\n+            return Chars (Name (Goto_Node));\n+\n+         elsif Nkind (Name (Goto_Node)) = N_Selected_Component then\n+            return Chars (Selector_Name (Name (Goto_Node)));\n+         else\n+\n+            --  In case of error, return Id that can't match anything\n+\n+            return Name_Null;\n+         end if;\n+      end Goto_Id;\n+\n+      -------------\n+      -- Matches --\n+      -------------\n+\n+      function Matches\n+        (Label_Node : Node_Id;\n+         Goto_Node  :  Node_Id) return Boolean\n+      is\n+      begin\n+         return Chars (Identifier (Label_Node)) = Goto_Id (Goto_Node)\n+           and then Find_Enclosing_Body (Label_Node) =\n+                    Find_Enclosing_Body (Goto_Node);\n+      end Matches;\n+\n+      -----------\n+      -- Merge --\n+      -----------\n+\n+      procedure Merge is\n+         L1 : Elmt_Id;\n+         G1 : Elmt_Id;\n+\n+      begin\n+         L1 := First_Elmt (Label_List);\n+         G1 := First_Elmt (Goto_List);\n+\n+         while Present (L1)\n+           and then Present (G1)\n+         loop\n+            if Sloc (Node (L1)) < Sloc (Node (G1)) then\n+\n+               --  Optimization: remove labels of loops and blocks, which\n+               --  play no role in what follows.\n+\n+               if Nkind (Node (L1)) /= N_Loop_Statement\n+                 and then Nkind (Node (L1)) /= N_Block_Statement\n+               then\n+                  Append_Elmt (Node (L1), Node_List);\n+               end if;\n+\n+               Next_Elmt (L1);\n+\n+            else\n+               Append_Elmt (Node (G1), Node_List);\n+               Next_Elmt (G1);\n+            end if;\n+         end loop;\n+\n+         while Present (L1) loop\n+            Append_Elmt (Node (L1), Node_List);\n+            Next_Elmt (L1);\n+         end loop;\n+\n+         while Present (G1) loop\n+            Append_Elmt (Node (G1), Node_List);\n+            Next_Elmt (G1);\n+         end loop;\n+      end Merge;\n+\n+      ---------------\n+      -- No_Header --\n+      ---------------\n+\n+      procedure No_Header (N : Elmt_Id) is\n+         S1, S2 : Elmt_Id;\n+\n+      begin\n+         S1 := Next_Elmt (N);\n+         while Present (S1) loop\n+            S2 := Next_Elmt (S1);\n+            if Nkind (Node (S1)) = N_Goto_Statement\n+              and then Matches (Node (N), Node (S1))\n+            then\n+               Remove_Elmt (Node_List, S1);\n+            end if;\n+\n+            S1 := S2;\n+         end loop;\n+      end No_Header;\n+\n+      ------------------\n+      -- Process_Goto --\n+      ------------------\n+\n+      procedure Process_Goto (N : Elmt_Id) is\n+         Goto1 : constant Node_Id := Node (N);\n+         Goto2 : Node_Id;\n+         S, S1 : Elmt_Id;\n+\n+      begin\n+         S := Next_Elmt (N);\n+\n+         while Present (S) loop\n+            S1 := Next_Elmt (S);\n+            Goto2 := Node (S);\n+\n+            if Nkind (Goto2) = N_Goto_Statement\n+              and then Goto_Id (Goto1) = Goto_Id (Goto2)\n+              and then Find_Enclosing_Body (Goto1) =\n+                       Find_Enclosing_Body (Goto2)\n+            then\n+\n+               --  Goto2 may have the same target, remove it from\n+               --  consideration.\n+\n+               Remove_Elmt (Node_List, S);\n+            end if;\n+\n+            S := S1;\n+         end loop;\n+      end Process_Goto;\n+\n+      ---------------------\n+      -- Rewrite_As_Loop --\n+      ---------------------\n+\n+      procedure Rewrite_As_Loop\n+        (Loop_Header : Node_Id;\n+         Loop_End    : Node_Id)\n+      is\n+         Loop_Body : constant List_Id := New_List;\n+         Loop_Stmt : constant Node_Id :=\n+                       New_Node (N_Loop_Statement, Sloc (Loop_Header));\n+         Stat      : Node_Id;\n+         Next_Stat : Node_Id;\n+      begin\n+         Stat := Next (Loop_Header);\n+         while Stat /= Loop_End loop\n+            Next_Stat := Next (Stat);\n+            Remove (Stat);\n+            Append (Stat, Loop_Body);\n+            Stat := Next_Stat;\n+         end loop;\n+\n+         Set_Statements (Loop_Stmt, Loop_Body);\n+         Set_Identifier (Loop_Stmt, Identifier (Loop_Header));\n+\n+         Remove (Loop_Header);\n+         Rewrite (Loop_End, Loop_Stmt);\n+         Error_Msg_N\n+           (\"code between label and backwards goto rewritten as loop?\",\n+             Loop_End);\n+      end Rewrite_As_Loop;\n+\n+      --------------\n+      -- Try_Loop --\n+      --------------\n+\n+      procedure Try_Loop (N : Elmt_Id) is\n+         Source : Elmt_Id;\n+         Found  : Boolean := False;\n+         S1     : Elmt_Id;\n+\n+      begin\n+         S1 := Next_Elmt (N);\n+         while Present (S1) loop\n+            if Nkind (Node (S1)) = N_Goto_Statement\n+              and then Matches (Node (N), Node (S1))\n+            then\n+               if not Found then\n+                  if Parent (Node (N)) = Parent (Node (S1)) then\n+                     Source := S1;\n+                     Found  := True;\n+\n+                  else\n+                     --  The goto is within some nested structure\n+\n+                     No_Header (N);\n+                     return;\n+                  end if;\n+\n+               else\n+                  --  More than one goto with the same target\n+\n+                  No_Header (N);\n+                  return;\n+               end if;\n+\n+            elsif Nkind (Node (S1)) = N_Label\n+              and then not Found\n+            then\n+               --  Intervening label before possible end of loop. Current\n+               --  label is not a candidate. This is conservative, because\n+               --  the label might not be the target of any jumps, but not\n+               --  worth dealing with useless labels!\n+\n+               No_Header (N);\n+               return;\n+\n+            else\n+               --  If the node is a loop_statement, it corresponds to a\n+               --  label-goto pair rewritten as a loop. Continue forward scan.\n+\n+               null;\n+            end if;\n+\n+            Next_Elmt (S1);\n+         end loop;\n+\n+         if Found then\n+            Rewrite_As_Loop (Node (N), Node (Source));\n+            Remove_Elmt (Node_List, N);\n+            Remove_Elmt (Node_List, Source);\n+         end if;\n+      end Try_Loop;\n+\n+   begin\n+      --  Start of processing for Find_Natural_Loops\n+\n+      Merge;\n+\n+      N := First_Elmt (Node_List);\n+      while Present (N) loop\n+         Succ := Next_Elmt (N);\n+\n+         if Nkind (Node (N)) = N_Label then\n+            if No (Succ) then\n+               exit;\n+\n+            elsif Nkind (Node (Succ)) = N_Label then\n+               Try_Loop (Succ);\n+\n+               --  If a loop was found, the label has been removed, and\n+               --  the following goto rewritten as the loop body.\n+\n+               Succ := Next_Elmt (N);\n+\n+               if Nkind (Node (Succ)) = N_Label then\n+\n+                  --  Following label was not removed, so current label\n+                  --  is not a candidate header.\n+\n+                  No_Header (N);\n+\n+               else\n+\n+                  --  Following label was part of inner loop. Current\n+                  --  label is still a candidate.\n+\n+                  Try_Loop (N);\n+                  Succ := Next_Elmt (N);\n+               end if;\n+\n+            elsif Nkind (Node (Succ)) = N_Goto_Statement then\n+               Try_Loop (N);\n+               Succ := Next_Elmt (N);\n+            end if;\n+\n+         elsif Nkind (Node (N)) = N_Goto_Statement then\n+            Process_Goto (N);\n+            Succ := Next_Elmt (N);\n+         end if;\n+\n+         N := Succ;\n+      end loop;\n+   end Find_Natural_Loops;\n+\n --  Start of processing for Par.Labl\n \n begin\n@@ -204,4 +532,6 @@ begin\n          Next_Elmt (Next_Label_Elmt);\n    end loop;\n \n+   Find_Natural_Loops;\n+\n end Labl;"}, {"sha": "897770656393e2d9f7f2d2ab2d1c391007e5a4e3", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -395,6 +395,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    SS_Whtm           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, T, F);\n    SS_Unco           : constant SS_Rec := SS_Rec'(F, F, F, F, F, F, F, T);\n \n+   Goto_List : Elist_Id;\n+   --  List of goto nodes appearing in the current compilation. Used to\n+   --  recognize natural loops and convert them into bona fide loops for\n+   --  optimization purposes.\n+\n    Label_List : Elist_Id;\n    --  List of label nodes for labels appearing in the current compilation.\n    --  Used by Par.Labl to construct the corresponding implicit declarations.\n@@ -1260,6 +1265,7 @@ begin\n          SIS_Entry_Active := False;\n          Last_Resync_Point := No_Location;\n \n+         Goto_List  := New_Elmt_List;\n          Label_List := New_Elmt_List;\n \n          --  If in multiple unit per file mode, skip past ignored unit"}, {"sha": "2127e35067ca93570a895c839464310573840e93", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 510, "deletions": 65, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -24,25 +24,26 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Characters.Handling; use Ada.Characters.Handling;\n-with Namet;     use Namet;\n-with Osint;     use Osint;\n-with Output;    use Output;\n+with Namet; use Namet;\n+with Osint; use Osint;\n+with Table;\n+\n+with System.Case_Util; use System.Case_Util;\n \n package body Prj.Attr is\n \n+   --  Data for predefined attributes and packages\n+\n    --  Names end with '#'\n \n    --  Package names are preceded by 'P'\n \n-   --  Attribute names are preceded by two letters\n-\n+   --  Attribute names are preceded by two letters:\n    --  The first letter is one of\n    --    'S' for Single\n    --    's' for Single with optional index\n    --    'L' for List\n    --    'l' for List of strings with optional indexes\n-\n    --  The second letter is one of\n    --    'V' for single variable\n    --    'A' for associative array\n@@ -182,27 +183,188 @@ package body Prj.Attr is\n \n      \"#\";\n \n+   Initialized : Boolean := False;\n+   --  A flag to avoid multiple initialization\n+\n+   ----------------\n+   -- Attributes --\n+   ----------------\n+\n+   type Attribute_Record is record\n+      Name           : Name_Id;\n+      Var_Kind       : Variable_Kind;\n+      Optional_Index : Boolean;\n+      Attr_Kind      : Attribute_Kind;\n+      Next           : Attr_Node_Id;\n+   end record;\n+   --  Data for an attribute\n+\n+   package Attrs is\n+      new Table.Table (Table_Component_Type => Attribute_Record,\n+                       Table_Index_Type     => Attr_Node_Id,\n+                       Table_Low_Bound      => First_Attribute,\n+                       Table_Initial        => Attributes_Initial,\n+                       Table_Increment      => Attributes_Increment,\n+                       Table_Name           => \"Prj.Attr.Attrs\");\n+   --  The table of the attributes\n+\n+   --------------\n+   -- Packages --\n+   --------------\n+\n+   type Package_Record is record\n+      Name            : Name_Id;\n+      Known           : Boolean := True;\n+      First_Attribute : Attr_Node_Id;\n+   end record;\n+   --  Data for a package\n+\n+   package Package_Attributes is\n+      new Table.Table (Table_Component_Type => Package_Record,\n+                       Table_Index_Type     => Pkg_Node_Id,\n+                       Table_Low_Bound      => First_Package,\n+                       Table_Initial        => Packages_Initial,\n+                       Table_Increment      => Packages_Increment,\n+                       Table_Name           => \"Prj.Attr.Packages\");\n+   --  The table of the packages\n+\n+   function Name_Id_Of (Name : String) return Name_Id;\n+   --  Returns the Name_Id for Name in lower case\n+\n+   -------------------\n+   -- Add_Attribute --\n+   -------------------\n+\n+   procedure Add_Attribute\n+     (To_Package     : Package_Node_Id;\n+      Attribute_Name : Name_Id;\n+      Attribute_Node : out Attribute_Node_Id)\n+   is\n+   begin\n+      --  Only add the attribute if the package is already defined\n+\n+      if To_Package /= Empty_Package then\n+         Attrs.Increment_Last;\n+         Attrs.Table (Attrs.Last) :=\n+           (Name              => Attribute_Name,\n+            Var_Kind          => Undefined,\n+            Optional_Index    => False,\n+            Attr_Kind         => Unknown,\n+            Next              =>\n+              Package_Attributes.Table (To_Package.Value).First_Attribute);\n+         Package_Attributes.Table (To_Package.Value).First_Attribute :=\n+           Attrs.Last;\n+         Attribute_Node := (Value => Attrs.Last);\n+      end if;\n+   end Add_Attribute;\n+\n+   -------------------------\n+   -- Add_Unknown_Package --\n+   -------------------------\n+\n+   procedure Add_Unknown_Package (Name : Name_Id; Id : out Package_Node_Id) is\n+   begin\n+      Package_Attributes.Increment_Last;\n+      Id := (Value => Package_Attributes.Last);\n+      Package_Attributes.Table (Id.Value) :=\n+        (Name => Name, Known => False, First_Attribute => Empty_Attr);\n+   end Add_Unknown_Package;\n+\n+   -----------------------\n+   -- Attribute_Kind_Of --\n+   -----------------------\n+\n+   function Attribute_Kind_Of\n+     (Attribute : Attribute_Node_Id) return Attribute_Kind\n+   is\n+   begin\n+      if Attribute = Empty_Attribute then\n+         return Unknown;\n+      else\n+         return Attrs.Table (Attribute.Value).Attr_Kind;\n+      end if;\n+   end Attribute_Kind_Of;\n+\n+   -----------------------\n+   -- Attribute_Name_Of --\n+   -----------------------\n+\n+   function Attribute_Name_Of (Attribute : Attribute_Node_Id) return Name_Id is\n+   begin\n+      if Attribute = Empty_Attribute then\n+         return No_Name;\n+      else\n+         return Attrs.Table (Attribute.Value).Name;\n+      end if;\n+   end Attribute_Name_Of;\n+\n+   --------------------------\n+   -- Attribute_Node_Id_Of --\n+   --------------------------\n+\n+   function Attribute_Node_Id_Of\n+     (Name        : Name_Id;\n+      Starting_At : Attribute_Node_Id) return Attribute_Node_Id\n+   is\n+      Id : Attr_Node_Id := Starting_At.Value;\n+   begin\n+      while Id /= Empty_Attr\n+        and then Attrs.Table (Id).Name /= Name\n+      loop\n+         Id := Attrs.Table (Id).Next;\n+      end loop;\n+\n+      return (Value => Id);\n+   end Attribute_Node_Id_Of;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n \n    procedure Initialize is\n-      Start             : Positive           := Initialization_Data'First;\n-      Finish            : Positive           := Start;\n-      Current_Package   : Package_Node_Id    := Empty_Package;\n-      Current_Attribute : Attribute_Node_Id  := Empty_Attribute;\n-      Is_An_Attribute   : Boolean            := False;\n-      Kind_1            : Variable_Kind      := Undefined;\n-      Optional_Index    : Boolean            := False;\n-      Kind_2            : Attribute_Kind     := Single;\n-      Package_Name      : Name_Id            := No_Name;\n-      Attribute_Name    : Name_Id            := No_Name;\n-      First_Attribute   : Attribute_Node_Id  := Attribute_First;\n+      Start             : Positive          := Initialization_Data'First;\n+      Finish            : Positive          := Start;\n+      Current_Package   : Pkg_Node_Id       := Empty_Pkg;\n+      Current_Attribute : Attr_Node_Id      := Empty_Attr;\n+      Is_An_Attribute   : Boolean           := False;\n+      Var_Kind          : Variable_Kind     := Undefined;\n+      Optional_Index    : Boolean           := False;\n+      Attr_Kind            : Attribute_Kind := Single;\n+      Package_Name      : Name_Id           := No_Name;\n+      Attribute_Name    : Name_Id           := No_Name;\n+      First_Attribute   : Attr_Node_Id      := Attr.First_Attribute;\n+\n+      function Attribute_Location return String;\n+      --  Returns a string depending if we are in the project level attributes\n+      --  or in the attributes of a package.\n+\n+      ------------------------\n+      -- Attribute_Location --\n+      ------------------------\n+\n+      function Attribute_Location return String is\n+      begin\n+         if Package_Name = No_Name then\n+            return \"project level attributes\";\n+\n+         else\n+            return \"attribute of package \"\"\" &\n+            Get_Name_String (Package_Name) & \"\"\"\";\n+         end if;\n+      end Attribute_Location;\n+\n+   --  Start of processing for Initialize\n \n    begin\n+      --  Don't allow Initialize action to be repeated\n+\n+      if Initialized then\n+         return;\n+      end if;\n+\n       --  Make sure the two tables are empty\n \n-      Attributes.Init;\n+      Attrs.Init;\n       Package_Attributes.Init;\n \n       while Initialization_Data (Start) /= '#' loop\n@@ -219,42 +381,41 @@ package body Prj.Attr is\n                   Finish := Finish + 1;\n                end loop;\n \n-               Name_Len := Finish - Start;\n-               Name_Buffer (1 .. Name_Len) :=\n-                 To_Lower (Initialization_Data (Start .. Finish - 1));\n-               Package_Name := Name_Find;\n+               Package_Name :=\n+                 Name_Id_Of (Initialization_Data (Start .. Finish - 1));\n \n-               for Index in Package_First .. Package_Attributes.Last loop\n+               for Index in First_Package .. Package_Attributes.Last loop\n                   if Package_Name = Package_Attributes.Table (Index).Name then\n-                     Write_Line (\"Duplicate package name \"\"\" &\n-                                 Initialization_Data (Start .. Finish - 1) &\n-                                 \"\"\" in Prj.Attr body.\");\n-                     raise Program_Error;\n+                     Fail (\"duplicate name \"\"\",\n+                           Initialization_Data (Start .. Finish - 1),\n+                           \"\"\" in predefined packages.\");\n                   end if;\n                end loop;\n \n                Is_An_Attribute := False;\n-               Current_Attribute := Empty_Attribute;\n+               Current_Attribute := Empty_Attr;\n                Package_Attributes.Increment_Last;\n                Current_Package := Package_Attributes.Last;\n-               Package_Attributes.Table (Current_Package).Name :=\n-                 Package_Name;\n+               Package_Attributes.Table (Current_Package) :=\n+                 (Name            => Package_Name,\n+                  Known           => True,\n+                  First_Attribute => Empty_Attr);\n                Start := Finish + 1;\n \n             when 'S' =>\n-               Kind_1         := Single;\n+               Var_Kind       := Single;\n                Optional_Index := False;\n \n             when 's' =>\n-               Kind_1         := Single;\n+               Var_Kind       := Single;\n                Optional_Index := True;\n \n             when 'L' =>\n-               Kind_1         := List;\n+               Var_Kind       := List;\n                Optional_Index := False;\n \n             when 'l' =>\n-               Kind_1         := List;\n+               Var_Kind         := List;\n                Optional_Index := True;\n \n             when others =>\n@@ -268,26 +429,26 @@ package body Prj.Attr is\n             Start := Start + 1;\n             case Initialization_Data (Start) is\n                when 'V' =>\n-                  Kind_2 := Single;\n+                  Attr_Kind := Single;\n \n                when 'A' =>\n-                  Kind_2 := Associative_Array;\n+                  Attr_Kind := Associative_Array;\n \n                when 'a' =>\n-                  Kind_2 := Case_Insensitive_Associative_Array;\n+                  Attr_Kind := Case_Insensitive_Associative_Array;\n \n                when 'b' =>\n                   if File_Names_Case_Sensitive then\n-                     Kind_2 := Associative_Array;\n+                     Attr_Kind := Associative_Array;\n                   else\n-                     Kind_2 := Case_Insensitive_Associative_Array;\n+                     Attr_Kind := Case_Insensitive_Associative_Array;\n                   end if;\n \n                when 'c' =>\n                   if File_Names_Case_Sensitive then\n-                     Kind_2 := Optional_Index_Associative_Array;\n+                     Attr_Kind := Optional_Index_Associative_Array;\n                   else\n-                     Kind_2 :=\n+                     Attr_Kind :=\n                        Optional_Index_Case_Insensitive_Associative_Array;\n                   end if;\n \n@@ -302,47 +463,331 @@ package body Prj.Attr is\n                Finish := Finish + 1;\n             end loop;\n \n-            Name_Len := Finish - Start;\n-            Name_Buffer (1 .. Name_Len) :=\n-              To_Lower (Initialization_Data (Start .. Finish - 1));\n-            Attribute_Name := Name_Find;\n-            Attributes.Increment_Last;\n+            Attribute_Name :=\n+              Name_Id_Of (Initialization_Data (Start .. Finish - 1));\n+            Attrs.Increment_Last;\n \n-            if Current_Attribute = Empty_Attribute then\n-               First_Attribute := Attributes.Last;\n+            if Current_Attribute = Empty_Attr then\n+               First_Attribute := Attrs.Last;\n \n-               if Current_Package /= Empty_Package then\n+               if Current_Package /= Empty_Pkg then\n                   Package_Attributes.Table (Current_Package).First_Attribute\n-                    := Attributes.Last;\n+                    := Attrs.Last;\n                end if;\n \n             else\n                --  Check that there are no duplicate attributes\n \n-               for Index in First_Attribute .. Attributes.Last - 1 loop\n-                  if Attribute_Name =\n-                    Attributes.Table (Index).Name then\n-                     Write_Line (\"Duplicate attribute name \"\"\" &\n-                                 Initialization_Data (Start .. Finish - 1) &\n-                                 \"\"\" in Prj.Attr body.\");\n-                     raise Program_Error;\n+               for Index in First_Attribute .. Attrs.Last - 1 loop\n+                  if Attribute_Name = Attrs.Table (Index).Name then\n+                     Fail (\"duplicate attribute \"\"\",\n+                           Initialization_Data (Start .. Finish - 1),\n+                           \"\"\" in \" & Attribute_Location);\n                   end if;\n                end loop;\n \n-               Attributes.Table (Current_Attribute).Next :=\n-                 Attributes.Last;\n+               Attrs.Table (Current_Attribute).Next :=\n+                 Attrs.Last;\n             end if;\n \n-            Current_Attribute := Attributes.Last;\n-            Attributes.Table (Current_Attribute) :=\n+            Current_Attribute := Attrs.Last;\n+            Attrs.Table (Current_Attribute) :=\n               (Name           => Attribute_Name,\n-               Kind_1         => Kind_1,\n+               Var_Kind       => Var_Kind,\n                Optional_Index => Optional_Index,\n-               Kind_2         => Kind_2,\n-               Next           => Empty_Attribute);\n+               Attr_Kind      => Attr_Kind,\n+               Next           => Empty_Attr);\n             Start := Finish + 1;\n          end if;\n       end loop;\n+\n+      Initialized := True;\n    end Initialize;\n \n+   ----------------\n+   -- Name_Id_Of --\n+   ----------------\n+\n+   function Name_Id_Of (Name : String) return Name_Id is\n+   begin\n+      Name_Len := 0;\n+      Add_Str_To_Name_Buffer (Name);\n+      To_Lower (Name_Buffer (1 .. Name_Len));\n+      return Name_Find;\n+   end Name_Id_Of;\n+\n+   --------------------\n+   -- Next_Attribute --\n+   --------------------\n+\n+   function Next_Attribute\n+     (After : Attribute_Node_Id) return Attribute_Node_Id\n+   is\n+   begin\n+      if After = Empty_Attribute then\n+         return Empty_Attribute;\n+      else\n+         return (Value => Attrs.Table (After.Value).Next);\n+      end if;\n+   end Next_Attribute;\n+\n+   -----------------------\n+   -- Optional_Index_Of --\n+   -----------------------\n+\n+   function Optional_Index_Of (Attribute : Attribute_Node_Id) return Boolean is\n+   begin\n+      if Attribute = Empty_Attribute then\n+         return False;\n+      else\n+         return Attrs.Table (Attribute.Value).Optional_Index;\n+      end if;\n+   end Optional_Index_Of;\n+\n+   ------------------------\n+   -- Package_Node_Id_Of --\n+   ------------------------\n+\n+   function Package_Node_Id_Of (Name : Name_Id) return Package_Node_Id is\n+   begin\n+      for Index in Package_Attributes.First .. Package_Attributes.Last loop\n+         if Package_Attributes.Table (Index).Name = Name then\n+            return (Value => Index);\n+         end if;\n+      end loop;\n+\n+      --  If there is no package with this name, return Empty_Package\n+\n+      return Empty_Package;\n+   end Package_Node_Id_Of;\n+\n+   ----------------------------\n+   -- Register_New_Attribute --\n+   ----------------------------\n+\n+   procedure Register_New_Attribute\n+     (Name               : String;\n+      In_Package         : Package_Node_Id;\n+      Attr_Kind          : Defined_Attribute_Kind;\n+      Var_Kind           : Defined_Variable_Kind;\n+      Index_Is_File_Name : Boolean := False;\n+      Opt_Index          : Boolean := False)\n+   is\n+      Attr_Name       : Name_Id;\n+      First_Attr      : Attr_Node_Id := Empty_Attr;\n+      Curr_Attr       : Attr_Node_Id;\n+      Real_Attr_Kind  : Attribute_Kind;\n+\n+   begin\n+      if Name'Length = 0 then\n+         Fail (\"cannot register an attribute with no name\");\n+      end if;\n+\n+      if In_Package = Empty_Package then\n+         Fail (\"attempt to add attribute \"\"\", Name,\n+               \"\"\" to an undefined package\");\n+      end if;\n+\n+      Attr_Name := Name_Id_Of (Name);\n+\n+      First_Attr :=\n+        Package_Attributes.Table (In_Package.Value).First_Attribute;\n+\n+      --  Check if attribute name is a duplicate\n+\n+      Curr_Attr := First_Attr;\n+      while Curr_Attr /= Empty_Attr loop\n+         if Attrs.Table (Curr_Attr).Name = Attr_Name then\n+            Fail (\"duplicate attribute name \"\"\", Name,\n+                  \"\"\" in package \"\"\" &\n+                  Get_Name_String\n+                    (Package_Attributes.Table (In_Package.Value).Name) &\n+                  \"\"\"\");\n+            exit;\n+         end if;\n+\n+         Curr_Attr := Attrs.Table (Curr_Attr).Next;\n+      end loop;\n+\n+      Real_Attr_Kind := Attr_Kind;\n+\n+      --  If Index_Is_File_Name, change the attribute kind if necessary\n+\n+      if Index_Is_File_Name  and then not File_Names_Case_Sensitive then\n+         case Attr_Kind is\n+            when Associative_Array =>\n+               Real_Attr_Kind := Case_Insensitive_Associative_Array;\n+\n+            when Optional_Index_Associative_Array =>\n+               Real_Attr_Kind :=\n+                 Optional_Index_Case_Insensitive_Associative_Array;\n+\n+            when others =>\n+               null;\n+         end case;\n+      end if;\n+\n+      --  Add the new attribute\n+\n+      Attrs.Increment_Last;\n+      Attrs.Table (Attrs.Last) :=\n+        (Name           => Attr_Name,\n+         Var_Kind       => Var_Kind,\n+         Optional_Index => Opt_Index,\n+         Attr_Kind      => Real_Attr_Kind,\n+         Next           => First_Attr);\n+      Package_Attributes.Table (In_Package.Value).First_Attribute :=\n+        Attrs.Last;\n+   end Register_New_Attribute;\n+\n+   --------------------------\n+   -- Register_New_Package --\n+   --------------------------\n+\n+   procedure Register_New_Package (Name : String; Id : out Package_Node_Id) is\n+      Pkg_Name   : Name_Id;\n+\n+   begin\n+      if Name'Length = 0 then\n+         Fail (\"cannot register a package with no name\");\n+      end if;\n+\n+      Pkg_Name := Name_Id_Of (Name);\n+      Package_Attributes.Increment_Last;\n+      Id := (Value => Package_Attributes.Last);\n+      Package_Attributes.Table (Package_Attributes.Last) :=\n+        (Name => Pkg_Name, Known => True, First_Attribute => Empty_Attr);\n+   end Register_New_Package;\n+\n+   procedure Register_New_Package\n+     (Name       : String;\n+      Attributes : Attribute_Data_Array)\n+   is\n+      Pkg_Name   : Name_Id;\n+      Attr_Name  : Name_Id;\n+      First_Attr : Attr_Node_Id := Empty_Attr;\n+      Curr_Attr  : Attr_Node_Id;\n+      Attr_Kind  : Attribute_Kind;\n+\n+   begin\n+      if Name'Length = 0 then\n+         Fail (\"cannot register a package with no name\");\n+      end if;\n+\n+      Pkg_Name := Name_Id_Of (Name);\n+\n+      for Index in Package_Attributes.First .. Package_Attributes.Last loop\n+         if Package_Attributes.Table (Index).Name = Pkg_Name then\n+            Fail (\"cannot register a package with a non unique name\"\"\",\n+                  Name, \"\"\"\");\n+            exit;\n+         end if;\n+      end loop;\n+\n+      for Index in Attributes'Range loop\n+         Attr_Name := Name_Id_Of (Attributes (Index).Name);\n+\n+         Curr_Attr := First_Attr;\n+         while Curr_Attr /= Empty_Attr loop\n+            if Attrs.Table (Curr_Attr).Name = Attr_Name then\n+               Fail (\"duplicate attribute name \"\"\", Attributes (Index).Name,\n+                     \"\"\" in new package \"\"\" & Name & \"\"\"\");\n+               exit;\n+            end if;\n+\n+            Curr_Attr := Attrs.Table (Curr_Attr).Next;\n+         end loop;\n+\n+         Attr_Kind := Attributes (Index).Attr_Kind;\n+\n+         if Attributes (Index).Index_Is_File_Name\n+           and then not File_Names_Case_Sensitive\n+         then\n+            case Attr_Kind is\n+               when Associative_Array =>\n+                  Attr_Kind := Case_Insensitive_Associative_Array;\n+\n+               when Optional_Index_Associative_Array =>\n+                  Attr_Kind :=\n+                    Optional_Index_Case_Insensitive_Associative_Array;\n+\n+               when others =>\n+                  null;\n+            end case;\n+         end if;\n+\n+         Attrs.Increment_Last;\n+         Attrs.Table (Attrs.Last) :=\n+           (Name           => Attr_Name,\n+            Var_Kind       => Attributes (Index).Var_Kind,\n+            Optional_Index => Attributes (Index).Opt_Index,\n+            Attr_Kind      => Attr_Kind,\n+            Next           => First_Attr);\n+         First_Attr := Attrs.Last;\n+      end loop;\n+\n+      Package_Attributes.Increment_Last;\n+      Package_Attributes.Table (Package_Attributes.Last) :=\n+        (Name => Pkg_Name, Known => True, First_Attribute => First_Attr);\n+   end Register_New_Package;\n+\n+   ---------------------------\n+   -- Set_Attribute_Kind_Of --\n+   ---------------------------\n+\n+   procedure Set_Attribute_Kind_Of\n+     (Attribute : Attribute_Node_Id;\n+      To        : Attribute_Kind)\n+   is\n+   begin\n+      if Attribute /= Empty_Attribute then\n+         Attrs.Table (Attribute.Value).Attr_Kind := To;\n+      end if;\n+   end Set_Attribute_Kind_Of;\n+\n+   --------------------------\n+   -- Set_Variable_Kind_Of --\n+   --------------------------\n+\n+   procedure Set_Variable_Kind_Of\n+     (Attribute : Attribute_Node_Id;\n+      To        : Variable_Kind)\n+   is\n+   begin\n+      if Attribute /= Empty_Attribute then\n+         Attrs.Table (Attribute.Value).Var_Kind := To;\n+      end if;\n+   end Set_Variable_Kind_Of;\n+\n+   ----------------------\n+   -- Variable_Kind_Of --\n+   ----------------------\n+\n+   function Variable_Kind_Of\n+     (Attribute : Attribute_Node_Id) return Variable_Kind\n+   is\n+   begin\n+      if Attribute = Empty_Attribute then\n+         return Undefined;\n+      else\n+         return Attrs.Table (Attribute.Value).Var_Kind;\n+      end if;\n+   end Variable_Kind_Of;\n+\n+   ------------------------\n+   -- First_Attribute_Of --\n+   ------------------------\n+\n+   function First_Attribute_Of\n+     (Pkg : Package_Node_Id) return Attribute_Node_Id\n+   is\n+   begin\n+      if Pkg = Empty_Package then\n+         return Empty_Attribute;\n+      else\n+         return\n+           (Value => Package_Attributes.Table (Pkg.Value).First_Attribute);\n+      end if;\n+   end First_Attribute_Of;\n+\n end Prj.Attr;"}, {"sha": "226d82440edaa96a5fa154033c757dce8738f3b2", "filename": "gcc/ada/prj-attr.ads", "status": "modified", "additions": 205, "deletions": 49, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -24,90 +24,246 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package defines allowed packages and attributes in GNAT project files\n+--  This package defines packages and attributes in GNAT project files.\n+--  There are predefined packages and attributes.\n+--  It is also possible to define new packages with their attributes.\n \n with Types; use Types;\n-with Table;\n \n package Prj.Attr is\n \n-   --  Define the allowed attributes\n+   procedure Initialize;\n+   --  Initialize the predefined project level attributes and the predefined\n+   --  packages and their attribute. This procedure should be called by\n+   --  Prj.Initialize.\n+\n+   type Attribute_Kind is\n+     (Unknown,\n+      Single,\n+      Associative_Array,\n+      Optional_Index_Associative_Array,\n+      Case_Insensitive_Associative_Array,\n+      Optional_Index_Case_Insensitive_Associative_Array);\n+   --  Characteristics of an attribute. Optional_Index indicates that there\n+   --  may be an optional index in the index of the associative array, as in\n+   --     for Switches (\"files.ada\" at 2) use ...\n+\n+   subtype Defined_Attribute_Kind is Attribute_Kind\n+     range Single .. Optional_Index_Case_Insensitive_Associative_Array;\n+   --  Subset of Attribute_Kinds that may be used for the attributes that is\n+   --  used when defining a new package.\n+\n+   Max_Attribute_Name_Length : constant := 64;\n+   --  The maximum length of attribute names\n+\n+   subtype Attribute_Name_Length is\n+     Positive range 1 .. Max_Attribute_Name_Length;\n+\n+   type Attribute_Data (Name_Length : Attribute_Name_Length := 1) is record\n+      Name : String (1 .. Name_Length);\n+      --  The name of the attribute\n+\n+      Attr_Kind  : Defined_Attribute_Kind;\n+      --  The type of the attribute\n+\n+      Index_Is_File_Name : Boolean;\n+      --  For associative arrays, indicate if the index is a file name, so\n+      --  that the attribute kind may be modified depending on the case\n+      --  sensitivity of file names. This is only taken into account when\n+      --  Attr_Kind is Associative_Array or Optional_Index_Associative_Array.\n+\n+      Opt_Index : Boolean;\n+      --  True if there may be an optional index in the value of the index,\n+      --  as in:\n+      --    \"file.ada\" at 2\n+      --    (\"main.adb\", \"file.ada\" at 1)\n+\n+      Var_Kind : Defined_Variable_Kind;\n+      --  The attribute value kind: single or list\n+\n+   end record;\n+   --  Name and characteristics of an attribute in a package registered\n+   --  explicitly with Register_New_Package (see below).\n+\n+   type Attribute_Data_Array is array (Positive range <>) of Attribute_Data;\n+\n+   procedure Register_New_Package\n+     (Name       : String;\n+      Attributes : Attribute_Data_Array);\n+   --  Add a new package with its attributes.\n+   --  This procedure can only be called after Initialize, but before any\n+   --  other call to a service of the Project Managers.\n+   --  The name of the package must be unique. The names of the attributes\n+   --  must be different.\n+\n+   --  The following declarations are only for the Project Manager, that is\n+   --  the packages of the Prj or MLib hierarchies.\n+\n+   ----------------\n+   -- Attributes --\n+   ----------------\n+\n+   type Attribute_Node_Id is private;\n+   --  The type to refers to an attribute, self-initialized\n+\n+   Empty_Attribute : constant Attribute_Node_Id;\n+   --  Indicates no attribute. Default value of Attribute_Node_Id objects.\n+\n+   Attribute_First : constant Attribute_Node_Id;\n+   --  First attribute node id of project level attributes\n+\n+   function Attribute_Node_Id_Of\n+     (Name        : Name_Id;\n+      Starting_At : Attribute_Node_Id) return Attribute_Node_Id;\n+   --  Returns the node id of an attribute at the project level or in\n+   --  a package. Starting_At indicates the first known attribute node where\n+   --  to start the search. Returns Empty_Attribute if the attribute cannot\n+   --  be found.\n+\n+   function Attribute_Kind_Of\n+     (Attribute : Attribute_Node_Id) return Attribute_Kind;\n+   --  Returns the attribute kind of a known attribute. Returns Unknown if\n+   --  Attribute is Empty_Attribute.\n+\n+   procedure Set_Attribute_Kind_Of\n+     (Attribute : Attribute_Node_Id;\n+      To        : Attribute_Kind);\n+   --  Set the attribute kind of a known attribute. Does nothing if\n+   --  Attribute is Empty_Attribute.\n+\n+   function Attribute_Name_Of (Attribute : Attribute_Node_Id) return Name_Id;\n+   --  Returns the name of a known attribute. Returns No_Name if Attribute is\n+   --  Empty_Attribute.\n \n-   --  All these declarations are uncommented, they all need comments ???\n+   function Variable_Kind_Of\n+     (Attribute : Attribute_Node_Id) return Variable_Kind;\n+   --  Returns the variable kind of a known attribute. Returns Undefined if\n+   --  Attribute is Empty_Attribute.\n+\n+   procedure Set_Variable_Kind_Of\n+     (Attribute : Attribute_Node_Id;\n+      To        : Variable_Kind);\n+   --  Set the variable kind of a known attribute. Does nothing if Attribute is\n+   --  Empty_Attribute.\n+\n+   function Optional_Index_Of (Attribute : Attribute_Node_Id) return Boolean;\n+   --  Returns True if Attribute is a known attribute and may have an\n+   --  optional index. Returns False otherwise.\n+\n+   function Next_Attribute\n+     (After : Attribute_Node_Id) return Attribute_Node_Id;\n+   --  Returns the attribute that follow After in the list of project level\n+   --  attributes or the list of attributes in a package.\n+   --  Returns Empty_Attribute if After is either Empty_Attribute or is the\n+   --  last of the list.\n+\n+   --------------\n+   -- Packages --\n+   --------------\n+\n+   type Package_Node_Id is private;\n+   --  Type to refer to a package, self initialized\n+\n+   Empty_Package : constant Package_Node_Id;\n+   --  Default value of Package_Node_Id objects\n+\n+   procedure Register_New_Package (Name : String; Id : out Package_Node_Id);\n+   --  Add a new package. Fails if the package has a duplicate name.\n+   --  Initially, the new package has no attributes. Id may be used to add\n+   --  attributes using procedure Register_New_Attribute below.\n+\n+   procedure Register_New_Attribute\n+     (Name               : String;\n+      In_Package         : Package_Node_Id;\n+      Attr_Kind          : Defined_Attribute_Kind;\n+      Var_Kind           : Defined_Variable_Kind;\n+      Index_Is_File_Name : Boolean := False;\n+      Opt_Index          : Boolean := False);\n+   --  Add a new attribute to registered package In_Package. Fails if the\n+   --  attribute has a duplicate name. See definition of type Attribute_Data\n+   --  above for the meaning of parameters Attr_Kind, Var_Kind,\n+   --  Index_Is_File_Name and Opt_Index.\n+\n+   function Package_Node_Id_Of (Name : Name_Id) return Package_Node_Id;\n+   --  Returns the package node id of the package with name Name. Returns\n+   --  Empty_Package if there is no package with this name.\n+\n+   procedure Add_Unknown_Package (Name : Name_Id; Id : out Package_Node_Id);\n+   --  Add a new package. The Name cannot be the name of a predefined or\n+   --  already registered package.\n+\n+   function First_Attribute_Of\n+     (Pkg : Package_Node_Id) return Attribute_Node_Id;\n+   --  Returns the first attribute in the list of attributes of package Pkg.\n+   --  Returns Empty_Attribute if Pkg is Empty_Package.\n+\n+   procedure Add_Attribute\n+     (To_Package     : Package_Node_Id;\n+      Attribute_Name : Name_Id;\n+      Attribute_Node : out Attribute_Node_Id);\n+   --  Add an attribute to the list for package To_Package. Attribute_Name\n+   --  cannot be the name of an existing attribute of the package.\n+   --  Does nothing if To_Package is Empty_Package.\n+\n+private\n+   ----------------\n+   -- Attributes --\n+   ----------------\n \n    Attributes_Initial   : constant := 50;\n    Attributes_Increment : constant := 50;\n \n    Attribute_Node_Low_Bound  : constant := 0;\n    Attribute_Node_High_Bound : constant := 099_999_999;\n \n-   type Attribute_Node_Id is\n+   type Attr_Node_Id is\n      range Attribute_Node_Low_Bound .. Attribute_Node_High_Bound;\n+   --  Index type for table Attrs in the body\n \n-   First_Attribute_Node_Id : constant Attribute_Node_Id :=\n-                               Attribute_Node_Low_Bound + 1;\n+   type Attribute_Node_Id is record\n+      Value : Attr_Node_Id := Attribute_Node_Low_Bound;\n+   end record;\n+   --  Full declaration of self-initialized private type\n \n-   Empty_Attribute : constant Attribute_Node_Id :=\n-                       Attribute_Node_Low_Bound;\n+   Empty_Attr : constant Attr_Node_Id := Attribute_Node_Low_Bound;\n \n-   type Attribute_Kind is\n-     (Single,\n-      Associative_Array,\n-      Optional_Index_Associative_Array,\n-      Case_Insensitive_Associative_Array,\n-      Optional_Index_Case_Insensitive_Associative_Array);\n+   Empty_Attribute : constant Attribute_Node_Id := (Value => Empty_Attr);\n \n-   type Attribute_Record is record\n-      Name           : Name_Id;\n-      Kind_1         : Variable_Kind;\n-      Optional_Index : Boolean;\n-      Kind_2         : Attribute_Kind;\n-      Next           : Attribute_Node_Id;\n-   end record;\n+   First_Attribute : constant Attr_Node_Id := Attribute_Node_Low_Bound + 1;\n \n-   package Attributes is\n-      new Table.Table (Table_Component_Type => Attribute_Record,\n-                       Table_Index_Type     => Attribute_Node_Id,\n-                       Table_Low_Bound      => First_Attribute_Node_Id,\n-                       Table_Initial        => Attributes_Initial,\n-                       Table_Increment      => Attributes_Increment,\n-                       Table_Name           => \"Prj.Attr.Attributes\");\n+   First_Attribute_Node_Id : constant Attribute_Node_Id :=\n+                               (Value => First_Attribute);\n \n    Attribute_First : constant Attribute_Node_Id := First_Attribute_Node_Id;\n \n-   --  Define the allowed packages\n+   --------------\n+   -- Packages --\n+   --------------\n \n    Packages_Initial   : constant := 10;\n    Packages_Increment : constant := 50;\n \n    Package_Node_Low_Bound  : constant := 0;\n    Package_Node_High_Bound : constant := 099_999_999;\n \n-   type Package_Node_Id is\n+   type Pkg_Node_Id is\n      range Package_Node_Low_Bound .. Package_Node_High_Bound;\n+   --  Index type for table Package_Attributes in the body\n \n-   First_Package_Node_Id : constant Package_Node_Id :=\n-                             Package_Node_Low_Bound + 1;\n+   type Package_Node_Id is record\n+      Value : Pkg_Node_Id := Package_Node_Low_Bound;\n+   end record;\n+   --  Full declaration of self-initialized private type\n \n-   Empty_Package : constant Package_Node_Id := Package_Node_Low_Bound;\n+   Empty_Pkg : constant Pkg_Node_Id := Package_Node_Low_Bound;\n \n-   type Package_Record is record\n-      Name            : Name_Id;\n-      First_Attribute : Attribute_Node_Id;\n-   end record;\n+   Empty_Package : constant Package_Node_Id := (Value => Empty_Pkg);\n \n-   package Package_Attributes is\n-      new Table.Table (Table_Component_Type => Package_Record,\n-                       Table_Index_Type     => Package_Node_Id,\n-                       Table_Low_Bound      => First_Package_Node_Id,\n-                       Table_Initial        => Packages_Initial,\n-                       Table_Increment      => Packages_Increment,\n-                       Table_Name           => \"Prj.Attr.Packages\");\n+   First_Package : constant Pkg_Node_Id := Package_Node_Low_Bound + 1;\n \n-   Package_First : constant Package_Node_Id := First_Package_Node_Id;\n+   First_Package_Node_Id  : constant Package_Node_Id :=\n+                              (Value => First_Package);\n \n-   procedure Initialize;\n-   --  Initialize the two tables above (Attributes and Package_Attributes).\n-   --  This procedure should be called by Prj.Initialize.\n+   Package_First : constant Package_Node_Id := First_Package_Node_Id;\n \n end Prj.Attr;"}, {"sha": "8a9ebaaf90a69c36272d53e368996416da1855d7", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 97, "deletions": 73, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -124,6 +124,8 @@ package body Prj.Dect is\n       Full_Associative_Array : Boolean           := False;\n       Attribute_Name         : Name_Id           := No_Name;\n       Optional_Index         : Boolean           := False;\n+      Pkg_Id                 : Package_Node_Id   := Empty_Package;\n+      Warning                : Boolean           := False;\n \n    begin\n       Attribute := Default_Project_Node (Of_Kind => N_Attribute_Declaration);\n@@ -150,27 +152,28 @@ package body Prj.Dect is\n \n          --  Find the attribute\n \n-         while Current_Attribute /= Empty_Attribute\n-           and then\n-             Attributes.Table (Current_Attribute).Name /= Token_Name\n-         loop\n-            Current_Attribute := Attributes.Table (Current_Attribute).Next;\n-         end loop;\n+         Current_Attribute :=\n+           Attribute_Node_Id_Of (Token_Name, First_Attribute);\n \n-         --  If not a valid attribute name, issue an error, or a warning\n-         --  if inside a package that does not need to be checked.\n+         --  If the attribute cannot be found, create the attribute if inside\n+         --  an unknown package.\n \n          if Current_Attribute = Empty_Attribute then\n-            declare\n-               Message : constant String :=\n-                 \"undefined attribute \"\"\" &\n-                 Get_Name_String (Name_Of (Attribute)) & '\"';\n+            if Current_Package /= Empty_Node\n+              and then Expression_Kind_Of (Current_Package) = Ignored\n+            then\n+               Pkg_Id := Package_Id_Of (Current_Package);\n+               Add_Attribute (Pkg_Id, Token_Name, Current_Attribute);\n+               Error_Msg_Name_1 := Token_Name;\n+               Error_Msg (\"?unknown attribute {\", Token_Ptr);\n \n-               Warning : Boolean :=\n-                 Current_Package /= Empty_Node\n-                 and then Current_Packages_To_Check /= All_Packages;\n+            else\n+               --  If not a valid attribute name, issue an error, or a warning\n+               --  if inside a package that does not need to be checked.\n+\n+               Warning := Current_Package /= Empty_Node and then\n+                          Current_Packages_To_Check /= All_Packages;\n \n-            begin\n                if Warning then\n \n                   --  Check that we are not in a package to check\n@@ -187,17 +190,19 @@ package body Prj.Dect is\n                   end loop;\n                end if;\n \n+               Error_Msg_Name_1 := Token_Name;\n+\n                if Warning then\n-                  Error_Msg ('?' & Message, Token_Ptr);\n+                  Error_Msg (\"?undefined attribute {\", Token_Ptr);\n \n                else\n-                  Error_Msg (Message, Token_Ptr);\n+                  Error_Msg (\"undefined attribute {\", Token_Ptr);\n                end if;\n-            end;\n+            end if;\n \n          --  Set, if appropriate the index case insensitivity flag\n \n-         elsif Attributes.Table (Current_Attribute).Kind_2 in\n+         elsif Attribute_Kind_Of (Current_Attribute) in\n                  Case_Insensitive_Associative_Array ..\n                  Optional_Index_Case_Insensitive_Associative_Array\n          then\n@@ -209,7 +214,10 @@ package body Prj.Dect is\n \n       --  Change obsolete names of attributes to the new names\n \n-      case Name_Of (Attribute) is\n+      if Current_Package /= Empty_Node\n+        and then Expression_Kind_Of (Current_Package) /= Ignored\n+      then\n+         case Name_Of (Attribute) is\n          when Snames.Name_Specification =>\n             Set_Name_Of (Attribute, To => Snames.Name_Spec);\n \n@@ -224,23 +232,28 @@ package body Prj.Dect is\n \n          when others =>\n             null;\n-      end case;\n+         end case;\n+      end if;\n \n       --  Associative array attributes\n \n       if Token = Tok_Left_Paren then\n \n          --  If the attribute is not an associative array attribute, report\n-         --  an error.\n+         --  an error. If this information is still unknown, set the kind\n+         --  to Associative_Array.\n \n          if Current_Attribute /= Empty_Attribute\n-           and then Attributes.Table (Current_Attribute).Kind_2 = Single\n+           and then Attribute_Kind_Of (Current_Attribute) = Single\n          then\n             Error_Msg (\"the attribute \"\"\" &\n                        Get_Name_String\n-                          (Attributes.Table (Current_Attribute).Name) &\n+                          (Attribute_Name_Of (Current_Attribute)) &\n                        \"\"\" cannot be an associative array\",\n                        Location_Of (Attribute));\n+\n+         elsif Attribute_Kind_Of (Current_Attribute) = Unknown then\n+            Set_Attribute_Kind_Of (Current_Attribute, To => Associative_Array);\n          end if;\n \n          Scan; --  past the left parenthesis\n@@ -251,7 +264,7 @@ package body Prj.Dect is\n             Scan; --  past the literal string index\n \n             if Token = Tok_At then\n-               case Attributes.Table (Current_Attribute).Kind_2 is\n+               case Attribute_Kind_Of (Current_Attribute) is\n                   when Optional_Index_Associative_Array |\n                        Optional_Index_Case_Insensitive_Associative_Array =>\n                      Scan;\n@@ -299,18 +312,23 @@ package body Prj.Dect is\n \n          if Current_Attribute /= Empty_Attribute\n            and then\n-             Attributes.Table (Current_Attribute).Kind_2 /= Single\n+             Attribute_Kind_Of (Current_Attribute) /= Single\n          then\n-            Full_Associative_Array := True;\n+            if Attribute_Kind_Of (Current_Attribute) = Unknown then\n+               Set_Attribute_Kind_Of (Current_Attribute, To => Single);\n+\n+            else\n+               Full_Associative_Array := True;\n+            end if;\n          end if;\n       end if;\n \n       --  Set the expression kind of the attribute\n \n       if Current_Attribute /= Empty_Attribute then\n          Set_Expression_Kind_Of\n-           (Attribute, To => Attributes.Table (Current_Attribute).Kind_1);\n-         Optional_Index := Attributes.Table (Current_Attribute).Optional_Index;\n+           (Attribute, To => Variable_Kind_Of (Current_Attribute));\n+         Optional_Index := Optional_Index_Of (Current_Attribute);\n       end if;\n \n       Expect (Tok_Use, \"USE\");\n@@ -488,15 +506,22 @@ package body Prj.Dect is\n \n                if Current_Attribute /= Empty_Attribute\n                  and then Expression /= Empty_Node\n-                 and then Attributes.Table (Current_Attribute).Kind_1 /=\n+                 and then Variable_Kind_Of (Current_Attribute) /=\n                  Expression_Kind_Of (Expression)\n                then\n-                  Error_Msg\n-                    (\"wrong expression kind for attribute \"\"\" &\n-                     Get_Name_String\n-                       (Attributes.Table (Current_Attribute).Name) &\n-                     \"\"\"\",\n-                     Expression_Location);\n+                  if  Variable_Kind_Of (Current_Attribute) = Undefined then\n+                     Set_Variable_Kind_Of\n+                       (Current_Attribute,\n+                        To => Expression_Kind_Of (Expression));\n+\n+                  else\n+                     Error_Msg\n+                       (\"wrong expression kind for attribute \"\"\" &\n+                        Get_Name_String\n+                          (Attribute_Name_Of (Current_Attribute)) &\n+                        \"\"\"\",\n+                        Expression_Location);\n+                  end if;\n                end if;\n             end;\n          end if;\n@@ -858,57 +883,56 @@ package body Prj.Dect is\n \n          Set_Name_Of (Package_Declaration, To => Token_Name);\n \n-         for Index in Package_Attributes.First .. Package_Attributes.Last loop\n-            if Token_Name = Package_Attributes.Table (Index).Name then\n-               First_Attribute :=\n-                 Package_Attributes.Table (Index).First_Attribute;\n-               Current_Package := Index;\n-               exit;\n-            end if;\n-         end loop;\n+         Current_Package := Package_Node_Id_Of (Token_Name);\n \n-         if Current_Package  = Empty_Package then\n+         if Current_Package  /= Empty_Package then\n+            First_Attribute := First_Attribute_Of (Current_Package);\n+\n+         else\n             Error_Msg (\"?\"\"\" &\n                        Get_Name_String (Name_Of (Package_Declaration)) &\n-                       \"\"\" is not an allowed package name\",\n+                       \"\"\" is not a known package name\",\n                        Token_Ptr);\n \n             --  Set the package declaration to \"ignored\" so that it is not\n             --  processed by Prj.Proc.Process.\n \n             Set_Expression_Kind_Of (Package_Declaration, Ignored);\n \n-         else\n-            Set_Package_Id_Of (Package_Declaration, To => Current_Package);\n+            --  Add the unknown package in the list of packages\n \n-            declare\n-               Current : Project_Node_Id := First_Package_Of (Current_Project);\n+            Add_Unknown_Package (Token_Name, Current_Package);\n+         end if;\n \n-            begin\n-               while Current /= Empty_Node\n-                 and then Name_Of (Current) /= Token_Name\n-               loop\n-                  Current := Next_Package_In_Project (Current);\n-               end loop;\n+         Set_Package_Id_Of (Package_Declaration, To => Current_Package);\n \n-               if Current /= Empty_Node then\n-                  Error_Msg\n-                    (\"package \"\"\" &\n-                     Get_Name_String (Name_Of (Package_Declaration)) &\n-                     \"\"\" is declared twice in the same project\",\n-                     Token_Ptr);\n+         declare\n+            Current : Project_Node_Id := First_Package_Of (Current_Project);\n \n-               else\n-                  --  Add the package to the project list\n+         begin\n+            while Current /= Empty_Node\n+              and then Name_Of (Current) /= Token_Name\n+            loop\n+               Current := Next_Package_In_Project (Current);\n+            end loop;\n \n-                  Set_Next_Package_In_Project\n-                    (Package_Declaration,\n-                     To => First_Package_Of (Current_Project));\n-                  Set_First_Package_Of\n-                    (Current_Project, To => Package_Declaration);\n-               end if;\n-            end;\n-         end if;\n+            if Current /= Empty_Node then\n+               Error_Msg\n+                 (\"package \"\"\" &\n+                  Get_Name_String (Name_Of (Package_Declaration)) &\n+                  \"\"\" is declared twice in the same project\",\n+                  Token_Ptr);\n+\n+            else\n+               --  Add the package to the project list\n+\n+               Set_Next_Package_In_Project\n+                 (Package_Declaration,\n+                  To => First_Package_Of (Current_Project));\n+               Set_First_Package_Of\n+                 (Current_Project, To => Package_Declaration);\n+            end if;\n+         end;\n \n          --  Scan past the package name\n "}, {"sha": "671b3156835913289dc83f141c0a2350b7b57517", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 101, "deletions": 98, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -664,6 +664,107 @@ package body Prj.Makr is\n          Output_Name (1 .. Path_Last) := To_Lower (Path_Name (1 .. Path_Last));\n          Output_Name_Last := Path_Last - Project_File_Extension'Length;\n \n+         --  If there is already a project file with the specified name, parse\n+         --  it to get the components that are not automatically generated.\n+\n+         if Is_Regular_File (Output_Name (1 .. Path_Last)) then\n+            if Opt.Verbose_Mode then\n+               Output.Write_Str (\"Parsing already existing project file \"\"\");\n+               Output.Write_Str (Output_Name (1 .. Output_Name_Last));\n+               Output.Write_Line (\"\"\"\");\n+            end if;\n+\n+            Part.Parse\n+              (Project                => Project_Node,\n+               Project_File_Name      => Output_Name (1 .. Output_Name_Last),\n+               Always_Errout_Finalize => False);\n+\n+            --  Fail if parsing was not successful\n+\n+            if Project_Node = Empty_Node then\n+               Fail (\"parsing of existing project file failed\");\n+\n+            else\n+               --  If parsing was successful, remove the components that are\n+               --  automatically generated, if any, so that they will be\n+               --  unconditionally added later.\n+\n+               --  Remove the with clause for the naming project file\n+\n+               declare\n+                  With_Clause : Project_Node_Id :=\n+                                  First_With_Clause_Of (Project_Node);\n+                  Previous    : Project_Node_Id := Empty_Node;\n+\n+               begin\n+                  while With_Clause /= Empty_Node loop\n+                     if Tree.Name_Of (With_Clause) = Project_Naming_Id then\n+                        if Previous = Empty_Node then\n+                           Set_First_With_Clause_Of\n+                             (Project_Node,\n+                              To => Next_With_Clause_Of (With_Clause));\n+                        else\n+                           Set_Next_With_Clause_Of\n+                             (Previous,\n+                              To => Next_With_Clause_Of (With_Clause));\n+                        end if;\n+\n+                        exit;\n+                     end if;\n+\n+                     Previous := With_Clause;\n+                     With_Clause := Next_With_Clause_Of (With_Clause);\n+                  end loop;\n+               end;\n+\n+               --  Remove attribute declarations of Source_Files,\n+               --  Source_List_File, Source_Dirs, and the declaration of\n+               --  package Naming, if they exist.\n+\n+               declare\n+                  Declaration  : Project_Node_Id :=\n+                                   First_Declarative_Item_Of\n+                                     (Project_Declaration_Of\n+                                       (Project_Node));\n+                  Previous     : Project_Node_Id := Empty_Node;\n+                  Current_Node : Project_Node_Id := Empty_Node;\n+\n+               begin\n+                  while Declaration /= Empty_Node loop\n+                     Current_Node := Current_Item_Node (Declaration);\n+\n+                     if (Kind_Of (Current_Node) = N_Attribute_Declaration\n+                           and then\n+                            (Tree.Name_Of (Current_Node) = Name_Source_Files\n+                               or else Tree.Name_Of (Current_Node) =\n+                                                 Name_Source_List_File\n+                               or else Tree.Name_Of (Current_Node) =\n+                                                 Name_Source_Dirs))\n+                       or else\n+                       (Kind_Of (Current_Node) = N_Package_Declaration\n+                          and then Tree.Name_Of (Current_Node) = Name_Naming)\n+                     then\n+                        if Previous = Empty_Node then\n+                           Set_First_Declarative_Item_Of\n+                             (Project_Declaration_Of (Project_Node),\n+                              To => Next_Declarative_Item (Declaration));\n+\n+                        else\n+                           Set_Next_Declarative_Item\n+                             (Previous,\n+                              To => Next_Declarative_Item (Declaration));\n+                        end if;\n+\n+                     else\n+                        Previous := Declaration;\n+                     end if;\n+\n+                     Declaration := Next_Declarative_Item (Declaration);\n+                  end loop;\n+               end;\n+            end if;\n+         end if;\n+\n          if Directory_Last /= 0 then\n             Output_Name (1 .. Output_Name_Last - Directory_Last) :=\n               Output_Name (Directory_Last + 1 .. Output_Name_Last);\n@@ -833,104 +934,6 @@ package body Prj.Makr is\n             Output.Write_Line (\"\"\"\");\n          end if;\n \n-         --  If there is already a project file with the specified name,\n-         --  parse it to get the components that are not automatically\n-         --  generated.\n-\n-         if Is_Regular_File (Output_Name (1 .. Output_Name_Last)) then\n-            if Opt.Verbose_Mode then\n-               Output.Write_Str (\"Parsing already existing project file \"\"\");\n-               Output.Write_Str (Output_Name (1 .. Output_Name_Last));\n-               Output.Write_Line (\"\"\"\");\n-            end if;\n-\n-            Part.Parse\n-              (Project                => Project_Node,\n-               Project_File_Name      => Output_Name (1 .. Output_Name_Last),\n-               Always_Errout_Finalize => False);\n-\n-            --  If parsing was successful, remove the components that are\n-            --  automatically generated, if any, so that they will be\n-            --  unconditionally added later.\n-\n-            if Project_Node /= Empty_Node then\n-\n-               --  Remove the with clause for the naming project file\n-\n-               declare\n-                  With_Clause : Project_Node_Id :=\n-                                  First_With_Clause_Of (Project_Node);\n-                  Previous    : Project_Node_Id := Empty_Node;\n-\n-               begin\n-                  while With_Clause /= Empty_Node loop\n-                     if Tree.Name_Of (With_Clause) = Project_Naming_Id then\n-                        if Previous = Empty_Node then\n-                           Set_First_With_Clause_Of\n-                             (Project_Node,\n-                              To => Next_With_Clause_Of (With_Clause));\n-                        else\n-                           Set_Next_With_Clause_Of\n-                             (Previous,\n-                              To => Next_With_Clause_Of (With_Clause));\n-                        end if;\n-\n-                        exit;\n-                     end if;\n-\n-                     Previous := With_Clause;\n-                     With_Clause := Next_With_Clause_Of (With_Clause);\n-                  end loop;\n-               end;\n-\n-               --  Remove attribute declarations of Source_Files,\n-               --  Source_List_File, Source_Dirs, and the declaration of\n-               --  package Naming, if they exist.\n-\n-               declare\n-                  Declaration  : Project_Node_Id :=\n-                                   First_Declarative_Item_Of\n-                                     (Project_Declaration_Of\n-                                       (Project_Node));\n-                  Previous     : Project_Node_Id := Empty_Node;\n-                  Current_Node : Project_Node_Id := Empty_Node;\n-\n-               begin\n-                  while Declaration /= Empty_Node loop\n-                     Current_Node := Current_Item_Node (Declaration);\n-\n-                     if (Kind_Of (Current_Node) = N_Attribute_Declaration\n-                           and then\n-                           (Tree.Name_Of (Current_Node) = Name_Source_Files\n-                             or else Tree.Name_Of (Current_Node) =\n-                                               Name_Source_List_File\n-                              or else Tree.Name_Of (Current_Node) =\n-                              Name_Source_Dirs))\n-                       or else\n-                       (Kind_Of (Current_Node) = N_Package_Declaration\n-                          and then Tree.Name_Of (Current_Node) = Name_Naming)\n-                     then\n-                        if Previous = Empty_Node then\n-                           Set_First_Declarative_Item_Of\n-                             (Project_Declaration_Of (Project_Node),\n-                              To => Next_Declarative_Item (Declaration));\n-\n-                        else\n-                           Set_Next_Declarative_Item\n-                             (Previous,\n-                              To => Next_Declarative_Item (Declaration));\n-                        end if;\n-\n-                     else\n-                        Previous := Declaration;\n-                     end if;\n-\n-                     Declaration := Next_Declarative_Item (Declaration);\n-                  end loop;\n-               end;\n-            end if;\n-         end if;\n-\n          --  If there were no already existing project file, or if the parsing\n          --  was unsuccessful, create an empty project node with the correct\n          --  name and its project declaration node."}, {"sha": "5df87a08fa30e5b104ac5b37b971e7a6e129f15c", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -155,18 +155,15 @@ package body Prj.Proc is\n       First   : Attribute_Node_Id)\n    is\n       The_Attribute  : Attribute_Node_Id := First;\n-      Attribute_Data : Attribute_Record;\n \n    begin\n       while The_Attribute /= Empty_Attribute loop\n-         Attribute_Data := Attributes.Table (The_Attribute);\n-\n-         if Attribute_Data.Kind_2 = Single then\n+         if Attribute_Kind_Of (The_Attribute) = Single then\n             declare\n                New_Attribute : Variable_Value;\n \n             begin\n-               case Attribute_Data.Kind_1 is\n+               case Variable_Kind_Of (The_Attribute) is\n \n                   --  Undefined should not happen\n \n@@ -201,13 +198,13 @@ package body Prj.Proc is\n                Variable_Elements.Increment_Last;\n                Variable_Elements.Table (Variable_Elements.Last) :=\n                  (Next  => Decl.Attributes,\n-                  Name  => Attribute_Data.Name,\n+                  Name  => Attribute_Name_Of (The_Attribute),\n                   Value => New_Attribute);\n                Decl.Attributes := Variable_Elements.Last;\n             end;\n          end if;\n \n-         The_Attribute := Attributes.Table (The_Attribute).Next;\n+         The_Attribute := Next_Attribute (After => The_Attribute);\n       end loop;\n    end Add_Attributes;\n \n@@ -1068,8 +1065,8 @@ package body Prj.Proc is\n                         Add_Attributes\n                           (Project,\n                            Packages.Table (New_Pkg).Decl,\n-                           Package_Attributes.Table\n-                             (Package_Id_Of (Current_Item)).First_Attribute);\n+                           First_Attribute_Of\n+                             (Package_Id_Of (Current_Item)));\n \n                         --  And process declarative items of the new package\n "}, {"sha": "b11124a2e38434471fa597b84985e48531c5f163", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -177,12 +177,8 @@ package body Prj.Strt is\n          --  Check if the identifier is one of the attribute identifiers in the\n          --  context (package or project level attributes).\n \n-         while Current_Attribute /= Empty_Attribute\n-           and then\n-             Attributes.Table (Current_Attribute).Name /= Token_Name\n-         loop\n-            Current_Attribute := Attributes.Table (Current_Attribute).Next;\n-         end loop;\n+         Current_Attribute :=\n+           Attribute_Node_Id_Of (Token_Name, Starting_At => First_Attribute);\n \n          --  If the identifier is not allowed, report an error\n \n@@ -201,9 +197,9 @@ package body Prj.Strt is\n             Set_Project_Node_Of (Reference, To => Current_Project);\n             Set_Package_Node_Of (Reference, To => Current_Package);\n             Set_Expression_Kind_Of\n-              (Reference, To => Attributes.Table (Current_Attribute).Kind_1);\n+              (Reference, To => Variable_Kind_Of (Current_Attribute));\n             Set_Case_Insensitive\n-              (Reference, To => Attributes.Table (Current_Attribute).Kind_2 =\n+              (Reference, To => Attribute_Kind_Of (Current_Attribute) =\n                                           Case_Insensitive_Associative_Array);\n \n             --  Scan past the attribute name\n@@ -212,7 +208,7 @@ package body Prj.Strt is\n \n             --  If the attribute is an associative array, get the index\n \n-            if Attributes.Table (Current_Attribute).Kind_2 /= Single then\n+            if Attribute_Kind_Of (Current_Attribute) /= Single then\n                Expect (Tok_Left_Paren, \"`(`\");\n \n                if Token = Tok_Left_Paren then\n@@ -651,15 +647,9 @@ package body Prj.Strt is\n \n                   --  First, look if it can be a package name\n \n-                  for Index in Package_First .. Package_Attributes.Last loop\n-                     if Package_Attributes.Table (Index).Name =\n-                                                      Names.Table (1).Name\n-                     then\n-                        First_Attribute :=\n-                          Package_Attributes.Table (Index).First_Attribute;\n-                        exit;\n-                     end if;\n-                  end loop;\n+                  First_Attribute :=\n+                    First_Attribute_Of\n+                      (Package_Node_Id_Of (Names.Table (1).Name));\n \n                   --  Now, look if it can be a project name\n \n@@ -808,8 +798,8 @@ package body Prj.Strt is\n                               --  package.\n \n                               First_Attribute :=\n-                                Package_Attributes.Table\n-                                (Package_Id_Of (The_Package)).First_Attribute;\n+                                First_Attribute_Of\n+                                  (Package_Id_Of (The_Package));\n                            end if;\n                         end if;\n                      end if;"}, {"sha": "af6482dac7670cc8a877fbfd914ec7ea6a3fd70f", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -161,7 +161,7 @@ package body Prj is\n \n    function Empty_Project return Project_Data is\n    begin\n-      Initialize;\n+      Prj.Initialize;\n       return Project_Empty;\n    end Empty_Project;\n \n@@ -415,7 +415,7 @@ package body Prj is\n \n    function Standard_Naming_Data return Naming_Data is\n    begin\n-      Initialize;\n+      Prj.Initialize;\n       return Std_Naming_Data;\n    end Standard_Naming_Data;\n "}, {"sha": "a67cb5685eb43dc2ae51278264db00cbcf54984b", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -240,6 +240,9 @@ package Prj is\n    type Variable_Kind is (Undefined, List, Single);\n    --  Different kinds of variables\n \n+   subtype Defined_Variable_Kind is Variable_Kind range List .. Single;\n+   --  The defined kinds of variables\n+\n    Ignored : constant Variable_Kind := Single;\n    --  Used to indicate that a package declaration must be ignored\n    --  while processing the project tree (unknown package name)."}, {"sha": "40175dde5efe153c41a0c988f70317048b352ddb", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -1274,6 +1274,8 @@ package Rtsfind is\n      RE_Asynchronous_Call,               -- System.Tasking\n      RE_Timed_Call,                      -- System.Tasking\n \n+     RE_Ada_Task_Control_Block,          -- System.Tasking\n+\n      RE_Task_List,                       -- System.Tasking\n \n      RE_Accept_Alternative,              -- System.Tasking\n@@ -2354,6 +2356,8 @@ package Rtsfind is\n      RE_Asynchronous_Call                => System_Tasking,\n      RE_Timed_Call                       => System_Tasking,\n \n+     RE_Ada_Task_Control_Block           => System_Tasking,\n+\n      RE_Task_List                        => System_Tasking,\n \n      RE_Accept_Alternative               => System_Tasking,"}, {"sha": "a98196ace81c2059915b65a1f64d9d7f5850e711", "filename": "gcc/ada/s-finimp.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-finimp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-finimp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -102,7 +102,7 @@ package body System.Finalization_Implementation is\n                     Object.My_Address - Object'Address;\n \n       procedure Ptr_Adjust (Ptr : in out Finalizable_Ptr);\n-      --  Substract the offset to the pointer\n+      --  Subtract the offset to the pointer\n \n       procedure Reverse_Adjust (P : Finalizable_Ptr);\n       --  Ajust the components in the reverse order in which they are stored"}, {"sha": "660f4dd0f15ca755df5bc4433bed5a85d02d9c9c", "filename": "gcc/ada/s-finimp.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-finimp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-finimp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -137,7 +137,7 @@ pragma Elaborate_Body (Finalization_Implementation);\n    --  Initialize the field My_Address to the Object'Address\n \n    procedure Adjust (Object : in out Record_Controller);\n-   --  Adjust the components and their finalization pointers by substracting\n+   --  Adjust the components and their finalization pointers by subtracting\n    --  by the offset of the target and the source addresses of the assignment.\n \n    --  Inherit Finalize from Limited_Record_Controller"}, {"sha": "bb3e04a70d7bc813b98c1add918b4aeae0e81669", "filename": "gcc/ada/s-mastop-x86.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-mastop-x86.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-mastop-x86.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-x86.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -469,7 +469,7 @@ package body System.Machine_State_Operations is\n          return To_Address (MS.eip);\n       else\n          --  When doing a call the return address is pushed to the stack.\n-         --  We want to return the call point address, so we substract\n+         --  We want to return the call point address, so we subtract\n          --  Asm_Call_Size from the return address. This value is set\n          --  to 5 as an asm call takes 5 bytes on x86 architectures.\n "}, {"sha": "12bcd655953f70b5ed8252c70b173e723e86f9b7", "filename": "gcc/ada/s-secsta.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-secsta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-secsta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-secsta.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -73,7 +73,7 @@ package System.Secondary_Stack is\n    --  to System.Null_Address.\n \n    type Mark_Id is private;\n-   --  Type used to mark the stack.\n+   --  Type used to mark the stack\n \n    function SS_Mark return Mark_Id;\n    --  Return the Mark corresponding to the current state of the stack"}, {"sha": "be0c6619ac70bb6858e3ad0f2aa124192f599ade", "filename": "gcc/ada/s-tarest.adb", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -443,9 +443,8 @@ package body System.Tasking.Restricted.Stages is\n       Elaborated    : Access_Boolean;\n       Chain         : in out Activation_Chain;\n       Task_Image    : String;\n-      Created_Task  : out Task_Id)\n+      Created_Task  : Task_Id)\n    is\n-      T             : Task_Id;\n       Self_ID       : constant Task_Id := STPO.Self;\n       Base_Priority : System.Any_Priority;\n       Success       : Boolean;\n@@ -457,8 +456,6 @@ package body System.Tasking.Restricted.Stages is\n          Base_Priority := System.Any_Priority (Priority);\n       end if;\n \n-      T := New_ATCB (0);\n-\n       if Single_Lock then\n          Lock_RTS;\n       end if;\n@@ -470,7 +467,7 @@ package body System.Tasking.Restricted.Stages is\n \n       Initialize_ATCB\n         (Self_ID, State, Discriminants, Self_ID, Elaborated, Base_Priority,\n-         Task_Info, Size, T, Success);\n+         Task_Info, Size, Created_Task, Success);\n \n       --  If we do our job right then there should never be any failures,\n       --  which was probably said about the Titanic; so just to be safe,\n@@ -486,11 +483,12 @@ package body System.Tasking.Restricted.Stages is\n          raise Program_Error;\n       end if;\n \n-      T.Entry_Calls (1).Self := T;\n+      Created_Task.Entry_Calls (1).Self := Created_Task;\n \n-      T.Common.Task_Image_Len :=\n-        Integer'Min (T.Common.Task_Image'Length, Task_Image'Length);\n-      T.Common.Task_Image (1 .. T.Common.Task_Image_Len) := Task_Image;\n+      Created_Task.Common.Task_Image_Len :=\n+        Integer'Min (Created_Task.Common.Task_Image'Length, Task_Image'Length);\n+      Created_Task.Common.Task_Image\n+        (1 .. Created_Task.Common.Task_Image_Len) := Task_Image;\n \n       Unlock (Self_ID);\n \n@@ -501,10 +499,9 @@ package body System.Tasking.Restricted.Stages is\n       --  Create TSD as early as possible in the creation of a task, since it\n       --  may be used by the operation of Ada code within the task.\n \n-      SSL.Create_TSD (T.Common.Compiler_Data);\n-      T.Common.Activation_Link := Chain.T_ID;\n-      Chain.T_ID   := T;\n-      Created_Task := T;\n+      SSL.Create_TSD (Created_Task.Common.Compiler_Data);\n+      Created_Task.Common.Activation_Link := Chain.T_ID;\n+      Chain.T_ID := Created_Task;\n    end Create_Restricted_Task;\n \n    ---------------------------"}, {"sha": "b8ec7c73bdc13c5e6f05627db37848300cde3fe1", "filename": "gcc/ada/s-tarest.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-tarest.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-tarest.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -75,9 +75,12 @@ package System.Tasking.Restricted.Stages is\n    --   task type t (discr : integer);\n    --   tE : aliased boolean := false;\n    --   tZ : size_type := unspecified_size;\n+\n    --   type tV (discr : integer) is limited record\n    --      _task_id : task_id;\n+   --      _atcb : aliased system__tasking__ada_task_control_block (0);\n    --   end record;\n+\n    --   procedure tB (_task : access tV);\n    --   freeze tV [\n    --      procedure tVIP (_init : in out tV; _master : master_id;\n@@ -86,26 +89,28 @@ package System.Tasking.Restricted.Stages is\n    --      begin\n    --         _init.discr := discr;\n    --         _init._task_id := null;\n+   --         system__tasking__ada_task_control_blockIP (_init._atcb, 0);\n+   --         _init._task_id := _init._atcb'unchecked_access;\n    --         create_restricted_task (unspecified_priority, tZ,\n    --           unspecified_task_info, task_procedure_access!(tB'address),\n    --           _init'address, tE'unchecked_access, _chain, _task_name, _init.\n    --           _task_id);\n    --         return;\n    --      end tVIP;\n-   --   ]\n \n    --   _chain : aliased activation_chain;\n    --   activation_chainIP (_chain);\n \n    --   procedure tB (_task : access tV) is\n    --      discr : integer renames _task.discr;\n-   --\n+\n    --      procedure _clean is\n    --      begin\n    --         complete_restricted_task;\n    --         finalize_list (F14b);\n    --         return;\n    --      end _clean;\n+\n    --   begin\n    --      ...declarations...\n    --      complete_restricted_activation;\n@@ -131,7 +136,7 @@ package System.Tasking.Restricted.Stages is\n       Elaborated    : Access_Boolean;\n       Chain         : in out Activation_Chain;\n       Task_Image    : String;\n-      Created_Task  : out Task_Id);\n+      Created_Task  : Task_Id);\n    --  Compiler interface only. Do not call from within the RTS.\n    --  This must be called to create a new task.\n    --"}, {"sha": "a79db6afb69b8cc76131e28b017d84459f759b2e", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -38,9 +38,6 @@ pragma Polling (Off);\n with System.Task_Primitives.Operations;\n --  used for Self\n \n-with Unchecked_Deallocation;\n---  To recover from failure of ATCB initialization.\n-\n with System.Storage_Elements;\n --  Needed for initializing Stack_Info.Size\n \n@@ -51,9 +48,6 @@ package body System.Tasking is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n-   procedure Free is new\n-     Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n-\n    ----------\n    -- Self --\n    ----------\n@@ -73,7 +67,7 @@ package body System.Tasking is\n       Base_Priority    : System.Any_Priority;\n       Task_Info        : System.Task_Info.Task_Info_Type;\n       Stack_Size       : System.Parameters.Size_Type;\n-      T                : in out Task_Id;\n+      T                : Task_Id;\n       Success          : out Boolean) is\n    begin\n       T.Common.State := Unactivated;\n@@ -83,7 +77,6 @@ package body System.Tasking is\n       STPO.Initialize_TCB (T, Success);\n \n       if not Success then\n-         Free (T);\n          return;\n       end if;\n "}, {"sha": "5fd2c22c4eff351f63d2f30ebb9635252095b1dc", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -960,13 +960,13 @@ package System.Tasking is\n       Base_Priority    : System.Any_Priority;\n       Task_Info        : System.Task_Info.Task_Info_Type;\n       Stack_Size       : System.Parameters.Size_Type;\n-      T                : in out Task_Id;\n+      T                : Task_Id;\n       Success          : out Boolean);\n    --  Initialize fields of a TCB and link into global TCB structures\n    --  Call this only with abort deferred and holding RTS_Lock.\n+   --  Need more documentation, mention T, and describe Success ???\n \n private\n-\n    Null_Task : constant Task_Id := null;\n \n    type Activation_Chain is record"}, {"sha": "bdd30be27f6ae1ea9db8c71fe92ed2255b6a0204", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -109,6 +109,9 @@ with System.Standard_Library;\n with System.Traces.Tasking;\n --  used for Send_Trace_Info\n \n+with Unchecked_Deallocation;\n+--  To recover from failure of ATCB initialization.\n+\n package body System.Tasking.Stages is\n \n    package STPO renames System.Task_Primitives.Operations;\n@@ -130,6 +133,9 @@ package body System.Tasking.Stages is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Free is new\n+     Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n+\n    procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_Id);\n    --  This procedure outputs the task specific message for exception\n    --  tracing purposes.\n@@ -569,6 +575,7 @@ package body System.Tasking.Stages is\n         Base_Priority, Task_Info, Size, T, Success);\n \n       if not Success then\n+         Free (T);\n          Unlock (Self_ID);\n          Unlock_RTS;\n          Initialization.Undefer_Abort_Nestable (Self_ID);"}, {"sha": "b06ab1e2919e4ab6afe99d4a8ea46b026fe15674", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -894,7 +894,7 @@ package body Sem_Case is\n \n       function Number_Of_Choices (N : Node_Id) return Nat is\n          Alt : Node_Id;\n-         --  A case statement alternative or a record variant.\n+         --  A case statement alternative or a record variant\n \n          Choice : Node_Id;\n          Count  : Nat := 0;"}, {"sha": "44d5f5974671edda481cf35aa0eb9ae8da180536", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -798,42 +798,18 @@ package body Sem_Cat is\n           K =  N_Subprogram_Renaming_Declaration)\n         and then Present (Parent_Spec (N))\n       then\n-         declare\n-            Parent_Lib_U  : constant Node_Id   := Parent_Spec (N);\n-            Parent_Kind   : constant Node_Kind :=\n-                              Nkind (Unit (Parent_Lib_U));\n-            Parent_Entity : Entity_Id;\n-\n-         begin\n-            if        Parent_Kind =  N_Package_Instantiation\n-              or else Parent_Kind =  N_Procedure_Instantiation\n-              or else Parent_Kind =  N_Function_Instantiation\n-              or else Parent_Kind =  N_Package_Renaming_Declaration\n-              or else Parent_Kind in N_Generic_Renaming_Declaration\n-            then\n-               Parent_Entity := Defining_Entity (Unit (Parent_Lib_U));\n-\n-            else\n-               Parent_Entity :=\n-                 Defining_Entity (Specification (Unit (Parent_Lib_U)));\n-            end if;\n-\n-            Check_Categorization_Dependencies (E, Parent_Entity, N, False);\n+         Check_Categorization_Dependencies (E, Scope (E), N, False);\n \n-            --  Verify that public child of an RCI library unit\n-            --  must also be an RCI library unit (RM E.2.3(15)).\n+         --  Verify that public child of an RCI library unit\n+         --  must also be an RCI library unit (RM E.2.3(15)).\n \n-            if Is_Remote_Call_Interface (Parent_Entity)\n-              and then not Private_Present (P)\n-              and then not Is_Remote_Call_Interface (E)\n-            then\n-               Error_Msg_N\n-                 (\"public child of rci unit must also be rci unit\", N);\n-               return;\n-            end if;\n-         end;\n+         if Is_Remote_Call_Interface (Scope (E))\n+           and then not Private_Present (P)\n+           and then not Is_Remote_Call_Interface (E)\n+         then\n+            Error_Msg_N (\"public child of rci unit must also be rci unit\", N);\n+         end if;\n       end if;\n-\n    end Validate_Categorization_Dependency;\n \n    --------------------------------"}, {"sha": "d913aa6f59fc2861decdc12931aa62bbafd9ba00", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -2493,8 +2493,16 @@ package body Sem_Ch10 is\n \n    function Get_Parent_Entity (Unit : Node_Id) return Entity_Id is\n    begin\n-      if Nkind (Unit) = N_Package_Instantiation then\n+      if Nkind (Unit) = N_Package_Body\n+        and then Nkind (Original_Node (Unit)) = N_Package_Instantiation\n+      then\n+         return\n+           Defining_Entity\n+             (Specification (Instance_Spec (Original_Node (Unit))));\n+\n+      elsif Nkind (Unit) = N_Package_Instantiation then\n          return Defining_Entity (Specification (Instance_Spec (Unit)));\n+\n       else\n          return Defining_Entity (Unit);\n       end if;\n@@ -2510,7 +2518,9 @@ package body Sem_Ch10 is\n    is\n       Loc    : constant Source_Ptr := Sloc (N);\n       P      : constant Node_Id    := Parent_Spec (Child_Unit);\n-      P_Unit : constant Node_Id    := Unit (P);\n+\n+      P_Unit : Node_Id    := Unit (P);\n+\n       P_Name : constant Entity_Id  := Get_Parent_Entity (P_Unit);\n       Withn  : Node_Id;\n \n@@ -2562,6 +2572,16 @@ package body Sem_Ch10 is\n    --  Start of processing for Implicit_With_On_Parent\n \n    begin\n+      --  The unit of the current compilation may be a package body\n+      --  that replaces an instance node. In this case we need the\n+      --  original instance node to construct the proper parent name.\n+\n+      if Nkind (P_Unit) = N_Package_Body\n+        and then Nkind (Original_Node (P_Unit)) = N_Package_Instantiation\n+      then\n+         P_Unit := Original_Node (P_Unit);\n+      end if;\n+\n       New_Nodes_OK := New_Nodes_OK + 1;\n       Withn := Make_With_Clause (Loc, Name => Build_Unit_Name);\n \n@@ -4318,16 +4338,26 @@ package body Sem_Ch10 is\n    procedure Remove_Parents (Lib_Unit : Node_Id) is\n       P      : Node_Id;\n       P_Name : Entity_Id;\n+      P_Spec : Node_Id := Empty;\n       E      : Entity_Id;\n       Vis    : constant Boolean :=\n                  Scope_Stack.Table (Scope_Stack.Last).Previous_Visibility;\n \n    begin\n       if Is_Child_Spec (Lib_Unit) then\n-         P := Unit (Parent_Spec (Lib_Unit));\n-         P_Name := Get_Parent_Entity (P);\n+         P_Spec := Parent_Spec (Lib_Unit);\n \n-         Remove_Context_Clauses (Parent_Spec (Lib_Unit));\n+      elsif Nkind (Lib_Unit) = N_Package_Body\n+        and then Nkind (Original_Node (Lib_Unit)) = N_Package_Instantiation\n+      then\n+         P_Spec := Parent_Spec (Original_Node (Lib_Unit));\n+      end if;\n+\n+      if Present (P_Spec) then\n+\n+         P := Unit (P_Spec);\n+         P_Name := Get_Parent_Entity (P);\n+         Remove_Context_Clauses (P_Spec);\n          End_Package_Scope (P_Name);\n          Set_Is_Immediately_Visible (P_Name, Vis);\n "}, {"sha": "11d4c014c6ae8520a4c261fb553eec982050493d", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -1238,7 +1238,7 @@ package body Sem_Ch3 is\n       --  appear in the private part of a package, for a private type that has\n       --  already been declared.\n \n-      --  In this case, the discriminants (if any) must match.\n+      --  In this case, the discriminants (if any) must match\n \n       T := Find_Type_Name (N);\n "}, {"sha": "f674ba6e005747b04abc00b2d3329a49c1085fdd", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -2990,12 +2990,8 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Slice\n \n    begin\n-      --  Analyze the prefix if not done already\n-\n-      if No (Etype (P)) then\n-         Analyze (P);\n-      end if;\n \n+      Analyze (P);\n       Analyze (D);\n \n       if Is_Overloaded (P) then"}, {"sha": "11be7c1df519a53753d0edc9eaff2b02adb2c79b", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -885,14 +885,31 @@ package body Sem_Ch7 is\n \n       Public_Child := False;\n \n-      if Present (Parent_Spec (Parent (N))) then\n-         Generate_Parent_References;\n+      declare\n+         Par       : Entity_Id;\n+         Pack_Decl : Node_Id;\n+         Par_Spec  : Node_Id;\n \n-         declare\n-            Par       : Entity_Id := Id;\n-            Pack_Decl : Node_Id;\n+      begin\n+         Par := Id;\n+         Par_Spec := Parent_Spec (Parent (N));\n+\n+         --  If the package is formal package of an enclosing generic, is is\n+         --  transformed into a local generic declaration, and compiled to make\n+         --  its spec available. We need to retrieve the original generic to\n+         --  determine whether it is a child unit, and install its parents.\n+\n+         if No (Par_Spec)\n+           and then\n+             Nkind (Original_Node (Parent (N))) = N_Formal_Package_Declaration\n+         then\n+            Par := Entity (Name (Original_Node (Parent (N))));\n+            Par_Spec := Parent_Spec (Unit_Declaration_Node (Par));\n+         end if;\n+\n+         if Present (Par_Spec) then\n+            Generate_Parent_References;\n \n-         begin\n             while Scope (Par) /= Standard_Standard\n               and then Is_Public_Child (Id, Par)\n             loop\n@@ -903,8 +920,8 @@ package body Sem_Ch7 is\n                Pack_Decl := Unit_Declaration_Node (Par);\n                Set_Use (Private_Declarations (Specification (Pack_Decl)));\n             end loop;\n-         end;\n-      end if;\n+         end if;\n+      end;\n \n       if Is_Compilation_Unit (Id) then\n          Install_Private_With_Clauses (Id);"}, {"sha": "0ce72096ca97ab425c2fac5c88a8de64d93e485a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -72,6 +72,7 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Stylesw;  use Stylesw;\n+with Table;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;\n@@ -138,6 +139,26 @@ package body Sem_Prag is\n    --  design and implementation and are intended to be fully compatible\n    --  with the use of these pragmas in the DEC Ada compiler.\n \n+   --------------------------------------------\n+   -- Checking for Duplicated External Names --\n+   --------------------------------------------\n+\n+   --  It is suspicious if two separate Export pragmas use the same external\n+   --  name. The following table is used to diagnose this situation so that\n+   --  an appropriate warning can be issued.\n+\n+   --  The Node_Id stored is for the N_String_Literal node created to\n+   --  hold the value of the external name. The Sloc of this node is\n+   --  used to cross-reference the location of the duplication.\n+\n+   package Externals is new Table.Table (\n+     Table_Component_Type => Node_Id,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => 100,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Name_Externals\");\n+\n    -------------------------------------\n    -- Local Subprograms and Variables --\n    -------------------------------------\n@@ -308,6 +329,12 @@ package body Sem_Prag is\n       procedure Check_At_Most_N_Arguments (N : Nat);\n       --  Check there are no more than N arguments present\n \n+      procedure Check_Duplicated_Export_Name (Nam : Node_Id);\n+      --  Nam is an N_String_Literal node containing the external name set\n+      --  by an Import or Export pragma (or extended Import or Export pragma).\n+      --  This procedure checks for possible duplications if this is the\n+      --  export case, and if found, issues an appropriate error message.\n+\n       procedure Check_First_Subtype (Arg : Node_Id);\n       --  Checks that Arg, whose expression is an entity name referencing\n       --  a subtype, does not reference a type that is not a first subtype.\n@@ -896,6 +923,39 @@ package body Sem_Prag is\n          end if;\n       end Check_At_Most_N_Arguments;\n \n+      ----------------------------------\n+      -- Check_Duplicated_Export_Name --\n+      ----------------------------------\n+\n+      procedure Check_Duplicated_Export_Name (Nam : Node_Id) is\n+         String_Val : constant String_Id := Strval (Nam);\n+\n+      begin\n+         --  We are only interested in the export case, and in the case of\n+         --  generics, it is the instance, not the template, that is the\n+         --  problem (the template will generate a warning in any case).\n+\n+         if not Inside_A_Generic\n+           and then (Prag_Id = Pragma_Export\n+                       or else\n+                     Prag_Id = Pragma_Export_Procedure\n+                       or else\n+                     Prag_Id = Pragma_Export_Valued_Procedure\n+                       or else\n+                     Prag_Id = Pragma_Export_Function)\n+         then\n+            for J in Externals.First .. Externals.Last loop\n+               if String_Equal (String_Val, Strval (Externals.Table (J))) then\n+                  Error_Msg_Sloc := Sloc (Externals.Table (J));\n+                  Error_Msg_N (\"external name duplicates name given#\", Nam);\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            Externals.Append (Nam);\n+         end if;\n+      end Check_Duplicated_Export_Name;\n+\n       -------------------------\n       -- Check_First_Subtype --\n       -------------------------\n@@ -3275,9 +3335,7 @@ package body Sem_Prag is\n          --  If there is no link name, just set the external name\n \n          if No (Link_Nam) then\n-            Set_Encoded_Interface_Name\n-              (Get_Base_Subprogram (Subprogram_Def),\n-               Adjust_External_Name_Case (Expr_Value_S (Ext_Nam)));\n+            Link_Nam := Adjust_External_Name_Case (Expr_Value_S (Ext_Nam));\n \n          --  For the Link_Name case, the given literal is preceded by an\n          --  asterisk, which indicates to GCC that the given name should\n@@ -3296,10 +3354,11 @@ package body Sem_Prag is\n \n             Link_Nam :=\n               Make_String_Literal (Sloc (Link_Nam), End_String);\n-\n-            Set_Encoded_Interface_Name\n-              (Get_Base_Subprogram (Subprogram_Def), Link_Nam);\n          end if;\n+\n+         Set_Encoded_Interface_Name\n+           (Get_Base_Subprogram (Subprogram_Def), Link_Nam);\n+         Check_Duplicated_Export_Name (Link_Nam);\n       end Process_Interface_Name;\n \n       -----------------------------------------\n@@ -3740,8 +3799,8 @@ package body Sem_Prag is\n \n          else\n             Set_Encoded_Interface_Name (Internal_Ent, New_Name);\n+            Check_Duplicated_Export_Name (New_Name);\n          end if;\n-\n       end Set_Extended_Import_Export_External_Name;\n \n       ------------------"}, {"sha": "e8eadd2ebe0762f718fbc2573ea539bc7267ca17", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -5093,7 +5093,8 @@ package body Sem_Util is\n                              or else\n                            (Nkind (Parent (N)) = N_Function_Call\n                              or else\n-                           Nkind (Parent (N)) = N_Parameter_Association))\n+                            Nkind (Parent (N)) = N_Parameter_Association))\n+                          and then Ekind (S) /= E_Function\n                         then\n                            Set_Etype (N, Etype (S));\n                         else\n@@ -5763,29 +5764,40 @@ package body Sem_Util is\n       then\n          return True;\n \n-      --  Record type. OK if none of the component types requires a transient\n-      --  scope. Note that we already know that this is a definite type (i.e.\n-      --  has discriminant defaults if it is a discriminated record).\n+      --  Record type\n \n       elsif Is_Record_Type (Typ) then\n-         if Has_Discriminants (Typ) then\n+\n+         --  In GCC 2, discriminated records always require a transient\n+         --  scope because the back end otherwise tries to allocate a\n+         --  variable length temporary for the particular variant.\n+\n+         if Opt.GCC_Version = 2\n+           and then Has_Discriminants (Typ)\n+         then\n             return True;\n-         end if;\n \n-         declare\n-            Comp : Entity_Id;\n-         begin\n-            Comp := First_Entity (Typ);\n-            while Present (Comp) loop\n-               if Requires_Transient_Scope (Etype (Comp)) then\n-                  return True;\n-               else\n-                  Next_Entity (Comp);\n-               end if;\n-            end loop;\n-         end;\n+         --  For GCC 3, or for a non-discriminated record in GCC 2, we are\n+         --  OK if none of the component types requires a transient scope.\n+         --  Note that we already know that this is a definite type (i.e.\n+         --  has discriminant defaults if it is a discriminated record).\n \n-         return False;\n+         else\n+            declare\n+               Comp : Entity_Id;\n+            begin\n+               Comp := First_Entity (Typ);\n+               while Present (Comp) loop\n+                  if Requires_Transient_Scope (Etype (Comp)) then\n+                     return True;\n+                  else\n+                     Next_Entity (Comp);\n+                  end if;\n+               end loop;\n+            end;\n+\n+            return False;\n+         end if;\n \n       --  String literal types never require transient scope\n "}, {"sha": "b9cd266b0de7a01254371e78902778c86fc937e2", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -359,7 +359,10 @@ package Sem_Util is\n \n    function Has_Access_Values (T : Entity_Id) return Boolean;\n    --  Returns true if type or subtype T is an access type, or has a\n-   --  component (at any recursive level) that is an access type.\n+   --  component (at any recursive level) that is an access type. This\n+   --  is a conservative predicate, if it is not known whether or not\n+   --  T contains access values (happens for generic formals in some\n+   --  cases), then False is returned.\n \n    function Has_Declarations (N : Node_Id) return Boolean;\n    --  Determines if the node can have declarations"}, {"sha": "864c2deecc04d07b2c55034f258375bcac9c0474", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -65,6 +65,7 @@ package body Snames is\n      \"_abort_signal#\" &\n      \"_alignment#\" &\n      \"_assign#\" &\n+     \"_atcb#\" &\n      \"_chain#\" &\n      \"_clean#\" &\n      \"_controller#\" &"}, {"sha": "cb3b9d77bcccee65d710f3bf27706da14a7dfd4e", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 641, "deletions": 640, "changes": 1281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -148,149 +148,150 @@ package Snames is\n    Name_uAbort_Signal                  : constant Name_Id := N + 005;\n    Name_uAlignment                     : constant Name_Id := N + 006;\n    Name_uAssign                        : constant Name_Id := N + 007;\n-   Name_uChain                         : constant Name_Id := N + 008;\n-   Name_uClean                         : constant Name_Id := N + 009;\n-   Name_uController                    : constant Name_Id := N + 010;\n-   Name_uEntry_Bodies                  : constant Name_Id := N + 011;\n-   Name_uExpunge                       : constant Name_Id := N + 012;\n-   Name_uFinal_List                    : constant Name_Id := N + 013;\n-   Name_uIdepth                        : constant Name_Id := N + 014;\n-   Name_uInit                          : constant Name_Id := N + 015;\n-   Name_uLocal_Final_List              : constant Name_Id := N + 016;\n-   Name_uMaster                        : constant Name_Id := N + 017;\n-   Name_uObject                        : constant Name_Id := N + 018;\n-   Name_uPriority                      : constant Name_Id := N + 019;\n-   Name_uProcess_ATSD                  : constant Name_Id := N + 020;\n-   Name_uSecondary_Stack               : constant Name_Id := N + 021;\n-   Name_uService                       : constant Name_Id := N + 022;\n-   Name_uSize                          : constant Name_Id := N + 023;\n-   Name_uTags                          : constant Name_Id := N + 024;\n-   Name_uTask                          : constant Name_Id := N + 025;\n-   Name_uTask_Id                       : constant Name_Id := N + 026;\n-   Name_uTask_Info                     : constant Name_Id := N + 027;\n-   Name_uTask_Name                     : constant Name_Id := N + 028;\n-   Name_uTrace_Sp                      : constant Name_Id := N + 029;\n+   Name_uATCB                          : constant Name_Id := N + 008;\n+   Name_uChain                         : constant Name_Id := N + 009;\n+   Name_uClean                         : constant Name_Id := N + 010;\n+   Name_uController                    : constant Name_Id := N + 011;\n+   Name_uEntry_Bodies                  : constant Name_Id := N + 012;\n+   Name_uExpunge                       : constant Name_Id := N + 013;\n+   Name_uFinal_List                    : constant Name_Id := N + 014;\n+   Name_uIdepth                        : constant Name_Id := N + 015;\n+   Name_uInit                          : constant Name_Id := N + 016;\n+   Name_uLocal_Final_List              : constant Name_Id := N + 017;\n+   Name_uMaster                        : constant Name_Id := N + 018;\n+   Name_uObject                        : constant Name_Id := N + 019;\n+   Name_uPriority                      : constant Name_Id := N + 020;\n+   Name_uProcess_ATSD                  : constant Name_Id := N + 021;\n+   Name_uSecondary_Stack               : constant Name_Id := N + 022;\n+   Name_uService                       : constant Name_Id := N + 023;\n+   Name_uSize                          : constant Name_Id := N + 024;\n+   Name_uTags                          : constant Name_Id := N + 025;\n+   Name_uTask                          : constant Name_Id := N + 026;\n+   Name_uTask_Id                       : constant Name_Id := N + 027;\n+   Name_uTask_Info                     : constant Name_Id := N + 028;\n+   Name_uTask_Name                     : constant Name_Id := N + 029;\n+   Name_uTrace_Sp                      : constant Name_Id := N + 030;\n \n    --  Names of routines in Ada.Finalization, needed by expander\n \n-   Name_Initialize                     : constant Name_Id := N + 030;\n-   Name_Adjust                         : constant Name_Id := N + 031;\n-   Name_Finalize                       : constant Name_Id := N + 032;\n+   Name_Initialize                     : constant Name_Id := N + 031;\n+   Name_Adjust                         : constant Name_Id := N + 032;\n+   Name_Finalize                       : constant Name_Id := N + 033;\n \n    --  Names of fields declared in System.Finalization_Implementation,\n    --  needed by the expander when generating code for finalization.\n \n-   Name_Next                           : constant Name_Id := N + 033;\n-   Name_Prev                           : constant Name_Id := N + 034;\n+   Name_Next                           : constant Name_Id := N + 034;\n+   Name_Prev                           : constant Name_Id := N + 035;\n \n    --  Names of TSS routines for implementation of DSA over PolyORB\n \n-   Name_uTypeCode                      : constant Name_Id := N + 035;\n-   Name_uFrom_Any                      : constant Name_Id := N + 036;\n-   Name_uTo_Any                        : constant Name_Id := N + 037;\n+   Name_uTypeCode                      : constant Name_Id := N + 036;\n+   Name_uFrom_Any                      : constant Name_Id := N + 037;\n+   Name_uTo_Any                        : constant Name_Id := N + 038;\n \n    --  Names of allocation routines, also needed by expander\n \n-   Name_Allocate                       : constant Name_Id := N + 038;\n-   Name_Deallocate                     : constant Name_Id := N + 039;\n-   Name_Dereference                    : constant Name_Id := N + 040;\n+   Name_Allocate                       : constant Name_Id := N + 039;\n+   Name_Deallocate                     : constant Name_Id := N + 040;\n+   Name_Dereference                    : constant Name_Id := N + 041;\n \n    --  Names of Text_IO generic subpackages (see Rtsfind.Text_IO_Kludge)\n \n-   First_Text_IO_Package               : constant Name_Id := N + 041;\n-   Name_Decimal_IO                     : constant Name_Id := N + 041;\n-   Name_Enumeration_IO                 : constant Name_Id := N + 042;\n-   Name_Fixed_IO                       : constant Name_Id := N + 043;\n-   Name_Float_IO                       : constant Name_Id := N + 044;\n-   Name_Integer_IO                     : constant Name_Id := N + 045;\n-   Name_Modular_IO                     : constant Name_Id := N + 046;\n-   Last_Text_IO_Package                : constant Name_Id := N + 046;\n+   First_Text_IO_Package               : constant Name_Id := N + 042;\n+   Name_Decimal_IO                     : constant Name_Id := N + 042;\n+   Name_Enumeration_IO                 : constant Name_Id := N + 043;\n+   Name_Fixed_IO                       : constant Name_Id := N + 044;\n+   Name_Float_IO                       : constant Name_Id := N + 045;\n+   Name_Integer_IO                     : constant Name_Id := N + 046;\n+   Name_Modular_IO                     : constant Name_Id := N + 047;\n+   Last_Text_IO_Package                : constant Name_Id := N + 047;\n \n    subtype Text_IO_Package_Name is Name_Id\n      range First_Text_IO_Package .. Last_Text_IO_Package;\n \n    --  Names of files in library for Ada.Text_IO and Ada.Wide_Text_IO\n \n-   Name_a_textio                       : constant Name_Id := N + 047;\n-   Name_a_witeio                       : constant Name_Id := N + 048;\n+   Name_a_textio                       : constant Name_Id := N + 048;\n+   Name_a_witeio                       : constant Name_Id := N + 049;\n \n    --  Some miscellaneous names used for error detection/recovery\n \n-   Name_Const                          : constant Name_Id := N + 049;\n-   Name_Error                          : constant Name_Id := N + 050;\n-   Name_Go                             : constant Name_Id := N + 051;\n-   Name_Put                            : constant Name_Id := N + 052;\n-   Name_Put_Line                       : constant Name_Id := N + 053;\n-   Name_To                             : constant Name_Id := N + 054;\n+   Name_Const                          : constant Name_Id := N + 050;\n+   Name_Error                          : constant Name_Id := N + 051;\n+   Name_Go                             : constant Name_Id := N + 052;\n+   Name_Put                            : constant Name_Id := N + 053;\n+   Name_Put_Line                       : constant Name_Id := N + 054;\n+   Name_To                             : constant Name_Id := N + 055;\n \n    --  Names for packages that are treated specially by the compiler\n \n-   Name_Finalization                   : constant Name_Id := N + 055;\n-   Name_Finalization_Root              : constant Name_Id := N + 056;\n-   Name_Interfaces                     : constant Name_Id := N + 057;\n-   Name_Standard                       : constant Name_Id := N + 058;\n-   Name_System                         : constant Name_Id := N + 059;\n-   Name_Text_IO                        : constant Name_Id := N + 060;\n-   Name_Wide_Text_IO                   : constant Name_Id := N + 061;\n+   Name_Finalization                   : constant Name_Id := N + 056;\n+   Name_Finalization_Root              : constant Name_Id := N + 057;\n+   Name_Interfaces                     : constant Name_Id := N + 058;\n+   Name_Standard                       : constant Name_Id := N + 059;\n+   Name_System                         : constant Name_Id := N + 060;\n+   Name_Text_IO                        : constant Name_Id := N + 061;\n+   Name_Wide_Text_IO                   : constant Name_Id := N + 062;\n \n    --  Names of implementations of the distributed systems annex\n \n-   Name_No_DSA                         : constant Name_Id := N + 062;\n-   Name_GLADE_DSA                      : constant Name_Id := N + 063;\n-   Name_PolyORB_DSA                    : constant Name_Id := N + 064;\n+   Name_No_DSA                         : constant Name_Id := N + 063;\n+   Name_GLADE_DSA                      : constant Name_Id := N + 064;\n+   Name_PolyORB_DSA                    : constant Name_Id := N + 065;\n \n    --  Names of identifiers used in expanding distribution stubs\n \n-   Name_Addr                           : constant Name_Id := N + 065;\n-   Name_Async                          : constant Name_Id := N + 066;\n-   Name_Get_Active_Partition_ID        : constant Name_Id := N + 067;\n-   Name_Get_RCI_Package_Receiver       : constant Name_Id := N + 068;\n-   Name_Get_RCI_Package_Ref            : constant Name_Id := N + 069;\n-   Name_Origin                         : constant Name_Id := N + 070;\n-   Name_Params                         : constant Name_Id := N + 071;\n-   Name_Partition                      : constant Name_Id := N + 072;\n-   Name_Partition_Interface            : constant Name_Id := N + 073;\n-   Name_Ras                            : constant Name_Id := N + 074;\n-   Name_Call                           : constant Name_Id := N + 075;\n-   Name_RCI_Name                       : constant Name_Id := N + 076;\n-   Name_Receiver                       : constant Name_Id := N + 077;\n-   Name_Result                         : constant Name_Id := N + 078;\n-   Name_Rpc                            : constant Name_Id := N + 079;\n-   Name_Subp_Id                        : constant Name_Id := N + 080;\n-   Name_Operation                      : constant Name_Id := N + 081;\n-   Name_Argument                       : constant Name_Id := N + 082;\n-   Name_Arg_Modes                      : constant Name_Id := N + 083;\n-   Name_Handler                        : constant Name_Id := N + 084;\n-   Name_Target                         : constant Name_Id := N + 085;\n-   Name_Req                            : constant Name_Id := N + 086;\n-   Name_Obj_TypeCode                   : constant Name_Id := N + 087;\n-   Name_Stub                           : constant Name_Id := N + 088;\n+   Name_Addr                           : constant Name_Id := N + 066;\n+   Name_Async                          : constant Name_Id := N + 067;\n+   Name_Get_Active_Partition_ID        : constant Name_Id := N + 068;\n+   Name_Get_RCI_Package_Receiver       : constant Name_Id := N + 069;\n+   Name_Get_RCI_Package_Ref            : constant Name_Id := N + 070;\n+   Name_Origin                         : constant Name_Id := N + 071;\n+   Name_Params                         : constant Name_Id := N + 072;\n+   Name_Partition                      : constant Name_Id := N + 073;\n+   Name_Partition_Interface            : constant Name_Id := N + 074;\n+   Name_Ras                            : constant Name_Id := N + 075;\n+   Name_Call                           : constant Name_Id := N + 076;\n+   Name_RCI_Name                       : constant Name_Id := N + 077;\n+   Name_Receiver                       : constant Name_Id := N + 078;\n+   Name_Result                         : constant Name_Id := N + 079;\n+   Name_Rpc                            : constant Name_Id := N + 080;\n+   Name_Subp_Id                        : constant Name_Id := N + 081;\n+   Name_Operation                      : constant Name_Id := N + 082;\n+   Name_Argument                       : constant Name_Id := N + 083;\n+   Name_Arg_Modes                      : constant Name_Id := N + 084;\n+   Name_Handler                        : constant Name_Id := N + 085;\n+   Name_Target                         : constant Name_Id := N + 086;\n+   Name_Req                            : constant Name_Id := N + 087;\n+   Name_Obj_TypeCode                   : constant Name_Id := N + 088;\n+   Name_Stub                           : constant Name_Id := N + 089;\n \n    --  Operator Symbol entries. The actual names have an upper case O at\n    --  the start in place of the Op_ prefix (e.g. the actual name that\n    --  corresponds to Name_Op_Abs is \"Oabs\".\n \n-   First_Operator_Name                 : constant Name_Id := N + 089;\n-   Name_Op_Abs                         : constant Name_Id := N + 089; -- \"abs\"\n-   Name_Op_And                         : constant Name_Id := N + 090; -- \"and\"\n-   Name_Op_Mod                         : constant Name_Id := N + 091; -- \"mod\"\n-   Name_Op_Not                         : constant Name_Id := N + 092; -- \"not\"\n-   Name_Op_Or                          : constant Name_Id := N + 093; -- \"or\"\n-   Name_Op_Rem                         : constant Name_Id := N + 094; -- \"rem\"\n-   Name_Op_Xor                         : constant Name_Id := N + 095; -- \"xor\"\n-   Name_Op_Eq                          : constant Name_Id := N + 096; -- \"=\"\n-   Name_Op_Ne                          : constant Name_Id := N + 097; -- \"/=\"\n-   Name_Op_Lt                          : constant Name_Id := N + 098; -- \"<\"\n-   Name_Op_Le                          : constant Name_Id := N + 099; -- \"<=\"\n-   Name_Op_Gt                          : constant Name_Id := N + 100; -- \">\"\n-   Name_Op_Ge                          : constant Name_Id := N + 101; -- \">=\"\n-   Name_Op_Add                         : constant Name_Id := N + 102; -- \"+\"\n-   Name_Op_Subtract                    : constant Name_Id := N + 103; -- \"-\"\n-   Name_Op_Concat                      : constant Name_Id := N + 104; -- \"&\"\n-   Name_Op_Multiply                    : constant Name_Id := N + 105; -- \"*\"\n-   Name_Op_Divide                      : constant Name_Id := N + 106; -- \"/\"\n-   Name_Op_Expon                       : constant Name_Id := N + 107; -- \"**\"\n-   Last_Operator_Name                  : constant Name_Id := N + 107;\n+   First_Operator_Name                 : constant Name_Id := N + 090;\n+   Name_Op_Abs                         : constant Name_Id := N + 090; -- \"abs\"\n+   Name_Op_And                         : constant Name_Id := N + 091; -- \"and\"\n+   Name_Op_Mod                         : constant Name_Id := N + 092; -- \"mod\"\n+   Name_Op_Not                         : constant Name_Id := N + 093; -- \"not\"\n+   Name_Op_Or                          : constant Name_Id := N + 094; -- \"or\"\n+   Name_Op_Rem                         : constant Name_Id := N + 095; -- \"rem\"\n+   Name_Op_Xor                         : constant Name_Id := N + 096; -- \"xor\"\n+   Name_Op_Eq                          : constant Name_Id := N + 097; -- \"=\"\n+   Name_Op_Ne                          : constant Name_Id := N + 098; -- \"/=\"\n+   Name_Op_Lt                          : constant Name_Id := N + 099; -- \"<\"\n+   Name_Op_Le                          : constant Name_Id := N + 100; -- \"<=\"\n+   Name_Op_Gt                          : constant Name_Id := N + 101; -- \">\"\n+   Name_Op_Ge                          : constant Name_Id := N + 102; -- \">=\"\n+   Name_Op_Add                         : constant Name_Id := N + 103; -- \"+\"\n+   Name_Op_Subtract                    : constant Name_Id := N + 104; -- \"-\"\n+   Name_Op_Concat                      : constant Name_Id := N + 105; -- \"&\"\n+   Name_Op_Multiply                    : constant Name_Id := N + 106; -- \"*\"\n+   Name_Op_Divide                      : constant Name_Id := N + 107; -- \"/\"\n+   Name_Op_Expon                       : constant Name_Id := N + 108; -- \"**\"\n+   Last_Operator_Name                  : constant Name_Id := N + 108;\n \n    --  Names for all pragmas recognized by GNAT. The entries with the comment\n    --  \"Ada 83\" are pragmas that are defined in Ada 83, but not in Ada 95.\n@@ -313,143 +314,143 @@ package Snames is\n    --  only in GNAT for the AAMP. They are ignored in other versions with\n    --  appropriate warnings.\n \n-   First_Pragma_Name                   : constant Name_Id := N + 108;\n+   First_Pragma_Name                   : constant Name_Id := N + 109;\n \n    --  Configuration pragmas are grouped at start\n \n-   Name_Ada_83                         : constant Name_Id := N + 108; -- GNAT\n-   Name_Ada_95                         : constant Name_Id := N + 109; -- GNAT\n-   Name_Ada_05                         : constant Name_Id := N + 110; -- GNAT\n-   Name_C_Pass_By_Copy                 : constant Name_Id := N + 111; -- GNAT\n-   Name_Compile_Time_Warning           : constant Name_Id := N + 112; -- GNAT\n-   Name_Component_Alignment            : constant Name_Id := N + 113; -- GNAT\n-   Name_Convention_Identifier          : constant Name_Id := N + 114; -- GNAT\n-   Name_Detect_Blocking                : constant Name_Id := N + 115; -- Ada05\n-   Name_Discard_Names                  : constant Name_Id := N + 116;\n-   Name_Elaboration_Checks             : constant Name_Id := N + 117; -- GNAT\n-   Name_Eliminate                      : constant Name_Id := N + 118; -- GNAT\n-   Name_Explicit_Overriding            : constant Name_Id := N + 119;\n-   Name_Extend_System                  : constant Name_Id := N + 120; -- GNAT\n-   Name_Extensions_Allowed             : constant Name_Id := N + 121; -- GNAT\n-   Name_External_Name_Casing           : constant Name_Id := N + 122; -- GNAT\n-   Name_Float_Representation           : constant Name_Id := N + 123; -- GNAT\n-   Name_Initialize_Scalars             : constant Name_Id := N + 124; -- GNAT\n-   Name_Interrupt_State                : constant Name_Id := N + 125; -- GNAT\n-   Name_License                        : constant Name_Id := N + 126; -- GNAT\n-   Name_Locking_Policy                 : constant Name_Id := N + 127;\n-   Name_Long_Float                     : constant Name_Id := N + 128; -- VMS\n-   Name_No_Run_Time                    : constant Name_Id := N + 129; -- GNAT\n-   Name_No_Strict_Aliasing             : constant Name_Id := N + 130; -- GNAT\n-   Name_Normalize_Scalars              : constant Name_Id := N + 131;\n-   Name_Polling                        : constant Name_Id := N + 132; -- GNAT\n-   Name_Persistent_Data                : constant Name_Id := N + 133; -- GNAT\n-   Name_Persistent_Object              : constant Name_Id := N + 134; -- GNAT\n-   Name_Profile                        : constant Name_Id := N + 135; -- Ada05\n-   Name_Profile_Warnings               : constant Name_Id := N + 136; -- GNAT\n-   Name_Propagate_Exceptions           : constant Name_Id := N + 137; -- GNAT\n-   Name_Queuing_Policy                 : constant Name_Id := N + 138;\n-   Name_Ravenscar                      : constant Name_Id := N + 139;\n-   Name_Restricted_Run_Time            : constant Name_Id := N + 140;\n-   Name_Restrictions                   : constant Name_Id := N + 141;\n-   Name_Restriction_Warnings           : constant Name_Id := N + 142; -- GNAT\n-   Name_Reviewable                     : constant Name_Id := N + 143;\n-   Name_Source_File_Name               : constant Name_Id := N + 144; -- GNAT\n-   Name_Source_File_Name_Project       : constant Name_Id := N + 145; -- GNAT\n-   Name_Style_Checks                   : constant Name_Id := N + 146; -- GNAT\n-   Name_Suppress                       : constant Name_Id := N + 147;\n-   Name_Suppress_Exception_Locations   : constant Name_Id := N + 148; -- GNAT\n-   Name_Task_Dispatching_Policy        : constant Name_Id := N + 149;\n-   Name_Universal_Data                 : constant Name_Id := N + 150; -- AAMP\n-   Name_Unsuppress                     : constant Name_Id := N + 151; -- GNAT\n-   Name_Use_VADS_Size                  : constant Name_Id := N + 152; -- GNAT\n-   Name_Validity_Checks                : constant Name_Id := N + 153; -- GNAT\n-   Name_Warnings                       : constant Name_Id := N + 154; -- GNAT\n-   Last_Configuration_Pragma_Name      : constant Name_Id := N + 154;\n+   Name_Ada_83                         : constant Name_Id := N + 109; -- GNAT\n+   Name_Ada_95                         : constant Name_Id := N + 110; -- GNAT\n+   Name_Ada_05                         : constant Name_Id := N + 111; -- GNAT\n+   Name_C_Pass_By_Copy                 : constant Name_Id := N + 112; -- GNAT\n+   Name_Compile_Time_Warning           : constant Name_Id := N + 113; -- GNAT\n+   Name_Component_Alignment            : constant Name_Id := N + 114; -- GNAT\n+   Name_Convention_Identifier          : constant Name_Id := N + 115; -- GNAT\n+   Name_Detect_Blocking                : constant Name_Id := N + 116; -- Ada05\n+   Name_Discard_Names                  : constant Name_Id := N + 117;\n+   Name_Elaboration_Checks             : constant Name_Id := N + 118; -- GNAT\n+   Name_Eliminate                      : constant Name_Id := N + 119; -- GNAT\n+   Name_Explicit_Overriding            : constant Name_Id := N + 120;\n+   Name_Extend_System                  : constant Name_Id := N + 121; -- GNAT\n+   Name_Extensions_Allowed             : constant Name_Id := N + 122; -- GNAT\n+   Name_External_Name_Casing           : constant Name_Id := N + 123; -- GNAT\n+   Name_Float_Representation           : constant Name_Id := N + 124; -- GNAT\n+   Name_Initialize_Scalars             : constant Name_Id := N + 125; -- GNAT\n+   Name_Interrupt_State                : constant Name_Id := N + 126; -- GNAT\n+   Name_License                        : constant Name_Id := N + 127; -- GNAT\n+   Name_Locking_Policy                 : constant Name_Id := N + 128;\n+   Name_Long_Float                     : constant Name_Id := N + 129; -- VMS\n+   Name_No_Run_Time                    : constant Name_Id := N + 130; -- GNAT\n+   Name_No_Strict_Aliasing             : constant Name_Id := N + 131; -- GNAT\n+   Name_Normalize_Scalars              : constant Name_Id := N + 132;\n+   Name_Polling                        : constant Name_Id := N + 133; -- GNAT\n+   Name_Persistent_Data                : constant Name_Id := N + 134; -- GNAT\n+   Name_Persistent_Object              : constant Name_Id := N + 135; -- GNAT\n+   Name_Profile                        : constant Name_Id := N + 136; -- Ada05\n+   Name_Profile_Warnings               : constant Name_Id := N + 137; -- GNAT\n+   Name_Propagate_Exceptions           : constant Name_Id := N + 138; -- GNAT\n+   Name_Queuing_Policy                 : constant Name_Id := N + 139;\n+   Name_Ravenscar                      : constant Name_Id := N + 140;\n+   Name_Restricted_Run_Time            : constant Name_Id := N + 141;\n+   Name_Restrictions                   : constant Name_Id := N + 142;\n+   Name_Restriction_Warnings           : constant Name_Id := N + 143; -- GNAT\n+   Name_Reviewable                     : constant Name_Id := N + 144;\n+   Name_Source_File_Name               : constant Name_Id := N + 145; -- GNAT\n+   Name_Source_File_Name_Project       : constant Name_Id := N + 146; -- GNAT\n+   Name_Style_Checks                   : constant Name_Id := N + 147; -- GNAT\n+   Name_Suppress                       : constant Name_Id := N + 148;\n+   Name_Suppress_Exception_Locations   : constant Name_Id := N + 149; -- GNAT\n+   Name_Task_Dispatching_Policy        : constant Name_Id := N + 150;\n+   Name_Universal_Data                 : constant Name_Id := N + 151; -- AAMP\n+   Name_Unsuppress                     : constant Name_Id := N + 152; -- GNAT\n+   Name_Use_VADS_Size                  : constant Name_Id := N + 153; -- GNAT\n+   Name_Validity_Checks                : constant Name_Id := N + 154; -- GNAT\n+   Name_Warnings                       : constant Name_Id := N + 155; -- GNAT\n+   Last_Configuration_Pragma_Name      : constant Name_Id := N + 155;\n \n    --  Remaining pragma names\n \n-   Name_Abort_Defer                    : constant Name_Id := N + 155; -- GNAT\n-   Name_All_Calls_Remote               : constant Name_Id := N + 156;\n-   Name_Annotate                       : constant Name_Id := N + 157; -- GNAT\n+   Name_Abort_Defer                    : constant Name_Id := N + 156; -- GNAT\n+   Name_All_Calls_Remote               : constant Name_Id := N + 157;\n+   Name_Annotate                       : constant Name_Id := N + 158; -- GNAT\n \n    --  Note: AST_Entry is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Attribute_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Name_AST_Entry.\n    --  AST_Entry is a VMS specific pragma.\n \n-   Name_Assert                         : constant Name_Id := N + 158; -- GNAT\n-   Name_Asynchronous                   : constant Name_Id := N + 159;\n-   Name_Atomic                         : constant Name_Id := N + 160;\n-   Name_Atomic_Components              : constant Name_Id := N + 161;\n-   Name_Attach_Handler                 : constant Name_Id := N + 162;\n-   Name_Comment                        : constant Name_Id := N + 163; -- GNAT\n-   Name_Common_Object                  : constant Name_Id := N + 164; -- GNAT\n-   Name_Complex_Representation         : constant Name_Id := N + 165; -- GNAT\n-   Name_Controlled                     : constant Name_Id := N + 166;\n-   Name_Convention                     : constant Name_Id := N + 167;\n-   Name_CPP_Class                      : constant Name_Id := N + 168; -- GNAT\n-   Name_CPP_Constructor                : constant Name_Id := N + 169; -- GNAT\n-   Name_CPP_Virtual                    : constant Name_Id := N + 170; -- GNAT\n-   Name_CPP_Vtable                     : constant Name_Id := N + 171; -- GNAT\n-   Name_Debug                          : constant Name_Id := N + 172; -- GNAT\n-   Name_Elaborate                      : constant Name_Id := N + 173; -- Ada 83\n-   Name_Elaborate_All                  : constant Name_Id := N + 174;\n-   Name_Elaborate_Body                 : constant Name_Id := N + 175;\n-   Name_Export                         : constant Name_Id := N + 176;\n-   Name_Export_Exception               : constant Name_Id := N + 177; -- VMS\n-   Name_Export_Function                : constant Name_Id := N + 178; -- GNAT\n-   Name_Export_Object                  : constant Name_Id := N + 179; -- GNAT\n-   Name_Export_Procedure               : constant Name_Id := N + 180; -- GNAT\n-   Name_Export_Value                   : constant Name_Id := N + 181; -- GNAT\n-   Name_Export_Valued_Procedure        : constant Name_Id := N + 182; -- GNAT\n-   Name_External                       : constant Name_Id := N + 183; -- GNAT\n-   Name_Finalize_Storage_Only          : constant Name_Id := N + 184; -- GNAT\n-   Name_Ident                          : constant Name_Id := N + 185; -- VMS\n-   Name_Import                         : constant Name_Id := N + 186;\n-   Name_Import_Exception               : constant Name_Id := N + 187; -- VMS\n-   Name_Import_Function                : constant Name_Id := N + 188; -- GNAT\n-   Name_Import_Object                  : constant Name_Id := N + 189; -- GNAT\n-   Name_Import_Procedure               : constant Name_Id := N + 190; -- GNAT\n-   Name_Import_Valued_Procedure        : constant Name_Id := N + 191; -- GNAT\n-   Name_Inline                         : constant Name_Id := N + 192;\n-   Name_Inline_Always                  : constant Name_Id := N + 193; -- GNAT\n-   Name_Inline_Generic                 : constant Name_Id := N + 194; -- GNAT\n-   Name_Inspection_Point               : constant Name_Id := N + 195;\n-   Name_Interface                      : constant Name_Id := N + 196; -- Ada 83\n-   Name_Interface_Name                 : constant Name_Id := N + 197; -- GNAT\n-   Name_Interrupt_Handler              : constant Name_Id := N + 198;\n-   Name_Interrupt_Priority             : constant Name_Id := N + 199;\n-   Name_Java_Constructor               : constant Name_Id := N + 200; -- GNAT\n-   Name_Java_Interface                 : constant Name_Id := N + 201; -- GNAT\n-   Name_Keep_Names                     : constant Name_Id := N + 202; -- GNAT\n-   Name_Link_With                      : constant Name_Id := N + 203; -- GNAT\n-   Name_Linker_Alias                   : constant Name_Id := N + 204; -- GNAT\n-   Name_Linker_Options                 : constant Name_Id := N + 205;\n-   Name_Linker_Section                 : constant Name_Id := N + 206; -- GNAT\n-   Name_List                           : constant Name_Id := N + 207;\n-   Name_Machine_Attribute              : constant Name_Id := N + 208; -- GNAT\n-   Name_Main                           : constant Name_Id := N + 209; -- GNAT\n-   Name_Main_Storage                   : constant Name_Id := N + 210; -- GNAT\n-   Name_Memory_Size                    : constant Name_Id := N + 211; -- Ada 83\n-   Name_No_Return                      : constant Name_Id := N + 212; -- GNAT\n-   Name_Obsolescent                    : constant Name_Id := N + 213; -- GNAT\n-   Name_Optimize                       : constant Name_Id := N + 214;\n-   Name_Optional_Overriding            : constant Name_Id := N + 215;\n-   Name_Overriding                     : constant Name_Id := N + 216;\n-   Name_Pack                           : constant Name_Id := N + 217;\n-   Name_Page                           : constant Name_Id := N + 218;\n-   Name_Passive                        : constant Name_Id := N + 219; -- GNAT\n-   Name_Preelaborate                   : constant Name_Id := N + 220;\n-   Name_Priority                       : constant Name_Id := N + 221;\n-   Name_Psect_Object                   : constant Name_Id := N + 222; -- VMS\n-   Name_Pure                           : constant Name_Id := N + 223;\n-   Name_Pure_Function                  : constant Name_Id := N + 224; -- GNAT\n-   Name_Remote_Call_Interface          : constant Name_Id := N + 225;\n-   Name_Remote_Types                   : constant Name_Id := N + 226;\n-   Name_Share_Generic                  : constant Name_Id := N + 227; -- GNAT\n-   Name_Shared                         : constant Name_Id := N + 228; -- Ada 83\n-   Name_Shared_Passive                 : constant Name_Id := N + 229;\n+   Name_Assert                         : constant Name_Id := N + 159; -- GNAT\n+   Name_Asynchronous                   : constant Name_Id := N + 160;\n+   Name_Atomic                         : constant Name_Id := N + 161;\n+   Name_Atomic_Components              : constant Name_Id := N + 162;\n+   Name_Attach_Handler                 : constant Name_Id := N + 163;\n+   Name_Comment                        : constant Name_Id := N + 164; -- GNAT\n+   Name_Common_Object                  : constant Name_Id := N + 165; -- GNAT\n+   Name_Complex_Representation         : constant Name_Id := N + 166; -- GNAT\n+   Name_Controlled                     : constant Name_Id := N + 167;\n+   Name_Convention                     : constant Name_Id := N + 168;\n+   Name_CPP_Class                      : constant Name_Id := N + 169; -- GNAT\n+   Name_CPP_Constructor                : constant Name_Id := N + 170; -- GNAT\n+   Name_CPP_Virtual                    : constant Name_Id := N + 171; -- GNAT\n+   Name_CPP_Vtable                     : constant Name_Id := N + 172; -- GNAT\n+   Name_Debug                          : constant Name_Id := N + 173; -- GNAT\n+   Name_Elaborate                      : constant Name_Id := N + 174; -- Ada 83\n+   Name_Elaborate_All                  : constant Name_Id := N + 175;\n+   Name_Elaborate_Body                 : constant Name_Id := N + 176;\n+   Name_Export                         : constant Name_Id := N + 177;\n+   Name_Export_Exception               : constant Name_Id := N + 178; -- VMS\n+   Name_Export_Function                : constant Name_Id := N + 179; -- GNAT\n+   Name_Export_Object                  : constant Name_Id := N + 180; -- GNAT\n+   Name_Export_Procedure               : constant Name_Id := N + 181; -- GNAT\n+   Name_Export_Value                   : constant Name_Id := N + 182; -- GNAT\n+   Name_Export_Valued_Procedure        : constant Name_Id := N + 183; -- GNAT\n+   Name_External                       : constant Name_Id := N + 184; -- GNAT\n+   Name_Finalize_Storage_Only          : constant Name_Id := N + 185; -- GNAT\n+   Name_Ident                          : constant Name_Id := N + 186; -- VMS\n+   Name_Import                         : constant Name_Id := N + 187;\n+   Name_Import_Exception               : constant Name_Id := N + 188; -- VMS\n+   Name_Import_Function                : constant Name_Id := N + 189; -- GNAT\n+   Name_Import_Object                  : constant Name_Id := N + 190; -- GNAT\n+   Name_Import_Procedure               : constant Name_Id := N + 191; -- GNAT\n+   Name_Import_Valued_Procedure        : constant Name_Id := N + 192; -- GNAT\n+   Name_Inline                         : constant Name_Id := N + 193;\n+   Name_Inline_Always                  : constant Name_Id := N + 194; -- GNAT\n+   Name_Inline_Generic                 : constant Name_Id := N + 195; -- GNAT\n+   Name_Inspection_Point               : constant Name_Id := N + 196;\n+   Name_Interface                      : constant Name_Id := N + 197; -- Ada 83\n+   Name_Interface_Name                 : constant Name_Id := N + 198; -- GNAT\n+   Name_Interrupt_Handler              : constant Name_Id := N + 199;\n+   Name_Interrupt_Priority             : constant Name_Id := N + 200;\n+   Name_Java_Constructor               : constant Name_Id := N + 201; -- GNAT\n+   Name_Java_Interface                 : constant Name_Id := N + 202; -- GNAT\n+   Name_Keep_Names                     : constant Name_Id := N + 203; -- GNAT\n+   Name_Link_With                      : constant Name_Id := N + 204; -- GNAT\n+   Name_Linker_Alias                   : constant Name_Id := N + 205; -- GNAT\n+   Name_Linker_Options                 : constant Name_Id := N + 206;\n+   Name_Linker_Section                 : constant Name_Id := N + 207; -- GNAT\n+   Name_List                           : constant Name_Id := N + 208;\n+   Name_Machine_Attribute              : constant Name_Id := N + 209; -- GNAT\n+   Name_Main                           : constant Name_Id := N + 210; -- GNAT\n+   Name_Main_Storage                   : constant Name_Id := N + 211; -- GNAT\n+   Name_Memory_Size                    : constant Name_Id := N + 212; -- Ada 83\n+   Name_No_Return                      : constant Name_Id := N + 213; -- GNAT\n+   Name_Obsolescent                    : constant Name_Id := N + 214; -- GNAT\n+   Name_Optimize                       : constant Name_Id := N + 215;\n+   Name_Optional_Overriding            : constant Name_Id := N + 216;\n+   Name_Overriding                     : constant Name_Id := N + 217;\n+   Name_Pack                           : constant Name_Id := N + 218;\n+   Name_Page                           : constant Name_Id := N + 219;\n+   Name_Passive                        : constant Name_Id := N + 220; -- GNAT\n+   Name_Preelaborate                   : constant Name_Id := N + 221;\n+   Name_Priority                       : constant Name_Id := N + 222;\n+   Name_Psect_Object                   : constant Name_Id := N + 223; -- VMS\n+   Name_Pure                           : constant Name_Id := N + 224;\n+   Name_Pure_Function                  : constant Name_Id := N + 225; -- GNAT\n+   Name_Remote_Call_Interface          : constant Name_Id := N + 226;\n+   Name_Remote_Types                   : constant Name_Id := N + 227;\n+   Name_Share_Generic                  : constant Name_Id := N + 228; -- GNAT\n+   Name_Shared                         : constant Name_Id := N + 229; -- Ada 83\n+   Name_Shared_Passive                 : constant Name_Id := N + 230;\n \n    --  Note: Storage_Size is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n@@ -459,27 +460,27 @@ package Snames is\n    --  Note: Storage_Unit is also omitted from the list because of a clash\n    --  with an attribute name, and is treated similarly.\n \n-   Name_Source_Reference               : constant Name_Id := N + 230; -- GNAT\n-   Name_Stream_Convert                 : constant Name_Id := N + 231; -- GNAT\n-   Name_Subtitle                       : constant Name_Id := N + 232; -- GNAT\n-   Name_Suppress_All                   : constant Name_Id := N + 233; -- GNAT\n-   Name_Suppress_Debug_Info            : constant Name_Id := N + 234; -- GNAT\n-   Name_Suppress_Initialization        : constant Name_Id := N + 235; -- GNAT\n-   Name_System_Name                    : constant Name_Id := N + 236; -- Ada 83\n-   Name_Task_Info                      : constant Name_Id := N + 237; -- GNAT\n-   Name_Task_Name                      : constant Name_Id := N + 238; -- GNAT\n-   Name_Task_Storage                   : constant Name_Id := N + 239; -- VMS\n-   Name_Thread_Body                    : constant Name_Id := N + 240; -- GNAT\n-   Name_Time_Slice                     : constant Name_Id := N + 241; -- GNAT\n-   Name_Title                          : constant Name_Id := N + 242; -- GNAT\n-   Name_Unchecked_Union                : constant Name_Id := N + 243; -- GNAT\n-   Name_Unimplemented_Unit             : constant Name_Id := N + 244; -- GNAT\n-   Name_Unreferenced                   : constant Name_Id := N + 245; -- GNAT\n-   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 246; -- GNAT\n-   Name_Volatile                       : constant Name_Id := N + 247;\n-   Name_Volatile_Components            : constant Name_Id := N + 248;\n-   Name_Weak_External                  : constant Name_Id := N + 249; -- GNAT\n-   Last_Pragma_Name                    : constant Name_Id := N + 249;\n+   Name_Source_Reference               : constant Name_Id := N + 231; -- GNAT\n+   Name_Stream_Convert                 : constant Name_Id := N + 232; -- GNAT\n+   Name_Subtitle                       : constant Name_Id := N + 233; -- GNAT\n+   Name_Suppress_All                   : constant Name_Id := N + 234; -- GNAT\n+   Name_Suppress_Debug_Info            : constant Name_Id := N + 235; -- GNAT\n+   Name_Suppress_Initialization        : constant Name_Id := N + 236; -- GNAT\n+   Name_System_Name                    : constant Name_Id := N + 237; -- Ada 83\n+   Name_Task_Info                      : constant Name_Id := N + 238; -- GNAT\n+   Name_Task_Name                      : constant Name_Id := N + 239; -- GNAT\n+   Name_Task_Storage                   : constant Name_Id := N + 240; -- VMS\n+   Name_Thread_Body                    : constant Name_Id := N + 241; -- GNAT\n+   Name_Time_Slice                     : constant Name_Id := N + 242; -- GNAT\n+   Name_Title                          : constant Name_Id := N + 243; -- GNAT\n+   Name_Unchecked_Union                : constant Name_Id := N + 244; -- GNAT\n+   Name_Unimplemented_Unit             : constant Name_Id := N + 245; -- GNAT\n+   Name_Unreferenced                   : constant Name_Id := N + 246; -- GNAT\n+   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 247; -- GNAT\n+   Name_Volatile                       : constant Name_Id := N + 248;\n+   Name_Volatile_Components            : constant Name_Id := N + 249;\n+   Name_Weak_External                  : constant Name_Id := N + 250; -- GNAT\n+   Last_Pragma_Name                    : constant Name_Id := N + 250;\n \n    --  Language convention names for pragma Convention/Export/Import/Interface\n    --  Note that Name_C is not included in this list, since it was already\n@@ -490,105 +491,105 @@ package Snames is\n    --  Entry and Protected, this is because these conventions cannot be\n    --  specified by a pragma.\n \n-   First_Convention_Name               : constant Name_Id := N + 250;\n-   Name_Ada                            : constant Name_Id := N + 250;\n-   Name_Assembler                      : constant Name_Id := N + 251;\n-   Name_COBOL                          : constant Name_Id := N + 252;\n-   Name_CPP                            : constant Name_Id := N + 253;\n-   Name_Fortran                        : constant Name_Id := N + 254;\n-   Name_Intrinsic                      : constant Name_Id := N + 255;\n-   Name_Java                           : constant Name_Id := N + 256;\n-   Name_Stdcall                        : constant Name_Id := N + 257;\n-   Name_Stubbed                        : constant Name_Id := N + 258;\n-   Last_Convention_Name                : constant Name_Id := N + 258;\n+   First_Convention_Name               : constant Name_Id := N + 251;\n+   Name_Ada                            : constant Name_Id := N + 251;\n+   Name_Assembler                      : constant Name_Id := N + 252;\n+   Name_COBOL                          : constant Name_Id := N + 253;\n+   Name_CPP                            : constant Name_Id := N + 254;\n+   Name_Fortran                        : constant Name_Id := N + 255;\n+   Name_Intrinsic                      : constant Name_Id := N + 256;\n+   Name_Java                           : constant Name_Id := N + 257;\n+   Name_Stdcall                        : constant Name_Id := N + 258;\n+   Name_Stubbed                        : constant Name_Id := N + 259;\n+   Last_Convention_Name                : constant Name_Id := N + 259;\n \n    --  The following names are preset as synonyms for Assembler\n \n-   Name_Asm                            : constant Name_Id := N + 259;\n-   Name_Assembly                       : constant Name_Id := N + 260;\n+   Name_Asm                            : constant Name_Id := N + 260;\n+   Name_Assembly                       : constant Name_Id := N + 261;\n \n    --  The following names are preset as synonyms for C\n \n-   Name_Default                        : constant Name_Id := N + 261;\n+   Name_Default                        : constant Name_Id := N + 262;\n    --  Name_Exernal (previously defined as pragma)\n \n    --  The following names are present as synonyms for Stdcall\n \n-   Name_DLL                            : constant Name_Id := N + 262;\n-   Name_Win32                          : constant Name_Id := N + 263;\n+   Name_DLL                            : constant Name_Id := N + 263;\n+   Name_Win32                          : constant Name_Id := N + 264;\n \n    --  Other special names used in processing pragmas\n \n-   Name_As_Is                          : constant Name_Id := N + 264;\n-   Name_Body_File_Name                 : constant Name_Id := N + 265;\n-   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 266;\n-   Name_Casing                         : constant Name_Id := N + 267;\n-   Name_Code                           : constant Name_Id := N + 268;\n-   Name_Component                      : constant Name_Id := N + 269;\n-   Name_Component_Size_4               : constant Name_Id := N + 270;\n-   Name_Copy                           : constant Name_Id := N + 271;\n-   Name_D_Float                        : constant Name_Id := N + 272;\n-   Name_Descriptor                     : constant Name_Id := N + 273;\n-   Name_Dot_Replacement                : constant Name_Id := N + 274;\n-   Name_Dynamic                        : constant Name_Id := N + 275;\n-   Name_Entity                         : constant Name_Id := N + 276;\n-   Name_External_Name                  : constant Name_Id := N + 277;\n-   Name_First_Optional_Parameter       : constant Name_Id := N + 278;\n-   Name_Form                           : constant Name_Id := N + 279;\n-   Name_G_Float                        : constant Name_Id := N + 280;\n-   Name_Gcc                            : constant Name_Id := N + 281;\n-   Name_Gnat                           : constant Name_Id := N + 282;\n-   Name_GPL                            : constant Name_Id := N + 283;\n-   Name_IEEE_Float                     : constant Name_Id := N + 284;\n-   Name_Internal                       : constant Name_Id := N + 285;\n-   Name_Link_Name                      : constant Name_Id := N + 286;\n-   Name_Lowercase                      : constant Name_Id := N + 287;\n-   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 288;\n-   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 289;\n-   Name_Max_Size                       : constant Name_Id := N + 290;\n-   Name_Mechanism                      : constant Name_Id := N + 291;\n-   Name_Mixedcase                      : constant Name_Id := N + 292;\n-   Name_Modified_GPL                   : constant Name_Id := N + 293;\n-   Name_Name                           : constant Name_Id := N + 294;\n-   Name_NCA                            : constant Name_Id := N + 295;\n-   Name_No                             : constant Name_Id := N + 296;\n-   Name_On                             : constant Name_Id := N + 297;\n-   Name_Parameter_Types                : constant Name_Id := N + 298;\n-   Name_Reference                      : constant Name_Id := N + 299;\n-   Name_No_Dynamic_Attachment          : constant Name_Id := N + 300;\n-   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 301;\n-   Name_No_Requeue                     : constant Name_Id := N + 302;\n-   Name_No_Requeue_Statements          : constant Name_Id := N + 303;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 304;\n-   Name_No_Task_Attributes_Package     : constant Name_Id := N + 305;\n-   Name_Restricted                     : constant Name_Id := N + 306;\n-   Name_Result_Mechanism               : constant Name_Id := N + 307;\n-   Name_Result_Type                    : constant Name_Id := N + 308;\n-   Name_Runtime                        : constant Name_Id := N + 309;\n-   Name_SB                             : constant Name_Id := N + 310;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 311;\n-   Name_Section                        : constant Name_Id := N + 312;\n-   Name_Semaphore                      : constant Name_Id := N + 313;\n-   Name_Simple_Barriers                : constant Name_Id := N + 314;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 315;\n-   Name_Static                         : constant Name_Id := N + 316;\n-   Name_Stack_Size                     : constant Name_Id := N + 317;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 318;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 319;\n-   Name_Task_Type                      : constant Name_Id := N + 320;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 321;\n-   Name_Top_Guard                      : constant Name_Id := N + 322;\n-   Name_UBA                            : constant Name_Id := N + 323;\n-   Name_UBS                            : constant Name_Id := N + 324;\n-   Name_UBSB                           : constant Name_Id := N + 325;\n-   Name_Unit_Name                      : constant Name_Id := N + 326;\n-   Name_Unknown                        : constant Name_Id := N + 327;\n-   Name_Unrestricted                   : constant Name_Id := N + 328;\n-   Name_Uppercase                      : constant Name_Id := N + 329;\n-   Name_User                           : constant Name_Id := N + 330;\n-   Name_VAX_Float                      : constant Name_Id := N + 331;\n-   Name_VMS                            : constant Name_Id := N + 332;\n-   Name_Working_Storage                : constant Name_Id := N + 333;\n+   Name_As_Is                          : constant Name_Id := N + 265;\n+   Name_Body_File_Name                 : constant Name_Id := N + 266;\n+   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 267;\n+   Name_Casing                         : constant Name_Id := N + 268;\n+   Name_Code                           : constant Name_Id := N + 269;\n+   Name_Component                      : constant Name_Id := N + 270;\n+   Name_Component_Size_4               : constant Name_Id := N + 271;\n+   Name_Copy                           : constant Name_Id := N + 272;\n+   Name_D_Float                        : constant Name_Id := N + 273;\n+   Name_Descriptor                     : constant Name_Id := N + 274;\n+   Name_Dot_Replacement                : constant Name_Id := N + 275;\n+   Name_Dynamic                        : constant Name_Id := N + 276;\n+   Name_Entity                         : constant Name_Id := N + 277;\n+   Name_External_Name                  : constant Name_Id := N + 278;\n+   Name_First_Optional_Parameter       : constant Name_Id := N + 279;\n+   Name_Form                           : constant Name_Id := N + 280;\n+   Name_G_Float                        : constant Name_Id := N + 281;\n+   Name_Gcc                            : constant Name_Id := N + 282;\n+   Name_Gnat                           : constant Name_Id := N + 283;\n+   Name_GPL                            : constant Name_Id := N + 284;\n+   Name_IEEE_Float                     : constant Name_Id := N + 285;\n+   Name_Internal                       : constant Name_Id := N + 286;\n+   Name_Link_Name                      : constant Name_Id := N + 287;\n+   Name_Lowercase                      : constant Name_Id := N + 288;\n+   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 289;\n+   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 290;\n+   Name_Max_Size                       : constant Name_Id := N + 291;\n+   Name_Mechanism                      : constant Name_Id := N + 292;\n+   Name_Mixedcase                      : constant Name_Id := N + 293;\n+   Name_Modified_GPL                   : constant Name_Id := N + 294;\n+   Name_Name                           : constant Name_Id := N + 295;\n+   Name_NCA                            : constant Name_Id := N + 296;\n+   Name_No                             : constant Name_Id := N + 297;\n+   Name_On                             : constant Name_Id := N + 298;\n+   Name_Parameter_Types                : constant Name_Id := N + 299;\n+   Name_Reference                      : constant Name_Id := N + 300;\n+   Name_No_Dynamic_Attachment          : constant Name_Id := N + 301;\n+   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 302;\n+   Name_No_Requeue                     : constant Name_Id := N + 303;\n+   Name_No_Requeue_Statements          : constant Name_Id := N + 304;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 305;\n+   Name_No_Task_Attributes_Package     : constant Name_Id := N + 306;\n+   Name_Restricted                     : constant Name_Id := N + 307;\n+   Name_Result_Mechanism               : constant Name_Id := N + 308;\n+   Name_Result_Type                    : constant Name_Id := N + 309;\n+   Name_Runtime                        : constant Name_Id := N + 310;\n+   Name_SB                             : constant Name_Id := N + 311;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 312;\n+   Name_Section                        : constant Name_Id := N + 313;\n+   Name_Semaphore                      : constant Name_Id := N + 314;\n+   Name_Simple_Barriers                : constant Name_Id := N + 315;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 316;\n+   Name_Static                         : constant Name_Id := N + 317;\n+   Name_Stack_Size                     : constant Name_Id := N + 318;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 319;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 320;\n+   Name_Task_Type                      : constant Name_Id := N + 321;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 322;\n+   Name_Top_Guard                      : constant Name_Id := N + 323;\n+   Name_UBA                            : constant Name_Id := N + 324;\n+   Name_UBS                            : constant Name_Id := N + 325;\n+   Name_UBSB                           : constant Name_Id := N + 326;\n+   Name_Unit_Name                      : constant Name_Id := N + 327;\n+   Name_Unknown                        : constant Name_Id := N + 328;\n+   Name_Unrestricted                   : constant Name_Id := N + 329;\n+   Name_Uppercase                      : constant Name_Id := N + 330;\n+   Name_User                           : constant Name_Id := N + 331;\n+   Name_VAX_Float                      : constant Name_Id := N + 332;\n+   Name_VMS                            : constant Name_Id := N + 333;\n+   Name_Working_Storage                : constant Name_Id := N + 334;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -602,376 +603,376 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 334;\n-   Name_Abort_Signal                   : constant Name_Id := N + 334;  -- GNAT\n-   Name_Access                         : constant Name_Id := N + 335;\n-   Name_Address                        : constant Name_Id := N + 336;\n-   Name_Address_Size                   : constant Name_Id := N + 337;  -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 338;\n-   Name_Alignment                      : constant Name_Id := N + 339;\n-   Name_Asm_Input                      : constant Name_Id := N + 340;  -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 341;  -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 342;  -- VMS\n-   Name_Bit                            : constant Name_Id := N + 343;  -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 344;\n-   Name_Bit_Position                   : constant Name_Id := N + 345;  -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 346;\n-   Name_Callable                       : constant Name_Id := N + 347;\n-   Name_Caller                         : constant Name_Id := N + 348;\n-   Name_Code_Address                   : constant Name_Id := N + 349;  -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 350;\n-   Name_Compose                        : constant Name_Id := N + 351;\n-   Name_Constrained                    : constant Name_Id := N + 352;\n-   Name_Count                          : constant Name_Id := N + 353;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 354; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 355;\n-   Name_Delta                          : constant Name_Id := N + 356;\n-   Name_Denorm                         : constant Name_Id := N + 357;\n-   Name_Digits                         : constant Name_Id := N + 358;\n-   Name_Elaborated                     : constant Name_Id := N + 359; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 360; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 361; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 362; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 363;\n-   Name_External_Tag                   : constant Name_Id := N + 364;\n-   Name_First                          : constant Name_Id := N + 365;\n-   Name_First_Bit                      : constant Name_Id := N + 366;\n-   Name_Fixed_Value                    : constant Name_Id := N + 367; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 368;\n-   Name_Has_Access_Values              : constant Name_Id := N + 369; -- GNAT\n-   Name_Has_Discriminants              : constant Name_Id := N + 370; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 371;\n-   Name_Img                            : constant Name_Id := N + 372; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 373; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 374; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 375;\n-   Name_Last_Bit                       : constant Name_Id := N + 376;\n-   Name_Leading_Part                   : constant Name_Id := N + 377;\n-   Name_Length                         : constant Name_Id := N + 378;\n-   Name_Machine_Emax                   : constant Name_Id := N + 379;\n-   Name_Machine_Emin                   : constant Name_Id := N + 380;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 381;\n-   Name_Machine_Overflows              : constant Name_Id := N + 382;\n-   Name_Machine_Radix                  : constant Name_Id := N + 383;\n-   Name_Machine_Rounds                 : constant Name_Id := N + 384;\n-   Name_Machine_Size                   : constant Name_Id := N + 385; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 386; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 387;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 388; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 389; -- GNAT\n-   Name_Model_Emin                     : constant Name_Id := N + 390;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 391;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 392;\n-   Name_Model_Small                    : constant Name_Id := N + 393;\n-   Name_Modulus                        : constant Name_Id := N + 394;\n-   Name_Null_Parameter                 : constant Name_Id := N + 395; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 396; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 397;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 398; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 399;\n-   Name_Pos                            : constant Name_Id := N + 400;\n-   Name_Position                       : constant Name_Id := N + 401;\n-   Name_Range                          : constant Name_Id := N + 402;\n-   Name_Range_Length                   : constant Name_Id := N + 403; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 404;\n-   Name_Safe_Emax                      : constant Name_Id := N + 405; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 406;\n-   Name_Safe_Large                     : constant Name_Id := N + 407; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 408;\n-   Name_Safe_Small                     : constant Name_Id := N + 409; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 410;\n-   Name_Scaling                        : constant Name_Id := N + 411;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 412;\n-   Name_Size                           : constant Name_Id := N + 413;\n-   Name_Small                          : constant Name_Id := N + 414;\n-   Name_Storage_Size                   : constant Name_Id := N + 415;\n-   Name_Storage_Unit                   : constant Name_Id := N + 416; -- GNAT\n-   Name_Tag                            : constant Name_Id := N + 417;\n-   Name_Target_Name                    : constant Name_Id := N + 418; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 419;\n-   Name_To_Address                     : constant Name_Id := N + 420; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 421; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 422; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 423;\n-   Name_Unchecked_Access               : constant Name_Id := N + 424;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 425;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 426; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 427; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 428; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 429;\n-   Name_Valid                          : constant Name_Id := N + 430;\n-   Name_Value_Size                     : constant Name_Id := N + 431; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 432;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 433; -- GNAT\n-   Name_Wide_Width                     : constant Name_Id := N + 434;\n-   Name_Width                          : constant Name_Id := N + 435;\n-   Name_Word_Size                      : constant Name_Id := N + 436; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 335;\n+   Name_Abort_Signal                   : constant Name_Id := N + 335;  -- GNAT\n+   Name_Access                         : constant Name_Id := N + 336;\n+   Name_Address                        : constant Name_Id := N + 337;\n+   Name_Address_Size                   : constant Name_Id := N + 338;  -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 339;\n+   Name_Alignment                      : constant Name_Id := N + 340;\n+   Name_Asm_Input                      : constant Name_Id := N + 341;  -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 342;  -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 343;  -- VMS\n+   Name_Bit                            : constant Name_Id := N + 344;  -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 345;\n+   Name_Bit_Position                   : constant Name_Id := N + 346;  -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 347;\n+   Name_Callable                       : constant Name_Id := N + 348;\n+   Name_Caller                         : constant Name_Id := N + 349;\n+   Name_Code_Address                   : constant Name_Id := N + 350;  -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 351;\n+   Name_Compose                        : constant Name_Id := N + 352;\n+   Name_Constrained                    : constant Name_Id := N + 353;\n+   Name_Count                          : constant Name_Id := N + 354;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 355; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 356;\n+   Name_Delta                          : constant Name_Id := N + 357;\n+   Name_Denorm                         : constant Name_Id := N + 358;\n+   Name_Digits                         : constant Name_Id := N + 359;\n+   Name_Elaborated                     : constant Name_Id := N + 360; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 361; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 362; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 363; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 364;\n+   Name_External_Tag                   : constant Name_Id := N + 365;\n+   Name_First                          : constant Name_Id := N + 366;\n+   Name_First_Bit                      : constant Name_Id := N + 367;\n+   Name_Fixed_Value                    : constant Name_Id := N + 368; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 369;\n+   Name_Has_Access_Values              : constant Name_Id := N + 370; -- GNAT\n+   Name_Has_Discriminants              : constant Name_Id := N + 371; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 372;\n+   Name_Img                            : constant Name_Id := N + 373; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 374; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 375; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 376;\n+   Name_Last_Bit                       : constant Name_Id := N + 377;\n+   Name_Leading_Part                   : constant Name_Id := N + 378;\n+   Name_Length                         : constant Name_Id := N + 379;\n+   Name_Machine_Emax                   : constant Name_Id := N + 380;\n+   Name_Machine_Emin                   : constant Name_Id := N + 381;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 382;\n+   Name_Machine_Overflows              : constant Name_Id := N + 383;\n+   Name_Machine_Radix                  : constant Name_Id := N + 384;\n+   Name_Machine_Rounds                 : constant Name_Id := N + 385;\n+   Name_Machine_Size                   : constant Name_Id := N + 386; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 387; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 388;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 389; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 390; -- GNAT\n+   Name_Model_Emin                     : constant Name_Id := N + 391;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 392;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 393;\n+   Name_Model_Small                    : constant Name_Id := N + 394;\n+   Name_Modulus                        : constant Name_Id := N + 395;\n+   Name_Null_Parameter                 : constant Name_Id := N + 396; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 397; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 398;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 399; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 400;\n+   Name_Pos                            : constant Name_Id := N + 401;\n+   Name_Position                       : constant Name_Id := N + 402;\n+   Name_Range                          : constant Name_Id := N + 403;\n+   Name_Range_Length                   : constant Name_Id := N + 404; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 405;\n+   Name_Safe_Emax                      : constant Name_Id := N + 406; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 407;\n+   Name_Safe_Large                     : constant Name_Id := N + 408; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 409;\n+   Name_Safe_Small                     : constant Name_Id := N + 410; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 411;\n+   Name_Scaling                        : constant Name_Id := N + 412;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 413;\n+   Name_Size                           : constant Name_Id := N + 414;\n+   Name_Small                          : constant Name_Id := N + 415;\n+   Name_Storage_Size                   : constant Name_Id := N + 416;\n+   Name_Storage_Unit                   : constant Name_Id := N + 417; -- GNAT\n+   Name_Tag                            : constant Name_Id := N + 418;\n+   Name_Target_Name                    : constant Name_Id := N + 419; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 420;\n+   Name_To_Address                     : constant Name_Id := N + 421; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 422; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 423; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 424;\n+   Name_Unchecked_Access               : constant Name_Id := N + 425;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 426;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 427; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 428; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 429; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 430;\n+   Name_Valid                          : constant Name_Id := N + 431;\n+   Name_Value_Size                     : constant Name_Id := N + 432; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 433;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 434; -- GNAT\n+   Name_Wide_Width                     : constant Name_Id := N + 435;\n+   Name_Width                          : constant Name_Id := N + 436;\n+   Name_Word_Size                      : constant Name_Id := N + 437; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 437;\n-   Name_Adjacent                       : constant Name_Id := N + 437;\n-   Name_Ceiling                        : constant Name_Id := N + 438;\n-   Name_Copy_Sign                      : constant Name_Id := N + 439;\n-   Name_Floor                          : constant Name_Id := N + 440;\n-   Name_Fraction                       : constant Name_Id := N + 441;\n-   Name_Image                          : constant Name_Id := N + 442;\n-   Name_Input                          : constant Name_Id := N + 443;\n-   Name_Machine                        : constant Name_Id := N + 444;\n-   Name_Max                            : constant Name_Id := N + 445;\n-   Name_Min                            : constant Name_Id := N + 446;\n-   Name_Model                          : constant Name_Id := N + 447;\n-   Name_Pred                           : constant Name_Id := N + 448;\n-   Name_Remainder                      : constant Name_Id := N + 449;\n-   Name_Rounding                       : constant Name_Id := N + 450;\n-   Name_Succ                           : constant Name_Id := N + 451;\n-   Name_Truncation                     : constant Name_Id := N + 452;\n-   Name_Value                          : constant Name_Id := N + 453;\n-   Name_Wide_Image                     : constant Name_Id := N + 454;\n-   Name_Wide_Value                     : constant Name_Id := N + 455;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 455;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 438;\n+   Name_Adjacent                       : constant Name_Id := N + 438;\n+   Name_Ceiling                        : constant Name_Id := N + 439;\n+   Name_Copy_Sign                      : constant Name_Id := N + 440;\n+   Name_Floor                          : constant Name_Id := N + 441;\n+   Name_Fraction                       : constant Name_Id := N + 442;\n+   Name_Image                          : constant Name_Id := N + 443;\n+   Name_Input                          : constant Name_Id := N + 444;\n+   Name_Machine                        : constant Name_Id := N + 445;\n+   Name_Max                            : constant Name_Id := N + 446;\n+   Name_Min                            : constant Name_Id := N + 447;\n+   Name_Model                          : constant Name_Id := N + 448;\n+   Name_Pred                           : constant Name_Id := N + 449;\n+   Name_Remainder                      : constant Name_Id := N + 450;\n+   Name_Rounding                       : constant Name_Id := N + 451;\n+   Name_Succ                           : constant Name_Id := N + 452;\n+   Name_Truncation                     : constant Name_Id := N + 453;\n+   Name_Value                          : constant Name_Id := N + 454;\n+   Name_Wide_Image                     : constant Name_Id := N + 455;\n+   Name_Wide_Value                     : constant Name_Id := N + 456;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 456;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 456;\n-   Name_Output                         : constant Name_Id := N + 456;\n-   Name_Read                           : constant Name_Id := N + 457;\n-   Name_Write                          : constant Name_Id := N + 458;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 458;\n+   First_Procedure_Attribute           : constant Name_Id := N + 457;\n+   Name_Output                         : constant Name_Id := N + 457;\n+   Name_Read                           : constant Name_Id := N + 458;\n+   Name_Write                          : constant Name_Id := N + 459;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 459;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 459;\n-   Name_Elab_Body                      : constant Name_Id := N + 459; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 460; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 461;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 460;\n+   Name_Elab_Body                      : constant Name_Id := N + 460; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 461; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 462;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 462;\n-   Name_Base                           : constant Name_Id := N + 462;\n-   Name_Class                          : constant Name_Id := N + 463;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 463;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 463;\n-   Last_Attribute_Name                 : constant Name_Id := N + 463;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 463;\n+   Name_Base                           : constant Name_Id := N + 463;\n+   Name_Class                          : constant Name_Id := N + 464;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 464;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 464;\n+   Last_Attribute_Name                 : constant Name_Id := N + 464;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 464;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 464;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 465;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 465;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 465;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 465;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 466;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 466;\n \n    --  Names of recognized queuing policy identifiers.\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 466;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 466;\n-   Name_Priority_Queuing               : constant Name_Id := N + 467;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 467;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 467;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 467;\n+   Name_Priority_Queuing               : constant Name_Id := N + 468;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 468;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_WIthinn_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 468;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 468;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 468;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 469;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 469;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 469;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 469;\n-   Name_Access_Check                   : constant Name_Id := N + 469;\n-   Name_Accessibility_Check            : constant Name_Id := N + 470;\n-   Name_Discriminant_Check             : constant Name_Id := N + 471;\n-   Name_Division_Check                 : constant Name_Id := N + 472;\n-   Name_Elaboration_Check              : constant Name_Id := N + 473;\n-   Name_Index_Check                    : constant Name_Id := N + 474;\n-   Name_Length_Check                   : constant Name_Id := N + 475;\n-   Name_Overflow_Check                 : constant Name_Id := N + 476;\n-   Name_Range_Check                    : constant Name_Id := N + 477;\n-   Name_Storage_Check                  : constant Name_Id := N + 478;\n-   Name_Tag_Check                      : constant Name_Id := N + 479;\n-   Name_All_Checks                     : constant Name_Id := N + 480;\n-   Last_Check_Name                     : constant Name_Id := N + 480;\n+   First_Check_Name                    : constant Name_Id := N + 470;\n+   Name_Access_Check                   : constant Name_Id := N + 470;\n+   Name_Accessibility_Check            : constant Name_Id := N + 471;\n+   Name_Discriminant_Check             : constant Name_Id := N + 472;\n+   Name_Division_Check                 : constant Name_Id := N + 473;\n+   Name_Elaboration_Check              : constant Name_Id := N + 474;\n+   Name_Index_Check                    : constant Name_Id := N + 475;\n+   Name_Length_Check                   : constant Name_Id := N + 476;\n+   Name_Overflow_Check                 : constant Name_Id := N + 477;\n+   Name_Range_Check                    : constant Name_Id := N + 478;\n+   Name_Storage_Check                  : constant Name_Id := N + 479;\n+   Name_Tag_Check                      : constant Name_Id := N + 480;\n+   Name_All_Checks                     : constant Name_Id := N + 481;\n+   Last_Check_Name                     : constant Name_Id := N + 481;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 481;\n-   Name_Abs                            : constant Name_Id := N + 482;\n-   Name_Accept                         : constant Name_Id := N + 483;\n-   Name_And                            : constant Name_Id := N + 484;\n-   Name_All                            : constant Name_Id := N + 485;\n-   Name_Array                          : constant Name_Id := N + 486;\n-   Name_At                             : constant Name_Id := N + 487;\n-   Name_Begin                          : constant Name_Id := N + 488;\n-   Name_Body                           : constant Name_Id := N + 489;\n-   Name_Case                           : constant Name_Id := N + 490;\n-   Name_Constant                       : constant Name_Id := N + 491;\n-   Name_Declare                        : constant Name_Id := N + 492;\n-   Name_Delay                          : constant Name_Id := N + 493;\n-   Name_Do                             : constant Name_Id := N + 494;\n-   Name_Else                           : constant Name_Id := N + 495;\n-   Name_Elsif                          : constant Name_Id := N + 496;\n-   Name_End                            : constant Name_Id := N + 497;\n-   Name_Entry                          : constant Name_Id := N + 498;\n-   Name_Exception                      : constant Name_Id := N + 499;\n-   Name_Exit                           : constant Name_Id := N + 500;\n-   Name_For                            : constant Name_Id := N + 501;\n-   Name_Function                       : constant Name_Id := N + 502;\n-   Name_Generic                        : constant Name_Id := N + 503;\n-   Name_Goto                           : constant Name_Id := N + 504;\n-   Name_If                             : constant Name_Id := N + 505;\n-   Name_In                             : constant Name_Id := N + 506;\n-   Name_Is                             : constant Name_Id := N + 507;\n-   Name_Limited                        : constant Name_Id := N + 508;\n-   Name_Loop                           : constant Name_Id := N + 509;\n-   Name_Mod                            : constant Name_Id := N + 510;\n-   Name_New                            : constant Name_Id := N + 511;\n-   Name_Not                            : constant Name_Id := N + 512;\n-   Name_Null                           : constant Name_Id := N + 513;\n-   Name_Of                             : constant Name_Id := N + 514;\n-   Name_Or                             : constant Name_Id := N + 515;\n-   Name_Others                         : constant Name_Id := N + 516;\n-   Name_Out                            : constant Name_Id := N + 517;\n-   Name_Package                        : constant Name_Id := N + 518;\n-   Name_Pragma                         : constant Name_Id := N + 519;\n-   Name_Private                        : constant Name_Id := N + 520;\n-   Name_Procedure                      : constant Name_Id := N + 521;\n-   Name_Raise                          : constant Name_Id := N + 522;\n-   Name_Record                         : constant Name_Id := N + 523;\n-   Name_Rem                            : constant Name_Id := N + 524;\n-   Name_Renames                        : constant Name_Id := N + 525;\n-   Name_Return                         : constant Name_Id := N + 526;\n-   Name_Reverse                        : constant Name_Id := N + 527;\n-   Name_Select                         : constant Name_Id := N + 528;\n-   Name_Separate                       : constant Name_Id := N + 529;\n-   Name_Subtype                        : constant Name_Id := N + 530;\n-   Name_Task                           : constant Name_Id := N + 531;\n-   Name_Terminate                      : constant Name_Id := N + 532;\n-   Name_Then                           : constant Name_Id := N + 533;\n-   Name_Type                           : constant Name_Id := N + 534;\n-   Name_Use                            : constant Name_Id := N + 535;\n-   Name_When                           : constant Name_Id := N + 536;\n-   Name_While                          : constant Name_Id := N + 537;\n-   Name_With                           : constant Name_Id := N + 538;\n-   Name_Xor                            : constant Name_Id := N + 539;\n+   Name_Abort                          : constant Name_Id := N + 482;\n+   Name_Abs                            : constant Name_Id := N + 483;\n+   Name_Accept                         : constant Name_Id := N + 484;\n+   Name_And                            : constant Name_Id := N + 485;\n+   Name_All                            : constant Name_Id := N + 486;\n+   Name_Array                          : constant Name_Id := N + 487;\n+   Name_At                             : constant Name_Id := N + 488;\n+   Name_Begin                          : constant Name_Id := N + 489;\n+   Name_Body                           : constant Name_Id := N + 490;\n+   Name_Case                           : constant Name_Id := N + 491;\n+   Name_Constant                       : constant Name_Id := N + 492;\n+   Name_Declare                        : constant Name_Id := N + 493;\n+   Name_Delay                          : constant Name_Id := N + 494;\n+   Name_Do                             : constant Name_Id := N + 495;\n+   Name_Else                           : constant Name_Id := N + 496;\n+   Name_Elsif                          : constant Name_Id := N + 497;\n+   Name_End                            : constant Name_Id := N + 498;\n+   Name_Entry                          : constant Name_Id := N + 499;\n+   Name_Exception                      : constant Name_Id := N + 500;\n+   Name_Exit                           : constant Name_Id := N + 501;\n+   Name_For                            : constant Name_Id := N + 502;\n+   Name_Function                       : constant Name_Id := N + 503;\n+   Name_Generic                        : constant Name_Id := N + 504;\n+   Name_Goto                           : constant Name_Id := N + 505;\n+   Name_If                             : constant Name_Id := N + 506;\n+   Name_In                             : constant Name_Id := N + 507;\n+   Name_Is                             : constant Name_Id := N + 508;\n+   Name_Limited                        : constant Name_Id := N + 509;\n+   Name_Loop                           : constant Name_Id := N + 510;\n+   Name_Mod                            : constant Name_Id := N + 511;\n+   Name_New                            : constant Name_Id := N + 512;\n+   Name_Not                            : constant Name_Id := N + 513;\n+   Name_Null                           : constant Name_Id := N + 514;\n+   Name_Of                             : constant Name_Id := N + 515;\n+   Name_Or                             : constant Name_Id := N + 516;\n+   Name_Others                         : constant Name_Id := N + 517;\n+   Name_Out                            : constant Name_Id := N + 518;\n+   Name_Package                        : constant Name_Id := N + 519;\n+   Name_Pragma                         : constant Name_Id := N + 520;\n+   Name_Private                        : constant Name_Id := N + 521;\n+   Name_Procedure                      : constant Name_Id := N + 522;\n+   Name_Raise                          : constant Name_Id := N + 523;\n+   Name_Record                         : constant Name_Id := N + 524;\n+   Name_Rem                            : constant Name_Id := N + 525;\n+   Name_Renames                        : constant Name_Id := N + 526;\n+   Name_Return                         : constant Name_Id := N + 527;\n+   Name_Reverse                        : constant Name_Id := N + 528;\n+   Name_Select                         : constant Name_Id := N + 529;\n+   Name_Separate                       : constant Name_Id := N + 530;\n+   Name_Subtype                        : constant Name_Id := N + 531;\n+   Name_Task                           : constant Name_Id := N + 532;\n+   Name_Terminate                      : constant Name_Id := N + 533;\n+   Name_Then                           : constant Name_Id := N + 534;\n+   Name_Type                           : constant Name_Id := N + 535;\n+   Name_Use                            : constant Name_Id := N + 536;\n+   Name_When                           : constant Name_Id := N + 537;\n+   Name_While                          : constant Name_Id := N + 538;\n+   Name_With                           : constant Name_Id := N + 539;\n+   Name_Xor                            : constant Name_Id := N + 540;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                : constant Name_Id := N + 540;\n-   Name_Divide                         : constant Name_Id := N + 540;\n-   Name_Enclosing_Entity               : constant Name_Id := N + 541;\n-   Name_Exception_Information          : constant Name_Id := N + 542;\n-   Name_Exception_Message              : constant Name_Id := N + 543;\n-   Name_Exception_Name                 : constant Name_Id := N + 544;\n-   Name_File                           : constant Name_Id := N + 545;\n-   Name_Import_Address                 : constant Name_Id := N + 546;\n-   Name_Import_Largest_Value           : constant Name_Id := N + 547;\n-   Name_Import_Value                   : constant Name_Id := N + 548;\n-   Name_Is_Negative                    : constant Name_Id := N + 549;\n-   Name_Line                           : constant Name_Id := N + 550;\n-   Name_Rotate_Left                    : constant Name_Id := N + 551;\n-   Name_Rotate_Right                   : constant Name_Id := N + 552;\n-   Name_Shift_Left                     : constant Name_Id := N + 553;\n-   Name_Shift_Right                    : constant Name_Id := N + 554;\n-   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 555;\n-   Name_Source_Location                : constant Name_Id := N + 556;\n-   Name_Unchecked_Conversion           : constant Name_Id := N + 557;\n-   Name_Unchecked_Deallocation         : constant Name_Id := N + 558;\n-   Name_To_Pointer                     : constant Name_Id := N + 559;\n-   Last_Intrinsic_Name                 : constant Name_Id := N + 559;\n+   First_Intrinsic_Name                : constant Name_Id := N + 541;\n+   Name_Divide                         : constant Name_Id := N + 541;\n+   Name_Enclosing_Entity               : constant Name_Id := N + 542;\n+   Name_Exception_Information          : constant Name_Id := N + 543;\n+   Name_Exception_Message              : constant Name_Id := N + 544;\n+   Name_Exception_Name                 : constant Name_Id := N + 545;\n+   Name_File                           : constant Name_Id := N + 546;\n+   Name_Import_Address                 : constant Name_Id := N + 547;\n+   Name_Import_Largest_Value           : constant Name_Id := N + 548;\n+   Name_Import_Value                   : constant Name_Id := N + 549;\n+   Name_Is_Negative                    : constant Name_Id := N + 550;\n+   Name_Line                           : constant Name_Id := N + 551;\n+   Name_Rotate_Left                    : constant Name_Id := N + 552;\n+   Name_Rotate_Right                   : constant Name_Id := N + 553;\n+   Name_Shift_Left                     : constant Name_Id := N + 554;\n+   Name_Shift_Right                    : constant Name_Id := N + 555;\n+   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 556;\n+   Name_Source_Location                : constant Name_Id := N + 557;\n+   Name_Unchecked_Conversion           : constant Name_Id := N + 558;\n+   Name_Unchecked_Deallocation         : constant Name_Id := N + 559;\n+   Name_To_Pointer                     : constant Name_Id := N + 560;\n+   Last_Intrinsic_Name                 : constant Name_Id := N + 560;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 560;\n-   Name_Abstract                       : constant Name_Id := N + 560;\n-   Name_Aliased                        : constant Name_Id := N + 561;\n-   Name_Protected                      : constant Name_Id := N + 562;\n-   Name_Until                          : constant Name_Id := N + 563;\n-   Name_Requeue                        : constant Name_Id := N + 564;\n-   Name_Tagged                         : constant Name_Id := N + 565;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 565;\n+   First_95_Reserved_Word              : constant Name_Id := N + 561;\n+   Name_Abstract                       : constant Name_Id := N + 561;\n+   Name_Aliased                        : constant Name_Id := N + 562;\n+   Name_Protected                      : constant Name_Id := N + 563;\n+   Name_Until                          : constant Name_Id := N + 564;\n+   Name_Requeue                        : constant Name_Id := N + 565;\n+   Name_Tagged                         : constant Name_Id := N + 566;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 566;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 566;\n+   Name_Raise_Exception                : constant Name_Id := N + 567;\n \n    --  Additional reserved words in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Binder                         : constant Name_Id := N + 567;\n-   Name_Body_Suffix                    : constant Name_Id := N + 568;\n-   Name_Builder                        : constant Name_Id := N + 569;\n-   Name_Compiler                       : constant Name_Id := N + 570;\n-   Name_Cross_Reference                : constant Name_Id := N + 571;\n-   Name_Default_Switches               : constant Name_Id := N + 572;\n-   Name_Exec_Dir                       : constant Name_Id := N + 573;\n-   Name_Executable                     : constant Name_Id := N + 574;\n-   Name_Executable_Suffix              : constant Name_Id := N + 575;\n-   Name_Extends                        : constant Name_Id := N + 576;\n-   Name_Finder                         : constant Name_Id := N + 577;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 578;\n-   Name_Gnatls                         : constant Name_Id := N + 579;\n-   Name_Gnatstub                       : constant Name_Id := N + 580;\n-   Name_Implementation                 : constant Name_Id := N + 581;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 582;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 583;\n-   Name_Languages                      : constant Name_Id := N + 584;\n-   Name_Library_Dir                    : constant Name_Id := N + 585;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 586;\n-   Name_Library_GCC                    : constant Name_Id := N + 587;\n-   Name_Library_Interface              : constant Name_Id := N + 588;\n-   Name_Library_Kind                   : constant Name_Id := N + 589;\n-   Name_Library_Name                   : constant Name_Id := N + 590;\n-   Name_Library_Options                : constant Name_Id := N + 591;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 592;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 593;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 594;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 595;\n-   Name_Library_Version                : constant Name_Id := N + 596;\n-   Name_Linker                         : constant Name_Id := N + 597;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 598;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 599;\n-   Name_Metrics                        : constant Name_Id := N + 600;\n-   Name_Naming                         : constant Name_Id := N + 601;\n-   Name_Object_Dir                     : constant Name_Id := N + 602;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 603;\n-   Name_Project                        : constant Name_Id := N + 604;\n-   Name_Separate_Suffix                : constant Name_Id := N + 605;\n-   Name_Source_Dirs                    : constant Name_Id := N + 606;\n-   Name_Source_Files                   : constant Name_Id := N + 607;\n-   Name_Source_List_File               : constant Name_Id := N + 608;\n-   Name_Spec                           : constant Name_Id := N + 609;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 610;\n-   Name_Specification                  : constant Name_Id := N + 611;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 612;\n-   Name_Specification_Suffix           : constant Name_Id := N + 613;\n-   Name_Switches                       : constant Name_Id := N + 614;\n+   Name_Binder                         : constant Name_Id := N + 568;\n+   Name_Body_Suffix                    : constant Name_Id := N + 569;\n+   Name_Builder                        : constant Name_Id := N + 570;\n+   Name_Compiler                       : constant Name_Id := N + 571;\n+   Name_Cross_Reference                : constant Name_Id := N + 572;\n+   Name_Default_Switches               : constant Name_Id := N + 573;\n+   Name_Exec_Dir                       : constant Name_Id := N + 574;\n+   Name_Executable                     : constant Name_Id := N + 575;\n+   Name_Executable_Suffix              : constant Name_Id := N + 576;\n+   Name_Extends                        : constant Name_Id := N + 577;\n+   Name_Finder                         : constant Name_Id := N + 578;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 579;\n+   Name_Gnatls                         : constant Name_Id := N + 580;\n+   Name_Gnatstub                       : constant Name_Id := N + 581;\n+   Name_Implementation                 : constant Name_Id := N + 582;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 583;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 584;\n+   Name_Languages                      : constant Name_Id := N + 585;\n+   Name_Library_Dir                    : constant Name_Id := N + 586;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 587;\n+   Name_Library_GCC                    : constant Name_Id := N + 588;\n+   Name_Library_Interface              : constant Name_Id := N + 589;\n+   Name_Library_Kind                   : constant Name_Id := N + 590;\n+   Name_Library_Name                   : constant Name_Id := N + 591;\n+   Name_Library_Options                : constant Name_Id := N + 592;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 593;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 594;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 595;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 596;\n+   Name_Library_Version                : constant Name_Id := N + 597;\n+   Name_Linker                         : constant Name_Id := N + 598;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 599;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 600;\n+   Name_Metrics                        : constant Name_Id := N + 601;\n+   Name_Naming                         : constant Name_Id := N + 602;\n+   Name_Object_Dir                     : constant Name_Id := N + 603;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 604;\n+   Name_Project                        : constant Name_Id := N + 605;\n+   Name_Separate_Suffix                : constant Name_Id := N + 606;\n+   Name_Source_Dirs                    : constant Name_Id := N + 607;\n+   Name_Source_Files                   : constant Name_Id := N + 608;\n+   Name_Source_List_File               : constant Name_Id := N + 609;\n+   Name_Spec                           : constant Name_Id := N + 610;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 611;\n+   Name_Specification                  : constant Name_Id := N + 612;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 613;\n+   Name_Specification_Suffix           : constant Name_Id := N + 614;\n+   Name_Switches                       : constant Name_Id := N + 615;\n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 615;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 616;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 615;\n+   Last_Predefined_Name                : constant Name_Id := N + 616;\n \n    subtype Any_Operator_Name is Name_Id range\n      First_Operator_Name .. Last_Operator_Name;"}, {"sha": "2daefa3a5520c9fa65a2c9236a60a557e88be335", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523456dbde953a6f2dac504b2fd2ff1ddc8ec03d/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=523456dbde953a6f2dac504b2fd2ff1ddc8ec03d", "patch": "@@ -774,7 +774,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n     case ARRAY_RANGE_REF:\n \n       /* First convert the right operand to its base type.  This will\n-\t prevent unneed signedness conversions when sizetype is wider than\n+\t prevent unneeded signedness conversions when sizetype is wider than\n \t integer.  */\n       right_operand = convert (right_base_type, right_operand);\n       right_operand = convert (TYPE_DOMAIN (left_type), right_operand);"}]}