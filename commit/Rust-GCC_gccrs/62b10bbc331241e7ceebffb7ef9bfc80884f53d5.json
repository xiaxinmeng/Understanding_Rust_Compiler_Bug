{"sha": "62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJiMTBiYmMzMzEyNDFlN2NlZWJmZmI3ZWY5YmZjODA4ODRmNTNkNQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-07-05T08:44:36Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-07-05T08:44:36Z"}, "message": "Add preliminary support for arm v5 architectures.\n\nFrom-SVN: r27944", "tree": {"sha": "e23b7de44adbdbdef1adab420a4cb75426a26a14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e23b7de44adbdbdef1adab420a4cb75426a26a14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/comments", "author": null, "committer": null, "parents": [{"sha": "32bebc4399ed6f3e721b0e81c29ef0f424aa138e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32bebc4399ed6f3e721b0e81c29ef0f424aa138e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32bebc4399ed6f3e721b0e81c29ef0f424aa138e"}], "stats": {"total": 947, "additions": 531, "deletions": 416}, "files": [{"sha": "ca5086d69b067573e90aa6c55e1f041805780ffd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "patch": "@@ -1,3 +1,25 @@\n+Fri Jul  2 18:49:51 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\tAdd framework to support armv5 architecture when it becomes\n+\tavailable: \n+\t\n+\t* config/arm/arm.c (FL_ARCH5): New processor capability flag.\n+\t(arm_arch5): New variable.\n+\t(all_architectures): Add armv5 line.\n+\t* config/arm/arm.h (CPP_CPU_ARCH_SPEC): Define __ARM_ARCH_5__ if\n+\t-march=armv5 is specified on the command line.\n+\t(arm_arch5): Export this variable.\n+\t* invoke.texi: Document new string accepted by -march= switch for\n+\tARM ports.\n+\n+\t* config/arm/arm.h: Replace use of constant 12 as a register\n+\tnumber with IP_REGNUM.  Similarly 14 and LR_REGNUM.\n+\t* config/arm/arm.c: Replace use of constant 12 as a register\n+\tnumber with IP_REGNUM.  Similarly 14 and LR_REGNUM.\n+\n+\t* config/arm/elf.h: Tidy up.\n+\t* config/arm/coff.h: Tidy up.\n+\t\n Thu Jul  1 19:08:13 1999  Mark P. Mitchell  <mark@codesourcery.com>\n \n \t* gcc/configure.in (mips-sgi-irix6*): Handle --with-gnu-ld."}, {"sha": "be1fa62dd5a55dbb944928317a4f2603fdf3c20d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 150, "deletions": 134, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "patch": "@@ -94,14 +94,15 @@ const char * structure_size_string = NULL;\n int    arm_structure_size_boundary = 32; /* Used to be 8 */\n \n /* Bit values used to identify processor capabilities.  */\n-#define FL_CO_PROC    0x01            /* Has external co-processor bus */\n-#define FL_FAST_MULT  0x02            /* Fast multiply */\n-#define FL_MODE26     0x04            /* 26-bit mode support */\n-#define FL_MODE32     0x08            /* 32-bit mode support */\n-#define FL_ARCH4      0x10            /* Architecture rel 4 */\n-#define FL_THUMB      0x20            /* Thumb aware */\n-#define FL_LDSCHED    0x40\t      /* Load scheduling necessary */\n-#define FL_STRONG     0x80\t      /* StrongARM */\n+#define FL_CO_PROC    (1 << 0)        /* Has external co-processor bus */\n+#define FL_FAST_MULT  (1 << 1)        /* Fast multiply */\n+#define FL_MODE26     (1 << 2)        /* 26-bit mode support */\n+#define FL_MODE32     (1 << 3)        /* 32-bit mode support */\n+#define FL_ARCH4      (1 << 4)        /* Architecture rel 4 */\n+#define FL_ARCH5      (1 << 5)        /* Architecture rel 5 */\n+#define FL_THUMB      (1 << 6)        /* Thumb aware */\n+#define FL_LDSCHED    (1 << 7)\t      /* Load scheduling necessary */\n+#define FL_STRONG     (1 << 8)\t      /* StrongARM */\n \n /* The bits in this mask specify which instructions we are allowed to generate.  */\n static int insn_flags = 0;\n@@ -120,6 +121,9 @@ int arm_fast_multiply = 0;\n /* Nonzero if this chip supports the ARM Architecture 4 extensions */\n int arm_arch4 = 0;\n \n+/* Nonzero if this chip supports the ARM Architecture 5 extensions */\n+int arm_arch5 = 0;\n+\n /* Nonzero if this chip can benefit from load scheduling.  */\n int arm_ld_sched = 0;\n \n@@ -229,15 +233,16 @@ static struct processors all_architectures[] =\n {\n   /* ARM Architectures */\n   \n-  {\"armv2\",     FL_CO_PROC | FL_MODE26 },\n-  {\"armv2a\",    FL_CO_PROC | FL_MODE26 },\n-  {\"armv3\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 },\n-  {\"armv3m\",    FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n-  {\"armv4\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4  },\n+  { \"armv2\",     FL_CO_PROC | FL_MODE26 },\n+  { \"armv2a\",    FL_CO_PROC | FL_MODE26 },\n+  { \"armv3\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 },\n+  { \"armv3m\",    FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT },\n+  { \"armv4\",     FL_CO_PROC | FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4  },\n   /* Strictly, FL_MODE26 is a permitted option for v4t, but there are no\n      implementations that support it, so we will leave it out for now.  */\n-  {\"armv4t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n-  {NULL, 0}\n+  { \"armv4t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n+  { \"armv5\",     FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n+  { NULL, 0 }\n };\n \n /* This is a magic stucture.  The 'string' field is magically filled in\n@@ -494,6 +499,7 @@ arm_override_options ()\n   /* Initialise boolean versions of the flags, for use in the arm.md file.  */\n   arm_fast_multiply = insn_flags & FL_FAST_MULT;\n   arm_arch4         = insn_flags & FL_ARCH4;\n+  arm_arch5         = insn_flags & FL_ARCH5;\n   \n   arm_ld_sched      = tune_flags & FL_LDSCHED;\n   arm_is_strong     = tune_flags & FL_STRONG;\n@@ -1279,7 +1285,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n enum rtx_code\n arm_canonicalize_comparison (code, op1)\n      enum rtx_code code;\n-     rtx *op1;\n+     rtx * op1;\n {\n   unsigned HOST_WIDE_INT i = INTVAL (*op1);\n \n@@ -1538,7 +1544,7 @@ legitimize_pic_address (orig, mode, reg)\n static rtx pic_rtx;\n \n int\n-is_pic(x)\n+is_pic (x)\n      rtx x;\n {\n   if (x == pic_rtx)\n@@ -1876,7 +1882,8 @@ arm_adjust_cost (insn, link, dep, cost)\n \n static int fpa_consts_inited = 0;\n \n-char *strings_fpa[8] = {\n+char * strings_fpa[8] =\n+{\n   \"0\",   \"1\",   \"2\",   \"3\",\n   \"4\",   \"5\",   \"0.5\", \"10\"\n };\n@@ -2401,7 +2408,7 @@ int\n symbol_mentioned_p (x)\n      rtx x;\n {\n-  register char *fmt;\n+  register char * fmt;\n   register int i;\n \n   if (GET_CODE (x) == SYMBOL_REF)\n@@ -2430,7 +2437,7 @@ int\n label_mentioned_p (x)\n      rtx x;\n {\n-  register char *fmt;\n+  register char * fmt;\n   register int i;\n \n   if (GET_CODE (x) == LABEL_REF)\n@@ -2647,11 +2654,11 @@ store_multiple_operation (op, mode)\n \n int\n load_multiple_sequence (operands, nops, regs, base, load_offset)\n-     rtx *operands;\n+     rtx * operands;\n      int nops;\n-     int *regs;\n-     int *base;\n-     HOST_WIDE_INT *load_offset;\n+     int * regs;\n+     int * base;\n+     HOST_WIDE_INT * load_offset;\n {\n   int unsorted_regs[4];\n   HOST_WIDE_INT unsorted_offsets[4];\n@@ -2820,7 +2827,7 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n \n char *\n emit_ldm_seq (operands, nops)\n-     rtx *operands;\n+     rtx * operands;\n      int nops;\n {\n   int regs[4];\n@@ -2880,11 +2887,11 @@ emit_ldm_seq (operands, nops)\n \n int\n store_multiple_sequence (operands, nops, regs, base, load_offset)\n-     rtx *operands;\n+     rtx * operands;\n      int nops;\n-     int *regs;\n-     int *base;\n-     HOST_WIDE_INT *load_offset;\n+     int * regs;\n+     int * base;\n+     HOST_WIDE_INT * load_offset;\n {\n   int unsorted_regs[4];\n   HOST_WIDE_INT unsorted_offsets[4];\n@@ -2933,7 +2940,7 @@ store_multiple_sequence (operands, nops, regs, base, load_offset)\n \t{\n \t  if (i == 0)\n \t    {\n-\t      base_reg = REGNO(reg);\n+\t      base_reg = REGNO (reg);\n \t      unsorted_regs[0] = (GET_CODE (operands[i]) == REG\n \t\t\t\t  ? REGNO (operands[i])\n \t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n@@ -3017,7 +3024,7 @@ store_multiple_sequence (operands, nops, regs, base, load_offset)\n \n char *\n emit_stm_seq (operands, nops)\n-     rtx *operands;\n+     rtx * operands;\n      int nops;\n {\n   int regs[4];\n@@ -3209,7 +3216,7 @@ arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n \n int\n arm_gen_movstrqi (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   HOST_WIDE_INT in_words_to_go, out_words_to_go, last_bytes;\n   int i;\n@@ -3291,27 +3298,27 @@ arm_gen_movstrqi (operands)\n \n   /* OUT_WORDS_TO_GO will be zero here if there are byte stores to do.  */\n   if (out_words_to_go)\n-  {\n-    rtx sreg;\n-\n-    mem = gen_rtx_MEM (SImode, src);\n-    RTX_UNCHANGING_P (mem) = src_unchanging_p;\n-    MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n-    MEM_SCALAR_P (mem) = src_scalar_p;\n-    emit_move_insn (sreg = gen_reg_rtx (SImode), mem);\n-    emit_move_insn (fin_src = gen_reg_rtx (SImode), plus_constant (src, 4));\n-\n-    mem = gen_rtx_MEM (SImode, dst);\n-    RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n-    MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n-    MEM_SCALAR_P (mem) = dst_scalar_p;\n-    emit_move_insn (mem, sreg);\n-    emit_move_insn (fin_dst = gen_reg_rtx (SImode), plus_constant (dst, 4));\n-    in_words_to_go--;\n-\n-    if (in_words_to_go)\t/* Sanity check */\n-      abort ();\n-  }\n+    {\n+      rtx sreg;\n+      \n+      mem = gen_rtx_MEM (SImode, src);\n+      RTX_UNCHANGING_P (mem) = src_unchanging_p;\n+      MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n+      MEM_SCALAR_P (mem) = src_scalar_p;\n+      emit_move_insn (sreg = gen_reg_rtx (SImode), mem);\n+      emit_move_insn (fin_src = gen_reg_rtx (SImode), plus_constant (src, 4));\n+      \n+      mem = gen_rtx_MEM (SImode, dst);\n+      RTX_UNCHANGING_P (mem) = dst_unchanging_p;\n+      MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n+      MEM_SCALAR_P (mem) = dst_scalar_p;\n+      emit_move_insn (mem, sreg);\n+      emit_move_insn (fin_dst = gen_reg_rtx (SImode), plus_constant (dst, 4));\n+      in_words_to_go--;\n+      \n+      if (in_words_to_go)\t/* Sanity check */\n+\tabort ();\n+    }\n \n   if (in_words_to_go)\n     {\n@@ -3344,6 +3351,7 @@ arm_gen_movstrqi (operands)\n \t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n \t  MEM_SCALAR_P (mem) = dst_scalar_p;\n \t  emit_move_insn (mem, gen_rtx_SUBREG (QImode, part_bytes_reg, 0));\n+\t  \n \t  if (--last_bytes)\n \t    {\n \t      tmp = gen_reg_rtx (SImode);\n@@ -3365,6 +3373,7 @@ arm_gen_movstrqi (operands)\n \t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n \t  MEM_SCALAR_P (mem) = dst_scalar_p;\n \t  emit_move_insn (mem, gen_rtx_SUBREG (QImode, part_bytes_reg, 0));\n+\t  \n \t  if (--last_bytes)\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\n@@ -3613,7 +3622,7 @@ gen_compare_reg (code, x, y)\n \n void\n arm_reload_in_hi (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   rtx ref = operands[1];\n   rtx base, scratch;\n@@ -3729,7 +3738,7 @@ arm_reload_in_hi (operands)\n    two scratch registers for some corner cases).  */\n void\n arm_reload_out_hi (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   rtx ref = operands[0];\n   rtx outval = operands[1];\n@@ -4047,7 +4056,7 @@ dump_table (scan)\n \n   for (i = 0; i < pool_size; i++)\n     {\n-      pool_node *p = pool_vector + i;\n+      pool_node * p = pool_vector + i;\n \n       switch (GET_MODE_SIZE (p->mode))\n \t{\n@@ -4362,7 +4371,7 @@ fp_immediate_constant (x)\n /* As for fp_immediate_constant, but value is passed directly, not in rtx.  */\n static char *\n fp_const_from_val (r)\n-     REAL_VALUE_TYPE *r;\n+     REAL_VALUE_TYPE * r;\n {\n   int i;\n \n@@ -4383,8 +4392,8 @@ fp_const_from_val (r)\n \n void\n print_multi_reg (stream, instr, mask, hat)\n-     FILE *stream;\n-     char *instr;\n+     FILE * stream;\n+     char * instr;\n      int mask, hat;\n {\n   int i;\n@@ -4393,11 +4402,13 @@ print_multi_reg (stream, instr, mask, hat)\n   fputc ('\\t', stream);\n   fprintf (stream, instr, REGISTER_PREFIX);\n   fputs (\", {\", stream);\n+  \n   for (i = 0; i < 16; i++)\n     if (mask & (1 << i))\n       {\n \tif (not_first)\n \t  fprintf (stream, \", \");\n+\t\n \tfprintf (stream, \"%s%s\", REGISTER_PREFIX, reg_names[i]);\n \tnot_first = TRUE;\n       }\n@@ -4409,15 +4420,16 @@ print_multi_reg (stream, instr, mask, hat)\n \n char *\n output_call (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   /* Handle calls to lr using ip (which may be clobbered in subr anyway). */\n \n-  if (REGNO (operands[0]) == 14)\n+  if (REGNO (operands[0]) == LR_REGNUM)\n     {\n-      operands[0] = gen_rtx_REG (SImode, 12);\n+      operands[0] = gen_rtx_REG (SImode, IP_REGNUM);\n       output_asm_insn (\"mov%?\\t%0, %|lr\", operands);\n     }\n+  \n   output_asm_insn (\"mov%?\\t%|lr, %|pc\", operands);\n   \n   if (TARGET_THUMB_INTERWORK)\n@@ -4430,32 +4442,34 @@ output_call (operands)\n \n static int\n eliminate_lr2ip (x)\n-     rtx *x;\n+     rtx * x;\n {\n   int something_changed = 0;\n-  rtx x0 = *x;\n+  rtx x0 = * x;\n   int code = GET_CODE (x0);\n   register int i, j;\n-  register char *fmt;\n+  register char * fmt;\n   \n   switch (code)\n     {\n     case REG:\n-      if (REGNO (x0) == 14)\n+      if (REGNO (x0) == LR_REGNUM)\n         {\n-\t  *x = gen_rtx_REG (SImode, 12);\n+\t  *x = gen_rtx_REG (SImode, IP_REGNUM);\n \t  return 1;\n         }\n       return 0;\n     default:\n       /* Scan through the sub-elements and change any references there */\n       fmt = GET_RTX_FORMAT (code);\n+      \n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \tif (fmt[i] == 'e')\n \t  something_changed |= eliminate_lr2ip (&XEXP (x0, i));\n \telse if (fmt[i] == 'E')\n \t  for (j = 0; j < XVECLEN (x0, i); j++)\n \t    something_changed |= eliminate_lr2ip (&XVECEXP (x0, i, j));\n+      \n       return something_changed;\n     }\n }\n@@ -4464,7 +4478,7 @@ eliminate_lr2ip (x)\n \n char *\n output_call_mem (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   operands[0] = copy_rtx (operands[0]); /* Be ultra careful */\n   /* Handle calls using lr by using ip (which may be clobbered in subr anyway).\n@@ -4494,20 +4508,21 @@ output_call_mem (operands)\n \n char *\n output_mov_long_double_fpu_from_arm (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[3];\n \n-  if (arm_reg0 == 12)\n-    abort();\n+  if (arm_reg0 == IP_REGNUM)\n+    abort ();\n \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n   ops[2] = gen_rtx_REG (SImode, 2 + arm_reg0);\n   \n   output_asm_insn (\"stm%?fd\\t%|sp!, {%0, %1, %2}\", ops);\n   output_asm_insn (\"ldf%?e\\t%0, [%|sp], #12\", operands);\n+  \n   return \"\";\n }\n \n@@ -4517,13 +4532,13 @@ output_mov_long_double_fpu_from_arm (operands)\n \n char *\n output_mov_long_double_arm_from_fpu (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[3];\n \n-  if (arm_reg0 == 12)\n-    abort();\n+  if (arm_reg0 == IP_REGNUM)\n+    abort ();\n \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n@@ -4539,7 +4554,7 @@ output_mov_long_double_arm_from_fpu (operands)\n    OPERANDS[1] is the source.  */\n char *\n output_mov_long_double_arm_from_arm (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   /* We have to be careful here because the two might overlap */\n   int dest_start = REGNO (operands[0]);\n@@ -4576,13 +4591,14 @@ output_mov_long_double_arm_from_arm (operands)\n \n char *\n output_mov_double_fpu_from_arm (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[2];\n \n-  if (arm_reg0 == 12)\n-    abort();\n+  if (arm_reg0 == IP_REGNUM)\n+    abort ();\n+  \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n   output_asm_insn (\"stm%?fd\\t%|sp!, {%0, %1}\", ops);\n@@ -4596,13 +4612,13 @@ output_mov_double_fpu_from_arm (operands)\n \n char *\n output_mov_double_arm_from_fpu (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[2];\n \n-  if (arm_reg0 == 12)\n-    abort();\n+  if (arm_reg0 == IP_REGNUM)\n+    abort ();\n \n   ops[0] = gen_rtx_REG (SImode, arm_reg0);\n   ops[1] = gen_rtx_REG (SImode, 1 + arm_reg0);\n@@ -4632,8 +4648,8 @@ output_move_double (operands)\n       if (code1 == REG)\n \t{\n \t  int reg1 = REGNO (operands[1]);\n-\t  if (reg1 == 12)\n-\t    abort();\n+\t  if (reg1 == IP_REGNUM)\n+\t    abort ();\n \n \t  /* Ensure the second source is not overwritten */\n \t  if (reg1 == reg0 + (WORDS_BIG_ENDIAN ? -1 : 1))\n@@ -4783,12 +4799,12 @@ output_move_double (operands)\n \t    }\n \t}\n       else\n-\tabort();  /* Constraints should prevent this */\n+\tabort ();  /* Constraints should prevent this */\n     }\n   else if (code0 == MEM && code1 == REG)\n     {\n-      if (REGNO (operands[1]) == 12)\n-\tabort();\n+      if (REGNO (operands[1]) == IP_REGNUM)\n+\tabort ();\n \n       switch (GET_CODE (XEXP (operands[0], 0)))\n         {\n@@ -4840,7 +4856,7 @@ output_move_double (operands)\n \t}\n     }\n   else\n-    abort();  /* Constraints should prevent this */\n+    abort ();  /* Constraints should prevent this */\n \n   return \"\";\n }\n@@ -4851,7 +4867,7 @@ output_move_double (operands)\n \n char *\n output_mov_immediate (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   HOST_WIDE_INT n = INTVAL (operands[1]);\n   int n_ones = 0;\n@@ -4894,7 +4910,7 @@ output_mov_immediate (operands)\n \n char *\n output_add_immediate (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   HOST_WIDE_INT n = INTVAL (operands[2]);\n \n@@ -4922,8 +4938,8 @@ output_add_immediate (operands)\n \n static char *\n output_multi_immediate (operands, instr1, instr2, immed_op, n)\n-     rtx *operands;\n-     char *instr1, *instr2;\n+     rtx * operands;\n+     char * instr1, * instr2;\n      int immed_op;\n      HOST_WIDE_INT n;\n {\n@@ -5001,7 +5017,7 @@ shift_op (op, amountp)\n      rtx op;\n      HOST_WIDE_INT *amountp;\n {\n-  char *mnem;\n+  char * mnem;\n   enum rtx_code code = GET_CODE (op);\n \n   if (GET_CODE (XEXP (op, 1)) == REG || GET_CODE (XEXP (op, 1)) == SUBREG)\n@@ -5092,8 +5108,8 @@ int_log2 (power)\n \n void\n output_ascii_pseudo_op (stream, p, len)\n-     FILE *stream;\n-     unsigned char *p;\n+     FILE * stream;\n+     unsigned char * p;\n      int len;\n {\n   int i;\n@@ -5157,11 +5173,11 @@ pattern_really_clobbers_lr (x)\n       switch (GET_CODE (SET_DEST (x)))\n \t{\n \tcase REG:\n-\t  return REGNO (SET_DEST (x)) == 14;\n+\t  return REGNO (SET_DEST (x)) == LR_REGNUM;\n \n         case SUBREG:\n \t  if (GET_CODE (XEXP (SET_DEST (x), 0)) == REG)\n-\t    return REGNO (XEXP (SET_DEST (x), 0)) == 14;\n+\t    return REGNO (XEXP (SET_DEST (x), 0)) == LR_REGNUM;\n \n \t  if (GET_CODE (XEXP (SET_DEST (x), 0)) == MEM)\n \t    return 0;\n@@ -5181,11 +5197,11 @@ pattern_really_clobbers_lr (x)\n       switch (GET_CODE (XEXP (x, 0)))\n         {\n \tcase REG:\n-\t  return REGNO (XEXP (x, 0)) == 14;\n+\t  return REGNO (XEXP (x, 0)) == LR_REGNUM;\n \n         case SUBREG:\n \t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n-\t    return REGNO (XEXP (XEXP (x, 0), 0)) == 14;\n+\t    return REGNO (XEXP (XEXP (x, 0), 0)) == LR_REGNUM;\n \t  abort ();\n \n         default:\n@@ -5295,7 +5311,7 @@ output_return_instruction (operand, really_return, reverse)\n \n   return_used_this_function = 1;\n \n-  if (volatile_func)\n+  if (TARGET_ABORT_NORETURN && volatile_func)\n     {\n       rtx ops[2];\n       /* If this function was declared non-returning, and we have found a tail \n@@ -5313,7 +5329,7 @@ output_return_instruction (operand, really_return, reverse)\n     }\n       \n   if (current_function_calls_alloca && ! really_return)\n-    abort();\n+    abort ();\n     \n   for (reg = 0; reg <= 10; reg++)\n     if (regs_ever_live[reg] && ! call_used_regs[reg])\n@@ -5322,15 +5338,15 @@ output_return_instruction (operand, really_return, reverse)\n   if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     live_regs++;\n \n-  if (live_regs || (regs_ever_live[14] && ! lr_save_eliminated))\n+  if (live_regs || (regs_ever_live[LR_REGNUM] && ! lr_save_eliminated))\n     live_regs++;\n \n   if (frame_pointer_needed)\n     live_regs += 4;\n \n   if (live_regs)\n     {\n-      if (lr_save_eliminated || ! regs_ever_live[14])\n+      if (lr_save_eliminated || ! regs_ever_live[LR_REGNUM])\n         live_regs++;\n \n       if (frame_pointer_needed)\n@@ -5341,7 +5357,7 @@ output_return_instruction (operand, really_return, reverse)\n \t\treverse ? \"ldm%?%D0fd\\t%|sp!, {\" : \"ldm%?%d0fd\\t%|sp!, {\");\n \n       for (reg = 0; reg <= 10; reg++)\n-        if (regs_ever_live[reg] \n+        if (regs_ever_live[reg]\n \t    && (! call_used_regs[reg]\n \t\t|| (flag_pic && reg == PIC_OFFSET_TABLE_REGNUM)))\n           {\n@@ -5361,15 +5377,15 @@ output_return_instruction (operand, really_return, reverse)\n           strcat (instr, \", \");\n \t  strcat (instr, \"%|\");\n \t  strcat (instr, TARGET_THUMB_INTERWORK || (! really_return)\n-\t\t  ? reg_names[14] : reg_names[15] );\n+\t\t  ? reg_names[LR_REGNUM] : reg_names[PC_REGNUM] );\n         }\n       else\n \t{\n \t  strcat (instr, \"%|\");\n \t  if (TARGET_THUMB_INTERWORK && really_return)\n-\t    strcat (instr, reg_names[12]);\n+\t    strcat (instr, reg_names[IP_REGNUM]);\n \t  else\n-\t    strcat (instr, really_return ? reg_names[15] : reg_names[14]);\n+\t    strcat (instr, really_return ? reg_names[PC_REGNUM] : reg_names[LR_REGNUM]);\n \t}\n       strcat (instr, (TARGET_APCS_32 || !really_return) ? \"}\" : \"}^\");\n       output_asm_insn (instr, &operand);\n@@ -5508,13 +5524,13 @@ output_func_prologue (f, frame_size)\n \n   if (frame_pointer_needed)\n     live_regs_mask |= 0xD800;\n-  else if (regs_ever_live[14])\n+  else if (regs_ever_live[LR_REGNUM])\n     {\n       if (! current_function_args_size\n \t  && ! function_really_clobbers_lr (get_insns ()))\n \tlr_save_eliminated = 1;\n       else\n-        live_regs_mask |= 0x4000;\n+        live_regs_mask |= 1 << LR_REGNUM;\n     }\n \n   if (live_regs_mask)\n@@ -5524,7 +5540,7 @@ output_func_prologue (f, frame_size)\n \t doing so,  in this case we need to push lr as well, or we\n \t will fail to get a proper return. */\n \n-      live_regs_mask |= 0x4000;\n+      live_regs_mask |= 1 << LR_REGNUM;\n       lr_save_eliminated = 0;\n \n     }\n@@ -5543,7 +5559,7 @@ output_func_prologue (f, frame_size)\n \n void\n output_func_epilogue (f, frame_size)\n-     FILE *f;\n+     FILE * f;\n      int frame_size;\n {\n   int reg, live_regs_mask = 0;\n@@ -5701,12 +5717,12 @@ output_func_epilogue (f, frame_size)\n \t\t     reg - start_reg, REGISTER_PREFIX);\n \t}\n \n-      if (current_function_pretend_args_size == 0 && regs_ever_live[14])\n+      if (current_function_pretend_args_size == 0 && regs_ever_live[LR_REGNUM])\n \t{\n \t  if (TARGET_THUMB_INTERWORK)\n \t    {\n \t      if (! lr_save_eliminated)\n-\t\tlive_regs_mask |= 0x4000;\n+\t\tlive_regs_mask |= 1 << LR_REGNUM;\n \n \t      if (live_regs_mask != 0)\n \t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n@@ -5723,11 +5739,11 @@ output_func_epilogue (f, frame_size)\n \t}\n       else\n \t{\n-\t  if (live_regs_mask || regs_ever_live[14])\n+\t  if (live_regs_mask || regs_ever_live[LR_REGNUM])\n \t    {\n \t      /* Restore the integer regs, and the return address into lr */\n \t      if (! lr_save_eliminated)\n-\t\tlive_regs_mask |= 0x4000;\n+\t\tlive_regs_mask |= 1 << LR_REGNUM;\n \n \t      if (live_regs_mask != 0)\n \t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n@@ -5856,14 +5872,14 @@ arm_expand_prologue ()\n       if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n \tlive_regs_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n \n-      if (regs_ever_live[14])\n-\tlive_regs_mask |= 0x4000;\n+      if (regs_ever_live[LR_REGNUM])\n+\tlive_regs_mask |= 1 << LR_REGNUM;\n     }\n \n   if (frame_pointer_needed)\n     {\n       live_regs_mask |= 0xD800;\n-      emit_insn (gen_movsi (gen_rtx_REG (SImode, 12),\n+      emit_insn (gen_movsi (gen_rtx_REG (SImode, IP_REGNUM),\n \t\t\t    stack_pointer_rtx));\n     }\n \n@@ -5881,7 +5897,7 @@ arm_expand_prologue ()\n     {\n       /* If we have to push any regs, then we must push lr as well, or\n \t we won't get a proper return.  */\n-      live_regs_mask |= 0x4000;\n+      live_regs_mask |= 1 << LR_REGNUM;\n       emit_multi_reg_push (live_regs_mask);\n     }\n       \n@@ -5928,7 +5944,7 @@ arm_expand_prologue ()\n     }\n \n   if (frame_pointer_needed)\n-    emit_insn (gen_addsi3 (hard_frame_pointer_rtx, gen_rtx_REG (SImode, 12),\n+    emit_insn (gen_addsi3 (hard_frame_pointer_rtx, gen_rtx_REG (SImode, IP_REGNUM),\n \t\t\t   (GEN_INT\n \t\t\t    (-(4 + current_function_pretend_args_size)))));\n \n@@ -5963,7 +5979,7 @@ arm_expand_prologue ()\n \n void\n arm_print_operand (stream, x, code)\n-     FILE *stream;\n+     FILE * stream;\n      rtx x;\n      int code;\n {\n@@ -6586,17 +6602,17 @@ arm_final_prescan_insn (insn)\n rtx aof_pic_label = NULL_RTX;\n struct pic_chain\n {\n-  struct pic_chain *next;\n-  char *symname;\n+  struct pic_chain * next;\n+  char * symname;\n };\n \n-static struct pic_chain *aof_pic_chain = NULL;\n+static struct pic_chain * aof_pic_chain = NULL;\n \n rtx\n aof_pic_entry (x)\n      rtx x;\n {\n-  struct pic_chain **chainp;\n+  struct pic_chain ** chainp;\n   int offset;\n \n   if (aof_pic_label == NULL_RTX)\n@@ -6620,9 +6636,9 @@ aof_pic_entry (x)\n \n void\n aof_dump_pic_table (f)\n-     FILE *f;\n+     FILE * f;\n {\n-  struct pic_chain *chain;\n+  struct pic_chain * chain;\n \n   if (aof_pic_chain == NULL)\n     return;\n@@ -6675,17 +6691,17 @@ aof_data_section ()\n \n struct import\n {\n-  struct import *next;\n-  char *name;\n+  struct import * next;\n+  char * name;\n };\n \n-static struct import *imports_list = NULL;\n+static struct import * imports_list = NULL;\n \n void\n aof_add_import (name)\n-     char *name;\n+     char * name;\n {\n-  struct import *new;\n+  struct import * new;\n \n   for (new = imports_list; new; new = new->next)\n     if (new->name == name)\n@@ -6699,9 +6715,9 @@ aof_add_import (name)\n \n void\n aof_delete_import (name)\n-     char *name;\n+     char * name;\n {\n-  struct import **old;\n+  struct import ** old;\n \n   for (old = &imports_list; *old; old = & (*old)->next)\n     {\n@@ -6717,7 +6733,7 @@ int arm_main_function = 0;\n \n void\n aof_dump_imports (f)\n-     FILE *f;\n+     FILE * f;\n {\n   /* The AOF assembler needs this to cause the startup code to be extracted\n      from the library.  Brining in __main causes the whole thing to work"}, {"sha": "1fd92079612dd3dd25a22adedaa81c8070a57f46", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 168, "deletions": 151, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "patch": "@@ -65,7 +65,7 @@ enum arm_cond_code\n   ARM_HI, ARM_LS, ARM_GE, ARM_LT, ARM_GT, ARM_LE, ARM_AL, ARM_NV\n };\n extern enum arm_cond_code arm_current_cc;\n-extern char *arm_condition_codes[];\n+extern char * arm_condition_codes[];\n \n #define ARM_INVERSE_CONDITION_CODE(X)  ((enum arm_cond_code) (((int)X) ^ 1))\n \n@@ -153,6 +153,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{march=armv3m:-D__ARM_ARCH_3M__} \\\n %{march=armv4:-D__ARM_ARCH_4__} \\\n %{march=armv4t:-D__ARM_ARCH_4T__} \\\n+%{march=armv5:-D__ARM_ARCH_5__} \\\n %{!march=*: \\\n  %{mcpu=arm2:-D__ARM_ARCH_2__} \\\n  %{mcpu=arm250:-D__ARM_ARCH_2__} \\\n@@ -459,6 +460,9 @@ extern int arm_fast_multiply;\n /* Nonzero if this chip supports the ARM Architecture 4 extensions */\n extern int arm_arch4;\n \n+/* Nonzero if this chip supports the ARM Architecture 5 extensions */\n+extern int arm_arch5;\n+\n /* Nonzero if this chip can benefit from load scheduling.  */\n extern int arm_ld_sched;\n \n@@ -785,6 +789,12 @@ extern const char * structure_size_string;\n    should point to a special register that we will make sure is eliminated. */\n #define HARD_FRAME_POINTER_REGNUM 11\n \n+/* Register which holds return address from a subroutine call.  */\n+#define LR_REGNUM\t\t14\n+\n+/* Scratch register - used in all kinds of places, eg trampolines.  */\n+#define IP_REGNUM\t\t12\n+\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n    via the stack pointer) in functions that seem suitable.  \n@@ -944,51 +954,53 @@ enum reg_class\n    For the ARM, we wish to handle large displacements off a base\n    register by splitting the addend across a MOV and the mem insn.\n    This can cut the number of reloads needed. */\n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\\\n-      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\\\n-      HOST_WIDE_INT low, high;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t\\\n-\tlow = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t\\\n-      else if (MODE == SImode || MODE == QImode\t\t\t\t\\\n-\t       || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t\t\\\n-\t       || (MODE == HImode && ! arm_arch4))\t\t\t\\\n-\t/* Need to be careful, -4096 is not a valid offset */\t\t\\\n-\tlow = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t\\\n-      else if (MODE == HImode && arm_arch4)\t\t\t\t\\\n-\t/* Need to be careful, -256 is not a valid offset */\t\t\\\n-\tlow = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t\\\n-      else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n-\t       && TARGET_HARD_FLOAT)\t\t\t\t\t\\\n-\t/* Need to be careful, -1024 is not a valid offset */\t\t\\\n-\tlow = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      high = ((((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000);\t\\\n-      /* Check for overflow or zero */\t\t\t\t\t\\\n-      if (low == 0 || high == 0 || (high + low != val))\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Reload the high part into a base reg; leave the low part\t\\\n-\t in the mem.  */\t\t\t\t\t\t\\\n-      X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\\\n-\t\t\tgen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\\\n-\t\t\t\t      GEN_INT (high)),\t\t\t\\\n-\t\t\tGEN_INT (low));\t\t\t\t\t\\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\\\n-\t\t   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n-\t\t   OPNUM, TYPE);\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\t\\\n+\t  && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n+\t  && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\t\t\\\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\t\\\n+\t  HOST_WIDE_INT low, high;\t\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\t\t\\\n+\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t\t\t\\\n+\t    low = ((val & 0xf) ^ 0x8) - 0x8;\t\t\t\t\t\t\\\n+\t  else if (MODE == SImode || MODE == QImode\t\t\t\t\t\\\n+\t\t   || (MODE == SFmode && TARGET_SOFT_FLOAT)\t\t\t\t\\\n+\t\t   || (MODE == HImode && ! arm_arch4))\t\t\t\t\t\\\n+\t    /* Need to be careful, -4096 is not a valid offset */\t\t\t\\\n+\t    low = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\t\t\t\t\\\n+\t  else if (MODE == HImode && arm_arch4)\t\t\t\t\t\t\\\n+\t    /* Need to be careful, -256 is not a valid offset */\t\t\t\\\n+\t    low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\t\t\t\t\\\n+\t  else if (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\t\\\n+\t\t   && TARGET_HARD_FLOAT)\t\t\t\t\t\t\\\n+\t    /* Need to be careful, -1024 is not a valid offset */\t\t\t\\\n+\t    low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\t\t\\\n+\t  high = ((((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000);\t\t\\\n+\t  /* Check for overflow or zero */\t\t\t\t\t\t\\\n+\t  if (low == 0 || high == 0 || (high + low != val))\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\t\t\\\n+\t  /* Reload the high part into a base reg; leave the low part\t\t\t\\\n+\t     in the mem.  */\t\t\t\t\t\t\t\t\\\n+\t  X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\t\\\n+\t\t\t    gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\t\t\\\n+\t\t\t\t\t  GEN_INT (high)),\t\t\t\t\\\n+\t\t\t    GEN_INT (low));\t\t\t\t\t\t\\\n+\t  push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\t\t\\\n+\t\t       BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\t\t\\\n+\t\t       OPNUM, TYPE);\t\t\t\t\t\t\t\\\n+\t  goto WIN;\t\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n@@ -1189,8 +1201,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   rtx sym;\t\t\t\t\t\t\t\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n   fprintf ((STREAM), \"\\tmov\\t%s%s, %s%s\\n\\tbl\\t\",\t\t\t    \\\n-\t   REGISTER_PREFIX, reg_names[12] /* ip */,\t\t\t    \\\n-\t   REGISTER_PREFIX, reg_names[14] /* lr */);\t\t\t    \\\n+\t   REGISTER_PREFIX, reg_names[IP_REGNUM] /* ip */,\t\t    \\\n+\t   REGISTER_PREFIX, reg_names[LR_REGNUM] /* lr */);\t\t    \\\n   assemble_name ((STREAM), ARM_MCOUNT_NAME);\t\t\t\t    \\\n   fputc ('\\n', (STREAM));\t\t\t\t\t\t    \\\n   ASM_GENERATE_INTERNAL_LABEL (temp, \"LP\", (LABELNO));\t\t\t    \\\n@@ -1280,7 +1292,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t   if (! frame_pointer_needed)\t\t\t\t\t\\\n \t     offset -= 16;\t\t\t\t\t\t\\\n \t   if (! volatile_func\t\t\t\t\t\t\\\n-\t       && (regs_ever_live[14] || saved_hard_reg)) \t\t\\\n+\t       && (regs_ever_live[LR_REGNUM] || saved_hard_reg))\t\\\n \t     offset += 4;\t\t\t\t\t\t\\\n \t   offset += current_function_outgoing_args_size;\t\t\\\n \t   (OFFSET) = ((get_frame_size () + 3) & ~3) + offset;\t\t\\\n@@ -1458,54 +1470,55 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* A C statement (sans semicolon) to jump to LABEL for legitimate index RTXs\n    used by the macro GO_IF_LEGITIMATE_ADDRESS.  Floating point indices can\n    only be small constants. */\n-#define GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)  \t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  HOST_WIDE_INT range;\t\t\t\t\t\t\t\\\n-  enum rtx_code code = GET_CODE (INDEX);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (code == CONST_INT && INTVAL (INDEX) < 1024\t\t\t\\\n-\t  && INTVAL (INDEX) > -1024\t\t\t\t\t\\\n-\t  && (INTVAL (INDEX) & 3) == 0)\t\t\t\t\t\\\n-\tgoto LABEL;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (INDEX_REGISTER_RTX_P (INDEX) && GET_MODE_SIZE (MODE) <= 4)\t\\\n-\tgoto LABEL;\t\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 4  && code == MULT\t\t\t\\\n-\t  && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\t\\\n-\t  rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\t\\\n-\t  if (INDEX_REGISTER_RTX_P (xiop0)\t\t\t\t\\\n-\t      && power_of_two_operand (xiop1, SImode))\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t  if (INDEX_REGISTER_RTX_P (xiop1)\t\t\t\t\\\n-\t      && power_of_two_operand (xiop0, SImode))\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n-\t  && (code == LSHIFTRT || code == ASHIFTRT\t\t\t\\\n-\t      || code == ASHIFT || code == ROTATERT)\t\t\t\\\n-\t  && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx op = XEXP (INDEX, 1);\t\t\t\t\t\\\n-\t  if (INDEX_REGISTER_RTX_P (XEXP (INDEX, 0))\t\t\t\\\n-\t      && GET_CODE (op) == CONST_INT && INTVAL (op) > 0\t\t\\\n-\t      && INTVAL (op) <= 31)\t\t\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      /* NASTY: Since this limits the addressing of unsigned byte loads */      \\\n-      range = ((MODE) == HImode || (MODE) == QImode)                    \\\n-              ? (arm_arch4 ? 256 : 4095) : 4096;                        \\\n-      if (code == CONST_INT && INTVAL (INDEX) < range\t\t\t\\\n-\t  && INTVAL (INDEX) > -range)  \t      \t\t\t\t\\\n-        goto LABEL;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)  \t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT range;\t\t\t\t\t\t\t\t\\\n+      enum rtx_code code = GET_CODE (INDEX);\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\t\t\\\n+\t  if (code == CONST_INT && INTVAL (INDEX) < 1024\t\t\t\t\\\n+\t      && INTVAL (INDEX) > -1024\t\t\t\t\t\t\t\\\n+\t      && (INTVAL (INDEX) & 3) == 0)\t\t\t\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\t\t\\\n+\t  if (INDEX_REGISTER_RTX_P (INDEX) && GET_MODE_SIZE (MODE) <= 4)\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\t\t\\\n+\t  if (GET_MODE_SIZE (MODE) <= 4  && code == MULT\t\t\t\t\\\n+\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\t\t\\\n+\t      rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\t\t\\\n+\t      rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\t\t\\\n+\t      if (INDEX_REGISTER_RTX_P (xiop0)\t\t\t\t\t\t\\\n+\t\t  && power_of_two_operand (xiop1, SImode))\t\t\t\t\\\n+\t\tgoto LABEL;\t\t\t\t\t\t\t\t\\\n+\t      if (INDEX_REGISTER_RTX_P (xiop1)\t\t\t\t\t\t\\\n+\t\t  && power_of_two_operand (xiop0, SImode))\t\t\t\t\\\n+\t\tgoto LABEL;\t\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\t\t\\\n+\t  if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\t\t\\\n+\t      && (code == LSHIFTRT || code == ASHIFTRT\t\t\t\t\t\\\n+\t\t  || code == ASHIFT || code == ROTATERT)\t\t\t\t\\\n+\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\t\t\\\n+\t      rtx op = XEXP (INDEX, 1);\t\t\t\t\t\t\t\\\n+\t      if (INDEX_REGISTER_RTX_P (XEXP (INDEX, 0))\t\t\t\t\\\n+\t\t  && GET_CODE (op) == CONST_INT && INTVAL (op) > 0\t\t\t\\\n+\t\t  && INTVAL (op) <= 31)\t\t\t\t\t\t\t\\\n+\t\tgoto LABEL;\t\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\t\t\\\n+\t  /* NASTY: Since this limits the addressing of unsigned byte loads */\t\t\\\n+\t  range = ((MODE) == HImode || (MODE) == QImode)                    \t\t\\\n+\t    ? (arm_arch4 ? 256 : 4095) : 4096;                        \t\t\t\\\n+\t  if (code == CONST_INT && INTVAL (INDEX) < range\t\t\t\t\\\n+\t      && INTVAL (INDEX) > -range)  \t      \t\t\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Jump to LABEL if X is a valid address RTX.  This must also take\n    REG_OK_STRICT into account when deciding about valid registers, but it uses\n@@ -1588,7 +1601,6 @@ do\t\t\t\t\t\t\t\t\t\\\n    On the ARM, try to convert [REG, #BIGCONST]\n    into ADD BASE, REG, #UPPERCONST and [BASE, #VALIDCONST],\n    where VALIDCONST == 0 in case of TImode.  */\n-extern struct rtx_def *legitimize_pic_address ();\n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t \\\n {\t\t\t\t\t\t\t\t\t \\\n   if (GET_CODE (X) == PLUS)\t\t\t\t\t\t \\\n@@ -1767,7 +1779,7 @@ extern struct rtx_def *legitimize_pic_address ();\n   ((X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n    || (X) == arg_pointer_rtx)\n \n-#define DEFAULT_RTX_COSTS(X,CODE,OUTER_CODE)\t\t\\\n+#define DEFAULT_RTX_COSTS(X, CODE, OUTER_CODE)\t\t\\\n    return arm_rtx_costs (X, CODE);\n \n /* Moves to and from memory are quite expensive */\n@@ -1851,26 +1863,28 @@ extern int making_const_table;\n \n #define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode)\n \n-#define CANONICALIZE_COMPARISON(CODE,OP0,OP1)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (OP1) == CONST_INT\t\t\t\t\\\n-      && ! (const_ok_for_arm (INTVAL (OP1))\t\t\t\\\n-\t    || (const_ok_for_arm (- INTVAL (OP1)))))\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      rtx const_op = OP1;\t\t\t\t\t\\\n-      CODE = arm_canonicalize_comparison ((CODE), &const_op);\t\\\n-      OP1 = const_op;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define CANONICALIZE_COMPARISON(CODE, OP0, OP1)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (OP1) == CONST_INT\t\t\t\t\t\\\n+          && ! (const_ok_for_arm (INTVAL (OP1))\t\t\t\t\\\n+\t        || (const_ok_for_arm (- INTVAL (OP1)))))\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+          rtx const_op = OP1;\t\t\t\t\t\t\\\n+          CODE = arm_canonicalize_comparison ((CODE), &const_op);\t\\\n+          OP1 = const_op;\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define STORE_FLAG_VALUE 1\n \n /* Define the information needed to generate branch insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n \n-extern struct rtx_def *arm_compare_op0, *arm_compare_op1;\n+extern struct rtx_def * arm_compare_op0;\n+extern struct rtx_def * arm_compare_op1;\n \n /* Define the codes that are matched by predicates in arm.c */\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n@@ -1914,22 +1928,23 @@ extern struct rtx_def *arm_compare_op0, *arm_compare_op1;\n \n /* Output an internal label definition.  */\n #ifndef ASM_OUTPUT_INTERNAL_LABEL\n-#define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)  \t\\\n-  do                                    \t      \t   \t\\\n-    {\t\t\t\t\t\t      \t   \t\\\n+#define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n       char * s = (char *) alloca (40 + strlen (PREFIX));\t\\\n-      extern int arm_target_label, arm_ccfsm_state;\t   \t\\\n+      extern int arm_target_label, arm_ccfsm_state;\t\t\\\n       extern rtx arm_target_insn;\t\t\t\t\\\n-\t\t\t\t\t\t           \t\\\n-      if (arm_ccfsm_state == 3 && arm_target_label == (NUM)   \t\\\n-\t&& !strcmp (PREFIX, \"L\"))\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (arm_ccfsm_state == 3 && arm_target_label == (NUM)\t\\\n+\t  && !strcmp (PREFIX, \"L\"))\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  arm_ccfsm_state = 0;\t\t\t\t        \\\n+\t  arm_ccfsm_state = 0;\t\t\t\t\t\\\n \t  arm_target_insn = NULL;\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (s, (PREFIX), (NUM));   \t\\\n-\tASM_OUTPUT_LABEL (STREAM, s);\t\t                \\\n-    } while (0)\n+      ASM_GENERATE_INTERNAL_LABEL (s, (PREFIX), (NUM));\t\t\\\n+      ASM_OUTPUT_LABEL (STREAM, s);\t\t                \\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n /* Output a push or a pop instruction (only used when profiling).  */\n@@ -2076,34 +2091,36 @@ extern struct rtx_def *arm_compare_op0, *arm_compare_op1;\n \n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n-#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  int mi_delta = (DELTA);\t\t\t\t\t\t\\\n-  char *mi_op = mi_delta < 0 ? \"sub\" : \"add\";\t\t\t\t\\\n-  int shift = 0;\t\t\t\t\t\t\t\\\n-  int this_regno = (aggregate_value_p (TREE_TYPE (TREE_TYPE (FUNCTION)))\\\n-\t\t    ? 1 : 0);\t\t\t\t\t\t\\\n-  if (mi_delta < 0) mi_delta = -mi_delta;\t\t\t\t\\\n-  while (mi_delta != 0)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (mi_delta & (3 << shift) == 0)\t\t\t\t\t\\\n-\tshift += 2;\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\t%s\\t%s%s, %s%s, #%d\\n\",\t\t\t\\\n-\t\t   mi_op, REGISTER_PREFIX, reg_names[this_regno],\t\\\n-\t\t   REGISTER_PREFIX, reg_names[this_regno],\t\t\\\n-\t\t   mi_delta & (0xff << shift));\t\t\t\t\\\n-\t  mi_delta &= ~(0xff << shift);\t\t\t\t\t\\\n-\t  shift += 8;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\tb\\t\", FILE);\t\t\t\t\t\t\\\n-  assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t\\\n-  if (NEED_PLT_GOT)\t\t\t\t\t\t\t\\\n-    fputs (\"(PLT)\", FILE);\t\t\t\t\t\t\\\n-  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\\\n+      int mi_delta = (DELTA);\t\t\t\t\t\t\t\\\n+      char * mi_op = mi_delta < 0 ? \"sub\" : \"add\";\t\t\t\t\\\n+      int shift = 0;\t\t\t\t\t\t\t\t\\\n+      int this_regno = (aggregate_value_p (TREE_TYPE (TREE_TYPE (FUNCTION)))\t\\\n+\t\t        ? 1 : 0);\t\t\t\t\t\t\\\n+      if (mi_delta < 0) mi_delta = -mi_delta;\t\t\t\t\t\\\n+      while (mi_delta != 0)\t\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\t\\\n+          if (mi_delta & (3 << shift) == 0)\t\t\t\t\t\\\n+\t    shift += 2;\t\t\t\t\t\t\t\t\\\n+          else\t\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\t\\\n+\t      fprintf (FILE, \"\\t%s\\t%s%s, %s%s, #%d\\n\",\t\t\t\t\\\n+\t\t       mi_op, REGISTER_PREFIX, reg_names[this_regno],\t\t\\\n+\t\t       REGISTER_PREFIX, reg_names[this_regno],\t\t\t\\\n+\t\t       mi_delta & (0xff << shift));\t\t\t\t\\\n+\t      mi_delta &= ~(0xff << shift);\t\t\t\t\t\\\n+\t      shift += 8;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\tb\\t\", FILE);\t\t\t\t\t\t\t\\\n+      assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t\t\\\n+      if (NEED_PLT_GOT)\t\t\t\t\t\t\t\t\\\n+        fputs (\"(PLT)\", FILE);\t\t\t\t\t\t\t\\\n+      fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.  */"}, {"sha": "478ae62022667de3b3e49959ce5129384907a2a3", "filename": "gcc/config/arm/coff.h", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcoff.h?ref=62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "patch": "@@ -35,7 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #undef  TARGET_DEFAULT\n #define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32)\n \n-#define MULTILIB_DEFAULTS { \"mlittle-endian\", \"msoft-float\", \"mapcs-32\" }\n+#define MULTILIB_DEFAULTS { \"mlittle-endian\", \"msoft-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n \f\n /* Setting this to 32 produces more efficient code, but the value set in previous\n    versions of this toolchain was 8, which produces more compact structures. The\n@@ -50,7 +50,7 @@ extern int arm_structure_size_boundary;\n    is a valid machine specific attribute for DECL.\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n-arm_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)\n+  arm_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)\n \f\n /* This is COFF, but prefer stabs.  */\n #define SDB_DEBUGGING_INFO\n@@ -68,31 +68,35 @@ arm_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)\n    ordinary symbol, or gdb won't see it.  The stabs entry must be\n    before the N_SO in order for gdb to find it.  */\n #define ASM_IDENTIFY_GCC(STREAM) \t\t\t\t\\\n-     fprintf (STREAM, \"%sgcc2_compiled.:\\n\", LOCAL_LABEL_PREFIX )\n+  fprintf (STREAM, \"%sgcc2_compiled.:\\n\", LOCAL_LABEL_PREFIX )\n \n /* This outputs a lot of .req's to define alias for various registers.\n    Let's try to avoid this.  */\n #undef ASM_FILE_START\n-#define ASM_FILE_START(STREAM) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  extern char *version_string;\t\t\t\t\t\\\n-  fprintf (STREAM, \"%s Generated by gcc %s for ARM/coff\\n\",\t\\\n-\t   ASM_COMMENT_START, version_string);\t\t\t\\\n-} while (0)\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      extern char * version_string;\t\t\t\t\\\n+      fprintf (STREAM, \"%s Generated by gcc %s for ARM/coff\\n\",\t\\\n+\t       ASM_COMMENT_START, version_string);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* A C statement to output something to the assembler file to switch to section\n    NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n    NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n    define this macro in such cases.  */\n-#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n-  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+        fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\\\n+      else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+        fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\\\n+      else\t\t\t\t\t\t\t\\\n+        fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Support the ctors/dtors and other sections.  */\n \n@@ -171,24 +175,28 @@ dtors_section ()\t\t\t\t\t\t\t\\\n /* A C statement (sans semicolon) to output an element in the table of\n    global constructors.  */\n #undef ASM_OUTPUT_CONSTRUCTOR\n-#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  ctors_section ();\t\t\t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_CONSTRUCTOR(STREAM, NAME)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      ctors_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+      assemble_name (STREAM, NAME);\t\t\\\n+      fprintf (STREAM, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* A C statement (sans semicolon) to output an element in the table of\n    global destructors.  */\n #undef ASM_OUTPUT_DESTRUCTOR\n-#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  dtors_section ();                   \t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);              \t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_DESTRUCTOR(STREAM, NAME)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      dtors_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+      assemble_name (STREAM, NAME);\t\t\\\n+      fprintf (STREAM, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n #define CTOR_LISTS_DEFINED_EXTERNALLY\n@@ -205,5 +213,5 @@ do {\t\t\t\t\t\t\\\n #define HAVE_ATEXIT\n \n /* The ARM development system defines __main.  */\n-#define NAME__MAIN \"__gccmain\"\n+#define NAME__MAIN  \"__gccmain\"\n #define SYMBOL__MAIN __gccmain"}, {"sha": "0b39e0d03e1e9e6306530f3ae5861197031770c5", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 111, "deletions": 93, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "patch": "@@ -76,69 +76,75 @@ Boston, MA 02111-1307, USA.  */\n   while (0)\n \n /* Write the extra assembler code needed to declare an object properly.  */\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    putc (',', FILE);\t\t\t\t\t\t\t\\\n-    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n-    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    size_directive_output = 0;\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tsize_directive_output = 1;\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n-\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n-\tputc (',', FILE);\t\t\t\t\t\t\\\n-\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\t\t\\\n-\t\t int_size_in_bytes (TREE_TYPE (DECL)));\t\t\t\\\n-\tfputc ('\\n', FILE);\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n-  } while (0)\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\\\n+      size_directive_output = 0;\t\t\t\t\\\n+      if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\\\n+        {\t\t\t\t\t\t\t\\\n+\t  size_directive_output = 1;\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n+\t  assemble_name (FILE, NAME);\t\t\t\t\\\n+\t  putc (',', FILE);\t\t\t\t\t\\\n+\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\\\n+\t\t   int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+\t  fputc ('\\n', FILE);\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Output the size directive for a decl in rest_of_decl_compilation\n    in the case where we did not do so before the initializer.\n    Once we find the error_mark_node, we know that the value of\n    size_directive_output was set\n    by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n-#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n-do {\t\t\t\t\t\t\t\t\t \\\n-     char * name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n-     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n-         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n-\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n-\t && !size_directive_output)\t\t\t\t\t \\\n-       {\t\t\t\t\t\t\t\t \\\n-\t size_directive_output = 1;\t\t\t\t\t \\\n-\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n-\t assemble_name (FILE, name);\t\t\t\t\t \\\n-\t putc (',', FILE);\t\t\t\t\t\t \\\n-\t fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\t \\\n-\t\t  int_size_in_bytes (TREE_TYPE (DECL))); \t\t \\\n-\tfputc ('\\n', FILE);\t\t\t\t\t\t \\\n-       }\t\t\t\t\t\t\t\t \\\n-   } while (0)\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      char * name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\\\n+      if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t\\\n+          && ! AT_END && TOP_LEVEL\t\t\t\t\t\\\n+\t  && DECL_INITIAL (DECL) == error_mark_node\t\t\t\\\n+\t  && !size_directive_output)\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  size_directive_output = 1;\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\\\n+\t  assemble_name (FILE, name);\t\t\t\t\t\\\n+\t  putc (',', FILE);\t\t\t\t\t\t\\\n+\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\t\\\n+\t\t  int_size_in_bytes (TREE_TYPE (DECL)));\t\t\\\n+\t fputc ('\\n', FILE);\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to declare the size of a function.  */\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        char label[256];\t\t\t\t\t\t\\\n-\tstatic int labelno;\t\t\t\t\t\t\\\n-\tlabelno ++;\t\t\t\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n-\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n-\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n-\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n-        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, label);\t\t\t\t\t\\\n-        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n-\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive)\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          char label[256];\t\t\t\t\t\\\n+\t  static int labelno;\t\t\t\t\t\\\n+\t  labelno ++;\t\t\t\t\t\t\\\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\\\n+\t  ASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\\\n+\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+          fprintf (FILE, \",\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, label);\t\t\t\t\\\n+          fprintf (FILE, \"-\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  putc ('\\n', FILE);\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Define this macro if jump tables (for `tablejump' insns) should be\n    output in the text section, along with the assembler instructions.\n@@ -180,7 +186,7 @@ extern int arm_structure_size_boundary;\n    is a valid machine specific attribute for DECL.\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n-arm_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)\n+  arm_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)\n \f\n \n /* A C statement to output assembler commands which will identify the\n@@ -193,39 +199,42 @@ arm_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)\n    before the N_SO in order for gdb to find it.  */\n #ifndef ASM_IDENTIFY_GCC\n #define ASM_IDENTIFY_GCC(STREAM) \t\t\t\t\\\n-     fprintf (STREAM, \"%sgcc2_compiled.:\\n\", LOCAL_LABEL_PREFIX )\n+  fprintf (STREAM, \"%sgcc2_compiled.:\\n\", LOCAL_LABEL_PREFIX )\n #endif\n \n /* This outputs a lot of .req's to define alias for various registers.\n    Let's try to avoid this.  */\n #ifndef ASM_FILE_START\n-#define ASM_FILE_START(STREAM) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  extern char * version_string;\t\t\t\t\t\\\n-  fprintf (STREAM, \"%s Generated by gcc %s for ARM/elf\\n\",\t\\\n-\t   ASM_COMMENT_START, version_string);\t\t\t\\\n-  output_file_directive ((STREAM), main_input_filename);\t\\\n-} while (0)\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      extern char * version_string;\t\t\t\t\\\n+      fprintf (STREAM, \"%s Generated by gcc %s for ARM/elf\\n\",\t\\\n+\t       ASM_COMMENT_START, version_string);\t\t\\\n+      output_file_directive ((STREAM), main_input_filename);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n-     \n+\n /* Output an internal label definition.  */\n #ifndef ASM_OUTPUT_INTERNAL_LABEL\n #define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)  \t\\\n-  do                                    \t      \t   \t\\\n-    {\t\t\t\t\t\t      \t   \t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n       char * s = (char *) alloca (40 + strlen (PREFIX));\t\\\n-      extern int arm_target_label, arm_ccfsm_state;\t   \t\\\n+      extern int arm_target_label, arm_ccfsm_state;\t\t\\\n       extern rtx arm_target_insn;\t\t\t\t\\\n-\t\t\t\t\t\t           \t\\\n-      if (arm_ccfsm_state == 3 && arm_target_label == (NUM)   \t\\\n+\t\t\t\t\t\t\t\t\\\n+      if (arm_ccfsm_state == 3 && arm_target_label == (NUM)\t\\\n \t&& !strcmp (PREFIX, \"L\"))\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  arm_ccfsm_state = 0;\t\t\t\t        \\\n+\t  arm_ccfsm_state = 0;\t\t\t\t\t\\\n \t  arm_target_insn = NULL;\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (s, (PREFIX), (NUM));   \t\\\n-\tASM_OUTPUT_LABEL (STREAM, s);\t                \t\\\n-    } while (0)\n+\tASM_GENERATE_INTERNAL_LABEL (s, (PREFIX), (NUM));\t\\\n+\tarm_asm_output_label (STREAM, s);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \f\n /* Support the ctors/dtors and other sections.  */\n@@ -308,32 +317,41 @@ dtors_section ()\t\t\t\t\t\t\t\\\n /* A C statement (sans semicolon) to output an element in the table of\n    global constructors.  */\n #ifndef ASM_OUTPUT_CONSTRUCTOR\n-#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  ctors_section ();\t\t\t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_CONSTRUCTOR(STREAM, NAME)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      ctors_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+      assemble_name (STREAM, NAME);\t\t\\\n+      fprintf (STREAM, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n #endif\n      \n /* A C statement (sans semicolon) to output an element in the table of\n    global destructors.  */\n #ifndef ASM_OUTPUT_DESTRUCTOR\n-#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \\\n-do {\t\t\t\t\t\t\\\n-  dtors_section ();                   \t\t\\\n-  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n-  assemble_name (STREAM, NAME);              \t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_DESTRUCTOR(STREAM, NAME)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      dtors_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+      assemble_name (STREAM, NAME);\t\t\\\n+      fprintf (STREAM, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n #endif\n \n /* This is how we tell the assembler that a symbol is weak.  */\n \n-#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n-  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n-       fputc ('\\n', FILE); } while (0)\n+#define ASM_WEAKEN_LABEL(FILE, NAME)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fputs (\"\\t.weak\\t\", FILE);\t\t\\\n+      assemble_name (FILE, NAME);\t\t\\\n+      fputc ('\\n', FILE);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* For PIC code we need to explicitly specify (PLT) and (GOT) relocs.  */\n #define NEED_PLT_GOT\tflag_pic\n@@ -345,10 +363,10 @@ do {\t\t\t\t\t\t\\\n    machine.  Use this macro to limit the alignment which can be\n    specified using the `__attribute__ ((aligned (N)))' construct.  If\n    not defined, the default value is `BIGGEST_ALIGNMENT'.  */\n-#define MAX_OFILE_ALIGNMENT (32768*8)\n+#define MAX_OFILE_ALIGNMENT (32768 * 8)\n \n /* Align output to a power of two.  */\n #define ASM_OUTPUT_ALIGN(STREAM, POWER)  \\\n-   fprintf (STREAM, \"\\t.align\\t%d\\n\", POWER)\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\", POWER)\n \n #include \"arm/aout.h\""}, {"sha": "1902c2a4b72d641344681ddfb330f2b71eb05d6a", "filename": "gcc/invoke.texi", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62b10bbc331241e7ceebffb7ef9bfc80884f53d5/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=62b10bbc331241e7ceebffb7ef9bfc80884f53d5", "patch": "@@ -263,13 +263,17 @@ in the following sections.\n -mbsd -mxopen -mno-symrename\n -mabort-on-noreturn\n -mno-sched-prolog\n+-mnop-fun-dllimport -mno-nop-fun-dllimport\n \n @emph{Thumb Options}\n -mtpcs-frame -mno-tpcs-frame\n -mtpcs-leaf-frame -mno-tpcs-leaf-frame\n -mlittle-endian  -mbig-endian\n -mthumb-interwork -mno-thumb-interwork\n -mstructure-size-boundary=\n+-mnop-fun-dllimport -mno-nop-fun-dllimport\n+-mcallee-super-interworking -mno-callee-super-interworking\n+-mcaller-super-interworking -mno-caller-super-interworking\n \n @emph{MN10200 Options}\n -mrelax\n@@ -3853,25 +3857,33 @@ suppresses this pass.  The post-processor is never run when the\n compiler is built for cross-compilation.\n \n @item -mcpu=<name>\n-@itemx -mtune=<name>\n @kindex -mcpu=\n-@kindex -mtune=\n This specifies the name of the target ARM processor.  GCC uses this name\n to determine what kind of instructions it can use when generating\n assembly code.  Permissable names are: arm2, arm250, arm3, arm6, arm60,\n arm600, arm610, arm620, arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi,\n arm70, arm700, arm700i, arm710, arm710c, arm7100, arm7500, arm7500fe,\n arm7tdmi, arm8, strongarm, strongarm110, strongarm1100, arm8, arm810,\n-arm9, arm9tdmi.  @samp{-mtune=} is a synonym for @samp{-mcpue=} to\n-support older versions of GCC.\n+arm9, arm920, arm920t, arm9tdmi.\n+\n+@itemx -mtune=<name>\n+@kindex -mtune=\n+This option is very similar to the @samp{-mcpu=} option, except that\n+instead of specifying the actual target processor type, and hence\n+restricting which instructions can be used, it specifies that GCC should\n+tune the performance of the code as if the target were of the type\n+specified in this option, but still choosing the instructions that it\n+will generate based on the cpu specified by a @samp{-mcpu=} option.\n+For some arm implementations better performance can be obtained by using\n+this option.\n \n @item -march=<name>\n @kindex -march=\n This specifies the name of the target ARM architecture.  GCC uses this\n name to determine what kind of instructions it can use when generating\n assembly code.  This option can be used in conjunction with or instead\n of the @samp{-mcpu=} option.  Permissable names are: armv2, armv2a,\n-armv3, armv3m, armv4, armv4t\n+armv3, armv3m, armv4, armv4t, armv5.\n \n @item -mfpe=<number>\n @itemx -mfp=<number>\n@@ -3900,6 +3912,10 @@ value as future versions of the toolchain may default to this value.\n Generate a call to the function abort at the end of a noreturn function.\n It will be executed if the function tries to return.\n \n+@item -mnop-fun-dllimport\n+@kindex -mnop-fun-dllimport\n+Disable the support for the @emph{dllimport} attribute.\n+\n @end table\n \n @node Thumb Options\n@@ -3953,6 +3969,24 @@ libraries compiled with the other value, if they exchange information\n using structures or unions.  Programmers are encouraged to use the 32\n value as future versions of the toolchain may default to this value.\n \n+@item -mnop-fun-dllimport\n+@kindex -mnop-fun-dllimport\n+Disable the support for the @emph{dllimport} attribute.\n+\n+@item -mcallee-super-interworking\n+@kindex -mcallee-super-interworking\n+Gives all externally visible functions in the file being compiled an ARM\n+instruction set header which switches to Thumb mode before executing the\n+rest of the function.  This allows these functions to be called from\n+non-interworking code.\n+\n+@item -mcaller-super-interworking\n+@kindex -mcaller-super-interworking\n+Allows calls via function pointers (including virtual functions) to\n+execute correctly regardless of whether the target code has been\n+compiled for interworking or not.  There is a small overhead in the cost\n+of executing a funciton pointer if this option is enabled.\n+\n @end table\n \n @node MN10200 Options"}]}