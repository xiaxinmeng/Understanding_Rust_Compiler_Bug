{"sha": "2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIzYWI4NzljN2UwMGQxZDlhODYzNTdiZjEzZWJiMDg1OWFiOWM4OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-19T03:03:28Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-19T03:03:28Z"}, "message": "constexpr.c (struct constexpr_ctx): Add quiet field.\n\n\t* constexpr.c (struct constexpr_ctx): Add quiet field.\n\t(cxx_eval_outermost_constant_expr, is_sub_constant_expr): Set it.\n\t(lots): Replace allow_non_constant parameter with ctx->quiet.\n\nFrom-SVN: r217746", "tree": {"sha": "dd9c93c0914b7e68729714f3ca85b4866afc511d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd9c93c0914b7e68729714f3ca85b4866afc511d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "643266a5a530e0b78c99cd9c7efe0bf8a0b0fc40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643266a5a530e0b78c99cd9c7efe0bf8a0b0fc40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/643266a5a530e0b78c99cd9c7efe0bf8a0b0fc40"}], "stats": {"total": 248, "additions": 124, "deletions": 124}, "files": [{"sha": "fefe4142f6775b174b702891c50c85035a870d66", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "patch": "@@ -1,5 +1,9 @@\n 2014-11-18  Jason Merrill  <jason@redhat.com>\n \n+\t* constexpr.c (struct constexpr_ctx): Add quiet field.\n+\t(cxx_eval_outermost_constant_expr, is_sub_constant_expr): Set it.\n+\t(lots): Replace allow_non_constant parameter with ctx->quiet.\n+\n \tPR c++/63940\n \t* constexpr.c (cxx_eval_binary_expression): Don't assume the\n \texpression was already folded."}, {"sha": "7cdf649c5f0cb3ae487709b450afa9dd131606d3", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 120, "deletions": 124, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (verify_constant ((X), allow_non_constant, non_constant_p, overflow_p)) \\\n+  if (verify_constant ((X), ctx->quiet, non_constant_p, overflow_p)) \\\n     return t;\t\t\t\t\t\t\t\t\\\n  } while (0)\n \n@@ -863,6 +863,7 @@ struct constexpr_ctx {\n   hash_map<tree,tree> *values;\n   tree ctor;\n   tree object;\n+  bool quiet;\n };\n \n /* A table of all constexpr calls that have been evaluated by the\n@@ -871,7 +872,7 @@ struct constexpr_ctx {\n static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n static tree cxx_eval_constant_expression (const constexpr_ctx *, tree,\n-\t\t\t\t\t  bool, bool, bool *, bool *, tree *);\n+\t\t\t\t\t  bool, bool *, bool *, tree *);\n \n /* Compute a hash value for a constexpr call representation.  */\n \n@@ -982,7 +983,7 @@ lookup_parameter_binding (const constexpr_call *call, tree t)\n \n static tree\n cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n-\t\t\t\tbool allow_non_constant, bool addr,\n+\t\t\t\tbool addr,\n \t\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   const int nargs = call_expr_nargs (t);\n@@ -992,10 +993,10 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n   for (i = 0; i < nargs; ++i)\n     {\n       args[i] = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, i),\n-\t\t\t\t\t      allow_non_constant, addr,\n+\t\t\t\t\t      addr,\n \t\t\t\t\t      non_constant_p, overflow_p,\n \t\t\t\t\t      NULL);\n-      if (allow_non_constant && *non_constant_p)\n+      if (ctx->quiet && *non_constant_p)\n \treturn t;\n     }\n   if (*non_constant_p)\n@@ -1034,7 +1035,6 @@ adjust_temp_type (tree type, tree temp)\n static void\n cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n                              constexpr_call *new_call,\n-\t\t\t     bool allow_non_constant,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   const int nargs = call_expr_nargs (t);\n@@ -1067,11 +1067,11 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  type = TREE_TYPE (type);\n \t  x = convert_from_reference (x);\n \t}\n-      arg = cxx_eval_constant_expression (ctx, x, allow_non_constant,\n+      arg = cxx_eval_constant_expression (ctx, x,\n \t\t\t\t\t  TREE_CODE (type) == REFERENCE_TYPE,\n \t\t\t\t\t  non_constant_p, overflow_p, NULL);\n       /* Don't VERIFY_CONSTANT here.  */\n-      if (*non_constant_p && allow_non_constant)\n+      if (*non_constant_p && ctx->quiet)\n \treturn;\n       /* Just discard ellipsis args after checking their constantitude.  */\n       if (!parms)\n@@ -1134,7 +1134,7 @@ cx_error_context (void)\n \n static tree\n cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t  bool allow_non_constant, bool addr,\n+\t\t\t  bool addr,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n@@ -1148,7 +1148,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n   if (TREE_CODE (fun) != FUNCTION_DECL)\n     {\n       /* Might be a constexpr function pointer.  */\n-      fun = cxx_eval_constant_expression (ctx, fun, allow_non_constant,\n+      fun = cxx_eval_constant_expression (ctx, fun,\n \t\t\t\t\t  /*addr*/false, non_constant_p,\n \t\t\t\t\t  overflow_p, NULL);\n       STRIP_NOPS (fun);\n@@ -1157,7 +1157,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n     }\n   if (TREE_CODE (fun) != FUNCTION_DECL)\n     {\n-      if (!allow_non_constant && !*non_constant_p)\n+      if (!ctx->quiet && !*non_constant_p)\n \terror_at (loc, \"expression %qE does not designate a constexpr \"\n \t\t  \"function\", fun);\n       *non_constant_p = true;\n@@ -1166,11 +1166,11 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n   if (DECL_CLONED_FUNCTION_P (fun))\n     fun = DECL_CLONED_FUNCTION (fun);\n   if (is_builtin_fn (fun))\n-    return cxx_eval_builtin_function_call (ctx, t, allow_non_constant,\n+    return cxx_eval_builtin_function_call (ctx, t,\n \t\t\t\t\t   addr, non_constant_p, overflow_p);\n   if (!DECL_DECLARED_CONSTEXPR_P (fun))\n     {\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \t{\n \t  error_at (loc, \"call to non-constexpr function %qD\", fun);\n \t  explain_invalid_constexpr_fn (fun);\n@@ -1185,7 +1185,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       if (call_expr_nargs (t) == 2)\n \t{\n \t  tree arg = convert_from_reference (get_nth_callarg (t, 1));\n-\t  return cxx_eval_constant_expression (ctx, arg, allow_non_constant,\n+\t  return cxx_eval_constant_expression (ctx, arg,\n \t\t\t\t\t       addr, non_constant_p,\n \t\t\t\t\t       overflow_p, NULL);\n \t}\n@@ -1202,7 +1202,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       new_call.fundef = retrieve_constexpr_fundef (fun);\n       if (new_call.fundef == NULL || new_call.fundef->body == NULL)\n         {\n-\t  if (!allow_non_constant)\n+\t  if (!ctx->quiet)\n \t    {\n \t      if (DECL_INITIAL (fun))\n \t\t{\n@@ -1232,7 +1232,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n     }\n \n   cxx_bind_parameters_in_call (ctx, t, &new_call,\n-\t\t\t       allow_non_constant, non_constant_p, overflow_p);\n+\t\t\t       non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n \n@@ -1257,15 +1257,15 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n      so that we can detect circular dependencies.  */\n   else if (entry->result == NULL)\n     {\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"call has circular dependency\");\n       *non_constant_p = true;\n       entry->result = result = error_mark_node;\n     }\n \n   if (!depth_ok)\n     {\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"constexpr evaluation depth exceeds maximum of %d (use \"\n \t       \"-fconstexpr-depth= to increase the maximum)\",\n \t       max_constexpr_depth);\n@@ -1282,7 +1282,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      new_ctx.call = &new_call;\n \t      result = (cxx_eval_constant_expression\n \t\t\t(&new_ctx, new_call.fundef->body,\n-\t\t\t allow_non_constant, addr,\n+\t\t\t addr,\n \t\t\t non_constant_p, overflow_p, NULL));\n \t    }\n \t  else\n@@ -1324,7 +1324,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\tctx->values->put (res, NULL_TREE);\n \n \t      tree jump_target = NULL_TREE;\n-\t      cxx_eval_constant_expression (ctx, body, allow_non_constant,\n+\t      cxx_eval_constant_expression (ctx, body,\n \t\t\t\t\t    addr, non_constant_p, overflow_p,\n \t\t\t\t\t    &jump_target);\n \n@@ -1340,7 +1340,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t  result = *ctx->values->get (slot ? slot : res);\n \t\t  if (result == NULL_TREE)\n \t\t    {\n-\t\t      if (!allow_non_constant)\n+\t\t      if (!ctx->quiet)\n \t\t\terror (\"constexpr call flows off the end \"\n \t\t\t       \"of the function\");\n \t\t      *non_constant_p = true;\n@@ -1452,12 +1452,12 @@ verify_constant (tree t, bool allow_non_constant, bool *non_constant_p,\n \n static tree\n cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t   bool allow_non_constant, bool addr,\n+\t\t\t   bool addr,\n \t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n-  tree arg = cxx_eval_constant_expression (ctx, orig_arg, allow_non_constant,\n+  tree arg = cxx_eval_constant_expression (ctx, orig_arg,\n \t\t\t\t\t   addr, non_constant_p, overflow_p,\n \t\t\t\t\t   NULL);\n   VERIFY_CONSTANT (arg);\n@@ -1481,19 +1481,19 @@ cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t    bool allow_non_constant, bool addr,\n+\t\t\t    bool addr,\n \t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_lhs = TREE_OPERAND (t, 0);\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n   lhs = cxx_eval_constant_expression (ctx, orig_lhs,\n-\t\t\t\t      allow_non_constant, addr,\n+\t\t\t\t      addr,\n \t\t\t\t      non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (lhs);\n   rhs = cxx_eval_constant_expression (ctx, orig_rhs,\n-\t\t\t\t      allow_non_constant, addr,\n+\t\t\t\t      addr,\n \t\t\t\t      non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (rhs);\n \n@@ -1518,23 +1518,23 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t\t bool allow_non_constant, bool addr,\n+\t\t\t\t bool addr,\n \t\t\t\t bool *non_constant_p, bool *overflow_p,\n \t\t\t\t tree *jump_target)\n {\n   tree val = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   addr,\n \t\t\t\t\t   non_constant_p, overflow_p,\n \t\t\t\t\t   NULL);\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n     return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n-\t\t\t\t\t allow_non_constant, addr,\n+\t\t\t\t\t addr,\n \t\t\t\t\t non_constant_p, overflow_p,\n \t\t\t\t\t jump_target);\n   return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t       addr,\n \t\t\t\t       non_constant_p, overflow_p,\n \t\t\t\t       jump_target);\n }\n@@ -1544,12 +1544,12 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n-\t\t\t  bool allow_non_constant, bool addr,\n+\t\t\t  bool addr,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   tree oldary = TREE_OPERAND (t, 0);\n   tree ary = cxx_eval_constant_expression (ctx, oldary,\n-\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   addr,\n \t\t\t\t\t   non_constant_p, overflow_p, NULL);\n   tree index, oldidx;\n   HOST_WIDE_INT i;\n@@ -1559,7 +1559,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n     return t;\n   oldidx = TREE_OPERAND (t, 1);\n   index = cxx_eval_constant_expression (ctx, oldidx,\n-\t\t\t\t\tallow_non_constant, false,\n+\t\t\t\t\tfalse,\n \t\t\t\t\tnon_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (index);\n   if (addr && ary == oldary && index == oldidx)\n@@ -1590,19 +1590,19 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t     initializer, it's value-initialized.  */\n \t  tree val = build_value_init (elem_type, tf_warning_or_error);\n \t  return cxx_eval_constant_expression (ctx, val,\n-\t\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t\t       addr,\n \t\t\t\t\t       non_constant_p, overflow_p,\n \t\t\t\t\t       NULL);\n \t}\n \n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"array subscript out of bound\");\n       *non_constant_p = true;\n       return t;\n     }\n   else if (tree_int_cst_lt (index, integer_zero_node))\n     {\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"negative array subscript\");\n       *non_constant_p = true;\n       return t;\n@@ -1628,7 +1628,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool allow_non_constant, bool addr,\n+\t\t\t      bool addr,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   unsigned HOST_WIDE_INT i;\n@@ -1637,7 +1637,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   tree part = TREE_OPERAND (t, 1);\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n-\t\t\t\t\t     allow_non_constant, addr,\n+\t\t\t\t\t     addr,\n \t\t\t\t\t     non_constant_p, overflow_p, NULL);\n   if (whole == orig_whole)\n     return t;\n@@ -1648,13 +1648,13 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n      CONSTRUCTOR.  */\n   if (!*non_constant_p && TREE_CODE (whole) != CONSTRUCTOR)\n     {\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"%qE is not a constant expression\", orig_whole);\n       *non_constant_p = true;\n     }\n   if (DECL_MUTABLE_P (part))\n     {\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"mutable %qD is not usable in a constant expression\", part);\n       *non_constant_p = true;\n     }\n@@ -1675,7 +1675,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n       && CONSTRUCTOR_NELTS (whole) > 0)\n     {\n       /* DR 1188 says we don't have to deal with this.  */\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"accessing %qD member instead of initialized %qD member in \"\n \t       \"constant expression\", part, CONSTRUCTOR_ELT (whole, 0)->index);\n       *non_constant_p = true;\n@@ -1687,7 +1687,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n       /* 'whole' is part of the aggregate initializer we're currently\n \t building; if there's no initializer for this member yet, that's an\n \t error. */\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"accessing uninitialized member %qD\", part);\n       *non_constant_p = true;\n       return t;\n@@ -1696,7 +1696,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   /* If there's no explicit init for this field, it's value-initialized.  */\n   value = build_value_init (TREE_TYPE (t), tf_warning_or_error);\n   return cxx_eval_constant_expression (ctx, value,\n-\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t       addr,\n \t\t\t\t       non_constant_p, overflow_p, NULL);\n }\n \n@@ -1706,15 +1706,15 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n-\t\t\tbool allow_non_constant, bool addr,\n+\t\t\tbool addr,\n \t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree retval, fldval, utype, mask;\n   bool fld_seen = false;\n   HOST_WIDE_INT istart, isize;\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n-\t\t\t\t\t     allow_non_constant, addr,\n+\t\t\t\t\t     addr,\n \t\t\t\t\t     non_constant_p, overflow_p, NULL);\n   tree start, field, value;\n   unsigned HOST_WIDE_INT i;\n@@ -1727,7 +1727,7 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n       && TREE_CODE (whole) != VECTOR_CST\n       && TREE_CODE (whole) != CONSTRUCTOR)\n     {\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"%qE is not a constant expression\", orig_whole);\n       *non_constant_p = true;\n     }\n@@ -1792,19 +1792,19 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n static tree\n cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,\n                              tree bailout_value, tree continue_value,\n-\t\t\t     bool allow_non_constant, bool addr,\n+\t\t\t     bool addr,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   addr,\n \t\t\t\t\t   non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (lhs);\n   if (tree_int_cst_equal (lhs, bailout_value))\n     return lhs;\n   gcc_assert (tree_int_cst_equal (lhs, continue_value));\n   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t    allow_non_constant, addr, non_constant_p,\n+\t\t\t\t    addr, non_constant_p,\n \t\t\t\t    overflow_p, NULL);\n   VERIFY_CONSTANT (r);\n   return r;\n@@ -1926,7 +1926,7 @@ verify_ctor_sanity (const constexpr_ctx *ctx, tree type)\n \n static tree\n cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n-\t\t\t bool allow_non_constant, bool addr,\n+\t\t\t bool addr,\n \t\t\t bool *non_constant_p, bool *overflow_p)\n {\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n@@ -1947,11 +1947,11 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \t   initializers can refer to it.  */\n \tCONSTRUCTOR_APPEND_ELT (*p, index, new_ctx.ctor);\n       tree elt = cxx_eval_constant_expression (&new_ctx, value,\n-\t\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t\t       addr,\n \t\t\t\t\t       non_constant_p, overflow_p,\n \t\t\t\t\t       NULL);\n       /* Don't VERIFY_CONSTANT here.  */\n-      if (allow_non_constant && *non_constant_p)\n+      if (ctx->quiet && *non_constant_p)\n \tbreak;\n       if (elt != value)\n \tchanged = true;\n@@ -2007,7 +2007,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n-\t\t     bool value_init, bool allow_non_constant, bool addr,\n+\t\t     bool value_init, bool addr,\n \t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree elttype = TREE_TYPE (atype);\n@@ -2058,15 +2058,15 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t    eltinit = cp_build_array_ref (input_location, init, idx,\n \t\t\t\t\t  tf_warning_or_error);\n \t  eltinit = cxx_eval_vec_init_1 (&new_ctx, elttype, eltinit, value_init,\n-\t\t\t\t\t allow_non_constant, addr,\n+\t\t\t\t\t addr,\n \t\t\t\t\t non_constant_p, overflow_p);\n \t}\n       else if (pre_init)\n \t{\n \t  /* Initializing an element using value or default initialization\n \t     we just pre-built above.  */\n \t  eltinit = (cxx_eval_constant_expression\n-\t\t     (&new_ctx, init, allow_non_constant,\n+\t\t     (&new_ctx, init,\n \t\t      addr, non_constant_p, overflow_p, NULL));\n \t}\n       else\n@@ -2080,10 +2080,10 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t    eltinit = move (eltinit);\n \t  eltinit = force_rvalue (eltinit, tf_warning_or_error);\n \t  eltinit = (cxx_eval_constant_expression\n-\t\t     (&new_ctx, eltinit, allow_non_constant, addr,\n+\t\t     (&new_ctx, eltinit, addr,\n \t\t      non_constant_p, overflow_p, NULL));\n \t}\n-      if (*non_constant_p && !allow_non_constant)\n+      if (*non_constant_p && !ctx->quiet)\n \tbreak;\n       if (new_ctx.ctor != ctx->ctor)\n \t{\n@@ -2105,14 +2105,14 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \n static tree\n cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n-\t\t   bool allow_non_constant, bool addr,\n+\t\t   bool addr,\n \t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree atype = TREE_TYPE (t);\n   tree init = VEC_INIT_EXPR_INIT (t);\n   tree r = cxx_eval_vec_init_1 (ctx, atype, init,\n \t\t\t\tVEC_INIT_EXPR_VALUE_INIT (t),\n-\t\t\t\tallow_non_constant, addr, non_constant_p, overflow_p);\n+\t\t\t\taddr, non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n   else\n@@ -2312,11 +2312,11 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \n static tree\n cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n-\t\t       bool allow_non_constant, bool addr,\n+\t\t       bool addr,\n \t\t       bool *non_constant_p, bool *overflow_p)\n {\n   tree orig_op0 = TREE_OPERAND (t, 0);\n-  tree op0 = cxx_eval_constant_expression (ctx, orig_op0, allow_non_constant,\n+  tree op0 = cxx_eval_constant_expression (ctx, orig_op0,\n \t\t\t\t\t   /*addr*/false, non_constant_p,\n \t\t\t\t\t   overflow_p, NULL);\n   bool empty_base = false;\n@@ -2330,7 +2330,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \t\t\t     &empty_base);\n \n   if (r)\n-    r = cxx_eval_constant_expression (ctx, r, allow_non_constant,\n+    r = cxx_eval_constant_expression (ctx, r,\n \t\t\t\t      addr, non_constant_p, overflow_p, NULL);\n   else\n     {\n@@ -2343,7 +2343,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \t  gcc_assert (!same_type_ignoring_top_level_qualifiers_p\n \t\t      (TREE_TYPE (TREE_TYPE (sub)), TREE_TYPE (t)));\n \t  /* DR 1188 says we don't have to deal with this.  */\n-\t  if (!allow_non_constant)\n+\t  if (!ctx->quiet)\n \t    error (\"accessing value of %qE through a %qT glvalue in a \"\n \t\t   \"constant expression\", build_fold_indirect_ref (sub),\n \t\t   TREE_TYPE (t));\n@@ -2422,7 +2422,7 @@ non_const_var_error (tree r)\n \n static tree\n cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t     bool allow_non_constant, bool addr,\n+\t\t\t     bool addr,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   int i;\n@@ -2432,7 +2432,7 @@ cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n   for (i = 0; i < 3; i++)\n     {\n       args[i] = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, i),\n-\t\t\t\t\t      allow_non_constant, addr,\n+\t\t\t\t\t      addr,\n \t\t\t\t\t      non_constant_p, overflow_p,\n \t\t\t\t\t      NULL);\n       VERIFY_CONSTANT (args[i]);\n@@ -2458,15 +2458,15 @@ var_in_constexpr_fn (tree t)\n \n static tree\n cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t   bool allow_non_constant, bool addr,\n+\t\t\t   bool addr,\n \t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   constexpr_ctx new_ctx = *ctx;\n \n   /* First we figure out where we're storing to.  */\n   tree target = TREE_OPERAND (t, 0);\n   target = cxx_eval_constant_expression (ctx, target,\n-\t\t\t\t\t allow_non_constant, true,\n+\t\t\t\t\t true,\n \t\t\t\t\t non_constant_p, overflow_p, NULL);\n   if (*non_constant_p)\n     return t;\n@@ -2499,7 +2499,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n     {\n       /* A constant-expression cannot modify objects from outside the\n \t constant-expression.  */\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n \terror (\"modification of %qD is not a constant-expression\", object);\n       *non_constant_p = true;\n       return t;\n@@ -2542,7 +2542,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n     }\n \n   tree init = cxx_eval_constant_expression (&new_ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\t    allow_non_constant, false,\n+\t\t\t\t\t    false,\n \t\t\t\t\t    non_constant_p, overflow_p, NULL);\n   if (target == object)\n     /* The hash table might have moved since the get earlier.  */\n@@ -2562,7 +2562,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool allow_non_constant, bool addr,\n+\t\t\t      bool addr,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   enum tree_code code = TREE_CODE (t);\n@@ -2572,12 +2572,12 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n   gcc_assert (TREE_CONSTANT (offset));\n \n   /* The operand as an lvalue.  */\n-  op = cxx_eval_constant_expression (ctx, op, allow_non_constant, true,\n+  op = cxx_eval_constant_expression (ctx, op, true,\n \t\t\t\t     non_constant_p, overflow_p, NULL);\n \n   /* The operand as an rvalue.  */\n   tree val = rvalue (op);\n-  val = cxx_eval_constant_expression (ctx, val, allow_non_constant, false,\n+  val = cxx_eval_constant_expression (ctx, val, false,\n \t\t\t\t      non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (val);\n \n@@ -2598,7 +2598,7 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n \n   /* Storing the modified value.  */\n   tree store = build2 (MODIFY_EXPR, type, op, mod);\n-  cxx_eval_constant_expression (ctx, store, allow_non_constant,\n+  cxx_eval_constant_expression (ctx, store,\n \t\t\t\ttrue, non_constant_p, overflow_p, NULL);\n \n   /* And the value of the expression.  */\n@@ -2686,7 +2686,6 @@ label_matches (tree *jump_target, tree_stmt_iterator i,\n \n static tree\n cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n-\t\t\t bool allow_non_constant,\n \t\t\t bool *non_constant_p, bool *overflow_p,\n \t\t\t tree *jump_target)\n {\n@@ -2707,7 +2706,7 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n \t    continue;\n \t}\n       cxx_eval_constant_expression (ctx, stmt,\n-\t\t\t\t    allow_non_constant, false,\n+\t\t\t\t    false,\n \t\t\t\t    non_constant_p, overflow_p,\n \t\t\t\t    jump_target);\n       if (*non_constant_p)\n@@ -2729,14 +2728,13 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n-\t\t    bool allow_non_constant,\n \t\t    bool *non_constant_p, bool *overflow_p,\n \t\t    tree *jump_target)\n {\n   tree body = TREE_OPERAND (t, 0);\n   while (true)\n     {\n-      cxx_eval_statement_list (ctx, body, allow_non_constant,\n+      cxx_eval_statement_list (ctx, body,\n \t\t\t       non_constant_p, overflow_p, jump_target);\n       if (returns (jump_target) || breaks (jump_target))\n \tbreak;\n@@ -2751,18 +2749,17 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n-\t\t      bool allow_non_constant,\n \t\t      bool *non_constant_p, bool *overflow_p,\n \t\t      tree *jump_target)\n {\n   tree cond = TREE_OPERAND (t, 0);\n-  cond = cxx_eval_constant_expression (ctx, cond, allow_non_constant, false,\n+  cond = cxx_eval_constant_expression (ctx, cond, false,\n \t\t\t\t       non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (cond);\n   *jump_target = cond;\n \n   tree body = TREE_OPERAND (t, 1);\n-  cxx_eval_statement_list (ctx, body, allow_non_constant,\n+  cxx_eval_statement_list (ctx, body,\n \t\t\t   non_constant_p, overflow_p, jump_target);\n   if (breaks (jump_target) || switches (jump_target))\n     *jump_target = NULL_TREE;\n@@ -2776,7 +2773,7 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool allow_non_constant, bool addr,\n+\t\t\t      bool addr,\n \t\t\t      bool *non_constant_p, bool *overflow_p,\n \t\t\t      tree *jump_target)\n {\n@@ -2792,7 +2789,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     {\n       if (TREE_CODE (t) == PTRMEM_CST)\n \tt = cplus_expand_constant (t);\n-      else if (TREE_OVERFLOW (t) && (!flag_permissive || allow_non_constant))\n+      else if (TREE_OVERFLOW (t) && (!flag_permissive || ctx->quiet))\n \t*overflow_p = true;\n       return t;\n     }\n@@ -2824,7 +2821,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  r = *p;\n       if (DECL_P (r))\n \t{\n-\t  if (!allow_non_constant)\n+\t  if (!ctx->quiet)\n \t    non_const_var_error (r);\n \t  *non_constant_p = true;\n \t}\n@@ -2849,15 +2846,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t/* Defer in case this is only used for its type.  */;\n       else\n \t{\n-\t  if (!allow_non_constant)\n+\t  if (!ctx->quiet)\n \t    error (\"%qE is not a constant expression\", t);\n \t  *non_constant_p = true;\n \t}\n       break;\n \n     case CALL_EXPR:\n     case AGGR_INIT_EXPR:\n-      r = cxx_eval_call_expression (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_call_expression (ctx, t, addr,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n@@ -2878,7 +2875,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tif (tree init = DECL_INITIAL (r))\n \t  {\n \t    init = cxx_eval_constant_expression (ctx, init,\n-\t\t\t\t\t\t allow_non_constant, false,\n+\t\t\t\t\t\t false,\n \t\t\t\t\t\t non_constant_p, overflow_p,\n \t\t\t\t\t\t NULL);\n \t    ctx->values->put (r, init);\n@@ -2893,7 +2890,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case TARGET_EXPR:\n       if (!literal_type_p (TREE_TYPE (t)))\n \t{\n-\t  if (!allow_non_constant)\n+\t  if (!ctx->quiet)\n \t    {\n \t      error (\"temporary of non-literal type %qT in a \"\n \t\t     \"constant expression\", TREE_TYPE (t));\n@@ -2917,7 +2914,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       /* Pass false for 'addr' because this indicates\n \t initialization of a temporary.  */\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\tallow_non_constant, false,\n+\t\t\t\t\tfalse,\n \t\t\t\t\tnon_constant_p, overflow_p, NULL);\n       if (!*non_constant_p)\n \t/* Adjust the type of the result to the type of the temporary.  */\n@@ -2930,25 +2927,25 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  /* In C++11 constexpr evaluation we are looking for the value,\n \t     not the side-effect of the initialization.  */\n \t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\t    allow_non_constant, false,\n+\t\t\t\t\t    false,\n \t\t\t\t\t    non_constant_p, overflow_p, NULL);\n \t  break;\n \t}\n       /* else fall through */\n     case MODIFY_EXPR:\n-      r = cxx_eval_store_expression (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_store_expression (ctx, t, addr,\n \t\t\t\t     non_constant_p, overflow_p);\n       break;\n \n     case SCOPE_REF:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\taddr,\n \t\t\t\t\tnon_constant_p, overflow_p, NULL);\n       break;\n \n     case RETURN_EXPR:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\taddr,\n \t\t\t\t\tnon_constant_p, overflow_p, NULL);\n       *jump_target = t;\n       break;\n@@ -2961,7 +2958,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case EXPR_STMT:\n     case EH_SPEC_BLOCK:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\taddr,\n \t\t\t\t\tnon_constant_p, overflow_p,\n \t\t\t\t\tjump_target);\n       break;\n@@ -2970,15 +2967,14 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t check for a constant operand or result; an address can be\n \t constant without its operand being, and vice versa.  */\n     case INDIRECT_REF:\n-      r = cxx_eval_indirect_ref (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_indirect_ref (ctx, t, addr,\n \t\t\t\t non_constant_p, overflow_p);\n       break;\n \n     case ADDR_EXPR:\n       {\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n-\t\t\t\t\t\tallow_non_constant,\n \t\t\t\t\t\t/*addr*/true,\n \t\t\t\t\t\tnon_constant_p, overflow_p,\n \t\t\t\t\t\tNULL);\n@@ -3002,7 +2998,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case BIT_NOT_EXPR:\n     case TRUTH_NOT_EXPR:\n     case FIXED_CONVERT_EXPR:\n-      r = cxx_eval_unary_expression (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_unary_expression (ctx, t, addr,\n \t\t\t\t     non_constant_p, overflow_p);\n       break;\n \n@@ -3031,17 +3027,17 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tSTRIP_NOPS (op1);\n \tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n \t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n-\t  r = cxx_eval_constant_expression (ctx, op0, allow_non_constant,\n+\t  r = cxx_eval_constant_expression (ctx, op0,\n \t\t\t\t\t    addr, non_constant_p, overflow_p,\n \t\t\t\t\t    jump_target);\n \telse\n \t  {\n \t    /* Check that the LHS is constant and then discard it.  */\n-\t    cxx_eval_constant_expression (ctx, op0, allow_non_constant,\n+\t    cxx_eval_constant_expression (ctx, op0,\n \t\t\t\t\t  false, non_constant_p, overflow_p,\n \t\t\t\t\t  jump_target);\n \t    op1 = TREE_OPERAND (t, 1);\n-\t    r = cxx_eval_constant_expression (ctx, op1, allow_non_constant,\n+\t    r = cxx_eval_constant_expression (ctx, op1,\n \t\t\t\t\t      addr, non_constant_p, overflow_p,\n \t\t\t\t\t      jump_target);\n \t  }\n@@ -3087,7 +3083,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case LTGT_EXPR:\n     case RANGE_EXPR:\n     case COMPLEX_EXPR:\n-      r = cxx_eval_binary_expression (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_binary_expression (ctx, t, addr,\n \t\t\t\t      non_constant_p, overflow_p);\n       break;\n \n@@ -3097,20 +3093,20 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case TRUTH_ANDIF_EXPR:\n       r = cxx_eval_logical_expression (ctx, t, boolean_false_node,\n \t\t\t\t       boolean_true_node,\n-\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t       addr,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case TRUTH_OR_EXPR:\n     case TRUTH_ORIF_EXPR:\n       r = cxx_eval_logical_expression (ctx, t, boolean_true_node,\n \t\t\t\t       boolean_false_node,\n-\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t       addr,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case ARRAY_REF:\n-      r = cxx_eval_array_reference (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_array_reference (ctx, t, addr,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n@@ -3121,28 +3117,28 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t     build_non_dependent_expr,  because any expression that\n \t     calls or takes the address of the function will have\n \t     pulled a FUNCTION_DECL out of the COMPONENT_REF.  */\n-\t  gcc_checking_assert (allow_non_constant || errorcount);\n+\t  gcc_checking_assert (ctx->quiet || errorcount);\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n-      r = cxx_eval_component_reference (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_component_reference (ctx, t, addr,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n     case BIT_FIELD_REF:\n-      r = cxx_eval_bit_field_ref (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_bit_field_ref (ctx, t, addr,\n \t\t\t\t  non_constant_p, overflow_p);\n       break;\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n-      r = cxx_eval_conditional_expression (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_conditional_expression (ctx, t, addr,\n \t\t\t\t\t   non_constant_p, overflow_p,\n \t\t\t\t\t   jump_target);\n       break;\n \n     case CONSTRUCTOR:\n-      r = cxx_eval_bare_aggregate (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_bare_aggregate (ctx, t, addr,\n \t\t\t\t   non_constant_p, overflow_p);\n       break;\n \n@@ -3152,13 +3148,13 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t be NULL, meaning default-initialization, or it will be an lvalue\n \t or xvalue of the same type, meaning direct-initialization from the\n \t corresponding member.  */\n-      r = cxx_eval_vec_init (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_vec_init (ctx, t, addr,\n \t\t\t     non_constant_p, overflow_p);\n       break;\n \n     case FMA_EXPR:\n     case VEC_PERM_EXPR:\n-      r = cxx_eval_trinary_expression (ctx, t, allow_non_constant, addr,\n+      r = cxx_eval_trinary_expression (ctx, t, addr,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n@@ -3168,7 +3164,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       {\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n-\t\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\t\taddr,\n \t\t\t\t\t\tnon_constant_p, overflow_p,\n \t\t\t\t\t\tNULL);\n \tif (*non_constant_p)\n@@ -3177,7 +3173,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    && TREE_CODE (op) == INTEGER_CST\n \t    && !integer_zerop (op))\n \t  {\n-\t    if (!allow_non_constant)\n+\t    if (!ctx->quiet)\n \t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n \t\t\t\"reinterpret_cast from integer to pointer\");\n \t    *non_constant_p = true;\n@@ -3204,20 +3200,20 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case STATEMENT_LIST:\n       new_ctx = *ctx;\n       new_ctx.ctor = new_ctx.object = NULL_TREE;\n-      return cxx_eval_statement_list (&new_ctx, t, allow_non_constant,\n+      return cxx_eval_statement_list (&new_ctx, t,\n \t\t\t\t      non_constant_p, overflow_p, jump_target);\n \n     case BIND_EXPR:\n       return cxx_eval_constant_expression (ctx, BIND_EXPR_BODY (t),\n-\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   addr,\n \t\t\t\t\t   non_constant_p, overflow_p,\n \t\t\t\t\t   jump_target);\n \n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      return cxx_eval_increment_expression (ctx, t, allow_non_constant,\n+      return cxx_eval_increment_expression (ctx, t,\n \t\t\t\t\t    addr, non_constant_p, overflow_p);\n \n     case LAMBDA_EXPR:\n@@ -3234,7 +3230,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case NON_DEPENDENT_EXPR:\n     case BASELINK:\n     case OFFSET_REF:\n-      if (!allow_non_constant)\n+      if (!ctx->quiet)\n         error_at (EXPR_LOC_OR_LOC (t, input_location),\n \t\t  \"expression %qE is not a constant-expression\", t);\n       *non_constant_p = true;\n@@ -3246,7 +3242,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  /* A placeholder without a referent.  We can get here when\n \t     checking whether NSDMIs are noexcept, or in massage_init_elt;\n \t     just say it's non-constant for now.  */\n-\t  gcc_assert (allow_non_constant);\n+\t  gcc_assert (ctx->quiet);\n \t  *non_constant_p = true;\n \t  break;\n \t}\n@@ -3259,7 +3255,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n \t\t      (TREE_TYPE (t), TREE_TYPE (ctor)));\n \t  return cxx_eval_constant_expression\n-\t    (ctx, ctor, allow_non_constant, addr,\n+\t    (ctx, ctor, addr,\n \t     non_constant_p, overflow_p, NULL);\n \t}\n       break;\n@@ -3270,12 +3266,12 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case LOOP_EXPR:\n-      cxx_eval_loop_expr (ctx, t, allow_non_constant,\n+      cxx_eval_loop_expr (ctx, t,\n \t\t\t  non_constant_p, overflow_p, jump_target);\n       break;\n \n     case SWITCH_EXPR:\n-      cxx_eval_switch_expr (ctx, t, allow_non_constant,\n+      cxx_eval_switch_expr (ctx, t,\n \t\t\t    non_constant_p, overflow_p, jump_target);\n       break;\n \n@@ -3301,7 +3297,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n {\n   bool non_constant_p = false;\n   bool overflow_p = false;\n-  constexpr_ctx ctx = { NULL, NULL, NULL, NULL };\n+  constexpr_ctx ctx = { NULL, NULL, NULL, NULL, allow_non_constant };\n   hash_map<tree,tree> map;\n   ctx.values = &map;\n   tree type = initialized_type (t);\n@@ -3336,7 +3332,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \tr = TARGET_EXPR_INITIAL (r);\n     }\n \n-  r = cxx_eval_constant_expression (&ctx, r, allow_non_constant,\n+  r = cxx_eval_constant_expression (&ctx, r,\n \t\t\t\t    false, &non_constant_p, &overflow_p, NULL);\n \n   verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n@@ -3410,10 +3406,10 @@ is_sub_constant_expr (tree t)\n {\n   bool non_constant_p = false;\n   bool overflow_p = false;\n-  constexpr_ctx ctx = { NULL, NULL, NULL, NULL };\n+  constexpr_ctx ctx = { NULL, NULL, NULL, NULL, true };\n   hash_map <tree, tree> map;\n   ctx.values = &map;\n-  cxx_eval_constant_expression (&ctx, t, true, false, &non_constant_p,\n+  cxx_eval_constant_expression (&ctx, t, false, &non_constant_p,\n \t\t\t\t&overflow_p, NULL);\n   return !non_constant_p && !overflow_p;\n }"}]}