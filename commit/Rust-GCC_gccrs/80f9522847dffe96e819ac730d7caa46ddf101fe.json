{"sha": "80f9522847dffe96e819ac730d7caa46ddf101fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBmOTUyMjg0N2RmZmU5NmU4MTlhYzczMGQ3Y2FhNDZkZGYxMDFmZQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-18T22:32:22Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-18T22:32:22Z"}, "message": "re PR fortran/45290 ([F08] pointer initialization)\n\n2010-08-19  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45290\n\t* gfortran.h (gfc_add_save): Modified prototype.\n\t* decl.c (add_init_expr_to_sym): Defer checking of proc pointer init.\n\t(match_pointer_init): New function to match F08 pointer initialization.\n\t(variable_decl,match_procedure_decl,match_ppc_decl): Use\n\t'match_pointer_init'.\n\t(match_attr_spec): Module variables are implicitly SAVE.\n\t(gfc_match_save): Modified call to 'gfc_add_save'.\n\t* expr.c (gfc_check_assign_symbol): Extra checks for pointer\n\tinitialization.\n\t* primary.c (gfc_variable_attr): Handle SAVE attribute.\n\t* resolve.c (resolve_structure_cons): Add new argument and do pointer\n\tinitialization checks.\n\t(gfc_resolve_expr): Modified call to 'resolve_structure_cons'.\n\t(resolve_values): Call 'resolve_structure_cons' directly with init arg.\n\t(resolve_fl_variable): Handle SAVE_IMPLICIT.\n\t* symbol.c (gfc_add_save,gfc_copy_attr,save_symbol): Handle\n\tSAVE_IMPLICIT.\n\t* trans-decl.c (gfc_create_module_variable): Module variables with\n\tTARGET can already exist.\n\t* trans-expr.c (gfc_conv_variable): Check for 'current_function_decl'.\n\t(gfc_conv_initializer): Implement non-NULL pointer\n\tinitialization.\n\n\n2010-08-19  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45290\n\t* gfortran.dg/proc_ptr_comp_3.f90: Modified.\n\t* gfortran.dg/pointer_init_2.f90: New.\n\t* gfortran.dg/pointer_init_3.f90: New.\n\t* gfortran.dg/pointer_init_4.f90: New.\n\nFrom-SVN: r163356", "tree": {"sha": "f271d1f77c0f13161bf127f660a05f91bcca1311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f271d1f77c0f13161bf127f660a05f91bcca1311"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80f9522847dffe96e819ac730d7caa46ddf101fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f9522847dffe96e819ac730d7caa46ddf101fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f9522847dffe96e819ac730d7caa46ddf101fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f9522847dffe96e819ac730d7caa46ddf101fe/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbb12873f243b8e02582f77950d3a03d7453a0cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb12873f243b8e02582f77950d3a03d7453a0cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb12873f243b8e02582f77950d3a03d7453a0cc"}], "stats": {"total": 360, "additions": 296, "deletions": 64}, "files": [{"sha": "cfc71c19991c70208d40551a1d48fe2795669019", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -1,3 +1,29 @@\n+2010-08-19  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45290\n+\t* gfortran.h (gfc_add_save): Modified prototype.\n+\t* decl.c (add_init_expr_to_sym): Defer checking of proc pointer init.\n+\t(match_pointer_init): New function to match F08 pointer initialization.\n+\t(variable_decl,match_procedure_decl,match_ppc_decl): Use\n+\t'match_pointer_init'.\n+\t(match_attr_spec): Module variables are implicitly SAVE.\n+\t(gfc_match_save): Modified call to 'gfc_add_save'.\n+\t* expr.c (gfc_check_assign_symbol): Extra checks for pointer\n+\tinitialization.\n+\t* primary.c (gfc_variable_attr): Handle SAVE attribute.\n+\t* resolve.c (resolve_structure_cons): Add new argument and do pointer\n+\tinitialization checks.\n+\t(gfc_resolve_expr): Modified call to 'resolve_structure_cons'.\n+\t(resolve_values): Call 'resolve_structure_cons' directly with init arg.\n+\t(resolve_fl_variable): Handle SAVE_IMPLICIT.\n+\t* symbol.c (gfc_add_save,gfc_copy_attr,save_symbol): Handle\n+\tSAVE_IMPLICIT.\n+\t* trans-decl.c (gfc_create_module_variable): Module variables with\n+\tTARGET can already exist.\n+\t* trans-expr.c (gfc_conv_variable): Check for 'current_function_decl'.\n+\t(gfc_conv_initializer): Implement non-NULL pointer\n+\tinitialization.\n+\n 2010-08-18  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/45295"}, {"sha": "5b4ab182ed7b1f100aa9f7b2650bffcaa08282f9", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -1312,9 +1312,10 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t}\n \n       /* Check if the assignment can happen. This has to be put off\n-\t until later for a derived type variable.  */\n+\t until later for derived type variables and procedure pointers.  */\n       if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED\n \t  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS\n+\t  && !sym->attr.proc_pointer \n \t  && gfc_check_assign_symbol (sym, init) == FAILURE)\n \treturn FAILURE;\n \n@@ -1652,6 +1653,48 @@ gfc_match_null (gfc_expr **result)\n }\n \n \n+/* Match the initialization expr for a data pointer or procedure pointer.  */\n+\n+static match\n+match_pointer_init (gfc_expr **init, int procptr)\n+{\n+  match m;\n+\n+  if (gfc_pure (NULL) && gfc_state_stack->state != COMP_DERIVED)\n+    {\n+      gfc_error (\"Initialization of pointer at %C is not allowed in \"\n+\t\t \"a PURE procedure\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* Match NULL() initilization.  */\n+  m = gfc_match_null (init);\n+  if (m != MATCH_NO)\n+    return m;\n+\n+  /* Match non-NULL initialization.  */\n+  gfc_matching_procptr_assignment = procptr;\n+  m = gfc_match_rvalue (init);\n+  gfc_matching_procptr_assignment = 0;\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+  else if (m == MATCH_NO)\n+    {\n+      gfc_error (\"Error in pointer initialization at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (!procptr)\n+    gfc_resolve_expr (*init);\n+  \n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: non-NULL pointer \"\n+\t\t      \"initialization at %C\") == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a variable name with an optional initializer.  When this\n    subroutine is called, a variable is expected to be parsed next.\n    Depending on what is happening at the moment, updates either the\n@@ -1899,23 +1942,9 @@ variable_decl (int elem)\n \t      goto cleanup;\n \t    }\n \n-\t  m = gfc_match_null (&initializer);\n-\t  if (m == MATCH_NO)\n-\t    {\n-\t      gfc_error (\"Pointer initialization requires a NULL() at %C\");\n-\t      m = MATCH_ERROR;\n-\t    }\n-\n-\t  if (gfc_pure (NULL) && gfc_state_stack->state != COMP_DERIVED)\n-\t    {\n-\t      gfc_error (\"Initialization of pointer at %C is not allowed in \"\n-\t\t\t \"a PURE procedure\");\n-\t      m = MATCH_ERROR;\n-\t    }\n-\n+\t  m = match_pointer_init (&initializer, 0);\n \t  if (m != MATCH_YES)\n \t    goto cleanup;\n-\n \t}\n       else if (gfc_match_char ('=') == MATCH_YES)\n \t{\n@@ -3511,7 +3540,7 @@ match_attr_spec (void)\n \t  break;\n \n \tcase DECL_SAVE:\n-\t  t = gfc_add_save (&current_attr, NULL, &seen_at[d]);\n+\t  t = gfc_add_save (&current_attr, SAVE_EXPLICIT, NULL, &seen_at[d]);\n \t  break;\n \n \tcase DECL_TARGET:\n@@ -3551,6 +3580,10 @@ match_attr_spec (void)\n \t}\n     }\n \n+  /* Module variables implicitly have the SAVE attribute.  */\n+  if (gfc_current_state () == COMP_MODULE && !current_attr.save)\n+    current_attr.save = SAVE_IMPLICIT;\n+\n   colon_seen = 1;\n   return MATCH_YES;\n \n@@ -4675,20 +4708,7 @@ match_procedure_decl (void)\n \t      goto cleanup;\n \t    }\n \n-\t  m = gfc_match_null (&initializer);\n-\t  if (m == MATCH_NO)\n-\t    {\n-\t      gfc_error (\"Pointer initialization requires a NULL() at %C\");\n-\t      m = MATCH_ERROR;\n-\t    }\n-\n-\t  if (gfc_pure (NULL))\n-\t    {\n-\t      gfc_error (\"Initialization of pointer at %C is not allowed in \"\n-\t\t\t \"a PURE procedure\");\n-\t      m = MATCH_ERROR;\n-\t    }\n-\n+\t  m = match_pointer_init (&initializer, 1);\n \t  if (m != MATCH_YES)\n \t    goto cleanup;\n \n@@ -4815,18 +4835,7 @@ match_ppc_decl (void)\n \n       if (gfc_match (\" =>\") == MATCH_YES)\n \t{\n-\t  m = gfc_match_null (&initializer);\n-\t  if (m == MATCH_NO)\n-\t    {\n-\t      gfc_error (\"Pointer initialization requires a NULL() at %C\");\n-\t      m = MATCH_ERROR;\n-\t    }\n-\t  if (gfc_pure (NULL))\n-\t    {\n-\t      gfc_error (\"Initialization of pointer at %C is not allowed in \"\n-\t\t\t \"a PURE procedure\");\n-\t      m = MATCH_ERROR;\n-\t    }\n+\t  m = match_pointer_init (&initializer, 1);\n \t  if (m != MATCH_YES)\n \t    {\n \t      gfc_free_expr (initializer);\n@@ -6720,8 +6729,8 @@ gfc_match_save (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_save (&sym->attr, sym->name, &gfc_current_locus)\n-\t      == FAILURE)\n+\t  if (gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name,\n+\t\t\t    &gfc_current_locus) == FAILURE)\n \t    return MATCH_ERROR;\n \t  goto next_item;\n "}, {"sha": "3d9f6dc61bf143f3041b7a17915bceed492a3e02", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -3552,7 +3552,35 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n \n   gfc_free (lvalue.symtree);\n \n-  return r;\n+  if (r == FAILURE)\n+    return r;\n+  \n+  if (sym->attr.pointer && rvalue->expr_type != EXPR_NULL)\n+    {\n+      /* F08:C461. Additional checks for pointer initialization.  */\n+      symbol_attribute attr;\n+      attr = gfc_expr_attr (rvalue);\n+      if (attr.allocatable)\n+\t{\n+\t  gfc_error (\"Pointer initialization target at %C \"\n+\t             \"must not be ALLOCATABLE \");\n+\t  return FAILURE;\n+\t}\n+      if (!attr.target)\n+\t{\n+\t  gfc_error (\"Pointer initialization target at %C \"\n+\t\t     \"must have the TARGET attribute\");\n+\t  return FAILURE;\n+\t}\n+      if (!attr.save)\n+\t{\n+\t  gfc_error (\"Pointer initialization target at %C \"\n+\t\t     \"must have the SAVE attribute\");\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  return SUCCESS;\n }\n \n "}, {"sha": "89a8e504711c80cf84c3819d93f15f007673ae54", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -2466,7 +2466,7 @@ gfc_try gfc_add_cray_pointee (symbol_attribute *, locus *);\n match gfc_mod_pointee_as (gfc_array_spec *);\n gfc_try gfc_add_protected (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_result (symbol_attribute *, const char *, locus *);\n-gfc_try gfc_add_save (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_save (symbol_attribute *, save_state, const char *, locus *);\n gfc_try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_saved_common (symbol_attribute *, locus *);\n gfc_try gfc_add_target (symbol_attribute *, locus *);"}, {"sha": "63889856604e10496ef9a553a327e5683c007e83", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -2088,6 +2088,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   attr.pointer = pointer;\n   attr.allocatable = allocatable;\n   attr.target = target;\n+  attr.save = sym->attr.save;\n \n   return attr;\n }"}, {"sha": "f770f601115adfbec29ecd8acc6cf8df2496fb09", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -833,10 +833,11 @@ resolve_contained_functions (gfc_namespace *ns)\n \n \n /* Resolve all of the elements of a structure constructor and make sure that\n-   the types are correct.  */\n+   the types are correct. The 'init' flag indicates that the given\n+   constructor is an initializer.  */\n \n static gfc_try\n-resolve_structure_cons (gfc_expr *expr)\n+resolve_structure_cons (gfc_expr *expr, int init)\n {\n   gfc_constructor *cons;\n   gfc_component *comp;\n@@ -896,7 +897,8 @@ resolve_structure_cons (gfc_expr *expr)\n \n       /* If we don't have the right type, try to convert it.  */\n \n-      if (!gfc_compare_types (&cons->expr->ts, &comp->ts))\n+      if (!comp->attr.proc_pointer &&\n+\t  !gfc_compare_types (&cons->expr->ts, &comp->ts))\n \t{\n \t  t = FAILURE;\n \t  if (strcmp (comp->name, \"$extends\") == 0)\n@@ -1005,6 +1007,23 @@ resolve_structure_cons (gfc_expr *expr)\n \t\t     \"a TARGET\", &cons->expr->where, comp->name);\n \t}\n \n+      if (init)\n+\t{\n+\t  /* F08:C461. Additional checks for pointer initialization.  */\n+\t  if (a.allocatable)\n+\t    {\n+\t      t = FAILURE;\n+\t      gfc_error (\"Pointer initialization target at %L \"\n+\t\t\t \"must not be ALLOCATABLE \", &cons->expr->where);\n+\t    }\n+\t  if (!a.save)\n+\t    {\n+\t      t = FAILURE;\n+\t      gfc_error (\"Pointer initialization target at %L \"\n+\t\t\t \"must have the SAVE attribute\", &cons->expr->where);\n+\t    }\n+\t}\n+\n       /* F2003, C1272 (3).  */\n       if (gfc_pure (NULL) && cons->expr->expr_type == EXPR_VARIABLE\n \t  && (gfc_impure_variable (cons->expr->symtree->n.sym)\n@@ -1015,6 +1034,7 @@ resolve_structure_cons (gfc_expr *expr)\n \t\t     \"pointer component '%s' at %L in PURE procedure\",\n \t\t     comp->name, &cons->expr->where);\n \t}\n+\n     }\n \n   return t;\n@@ -5977,7 +5997,7 @@ gfc_resolve_expr (gfc_expr *e)\n       if (t == FAILURE)\n \tbreak;\n \n-      t = resolve_structure_cons (e);\n+      t = resolve_structure_cons (e, 0);\n       if (t == FAILURE)\n \tbreak;\n \n@@ -8924,10 +8944,17 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n static void\n resolve_values (gfc_symbol *sym)\n {\n+  gfc_try t;\n+\n   if (sym->value == NULL)\n     return;\n \n-  if (gfc_resolve_expr (sym->value) == FAILURE)\n+  if (sym->value->expr_type == EXPR_STRUCTURE)\n+    t= resolve_structure_cons (sym->value, 1);\n+  else \n+    t = gfc_resolve_expr (sym->value);\n+\n+  if (t == FAILURE)\n     return;\n \n   gfc_check_assign_symbol (sym, sym->value);\n@@ -9636,7 +9663,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t  return FAILURE;\n \t}\n \n-      if (e && sym->attr.save && !gfc_is_constant_expr (e))\n+      if (e && sym->attr.save == SAVE_EXPLICIT && !gfc_is_constant_expr (e))\n \t{\n \t  gfc_error (auto_save_msg, sym->name, &sym->declared_at);\n \t  return FAILURE;"}, {"sha": "4d3db861053ed997041057d0ae34ab3c7512ab31", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -1095,21 +1095,22 @@ gfc_add_result (symbol_attribute *attr, const char *name, locus *where)\n \n \n gfc_try\n-gfc_add_save (symbol_attribute *attr, const char *name, locus *where)\n+gfc_add_save (symbol_attribute *attr, save_state s, const char *name,\n+\t      locus *where)\n {\n \n   if (check_used (attr, name, where))\n     return FAILURE;\n \n-  if (gfc_pure (NULL))\n+  if (s == SAVE_EXPLICIT && gfc_pure (NULL))\n     {\n       gfc_error\n \t(\"SAVE attribute at %L cannot be specified in a PURE procedure\",\n \t where);\n       return FAILURE;\n     }\n \n-  if (attr->save == SAVE_EXPLICIT && !attr->vtab)\n+  if (s == SAVE_EXPLICIT && attr->save == SAVE_EXPLICIT)\n     {\n \tif (gfc_notify_std (GFC_STD_LEGACY, \n \t\t\t    \"Duplicate SAVE attribute specified at %L\",\n@@ -1118,7 +1119,7 @@ gfc_add_save (symbol_attribute *attr, const char *name, locus *where)\n \t  return FAILURE;\n     }\n \n-  attr->save = SAVE_EXPLICIT;\n+  attr->save = s;\n   return check_conflict (attr, name, where);\n }\n \n@@ -1740,7 +1741,7 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n     goto fail;\n   if (src->is_protected && gfc_add_protected (dest, NULL, where) == FAILURE)\n     goto fail;\n-  if (src->save && gfc_add_save (dest, NULL, where) == FAILURE)\n+  if (src->save && gfc_add_save (dest, src->save, NULL, where) == FAILURE)\n     goto fail;\n   if (src->value && gfc_add_value (dest, NULL, where) == FAILURE)\n     goto fail;\n@@ -3430,7 +3431,7 @@ save_symbol (gfc_symbol *sym)\n   /* Automatic objects are not saved.  */\n   if (gfc_is_var_automatic (sym))\n     return;\n-  gfc_add_save (&sym->attr, sym->name, &sym->declared_at);\n+  gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name, &sym->declared_at);\n }\n \n "}, {"sha": "f3e29502054cf939fb1426dba9b92fe12216cf65", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -3587,7 +3587,7 @@ gfc_create_module_variable (gfc_symbol * sym)\n       && (sym->equiv_built || sym->attr.in_equivalence))\n     return;\n \n-  if (sym->backend_decl && !sym->attr.vtab)\n+  if (sym->backend_decl && !sym->attr.vtab && !sym->attr.target)\n     internal_error (\"backend decl for module variable %s already exists\",\n \t\t    sym->name);\n "}, {"sha": "810212ba9cffc553125fe8569e514a7aa3a1b608", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -556,7 +556,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n {\n   gfc_ref *ref;\n   gfc_symbol *sym;\n-  tree parent_decl;\n+  tree parent_decl = NULL_TREE;\n   int parent_flag;\n   bool return_value;\n   bool alternate_entry;\n@@ -590,7 +590,8 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       entry_master = sym->attr.result\n \t\t     && sym->ns->proc_name->attr.entry_master\n \t\t     && !gfc_return_by_reference (sym->ns->proc_name);\n-      parent_decl = DECL_CONTEXT (current_function_decl);\n+      if (current_function_decl)\n+\tparent_decl = DECL_CONTEXT (current_function_decl);\n \n       if ((se->expr == parent_decl && return_value)\n \t   || (sym->ns && sym->ns->proc_name\n@@ -3983,7 +3984,17 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n \treturn gfc_conv_array_initializer (type, expr);\n     }\n   else if (pointer)\n-    return fold_convert (type, null_pointer_node);\n+    {\n+      if (!expr || expr->expr_type == EXPR_NULL)\n+\treturn fold_convert (type, null_pointer_node);\n+      else\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  se.want_pointer = 1;\n+\t  gfc_conv_expr (&se, expr);\n+\t  return se.expr;\n+\t}\n+    }\n   else\n     {\n       switch (ts->type)"}, {"sha": "d033f9a9d57a9a49daa74611a80e15a8e59581fd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -1,3 +1,11 @@\n+2010-08-19  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45290\n+\t* gfortran.dg/proc_ptr_comp_3.f90: Modified.\n+\t* gfortran.dg/pointer_init_2.f90: New.\n+\t* gfortran.dg/pointer_init_3.f90: New.\n+\t* gfortran.dg/pointer_init_4.f90: New.\n+\n 2010-08-18  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR c++/45049"}, {"sha": "8f72663e259b828d6ae316a05a969ab7d2a20b81", "filename": "gcc/testsuite/gfortran.dg/pointer_init_2.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_2.f90?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+!\n+! PR 45290: [F08] pointer initialization\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+subroutine sub\n+  implicit none\n+\n+  real, target, save :: r\n+  integer, target, save, dimension(1:3) :: v\n+\n+  integer, save :: i\n+  integer, target :: j\n+  integer, target, save, allocatable :: a\n+\n+\n+  integer, pointer :: dp0 => 13  ! { dg-error \"Error in pointer initialization\" }\n+  integer, pointer :: dp1 => r   ! { dg-error \"Different types in pointer assignment\" }\n+  integer, pointer :: dp2 => v   ! { dg-error \"Different ranks in pointer assignment\" }\n+  integer, pointer :: dp3 => i   ! { dg-error \"is neither TARGET nor POINTER\" }\n+  integer, pointer :: dp4 => j   ! { dg-error \"must have the SAVE attribute\" }\n+  integer, pointer :: dp5 => a   ! { dg-error \"must not be ALLOCATABLE\" }\n+\n+  type :: t\n+    integer, pointer :: dpc0 => 13  ! { dg-error \"Error in pointer initialization\" }\n+    integer, pointer :: dpc1 => r   ! { dg-error \"is REAL but should be INTEGER\" }\n+    integer, pointer :: dpc2 => v   ! { dg-error \"rank of the element.*does not match\" }\n+    integer, pointer :: dpc3 => i   ! { dg-error \"should be a POINTER or a TARGET\" }\n+    integer, pointer :: dpc4 => j   ! { dg-error \"must have the SAVE attribute\" }\n+    integer, pointer :: dpc5 => a   ! { dg-error \"must not be ALLOCATABLE\" }\n+  end type\n+\n+  type(t) ::u\n+\n+end subroutine"}, {"sha": "867a428bf489c244e83018b22a3c9a55891e6a9e", "filename": "gcc/testsuite/gfortran.dg/pointer_init_3.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_3.f90?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+!\n+! PR 45290: [F08] pointer initialization\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+ integer, target  :: t1          ! SAVE is implicit\n+ integer, pointer :: p1 => t1\n+end module m\n+\n+\n+use m\n+implicit none\n+\n+integer,target :: i0 = 2\n+integer,target,dimension(1:3) :: vec = 1\n+\n+type :: t\n+  integer, pointer :: dpc => i0\n+  integer :: i = 0\n+end type\n+\n+type (t), save, target :: u\n+\n+integer, pointer :: dp => i0\n+integer, pointer :: dp2 => vec(2)\n+integer, pointer :: dp3 => u%i\n+\n+dp = 5\n+if (i0/=5) call abort()\n+\n+u%dpc = 6\n+if (i0/=6) call abort()\n+\n+dp2 = 3\n+if (vec(2)/=3) call abort()\n+\n+dp3 = 4\n+if (u%i/=4) call abort()\n+\n+end \n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "75ead452917093b84e0d5bd3d6d93f058286c562", "filename": "gcc/testsuite/gfortran.dg/pointer_init_4.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_init_4.f90?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+!\n+! PR 45290: [F08] pointer initialization\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+module m\n+\n+implicit none\n+\n+contains\n+\n+  integer function f1()\n+    f1 = 42\n+  end function\n+\n+  integer function f2()\n+    f2 = 43\n+  end function\n+\n+end module\n+\n+\n+program test_ptr_init\n+\n+use m\n+implicit none\n+\n+procedure(f1), pointer :: pp => f1\n+\n+type :: t\n+  procedure(f2), pointer, nopass :: ppc => f2\n+end type\n+\n+type (t) :: u\n+\n+if (pp()/=42) call abort()\n+if (u%ppc()/=43) call abort()\n+\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "4b866c0c562882ffff04a494c5758333790e802b", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_3.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f9522847dffe96e819ac730d7caa46ddf101fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90?ref=80f9522847dffe96e819ac730d7caa46ddf101fe", "patch": "@@ -22,7 +22,6 @@ subroutine sub\n   procedure(), pointer, nopass ptr4              ! { dg-error \"Expected '::'\" }\n   procedure(), pointer, nopass, pointer :: ptr5  ! { dg-error \"Duplicate\" }\n   procedure, pointer, nopass :: ptr6             ! { dg-error \"Syntax error\" }\n-  procedure(), pointer, nopass :: ptr7 => ptr2   ! { dg-error \"requires a NULL\" }\n   procedure(), nopass :: ptr8                    ! { dg-error \"POINTER attribute is required\" }\n   procedure(pp), pointer, nopass :: ptr9         ! { dg-error \"declared in a later PROCEDURE statement\" }\n   procedure(aaargh), pointer, nopass :: ptr10    ! { dg-error \"must be explicit\" }"}]}