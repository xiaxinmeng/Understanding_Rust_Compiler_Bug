{"sha": "b749b5ec58acd1da57f2afabac732027e8a88755", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0OWI1ZWM1OGFjZDFkYTU3ZjJhZmFiYWM3MzIwMjdlOGE4ODc1NQ==", "commit": {"author": {"name": "Jim Johnston", "email": "jjohnst@us.ibm.com", "date": "2020-04-03T06:46:11Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2020-04-03T06:46:11Z"}, "message": "S/390 zTPF: Handle skip trace addresses when unwinding\n\nCheck for and handle new skip trace addresses when unwinding on zTPF.\n\nlibgcc/ChangeLog:\n\n2020-04-03  Jim Johnston  <jjohnst@us.ibm.com>\n\n\t* config/s390/tpf-unwind.h (MIN_PATRANGE, MAX_PATRANGE)\n\t(TPFRA_OFFSET): Macros removed.\n\t(CP_CNF, cinfc_fast, CINFC_CMRESET, CINTFC_CMCENBKST)\n\t(CINTFC_CMCENBKED, ICST_CRET, ICST_SRET, LOWCORE_PAGE3_ADDR)\n\t(PG3_SKIPPING_OFFSET): New macros.\n\t(__isPATrange): Use cinfc_fast for the check.\n\t(__isSkipResetAddr): New function.\n\t(s390_fallback_frame_state): Check for skip trace addresses. Use\n\teither ICST_CRET or ICST_SRET to calculate return address\n\tlocation.\n\t(__tpf_eh_return): Handle skip trace addresses.", "tree": {"sha": "935bd6a0185d65b54e1175ba2d5bb18d90f156ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/935bd6a0185d65b54e1175ba2d5bb18d90f156ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b749b5ec58acd1da57f2afabac732027e8a88755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b749b5ec58acd1da57f2afabac732027e8a88755", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b749b5ec58acd1da57f2afabac732027e8a88755", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b749b5ec58acd1da57f2afabac732027e8a88755/comments", "author": {"login": "jjohnst-us", "id": 28395979, "node_id": "MDQ6VXNlcjI4Mzk1OTc5", "avatar_url": "https://avatars.githubusercontent.com/u/28395979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjohnst-us", "html_url": "https://github.com/jjohnst-us", "followers_url": "https://api.github.com/users/jjohnst-us/followers", "following_url": "https://api.github.com/users/jjohnst-us/following{/other_user}", "gists_url": "https://api.github.com/users/jjohnst-us/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjohnst-us/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjohnst-us/subscriptions", "organizations_url": "https://api.github.com/users/jjohnst-us/orgs", "repos_url": "https://api.github.com/users/jjohnst-us/repos", "events_url": "https://api.github.com/users/jjohnst-us/events{/privacy}", "received_events_url": "https://api.github.com/users/jjohnst-us/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "535ce76acbeb0791da0c2d707b543b54a9e0668f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535ce76acbeb0791da0c2d707b543b54a9e0668f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535ce76acbeb0791da0c2d707b543b54a9e0668f"}], "stats": {"total": 146, "additions": 89, "deletions": 57}, "files": [{"sha": "7548e34764033fa8e68d77d33153ef71fa9c74d6", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b749b5ec58acd1da57f2afabac732027e8a88755/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b749b5ec58acd1da57f2afabac732027e8a88755/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=b749b5ec58acd1da57f2afabac732027e8a88755", "patch": "@@ -1,3 +1,17 @@\n+2020-04-03  Jim Johnston  <jjohnst@us.ibm.com>\n+\n+\t* config/s390/tpf-unwind.h (MIN_PATRANGE, MAX_PATRANGE)\n+\t(TPFRA_OFFSET): Macros removed.\n+\t(CP_CNF, cinfc_fast, CINFC_CMRESET, CINTFC_CMCENBKST)\n+\t(CINTFC_CMCENBKED, ICST_CRET, ICST_SRET, LOWCORE_PAGE3_ADDR)\n+\t(PG3_SKIPPING_OFFSET): New macros.\n+\t(__isPATrange): Use cinfc_fast for the check.\n+\t(__isSkipResetAddr): New function.\n+\t(s390_fallback_frame_state): Check for skip trace addresses. Use\n+\teither ICST_CRET or ICST_SRET to calculate return address\n+\tlocation.\n+\t(__tpf_eh_return): Handle skip trace addresses.\n+\n 2020-03-26  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/94220"}, {"sha": "fadc06b5e596c54a71703bbe42c74a7c12d14016", "filename": "libgcc/config/s390/tpf-unwind.h", "status": "modified", "additions": 75, "deletions": 57, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b749b5ec58acd1da57f2afabac732027e8a88755/libgcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b749b5ec58acd1da57f2afabac732027e8a88755/libgcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2Ftpf-unwind.h?ref=b749b5ec58acd1da57f2afabac732027e8a88755", "patch": "@@ -32,20 +32,29 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    Description: This function simply checks to see if the address\n    passed to it is in the CP pat code range.  */\n \n-#define MIN_PATRANGE 0x10000\n-#define MAX_PATRANGE 0x800000\n+#define CP_CNF  0x000000000000c18u /* location of BSS CINFC pointer */\n+#define cinfc_fast(TAG) (void *) \\\n+  *((unsigned long *) *(unsigned long *) (CP_CNF) + (TAG))\n+#define CINFC_CMRESET 187\n+#define CINTFC_CMCENBKST 431\n+#define CINTFC_CMCENBKED 432\n \n static inline unsigned int\n __isPATrange (void *addr)\n {\n-  if (addr > (void *)MIN_PATRANGE && addr < (void *)MAX_PATRANGE)\n-    return 1;\n-  else\n-    return 0;\n+  return !!(addr > cinfc_fast (CINTFC_CMCENBKST)\n+\t    && addr < cinfc_fast (CINTFC_CMCENBKED));\n+}\n+\n+static inline unsigned int\n+__isSkipResetAddr (void *addr)\n+{\n+  return !!(addr == cinfc_fast (CINFC_CMRESET));\n }\n \n /* TPF return address offset from start of stack frame.  */\n-#define TPFRA_OFFSET 168\n+#define ICST_CRET 168\n+#define ICST_SRET 320\n \n /* Exceptions macro defined for TPF so that functions without\n    dwarf frame information can be used with exceptions.  */\n@@ -63,12 +72,12 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n         (((unsigned long int) context->cfa) - STACK_POINTER_OFFSET));\n \n   /* Are we going through special linkage code?  */\n-  if (__isPATrange (context->ra))\n+  if (__isPATrange (context->ra) || __isSkipResetAddr (context->ra))\n     {\n \n       /* Our return register isn't zero for end of stack, so\n          check backward stackpointer to see if it is zero.  */\n-      if (regs == NULL)\n+      if (regs == 0)\n          return _URC_END_OF_STACK;\n \n       /* No stack frame.  */\n@@ -83,11 +92,18 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n \t  fs->regs.reg[i].loc.reg = i;\n \t}\n \n-      /* ... except for %r14, which is stored at CFA-112\n-\t and used as return address.  */\n-      fs->regs.reg[14].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[14].loc.offset = TPFRA_OFFSET - STACK_POINTER_OFFSET;\n-      fs->retaddr_column = 14;\n+      /* ... except for %r14, which is stored at CFA+offset where offset\n+\t is displacment of ICST_CRET or ICST_SRET from CFA */\n+      if ( __isPATrange(context->ra) )  {\n+\t   fs->regs.reg[14].how = REG_SAVED_OFFSET;\n+\t   fs->regs.reg[14].loc.offset = ICST_CRET - STACK_POINTER_OFFSET;\n+\t   fs->retaddr_column = 14;\n+      }  else  {\n+\t   fs->regs.reg[14].how = REG_SAVED_OFFSET;\n+\t   fs->regs.reg[14].loc.offset = ICST_SRET - STACK_POINTER_OFFSET;\n+\t   fs->retaddr_column = 14;\n+\n+      }\n \n       return _URC_NO_REASON;\n     }\n@@ -140,6 +156,9 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n #define TPFAREA_SIZE STACK_POINTER_OFFSET-TPFAREA_OFFSET\n #define INVALID_RETURN 0\n \n+#define LOWCORE_PAGE3_ADDR 4032\n+#define PG3_SKIPPING_OFFSET 18\n+\n void * __tpf_eh_return (void *target, void *origRA);\n \n void *\n@@ -148,58 +167,49 @@ __tpf_eh_return (void *target, void *origRA)\n   Dl_info targetcodeInfo, currentcodeInfo;\n   int retval;\n   void *current, *stackptr, *destination_frame;\n+  unsigned char *skipFlagAddress;\n   unsigned long int shifter;\n-  bool is_a_stub, frameDepth2, firstIteration;\n+  bool is_a_stub;\n \n   is_a_stub = false;\n-  frameDepth2 = false;\n-  firstIteration = true;\n \n   /* Get code info for target return's address.  */\n   retval = dladdr (target, &targetcodeInfo);\n \n-  /* Check if original RA is a Pat stub.  If so set flag.  */\n-  if (__isPATrange (origRA))\n-    frameDepth2 = true;\n-\n   /* Ensure the code info is valid (for target).  */\n   if (retval != INVALID_RETURN)\n     {\n-      /* Get the stack pointer of the first stack frame beyond the\n-         unwinder or if exists the calling C++ runtime function (e.g.,\n-         __cxa_throw).  */\n-      if (!frameDepth2)\n-        stackptr = (void *) *((unsigned long int *) (*(PREVIOUS_STACK_PTR())));\n-      else\n-        stackptr = (void *) *(PREVIOUS_STACK_PTR());\n+      /* Begin climbing stack searching for target address. */\n+      stackptr = (void *) *(CURRENT_STACK_PTR());\n+\n+      /* Get return address based on our stackptr. */\n+      current = (void *) *(unsigned long *) (stackptr + RA_OFFSET);\n+\n+      /* Is current return address our initiating exception stack\n+\t frame? If not, climb the stack one more frame. */\n+      if (current != origRA)  {\n+\t   stackptr = (void *) *(unsigned long *) stackptr;\n+      }\n \n       /* Begin looping through stack frames.  Stop if invalid\n          code information is retrieved or if a match between the\n          current stack frame iteration shared object's address\n          matches that of the target, calculated above.  */\n       do\n         {\n-          if (!frameDepth2 || (frameDepth2 && !firstIteration))\n-            {\n-              /* Get return address based on our stackptr iterator.  */\n-              current = (void *) *((unsigned long int *)\n-                                   (stackptr + RA_OFFSET));\n-\n-              /* Is it a Pat Stub?  */\n-              if (__isPATrange (current))\n-                {\n-                  /* Yes it was, get real return address in TPF stack area.  */\n-                  current = (void *) *((unsigned long int *)\n-                                       (stackptr + TPFRA_OFFSET))\n-                  is_a_stub = true;\n-                }\n-            }\n-          else\n-            {\n-              current = (void *) *((unsigned long int *)\n-                                   (stackptr + TPFRA_OFFSET));\n-              is_a_stub = true;\n-            }\n+\t  /* Get return address based on our stackptr iterator.  */\n+\t  current = (void *) *(unsigned long *) (stackptr + RA_OFFSET);\n+\n+\t  /* Is it a Pat Stub?  */\n+\t  if (__isPATrange (current)\n+\t      || (__isSkipResetAddr (current)\n+\t\t  && __isPATrange ((void *) *(unsigned long *) (stackptr\n+\t\t\t\t\t\t\t\t+ ICST_SRET))))\n+\t    {\n+\t      /* Yes it was, get real return address in TPF stack area.  */\n+\t      current = (void *) *(unsigned long *) (stackptr + ICST_CRET);\n+\t      is_a_stub = true;\n+\t    }\n \n           /* Get codeinfo on RA so that we can figure out\n              the module address.  */\n@@ -227,8 +237,8 @@ __tpf_eh_return (void *target, void *origRA)\n                /* Now overlay the\n                   real target address into the TPF stack area of\n                   the target frame we are jumping to.  */\n-               *((unsigned long int *) (destination_frame +\n-                   TPFRA_OFFSET)) = (unsigned long int) target;\n+\t       *(unsigned long *) (destination_frame + ICST_CRET) =\n+\t\t (unsigned long) target;\n \n                /* Before returning the desired pat stub address to\n                   the exception handling unwinder so that it can\n@@ -237,10 +247,7 @@ __tpf_eh_return (void *target, void *origRA)\n                   This is necessary for CTOA stubs.\n                   Otherwise we leap one byte past where we want to\n                   go to in the TPF pat stub linkage code.  */\n-               if (!frameDepth2 || (frameDepth2 && !firstIteration))\n-                 shifter = *((unsigned long int *) (stackptr + RA_OFFSET));\n-               else\n-                 shifter = (unsigned long int) origRA;\n+\t       shifter = *(unsigned long *) (stackptr + RA_OFFSET);\n \n                shifter &= ~1ul;\n \n@@ -252,6 +259,13 @@ __tpf_eh_return (void *target, void *origRA)\n                   in linkage.  */\n                shifter = shifter - 4;\n \n+\t       /* Reset the Function Trace Skipping Switch to re-enable */\n+\t       /* recording Trace entries if it was turned off. */\n+\t       skipFlagAddress =\n+\t\t (unsigned char *) *(unsigned long *) LOWCORE_PAGE3_ADDR;\n+\t       skipFlagAddress += PG3_SKIPPING_OFFSET;\n+\t       *skipFlagAddress = '\\x00';\n+\n                return (void *) shifter;\n              }\n \n@@ -260,14 +274,18 @@ __tpf_eh_return (void *target, void *origRA)\n           stackptr = (void *) *(unsigned long int *) stackptr;\n \n           is_a_stub = false;\n-          firstIteration = false;\n \n         }  while (stackptr && retval != INVALID_RETURN\n                 && targetcodeInfo.dli_fbase != currentcodeInfo.dli_fbase);\n     }\n \n+  /* Reset the Function Trace Skipping Switch to re-enable */\n+  /* recording Trace entries if it was turned off. */\n+  skipFlagAddress = (unsigned char *) *(unsigned long *) LOWCORE_PAGE3_ADDR;\n+  skipFlagAddress += PG3_SKIPPING_OFFSET;\n+  *skipFlagAddress = '\\x00';\n+\n   /* No pat stub found, could be a problem?  Simply return unmodified\n      target address.  */\n   return target;\n }\n-"}]}