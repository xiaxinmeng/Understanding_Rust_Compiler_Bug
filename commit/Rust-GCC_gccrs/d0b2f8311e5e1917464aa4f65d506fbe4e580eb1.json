{"sha": "d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBiMmY4MzExZTVlMTkxNzQ2NGFhNGY2NWQ1MDZmYmU0ZTU4MGViMQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2013-08-05T17:58:22Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2013-08-05T17:58:22Z"}, "message": "re PR rtl-optimization/57708 (function clobbers callee saved register on ARM)\n\n\tPR rtl-optimization/57708\n\t* recog.c (peep2_find_free_register): Validate all regs in a\n\tmulti-reg mode.\n\nFrom-SVN: r201501", "tree": {"sha": "3587b9b99a17949bd6632984ba58cb5ef4ee7daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3587b9b99a17949bd6632984ba58cb5ef4ee7daa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1/comments", "author": null, "committer": null, "parents": [{"sha": "4b7dff77bfb5e2844b4d185217b27a1973670395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7dff77bfb5e2844b4d185217b27a1973670395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7dff77bfb5e2844b4d185217b27a1973670395"}], "stats": {"total": 70, "additions": 49, "deletions": 21}, "files": [{"sha": "eece522af1a229e6da0f7308cd41764a36897884", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "patch": "@@ -1,3 +1,9 @@\n+2013-08-05  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR rtl-optimization/57708\n+\t* recog.c (peep2_find_free_register): Validate all regs in a\n+\tmulti-reg mode.\n+\n 2013-08-05  Jan Hubicka  <jh@suse.cz>\n \n \tPR lto/57602"}, {"sha": "aa026a27d59938e8d64098b0998be64ecd6e9b48", "filename": "gcc/recog.c", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b2f8311e5e1917464aa4f65d506fbe4e580eb1/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d0b2f8311e5e1917464aa4f65d506fbe4e580eb1", "patch": "@@ -3124,39 +3124,61 @@ peep2_find_free_register (int from, int to, const char *class_str,\n       regno = raw_regno;\n #endif\n \n-      /* Don't allocate fixed registers.  */\n-      if (fixed_regs[regno])\n-\tcontinue;\n-      /* Don't allocate global registers.  */\n-      if (global_regs[regno])\n-\tcontinue;\n-      /* Make sure the register is of the right class.  */\n-      if (! TEST_HARD_REG_BIT (reg_class_contents[cl], regno))\n-\tcontinue;\n-      /* And can support the mode we need.  */\n+      /* Can it support the mode we need?  */\n       if (! HARD_REGNO_MODE_OK (regno, mode))\n \tcontinue;\n-      /* And that we don't create an extra save/restore.  */\n-      if (! call_used_regs[regno] && ! df_regs_ever_live_p (regno))\n-\tcontinue;\n-      if (! targetm.hard_regno_scratch_ok (regno))\n-\tcontinue;\n-\n-      /* And we don't clobber traceback for noreturn functions.  */\n-      if ((regno == FRAME_POINTER_REGNUM || regno == HARD_FRAME_POINTER_REGNUM)\n-\t  && (! reload_completed || frame_pointer_needed))\n-\tcontinue;\n \n       success = 1;\n-      for (j = hard_regno_nregs[regno][mode] - 1; j >= 0; j--)\n+      for (j = 0; success && j < hard_regno_nregs[regno][mode]; j++)\n \t{\n+\t  /* Don't allocate fixed registers.  */\n+\t  if (fixed_regs[regno + j])\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\t  /* Don't allocate global registers.  */\n+\t  if (global_regs[regno + j])\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\t  /* Make sure the register is of the right class.  */\n+\t  if (! TEST_HARD_REG_BIT (reg_class_contents[cl], regno + j))\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\t  /* And that we don't create an extra save/restore.  */\n+\t  if (! call_used_regs[regno + j] && ! df_regs_ever_live_p (regno + j))\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\n+\t  if (! targetm.hard_regno_scratch_ok (regno + j))\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\n+\t  /* And we don't clobber traceback for noreturn functions.  */\n+\t  if ((regno + j == FRAME_POINTER_REGNUM\n+\t       || regno + j == HARD_FRAME_POINTER_REGNUM)\n+\t      && (! reload_completed || frame_pointer_needed))\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\n \t  if (TEST_HARD_REG_BIT (*reg_set, regno + j)\n \t      || TEST_HARD_REG_BIT (live, regno + j))\n \t    {\n \t      success = 0;\n \t      break;\n \t    }\n \t}\n+\n       if (success)\n \t{\n \t  add_to_hard_reg_set (reg_set, mode, regno);"}]}