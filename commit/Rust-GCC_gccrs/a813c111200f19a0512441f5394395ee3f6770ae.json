{"sha": "a813c111200f19a0512441f5394395ee3f6770ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxM2MxMTEyMDBmMTlhMDUxMjQ0MWY1Mzk0Mzk1ZWUzZjY3NzBhZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-12-11T00:20:51Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-12-11T00:20:51Z"}, "message": "basic-block.h (BLOCK_HEAD, BLOCK_END): Remove.\n\n2003-12-11  Steven Bosscher  <steven@gcc.gnu.org>\n\n\t* basic-block.h (BLOCK_HEAD, BLOCK_END): Remove.\n\t(BLOCK_HEAD_TREE, BLOCK_END_TREE): Remove.\n\t(basic_block_def): Rename `head' to `head_' and `end' to `end_'.\n\t(BB_HEAD, BB_END): New accessor macros for the `head_' and `end_'\n\tfields of a basic block.\n\t* bb-reorder.c, bt-load.c, caller-save.c, cfg.c, cfganal.c,\n\tcfgbuild.c, cfgcleanup.c, cfglayout.c, cfgloop.c, cfgloopanal.c,\n\tcfgloopmanip.c, cfgrtl.c, combine.c, conflict.c, df.c, emit-rtl.c,\n\tfinal.c, flow.c, function.c, gcse.c, global.c, graph.c,\n\thaifa-sched.c, ifcvt.c, lcm.c, local-alloc.c, loop-unswitch.c,\n\tloop.c, postreload.c, predict.c, profile.c, ra-build.c, ra-debug.c,\n\tra-rewrite.c, ra.c, recog.c, reg-stack.c, regclass.c, regmove.c,\n\tregrename.c, reload1.c, resource.c, sched-ebb.c, sched-rgn.c,\n\tsibcall.c, tracer.c, config/frv/frv.c, config/i386/i386.c,\n\tconfig/ia64/ia64.c: Use the BB_HEAD and BB_END macros instead of\n\taccessing the `head' and `end' fields of a basic block directly.\n\n\t* gengtype.c: Add missing piece from earlier patch.  Dunno what\n\tI was thinking...\n\nFrom-SVN: r74520", "tree": {"sha": "753b85b3ca471980585369128978b9ba6e133c3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/753b85b3ca471980585369128978b9ba6e133c3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a813c111200f19a0512441f5394395ee3f6770ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a813c111200f19a0512441f5394395ee3f6770ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a813c111200f19a0512441f5394395ee3f6770ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a813c111200f19a0512441f5394395ee3f6770ae/comments", "author": null, "committer": null, "parents": [{"sha": "2086c099f62cc6d4c7fa4fd0fcbf8350f6c21364", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2086c099f62cc6d4c7fa4fd0fcbf8350f6c21364", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2086c099f62cc6d4c7fa4fd0fcbf8350f6c21364"}], "stats": {"total": 1295, "additions": 662, "deletions": 633}, "files": [{"sha": "0ab825b41654dc10fb75e64eebc9508f26dd8a93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -1,3 +1,25 @@\n+2003-12-11  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* basic-block.h (BLOCK_HEAD, BLOCK_END): Remove.\n+\t(BLOCK_HEAD_TREE, BLOCK_END_TREE): Remove.\n+\t(basic_block_def): Rename `head' to `head_' and `end' to `end_'.\n+\t(BB_HEAD, BB_END): New accessor macros for the `head_' and `end_'\n+\tfields of a basic block.\n+\t* bb-reorder.c, bt-load.c, caller-save.c, cfg.c, cfganal.c,\n+\tcfgbuild.c, cfgcleanup.c, cfglayout.c, cfgloop.c, cfgloopanal.c,\n+\tcfgloopmanip.c, cfgrtl.c, combine.c, conflict.c, df.c, emit-rtl.c,\n+\tfinal.c, flow.c, function.c, gcse.c, global.c, graph.c,\n+\thaifa-sched.c, ifcvt.c, lcm.c, local-alloc.c, loop-unswitch.c,\n+\tloop.c, postreload.c, predict.c, profile.c, ra-build.c, ra-debug.c,\n+\tra-rewrite.c, ra.c, recog.c, reg-stack.c, regclass.c, regmove.c,\n+\tregrename.c, reload1.c, resource.c, sched-ebb.c, sched-rgn.c,\n+\tsibcall.c, tracer.c, config/frv/frv.c, config/i386/i386.c,\n+\tconfig/ia64/ia64.c: Use the BB_HEAD and BB_END macros instead of\n+\taccessing the `head' and `end' fields of a basic block directly.\n+\n+\t* gengtype.c: Teach about \"void**\" pointers and \"void *\" function\n+\ttypes.  Fixes earlier commit.\n+\n 2003-12-10  Geoffrey Keating  <geoffk@apple.com>\n \n \t* doc/extend.texi (Vector Extensions): Document that bitwise"}, {"sha": "9b664a1f74838212297dfdcbc6aed8739a6a2717", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -193,7 +193,7 @@ struct loops;\n /* Basic block information indexed by block number.  */\n typedef struct basic_block_def {\n   /* The first and last insns of the block.  */\n-  rtx head, end;\n+  rtx head_, end_;\n \n   /* The first and last trees of the block.  */\n   tree head_tree;\n@@ -316,11 +316,8 @@ extern struct obstack flow_obstack;\n \f\n /* Stuff for recording basic block info.  */\n \n-#define BLOCK_HEAD(B)      (BASIC_BLOCK (B)->head)\n-#define BLOCK_END(B)       (BASIC_BLOCK (B)->end)\n-\n-#define BLOCK_HEAD_TREE(B) (BASIC_BLOCK (B)->head_tree)\n-#define BLOCK_END_TREE(B) (BASIC_BLOCK (B)->end_tree)\n+#define BB_HEAD(B)      (B)->head_\n+#define BB_END(B)       (B)->end_\n \n /* Special block numbers [markers] for entry and exit.  */\n #define ENTRY_BLOCK (-1)"}, {"sha": "0a433424fb5b80a238436109aacfe7a1fda5d2c6", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -312,7 +312,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \n \t      /* Duplicate HEADER if it is a small block containing cond jump\n \t\t in the end.  */\n-\t      if (any_condjump_p (header->end) && copy_bb_p (header, 0))\n+\t      if (any_condjump_p (BB_END (header)) && copy_bb_p (header, 0))\n \t\t{\n \t\t  copy_bb (header, prev_bb->succ, prev_bb, trace_n);\n \t\t}\n@@ -1011,7 +1011,7 @@ copy_bb_p (basic_block bb, int code_may_grow)\n   if (code_may_grow && maybe_hot_bb_p (bb))\n     max_size *= 8;\n \n-  for (insn = bb->head; insn != NEXT_INSN (bb->end);\n+  for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n        insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))"}, {"sha": "024092fa5bcb9acd1c815740fa13db63d0d8c305", "filename": "gcc/bt-load.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -477,7 +477,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t    && REGNO_REG_SET_P (bb->global_live_at_start, reg))\n \t  SET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n \n-      for (insn = bb->head, last = NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n \t   insn != last;\n \t   insn = NEXT_INSN (insn), insn_luid++)\n \t{\n@@ -629,7 +629,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n       rtx last;\n \n       sbitmap_union_of_preds (reaching_defs, bb_out, i);\n-      for (insn = bb->head, last = NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n \t   insn != last;\n \t   insn = NEXT_INSN (insn))\n \t{\n@@ -1058,7 +1058,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n      Replace all uses of the old target register definition by\n      uses of the new definition.  Delete the old definition.  */\n   basic_block b = new_def_bb;\n-  rtx insp = b->head;\n+  rtx insp = BB_HEAD (b);\n   rtx old_insn = def->insn;\n   rtx src;\n   rtx btr_rtx;\n@@ -1131,7 +1131,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n static int\n can_move_up (basic_block bb, rtx insn, int n_insns)\n {\n-  while (insn != bb->head && n_insns > 0)\n+  while (insn != BB_HEAD (bb) && n_insns > 0)\n     {\n       insn = PREV_INSN (insn);\n       /* ??? What if we have an anti-dependency that actually prevents the"}, {"sha": "9a0a4e3fbfd8f10b2f82d163cf07f09d80159153", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -832,8 +832,8 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n \t    }\n \t}\n       CLEAR_REG_SET (&new->dead_or_set);\n-      if (chain->insn == BLOCK_HEAD (chain->block))\n-\tBLOCK_HEAD (chain->block) = new->insn;\n+      if (chain->insn == BB_HEAD (BASIC_BLOCK (chain->block)))\n+\tBB_HEAD (BASIC_BLOCK (chain->block)) = new->insn;\n     }\n   else\n     {\n@@ -852,8 +852,8 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n       note_stores (PATTERN (chain->insn), add_stored_regs,\n \t\t   &new->live_throughout);\n       CLEAR_REG_SET (&new->dead_or_set);\n-      if (chain->insn == BLOCK_END (chain->block))\n-\tBLOCK_END (chain->block) = new->insn;\n+      if (chain->insn == BB_END (BASIC_BLOCK (chain->block)))\n+\tBB_END (BASIC_BLOCK (chain->block)) = new->insn;\n     }\n   new->block = chain->block;\n   new->is_caller_save_insn = 1;"}, {"sha": "32da973369c1457a56c24a04d799093d5e1189dc", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -543,7 +543,7 @@ dump_flow_info (FILE *file)\n       gcov_type lsum;\n \n       fprintf (file, \"\\nBasic block %d: first insn %d, last %d, \",\n-\t       bb->index, INSN_UID (bb->head), INSN_UID (bb->end));\n+\t       bb->index, INSN_UID (BB_HEAD (bb)), INSN_UID (BB_END (bb)));\n       fprintf (file, \"prev %d, next %d, \",\n \t       bb->prev_bb->index, bb->next_bb->index);\n       fprintf (file, \"loop_depth %d, count \", bb->loop_depth);"}, {"sha": "91297e53daaaadf9cfc2d73e376f4949172be8fe", "filename": "gcc/cfganal.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -89,7 +89,7 @@ forwarder_block_p (basic_block bb)\n       || !bb->succ || bb->succ->succ_next)\n     return false;\n \n-  for (insn = bb->head; insn != bb->end; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n     if (INSN_P (insn) && flow_active_insn_p (insn))\n       return false;\n \n@@ -103,8 +103,8 @@ forwarder_block_p (basic_block bb)\n bool\n can_fallthru (basic_block src, basic_block target)\n {\n-  rtx insn = src->end;\n-  rtx insn2 = target == EXIT_BLOCK_PTR ? NULL : target->head;\n+  rtx insn = BB_END (src);\n+  rtx insn2 = target == EXIT_BLOCK_PTR ? NULL : BB_HEAD (target);\n \n   if (src->next_bb != target)\n     return 0;\n@@ -232,11 +232,11 @@ set_edge_can_fallthru_flag (void)\n \t CAN_FALLTHRU edges.  */\n       if (!bb->succ || !bb->succ->succ_next || bb->succ->succ_next->succ_next)\n \tcontinue;\n-      if (!any_condjump_p (bb->end))\n+      if (!any_condjump_p (BB_END (bb)))\n \tcontinue;\n-      if (!invert_jump (bb->end, JUMP_LABEL (bb->end), 0))\n+      if (!invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0))\n \tcontinue;\n-      invert_jump (bb->end, JUMP_LABEL (bb->end), 0);\n+      invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0);\n       bb->succ->flags |= EDGE_CAN_FALLTHRU;\n       bb->succ->succ_next->flags |= EDGE_CAN_FALLTHRU;\n     }\n@@ -305,10 +305,10 @@ flow_call_edges_add (sbitmap blocks)\n   if (check_last_block)\n     {\n       basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n-      rtx insn = bb->end;\n+      rtx insn = BB_END (bb);\n \n       /* Back up past insns that must be kept in the same block as a call.  */\n-      while (insn != bb->head\n+      while (insn != BB_HEAD (bb)\n \t     && keep_with_call_p (insn))\n \tinsn = PREV_INSN (insn);\n \n@@ -342,7 +342,7 @@ flow_call_edges_add (sbitmap blocks)\n       if (blocks && !TEST_BIT (blocks, i))\n \tcontinue;\n \n-      for (insn = bb->end; ; insn = prev_insn)\n+      for (insn = BB_END (bb); ; insn = prev_insn)\n \t{\n \t  prev_insn = PREV_INSN (insn);\n \t  if (need_fake_edge_p (insn))\n@@ -353,7 +353,7 @@ flow_call_edges_add (sbitmap blocks)\n \t      /* Don't split the block between a call and an insn that should\n \t         remain in the same block as the call.  */\n \t      if (GET_CODE (insn) == CALL_INSN)\n-\t\twhile (split_at_insn != bb->end\n+\t\twhile (split_at_insn != BB_END (bb)\n \t\t       && keep_with_call_p (NEXT_INSN (split_at_insn)))\n \t\t  split_at_insn = NEXT_INSN (split_at_insn);\n \n@@ -363,15 +363,15 @@ flow_call_edges_add (sbitmap blocks)\n \t\t cause us to mark that edge as fake and remove it later.  */\n \n #ifdef ENABLE_CHECKING\n-\t      if (split_at_insn == bb->end)\n+\t      if (split_at_insn == BB_END (bb))\n \t\tfor (e = bb->succ; e; e = e->succ_next)\n \t\t  if (e->dest == EXIT_BLOCK_PTR)\n \t\t    abort ();\n #endif\n \n \t      /* Note that the following may create a new basic block\n \t\t and renumber the existing basic blocks.  */\n-\t      if (split_at_insn != bb->end)\n+\t      if (split_at_insn != BB_END (bb))\n \t\t{\n \t\t  e = split_block (bb, split_at_insn);\n \t\t  if (e)\n@@ -381,7 +381,7 @@ flow_call_edges_add (sbitmap blocks)\n \t      make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n \t    }\n \n-\t  if (insn == bb->head)\n+\t  if (insn == BB_HEAD (bb))\n \t    break;\n \t}\n     }"}, {"sha": "5805e587ec82204731264b79bcbaa39d8a748223", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -303,13 +303,14 @@ make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p\n       enum rtx_code code;\n       int force_fallthru = 0;\n \n-      if (GET_CODE (bb->head) == CODE_LABEL && LABEL_ALT_ENTRY_P (bb->head))\n+      if (GET_CODE (BB_HEAD (bb)) == CODE_LABEL\n+\t  && LABEL_ALT_ENTRY_P (BB_HEAD (bb)))\n \tcached_make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n \n       /* Examine the last instruction of the block, and discover the\n \t ways we can leave the block.  */\n \n-      insn = bb->end;\n+      insn = BB_END (bb);\n       code = GET_CODE (insn);\n \n       /* A branch.  */\n@@ -432,7 +433,7 @@ make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p\n \tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n       else if (bb->next_bb != EXIT_BLOCK_PTR)\n \t{\n-\t  if (force_fallthru || insn == bb->next_bb->head)\n+\t  if (force_fallthru || insn == BB_HEAD (bb->next_bb))\n \t    cached_make_edge (edge_cache, bb, bb->next_bb, EDGE_FALLTHRU);\n \t}\n     }\n@@ -649,12 +650,12 @@ enum state {BLOCK_NEW = 0, BLOCK_ORIGINAL, BLOCK_TO_SPLIT};\n static void\n find_bb_boundaries (basic_block bb)\n {\n-  rtx insn = bb->head;\n-  rtx end = bb->end;\n+  rtx insn = BB_HEAD (bb);\n+  rtx end = BB_END (bb);\n   rtx flow_transfer_insn = NULL_RTX;\n   edge fallthru = NULL;\n \n-  if (insn == bb->end)\n+  if (insn == BB_END (bb))\n     return;\n \n   if (GET_CODE (insn) == CODE_LABEL)\n@@ -670,7 +671,7 @@ find_bb_boundaries (basic_block bb)\n \t{\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n \t  if (flow_transfer_insn)\n-\t    bb->end = flow_transfer_insn;\n+\t    BB_END (bb) = flow_transfer_insn;\n \n \t  bb = fallthru->dest;\n \t  remove_edge (fallthru);\n@@ -684,7 +685,7 @@ find_bb_boundaries (basic_block bb)\n       if (flow_transfer_insn && inside_basic_block_p (insn))\n \t{\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n-\t  bb->end = flow_transfer_insn;\n+\t  BB_END (bb) = flow_transfer_insn;\n \t  bb = fallthru->dest;\n \t  remove_edge (fallthru);\n \t  flow_transfer_insn = NULL_RTX;\n@@ -701,7 +702,7 @@ find_bb_boundaries (basic_block bb)\n      return and barrier, or possibly other sequence not behaving like\n      ordinary jump, we need to take care and move basic block boundary.  */\n   if (flow_transfer_insn)\n-    bb->end = flow_transfer_insn;\n+    BB_END (bb) = flow_transfer_insn;\n \n   /* We've possibly replaced the conditional jump by conditional jump\n      followed by cleanup at fallthru edge, so the outgoing edges may\n@@ -719,7 +720,7 @@ compute_outgoing_frequencies (basic_block b)\n \n   if (b->succ && b->succ->succ_next && !b->succ->succ_next->succ_next)\n     {\n-      rtx note = find_reg_note (b->end, REG_BR_PROB, NULL);\n+      rtx note = find_reg_note (BB_END (b), REG_BR_PROB, NULL);\n       int probability;\n \n       if (!note)"}, {"sha": "c0b929badd005edefc3cd02a8f3f4b4e816602de", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -129,7 +129,7 @@ try_simplify_condjump (basic_block cbranch_block)\n \n   /* Verify that we've got a normal conditional branch at the end\n      of the block.  */\n-  cbranch_insn = cbranch_block->end;\n+  cbranch_insn = BB_END (cbranch_block);\n   if (!any_condjump_p (cbranch_insn))\n     return false;\n \n@@ -159,7 +159,7 @@ try_simplify_condjump (basic_block cbranch_block)\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Simplifying condjump %i around jump %i\\n\",\n-\t     INSN_UID (cbranch_insn), INSN_UID (jump_block->end));\n+\t     INSN_UID (cbranch_insn), INSN_UID (BB_END (jump_block)));\n \n   /* Success.  Update the CFG to match.  Note that after this point\n      the edge variable names appear backwards; the redirection is done\n@@ -172,19 +172,19 @@ try_simplify_condjump (basic_block cbranch_block)\n   cbranch_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n   update_br_prob_note (cbranch_block);\n \n-  end = jump_block->end;\n+  end = BB_END (jump_block);\n   /* Deleting a block may produce unreachable code warning even when we are\n      not deleting anything live.  Supress it by moving all the line number\n      notes out of the block.  */\n-  for (insn = jump_block->head; insn != NEXT_INSN (jump_block->end);\n+  for (insn = BB_HEAD (jump_block); insn != NEXT_INSN (BB_END (jump_block));\n        insn = next)\n     {\n       next = NEXT_INSN (insn);\n       if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n \t{\n-\t  if (insn == jump_block->end)\n+\t  if (insn == BB_END (jump_block))\n \t    {\n-\t      jump_block->end = PREV_INSN (insn);\n+\t      BB_END (jump_block) = PREV_INSN (insn);\n \t      if (insn == end)\n \t        break;\n \t    }\n@@ -300,30 +300,30 @@ thread_jump (int mode, edge e, basic_block b)\n     }\n \n   /* Second branch must end with onlyjump, as we will eliminate the jump.  */\n-  if (!any_condjump_p (e->src->end))\n+  if (!any_condjump_p (BB_END (e->src)))\n     return NULL;\n \n-  if (!any_condjump_p (b->end) || !onlyjump_p (b->end))\n+  if (!any_condjump_p (BB_END (b)) || !onlyjump_p (BB_END (b)))\n     {\n       BB_SET_FLAG (b, BB_NONTHREADABLE_BLOCK);\n       return NULL;\n     }\n \n-  set1 = pc_set (e->src->end);\n-  set2 = pc_set (b->end);\n+  set1 = pc_set (BB_END (e->src));\n+  set2 = pc_set (BB_END (b));\n   if (((e->flags & EDGE_FALLTHRU) != 0)\n       != (XEXP (SET_SRC (set1), 1) == pc_rtx))\n     reverse1 = true;\n \n   cond1 = XEXP (SET_SRC (set1), 0);\n   cond2 = XEXP (SET_SRC (set2), 0);\n   if (reverse1)\n-    code1 = reversed_comparison_code (cond1, e->src->end);\n+    code1 = reversed_comparison_code (cond1, BB_END (e->src));\n   else\n     code1 = GET_CODE (cond1);\n \n   code2 = GET_CODE (cond2);\n-  reversed_code2 = reversed_comparison_code (cond2, b->end);\n+  reversed_code2 = reversed_comparison_code (cond2, BB_END (b));\n \n   if (!comparison_dominates_p (code1, code2)\n       && !comparison_dominates_p (code1, reversed_code2))\n@@ -339,7 +339,7 @@ thread_jump (int mode, edge e, basic_block b)\n \n   /* Short circuit cases where block B contains some side effects, as we can't\n      safely bypass it.  */\n-  for (insn = NEXT_INSN (b->head); insn != NEXT_INSN (b->end);\n+  for (insn = NEXT_INSN (BB_HEAD (b)); insn != NEXT_INSN (BB_END (b));\n        insn = NEXT_INSN (insn))\n     if (INSN_P (insn) && side_effects_p (PATTERN (insn)))\n       {\n@@ -350,7 +350,7 @@ thread_jump (int mode, edge e, basic_block b)\n   cselib_init ();\n \n   /* First process all values computed in the source basic block.  */\n-  for (insn = NEXT_INSN (e->src->head); insn != NEXT_INSN (e->src->end);\n+  for (insn = NEXT_INSN (BB_HEAD (e->src)); insn != NEXT_INSN (BB_END (e->src));\n        insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       cselib_process_insn (insn);\n@@ -362,7 +362,7 @@ thread_jump (int mode, edge e, basic_block b)\n      processing as if it were same basic block.\n      Our goal is to prove that whole block is an NOOP.  */\n \n-  for (insn = NEXT_INSN (b->head); insn != NEXT_INSN (b->end) && !failed;\n+  for (insn = NEXT_INSN (BB_HEAD (b)); insn != NEXT_INSN (BB_END (b)) && !failed;\n        insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n@@ -509,7 +509,7 @@ try_forward_edges (int mode, basic_block b)\n \t  if ((mode & CLEANUP_PRE_LOOP) && optimize)\n \t    {\n \t      rtx insn = (target->succ->flags & EDGE_FALLTHRU\n-\t\t\t  ? target->head : prev_nonnote_insn (target->end));\n+\t\t\t  ? BB_HEAD (target) : prev_nonnote_insn (BB_END (target)));\n \n \t      if (GET_CODE (insn) != NOTE)\n \t\tinsn = NEXT_INSN (insn);\n@@ -527,7 +527,7 @@ try_forward_edges (int mode, basic_block b)\n \t\t at this time; it can mess up the loop optimizer's\n \t\t recognition of some patterns.  */\n \n-\t      insn = PREV_INSN (target->head);\n+\t      insn = PREV_INSN (BB_HEAD (target));\n \t      if (insn && GET_CODE (insn) == NOTE\n \t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \t\tbreak;\n@@ -696,7 +696,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier;\n \n-  barrier = next_nonnote_insn (a->end);\n+  barrier = next_nonnote_insn (BB_END (a));\n   if (GET_CODE (barrier) != BARRIER)\n     abort ();\n   delete_insn (barrier);\n@@ -708,12 +708,12 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n      and adjust the block trees appropriately.   Even better would be to have\n      a tighter connection between block trees and rtl so that this is not\n      necessary.  */\n-  if (squeeze_notes (&a->head, &a->end))\n+  if (squeeze_notes (&BB_HEAD (a), &BB_END (a)))\n     abort ();\n \n   /* Scramble the insn chain.  */\n-  if (a->end != PREV_INSN (b->head))\n-    reorder_insns_nobb (a->head, a->end, PREV_INSN (b->head));\n+  if (BB_END (a) != PREV_INSN (BB_HEAD (b)))\n+    reorder_insns_nobb (BB_HEAD (a), BB_END (a), PREV_INSN (BB_HEAD (b)));\n   a->flags |= BB_DIRTY;\n \n   if (rtl_dump_file)\n@@ -739,18 +739,18 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n   rtx barrier, real_b_end;\n   rtx label, table;\n \n-  real_b_end = b->end;\n+  real_b_end = BB_END (b);\n \n   /* If there is a jump table following block B temporarily add the jump table\n      to block B so that it will also be moved to the correct location.  */\n-  if (tablejump_p (b->end, &label, &table)\n-      && prev_active_insn (label) == b->end)\n+  if (tablejump_p (BB_END (b), &label, &table)\n+      && prev_active_insn (label) == BB_END (b))\n     {\n-      b->end = table;\n+      BB_END (b) = table;\n     }\n \n   /* There had better have been a barrier there.  Delete it.  */\n-  barrier = NEXT_INSN (b->end);\n+  barrier = NEXT_INSN (BB_END (b));\n   if (barrier && GET_CODE (barrier) == BARRIER)\n     delete_insn (barrier);\n \n@@ -761,14 +761,14 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n      and adjust the block trees appropriately.   Even better would be to have\n      a tighter connection between block trees and rtl so that this is not\n      necessary.  */\n-  if (squeeze_notes (&b->head, &b->end))\n+  if (squeeze_notes (&BB_HEAD (b), &BB_END (b)))\n     abort ();\n \n   /* Scramble the insn chain.  */\n-  reorder_insns_nobb (b->head, b->end, a->end);\n+  reorder_insns_nobb (BB_HEAD (b), BB_END (b), BB_END (a));\n \n   /* Restore the real end of b.  */\n-  b->end = real_b_end;\n+  BB_END (b) = real_b_end;\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Moved block %d after %d and merged.\\n\",\n@@ -799,8 +799,8 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n      that would make optimize_sibling_and_tail_recursive_calls more\n      complex for no gain.  */\n   if ((mode & CLEANUP_PRE_SIBCALL)\n-      && GET_CODE (c->head) == CODE_LABEL\n-      && tail_recursion_label_p (c->head))\n+      && GET_CODE (BB_HEAD (c)) == CODE_LABEL\n+      && tail_recursion_label_p (BB_HEAD (c)))\n     return NULL;\n \n   /* If B has a fallthru edge to C, no need to move anything.  */\n@@ -1010,7 +1010,7 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n   /* Skip simple jumps at the end of the blocks.  Complex jumps still\n      need to be compared for equivalence, which we'll do below.  */\n \n-  i1 = bb1->end;\n+  i1 = BB_END (bb1);\n   last1 = afterlast1 = last2 = afterlast2 = NULL_RTX;\n   if (onlyjump_p (i1)\n       || (returnjump_p (i1) && !side_effects_p (PATTERN (i1))))\n@@ -1019,7 +1019,7 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n       i1 = PREV_INSN (i1);\n     }\n \n-  i2 = bb2->end;\n+  i2 = BB_END (bb2);\n   if (onlyjump_p (i2)\n       || (returnjump_p (i2) && !side_effects_p (PATTERN (i2))))\n     {\n@@ -1033,13 +1033,13 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n   while (true)\n     {\n       /* Ignore notes.  */\n-      while (!INSN_P (i1) && i1 != bb1->head)\n+      while (!INSN_P (i1) && i1 != BB_HEAD (bb1))\n \ti1 = PREV_INSN (i1);\n \n-      while (!INSN_P (i2) && i2 != bb2->head)\n+      while (!INSN_P (i2) && i2 != BB_HEAD (bb2))\n \ti2 = PREV_INSN (i2);\n \n-      if (i1 == bb1->head || i2 == bb2->head)\n+      if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n \tbreak;\n \n       if (!insns_match_p (mode, i1, i2))\n@@ -1085,16 +1085,16 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n      Two, it keeps line number notes as matched as may be.  */\n   if (ninsns)\n     {\n-      while (last1 != bb1->head && !INSN_P (PREV_INSN (last1)))\n+      while (last1 != BB_HEAD (bb1) && !INSN_P (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n \n-      if (last1 != bb1->head && GET_CODE (PREV_INSN (last1)) == CODE_LABEL)\n+      if (last1 != BB_HEAD (bb1) && GET_CODE (PREV_INSN (last1)) == CODE_LABEL)\n \tlast1 = PREV_INSN (last1);\n \n-      while (last2 != bb2->head && !INSN_P (PREV_INSN (last2)))\n+      while (last2 != BB_HEAD (bb2) && !INSN_P (PREV_INSN (last2)))\n \tlast2 = PREV_INSN (last2);\n \n-      if (last2 != bb2->head && GET_CODE (PREV_INSN (last2)) == CODE_LABEL)\n+      if (last2 != BB_HEAD (bb2) && GET_CODE (PREV_INSN (last2)) == CODE_LABEL)\n \tlast2 = PREV_INSN (last2);\n \n       *f1 = last1;\n@@ -1121,18 +1121,18 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n      unconditional jump, or a fake edge to exit.  */\n   if (bb1->succ && !bb1->succ->succ_next\n       && (bb1->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n-      && (GET_CODE (bb1->end) != JUMP_INSN || simplejump_p (bb1->end)))\n+      && (GET_CODE (BB_END (bb1)) != JUMP_INSN || simplejump_p (BB_END (bb1))))\n     return (bb2->succ &&  !bb2->succ->succ_next\n \t    && (bb2->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n-\t    && (GET_CODE (bb2->end) != JUMP_INSN || simplejump_p (bb2->end)));\n+\t    && (GET_CODE (BB_END (bb2)) != JUMP_INSN || simplejump_p (BB_END (bb2))));\n \n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n   if (bb1->succ\n       && bb1->succ->succ_next\n       && !bb1->succ->succ_next->succ_next\n-      && any_condjump_p (bb1->end)\n-      && onlyjump_p (bb1->end))\n+      && any_condjump_p (BB_END (bb1))\n+      && onlyjump_p (BB_END (bb1)))\n     {\n       edge b1, f1, b2, f2;\n       bool reverse, match;\n@@ -1142,8 +1142,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       if (!bb2->succ\n \t  || !bb2->succ->succ_next\n \t  || bb2->succ->succ_next->succ_next\n-\t  || !any_condjump_p (bb2->end)\n-\t  || !onlyjump_p (bb2->end))\n+\t  || !any_condjump_p (BB_END (bb2))\n+\t  || !onlyjump_p (BB_END (bb2)))\n \treturn false;\n \n       b1 = BRANCH_EDGE (bb1);\n@@ -1175,8 +1175,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       else\n \treturn false;\n \n-      set1 = pc_set (bb1->end);\n-      set2 = pc_set (bb2->end);\n+      set1 = pc_set (BB_END (bb1));\n+      set2 = pc_set (BB_END (bb2));\n       if ((XEXP (SET_SRC (set1), 1) == pc_rtx)\n \t  != (XEXP (SET_SRC (set2), 1) == pc_rtx))\n \treverse = !reverse;\n@@ -1185,7 +1185,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       cond2 = XEXP (SET_SRC (set2), 0);\n       code1 = GET_CODE (cond1);\n       if (reverse)\n-\tcode2 = reversed_comparison_code (cond2, bb2->end);\n+\tcode2 = reversed_comparison_code (cond2, BB_END (bb2));\n       else\n \tcode2 = GET_CODE (cond2);\n \n@@ -1250,8 +1250,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       rtx label1, label2;\n       rtx table1, table2;\n \n-      if (tablejump_p (bb1->end, &label1, &table1)\n-\t  && tablejump_p (bb2->end, &label2, &table2)\n+      if (tablejump_p (BB_END (bb1), &label1, &table1)\n+\t  && tablejump_p (BB_END (bb2), &label2, &table2)\n \t  && GET_CODE (PATTERN (table1)) == GET_CODE (PATTERN (table2)))\n \t{\n \t  /* The labels should never be the same rtx.  If they really are same\n@@ -1261,7 +1261,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t  /* If LABEL2 is referenced in BB1->END do not do anything\n \t     because we would loose information when replacing\n \t     LABEL1 by LABEL2 and then LABEL2 by LABEL1 in BB1->END.  */\n-\t  if (label1 != label2 && !rtx_referenced_p (label2, bb1->end))\n+\t  if (label1 != label2 && !rtx_referenced_p (label2, BB_END (bb1)))\n \t    {\n \t      /* Set IDENTICAL to true when the tables are identical.  */\n \t      bool identical = false;\n@@ -1296,9 +1296,9 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t\t  rr.r1 = label1;\n \t\t  rr.r2 = label2;\n \t\t  rr.update_label_nuses = false;\n-\t\t  for_each_rtx (&bb1->end, replace_label, &rr);\n+\t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n \n-\t\t  match = insns_match_p (mode, bb1->end, bb2->end);\n+\t\t  match = insns_match_p (mode, BB_END (bb1), BB_END (bb2));\n \t\t  if (rtl_dump_file && match)\n \t\t    fprintf (rtl_dump_file,\n \t\t\t     \"Tablejumps in bb %i and %i match.\\n\",\n@@ -1309,7 +1309,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t\t     from the instruction is deleted too.  */\n \t\t  rr.r1 = label2;\n \t\t  rr.r2 = label1;\n-\t\t  for_each_rtx (&bb1->end, replace_label, &rr);\n+\t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n \n \t\t  return match;\n \t\t}\n@@ -1321,7 +1321,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \n   /* First ensure that the instructions match.  There may be many outgoing\n      edges so this test is generally cheaper.  */\n-  if (!insns_match_p (mode, bb1->end, bb2->end))\n+  if (!insns_match_p (mode, BB_END (bb1), BB_END (bb2)))\n     return false;\n \n   /* Search the outgoing edges, ensure that the counts do match, find possible\n@@ -1362,8 +1362,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \n   /* Ensure the same EH region.  */\n   {\n-    rtx n1 = find_reg_note (bb1->end, REG_EH_REGION, 0);\n-    rtx n2 = find_reg_note (bb2->end, REG_EH_REGION, 0);\n+    rtx n1 = find_reg_note (BB_END (bb1), REG_EH_REGION, 0);\n+    rtx n2 = find_reg_note (BB_END (bb2), REG_EH_REGION, 0);\n \n     if (!n1 && n2)\n       return false;\n@@ -1443,8 +1443,8 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n       rtx label1, label2;\n       rtx table1, table2;\n \n-      if (tablejump_p (src1->end, &label1, &table1)\n-\t  && tablejump_p (src2->end, &label2, &table2)\n+      if (tablejump_p (BB_END (src1), &label1, &table1)\n+\t  && tablejump_p (BB_END (src2), &label2, &table2)\n \t  && label1 != label2)\n \t{\n \t  replace_label_data rr;\n@@ -1459,15 +1459,15 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \t      /* Do not replace the label in SRC1->END because when deleting\n \t\t a block whose end is a tablejump, the tablejump referenced\n \t\t from the instruction is deleted too.  */\n-\t      if (insn != src1->end)\n+\t      if (insn != BB_END (src1))\n \t\tfor_each_rtx (&insn, replace_label, &rr);\n \t    }\n \t}\n     }\n #endif\n \n   /* Avoid splitting if possible.  */\n-  if (newpos2 == src2->head)\n+  if (newpos2 == BB_HEAD (src2))\n     redirect_to = src2;\n   else\n     {\n@@ -1716,31 +1716,31 @@ try_optimize_cfg (int mode)\n \t      if (b->pred->pred_next == NULL\n \t\t  && (b->pred->flags & EDGE_FALLTHRU)\n \t\t  && !(b->pred->flags & EDGE_COMPLEX)\n-\t\t  && GET_CODE (b->head) == CODE_LABEL\n+\t\t  && GET_CODE (BB_HEAD (b)) == CODE_LABEL\n \t\t  && (!(mode & CLEANUP_PRE_SIBCALL)\n-\t\t      || !tail_recursion_label_p (b->head))\n+\t\t      || !tail_recursion_label_p (BB_HEAD (b)))\n \t\t  /* If the previous block ends with a branch to this\n \t\t     block, we can't delete the label.  Normally this\n \t\t     is a condjump that is yet to be simplified, but\n \t\t     if CASE_DROPS_THRU, this can be a tablejump with\n \t\t     some element going to the same place as the\n \t\t     default (fallthru).  */\n \t\t  && (b->pred->src == ENTRY_BLOCK_PTR\n-\t\t      || GET_CODE (b->pred->src->end) != JUMP_INSN\n-\t\t      || ! label_is_jump_target_p (b->head,\n-\t\t\t\t\t\t   b->pred->src->end)))\n+\t\t      || GET_CODE (BB_END (b->pred->src)) != JUMP_INSN\n+\t\t      || ! label_is_jump_target_p (BB_HEAD (b),\n+\t\t\t\t\t\t   BB_END (b->pred->src))))\n \t\t{\n-\t\t  rtx label = b->head;\n+\t\t  rtx label = BB_HEAD (b);\n \n \t\t  delete_insn_chain (label, label);\n \t\t  /* In the case label is undeletable, move it after the\n \t\t     BASIC_BLOCK note.  */\n-\t\t  if (NOTE_LINE_NUMBER (b->head) == NOTE_INSN_DELETED_LABEL)\n+\t\t  if (NOTE_LINE_NUMBER (BB_HEAD (b)) == NOTE_INSN_DELETED_LABEL)\n \t\t    {\n-\t\t      rtx bb_note = NEXT_INSN (b->head);\n+\t\t      rtx bb_note = NEXT_INSN (BB_HEAD (b));\n \n \t\t      reorder_insns_nobb (label, label, bb_note);\n-\t\t      b->head = bb_note;\n+\t\t      BB_HEAD (b) = bb_note;\n \t\t    }\n \t\t  if (rtl_dump_file)\n \t\t    fprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n@@ -1751,7 +1751,7 @@ try_optimize_cfg (int mode)\n \t      if (!(mode & CLEANUP_CFGLAYOUT)\n \t\t  && b->pred->pred_next == NULL\n \t\t  && (b->pred->flags & EDGE_FALLTHRU)\n-\t\t  && GET_CODE (b->head) != CODE_LABEL\n+\t\t  && GET_CODE (BB_HEAD (b)) != CODE_LABEL\n \t\t  && FORWARDER_BLOCK_P (b)\n \t\t  /* Note that forwarder_block_p true ensures that\n \t\t     there is a successor for this block.  */\n@@ -1793,10 +1793,10 @@ try_optimize_cfg (int mode)\n \t\t  else if (!(mode & CLEANUP_CFGLAYOUT)\n \t\t\t   /* If the jump insn has side effects,\n \t\t\t      we can't kill the edge.  */\n-\t\t\t   && (GET_CODE (b->end) != JUMP_INSN\n+\t\t\t   && (GET_CODE (BB_END (b)) != JUMP_INSN\n \t\t\t       || (flow2_completed\n-\t\t\t\t   ? simplejump_p (b->end)\n-\t\t\t\t   : onlyjump_p (b->end)))\n+\t\t\t\t   ? simplejump_p (BB_END (b))\n+\t\t\t\t   : onlyjump_p (BB_END (b))))\n \t\t\t   && (next = merge_blocks_move (s, b, c, mode)))\n \t\t      {\n \t\t\tb = next;\n@@ -1818,7 +1818,7 @@ try_optimize_cfg (int mode)\n \t      if (b->succ\n \t\t  && ! b->succ->succ_next\n \t\t  && b->succ->dest != EXIT_BLOCK_PTR\n-\t\t  && onlyjump_p (b->end)\n+\t\t  && onlyjump_p (BB_END (b))\n \t\t  && redirect_edge_and_branch (b->succ, b->succ->dest))\n \t\t{\n \t\t  update_forwarder_flag (b);"}, {"sha": "14138a764de4302eb2ae25f28bcd8951bf469470", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -89,9 +89,9 @@ skip_insns_after_block (basic_block bb)\n \n   next_head = NULL_RTX;\n   if (bb->next_bb != EXIT_BLOCK_PTR)\n-    next_head = bb->next_bb->head;\n+    next_head = BB_HEAD (bb->next_bb);\n \n-  for (last_insn = insn = bb->end; (insn = NEXT_INSN (insn)) != 0; )\n+  for (last_insn = insn = BB_END (bb); (insn = NEXT_INSN (insn)) != 0; )\n     {\n       if (insn == next_head)\n \tbreak;\n@@ -148,7 +148,7 @@ skip_insns_after_block (basic_block bb)\n      created by removing the basic block originally following\n      NOTE_INSN_LOOP_BEG.  In such case reorder the notes.  */\n \n-  for (insn = last_insn; insn != bb->end; insn = prev)\n+  for (insn = last_insn; insn != BB_END (bb); insn = prev)\n     {\n       prev = PREV_INSN (insn);\n       if (GET_CODE (insn) == NOTE)\n@@ -172,7 +172,7 @@ skip_insns_after_block (basic_block bb)\n static rtx\n label_for_bb (basic_block bb)\n {\n-  rtx label = bb->head;\n+  rtx label = BB_HEAD (bb);\n \n   if (GET_CODE (label) != CODE_LABEL)\n     {\n@@ -214,13 +214,13 @@ record_effective_endpoints (void)\n     {\n       rtx end;\n \n-      if (PREV_INSN (bb->head) && next_insn != bb->head)\n+      if (PREV_INSN (BB_HEAD (bb)) && next_insn != BB_HEAD (bb))\n \tbb->rbi->header = unlink_insn_chain (next_insn,\n-\t\t\t\t\t      PREV_INSN (bb->head));\n+\t\t\t\t\t      PREV_INSN (BB_HEAD (bb)));\n       end = skip_insns_after_block (bb);\n-      if (NEXT_INSN (bb->end) && bb->end != end)\n-\tbb->rbi->footer = unlink_insn_chain (NEXT_INSN (bb->end), end);\n-      next_insn = NEXT_INSN (bb->end);\n+      if (NEXT_INSN (BB_END (bb)) && BB_END (bb) != end)\n+\tbb->rbi->footer = unlink_insn_chain (NEXT_INSN (BB_END (bb)), end);\n+      next_insn = NEXT_INSN (BB_END (bb));\n     }\n \n   cfg_layout_function_footer = next_insn;\n@@ -598,11 +598,11 @@ fixup_reorder_chain (void)\n \t    insn = NEXT_INSN (insn);\n \t}\n       if (insn)\n-\tNEXT_INSN (insn) = bb->head;\n+\tNEXT_INSN (insn) = BB_HEAD (bb);\n       else\n-\tset_first_insn (bb->head);\n-      PREV_INSN (bb->head) = insn;\n-      insn = bb->end;\n+\tset_first_insn (BB_HEAD (bb));\n+      PREV_INSN (BB_HEAD (bb)) = insn;\n+      insn = BB_END (bb);\n       if (bb->rbi->footer)\n \t{\n \t  NEXT_INSN (insn) = bb->rbi->footer;\n@@ -649,7 +649,7 @@ fixup_reorder_chain (void)\n \telse if (! (e->flags & EDGE_EH))\n \t  e_taken = e;\n \n-      bb_end_insn = bb->end;\n+      bb_end_insn = BB_END (bb);\n       if (GET_CODE (bb_end_insn) == JUMP_INSN)\n \t{\n \t  if (any_condjump_p (bb_end_insn))\n@@ -675,9 +675,9 @@ fixup_reorder_chain (void)\n \n \t\t  e_fake = unchecked_make_edge (bb, e_fall->dest, 0);\n \n-\t\t  if (!redirect_jump (bb->end, block_label (bb), 0))\n+\t\t  if (!redirect_jump (BB_END (bb), block_label (bb), 0))\n \t\t    abort ();\n-\t\t  note = find_reg_note (bb->end, REG_BR_PROB, NULL_RTX);\n+\t\t  note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);\n \t\t  if (note)\n \t\t    {\n \t\t      int prob = INTVAL (XEXP (note, 0));\n@@ -784,7 +784,7 @@ fixup_reorder_chain (void)\n \t  if (bb->rbi->original)\n \t    fprintf (rtl_dump_file, \"duplicate of %i \",\n \t\t     bb->rbi->original->index);\n-\t  else if (forwarder_block_p (bb) && GET_CODE (bb->head) != CODE_LABEL)\n+\t  else if (forwarder_block_p (bb) && GET_CODE (BB_HEAD (bb)) != CODE_LABEL)\n \t    fprintf (rtl_dump_file, \"compensation \");\n \t  else\n \t    fprintf (rtl_dump_file, \"bb %i \", bb->index);\n@@ -896,18 +896,18 @@ cfg_layout_can_duplicate_bb_p (basic_block bb)\n   /* Do not attempt to duplicate tablejumps, as we need to unshare\n      the dispatch table.  This is difficult to do, as the instructions\n      computing jump destination may be hoisted outside the basic block.  */\n-  if (tablejump_p (bb->end, NULL, NULL))\n+  if (tablejump_p (BB_END (bb), NULL, NULL))\n     return false;\n \n   /* Do not duplicate blocks containing insns that can't be copied.  */\n   if (targetm.cannot_copy_insn_p)\n     {\n-      rtx insn = bb->head;\n+      rtx insn = BB_HEAD (bb);\n       while (1)\n \t{\n \t  if (INSN_P (insn) && (*targetm.cannot_copy_insn_p) (insn))\n \t    return false;\n-\t  if (insn == bb->end)\n+\t  if (insn == BB_END (bb))\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}\n@@ -1028,7 +1028,7 @@ cfg_layout_duplicate_bb (basic_block bb, edge e)\n     abort ();\n #endif\n \n-  insn = duplicate_insn_chain (bb->head, bb->end);\n+  insn = duplicate_insn_chain (BB_HEAD (bb), BB_END (bb));\n   new_bb = create_basic_block (insn,\n \t\t\t       insn ? get_last_insn () : NULL,\n \t\t\t       EXIT_BLOCK_PTR->prev_bb);"}, {"sha": "413b606608b868d2ac11b104ee1791a140db6c63", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -588,7 +588,7 @@ make_forwarder_block (basic_block bb, int redirect_latch, int redirect_nonlatch,\n   insn = PREV_INSN (first_insn_after_basic_block_note (bb));\n \n   /* For empty block split_block will return NULL.  */\n-  if (bb->end == insn)\n+  if (BB_END (bb) == insn)\n     emit_note_after (NOTE_INSN_DELETED, insn);\n \n   fallthru = split_block (bb, insn);"}, {"sha": "3d6e69ef48d89bd836dc5eb47fe6979372980977", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -112,8 +112,8 @@ blocks_invariant_registers (basic_block *bbs, int nbbs, regset regs)\n   for (i = 0; i < max_reg_num (); i++)\n     SET_REGNO_REG_SET (regs, i);\n   for (i = 0; i < nbbs; i++)\n-    for (insn = bbs[i]->head;\n-\t insn != NEXT_INSN (bbs[i]->end);\n+    for (insn = BB_HEAD (bbs[i]);\n+\t insn != NEXT_INSN (BB_END (bbs[i]));\n \t insn = NEXT_INSN (insn))\n       if (INSN_P (insn))\n \tnote_stores (PATTERN (insn),\n@@ -157,8 +157,8 @@ blocks_single_set_registers (basic_block *bbs, int nbbs, rtx *regs)\n     regs[i] = NULL;\n \n   for (i = 0; i < nbbs; i++)\n-    for (insn = bbs[i]->head;\n-\t insn != NEXT_INSN (bbs[i]->end);\n+    for (insn = BB_HEAD (bbs[i]);\n+\t insn != NEXT_INSN (BB_END (bbs[i]));\n \t insn = NEXT_INSN (insn))\n       {\n \trtx set = single_set (insn);\n@@ -171,8 +171,8 @@ blocks_single_set_registers (basic_block *bbs, int nbbs, rtx *regs)\n \n   data.regs = regs;\n   for (i = 0; i < nbbs; i++)\n-    for (insn = bbs[i]->head;\n-\t insn != NEXT_INSN (bbs[i]->end);\n+    for (insn = BB_HEAD (bbs[i]);\n+\t insn != NEXT_INSN (BB_END (bbs[i]));\n \t insn = NEXT_INSN (insn))\n       {\n         if (!INSN_P (insn))\n@@ -360,12 +360,12 @@ simple_increment (struct loops *loops, struct loop *loop,\n       if (mod_bb1 == mod_bb)\n \t{\n \t  for (;\n-\t       mod_insn != PREV_INSN (mod_bb->head);\n+\t       mod_insn != PREV_INSN (BB_HEAD (mod_bb));\n \t       mod_insn = PREV_INSN (mod_insn))\n \t    if (mod_insn == mod_insn1)\n \t      break;\n \n-\t  if (mod_insn == PREV_INSN (mod_bb->head))\n+\t  if (mod_insn == PREV_INSN (BB_HEAD (mod_bb)))\n \t    return NULL;\n \t}\n \n@@ -416,7 +416,7 @@ variable_initial_value (rtx insn, regset invariant_regs,\n   bb = BLOCK_FOR_INSN (insn);\n   while (1)\n     {\n-      for (; insn != bb->head; insn = PREV_INSN (insn))\n+      for (; insn != BB_HEAD (bb); insn = PREV_INSN (insn))\n \t{\n \t  if (INSN_P (insn))\n \t    note_stores (PATTERN (insn),\n@@ -426,7 +426,7 @@ variable_initial_value (rtx insn, regset invariant_regs,\n \t    break;\n \t}\n \n-      if (insn != bb->head)\n+      if (insn != BB_HEAD (bb))\n \t{\n \t  /* We found place where var is set.  */\n \t  rtx set_dest;\n@@ -471,7 +471,7 @@ variable_initial_value (rtx insn, regset invariant_regs,\n \treturn NULL;\n \n       bb = bb->pred->src;\n-      insn = bb->end;\n+      insn = BB_END (bb);\n     }\n \n   return NULL;\n@@ -496,7 +496,7 @@ variable_initial_values (edge e, rtx var, enum machine_mode inner_mode)\n   if (e->src == ENTRY_BLOCK_PTR)\n     return list;\n \n-  set_insn = e->src->end;\n+  set_insn = BB_END (e->src);\n   while (REG_P (var)\n \t && (var = variable_initial_value (set_insn, invariant_regs, var,\n \t\t\t\t\t   &set_insn, inner_mode)))\n@@ -983,7 +983,7 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n     return false;\n \n   /* It must end in a simple conditional jump.  */\n-  if (!any_condjump_p (exit_bb->end))\n+  if (!any_condjump_p (BB_END (exit_bb)))\n     return false;\n \n   ei = exit_bb->succ;\n@@ -995,7 +995,7 @@ simple_loop_exit_p (struct loops *loops, struct loop *loop, edge exit_edge,\n \n   /* Condition must be a simple comparison in that one of operands\n      is register and the other one is invariant.  */\n-  if (!(condition = get_condition (exit_bb->end, NULL, false)))\n+  if (!(condition = get_condition (BB_END (exit_bb), NULL, false)))\n     return false;\n \n   if (!simple_condition_p (loop, condition, invariant_regs, desc))\n@@ -1323,7 +1323,7 @@ num_loop_insns (struct loop *loop)\n     {\n       bb = bbs[i];\n       ninsns++;\n-      for (insn = bb->head; insn != bb->end; insn = NEXT_INSN (insn))\n+      for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  ninsns++;\n     }\n@@ -1347,7 +1347,7 @@ average_num_loop_insns (struct loop *loop)\n       bb = bbs[i];\n \n       binsns = 1;\n-      for (insn = bb->head; insn != bb->end; insn = NEXT_INSN (insn))\n+      for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  binsns++;\n "}, {"sha": "6fa80c716aad1d5211288aa689525e2e14b0a3a0", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -788,7 +788,7 @@ loop_delete_branch_edge (edge e, int really_delete)\n       if (src->succ->succ_next->succ_next)\n \treturn false;\n       /* And it must be just a simple branch.  */\n-      if (!any_condjump_p (src->end))\n+      if (!any_condjump_p (BB_END (src)))\n \treturn false;\n \n       snd = e == src->succ ? src->succ->succ_next : src->succ;\n@@ -1126,7 +1126,7 @@ create_preheader (struct loop *loop, dominance_info dom, int flags)\n     insn = PREV_INSN (insn);\n   else\n     insn = get_last_insn ();\n-  if (insn == loop->header->end)\n+  if (insn == BB_END (loop->header))\n     {\n       /* Split_block would not split block after its end.  */\n       emit_note_after (NOTE_INSN_DELETED, insn);\n@@ -1243,7 +1243,7 @@ loop_split_edge_with (edge e, rtx insns, struct loops *loops)\n     }\n \n   if (insns)\n-    emit_insn_after (insns, new_bb->end);\n+    emit_insn_after (insns, BB_END (new_bb));\n \n   set_immediate_dominator (loops->cfg.dom, new_bb, src);\n   set_immediate_dominator (loops->cfg.dom, dest,"}, {"sha": "c44d25285dcfa00460c9c5af632cfa164e39048e", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 140, "deletions": 138, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -199,7 +199,7 @@ delete_insn_and_edges (rtx insn)\n \n   if (INSN_P (insn)\n       && BLOCK_FOR_INSN (insn)\n-      && BLOCK_FOR_INSN (insn)->end == insn)\n+      && BB_END (BLOCK_FOR_INSN (insn)) == insn)\n     purge = true;\n   x = delete_insn (insn);\n   if (purge)\n@@ -240,7 +240,7 @@ delete_insn_chain_and_edges (rtx first, rtx last)\n \n   if (INSN_P (last)\n       && BLOCK_FOR_INSN (last)\n-      && BLOCK_FOR_INSN (last)->end == last)\n+      && BB_END (BLOCK_FOR_INSN (last)) == last)\n     purge = true;\n   delete_insn_chain (first, last);\n   if (purge)\n@@ -310,8 +310,8 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n   if (NEXT_INSN (end) == bb_note)\n     end = bb_note;\n \n-  bb->head = head;\n-  bb->end = end;\n+  BB_HEAD (bb) = head;\n+  BB_END (bb) = end;\n   bb->index = last_basic_block++;\n   bb->flags = BB_NEW;\n   link_block (bb, after);\n@@ -378,7 +378,7 @@ rtl_delete_block (basic_block b)\n   /* Get rid of all NOTE_INSN_PREDICTIONs and NOTE_INSN_LOOP_CONTs\n      hanging before the block.  */\n \n-  for (insn = PREV_INSN (b->head); insn; insn = PREV_INSN (insn))\n+  for (insn = PREV_INSN (BB_HEAD (b)); insn; insn = PREV_INSN (insn))\n     {\n       if (GET_CODE (insn) != NOTE)\n \tbreak;\n@@ -387,15 +387,15 @@ rtl_delete_block (basic_block b)\n \tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n     }\n \n-  insn = b->head;\n+  insn = BB_HEAD (b);\n \n-  never_reached_warning (insn, b->end);\n+  never_reached_warning (insn, BB_END (b));\n \n   if (GET_CODE (insn) == CODE_LABEL)\n     maybe_remove_eh_handler (insn);\n \n   /* Include any jump table following the basic block.  */\n-  end = b->end;\n+  end = BB_END (b);\n   if (tablejump_p (end, NULL, &tmp))\n     end = tmp;\n \n@@ -405,7 +405,7 @@ rtl_delete_block (basic_block b)\n     end = tmp;\n \n   /* Selectively delete the entire chain.  */\n-  b->head = NULL;\n+  BB_HEAD (b) = NULL;\n   delete_insn_chain (insn, end);\n \n   /* Remove the edges into and out of this block.  Note that there may\n@@ -431,10 +431,10 @@ compute_bb_for_insn (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      rtx end = bb->end;\n+      rtx end = BB_END (bb);\n       rtx insn;\n \n-      for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+      for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n \t{\n \t  BLOCK_FOR_INSN (insn) = bb;\n \t  if (insn == end)\n@@ -461,11 +461,11 @@ update_bb_for_insn (basic_block bb)\n {\n   rtx insn;\n \n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) != BARRIER)\n \tset_block_for_insn (insn, bb);\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n }\n@@ -484,15 +484,15 @@ rtl_split_block (basic_block bb, void *insnp)\n   rtx insn = insnp;\n \n   /* There is no point splitting the block after its end.  */\n-  if (bb->end == insn)\n+  if (BB_END (bb) == insn)\n     return 0;\n \n   /* Create the new basic block.  */\n-  new_bb = create_basic_block (NEXT_INSN (insn), bb->end, bb);\n+  new_bb = create_basic_block (NEXT_INSN (insn), BB_END (bb), bb);\n   new_bb->count = bb->count;\n   new_bb->frequency = bb->frequency;\n   new_bb->loop_depth = bb->loop_depth;\n-  bb->end = insn;\n+  BB_END (bb) = insn;\n \n   /* Redirect the outgoing edges.  */\n   new_bb->succ = bb->succ;\n@@ -564,7 +564,7 @@ update_cfg_after_block_merging (basic_block a, basic_block b)\n static void\n rtl_merge_blocks (basic_block a, basic_block b)\n {\n-  rtx b_head = b->head, b_end = b->end, a_end = a->end;\n+  rtx b_head = BB_HEAD (b), b_end = BB_END (b), a_end = BB_END (a);\n   rtx del_first = NULL_RTX, del_last = NULL_RTX;\n   int b_empty = 0;\n \n@@ -601,7 +601,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n       for (prev = PREV_INSN (a_end); ; prev = PREV_INSN (prev))\n \tif (GET_CODE (prev) != NOTE\n \t    || NOTE_LINE_NUMBER (prev) == NOTE_INSN_BASIC_BLOCK\n-\t    || prev == a->head)\n+\t    || prev == BB_HEAD (a))\n \t  break;\n \n       del_first = a_end;\n@@ -615,7 +615,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n \t  prev = prev_nonnote_insn (prev);\n \t  if (!prev)\n-\t    prev = a->head;\n+\t    prev = BB_HEAD (a);\n \t  del_first = tmp;\n \t}\n #endif\n@@ -644,7 +644,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n       a_end = b_end;\n     }\n \n-  a->end = a_end;\n+  BB_END (a) = a_end;\n }\n \n /* Return true when block A and B can be merged.  */\n@@ -660,9 +660,9 @@ rtl_can_merge_blocks (basic_block a,basic_block b)\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */\n-\t  && (GET_CODE (a->end) != JUMP_INSN\n+\t  && (GET_CODE (BB_END (a)) != JUMP_INSN\n \t      || (flow2_completed\n-\t\t  ? simplejump_p (a->end) : onlyjump_p (a->end))));\n+\t\t  ? simplejump_p (BB_END (a)) : onlyjump_p (BB_END (a)))));\n }\n \f\n /* Return the label in the head of basic block BLOCK.  Create one if it doesn't\n@@ -674,12 +674,12 @@ block_label (basic_block block)\n   if (block == EXIT_BLOCK_PTR)\n     return NULL_RTX;\n \n-  if (GET_CODE (block->head) != CODE_LABEL)\n+  if (GET_CODE (BB_HEAD (block)) != CODE_LABEL)\n     {\n-      block->head = emit_label_before (gen_label_rtx (), block->head);\n+      BB_HEAD (block) = emit_label_before (gen_label_rtx (), BB_HEAD (block));\n     }\n \n-  return block->head;\n+  return BB_HEAD (block);\n }\n \n /* Attempt to perform edge redirection by replacing possibly complex jump\n@@ -691,7 +691,7 @@ static bool\n try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n {\n   basic_block src = e->src;\n-  rtx insn = src->end, kill_from;\n+  rtx insn = BB_END (src), kill_from;\n   edge tmp;\n   rtx set;\n   int fallthru = 0;\n@@ -731,7 +731,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t{\n \t  rtx insn = src->rbi->footer;\n \n-          delete_insn_chain (kill_from, src->end);\n+          delete_insn_chain (kill_from, BB_END (src));\n \n \t  /* Remove barriers but keep jumptables.  */\n \t  while (insn)\n@@ -751,7 +751,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t    }\n \t}\n       else\n-        delete_insn_chain (kill_from, PREV_INSN (target->head));\n+        delete_insn_chain (kill_from, PREV_INSN (BB_HEAD (target)));\n     }\n \n   /* If this already is simplejump, redirect it.  */\n@@ -781,11 +781,11 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       rtx barrier, label, table;\n \n       emit_jump_insn_after (gen_jump (target_label), insn);\n-      JUMP_LABEL (src->end) = target_label;\n+      JUMP_LABEL (BB_END (src)) = target_label;\n       LABEL_NUSES (target_label)++;\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n-\t\t INSN_UID (insn), INSN_UID (src->end));\n+\t\t INSN_UID (insn), INSN_UID (BB_END (src)));\n \n \n       delete_insn_chain (kill_from, insn);\n@@ -796,20 +796,20 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       if (tablejump_p (insn, &label, &table))\n \tdelete_insn_chain (label, table);\n \n-      barrier = next_nonnote_insn (src->end);\n+      barrier = next_nonnote_insn (BB_END (src));\n       if (!barrier || GET_CODE (barrier) != BARRIER)\n-\temit_barrier_after (src->end);\n+\temit_barrier_after (BB_END (src));\n       else\n \t{\n-\t  if (barrier != NEXT_INSN (src->end))\n+\t  if (barrier != NEXT_INSN (BB_END (src)))\n \t    {\n \t      /* Move the jump before barrier so that the notes\n \t\t which originally were or were created before jump table are\n \t\t inside the basic block.  */\n-\t      rtx new_insn = src->end;\n+\t      rtx new_insn = BB_END (src);\n \t      rtx tmp;\n \n-\t      for (tmp = NEXT_INSN (src->end); tmp != barrier;\n+\t      for (tmp = NEXT_INSN (BB_END (src)); tmp != barrier;\n \t\t   tmp = NEXT_INSN (tmp))\n \t\tset_block_for_insn (tmp, src);\n \n@@ -839,9 +839,9 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \n   /* We don't want a block to end on a line-number note since that has\n      the potential of changing the code between -g and not -g.  */\n-  while (GET_CODE (e->src->end) == NOTE\n-\t && NOTE_LINE_NUMBER (e->src->end) >= 0)\n-    delete_insn (e->src->end);\n+  while (GET_CODE (BB_END (e->src)) == NOTE\n+\t && NOTE_LINE_NUMBER (BB_END (e->src)) >= 0)\n+    delete_insn (BB_END (e->src));\n \n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n@@ -876,9 +876,9 @@ static bool\n redirect_branch_edge (edge e, basic_block target)\n {\n   rtx tmp;\n-  rtx old_label = e->dest->head;\n+  rtx old_label = BB_HEAD (e->dest);\n   basic_block src = e->src;\n-  rtx insn = src->end;\n+  rtx insn = BB_END (src);\n \n   /* We can only redirect non-fallthru edges of jump insn.  */\n   if (e->flags & EDGE_FALLTHRU)\n@@ -1000,18 +1000,18 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n      instruction, first redirect the jump itself and then continue\n      by creating a basic block afterwards to redirect fallthru edge.  */\n   if (e->src != ENTRY_BLOCK_PTR && e->dest != EXIT_BLOCK_PTR\n-      && any_condjump_p (e->src->end)\n+      && any_condjump_p (BB_END (e->src))\n       /* When called from cfglayout, fallthru edges do not\n          necessarily go to the next block.  */\n       && e->src->next_bb == e->dest\n-      && JUMP_LABEL (e->src->end) == e->dest->head)\n+      && JUMP_LABEL (BB_END (e->src)) == BB_HEAD (e->dest))\n     {\n       rtx note;\n       edge b = unchecked_make_edge (e->src, target, 0);\n \n-      if (!redirect_jump (e->src->end, block_label (target), 0))\n+      if (!redirect_jump (BB_END (e->src), block_label (target), 0))\n \tabort ();\n-      note = find_reg_note (e->src->end, REG_BR_PROB, NULL_RTX);\n+      note = find_reg_note (BB_END (e->src), REG_BR_PROB, NULL_RTX);\n       if (note)\n \t{\n \t  int prob = INTVAL (XEXP (note, 0));\n@@ -1046,7 +1046,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n       /* We can't redirect the entry block.  Create an empty block at the\n          start of the function which we use to add the new jump.  */\n       edge *pe1;\n-      basic_block bb = create_basic_block (e->dest->head, NULL, ENTRY_BLOCK_PTR);\n+      basic_block bb = create_basic_block (BB_HEAD (e->dest), NULL, ENTRY_BLOCK_PTR);\n \n       /* Change the existing edge's source to be the new block, and add\n \t a new edge from the entry block to the new block.  */\n@@ -1069,8 +1069,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n       /* If the old block ended with a tablejump, skip its table\n \t by searching forward from there.  Otherwise start searching\n \t forward from the last instruction of the old block.  */\n-      if (!tablejump_p (e->src->end, NULL, &note))\n-\tnote = e->src->end;\n+      if (!tablejump_p (BB_END (e->src), NULL, &note))\n+\tnote = BB_END (e->src);\n \n       /* Position the new block correctly relative to loop notes.  */\n       note = last_loop_beg_note (note);\n@@ -1111,19 +1111,19 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   if (target == EXIT_BLOCK_PTR)\n     {\n       if (HAVE_return)\n-\temit_jump_insn_after (gen_return (), jump_block->end);\n+\temit_jump_insn_after (gen_return (), BB_END (jump_block));\n       else\n \tabort ();\n     }\n   else\n     {\n       rtx label = block_label (target);\n-      emit_jump_insn_after (gen_jump (label), jump_block->end);\n-      JUMP_LABEL (jump_block->end) = label;\n+      emit_jump_insn_after (gen_jump (label), BB_END (jump_block));\n+      JUMP_LABEL (BB_END (jump_block)) = label;\n       LABEL_NUSES (label)++;\n     }\n \n-  emit_barrier_after (jump_block->end);\n+  emit_barrier_after (BB_END (jump_block));\n   redirect_edge_succ_nodup (e, target);\n \n   if (abnormal_edge_flags)\n@@ -1176,14 +1176,14 @@ tidy_fallthru_edge (edge e, basic_block b, basic_block c)\n      So search through a sequence of barriers, labels, and notes for\n      the head of block C and assert that we really do fall through.  */\n \n-  for (q = NEXT_INSN (b->end); q != c->head; q = NEXT_INSN (q))\n+  for (q = NEXT_INSN (BB_END (b)); q != BB_HEAD (c); q = NEXT_INSN (q))\n     if (INSN_P (q))\n       return;\n \n   /* Remove what will soon cease being the jump insn from the source block.\n      If block B consisted only of this single jump, turn it into a deleted\n      note.  */\n-  q = b->end;\n+  q = BB_END (b);\n   if (GET_CODE (q) == JUMP_INSN\n       && onlyjump_p (q)\n       && (any_uncondjump_p (q)\n@@ -1205,8 +1205,8 @@ tidy_fallthru_edge (edge e, basic_block b, basic_block c)\n     }\n \n   /* Selectively unlink the sequence.  */\n-  if (q != PREV_INSN (c->head))\n-    delete_insn_chain (NEXT_INSN (q), PREV_INSN (c->head));\n+  if (q != PREV_INSN (BB_HEAD (c)))\n+    delete_insn_chain (NEXT_INSN (q), PREV_INSN (BB_HEAD (c)));\n \n   e->flags |= EDGE_FALLTHRU;\n }\n@@ -1247,8 +1247,8 @@ tidy_fallthru_edges (void)\n \t  && s->succ_next == NULL\n \t  && s->dest == c\n \t  /* If the jump insn has side effects, we can't tidy the edge.  */\n-\t  && (GET_CODE (b->end) != JUMP_INSN\n-\t      || onlyjump_p (b->end)))\n+\t  && (GET_CODE (BB_END (b)) != JUMP_INSN\n+\t      || onlyjump_p (BB_END (b))))\n \ttidy_fallthru_edge (s, b, c);\n     }\n }\n@@ -1274,7 +1274,7 @@ back_edge_of_syntactic_loop_p (basic_block bb1, basic_block bb2)\n   if (!bb)\n     return false;\n \n-  for (insn = bb1->end; insn != bb2->head && count >= 0;\n+  for (insn = BB_END (bb1); insn != BB_HEAD (bb2) && count >= 0;\n        insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE)\n       {\n@@ -1337,14 +1337,14 @@ rtl_split_edge (edge edge_in)\n       we confuse the loop optimizer into thinking the loop is a phony.  */\n \n   if (edge_in->dest != EXIT_BLOCK_PTR\n-      && PREV_INSN (edge_in->dest->head)\n-      && GET_CODE (PREV_INSN (edge_in->dest->head)) == NOTE\n-      && (NOTE_LINE_NUMBER (PREV_INSN (edge_in->dest->head))\n+      && PREV_INSN (BB_HEAD (edge_in->dest))\n+      && GET_CODE (PREV_INSN (BB_HEAD (edge_in->dest))) == NOTE\n+      && (NOTE_LINE_NUMBER (PREV_INSN (BB_HEAD (edge_in->dest)))\n \t  == NOTE_INSN_LOOP_BEG)\n       && !back_edge_of_syntactic_loop_p (edge_in->dest, edge_in->src))\n-    before = PREV_INSN (edge_in->dest->head);\n+    before = PREV_INSN (BB_HEAD (edge_in->dest));\n   else if (edge_in->dest != EXIT_BLOCK_PTR)\n-    before = edge_in->dest->head;\n+    before = BB_HEAD (edge_in->dest);\n   else\n     before = NULL_RTX;\n \n@@ -1512,11 +1512,11 @@ commit_one_edge_insertion (edge e, int watch_calls)\n      its return value.  */\n   if (watch_calls && (e->flags & EDGE_FALLTHRU) && !e->dest->pred->pred_next\n       && e->src != ENTRY_BLOCK_PTR\n-      && GET_CODE (e->src->end) == CALL_INSN)\n+      && GET_CODE (BB_END (e->src)) == CALL_INSN)\n     {\n-      rtx next = next_nonnote_insn (e->src->end);\n+      rtx next = next_nonnote_insn (BB_END (e->src));\n \n-      after = e->dest->head;\n+      after = BB_HEAD (e->dest);\n       /* The first insn after the call may be a stack pop, skip it.  */\n       while (next\n \t     && keep_with_call_p (next))\n@@ -1536,12 +1536,12 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \n \t  /* Get the location correct wrt a code label, and \"nice\" wrt\n \t     a basic block note, and before everything else.  */\n-\t  tmp = bb->head;\n+\t  tmp = BB_HEAD (bb);\n \t  if (GET_CODE (tmp) == CODE_LABEL)\n \t    tmp = NEXT_INSN (tmp);\n \t  if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n \t    tmp = NEXT_INSN (tmp);\n-\t  if (tmp == bb->head)\n+\t  if (tmp == BB_HEAD (bb))\n \t    before = tmp;\n \t  else if (tmp)\n \t    after = PREV_INSN (tmp);\n@@ -1563,8 +1563,8 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \n \t     We know this block has a single successor, so we can just emit\n \t     the queued insns before the jump.  */\n-\t  if (GET_CODE (bb->end) == JUMP_INSN)\n-\t    for (before = bb->end;\n+\t  if (GET_CODE (BB_END (bb)) == JUMP_INSN)\n+\t    for (before = BB_END (bb);\n \t\t GET_CODE (PREV_INSN (before)) == NOTE\n \t\t && NOTE_LINE_NUMBER (PREV_INSN (before)) ==\n \t\t NOTE_INSN_LOOP_BEG; before = PREV_INSN (before))\n@@ -1575,14 +1575,14 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      if ((e->flags & EDGE_FALLTHRU) == 0)\n \t\tabort ();\n \n-\t      after = bb->end;\n+\t      after = BB_END (bb);\n \t    }\n \t}\n       /* Otherwise we must split the edge.  */\n       else\n \t{\n \t  bb = split_edge (e);\n-\t  after = bb->end;\n+\t  after = BB_END (bb);\n \t}\n     }\n \n@@ -1728,7 +1728,7 @@ rtl_dump_bb (basic_block bb, FILE *outf)\n   dump_regset (bb->global_live_at_start, outf);\n   putc ('\\n', outf);\n \n-  for (insn = bb->head, last = NEXT_INSN (bb->end); insn != last;\n+  for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;\n        insn = NEXT_INSN (insn))\n     print_rtl_single (outf, insn);\n \n@@ -1761,17 +1761,17 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n \t{\n \t  rtx x;\n \n-\t  start[INSN_UID (bb->head)] = bb;\n-\t  end[INSN_UID (bb->end)] = bb;\n-\t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n+\t  start[INSN_UID (BB_HEAD (bb))] = bb;\n+\t  end[INSN_UID (BB_END (bb))] = bb;\n+\t  for (x = BB_HEAD (bb); x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      enum bb_state state = IN_MULTIPLE_BB;\n \n \t      if (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n \t\tstate = IN_ONE_BB;\n \t      in_bb_p[INSN_UID (x)] = state;\n \n-\t      if (x == bb->end)\n+\t      if (x == BB_END (bb))\n \t\tbreak;\n \t    }\n \t}\n@@ -1827,9 +1827,9 @@ void\n update_br_prob_note (basic_block bb)\n {\n   rtx note;\n-  if (GET_CODE (bb->end) != JUMP_INSN)\n+  if (GET_CODE (BB_END (bb)) != JUMP_INSN)\n     return;\n-  note = find_reg_note (bb->end, REG_BR_PROB, NULL_RTX);\n+  note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);\n   if (!note || INTVAL (XEXP (note, 0)) == BRANCH_EDGE (bb)->probability)\n     return;\n   XEXP (note, 0) = GEN_INT (BRANCH_EDGE (bb)->probability);\n@@ -1866,8 +1866,8 @@ rtl_verify_flow_info_1 (void)\n \n   FOR_EACH_BB_REVERSE (bb)\n     {\n-      rtx head = bb->head;\n-      rtx end = bb->end;\n+      rtx head = BB_HEAD (bb);\n+      rtx end = BB_END (bb);\n \n       /* Verify the end of the basic block is in the INSN chain.  */\n       for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n@@ -1917,10 +1917,10 @@ rtl_verify_flow_info_1 (void)\n       edge e, fallthru = NULL;\n       rtx note;\n \n-      if (INSN_P (bb->end)\n-\t  && (note = find_reg_note (bb->end, REG_BR_PROB, NULL_RTX))\n+      if (INSN_P (BB_END (bb))\n+\t  && (note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX))\n \t  && bb->succ && bb->succ->succ_next\n-\t  && any_condjump_p (bb->end))\n+\t  && any_condjump_p (BB_END (bb)))\n \t{\n \t  if (INTVAL (XEXP (note, 0)) != BRANCH_EDGE (bb)->probability)\n \t    {\n@@ -1949,52 +1949,52 @@ rtl_verify_flow_info_1 (void)\n \t    n_abnormal++;\n \t}\n \n-      if (n_eh && GET_CODE (PATTERN (bb->end)) != RESX\n-\t  && !find_reg_note (bb->end, REG_EH_REGION, NULL_RTX))\n+      if (n_eh && GET_CODE (PATTERN (BB_END (bb))) != RESX\n+\t  && !find_reg_note (BB_END (bb), REG_EH_REGION, NULL_RTX))\n \t{\n \t  error (\"Missing REG_EH_REGION note in the end of bb %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_branch\n-\t  && (GET_CODE (bb->end) != JUMP_INSN\n-\t      || (n_branch > 1 && (any_uncondjump_p (bb->end)\n-\t\t\t\t   || any_condjump_p (bb->end)))))\n+\t  && (GET_CODE (BB_END (bb)) != JUMP_INSN\n+\t      || (n_branch > 1 && (any_uncondjump_p (BB_END (bb))\n+\t\t\t\t   || any_condjump_p (BB_END (bb))))))\n \t{\n \t  error (\"Too many outgoing branch edges from bb %i\", bb->index);\n \t  err = 1;\n \t}\n-      if (n_fallthru && any_uncondjump_p (bb->end))\n+      if (n_fallthru && any_uncondjump_p (BB_END (bb)))\n \t{\n \t  error (\"Fallthru edge after unconditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n-      if (n_branch != 1 && any_uncondjump_p (bb->end))\n+      if (n_branch != 1 && any_uncondjump_p (BB_END (bb)))\n \t{\n \t  error (\"Wrong amount of branch edges after unconditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n-      if (n_branch != 1 && any_condjump_p (bb->end)\n-\t  && JUMP_LABEL (bb->end) != fallthru->dest->head)\n+      if (n_branch != 1 && any_condjump_p (BB_END (bb))\n+\t  && JUMP_LABEL (BB_END (bb)) != BB_HEAD (fallthru->dest))\n \t{\n \t  error (\"Wrong amount of branch edges after conditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n-      if (n_call && GET_CODE (bb->end) != CALL_INSN)\n+      if (n_call && GET_CODE (BB_END (bb)) != CALL_INSN)\n \t{\n \t  error (\"Call edges for non-call insn in bb %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_abnormal\n-\t  && (GET_CODE (bb->end) != CALL_INSN && n_call != n_abnormal)\n-\t  && (GET_CODE (bb->end) != JUMP_INSN\n-\t      || any_condjump_p (bb->end)\n-\t      || any_uncondjump_p (bb->end)))\n+\t  && (GET_CODE (BB_END (bb)) != CALL_INSN && n_call != n_abnormal)\n+\t  && (GET_CODE (BB_END (bb)) != JUMP_INSN\n+\t      || any_condjump_p (BB_END (bb))\n+\t      || any_uncondjump_p (BB_END (bb))))\n \t{\n \t  error (\"Abnormal edges for no purpose in bb %i\", bb->index);\n \t  err = 1;\n \t}\n \n-      for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n+      for (x = BB_HEAD (bb); x != NEXT_INSN (BB_END (bb)); x = NEXT_INSN (x))\n \tif (BLOCK_FOR_INSN (x) != bb)\n \t  {\n \t    debug_rtx (x);\n@@ -2013,10 +2013,10 @@ rtl_verify_flow_info_1 (void)\n       /* OK pointers are correct.  Now check the header of basic\n          block.  It ought to contain optional CODE_LABEL followed\n \t by NOTE_BASIC_BLOCK.  */\n-      x = bb->head;\n+      x = BB_HEAD (bb);\n       if (GET_CODE (x) == CODE_LABEL)\n \t{\n-\t  if (bb->end == x)\n+\t  if (BB_END (bb) == x)\n \t    {\n \t      error (\"NOTE_INSN_BASIC_BLOCK is missing for block %d\",\n \t\t     bb->index);\n@@ -2033,7 +2033,7 @@ rtl_verify_flow_info_1 (void)\n \t  err = 1;\n \t}\n \n-      if (bb->end == x)\n+      if (BB_END (bb) == x)\n \t/* Do checks for empty blocks her. e */\n \t;\n       else\n@@ -2046,7 +2046,7 @@ rtl_verify_flow_info_1 (void)\n \t\terr = 1;\n \t      }\n \n-\t    if (x == bb->end)\n+\t    if (x == BB_END (bb))\n \t      break;\n \n \t    if (control_flow_insn_p (x))\n@@ -2092,7 +2092,7 @@ rtl_verify_flow_info (void)\n \t  rtx insn;\n \n \t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n-\t  for (insn = bb->end; !insn || GET_CODE (insn) != BARRIER;\n+\t  for (insn = BB_END (bb); !insn || GET_CODE (insn) != BARRIER;\n \t       insn = NEXT_INSN (insn))\n \t    if (!insn\n \t\t|| (GET_CODE (insn) == NOTE\n@@ -2116,7 +2116,7 @@ rtl_verify_flow_info (void)\n \t      err = 1;\n \t    }\n \t  else\n-\t    for (insn = NEXT_INSN (e->src->end); insn != e->dest->head;\n+\t    for (insn = NEXT_INSN (BB_END (e->src)); insn != BB_HEAD (e->dest);\n \t\t insn = NEXT_INSN (insn))\n \t      if (GET_CODE (insn) == BARRIER\n #ifndef CASE_DROPS_THROUGH\n@@ -2179,7 +2179,7 @@ rtl_verify_flow_info (void)\n \t  && returnjump_p (x) && ! condjump_p (x)\n \t  && ! (NEXT_INSN (x) && GET_CODE (NEXT_INSN (x)) == BARRIER))\n \t    fatal_insn (\"return not followed by barrier\", x);\n-      if (curr_bb && x == curr_bb->end)\n+      if (curr_bb && x == BB_END (curr_bb))\n \tcurr_bb = NULL;\n     }\n \n@@ -2199,7 +2199,7 @@ bool\n purge_dead_edges (basic_block bb)\n {\n   edge e, next;\n-  rtx insn = bb->end, note;\n+  rtx insn = BB_END (bb), note;\n   bool purged = false;\n \n   /* If this instruction cannot trap, remove REG_EH_REGION notes.  */\n@@ -2220,12 +2220,12 @@ purge_dead_edges (basic_block bb)\n       next = e->succ_next;\n       if (e->flags & EDGE_EH)\n \t{\n-\t  if (can_throw_internal (bb->end))\n+\t  if (can_throw_internal (BB_END (bb)))\n \t    continue;\n \t}\n       else if (e->flags & EDGE_ABNORMAL_CALL)\n \t{\n-\t  if (GET_CODE (bb->end) == CALL_INSN\n+\t  if (GET_CODE (BB_END (bb)) == CALL_INSN\n \t      && (! (note = find_reg_note (insn, REG_EH_REGION, NULL))\n \t\t  || INTVAL (XEXP (note, 0)) >= 0))\n \t    continue;\n@@ -2275,7 +2275,7 @@ purge_dead_edges (basic_block bb)\n \t       block, so we should keep the edge.  */\n \t    continue;\n \t  else if (e->dest != EXIT_BLOCK_PTR\n-\t\t   && e->dest->head == JUMP_LABEL (insn))\n+\t\t   && BB_HEAD (e->dest) == JUMP_LABEL (insn))\n \t    /* If the destination block is the target of the jump,\n \t       keep the edge.  */\n \t    continue;\n@@ -2462,10 +2462,10 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->flags & EDGE_FALLTHRU)\n     {\n       /* Redirect any branch edges unified with the fallthru one.  */\n-      if (GET_CODE (src->end) == JUMP_INSN\n-\t  && JUMP_LABEL (src->end) == e->dest->head)\n+      if (GET_CODE (BB_END (src)) == JUMP_INSN\n+\t  && JUMP_LABEL (BB_END (src)) == BB_HEAD (e->dest))\n \t{\n-          if (!redirect_jump (src->end, block_label (dest), 0))\n+          if (!redirect_jump (BB_END (src), block_label (dest), 0))\n \t    abort ();\n \t}\n       /* In case we are redirecting fallthru edge to the branch edge\n@@ -2475,9 +2475,9 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t{\n \t  edge s = e->succ_next ? e->succ_next : src->succ;\n \t  if (s->dest == dest\n-\t      && any_condjump_p (src->end)\n-\t      && onlyjump_p (src->end))\n-\t    delete_insn (src->end);\n+\t      && any_condjump_p (BB_END (src))\n+\t      && onlyjump_p (BB_END (src)))\n+\t    delete_insn (BB_END (src));\n \t}\n       redirect_edge_succ_nodup (e, dest);\n       if (rtl_dump_file)\n@@ -2490,7 +2490,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n     ret = redirect_branch_edge (e, dest);\n \n   /* We don't want simplejumps in the insn stream during cfglayout.  */\n-  if (simplejump_p (src->end))\n+  if (simplejump_p (BB_END (src)))\n     abort ();\n \n   return ret;\n@@ -2509,11 +2509,11 @@ cfg_layout_redirect_edge_and_branch_force (edge e, basic_block dest)\n static void\n cfg_layout_delete_block (basic_block bb)\n {\n-  rtx insn, next, prev = PREV_INSN (bb->head), *to, remaints;\n+  rtx insn, next, prev = PREV_INSN (BB_HEAD (bb)), *to, remaints;\n \n   if (bb->rbi->header)\n     {\n-      next = bb->head;\n+      next = BB_HEAD (bb);\n       if (prev)\n \tNEXT_INSN (prev) = bb->rbi->header;\n       else\n@@ -2525,7 +2525,7 @@ cfg_layout_delete_block (basic_block bb)\n       NEXT_INSN (insn) = next;\n       PREV_INSN (next) = insn;\n     }\n-  next = NEXT_INSN (bb->end);\n+  next = NEXT_INSN (BB_END (bb));\n   if (bb->rbi->footer)\n     {\n       insn = bb->rbi->footer;\n@@ -2546,7 +2546,7 @@ cfg_layout_delete_block (basic_block bb)\n \t}\n       if (bb->rbi->footer)\n \t{\n-\t  insn = bb->end;\n+\t  insn = BB_END (bb);\n \t  NEXT_INSN (insn) = bb->rbi->footer;\n \t  PREV_INSN (bb->rbi->footer) = insn;\n \t  while (NEXT_INSN (insn))\n@@ -2598,9 +2598,9 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */\n-\t  && (GET_CODE (a->end) != JUMP_INSN\n+\t  && (GET_CODE (BB_END (a)) != JUMP_INSN\n \t      || (flow2_completed\n-\t\t  ? simplejump_p (a->end) : onlyjump_p (a->end))));\n+\t\t  ? simplejump_p (BB_END (a)) : onlyjump_p (BB_END (a)))));\n }\n \n /* Merge block A and B, abort when it is not possible.  */\n@@ -2613,55 +2613,57 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n #endif\n \n   /* If there was a CODE_LABEL beginning B, delete it.  */\n-  if (GET_CODE (b->head) == CODE_LABEL)\n-    delete_insn (b->head);\n+  if (GET_CODE (BB_HEAD (b)) == CODE_LABEL)\n+    delete_insn (BB_HEAD (b));\n \n   /* We should have fallthru edge in a, or we can do dummy redirection to get\n      it cleaned up.  */\n-  if (GET_CODE (a->end) == JUMP_INSN)\n+  if (GET_CODE (BB_END (a)) == JUMP_INSN)\n     redirect_edge_and_branch (a->succ, b);\n-  if (GET_CODE (a->end) == JUMP_INSN)\n+  if (GET_CODE (BB_END (a)) == JUMP_INSN)\n     abort ();\n \n   /* Possible line number notes should appear in between.  */\n   if (b->rbi->header)\n     {\n-      rtx first = a->end, last;\n+      rtx first = BB_END (a), last;\n \n-      last = emit_insn_after (b->rbi->header, a->end);\n+      last = emit_insn_after (b->rbi->header, BB_END (a));\n       delete_insn_chain (NEXT_INSN (first), last);\n       b->rbi->header = NULL;\n     }\n \n   /* In the case basic blocks are not adjacent, move them around.  */\n-  if (NEXT_INSN (a->end) != b->head)\n+  if (NEXT_INSN (BB_END (a)) != BB_HEAD (b))\n     {\n-      rtx first = unlink_insn_chain (b->head, b->end);\n+      rtx first = unlink_insn_chain (BB_HEAD (b), BB_END (b));\n \n-      emit_insn_after (first, a->end);\n+      emit_insn_after (first, BB_END (a));\n       /* Skip possible DELETED_LABEL insn.  */\n       if (!NOTE_INSN_BASIC_BLOCK_P (first))\n \tfirst = NEXT_INSN (first);\n       if (!NOTE_INSN_BASIC_BLOCK_P (first))\n \tabort ();\n-      b->head = NULL;\n+      BB_HEAD (b) = NULL;\n       delete_insn (first);\n     }\n   /* Otherwise just re-associate the instructions.  */\n   else\n     {\n       rtx insn;\n \n-      for (insn = b->head; insn != NEXT_INSN (b->end); insn = NEXT_INSN (insn))\n+      for (insn = BB_HEAD (b);\n+\t   insn != NEXT_INSN (BB_END (b));\n+\t   insn = NEXT_INSN (insn))\n \tset_block_for_insn (insn, a);\n-      insn = b->head;\n+      insn = BB_HEAD (b);\n       /* Skip possible DELETED_LABEL insn.  */\n       if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n \tinsn = NEXT_INSN (insn);\n       if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n \tabort ();\n-      b->head = NULL;\n-      a->end = b->end;\n+      BB_HEAD (b) = NULL;\n+      BB_END (a) = BB_END (b);\n       delete_insn (insn);\n     }\n \n@@ -2696,7 +2698,7 @@ cfg_layout_split_edge (edge e)\n   edge new_e;\n   basic_block new_bb =\n     create_basic_block (e->src != ENTRY_BLOCK_PTR\n-\t\t\t? NEXT_INSN (e->src-> end) : get_insns (),\n+\t\t\t? NEXT_INSN (BB_END (e->src)) : get_insns (),\n \t\t\tNULL_RTX, e->src);\n \n   new_bb->count = e->count;"}, {"sha": "02a92c1609dc38b528638913fa4d3ff648d21cf2", "filename": "gcc/combine.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -608,8 +608,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   FOR_EACH_BB (this_basic_block)\n     {\n-      for (insn = this_basic_block->head;\n-           insn != NEXT_INSN (this_basic_block->end);\n+      for (insn = BB_HEAD (this_basic_block);\n+           insn != NEXT_INSN (BB_END (this_basic_block));\n \t   insn = next ? next : NEXT_INSN (insn))\n \t{\n \t  next = 0;\n@@ -2337,7 +2337,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n \t  for (insn = NEXT_INSN (i3);\n \t       insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n-\t\t\t|| insn != this_basic_block->next_bb->head);\n+\t\t\t|| insn != BB_HEAD (this_basic_block->next_bb));\n \t       insn = NEXT_INSN (insn))\n \t    {\n \t      if (INSN_P (insn) && reg_referenced_p (ni2dest, PATTERN (insn)))\n@@ -2546,7 +2546,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t\t\t  SET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n \t    for (temp = NEXT_INSN (i2);\n \t\t temp && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n-\t\t\t  || this_basic_block->head != temp);\n+\t\t\t  || BB_HEAD (this_basic_block) != temp);\n \t\t temp = NEXT_INSN (temp))\n \t      if (temp != i3 && INSN_P (temp))\n \t\tfor (link = LOG_LINKS (temp); link; link = XEXP (link, 1))\n@@ -11978,7 +11978,7 @@ reg_dead_at_p (rtx reg, rtx insn)\n   else\n     {\n       FOR_EACH_BB (block)\n-\tif (insn == block->head)\n+\tif (insn == BB_HEAD (block))\n \t  break;\n \n       if (block == EXIT_BLOCK_PTR)\n@@ -12617,7 +12617,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t{\n \t\t  if (! INSN_P (tem))\n \t\t    {\n-\t\t      if (tem == bb->head)\n+\t\t      if (tem == BB_HEAD (bb))\n \t\t\tbreak;\n \t\t      continue;\n \t\t    }\n@@ -12744,7 +12744,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t      break;\n \t\t    }\n \n-\t\t  if (tem == bb->head)\n+\t\t  if (tem == BB_HEAD (bb))\n \t\t    break;\n \t\t}\n \n@@ -12841,7 +12841,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t\t      {\n \t\t\t\tif (! INSN_P (tem))\n \t\t\t\t  {\n-\t\t\t\t    if (tem == bb->head)\n+\t\t\t\t    if (tem == BB_HEAD (bb))\n \t\t\t\t      {\n \t\t\t\t\tSET_BIT (refresh_blocks,\n \t\t\t\t\t\t this_basic_block->index);\n@@ -12948,7 +12948,7 @@ distribute_links (rtx links)\n \n       for (insn = NEXT_INSN (XEXP (link, 0));\n \t   (insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n-\t\t     || this_basic_block->next_bb->head != insn));\n+\t\t     || BB_HEAD (this_basic_block->next_bb) != insn));\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn) && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n \t  {"}, {"sha": "7f641ff1e3fadec6f18ad1a114f405fd5dac23c4", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -6402,16 +6402,16 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n   /* Scan all of the blocks for registers that must not be allocated.  */\n   for (j = 0; j < num_bb; j++)\n     {\n-      rtx last_insn = bb[j]->end;\n-      rtx insn = bb[j]->head;\n+      rtx last_insn = BB_END (bb[j]);\n+      rtx insn = BB_HEAD (bb[j]);\n       int regno;\n \n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Scanning %s block %d, start %d, end %d\\n\",\n \t\t (bb[j] == else_bb) ? \"else\" : ((bb[j] == then_bb) ? \"then\" : \"test\"),\n \t\t (int) bb[j]->index,\n-\t\t (int) INSN_UID (bb[j]->head),\n-\t\t (int) INSN_UID (bb[j]->end));\n+\t\t (int) INSN_UID (BB_HEAD (bb[j])),\n+\t\t (int) INSN_UID (BB_END (bb[j])));\n \n       /* Anything live at the beginning of the block is obviously unavailable\n          for allocation.  */\n@@ -6611,7 +6611,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \t\t\t    gen_rtx_fmt_ee (code, CC_CCRmode, cc, const0_rtx));\n \n   /* Record the check insn to be inserted later.  */\n-  frv_ifcvt_add_insn (check_insn, test_bb->end, TRUE);\n+  frv_ifcvt_add_insn (check_insn, BB_END (test_bb), TRUE);\n \n   /* Update the tests.  */\n   frv_ifcvt.cr_reg = cr;\n@@ -6729,7 +6729,7 @@ frv_ifcvt_modify_multiple_tests (ce_if_block_t *ce_info,\n   /* First add the andcr/andncr/orcr/orncr, which will be added after the\n      conditional check instruction, due to frv_ifcvt_add_insn being a LIFO\n      stack.  */\n-  frv_ifcvt_add_insn ((*logical_func) (cr, cr, new_cr), bb->end, TRUE);\n+  frv_ifcvt_add_insn ((*logical_func) (cr, cr, new_cr), BB_END (bb), TRUE);\n \n   /* Now add the conditional check insn.  */\n   cc = XEXP (test_expr, 0);\n@@ -6740,7 +6740,7 @@ frv_ifcvt_modify_multiple_tests (ce_if_block_t *ce_info,\n \n   /* add the new check insn to the list of check insns that need to be\n      inserted.  */\n-  frv_ifcvt_add_insn (check_insn, bb->end, TRUE);\n+  frv_ifcvt_add_insn (check_insn, BB_END (bb), TRUE);\n \n   if (TARGET_DEBUG_COND_EXEC)\n     {"}, {"sha": "c192df97846635689f54cd446ed17ba5d22cee3a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -15673,7 +15673,7 @@ ix86_reorg (void)\n   for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n   {\n     basic_block bb = e->src;\n-    rtx ret = bb->end;\n+    rtx ret = BB_END (bb);\n     rtx prev;\n     bool replace = false;\n "}, {"sha": "5a7c684d8a5539a129040e6a1f4b883754cc5d0a", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -7140,7 +7140,7 @@ emit_predicate_relation_info (void)\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       int r;\n-      rtx head = bb->head;\n+      rtx head = BB_HEAD (bb);\n \n       /* We only need such notes at code labels.  */\n       if (GET_CODE (head) != CODE_LABEL)\n@@ -7154,8 +7154,8 @@ emit_predicate_relation_info (void)\n \t  {\n \t    rtx p = gen_rtx_REG (BImode, r);\n \t    rtx n = emit_insn_after (gen_pred_rel_mutex (p), head);\n-\t    if (head == bb->end)\n-\t      bb->end = n;\n+\t    if (head == BB_END (bb))\n+\t      BB_END (bb) = n;\n \t    head = n;\n \t  }\n     }\n@@ -7166,7 +7166,7 @@ emit_predicate_relation_info (void)\n      the call.  */\n   FOR_EACH_BB_REVERSE (bb)\n     {\n-      rtx insn = bb->head;\n+      rtx insn = BB_HEAD (bb);\n \n       while (1)\n \t{\n@@ -7176,13 +7176,13 @@ emit_predicate_relation_info (void)\n \t    {\n \t      rtx b = emit_insn_before (gen_safe_across_calls_all (), insn);\n \t      rtx a = emit_insn_after (gen_safe_across_calls_normal (), insn);\n-\t      if (bb->head == insn)\n-\t\tbb->head = b;\n-\t      if (bb->end == insn)\n-\t\tbb->end = a;\n+\t      if (BB_HEAD (bb) == insn)\n+\t\tBB_HEAD (bb) = b;\n+\t      if (BB_END (bb) == insn)\n+\t\tBB_END (bb) = a;\n \t    }\n \n-\t  if (insn == bb->end)\n+\t  if (insn == BB_END (bb))\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}"}, {"sha": "a23bad35c193d7095b8bb7ade4c62dd99972a508", "filename": "gcc/conflict.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -435,9 +435,9 @@ conflict_graph_compute (regset regs, partition p)\n       AND_REG_SET (live, regs);\n \n       /* Walk the instruction stream backwards.  */\n-      head = bb->head;\n-      insn = bb->end;\n-      for (insn = bb->end; insn != head; insn = PREV_INSN (insn))\n+      head = BB_HEAD (bb);\n+      insn = BB_END (bb);\n+      for (insn = BB_END (bb); insn != head; insn = PREV_INSN (insn))\n \t{\n \t  int born_reg;\n \t  int live_reg;"}, {"sha": "96c8ad8dbd2c8be4afd9b92dcc8caa2b3baf33a2", "filename": "gcc/df.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -1215,14 +1215,14 @@ df_bb_refs_record (struct df *df, basic_block bb)\n   rtx insn;\n \n   /* Scan the block an insn at a time from beginning to end.  */\n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \t{\n \t  /* Record defs within INSN.  */\n \t  df_insn_refs_record (df, bb, insn);\n \t}\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n }\n@@ -1255,7 +1255,7 @@ df_bb_reg_def_chain_create (struct df *df, basic_block bb)\n      scan the basic blocks in reverse order so that the first defs\n      appear at the start of the chain.  */\n \n-  for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n+  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n        insn = PREV_INSN (insn))\n     {\n       struct df_link *link;\n@@ -1307,7 +1307,7 @@ df_bb_reg_use_chain_create (struct df *df, basic_block bb)\n   /* Scan in forward order so that the last uses appear at the start\n      of the chain.  */\n \n-  for (insn = bb->head; insn && insn != NEXT_INSN (bb->end);\n+  for (insn = BB_HEAD (bb); insn && insn != NEXT_INSN (BB_END (bb));\n        insn = NEXT_INSN (insn))\n     {\n       struct df_link *link;\n@@ -1360,7 +1360,7 @@ df_bb_du_chain_create (struct df *df, basic_block bb, bitmap ru)\n \n   /* For each def in BB create a linked list (chain) of uses\n      reached from the def.  */\n-  for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n+  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n        insn = PREV_INSN (insn))\n     {\n       struct df_link *def_link;\n@@ -1437,7 +1437,7 @@ df_bb_ud_chain_create (struct df *df, basic_block bb)\n \n   /* For each use in BB create a linked list (chain) of defs\n      that reach the use.  */\n-  for (insn = bb->head; insn && insn != NEXT_INSN (bb->end);\n+  for (insn = BB_HEAD (bb); insn && insn != NEXT_INSN (BB_END (bb));\n        insn = NEXT_INSN (insn))\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -1547,7 +1547,7 @@ df_bb_rd_local_compute (struct df *df, basic_block bb)\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n \n-  for (insn = bb->head; insn && insn != NEXT_INSN (bb->end);\n+  for (insn = BB_HEAD (bb); insn && insn != NEXT_INSN (BB_END (bb));\n        insn = NEXT_INSN (insn))\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -1611,7 +1611,7 @@ df_bb_ru_local_compute (struct df *df, basic_block bb)\n   rtx insn;\n \n \n-  for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n+  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n        insn = PREV_INSN (insn))\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -1674,7 +1674,7 @@ df_bb_lr_local_compute (struct df *df, basic_block bb)\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n \n-  for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n+  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n        insn = PREV_INSN (insn))\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -1729,7 +1729,7 @@ df_bb_reg_info_compute (struct df *df, basic_block bb, bitmap live)\n \n   bitmap_copy (live, bb_info->lr_out);\n \n-  for (insn = bb->end; insn && insn != PREV_INSN (bb->head);\n+  for (insn = BB_END (bb); insn && insn != PREV_INSN (BB_HEAD (bb));\n        insn = PREV_INSN (insn))\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -1795,13 +1795,13 @@ df_bb_luids_set (struct df *df, basic_block bb)\n \n   /* The LUIDs are monotonically increasing for each basic block.  */\n \n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \tDF_INSN_LUID (df, insn) = luid++;\n       DF_INSN_LUID (df, insn) = luid;\n \n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n   return luid;\n@@ -2096,7 +2096,7 @@ df_bb_refs_update (struct df *df, basic_block bb)\n      a bitmap for insns_modified saves memory and avoids queuing\n      duplicates.  */\n \n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       unsigned int uid;\n \n@@ -2112,7 +2112,7 @@ df_bb_refs_update (struct df *df, basic_block bb)\n \n \t  count++;\n \t}\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n   return count;\n@@ -2248,14 +2248,14 @@ df_bb_refs_unlink (struct df *df, basic_block bb)\n   rtx insn;\n \n   /* Scan the block an insn at a time from beginning to end.  */\n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \t{\n \t  /* Unlink refs for INSN.  */\n \t  df_insn_refs_unlink (df, bb, insn);\n \t}\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n }\n@@ -2294,7 +2294,7 @@ df_insn_delete (struct df *df, basic_block bb ATTRIBUTE_UNUSED, rtx insn)\n      handle the JUMP_LABEL?  */\n \n   /* We should not be deleting the NOTE_INSN_BASIC_BLOCK or label.  */\n-  if (insn == bb->head)\n+  if (insn == BB_HEAD (bb))\n     abort ();\n \n   /* Delete the insn.  */\n@@ -2591,7 +2591,7 @@ df_pattern_emit_before (struct df *df, rtx pattern, basic_block bb, rtx insn)\n   rtx prev_insn = PREV_INSN (insn);\n \n   /* We should not be inserting before the start of the block.  */\n-  if (insn == bb->head)\n+  if (insn == BB_HEAD (bb))\n     abort ();\n   ret_insn = emit_insn_before (pattern, insn);\n   if (ret_insn == insn)"}, {"sha": "cf893b5e7ecec3ef845af2c50373cfc26932f18a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -3803,12 +3803,12 @@ add_insn_after (rtx insn, rtx after)\n \tbb->flags |= BB_DIRTY;\n       /* Should not happen as first in the BB is always\n \t either NOTE or LABEL.  */\n-      if (bb->end == after\n+      if (BB_END (bb) == after\n \t  /* Avoid clobbering of structure when creating new BB.  */\n \t  && GET_CODE (insn) != BARRIER\n \t  && (GET_CODE (insn) != NOTE\n \t      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n-\tbb->end = insn;\n+\tBB_END (bb) = insn;\n     }\n \n   NEXT_INSN (after) = insn;\n@@ -3871,7 +3871,7 @@ add_insn_before (rtx insn, rtx before)\n \tbb->flags |= BB_DIRTY;\n       /* Should not happen as first in the BB is always\n \t either NOTE or LABEl.  */\n-      if (bb->head == insn\n+      if (BB_HEAD (bb) == insn\n \t  /* Avoid clobbering of structure when creating new BB.  */\n \t  && GET_CODE (insn) != BARRIER\n \t  && (GET_CODE (insn) != NOTE\n@@ -3946,16 +3946,16 @@ remove_insn (rtx insn)\n     {\n       if (INSN_P (insn))\n \tbb->flags |= BB_DIRTY;\n-      if (bb->head == insn)\n+      if (BB_HEAD (bb) == insn)\n \t{\n \t  /* Never ever delete the basic block note without deleting whole\n \t     basic block.  */\n \t  if (GET_CODE (insn) == NOTE)\n \t    abort ();\n-\t  bb->head = next;\n+\t  BB_HEAD (bb) = next;\n \t}\n-      if (bb->end == insn)\n-\tbb->end = prev;\n+      if (BB_END (bb) == insn)\n+\tBB_END (bb) = prev;\n     }\n }\n \n@@ -4048,13 +4048,13 @@ reorder_insns (rtx from, rtx to, rtx after)\n       if (GET_CODE (from) != BARRIER\n \t  && (bb2 = BLOCK_FOR_INSN (from)))\n \t{\n-\t  if (bb2->end == to)\n-\t    bb2->end = prev;\n+\t  if (BB_END (bb2) == to)\n+\t    BB_END (bb2) = prev;\n \t  bb2->flags |= BB_DIRTY;\n \t}\n \n-      if (bb->end == after)\n-\tbb->end = to;\n+      if (BB_END (bb) == after)\n+\tBB_END (bb) = to;\n \n       for (x = from; x != NEXT_INSN (to); x = NEXT_INSN (x))\n \tset_block_for_insn (x, bb);\n@@ -4443,8 +4443,8 @@ emit_insn_after_1 (rtx first, rtx after)\n \t  set_block_for_insn (last, bb);\n       if (GET_CODE (last) != BARRIER)\n \tset_block_for_insn (last, bb);\n-      if (bb->end == after)\n-\tbb->end = last;\n+      if (BB_END (bb) == after)\n+\tBB_END (bb) = last;\n     }\n   else\n     for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))"}, {"sha": "6003ac1bd1e90832a880e8fd6b68fb57195190ad", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -673,7 +673,7 @@ compute_alignments (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      rtx label = bb->head;\n+      rtx label = BB_HEAD (bb);\n       int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n       edge e;\n "}, {"sha": "6be78fcf71a4a0b3cb49819c0804aa892a19b7ba", "filename": "gcc/flow.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -376,7 +376,7 @@ first_insn_after_basic_block_note (basic_block block)\n   rtx insn;\n \n   /* Get the first instruction in the block.  */\n-  insn = block->head;\n+  insn = BB_HEAD (block);\n \n   if (insn == NULL_RTX)\n     return NULL_RTX;\n@@ -505,7 +505,7 @@ verify_wide_reg_1 (rtx *px, void *pregno)\n static void\n verify_wide_reg (int regno, basic_block bb)\n {\n-  rtx head = bb->head, end = bb->end;\n+  rtx head = BB_HEAD (bb), end = BB_END (bb);\n \n   while (1)\n     {\n@@ -822,7 +822,7 @@ delete_noop_moves (rtx f ATTRIBUTE_UNUSED)\n \n   FOR_EACH_BB (bb)\n     {\n-      for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = next)\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb)); insn = next)\n \t{\n \t  next = NEXT_INSN (insn);\n \t  if (INSN_P (insn) && noop_move_p (insn))\n@@ -1844,8 +1844,8 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n   /* If this block ends in a conditional branch, for each register\n      live from one side of the branch and not the other, record the\n      register as conditionally dead.  */\n-  if (GET_CODE (bb->end) == JUMP_INSN\n-      && any_condjump_p (bb->end))\n+  if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+      && any_condjump_p (BB_END (bb)))\n     {\n       regset_head diff_head;\n       regset diff = INITIALIZE_REG_SET (diff_head);\n@@ -1870,7 +1870,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n       else\n \t{\n \t  /* This can happen with a conditional jump to the next insn.  */\n-\t  if (JUMP_LABEL (bb->end) != bb_true->head)\n+\t  if (JUMP_LABEL (BB_END (bb)) != BB_HEAD (bb_true))\n \t    abort ();\n \n \t  /* Simplest way to do nothing.  */\n@@ -1882,7 +1882,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t\t\t    bb_false->global_live_at_start, BITMAP_XOR))\n \t{\n \t  /* Extract the condition from the branch.  */\n-\t  rtx set_src = SET_SRC (pc_set (bb->end));\n+\t  rtx set_src = SET_SRC (pc_set (BB_END (bb)));\n \t  rtx cond_true = XEXP (set_src, 0);\n \t  rtx reg = XEXP (cond_true, 0);\n \n@@ -1951,7 +1951,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t      && ! current_function_calls_eh_return)))\n     {\n       rtx insn, set;\n-      for (insn = bb->end; insn != bb->head; insn = PREV_INSN (insn))\n+      for (insn = BB_END (bb); insn != BB_HEAD (bb); insn = PREV_INSN (insn))\n \tif (GET_CODE (insn) == INSN\n \t    && (set = single_set (insn))\n \t    && GET_CODE (SET_DEST (set)) == MEM)\n@@ -2031,7 +2031,7 @@ propagate_block (basic_block bb, regset live, regset local_set,\n   /* Scan the block an insn at a time from end to beginning.  */\n \n   changed = 0;\n-  for (insn = bb->end;; insn = prev)\n+  for (insn = BB_END (bb); ; insn = prev)\n     {\n       /* If this is a call to `setjmp' et al, warn if any\n \t non-volatile datum is live.  */\n@@ -2046,7 +2046,7 @@ propagate_block (basic_block bb, regset live, regset local_set,\n       else\n         changed |= NEXT_INSN (prev) != insn;\n \n-      if (insn == bb->head)\n+      if (insn == BB_HEAD (bb))\n \tbreak;\n     }\n \n@@ -3313,8 +3313,8 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n \t new insn(s) and do the updates.  */\n       emit_insn_before (insns, insn);\n \n-      if (pbi->bb->head == insn)\n-\tpbi->bb->head = insns;\n+      if (BB_HEAD (pbi->bb) == insn)\n+\tBB_HEAD (pbi->bb) = insns;\n \n       /* INCR will become a NOTE and INSN won't contain a\n \t use of INCR_REG.  If a use of INCR_REG was just placed in\n@@ -4229,7 +4229,7 @@ count_or_remove_death_notes_bb (basic_block bb, int kill)\n   int count = 0;\n   rtx insn;\n \n-  for (insn = bb->head;; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \t{\n@@ -4273,7 +4273,7 @@ count_or_remove_death_notes_bb (basic_block bb, int kill)\n \t    }\n \t}\n \n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n \n@@ -4300,7 +4300,7 @@ clear_log_links (sbitmap blocks)\n       {\n \tbasic_block bb = BASIC_BLOCK (i);\n \n-\tfor (insn = bb->head; insn != NEXT_INSN (bb->end);\n+\tfor (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n \t     insn = NEXT_INSN (insn))\n \t  if (INSN_P (insn))\n \t    free_INSN_LIST_list (&LOG_LINKS (insn));"}, {"sha": "2f6fb9bd1434c75ec58e7a28a77ecd363d7df9f3", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -7293,9 +7293,9 @@ sibcall_epilogue_contains (rtx insn)\n static void\n emit_return_into_block (basic_block bb, rtx line_note)\n {\n-  emit_jump_insn_after (gen_return (), bb->end);\n+  emit_jump_insn_after (gen_return (), BB_END (bb));\n   if (line_note)\n-    emit_note_copy_after (line_note, PREV_INSN (bb->end));\n+    emit_note_copy_after (line_note, PREV_INSN (BB_END (bb)));\n }\n #endif /* HAVE_return */\n \n@@ -7720,15 +7720,15 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       last = e->src;\n \n       /* Verify that there are no active instructions in the last block.  */\n-      label = last->end;\n+      label = BB_END (last);\n       while (label && GET_CODE (label) != CODE_LABEL)\n \t{\n \t  if (active_insn_p (label))\n \t    break;\n \t  label = PREV_INSN (label);\n \t}\n \n-      if (last->head == label && GET_CODE (label) == CODE_LABEL)\n+      if (BB_HEAD (last) == label && GET_CODE (label) == CODE_LABEL)\n \t{\n \t  rtx epilogue_line_note = NULL_RTX;\n \n@@ -7752,7 +7752,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t      if (bb == ENTRY_BLOCK_PTR)\n \t\tcontinue;\n \n-\t      jump = bb->end;\n+\t      jump = BB_END (bb);\n \t      if ((GET_CODE (jump) != JUMP_INSN) || JUMP_LABEL (jump) != label)\n \t\tcontinue;\n \n@@ -7787,9 +7787,9 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t  /* Emit a return insn for the exit fallthru block.  Whether\n \t     this is still reachable will be determined later.  */\n \n-\t  emit_barrier_after (last->end);\n+\t  emit_barrier_after (BB_END (last));\n \t  emit_return_into_block (last, epilogue_line_note);\n-\t  epilogue_end = last->end;\n+\t  epilogue_end = BB_END (last);\n \t  last->succ->flags &= ~EDGE_FALLTHRU;\n \t  goto epilogue_done;\n \t}\n@@ -7845,7 +7845,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n   for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     {\n       basic_block bb = e->src;\n-      rtx insn = bb->end;\n+      rtx insn = BB_END (bb);\n       rtx i;\n       rtx newinsn;\n \n@@ -7902,7 +7902,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t}\n \n       /* Find the last line number note in the first block.  */\n-      for (insn = ENTRY_BLOCK_PTR->next_bb->end;\n+      for (insn = BB_END (ENTRY_BLOCK_PTR->next_bb);\n \t   insn != prologue_end && insn;\n \t   insn = PREV_INSN (insn))\n \tif (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)"}, {"sha": "dc18797f51354c5c30b5da247ad3b1329d5d99f0", "filename": "gcc/gcse.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -2203,7 +2203,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n \t       /* A copy is not available if its src or dest is subsequently\n \t\t  modified.  Here we want to search from INSN+1 on, but\n \t\t  oprs_available_p searches from INSN on.  */\n-\t       && (insn == BLOCK_END (BLOCK_NUM (insn))\n+\t       && (insn == BB_END (BLOCK_FOR_INSN (insn))\n \t\t   || ((tmp = next_nonnote_insn (insn)) != NULL_RTX\n \t\t       && oprs_available_p (pat, tmp))))\n \tinsert_set_in_table (pat, insn, table);\n@@ -2510,8 +2510,8 @@ compute_hash_table_work (struct hash_table *table)\n \t ??? hard-reg reg_set_in_block computation\n \t could be moved to compute_sets since they currently don't change.  */\n \n-      for (insn = current_bb->head;\n-\t   insn && insn != NEXT_INSN (current_bb->end);\n+      for (insn = BB_HEAD (current_bb);\n+\t   insn && insn != NEXT_INSN (BB_END (current_bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_P (insn))\n@@ -2541,12 +2541,12 @@ compute_hash_table_work (struct hash_table *table)\n       if (table->set_p\n \t  && implicit_sets[current_bb->index] != NULL_RTX)\n \thash_scan_set (implicit_sets[current_bb->index],\n-\t\t       current_bb->head, table);\n+\t\t       BB_HEAD (current_bb), table);\n \n       /* The next pass builds the hash table.  */\n \n-      for (insn = current_bb->head, in_libcall_block = 0;\n-\t   insn && insn != NEXT_INSN (current_bb->end);\n+      for (insn = BB_HEAD (current_bb), in_libcall_block = 0;\n+\t   insn && insn != NEXT_INSN (BB_END (current_bb));\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n@@ -3540,8 +3540,8 @@ classic_gcse (void)\n \t start of the block].  */\n       reset_opr_set_tables ();\n \n-      for (insn = bb->head;\n-\t   insn != NULL && insn != NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NULL && insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  /* Is insn of form (set (pseudo-reg) ...)?  */\n@@ -4477,8 +4477,8 @@ cprop (int alter_jumps)\n \t start of the block].  */\n       reset_opr_set_tables ();\n \n-      for (insn = bb->head;\n-\t   insn != NULL && insn != NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NULL && insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n@@ -4578,7 +4578,7 @@ find_implicit_sets (void)\n     /* Check for more than one successor.  */\n     if (bb->succ && bb->succ->succ_next)\n       {\n-\tcond = fis_get_condition (bb->end);\n+\tcond = fis_get_condition (BB_END (bb));\n \n \tif (cond\n \t    && (GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n@@ -4901,8 +4901,8 @@ bypass_conditional_jumps (void)\n       if (bb->pred && bb->pred->pred_next)\n \t{\n \t  setcc = NULL_RTX;\n-\t  for (insn = bb->head;\n-\t       insn != NULL && insn != NEXT_INSN (bb->end);\n+\t  for (insn = BB_HEAD (bb);\n+\t       insn != NULL && insn != NEXT_INSN (BB_END (bb));\n \t       insn = NEXT_INSN (insn))\n \t    if (GET_CODE (insn) == INSN)\n \t      {\n@@ -5193,7 +5193,7 @@ process_insert_insn (struct expr *expr)\n static void\n insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n {\n-  rtx insn = bb->end;\n+  rtx insn = BB_END (bb);\n   rtx new_insn;\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n@@ -5274,7 +5274,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n       /* Since different machines initialize their parameter registers\n \t in different orders, assume nothing.  Collect the set of all\n \t parameter registers.  */\n-      insn = find_first_parameter_load (insn, bb->head);\n+      insn = find_first_parameter_load (insn, BB_HEAD (bb));\n \n       /* If we found all the parameter loads, then we want to insert\n \t before the first parameter load.\n@@ -5834,7 +5834,7 @@ compute_transpout (void)\n       /* Note that flow inserted a nop a the end of basic blocks that\n \t end in call instructions for reasons other than abnormal\n \t control flow.  */\n-      if (GET_CODE (bb->end) != CALL_INSN)\n+      if (GET_CODE (BB_END (bb)) != CALL_INSN)\n \tcontinue;\n \n       for (i = 0; i < expr_hash_table.size; i++)\n@@ -5916,8 +5916,8 @@ delete_null_pointer_checks_1 (unsigned int *block_reg, sbitmap *nonnull_avin,\n \n       /* Scan each insn in the basic block looking for memory references and\n \t register sets.  */\n-      stop_insn = NEXT_INSN (current_block->end);\n-      for (insn = current_block->head;\n+      stop_insn = NEXT_INSN (BB_HEAD (current_block));\n+      for (insn = BB_HEAD (current_block);\n \t   insn != stop_insn;\n \t   insn = NEXT_INSN (insn))\n \t{\n@@ -5972,7 +5972,7 @@ delete_null_pointer_checks_1 (unsigned int *block_reg, sbitmap *nonnull_avin,\n      against zero.  */\n   FOR_EACH_BB (bb)\n     {\n-      rtx last_insn = bb->end;\n+      rtx last_insn = BB_END (bb);\n       rtx condition, earliest;\n       int compare_and_branch;\n \n@@ -6022,7 +6022,7 @@ delete_null_pointer_checks_1 (unsigned int *block_reg, sbitmap *nonnull_avin,\n \tdelete_insn (earliest);\n       purge_dead_edges (bb);\n \n-      /* Don't check this block again.  (Note that BLOCK_END is\n+      /* Don't check this block again.  (Note that BB_END is\n \t invalid here; we deleted the last instruction in the\n \t block.)  */\n       block_reg[bb->index] = 0;\n@@ -6088,7 +6088,7 @@ delete_null_pointer_checks (rtx f ATTRIBUTE_UNUSED)\n   block_reg = xcalloc (last_basic_block, sizeof (int));\n   FOR_EACH_BB (bb)\n     {\n-      rtx last_insn = bb->end;\n+      rtx last_insn = BB_END (bb);\n       rtx condition, earliest, reg;\n \n       /* We only want conditional branches.  */\n@@ -6747,8 +6747,8 @@ compute_ld_motion_mems (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      for (insn = bb->head;\n-\t   insn && insn != NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb);\n+\t   insn && insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (INSN_P (insn))\n@@ -7156,7 +7156,7 @@ find_moveable_store (rtx insn, int *regs_set_before, int *regs_set_after)\n \t failed last time.  */\n       if (LAST_AVAIL_CHECK_FAILURE (ptr))\n \t{\n-\t  for (tmp = bb->end;\n+\t  for (tmp = BB_END (bb);\n \t       tmp != insn && tmp != LAST_AVAIL_CHECK_FAILURE (ptr);\n \t       tmp = PREV_INSN (tmp))\n \t    continue;\n@@ -7199,8 +7199,8 @@ compute_store_table (void)\n       /* First compute the registers set in this block.  */\n       regvec = last_set_in;\n \n-      for (insn = bb->head;\n-\t   insn != NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_P (insn))\n@@ -7232,8 +7232,8 @@ compute_store_table (void)\n       /* Now find the stores.  */\n       memset (already_set, 0, sizeof (int) * max_gcse_regno);\n       regvec = already_set;\n-      for (insn = bb->head;\n-\t   insn != NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_P (insn))\n@@ -7466,7 +7466,7 @@ static bool\n store_killed_after (rtx x, rtx x_regs, rtx insn, basic_block bb,\n \t\t    int *regs_set_after, rtx *fail_insn)\n {\n-  rtx last = bb->end, act;\n+  rtx last = BB_END (bb), act;\n \n   if (!store_ops_ok (x_regs, regs_set_after))\n     {\n@@ -7495,7 +7495,7 @@ static bool\n store_killed_before (rtx x, rtx x_regs, rtx insn, basic_block bb,\n \t\t     int *regs_set_before)\n {\n-  rtx first = bb->head;\n+  rtx first = BB_HEAD (bb);\n \n   if (!store_ops_ok (x_regs, regs_set_before))\n     return true;\n@@ -7570,7 +7570,7 @@ build_store_vectors (void)\n \n       for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n \t{\n-\t  if (store_killed_after (ptr->pattern, ptr->pattern_regs, bb->head,\n+\t  if (store_killed_after (ptr->pattern, ptr->pattern_regs, BB_HEAD (bb),\n \t\t\t\t  bb, regs_set_in_block, NULL))\n \t    {\n \t      /* It should not be necessary to consider the expression\n@@ -7596,22 +7596,22 @@ build_store_vectors (void)\n }\n \n /* Insert an instruction at the beginning of a basic block, and update\n-   the BLOCK_HEAD if needed.  */\n+   the BB_HEAD if needed.  */\n \n static void\n insert_insn_start_bb (rtx insn, basic_block bb)\n {\n   /* Insert at start of successor block.  */\n-  rtx prev = PREV_INSN (bb->head);\n-  rtx before = bb->head;\n+  rtx prev = PREV_INSN (BB_HEAD (bb));\n+  rtx before = BB_HEAD (bb);\n   while (before != 0)\n     {\n       if (GET_CODE (before) != CODE_LABEL\n \t  && (GET_CODE (before) != NOTE\n \t      || NOTE_LINE_NUMBER (before) != NOTE_INSN_BASIC_BLOCK))\n \tbreak;\n       prev = before;\n-      if (prev == bb->end)\n+      if (prev == BB_END (bb))\n \tbreak;\n       before = NEXT_INSN (before);\n     }\n@@ -7746,9 +7746,9 @@ remove_reachable_equiv_notes (basic_block bb, struct ls_expr *smexpr)\n \t  last = XEXP (last, 0);\n \t}\n       else\n-\tlast = NEXT_INSN (bb->end);\n+\tlast = NEXT_INSN (BB_END (bb));\n   \n-      for (insn = bb->head; insn != last; insn = NEXT_INSN (insn))\n+      for (insn = BB_HEAD (bb); insn != last; insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n \t    note = find_reg_equal_equiv_note (insn);\n@@ -7802,7 +7802,7 @@ replace_store_insn (rtx reg, rtx del, basic_block bb, struct ls_expr *smexpr)\n   /* Now we must handle REG_EQUAL notes whose contents is equal to the mem;\n      they are no longer accurate provided that they are reached by this\n      definition, so drop them.  */\n-  for (; insn != NEXT_INSN (bb->end); insn = NEXT_INSN (insn))\n+  for (; insn != NEXT_INSN (BB_END (bb)); insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       {\n \tset = single_set (insn);"}, {"sha": "784d551fb8acfe4d633a1d56635644c7920abf1e", "filename": "gcc/gengtype.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -2914,10 +2914,10 @@ main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n   do_scalar_typedef (\"uint8\", &pos);\n   do_scalar_typedef (\"jword\", &pos);\n   do_scalar_typedef (\"JCF_u2\", &pos);\n+  do_scalar_typedef (\"void\", &pos);\n+\n+  do_typedef (\"PTR\", create_pointer (resolve_typedef (\"void\", &pos)), &pos);\n \n-  do_typedef (\"PTR\", create_pointer (create_scalar_type (\"void\",\n-\t\t\t\t\t\t\t strlen (\"void\"))),\n-\t      &pos);\n   do_typedef (\"HARD_REG_SET\", create_array (\n \t      create_scalar_type (\"unsigned long\", strlen (\"unsigned long\")),\n \t      \"2\"), &pos);"}, {"sha": "783b96f1f152dff265d06bd38b0de5320b3a58ee", "filename": "gcc/global.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -752,7 +752,7 @@ global_conflicts (void)\n \t}\n       }\n \n-      insn = b->head;\n+      insn = BB_HEAD (b);\n \n       /* Scan the code of this basic block, noting which allocnos\n \t and hard regs are born or die.  When one is born,\n@@ -852,7 +852,7 @@ global_conflicts (void)\n \t\t}\n \t    }\n \n-\t  if (insn == b->end)\n+\t  if (insn == BB_END (b))\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}\n@@ -1801,7 +1801,7 @@ build_insn_chain (rtx first)\n     {\n       struct insn_chain *c;\n \n-      if (first == b->head)\n+      if (first == BB_HEAD (b))\n \t{\n \t  int i;\n \n@@ -1863,7 +1863,7 @@ build_insn_chain (rtx first)\n \t    }\n \t}\n \n-      if (first == b->end)\n+      if (first == BB_END (b))\n \tb = b->next_bb;\n \n       /* Stop after we pass the end of the last basic block.  Verify that"}, {"sha": "d82dd917ce9ee712c0a7a5d1a184333bae3590c5", "filename": "gcc/graph.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -260,14 +260,14 @@ print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n       FOR_EACH_BB_REVERSE (bb)\n \t{\n \t  rtx x;\n-\t  start[INSN_UID (bb->head)] = bb->index;\n-\t  end[INSN_UID (bb->end)] = bb->index;\n-\t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n+\t  start[INSN_UID (BB_HEAD (bb))] = bb->index;\n+\t  end[INSN_UID (BB_END (bb))] = bb->index;\n+\t  for (x = BB_HEAD (bb); x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      in_bb_p[INSN_UID (x)]\n \t\t= (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n \t\t ? IN_ONE_BB : IN_MULTIPLE_BB;\n-\t      if (x == bb->end)\n+\t      if (x == BB_END (bb))\n \t\tbreak;\n \t    }\n \t}\n@@ -321,7 +321,7 @@ print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n \t\t{\n \t\t  if (e->dest != EXIT_BLOCK_PTR)\n \t\t    {\n-\t\t      rtx block_head = e->dest->head;\n+\t\t      rtx block_head = BB_HEAD (e->dest);\n \n \t\t      draw_edge (fp, INSN_UID (tmp_rtx),\n \t\t\t\t INSN_UID (block_head),"}, {"sha": "94f67b7a23a451d293a427c1bc7ad68376a08d79", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -123,8 +123,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    This pass must update information that subsequent passes expect to\n    be correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,\n-   reg_n_calls_crossed, and reg_live_length.  Also, BLOCK_HEAD,\n-   BLOCK_END.\n+   reg_n_calls_crossed, and reg_live_length.  Also, BB_HEAD, BB_END.\n \n    The information in the line number notes is carefully retained by\n    this pass.  Notes that refer to the starting and ending of\n@@ -1432,8 +1431,8 @@ void\n get_block_head_tail (int b, rtx *headp, rtx *tailp)\n {\n   /* HEAD and TAIL delimit the basic block being scheduled.  */\n-  rtx head = BLOCK_HEAD (b);\n-  rtx tail = BLOCK_END (b);\n+  rtx head = BB_HEAD (BASIC_BLOCK (b));\n+  rtx tail = BB_END (BASIC_BLOCK (b));\n \n   /* Don't include any notes or labels at the beginning of the\n      basic block, or notes at the ends of basic blocks.  */\n@@ -2791,7 +2790,7 @@ sched_init (FILE *dump_file)\n   h_i_d[0].luid = 0;\n   luid = 1;\n   FOR_EACH_BB (b)\n-    for (insn = b->head;; insn = NEXT_INSN (insn))\n+    for (insn = BB_HEAD (b); ; insn = NEXT_INSN (insn))\n       {\n \tINSN_LUID (insn) = luid;\n \n@@ -2803,7 +2802,7 @@ sched_init (FILE *dump_file)\n \tif (GET_CODE (insn) != NOTE)\n \t  ++luid;\n \n-\tif (insn == b->end)\n+\tif (insn == BB_END (b))\n \t  break;\n       }\n \n@@ -2825,15 +2824,15 @@ sched_init (FILE *dump_file)\n \n       FOR_EACH_BB (b)\n \t{\n-\t  for (line = b->head; line; line = PREV_INSN (line))\n+\t  for (line = BB_HEAD (b); line; line = PREV_INSN (line))\n \t    if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n \t      {\n \t\tline_note_head[b->index] = line;\n \t\tbreak;\n \t      }\n \t  /* Do a forward search as well, since we won't get to see the first\n \t     notes in a basic block.  */\n-\t  for (line = b->head; line; line = NEXT_INSN (line))\n+\t  for (line = BB_HEAD (b); line; line = NEXT_INSN (line))\n \t    {\n \t      if (INSN_P (line))\n \t\tbreak;\n@@ -2852,16 +2851,16 @@ sched_init (FILE *dump_file)\n   /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n      known why this is done.  */\n \n-  insn = EXIT_BLOCK_PTR->prev_bb->end;\n+  insn = BB_END (EXIT_BLOCK_PTR->prev_bb);\n   if (NEXT_INSN (insn) == 0\n       || (GET_CODE (insn) != NOTE\n \t  && GET_CODE (insn) != CODE_LABEL\n \t  /* Don't emit a NOTE if it would end up before a BARRIER.  */\n \t  && GET_CODE (NEXT_INSN (insn)) != BARRIER))\n     {\n-      emit_note_after (NOTE_INSN_DELETED, EXIT_BLOCK_PTR->prev_bb->end);\n+      emit_note_after (NOTE_INSN_DELETED, BB_END (EXIT_BLOCK_PTR->prev_bb));\n       /* Make insn to appear outside BB.  */\n-      EXIT_BLOCK_PTR->prev_bb->end = PREV_INSN (EXIT_BLOCK_PTR->prev_bb->end);\n+      BB_END (EXIT_BLOCK_PTR->prev_bb) = PREV_INSN (BB_END (EXIT_BLOCK_PTR->prev_bb));\n     }\n \n   /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before"}, {"sha": "97efb72bae1c0499bdce221027dc53384a8ac9e8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -148,14 +148,14 @@ static int\n count_bb_insns (basic_block bb)\n {\n   int count = 0;\n-  rtx insn = bb->head;\n+  rtx insn = BB_HEAD (bb);\n \n   while (1)\n     {\n       if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == INSN)\n \tcount++;\n \n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n       insn = NEXT_INSN (insn);\n     }\n@@ -168,18 +168,18 @@ count_bb_insns (basic_block bb)\n static rtx\n first_active_insn (basic_block bb)\n {\n-  rtx insn = bb->head;\n+  rtx insn = BB_HEAD (bb);\n \n   if (GET_CODE (insn) == CODE_LABEL)\n     {\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \treturn NULL_RTX;\n       insn = NEXT_INSN (insn);\n     }\n \n   while (GET_CODE (insn) == NOTE)\n     {\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \treturn NULL_RTX;\n       insn = NEXT_INSN (insn);\n     }\n@@ -195,8 +195,8 @@ first_active_insn (basic_block bb)\n static rtx\n last_active_insn (basic_block bb, int skip_use_p)\n {\n-  rtx insn = bb->end;\n-  rtx head = bb->head;\n+  rtx insn = BB_END (bb);\n+  rtx head = BB_HEAD (bb);\n \n   while (GET_CODE (insn) == NOTE\n \t || GET_CODE (insn) == JUMP_INSN\n@@ -407,13 +407,13 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n \n   /* Find the conditional jump to the ELSE or JOIN part, and isolate\n      the test.  */\n-  test_expr = cond_exec_get_condition (test_bb->end);\n+  test_expr = cond_exec_get_condition (BB_END (test_bb));\n   if (! test_expr)\n     return FALSE;\n \n   /* If the conditional jump is more than just a conditional jump,\n      then we can not do conditional execution conversion on this block.  */\n-  if (! onlyjump_p (test_bb->end))\n+  if (! onlyjump_p (BB_END (test_bb)))\n     return FALSE;\n \n   /* Collect the bounds of where we're to search, skipping any labels, jumps\n@@ -440,7 +440,7 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n \n   true_expr = test_expr;\n \n-  false_code = reversed_comparison_code (true_expr, test_bb->end);\n+  false_code = reversed_comparison_code (true_expr, BB_END (test_bb));\n   if (false_code != UNKNOWN)\n     false_expr = gen_rtx_fmt_ee (false_code, GET_MODE (true_expr),\n \t\t\t\t XEXP (true_expr, 0), XEXP (true_expr, 1));\n@@ -457,7 +457,7 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n     goto fail;\n #endif\n \n-  true_prob_val = find_reg_note (test_bb->end, REG_BR_PROB, NULL_RTX);\n+  true_prob_val = find_reg_note (BB_END (test_bb), REG_BR_PROB, NULL_RTX);\n   if (true_prob_val)\n     {\n       true_prob_val = XEXP (true_prob_val, 0);\n@@ -491,11 +491,11 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n \n \t  /* If the conditional jump is more than just a conditional jump, then\n \t     we can not do conditional execution conversion on this block.  */\n-\t  if (! onlyjump_p (bb->end))\n+\t  if (! onlyjump_p (BB_END (bb)))\n \t    goto fail;\n \n \t  /* Find the conditional jump and isolate the test.  */\n-\t  t = cond_exec_get_condition (bb->end);\n+\t  t = cond_exec_get_condition (BB_END (bb));\n \t  if (! t)\n \t    goto fail;\n \n@@ -1629,7 +1629,7 @@ noce_try_abs (struct noce_if_info *if_info)\n     {\n       rtx insn, note = NULL;\n       for (insn = earliest;\n-\t   insn != if_info->test_bb->head;\n+\t   insn != BB_HEAD (if_info->test_bb);\n \t   insn = PREV_INSN (insn))\n \tif (INSN_P (insn)\n \t    && ((note = find_reg_note (insn, REG_EQUAL, c))\n@@ -1829,7 +1829,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n     }\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n-  jump = test_bb->end;\n+  jump = BB_END (test_bb);\n   cond = noce_get_condition (jump, &if_info.cond_earliest);\n   if (! cond)\n     return FALSE;\n@@ -1945,8 +1945,8 @@ noce_process_if_block (struct ce_if_block * ce_info)\n \t{\n \t  rtx note;\n \n-\t  if (else_bb && insn_b == else_bb->end)\n-\t    else_bb->end = PREV_INSN (insn_b);\n+\t  if (else_bb && insn_b == BB_END (else_bb))\n+\t    BB_END (else_bb) = PREV_INSN (insn_b);\n \t  reorder_insns (insn_b, insn_b, PREV_INSN (jump));\n \n \t  /* If there was a REG_EQUAL note, delete it since it may have been\n@@ -2019,7 +2019,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n       unshare_all_rtl_in_chain (insn_b);\n       end_sequence ();\n \n-      emit_insn_after_setloc (insn_b, test_bb->end, INSN_LOCATOR (insn_a));\n+      emit_insn_after_setloc (insn_b, BB_END (test_bb), INSN_LOCATOR (insn_a));\n     }\n \n   /* Merge the blocks!  */\n@@ -2125,7 +2125,7 @@ merge_if_block (struct ce_if_block * ce_info)\n \n   if (! join_bb)\n     {\n-      rtx last = combo_bb->end;\n+      rtx last = BB_END (combo_bb);\n \n       /* The outgoing edge for the current COMBO block should already\n \t be correct.  Verify this.  */\n@@ -2316,8 +2316,8 @@ block_jumps_and_fallthru_p (basic_block cur_bb, basic_block target_bb)\n      together for conditional execution support.  ??? we should support\n      conditional execution support across calls for IA-64 some day, but\n      for now it makes the code simpler.  */\n-  end = cur_bb->end;\n-  insn = cur_bb->head;\n+  end = BB_END (cur_bb);\n+  insn = BB_HEAD (cur_bb);\n \n   while (insn != NULL_RTX)\n     {\n@@ -2448,7 +2448,7 @@ find_if_block (struct ce_if_block * ce_info)\n   if (then_succ != NULL_EDGE\n       && (then_succ->succ_next != NULL_EDGE\n           || (then_succ->flags & EDGE_COMPLEX)\n-\t  || (flow2_completed && tablejump_p (then_bb->end, NULL, NULL))))\n+\t  || (flow2_completed && tablejump_p (BB_END (then_bb), NULL, NULL))))\n     return FALSE;\n \n   /* If the THEN block has no successors, conditional execution can still\n@@ -2461,11 +2461,11 @@ find_if_block (struct ce_if_block * ce_info)\n     {\n       if (else_bb->pred->pred_next == NULL_EDGE)\n \t{\n-\t  rtx last_insn = then_bb->end;\n+\t  rtx last_insn = BB_END (then_bb);\n \n \t  while (last_insn\n \t\t && GET_CODE (last_insn) == NOTE\n-\t\t && last_insn != then_bb->head)\n+\t\t && last_insn != BB_HEAD (then_bb))\n \t    last_insn = PREV_INSN (last_insn);\n \n \t  if (last_insn\n@@ -2496,7 +2496,7 @@ find_if_block (struct ce_if_block * ce_info)\n \t   && else_bb->pred->pred_next == NULL_EDGE\n \t   && else_succ->succ_next == NULL_EDGE\n \t   && ! (else_succ->flags & EDGE_COMPLEX)\n-\t   && ! (flow2_completed && tablejump_p (else_bb->end, NULL, NULL)))\n+\t   && ! (flow2_completed && tablejump_p (BB_END (else_bb), NULL, NULL)))\n     join_bb = else_succ->dest;\n \n   /* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */\n@@ -2510,24 +2510,24 @@ find_if_block (struct ce_if_block * ce_info)\n       fprintf (rtl_dump_file, \"\\nIF-THEN%s block found, pass %d, start block %d [insn %d], then %d [%d]\",\n \t       (else_bb) ? \"-ELSE\" : \"\",\n \t       ce_info->pass,\n-\t       test_bb->index, (test_bb->head) ? (int)INSN_UID (test_bb->head) : -1,\n-\t       then_bb->index, (then_bb->head) ? (int)INSN_UID (then_bb->head) : -1);\n+\t       test_bb->index, (BB_HEAD (test_bb)) ? (int)INSN_UID (BB_HEAD (test_bb)) : -1,\n+\t       then_bb->index, (BB_HEAD (then_bb)) ? (int)INSN_UID (BB_HEAD (then_bb)) : -1);\n \n       if (else_bb)\n \tfprintf (rtl_dump_file, \", else %d [%d]\",\n-\t\t else_bb->index, (else_bb->head) ? (int)INSN_UID (else_bb->head) : -1);\n+\t\t else_bb->index, (BB_HEAD (else_bb)) ? (int)INSN_UID (BB_HEAD (else_bb)) : -1);\n \n       fprintf (rtl_dump_file, \", join %d [%d]\",\n-\t       join_bb->index, (join_bb->head) ? (int)INSN_UID (join_bb->head) : -1);\n+\t       join_bb->index, (BB_HEAD (join_bb)) ? (int)INSN_UID (BB_HEAD (join_bb)) : -1);\n \n       if (ce_info->num_multiple_test_blocks > 0)\n \tfprintf (rtl_dump_file, \", %d %s block%s last test %d [%d]\",\n \t\t ce_info->num_multiple_test_blocks,\n \t\t (ce_info->and_and_p) ? \"&&\" : \"||\",\n \t\t (ce_info->num_multiple_test_blocks == 1) ? \"\" : \"s\",\n \t\t ce_info->last_test_bb->index,\n-\t\t ((ce_info->last_test_bb->head)\n-\t\t  ? (int)INSN_UID (ce_info->last_test_bb->head)\n+\t\t ((BB_HEAD (ce_info->last_test_bb))\n+\t\t  ? (int)INSN_UID (BB_HEAD (ce_info->last_test_bb))\n \t\t  : -1));\n \n       fputc ('\\n', rtl_dump_file);\n@@ -2588,7 +2588,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n     }\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n-  jump = test_bb->end;\n+  jump = BB_END (test_bb);\n   cond = noce_get_condition (jump, &cond_earliest);\n   if (! cond)\n     return FALSE;\n@@ -2679,7 +2679,7 @@ block_has_only_trap (basic_block bb)\n \n   /* The only instruction in the THEN block must be the trap.  */\n   trap = first_active_insn (bb);\n-  if (! (trap == bb->end\n+  if (! (trap == BB_END (bb)\n \t && GET_CODE (PATTERN (trap)) == TRAP_IF\n          && TRAP_CONDITION (PATTERN (trap)) == const_true_rtx))\n     return NULL_RTX;\n@@ -2861,7 +2861,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */\n-  note = find_reg_note (test_bb->end, REG_BR_PROB, NULL_RTX);\n+  note = find_reg_note (BB_END (test_bb), REG_BR_PROB, NULL_RTX);\n   if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n     ;\n   else if (else_succ->dest->index < 0\n@@ -2928,11 +2928,11 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n {\n   rtx head, end, jump, earliest, old_dest, new_label = NULL_RTX;\n \n-  jump = test_bb->end;\n+  jump = BB_END (test_bb);\n \n   /* Find the extent of the real code in the merge block.  */\n-  head = merge_bb->head;\n-  end = merge_bb->end;\n+  head = BB_HEAD (merge_bb);\n+  end = BB_END (merge_bb);\n \n   if (GET_CODE (head) == CODE_LABEL)\n     head = NEXT_INSN (head);\n@@ -3152,8 +3152,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   /* Move the insns out of MERGE_BB to before the branch.  */\n   if (head != NULL)\n     {\n-      if (end == merge_bb->end)\n-\tmerge_bb->end = PREV_INSN (head);\n+      if (end == BB_END (merge_bb))\n+\tBB_END (merge_bb) = PREV_INSN (head);\n \n       if (squeeze_notes (&head, &end))\n \treturn TRUE;"}, {"sha": "c8669049a6a722a3e8bb91a929ac76d6c6e9073e", "filename": "gcc/lcm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -1058,8 +1058,8 @@ optimize_mode_switching (FILE *file)\n \n \t  REG_SET_TO_HARD_REG_SET (live_now,\n \t\t\t\t   bb->global_live_at_start);\n-\t  for (insn = bb->head;\n-\t       insn != NULL && insn != NEXT_INSN (bb->end);\n+\t  for (insn = BB_HEAD (bb);\n+\t       insn != NULL && insn != NEXT_INSN (BB_END (bb));\n \t       insn = NEXT_INSN (insn))\n \t    {\n \t      if (INSN_P (insn))\n@@ -1093,7 +1093,7 @@ optimize_mode_switching (FILE *file)\n \t  /* Check for blocks without ANY mode requirements.  */\n \t  if (last_mode == no_mode)\n \t    {\n-\t      ptr = new_seginfo (no_mode, bb->end, bb->index, live_now);\n+\t      ptr = new_seginfo (no_mode, BB_END (bb), bb->index, live_now);\n \t      add_seginfo (info + bb->index, ptr);\n \t    }\n \t}\n@@ -1201,8 +1201,8 @@ optimize_mode_switching (FILE *file)\n \t      if (eg->flags & EDGE_ABNORMAL)\n \t\t{\n \t\t  emited = true;\n-\t\t  if (GET_CODE (src_bb->end) == JUMP_INSN)\n-\t\t    emit_insn_before (mode_set, src_bb->end);\n+\t\t  if (GET_CODE (BB_END (src_bb)) == JUMP_INSN)\n+\t\t    emit_insn_before (mode_set, BB_END (src_bb));\n \t\t  /* It doesn't make sense to switch to normal mode\n \t\t     after a CALL_INSN, so we're going to abort if we\n \t\t     find one.  The cases in which a CALL_INSN may\n@@ -1214,8 +1214,8 @@ optimize_mode_switching (FILE *file)\n \t\t     the call (it wouldn't make sense, anyway).  In\n \t\t     the case of EH edges, EH entry points also start\n \t\t     in normal mode, so a similar reasoning applies.  */\n-\t\t  else if (GET_CODE (src_bb->end) == INSN)\n-\t\t    emit_insn_after (mode_set, src_bb->end);\n+\t\t  else if (GET_CODE (BB_END (src_bb)) == INSN)\n+\t\t    emit_insn_after (mode_set, BB_END (src_bb));\n \t\t  else\n \t\t    abort ();\n \t\t  bb_info[j][src_bb->index].computing = mode;"}, {"sha": "840b126da8039abda7e0dccb5a042b18715f396c", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -809,7 +809,9 @@ update_equiv_regs (void)\n     {\n       loop_depth = bb->loop_depth;\n \n-      for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = NEXT_INSN (insn))\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n \t{\n \t  rtx note;\n \t  rtx set;\n@@ -1023,7 +1025,9 @@ update_equiv_regs (void)\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       loop_depth = bb->loop_depth;\n-      for (insn = bb->end; insn != PREV_INSN (bb->head); insn = PREV_INSN (insn))\n+      for (insn = BB_END (bb);\n+\t   insn != PREV_INSN (BB_HEAD (bb));\n+\t   insn = PREV_INSN (insn))\n \t{\n \t  rtx link;\n \n@@ -1117,8 +1121,8 @@ update_equiv_regs (void)\n \t\t      REG_N_CALLS_CROSSED (regno) = 0;\n \t\t      REG_LIVE_LENGTH (regno) = 2;\n \n-\t\t      if (insn == bb->head)\n-\t\t\tbb->head = PREV_INSN (insn);\n+\t\t      if (insn == BB_HEAD (bb))\n+\t\t\tBB_HEAD (bb) = PREV_INSN (insn);\n \n \t\t      /* Remember to clear REGNO from all basic block's live\n \t\t\t info.  */\n@@ -1204,13 +1208,13 @@ block_alloc (int b)\n \n   /* Count the instructions in the basic block.  */\n \n-  insn = BLOCK_END (b);\n+  insn = BB_END (BASIC_BLOCK (b));\n   while (1)\n     {\n       if (GET_CODE (insn) != NOTE)\n \tif (++insn_count > max_uid)\n \t  abort ();\n-      if (insn == BLOCK_HEAD (b))\n+      if (insn == BB_HEAD (BASIC_BLOCK (b)))\n \tbreak;\n       insn = PREV_INSN (insn);\n     }\n@@ -1227,7 +1231,7 @@ block_alloc (int b)\n      and assigns quantities to registers.\n      It computes which registers to tie.  */\n \n-  insn = BLOCK_HEAD (b);\n+  insn = BB_HEAD (BASIC_BLOCK (b));\n   while (1)\n     {\n       if (GET_CODE (insn) != NOTE)\n@@ -1459,7 +1463,7 @@ block_alloc (int b)\n       IOR_HARD_REG_SET (regs_live_at[2 * insn_number], regs_live);\n       IOR_HARD_REG_SET (regs_live_at[2 * insn_number + 1], regs_live);\n \n-      if (insn == BLOCK_END (b))\n+      if (insn == BB_END (BASIC_BLOCK (b)))\n \tbreak;\n \n       insn = NEXT_INSN (insn);"}, {"sha": "f276b7307a4adcff0affa4eef5de2a371b0e425c", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -126,7 +126,7 @@ may_unswitch_on_p (struct loops *loops, basic_block bb, struct loop *loop,\n   /* BB must end in a simple conditional jump.  */\n   if (!bb->succ || !bb->succ->succ_next || bb->succ->succ_next->succ_next)\n     return false;\n-  if (!any_condjump_p (bb->end))\n+  if (!any_condjump_p (BB_END (bb)))\n     return false;\n \n   /* With branches inside loop.  */\n@@ -141,12 +141,12 @@ may_unswitch_on_p (struct loops *loops, basic_block bb, struct loop *loop,\n \n   /* Condition must be invariant.  We use just a stupid test of invariantness\n      of the condition: all used regs must not be modified inside loop body.  */\n-  test = get_condition (bb->end, NULL, true);\n+  test = get_condition (BB_END (bb), NULL, true);\n   if (!test)\n     return false;\n \n   for (i = 0; i < loop->num_nodes; i++)\n-    if (modified_between_p (test, body[i]->head, NEXT_INSN (body[i]->end)))\n+    if (modified_between_p (test, BB_HEAD (body[i]), NEXT_INSN (BB_END (body[i]))))\n       return false;\n \n   return true;\n@@ -248,7 +248,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n \t  return;\n \t}\n \n-      if (!(cond = get_condition (bbs[i]->end, &split_before, true)))\n+      if (!(cond = get_condition (BB_END (bbs[i]), &split_before, true)))\n \tabort ();\n       rcond = reversed_condition (cond);\n \n@@ -345,7 +345,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on)\n     abort ();\n \n   /* Will we be able to perform redirection?  */\n-  if (!any_condjump_p (unswitch_on->end))\n+  if (!any_condjump_p (BB_END (unswitch_on)))\n     return NULL;\n   if (!cfg_layout_can_duplicate_bb_p (unswitch_on))\n     return NULL;"}, {"sha": "e1e85e83fbb07078984b27f0fcca8323ff8943e5", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -10697,18 +10697,18 @@ loop_dump_aux (const struct loop *loop, FILE *file,\n \n   /* Print diagnostics to compare our concept of a loop with\n      what the loop notes say.  */\n-  if (! PREV_INSN (loop->first->head)\n-      || GET_CODE (PREV_INSN (loop->first->head)) != NOTE\n-      || NOTE_LINE_NUMBER (PREV_INSN (loop->first->head))\n+  if (! PREV_INSN (BB_HEAD (loop->first))\n+      || GET_CODE (PREV_INSN (BB_HEAD (loop->first))) != NOTE\n+      || NOTE_LINE_NUMBER (PREV_INSN (BB_HEAD (loop->first)))\n       != NOTE_INSN_LOOP_BEG)\n     fprintf (file, \";;  No NOTE_INSN_LOOP_BEG at %d\\n\",\n-\t     INSN_UID (PREV_INSN (loop->first->head)));\n-  if (! NEXT_INSN (loop->last->end)\n-      || GET_CODE (NEXT_INSN (loop->last->end)) != NOTE\n-      || NOTE_LINE_NUMBER (NEXT_INSN (loop->last->end))\n+\t     INSN_UID (PREV_INSN (BB_HEAD (loop->first))));\n+  if (! NEXT_INSN (BB_END (loop->last))\n+      || GET_CODE (NEXT_INSN (BB_END (loop->last))) != NOTE\n+      || NOTE_LINE_NUMBER (NEXT_INSN (BB_END (loop->last)))\n       != NOTE_INSN_LOOP_END)\n     fprintf (file, \";;  No NOTE_INSN_LOOP_END at %d\\n\",\n-\t     INSN_UID (NEXT_INSN (loop->last->end)));\n+\t     INSN_UID (NEXT_INSN (BB_END (loop->last))));\n \n   if (loop->start)\n     {"}, {"sha": "835a7218b364514768990e93b6b0922f76dc20ee", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -664,7 +664,7 @@ reload_combine (void)\n \n   FOR_EACH_BB_REVERSE (bb)\n     {\n-      insn = bb->head;\n+      insn = BB_HEAD (bb);\n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  HARD_REG_SET live;"}, {"sha": "71cab30b6056777fa3193f33ff01831ce834c1f7", "filename": "gcc/predict.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -154,9 +154,9 @@ static bool\n predicted_by_p (basic_block bb, enum br_predictor predictor)\n {\n   rtx note;\n-  if (!INSN_P (bb->end))\n+  if (!INSN_P (BB_END (bb)))\n     return false;\n-  for (note = REG_NOTES (bb->end); note; note = XEXP (note, 1))\n+  for (note = REG_NOTES (BB_END (bb)); note; note = XEXP (note, 1))\n     if (REG_NOTE_KIND (note) == REG_BR_PRED\n \t&& INTVAL (XEXP (XEXP (note, 0), 0)) == (int)predictor)\n       return true;\n@@ -199,7 +199,7 @@ void\n predict_edge (edge e, enum br_predictor predictor, int probability)\n {\n   rtx last_insn;\n-  last_insn = e->src->end;\n+  last_insn = BB_END (e->src);\n \n   /* We can store the branch prediction information only about\n      conditional jumps.  */\n@@ -445,7 +445,7 @@ estimate_probability (struct loops *loops_info)\n \t     statements construct loops via \"non-loop\" constructs\n \t     in the source language and are better to be handled\n \t     separately.  */\n-\t  if (!can_predict_insn_p (bb->end)\n+\t  if (!can_predict_insn_p (BB_END (bb))\n \t      || predicted_by_p (bb, PRED_CONTINUE))\n \t    continue;\n \n@@ -476,7 +476,7 @@ estimate_probability (struct loops *loops_info)\n   /* Attempt to predict conditional jumps using a number of heuristics.  */\n   FOR_EACH_BB (bb)\n     {\n-      rtx last_insn = bb->end;\n+      rtx last_insn = BB_END (bb);\n       rtx cond, earliest;\n       edge e;\n \n@@ -509,7 +509,7 @@ estimate_probability (struct loops *loops_info)\n \t\t is improbable.  This is because such calls are often used\n \t\t to signal exceptional situations such as printing error\n \t\t messages.  */\n-\t      for (insn = e->dest->head; insn != NEXT_INSN (e->dest->end);\n+\t      for (insn = BB_HEAD (e->dest); insn != NEXT_INSN (BB_END (e->dest));\n \t\t   insn = NEXT_INSN (insn))\n \t\tif (GET_CODE (insn) == CALL_INSN\n \t\t    /* Constant and pure calls are hardly used to signalize\n@@ -613,10 +613,10 @@ estimate_probability (struct loops *loops_info)\n \n   /* Attach the combined probability to each conditional jump.  */\n   FOR_EACH_BB (bb)\n-    if (GET_CODE (bb->end) == JUMP_INSN\n-\t&& any_condjump_p (bb->end)\n+    if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+\t&& any_condjump_p (BB_END (bb))\n \t&& bb->succ->succ_next != NULL)\n-      combine_predictions_for_insn (bb->end, bb);\n+      combine_predictions_for_insn (BB_END (bb), bb);\n \n   free_dominance_info (post_dominators);\n   free_dominance_info (dominators);\n@@ -765,7 +765,7 @@ process_note_prediction (basic_block bb, int *heads,\n \n   /* Now find the edge that leads to our branch and aply the prediction.  */\n \n-  if (y == last_basic_block || !can_predict_insn_p (BASIC_BLOCK (y)->end))\n+  if (y == last_basic_block || !can_predict_insn_p (BB_END (BASIC_BLOCK (y))))\n     return;\n   for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n     if (e->dest->index >= 0\n@@ -790,8 +790,8 @@ process_note_predictions (basic_block bb, int *heads,\n   int was_bb_head = 0;\n   int noreturn_block = 1;\n \n-  for (insn = bb->end; insn;\n-       was_bb_head |= (insn == bb->head), insn = PREV_INSN (insn))\n+  for (insn = BB_END (bb); insn;\n+       was_bb_head |= (insn == BB_HEAD (bb)), insn = PREV_INSN (insn))\n     {\n       if (GET_CODE (insn) != NOTE)\n \t{\n@@ -1105,7 +1105,7 @@ expensive_function_p (int threshold)\n     {\n       rtx insn;\n \n-      for (insn = bb->head; insn != NEXT_INSN (bb->end);\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n \t   insn = NEXT_INSN (insn))\n \tif (active_insn_p (insn))\n \t  {\n@@ -1149,7 +1149,7 @@ estimate_bb_frequencies (struct loops *loops)\n          notes.  */\n       FOR_EACH_BB (bb)\n \t{\n-\t  rtx last_insn = bb->end;\n+\t  rtx last_insn = BB_END (bb);\n \n \t  if (!can_predict_insn_p (last_insn))\n \t    {"}, {"sha": "5e117e1a1ed0b77499ae68919611d943c6ec433b", "filename": "gcc/profile.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -512,10 +512,10 @@ compute_branch_probabilities (void)\n \t      || (e->count > bb->count\n \t\t  && e->dest != EXIT_BLOCK_PTR))\n \t    {\n-\t      rtx insn = bb->end;\n+\t      rtx insn = BB_END (bb);\n \n \t      while (GET_CODE (insn) != CALL_INSN\n-\t\t     && insn != bb->head\n+\t\t     && insn != BB_HEAD (bb)\n \t\t     && keep_with_call_p (insn))\n \t\tinsn = PREV_INSN (insn);\n \t      if (GET_CODE (insn) == CALL_INSN)\n@@ -534,7 +534,7 @@ compute_branch_probabilities (void)\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    e->probability = (e->count * REG_BR_PROB_BASE + bb->count / 2) / bb->count;\n \t  if (bb->index >= 0\n-\t      && any_condjump_p (bb->end)\n+\t      && any_condjump_p (BB_END (bb))\n \t      && bb->succ->succ_next)\n \t    {\n \t      int prob;\n@@ -554,15 +554,15 @@ compute_branch_probabilities (void)\n \t\tindex = 19;\n \t      hist_br_prob[index]++;\n \n-\t      note = find_reg_note (bb->end, REG_BR_PROB, 0);\n+\t      note = find_reg_note (BB_END (bb), REG_BR_PROB, 0);\n \t      /* There may be already note put by some other pass, such\n \t\t as builtin_expect expander.  */\n \t      if (note)\n \t\tXEXP (note, 0) = GEN_INT (prob);\n \t      else\n-\t\tREG_NOTES (bb->end)\n+\t\tREG_NOTES (BB_END (bb))\n \t\t  = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n-\t\t\t\t       REG_NOTES (bb->end));\n+\t\t\t\t       REG_NOTES (BB_END (bb)));\n \t      num_branches++;\n \t    }\n \t}\n@@ -594,7 +594,7 @@ compute_branch_probabilities (void)\n \t\te->probability = REG_BR_PROB_BASE / total;\n \t    }\n \t  if (bb->index >= 0\n-\t      && any_condjump_p (bb->end)\n+\t      && any_condjump_p (BB_END (bb))\n \t      && bb->succ->succ_next)\n \t    num_branches++, num_never_executed;\n \t}\n@@ -892,7 +892,7 @@ branch_prob (void)\n \n       FOR_EACH_BB (bb)\n \t{\n-\t  rtx insn = bb->head;\n+\t  rtx insn = BB_HEAD (bb);\n \t  int ignore_next_note = 0;\n \n \t  offset = 0;\n@@ -905,7 +905,7 @@ branch_prob (void)\n \t  else\n \t    insn = NEXT_INSN (insn);\n \n-\t  while (insn != bb->end)\n+\t  while (insn != BB_END (bb))\n \t    {\n \t      if (GET_CODE (insn) == NOTE)\n \t\t{"}, {"sha": "a305921c250870f80e55127bbe26b7ce35a2a99d", "filename": "gcc/ra-build.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -884,7 +884,7 @@ live_in_edge (struct df *df, struct curr_use *use, edge e)\n     use->live_over_abnormal = 1;\n   bitmap_set_bit (live_at_end[e->src->index], DF_REF_ID (use->wp->ref));\n   info_pred = (struct ra_bb_info *) e->src->aux;\n-  next_insn = e->src->end;\n+  next_insn = BB_END (e->src);\n \n   /* If the last insn of the pred. block doesn't completely define the\n      current use, we need to check the block.  */\n@@ -899,7 +899,7 @@ live_in_edge (struct df *df, struct curr_use *use, edge e)\n \t     creation to later.  */\n \t  bitmap_set_bit (info_pred->live_throughout,\n \t\t\t  DF_REF_ID (use->wp->ref));\n-\t  next_insn = e->src->head;\n+\t  next_insn = BB_HEAD (e->src);\n \t}\n       return next_insn;\n     }\n@@ -1033,7 +1033,7 @@ livethrough_conflicts_bb (basic_block bb)\n   /* First collect the IDs of all defs, count the number of death\n      containing insns, and if there's some call_insn here.  */\n   all_defs = BITMAP_XMALLOC ();\n-  for (insn = bb->head; insn; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \t{\n@@ -1048,7 +1048,7 @@ livethrough_conflicts_bb (basic_block bb)\n \t  if (GET_CODE (insn) == CALL_INSN)\n \t    contains_call = 1;\n \t}\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n \n@@ -2674,10 +2674,10 @@ detect_webs_set_in_cond_jump (void)\n {\n   basic_block bb;\n   FOR_EACH_BB (bb)\n-    if (GET_CODE (bb->end) == JUMP_INSN)\n+    if (GET_CODE (BB_END (bb)) == JUMP_INSN)\n       {\n \tstruct df_link *link;\n-\tfor (link = DF_INSN_DEFS (df, bb->end); link; link = link->next)\n+\tfor (link = DF_INSN_DEFS (df, BB_END (bb)); link; link = link->next)\n \t  if (link->ref && DF_REF_REGNO (link->ref) >= FIRST_PSEUDO_REGISTER)\n \t    {\n \t      struct web *web = def2web[DF_REF_ID (link->ref)];"}, {"sha": "26aac12df0ed6756479aaa3cf7cb3b11af1551c5", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -528,11 +528,12 @@ ra_debug_bbi (int bbi)\n {\n   basic_block bb = BASIC_BLOCK (bbi);\n   rtx insn;\n-  for (insn = bb->head; insn; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); insn; insn = NEXT_INSN (insn))\n     {\n-      ra_print_rtx_top (stderr, insn, (insn == bb->head || insn == bb->end));\n+      ra_print_rtx_top (stderr, insn,\n+\t\t\t(insn == BB_HEAD (bb) || insn == BB_END (bb)));\n       fprintf (stderr, \"\\n\");\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n }\n@@ -911,7 +912,7 @@ dump_static_insn_cost (FILE *file, const char *message, const char *prefix)\n     {\n       unsigned HOST_WIDE_INT block_cost = bb->frequency;\n       rtx insn, set;\n-      for (insn = bb->head; insn; insn = NEXT_INSN (insn))\n+      for (insn = BB_HEAD (bb); insn; insn = NEXT_INSN (insn))\n \t{\n \t  /* Yes, yes.  We don't calculate the costs precisely.\n \t     Only for \"simple enough\" insns.  Those containing single\n@@ -950,7 +951,7 @@ dump_static_insn_cost (FILE *file, const char *message, const char *prefix)\n \t\t  pcost->count++;\n \t\t}\n \t    }\n-\t  if (insn == bb->end)\n+\t  if (insn == BB_END (bb))\n \t    break;\n \t}\n     }"}, {"sha": "44fde7ddd2f3a389a411a7eaa1812db41b8155f9", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -444,8 +444,8 @@ rewrite_program (bitmap new_deaths)\n \t\tend_sequence ();\n \t\temit_insn_before (insns, insn);\n \n-\t        if (bb->head == insn)\n-\t\t  bb->head = NEXT_INSN (prev);\n+\t        if (BB_HEAD (bb) == insn)\n+\t\t  BB_HEAD (bb) = NEXT_INSN (prev);\n \t\tfor (insn = PREV_INSN (insn); insn != prev;\n \t\t     insn = PREV_INSN (insn))\n \t\t  {\n@@ -492,8 +492,8 @@ rewrite_program (bitmap new_deaths)\n \t      if (insns)\n \t\t{\n \t\t  emit_insn_after (insns, insn);\n-\t\t  if (bb->end == insn)\n-\t\t    bb->end = PREV_INSN (following);\n+\t\t  if (BB_END (bb) == insn)\n+\t\t    BB_END (bb) = PREV_INSN (following);\n \t\t  for (insn = insns; insn != following; insn = NEXT_INSN (insn))\n \t\t    {\n \t\t      set_block_for_insn (insn, bb);\n@@ -685,8 +685,8 @@ insert_stores (bitmap new_deaths)\n \t\t  if (insns)\n \t\t    {\n \t\t      emit_insn_after (insns, insn);\n-\t\t      if (bb->end == insn)\n-\t\t\tbb->end = PREV_INSN (following);\n+\t\t      if (BB_END (bb) == insn)\n+\t\t\tBB_END (bb) = PREV_INSN (following);\n \t\t      for (ni = insns; ni != following; ni = NEXT_INSN (ni))\n \t\t\t{\n \t\t\t  set_block_for_insn (ni, bb);\n@@ -941,8 +941,8 @@ emit_loads (struct rewrite_info *ri, int nl_first_reload, rtx last_block_insn)\n \t  rtx foll = NEXT_INSN (after);\n \t  bb = BLOCK_FOR_INSN (after);\n \t  emit_insn_after (ni, after);\n-\t  if (bb->end == after)\n-\t    bb->end = PREV_INSN (foll);\n+\t  if (BB_END (bb) == after)\n+\t    BB_END (bb) = PREV_INSN (foll);\n \t  for (ni = NEXT_INSN (after); ni != foll; ni = NEXT_INSN (ni))\n \t    {\n \t      set_block_for_insn (ni, bb);\n@@ -954,8 +954,8 @@ emit_loads (struct rewrite_info *ri, int nl_first_reload, rtx last_block_insn)\n \t  rtx prev = PREV_INSN (before);\n \t  bb = BLOCK_FOR_INSN (before);\n \t  emit_insn_before (ni, before);\n-\t  if (bb->head == before)\n-\t    bb->head = NEXT_INSN (prev);\n+\t  if (BB_HEAD (bb) == before)\n+\t    BB_HEAD (bb) = NEXT_INSN (prev);\n \t  for (; ni != before; ni = NEXT_INSN (ni))\n \t    {\n \t      set_block_for_insn (ni, bb);"}, {"sha": "2d4ebe3f520c01686270172dee54df3493b2d476", "filename": "gcc/ra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -665,7 +665,7 @@ reg_alloc (void)\n       for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n \t{\n \t  basic_block bb = e->src;\n-\t  last = bb->end;\n+\t  last = BB_END (bb);\n \t  if (!INSN_P (last) || GET_CODE (PATTERN (last)) != USE)\n \t    {\n \t      rtx insns;"}, {"sha": "7df8d3300fe01c50ed30e499c0285cf85d2cb4fb", "filename": "gcc/recog.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -2696,12 +2696,12 @@ split_all_insns (int upd_life)\n       rtx insn, next;\n       bool finish = false;\n \n-      for (insn = bb->head; !finish ; insn = next)\n+      for (insn = BB_HEAD (bb); !finish ; insn = next)\n \t{\n \t  /* Can't use `next_real_insn' because that might go across\n \t     CODE_LABELS and short-out basic blocks.  */\n \t  next = NEXT_INSN (insn);\n-\t  finish = (insn == bb->end);\n+\t  finish = (insn == BB_END (bb));\n \t  if (INSN_P (insn))\n \t    {\n \t      rtx set = single_set (insn);\n@@ -3042,7 +3042,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n       pbi = init_propagate_block_info (bb, live, NULL, NULL, PROP_DEATH_NOTES);\n #endif\n \n-      for (insn = bb->end; ; insn = prev)\n+      for (insn = BB_END (bb); ; insn = prev)\n \t{\n \t  prev = PREV_INSN (insn);\n \t  if (INSN_P (insn))\n@@ -3158,7 +3158,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t\t\t\t\t     XEXP (note, 0),\n \t\t\t\t\t\t     REG_NOTES (x));\n \n-\t\t\t    if (x != bb->end && eh_edge)\n+\t\t\t    if (x != BB_END (bb) && eh_edge)\n \t\t\t      {\n \t\t\t\tedge nfte, nehe;\n \t\t\t\tint flags;\n@@ -3242,7 +3242,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t}\n \t    }\n \n-\t  if (insn == bb->head)\n+\t  if (insn == BB_HEAD (bb))\n \t    break;\n \t}\n "}, {"sha": "228723b8ac5674a77e2f53917e0b87b5e59e5567", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -336,7 +336,7 @@ next_flags_user (rtx insn)\n   /* Search forward looking for the first use of this value.\n      Stop at block boundaries.  */\n \n-  while (insn != current_block->end)\n+  while (insn != BB_END (current_block))\n     {\n       insn = NEXT_INSN (insn);\n \n@@ -973,10 +973,10 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n   /* Find the previous insn involving stack regs, but don't pass a\n      block boundary.  */\n   i1 = NULL;\n-  if (current_block && insn != current_block->head)\n+  if (current_block && insn != BB_HEAD (current_block))\n     {\n       rtx tmp = PREV_INSN (insn);\n-      rtx limit = PREV_INSN (current_block->head);\n+      rtx limit = PREV_INSN (BB_HEAD (current_block));\n       while (tmp != limit)\n \t{\n \t  if (GET_CODE (tmp) == CODE_LABEL\n@@ -1022,7 +1022,7 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n   if (i1)\n     emit_insn_after (swap_rtx, i1);\n   else if (current_block)\n-    emit_insn_before (swap_rtx, current_block->head);\n+    emit_insn_before (swap_rtx, BB_HEAD (current_block));\n   else\n     emit_insn_before (swap_rtx, insn);\n }\n@@ -1232,7 +1232,7 @@ swap_rtx_condition (rtx insn)\n \n       /* Search forward looking for the first use of this value.\n \t Stop at block boundaries.  */\n-      while (insn != current_block->end)\n+      while (insn != BB_END (current_block))\n \t{\n \t  insn = NEXT_INSN (insn);\n \t  if (INSN_P (insn) && reg_mentioned_p (dest, insn))\n@@ -2292,7 +2292,7 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \n   if (where == EMIT_AFTER)\n     {\n-      if (current_block && current_block->end == insn)\n+      if (current_block && BB_END (current_block) == insn)\n \tupdate_end = 1;\n       insn = NEXT_INSN (insn);\n     }\n@@ -2375,7 +2375,7 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n     }\n \n   if (update_end)\n-    current_block->end = PREV_INSN (insn);\n+    BB_END (current_block) = PREV_INSN (insn);\n }\n \f\n /* Print stack configuration.  */\n@@ -2536,7 +2536,7 @@ compensate_edge (edge e, FILE *file)\n \t  /* change_stack kills values in regstack.  */\n \t  tmpstack = regstack;\n \n-\t  change_stack (block->end, &tmpstack, target_stack, EMIT_AFTER);\n+\t  change_stack (BB_END (block), &tmpstack, target_stack, EMIT_AFTER);\n \t  return false;\n \t}\n \n@@ -2607,8 +2607,8 @@ compensate_edge (edge e, FILE *file)\n       /* change_stack kills values in regstack.  */\n       tmpstack = regstack;\n \n-      change_stack (block->end, &tmpstack, target_stack,\n-\t\t    (GET_CODE (block->end) == JUMP_INSN\n+      change_stack (BB_END (block), &tmpstack, target_stack,\n+\t\t    (GET_CODE (BB_END (block)) == JUMP_INSN\n \t\t     ? EMIT_BEFORE : EMIT_AFTER));\n     }\n   else\n@@ -2714,7 +2714,7 @@ convert_regs_1 (FILE *file, basic_block block)\n \n   /* Process all insns in this block.  Keep track of NEXT so that we\n      don't process insns emitted while substituting in INSN.  */\n-  next = block->head;\n+  next = BB_HEAD (block);\n   regstack = bi->stack_in;\n   do\n     {\n@@ -2724,7 +2724,7 @@ convert_regs_1 (FILE *file, basic_block block)\n       /* Ensure we have not missed a block boundary.  */\n       if (next == NULL)\n \tabort ();\n-      if (insn == block->end)\n+      if (insn == BB_END (block))\n \tnext = NULL;\n \n       /* Don't bother processing unless there is a stack reg\n@@ -2753,7 +2753,7 @@ convert_regs_1 (FILE *file, basic_block block)\n       print_stack (file, &regstack);\n     }\n \n-  insn = block->end;\n+  insn = BB_END (block);\n   if (GET_CODE (insn) == JUMP_INSN)\n     insn = PREV_INSN (insn);\n "}, {"sha": "021c119b2b1b832c644c2c502ad037be80abcc3c", "filename": "gcc/regclass.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -1085,8 +1085,8 @@ scan_one_insn (rtx insn, int pass)\n \t{\n \t  basic_block b;\n \t  FOR_EACH_BB (b)\n-\t    if (insn == b->head)\n-\t      b->head = newinsn;\n+\t    if (insn == BB_HEAD (b))\n+\t      BB_HEAD (b) = newinsn;\n \t}\n \n       /* This makes one more setting of new insns's dest.  */\n@@ -1240,10 +1240,10 @@ regclass (rtx f, int nregs, FILE *dump)\n \t       aggressive than the assumptions made elsewhere and is being\n \t       tried as an experiment.  */\n \t    frequency = REG_FREQ_FROM_BB (bb);\n-\t    for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+\t    for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n \t      {\n \t\tinsn = scan_one_insn (insn, pass);\n-\t\tif (insn == bb->end)\n+\t\tif (insn == BB_END (bb))\n \t\t  break;\n \t      }\n \t  }"}, {"sha": "c6c30d1070686eaf3b4f18b6a0acdb559d18dc33", "filename": "gcc/regmove.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -256,8 +256,8 @@ mark_flags_life_zones (rtx flags)\n       rtx insn, end;\n       int live;\n \n-      insn = block->head;\n-      end = block->end;\n+      insn = BB_HEAD (block);\n+      end = BB_END (block);\n \n       /* Look out for the (unlikely) case of flags being live across\n \t basic block boundaries.  */\n@@ -810,7 +810,7 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n \t  bb = regmove_bb_head[insn_uid];\n \t  if (bb >= 0)\n \t    {\n-\t      BLOCK_HEAD (bb) = move_insn;\n+\t      BB_HEAD (BASIC_BLOCK (bb)) = move_insn;\n \t      regmove_bb_head[insn_uid] = -1;\n \t    }\n \t}\n@@ -1061,7 +1061,7 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n   regmove_bb_head = xmalloc (sizeof (int) * (old_max_uid + 1));\n   for (i = old_max_uid; i >= 0; i--) regmove_bb_head[i] = -1;\n   FOR_EACH_BB (bb)\n-    regmove_bb_head[INSN_UID (bb->head)] = bb->index;\n+    regmove_bb_head[INSN_UID (BB_HEAD (bb))] = bb->index;\n \n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n@@ -1491,13 +1491,13 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n      ends.  Fix that here.  */\n   FOR_EACH_BB (bb)\n     {\n-      rtx end = bb->end;\n+      rtx end = BB_END (bb);\n       rtx new = end;\n       rtx next = NEXT_INSN (new);\n       while (next != 0 && INSN_UID (next) >= old_max_uid\n-\t     && (bb->next_bb == EXIT_BLOCK_PTR || bb->next_bb->head != next))\n+\t     && (bb->next_bb == EXIT_BLOCK_PTR || BB_HEAD (bb->next_bb) != next))\n \tnew = next, next = NEXT_INSN (new);\n-      bb->end = new;\n+      BB_END (bb) = new;\n     }\n \n  done:\n@@ -2304,9 +2304,9 @@ combine_stack_adjustments_for_block (basic_block bb)\n   struct record_stack_memrefs_data data;\n   bool end_of_block = false;\n \n-  for (insn = bb->head; !end_of_block ; insn = next)\n+  for (insn = BB_HEAD (bb); !end_of_block ; insn = next)\n     {\n-      end_of_block = insn == bb->end;\n+      end_of_block = insn == BB_END (bb);\n       next = NEXT_INSN (insn);\n \n       if (! INSN_P (insn))"}, {"sha": "56f6a8842b62ddda8fe9729bb8bd3715a357e73b", "filename": "gcc/regrename.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -149,7 +149,7 @@ merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n   HARD_REG_SET live;\n \n   REG_SET_TO_HARD_REG_SET (live, b->global_live_at_start);\n-  insn = b->head;\n+  insn = BB_HEAD (b);\n   while (t)\n     {\n       /* Search forward until the next reference to the register to be\n@@ -729,7 +729,7 @@ build_def_use (basic_block bb)\n \n   open_chains = closed_chains = NULL;\n \n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n \t{\n@@ -954,7 +954,7 @@ build_def_use (basic_block bb)\n \t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n \t\t\tOP_IN, 0);\n \t}\n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n \n@@ -1525,15 +1525,15 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n   bool changed = false;\n   rtx insn;\n \n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       int n_ops, i, alt, predicated;\n       bool is_asm;\n       rtx set;\n \n       if (! INSN_P (insn))\n \t{\n-\t  if (insn == bb->end)\n+\t  if (insn == BB_END (bb))\n \t    break;\n \t  else\n \t    continue;\n@@ -1709,7 +1709,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       if (set && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set)))\n \tcopy_value (SET_DEST (set), SET_SRC (set), vd);\n \n-      if (insn == bb->end)\n+      if (insn == BB_END (bb))\n \tbreak;\n     }\n "}, {"sha": "c6fd61ed78932eaa02c2b57bf7a253c7907dc6f4", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -7963,9 +7963,10 @@ fixup_abnormal_edges (void)\n \t      == (EDGE_ABNORMAL | EDGE_EH))\n \t    break;\n \t}\n-      if (e && GET_CODE (bb->end) != CALL_INSN && !can_throw_internal (bb->end))\n+      if (e && GET_CODE (BB_END (bb)) != CALL_INSN\n+\t  && !can_throw_internal (BB_END (bb)))\n \t{\n-\t  rtx insn = bb->end, stop = NEXT_INSN (bb->end);\n+\t  rtx insn = BB_END (bb), stop = NEXT_INSN (BB_END (bb));\n \t  rtx next;\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    if (e->flags & EDGE_FALLTHRU)\n@@ -7974,11 +7975,11 @@ fixup_abnormal_edges (void)\n \t     be already deleted.  */\n \t  while ((GET_CODE (insn) == INSN || GET_CODE (insn) == NOTE)\n \t\t && !can_throw_internal (insn)\n-\t\t && insn != bb->head)\n+\t\t && insn != BB_HEAD (bb))\n \t    insn = PREV_INSN (insn);\n \t  if (GET_CODE (insn) != CALL_INSN && !can_throw_internal (insn))\n \t    abort ();\n-\t  bb->end = insn;\n+\t  BB_END (bb) = insn;\n \t  inserted = true;\n \t  insn = NEXT_INSN (insn);\n \t  while (insn && insn != stop)"}, {"sha": "620ee4651cac56b55bd481e828b2963a47c6407a", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -155,7 +155,7 @@ find_basic_block (rtx insn, int search_limit)\n        insn = next_nonnote_insn (insn))\n     {\n       FOR_EACH_BB (bb)\n-\tif (insn == bb->head)\n+\tif (insn == BB_HEAD (bb))\n \t  return bb->index;\n     }\n \n@@ -913,7 +913,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t information, we can get it from there unless the insn at the\n \t start of the basic block has been deleted.  */\n       if (tinfo && tinfo->block != -1\n-\t  && ! INSN_DELETED_P (BLOCK_HEAD (tinfo->block)))\n+\t  && ! INSN_DELETED_P (BB_HEAD (BASIC_BLOCK (tinfo->block))))\n \tb = tinfo->block;\n     }\n \n@@ -979,7 +979,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \n       /* Get starting and ending insn, handling the case where each might\n \t be a SEQUENCE.  */\n-      start_insn = (b == 0 ? insns : BLOCK_HEAD (b));\n+      start_insn = (b == 0 ? insns : BB_HEAD (BASIC_BLOCK (b)));\n       stop_insn = target;\n \n       if (GET_CODE (start_insn) == INSN"}, {"sha": "2d4f125e62f2741631aeab426eaf69839eebe4f5", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -218,8 +218,8 @@ add_missing_bbs (rtx before, basic_block first, basic_block last)\n     {\n       before = emit_note_before (NOTE_INSN_BASIC_BLOCK, before);\n       NOTE_BASIC_BLOCK (before) = last;\n-      last->head = before;\n-      last->end = before;\n+      BB_HEAD (last) = before;\n+      BB_END (last) = before;\n       update_bb_for_insn (last);\n     }\n }\n@@ -233,10 +233,10 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t\t\t    rtx tail)\n {\n   rtx insn = head;\n-  rtx last_inside = bb->head;\n+  rtx last_inside = BB_HEAD (bb);\n   rtx aftertail = NEXT_INSN (tail);\n \n-  head = bb->head;\n+  head = BB_HEAD (bb);\n \n   for (; insn != aftertail; insn = NEXT_INSN (insn))\n     {\n@@ -299,9 +299,9 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t      if (f)\n \t\t{\n \t\t  last = curr_bb = split_edge (f);\n-\t\t  h = curr_bb->head;\n-\t\t  curr_bb->head = head;\n-\t\t  curr_bb->end = insn;\n+\t\t  h = BB_HEAD (curr_bb);\n+\t\t  BB_HEAD (curr_bb) = head;\n+\t\t  BB_END (curr_bb) = insn;\n \t\t  /* Edge splitting created misplaced BASIC_BLOCK note, kill\n \t\t     it.  */\n \t\t  delete_insn (h);\n@@ -324,9 +324,9 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t    }\n \t  else\n \t    {\n-\t      curr_bb->head = head;\n-\t      curr_bb->end = insn;\n-\t      add_missing_bbs (curr_bb->head, bb, curr_bb->prev_bb);\n+\t      BB_HEAD (curr_bb) = head;\n+\t      BB_END (curr_bb) = insn;\n+\t      add_missing_bbs (BB_HEAD (curr_bb), bb, curr_bb->prev_bb);\n \t    }\n \t  note = GET_CODE (head) == CODE_LABEL ? NEXT_INSN (head) : head;\n \t  NOTE_BASIC_BLOCK (note) = curr_bb;\n@@ -337,7 +337,7 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t     break;\n \t}\n     }\n-  add_missing_bbs (last->next_bb->head, bb, last);\n+  add_missing_bbs (BB_HEAD (last->next_bb), bb, last);\n   return bb->prev_bb;\n }\n \n@@ -442,7 +442,7 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n \t\t    bb = bb->aux;\n \t\t    if (!bb)\n \t\t      break;\n-\t\t    prev = bb->end;\n+\t\t    prev = BB_END (bb);\n \t\t  }\n \t      }\n \t    /* FALLTHRU */\n@@ -585,15 +585,15 @@ schedule_ebbs (FILE *dump_file)\n   /* Schedule every region in the subroutine.  */\n   FOR_EACH_BB (bb)\n     {\n-      rtx head = bb->head;\n+      rtx head = BB_HEAD (bb);\n       rtx tail;\n \n       for (;;)\n \t{\n \t  edge e;\n-\t  tail = bb->end;\n+\t  tail = BB_END (bb);\n \t  if (bb->next_bb == EXIT_BLOCK_PTR\n-\t      || GET_CODE (bb->next_bb->head) == CODE_LABEL)\n+\t      || GET_CODE (BB_HEAD (bb->next_bb)) == CODE_LABEL)\n \t    break;\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    if ((e->flags & EDGE_FALLTHRU) != 0)"}, {"sha": "138bab36b9604278c9e236894d657681b5e0e19c", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -343,7 +343,7 @@ is_cfg_nonregular (void)\n      the cfg not well structured.  */\n   /* Check for labels referred to other thn by jumps.  */\n   FOR_EACH_BB (b)\n-    for (insn = b->head;; insn = NEXT_INSN (insn))\n+    for (insn = BB_HEAD (b); ; insn = NEXT_INSN (insn))\n       {\n \tcode = GET_CODE (insn);\n \tif (GET_RTX_CLASS (code) == 'i' && code != JUMP_INSN)\n@@ -357,7 +357,7 @@ is_cfg_nonregular (void)\n \t      return 1;\n \t  }\n \n-\tif (insn == b->end)\n+\tif (insn == BB_END (b))\n \t  break;\n       }\n \n@@ -558,8 +558,8 @@ static int\n too_large (int block, int *num_bbs, int *num_insns)\n {\n   (*num_bbs)++;\n-  (*num_insns) += (INSN_LUID (BLOCK_END (block)) -\n-\t\t   INSN_LUID (BLOCK_HEAD (block)));\n+  (*num_insns) += (INSN_LUID (BB_END (BASIC_BLOCK (block))) -\n+\t\t   INSN_LUID (BB_HEAD (BASIC_BLOCK (block))));\n   if ((*num_bbs > MAX_RGN_BLOCKS) || (*num_insns > MAX_RGN_INSNS))\n     return 1;\n   else\n@@ -852,8 +852,8 @@ find_rgns (struct edge_list *edge_list, dominance_info dom)\n \n \t      /* Estimate # insns, and count # blocks in the region.  */\n \t      num_bbs = 1;\n-\t      num_insns = (INSN_LUID (bb->end)\n-\t\t\t   - INSN_LUID (bb->head));\n+\t      num_insns = (INSN_LUID (BB_END (bb))\n+\t\t\t   - INSN_LUID (BB_HEAD (bb)));\n \n \t      /* Find all loop latches (blocks with back edges to the loop\n \t\t header) or all the leaf blocks in the cfg has no loops.\n@@ -1839,28 +1839,28 @@ can_schedule_ready_p (rtx insn)\n \n       /* Update source block boundaries.  */\n       b1 = BLOCK_FOR_INSN (insn);\n-      if (insn == b1->head && insn == b1->end)\n+      if (insn == BB_HEAD (b1) && insn == BB_END (b1))\n \t{\n \t  /* We moved all the insns in the basic block.\n \t     Emit a note after the last insn and update the\n \t     begin/end boundaries to point to the note.  */\n \t  rtx note = emit_note_after (NOTE_INSN_DELETED, insn);\n-\t  b1->head = note;\n-\t  b1->end = note;\n+\t  BB_HEAD (b1) = note;\n+\t  BB_END (b1) = note;\n \t}\n-      else if (insn == b1->end)\n+      else if (insn == BB_END (b1))\n \t{\n \t  /* We took insns from the end of the basic block,\n \t     so update the end of block boundary so that it\n \t     points to the first insn we did not move.  */\n-\t  b1->end = PREV_INSN (insn);\n+\t  BB_END (b1) = PREV_INSN (insn);\n \t}\n-      else if (insn == b1->head)\n+      else if (insn == BB_HEAD (b1))\n \t{\n \t  /* We took insns from the start of the basic block,\n \t     so update the start of block boundary so that\n \t     it points to the first insn we did not move.  */\n-\t  b1->head = NEXT_INSN (insn);\n+\t  BB_HEAD (b1) = NEXT_INSN (insn);\n \t}\n     }\n   else\n@@ -2516,10 +2516,10 @@ schedule_region (int rgn)\n       sched_rgn_n_insns += sched_n_insns;\n \n       /* Update target block boundaries.  */\n-      if (head == BLOCK_HEAD (b))\n-\tBLOCK_HEAD (b) = current_sched_info->head;\n-      if (tail == BLOCK_END (b))\n-\tBLOCK_END (b) = current_sched_info->tail;\n+      if (head == BB_HEAD (BASIC_BLOCK (b)))\n+\tBB_HEAD (BASIC_BLOCK (b)) = current_sched_info->head;\n+      if (tail == BB_END (BASIC_BLOCK (b)))\n+\tBB_END (BASIC_BLOCK (b)) = current_sched_info->tail;\n \n       /* Clean up.  */\n       if (current_nr_blocks > 1)"}, {"sha": "81509ee9b56e4eea530fbc5d08302b77ba9aa94c", "filename": "gcc/sibcall.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -597,7 +597,7 @@ optimize_sibling_and_tail_recursive_calls (void)\n \n       /* Walk forwards through the last normal block and see if it\n \t does nothing except fall into the exit block.  */\n-      for (insn = EXIT_BLOCK_PTR->prev_bb->head;\n+      for (insn = BB_HEAD (EXIT_BLOCK_PTR->prev_bb);\n \t   insn;\n \t   insn = NEXT_INSN (insn))\n \t{\n@@ -685,7 +685,7 @@ optimize_sibling_and_tail_recursive_calls (void)\n \t\t  && call_block->succ->dest != alternate_exit)\n \t      /* If this call doesn't end the block, there are operations at\n \t\t the end of the block which we must execute after returning.  */\n-\t      || ! call_ends_block_p (insn, call_block->end))\n+\t      || ! call_ends_block_p (insn, BB_END (call_block)))\n \t    sibcall = 0, tailrecursion = 0;\n \n \t  /* Select a set of insns to implement the call and emit them."}, {"sha": "68b3f6697c261442487c9f5d5472c7ac896a2ee8", "filename": "gcc/tracer.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a813c111200f19a0512441f5394395ee3f6770ae/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=a813c111200f19a0512441f5394395ee3f6770ae", "patch": "@@ -85,7 +85,9 @@ count_insns (basic_block bb)\n   rtx insn;\n   int n = 0;\n \n-  for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = NEXT_INSN (insn))\n+  for (insn = BB_HEAD (bb);\n+       insn != NEXT_INSN (BB_END (bb));\n+       insn = NEXT_INSN (insn))\n     if (active_insn_p (insn))\n       n++;\n   return n;"}]}