{"sha": "e44deb433b5c4eac6caeae284e9eebbb3760531c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ0ZGViNDMzYjVjNGVhYzZjYWVhZTI4NGU5ZWViYmIzNzYwNTMxYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-12-13T15:41:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-12-13T15:41:55Z"}, "message": "Fix merging of common traget info.\n\n\t* ipa-utils.c (ipa_merge_profiles): Improve dumping; merge common\n\ttargets.\n\nFrom-SVN: r279373", "tree": {"sha": "24cbca925e1991f39bab08e5e855aa4635e1878c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24cbca925e1991f39bab08e5e855aa4635e1878c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e44deb433b5c4eac6caeae284e9eebbb3760531c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e44deb433b5c4eac6caeae284e9eebbb3760531c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e44deb433b5c4eac6caeae284e9eebbb3760531c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e44deb433b5c4eac6caeae284e9eebbb3760531c/comments", "author": null, "committer": null, "parents": [{"sha": "3d66c777195cdefd1397a1a77a5396d914881494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d66c777195cdefd1397a1a77a5396d914881494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d66c777195cdefd1397a1a77a5396d914881494"}], "stats": {"total": 184, "additions": 151, "deletions": 33}, "files": [{"sha": "c40d936e6cbb14e9d16f06e42362ac7782dee36c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e44deb433b5c4eac6caeae284e9eebbb3760531c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e44deb433b5c4eac6caeae284e9eebbb3760531c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e44deb433b5c4eac6caeae284e9eebbb3760531c", "patch": "@@ -1,3 +1,8 @@\n+2019-12-13  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.c (ipa_merge_profiles): Improve dumping; merge common\n+\ttargets.\n+\n 2019-12-13  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn-valu.md (sdwa): New mode attribute."}, {"sha": "cc65e2a7a00becfa3d2b599ea20403903d5debad", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 146, "deletions": 33, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e44deb433b5c4eac6caeae284e9eebbb3760531c/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e44deb433b5c4eac6caeae284e9eebbb3760531c/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=e44deb433b5c4eac6caeae284e9eebbb3760531c", "patch": "@@ -423,11 +423,6 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (!src->count.initialized_p ()\n       || !(src->count.ipa () == src->count))\n     return;\n-  if (symtab->dump_file)\n-    {\n-      fprintf (symtab->dump_file, \"Merging profiles of %s to %s\\n\",\n-\t       src->dump_name (), dst->dump_name ());\n-    }\n   profile_count orig_count = dst->count;\n \n   /* Either sum the profiles if both are IPA and not global0, or\n@@ -451,6 +446,19 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (dst->count == orig_count)\n     return;\n \n+  if (symtab->dump_file)\n+    {\n+      fprintf (symtab->dump_file, \"Merging profiles of %s count:\",\n+\t       src->dump_name ());\n+      src->count.dump (symtab->dump_file);\n+      fprintf (symtab->dump_file, \" to %s count:\",\n+\t       dst->dump_name ());\n+      orig_count.dump (symtab->dump_file);\n+      fprintf (symtab->dump_file, \" resulting count:\");\n+      dst->count.dump (symtab->dump_file);\n+      fprintf (symtab->dump_file, \"\\n\");\n+    }\n+\n   /* First handle functions with no gimple body.  */\n   if (dst->thunk.thunk_p || dst->alias\n       || src->thunk.thunk_p || src->alias)\n@@ -516,45 +524,86 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   else \n     {\n       basic_block srcbb, dstbb;\n+      struct cgraph_edge *e, *e2;\n \n-      FOR_ALL_BB_FN (srcbb, srccfun)\n+      for (e = dst->callees, e2 = src->callees; e && e2 && match;\n+\t   e2 = e2->next_callee, e = e->next_callee)\n \t{\n-\t  unsigned int i;\n-\n-\t  dstbb = BASIC_BLOCK_FOR_FN (dstcfun, srcbb->index);\n-\t  if (dstbb == NULL)\n+\t  if (gimple_bb (e->call_stmt)->index\n+\t      != gimple_bb (e2->call_stmt)->index)\n \t    {\n \t      if (symtab->dump_file)\n \t\tfprintf (symtab->dump_file,\n-\t\t\t \"No matching block for bb %i.\\n\",\n-\t\t\t srcbb->index);\n+\t\t\t \"Giving up; call stmt mismatch.\\n\");\n \t      match = false;\n-\t      break;\n \t    }\n-\t  if (EDGE_COUNT (srcbb->succs) != EDGE_COUNT (dstbb->succs))\n+\t}\n+      if (e || e2)\n+\t{\n+\t  if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file,\n+\t\t     \"Giving up; number of calls differs.\\n\");\n+\t  match = false;\n+\t}\n+      for (e = dst->indirect_calls, e2 = src->indirect_calls; e && e2 && match;\n+\t   e2 = e2->next_callee, e = e->next_callee)\n+\t{\n+\t  if (gimple_bb (e->call_stmt)->index\n+\t      != gimple_bb (e2->call_stmt)->index)\n \t    {\n \t      if (symtab->dump_file)\n \t\tfprintf (symtab->dump_file,\n-\t\t\t \"Edge count mismatch for bb %i.\\n\",\n-\t\t\t srcbb->index);\n+\t\t\t \"Giving up; indirect call stmt mismatch.\\n\");\n \t      match = false;\n-\t      break;\n-\t    }\n-\t  for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n-\t    {\n-\t      edge srce = EDGE_SUCC (srcbb, i);\n-\t      edge dste = EDGE_SUCC (dstbb, i);\n-\t      if (srce->dest->index != dste->dest->index)\n-\t\t{\n-\t\t  if (symtab->dump_file)\n-\t\t    fprintf (symtab->dump_file,\n-\t\t\t     \"Succ edge mismatch for bb %i.\\n\",\n-\t\t\t     srce->dest->index);\n-\t\t  match = false;\n-\t\t  break;\n-\t\t}\n \t    }\n \t}\n+      if (e || e2)\n+\t{\n+\t  if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file,\n+\t\t     \"Giving up; number of indirect calls differs.\\n\");\n+\t  match=false;\n+\t}\n+\n+      if (match)\n+\tFOR_ALL_BB_FN (srcbb, srccfun)\n+\t  {\n+\t    unsigned int i;\n+\n+\t    dstbb = BASIC_BLOCK_FOR_FN (dstcfun, srcbb->index);\n+\t    if (dstbb == NULL)\n+\t      {\n+\t\tif (symtab->dump_file)\n+\t\t  fprintf (symtab->dump_file,\n+\t\t\t   \"No matching block for bb %i.\\n\",\n+\t\t\t   srcbb->index);\n+\t\tmatch = false;\n+\t\tbreak;\n+\t      }\n+\t    if (EDGE_COUNT (srcbb->succs) != EDGE_COUNT (dstbb->succs))\n+\t      {\n+\t\tif (symtab->dump_file)\n+\t\t  fprintf (symtab->dump_file,\n+\t\t\t   \"Edge count mismatch for bb %i.\\n\",\n+\t\t\t   srcbb->index);\n+\t\tmatch = false;\n+\t\tbreak;\n+\t      }\n+\t    for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n+\t      {\n+\t\tedge srce = EDGE_SUCC (srcbb, i);\n+\t\tedge dste = EDGE_SUCC (dstbb, i);\n+\t\tif (srce->dest->index != dste->dest->index)\n+\t\t  {\n+\t\t    if (symtab->dump_file)\n+\t\t      fprintf (symtab->dump_file,\n+\t\t\t       \"Succ edge mismatch for bb %i.\\n\",\n+\t\t\t       srce->dest->index);\n+\t\t    match = false;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n     }\n   if (match)\n     {\n@@ -626,6 +675,70 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t   e2 = (e2 ? e2->next_callee : NULL), e = e->next_callee)\n \t{\n \t  profile_count count = gimple_bb (e->call_stmt)->count;\n+\t  if (copy_counts)\n+\t    {\n+\t      e->indirect_info->common_target_id\n+\t\t      = e2->indirect_info->common_target_id;\n+\t      e->indirect_info->common_target_probability\n+\t\t      = e2->indirect_info->common_target_probability;\n+\t    }\n+\t  else if (e->indirect_info->common_target_id\n+\t\t   || e2->indirect_info->common_target_id)\n+\t    {\n+\t      sreal scale1\n+\t\t = e->count.ipa().to_sreal_scale (count);\n+\t      sreal scale2\n+\t\t = e2->count.ipa().to_sreal_scale (count);\n+\n+\t      if (scale1 == 0 && scale2 == 0)\n+\t\tscale1 = scale2 = 1;\n+\t      sreal sum = scale1 + scale2;\n+\t      int scaled_probability1\n+\t\t      = ((sreal)e->indirect_info->common_target_probability\n+\t\t\t* scale1 / sum).to_int ();\n+\t      int scaled_probability2\n+\t\t      = ((sreal)e2->indirect_info->common_target_probability\n+\t\t\t * scale2 / sum).to_int ();\n+\t      if (symtab->dump_file)\n+\t\t{\n+\t\t  fprintf (symtab->dump_file,\n+\t\t\t   \"Merging common targets %i prob %i\"\n+\t\t\t   \" and %i prob %i with scales %f %f\\n\",\n+\t\t\t   e->indirect_info->common_target_id,\n+\t\t\t   e->indirect_info->common_target_probability,\n+\t\t\t   e2->indirect_info->common_target_id,\n+\t\t\t   e2->indirect_info->common_target_probability,\n+\t\t\t   scale1.to_double (),\n+\t\t\t   scale2.to_double ());\n+\t\t  fprintf (symtab->dump_file, \"Combined BB count \");\n+\t\t  count.dump (symtab->dump_file);\n+\t\t  fprintf (symtab->dump_file, \" dst edge count \");\n+\t\t  e->count.dump (symtab->dump_file);\n+\t\t  fprintf (symtab->dump_file, \" src edge count \");\n+\t\t  e2->count.dump (symtab->dump_file);\n+\t\t  fprintf (symtab->dump_file, \"\\n\");\n+\t\t}\n+\t      if (e->indirect_info->common_target_id\n+\t\t  == e2->indirect_info->common_target_id)\n+\t\te->indirect_info->common_target_probability\n+\t\t       \t= scaled_probability1 + scaled_probability2;\n+\t      else if (!e2->indirect_info->common_target_id\n+\t\t       || scaled_probability1 > scaled_probability2)\n+\t\te->indirect_info->common_target_probability\n+\t\t       \t= scaled_probability1;\n+\t      else \n+\t\t{\n+\t\t  e->indirect_info->common_target_id\n+\t\t\t  = e2->indirect_info->common_target_id;\n+\t\t  e->indirect_info->common_target_probability\n+\t\t\t  = scaled_probability2;\n+\t\t}\n+\t      if (symtab->dump_file)\n+\t\tfprintf (symtab->dump_file, \"Merged as %i prob %i\\n\",\n+\t\t\t e->indirect_info->common_target_id,\n+\t\t\t e->indirect_info->common_target_probability);\n+\t    }\n+\n \t  /* When call is speculative, we need to re-distribute probabilities\n \t     the same way as they was.  This is not really correct because\n \t     in the other copy the speculation may differ; but probably it\n@@ -647,8 +760,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t\t     indirect edge.  */\n \t\t  if (!e2)\n \t\t    {\n-\t\t      if (dump_file)\n-\t\t        fprintf (dump_file,\n+\t\t      if (symtab->dump_file)\n+\t\t        fprintf (symtab->dump_file,\n \t\t\t\t \"Mismatch in merging indirect edges\\n\");\n \t\t    }\n \t\t  else if (!e2->speculative)"}]}