{"sha": "1f9ceff11132bb256260ce0501c6d14f2d0fc650", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY5Y2VmZjExMTMyYmIyNTYyNjBjZTA1MDFjNmQxNGYyZDBmYzY1MA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-08-14T18:51:50Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-08-14T18:51:50Z"}, "message": "[PR64164] Drop copyrename, use coalescible partition as base when optimizing.\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/64164\n\tPR bootstrap/66978\n\tPR middle-end/66983\n\tPR rtl-optimization/67000\n\tPR middle-end/67034\n\tPR middle-end/67035\n\t* Makefile.in (OBJS): Drop tree-ssa-copyrename.o.\n\t* tree-ssa-copyrename.c: Removed.\n\t* opts.c (default_options_table): Drop -ftree-copyrename.  Add\n\t-ftree-coalesce-vars.\n\t* passes.def: Drop all occurrences of pass_rename_ssa_copies.\n\t* common.opt (ftree-copyrename): Ignore.\n\t(ftree-coalesce-inlined-vars): Likewise.\n\t* doc/invoke.texi: Remove the ignored options above.\n\t* gimple-expr.h (gimple_can_coalesce_p): Move declaration\n\t* tree-ssa-coalesce.h: ... here.\n\t* tree-ssa-uncprop.c: Include tree-ssa-coalesce.h and other\n\theaders required by it.\n\t* gimple-expr.c (gimple_can_coalesce_p): Allow coalescing\n\tacross variables when flag_tree_coalesce_vars.  Check register\n\tuse and promoted modes to allow coalescing.  Do not coalesce\n\tmaybe-byref parms with SSA_NAMEs of other variables, or\n\tanonymous SSA_NAMEs.  Moved to tree-ssa-coalesce.c.\n\t* tree-ssa-live.c (struct tree_int_map_hasher): Move along\n\twith its member functions to tree-ssa-coalesce.c.\n\t(var_map_base_init): Likewise.  Renamed to\n\tcompute_samebase_partition_bases.\n\t(partition_view_normal): Drop want_bases parameter.\n\t(partition_view_bitmap): Likewise.\n\t* tree-ssa-live.h: Adjust declarations.\n\t* tree-ssa-coalesce.c: Include explow.h and cfgexpand.h.\n\t(build_ssa_conflict_graph): Process PARM_ and RESULT_DECLs's\n\tdefault defs at the entry point.\n\t(dump_part_var_map): New.\n\t(compute_optimized_partition_bases): New, called by...\n\t(coalesce_ssa_name): ... when flag_tree_coalesce_vars, instead\n\tof compute_samebase_partition_bases.  Adjust.\n\t* alias.c (nonoverlapping_memrefs_p): Disregard gimple-regs.\n\t* cfgexpand.c (leader_merge, parm_maybe_byref_p): New.\n\t(ssa_default_def_partition): New.\n\t(get_rtl_for_parm_ssa_default_def): New.\n\t(align_local_variable, add_stack_var): Support anonymous SSA\n\tnames.\n\t(defer_stack_allocation): Likewise.  Declare earlier.\n\t(set_rtl): Merge exprs and attrs, even for MEMs and non-SSA\n\tvars.  Update DECL_RTL for PARM_DECLs and RESULT_DECLs too.\n\tDo no record deferred-allocation marker in\n\tSA.partition_to_pseudo.\n\t(expand_stack_vars): Adjust check for the marker in it.\n\t(expand_one_stack_var_at): Handle anonymous SSA_NAMEs.  Drop\n\tredundant MEM attr setting.\n\t(expand_one_stack_var_1): Handle anonymous SSA_NAMEs.  Renamed\n\tfrom...\n\t(expand_one_stack_var): ... this.  New wrapper to check and\n\tskip already expanded SSA partitions.\n\t(record_alignment_for_reg_var): New, factored out of...\n\t(expand_one_var): ... this.\n\t(expand_one_ssa_partition): New.\n\t(adjust_one_expanded_partition_var): New.\n\t(expand_one_register_var): Check and skip already expanded SSA\n\tpartitions.\n\t(expand_used_vars): Don't create DECLs for anonymous SSA\n\tnames.  Expand all SSA partitions, then adjust all SSA names.\n\t(pass::execute): Replace the loops that set\n\tSA.partition_to_pseudo from partition leaders and cleared\n\tDECL_RTL for multi-location variables, and that which used to\n\trename vars and set attrs, with one that clears DECL_RTL and\n\tchecks that PARMs and RESULTs default_defs match DECL_RTL.\n\t* cfgexpand.h (get_rtl_for_parm_ssa_default_def): Declare.\n\t* emit-rtl.c: Include stor-layout.h.\n\t(set_reg_attrs_for_parm): Handle NULL decl.\n\t(set_reg_attrs_for_decl_rtl): Take mode from expression if\n\tit's not a DECL.\n\t* stmt.c (emit_case_decision_tree): Pass it the SSA_NAME\n\trather than its possibly-NULL DECL.\n\t* explow.c (promote_ssa_mode): New.\n\t* explow.h (promote_ssa_mode): Declare.\n\t* expr.c (expand_expr_real_1): Handle anonymous SSA_NAMEs.\n\t(read_complex_part): Export.\n\t* expr.h (read_complex_part): Declare.\n\t* cfgexpand.h (parm_maybe_byref_p): Declare.\n\t* function.c: Include cfgexpand.h.\n\t(use_register_for_decl): Handle SSA_NAMEs, anonymous or not.\n\t(use_register_for_parm_decl): Wrapper for the above to\n\tspecial-case the result_ptr.\n\t(rtl_for_parm): Ditto for get_rtl_for_parm_ssa_default_def.\n\t(split_complex_args): Take assign_parm_data_all argument.\n\tPass it to rtl_for_parm.  Set up rtl and context for split\n\targs.  Reset complex parm before fetching its default decl\n\trtl.\n\t(assign_parms_unsplit_complex): Use the default-def complex\n\tparm rtl if it matches the components.\n\t(assign_parms_augmented_arg_list): Adjust.\n\t(maybe_reset_rtl_for_parm): Reset DECL_RTL of parms with\n\tmultiple locations.  Recognize split complex args.\n\t(assign_parm_adjust_stack_rtl): Add all and parm arguments,\n\tfor rtl_for_parm.  For SSA-assigned parms, zero stack_parm.\n\t(assign_parm_setup_block): Prefer SSA-assigned location, and\n\tfill in its address if the memory location of a maybe-byref\n\tparm was not assigned by cfgexpand.\n\t(assign_parm_setup_reg): Likewise.  Adjust its mode as\n\tneeded.  Use entry_parm for equiv if stack_parm is NULL.  Make\n\tsure passed_pointer parms don't need conversion.  Copy address\n\tor value as needed.\n\t(assign_parm_setup_stack): Prefer SSA-assigned location.\n\t(assign_parms): Maybe reset DECL_RTL of params.  Adjust stack\n\trtl before testing for pointer bounds.  Special-case result_ptr.\n\t(expand_function_start): Maybe reset DECL_RTL of result.\n\tPrefer SSA-assigned location for result and static chain.\n\tFactor out DECL_RESULT and SET_DECL_RTL.  Convert static chain\n\tto Pmode if needed, from H.J. Lu  <hongjiu.lu@intel.com>.\n\t* tree-outof-ssa.c (insert_value_copy_on_edge): Handle\n\tanonymous SSA names.  Use promote_ssa_mode.\n\t(get_temp_reg): Likewise.\n\t(remove_ssa_form): Adjust.\n\t* stor-layout.c (layout_decl): Don't set mem attributes of\n\tnon-MEMs.\n\t* var-tracking.c (dataflow_set_clear_at_call): Take call_insn\n\tand get its reg_usage for reg invalidation.\n\t(compute_bb_dataflow): Pass it insn.\n\t(emit_notes_in_bb): Likewise.\n\nfor  gcc/testsuite/ChangeLog\n\n\t* gcc.dg/guality/pr54200.c: Add -fno-tree-coalesce-vars.\n\t* gcc.dg/ssp-1.c: Make counter a register.\n\t* gcc.dg/ssp-2.c: Likewise.\n\t* gcc.dg/torture/parm-coalesce.c: New.\n\nFrom-SVN: r226901", "tree": {"sha": "46e871c76eec316977d9c53145eb5c5baaca6e69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e871c76eec316977d9c53145eb5c5baaca6e69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f9ceff11132bb256260ce0501c6d14f2d0fc650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f9ceff11132bb256260ce0501c6d14f2d0fc650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f9ceff11132bb256260ce0501c6d14f2d0fc650", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f9ceff11132bb256260ce0501c6d14f2d0fc650/comments", "author": null, "committer": null, "parents": [{"sha": "d7e90b6653961db45623895733bbeb9537bf5910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e90b6653961db45623895733bbeb9537bf5910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e90b6653961db45623895733bbeb9537bf5910"}], "stats": {"total": 2196, "additions": 1318, "deletions": 878}, "files": [{"sha": "a0f656faae53acd5d6eacf809411ee2152f58aba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -1,3 +1,127 @@\n+2015-08-14  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/64164\n+\tPR bootstrap/66978\n+\tPR middle-end/66983\n+\tPR rtl-optimization/67000\n+\tPR middle-end/67034\n+\tPR middle-end/67035\n+\t* Makefile.in (OBJS): Drop tree-ssa-copyrename.o.\n+\t* tree-ssa-copyrename.c: Removed.\n+\t* opts.c (default_options_table): Drop -ftree-copyrename.  Add\n+\t-ftree-coalesce-vars.\n+\t* passes.def: Drop all occurrences of pass_rename_ssa_copies.\n+\t* common.opt (ftree-copyrename): Ignore.\n+\t(ftree-coalesce-inlined-vars): Likewise.\n+\t* doc/invoke.texi: Remove the ignored options above.\n+\t* gimple-expr.h (gimple_can_coalesce_p): Move declaration\n+\t* tree-ssa-coalesce.h: ... here.\n+\t* tree-ssa-uncprop.c: Include tree-ssa-coalesce.h and other\n+\theaders required by it.\n+\t* gimple-expr.c (gimple_can_coalesce_p): Allow coalescing\n+\tacross variables when flag_tree_coalesce_vars.  Check register\n+\tuse and promoted modes to allow coalescing.  Do not coalesce\n+\tmaybe-byref parms with SSA_NAMEs of other variables, or\n+\tanonymous SSA_NAMEs.  Moved to tree-ssa-coalesce.c.\n+\t* tree-ssa-live.c (struct tree_int_map_hasher): Move along\n+\twith its member functions to tree-ssa-coalesce.c.\n+\t(var_map_base_init): Likewise.  Renamed to\n+\tcompute_samebase_partition_bases.\n+\t(partition_view_normal): Drop want_bases parameter.\n+\t(partition_view_bitmap): Likewise.\n+\t* tree-ssa-live.h: Adjust declarations.\n+\t* tree-ssa-coalesce.c: Include explow.h and cfgexpand.h.\n+\t(build_ssa_conflict_graph): Process PARM_ and RESULT_DECLs's\n+\tdefault defs at the entry point.\n+\t(dump_part_var_map): New.\n+\t(compute_optimized_partition_bases): New, called by...\n+\t(coalesce_ssa_name): ... when flag_tree_coalesce_vars, instead\n+\tof compute_samebase_partition_bases.  Adjust.\n+\t* alias.c (nonoverlapping_memrefs_p): Disregard gimple-regs.\n+\t* cfgexpand.c (leader_merge, parm_maybe_byref_p): New.\n+\t(ssa_default_def_partition): New.\n+\t(get_rtl_for_parm_ssa_default_def): New.\n+\t(align_local_variable, add_stack_var): Support anonymous SSA\n+\tnames.\n+\t(defer_stack_allocation): Likewise.  Declare earlier.\n+\t(set_rtl): Merge exprs and attrs, even for MEMs and non-SSA\n+\tvars.  Update DECL_RTL for PARM_DECLs and RESULT_DECLs too.\n+\tDo no record deferred-allocation marker in\n+\tSA.partition_to_pseudo.\n+\t(expand_stack_vars): Adjust check for the marker in it.\n+\t(expand_one_stack_var_at): Handle anonymous SSA_NAMEs.  Drop\n+\tredundant MEM attr setting.\n+\t(expand_one_stack_var_1): Handle anonymous SSA_NAMEs.  Renamed\n+\tfrom...\n+\t(expand_one_stack_var): ... this.  New wrapper to check and\n+\tskip already expanded SSA partitions.\n+\t(record_alignment_for_reg_var): New, factored out of...\n+\t(expand_one_var): ... this.\n+\t(expand_one_ssa_partition): New.\n+\t(adjust_one_expanded_partition_var): New.\n+\t(expand_one_register_var): Check and skip already expanded SSA\n+\tpartitions.\n+\t(expand_used_vars): Don't create DECLs for anonymous SSA\n+\tnames.  Expand all SSA partitions, then adjust all SSA names.\n+\t(pass::execute): Replace the loops that set\n+\tSA.partition_to_pseudo from partition leaders and cleared\n+\tDECL_RTL for multi-location variables, and that which used to\n+\trename vars and set attrs, with one that clears DECL_RTL and\n+\tchecks that PARMs and RESULTs default_defs match DECL_RTL.\n+\t* cfgexpand.h (get_rtl_for_parm_ssa_default_def): Declare.\n+\t* emit-rtl.c: Include stor-layout.h.\n+\t(set_reg_attrs_for_parm): Handle NULL decl.\n+\t(set_reg_attrs_for_decl_rtl): Take mode from expression if\n+\tit's not a DECL.\n+\t* stmt.c (emit_case_decision_tree): Pass it the SSA_NAME\n+\trather than its possibly-NULL DECL.\n+\t* explow.c (promote_ssa_mode): New.\n+\t* explow.h (promote_ssa_mode): Declare.\n+\t* expr.c (expand_expr_real_1): Handle anonymous SSA_NAMEs.\n+\t(read_complex_part): Export.\n+\t* expr.h (read_complex_part): Declare.\n+\t* cfgexpand.h (parm_maybe_byref_p): Declare.\n+\t* function.c: Include cfgexpand.h.\n+\t(use_register_for_decl): Handle SSA_NAMEs, anonymous or not.\n+\t(use_register_for_parm_decl): Wrapper for the above to\n+\tspecial-case the result_ptr.\n+\t(rtl_for_parm): Ditto for get_rtl_for_parm_ssa_default_def.\n+\t(split_complex_args): Take assign_parm_data_all argument.\n+\tPass it to rtl_for_parm.  Set up rtl and context for split\n+\targs.  Reset complex parm before fetching its default decl\n+\trtl.\n+\t(assign_parms_unsplit_complex): Use the default-def complex\n+\tparm rtl if it matches the components.\n+\t(assign_parms_augmented_arg_list): Adjust.\n+\t(maybe_reset_rtl_for_parm): Reset DECL_RTL of parms with\n+\tmultiple locations.  Recognize split complex args.\n+\t(assign_parm_adjust_stack_rtl): Add all and parm arguments,\n+\tfor rtl_for_parm.  For SSA-assigned parms, zero stack_parm.\n+\t(assign_parm_setup_block): Prefer SSA-assigned location, and\n+\tfill in its address if the memory location of a maybe-byref\n+\tparm was not assigned by cfgexpand.\n+\t(assign_parm_setup_reg): Likewise.  Adjust its mode as\n+\tneeded.  Use entry_parm for equiv if stack_parm is NULL.  Make\n+\tsure passed_pointer parms don't need conversion.  Copy address\n+\tor value as needed.\n+\t(assign_parm_setup_stack): Prefer SSA-assigned location.\n+\t(assign_parms): Maybe reset DECL_RTL of params.  Adjust stack\n+\trtl before testing for pointer bounds.  Special-case result_ptr.\n+\t(expand_function_start): Maybe reset DECL_RTL of result.\n+\tPrefer SSA-assigned location for result and static chain.\n+\tFactor out DECL_RESULT and SET_DECL_RTL.  Convert static chain\n+\tto Pmode if needed, from H.J. Lu  <hongjiu.lu@intel.com>.\n+\t* tree-outof-ssa.c (insert_value_copy_on_edge): Handle\n+\tanonymous SSA names.  Use promote_ssa_mode.\n+\t(get_temp_reg): Likewise.\n+\t(remove_ssa_form): Adjust.\n+\t* stor-layout.c (layout_decl): Don't set mem attributes of\n+\tnon-MEMs.\n+\t* var-tracking.c (dataflow_set_clear_at_call): Take call_insn\n+\tand get its reg_usage for reg invalidation.\n+\t(compute_bb_dataflow): Pass it insn.\n+\t(emit_notes_in_bb): Likewise.\n+\n 2015-08-14  Marek Polacek  <polacek@redhat.com>\n \n \t* tree-core.h (tree_base): Fix typo."}, {"sha": "e298eccb682aa30eeaf50c4e3e2d8bfccf8aaefd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -1447,7 +1447,6 @@ OBJS = \\\n \ttree-ssa-ccp.o \\\n \ttree-ssa-coalesce.o \\\n \ttree-ssa-copy.o \\\n-\ttree-ssa-copyrename.o \\\n \ttree-ssa-dce.o \\\n \ttree-ssa-dom.o \\\n \ttree-ssa-dse.o \\"}, {"sha": "4681e3f8b9618563be48d6962bfebffab8838439", "filename": "gcc/alias.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -2507,6 +2507,19 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n   if (! DECL_P (exprx) || ! DECL_P (expry))\n     return 0;\n \n+  /* If we refer to different gimple registers, or one gimple register\n+     and one non-gimple-register, we know they can't overlap.  First,\n+     gimple registers don't have their addresses taken.  Now, there\n+     could be more than one stack slot for (different versions of) the\n+     same gimple register, but we can presumably tell they don't\n+     overlap based on offsets from stack base addresses elsewhere.\n+     It's important that we don't proceed to DECL_RTL, because gimple\n+     registers may not pass DECL_RTL_SET_P, and make_decl_rtl won't be\n+     able to do anything about them since no SSA information will have\n+     remained to guide it.  */\n+  if (is_gimple_reg (exprx) || is_gimple_reg (expry))\n+    return exprx != expry;\n+\n   /* With invalid code we can end up storing into the constant pool.\n      Bail out to avoid ICEing when creating RTL for this.\n      See gfortran.dg/lto/20091028-2_0.f90.  */"}, {"sha": "0bc20f6816cd55ffde1d22aa3b23712cbc499d73", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 354, "deletions": 117, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -97,6 +97,8 @@ gimple currently_expanding_gimple_stmt;\n \n static rtx expand_debug_expr (tree);\n \n+static bool defer_stack_allocation (tree, bool);\n+\n /* Return an expression tree corresponding to the RHS of GIMPLE\n    statement STMT.  */\n \n@@ -150,21 +152,149 @@ gimple_assign_rhs_to_tree (gimple stmt)\n \n #define SSAVAR(x) (TREE_CODE (x) == SSA_NAME ? SSA_NAME_VAR (x) : x)\n \n+/* Choose either CUR or NEXT as the leader DECL for a partition.\n+   Prefer ignored decls, to simplify debug dumps and reduce ambiguity\n+   out of the same user variable being in multiple partitions (this is\n+   less likely for compiler-introduced temps).  */\n+\n+static tree\n+leader_merge (tree cur, tree next)\n+{\n+  if (cur == NULL || cur == next)\n+    return next;\n+\n+  if (DECL_P (cur) && DECL_IGNORED_P (cur))\n+    return cur;\n+\n+  if (DECL_P (next) && DECL_IGNORED_P (next))\n+    return next;\n+\n+  return cur;\n+}\n+\n+/* Return true if VAR is a PARM_DECL or a RESULT_DECL of type BLKmode.\n+   Such parameters are likely passed as a pointer to the value, rather\n+   than as a value, and so we must not coalesce them, nor allocate\n+   stack space for them before determining the calling conventions for\n+   them.  For their SSA_NAMEs, expand_one_ssa_partition emits RTL as\n+   MEMs with pc_rtx as the address, and then it replaces the pc_rtx\n+   with NULL so as to make sure the MEM is not used before it is\n+   adjusted in assign_parm_setup_reg.  */\n+\n+bool\n+parm_maybe_byref_p (tree var)\n+{\n+  if (!var || VAR_P (var))\n+    return false;\n+\n+  gcc_assert (TREE_CODE (var) == PARM_DECL\n+\t      || TREE_CODE (var) == RESULT_DECL);\n+\n+  return TYPE_MODE (TREE_TYPE (var)) == BLKmode;\n+}\n+\n+/* Return the partition of the default SSA_DEF for decl VAR.  */\n+\n+static int\n+ssa_default_def_partition (tree var)\n+{\n+  tree name = ssa_default_def (cfun, var);\n+\n+  if (!name)\n+    return NO_PARTITION;\n+\n+  return var_to_partition (SA.map, name);\n+}\n+\n+/* Return the RTL for the default SSA def of a PARM or RESULT, if\n+   there is one.  */\n+\n+rtx\n+get_rtl_for_parm_ssa_default_def (tree var)\n+{\n+  gcc_assert (TREE_CODE (var) == PARM_DECL || TREE_CODE (var) == RESULT_DECL);\n+\n+  if (!is_gimple_reg (var))\n+    return NULL_RTX;\n+\n+  /* If we've already determined RTL for the decl, use it.  This is\n+     not just an optimization: if VAR is a PARM whose incoming value\n+     is unused, we won't find a default def to use its partition, but\n+     we still want to use the location of the parm, if it was used at\n+     all.  During assign_parms, until a location is assigned for the\n+     VAR, RTL can only for a parm or result if we're not coalescing\n+     across variables, when we know we're coalescing all SSA_NAMEs of\n+     each parm or result, and we're not coalescing them with names\n+     pertaining to other variables, such as other parms' default\n+     defs.  */\n+  if (DECL_RTL_SET_P (var))\n+    {\n+      gcc_assert (DECL_RTL (var) != pc_rtx);\n+      return DECL_RTL (var);\n+    }\n+\n+  int part = ssa_default_def_partition (var);\n+  if (part == NO_PARTITION)\n+    return NULL_RTX;\n+\n+  return SA.partition_to_pseudo[part];\n+}\n+\n /* Associate declaration T with storage space X.  If T is no\n    SSA name this is exactly SET_DECL_RTL, otherwise make the\n    partition of T associated with X.  */\n static inline void\n set_rtl (tree t, rtx x)\n {\n+  if (x && SSAVAR (t))\n+    {\n+      bool skip = false;\n+      tree cur = NULL_TREE;\n+\n+      if (MEM_P (x))\n+\tcur = MEM_EXPR (x);\n+      else if (REG_P (x))\n+\tcur = REG_EXPR (x);\n+      else if (GET_CODE (x) == CONCAT\n+\t       && REG_P (XEXP (x, 0)))\n+\tcur = REG_EXPR (XEXP (x, 0));\n+      else if (GET_CODE (x) == PARALLEL)\n+\tcur = REG_EXPR (XVECEXP (x, 0, 0));\n+      else if (x == pc_rtx)\n+\tskip = true;\n+      else\n+\tgcc_unreachable ();\n+\n+      tree next = skip ? cur : leader_merge (cur, SSAVAR (t));\n+\n+      if (cur != next)\n+\t{\n+\t  if (MEM_P (x))\n+\t    set_mem_attributes (x, next, true);\n+\t  else\n+\t    set_reg_attrs_for_decl_rtl (next, x);\n+\t}\n+    }\n+\n   if (TREE_CODE (t) == SSA_NAME)\n     {\n-      SA.partition_to_pseudo[var_to_partition (SA.map, t)] = x;\n-      if (x && !MEM_P (x))\n-\tset_reg_attrs_for_decl_rtl (SSA_NAME_VAR (t), x);\n-      /* For the benefit of debug information at -O0 (where vartracking\n-         doesn't run) record the place also in the base DECL if it's\n-\t a normal variable (not a parameter).  */\n-      if (x && x != pc_rtx && TREE_CODE (SSA_NAME_VAR (t)) == VAR_DECL)\n+      int part = var_to_partition (SA.map, t);\n+      if (part != NO_PARTITION)\n+\t{\n+\t  if (SA.partition_to_pseudo[part])\n+\t    gcc_assert (SA.partition_to_pseudo[part] == x);\n+\t  else if (x != pc_rtx)\n+\t    SA.partition_to_pseudo[part] = x;\n+\t}\n+      /* For the benefit of debug information at -O0 (where\n+         vartracking doesn't run) record the place also in the base\n+         DECL.  For PARMs and RESULTs, we may end up resetting these\n+         in function.c:maybe_reset_rtl_for_parm, but in some rare\n+         cases we may need them (unused and overwritten incoming\n+         value, that at -O0 must share the location with the other\n+         uses in spite of the missing default def), and this may be\n+         the only chance to preserve them.  */\n+      if (x && x != pc_rtx && SSA_NAME_VAR (t))\n \t{\n \t  tree var = SSA_NAME_VAR (t);\n \t  /* If we don't yet have something recorded, just record it now.  */\n@@ -248,8 +378,15 @@ static bool has_short_buffer;\n static unsigned int\n align_local_variable (tree decl)\n {\n-  unsigned int align = LOCAL_DECL_ALIGNMENT (decl);\n-  DECL_ALIGN (decl) = align;\n+  unsigned int align;\n+\n+  if (TREE_CODE (decl) == SSA_NAME)\n+    align = TYPE_ALIGN (TREE_TYPE (decl));\n+  else\n+    {\n+      align = LOCAL_DECL_ALIGNMENT (decl);\n+      DECL_ALIGN (decl) = align;\n+    }\n   return align / BITS_PER_UNIT;\n }\n \n@@ -315,12 +452,15 @@ add_stack_var (tree decl)\n   decl_to_stack_part->put (decl, stack_vars_num);\n \n   v->decl = decl;\n-  v->size = tree_to_uhwi (DECL_SIZE_UNIT (SSAVAR (decl)));\n+  tree size = TREE_CODE (decl) == SSA_NAME\n+    ? TYPE_SIZE_UNIT (TREE_TYPE (decl))\n+    : DECL_SIZE_UNIT (decl);\n+  v->size = tree_to_uhwi (size);\n   /* Ensure that all variables have size, so that &a != &b for any two\n      variables that are simultaneously live.  */\n   if (v->size == 0)\n     v->size = 1;\n-  v->alignb = align_local_variable (SSAVAR (decl));\n+  v->alignb = align_local_variable (decl);\n   /* An alignment of zero can mightily confuse us later.  */\n   gcc_assert (v->alignb != 0);\n \n@@ -862,7 +1002,9 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n   gcc_assert (offset == trunc_int_for_mode (offset, Pmode));\n \n   x = plus_constant (Pmode, base, offset);\n-  x = gen_rtx_MEM (DECL_MODE (SSAVAR (decl)), x);\n+  x = gen_rtx_MEM (TREE_CODE (decl) == SSA_NAME\n+\t\t   ? TYPE_MODE (TREE_TYPE (decl))\n+\t\t   : DECL_MODE (SSAVAR (decl)), x);\n \n   if (TREE_CODE (decl) != SSA_NAME)\n     {\n@@ -884,7 +1026,6 @@ expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n       DECL_USER_ALIGN (decl) = 0;\n     }\n \n-  set_mem_attributes (x, SSAVAR (decl), true);\n   set_rtl (decl, x);\n }\n \n@@ -950,9 +1091,9 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n \t  /* Skip variables that have already had rtl assigned.  See also\n \t     add_stack_var where we perpetrate this pc_rtx hack.  */\n \t  decl = stack_vars[i].decl;\n-\t  if ((TREE_CODE (decl) == SSA_NAME\n-\t      ? SA.partition_to_pseudo[var_to_partition (SA.map, decl)]\n-\t      : DECL_RTL (decl)) != pc_rtx)\n+\t  if (TREE_CODE (decl) == SSA_NAME\n+\t      ? SA.partition_to_pseudo[var_to_partition (SA.map, decl)] != NULL_RTX\n+\t      : DECL_RTL (decl) != pc_rtx)\n \t    continue;\n \n \t  large_size += alignb - 1;\n@@ -981,9 +1122,9 @@ expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n       /* Skip variables that have already had rtl assigned.  See also\n \t add_stack_var where we perpetrate this pc_rtx hack.  */\n       decl = stack_vars[i].decl;\n-      if ((TREE_CODE (decl) == SSA_NAME\n-\t   ? SA.partition_to_pseudo[var_to_partition (SA.map, decl)]\n-\t   : DECL_RTL (decl)) != pc_rtx)\n+      if (TREE_CODE (decl) == SSA_NAME\n+\t  ? SA.partition_to_pseudo[var_to_partition (SA.map, decl)] != NULL_RTX\n+\t  : DECL_RTL (decl) != pc_rtx)\n \tcontinue;\n \n       /* Check the predicate to see whether this variable should be\n@@ -1099,13 +1240,22 @@ account_stack_vars (void)\n    to a variable to be allocated in the stack frame.  */\n \n static void\n-expand_one_stack_var (tree var)\n+expand_one_stack_var_1 (tree var)\n {\n   HOST_WIDE_INT size, offset;\n   unsigned byte_align;\n \n-  size = tree_to_uhwi (DECL_SIZE_UNIT (SSAVAR (var)));\n-  byte_align = align_local_variable (SSAVAR (var));\n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      tree type = TREE_TYPE (var);\n+      size = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+      byte_align = TYPE_ALIGN_UNIT (type);\n+    }\n+  else\n+    {\n+      size = tree_to_uhwi (DECL_SIZE_UNIT (var));\n+      byte_align = align_local_variable (var);\n+    }\n \n   /* We handle highly aligned variables in expand_stack_vars.  */\n   gcc_assert (byte_align * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT);\n@@ -1116,6 +1266,27 @@ expand_one_stack_var (tree var)\n \t\t\t   crtl->max_used_stack_slot_alignment, offset);\n }\n \n+/* Wrapper for expand_one_stack_var_1 that checks SSA_NAMEs are\n+   already assigned some MEM.  */\n+\n+static void\n+expand_one_stack_var (tree var)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      int part = var_to_partition (SA.map, var);\n+      if (part != NO_PARTITION)\n+\t{\n+\t  rtx x = SA.partition_to_pseudo[part];\n+\t  gcc_assert (x);\n+\t  gcc_assert (MEM_P (x));\n+\t  return;\n+\t}\n+    }\n+\n+  return expand_one_stack_var_1 (var);\n+}\n+\n /* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL\n    that will reside in a hard register.  */\n \n@@ -1125,13 +1296,136 @@ expand_one_hard_reg_var (tree var)\n   rest_of_decl_compilation (var, 0, 0);\n }\n \n+/* Record the alignment requirements of some variable assigned to a\n+   pseudo.  */\n+\n+static void\n+record_alignment_for_reg_var (unsigned int align)\n+{\n+  if (SUPPORTS_STACK_ALIGNMENT\n+      && crtl->stack_alignment_estimated < align)\n+    {\n+      /* stack_alignment_estimated shouldn't change after stack\n+         realign decision made */\n+      gcc_assert (!crtl->stack_realign_processed);\n+      crtl->stack_alignment_estimated = align;\n+    }\n+\n+  /* stack_alignment_needed > PREFERRED_STACK_BOUNDARY is permitted.\n+     So here we only make sure stack_alignment_needed >= align.  */\n+  if (crtl->stack_alignment_needed < align)\n+    crtl->stack_alignment_needed = align;\n+  if (crtl->max_used_stack_slot_alignment < align)\n+    crtl->max_used_stack_slot_alignment = align;\n+}\n+\n+/* Create RTL for an SSA partition.  */\n+\n+static void\n+expand_one_ssa_partition (tree var)\n+{\n+  int part = var_to_partition (SA.map, var);\n+  gcc_assert (part != NO_PARTITION);\n+\n+  if (SA.partition_to_pseudo[part])\n+    return;\n+\n+  unsigned int align = MINIMUM_ALIGNMENT (TREE_TYPE (var),\n+\t\t\t\t\t  TYPE_MODE (TREE_TYPE (var)),\n+\t\t\t\t\t  TYPE_ALIGN (TREE_TYPE (var)));\n+\n+  /* If the variable alignment is very large we'll dynamicaly allocate\n+     it, which means that in-frame portion is just a pointer.  */\n+  if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    align = POINTER_SIZE;\n+\n+  record_alignment_for_reg_var (align);\n+\n+  if (!use_register_for_decl (var))\n+    {\n+      if (parm_maybe_byref_p (SSA_NAME_VAR (var))\n+\t  && ssa_default_def_partition (SSA_NAME_VAR (var)) == part)\n+\t{\n+\t  expand_one_stack_var_at (var, pc_rtx, 0, 0);\n+\t  rtx x = SA.partition_to_pseudo[part];\n+\t  gcc_assert (GET_CODE (x) == MEM);\n+\t  gcc_assert (GET_MODE (x) == BLKmode);\n+\t  gcc_assert (XEXP (x, 0) == pc_rtx);\n+\t  /* Reset the address, so that any attempt to use it will\n+\t     ICE.  It will be adjusted in assign_parm_setup_reg.  */\n+\t  XEXP (x, 0) = NULL_RTX;\n+\t}\n+      else if (defer_stack_allocation (var, true))\n+\tadd_stack_var (var);\n+      else\n+\texpand_one_stack_var_1 (var);\n+      return;\n+    }\n+\n+  machine_mode reg_mode = promote_ssa_mode (var, NULL);\n+\n+  rtx x = gen_reg_rtx (reg_mode);\n+\n+  set_rtl (var, x);\n+}\n+\n+/* Record the association between the RTL generated for a partition\n+   and the underlying variable of the SSA_NAME.  */\n+\n+static void\n+adjust_one_expanded_partition_var (tree var)\n+{\n+  if (!var)\n+    return;\n+\n+  tree decl = SSA_NAME_VAR (var);\n+\n+  int part = var_to_partition (SA.map, var);\n+  if (part == NO_PARTITION)\n+    return;\n+\n+  rtx x = SA.partition_to_pseudo[part];\n+\n+  if (!x)\n+    {\n+      /* This var will get a stack slot later.  */\n+      gcc_assert (defer_stack_allocation (var, true));\n+      return;\n+    }\n+\n+  set_rtl (var, x);\n+\n+  if (!REG_P (x))\n+    return;\n+\n+  /* Note if the object is a user variable.  */\n+  if (decl && !DECL_ARTIFICIAL (decl))\n+    mark_user_reg (x);\n+\n+  if (POINTER_TYPE_P (decl ? TREE_TYPE (decl) : TREE_TYPE (var)))\n+    mark_reg_pointer (x, get_pointer_alignment (var));\n+}\n+\n /* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL\n    that will reside in a pseudo register.  */\n \n static void\n expand_one_register_var (tree var)\n {\n-  tree decl = SSAVAR (var);\n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      int part = var_to_partition (SA.map, var);\n+      if (part != NO_PARTITION)\n+\t{\n+\t  rtx x = SA.partition_to_pseudo[part];\n+\t  gcc_assert (x);\n+\t  gcc_assert (REG_P (x));\n+\t  return;\n+\t}\n+      gcc_unreachable ();\n+    }\n+\n+  tree decl = var;\n   tree type = TREE_TYPE (decl);\n   machine_mode reg_mode = promote_decl_mode (decl, NULL);\n   rtx x = gen_reg_rtx (reg_mode);\n@@ -1177,10 +1471,14 @@ expand_one_error_var (tree var)\n static bool\n defer_stack_allocation (tree var, bool toplevel)\n {\n+  tree size_unit = TREE_CODE (var) == SSA_NAME\n+    ? TYPE_SIZE_UNIT (TREE_TYPE (var))\n+    : DECL_SIZE_UNIT (var);\n+\n   /* Whether the variable is small enough for immediate allocation not to be\n      a problem with regard to the frame size.  */\n   bool smallish\n-    = ((HOST_WIDE_INT) tree_to_uhwi (DECL_SIZE_UNIT (var))\n+    = ((HOST_WIDE_INT) tree_to_uhwi (size_unit)\n        < PARAM_VALUE (PARAM_MIN_SIZE_FOR_STACK_SHARING));\n \n   /* If stack protection is enabled, *all* stack variables must be deferred,\n@@ -1189,16 +1487,24 @@ defer_stack_allocation (tree var, bool toplevel)\n   if (flag_stack_protect || ((flag_sanitize & SANITIZE_ADDRESS) && ASAN_STACK))\n     return true;\n \n+  unsigned int align = TREE_CODE (var) == SSA_NAME\n+    ? TYPE_ALIGN (TREE_TYPE (var))\n+    : DECL_ALIGN (var);\n+\n   /* We handle \"large\" alignment via dynamic allocation.  We want to handle\n      this extra complication in only one place, so defer them.  */\n-  if (DECL_ALIGN (var) > MAX_SUPPORTED_STACK_ALIGNMENT)\n+  if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n     return true;\n \n+  bool ignored = TREE_CODE (var) == SSA_NAME\n+    ? !SSAVAR (var) || DECL_IGNORED_P (SSA_NAME_VAR (var))\n+    : DECL_IGNORED_P (var);\n+\n   /* When optimization is enabled, DECL_IGNORED_P variables originally scoped\n      might be detached from their block and appear at toplevel when we reach\n      here.  We want to coalesce them with variables from other blocks when\n      the immediate contribution to the frame size would be noticeable.  */\n-  if (toplevel && optimize > 0 && DECL_IGNORED_P (var) && !smallish)\n+  if (toplevel && optimize > 0 && ignored && !smallish)\n     return true;\n \n   /* Variables declared in the outermost scope automatically conflict\n@@ -1265,21 +1571,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n \talign = POINTER_SIZE;\n     }\n \n-  if (SUPPORTS_STACK_ALIGNMENT\n-      && crtl->stack_alignment_estimated < align)\n-    {\n-      /* stack_alignment_estimated shouldn't change after stack\n-         realign decision made */\n-      gcc_assert (!crtl->stack_realign_processed);\n-      crtl->stack_alignment_estimated = align;\n-    }\n-\n-  /* stack_alignment_needed > PREFERRED_STACK_BOUNDARY is permitted.\n-     So here we only make sure stack_alignment_needed >= align.  */\n-  if (crtl->stack_alignment_needed < align)\n-    crtl->stack_alignment_needed = align;\n-  if (crtl->max_used_stack_slot_alignment < align)\n-    crtl->max_used_stack_slot_alignment = align;\n+  record_alignment_for_reg_var (align);\n \n   if (TREE_CODE (origvar) == SSA_NAME)\n     {\n@@ -1722,48 +2014,18 @@ expand_used_vars (void)\n   if (targetm.use_pseudo_pic_reg ())\n     pic_offset_table_rtx = gen_reg_rtx (Pmode);\n \n-  hash_map<tree, tree> ssa_name_decls;\n   for (i = 0; i < SA.map->num_partitions; i++)\n     {\n       tree var = partition_to_var (SA.map, i);\n \n       gcc_assert (!virtual_operand_p (var));\n \n-      /* Assign decls to each SSA name partition, share decls for partitions\n-         we could have coalesced (those with the same type).  */\n-      if (SSA_NAME_VAR (var) == NULL_TREE)\n-\t{\n-\t  tree *slot = &ssa_name_decls.get_or_insert (TREE_TYPE (var));\n-\t  if (!*slot)\n-\t    *slot = create_tmp_reg (TREE_TYPE (var));\n-\t  replace_ssa_name_symbol (var, *slot);\n-\t}\n-\n-      /* Always allocate space for partitions based on VAR_DECLs.  But for\n-\t those based on PARM_DECLs or RESULT_DECLs and which matter for the\n-\t debug info, there is no need to do so if optimization is disabled\n-\t because all the SSA_NAMEs based on these DECLs have been coalesced\n-\t into a single partition, which is thus assigned the canonical RTL\n-\t location of the DECLs.  If in_lto_p, we can't rely on optimize,\n-\t a function could be compiled with -O1 -flto first and only the\n-\t link performed at -O0.  */\n-      if (TREE_CODE (SSA_NAME_VAR (var)) == VAR_DECL)\n-\texpand_one_var (var, true, true);\n-      else if (DECL_IGNORED_P (SSA_NAME_VAR (var)) || optimize || in_lto_p)\n-\t{\n-\t  /* This is a PARM_DECL or RESULT_DECL.  For those partitions that\n-\t     contain the default def (representing the parm or result itself)\n-\t     we don't do anything here.  But those which don't contain the\n-\t     default def (representing a temporary based on the parm/result)\n-\t     we need to allocate space just like for normal VAR_DECLs.  */\n-\t  if (!bitmap_bit_p (SA.partition_has_default_def, i))\n-\t    {\n-\t      expand_one_var (var, true, true);\n-\t      gcc_assert (SA.partition_to_pseudo[i]);\n-\t    }\n-\t}\n+      expand_one_ssa_partition (var);\n     }\n \n+  for (i = 1; i < num_ssa_names; i++)\n+    adjust_one_expanded_partition_var (ssa_name (i));\n+\n   if (flag_stack_protect == SPCT_FLAG_STRONG)\n       gen_stack_protect_signal\n \t= stack_protect_decl_p () || stack_protect_return_slot_p ();\n@@ -5928,43 +6190,13 @@ pass_expand::execute (function *fun)\n       parm_birth_insn = var_seq;\n     }\n \n-  /* Now that we also have the parameter RTXs, copy them over to our\n-     partitions.  */\n-  for (i = 0; i < SA.map->num_partitions; i++)\n-    {\n-      tree var = SSA_NAME_VAR (partition_to_var (SA.map, i));\n-\n-      if (TREE_CODE (var) != VAR_DECL\n-\t  && !SA.partition_to_pseudo[i])\n-\tSA.partition_to_pseudo[i] = DECL_RTL_IF_SET (var);\n-      gcc_assert (SA.partition_to_pseudo[i]);\n-\n-      /* If this decl was marked as living in multiple places, reset\n-\t this now to NULL.  */\n-      if (DECL_RTL_IF_SET (var) == pc_rtx)\n-\tSET_DECL_RTL (var, NULL);\n-\n-      /* Some RTL parts really want to look at DECL_RTL(x) when x\n-\t was a decl marked in REG_ATTR or MEM_ATTR.  We could use\n-\t SET_DECL_RTL here making this available, but that would mean\n-\t to select one of the potentially many RTLs for one DECL.  Instead\n-\t of doing that we simply reset the MEM_EXPR of the RTL in question,\n-\t then nobody can get at it and hence nobody can call DECL_RTL on it.  */\n-      if (!DECL_RTL_SET_P (var))\n-\t{\n-\t  if (MEM_P (SA.partition_to_pseudo[i]))\n-\t    set_mem_expr (SA.partition_to_pseudo[i], NULL);\n-\t}\n-    }\n-\n   /* If we have a class containing differently aligned pointers\n      we need to merge those into the corresponding RTL pointer\n      alignment.  */\n   for (i = 1; i < num_ssa_names; i++)\n     {\n       tree name = ssa_name (i);\n       int part;\n-      rtx r;\n \n       if (!name\n \t  /* We might have generated new SSA names in\n@@ -5977,20 +6209,25 @@ pass_expand::execute (function *fun)\n       if (part == NO_PARTITION)\n \tcontinue;\n \n-      /* Adjust all partition members to get the underlying decl of\n-\t the representative which we might have created in expand_one_var.  */\n-      if (SSA_NAME_VAR (name) == NULL_TREE)\n+      gcc_assert (SA.partition_to_pseudo[part]\n+\t\t  || defer_stack_allocation (name, true));\n+\n+      /* If this decl was marked as living in multiple places, reset\n+\t this now to NULL.  */\n+      tree var = SSA_NAME_VAR (name);\n+      if (var && DECL_RTL_IF_SET (var) == pc_rtx)\n+\tSET_DECL_RTL (var, NULL);\n+      /* Check that the pseudos chosen by assign_parms are those of\n+\t the corresponding default defs.  */\n+      else if (SSA_NAME_IS_DEFAULT_DEF (name)\n+\t       && (TREE_CODE (var) == PARM_DECL\n+\t\t   || TREE_CODE (var) == RESULT_DECL))\n \t{\n-\t  tree leader = partition_to_var (SA.map, part);\n-\t  gcc_assert (SSA_NAME_VAR (leader) != NULL_TREE);\n-\t  replace_ssa_name_symbol (name, SSA_NAME_VAR (leader));\n+\t  rtx in = DECL_RTL_IF_SET (var);\n+\t  gcc_assert (in);\n+\t  rtx out = SA.partition_to_pseudo[part];\n+\t  gcc_assert (in == out || rtx_equal_p (in, out));\n \t}\n-      if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-\tcontinue;\n-\n-      r = SA.partition_to_pseudo[part];\n-      if (REG_P (r))\n-\tmark_reg_pointer (r, get_pointer_alignment (name));\n     }\n \n   /* If this function is `main', emit a call to `__main'"}, {"sha": "987cf356a4090fde6b479bdccf4fb50eefc497c8", "filename": "gcc/cfgexpand.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fcfgexpand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fcfgexpand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.h?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -22,5 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n \n extern tree gimple_assign_rhs_to_tree (gimple);\n extern HOST_WIDE_INT estimated_stack_frame_size (struct cgraph_node *);\n+extern bool parm_maybe_byref_p (tree);\n+extern rtx get_rtl_for_parm_ssa_default_def (tree var);\n+\n \n #endif /* GCC_CFGEXPAND_H */"}, {"sha": "dd59ff337e62255e9054a8d3c4183c8211629e1f", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -2234,16 +2234,16 @@ Common Report Var(flag_tree_ch) Optimization\n Enable loop header copying on trees\n \n ftree-coalesce-inlined-vars\n-Common Report Var(flag_ssa_coalesce_vars,1) Init(2) RejectNegative Optimization\n-Enable coalescing of copy-related user variables that are inlined\n+Common Ignore RejectNegative\n+Does nothing.  Preserved for backward compatibility.\n \n ftree-coalesce-vars\n-Common Report Var(flag_ssa_coalesce_vars,2) Optimization\n-Enable coalescing of all copy-related user variables\n+Common Report Var(flag_tree_coalesce_vars) Optimization\n+Enable SSA coalescing of user variables\n \n ftree-copyrename\n-Common Report Var(flag_tree_copyrename) Optimization\n-Replace SSA temporaries with better names in copies\n+Common Ignore\n+Does nothing.  Preserved for backward compatibility.\n \n ftree-copy-prop\n Common Report Var(flag_tree_copy_prop) Optimization"}, {"sha": "27be317d7634aea9bb4b0d5cf85ca1c5f16185bc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -342,7 +342,6 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-phiprop@r{[}-@var{n}@r{]} @gol\n -fdump-tree-phiopt@r{[}-@var{n}@r{]} @gol\n -fdump-tree-forwprop@r{[}-@var{n}@r{]} @gol\n--fdump-tree-copyrename@r{[}-@var{n}@r{]} @gol\n -fdump-tree-nrv -fdump-tree-vect @gol\n -fdump-tree-sink @gol\n -fdump-tree-sra@r{[}-@var{n}@r{]} @gol\n@@ -448,9 +447,8 @@ Objective-C and Objective-C++ Dialects}.\n -fstack-protector-explicit -fstdarg-opt -fstrict-aliasing @gol\n -fstrict-overflow -fthread-jumps -ftracer -ftree-bit-ccp @gol\n -ftree-builtin-call-dce -ftree-ccp -ftree-ch @gol\n--ftree-coalesce-inline-vars -ftree-coalesce-vars -ftree-copy-prop @gol\n--ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse @gol\n--ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol\n+-ftree-coalesce-vars -ftree-copy-prop -ftree-dce -ftree-dominator-opts @gol\n+-ftree-dse -ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol\n -ftree-loop-if-convert-stores -ftree-loop-im @gol\n -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n@@ -7133,11 +7131,6 @@ name is made by appending @file{.phiopt} to the source file name.\n Dump each function after forward propagating single use variables.  The file\n name is made by appending @file{.forwprop} to the source file name.\n \n-@item copyrename\n-@opindex fdump-tree-copyrename\n-Dump each function after applying the copy rename optimization.  The file\n-name is made by appending @file{.copyrename} to the source file name.\n-\n @item nrv\n @opindex fdump-tree-nrv\n Dump each function after applying the named return value optimization on\n@@ -7602,8 +7595,8 @@ compilation time.\n -ftree-ccp @gol\n -fssa-phiopt @gol\n -ftree-ch @gol\n+-ftree-coalesce-vars @gol\n -ftree-copy-prop @gol\n--ftree-copyrename @gol\n -ftree-dce @gol\n -ftree-dominator-opts @gol\n -ftree-dse @gol\n@@ -8867,6 +8860,15 @@ be parallelized.  Parallelize all the loops that can be analyzed to\n not contain loop carried dependences without checking that it is\n profitable to parallelize the loops.\n \n+@item -ftree-coalesce-vars\n+@opindex ftree-coalesce-vars\n+Tell the compiler to attempt to combine small user-defined variables\n+too, instead of just compiler temporaries.  This may severely limit the\n+ability to debug an optimized program compiled with\n+@option{-fno-var-tracking-assignments}.  In the negated form, this flag\n+prevents SSA coalescing of user variables.  This option is enabled by\n+default if optimization is enabled.\n+\n @item -ftree-loop-if-convert\n @opindex ftree-loop-if-convert\n Attempt to transform conditional jumps in the innermost loops to\n@@ -8980,32 +8982,6 @@ Perform scalar replacement of aggregates.  This pass replaces structure\n references with scalars to prevent committing structures to memory too\n early.  This flag is enabled by default at @option{-O} and higher.\n \n-@item -ftree-copyrename\n-@opindex ftree-copyrename\n-Perform copy renaming on trees.  This pass attempts to rename compiler\n-temporaries to other variables at copy locations, usually resulting in\n-variable names which more closely resemble the original variables.  This flag\n-is enabled by default at @option{-O} and higher.\n-\n-@item -ftree-coalesce-inlined-vars\n-@opindex ftree-coalesce-inlined-vars\n-Tell the copyrename pass (see @option{-ftree-copyrename}) to attempt to\n-combine small user-defined variables too, but only if they are inlined\n-from other functions.  It is a more limited form of\n-@option{-ftree-coalesce-vars}.  This may harm debug information of such\n-inlined variables, but it keeps variables of the inlined-into\n-function apart from each other, such that they are more likely to\n-contain the expected values in a debugging session.\n-\n-@item -ftree-coalesce-vars\n-@opindex ftree-coalesce-vars\n-Tell the copyrename pass (see @option{-ftree-copyrename}) to attempt to\n-combine small user-defined variables too, instead of just compiler\n-temporaries.  This may severely limit the ability to debug an optimized\n-program compiled with @option{-fno-var-tracking-assignments}.  In the\n-negated form, this flag prevents SSA coalescing of user variables,\n-including inlined ones.  This option is enabled by default.\n-\n @item -ftree-ter\n @opindex ftree-ter\n Perform temporary expression replacement during the SSA->normal phase.  Single"}, {"sha": "a6ef154f3ded9f46007eec3f24e2826fbd132a94", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"builtins.h\"\n #include \"rtl-iter.h\"\n+#include \"stor-layout.h\"\n \n struct target_rtl default_target_rtl;\n #if SWITCHABLE_TARGET\n@@ -1233,6 +1234,9 @@ set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n void\n set_reg_attrs_for_decl_rtl (tree t, rtx x)\n {\n+  if (!t)\n+    return;\n+  tree tdecl = t;\n   if (GET_CODE (x) == SUBREG)\n     {\n       gcc_assert (subreg_lowpart_p (x));\n@@ -1241,7 +1245,9 @@ set_reg_attrs_for_decl_rtl (tree t, rtx x)\n   if (REG_P (x))\n     REG_ATTRS (x)\n       = get_reg_attrs (t, byte_lowpart_offset (GET_MODE (x),\n-\t\t\t\t\t       DECL_MODE (t)));\n+\t\t\t\t\t       DECL_P (tdecl)\n+\t\t\t\t\t       ? DECL_MODE (tdecl)\n+\t\t\t\t\t       : TYPE_MODE (TREE_TYPE (tdecl))));\n   if (GET_CODE (x) == CONCAT)\n     {\n       if (REG_P (XEXP (x, 0)))"}, {"sha": "6941f4e8ebc25ed54e282864dc88e97b55343278", "filename": "gcc/explow.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -842,6 +842,35 @@ promote_decl_mode (const_tree decl, int *punsignedp)\n   return pmode;\n }\n \n+/* Return the promoted mode for name.  If it is a named SSA_NAME, it\n+   is the same as promote_decl_mode.  Otherwise, it is the promoted\n+   mode of a temp decl of same type as the SSA_NAME, if we had created\n+   one.  */\n+\n+machine_mode\n+promote_ssa_mode (const_tree name, int *punsignedp)\n+{\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  /* Partitions holding parms and results must be promoted as expected\n+     by function.c.  */\n+  if (SSA_NAME_VAR (name)\n+      && (TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL\n+\t  || TREE_CODE (SSA_NAME_VAR (name)) == RESULT_DECL))\n+    return promote_decl_mode (SSA_NAME_VAR (name), punsignedp);\n+\n+  tree type = TREE_TYPE (name);\n+  int unsignedp = TYPE_UNSIGNED (type);\n+  machine_mode mode = TYPE_MODE (type);\n+\n+  machine_mode pmode = promote_mode (type, mode, &unsignedp);\n+  if (punsignedp)\n+    *punsignedp = unsignedp;\n+\n+  return pmode;\n+}\n+\n+\n \f\n /* Controls the behaviour of {anti_,}adjust_stack.  */\n static bool suppress_reg_args_size;"}, {"sha": "52113db716b01e2c1361ab48ed0d1d8caa33f4e2", "filename": "gcc/explow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -57,6 +57,9 @@ extern machine_mode promote_mode (const_tree, machine_mode, int *);\n /* Return mode and signedness to use when object is promoted.  */\n machine_mode promote_decl_mode (const_tree, int *);\n \n+/* Return mode and signedness to use when object is promoted.  */\n+machine_mode promote_ssa_mode (const_tree, int *);\n+\n /* Remove some bytes from the stack.  An rtx says how many.  */\n extern void adjust_stack (rtx);\n "}, {"sha": "f604f5251cfb93f2c34060dca65d9f0ea13fed5d", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -3022,7 +3022,7 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n /* Extract one of the components of the complex value CPLX.  Extract the\n    real part if IMAG_P is false, and the imaginary part if it's true.  */\n \n-static rtx\n+rtx\n read_complex_part (rtx cplx, bool imag_p)\n {\n   machine_mode cmode, imode;\n@@ -9236,7 +9236,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n   rtx op0, op1, temp, decl_rtl;\n   tree type;\n   int unsignedp;\n-  machine_mode mode;\n+  machine_mode mode, dmode;\n   enum tree_code code = TREE_CODE (exp);\n   rtx subtarget, original_target;\n   int ignore;\n@@ -9367,7 +9367,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       if (g == NULL\n \t  && modifier == EXPAND_INITIALIZER\n \t  && !SSA_NAME_IS_DEFAULT_DEF (exp)\n-\t  && (optimize || DECL_IGNORED_P (SSA_NAME_VAR (exp)))\n+\t  && (optimize || !SSA_NAME_VAR (exp)\n+\t      || DECL_IGNORED_P (SSA_NAME_VAR (exp)))\n \t  && stmt_is_replaceable_p (SSA_NAME_DEF_STMT (exp)))\n \tg = SSA_NAME_DEF_STMT (exp);\n       if (g)\n@@ -9446,15 +9447,18 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       /* Ensure variable marked as used even if it doesn't go through\n \t a parser.  If it hasn't be used yet, write out an external\n \t definition.  */\n-      TREE_USED (exp) = 1;\n+      if (exp)\n+\tTREE_USED (exp) = 1;\n \n       /* Show we haven't gotten RTL for this yet.  */\n       temp = 0;\n \n       /* Variables inherited from containing functions should have\n \t been lowered by this point.  */\n-      context = decl_function_context (exp);\n-      gcc_assert (SCOPE_FILE_SCOPE_P (context)\n+      if (exp)\n+\tcontext = decl_function_context (exp);\n+      gcc_assert (!exp\n+\t\t  || SCOPE_FILE_SCOPE_P (context)\n \t\t  || context == current_function_decl\n \t\t  || TREE_STATIC (exp)\n \t\t  || DECL_EXTERNAL (exp)\n@@ -9478,7 +9482,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t  decl_rtl = use_anchored_address (decl_rtl);\n \t  if (modifier != EXPAND_CONST_ADDRESS\n \t      && modifier != EXPAND_SUM\n-\t      && !memory_address_addr_space_p (DECL_MODE (exp),\n+\t      && !memory_address_addr_space_p (exp ? DECL_MODE (exp)\n+\t\t\t\t\t       : GET_MODE (decl_rtl),\n \t\t\t\t\t       XEXP (decl_rtl, 0),\n \t\t\t\t\t       MEM_ADDR_SPACE (decl_rtl)))\n \t    temp = replace_equiv_address (decl_rtl,\n@@ -9489,35 +9494,41 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t if the address is a register.  */\n       if (temp != 0)\n \t{\n-\t  if (MEM_P (temp) && REG_P (XEXP (temp, 0)))\n+\t  if (exp && MEM_P (temp) && REG_P (XEXP (temp, 0)))\n \t    mark_reg_pointer (XEXP (temp, 0), DECL_ALIGN (exp));\n \n \t  return temp;\n \t}\n \n+      if (exp)\n+\tdmode = DECL_MODE (exp);\n+      else\n+\tdmode = TYPE_MODE (TREE_TYPE (ssa_name));\n+\n       /* If the mode of DECL_RTL does not match that of the decl,\n \t there are two cases: we are dealing with a BLKmode value\n \t that is returned in a register, or we are dealing with\n \t a promoted value.  In the latter case, return a SUBREG\n \t of the wanted mode, but mark it so that we know that it\n \t was already extended.  */\n       if (REG_P (decl_rtl)\n-\t  && DECL_MODE (exp) != BLKmode\n-\t  && GET_MODE (decl_rtl) != DECL_MODE (exp))\n+\t  && dmode != BLKmode\n+\t  && GET_MODE (decl_rtl) != dmode)\n \t{\n \t  machine_mode pmode;\n \n \t  /* Get the signedness to be used for this variable.  Ensure we get\n \t     the same mode we got when the variable was declared.  */\n-\t  if (code == SSA_NAME\n-\t      && (g = SSA_NAME_DEF_STMT (ssa_name))\n-\t      && gimple_code (g) == GIMPLE_CALL\n-\t      && !gimple_call_internal_p (g))\n+\t  if (code != SSA_NAME)\n+\t    pmode = promote_decl_mode (exp, &unsignedp);\n+\t  else if ((g = SSA_NAME_DEF_STMT (ssa_name))\n+\t\t   && gimple_code (g) == GIMPLE_CALL\n+\t\t   && !gimple_call_internal_p (g))\n \t    pmode = promote_function_mode (type, mode, &unsignedp,\n \t\t\t\t\t   gimple_call_fntype (g),\n \t\t\t\t\t   2);\n \t  else\n-\t    pmode = promote_decl_mode (exp, &unsignedp);\n+\t    pmode = promote_ssa_mode (ssa_name, &unsignedp);\n \t  gcc_assert (GET_MODE (decl_rtl) == pmode);\n \n \t  temp = gen_lowpart_SUBREG (mode, decl_rtl);"}, {"sha": "a2c8e1d1e5797d0a28a6fb4e9c17b10916409034", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -210,6 +210,7 @@ extern rtx_insn *emit_move_insn_1 (rtx, rtx);\n \n extern rtx_insn *emit_move_complex_push (machine_mode, rtx, rtx);\n extern rtx_insn *emit_move_complex_parts (rtx, rtx);\n+extern rtx read_complex_part (rtx, bool);\n extern void write_complex_part (rtx, rtx, bool);\n extern rtx emit_move_resolve_push (machine_mode, rtx);\n "}, {"sha": "715c19f4ebc269fa14cd3c3eea79796af911b569", "filename": "gcc/function.c", "status": "modified", "additions": 281, "deletions": 60, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -72,6 +72,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfganal.h\"\n #include \"cfgbuild.h\"\n #include \"cfgcleanup.h\"\n+#include \"cfgexpand.h\"\n+#include \"basic-block.h\"\n+#include \"df.h\"\n #include \"params.h\"\n #include \"bb-reorder.h\"\n #include \"shrink-wrap.h\"\n@@ -148,6 +151,9 @@ static bool contains (const_rtx, hash_table<insn_cache_hasher> *);\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n+static rtx rtl_for_parm (struct assign_parm_data_all *, tree);\n+static void maybe_reset_rtl_for_parm (tree);\n+\n \f\n /* Stack of nested functions.  */\n /* Keep track of the cfun stack.  */\n@@ -2105,6 +2111,30 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n bool\n use_register_for_decl (const_tree decl)\n {\n+  if (TREE_CODE (decl) == SSA_NAME)\n+    {\n+      /* We often try to use the SSA_NAME, instead of its underlying\n+\t decl, to get type information and guide decisions, to avoid\n+\t differences of behavior between anonymous and named\n+\t variables, but in this one case we have to go for the actual\n+\t variable if there is one.  The main reason is that, at least\n+\t at -O0, we want to place user variables on the stack, but we\n+\t don't mind using pseudos for anonymous or ignored temps.\n+\t Should we take the SSA_NAME, we'd conclude all SSA_NAMEs\n+\t should go in pseudos, whereas their corresponding variables\n+\t might have to go on the stack.  So, disregarding the decl\n+\t here would negatively impact debug info at -O0, enable\n+\t coalescing between SSA_NAMEs that ought to get different\n+\t stack/pseudo assignments, and get the incoming argument\n+\t processing thoroughly confused by PARM_DECLs expected to live\n+\t in stack slots but assigned to pseudos.  */\n+      if (!SSA_NAME_VAR (decl))\n+\treturn TYPE_MODE (TREE_TYPE (decl)) != BLKmode\n+\t  && !(flag_float_store && FLOAT_TYPE_P (TREE_TYPE (decl)));\n+\n+      decl = SSA_NAME_VAR (decl);\n+    }\n+\n   /* Honor volatile.  */\n   if (TREE_SIDE_EFFECTS (decl))\n     return false;\n@@ -2240,7 +2270,7 @@ assign_parms_initialize_all (struct assign_parm_data_all *all)\n    needed, else the old list.  */\n \n static void\n-split_complex_args (vec<tree> *args)\n+split_complex_args (struct assign_parm_data_all *all, vec<tree> *args)\n {\n   unsigned i;\n   tree p;\n@@ -2251,6 +2281,7 @@ split_complex_args (vec<tree> *args)\n       if (TREE_CODE (type) == COMPLEX_TYPE\n \t  && targetm.calls.split_complex_arg (type))\n \t{\n+\t  tree cparm = p;\n \t  tree decl;\n \t  tree subtype = TREE_TYPE (type);\n \t  bool addressable = TREE_ADDRESSABLE (p);\n@@ -2269,6 +2300,9 @@ split_complex_args (vec<tree> *args)\n \t  DECL_ARTIFICIAL (p) = addressable;\n \t  DECL_IGNORED_P (p) = addressable;\n \t  TREE_ADDRESSABLE (p) = 0;\n+\t  /* Reset the RTL before layout_decl, or it may change the\n+\t     mode of the RTL of the original argument copied to P.  */\n+\t  SET_DECL_RTL (p, NULL_RTX);\n \t  layout_decl (p, 0);\n \t  (*args)[i] = p;\n \n@@ -2280,6 +2314,25 @@ split_complex_args (vec<tree> *args)\n \t  DECL_IGNORED_P (decl) = addressable;\n \t  layout_decl (decl, 0);\n \t  args->safe_insert (++i, decl);\n+\n+\t  /* If we are expanding a function, rather than gimplifying\n+\t     it, propagate the RTL of the complex parm to the split\n+\t     declarations, and set their contexts so that\n+\t     maybe_reset_rtl_for_parm can recognize them and refrain\n+\t     from resetting their RTL.  */\n+\t  if (currently_expanding_to_rtl)\n+\t    {\n+\t      maybe_reset_rtl_for_parm (cparm);\n+\t      rtx rtl = rtl_for_parm (all, cparm);\n+\t      if (rtl)\n+\t\t{\n+\t\t  SET_DECL_RTL (p, read_complex_part (rtl, false));\n+\t\t  SET_DECL_RTL (decl, read_complex_part (rtl, true));\n+\n+\t\t  DECL_CONTEXT (p) = cparm;\n+\t\t  DECL_CONTEXT (decl) = cparm;\n+\t\t}\n+\t    }\n \t}\n     }\n }\n@@ -2342,7 +2395,7 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n \n   /* If the target wants to split complex arguments into scalars, do so.  */\n   if (targetm.calls.split_complex_arg)\n-    split_complex_args (&fnargs);\n+    split_complex_args (all, &fnargs);\n \n   return fnargs;\n }\n@@ -2745,23 +2798,98 @@ assign_parm_remove_parallels (struct assign_parm_data_one *data)\n   data->entry_parm = entry_parm;\n }\n \n+/* Wrapper for use_register_for_decl, that special-cases the\n+   .result_ptr as the function's RESULT_DECL when the RESULT_DECL is\n+   passed by reference.  */\n+\n+static bool\n+use_register_for_parm_decl (struct assign_parm_data_all *all, tree parm)\n+{\n+  if (parm == all->function_result_decl)\n+    {\n+      tree result = DECL_RESULT (current_function_decl);\n+\n+      if (DECL_BY_REFERENCE (result))\n+\tparm = result;\n+    }\n+\n+  return use_register_for_decl (parm);\n+}\n+\n+/* Wrapper for get_rtl_for_parm_ssa_default_def, that special-cases\n+   the .result_ptr as the function's RESULT_DECL when the RESULT_DECL\n+   is passed by reference.  */\n+\n+static rtx\n+rtl_for_parm (struct assign_parm_data_all *all, tree parm)\n+{\n+  if (parm == all->function_result_decl)\n+    {\n+      tree result = DECL_RESULT (current_function_decl);\n+\n+      if (!DECL_BY_REFERENCE (result))\n+\treturn NULL_RTX;\n+\n+      parm = result;\n+    }\n+\n+  return get_rtl_for_parm_ssa_default_def (parm);\n+}\n+\n+/* Reset the location of PARM_DECLs and RESULT_DECLs that had\n+   SSA_NAMEs in multiple partitions, so that assign_parms will choose\n+   the default def, if it exists, or create new RTL to hold the unused\n+   entry value.  If we are coalescing across variables, we want to\n+   reset the location too, because a parm without a default def\n+   (incoming value unused) might be coalesced with one with a default\n+   def, and then assign_parms would copy both incoming values to the\n+   same location, which might cause the wrong value to survive.  */\n+static void\n+maybe_reset_rtl_for_parm (tree parm)\n+{\n+  gcc_assert (TREE_CODE (parm) == PARM_DECL\n+\t      || TREE_CODE (parm) == RESULT_DECL);\n+\n+  /* This is a split complex parameter, and its context was set to its\n+     original PARM_DECL in split_complex_args so that we could\n+     recognize it here and not reset its RTL.  */\n+  if (DECL_CONTEXT (parm) && TREE_CODE (DECL_CONTEXT (parm)) == PARM_DECL)\n+    {\n+      DECL_CONTEXT (parm) = DECL_CONTEXT (DECL_CONTEXT (parm));\n+      return;\n+    }\n+\n+  if ((flag_tree_coalesce_vars\n+       || (DECL_RTL_SET_P (parm) && DECL_RTL (parm) == pc_rtx))\n+      && is_gimple_reg (parm))\n+    SET_DECL_RTL (parm, NULL_RTX);\n+}\n+\n /* A subroutine of assign_parms.  Adjust DATA->STACK_RTL such that it's\n    always valid and properly aligned.  */\n \n static void\n-assign_parm_adjust_stack_rtl (struct assign_parm_data_one *data)\n+assign_parm_adjust_stack_rtl (struct assign_parm_data_all *all, tree parm,\n+\t\t\t      struct assign_parm_data_one *data)\n {\n   rtx stack_parm = data->stack_parm;\n \n+  /* If out-of-SSA assigned RTL to the parm default def, make sure we\n+     don't use what we might have computed before.  */\n+  rtx ssa_assigned = rtl_for_parm (all, parm);\n+  if (ssa_assigned)\n+    stack_parm = NULL;\n+\n   /* If we can't trust the parm stack slot to be aligned enough for its\n      ultimate type, don't use that slot after entry.  We'll make another\n      stack slot, if we need one.  */\n-  if (stack_parm\n-      && ((STRICT_ALIGNMENT\n-\t   && GET_MODE_ALIGNMENT (data->nominal_mode) > MEM_ALIGN (stack_parm))\n-\t  || (data->nominal_type\n-\t      && TYPE_ALIGN (data->nominal_type) > MEM_ALIGN (stack_parm)\n-\t      && MEM_ALIGN (stack_parm) < PREFERRED_STACK_BOUNDARY)))\n+  else if (stack_parm\n+\t   && ((STRICT_ALIGNMENT\n+\t\t&& (GET_MODE_ALIGNMENT (data->nominal_mode)\n+\t\t    > MEM_ALIGN (stack_parm)))\n+\t       || (data->nominal_type\n+\t\t   && TYPE_ALIGN (data->nominal_type) > MEM_ALIGN (stack_parm)\n+\t\t   && MEM_ALIGN (stack_parm) < PREFERRED_STACK_BOUNDARY)))\n     stack_parm = NULL;\n \n   /* If parm was passed in memory, and we need to convert it on entry,\n@@ -2823,14 +2951,32 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \n   size = int_size_in_bytes (data->passed_type);\n   size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n+\n   if (stack_parm == 0)\n     {\n       DECL_ALIGN (parm) = MAX (DECL_ALIGN (parm), BITS_PER_WORD);\n-      stack_parm = assign_stack_local (BLKmode, size_stored,\n-\t\t\t\t       DECL_ALIGN (parm));\n-      if (GET_MODE_SIZE (GET_MODE (entry_parm)) == size)\n-\tPUT_MODE (stack_parm, GET_MODE (entry_parm));\n-      set_mem_attributes (stack_parm, parm, 1);\n+      rtx from_expand = rtl_for_parm (all, parm);\n+      if (from_expand && (!parm_maybe_byref_p (parm)\n+\t\t\t  || XEXP (from_expand, 0) != NULL_RTX))\n+\tstack_parm = copy_rtx (from_expand);\n+      else\n+\t{\n+\t  stack_parm = assign_stack_local (BLKmode, size_stored,\n+\t\t\t\t\t   DECL_ALIGN (parm));\n+\t  if (GET_MODE_SIZE (GET_MODE (entry_parm)) == size)\n+\t    PUT_MODE (stack_parm, GET_MODE (entry_parm));\n+\t  if (from_expand)\n+\t    {\n+\t      gcc_assert (GET_CODE (stack_parm) == MEM);\n+\t      gcc_assert (GET_CODE (from_expand) == MEM);\n+\t      gcc_assert (XEXP (from_expand, 0) == NULL_RTX);\n+\t      XEXP (from_expand, 0) = XEXP (stack_parm, 0);\n+\t      PUT_MODE (from_expand, GET_MODE (stack_parm));\n+\t      stack_parm = copy_rtx (from_expand);\n+\t    }\n+\t  else\n+\t    set_mem_attributes (stack_parm, parm, 1);\n+\t}\n     }\n \n   /* If a BLKmode arrives in registers, copy it to a stack slot.  Handle\n@@ -2968,14 +3114,34 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n     = promote_function_mode (data->nominal_type, data->nominal_mode, &unsignedp,\n \t\t\t     TREE_TYPE (current_function_decl), 2);\n \n-  parmreg = gen_reg_rtx (promoted_nominal_mode);\n+  rtx from_expand = parmreg = rtl_for_parm (all, parm);\n \n-  if (!DECL_ARTIFICIAL (parm))\n-    mark_user_reg (parmreg);\n+  if (from_expand && !data->passed_pointer)\n+    {\n+      if (GET_MODE (parmreg) != promoted_nominal_mode)\n+\tparmreg = gen_lowpart (promoted_nominal_mode, parmreg);\n+    }\n+  else if (!from_expand || parm_maybe_byref_p (parm))\n+    {\n+      parmreg = gen_reg_rtx (promoted_nominal_mode);\n+      if (!DECL_ARTIFICIAL (parm))\n+\tmark_user_reg (parmreg);\n+\n+      if (from_expand)\n+\t{\n+\t  gcc_assert (data->passed_pointer);\n+\t  gcc_assert (GET_CODE (from_expand) == MEM\n+\t\t      && GET_MODE (from_expand) == BLKmode\n+\t\t      && XEXP (from_expand, 0) == NULL_RTX);\n+\t  XEXP (from_expand, 0) = parmreg;\n+\t}\n+    }\n \n   /* If this was an item that we received a pointer to,\n      set DECL_RTL appropriately.  */\n-  if (data->passed_pointer)\n+  if (from_expand)\n+    SET_DECL_RTL (parm, from_expand);\n+  else if (data->passed_pointer)\n     {\n       rtx x = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data->passed_type)), parmreg);\n       set_mem_attributes (x, parm, 1);\n@@ -2990,10 +3156,13 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n      assign_parm_find_data_types and expand_expr_real_1.  */\n \n   equiv_stack_parm = data->stack_parm;\n+  if (!equiv_stack_parm)\n+    equiv_stack_parm = data->entry_parm;\n   validated_mem = validize_mem (copy_rtx (data->entry_parm));\n \n   need_conversion = (data->nominal_mode != data->passed_mode\n \t\t     || promoted_nominal_mode != data->promoted_mode);\n+  gcc_assert (!(need_conversion && data->passed_pointer && from_expand));\n   moved = false;\n \n   if (need_conversion\n@@ -3125,16 +3294,28 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n       did_conversion = true;\n     }\n-  else\n+  /* We don't want to copy the incoming pointer to a parmreg expected\n+     to hold the value rather than the pointer.  */\n+  else if (!data->passed_pointer || parmreg != from_expand)\n     emit_move_insn (parmreg, validated_mem);\n \n   /* If we were passed a pointer but the actual value can safely live\n      in a register, retrieve it and use it directly.  */\n-  if (data->passed_pointer && TYPE_MODE (TREE_TYPE (parm)) != BLKmode)\n+  if (data->passed_pointer\n+      && (from_expand || TYPE_MODE (TREE_TYPE (parm)) != BLKmode))\n     {\n+      rtx src = DECL_RTL (parm);\n+\n       /* We can't use nominal_mode, because it will have been set to\n \t Pmode above.  We must use the actual mode of the parm.  */\n-      if (use_register_for_decl (parm))\n+      if (from_expand)\n+\t{\n+\t  parmreg = from_expand;\n+\t  gcc_assert (GET_MODE (parmreg) == TYPE_MODE (TREE_TYPE (parm)));\n+\t  src = gen_rtx_MEM (GET_MODE (parmreg), validated_mem);\n+\t  set_mem_attributes (src, parm, 1);\n+\t}\n+      else if (use_register_for_decl (parm))\n \t{\n \t  parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));\n \t  mark_user_reg (parmreg);\n@@ -3151,14 +3332,14 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  set_mem_attributes (parmreg, parm, 1);\n \t}\n \n-      if (GET_MODE (parmreg) != GET_MODE (DECL_RTL (parm)))\n+      if (GET_MODE (parmreg) != GET_MODE (src))\n \t{\n-\t  rtx tempreg = gen_reg_rtx (GET_MODE (DECL_RTL (parm)));\n+\t  rtx tempreg = gen_reg_rtx (GET_MODE (src));\n \t  int unsigned_p = TYPE_UNSIGNED (TREE_TYPE (parm));\n \n \t  push_to_sequence2 (all->first_conversion_insn,\n \t\t\t     all->last_conversion_insn);\n-\t  emit_move_insn (tempreg, DECL_RTL (parm));\n+\t  emit_move_insn (tempreg, src);\n \t  tempreg = convert_to_mode (GET_MODE (parmreg), tempreg, unsigned_p);\n \t  emit_move_insn (parmreg, tempreg);\n \t  all->first_conversion_insn = get_insns ();\n@@ -3167,14 +3348,16 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n \t  did_conversion = true;\n \t}\n+      else if (GET_MODE (parmreg) == BLKmode)\n+\tgcc_assert (parm_maybe_byref_p (parm));\n       else\n-\temit_move_insn (parmreg, DECL_RTL (parm));\n+\temit_move_insn (parmreg, src);\n \n       SET_DECL_RTL (parm, parmreg);\n \n       /* STACK_PARM is the pointer, not the parm, and PARMREG is\n \t now the parm.  */\n-      data->stack_parm = NULL;\n+      data->stack_parm = equiv_stack_parm = NULL;\n     }\n \n   /* Mark the register as eliminable if we did no conversion and it was\n@@ -3184,11 +3367,11 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n      make here would screw up life analysis for it.  */\n   if (data->nominal_mode == data->passed_mode\n       && !did_conversion\n-      && data->stack_parm != 0\n-      && MEM_P (data->stack_parm)\n+      && equiv_stack_parm != 0\n+      && MEM_P (equiv_stack_parm)\n       && data->locate.offset.var == 0\n       && reg_mentioned_p (virtual_incoming_args_rtx,\n-\t\t\t  XEXP (data->stack_parm, 0)))\n+\t\t\t  XEXP (equiv_stack_parm, 0)))\n     {\n       rtx_insn *linsn = get_last_insn ();\n       rtx_insn *sinsn;\n@@ -3201,8 +3384,8 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t    = GET_MODE_INNER (GET_MODE (parmreg));\n \t  int regnor = REGNO (XEXP (parmreg, 0));\n \t  int regnoi = REGNO (XEXP (parmreg, 1));\n-\t  rtx stackr = adjust_address_nv (data->stack_parm, submode, 0);\n-\t  rtx stacki = adjust_address_nv (data->stack_parm, submode,\n+\t  rtx stackr = adjust_address_nv (equiv_stack_parm, submode, 0);\n+\t  rtx stacki = adjust_address_nv (equiv_stack_parm, submode,\n \t\t\t\t\t  GET_MODE_SIZE (submode));\n \n \t  /* Scan backwards for the set of the real and\n@@ -3273,6 +3456,13 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n     {\n       rtx src, dest;\n \n+      if (data->stack_parm == 0)\n+\t{\n+\t  rtx x = data->stack_parm = rtl_for_parm (all, parm);\n+\t  if (x)\n+\t    gcc_assert (GET_MODE (x) == GET_MODE (data->entry_parm));\n+\t}\n+\n       if (data->stack_parm == 0)\n \t{\n \t  int align = STACK_SLOT_ALIGNMENT (data->passed_type,\n@@ -3337,11 +3527,21 @@ assign_parms_unsplit_complex (struct assign_parm_data_all *all,\n \t  imag = DECL_RTL (fnargs[i + 1]);\n \t  if (inner != GET_MODE (real))\n \t    {\n-\t      real = gen_lowpart_SUBREG (inner, real);\n-\t      imag = gen_lowpart_SUBREG (inner, imag);\n+\t      real = simplify_gen_subreg (inner, real, GET_MODE (real),\n+\t\t\t\t\t  subreg_lowpart_offset\n+\t\t\t\t\t  (inner, GET_MODE (real)));\n+\t      imag = simplify_gen_subreg (inner, imag, GET_MODE (imag),\n+\t\t\t\t\t  subreg_lowpart_offset\n+\t\t\t\t\t  (inner, GET_MODE (imag)));\n \t    }\n \n-\t  if (TREE_ADDRESSABLE (parm))\n+\t  if ((tmp = rtl_for_parm (all, parm)) != NULL_RTX\n+\t      && rtx_equal_p (real,\n+\t\t\t      read_complex_part (tmp, false))\n+\t      && rtx_equal_p (imag,\n+\t\t\t      read_complex_part (tmp, true)))\n+\t    ; /* We now have the right rtl in tmp.  */\n+\t  else if (TREE_ADDRESSABLE (parm))\n \t    {\n \t      rtx rmem, imem;\n \t      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (parm));\n@@ -3487,7 +3687,7 @@ assign_bounds (vec<bounds_parm_data> &bndargs,\n \t  assign_parm_setup_block (&all, pbdata->bounds_parm,\n \t\t\t\t   &pbdata->parm_data);\n \telse if (pbdata->parm_data.passed_pointer\n-\t\t || use_register_for_decl (pbdata->bounds_parm))\n+\t\t || use_register_for_parm_decl (&all, pbdata->bounds_parm))\n \t  assign_parm_setup_reg (&all, pbdata->bounds_parm,\n \t\t\t\t &pbdata->parm_data);\n \telse\n@@ -3531,6 +3731,8 @@ assign_parms (tree fndecl)\n \t  DECL_INCOMING_RTL (parm) = DECL_RTL (parm);\n \t  continue;\n \t}\n+      else\n+\tmaybe_reset_rtl_for_parm (parm);\n \n       /* Estimate stack alignment from parameter alignment.  */\n       if (SUPPORTS_STACK_ALIGNMENT)\n@@ -3580,7 +3782,9 @@ assign_parms (tree fndecl)\n       else\n \tset_decl_incoming_rtl (parm, data.entry_parm, false);\n \n-      /* Boudns should be loaded in the particular order to\n+      assign_parm_adjust_stack_rtl (&all, parm, &data);\n+\n+      /* Bounds should be loaded in the particular order to\n \t have registers allocated correctly.  Collect info about\n \t input bounds and load them later.  */\n       if (POINTER_BOUNDS_TYPE_P (data.passed_type))\n@@ -3597,11 +3801,10 @@ assign_parms (tree fndecl)\n \t}\n       else\n \t{\n-\t  assign_parm_adjust_stack_rtl (&data);\n-\n \t  if (assign_parm_setup_block_p (&data))\n \t    assign_parm_setup_block (&all, parm, &data);\n-\t  else if (data.passed_pointer || use_register_for_decl (parm))\n+\t  else if (data.passed_pointer\n+\t\t   || use_register_for_parm_decl (&all, parm))\n \t    assign_parm_setup_reg (&all, parm, &data);\n \t  else\n \t    assign_parm_setup_stack (&all, parm, &data);\n@@ -4932,15 +5135,17 @@ expand_function_start (tree subr)\n      before any library calls that assign parms might generate.  */\n \n   /* Decide whether to return the value in memory or in a register.  */\n-  if (aggregate_value_p (DECL_RESULT (subr), subr))\n+  tree res = DECL_RESULT (subr);\n+  maybe_reset_rtl_for_parm (res);\n+  if (aggregate_value_p (res, subr))\n     {\n       /* Returning something that won't go in a register.  */\n       rtx value_address = 0;\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n       if (cfun->returns_pcc_struct)\n \t{\n-\t  int size = int_size_in_bytes (TREE_TYPE (DECL_RESULT (subr)));\n+\t  int size = int_size_in_bytes (TREE_TYPE (res));\n \t  value_address = assemble_static_space (size);\n \t}\n       else\n@@ -4952,36 +5157,45 @@ expand_function_start (tree subr)\n \t     it.  */\n \t  if (sv)\n \t    {\n-\t      value_address = gen_reg_rtx (Pmode);\n+\t      if (DECL_BY_REFERENCE (res))\n+\t\tvalue_address = get_rtl_for_parm_ssa_default_def (res);\n+\t      if (!value_address)\n+\t\tvalue_address = gen_reg_rtx (Pmode);\n \t      emit_move_insn (value_address, sv);\n \t    }\n \t}\n       if (value_address)\n \t{\n \t  rtx x = value_address;\n-\t  if (!DECL_BY_REFERENCE (DECL_RESULT (subr)))\n+\t  if (!DECL_BY_REFERENCE (res))\n \t    {\n-\t      x = gen_rtx_MEM (DECL_MODE (DECL_RESULT (subr)), x);\n-\t      set_mem_attributes (x, DECL_RESULT (subr), 1);\n+\t      x = get_rtl_for_parm_ssa_default_def (res);\n+\t      if (!x)\n+\t\t{\n+\t\t  x = gen_rtx_MEM (DECL_MODE (res), value_address);\n+\t\t  set_mem_attributes (x, res, 1);\n+\t\t}\n \t    }\n-\t  SET_DECL_RTL (DECL_RESULT (subr), x);\n+\t  SET_DECL_RTL (res, x);\n \t}\n     }\n-  else if (DECL_MODE (DECL_RESULT (subr)) == VOIDmode)\n+  else if (DECL_MODE (res) == VOIDmode)\n     /* If return mode is void, this decl rtl should not be used.  */\n-    SET_DECL_RTL (DECL_RESULT (subr), NULL_RTX);\n+    SET_DECL_RTL (res, NULL_RTX);\n   else\n     {\n       /* Compute the return values into a pseudo reg, which we will copy\n \t into the true return register after the cleanups are done.  */\n-      tree return_type = TREE_TYPE (DECL_RESULT (subr));\n-      if (TYPE_MODE (return_type) != BLKmode\n-\t  && targetm.calls.return_in_msb (return_type))\n+      tree return_type = TREE_TYPE (res);\n+      rtx x = get_rtl_for_parm_ssa_default_def (res);\n+      if (x)\n+\t/* Use it.  */;\n+      else if (TYPE_MODE (return_type) != BLKmode\n+\t       && targetm.calls.return_in_msb (return_type))\n \t/* expand_function_end will insert the appropriate padding in\n \t   this case.  Use the return value's natural (unpadded) mode\n \t   within the function proper.  */\n-\tSET_DECL_RTL (DECL_RESULT (subr),\n-\t\t      gen_reg_rtx (TYPE_MODE (return_type)));\n+\tx = gen_reg_rtx (TYPE_MODE (return_type));\n       else\n \t{\n \t  /* In order to figure out what mode to use for the pseudo, we\n@@ -4992,25 +5206,26 @@ expand_function_start (tree subr)\n \t  /* Structures that are returned in registers are not\n \t     aggregate_value_p, so we may see a PARALLEL or a REG.  */\n \t  if (REG_P (hard_reg))\n-\t    SET_DECL_RTL (DECL_RESULT (subr),\n-\t\t\t  gen_reg_rtx (GET_MODE (hard_reg)));\n+\t    x = gen_reg_rtx (GET_MODE (hard_reg));\n \t  else\n \t    {\n \t      gcc_assert (GET_CODE (hard_reg) == PARALLEL);\n-\t      SET_DECL_RTL (DECL_RESULT (subr), gen_group_rtx (hard_reg));\n+\t      x = gen_group_rtx (hard_reg);\n \t    }\n \t}\n \n+      SET_DECL_RTL (res, x);\n+\n       /* Set DECL_REGISTER flag so that expand_function_end will copy the\n \t result to the real return register(s).  */\n-      DECL_REGISTER (DECL_RESULT (subr)) = 1;\n+      DECL_REGISTER (res) = 1;\n \n       if (chkp_function_instrumented_p (current_function_decl))\n \t{\n-\t  tree return_type = TREE_TYPE (DECL_RESULT (subr));\n+\t  tree return_type = TREE_TYPE (res);\n \t  rtx bounds = targetm.calls.chkp_function_value_bounds (return_type,\n \t\t\t\t\t\t\t\t subr, 1);\n-\t  SET_DECL_BOUNDS_RTL (DECL_RESULT (subr), bounds);\n+\t  SET_DECL_BOUNDS_RTL (res, bounds);\n \t}\n     }\n \n@@ -5025,13 +5240,19 @@ expand_function_start (tree subr)\n       rtx local, chain;\n      rtx_insn *insn;\n \n-      local = gen_reg_rtx (Pmode);\n+      local = get_rtl_for_parm_ssa_default_def (parm);\n+      if (!local)\n+\tlocal = gen_reg_rtx (Pmode);\n       chain = targetm.calls.static_chain (current_function_decl, true);\n \n       set_decl_incoming_rtl (parm, chain, false);\n       SET_DECL_RTL (parm, local);\n       mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n \n+      if (GET_MODE (local) != Pmode)\n+\tlocal = convert_to_mode (Pmode, local,\n+\t\t\t\t TYPE_UNSIGNED (TREE_TYPE (parm)));\n+\n       insn = emit_move_insn (local, chain);\n \n       /* Mark the register as eliminable, similar to parameters.  */"}, {"sha": "baed63011fa1b136f69e37070bbc870c647d3a3c", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -375,45 +375,6 @@ copy_var_decl (tree var, tree name, tree type)\n   return copy;\n }\n \n-/* Given SSA_NAMEs NAME1 and NAME2, return true if they are candidates for\n-   coalescing together, false otherwise.\n-\n-   This must stay consistent with var_map_base_init in tree-ssa-live.c.  */\n-\n-bool\n-gimple_can_coalesce_p (tree name1, tree name2)\n-{\n-  /* First check the SSA_NAME's associated DECL.  We only want to\n-     coalesce if they have the same DECL or both have no associated DECL.  */\n-  tree var1 = SSA_NAME_VAR (name1);\n-  tree var2 = SSA_NAME_VAR (name2);\n-  var1 = (var1 && (!VAR_P (var1) || !DECL_IGNORED_P (var1))) ? var1 : NULL_TREE;\n-  var2 = (var2 && (!VAR_P (var2) || !DECL_IGNORED_P (var2))) ? var2 : NULL_TREE;\n-  if (var1 != var2)\n-    return false;\n-\n-  /* Now check the types.  If the types are the same, then we should\n-     try to coalesce V1 and V2.  */\n-  tree t1 = TREE_TYPE (name1);\n-  tree t2 = TREE_TYPE (name2);\n-  if (t1 == t2)\n-    return true;\n-\n-  /* If the types are not the same, check for a canonical type match.  This\n-     (for example) allows coalescing when the types are fundamentally the\n-     same, but just have different names. \n-\n-     Note pointer types with different address spaces may have the same\n-     canonical type.  Those are rejected for coalescing by the\n-     types_compatible_p check.  */\n-  if (TYPE_CANONICAL (t1)\n-      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2)\n-      && types_compatible_p (t1, t2))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Strip off a legitimate source ending from the input string NAME of\n    length LEN.  Rather than having to know the names used by all of\n    our front ends, we strip off an ending of a period followed by"}, {"sha": "3d1c89ff371356e88007e315271a541e04455b51", "filename": "gcc/gimple-expr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -28,7 +28,6 @@ extern gimple_seq gimple_body (tree);\n extern bool gimple_has_body_p (tree);\n extern const char *gimple_decl_printable_name (tree, int);\n extern tree copy_var_decl (tree, tree, tree);\n-extern bool gimple_can_coalesce_p (tree, tree);\n extern tree create_tmp_var_name (const char *);\n extern tree create_tmp_var_raw (tree, const char * = NULL);\n extern tree create_tmp_var (tree, const char * = NULL);"}, {"sha": "32de605314fad1b24d52d688c0bb27487c4167a4", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -445,12 +445,12 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_1_PLUS, OPT_fsplit_wide_types, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_ccp, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_ftree_bit_ccp, NULL, 1 },\n+    { OPT_LEVELS_1_PLUS, OPT_ftree_coalesce_vars, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_dce, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_dominator_opts, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_dse, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_ter, NULL, 1 },\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_ftree_sra, NULL, 1 },\n-    { OPT_LEVELS_1_PLUS, OPT_ftree_copyrename, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_fre, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_copy_prop, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_sink, NULL, 1 },"}, {"sha": "64fc4d9e7892f773cc052f861e1dc86a61c9287b", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -77,7 +77,6 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_all_early_optimizations);\n       PUSH_INSERT_PASSES_WITHIN (pass_all_early_optimizations)\n \t  NEXT_PASS (pass_remove_cgraph_callee_edges);\n-\t  NEXT_PASS (pass_rename_ssa_copies);\n \t  NEXT_PASS (pass_object_sizes);\n \t  NEXT_PASS (pass_ccp);\n \t  /* After CCP we rewrite no longer addressed locals into SSA\n@@ -155,7 +154,6 @@ along with GCC; see the file COPYING3.  If not see\n       /* Initial scalar cleanups before alias computation.\n \t They ensure memory accesses are not indirect wherever possible.  */\n       NEXT_PASS (pass_strip_predict_hints);\n-      NEXT_PASS (pass_rename_ssa_copies);\n       NEXT_PASS (pass_ccp);\n       /* After CCP we rewrite no longer addressed locals into SSA\n \t form if possible.  */\n@@ -183,7 +181,6 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_ch);\n       NEXT_PASS (pass_lower_complex);\n       NEXT_PASS (pass_sra);\n-      NEXT_PASS (pass_rename_ssa_copies);\n       /* The dom pass will also resolve all __builtin_constant_p calls\n          that are still there to 0.  This has to be done after some\n \t propagations have already run, but before some more dead code\n@@ -293,7 +290,6 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_fold_builtins);\n       NEXT_PASS (pass_optimize_widening_mul);\n       NEXT_PASS (pass_tail_calls);\n-      NEXT_PASS (pass_rename_ssa_copies);\n       /* FIXME: If DCE is not run before checking for uninitialized uses,\n \t we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).\n \t However, this also causes us to misdiagnose cases that should be\n@@ -328,7 +324,6 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_dce);\n       NEXT_PASS (pass_asan);\n       NEXT_PASS (pass_tsan);\n-      NEXT_PASS (pass_rename_ssa_copies);\n       /* ???  We do want some kind of loop invariant motion, but we possibly\n          need to adjust LIM to be more friendly towards preserving accurate\n \t debug information here.  */"}, {"sha": "e7f7dd43e74ea014680266be0f96bfd24689c7ed", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -891,7 +891,7 @@ emit_case_decision_tree (tree index_expr, tree index_type,\n     {\n       index = copy_to_reg (index);\n       if (TREE_CODE (index_expr) == SSA_NAME)\n-\tset_reg_attrs_for_decl_rtl (SSA_NAME_VAR (index_expr), index);\n+\tset_reg_attrs_for_decl_rtl (index_expr, index);\n     }\n \n   balance_case_nodes (&case_list, NULL);"}, {"sha": "938e54b7c930a177d7c15f5d01358c8e621761f1", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -782,7 +782,8 @@ layout_decl (tree decl, unsigned int known_align)\n     {\n       PUT_MODE (rtl, DECL_MODE (decl));\n       SET_DECL_RTL (decl, 0);\n-      set_mem_attributes (rtl, decl, 1);\n+      if (MEM_P (rtl))\n+\tset_mem_attributes (rtl, decl, 1);\n       SET_DECL_RTL (decl, rtl);\n     }\n }"}, {"sha": "221a0ab257ef23b7fa17ee66d3074f34d9e4d437", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -1,3 +1,10 @@\n+2015-08-14  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* gcc.dg/guality/pr54200.c: Add -fno-tree-coalesce-vars.\n+\t* gcc.dg/ssp-1.c: Make counter a register.\n+\t* gcc.dg/ssp-2.c: Likewise.\n+\t* gcc.dg/torture/parm-coalesce.c: New.\n+\n 2015-08-14  Marek Polacek  <polacek@redhat.com>\n \n \tPR middle-end/67133"}, {"sha": "e1e729389626ad0e9ad80e24555c9a70f9d03c0b", "filename": "gcc/testsuite/gcc.dg/guality/pr54200.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr54200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr54200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr54200.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/54200 */\n /* { dg-do run } */\n-/* { dg-options \"-g -fno-var-tracking-assignments\" } */\n+/* { dg-options \"-g -fno-var-tracking-assignments -fno-tree-coalesce-vars\" } */\n \n int o __attribute__((used));\n "}, {"sha": "db693327f701e73f6b0a824bb298680b3651d871", "filename": "gcc/testsuite/gcc.dg/ssp-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Fssp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Fssp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fssp-1.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -12,7 +12,7 @@ __stack_chk_fail (void)\n \n int main ()\n {\n-  int i;\n+  register int i;\n   char foo[255];\n \n   // smash stack"}, {"sha": "752fe5393f4c66a57bc8b8dc8bc623fe2c1893ab", "filename": "gcc/testsuite/gcc.dg/ssp-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Fssp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Fssp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fssp-2.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -14,7 +14,7 @@ __stack_chk_fail (void)\n void\n overflow()\n {\n-  int i = 0;\n+  register int i = 0;\n   char foo[30];\n \n   /* Overflow buffer.  */"}, {"sha": "dbd81c1ba213f73e7556cc7ef9bd53e2c246765f", "filename": "gcc/testsuite/gcc.dg/torture/parm-coalesce.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fparm-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fparm-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fparm-coalesce.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+/* Make sure we don't coalesce both incoming parms, one whose incoming\n+   value is unused, to the same location, so as to overwrite one of\n+   them with the incoming value of the other.  */\n+\n+int __attribute__((noinline, noclone))\n+foo (int i, int j)\n+{\n+  j = i; /* The incoming value for J is unused.  */\n+  i = 2;\n+  if (j)\n+    j++;\n+  j += i + 1;\n+  return j;\n+}\n+\n+/* Same as foo, but with swapped parameters.  */\n+int __attribute__((noinline, noclone))\n+bar (int j, int i)\n+{\n+  j = i; /* The incoming value for J is unused.  */\n+  i = 2;\n+  if (j)\n+    j++;\n+  j += i + 1;\n+  return j;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo (0, 1) != 3)\n+    abort ();\n+  if (bar (1, 0) != 3)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "978476c913ce7f8a76dccfaeb526dfd7ec2d6b1b", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -279,7 +279,6 @@ insert_value_copy_on_edge (edge e, int dest, tree src, source_location locus)\n   rtx dest_rtx, seq, x;\n   machine_mode dest_mode, src_mode;\n   int unsignedp;\n-  tree var;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -301,12 +300,12 @@ insert_value_copy_on_edge (edge e, int dest, tree src, source_location locus)\n \n   start_sequence ();\n \n-  var = SSA_NAME_VAR (partition_to_var (SA.map, dest));\n+  tree name = partition_to_var (SA.map, dest);\n   src_mode = TYPE_MODE (TREE_TYPE (src));\n   dest_mode = GET_MODE (dest_rtx);\n-  gcc_assert (src_mode == TYPE_MODE (TREE_TYPE (var)));\n+  gcc_assert (src_mode == TYPE_MODE (TREE_TYPE (name)));\n   gcc_assert (!REG_P (dest_rtx)\n-\t      || dest_mode == promote_decl_mode (var, &unsignedp));\n+\t      || dest_mode == promote_ssa_mode (name, &unsignedp));\n \n   if (src_mode != dest_mode)\n     {\n@@ -682,13 +681,12 @@ elim_backward (elim_graph g, int T)\n static rtx\n get_temp_reg (tree name)\n {\n-  tree var = TREE_CODE (name) == SSA_NAME ? SSA_NAME_VAR (name) : name;\n-  tree type = TREE_TYPE (var);\n+  tree type = TREE_TYPE (name);\n   int unsignedp;\n-  machine_mode reg_mode = promote_decl_mode (var, &unsignedp);\n+  machine_mode reg_mode = promote_ssa_mode (name, &unsignedp);\n   rtx x = gen_reg_rtx (reg_mode);\n   if (POINTER_TYPE_P (type))\n-    mark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (var))));\n+    mark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (type)));\n   return x;\n }\n \n@@ -988,7 +986,7 @@ remove_ssa_form (bool perform_ter, struct ssaexpand *sa)\n \n   /* Return to viewing the variable list as just all reference variables after\n      coalescing has been performed.  */\n-  partition_view_normal (map, false);\n+  partition_view_normal (map);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "08ce72c79c069c4240a062a5e89dafaf2892032c", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 377, "deletions": 7, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -36,6 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-ssa-live.h\"\n #include \"tree-ssa-coalesce.h\"\n+#include \"cfgexpand.h\"\n+#include \"explow.h\"\n #include \"diagnostic-core.h\"\n \n \n@@ -806,6 +808,16 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n   basic_block bb;\n   ssa_op_iter iter;\n   live_track_p live;\n+  basic_block entry;\n+\n+  /* If inter-variable coalescing is enabled, we may attempt to\n+     coalesce variables from different base variables, including\n+     different parameters, so we have to make sure default defs live\n+     at the entry block conflict with each other.  */\n+  if (flag_tree_coalesce_vars)\n+    entry = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  else\n+    entry = NULL;\n \n   map = live_var_map (liveinfo);\n   graph = ssa_conflicts_new (num_var_partitions (map));\n@@ -864,6 +876,30 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n \t    live_track_process_def (live, result, graph);\n \t}\n \n+      /* Pretend there are defs for params' default defs at the start\n+\t of the (post-)entry block.  */\n+      if (bb == entry)\n+\t{\n+\t  unsigned base;\n+\t  bitmap_iterator bi;\n+\t  EXECUTE_IF_SET_IN_BITMAP (live->live_base_var, 0, base, bi)\n+\t    {\n+\t      bitmap_iterator bi2;\n+\t      unsigned part;\n+\t      EXECUTE_IF_SET_IN_BITMAP (live->live_base_partitions[base],\n+\t\t\t\t\t0, part, bi2)\n+\t\t{\n+\t\t  tree var = partition_to_var (map, part);\n+\t\t  if (!SSA_NAME_VAR (var)\n+\t\t      || (TREE_CODE (SSA_NAME_VAR (var)) != PARM_DECL\n+\t\t\t  && TREE_CODE (SSA_NAME_VAR (var)) != RESULT_DECL)\n+\t\t      || !SSA_NAME_IS_DEFAULT_DEF (var))\n+\t\t    continue;\n+\t\t  live_track_process_def (live, var, graph);\n+\t\t}\n+\t    }\n+\t}\n+\n      live_track_clear_base_vars (live);\n     }\n \n@@ -1132,6 +1168,7 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n     {\n       var1 = partition_to_var (map, p1);\n       var2 = partition_to_var (map, p2);\n+\n       z = var_union (map, var1, var2);\n       if (z == NO_PARTITION)\n \t{\n@@ -1149,6 +1186,7 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n \n       if (debug)\n \tfprintf (debug, \": Success -> %d\\n\", z);\n+\n       return true;\n     }\n \n@@ -1244,6 +1282,333 @@ ssa_name_var_hash::equal (const tree_node *n1, const tree_node *n2)\n }\n \n \n+/* Output partition map MAP with coalescing plan PART to file F.  */\n+\n+void\n+dump_part_var_map (FILE *f, partition part, var_map map)\n+{\n+  int t;\n+  unsigned x, y;\n+  int p;\n+\n+  fprintf (f, \"\\nCoalescible Partition map \\n\\n\");\n+\n+  for (x = 0; x < map->num_partitions; x++)\n+    {\n+      if (map->view_to_partition != NULL)\n+\tp = map->view_to_partition[x];\n+      else\n+\tp = x;\n+\n+      if (ssa_name (p) == NULL_TREE\n+\t  || virtual_operand_p (ssa_name (p)))\n+        continue;\n+\n+      t = 0;\n+      for (y = 1; y < num_ssa_names; y++)\n+        {\n+\t  tree var = version_to_var (map, y);\n+\t  if (!var)\n+\t    continue;\n+\t  int q = var_to_partition (map, var);\n+\t  p = partition_find (part, q);\n+\t  gcc_assert (map->partition_to_base_index[q]\n+\t\t      == map->partition_to_base_index[p]);\n+\n+\t  if (p == (int)x)\n+\t    {\n+\t      if (t++ == 0)\n+\t        {\n+\t\t  fprintf (f, \"Partition %d, base %d (\", x,\n+\t\t\t   map->partition_to_base_index[q]);\n+\t\t  print_generic_expr (f, partition_to_var (map, q), TDF_SLIM);\n+\t\t  fprintf (f, \" - \");\n+\t\t}\n+\t      fprintf (f, \"%d \", y);\n+\t    }\n+\t}\n+      if (t != 0)\n+\tfprintf (f, \")\\n\");\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n+/* Given SSA_NAMEs NAME1 and NAME2, return true if they are candidates for\n+   coalescing together, false otherwise.\n+\n+   This must stay consistent with var_map_base_init in tree-ssa-live.c.  */\n+\n+bool\n+gimple_can_coalesce_p (tree name1, tree name2)\n+{\n+  /* First check the SSA_NAME's associated DECL.  Without\n+     optimization, we only want to coalesce if they have the same DECL\n+     or both have no associated DECL.  */\n+  tree var1 = SSA_NAME_VAR (name1);\n+  tree var2 = SSA_NAME_VAR (name2);\n+  var1 = (var1 && (!VAR_P (var1) || !DECL_IGNORED_P (var1))) ? var1 : NULL_TREE;\n+  var2 = (var2 && (!VAR_P (var2) || !DECL_IGNORED_P (var2))) ? var2 : NULL_TREE;\n+  if (var1 != var2 && !flag_tree_coalesce_vars)\n+    return false;\n+\n+  /* Now check the types.  If the types are the same, then we should\n+     try to coalesce V1 and V2.  */\n+  tree t1 = TREE_TYPE (name1);\n+  tree t2 = TREE_TYPE (name2);\n+  if (t1 == t2)\n+    {\n+    check_modes:\n+      /* If the base variables are the same, we're good: none of the\n+\t other tests below could possibly fail.  */\n+      var1 = SSA_NAME_VAR (name1);\n+      var2 = SSA_NAME_VAR (name2);\n+      if (var1 == var2)\n+\treturn true;\n+\n+      /* We don't want to coalesce two SSA names if one of the base\n+\t variables is supposed to be a register while the other is\n+\t supposed to be on the stack.  Anonymous SSA names take\n+\t registers, but when not optimizing, user variables should go\n+\t on the stack, so coalescing them with the anonymous variable\n+\t as the partition leader would end up assigning the user\n+\t variable to a register.  Don't do that!  */\n+      bool reg1 = !var1 || use_register_for_decl (var1);\n+      bool reg2 = !var2 || use_register_for_decl (var2);\n+      if (reg1 != reg2)\n+\treturn false;\n+\n+      /* Check that the promoted modes are the same.  We don't want to\n+\t coalesce if the promoted modes would be different.  Only\n+\t PARM_DECLs and RESULT_DECLs have different promotion rules,\n+\t so skip the test if both are variables, or both are anonymous\n+\t SSA_NAMEs.  Now, if a parm or result has BLKmode, do not\n+\t coalesce its SSA versions with those of any other variables,\n+\t because it may be passed by reference.  */\n+      return ((!var1 || VAR_P (var1)) && (!var2 || VAR_P (var2)))\n+\t|| (/* The case var1 == var2 is already covered above.  */\n+\t    !parm_maybe_byref_p (var1)\n+\t    && !parm_maybe_byref_p (var2)\n+\t    && promote_ssa_mode (name1, NULL) == promote_ssa_mode (name2, NULL));\n+    }\n+\n+  /* If the types are not the same, check for a canonical type match.  This\n+     (for example) allows coalescing when the types are fundamentally the\n+     same, but just have different names. \n+\n+     Note pointer types with different address spaces may have the same\n+     canonical type.  Those are rejected for coalescing by the\n+     types_compatible_p check.  */\n+  if (TYPE_CANONICAL (t1)\n+      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2)\n+      && types_compatible_p (t1, t2))\n+    goto check_modes;\n+\n+  return false;\n+}\n+\n+/* Fill in MAP's partition_to_base_index, with one index for each\n+   partition of SSA names USED_IN_COPIES and related by CL coalesce\n+   possibilities.  This must match gimple_can_coalesce_p in the\n+   optimized case.  */\n+\n+static void\n+compute_optimized_partition_bases (var_map map, bitmap used_in_copies,\n+\t\t\t\t   coalesce_list_p cl)\n+{\n+  int parts = num_var_partitions (map);\n+  partition tentative = partition_new (parts);\n+\n+  /* Partition the SSA versions so that, for each coalescible\n+     pair, both of its members are in the same partition in\n+     TENTATIVE.  */\n+  gcc_assert (!cl->sorted);\n+  coalesce_pair_p node;\n+  coalesce_iterator_type ppi;\n+  FOR_EACH_PARTITION_PAIR (node, ppi, cl)\n+    {\n+      tree v1 = ssa_name (node->first_element);\n+      int p1 = partition_find (tentative, var_to_partition (map, v1));\n+      tree v2 = ssa_name (node->second_element);\n+      int p2 = partition_find (tentative, var_to_partition (map, v2));\n+\n+      if (p1 == p2)\n+\tcontinue;\n+\n+      partition_union (tentative, p1, p2);\n+    }\n+\n+  /* We have to deal with cost one pairs too.  */\n+  for (cost_one_pair_d *co = cl->cost_one_list; co; co = co->next)\n+    {\n+      tree v1 = ssa_name (co->first_element);\n+      int p1 = partition_find (tentative, var_to_partition (map, v1));\n+      tree v2 = ssa_name (co->second_element);\n+      int p2 = partition_find (tentative, var_to_partition (map, v2));\n+\n+      if (p1 == p2)\n+\tcontinue;\n+\n+      partition_union (tentative, p1, p2);\n+    }\n+\n+  /* And also with abnormal edges.  */\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  {\n+\t    gphi_iterator gsi;\n+\t    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t\t gsi_next (&gsi))\n+\t      {\n+\t\tgphi *phi = gsi.phi ();\n+\t\ttree arg = PHI_ARG_DEF (phi, e->dest_idx);\n+\t\tif (SSA_NAME_IS_DEFAULT_DEF (arg)\n+\t\t    && (!SSA_NAME_VAR (arg)\n+\t\t\t|| TREE_CODE (SSA_NAME_VAR (arg)) != PARM_DECL))\n+\t\t  continue;\n+\n+\t\ttree res = PHI_RESULT (phi);\n+\n+\t\tint p1 = partition_find (tentative, var_to_partition (map, res));\n+\t\tint p2 = partition_find (tentative, var_to_partition (map, arg));\n+\n+\t\tif (p1 == p2)\n+\t\t  continue;\n+\n+\t\tpartition_union (tentative, p1, p2);\n+\t      }\n+\t  }\n+    }\n+\n+  map->partition_to_base_index = XCNEWVEC (int, parts);\n+  auto_vec<unsigned int> index_map (parts);\n+  if (parts)\n+    index_map.quick_grow (parts);\n+\n+  const unsigned no_part = -1;\n+  unsigned count = parts;\n+  while (count)\n+    index_map[--count] = no_part;\n+\n+  /* Initialize MAP's mapping from partition to base index, using\n+     as base indices an enumeration of the TENTATIVE partitions in\n+     which each SSA version ended up, so that we compute conflicts\n+     between all SSA versions that ended up in the same potential\n+     coalesce partition.  */\n+  bitmap_iterator bi;\n+  unsigned i;\n+  EXECUTE_IF_SET_IN_BITMAP (used_in_copies, 0, i, bi)\n+    {\n+      int pidx = var_to_partition (map, ssa_name (i));\n+      int base = partition_find (tentative, pidx);\n+      if (index_map[base] != no_part)\n+\tcontinue;\n+      index_map[base] = count++;\n+    }\n+\n+  map->num_basevars = count;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (used_in_copies, 0, i, bi)\n+    {\n+      int pidx = var_to_partition (map, ssa_name (i));\n+      int base = partition_find (tentative, pidx);\n+      gcc_assert (index_map[base] < count);\n+      map->partition_to_base_index[pidx] = index_map[base];\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_part_var_map (dump_file, tentative, map);\n+\n+  partition_delete (tentative);\n+}\n+\n+/* Hashtable helpers.  */\n+\n+struct tree_int_map_hasher : nofree_ptr_hash <tree_int_map>\n+{\n+  static inline hashval_t hash (const tree_int_map *);\n+  static inline bool equal (const tree_int_map *, const tree_int_map *);\n+};\n+\n+inline hashval_t\n+tree_int_map_hasher::hash (const tree_int_map *v)\n+{\n+  return tree_map_base_hash (v);\n+}\n+\n+inline bool\n+tree_int_map_hasher::equal (const tree_int_map *v, const tree_int_map *c)\n+{\n+  return tree_int_map_eq (v, c);\n+}\n+\n+/* This routine will initialize the basevar fields of MAP with base\n+   names.  Partitions will share the same base if they have the same\n+   SSA_NAME_VAR, or, being anonymous variables, the same type.  This\n+   must match gimple_can_coalesce_p in the non-optimized case.  */\n+\n+static void\n+compute_samebase_partition_bases (var_map map)\n+{\n+  int x, num_part;\n+  tree var;\n+  struct tree_int_map *m, *mapstorage;\n+\n+  num_part = num_var_partitions (map);\n+  hash_table<tree_int_map_hasher> tree_to_index (num_part);\n+  /* We can have at most num_part entries in the hash tables, so it's\n+     enough to allocate so many map elements once, saving some malloc\n+     calls.  */\n+  mapstorage = m = XNEWVEC (struct tree_int_map, num_part);\n+\n+  /* If a base table already exists, clear it, otherwise create it.  */\n+  free (map->partition_to_base_index);\n+  map->partition_to_base_index = (int *) xmalloc (sizeof (int) * num_part);\n+\n+  /* Build the base variable list, and point partitions at their bases.  */\n+  for (x = 0; x < num_part; x++)\n+    {\n+      struct tree_int_map **slot;\n+      unsigned baseindex;\n+      var = partition_to_var (map, x);\n+      if (SSA_NAME_VAR (var)\n+\t  && (!VAR_P (SSA_NAME_VAR (var))\n+\t      || !DECL_IGNORED_P (SSA_NAME_VAR (var))))\n+\tm->base.from = SSA_NAME_VAR (var);\n+      else\n+\t/* This restricts what anonymous SSA names we can coalesce\n+\t   as it restricts the sets we compute conflicts for.\n+\t   Using TREE_TYPE to generate sets is the easies as\n+\t   type equivalency also holds for SSA names with the same\n+\t   underlying decl.\n+\n+\t   Check gimple_can_coalesce_p when changing this code.  */\n+\tm->base.from = (TYPE_CANONICAL (TREE_TYPE (var))\n+\t\t\t? TYPE_CANONICAL (TREE_TYPE (var))\n+\t\t\t: TREE_TYPE (var));\n+      /* If base variable hasn't been seen, set it up.  */\n+      slot = tree_to_index.find_slot (m, INSERT);\n+      if (!*slot)\n+\t{\n+\t  baseindex = m - mapstorage;\n+\t  m->to = baseindex;\n+\t  *slot = m;\n+\t  m++;\n+\t}\n+      else\n+\tbaseindex = (*slot)->to;\n+      map->partition_to_base_index[x] = baseindex;\n+    }\n+\n+  map->num_basevars = m - mapstorage;\n+\n+  free (mapstorage);\n+}\n+\n /* Reduce the number of copies by coalescing variables in the function.  Return\n    a partition map with the resulting coalesces.  */\n \n@@ -1260,9 +1625,10 @@ coalesce_ssa_name (void)\n   cl = create_coalesce_list ();\n   map = create_outofssa_var_map (cl, used_in_copies);\n \n-  /* If optimization is disabled, we need to coalesce all the names originating\n-     from the same SSA_NAME_VAR so debug info remains undisturbed.  */\n-  if (!optimize)\n+  /* If this optimization is disabled, we need to coalesce all the\n+     names originating from the same SSA_NAME_VAR so debug info\n+     remains undisturbed.  */\n+  if (!flag_tree_coalesce_vars)\n     {\n       hash_table<ssa_name_var_hash> ssa_name_hash (10);\n \n@@ -1303,8 +1669,13 @@ coalesce_ssa_name (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);\n \n-  /* Don't calculate live ranges for variables not in the coalesce list.  */\n-  partition_view_bitmap (map, used_in_copies, true);\n+  partition_view_bitmap (map, used_in_copies);\n+\n+  if (flag_tree_coalesce_vars)\n+    compute_optimized_partition_bases (map, used_in_copies, cl);\n+  else\n+    compute_samebase_partition_bases (map);\n+\n   BITMAP_FREE (used_in_copies);\n \n   if (num_var_partitions (map) < 1)\n@@ -1343,8 +1714,7 @@ coalesce_ssa_name (void)\n \n   /* Now coalesce everything in the list.  */\n   coalesce_partitions (map, graph, cl,\n-\t\t       ((dump_flags & TDF_DETAILS) ? dump_file\n-\t\t\t\t\t\t   : NULL));\n+\t\t       ((dump_flags & TDF_DETAILS) ? dump_file : NULL));\n \n   delete_coalesce_list (cl);\n   ssa_conflicts_delete (graph);"}, {"sha": "ae289b48d6e1ca0370d74fa12912d2f37f84c75f", "filename": "gcc/tree-ssa-coalesce.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-coalesce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-coalesce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.h?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -21,5 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SSA_COALESCE_H\n \n extern var_map coalesce_ssa_name (void);\n+extern bool gimple_can_coalesce_p (tree, tree);\n \n #endif /* GCC_TREE_SSA_COALESCE_H */"}, {"sha": "aeb7f28f03b6d745e59424f9a88211903aec2451", "filename": "gcc/tree-ssa-copyrename.c", "status": "removed", "additions": 0, "deletions": 475, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e90b6653961db45623895733bbeb9537bf5910/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e90b6653961db45623895733bbeb9537bf5910/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=d7e90b6653961db45623895733bbeb9537bf5910", "patch": "@@ -1,475 +0,0 @@\n-/* Rename SSA copies.\n-   Copyright (C) 2004-2015 Free Software Foundation, Inc.\n-   Contributed by Andrew MacLeod <amacleod@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"rtl.h\"\n-#include \"ssa.h\"\n-#include \"alias.h\"\n-#include \"fold-const.h\"\n-#include \"internal-fn.h\"\n-#include \"gimple-iterator.h\"\n-#include \"flags.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"insn-config.h\"\n-#include \"expmed.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"calls.h\"\n-#include \"emit-rtl.h\"\n-#include \"varasm.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n-#include \"tree-dfa.h\"\n-#include \"tree-inline.h\"\n-#include \"tree-ssa-live.h\"\n-#include \"tree-pass.h\"\n-#include \"langhooks.h\"\n-\n-static struct\n-{\n-  /* Number of copies coalesced.  */\n-  int coalesced;\n-} stats;\n-\n-/* The following routines implement the SSA copy renaming phase.\n-\n-   This optimization looks for copies between 2 SSA_NAMES, either through a\n-   direct copy, or an implicit one via a PHI node result and its arguments.\n-\n-   Each copy is examined to determine if it is possible to rename the base\n-   variable of one of the operands to the same variable as the other operand.\n-   i.e.\n-   T.3_5 = <blah>\n-   a_1 = T.3_5\n-\n-   If this copy couldn't be copy propagated, it could possibly remain in the\n-   program throughout the optimization phases.   After SSA->normal, it would\n-   become:\n-\n-   T.3 = <blah>\n-   a = T.3\n-\n-   Since T.3_5 is distinct from all other SSA versions of T.3, there is no\n-   fundamental reason why the base variable needs to be T.3, subject to\n-   certain restrictions.  This optimization attempts to determine if we can\n-   change the base variable on copies like this, and result in code such as:\n-\n-   a_5 = <blah>\n-   a_1 = a_5\n-\n-   This gives the SSA->normal pass a shot at coalescing a_1 and a_5. If it is\n-   possible, the copy goes away completely. If it isn't possible, a new temp\n-   will be created for a_5, and you will end up with the exact same code:\n-\n-   a.8 = <blah>\n-   a = a.8\n-\n-   The other benefit of performing this optimization relates to what variables\n-   are chosen in copies.  Gimplification of the program uses temporaries for\n-   a lot of things. expressions like\n-\n-   a_1 = <blah>\n-   <blah2> = a_1\n-\n-   get turned into\n-\n-   T.3_5 = <blah>\n-   a_1 = T.3_5\n-   <blah2> = a_1\n-\n-   Copy propagation is done in a forward direction, and if we can propagate\n-   through the copy, we end up with:\n-\n-   T.3_5 = <blah>\n-   <blah2> = T.3_5\n-\n-   The copy is gone, but so is all reference to the user variable 'a'. By\n-   performing this optimization, we would see the sequence:\n-\n-   a_5 = <blah>\n-   a_1 = a_5\n-   <blah2> = a_1\n-\n-   which copy propagation would then turn into:\n-\n-   a_5 = <blah>\n-   <blah2> = a_5\n-\n-   and so we still retain the user variable whenever possible.  */\n-\n-\n-/* Coalesce the partitions in MAP representing VAR1 and VAR2 if it is valid.\n-   Choose a representative for the partition, and send debug info to DEBUG.  */\n-\n-static void\n-copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n-{\n-  int p1, p2, p3;\n-  tree root1, root2;\n-  tree rep1, rep2;\n-  bool ign1, ign2, abnorm;\n-\n-  gcc_assert (TREE_CODE (var1) == SSA_NAME);\n-  gcc_assert (TREE_CODE (var2) == SSA_NAME);\n-\n-  register_ssa_partition (map, var1);\n-  register_ssa_partition (map, var2);\n-\n-  p1 = partition_find (map->var_partition, SSA_NAME_VERSION (var1));\n-  p2 = partition_find (map->var_partition, SSA_NAME_VERSION (var2));\n-\n-  if (debug)\n-    {\n-      fprintf (debug, \"Try : \");\n-      print_generic_expr (debug, var1, TDF_SLIM);\n-      fprintf (debug, \"(P%d) & \", p1);\n-      print_generic_expr (debug, var2, TDF_SLIM);\n-      fprintf (debug, \"(P%d)\", p2);\n-    }\n-\n-  gcc_assert (p1 != NO_PARTITION);\n-  gcc_assert (p2 != NO_PARTITION);\n-\n-  if (p1 == p2)\n-    {\n-      if (debug)\n-\tfprintf (debug, \" : Already coalesced.\\n\");\n-      return;\n-    }\n-\n-  rep1 = partition_to_var (map, p1);\n-  rep2 = partition_to_var (map, p2);\n-  root1 = SSA_NAME_VAR (rep1);\n-  root2 = SSA_NAME_VAR (rep2);\n-  if (!root1 && !root2)\n-    return;\n-\n-  /* Don't coalesce if one of the variables occurs in an abnormal PHI.  */\n-  abnorm = (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rep1)\n-\t    || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rep2));\n-  if (abnorm)\n-    {\n-      if (debug)\n-\tfprintf (debug, \" : Abnormal PHI barrier.  No coalesce.\\n\");\n-      return;\n-    }\n-\n-  /* Partitions already have the same root, simply merge them.  */\n-  if (root1 == root2)\n-    {\n-      p1 = partition_union (map->var_partition, p1, p2);\n-      if (debug)\n-\tfprintf (debug, \" : Same root, coalesced --> P%d.\\n\", p1);\n-      return;\n-    }\n-\n-  /* Never attempt to coalesce 2 different parameters.  */\n-  if ((root1 && TREE_CODE (root1) == PARM_DECL)\n-      && (root2 && TREE_CODE (root2) == PARM_DECL))\n-    {\n-      if (debug)\n-        fprintf (debug, \" : 2 different PARM_DECLS. No coalesce.\\n\");\n-      return;\n-    }\n-\n-  if ((root1 && TREE_CODE (root1) == RESULT_DECL)\n-      != (root2 && TREE_CODE (root2) == RESULT_DECL))\n-    {\n-      if (debug)\n-        fprintf (debug, \" : One root a RESULT_DECL. No coalesce.\\n\");\n-      return;\n-    }\n-\n-  ign1 = !root1 || (TREE_CODE (root1) == VAR_DECL && DECL_IGNORED_P (root1));\n-  ign2 = !root2 || (TREE_CODE (root2) == VAR_DECL && DECL_IGNORED_P (root2));\n-\n-  /* Refrain from coalescing user variables, if requested.  */\n-  if (!ign1 && !ign2)\n-    {\n-      if (flag_ssa_coalesce_vars && DECL_FROM_INLINE (root2))\n-\tign2 = true;\n-      else if (flag_ssa_coalesce_vars && DECL_FROM_INLINE (root1))\n-\tign1 = true;\n-      else if (flag_ssa_coalesce_vars != 2)\n-\t{\n-\t  if (debug)\n-\t    fprintf (debug, \" : 2 different USER vars. No coalesce.\\n\");\n-\t  return;\n-\t}\n-      else\n-\tign2 = true;\n-    }\n-\n-  /* If both values have default defs, we can't coalesce.  If only one has a\n-     tag, make sure that variable is the new root partition.  */\n-  if (root1 && ssa_default_def (cfun, root1))\n-    {\n-      if (root2 && ssa_default_def (cfun, root2))\n-\t{\n-\t  if (debug)\n-\t    fprintf (debug, \" : 2 default defs. No coalesce.\\n\");\n-\t  return;\n-\t}\n-      else\n-        {\n-\t  ign2 = true;\n-\t  ign1 = false;\n-\t}\n-    }\n-  else if (root2 && ssa_default_def (cfun, root2))\n-    {\n-      ign1 = true;\n-      ign2 = false;\n-    }\n-\n-  /* Do not coalesce if we cannot assign a symbol to the partition.  */\n-  if (!(!ign2 && root2)\n-      && !(!ign1 && root1))\n-    {\n-      if (debug)\n-\tfprintf (debug, \" : Choosen variable has no root.  No coalesce.\\n\");\n-      return;\n-    }\n-\n-  /* Don't coalesce if the new chosen root variable would be read-only.\n-     If both ign1 && ign2, then the root var of the larger partition\n-     wins, so reject in that case if any of the root vars is TREE_READONLY.\n-     Otherwise reject only if the root var, on which replace_ssa_name_symbol\n-     will be called below, is readonly.  */\n-  if (((root1 && TREE_READONLY (root1)) && ign2)\n-      || ((root2 && TREE_READONLY (root2)) && ign1))\n-    {\n-      if (debug)\n-\tfprintf (debug, \" : Readonly variable.  No coalesce.\\n\");\n-      return;\n-    }\n-\n-  /* Don't coalesce if the two variables aren't type compatible .  */\n-  if (!types_compatible_p (TREE_TYPE (var1), TREE_TYPE (var2))\n-      /* There is a disconnect between the middle-end type-system and\n-         VRP, avoid coalescing enum types with different bounds.  */\n-      || ((TREE_CODE (TREE_TYPE (var1)) == ENUMERAL_TYPE\n-\t   || TREE_CODE (TREE_TYPE (var2)) == ENUMERAL_TYPE)\n-\t  && TREE_TYPE (var1) != TREE_TYPE (var2)))\n-    {\n-      if (debug)\n-\tfprintf (debug, \" : Incompatible types.  No coalesce.\\n\");\n-      return;\n-    }\n-\n-  /* Merge the two partitions.  */\n-  p3 = partition_union (map->var_partition, p1, p2);\n-\n-  /* Set the root variable of the partition to the better choice, if there is\n-     one.  */\n-  if (!ign2 && root2)\n-    replace_ssa_name_symbol (partition_to_var (map, p3), root2);\n-  else if (!ign1 && root1)\n-    replace_ssa_name_symbol (partition_to_var (map, p3), root1);\n-  else\n-    gcc_unreachable ();\n-\n-  if (debug)\n-    {\n-      fprintf (debug, \" --> P%d \", p3);\n-      print_generic_expr (debug, SSA_NAME_VAR (partition_to_var (map, p3)),\n-\t\t\t  TDF_SLIM);\n-      fprintf (debug, \"\\n\");\n-    }\n-}\n-\n-\n-namespace {\n-\n-const pass_data pass_data_rename_ssa_copies =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"copyrename\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_COPY_RENAME, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_rename_ssa_copies : public gimple_opt_pass\n-{\n-public:\n-  pass_rename_ssa_copies (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_rename_ssa_copies, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_rename_ssa_copies (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_copyrename != 0; }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_rename_ssa_copies\n-\n-/* This function will make a pass through the IL, and attempt to coalesce any\n-   SSA versions which occur in PHI's or copies.  Coalescing is accomplished by\n-   changing the underlying root variable of all coalesced version.  This will\n-   then cause the SSA->normal pass to attempt to coalesce them all to the same\n-   variable.  */\n-\n-unsigned int\n-pass_rename_ssa_copies::execute (function *fun)\n-{\n-  var_map map;\n-  basic_block bb;\n-  tree var, part_var;\n-  gimple stmt;\n-  unsigned x;\n-  FILE *debug;\n-\n-  memset (&stats, 0, sizeof (stats));\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    debug = dump_file;\n-  else\n-    debug = NULL;\n-\n-  map = init_var_map (num_ssa_names);\n-\n-  FOR_EACH_BB_FN (bb, fun)\n-    {\n-      /* Scan for real copies.  */\n-      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n-\t   gsi_next (&gsi))\n-\t{\n-\t  stmt = gsi_stmt (gsi);\n-\t  if (gimple_assign_ssa_name_copy_p (stmt))\n-\t    {\n-\t      tree lhs = gimple_assign_lhs (stmt);\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\n-\t      copy_rename_partition_coalesce (map, lhs, rhs, debug);\n-\t    }\n-\t}\n-    }\n-\n-  FOR_EACH_BB_FN (bb, fun)\n-    {\n-      /* Treat PHI nodes as copies between the result and each argument.  */\n-      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n-\t   gsi_next (&gsi))\n-        {\n-          size_t i;\n-\t  tree res;\n-\t  gphi *phi = gsi.phi ();\n-\t  res = gimple_phi_result (phi);\n-\n-\t  /* Do not process virtual SSA_NAMES.  */\n-\t  if (virtual_operand_p (res))\n-\t    continue;\n-\n-\t  /* Make sure to only use the same partition for an argument\n-\t     as the result but never the other way around.  */\n-\t  if (SSA_NAME_VAR (res)\n-\t      && !DECL_IGNORED_P (SSA_NAME_VAR (res)))\n-\t    for (i = 0; i < gimple_phi_num_args (phi); i++)\n-\t      {\n-\t\ttree arg = PHI_ARG_DEF (phi, i);\n-\t\tif (TREE_CODE (arg) == SSA_NAME)\n-\t\t  copy_rename_partition_coalesce (map, res, arg,\n-\t\t\t\t\t\t  debug);\n-\t      }\n-\t  /* Else if all arguments are in the same partition try to merge\n-\t     it with the result.  */\n-\t  else\n-\t    {\n-\t      int all_p_same = -1;\n-\t      int p = -1;\n-\t      for (i = 0; i < gimple_phi_num_args (phi); i++)\n-\t\t{\n-\t\t  tree arg = PHI_ARG_DEF (phi, i);\n-\t\t  if (TREE_CODE (arg) != SSA_NAME)\n-\t\t    {\n-\t\t      all_p_same = 0;\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (all_p_same == -1)\n-\t\t    {\n-\t\t      p = partition_find (map->var_partition,\n-\t\t\t\t\t  SSA_NAME_VERSION (arg));\n-\t\t      all_p_same = 1;\n-\t\t    }\n-\t\t  else if (all_p_same == 1\n-\t\t\t   && p != partition_find (map->var_partition,\n-\t\t\t\t\t\t   SSA_NAME_VERSION (arg)))\n-\t\t    {\n-\t\t      all_p_same = 0;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (all_p_same == 1)\n-\t\tcopy_rename_partition_coalesce (map, res,\n-\t\t\t\t\t\tPHI_ARG_DEF (phi, 0),\n-\t\t\t\t\t\tdebug);\n-\t    }\n-        }\n-    }\n-\n-  if (debug)\n-    dump_var_map (debug, map);\n-\n-  /* Now one more pass to make all elements of a partition share the same\n-     root variable.  */\n-\n-  for (x = 1; x < num_ssa_names; x++)\n-    {\n-      part_var = partition_to_var (map, x);\n-      if (!part_var)\n-        continue;\n-      var = ssa_name (x);\n-      if (SSA_NAME_VAR (var) == SSA_NAME_VAR (part_var))\n-\tcontinue;\n-      if (debug)\n-        {\n-\t  fprintf (debug, \"Coalesced \");\n-\t  print_generic_expr (debug, var, TDF_SLIM);\n-\t  fprintf (debug, \" to \");\n-\t  print_generic_expr (debug, part_var, TDF_SLIM);\n-\t  fprintf (debug, \"\\n\");\n-\t}\n-      stats.coalesced++;\n-      replace_ssa_name_symbol (var, SSA_NAME_VAR (part_var));\n-    }\n-\n-  statistics_counter_event (fun, \"copies coalesced\",\n-\t\t\t    stats.coalesced);\n-  delete_var_map (map);\n-  return 0;\n-}\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_rename_ssa_copies (gcc::context *ctxt)\n-{\n-  return new pass_rename_ssa_copies (ctxt);\n-}"}, {"sha": "47725585be9f870177385ca3a226b98a6cabb360", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 5, "deletions": 94, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -70,88 +70,6 @@ static void  verify_live_on_entry (tree_live_info_p);\n    ssa_name or variable, and vice versa.  */\n \n \n-/* Hashtable helpers.  */\n-\n-struct tree_int_map_hasher : nofree_ptr_hash <tree_int_map>\n-{\n-  static inline hashval_t hash (const tree_int_map *);\n-  static inline bool equal (const tree_int_map *, const tree_int_map *);\n-};\n-\n-inline hashval_t\n-tree_int_map_hasher::hash (const tree_int_map *v)\n-{\n-  return tree_map_base_hash (v);\n-}\n-\n-inline bool\n-tree_int_map_hasher::equal (const tree_int_map *v, const tree_int_map *c)\n-{\n-  return tree_int_map_eq (v, c);\n-}\n-\n-\n-/* This routine will initialize the basevar fields of MAP.  */\n-\n-static void\n-var_map_base_init (var_map map)\n-{\n-  int x, num_part;\n-  tree var;\n-  struct tree_int_map *m, *mapstorage;\n-\n-  num_part = num_var_partitions (map);\n-  hash_table<tree_int_map_hasher> tree_to_index (num_part);\n-  /* We can have at most num_part entries in the hash tables, so it's\n-     enough to allocate so many map elements once, saving some malloc\n-     calls.  */\n-  mapstorage = m = XNEWVEC (struct tree_int_map, num_part);\n-\n-  /* If a base table already exists, clear it, otherwise create it.  */\n-  free (map->partition_to_base_index);\n-  map->partition_to_base_index = (int *) xmalloc (sizeof (int) * num_part);\n-\n-  /* Build the base variable list, and point partitions at their bases.  */\n-  for (x = 0; x < num_part; x++)\n-    {\n-      struct tree_int_map **slot;\n-      unsigned baseindex;\n-      var = partition_to_var (map, x);\n-      if (SSA_NAME_VAR (var)\n-\t  && (!VAR_P (SSA_NAME_VAR (var))\n-\t      || !DECL_IGNORED_P (SSA_NAME_VAR (var))))\n-\tm->base.from = SSA_NAME_VAR (var);\n-      else\n-\t/* This restricts what anonymous SSA names we can coalesce\n-\t   as it restricts the sets we compute conflicts for.\n-\t   Using TREE_TYPE to generate sets is the easies as\n-\t   type equivalency also holds for SSA names with the same\n-\t   underlying decl. \n-\n-\t   Check gimple_can_coalesce_p when changing this code.  */\n-\tm->base.from = (TYPE_CANONICAL (TREE_TYPE (var))\n-\t\t\t? TYPE_CANONICAL (TREE_TYPE (var))\n-\t\t\t: TREE_TYPE (var));\n-      /* If base variable hasn't been seen, set it up.  */\n-      slot = tree_to_index.find_slot (m, INSERT);\n-      if (!*slot)\n-\t{\n-\t  baseindex = m - mapstorage;\n-\t  m->to = baseindex;\n-\t  *slot = m;\n-\t  m++;\n-\t}\n-      else\n-\tbaseindex = (*slot)->to;\n-      map->partition_to_base_index[x] = baseindex;\n-    }\n-\n-  map->num_basevars = m - mapstorage;\n-\n-  free (mapstorage);\n-}\n-\n-\n /* Remove the base table in MAP.  */\n \n static void\n@@ -329,21 +247,17 @@ partition_view_fini (var_map map, bitmap selected)\n }\n \n \n-/* Create a partition view which includes all the used partitions in MAP.  If\n-   WANT_BASES is true, create the base variable map as well.  */\n+/* Create a partition view which includes all the used partitions in MAP.  */\n \n void\n-partition_view_normal (var_map map, bool want_bases)\n+partition_view_normal (var_map map)\n {\n   bitmap used;\n \n   used = partition_view_init (map);\n   partition_view_fini (map, used);\n \n-  if (want_bases)\n-    var_map_base_init (map);\n-  else\n-    var_map_base_fini (map);\n+  var_map_base_fini (map);\n }\n \n \n@@ -352,7 +266,7 @@ partition_view_normal (var_map map, bool want_bases)\n    as well.  */\n \n void\n-partition_view_bitmap (var_map map, bitmap only, bool want_bases)\n+partition_view_bitmap (var_map map, bitmap only)\n {\n   bitmap used;\n   bitmap new_partitions = BITMAP_ALLOC (NULL);\n@@ -368,10 +282,7 @@ partition_view_bitmap (var_map map, bitmap only, bool want_bases)\n     }\n   partition_view_fini (map, new_partitions);\n \n-  if (want_bases)\n-    var_map_base_init (map);\n-  else\n-    var_map_base_fini (map);\n+  var_map_base_fini (map);\n }\n \n "}, {"sha": "1f88358add0c9960c1504a0c4882024a22bcf635", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -71,8 +71,8 @@ typedef struct _var_map\n extern var_map init_var_map (int);\n extern void delete_var_map (var_map);\n extern int var_union (var_map, tree, tree);\n-extern void partition_view_normal (var_map, bool);\n-extern void partition_view_bitmap (var_map, bitmap, bool);\n+extern void partition_view_normal (var_map);\n+extern void partition_view_bitmap (var_map, bitmap);\n extern void dump_scope_blocks (FILE *, int);\n extern void debug_scope_block (tree, int);\n extern void debug_scope_blocks (int);"}, {"sha": "1fbd71ef483be798ae6a578247831de72706d8c9", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -38,6 +38,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"tree-hash-traits.h\"\n+#include \"bitmap.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssanames.h\"\n+#include \"tree-ssa-live.h\"\n+#include \"tree-ssa-coalesce.h\"\n \n /* The basic structure describing an equivalency created by traversing\n    an edge.  Traversing the edge effectively means that we can assume"}, {"sha": "a31a1376007ff72cfdeefc367eb74deeb60f66b6", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f9ceff11132bb256260ce0501c6d14f2d0fc650/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=1f9ceff11132bb256260ce0501c6d14f2d0fc650", "patch": "@@ -4856,12 +4856,16 @@ dataflow_set_remove_mem_locs (variable_def **slot, dataflow_set *set)\n    registers, as well as associations between MEMs and VALUEs.  */\n \n static void\n-dataflow_set_clear_at_call (dataflow_set *set)\n+dataflow_set_clear_at_call (dataflow_set *set, rtx_insn *call_insn)\n {\n   unsigned int r;\n   hard_reg_set_iterator hrsi;\n+  HARD_REG_SET invalidated_regs;\n \n-  EXECUTE_IF_SET_IN_HARD_REG_SET (regs_invalidated_by_call, 0, r, hrsi)\n+  get_call_reg_set_usage (call_insn, &invalidated_regs,\n+\t\t\t  regs_invalidated_by_call);\n+\n+  EXECUTE_IF_SET_IN_HARD_REG_SET (invalidated_regs, 0, r, hrsi)\n     var_regno_delete (set, r);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n@@ -6645,7 +6649,7 @@ compute_bb_dataflow (basic_block bb)\n       switch (mo->type)\n \t{\n \t  case MO_CALL:\n-\t    dataflow_set_clear_at_call (out);\n+\t    dataflow_set_clear_at_call (out, insn);\n \t    break;\n \n \t  case MO_USE:\n@@ -9107,7 +9111,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n       switch (mo->type)\n \t{\n \t  case MO_CALL:\n-\t    dataflow_set_clear_at_call (set);\n+\t    dataflow_set_clear_at_call (set, insn);\n \t    emit_notes_for_changes (insn, EMIT_NOTE_AFTER_CALL_INSN, set->vars);\n \t    {\n \t      rtx arguments = mo->u.loc, *p = &arguments;"}]}