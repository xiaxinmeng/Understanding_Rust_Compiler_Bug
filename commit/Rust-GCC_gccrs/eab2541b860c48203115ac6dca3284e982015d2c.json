{"sha": "eab2541b860c48203115ac6dca3284e982015d2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFiMjU0MWI4NjBjNDgyMDMxMTVhYzZkY2EzMjg0ZTk4MjAxNWQyYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-03-01T23:12:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-03-01T23:12:10Z"}, "message": "re PR tree-optimization/69196 (code size regression with jump threading at -O2)\n\n\tPR tree-optimization/69196\n\t* tree-ssa-threadbackward.c (fsm_find_control_statement_thread_paths):\n\tAppropriately clamp the number of statements to copy when the\n\tthread path does not traverse a loop backedge.\n\n\tPR tree-optimization/69196\n\t* gcc.dg/tree-ssa/pr69196.c: New test.\n\nFrom-SVN: r233870", "tree": {"sha": "48b5cf44ccfa93c5f48324a74c4d329401120df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48b5cf44ccfa93c5f48324a74c4d329401120df3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eab2541b860c48203115ac6dca3284e982015d2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab2541b860c48203115ac6dca3284e982015d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab2541b860c48203115ac6dca3284e982015d2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab2541b860c48203115ac6dca3284e982015d2c/comments", "author": null, "committer": null, "parents": [{"sha": "0bca04b822bc5ee0f5bbb2ba5df6669a433d0bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bca04b822bc5ee0f5bbb2ba5df6669a433d0bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bca04b822bc5ee0f5bbb2ba5df6669a433d0bf5"}], "stats": {"total": 166, "additions": 166, "deletions": 0}, "files": [{"sha": "88f0806ac52e17be70a55e2505b2d17c2ca7d28c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eab2541b860c48203115ac6dca3284e982015d2c", "patch": "@@ -6,6 +6,11 @@\n \n 2016-03-01  Jeff Law  <law@redhat.com>\n \n+\tPR tree-optimization/69196\n+\t* tree-ssa-threadbackward.c (fsm_find_control_statement_thread_paths):\n+\tAppropriately clamp the number of statements to copy when the\n+\tthread path does not traverse a loop backedge.\n+\n \tPR tree-optimization/69196\n \t* tree-ssa-threadbackward.c (fsm_find_control_statement_thread_paths):\n \tDo count some PHIs in the thread path against the insn count.  Decrease"}, {"sha": "1e6a8500c5120e8819d1f2d6f58d906c048e99eb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eab2541b860c48203115ac6dca3284e982015d2c", "patch": "@@ -4,6 +4,9 @@\n \n 2016-03-01  Jeff Law  <law@redhat.com>\n \n+\tPR tree-optimization/69196\n+\t* gcc.dg/tree-ssa/pr69196.c: New test.\n+\n \tPR tree-optimization/69196\n \t* gcc.dg/tree-ssa/vrp46.c: Twiddle threading params to keep it from\n \tduplicating code and spoiling the expected output."}, {"sha": "11c7cf5698d63d21baaae6dcfe43976a5a760b89", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr69196-1.c", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69196-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69196-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69196-1.c?ref=eab2541b860c48203115ac6dca3284e982015d2c", "patch": "@@ -0,0 +1,138 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n+\n+/* { dg-final { scan-tree-dump \"FSM did not thread around loop and would copy too many statements\" \"vrp1\" } } */\n+\n+\n+typedef __builtin_va_list __gnuc_va_list;\n+typedef __gnuc_va_list va_list;\n+extern void rtems_putc(char c);\n+\n+void vprintk(\n+  const char *fmt,\n+  va_list ap\n+)\n+{\n+  for (; *fmt != '\\0'; fmt++) {\n+    unsigned base = 0;\n+    unsigned width = 0;\n+    enum {\n+      LFLAG_INT,\n+      LFLAG_LONG,\n+      LFLAG_LONG_LONG\n+    } lflag = LFLAG_INT;\n+    _Bool minus = 0;\n+    _Bool sign = 0;\n+    char lead = ' ';\n+    char c = *fmt;\n+    long long num;\n+\n+    if (c != '%') {\n+      rtems_putc(c);\n+      continue;\n+    }\n+\n+    ++fmt; c = *fmt;\n+\n+    if (c == '0') {\n+      lead = '0';\n+      ++fmt; c = *fmt;\n+    }\n+\n+    if (c == '-') {\n+      minus = 1;\n+      ++fmt; c = *fmt;\n+    }\n+\n+    while (c >= '0' && c <= '9' ) {\n+      width *= 10;\n+      width += ((unsigned) c - '0');\n+      ++fmt; c = *fmt;\n+    }\n+\n+    if (c == 'l') {\n+      lflag = LFLAG_LONG;\n+      ++fmt; c = *fmt;\n+\n+      if (c == 'l') {\n+        lflag = LFLAG_LONG_LONG;\n+        ++fmt; c = *fmt;\n+      }\n+    }\n+\n+    if ( c == 'c' ) {\n+\n+      char chr = (char) __builtin_va_arg(ap,int);\n+      rtems_putc(chr);\n+      continue;\n+    }\n+\n+    if ( c == 's' ) {\n+      unsigned i, len;\n+      char *s, *str;\n+\n+      str = __builtin_va_arg(ap,char *);\n+\n+      if ( str == ((void *)0) ) {\n+        str = \"\";\n+      }\n+\n+\n+      for ( len=0, s=str ; *s ; len++, s++ )\n+        ;\n+\n+\n+      if ( !minus )\n+        for ( i=len ; i<width ; i++ )\n+          rtems_putc(' ');\n+\n+\n+      if (width == 0) {\n+          width = len;\n+      }\n+\n+\n+      for ( i=0 ; i<width && *str ; str++ )\n+        rtems_putc(*str);\n+\n+\n+      if ( minus )\n+        for ( i=len ; i<width ; i++ )\n+          rtems_putc(' ');\n+\n+      continue;\n+    }\n+\n+\n+    if ( c == 'o' || c == 'O' ) {\n+      base = 8; sign = 0;\n+    } else if ( c == 'i' || c == 'I' ||\n+                c == 'd' || c == 'D' ) {\n+      base = 10; sign = 1;\n+    } else if ( c == 'u' || c == 'U' ) {\n+      base = 10; sign = 0;\n+    } else if ( c == 'x' || c == 'X' ) {\n+      base = 16; sign = 0;\n+    } else if ( c == 'p' ) {\n+      base = 16; sign = 0; lflag = LFLAG_LONG;\n+    } else {\n+      rtems_putc(c);\n+      continue;\n+    }\n+\n+    switch (lflag) {\n+      case LFLAG_LONG:\n+        num = sign ? (long long) __builtin_va_arg(ap,long)\n+          : (long long) __builtin_va_arg(ap,unsigned long);\n+        break;\n+      case LFLAG_LONG_LONG:\n+        num = __builtin_va_arg(ap,long long);\n+        break;\n+      case LFLAG_INT:\n+      default:\n+        num = sign ? (long long) __builtin_va_arg(ap,int)\n+          : (long long) __builtin_va_arg(ap,unsigned int);\n+        break;\n+    }\n+  }\n+}"}, {"sha": "747296bff36415dd02b8bf1cb07e3ce184ffb08b", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab2541b860c48203115ac6dca3284e982015d2c/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=eab2541b860c48203115ac6dca3284e982015d2c", "patch": "@@ -429,6 +429,26 @@ fsm_find_control_statement_thread_paths (tree name,\n \t      continue;\n \t    }\n \n+\n+\t  /* If this path does not thread through the loop latch, then we are\n+\t     using the FSM threader to find old style jump threads.  This\n+\t     is good, except the FSM threader does not re-use an existing\n+\t     threading path to reduce code duplication.\n+\n+\t     So for that case, drastically reduce the number of statements\n+\t     we are allowed to copy.  */\n+\t  if (!threaded_through_latch\n+\t      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n+\t\t  >= PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS)))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"FSM did not thread around loop and would copy too \"\n+\t\t\t \"many statements.\\n\");\n+\t      path->pop ();\n+\t      continue;\n+\t    }\n+\n \t  /* When there is a multi-way branch on the path, then threading can\n \t     explode the CFG due to duplicating the edges for that multi-way\n \t     branch.  So like above, only allow a multi-way branch on the path"}]}