{"sha": "bdfa170fda77953d49509e4f16da32f1d584f3f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRmYTE3MGZkYTc3OTUzZDQ5NTA5ZTRmMTZkYTMyZjFkNTg0ZjNmNQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-10-26T14:43:47Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-10-26T14:43:47Z"}, "message": "sched-rgn.c: Remove bitset typedef.\n\n2001-10-27  Daniel Berlin  <dan@cgsoftware.com>\n\n        * sched-rgn.c: Remove bitset typedef.\n        Change bitset to sbitmap in prototypes / variable types.\n        Remove bbset_size.\n        Remove edgeset_bits.\n        Remove edgeset_size.\n        s/BITSET_ADD/SET_BIT/g\n        s/BITSET_INVERT/sbitmap_ones/g\n        s/BITSET_INTER/sbitmap_a_and_b/g\n        s/BITSET_UNION/sbitmap_a_or_b/g\n        s/BITSET_DIFFER/sbitmap_difference/g\n        s/bitset_member/TEST_BIT/g\n        (BITSET_*): Removed.\n        (bitset_member): Removed.\n        (extract_bitlst): Rewrite, now that we have sbitmaps, we can use\n        EXECUTE_IF_SET_IN_SBITMAP.\n        (split_edges): Rewrite, use sbitmap functions instead of bitset\n        operations.\n        (schedule_region): Allocate/free sbitmaps, rather than bitsets.\n\nFrom-SVN: r46541", "tree": {"sha": "4386e3d6e3a08b35198b2ec0760b1342c698d657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4386e3d6e3a08b35198b2ec0760b1342c698d657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdfa170fda77953d49509e4f16da32f1d584f3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdfa170fda77953d49509e4f16da32f1d584f3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdfa170fda77953d49509e4f16da32f1d584f3f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdfa170fda77953d49509e4f16da32f1d584f3f5/comments", "author": null, "committer": null, "parents": [{"sha": "41af791f497bc9e4ad29662f4f4bf429ac4875c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41af791f497bc9e4ad29662f4f4bf429ac4875c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41af791f497bc9e4ad29662f4f4bf429ac4875c4"}], "stats": {"total": 223, "additions": 62, "deletions": 161}, "files": [{"sha": "609dc2140e114d9809d99e77553f4394366e0746", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdfa170fda77953d49509e4f16da32f1d584f3f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdfa170fda77953d49509e4f16da32f1d584f3f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdfa170fda77953d49509e4f16da32f1d584f3f5", "patch": "@@ -1,3 +1,24 @@\n+2001-10-27  Daniel Berlin  <dan@cgsoftware.com>\n+\n+        * sched-rgn.c: Remove bitset typedef.\n+        Change bitset to sbitmap in prototypes / variable types.\n+        Remove bbset_size.\n+        Remove edgeset_bits.\n+        Remove edgeset_size.\n+        s/BITSET_ADD/SET_BIT/g\n+        s/BITSET_INVERT/sbitmap_ones/g\n+        s/BITSET_INTER/sbitmap_a_and_b/g\n+        s/BITSET_UNION/sbitmap_a_or_b/g\n+        s/BITSET_DIFFER/sbitmap_difference/g\n+        s/bitset_member/TEST_BIT/g\n+        (BITSET_*): Removed.\n+        (bitset_member): Removed.\n+        (extract_bitlst): Rewrite, now that we have sbitmaps, we can use\n+        EXECUTE_IF_SET_IN_SBITMAP.\n+        (split_edges): Rewrite, use sbitmap functions instead of bitset\n+        operations.\n+        (schedule_region): Allocate/free sbitmaps, rather than bitsets.\n+\n 2001-10-26  Andreas Schwab  <schwab@suse.de>\n \n \t* reload1.c (emit_input_reload_insns): Fix parens in last"}, {"sha": "3cd89e913ea06ec7f26f11445f3db349da110bdd", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 41, "deletions": 161, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdfa170fda77953d49509e4f16da32f1d584f3f5/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdfa170fda77953d49509e4f16da32f1d584f3f5/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=bdfa170fda77953d49509e4f16da32f1d584f3f5", "patch": "@@ -152,10 +152,6 @@ static int current_blocks;\n /* The mapping from bb to block.  */\n #define BB_TO_BLOCK(bb) (rgn_bb_table[current_blocks + (bb)])\n \n-/* Bit vectors and bitset operations are needed for computations on\n-   the control flow graph.  */\n-\n-typedef unsigned HOST_WIDE_INT *bitset;\n typedef struct\n {\n   int *first_member;\t\t/* Pointer to the list start in bitlst_table.  */\n@@ -167,8 +163,7 @@ static int bitlst_table_last;\n static int bitlst_table_size;\n static int *bitlst_table;\n \n-static char bitset_member PARAMS ((bitset, int, int));\n-static void extract_bitlst PARAMS ((bitset, int, int, bitlst *));\n+static void extract_bitlst PARAMS ((sbitmap, bitlst *));\n \n /* Target info declarations.\n \n@@ -214,22 +209,16 @@ static void compute_trg_info PARAMS ((int));\n void debug_candidate PARAMS ((int));\n void debug_candidates PARAMS ((int));\n \n-/* Bit-set of bbs, where bit 'i' stands for bb 'i'.  */\n-typedef bitset bbset;\n-\n-/* Number of words of the bbset.  */\n-static int bbset_size;\n-\n-/* Dominators array: dom[i] contains the bbset of dominators of\n+/* Dominators array: dom[i] contains the sbitmap of dominators of\n    bb i in the region.  */\n-static bbset *dom;\n+static sbitmap *dom;\n \n /* bb 0 is the only region entry.  */\n #define IS_RGN_ENTRY(bb) (!bb)\n \n /* Is bb_src dominated by bb_trg.  */\n #define IS_DOMINATED(bb_src, bb_trg)                                 \\\n-( bitset_member (dom[bb_src], bb_trg, bbset_size) )\n+( TEST_BIT (dom[bb_src], bb_trg) )\n \n /* Probability: Prob[i] is a float in [0, 1] which is the probability\n    of bb i relative to the region entry.  */\n@@ -242,19 +231,14 @@ static float *prob;\n \t\t\t\t\t\t      prob[bb_trg])))\n \n /* Bit-set of edges, where bit i stands for edge i.  */\n-typedef bitset edgeset;\n+typedef sbitmap edgeset;\n \n /* Number of edges in the region.  */\n static int rgn_nr_edges;\n \n /* Array of size rgn_nr_edges.  */\n static int *rgn_edges;\n \n-/* Number of words in an edgeset.  */\n-static int edgeset_size;\n-\n-/* Number of bits in an edgeset.  */\n-static int edgeset_bitsize;\n \n /* Mapping from each edge in the graph to its number in the rgn.  */\n static int *edge_to_bit;\n@@ -482,81 +466,14 @@ new_edge (source, target)\n     }\n }\n \n-/* BITSET macros for operations on the control flow graph.  */\n-\n-/* Compute bitwise union of two bitsets.  */\n-#define BITSET_UNION(set1, set2, len)                                \\\n-do { bitset tp = set1, sp = set2;                                    \\\n-     int i;                                                          \\\n-     for (i = 0; i < len; i++)                                       \\\n-       *(tp++) |= *(sp++); } while (0)\n-\n-/* Compute bitwise intersection of two bitsets.  */\n-#define BITSET_INTER(set1, set2, len)                                \\\n-do { bitset tp = set1, sp = set2;                                    \\\n-     int i;                                                          \\\n-     for (i = 0; i < len; i++)                                       \\\n-       *(tp++) &= *(sp++); } while (0)\n-\n-/* Compute bitwise difference of two bitsets.  */\n-#define BITSET_DIFFER(set1, set2, len)                               \\\n-do { bitset tp = set1, sp = set2;                                    \\\n-     int i;                                                          \\\n-     for (i = 0; i < len; i++)                                       \\\n-       *(tp++) &= ~*(sp++); } while (0)\n-\n-/* Inverts every bit of bitset 'set'.  */\n-#define BITSET_INVERT(set, len)                                      \\\n-do { bitset tmpset = set;                                            \\\n-     int i;                                                          \\\n-     for (i = 0; i < len; i++, tmpset++)                             \\\n-       *tmpset = ~*tmpset; } while (0)\n-\n-/* Turn on the index'th bit in bitset set.  */\n-#define BITSET_ADD(set, index, len)                                  \\\n-{                                                                    \\\n-  if (index >= HOST_BITS_PER_WIDE_INT * len)                         \\\n-    abort ();                                                        \\\n-  else                                                               \\\n-    set[index/HOST_BITS_PER_WIDE_INT] |=\t\t\t     \\\n-      ((unsigned HOST_WIDE_INT) 1) << (index % HOST_BITS_PER_WIDE_INT); \\\n-}\n-\n-/* Turn off the index'th bit in set.  */\n-#define BITSET_REMOVE(set, index, len)                               \\\n-{                                                                    \\\n-  if (index >= HOST_BITS_PER_WIDE_INT * len)                         \\\n-    abort ();                                                        \\\n-  else                                                               \\\n-    set[index/HOST_BITS_PER_WIDE_INT] &=\t\t\t     \\\n-      ~(((unsigned HOST_WIDE_INT) 1) << (index % HOST_BITS_PER_WIDE_INT)); \\\n-}\n-\n-/* Check if the index'th bit in bitset set is on.  */\n-\n-static char\n-bitset_member (set, index, len)\n-     bitset set;\n-     int index, len;\n-{\n-  if (index >= HOST_BITS_PER_WIDE_INT * len)\n-    abort ();\n-  return ((set[index / HOST_BITS_PER_WIDE_INT] &\n-\t   ((unsigned HOST_WIDE_INT) 1) << (index % HOST_BITS_PER_WIDE_INT))\n-\t  ? 1 : 0);\n-}\n-\n /* Translate a bit-set SET to a list BL of the bit-set members.  */\n \n static void\n-extract_bitlst (set, len, bitlen, bl)\n-     bitset set;\n-     int len;\n-     int bitlen;\n+extract_bitlst (set, bl)\n+     sbitmap set;\n      bitlst *bl;\n {\n-  int i, j, offset;\n-  unsigned HOST_WIDE_INT word;\n+  int i;\n \n   /* bblst table space is reused in each call to extract_bitlst.  */\n   bitlst_table_last = 0;\n@@ -565,24 +482,11 @@ extract_bitlst (set, len, bitlen, bl)\n   bl->nr_members = 0;\n \n   /* Iterate over each word in the bitset.  */\n-  for (i = 0; i < len; i++)\n-    {\n-      word = set[i];\n-      offset = i * HOST_BITS_PER_WIDE_INT;\n-\n-      /* Iterate over each bit in the word, but do not\n-\t go beyond the end of the defined bits.  */\n-      for (j = 0; offset < bitlen && word; j++)\n-\t{\n-\t  if (word & 1)\n-\t    {\n-\t      bitlst_table[bitlst_table_last++] = offset;\n-\t      (bl->nr_members)++;\n-\t    }\n-\t  word >>= 1;\n-\t  ++offset;\n-\t}\n-    }\n+  EXECUTE_IF_SET_IN_SBITMAP (set, 0, i,\n+  {\n+    bitlst_table[bitlst_table_last++] = i;\n+    (bl->nr_members)++;\n+  });\n \n }\n \n@@ -1134,34 +1038,32 @@ compute_dom_prob_ps (bb)\n   prob[bb] = 0.0;\n   if (IS_RGN_ENTRY (bb))\n     {\n-      BITSET_ADD (dom[bb], 0, bbset_size);\n+      SET_BIT (dom[bb], 0);\n       prob[bb] = 1.0;\n       return;\n     }\n \n   fst_in_edge = nxt_in_edge = IN_EDGES (BB_TO_BLOCK (bb));\n \n   /* Intialize dom[bb] to '111..1'.  */\n-  BITSET_INVERT (dom[bb], bbset_size);\n+  sbitmap_ones (dom[bb]);\n \n   do\n     {\n       pred = FROM_BLOCK (nxt_in_edge);\n-      BITSET_INTER (dom[bb], dom[BLOCK_TO_BB (pred)], bbset_size);\n+      sbitmap_a_and_b (dom[bb], dom[bb], dom[BLOCK_TO_BB (pred)]);\n+      sbitmap_a_or_b (ancestor_edges[bb], ancestor_edges[bb], ancestor_edges[BLOCK_TO_BB (pred)]);\n \n-      BITSET_UNION (ancestor_edges[bb], ancestor_edges[BLOCK_TO_BB (pred)],\n-\t\t    edgeset_size);\n-\n-      BITSET_ADD (ancestor_edges[bb], EDGE_TO_BIT (nxt_in_edge), edgeset_size);\n+      SET_BIT (ancestor_edges[bb], EDGE_TO_BIT (nxt_in_edge));\n \n       nr_out_edges = 1;\n       nr_rgn_out_edges = 0;\n       fst_out_edge = OUT_EDGES (pred);\n       nxt_out_edge = NEXT_OUT (fst_out_edge);\n-      BITSET_UNION (pot_split[bb], pot_split[BLOCK_TO_BB (pred)],\n-\t\t    edgeset_size);\n \n-      BITSET_ADD (pot_split[bb], EDGE_TO_BIT (fst_out_edge), edgeset_size);\n+      sbitmap_a_or_b (pot_split[bb], pot_split[bb], pot_split[BLOCK_TO_BB (pred)]);\n+\n+      SET_BIT (pot_split[bb], EDGE_TO_BIT (fst_out_edge));\n \n       /* The successor doesn't belong in the region?  */\n       if (CONTAINING_RGN (TO_BLOCK (fst_out_edge)) !=\n@@ -1175,7 +1077,7 @@ compute_dom_prob_ps (bb)\n \t  if (CONTAINING_RGN (TO_BLOCK (nxt_out_edge)) !=\n \t      CONTAINING_RGN (BB_TO_BLOCK (bb)))\n \t    ++nr_rgn_out_edges;\n-\t  BITSET_ADD (pot_split[bb], EDGE_TO_BIT (nxt_out_edge), edgeset_size);\n+        SET_BIT (pot_split[bb], EDGE_TO_BIT (nxt_out_edge));\n \t  nxt_out_edge = NEXT_OUT (nxt_out_edge);\n \n \t}\n@@ -1192,8 +1094,8 @@ compute_dom_prob_ps (bb)\n     }\n   while (fst_in_edge != nxt_in_edge);\n \n-  BITSET_ADD (dom[bb], bb, bbset_size);\n-  BITSET_DIFFER (pot_split[bb], ancestor_edges[bb], edgeset_size);\n+  SET_BIT (dom[bb], bb);\n+  sbitmap_difference (pot_split[bb], pot_split[bb], ancestor_edges[bb]);\n \n   if (sched_verbose >= 2)\n     fprintf (sched_dump, \";;  bb_prob(%d, %d) = %3d\\n\", bb, BB_TO_BLOCK (bb),\n@@ -1211,14 +1113,12 @@ split_edges (bb_src, bb_trg, bl)\n      int bb_trg;\n      edgelst *bl;\n {\n-  int es = edgeset_size;\n-  edgeset src = (edgeset) xcalloc (es, sizeof (HOST_WIDE_INT));\n-\n-  while (es--)\n-    src[es] = (pot_split[bb_src])[es];\n-  BITSET_DIFFER (src, pot_split[bb_trg], edgeset_size);\n-  extract_bitlst (src, edgeset_size, edgeset_bitsize, bl);\n-  free (src);\n+  sbitmap src = (edgeset) sbitmap_alloc (pot_split[bb_src]->n_bits);\n+  sbitmap_copy (src, pot_split[bb_src]);\n+\n+  sbitmap_difference (src, src, pot_split[bb_trg]);\n+  extract_bitlst (src, bl);\n+  sbitmap_free (src);\n }\n \n /* Find the valid candidate-source-blocks for the target block TRG, compute\n@@ -1647,9 +1547,8 @@ enum INSN_TRAP_CLASS\n #define IS_REACHABLE(bb_from, bb_to)\t\t\t\t\t\\\n (bb_from == bb_to                                                       \\\n    || IS_RGN_ENTRY (bb_from)\t\t\t\t\t\t\\\n-   || (bitset_member (ancestor_edges[bb_to],\t\t\t\t\\\n-\t\t      EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))),\t\\\n-\t\t      edgeset_size)))\n+   || (TEST_BIT (ancestor_edges[bb_to],                               \\\n+                    EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))))))\n \n /* Non-zero iff the address is comprised from at most 1 register.  */\n #define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n@@ -2747,11 +2646,8 @@ schedule_region (rgn)\n \n       prob = (float *) xmalloc ((current_nr_blocks) * sizeof (float));\n \n-      bbset_size = current_nr_blocks / HOST_BITS_PER_WIDE_INT + 1;\n-      dom = (bbset *) xmalloc (current_nr_blocks * sizeof (bbset));\n-      for (i = 0; i < current_nr_blocks; i++)\n-\tdom[i] = (bbset) xcalloc (bbset_size, sizeof (HOST_WIDE_INT));\n-\n+      dom = sbitmap_vector_alloc (current_nr_blocks, current_nr_blocks);\n+      sbitmap_vector_zero (dom, current_nr_blocks);\n       /* Edge to bit.  */\n       rgn_nr_edges = 0;\n       edge_to_bit = (int *) xmalloc (nr_edges * sizeof (int));\n@@ -2766,18 +2662,10 @@ schedule_region (rgn)\n \t  rgn_edges[rgn_nr_edges++] = i;\n \n       /* Split edges.  */\n-      edgeset_size = rgn_nr_edges / HOST_BITS_PER_WIDE_INT + 1;\n-      edgeset_bitsize = rgn_nr_edges;\n-      pot_split = (edgeset *) xmalloc (current_nr_blocks * sizeof (edgeset));\n-      ancestor_edges\n-\t= (edgeset *) xmalloc (current_nr_blocks * sizeof (edgeset));\n-      for (i = 0; i < current_nr_blocks; i++)\n-\t{\n-\t  pot_split[i] =\n-\t    (edgeset) xcalloc (edgeset_size, sizeof (HOST_WIDE_INT));\n-\t  ancestor_edges[i] =\n-\t    (edgeset) xcalloc (edgeset_size, sizeof (HOST_WIDE_INT));\n-\t}\n+      pot_split = sbitmap_vector_alloc (current_nr_blocks, rgn_nr_edges);\n+      sbitmap_vector_zero (pot_split, current_nr_blocks);\n+      ancestor_edges = sbitmap_vector_alloc (current_nr_blocks, rgn_nr_edges);\n+      sbitmap_vector_zero (ancestor_edges, current_nr_blocks);\n \n       /* Compute probabilities, dominators, split_edges.  */\n       for (bb = 0; bb < current_nr_blocks; bb++)\n@@ -2875,20 +2763,12 @@ schedule_region (rgn)\n \n   if (current_nr_blocks > 1)\n     {\n-      int i;\n-\n       free (prob);\n-      for (i = 0; i < current_nr_blocks; ++i)\n-\t{\n-\t  free (dom[i]);\n-\t  free (pot_split[i]);\n-\t  free (ancestor_edges[i]);\n-\t}\n-      free (dom);\n+      sbitmap_vector_free (dom);\n+      sbitmap_vector_free (pot_split);\n+      sbitmap_vector_free (ancestor_edges);\n       free (edge_to_bit);\n       free (rgn_edges);\n-      free (pot_split);\n-      free (ancestor_edges);\n     }\n }\n "}]}