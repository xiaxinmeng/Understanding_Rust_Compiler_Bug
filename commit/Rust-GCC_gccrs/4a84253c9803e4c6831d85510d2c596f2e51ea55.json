{"sha": "4a84253c9803e4c6831d85510d2c596f2e51ea55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4NDI1M2M5ODAzZTRjNjgzMWQ4NTUxMGQyYzU5NmYyZTUxZWE1NQ==", "commit": {"author": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2012-08-20T21:13:23Z"}, "committer": {"name": "Florian Weimer", "email": "fw@gcc.gnu.org", "date": "2012-08-20T21:13:23Z"}, "message": "Fix PR C++/19351: integer overflow in operator new[]\n\n2012-08-20  Florian Weimer  <fweimer@redhat.com>\n\n\tPR c++/19351\n\t* call.c (build_operator_new_call): Add size_check argument and\n\tevaluate it.\n\t* cp-tree.h (build_operator_new_call): Adjust declaration.\n\t* init.c (build_new_1): Compute array size check and apply it.\n\n2012-08-10  Florian Weimer  <fweimer@redhat.com>\n\n\tPR c++/19351\n\t* g++.dg/init/new38.C: New test.\n\t* g++.dg/init/new39.C: New test.\n\nFrom-SVN: r190546", "tree": {"sha": "fc3295f979c18be864a1b430c97ff13ffa49cdde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc3295f979c18be864a1b430c97ff13ffa49cdde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a84253c9803e4c6831d85510d2c596f2e51ea55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a84253c9803e4c6831d85510d2c596f2e51ea55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a84253c9803e4c6831d85510d2c596f2e51ea55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a84253c9803e4c6831d85510d2c596f2e51ea55/comments", "author": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5592815a885e6101054be5b7fbac7a223b698815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5592815a885e6101054be5b7fbac7a223b698815", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5592815a885e6101054be5b7fbac7a223b698815"}], "stats": {"total": 247, "additions": 232, "deletions": 15}, "files": [{"sha": "b21e1e0b03a29bef26794b79f1b2d8a4955a8076", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a84253c9803e4c6831d85510d2c596f2e51ea55", "patch": "@@ -1,3 +1,11 @@\n+2012-08-20  Florian Weimer  <fweimer@redhat.com>\n+\n+\tPR c++/19351\n+\t* call.c (build_operator_new_call): Add size_check argument and\n+\tevaluate it.\n+\t* cp-tree.h (build_operator_new_call): Adjust declaration.\n+\t* init.c (build_new_1): Compute array size check and apply it.\n+\n 2012-08-20  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/50489"}, {"sha": "5d5899f94fe2fc89af9533ab10002ba408e27678", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4a84253c9803e4c6831d85510d2c596f2e51ea55", "patch": "@@ -3943,22 +3943,30 @@ build_new_function_call (tree fn, VEC(tree,gc) **args, bool koenig_p,\n    total number of bytes required by the allocation, and is updated if\n    that is changed here.  *COOKIE_SIZE is non-NULL if a cookie should\n    be used.  If this function determines that no cookie should be\n-   used, after all, *COOKIE_SIZE is set to NULL_TREE.  If FN is\n-   non-NULL, it will be set, upon return, to the allocation function\n-   called.  */\n+   used, after all, *COOKIE_SIZE is set to NULL_TREE.  If SIZE_CHECK\n+   is not NULL_TREE, it is evaluated before calculating the final\n+   array size, and if it fails, the array size is replaced with\n+   (size_t)-1 (usually triggering a std::bad_alloc exception).  If FN\n+   is non-NULL, it will be set, upon return, to the allocation\n+   function called.  */\n \n tree\n build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n-\t\t\t tree *size, tree *cookie_size,\n+\t\t\t tree *size, tree *cookie_size, tree size_check,\n \t\t\t tree *fn, tsubst_flags_t complain)\n {\n+  tree original_size = *size;\n   tree fns;\n   struct z_candidate *candidates;\n   struct z_candidate *cand;\n   bool any_viable_p;\n \n   if (fn)\n     *fn = NULL_TREE;\n+  /* Set to (size_t)-1 if the size check fails.  */\n+  if (size_check != NULL_TREE)\n+    *size = fold_build3 (COND_EXPR, sizetype, size_check,\n+\t\t\t original_size, TYPE_MAX_VALUE (sizetype));\n   VEC_safe_insert (tree, gc, *args, 0, *size);\n   *args = resolve_args (*args, complain);\n   if (*args == NULL)\n@@ -4022,7 +4030,11 @@ build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n        if (use_cookie)\n \t {\n \t   /* Update the total size.  */\n-\t   *size = size_binop (PLUS_EXPR, *size, *cookie_size);\n+\t   *size = size_binop (PLUS_EXPR, original_size, *cookie_size);\n+\t   /* Set to (size_t)-1 if the size check fails.  */\n+\t   gcc_assert (size_check != NULL_TREE);\n+\t   *size = fold_build3 (COND_EXPR, sizetype, size_check,\n+\t\t\t\t*size, TYPE_MAX_VALUE (sizetype));\n \t   /* Update the argument list to reflect the adjusted size.  */\n \t   VEC_replace (tree, *args, 0, *size);\n \t }"}, {"sha": "f3dccf98e6e191cd00691422d552d36e57e7d5bf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4a84253c9803e4c6831d85510d2c596f2e51ea55", "patch": "@@ -4886,7 +4886,7 @@ extern tree build_user_type_conversion\t\t(tree, tree, int,\n extern tree build_new_function_call\t\t(tree, VEC(tree,gc) **, bool, \n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_operator_new_call\t\t(tree, VEC(tree,gc) **, tree *,\n-\t\t\t\t\t\t tree *, tree *,\n+\t\t\t\t\t\t tree *, tree, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_method_call\t\t(tree, tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tree, int, tree *,"}, {"sha": "09288f87e20fa71d8a2724aba21cd163e65de0ff", "filename": "gcc/cp/init.c", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4a84253c9803e4c6831d85510d2c596f2e51ea55", "patch": "@@ -2178,7 +2178,10 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n   tree pointer_type;\n   tree non_const_pointer_type;\n   tree outer_nelts = NULL_TREE;\n+  /* For arrays, a bounds checks on the NELTS parameter. */\n+  tree outer_nelts_check = NULL_TREE;\n   bool outer_nelts_from_type = false;\n+  double_int inner_nelts_count = double_int_one;\n   tree alloc_call, alloc_expr;\n   /* The address returned by the call to \"operator new\".  This node is\n      a VAR_DECL and is therefore reusable.  */\n@@ -2231,7 +2234,22 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n     {\n       tree inner_nelts = array_type_nelts_top (elt_type);\n       tree inner_nelts_cst = maybe_constant_value (inner_nelts);\n-      if (!TREE_CONSTANT (inner_nelts_cst))\n+      if (TREE_CONSTANT (inner_nelts_cst)\n+\t  && TREE_CODE (inner_nelts_cst) == INTEGER_CST)\n+\t{\n+\t  double_int result;\n+\t  if (mul_double (TREE_INT_CST_LOW (inner_nelts_cst),\n+\t\t\t  TREE_INT_CST_HIGH (inner_nelts_cst),\n+\t\t\t  inner_nelts_count.low, inner_nelts_count.high,\n+\t\t\t  &result.low, &result.high))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"integer overflow in array size\");\n+\t      nelts = error_mark_node;\n+\t    }\n+\t  inner_nelts_count = result;\n+\t}\n+      else\n \t{\n \t  if (complain & tf_error)\n \t    {\n@@ -2321,7 +2339,56 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \n   size = size_in_bytes (elt_type);\n   if (array_p)\n-    size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n+    {\n+      /* Maximum available size in bytes.  Half of the address space\n+\t minus the cookie size.  */\n+      double_int max_size\n+\t= double_int_lshift (double_int_one, TYPE_PRECISION (sizetype) - 1,\n+\t\t\t     HOST_BITS_PER_DOUBLE_INT, false);\n+      /* Size of the inner array elements. */\n+      double_int inner_size;\n+      /* Maximum number of outer elements which can be allocated. */\n+      double_int max_outer_nelts;\n+      tree max_outer_nelts_tree;\n+\n+      gcc_assert (TREE_CODE (size) == INTEGER_CST);\n+      cookie_size = targetm.cxx.get_cookie_size (elt_type);\n+      gcc_assert (TREE_CODE (cookie_size) == INTEGER_CST);\n+      gcc_checking_assert (double_int_ucmp\n+\t\t\t   (TREE_INT_CST (cookie_size), max_size) < 0);\n+      /* Unconditionally substract the cookie size.  This decreases the\n+\t maximum object size and is safe even if we choose not to use\n+\t a cookie after all.  */\n+      max_size = double_int_sub (max_size, TREE_INT_CST (cookie_size));\n+      if (mul_double (TREE_INT_CST_LOW (size), TREE_INT_CST_HIGH (size),\n+\t\t      inner_nelts_count.low, inner_nelts_count.high,\n+\t\t      &inner_size.low, &inner_size.high)\n+\t  || double_int_ucmp (inner_size, max_size) > 0)\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"size of array is too large\");\n+\t  return error_mark_node;\n+\t}\n+      max_outer_nelts = double_int_udiv (max_size, inner_size, TRUNC_DIV_EXPR);\n+      /* Only keep the top-most seven bits, to simplify encoding the\n+\t constant in the instruction stream.  */\n+      {\n+\tunsigned shift = HOST_BITS_PER_DOUBLE_INT - 7\n+\t  - (max_outer_nelts.high ? clz_hwi (max_outer_nelts.high)\n+\t     : (HOST_BITS_PER_WIDE_INT + clz_hwi (max_outer_nelts.low)));\n+\tmax_outer_nelts\n+\t  = double_int_lshift (double_int_rshift\n+\t\t\t       (max_outer_nelts, shift,\n+\t\t\t\tHOST_BITS_PER_DOUBLE_INT, false),\n+\t\t\t       shift, HOST_BITS_PER_DOUBLE_INT, false);\n+      }\n+      max_outer_nelts_tree = double_int_to_tree (sizetype, max_outer_nelts);\n+\n+      size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n+      outer_nelts_check = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t       outer_nelts,\n+\t\t\t\t       max_outer_nelts_tree);\n+    }\n \n   alloc_fn = NULL_TREE;\n \n@@ -2384,10 +2451,13 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t  /* Use a class-specific operator new.  */\n \t  /* If a cookie is required, add some extra space.  */\n \t  if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))\n-\t    {\n-\t      cookie_size = targetm.cxx.get_cookie_size (elt_type);\n-\t      size = size_binop (PLUS_EXPR, size, cookie_size);\n-\t    }\n+\t    size = size_binop (PLUS_EXPR, size, cookie_size);\n+\t  else\n+\t    cookie_size = NULL_TREE;\n+\t  /* Perform the overflow check.  */\n+\t  if (outer_nelts_check != NULL_TREE)\n+            size = fold_build3 (COND_EXPR, sizetype, outer_nelts_check,\n+                                size, TYPE_MAX_VALUE (sizetype));\n \t  /* Create the argument list.  */\n \t  VEC_safe_insert (tree, gc, *placement, 0, size);\n \t  /* Do name-lookup to find the appropriate operator.  */\n@@ -2418,13 +2488,12 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t{\n \t  /* Use a global operator new.  */\n \t  /* See if a cookie might be required.  */\n-\t  if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))\n-\t    cookie_size = targetm.cxx.get_cookie_size (elt_type);\n-\t  else\n+\t  if (!(array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type)))\n \t    cookie_size = NULL_TREE;\n \n \t  alloc_call = build_operator_new_call (fnname, placement,\n \t\t\t\t\t\t&size, &cookie_size,\n+\t\t\t\t\t\touter_nelts_check,\n \t\t\t\t\t\t&alloc_fn, complain);\n \t}\n     }"}, {"sha": "c31dca536ee518ba2aa75fbed7d76ae33b3ba26f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a84253c9803e4c6831d85510d2c596f2e51ea55", "patch": "@@ -1,3 +1,9 @@\n+2012-08-20  Florian Weimer  <fweimer@redhat.com>\n+\n+\tPR c++/19351\n+\t* g++.dg/init/new38.C: New test.\n+\t* g++.dg/init/new39.C: New test.\n+\n 2012-08-20  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/50489"}, {"sha": "1672f229d64b0e54ebda118cafd6bc78a2ab23c8", "filename": "gcc/testsuite/g++.dg/init/new38.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew38.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew38.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew38.C?ref=4a84253c9803e4c6831d85510d2c596f2e51ea55", "patch": "@@ -0,0 +1,54 @@\n+// { dg-do compile }\n+\n+void\n+large_array_char(int n)\n+{\n+  new char[n]\n+    [1ULL << (sizeof(void *) * 4)]\n+    [1ULL << (sizeof(void *) * 4)]; // { dg-error \"size of array\" }\n+}\n+\n+template <typename T>\n+void\n+large_array_char_template(int n)\n+{\n+  new char[n]\n+    [1ULL << (sizeof(void *) * 4)]\n+    [1ULL << (sizeof(void *) * 4)]; // { dg-error \"size of array\" }\n+}\n+\n+\n+template <typename T>\n+void\n+large_array_template1(int n)\n+{\n+  new T[n] // { dg-error \"size of array is too large\" }\n+    [(1ULL << (sizeof(void *) * 4)) / sizeof(T)]\n+    [1ULL << (sizeof(void *) * 4)];\n+}\n+\n+template <typename T>\n+void\n+large_array_template2(int n)\n+{\n+  new T[n] // { dg-error \"size of array is too large\" }\n+    [(1ULL << (sizeof(void *) * 4)) / sizeof(T)]\n+    [1ULL << (sizeof(void *) * 4)];\n+}\n+\n+template <typename T>\n+void\n+large_array_template3(int n)\n+{\n+  new T[n] // { dg-error \"size of array is too large\" }\n+    [(1ULL << (sizeof(void *) * 4)) / sizeof(T)]\n+    [1ULL << (sizeof(void *) * 4)];\n+}\n+\n+void\n+call_large_array_template(int n)\n+{\n+  large_array_template1<char>(n);\n+  large_array_template2<int>(n);\n+  large_array_template3<double>(n);\n+}"}, {"sha": "f274ebb7b9d69e599225a77269b3cdf0593fa136", "filename": "gcc/testsuite/g++.dg/init/new39.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a84253c9803e4c6831d85510d2c596f2e51ea55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew39.C?ref=4a84253c9803e4c6831d85510d2c596f2e51ea55", "patch": "@@ -0,0 +1,68 @@\n+// Testcase for overflow handling in operator new[].\n+// { dg-do run }\n+\n+#include <stdlib.h>\n+#include <stdexcept>\n+\n+struct without_new {\n+  char bar[256];\n+};\n+\n+struct with_new {\n+  char bar[256];\n+  void *operator new[] (size_t sz)\n+  {\n+    if (sz != -1)\n+      abort ();\n+    throw std::bad_alloc();\n+  }\n+};\n+\n+template <typename T>\n+inline void\n+test (size_t s)\n+{\n+  try {\n+    new T[s];\n+    abort ();\n+  } catch (std::bad_alloc &) {\n+  }\n+}\n+\n+template <typename T>\n+void\n+test_noopt (size_t s) __attribute__((noinline));\n+\n+template <typename T>\n+void\n+test_noopt (size_t s)\n+{\n+  __asm__ (\"\");\n+  test<T> (s);\n+}\n+\n+template <typename T>\n+void\n+all_tests ()\n+{\n+  test<T>(-1);\n+  test<T>(size_t(-1) / sizeof (T) + 1);\n+  test<T>(size_t(-1) / sizeof (T) + 2);\n+  test_noopt<T>(-1);\n+  test_noopt<T>(size_t(-1) / sizeof (T) + 1);\n+  test_noopt<T>(size_t(-1) / sizeof (T) + 2);\n+}\n+\n+int\n+main ()\n+{\n+  try {\n+    ::operator new(size_t(-1));\n+    abort ();\n+  } catch (std::bad_alloc &) {\n+  }\n+  all_tests<without_new> ();\n+  all_tests<with_new> ();\n+  return 0;\n+}\n+"}]}