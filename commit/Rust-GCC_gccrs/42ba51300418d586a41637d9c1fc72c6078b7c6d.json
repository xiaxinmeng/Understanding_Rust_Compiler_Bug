{"sha": "42ba51300418d586a41637d9c1fc72c6078b7c6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJiYTUxMzAwNDE4ZDU4NmE0MTYzN2Q5YzFmYzcyYzYwNzhiN2M2ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-03-12T10:03:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-03-12T10:03:32Z"}, "message": "re PR target/14547 (Passing _Complex long double does not follow the ABI)\n\n        PR target/14547\n        * target.h (struct gcc_target): Move calls substructure before\n        booleans.  Add split_complex_arg.\n        * function.c (assign_parms, split_complex_args): Use it.\n        * calls.c (expand_call): Likewise.\n        (split_complex_values): Likewise.  Check for splittable types\n        before allocating memory.\n        (split_complex_types): Likewise.\n        * system.h (SPLIT_COMPLEX_ARGS): Poison.\n        * expr.h (SPLIT_COMPLEX_ARGS): Remove.\n        * target-def.h (TARGET_SPLIT_COMPLEX_ARG): New.\n        * config/alpha/alpha.c (alpha_split_complex_arg): New.\n        (TARGET_SPLIT_COMPLEX_ARG): New.\n        * config/alpha/alpha.h (SPLIT_COMPLEX_ARGS): Remove.\n        * config/rs6000/rs6000.c (TARGET_SPLIT_COMPLEX_ARG): New.\n        (rs6000_override_options): Zap it for non-AIX.\n        (rs6000_function_value): Use targetm.calls.split_complex_arg.\n        * config/rs6000/rs6000.h (SPLIT_COMPLEX_ARGS): Remove.\n        * config/xtensa/xtensa.c (TARGET_SPLIT_COMPLEX_ARG): New.\n        * config/xtensa/xtensa.h (SPLIT_COMPLEX_ARGS): Remove.\n        * doc/tm.texi (TARGET_SPLIT_COMPLEX_ARG): Modify from old\n        SPLIT_COMPLEX_ARGS entry.\n\nFrom-SVN: r79376", "tree": {"sha": "bdd3000f3e6489ec11b58de31921ac902908031e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdd3000f3e6489ec11b58de31921ac902908031e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42ba51300418d586a41637d9c1fc72c6078b7c6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ba51300418d586a41637d9c1fc72c6078b7c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ba51300418d586a41637d9c1fc72c6078b7c6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ba51300418d586a41637d9c1fc72c6078b7c6d/comments", "author": null, "committer": null, "parents": [{"sha": "ac011d28bb63763829fd3bec7792fe13d58cfac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac011d28bb63763829fd3bec7792fe13d58cfac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac011d28bb63763829fd3bec7792fe13d58cfac7"}], "stats": {"total": 192, "additions": 131, "deletions": 61}, "files": [{"sha": "f80b5355b0422ff4f50f2993778a46981db0b348", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -1,3 +1,28 @@\n+2004-03-12  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/14547\n+\t* target.h (struct gcc_target): Move calls substructure before\n+\tbooleans.  Add split_complex_arg.\n+\t* function.c (assign_parms, split_complex_args): Use it.\n+        * calls.c (expand_call): Likewise.\n+        (split_complex_values): Likewise.  Check for splittable types\n+        before allocating memory.\n+        (split_complex_types): Likewise.\n+\t* system.h (SPLIT_COMPLEX_ARGS): Poison.\n+\t* expr.h (SPLIT_COMPLEX_ARGS): Remove.\n+\t* target-def.h (TARGET_SPLIT_COMPLEX_ARG): New.\n+\t* config/alpha/alpha.c (alpha_split_complex_arg): New.\n+\t(TARGET_SPLIT_COMPLEX_ARG): New.\n+\t* config/alpha/alpha.h (SPLIT_COMPLEX_ARGS): Remove.\n+\t* config/rs6000/rs6000.c (TARGET_SPLIT_COMPLEX_ARG): New.\n+\t(rs6000_override_options): Zap it for non-AIX.\n+\t(rs6000_function_value): Use targetm.calls.split_complex_arg.\n+\t* config/rs6000/rs6000.h (SPLIT_COMPLEX_ARGS): Remove.\n+\t* config/xtensa/xtensa.c (TARGET_SPLIT_COMPLEX_ARG): New.\n+\t* config/xtensa/xtensa.h (SPLIT_COMPLEX_ARGS): Remove.\n+\t* doc/tm.texi (TARGET_SPLIT_COMPLEX_ARG): Modify from old\n+\tSPLIT_COMPLEX_ARGS entry.\n+\n 2004-03-11  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (xfloating_ops, vax_cvt_ops): New."}, {"sha": "e58bd05f8ce771610e35e3b26383731564331c32", "filename": "gcc/calls.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -2347,7 +2347,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n   /* Munge the tree to split complex arguments into their imaginary\n      and real parts.  */\n-  if (SPLIT_COMPLEX_ARGS)\n+  if (targetm.calls.split_complex_arg)\n     {\n       type_arg_types = split_complex_types (TYPE_ARG_TYPES (funtype));\n       actparms = split_complex_values (actparms);\n@@ -3557,6 +3557,17 @@ split_complex_values (tree values)\n {\n   tree p;\n \n+  /* Before allocating memory, check for the common case of no complex.  */\n+  for (p = values; p; p = TREE_CHAIN (p))\n+    {\n+      tree type = TREE_TYPE (TREE_VALUE (p));\n+      if (type && TREE_CODE (type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (type))\n+        goto found;\n+    }\n+  return values;\n+\n+ found:\n   values = copy_list (values);\n \n   for (p = values; p; p = TREE_CHAIN (p))\n@@ -3568,7 +3579,8 @@ split_complex_values (tree values)\n       if (!complex_type)\n \tcontinue;\n \n-      if (TREE_CODE (complex_type) == COMPLEX_TYPE)\n+      if (TREE_CODE (complex_type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (complex_type))\n \t{\n \t  tree subtype;\n \t  tree real, imag, next;\n@@ -3599,13 +3611,25 @@ split_complex_types (tree types)\n {\n   tree p;\n \n+  /* Before allocating memory, check for the common case of no complex.  */\n+  for (p = types; p; p = TREE_CHAIN (p))\n+    {\n+      tree type = TREE_VALUE (p);\n+      if (TREE_CODE (type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (type))\n+        goto found;\n+    }\n+  return types;\n+\n+ found:\n   types = copy_list (types);\n \n   for (p = types; p; p = TREE_CHAIN (p))\n     {\n       tree complex_type = TREE_VALUE (p);\n \n-      if (TREE_CODE (complex_type) == COMPLEX_TYPE)\n+      if (TREE_CODE (complex_type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (complex_type))\n \t{\n \t  tree next, imag;\n "}, {"sha": "c9a87ebf31180c0ef3de33adeb1b7d41222bbe05", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -5889,7 +5889,7 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n   else\n     {\n #ifdef ENABLE_CHECKING\n-      /* With SPLIT_COMPLEX_ARGS, we shouldn't see any raw complex\n+      /* With alpha_split_complex_arg, we shouldn't see any raw complex\n \t values here.  */\n       if (COMPLEX_MODE_P (mode))\n \tabort ();\n@@ -6106,6 +6106,15 @@ function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n   return gen_rtx_REG (mode, regnum);\n }\n \n+/* TCmode complex values are passed by invisible reference.  We \n+   should not split these values.  */\n+\n+static bool\n+alpha_split_complex_arg (tree type)\n+{\n+  return TYPE_MODE (type) != TCmode;\n+}\n+\n static tree\n alpha_build_builtin_va_list (void)\n {\n@@ -10223,6 +10232,8 @@ alpha_init_libfuncs (void)\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n #undef TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n #define TARGET_PRETEND_OUTGOING_VARARGS_NAMED hook_bool_CUMULATIVE_ARGS_true\n+#undef TARGET_SPLIT_COMPLEX_ARG\n+#define TARGET_SPLIT_COMPLEX_ARG alpha_split_complex_arg\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST alpha_build_builtin_va_list"}, {"sha": "d59797c103fa76806e125a35632e2663fd72cd75", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -1839,6 +1839,3 @@ do {\t\t\t\t\t\t\t\\\n \n /* Generate calls to memcpy, etc., not bcopy, etc.  */\n #define TARGET_MEM_FUNCTIONS 1\n-\n-/* Pass complex arguments independently.  */\n-#define SPLIT_COMPLEX_ARGS 1"}, {"sha": "d53c32eea9351bbd64e13577bd980d55893caf49", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -621,6 +621,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n #undef TARGET_PRETEND_OUTGOING_VARARGS_NAMED\n #define TARGET_PRETEND_OUTGOING_VARARGS_NAMED hook_bool_CUMULATIVE_ARGS_true\n+#undef TARGET_SPLIT_COMPLEX_ARG\n+#define TARGET_SPLIT_COMPLEX_ARG hook_bool_tree_true\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST rs6000_build_builtin_va_list\n@@ -1006,6 +1008,11 @@ rs6000_override_options (const char *default_cpu)\n \n   /* Arrange to save and restore machine status around nested functions.  */\n   init_machine_status = rs6000_init_machine_status;\n+\n+  /* We should always be splitting complex arguments, but we can't break\n+     Linux and Darwin ABIs at the moment.  For now, only AIX is fixed.  */\n+  if (DEFAULT_ABI != ABI_AIX)\n+    targetm.calls.split_complex_arg = NULL;\n }\n \n /* Handle generic options of the form -mfoo=yes/no.\n@@ -15970,7 +15977,7 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n     regno = FP_ARG_RETURN;\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n \t   && TARGET_HARD_FLOAT\n-\t   && SPLIT_COMPLEX_ARGS)\n+\t   && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else if (TREE_CODE (valtype) == VECTOR_TYPE && TARGET_ALTIVEC)\n     regno = ALTIVEC_ARG_RETURN;\n@@ -15992,7 +15999,7 @@ rs6000_libcall_value (enum machine_mode mode)\n     regno = FP_ARG_RETURN;\n   else if (ALTIVEC_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n-  else if (COMPLEX_MODE_P (mode) && SPLIT_COMPLEX_ARGS)\n+  else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else\n     regno = GP_ARG_RETURN;"}, {"sha": "d520cb64efda9fd49f08127a6270cdf583844807", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -1846,13 +1846,6 @@ typedef struct rs6000_args\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n   function_arg_boundary (MODE, TYPE)\n \n-/* Define to nonzero if complex arguments should be split into their\n-   corresponding components.\n-\n-   This should be set for Linux and Darwin as well, but we can't break\n-   the ABIs at the moment.  For now, only AIX gets fixed.  */\n-#define SPLIT_COMPLEX_ARGS (DEFAULT_ABI == ABI_AIX)\n-\n /* Implement `va_start' for varargs and stdarg.  */\n #define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n   rs6000_va_start (valist, nextarg)"}, {"sha": "0c88d8539d89c2ed5105ccf87cd1df23688a4fca", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -251,6 +251,8 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n \n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY xtensa_return_in_memory\n+#undef TARGET_SPLIT_COMPLEX_ARG\n+#define TARGET_SPLIT_COMPLEX_ARG hook_bool_tree_true\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS xtensa_builtin_saveregs"}, {"sha": "3d2432be9e1dbc27b9d5d7a69dab0df0b4759412", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -794,9 +794,6 @@ typedef struct xtensa_args\n    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\t\\\n        || TREE_ADDRESSABLE (TYPE)))\n \n-/* Pass complex arguments independently.  */\n-#define SPLIT_COMPLEX_ARGS 1\n-\n /* Profiling Xtensa code is typically done with the built-in profiling\n    feature of Tensilica's instruction set simulator, which does not\n    require any compiler support.  Profiling code on a real (i.e.,"}, {"sha": "4b65d900699f12634b17a3710923fc41629dfa92", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -3794,16 +3794,18 @@ used for this purpose since all function arguments are pushed on the\n stack.\n @end defmac\n \n-@defmac SPLIT_COMPLEX_ARGS\n-\n-Define this macro to a nonzero value if complex function arguments\n-should be split into their corresponding components.  By default, GCC\n-will attempt to pack complex arguments into the target's word size.\n-Some ABIs require complex arguments to be split and treated as their\n-individual components.  For example, on AIX64, complex floats should\n-be passed in a pair of floating point registers, even though a complex\n-float would fit in one 64-bit floating point register.\n-@end defmac\n+@deftypefn {Target Hook} bool TARGET_SPLIT_COMPLEX_ARG (tree @var{type})\n+This hook should return true if parameter of type @var{type} are passed\n+as two scalar parameters.  By default, GCC will attempt to pack complex\n+arguments into the target's word size.  Some ABIs require complex arguments\n+to be split and treated as their individual components.  For example, on\n+AIX64, complex floats should be passed in a pair of floating point\n+registers, even though a complex float would fit in one 64-bit floating\n+point register.\n+\n+The default value of this hook is @code{NULL}, which is treated as always\n+false.\n+@end deftypefn\n \n @node Scalar Return\n @subsection How Scalar Function Values Are Returned"}, {"sha": "dd7ac9c6058b85b7fe918ce2e2dcebfbf6547811", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -188,11 +188,6 @@ do {\t\t\t\t\t\t\t\\\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n #endif\n \n-/* Define to nonzero if complex arguments should be split into their\n-   corresponding components.  */\n-#ifndef SPLIT_COMPLEX_ARGS\n-#define SPLIT_COMPLEX_ARGS 0\n-#endif\n tree split_complex_types (tree);\n tree split_complex_values (tree);\n "}, {"sha": "3d48b404a4e81f10c6d9be5aec0b856e80be59b8", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -4349,7 +4349,8 @@ assign_parms (tree fndecl)\n   max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n   parm_reg_stack_loc = ggc_alloc_cleared (max_parm_reg * sizeof (rtx));\n \n-  if (SPLIT_COMPLEX_ARGS)\n+  /* If the target wants to split complex arguments into scalars, do so.  */\n+  if (targetm.calls.split_complex_arg)\n     fnargs = split_complex_args (fnargs);\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -5225,11 +5226,12 @@ assign_parms (tree fndecl)\n \t}\n     }\n \n-  if (SPLIT_COMPLEX_ARGS && fnargs != orig_fnargs)\n+  if (targetm.calls.split_complex_arg && fnargs != orig_fnargs)\n     {\n       for (parm = orig_fnargs; parm; parm = TREE_CHAIN (parm))\n \t{\n-\t  if (TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE)\n+\t  if (TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE\n+\t      && targetm.calls.split_complex_arg (TREE_TYPE (parm)))\n \t    {\n \t      rtx tmp, real, imag;\n \t      enum machine_mode inner = GET_MODE_INNER (DECL_MODE (parm));\n@@ -5373,8 +5375,12 @@ split_complex_args (tree args)\n \n   /* Before allocating memory, check for the common case of no complex.  */\n   for (p = args; p; p = TREE_CHAIN (p))\n-    if (TREE_CODE (TREE_TYPE (p)) == COMPLEX_TYPE)\n-      goto found;\n+    {\n+      tree type = TREE_TYPE (p);\n+      if (TREE_CODE (type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (type))\n+        goto found;\n+    }\n   return args;\n \n  found:\n@@ -5383,7 +5389,8 @@ split_complex_args (tree args)\n   for (p = args; p; p = TREE_CHAIN (p))\n     {\n       tree type = TREE_TYPE (p);\n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n+      if (TREE_CODE (type) == COMPLEX_TYPE\n+\t  && targetm.calls.split_complex_arg (type))\n \t{\n \t  tree decl;\n \t  tree subtype = TREE_TYPE (type);"}, {"sha": "b6d972b1a45e63dfe5aa079da9316cff49184d22", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -606,7 +606,7 @@ typedef char _Bool;\n \tSTRUCT_VALUE_INCOMING STRICT_ARGUMENT_NAMING\t\t\t\\\n \tPROMOTE_FUNCTION_RETURN PROMOTE_PROTOTYPES STRUCT_VALUE_REGNUM\t\\\n \tSETUP_INCOMING_VARARGS EXPAND_BUILTIN_SAVEREGS\t\t\t\\\n-\tDEFAULT_SHORT_ENUMS\n+\tDEFAULT_SHORT_ENUMS SPLIT_COMPLEX_ARGS\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "cfc8a19eb69029d3bc689d68c4d19cbc3f0d2e41", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -346,7 +346,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_EXPAND_BUILTIN_SAVEREGS default_expand_builtin_saveregs\n #define TARGET_SETUP_INCOMING_VARARGS default_setup_incoming_varargs\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_false\n-#define TARGET_PRETEND_OUTGOING_VARARGS_NAMED default_pretend_outgoing_varargs_named\n+#define TARGET_PRETEND_OUTGOING_VARARGS_NAMED \\\n+  default_pretend_outgoing_varargs_named\n+#define TARGET_SPLIT_COMPLEX_ARG NULL\n \n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n@@ -359,6 +361,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SETUP_INCOMING_VARARGS,\t\t\t\t\\\n    TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\\n    TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n+   TARGET_SPLIT_COMPLEX_ARG,\t\t\t\t\t\\\n    }\n \n /* The whole shebang.  */\n@@ -403,14 +406,14 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_DEFAULT_SHORT_ENUMS,\t\t\t\\\n   TARGET_BUILTIN_SETJMP_FRAME_VALUE,\t\t\\\n   TARGET_MD_ASM_CLOBBERS,\t\t\t\\\n+  TARGET_CALLS,\t\t\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n   TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n   TARGET_HAVE_TLS,\t\t\t\t\\\n   TARGET_HAVE_SRODATA_SECTION,\t\t\t\\\n   TARGET_TERMINATE_DW2_EH_FRAME_INFO,\t\t\\\n   TARGET_ASM_FILE_START_APP_OFF,\t\t\\\n   TARGET_ASM_FILE_START_FILE_DIRECTIVE,\t\t\\\n-  TARGET_CALLS,\t\t\t\t\t\\\n }\n \n #include \"hooks.h\""}, {"sha": "e33e815ec8640b5f8ffcb962a10e4b02700f290a", "filename": "gcc/target.h", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42ba51300418d586a41637d9c1fc72c6078b7c6d/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=42ba51300418d586a41637d9c1fc72c6078b7c6d", "patch": "@@ -429,6 +429,30 @@ struct gcc_target\n      the port wishes to automatically clobber for all asms.  */\n   tree (* md_asm_clobbers) (tree);\n \n+  /* Functions relating to calls - argument passing, returns, etc.  */\n+  struct calls {\n+    bool (*promote_function_args) (tree fntype);\n+    bool (*promote_function_return) (tree fntype);\n+    bool (*promote_prototypes) (tree fntype);\n+    rtx (*struct_value_rtx) (tree fndecl, int incoming);\n+    bool (*return_in_memory) (tree type, tree fndecl);\n+    bool (*return_in_msb) (tree type);\n+    rtx (*expand_builtin_saveregs) (void);\n+    /* Returns pretend_argument_size.  */\n+    void (*setup_incoming_varargs) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\t\t    tree type, int *pretend_arg_size,\n+\t\t\t\t    int second_time);\n+    bool (*strict_argument_naming) (CUMULATIVE_ARGS *ca);\n+    /* Returns true if we should use\n+       targetm.calls.setup_incoming_varargs() and/or\n+       targetm.calls.strict_argument_naming().  */\n+    bool (*pretend_outgoing_varargs_named) (CUMULATIVE_ARGS *ca);\n+\n+    /* Given a complex type T, return true if a parameter of type T\n+       should be passed as two scalars.  */\n+    bool (* split_complex_arg) (tree type);\n+  } calls;\n+\n   /* Leave the boolean fields at the end.  */\n \n   /* True if arbitrary sections are supported.  */\n@@ -455,24 +479,7 @@ struct gcc_target\n      at the beginning of assembly output.  */\n   bool file_start_file_directive;\n \n-  /* Functions relating to calls - argument passing, returns, etc.  */\n-  struct calls {\n-    bool (*promote_function_args) (tree fntype);\n-    bool (*promote_function_return) (tree fntype);\n-    bool (*promote_prototypes) (tree fntype);\n-    rtx (*struct_value_rtx) (tree fndecl, int incoming);\n-    bool (*return_in_memory) (tree type, tree fndecl);\n-    bool (*return_in_msb) (tree type);\n-    rtx (*expand_builtin_saveregs) (void);\n-    /* Returns pretend_argument_size.  */\n-    void (*setup_incoming_varargs) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n-\t\t\t\t    tree type, int *pretend_arg_size, int second_time);\n-    bool (*strict_argument_naming) (CUMULATIVE_ARGS *ca);\n-    /* Returns true if we should use\n-       targetm.calls.setup_incoming_varargs() and/or\n-       targetm.calls.strict_argument_naming().  */\n-    bool (*pretend_outgoing_varargs_named) (CUMULATIVE_ARGS *ca);\n-  } calls;\n+  /* Leave the boolean fields at the end.  */\n };\n \n extern struct gcc_target targetm;"}]}