{"sha": "46527cc82c394c372e91b7453dccfc1da5899aa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY1MjdjYzgyYzM5NGMzNzJlOTFiNzQ1M2RjY2ZjMWRhNTg5OWFhMA==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2009-10-31T16:40:03Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2009-10-31T16:40:03Z"}, "message": "A9 integer pipeline description.\n\n2009-10-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n        * config/arm/cortex-a9.md: New - integer pipeline description.\n\nFrom-SVN: r153779", "tree": {"sha": "d4414a42acf5ec71a3386164df802b1eceaade62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4414a42acf5ec71a3386164df802b1eceaade62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46527cc82c394c372e91b7453dccfc1da5899aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46527cc82c394c372e91b7453dccfc1da5899aa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46527cc82c394c372e91b7453dccfc1da5899aa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46527cc82c394c372e91b7453dccfc1da5899aa0/comments", "author": null, "committer": null, "parents": [{"sha": "03472fddffd21c67c505d53cc2b3437be16ae090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03472fddffd21c67c505d53cc2b3437be16ae090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03472fddffd21c67c505d53cc2b3437be16ae090"}], "stats": {"total": 190, "additions": 184, "deletions": 6}, "files": [{"sha": "179c40e3d1e0d1744465a686ccc56ac5228f29f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46527cc82c394c372e91b7453dccfc1da5899aa0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46527cc82c394c372e91b7453dccfc1da5899aa0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46527cc82c394c372e91b7453dccfc1da5899aa0", "patch": "@@ -1,3 +1,7 @@\n+2009-10-31  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+        * config/arm/cortex-a9.md: New - integer pipeline description.\n+\n 2009-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-sccvn.c (vn_reference_lookup_3): Bail out instead of"}, {"sha": "d1ad7cba7674559b18dde3e368739397009b8967", "filename": "gcc/config/arm/cortex-a9.md", "status": "modified", "additions": 180, "deletions": 6, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46527cc82c394c372e91b7453dccfc1da5899aa0/gcc%2Fconfig%2Farm%2Fcortex-a9.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46527cc82c394c372e91b7453dccfc1da5899aa0/gcc%2Fconfig%2Farm%2Fcortex-a9.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-a9.md?ref=46527cc82c394c372e91b7453dccfc1da5899aa0", "patch": "@@ -1,6 +1,8 @@\n-;; ARM Cortex-A9 VFP pipeline description\n-;; Copyright (C) 2008 Free Software Foundation, Inc.\n-;; Written by CodeSourcery.\n+;; ARM Cortex-A9 pipeline description\n+;; Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+;; Originally written by CodeSourcery for VFP.\n+;;\n+;; Integer core pipeline description contributed by ARM Ltd.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -20,9 +22,181 @@\n \n (define_automaton \"cortex_a9\")\n \n-;; FIXME: We model a single pipeline for all instructions.\n-;; Is dual-issue possible, and do we have other pipelines?\n-(define_cpu_unit \"cortex_a9_vfp\" \"cortex_a9\")\n+;; The Cortex-A9 integer core is modelled as a dual issue pipeline that has\n+;; the following components.\n+;; 1. 1 Load Store Pipeline.\n+;; 2. P0 / main pipeline for data processing instructions.\n+;; 3. P1 / Dual pipeline for Data processing instructions.\n+;; 4. MAC pipeline for multiply as well as multiply\n+;;    and accumulate instructions.\n+;; 5. 1 VFP / Neon pipeline.\n+;; The Load/Store and VFP/Neon pipeline are multiplexed.\n+;; The P0 / main pipeline and M1 stage of the MAC pipeline are\n+;;   multiplexed.\n+;; The P1 / dual pipeline and M2 stage of the MAC pipeline are\n+;;   multiplexed.\n+;; There are only 4 register read ports and hence at any point of\n+;; time we can't have issue down the E1 and the E2 ports unless\n+;; of course there are bypass paths that get exercised.\n+;; Both P0 and P1 have 2 stages E1 and E2.\n+;; Data processing instructions issue to E1 or E2 depending on\n+;; whether they have an early shift or not.\n+\n+\n+(define_cpu_unit \"cortex_a9_vfp, cortex_a9_ls\" \"cortex_a9\")\n+(define_cpu_unit \"cortex_a9_p0_e1, cortex_a9_p0_e2\" \"cortex_a9\")\n+(define_cpu_unit \"cortex_a9_p1_e1, cortex_a9_p1_e2\" \"cortex_a9\")\n+(define_cpu_unit \"cortex_a9_p0_wb, cortex_a9_p1_wb\" \"cortex_a9\")\n+(define_cpu_unit \"cortex_a9_mac_m1, cortex_a9_mac_m2\" \"cortex_a9\")\n+(define_cpu_unit \"cortex_a9_branch, cortex_a9_issue_branch\" \"cortex_a9\")\n+\n+(define_reservation \"cortex_a9_p0_default\" \"cortex_a9_p0_e2, cortex_a9_p0_wb\")\n+(define_reservation \"cortex_a9_p1_default\" \"cortex_a9_p1_e2, cortex_a9_p1_wb\")\n+(define_reservation \"cortex_a9_p0_shift\" \"cortex_a9_p0_e1, cortex_a9_p0_default\")\n+(define_reservation \"cortex_a9_p1_shift\" \"cortex_a9_p1_e1, cortex_a9_p1_default\")\n+\n+(define_reservation \"cortex_a9_multcycle1\"\n+  \"cortex_a9_p0_e2 + cortex_a9_mac_m1 + cortex_a9_mac_m2 + \\\n+cortex_a9_p1_e2 + cortex_a9_p0_e1 + cortex_a9_p1_e1\")\n+\n+(define_reservation \"cortex_a9_mult16\"\n+  \"cortex_a9_mac_m1, cortex_a9_mac_m2, cortex_a9_p0_wb\")\n+(define_reservation \"cortex_a9_mac16\"\n+  \"cortex_a9_multcycle1, cortex_a9_mac_m2, cortex_a9_p0_wb\")\n+(define_reservation \"cortex_a9_mult\"\n+  \"cortex_a9_mac_m1*2, cortex_a9_mac_m2, cortex_a9_p0_wb\")\n+(define_reservation \"cortex_a9_mac\"\n+  \"cortex_a9_multcycle1*2 ,cortex_a9_mac_m2, cortex_a9_p0_wb\")\n+\n+\n+;; Issue at the same time along the load store pipeline and\n+;; the VFP / Neon pipeline is not possible.\n+;; FIXME:: At some point we need to model the issue\n+;; of the load store and the vfp being shared rather than anything else.\n+\n+(exclusion_set \"cortex_a9_ls\" \"cortex_a9_vfp\")\n+\n+\n+;; Default data processing instruction without any shift\n+;; The only exception to this is the mov instruction\n+;; which can go down E2 without any problem.\n+(define_insn_reservation \"cortex_a9_dp\" 2\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (ior (eq_attr \"type\" \"alu\")\n+\t    (and (eq_attr \"type\" \"alu_shift_reg, alu_shift\")\n+\t\t (eq_attr \"insn\" \"mov\"))))\n+  \"cortex_a9_p0_default|cortex_a9_p1_default\")\n+\n+;; An instruction using the shifter will go down E1.\n+(define_insn_reservation \"cortex_a9_dp_shift\" 3\n+   (and (eq_attr \"tune\" \"cortexa9\")\n+\t(and (eq_attr \"type\" \"alu_shift_reg, alu_shift\")\n+\t     (not (eq_attr \"insn\" \"mov\"))))\n+   \"cortex_a9_p0_shift | cortex_a9_p1_shift\")\n+\n+;; Loads have a latency of 4 cycles.\n+;; We don't model autoincrement instructions. These\n+;; instructions use the load store pipeline and 1 of\n+;; the E2 units to write back the result of the increment.\n+\n+(define_insn_reservation \"cortex_a9_load1_2\" 4\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"load1, load2, load_byte\"))\n+  \"cortex_a9_ls\")\n+\n+;; Loads multiples and store multiples can't be issued for 2 cycles in a\n+;; row. The description below assumes that addresses are 64 bit aligned.\n+;; If not, there is an extra cycle latency which is not modelled.\n+\n+;; FIXME:: This bit might need to be reworked when we get to\n+;; tuning for the VFP because strictly speaking the ldm\n+;; is sent to the LSU unit as is and there is only an\n+;; issue restriction between the LSU and the VFP/ Neon unit.\n+\n+(define_insn_reservation \"cortex_a9_load3_4\" 5\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"load3, load4\"))\n+  \"cortex_a9_ls, cortex_a9_ls\")\n+\n+(define_insn_reservation \"cortex_a9_store1_2\" 0\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"store1, store2\"))\n+  \"cortex_a9_ls\")\n+\n+;; Almost all our store multiples use an auto-increment\n+;; form. Don't issue back to back load and store multiples\n+;; because the load store unit will stall.\n+(define_insn_reservation \"cortex_a9_store3_4\" 0\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"store3, store4\"))\n+  \"cortex_a9_ls+(cortex_a9_p0_default | cortex_a9_p1_default), cortex_a9_ls\")\n+\n+;; We get 16*16 multiply / mac results in 3 cycles.\n+(define_insn_reservation \"cortex_a9_mult16\" 3\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"insn\" \"smulxy\"))\n+       \"cortex_a9_mult16\")\n+\n+;; The 16*16 mac is slightly different that it\n+;; reserves M1 and M2 in the same cycle.\n+(define_insn_reservation \"cortex_a9_mac16\" 3\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"insn\" \"smlaxy\"))\n+  \"cortex_a9_mac16\")\n+\n+\n+(define_insn_reservation \"cortex_a9_multiply\" 4\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"insn\" \"mul\"))\n+       \"cortex_a9_mult\")\n+\n+(define_insn_reservation \"cortex_a9_mac\" 4\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"insn\" \"mla\"))\n+       \"cortex_a9_mac\")\n+\n+;; An instruction with a result in E2 can be forwarded\n+;; to E2 or E1 or M1 or the load store unit in the next cycle.\n+\n+(define_bypass 1 \"cortex_a9_dp\"\n+                 \"cortex_a9_dp_shift, cortex_a9_multiply,\n+ cortex_a9_load1_2, cortex_a9_dp, cortex_a9_store1_2,\n+ cortex_a9_mult16, cortex_a9_mac16, cortex_a9_mac, cortex_a9_store3_4, cortex_a9_load3_4\")\n+\n+(define_bypass 2 \"cortex_a9_dp_shift\"\n+                 \"cortex_a9_dp_shift, cortex_a9_multiply,\n+ cortex_a9_load1_2, cortex_a9_dp, cortex_a9_store1_2,\n+ cortex_a9_mult16, cortex_a9_mac16, cortex_a9_mac, cortex_a9_store3_4, cortex_a9_load3_4\")\n+\n+;; An instruction in the load store pipeline can provide\n+;; read access to a DP instruction in the P0 default pipeline\n+;; before the writeback stage.\n+\n+(define_bypass 3 \"cortex_a9_load1_2\" \"cortex_a9_dp, cortex_a9_load1_2,\n+cortex_a9_store3_4, cortex_a9_store1_2\")\n+\n+(define_bypass 4 \"cortex_a9_load3_4\" \"cortex_a9_dp, cortex_a9_load1_2,\n+cortex_a9_store3_4, cortex_a9_store1_2,  cortex_a9_load3_4\")\n+\n+;; Calls and branches.\n+\n+;; Branch instructions\n+\n+(define_insn_reservation \"cortex_a9_branch\" 0\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"branch\"))\n+  \"cortex_a9_branch\")\n+\n+;; Call latencies are essentially 0 but make sure\n+;; dual issue doesn't happen i.e the next instruction\n+;; starts at the next cycle.\n+(define_insn_reservation \"cortex_a9_call\"  0\n+  (and (eq_attr \"tune\" \"cortexa9\")\n+       (eq_attr \"type\" \"call\"))\n+  \"cortex_a9_issue_branch + cortex_a9_multcycle1 + cortex_a9_ls + cortex_a9_vfp\")\n+\n+\n+;; Pipelining for VFP instructions.\n \n (define_insn_reservation \"cortex_a9_ffarith\" 1\n  (and (eq_attr \"tune\" \"cortexa9\")"}]}