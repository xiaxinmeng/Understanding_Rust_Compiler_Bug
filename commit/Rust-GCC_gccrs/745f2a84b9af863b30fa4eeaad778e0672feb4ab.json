{"sha": "745f2a84b9af863b30fa4eeaad778e0672feb4ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ1ZjJhODRiOWFmODYzYjMwZmE0ZWVhYWQ3NzhlMDY3MmZlYjRhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-11-02T02:12:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-11-02T02:12:32Z"}, "message": "re PR target/21518 (unable to find a register with -fPIC and -O2 and non inlining static function)\n\n        PR 21518\n        * loop.c (scan_loop): Do not propagate computations to a hard\n        register destination with SMALL_REGISTER_CLASSES.\n\nFrom-SVN: r106373", "tree": {"sha": "f8c7bb3ac6acc88ef7399b4180d01aa78289266f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8c7bb3ac6acc88ef7399b4180d01aa78289266f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/745f2a84b9af863b30fa4eeaad778e0672feb4ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/745f2a84b9af863b30fa4eeaad778e0672feb4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/745f2a84b9af863b30fa4eeaad778e0672feb4ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/745f2a84b9af863b30fa4eeaad778e0672feb4ab/comments", "author": null, "committer": null, "parents": [{"sha": "12674da393dd9681b088012753fb0111156ab1b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12674da393dd9681b088012753fb0111156ab1b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12674da393dd9681b088012753fb0111156ab1b1"}], "stats": {"total": 94, "additions": 68, "deletions": 26}, "files": [{"sha": "e6d1b9c6b5b1cc09aa992db21a624cd4fd83ad55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f2a84b9af863b30fa4eeaad778e0672feb4ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f2a84b9af863b30fa4eeaad778e0672feb4ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=745f2a84b9af863b30fa4eeaad778e0672feb4ab", "patch": "@@ -1,3 +1,9 @@\n+2005-11-01  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 21518\n+\t* loop.c (scan_loop): Do not propagate computations to a hard\n+\tregister destination with SMALL_REGISTER_CLASSES.\n+\n 2005-11-01  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* config/rs6000/rs6000.c (rs6000_rtx_costs): Do not add extra"}, {"sha": "b16c6a75eb5789a7d7c960c71f0aaac6c5032c70", "filename": "gcc/loop.c", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f2a84b9af863b30fa4eeaad778e0672feb4ab/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f2a84b9af863b30fa4eeaad778e0672feb4ab/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=745f2a84b9af863b30fa4eeaad778e0672feb4ab", "patch": "@@ -1266,54 +1266,58 @@ scan_loop (struct loop *loop, int flags)\n \t\t{\n \t\t  struct movable *m;\n \t\t  int regno = REGNO (SET_DEST (set));\n+\t\t  rtx user, user_set;\n \n-\t\t  /* A potential lossage is where we have a case where two insns\n-\t\t     can be combined as long as they are both in the loop, but\n-\t\t     we move one of them outside the loop.  For large loops,\n-\t\t     this can lose.  The most common case of this is the address\n-\t\t     of a function being called.\n+\t\t  /* A potential lossage is where we have a case where two\n+\t\t     insns can be combined as long as they are both in the\n+\t\t     loop, but we move one of them outside the loop.  For\n+\t\t     large loops, this can lose.  The most common case of\n+\t\t     this is the address of a function being called.\n \n \t\t     Therefore, if this register is marked as being used\n \t\t     exactly once if we are in a loop with calls\n \t\t     (a \"large loop\"), see if we can replace the usage of\n \t\t     this register with the source of this SET.  If we can,\n \t\t     delete this insn.\n \n-\t\t     Don't do this if P has a REG_RETVAL note or if we have\n-\t\t     SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n+\t\t     Don't do this if:\n+\t\t      (1) P has a REG_RETVAL note or\n+\t\t      (2) if we have SMALL_REGISTER_CLASSES and\n+\t\t\t(a) SET_SRC is a hard register or\n+\t\t\t(b) the destination of the user is a hard register.  */\n \n \t\t  if (loop_info->has_call\n-\t\t      && regs->array[regno].single_usage != 0\n-\t\t      && regs->array[regno].single_usage != const0_rtx\n+\t\t      && regno >= FIRST_PSEUDO_REGISTER \n+\t\t      && (user = regs->array[regno].single_usage) != NULL\n+\t\t      && user != const0_rtx\n \t\t      && REGNO_FIRST_UID (regno) == INSN_UID (p)\n-\t\t      && (REGNO_LAST_UID (regno)\n-\t\t\t  == INSN_UID (regs->array[regno].single_usage))\n+\t\t      && REGNO_LAST_UID (regno) == INSN_UID (user)\n \t\t      && regs->array[regno].set_in_loop == 1\n \t\t      && GET_CODE (SET_SRC (set)) != ASM_OPERANDS\n \t\t      && ! side_effects_p (SET_SRC (set))\n \t\t      && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n-\t\t      && (! SMALL_REGISTER_CLASSES\n-\t\t\t  || (! (REG_P (SET_SRC (set))\n-\t\t\t\t && (REGNO (SET_SRC (set))\n-\t\t\t\t     < FIRST_PSEUDO_REGISTER))))\n-\t\t      && regno >= FIRST_PSEUDO_REGISTER \n+\t\t      && (!SMALL_REGISTER_CLASSES\n+\t\t\t  || !REG_P (SET_SRC (set))\n+\t\t\t  || !HARD_REGISTER_P (SET_SRC (set)))\n+\t\t      && (!SMALL_REGISTER_CLASSES\n+\t\t\t  || !NONJUMP_INSN_P (user)\n+\t\t\t  || !(user_set = single_set (user))\n+\t\t\t  || !REG_P (SET_DEST (user_set))\n+\t\t\t  || !HARD_REGISTER_P (SET_DEST (user_set)))\n \t\t      /* This test is not redundant; SET_SRC (set) might be\n \t\t\t a call-clobbered register and the life of REGNO\n \t\t\t might span a call.  */\n-\t\t      && ! modified_between_p (SET_SRC (set), p,\n-\t\t\t\t\t       regs->array[regno].single_usage)\n-\t\t      && no_labels_between_p (p,\n-\t\t\t\t\t      regs->array[regno].single_usage)\n-\t\t      && validate_replace_rtx (SET_DEST (set), SET_SRC (set),\n-\t\t\t\t\t       regs->array[regno].single_usage))\n+\t\t      && ! modified_between_p (SET_SRC (set), p, user)\n+\t\t      && no_labels_between_p (p, user)\n+\t\t      && validate_replace_rtx (SET_DEST (set),\n+\t\t\t\t\t       SET_SRC (set), user))\n \t\t    {\n \t\t      /* Replace any usage in a REG_EQUAL note.  Must copy\n \t\t\t the new source, so that we don't get rtx sharing\n \t\t\t between the SET_SOURCE and REG_NOTES of insn p.  */\n-\t\t      REG_NOTES (regs->array[regno].single_usage)\n-\t\t\t= (replace_rtx\n-\t\t\t   (REG_NOTES (regs->array[regno].single_usage),\n-\t\t\t    SET_DEST (set), copy_rtx (SET_SRC (set))));\n+\t\t      REG_NOTES (user)\n+\t\t\t= replace_rtx (REG_NOTES (user), SET_DEST (set),\n+\t\t\t\t       copy_rtx (SET_SRC (set)));\n \n \t\t      delete_insn (p);\n \t\t      for (i = 0; i < LOOP_REGNO_NREGS (regno, SET_DEST (set));"}, {"sha": "f2ac666071e5ebda8739920340cb7a0fac6a7b4c", "filename": "gcc/testsuite/gcc.target/i386/pr21518.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f2a84b9af863b30fa4eeaad778e0672feb4ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21518.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f2a84b9af863b30fa4eeaad778e0672feb4ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21518.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr21518.c?ref=745f2a84b9af863b30fa4eeaad778e0672feb4ab", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fPIC -fno-tree-pre\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+extern void __attribute__ ((regparm (3)))\n+drawPointsLines (char type, int first, int *dd);\n+\n+int\n+do_locator (int *call)\n+{\n+  char prephitmp5;\n+  int type;\n+  int i;\n+\n+  if (call == 0)\n+    prephitmp5 = 1;\n+  else\n+    {\n+      type = *call;\n+      i = 0;\n+      do\n+\t{\n+\t  if (i != type)\n+\t    drawPointsLines ((int) (char) type, 0, call);\n+\t  i = i + 1;\n+\t}\n+      while (i != 2);\n+      prephitmp5 = (char) type;\n+    }\n+  drawPointsLines ((int) prephitmp5, 0, call);\n+  return 0;\n+}"}]}