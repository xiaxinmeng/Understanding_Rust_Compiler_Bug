{"sha": "29ef50b6bc609130a1550cdfc3997d1e501ffb28", "node_id": "C_kwDOANBUbNoAKDI5ZWY1MGI2YmM2MDkxMzBhMTU1MGNkZmMzOTk3ZDFlNTAxZmZiMjg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-01T12:34:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-01T12:34:51Z"}, "message": "libstdc++-v3: Some std::*float*_t charconv and i/ostream overloads\n\nThe following patch adds the easy part of <charconv>, <istream> and\n<ostream> changes for extended floats.\nIn particular, for the first one only overloads where the _Float* has\nthe same format as float/double/long double and for the latter two\neverything but the _GLIBCXX_HAVE_FLOAT128_MATH case.\nFor charconv, I'm not really familiar with it, I'm pretty sure\nwe need new libstdc++.so.6 side implementation of from_chars for\n{,b}float16_t and for to_chars not really sure but for unspecified precision\nif it should emit minimum characters that to_chars then can unambiguously\nparse, I think it is less than in the float case.  For float128_t\n{to,from}_chars I think we even have it on the library side already, just\nifdefed for powerpc64le only.\nFor i/o stream operator<</>>, not sure what is better, if not providing\nanything at all, or doing what we in the end do if user doesn't override\nthe virtual functions, or use {to,from}_chars under the hood, something\nelse?\nBesides this, the patch adds some further missed\n// { dg-options \"-std=gnu++2b\" }\nspots, I've also noticed I got the formatting wrong in some testcases\nby not using spaces around VERIFY conditions and elsewhere by having\nspace before ( for calls.\nThe testsuite coverage is limited, I've added test for from_chars because\nit was easy to port, but not really sure what to do about to_chars, it has\nfor float/double huge testcases which would be excessive to repeat.\nAnd for i/ostream not really sure what exactly is worth testing.\n\n2022-11-01  Jakub Jelinek  <jakub@redhat.com>\n\n\t* include/std/charconv (from_chars, to_chars): Add _Float{32,64,128}\n\toverloads for cases where those types match {float,double,long double}.\n\t* include/std/istream (basic_istream::operator>>): Add\n\t_Float{16,32,64,128} and __gnu_cxx::__bfloat16_t overloads.\n\t* include/std/ostream (basic_ostream::operator<<): Add\n\t_Float{16,32,64,128} and __gnu_cxx::__bfloat16_t overloads.\n\t* testsuite/20_util/from_chars/8.cc: New test.\n\t* testsuite/26_numerics/headers/cmath/nextafter_c++23.cc (test):\n\tFormatting fixes.\n\t* testsuite/26_numerics/headers/cmath/functions_std_c++23.cc: Add\n\tdg-options \"-std=gnu++2b\".\n\t(test_functions, main): Formatting fixes.\n\t* testsuite/26_numerics/headers/cmath/c99_classification_macros_c++23.cc:\n\tAdd dg-options \"-std=gnu++2b\".", "tree": {"sha": "ca94c6eaf682309b1bafd19952ddc56716ac1d82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca94c6eaf682309b1bafd19952ddc56716ac1d82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ef50b6bc609130a1550cdfc3997d1e501ffb28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ef50b6bc609130a1550cdfc3997d1e501ffb28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ef50b6bc609130a1550cdfc3997d1e501ffb28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ef50b6bc609130a1550cdfc3997d1e501ffb28/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cee5f94000ee5eabce9b223c44c7923c1c69f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cee5f94000ee5eabce9b223c44c7923c1c69f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cee5f94000ee5eabce9b223c44c7923c1c69f61"}], "stats": {"total": 832, "additions": 710, "deletions": 122}, "files": [{"sha": "9b9cd83515b45a5de388af91a91b359ca43b817d", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=29ef50b6bc609130a1550cdfc3997d1e501ffb28", "patch": "@@ -672,6 +672,45 @@ namespace __detail\n   from_chars_result\n   from_chars(const char* __first, const char* __last, long double& __value,\n \t     chars_format __fmt = chars_format::general) noexcept;\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline from_chars_result\n+  from_chars(const char* __first, const char* __last, _Float32& __value,\n+\t     chars_format __fmt = chars_format::general) noexcept\n+  {\n+    float __val;\n+    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n+    if (__res.ec == errc{})\n+      __value = __val;\n+    return __res;\n+  }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline from_chars_result\n+  from_chars(const char* __first, const char* __last, _Float64& __value,\n+\t     chars_format __fmt = chars_format::general) noexcept\n+  {\n+    double __val;\n+    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n+    if (__res.ec == errc{})\n+      __value = __val;\n+    return __res;\n+  }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  inline from_chars_result\n+  from_chars(const char* __first, const char* __last, _Float128& __value,\n+\t     chars_format __fmt = chars_format::general) noexcept\n+  {\n+    long double __val;\n+    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n+    if (__res.ec == errc{})\n+      __value = __val;\n+    return __res;\n+  }\n+#endif\n #endif\n \n #if defined __cpp_lib_to_chars\n@@ -698,6 +737,53 @@ namespace __detail\n \t\t\t   chars_format __fmt) noexcept;\n   to_chars_result to_chars(char* __first, char* __last, long double __value,\n \t\t\t   chars_format __fmt, int __precision) noexcept;\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float32 __value) noexcept\n+  { return to_chars(__first, __last, float(__value)); }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float32 __value,\n+\t   chars_format __fmt) noexcept\n+  { return to_chars(__first, __last, float(__value), __fmt); }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float32 __value,\n+\t   chars_format __fmt, int __precision) noexcept\n+  { return to_chars(__first, __last, float(__value), __fmt, __precision); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float64 __value) noexcept\n+  { return to_chars(__first, __last, double(__value)); }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float64 __value,\n+\t   chars_format __fmt) noexcept\n+  { return to_chars(__first, __last, double(__value), __fmt); }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float64 __value,\n+\t   chars_format __fmt, int __precision) noexcept\n+  { return to_chars(__first, __last, double(__value), __fmt, __precision); }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float128 __value) noexcept\n+  { return to_chars(__first, __last, static_cast<long double>(__value)); }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float128 __value,\n+\t   chars_format __fmt) noexcept\n+  {\n+    return to_chars(__first, __last, static_cast<long double>(__value), __fmt);\n+  }\n+  inline to_chars_result\n+  to_chars(char* __first, char* __last, _Float128 __value,\n+\t   chars_format __fmt, int __precision) noexcept\n+  {\n+    return to_chars(__first, __last, static_cast<long double>(__value), __fmt,\n+\t\t    __precision);\n+  }\n+#endif\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "8476d62d2afcd10920990ea20ad23240388c0f05", "filename": "libstdc++-v3/include/std/istream", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream?ref=29ef50b6bc609130a1550cdfc3997d1e501ffb28", "patch": "@@ -225,6 +225,94 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return _M_extract(__f); }\n       ///@}\n \n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+      __attribute__((__always_inline__))\n+      __istream_type&\n+      operator>>(_Float16& __f)\n+      {\n+\tfloat __flt;\n+\t__istream_type& __ret = _M_extract(__flt);\n+\tios_base::iostate __err = ios_base::goodbit;\n+\tif (__flt < -__FLT16_MAX__)\n+\t  {\n+\t    __f = -__FLT16_MAX__;\n+\t    __err = ios_base::failbit;\n+\t  }\n+\telse if (__flt > __FLT16_MAX__)\n+\t  {\n+\t    __f = __FLT16_MAX__;\n+\t    __err = ios_base::failbit;\n+\t  }\n+\telse\n+\t  __f = static_cast<_Float16>(__flt);\n+\tif (__err)\n+\t  this->setstate(__err);\n+\treturn __ret;\n+      }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+      __attribute__((__always_inline__))\n+      __istream_type&\n+      operator>>(_Float32& __f)\n+      {\n+\tfloat __flt;\n+\t__istream_type& __ret = _M_extract(__flt);\n+\t__f = static_cast<_Float32> (__flt);\n+\treturn __ret;\n+      }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+      __attribute__((__always_inline__))\n+      __istream_type&\n+      operator>>(_Float64& __f)\n+      {\n+\tdouble __dbl;\n+\t__istream_type& __ret = _M_extract(__dbl);\n+\t__f = static_cast<_Float64> (__dbl);\n+\treturn __ret;\n+      }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+      __attribute__((__always_inline__))\n+      __istream_type&\n+      operator>>(_Float128& __f)\n+      {\n+\tlong double __ldbl;\n+\t__istream_type& __ret = _M_extract(__ldbl);\n+\t__f = static_cast<_Float128> (__ldbl);\n+\treturn __ret;\n+      }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+      __attribute__((__always_inline__))\n+      __istream_type&\n+      operator>>(__gnu_cxx::__bfloat16_t & __f)\n+      {\n+\tfloat __flt;\n+\t__istream_type& __ret = _M_extract(__flt);\n+\tios_base::iostate __err = ios_base::goodbit;\n+\tif (__flt < -__BFLT16_MAX__)\n+\t  {\n+\t    __f = -__BFLT16_MAX__;\n+\t    __err = ios_base::failbit;\n+\t  }\n+\telse if (__flt > __BFLT16_MAX__)\n+\t  {\n+\t    __f = __BFLT16_MAX__;\n+\t    __err = ios_base::failbit;\n+\t  }\n+\telse\n+\t  __f = static_cast<__gnu_cxx::__bfloat16_t>(__flt);\n+\tif (__err)\n+\t  this->setstate(__err);\n+\treturn __ret;\n+      }\n+#endif\n+\n       /**\n        *  @brief  Basic arithmetic extractors\n        *  @param  __p A variable of pointer type."}, {"sha": "ffffec77f38bde9b928badba5f5b9a5464fc33bc", "filename": "libstdc++-v3/include/std/ostream", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream?ref=29ef50b6bc609130a1550cdfc3997d1e501ffb28", "patch": "@@ -235,6 +235,51 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return _M_insert(__f); }\n       ///@}\n \n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+      __attribute__((__always_inline__))\n+      __ostream_type&\n+      operator<<(_Float16 __f)\n+      {\n+\treturn _M_insert(static_cast<double>(__f));\n+      }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+      __attribute__((__always_inline__))\n+      __ostream_type&\n+      operator<<(_Float32 __f)\n+      {\n+\treturn _M_insert(static_cast<double>(__f));\n+      }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+      __attribute__((__always_inline__))\n+      __ostream_type&\n+      operator<<(_Float64 __f)\n+      {\n+\treturn _M_insert(static_cast<double>(__f));\n+      }\n+#endif\n+\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+      __attribute__((__always_inline__))\n+      __ostream_type&\n+      operator<<(_Float128 __f)\n+      {\n+\treturn _M_insert(static_cast<long double>(__f));\n+      }\n+#endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+      __attribute__((__always_inline__))\n+      __ostream_type&\n+      operator<<(__gnu_cxx::__bfloat16_t __f)\n+      {\n+\treturn _M_insert(static_cast<double>(__f));\n+      }\n+#endif\n+\n       /**\n        *  @brief  Pointer arithmetic inserters\n        *  @param  __p A variable of pointer type."}, {"sha": "ba34c2c170d5393428a14619d871cf618f80efd6", "filename": "libstdc++-v3/testsuite/20_util/from_chars/8.cc", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F8.cc?ref=29ef50b6bc609130a1550cdfc3997d1e501ffb28", "patch": "@@ -0,0 +1,367 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do run { target c++23 } }\n+// { dg-add-options ieee }\n+\n+#include <charconv>\n+#include <string>\n+#include <limits>\n+#include <stdfloat>\n+#include <cmath>\n+#include <cstdlib>\n+#include <testsuite_hooks.h>\n+\n+// Test std::from_chars floating-point conversions.\n+\n+#if __cpp_lib_to_chars >= 201611L\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+void\n+test01()\n+{\n+  std::string s;\n+  std::float64_t f64;\n+  std::from_chars_result res;\n+\n+  for (auto fmt : { std::chars_format::fixed, std::chars_format::scientific,\n+\t\t    std::chars_format::general, std::chars_format::hex })\n+  {\n+    s = \"Info\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), f64, fmt);\n+    VERIFY( std::isinf(f64) );\n+    VERIFY( res.ptr == s.data() + 3 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"-INFIN\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), f64, fmt);\n+    VERIFY( std::isinf(f64) );\n+    VERIFY( f64 < 0 );\n+    VERIFY( res.ptr == s.data() + 4 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"InFiNiTy aNd BeYoNd\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), f64, fmt);\n+    VERIFY( std::isinf(f64) );\n+    VERIFY( res.ptr == s.data() + 8 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"nAn\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), f64, fmt);\n+    VERIFY( std::isnan(f64) );\n+    VERIFY( res.ptr == s.data() + 3 );\n+    VERIFY( res.ec == std::errc{} );\n+\n+    s = \"-NAN()\";\n+    res = std::from_chars(s.data(), s.data() + s.length(), f64, fmt);\n+    VERIFY( std::isnan(f64) );\n+    VERIFY( res.ptr == s.data() + s.length() );\n+    VERIFY( res.ec == std::errc{} );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  std::string s;\n+  std::float64_t f64 = 1.0f64;\n+  std::from_chars_result res;\n+\n+  s = \"0x123\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64);\n+  VERIFY( f64 == 0.0f64 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  f64 = 1.0f64;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::fixed);\n+  VERIFY( f64 == 0.0f64 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  f64 = 1.0f64;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::scientific);\n+  VERIFY( f64 == 1.0f64 );\n+  VERIFY( res.ptr == s.data() );\n+  VERIFY( res.ec == std::errc::invalid_argument );\n+\n+  f64 = 1.0f64;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::general);\n+  VERIFY( f64 == 0.0f64 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  f64 = 1.0f64;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::hex);\n+  VERIFY( f64 == 0.0f64 );\n+  VERIFY( res.ptr == s.data() + 1 );\n+  VERIFY( res.ec == std::errc{} );\n+}\n+\n+void\n+test03()\n+{\n+  std::string s;\n+  std::float64_t f64 = 1.0f64;\n+  std::from_chars_result res;\n+\n+  s = \"0.5e+2azzz\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64);\n+  VERIFY( f64 == 0.5e+2f64 );\n+  VERIFY( res.ptr == s.data() + s.length() - 1 - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::fixed);\n+  VERIFY( f64 == 0.5f64 );\n+  VERIFY( res.ptr == s.data() + 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  f64 = 1.0f64;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::scientific);\n+  VERIFY( f64 == 0.5e+2f64 );\n+  VERIFY( res.ptr == s.data() + s.length() - 1 - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  f64 = 1.0f64;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::general);\n+  VERIFY( f64 == 0.5e+2f64 );\n+  VERIFY( res.ptr == s.data() + s.length() - 1 - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  f64 = 1.0;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::hex);\n+  VERIFY( f64 == 0x0.5Ep0f64 );\n+  VERIFY( res.ptr == s.data() + 4 );\n+  VERIFY( res.ec == std::errc{} );\n+\n+  s = \"1.Ap-2zzz\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64,\n+\t\t\tstd::chars_format::hex);\n+  VERIFY( f64 == 0.40625f64 );\n+  VERIFY( res.ptr == s.data() + s.length() - 3 );\n+  VERIFY( res.ec == std::errc{} );\n+}\n+\n+void\n+test04()\n+{\n+  // Huge input strings\n+  std::string s(1000, '0');\n+  std::float64_t f64 = 1.0f64;\n+  std::from_chars_result res;\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64);\n+  VERIFY( res.ptr == s.data() + s.length() );\n+  VERIFY( res.ec == std::errc{} );\n+  VERIFY( f64 == 0.0f64 );\n+\n+  s += \".5\";\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64);\n+  VERIFY( res.ptr == s.data() + s.length() );\n+  VERIFY( res.ec == std::errc{} );\n+  VERIFY( f64 == 0.5f64 );\n+\n+  s += \"e2\";\n+  auto len = s.length();\n+  s += std::string(1000, 'a');\n+  res = std::from_chars(s.data(), s.data() + s.length(), f64);\n+  VERIFY( res.ptr == s.data() + len );\n+  VERIFY( res.ec == std::errc{} );\n+  VERIFY( f64 == 50.f64 );\n+}\n+#endif\n+\n+using std::to_string;\n+\n+#ifdef __GLIBCXX_TYPE_INT_N_0\n+std::string\n+to_string(unsigned __GLIBCXX_TYPE_INT_N_0 val)\n+{\n+  using Limits = std::numeric_limits<unsigned __GLIBCXX_TYPE_INT_N_0>;\n+  std::string s(Limits::digits10+2, '0');\n+  for (auto iter = s.end(); val != 0; val /= 10)\n+    *--iter = '0' + (val % 10);\n+  return s;\n+}\n+#endif\n+\n+template<typename FloatT>\n+void\n+test_small_num()\n+{\n+  std::from_chars_result res;\n+  FloatT flt;\n+\n+  // Small integer values that are exactly representable\n+\n+  for (int i = 0; i < 100; ++i)\n+  {\n+    std::string s = to_string(i);\n+    int len = s.length();\n+    s += \"123\";\n+    const char* s1 = s.c_str();\n+    const char* s1_end = s1 + len;\n+\n+    for (auto fmt : { std::chars_format::fixed,\n+\t\t      std::chars_format::general,\n+\t\t      std::chars_format::hex })\n+    {\n+      if (fmt == std::chars_format::hex && i > 9)\n+\tcontinue;\n+\n+      res = std::from_chars(s1, s1_end, flt, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s1_end );\n+      VERIFY( flt == i );\n+    }\n+\n+    if (i > 9)\n+      continue;\n+\n+    // Test single-digit integers with small exponents.\n+\n+    const char s2[] = { '.', *s1, 'e', '0', '0', '0', '1' };\n+    const char* s2_end = s2 + sizeof(s2);\n+\n+    const char s3[] = { *s1, '0', 'e', '-', '0', '0', '1' };\n+    const char* s3_end = s3 + sizeof(s3);\n+\n+    for (auto fmt : { std::chars_format::scientific,\n+\t\t      std::chars_format::general })\n+    {\n+      res = std::from_chars(s2, s2_end, flt, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s2_end );\n+      VERIFY( flt == i );\n+\n+      res = std::from_chars(s3, s3_end, flt, fmt);\n+      VERIFY( res.ec == std::errc{} );\n+      VERIFY( res.ptr == s3_end );\n+      VERIFY( flt == i );\n+    }\n+  }\n+}\n+\n+void\n+test05()\n+{\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  test_small_num<std::float32_t>();\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  test_small_num<std::float64_t>();\n+#endif\n+#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  test_small_num<std::float128_t>();\n+#endif\n+}\n+\n+template<typename FloatT, typename UIntT>\n+void\n+test_max_mantissa()\n+{\n+  using Float_limits = std::numeric_limits<FloatT>;\n+  using UInt_limits = std::numeric_limits<UIntT>;\n+\n+  if (Float_limits::is_iec559 && Float_limits::digits < UInt_limits::digits)\n+  {\n+#ifdef _GLIBCXX_USE_C99_MATH_TR1\n+    std::printf(\"Testing %d-bit float, using %zu-bit integer\\n\",\n+\tFloat_limits::digits + (int)std::log2(Float_limits::max_exponent) + 1,\n+\tsizeof(UIntT) * __CHAR_BIT__);\n+#endif\n+\n+    std::from_chars_result res;\n+    FloatT flt;\n+\n+    for (int i = 0; i < 10; ++i)\n+    {\n+      // (1 << digits) - 1 is the maximum value of the mantissa\n+      const auto val = ((UIntT)1 << Float_limits::digits) - 1 - i;\n+      std::string s = to_string(val);\n+      auto len = s.length();\n+      s += \"000\"; // these should be ignored\n+      for (auto fmt : { std::chars_format::fixed,\n+\t\t\tstd::chars_format::general })\n+      {\n+\tres = std::from_chars(s.data(), s.data() + len, flt, fmt);\n+\tVERIFY( res.ec == std::errc{} );\n+\tVERIFY( res.ptr == s.data() + len );\n+\tVERIFY( flt == val );\n+      }\n+      s.resize(len);\n+      const auto orig_len = len;\n+      s += \"e+000\";\n+      len = s.length();\n+      s += \"111\";\n+      for (auto fmt : { std::chars_format::scientific,\n+\t\t\tstd::chars_format::general })\n+      {\n+\tres = std::from_chars(s.data(), s.data() + len, flt, fmt);\n+\tVERIFY( res.ec == std::errc{} );\n+\tVERIFY( res.ptr == s.data() + len );\n+\tVERIFY( flt == val );\n+\n+\tstd::string s2 = s.substr(0, len - 5);\n+\ts2.insert(s2.begin() + orig_len - 1, '.');\n+\ts2 += \"e000000000001\";\n+\tres = std::from_chars(s.data(), s.data() + len, flt, fmt);\n+\tVERIFY( res.ec == std::errc{} );\n+\tVERIFY( res.ptr == s.data() + len );\n+\tVERIFY( flt == val );\n+      }\n+    }\n+  }\n+}\n+\n+void\n+test06()\n+{\n+#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n+  test_max_mantissa<std::float32_t, unsigned long>();\n+#endif\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  test_max_mantissa<std::float64_t, unsigned long long>();\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0) \\\n+    && defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n+  test_max_mantissa<std::float128_t, unsigned __GLIBCXX_TYPE_INT_N_0>();\n+#endif\n+}\n+#endif\n+\n+int\n+main()\n+{\n+#if __cpp_lib_to_chars >= 201611L\n+#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+#endif\n+  test05();\n+  test06();\n+#endif\n+}"}, {"sha": "193e77b0ae578f729dc006856b00cce5cc5e8af2", "filename": "libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c++23.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B23.cc?ref=29ef50b6bc609130a1550cdfc3997d1e501ffb28", "patch": "@@ -15,6 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+// { dg-options \"-std=gnu++2b\" }\n // { dg-do link { target c++23 } }\n // { dg-excess-errors \"\" { target uclibc } }\n "}, {"sha": "99436b84446fb2b7f8739fe949f641d172a8ba3d", "filename": "libstdc++-v3/testsuite/26_numerics/headers/cmath/functions_std_c++23.cc", "status": "modified", "additions": 87, "deletions": 86, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Ffunctions_std_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Ffunctions_std_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Ffunctions_std_c%2B%2B23.cc?ref=29ef50b6bc609130a1550cdfc3997d1e501ffb28", "patch": "@@ -15,132 +15,133 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+// { dg-options \"-std=gnu++2b\" }\n // { dg-do link { target c++23 } }\n \n #include <stdfloat>\n #include <cmath>\n \n template <typename T>\n __attribute__((__noipa__)) void\n-test_functions (T *p, int *q, long int *r, long long int *s)\n+test_functions(T *p, int *q, long int *r, long long int *s)\n {\n-  p[0] = std::acos (p[0]);\n-  p[1] = std::asin (p[1]);\n-  p[2] = std::atan (p[2]);\n-  p[3] = std::cos (p[3]);\n-  p[4] = std::sin (p[4]);\n-  p[5] = std::tan (p[5]);\n-  p[6] = std::acosh (p[6]);\n-  p[7] = std::asinh (p[7]);\n-  p[8] = std::atanh (p[8]);\n-  p[9] = std::cosh (p[9]);\n-  p[10] = std::sinh (p[10]);\n-  p[11] = std::tanh (p[11]);\n-  p[12] = std::exp (p[12]);\n-  p[13] = std::exp2 (p[13]);\n-  p[14] = std::expm1 (p[14]);\n-  p[15] = std::log (p[15]);\n-  p[16] = std::log10 (p[16]);\n-  p[17] = std::log1p (p[17]);\n-  p[18] = std::log2 (p[18]);\n-  p[19] = std::logb (p[19]);\n-  p[20] = std::cbrt (p[20]);\n-  p[21] = std::fabs (p[21]);\n-  p[22] = std::sqrt (p[22]);\n-  p[23] = std::erf (p[23]);\n-  p[24] = std::erfc (p[24]);\n-  p[25] = std::lgamma (p[25]);\n-  p[26] = std::tgamma (p[26]);\n-  p[27] = std::ceil (p[27]);\n-  p[28] = std::floor (p[28]);\n-  p[29] = std::nearbyint (p[29]);\n-  p[30] = std::rint (p[30]);\n-  p[31] = std::round (p[31]);\n-  p[32] = std::trunc (p[32]);\n-  p[33] = std::atan2 (p[33], p[100]);\n-  p[34] = std::hypot (p[34], p[101]);\n-  p[35] = std::pow (p[35], p[102]);\n-  p[36] = std::fmod (p[36], p[103]);\n-  p[37] = std::remainder (p[37], p[104]);\n-  p[38] = std::copysign (p[38], p[105]);\n-  p[39] = std::nextafter (p[39], p[106]);\n-  p[40] = std::fdim (p[40], p[107]);\n-  p[41] = std::fmax (p[41], p[108]);\n-  p[42] = std::fmin (p[42], p[109]);\n-  p[43] = std::atan2 (p[43], p[110]);\n-  p[44] = std::frexp (p[44], q + 0);\n-  q[1] = std::ilogb (p[45]);\n-  p[46] = std::ldexp (p[46], q[2]);\n-  p[47] = std::modf (p[47], p + 111);\n-  p[48] = std::scalbn (p[48], q[3]);\n-  p[49] = std::scalbln (p[49], r[0]);\n-  p[50] = std::hypot (p[50], p[111], p[112]);\n-  r[1] = std::lrint (p[51]);\n-  s[0] = std::llrint (p[52]);\n-  r[2] = std::lround (p[53]);\n-  s[1] = std::llround (p[54]);\n-  p[55] = std::remquo (p[55], p[113], q + 4);\n-  p[56] = std::fma (p[56], p[114], p[115]);\n-  p[57] = std::lerp (p[57], p[116], p[117]);\n-  p[58] = std::assoc_laguerre (q[5], q[6], p[58]);\n-  p[59] = std::assoc_legendre (q[7], q[8], p[59]);\n-  p[60] = std::beta (p[60], p[118]);\n-  p[61] = std::comp_ellint_1 (p[61]);\n-  p[62] = std::comp_ellint_2 (p[62]);\n-  p[63] = std::comp_ellint_3 (p[63], p[119]);\n-  p[64] = std::cyl_bessel_i (p[64], p[120]);\n-  p[65] = std::cyl_bessel_j (p[65], p[121]);\n-  p[66] = std::cyl_bessel_k (p[66], p[122]);\n-  p[67] = std::cyl_neumann (p[67], p[123]);\n-  p[68] = std::ellint_1 (p[68], p[124]);\n-  p[69] = std::ellint_2 (p[69], p[125]);\n-  p[70] = std::ellint_3 (p[70], p[126], p[127]);\n-  p[71] = std::expint (p[71]);\n-  p[72] = std::hermite (q[9], p[72]);\n-  p[73] = std::laguerre (q[10], p[73]);\n-  p[74] = std::legendre (q[11], p[72]);\n-  p[75] = std::riemann_zeta (p[75]);\n-  p[76] = std::sph_bessel (q[12], p[76]);\n-  p[77] = std::sph_legendre (q[13], q[14], p[77]);\n-  p[78] = std::sph_neumann (q[15], p[78]);\n+  p[0] = std::acos(p[0]);\n+  p[1] = std::asin(p[1]);\n+  p[2] = std::atan(p[2]);\n+  p[3] = std::cos(p[3]);\n+  p[4] = std::sin(p[4]);\n+  p[5] = std::tan(p[5]);\n+  p[6] = std::acosh(p[6]);\n+  p[7] = std::asinh(p[7]);\n+  p[8] = std::atanh(p[8]);\n+  p[9] = std::cosh(p[9]);\n+  p[10] = std::sinh(p[10]);\n+  p[11] = std::tanh(p[11]);\n+  p[12] = std::exp(p[12]);\n+  p[13] = std::exp2(p[13]);\n+  p[14] = std::expm1(p[14]);\n+  p[15] = std::log(p[15]);\n+  p[16] = std::log10(p[16]);\n+  p[17] = std::log1p(p[17]);\n+  p[18] = std::log2(p[18]);\n+  p[19] = std::logb(p[19]);\n+  p[20] = std::cbrt(p[20]);\n+  p[21] = std::fabs(p[21]);\n+  p[22] = std::sqrt(p[22]);\n+  p[23] = std::erf(p[23]);\n+  p[24] = std::erfc(p[24]);\n+  p[25] = std::lgamma(p[25]);\n+  p[26] = std::tgamma(p[26]);\n+  p[27] = std::ceil(p[27]);\n+  p[28] = std::floor(p[28]);\n+  p[29] = std::nearbyint(p[29]);\n+  p[30] = std::rint(p[30]);\n+  p[31] = std::round(p[31]);\n+  p[32] = std::trunc(p[32]);\n+  p[33] = std::atan2(p[33], p[100]);\n+  p[34] = std::hypot(p[34], p[101]);\n+  p[35] = std::pow(p[35], p[102]);\n+  p[36] = std::fmod(p[36], p[103]);\n+  p[37] = std::remainder(p[37], p[104]);\n+  p[38] = std::copysign(p[38], p[105]);\n+  p[39] = std::nextafter(p[39], p[106]);\n+  p[40] = std::fdim(p[40], p[107]);\n+  p[41] = std::fmax(p[41], p[108]);\n+  p[42] = std::fmin(p[42], p[109]);\n+  p[43] = std::atan2(p[43], p[110]);\n+  p[44] = std::frexp(p[44], q + 0);\n+  q[1] = std::ilogb(p[45]);\n+  p[46] = std::ldexp(p[46], q[2]);\n+  p[47] = std::modf(p[47], p + 111);\n+  p[48] = std::scalbn(p[48], q[3]);\n+  p[49] = std::scalbln(p[49], r[0]);\n+  p[50] = std::hypot(p[50], p[111], p[112]);\n+  r[1] = std::lrint(p[51]);\n+  s[0] = std::llrint(p[52]);\n+  r[2] = std::lround(p[53]);\n+  s[1] = std::llround(p[54]);\n+  p[55] = std::remquo(p[55], p[113], q + 4);\n+  p[56] = std::fma(p[56], p[114], p[115]);\n+  p[57] = std::lerp(p[57], p[116], p[117]);\n+  p[58] = std::assoc_laguerre(q[5], q[6], p[58]);\n+  p[59] = std::assoc_legendre(q[7], q[8], p[59]);\n+  p[60] = std::beta(p[60], p[118]);\n+  p[61] = std::comp_ellint_1(p[61]);\n+  p[62] = std::comp_ellint_2(p[62]);\n+  p[63] = std::comp_ellint_3(p[63], p[119]);\n+  p[64] = std::cyl_bessel_i(p[64], p[120]);\n+  p[65] = std::cyl_bessel_j(p[65], p[121]);\n+  p[66] = std::cyl_bessel_k(p[66], p[122]);\n+  p[67] = std::cyl_neumann(p[67], p[123]);\n+  p[68] = std::ellint_1(p[68], p[124]);\n+  p[69] = std::ellint_2(p[69], p[125]);\n+  p[70] = std::ellint_3(p[70], p[126], p[127]);\n+  p[71] = std::expint(p[71]);\n+  p[72] = std::hermite(q[9], p[72]);\n+  p[73] = std::laguerre(q[10], p[73]);\n+  p[74] = std::legendre(q[11], p[72]);\n+  p[75] = std::riemann_zeta(p[75]);\n+  p[76] = std::sph_bessel(q[12], p[76]);\n+  p[77] = std::sph_legendre(q[13], q[14], p[77]);\n+  p[78] = std::sph_neumann(q[15], p[78]);\n }\n \n int\n-main ()\n+main()\n {\n   int q[16] = {};\n   long int r[16] = {};\n   long long int s[16] = {};\n #if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n   {\n     std::float16_t p[128] = {};\n-    test_functions (p, q, r, s);\n+    test_functions(p, q, r, s);\n   }\n #endif\n #if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n   {\n     std::float32_t p[128] = {};\n-    test_functions (p, q, r, s);\n+    test_functions(p, q, r, s);\n   }\n #endif\n #if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n   {\n     std::float64_t p[128] = {};\n-    test_functions (p, q, r, s);\n+    test_functions(p, q, r, s);\n   }\n #endif\n #if defined(__STDCPP_FLOAT128_T__) \\\n     && (defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY128) \\\n \t|| defined(_GLIBCXX_HAVE_FLOAT128_MATH))\n   {\n     std::float128_t p[128] = {};\n-    test_functions (p, q, r, s);\n+    test_functions(p, q, r, s);\n   }\n #endif\n #if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n   {\n     std::bfloat16_t p[128] = {};\n-    test_functions (p, q, r, s);\n+    test_functions(p, q, r, s);\n   }\n #endif\n }"}, {"sha": "c105901ebd81c362cfbf2d4096ad7331210094ea", "filename": "libstdc++-v3/testsuite/26_numerics/headers/cmath/nextafter_c++23.cc", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fnextafter_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ef50b6bc609130a1550cdfc3997d1e501ffb28/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fnextafter_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fnextafter_c%2B%2B23.cc?ref=29ef50b6bc609130a1550cdfc3997d1e501ffb28", "patch": "@@ -29,77 +29,77 @@ test ()\n {\n   using lim = std::numeric_limits<T>;\n   T t0 = std::nextafter(T(-0.0), T(2.0));\n-  VERIFY(t0 == lim::denorm_min());\n+  VERIFY( t0 == lim::denorm_min() );\n   T t1 = std::nextafter(T(), T(1.0));\n-  VERIFY(t1 == lim::denorm_min());\n+  VERIFY( t1 == lim::denorm_min() );\n   T t2 = std::nextafter(T(), T());\n-  VERIFY(t2 == T() && !std::signbit(t2));\n+  VERIFY( t2 == T() && !std::signbit(t2) );\n   T t3 = std::nextafter(lim::denorm_min(), T(-2.0));\n-  VERIFY(t3 == T() && !std::signbit(t3));\n+  VERIFY( t3 == T() && !std::signbit(t3) );\n   T t4 = std::nextafter(lim::min(), T(-0.0));\n-  VERIFY(std::fpclassify(t4) == FP_SUBNORMAL && t4 > T());\n+  VERIFY( std::fpclassify(t4) == FP_SUBNORMAL && t4 > T() );\n   T t5 = std::nextafter(t4, T(1.0));\n-  VERIFY(t5 == lim::min());\n+  VERIFY( t5 == lim::min() );\n   T t6 = std::nextafter(lim::min(), lim::infinity());\n-  VERIFY(std::fpclassify(t6) == FP_NORMAL && t6 > lim::min());\n+  VERIFY( std::fpclassify(t6) == FP_NORMAL && t6 > lim::min() );\n   T t7 = std::nextafter(t6, -lim::infinity());\n-  VERIFY(t7 == lim::min());\n+  VERIFY( t7 == lim::min() );\n   T t8 = std::nextafter(T(16.0), T(16.5));\n-  VERIFY(t8 > t7);\n+  VERIFY( t8 > t7 );\n   T t9 = std::nextafter(t8, T(15.5));\n-  VERIFY(t9 == T(16.0));\n+  VERIFY( t9 == T(16.0) );\n   T t10 = std::nextafter(lim::max(), T(-0.5));\n-  VERIFY(std::fpclassify(t10) == FP_NORMAL && t10 < lim::max());\n+  VERIFY( std::fpclassify(t10) == FP_NORMAL && t10 < lim::max() );\n   T t11 = std::nextafter(t10, lim::infinity());\n-  VERIFY(t11 == lim::max());\n+  VERIFY( t11 == lim::max() );\n   T t12 = std::nextafter(t11, lim::infinity());\n-  VERIFY(std::fpclassify(t12) == FP_INFINITE && !std::signbit(t12));\n+  VERIFY( std::fpclassify(t12) == FP_INFINITE && !std::signbit(t12) );\n   T t13 = std::nextafter(lim::infinity(), t12);\n-  VERIFY(t13 == t12);\n+  VERIFY( t13 == t12 );\n   T t14 = std::nextafter(t13, T(1.0));\n-  VERIFY(t14 == lim::max());\n+  VERIFY( t14 == lim::max() );\n   T t15 = std::nextafter(lim::quiet_NaN(), T());\n-  VERIFY(std::fpclassify(t15) == FP_NAN);\n+  VERIFY( std::fpclassify(t15) == FP_NAN );\n   T t16 = std::nextafter(T(17.0), lim::quiet_NaN());\n-  VERIFY(std::fpclassify(t16) == FP_NAN);\n+  VERIFY( std::fpclassify(t16) == FP_NAN );\n   T t17 = std::nextafter(T(), T(-0.0));\n-  VERIFY(t17 == T() && std::signbit(t17));\n+  VERIFY( t17 == T() && std::signbit(t17) );\n   T t20 = std::nextafter(T(-0.0), T(-2.0));\n-  VERIFY(t20 == -lim::denorm_min());\n+  VERIFY( t20 == -lim::denorm_min() );\n   T t21 = std::nextafter(T(), T(-1.0));\n-  VERIFY(t21 == -lim::denorm_min());\n+  VERIFY( t21 == -lim::denorm_min() );\n   T t22 = std::nextafter(T(-0.0), T(-0.0));\n-  VERIFY(t22 == T() && std::signbit(t22));\n+  VERIFY( t22 == T() && std::signbit(t22) );\n   T t23 = std::nextafter(-lim::denorm_min(), T(2.0));\n-  VERIFY(t23 == T() && std::signbit(t23));\n+  VERIFY( t23 == T() && std::signbit(t23) );\n   T t24 = std::nextafter(-lim::min(), T());\n-  VERIFY(std::fpclassify(t24) == FP_SUBNORMAL && t24 < T());\n+  VERIFY( std::fpclassify(t24) == FP_SUBNORMAL && t24 < T() );\n   T t25 = std::nextafter(t24, T(-1.0));\n-  VERIFY(t25 == -lim::min());\n+  VERIFY( t25 == -lim::min() );\n   T t26 = std::nextafter(-lim::min(), -lim::infinity());\n-  VERIFY(std::fpclassify(t26) == FP_NORMAL && t26 < -lim::min());\n+  VERIFY( std::fpclassify(t26) == FP_NORMAL && t26 < -lim::min() );\n   T t27 = std::nextafter(t26, lim::infinity());\n-  VERIFY(t27 == -lim::min());\n+  VERIFY( t27 == -lim::min() );\n   T t28 = std::nextafter(T(-16.0), T(-16.5));\n-  VERIFY(t28 < t27);\n+  VERIFY( t28 < t27 );\n   T t29 = std::nextafter(t28, T(-15.5));\n-  VERIFY(t29 == T(-16.0));\n+  VERIFY( t29 == T(-16.0) );\n   T t30 = std::nextafter(-lim::max(), T(0.5));\n-  VERIFY(std::fpclassify(t30) == FP_NORMAL && t30 > -lim::max());\n+  VERIFY( std::fpclassify(t30) == FP_NORMAL && t30 > -lim::max() );\n   T t31 = std::nextafter(t30, -lim::infinity());\n-  VERIFY(t31 == -lim::max());\n+  VERIFY( t31 == -lim::max() );\n   T t32 = std::nextafter(t31, -lim::infinity());\n-  VERIFY(std::fpclassify(t32) == FP_INFINITE && std::signbit(t32));\n+  VERIFY( std::fpclassify(t32) == FP_INFINITE && std::signbit(t32) );\n   T t33 = std::nextafter(-lim::infinity(), t32);\n-  VERIFY(t33 == t32);\n+  VERIFY( t33 == t32 );\n   T t34 = std::nextafter(t33, T(-1.0));\n-  VERIFY(t34 == -lim::max());\n+  VERIFY( t34 == -lim::max() );\n   T t35 = std::nextafter(-lim::quiet_NaN(), T());\n-  VERIFY(std::fpclassify(t35) == FP_NAN);\n+  VERIFY( std::fpclassify(t35) == FP_NAN );\n   T t36 = std::nextafter(T(-17.0), lim::quiet_NaN());\n-  VERIFY(std::fpclassify(t36) == FP_NAN);\n+  VERIFY( std::fpclassify(t36) == FP_NAN );\n   T t37 = std::nextafter(T(-0.0), T());\n-  VERIFY(t37 == T() && !std::signbit(t37));\n+  VERIFY( t37 == T() && !std::signbit(t37) );\n   static_assert(std::nextafter(T(1.0), T(2.0)) > T(1.0));\n   static_assert(std::nextafter(std::nextafter(T(1.0), T(5.0)), T(0.0)) == T(1.0));\n }"}]}