{"sha": "dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyMjNhZDQ4OTcxYjJkMmIxZTRiY2ZiYmI0N2E5NjM1NGUzZDJlYQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-20T08:52:12Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-20T08:52:12Z"}, "message": "Switch other switch expansion methods into classes.\n\n2018-06-20  Martin Liska  <mliska@suse.cz>\n\n\t* tree-switch-conversion.c (switch_conversion::collect):\n        Record m_uniq property.\n\t(switch_conversion::expand): Bail out for special conditions.\n\t(group_cluster::~group_cluster): New.\n\t(group_cluster::group_cluster): Likewise.\n\t(group_cluster::dump): Likewise.\n\t(jump_table_cluster::emit): New.\n\t(switch_decision_tree::fix_phi_operands_for_edges): New.\n\t(struct case_node): Remove struct.\n\t(jump_table_cluster::can_be_handled): New.\n\t(case_values_threshold): Moved to header.\n\t(reset_out_edges_aux): Likewise.\n\t(jump_table_cluster::is_beneficial): New.\n\t(bit_test_cluster::can_be_handled): Likewise.\n\t(add_case_node): Remove.\n\t(bit_test_cluster::is_beneficial): New.\n\t(case_bit_test::cmp): New.\n\t(bit_test_cluster::emit): New.\n\t(expand_switch_as_decision_tree_p): Remove.\n\t(bit_test_cluster::hoist_edge_and_branch_if_true): New.\n\t(fix_phi_operands_for_edge): Likewise.\n\t(switch_decision_tree::analyze_switch_statement): New.\n\t(compute_cases_per_edge): Move ...\n\t(switch_decision_tree::compute_cases_per_edge): ... here.\n\t(try_switch_expansion): Likewise.\n\t(switch_decision_tree::try_switch_expansion): Likewise.\n\t(record_phi_operand_mapping): Likewise.\n\t(switch_decision_tree::record_phi_operand_mapping): Likewise.\n\t(emit_case_decision_tree): Likewise.\n\t(switch_decision_tree::emit): Likewise.\n\t(balance_case_nodes): Likewise.\n\t(switch_decision_tree::balance_case_nodes): Likewise.\n\t(dump_case_nodes): Likewise.\n\t(switch_decision_tree::dump_case_nodes): Likewise.\n\t(emit_jump): Likewise.\n\t(switch_decision_tree::emit_jump): Likewise.\n\t(emit_cmp_and_jump_insns): Likewise.\n\t(switch_decision_tree::emit_cmp_and_jump_insns): Likewise.\n\t(emit_case_nodes): Likewise.\n\t(switch_decision_tree::emit_case_nodes): Likewise.\n\t(conditional_probability): Remove.\n\t* tree-switch-conversion.h (enum cluster_type): New.\n\t(PRINT_CASE): New.\n\t(struct cluster): Likewise.\n\t(cluster::cluster): Likewise.\n\t(struct simple_cluster): Likewise.\n\t(simple_cluster::simple_cluster): Likewise.\n\t(struct group_cluster): Likewise.\n\t(struct jump_table_cluster): Likewise.\n\t(struct bit_test_cluster): Likewise.\n\t(struct min_cluster_item): Likewise.\n\t(struct case_tree_node): Likewise.\n\t(case_tree_node::case_tree_node): Likewise.\n\t(jump_table_cluster::case_values_threshold): Likewise.\n\t(struct case_bit_test): Likewise.\n\t(struct switch_decision_tree): Likewise.\n\t(struct switch_conversion): Likewise.\n\t(switch_decision_tree::reset_out_edges_aux): Likewise.\n2018-06-20  Martin Liska  <mliska@suse.cz>\n\n\t* gcc.dg/tree-ssa/vrp104.c: Grep just for GIMPLE IL.\n\nFrom-SVN: r261793", "tree": {"sha": "612bcb0ce9171f466c03a6f6a569e73120b4fcd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/612bcb0ce9171f466c03a6f6a569e73120b4fcd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "789410e4824b60f423f7855d68f234e02f9300fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/789410e4824b60f423f7855d68f234e02f9300fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/789410e4824b60f423f7855d68f234e02f9300fb"}], "stats": {"total": 2040, "additions": 1484, "deletions": 556}, "files": [{"sha": "4b919a8c957252677d59b5b736e97bb4f7def1c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "patch": "@@ -1,3 +1,64 @@\n+2018-06-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-switch-conversion.c (switch_conversion::collect):\n+        Record m_uniq property.\n+\t(switch_conversion::expand): Bail out for special conditions.\n+\t(group_cluster::~group_cluster): New.\n+\t(group_cluster::group_cluster): Likewise.\n+\t(group_cluster::dump): Likewise.\n+\t(jump_table_cluster::emit): New.\n+\t(switch_decision_tree::fix_phi_operands_for_edges): New.\n+\t(struct case_node): Remove struct.\n+\t(jump_table_cluster::can_be_handled): New.\n+\t(case_values_threshold): Moved to header.\n+\t(reset_out_edges_aux): Likewise.\n+\t(jump_table_cluster::is_beneficial): New.\n+\t(bit_test_cluster::can_be_handled): Likewise.\n+\t(add_case_node): Remove.\n+\t(bit_test_cluster::is_beneficial): New.\n+\t(case_bit_test::cmp): New.\n+\t(bit_test_cluster::emit): New.\n+\t(expand_switch_as_decision_tree_p): Remove.\n+\t(bit_test_cluster::hoist_edge_and_branch_if_true): New.\n+\t(fix_phi_operands_for_edge): Likewise.\n+\t(switch_decision_tree::analyze_switch_statement): New.\n+\t(compute_cases_per_edge): Move ...\n+\t(switch_decision_tree::compute_cases_per_edge): ... here.\n+\t(try_switch_expansion): Likewise.\n+\t(switch_decision_tree::try_switch_expansion): Likewise.\n+\t(record_phi_operand_mapping): Likewise.\n+\t(switch_decision_tree::record_phi_operand_mapping): Likewise.\n+\t(emit_case_decision_tree): Likewise.\n+\t(switch_decision_tree::emit): Likewise.\n+\t(balance_case_nodes): Likewise.\n+\t(switch_decision_tree::balance_case_nodes): Likewise.\n+\t(dump_case_nodes): Likewise.\n+\t(switch_decision_tree::dump_case_nodes): Likewise.\n+\t(emit_jump): Likewise.\n+\t(switch_decision_tree::emit_jump): Likewise.\n+\t(emit_cmp_and_jump_insns): Likewise.\n+\t(switch_decision_tree::emit_cmp_and_jump_insns): Likewise.\n+\t(emit_case_nodes): Likewise.\n+\t(switch_decision_tree::emit_case_nodes): Likewise.\n+\t(conditional_probability): Remove.\n+\t* tree-switch-conversion.h (enum cluster_type): New.\n+\t(PRINT_CASE): New.\n+\t(struct cluster): Likewise.\n+\t(cluster::cluster): Likewise.\n+\t(struct simple_cluster): Likewise.\n+\t(simple_cluster::simple_cluster): Likewise.\n+\t(struct group_cluster): Likewise.\n+\t(struct jump_table_cluster): Likewise.\n+\t(struct bit_test_cluster): Likewise.\n+\t(struct min_cluster_item): Likewise.\n+\t(struct case_tree_node): Likewise.\n+\t(case_tree_node::case_tree_node): Likewise.\n+\t(jump_table_cluster::case_values_threshold): Likewise.\n+\t(struct case_bit_test): Likewise.\n+\t(struct switch_decision_tree): Likewise.\n+\t(struct switch_conversion): Likewise.\n+\t(switch_decision_tree::reset_out_edges_aux): Likewise.\n+\n 2018-06-20  Martin Liska  <mliska@suse.cz>\n \n \t* tree-switch-conversion.c (MAX_CASE_BIT_TESTS): Remove."}, {"sha": "4dd987bcd647afef14ded9a49e8afa88dc9f97b6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "patch": "@@ -1,3 +1,7 @@\n+2018-06-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/vrp104.c: Grep just for GIMPLE IL.\n+\n 2018-06-19  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/48560"}, {"sha": "1bef76f1a21855f5744ca14efb62b902df7fc974", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp104.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp104.c?ref=dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "patch": "@@ -2,7 +2,7 @@\n /* { dg-options \"-O2 -fdump-tree-switchlower\" }  */\n /* We scan for 2 switches as the dump file reports a transformation,\n    IL really contains just a single.  */\n-/* { dg-final { scan-tree-dump-times \"switch\" 2 \"switchlower1\" } }  */\n+/* { dg-final { scan-tree-dump-times \"switch \\\\(\" 2 \"switchlower1\" } }  */\n \n void foo (void);\n void bar (void);"}, {"sha": "1260ba2e145c48bd35d41b94d162d2d7fee594cf", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 875, "deletions": 555, "changes": 1430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "patch": "@@ -179,6 +179,11 @@ switch_conversion::collect (gswitch *swtch)\n \t  && ! tree_int_cst_equal (CASE_LOW (elt), CASE_HIGH (elt)))\n \tm_count++;\n     }\n+\n+  /* Get the number of unique non-default targets out of the GIMPLE_SWITCH\n+     block.  Assume a CFG cleanup would have already removed degenerate\n+     switch statements, this allows us to just use EDGE_COUNT.  */\n+  m_uniq = EDGE_COUNT (gimple_bb (swtch)->succs) - 1;\n }\n \n /* Checks whether the range given by individual case statements of the switch\n@@ -935,6 +940,22 @@ switch_conversion::expand (gswitch *swtch)\n   /* A switch on a constant should have been optimized in tree-cfg-cleanup.  */\n   gcc_checking_assert (!TREE_CONSTANT (m_index_expr));\n \n+  /* Prefer bit test if possible.  */\n+  if (tree_fits_uhwi_p (m_range_size)\n+      && bit_test_cluster::can_be_handled (tree_to_uhwi (m_range_size), m_uniq)\n+      && bit_test_cluster::is_beneficial (m_count, m_uniq))\n+    {\n+      m_reason = \"expanding as bit test is preferable\";\n+      return;\n+    }\n+\n+  if (m_uniq <= 2)\n+    {\n+      /* This will be expanded as a decision tree .  */\n+      m_reason = \"expanding as jumps is preferable\";\n+      return;\n+    }\n+\n   /* If there is no common successor, we cannot do the transformation.  */\n   if (!m_final_bb)\n     {\n@@ -985,409 +1006,550 @@ switch_conversion::~switch_conversion ()\n   XDELETEVEC (m_default_values);\n }\n \n-/* The main function of the pass scans statements for switches and invokes\n-   process_switch on them.  */\n-\n-namespace {\n+/* Constructor.  */\n \n-const pass_data pass_data_convert_switch =\n+group_cluster::group_cluster (vec<cluster *> &clusters,\n+\t\t\t      unsigned start, unsigned end)\n {\n-  GIMPLE_PASS, /* type */\n-  \"switchconv\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_SWITCH_CONVERSION, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_update_ssa, /* todo_flags_finish */\n-};\n+  gcc_checking_assert (end - start + 1 >= 1);\n+  m_prob = profile_probability::never ();\n+  m_cases.create (end - start + 1);\n+  for (unsigned i = start; i <= end; i++)\n+    {\n+      m_cases.quick_push (static_cast<simple_cluster *> (clusters[i]));\n+      m_prob += clusters[i]->m_prob;\n+    }\n+  m_subtree_prob = m_prob;\n+}\n \n-class pass_convert_switch : public gimple_opt_pass\n+/* Destructor.  */\n+\n+group_cluster::~group_cluster ()\n {\n-public:\n-  pass_convert_switch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_convert_switch, ctxt)\n-  {}\n+  for (unsigned i = 0; i < m_cases.length (); i++)\n+    delete m_cases[i];\n \n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_tree_switch_conversion != 0; }\n-  virtual unsigned int execute (function *);\n+  m_cases.release ();\n+}\n \n-}; // class pass_convert_switch\n+/* Dump content of a cluster.  */\n \n-unsigned int\n-pass_convert_switch::execute (function *fun)\n+void\n+group_cluster::dump (FILE *f, bool details)\n {\n-  basic_block bb;\n-  bool cfg_altered = false;\n-\n-  FOR_EACH_BB_FN (bb, fun)\n-  {\n-    gimple *stmt = last_stmt (bb);\n-    if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n-      {\n-\tif (dump_file)\n-\t  {\n-\t    expanded_location loc = expand_location (gimple_location (stmt));\n+  unsigned total_values = 0;\n+  for (unsigned i = 0; i < m_cases.length (); i++)\n+    total_values += m_cases[i]->get_range (m_cases[i]->get_low (),\n+\t\t\t\t\t   m_cases[i]->get_high ());\n \n-\t    fprintf (dump_file, \"beginning to process the following \"\n-\t\t     \"SWITCH statement (%s:%d) : ------- \\n\",\n-\t\t     loc.file, loc.line);\n-\t    print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t    putc ('\\n', dump_file);\n-\t  }\n+  unsigned comparison_count = 0;\n+  for (unsigned i = 0; i < m_cases.length (); i++)\n+    {\n+      simple_cluster *sc = static_cast<simple_cluster *> (m_cases[i]);\n+      comparison_count += sc->m_range_p ? 2 : 1;\n+    }\n \n-\tswitch_conversion sconv;\n-\tsconv.expand (as_a <gswitch *> (stmt));\n-\tcfg_altered |= sconv.m_cfg_altered;\n-\tif (!sconv.m_reason)\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tfputs (\"Switch converted\\n\", dump_file);\n-\t\tfputs (\"--------------------------------\\n\", dump_file);\n-\t      }\n+  unsigned HOST_WIDE_INT range = get_range (get_low (), get_high ());\n+  fprintf (f, \"%s\", get_type () == JUMP_TABLE ? \"JT\" : \"BT\");\n \n-\t    /* Make no effort to update the post-dominator tree.\n-\t       It is actually not that hard for the transformations\n-\t       we have performed, but it is not supported\n-\t       by iterate_fix_dominators.  */\n-\t    free_dominance_info (CDI_POST_DOMINATORS);\n-\t  }\n-\telse\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tfputs (\"Bailing out - \", dump_file);\n-\t\tfputs (sconv.m_reason, dump_file);\n-\t\tfputs (\"\\n--------------------------------\\n\", dump_file);\n-\t      }\n-\t  }\n-      }\n-  }\n+  if (details)\n+    fprintf (f, \"(values:%d comparisons:%d range:\" HOST_WIDE_INT_PRINT_DEC\n+\t     \" density: %.2f%%)\", total_values, comparison_count, range,\n+\t     100.0f * comparison_count / range);\n \n-  return cfg_altered ? TODO_cleanup_cfg : 0;;\n+  fprintf (f, \":\");\n+  PRINT_CASE (f, get_low ());\n+  fprintf (f, \"-\");\n+  PRINT_CASE (f, get_high ());\n+  fprintf (f, \" \");\n }\n \n-} // anon namespace\n+/* Emit GIMPLE code to handle the cluster.  */\n \n-gimple_opt_pass *\n-make_pass_convert_switch (gcc::context *ctxt)\n+void\n+jump_table_cluster::emit (tree index_expr, tree,\n+\t\t\t  tree default_label_expr, basic_block default_bb)\n {\n-  return new pass_convert_switch (ctxt);\n+  /* For jump table we just emit a new gswitch statement that will\n+     be latter lowered to jump table.  */\n+  auto_vec <tree> labels;\n+  labels.create (m_cases.length ());\n+\n+  make_edge (m_case_bb, default_bb, 0);\n+  for (unsigned i = 0; i < m_cases.length (); i++)\n+    {\n+      labels.quick_push (unshare_expr (m_cases[i]->m_case_label_expr));\n+      make_edge (m_case_bb, m_cases[i]->m_case_bb, 0);\n+    }\n+\n+  gswitch *s = gimple_build_switch (index_expr,\n+\t\t\t\t    unshare_expr (default_label_expr), labels);\n+  gimple_stmt_iterator gsi = gsi_start_bb (m_case_bb);\n+  gsi_insert_after (&gsi, s, GSI_NEW_STMT);\n }\n \n-struct case_node\n+/* Return true when cluster starting at START and ending at END (inclusive)\n+   can build a jump-table.  */\n+\n+bool\n+jump_table_cluster::can_be_handled (const vec<cluster *> &clusters,\n+\t\t\t\t    unsigned start, unsigned end)\n {\n-  case_node\t\t*left;\t/* Left son in binary tree.  */\n-  case_node\t\t*right;\t/* Right son in binary tree;\n-\t\t\t\t   also node chain.  */\n-  case_node\t\t*parent; /* Parent of node in binary tree.  */\n-  tree\t\t\tlow;\t/* Lowest index value for this label.  */\n-  tree\t\t\thigh;\t/* Highest index value for this label.  */\n-  basic_block\t\tcase_bb; /* Label to jump to when node matches.  */\n-  tree\t\t\tcase_label; /* Label to jump to when node matches.  */\n-  profile_probability   prob; /* Probability of taking this case.  */\n-  profile_probability   subtree_prob;  /* Probability of reaching subtree\n-\t\t\t\t\t  rooted at this node.  */\n-};\n+  /* If the switch is relatively small such that the cost of one\n+     indirect jump on the target are higher than the cost of a\n+     decision tree, go with the decision tree.\n \n-typedef case_node *case_node_ptr;\n+     If range of values is much bigger than number of values,\n+     or if it is too large to represent in a HOST_WIDE_INT,\n+     make a sequence of conditional branches instead of a dispatch.\n \n-static basic_block emit_case_nodes (basic_block, tree, case_node_ptr,\n-\t\t\t\t    basic_block, tree, profile_probability,\n-\t\t\t\t    tree, hash_map<tree, tree> *);\n+     The definition of \"much bigger\" depends on whether we are\n+     optimizing for size or for speed.  If the former, the maximum\n+     ratio range/count = 3, because this was found to be the optimal\n+     ratio for size on i686-pc-linux-gnu, see PR11823.  The ratio\n+     10 is much older, and was probably selected after an extensive\n+     benchmarking investigation on numerous platforms.  Or maybe it\n+     just made sense to someone at some point in the history of GCC,\n+     who knows...  */\n+  if (!flag_jump_tables)\n+    return false;\n \n-/* Return the smallest number of different values for which it is best to use a\n-   jump-table instead of a tree of conditional branches.  */\n+  unsigned HOST_WIDE_INT max_ratio = optimize_insn_for_size_p () ? 3 : 10;\n \n-static unsigned int\n-case_values_threshold (void)\n-{\n-  unsigned int threshold = PARAM_VALUE (PARAM_CASE_VALUES_THRESHOLD);\n+  unsigned HOST_WIDE_INT range = get_range (clusters[start]->get_low (),\n+\t\t\t\t\t    clusters[end]->get_high ());\n+  /* Check overflow.  */\n+  if (range == 0)\n+    return false;\n \n-  if (threshold == 0)\n-    threshold = targetm.case_values_threshold ();\n+  unsigned HOST_WIDE_INT comparison_count = 0;\n+  for (unsigned i = start; i <= end; i++)\n+    {\n+      simple_cluster *sc = static_cast<simple_cluster *> (clusters[i]);\n+      comparison_count += sc->m_range_p ? 2 : 1;\n+    }\n \n-  return threshold;\n+  return range <= max_ratio * comparison_count;\n }\n \n-/* Reset the aux field of all outgoing edges of basic block BB.  */\n+/* Return true if cluster starting at START and ending at END (inclusive)\n+   is profitable transformation.  */\n \n-static inline void\n-reset_out_edges_aux (basic_block bb)\n+bool\n+jump_table_cluster::is_beneficial (const vec<cluster *> &,\n+\t\t\t\t   unsigned start, unsigned end)\n {\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    e->aux = (void *) 0;\n+  return end - start + 1 >= case_values_threshold ();\n }\n \n-/* Compute the number of case labels that correspond to each outgoing edge of\n-   STMT.  Record this information in the aux field of the edge.  */\n+/* Return true when RANGE of case values with UNIQ labels\n+   can build a bit test.  */\n \n-static inline void\n-compute_cases_per_edge (gswitch *stmt)\n+bool\n+bit_test_cluster::can_be_handled (unsigned HOST_WIDE_INT range,\n+\t\t\t\t  unsigned int uniq)\n {\n-  basic_block bb = gimple_bb (stmt);\n-  reset_out_edges_aux (bb);\n-  int ncases = gimple_switch_num_labels (stmt);\n-  for (int i = ncases - 1; i >= 1; --i)\n+  /* Check overflow.  */\n+  if (range == 0)\n+    return 0;\n+\n+  if (range >= GET_MODE_BITSIZE (word_mode))\n+    return false;\n+\n+  return uniq <= 3;\n+}\n+\n+/* Return true when cluster starting at START and ending at END (inclusive)\n+   can build a bit test.  */\n+\n+bool\n+bit_test_cluster::can_be_handled (const vec<cluster *> &clusters,\n+\t\t\t\t  unsigned start, unsigned end)\n+{\n+  unsigned HOST_WIDE_INT range = get_range (clusters[start]->get_low (),\n+\t\t\t\t\t    clusters[end]->get_high ());\n+  auto_bitmap dest_bbs;\n+\n+  for (unsigned i = start; i <= end; i++)\n     {\n-      tree elt = gimple_switch_label (stmt, i);\n-      tree lab = CASE_LABEL (elt);\n-      basic_block case_bb = label_to_block_fn (cfun, lab);\n-      edge case_edge = find_edge (bb, case_bb);\n-      case_edge->aux = (void *) ((intptr_t) (case_edge->aux) + 1);\n+      simple_cluster *sc = static_cast<simple_cluster *> (clusters[i]);\n+      bitmap_set_bit (dest_bbs, sc->m_case_bb->index);\n     }\n-}\n \n-/* Do the insertion of a case label into case_list.  The labels are\n-   fed to us in descending order from the sorted vector of case labels used\n-   in the tree part of the middle end.  So the list we construct is\n-   sorted in ascending order.\n+  return can_be_handled (range, bitmap_count_bits (dest_bbs));\n+}\n \n-   LABEL is the case label to be inserted.  LOW and HIGH are the bounds\n-   against which the index is compared to jump to LABEL and PROB is the\n-   estimated probability LABEL is reached from the switch statement.  */\n+/* Return true when COUNT of cases of UNIQ labels is beneficial for bit test\n+   transformation.  */\n \n-static case_node *\n-add_case_node (case_node *head, tree low, tree high, basic_block case_bb,\n-\t       tree case_label, profile_probability prob,\n-\t       object_allocator<case_node> &case_node_pool)\n+bool\n+bit_test_cluster::is_beneficial (unsigned count, unsigned uniq)\n {\n-  case_node *r;\n-\n-  gcc_checking_assert (low);\n-  gcc_checking_assert (high && (TREE_TYPE (low) == TREE_TYPE (high)));\n-\n-  /* Add this label to the chain.  */\n-  r = case_node_pool.allocate ();\n-  r->low = low;\n-  r->high = high;\n-  r->case_bb = case_bb;\n-  r->case_label = case_label;\n-  r->parent = r->left = NULL;\n-  r->prob = prob;\n-  r->subtree_prob = prob;\n-  r->right = head;\n-  return r;\n+  return (((uniq == 1 && count >= 3)\n+\t   || (uniq == 2 && count >= 5)\n+\t   || (uniq == 3 && count >= 6)));\n }\n \n-/* Dump ROOT, a list or tree of case nodes, to file.  */\n+/* Return true if cluster starting at START and ending at END (inclusive)\n+   is profitable transformation.  */\n \n-static void\n-dump_case_nodes (FILE *f, case_node *root, int indent_step, int indent_level)\n+bool\n+bit_test_cluster::is_beneficial (const vec<cluster *> &clusters,\n+\t\t\t\t unsigned start, unsigned end)\n {\n-  if (root == 0)\n-    return;\n-  indent_level++;\n-\n-  dump_case_nodes (f, root->left, indent_step, indent_level);\n+  auto_bitmap dest_bbs;\n \n-  fputs (\";; \", f);\n-  fprintf (f, \"%*s\", indent_step * indent_level, \"\");\n-  print_dec (wi::to_wide (root->low), f, TYPE_SIGN (TREE_TYPE (root->low)));\n-  if (!tree_int_cst_equal (root->low, root->high))\n+  for (unsigned i = start; i <= end; i++)\n     {\n-      fprintf (f, \" ... \");\n-      print_dec (wi::to_wide (root->high), f,\n-\t\t TYPE_SIGN (TREE_TYPE (root->high)));\n+      simple_cluster *sc = static_cast<simple_cluster *> (clusters[i]);\n+      bitmap_set_bit (dest_bbs, sc->m_case_bb->index);\n     }\n-  fputs (\"\\n\", f);\n \n-  dump_case_nodes (f, root->right, indent_step, indent_level);\n+  unsigned uniq = bitmap_count_bits (dest_bbs);\n+  unsigned count = end - start + 1;\n+  return is_beneficial (count, uniq);\n }\n \n-/* Take an ordered list of case nodes\n-   and transform them into a near optimal binary tree,\n-   on the assumption that any target code selection value is as\n-   likely as any other.\n+/* Comparison function for qsort to order bit tests by decreasing\n+   probability of execution.  */\n \n-   The transformation is performed by splitting the ordered\n-   list into two equal sections plus a pivot.  The parts are\n-   then attached to the pivot as left and right branches.  Each\n-   branch is then transformed recursively.  */\n+int\n+case_bit_test::cmp (const void *p1, const void *p2)\n+{\n+  const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n+  const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n+\n+  if (d2->bits != d1->bits)\n+    return d2->bits - d1->bits;\n+\n+  /* Stabilize the sort.  */\n+  return (LABEL_DECL_UID (CASE_LABEL (d2->label))\n+\t  - LABEL_DECL_UID (CASE_LABEL (d1->label)));\n+}\n+\n+/*  Expand a switch statement by a short sequence of bit-wise\n+    comparisons.  \"switch(x)\" is effectively converted into\n+    \"if ((1 << (x-MINVAL)) & CST)\" where CST and MINVAL are\n+    integer constants.\n+\n+    INDEX_EXPR is the value being switched on.\n+\n+    MINVAL is the lowest case value of in the case nodes,\n+    and RANGE is highest value minus MINVAL.  MINVAL and RANGE\n+    are not guaranteed to be of the same type as INDEX_EXPR\n+    (the gimplifier doesn't change the type of case label values,\n+    and MINVAL and RANGE are derived from those values).\n+    MAXVAL is MINVAL + RANGE.\n \n-static void\n-balance_case_nodes (case_node_ptr *head, case_node_ptr parent)\n+    There *MUST* be max_case_bit_tests or less unique case\n+    node targets.  */\n+\n+void\n+bit_test_cluster::emit (tree index_expr, tree index_type,\n+\t\t\ttree, basic_block default_bb)\n {\n-  case_node_ptr np;\n+  struct case_bit_test test[m_max_case_bit_tests] = { {} };\n+  unsigned int i, j, k;\n+  unsigned int count;\n \n-  np = *head;\n-  if (np)\n-    {\n-      int i = 0;\n-      int ranges = 0;\n-      case_node_ptr *npp;\n-      case_node_ptr left;\n+  tree unsigned_index_type = unsigned_type_for (index_type);\n \n-      /* Count the number of entries on branch.  Also count the ranges.  */\n+  gimple_stmt_iterator gsi;\n+  gassign *shift_stmt;\n \n-      while (np)\n-\t{\n-\t  if (!tree_int_cst_equal (np->low, np->high))\n-\t    ranges++;\n+  tree idx, tmp, csui;\n+  tree word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n+  tree word_mode_zero = fold_convert (word_type_node, integer_zero_node);\n+  tree word_mode_one = fold_convert (word_type_node, integer_one_node);\n+  int prec = TYPE_PRECISION (word_type_node);\n+  wide_int wone = wi::one (prec);\n \n-\t  i++;\n-\t  np = np->right;\n-\t}\n+  tree minval = get_low ();\n+  tree maxval = get_high ();\n+  tree range = int_const_binop (MINUS_EXPR, maxval, minval);\n \n-      if (i > 2)\n+  /* Go through all case labels, and collect the case labels, profile\n+     counts, and other information we need to build the branch tests.  */\n+  count = 0;\n+  for (i = 0; i < m_cases.length (); i++)\n+    {\n+      unsigned int lo, hi;\n+      simple_cluster *n = static_cast<simple_cluster *> (m_cases[i]);\n+      for (k = 0; k < count; k++)\n+\tif (n->m_case_bb == test[k].target_bb)\n+\t  break;\n+\n+      if (k == count)\n \t{\n-\t  /* Split this list if it is long enough for that to help.  */\n-\t  npp = head;\n-\t  left = *npp;\n+\t  gcc_checking_assert (count < m_max_case_bit_tests);\n+\t  test[k].mask = wi::zero (prec);\n+\t  test[k].target_bb = n->m_case_bb;\n+\t  test[k].label = n->m_case_label_expr;\n+\t  test[k].bits = 1;\n+\t  count++;\n+\t}\n+      else\n+\ttest[k].bits++;\n \n-\t  /* If there are just three nodes, split at the middle one.  */\n-\t  if (i == 3)\n-\t    npp = &(*npp)->right;\n-\t  else\n-\t    {\n-\t      /* Find the place in the list that bisects the list's total cost,\n-\t\t where ranges count as 2.\n-\t\t Here I gets half the total cost.  */\n-\t      i = (i + ranges + 1) / 2;\n-\t      while (1)\n-\t\t{\n-\t\t  /* Skip nodes while their cost does not reach that amount.  */\n-\t\t  if (!tree_int_cst_equal ((*npp)->low, (*npp)->high))\n-\t\t    i--;\n-\t\t  i--;\n-\t\t  if (i <= 0)\n-\t\t    break;\n-\t\t  npp = &(*npp)->right;\n-\t\t}\n-\t    }\n-\t  *head = np = *npp;\n-\t  *npp = 0;\n-\t  np->parent = parent;\n-\t  np->left = left;\n+      lo = tree_to_uhwi (int_const_binop (MINUS_EXPR, n->get_low (), minval));\n+      if (n->get_high () == NULL_TREE)\n+\thi = lo;\n+      else\n+\thi = tree_to_uhwi (int_const_binop (MINUS_EXPR, n->get_high (),\n+\t\t\t\t\t    minval));\n \n-\t  /* Optimize each of the two split parts.  */\n-\t  balance_case_nodes (&np->left, np);\n-\t  balance_case_nodes (&np->right, np);\n-\t  np->subtree_prob = np->prob;\n-\t  np->subtree_prob += np->left->subtree_prob;\n-\t  np->subtree_prob += np->right->subtree_prob;\n+      for (j = lo; j <= hi; j++)\n+\ttest[k].mask |= wi::lshift (wone, j);\n+    }\n+\n+  qsort (test, count, sizeof (*test), case_bit_test::cmp);\n+\n+  /* If all values are in the 0 .. BITS_PER_WORD-1 range, we can get rid of\n+     the minval subtractions, but it might make the mask constants more\n+     expensive.  So, compare the costs.  */\n+  if (compare_tree_int (minval, 0) > 0\n+      && compare_tree_int (maxval, GET_MODE_BITSIZE (word_mode)) < 0)\n+    {\n+      int cost_diff;\n+      HOST_WIDE_INT m = tree_to_uhwi (minval);\n+      rtx reg = gen_raw_REG (word_mode, 10000);\n+      bool speed_p = optimize_insn_for_speed_p ();\n+      cost_diff = set_rtx_cost (gen_rtx_PLUS (word_mode, reg,\n+\t\t\t\t\t      GEN_INT (-m)), speed_p);\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  rtx r = immed_wide_int_const (test[i].mask, word_mode);\n+\t  cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r),\n+\t\t\t\t     word_mode, speed_p);\n+\t  r = immed_wide_int_const (wi::lshift (test[i].mask, m), word_mode);\n+\t  cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r),\n+\t\t\t\t     word_mode, speed_p);\n \t}\n-      else\n+      if (cost_diff > 0)\n \t{\n-\t  /* Else leave this branch as one level,\n-\t     but fill in `parent' fields.  */\n-\t  np = *head;\n-\t  np->parent = parent;\n-\t  np->subtree_prob = np->prob;\n-\t  for (; np->right; np = np->right)\n-\t    {\n-\t      np->right->parent = np;\n-\t      (*head)->subtree_prob += np->right->subtree_prob;\n-\t    }\n+\t  for (i = 0; i < count; i++)\n+\t    test[i].mask = wi::lshift (test[i].mask, m);\n+\t  minval = build_zero_cst (TREE_TYPE (minval));\n+\t  range = maxval;\n \t}\n     }\n-}\n \n-/* Return true if a switch should be expanded as a decision tree.\n-   RANGE is the difference between highest and lowest case.\n-   UNIQ is number of unique case node targets, not counting the default case.\n-   COUNT is the number of comparisons needed, not counting the default case.  */\n+  /* Now build the test-and-branch code.  */\n+\n+  gsi = gsi_last_bb (m_case_bb);\n+\n+  /* idx = (unsigned)x - minval.  */\n+  idx = fold_convert (unsigned_index_type, index_expr);\n+  idx = fold_build2 (MINUS_EXPR, unsigned_index_type, idx,\n+\t\t     fold_convert (unsigned_index_type, minval));\n+  idx = force_gimple_operand_gsi (&gsi, idx,\n+\t\t\t\t  /*simple=*/true, NULL_TREE,\n+\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n+\n+  /* if (idx > range) goto default */\n+  range = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t    fold_convert (unsigned_index_type, range),\n+\t\t\t\t    /*simple=*/true, NULL_TREE,\n+\t\t\t\t    /*before=*/true, GSI_SAME_STMT);\n+  tmp = fold_build2 (GT_EXPR, boolean_type_node, idx, range);\n+  basic_block new_bb = hoist_edge_and_branch_if_true (&gsi, tmp, default_bb);\n+  gsi = gsi_last_bb (new_bb);\n+\n+  /* csui = (1 << (word_mode) idx) */\n+  csui = make_ssa_name (word_type_node);\n+  tmp = fold_build2 (LSHIFT_EXPR, word_type_node, word_mode_one,\n+\t\t     fold_convert (word_type_node, idx));\n+  tmp = force_gimple_operand_gsi (&gsi, tmp,\n+\t\t\t\t  /*simple=*/false, NULL_TREE,\n+\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n+  shift_stmt = gimple_build_assign (csui, tmp);\n+  gsi_insert_before (&gsi, shift_stmt, GSI_SAME_STMT);\n+  update_stmt (shift_stmt);\n+\n+  /* for each unique set of cases:\n+       if (const & csui) goto target  */\n+  for (k = 0; k < count; k++)\n+    {\n+      tmp = wide_int_to_tree (word_type_node, test[k].mask);\n+      tmp = fold_build2 (BIT_AND_EXPR, word_type_node, csui, tmp);\n+      tmp = force_gimple_operand_gsi (&gsi, tmp,\n+\t\t\t\t      /*simple=*/true, NULL_TREE,\n+\t\t\t\t      /*before=*/true, GSI_SAME_STMT);\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, word_mode_zero);\n+      new_bb = hoist_edge_and_branch_if_true (&gsi, tmp, test[k].target_bb);\n+      gsi = gsi_last_bb (new_bb);\n+    }\n \n-static bool\n-expand_switch_as_decision_tree_p (tree range,\n-\t\t\t\t  unsigned int uniq ATTRIBUTE_UNUSED,\n-\t\t\t\t  unsigned int count)\n-{\n-  int max_ratio;\n+  /* We should have removed all edges now.  */\n+  gcc_assert (EDGE_COUNT (gsi_bb (gsi)->succs) == 0);\n \n-  /* If neither casesi or tablejump is available, or flag_jump_tables\n-     over-ruled us, we really have no choice.  */\n-  if (!targetm.have_casesi () && !targetm.have_tablejump ())\n-    return true;\n-  if (!flag_jump_tables)\n-    return true;\n-#ifndef ASM_OUTPUT_ADDR_DIFF_ELT\n-  if (flag_pic)\n-    return true;\n-#endif\n+  /* If nothing matched, go to the default label.  */\n+  make_edge (gsi_bb (gsi), default_bb, EDGE_FALLTHRU);\n+}\n \n-  /* If the switch is relatively small such that the cost of one\n-     indirect jump on the target are higher than the cost of a\n-     decision tree, go with the decision tree.\n+/* Split the basic block at the statement pointed to by GSIP, and insert\n+   a branch to the target basic block of E_TRUE conditional on tree\n+   expression COND.\n \n-     If range of values is much bigger than number of values,\n-     or if it is too large to represent in a HOST_WIDE_INT,\n-     make a sequence of conditional branches instead of a dispatch.\n+   It is assumed that there is already an edge from the to-be-split\n+   basic block to E_TRUE->dest block.  This edge is removed, and the\n+   profile information on the edge is re-used for the new conditional\n+   jump.\n \n-     The definition of \"much bigger\" depends on whether we are\n-     optimizing for size or for speed.  If the former, the maximum\n-     ratio range/count = 3, because this was found to be the optimal\n-     ratio for size on i686-pc-linux-gnu, see PR11823.  The ratio\n-     10 is much older, and was probably selected after an extensive\n-     benchmarking investigation on numerous platforms.  Or maybe it\n-     just made sense to someone at some point in the history of GCC,\n-     who knows...  */\n-  max_ratio = optimize_insn_for_size_p () ? 3 : 10;\n-  if (count < case_values_threshold () || !tree_fits_uhwi_p (range)\n-      || compare_tree_int (range, max_ratio * count) > 0)\n-    return true;\n+   The CFG is updated.  The dominator tree will not be valid after\n+   this transformation, but the immediate dominators are updated if\n+   UPDATE_DOMINATORS is true.\n \n-  return false;\n-}\n+   Returns the newly created basic block.  */\n \n-static void\n-fix_phi_operands_for_edge (edge e, hash_map<tree, tree> *phi_mapping)\n+basic_block\n+bit_test_cluster::hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n+\t\t\t\t\t\t tree cond, basic_block case_bb)\n {\n-  basic_block bb = e->dest;\n-  gphi_iterator gsi;\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gphi *phi = gsi.phi ();\n+  tree tmp;\n+  gcond *cond_stmt;\n+  edge e_false;\n+  basic_block new_bb, split_bb = gsi_bb (*gsip);\n \n-      tree *definition = phi_mapping->get (gimple_phi_result (phi));\n-      if (definition)\n-\tadd_phi_arg (phi, *definition, e, UNKNOWN_LOCATION);\n-    }\n-}\n+  edge e_true = make_edge (split_bb, case_bb, EDGE_TRUE_VALUE);\n+  gcc_assert (e_true->src == split_bb);\n \n+  tmp = force_gimple_operand_gsi (gsip, cond, /*simple=*/true, NULL,\n+\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n+  cond_stmt = gimple_build_cond_from_tree (tmp, NULL_TREE, NULL_TREE);\n+  gsi_insert_before (gsip, cond_stmt, GSI_SAME_STMT);\n \n-/* Add an unconditional jump to CASE_BB that happens in basic block BB.  */\n+  e_false = split_block (split_bb, cond_stmt);\n+  new_bb = e_false->dest;\n+  redirect_edge_pred (e_true, split_bb);\n \n-static void\n-emit_jump (basic_block bb, basic_block case_bb,\n-\t   hash_map<tree, tree> *phi_mapping)\n-{\n-  edge e = single_succ_edge (bb);\n-  redirect_edge_succ (e, case_bb);\n-  fix_phi_operands_for_edge (e, phi_mapping);\n+  e_false->flags &= ~EDGE_FALLTHRU;\n+  e_false->flags |= EDGE_FALSE_VALUE;\n+  e_false->probability = e_true->probability.invert ();\n+  new_bb->count = e_false->count ();\n+\n+  return new_bb;\n }\n \n-/* Generate a decision tree, switching on INDEX_EXPR and jumping to\n-   one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n-   DEFAULT_PROB is the estimated probability that it jumps to\n-   DEFAULT_LABEL.\n+/* Compute the number of case labels that correspond to each outgoing edge of\n+   switch statement.  Record this information in the aux field of the edge.  */\n \n-   We generate a binary decision tree to select the appropriate target\n-   code.  */\n+void\n+switch_decision_tree::compute_cases_per_edge ()\n+{\n+  basic_block bb = gimple_bb (m_switch);\n+  reset_out_edges_aux ();\n+  int ncases = gimple_switch_num_labels (m_switch);\n+  for (int i = ncases - 1; i >= 1; --i)\n+    {\n+      tree elt = gimple_switch_label (m_switch, i);\n+      tree lab = CASE_LABEL (elt);\n+      basic_block case_bb = label_to_block_fn (cfun, lab);\n+      edge case_edge = find_edge (bb, case_bb);\n+      case_edge->aux = (void *) ((intptr_t) (case_edge->aux) + 1);\n+    }\n+}\n+\n+/* Analyze switch statement and return true when the statement is expanded\n+   as decision tree.  */\n \n-static void\n-emit_case_decision_tree (gswitch *s, tree index_expr, tree index_type,\n-\t\t\t case_node_ptr case_list, basic_block default_bb,\n-\t\t\t tree default_label, profile_probability default_prob,\n-\t\t\t hash_map<tree, tree> *phi_mapping)\n+bool\n+switch_decision_tree::analyze_switch_statement ()\n {\n-  balance_case_nodes (&case_list, NULL);\n+  unsigned l = gimple_switch_num_labels (m_switch);\n+  basic_block bb = gimple_bb (m_switch);\n+  auto_vec<cluster *> clusters;\n+  clusters.create (l - 1);\n+\n+  tree default_label = CASE_LABEL (gimple_switch_default_label (m_switch));\n+  basic_block default_bb = label_to_block_fn (cfun, default_label);\n+  m_case_bbs.reserve (l);\n+  m_case_bbs.quick_push (default_bb);\n+\n+  compute_cases_per_edge ();\n+\n+  for (unsigned i = 1; i < l; i++)\n+    {\n+      tree elt = gimple_switch_label (m_switch, i);\n+      tree lab = CASE_LABEL (elt);\n+      basic_block case_bb = label_to_block_fn (cfun, lab);\n+      edge case_edge = find_edge (bb, case_bb);\n+      tree low = CASE_LOW (elt);\n+      tree high = CASE_HIGH (elt);\n+\n+      profile_probability p\n+\t= case_edge->probability.apply_scale (1, (intptr_t) (case_edge->aux));\n+      clusters.quick_push (new simple_cluster (low, high, elt, case_bb, p));\n+      m_case_bbs.quick_push (case_bb);\n+    }\n+\n+  reset_out_edges_aux ();\n+\n+  vec<cluster *> output;\n+  output.create (1);\n+\n+  /* Find whether the switch statement can be expanded with a method\n+     different from decision tree.  */\n+  unsigned end = clusters.length () - 1;\n+  if (jump_table_cluster::can_be_handled (clusters, 0, end)\n+      && jump_table_cluster::is_beneficial (clusters, 0, end))\n+    output.safe_push (new jump_table_cluster (clusters, 0, end));\n+  else if (bit_test_cluster::can_be_handled (clusters, 0, end)\n+\t   && bit_test_cluster::is_beneficial (clusters, 0, end))\n+    output.safe_push (new bit_test_cluster (clusters, 0, end));\n+  else\n+    output = clusters;\n \n   if (dump_file)\n-    dump_function_to_file (current_function_decl, dump_file, dump_flags);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      int indent_step = ceil_log2 (TYPE_PRECISION (index_type)) + 2;\n-      fprintf (dump_file, \";; Expanding GIMPLE switch as decision tree:\\n\");\n-      dump_case_nodes (dump_file, case_list, indent_step, 0);\n+      fprintf (dump_file, \";; GIMPLE switch case clusters: \");\n+      for (unsigned i = 0; i < output.length (); i++)\n+\toutput[i]->dump (dump_file, dump_flags & TDF_DETAILS);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  bool expanded = try_switch_expansion (output);\n+\n+  for (unsigned i = 0; i < output.length (); i++)\n+    delete output[i];\n+\n+  return expanded;\n+}\n+\n+/* Attempt to expand CLUSTERS as a decision tree.  Return true when\n+   expanded.  */\n+\n+bool\n+switch_decision_tree::try_switch_expansion (vec<cluster *> &clusters)\n+{\n+  tree index_expr = gimple_switch_index (m_switch);\n+  tree index_type = TREE_TYPE (index_expr);\n+  basic_block bb = gimple_bb (m_switch);\n+\n+  if (gimple_switch_num_labels (m_switch) == 1)\n+    return false;\n+\n+  /* Find the default case target label.  */\n+  tree default_label_expr = CASE_LABEL (gimple_switch_default_label (m_switch));\n+  m_default_bb = label_to_block_fn (cfun, default_label_expr);\n+  edge default_edge = find_edge (bb, m_default_bb);\n+\n+  /* Do the insertion of a case label into m_case_list.  The labels are\n+     fed to us in descending order from the sorted vector of case labels used\n+     in the tree part of the middle end.  So the list we construct is\n+     sorted in ascending order.  */\n+\n+  for (int i = clusters.length () - 1; i >= 0; i--)\n+    {\n+      case_tree_node *r = m_case_list;\n+      m_case_list = m_case_node_pool.allocate ();\n+      m_case_list->m_right = r;\n+      m_case_list->m_c = clusters[i];\n     }\n \n-  basic_block bb = gimple_bb (s);\n+  record_phi_operand_mapping ();\n+\n+  /* Split basic block that contains the gswitch statement.  */\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n   edge e;\n   if (gsi_end_p (gsi))\n@@ -1399,27 +1561,49 @@ emit_case_decision_tree (gswitch *s, tree index_expr, tree index_type,\n     }\n   bb = split_edge (e);\n \n-  bb = emit_case_nodes (bb, index_expr, case_list, default_bb, default_label,\n-\t\t\tdefault_prob, index_type, phi_mapping);\n+  /* Create new basic blocks for non-case clusters where specific expansion\n+     needs to happen.  */\n+  for (unsigned i = 0; i < clusters.length (); i++)\n+    if (clusters[i]->get_type () != SIMPLE_CASE)\n+      {\n+\tclusters[i]->m_case_bb = create_empty_bb (bb);\n+\tclusters[i]->m_case_bb->loop_father = bb->loop_father;\n+      }\n \n-  if (bb)\n-    emit_jump (bb, default_bb, phi_mapping);\n+  /* Do not do an extra work for a single cluster.  */\n+  if (clusters.length () == 1\n+      && clusters[0]->get_type () != SIMPLE_CASE)\n+    clusters[0]->emit (index_expr, index_type,\n+\t\t       gimple_switch_default_label (m_switch), m_default_bb);\n+  else\n+    {\n+      emit (bb, index_expr, default_edge->probability, index_type);\n+\n+      /* Emit cluster-specific switch handling.  */\n+      for (unsigned i = 0; i < clusters.length (); i++)\n+\tif (clusters[i]->get_type () != SIMPLE_CASE)\n+\t  clusters[i]->emit (index_expr, index_type,\n+\t\t\t     gimple_switch_default_label (m_switch),\n+\t\t\t     m_default_bb);\n+    }\n \n-  /* Remove all edges and do just an edge that will reach default_bb.  */\n-  gsi = gsi_last_bb (gimple_bb (s));\n-  gsi_remove (&gsi, true);\n+  fix_phi_operands_for_edges ();\n+\n+  return true;\n }\n \n-static void\n-record_phi_operand_mapping (const vec<basic_block> bbs, basic_block switch_bb,\n-\t\t\t    hash_map <tree, tree> *map)\n+/* Before switch transformation, record all SSA_NAMEs defined in switch BB\n+   and used in a label basic block.  */\n+\n+void\n+switch_decision_tree::record_phi_operand_mapping ()\n {\n+  basic_block switch_bb = gimple_bb (m_switch);\n   /* Record all PHI nodes that have to be fixed after conversion.  */\n-  for (unsigned i = 0; i < bbs.length (); i++)\n+  for (unsigned i = 0; i < m_case_bbs.length (); i++)\n     {\n-      basic_block bb = bbs[i];\n-\n       gphi_iterator gsi;\n+      basic_block bb = m_case_bbs[i];\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gphi *phi = gsi.phi ();\n@@ -1431,141 +1615,373 @@ record_phi_operand_mapping (const vec<basic_block> bbs, basic_block switch_bb,\n \t\t{\n \t\t  tree def = gimple_phi_arg_def (phi, i);\n \t\t  tree result = gimple_phi_result (phi);\n-\t\t  map->put (result, def);\n+\t\t  m_phi_mapping.put (result, def);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n     }\n }\n \n-/* Attempt to expand gimple switch STMT to a decision tree.  */\n+/* Append new operands to PHI statements that were introduced due to\n+   addition of new edges to case labels.  */\n \n-static bool\n-try_switch_expansion (gswitch *stmt)\n+void\n+switch_decision_tree::fix_phi_operands_for_edges ()\n {\n-  tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n-  basic_block default_bb;\n-  unsigned int count, uniq;\n-  int i;\n-  int ncases = gimple_switch_num_labels (stmt);\n-  tree index_expr = gimple_switch_index (stmt);\n-  tree index_type = TREE_TYPE (index_expr);\n-  tree elt;\n-  basic_block bb = gimple_bb (stmt);\n+  gphi_iterator gsi;\n \n-  hash_map<tree, tree> phi_mapping;\n-  auto_vec<basic_block> case_bbs;\n+  for (unsigned i = 0; i < m_case_bbs.length (); i++)\n+    {\n+      basic_block bb = m_case_bbs[i];\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  for (unsigned j = 0; j < gimple_phi_num_args (phi); j++)\n+\t    {\n+\t      tree def = gimple_phi_arg_def (phi, j);\n+\t      if (def == NULL_TREE)\n+\t\t{\n+\t\t  edge e = gimple_phi_arg_edge (phi, j);\n+\t\t  tree *definition\n+\t\t    = m_phi_mapping.get (gimple_phi_result (phi));\n+\t\t  gcc_assert (definition);\n+\t\t  add_phi_arg (phi, *definition, e, UNKNOWN_LOCATION);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n \n-  /* A list of case labels; it is first built as a list and it may then\n-     be rearranged into a nearly balanced binary tree.  */\n-  case_node *case_list = 0;\n+/* Generate a decision tree, switching on INDEX_EXPR and jumping to\n+   one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n \n-  /* A pool for case nodes.  */\n-  object_allocator<case_node> case_node_pool (\"struct case_node pool\");\n+   We generate a binary decision tree to select the appropriate target\n+   code.  */\n \n-  /* cleanup_tree_cfg removes all SWITCH_EXPR with their index\n-     expressions being INTEGER_CST.  */\n-  gcc_assert (TREE_CODE (index_expr) != INTEGER_CST);\n+void\n+switch_decision_tree::emit (basic_block bb, tree index_expr,\n+\t\t\t    profile_probability default_prob, tree index_type)\n+{\n+  balance_case_nodes (&m_case_list, NULL);\n \n-  if (ncases == 1)\n-    return false;\n+  if (dump_file)\n+    dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      int indent_step = ceil_log2 (TYPE_PRECISION (index_type)) + 2;\n+      fprintf (dump_file, \";; Expanding GIMPLE switch as decision tree:\\n\");\n+      gcc_assert (m_case_list != NULL);\n+      dump_case_nodes (dump_file, m_case_list, indent_step, 0);\n+    }\n \n-  /* Find the default case target label.  */\n-  tree default_label = CASE_LABEL (gimple_switch_default_label (stmt));\n-  default_bb = label_to_block_fn (cfun, default_label);\n-  edge default_edge = find_edge (bb, default_bb);\n-  profile_probability default_prob = default_edge->probability;\n-  case_bbs.safe_push (default_bb);\n-\n-  /* Get upper and lower bounds of case values.  */\n-  elt = gimple_switch_label (stmt, 1);\n-  minval = fold_convert (index_type, CASE_LOW (elt));\n-  elt = gimple_switch_label (stmt, ncases - 1);\n-  if (CASE_HIGH (elt))\n-    maxval = fold_convert (index_type, CASE_HIGH (elt));\n-  else\n-    maxval = fold_convert (index_type, CASE_LOW (elt));\n+  bb = emit_case_nodes (bb, index_expr, m_case_list, default_prob, index_type);\n \n-  /* Compute span of values.  */\n-  range = fold_build2 (MINUS_EXPR, index_type, maxval, minval);\n+  if (bb)\n+    emit_jump (bb, m_default_bb);\n \n-  /* Listify the labels queue and gather some numbers to decide\n-     how to expand this switch.  */\n-  uniq = 0;\n-  count = 0;\n-  hash_set<tree> seen_labels;\n-  compute_cases_per_edge (stmt);\n+  /* Remove all edges and do just an edge that will reach default_bb.  */\n+  bb = gimple_bb (m_switch);\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gsi_remove (&gsi, true);\n \n-  for (i = ncases - 1; i >= 1; --i)\n+  delete_basic_block (bb);\n+}\n+\n+/* Take an ordered list of case nodes\n+   and transform them into a near optimal binary tree,\n+   on the assumption that any target code selection value is as\n+   likely as any other.\n+\n+   The transformation is performed by splitting the ordered\n+   list into two equal sections plus a pivot.  The parts are\n+   then attached to the pivot as left and right branches.  Each\n+   branch is then transformed recursively.  */\n+\n+void\n+switch_decision_tree::balance_case_nodes (case_tree_node **head,\n+\t\t\t\t\t  case_tree_node *parent)\n+{\n+  case_tree_node *np;\n+\n+  np = *head;\n+  if (np)\n     {\n-      elt = gimple_switch_label (stmt, i);\n-      tree low = CASE_LOW (elt);\n-      gcc_assert (low);\n-      tree high = CASE_HIGH (elt);\n-      gcc_assert (!high || tree_int_cst_lt (low, high));\n-      tree lab = CASE_LABEL (elt);\n+      int i = 0;\n+      int ranges = 0;\n+      case_tree_node **npp;\n+      case_tree_node *left;\n \n-      /* Count the elements.\n-\t A range counts double, since it requires two compares.  */\n-      count++;\n-      if (high)\n-\tcount++;\n-\n-      /* If we have not seen this label yet, then increase the\n-\t number of unique case node targets seen.  */\n-      if (!seen_labels.add (lab))\n-\tuniq++;\n-\n-      /* The bounds on the case range, LOW and HIGH, have to be converted\n-\t to case's index type TYPE.  Note that the original type of the\n-\t case index in the source code is usually \"lost\" during\n-\t gimplification due to type promotion, but the case labels retain the\n-\t original type.  Make sure to drop overflow flags.  */\n-      low = fold_convert (index_type, low);\n-      if (TREE_OVERFLOW (low))\n-\tlow = wide_int_to_tree (index_type, wi::to_wide (low));\n-\n-      /* The canonical from of a case label in GIMPLE is that a simple case\n-\t has an empty CASE_HIGH.  For the casesi and tablejump expanders,\n-\t the back ends want simple cases to have high == low.  */\n-      if (!high)\n-\thigh = low;\n-      high = fold_convert (index_type, high);\n-      if (TREE_OVERFLOW (high))\n-\thigh = wide_int_to_tree (index_type, wi::to_wide (high));\n+      /* Count the number of entries on branch.  Also count the ranges.  */\n \n-      basic_block case_bb = label_to_block_fn (cfun, lab);\n-      edge case_edge = find_edge (bb, case_bb);\n-      case_list = add_case_node (\n-\tcase_list, low, high, case_bb, lab,\n-\tcase_edge->probability.apply_scale (1, (intptr_t) (case_edge->aux)),\n-\tcase_node_pool);\n+      while (np)\n+\t{\n+\t  if (!tree_int_cst_equal (np->m_c->get_low (), np->m_c->get_high ()))\n+\t    ranges++;\n \n-      case_bbs.safe_push (case_bb);\n-    }\n-  reset_out_edges_aux (bb);\n-  record_phi_operand_mapping (case_bbs, bb, &phi_mapping);\n+\t  i++;\n+\t  np = np->m_right;\n+\t}\n \n-  /* cleanup_tree_cfg removes all SWITCH_EXPR with a single\n-     destination, such as one with a default case only.\n-     It also removes cases that are out of range for the switch\n-     type, so we should never get a zero here.  */\n-  gcc_assert (count > 0);\n+      if (i > 2)\n+\t{\n+\t  /* Split this list if it is long enough for that to help.  */\n+\t  npp = head;\n+\t  left = *npp;\n \n-  /* Decide how to expand this switch.\n-     The two options at this point are a dispatch table (casesi or\n-     tablejump) or a decision tree.  */\n+\t  /* If there are just three nodes, split at the middle one.  */\n+\t  if (i == 3)\n+\t    npp = &(*npp)->m_right;\n+\t  else\n+\t    {\n+\t      /* Find the place in the list that bisects the list's total cost,\n+\t\t where ranges count as 2.\n+\t\t Here I gets half the total cost.  */\n+\t      i = (i + ranges + 1) / 2;\n+\t      while (1)\n+\t\t{\n+\t\t  /* Skip nodes while their cost does not reach that amount.  */\n+\t\t  if (!tree_int_cst_equal ((*npp)->m_c->get_low (),\n+\t\t\t\t\t   (*npp)->m_c->get_high ()))\n+\t\t    i--;\n+\t\t  i--;\n+\t\t  if (i <= 0)\n+\t\t    break;\n+\t\t  npp = &(*npp)->m_right;\n+\t\t}\n+\t    }\n+\t  *head = np = *npp;\n+\t  *npp = 0;\n+\t  np->m_parent = parent;\n+\t  np->m_left = left;\n \n-  if (expand_switch_as_decision_tree_p (range, uniq, count))\n-    {\n-      emit_case_decision_tree (stmt, index_expr, index_type, case_list,\n-\t\t\t       default_bb, default_label, default_prob,\n-\t\t\t       &phi_mapping);\n-      return true;\n+\t  /* Optimize each of the two split parts.  */\n+\t  balance_case_nodes (&np->m_left, np);\n+\t  balance_case_nodes (&np->m_right, np);\n+\t  np->m_c->m_subtree_prob = np->m_c->m_prob;\n+\t  np->m_c->m_subtree_prob += np->m_left->m_c->m_subtree_prob;\n+\t  np->m_c->m_subtree_prob += np->m_right->m_c->m_subtree_prob;\n+\t}\n+      else\n+\t{\n+\t  /* Else leave this branch as one level,\n+\t     but fill in `parent' fields.  */\n+\t  np = *head;\n+\t  np->m_parent = parent;\n+\t  np->m_c->m_subtree_prob = np->m_c->m_prob;\n+\t  for (; np->m_right; np = np->m_right)\n+\t    {\n+\t      np->m_right->m_parent = np;\n+\t      (*head)->m_c->m_subtree_prob += np->m_right->m_c->m_subtree_prob;\n+\t    }\n+\t}\n     }\n+}\n+\n+/* Dump ROOT, a list or tree of case nodes, to file.  */\n \n-  return false;\n+void\n+switch_decision_tree::dump_case_nodes (FILE *f, case_tree_node *root,\n+\t\t\t\t       int indent_step, int indent_level)\n+{\n+  if (root == 0)\n+    return;\n+  indent_level++;\n+\n+  dump_case_nodes (f, root->m_left, indent_step, indent_level);\n+\n+  fputs (\";; \", f);\n+  fprintf (f, \"%*s\", indent_step * indent_level, \"\");\n+  root->m_c->dump (f);\n+  root->m_c->m_prob.dump (f);\n+  fputs (\"\\n\", f);\n+\n+  dump_case_nodes (f, root->m_right, indent_step, indent_level);\n+}\n+\n+\n+/* Add an unconditional jump to CASE_BB that happens in basic block BB.  */\n+\n+void\n+switch_decision_tree::emit_jump (basic_block bb, basic_block case_bb)\n+{\n+  edge e = single_succ_edge (bb);\n+  redirect_edge_succ (e, case_bb);\n+}\n+\n+/* Generate code to compare OP0 with OP1 so that the condition codes are\n+   set and to jump to LABEL_BB if the condition is true.\n+   COMPARISON is the GIMPLE comparison (EQ, NE, GT, etc.).\n+   PROB is the probability of jumping to LABEL_BB.  */\n+\n+basic_block\n+switch_decision_tree::emit_cmp_and_jump_insns (basic_block bb, tree op0,\n+\t\t\t\t\t       tree op1, tree_code comparison,\n+\t\t\t\t\t       basic_block label_bb,\n+\t\t\t\t\t       profile_probability prob)\n+{\n+  // TODO: it's once called with lhs != index.\n+  op1 = fold_convert (TREE_TYPE (op0), op1);\n+\n+  gcond *cond = gimple_build_cond (comparison, op0, op1, NULL_TREE, NULL_TREE);\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gsi_insert_after (&gsi, cond, GSI_NEW_STMT);\n+\n+  gcc_assert (single_succ_p (bb));\n+\n+  /* Make a new basic block where false branch will take place.  */\n+  edge false_edge = split_block (bb, cond);\n+  false_edge->flags = EDGE_FALSE_VALUE;\n+  false_edge->probability = prob.invert ();\n+\n+  edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n+  true_edge->probability = prob;\n+\n+  return false_edge->dest;\n+}\n+\n+/* Emit step-by-step code to select a case for the value of INDEX.\n+   The thus generated decision tree follows the form of the\n+   case-node binary tree NODE, whose nodes represent test conditions.\n+   DEFAULT_PROB is probability of cases leading to default BB.\n+   INDEX_TYPE is the type of the index of the switch.  */\n+\n+basic_block\n+switch_decision_tree::emit_case_nodes (basic_block bb, tree index,\n+\t\t\t\t       case_tree_node *node,\n+\t\t\t\t       profile_probability default_prob,\n+\t\t\t\t       tree index_type)\n+{\n+  /* If node is null, we are done.  */\n+  if (node == NULL)\n+    return bb;\n+\n+  /* Branch to a label where we will handle it later.  */\n+  basic_block test_bb = split_edge (single_succ_edge (bb));\n+  redirect_edge_succ (single_pred_edge (test_bb),\n+\t\t      single_succ_edge (bb)->dest);\n+\n+  profile_probability probability\n+    = (node->m_right\n+       ? node->m_right->m_c->m_subtree_prob : profile_probability::never ());\n+  probability = ((probability + default_prob.apply_scale (1, 2))\n+\t\t / (node->m_c->m_subtree_prob + default_prob));\n+  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_high (), GT_EXPR,\n+\t\t\t\ttest_bb, probability);\n+  default_prob = default_prob.apply_scale (1, 2);\n+\n+  /* Value belongs to this node or to the left-hand subtree.  */\n+  probability = node->m_c->m_prob /\n+    (node->m_c->m_subtree_prob + default_prob);\n+  bb = emit_cmp_and_jump_insns (bb, index, node->m_c->get_low (), GE_EXPR,\n+\t\t\t\tnode->m_c->m_case_bb, probability);\n+\n+  /* Handle the left-hand subtree.  */\n+  bb = emit_case_nodes (bb, index, node->m_left,\n+\t\t\tdefault_prob, index_type);\n+\n+  /* If the left-hand subtree fell through,\n+     don't let it fall into the right-hand subtree.  */\n+  if (m_default_bb)\n+    emit_jump (bb, m_default_bb);\n+\n+  bb = emit_case_nodes (test_bb, index, node->m_right,\n+\t\t\tdefault_prob, index_type);\n+\n+  return bb;\n+}\n+\n+/* The main function of the pass scans statements for switches and invokes\n+   process_switch on them.  */\n+\n+namespace {\n+\n+const pass_data pass_data_convert_switch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"switchconv\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_SWITCH_CONVERSION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_convert_switch : public gimple_opt_pass\n+{\n+public:\n+  pass_convert_switch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_convert_switch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_tree_switch_conversion != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_convert_switch\n+\n+unsigned int\n+pass_convert_switch::execute (function *fun)\n+{\n+  basic_block bb;\n+  bool cfg_altered = false;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+  {\n+    gimple *stmt = last_stmt (bb);\n+    if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n+      {\n+\tif (dump_file)\n+\t  {\n+\t    expanded_location loc = expand_location (gimple_location (stmt));\n+\n+\t    fprintf (dump_file, \"beginning to process the following \"\n+\t\t     \"SWITCH statement (%s:%d) : ------- \\n\",\n+\t\t     loc.file, loc.line);\n+\t    print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t    putc ('\\n', dump_file);\n+\t  }\n+\n+\tswitch_conversion sconv;\n+\tsconv.expand (as_a <gswitch *> (stmt));\n+\tcfg_altered |= sconv.m_cfg_altered;\n+\tif (!sconv.m_reason)\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tfputs (\"Switch converted\\n\", dump_file);\n+\t\tfputs (\"--------------------------------\\n\", dump_file);\n+\t      }\n+\n+\t    /* Make no effort to update the post-dominator tree.\n+\t       It is actually not that hard for the transformations\n+\t       we have performed, but it is not supported\n+\t       by iterate_fix_dominators.  */\n+\t    free_dominance_info (CDI_POST_DOMINATORS);\n+\t  }\n+\telse\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tfputs (\"Bailing out - \", dump_file);\n+\t\tfputs (sconv.m_reason, dump_file);\n+\t\tfputs (\"\\n--------------------------------\\n\", dump_file);\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  return cfg_altered ? TODO_cleanup_cfg : 0;;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_convert_switch (gcc::context *ctxt)\n+{\n+  return new pass_convert_switch (ctxt);\n }\n \n /* The main function of the pass scans statements for switches and invokes\n@@ -1614,23 +2030,35 @@ pass_lower_switch<O0>::execute (function *fun)\n   basic_block bb;\n   bool expanded = false;\n \n+  auto_vec<gimple *> switch_statements;\n+  switch_statements.create (1);\n+\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple *stmt = last_stmt (bb);\n       if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n+\tswitch_statements.safe_push (stmt);\n+    }\n+\n+  for (unsigned i = 0; i < switch_statements.length (); i++)\n+    {\n+      gimple *stmt = switch_statements[i];\n+      if (dump_file)\n \t{\n-\t  if (dump_file)\n-\t    {\n-\t      expanded_location loc = expand_location (gimple_location (stmt));\n+\t  expanded_location loc = expand_location (gimple_location (stmt));\n \n-\t      fprintf (dump_file, \"beginning to process the following \"\n-\t\t\t\t  \"SWITCH statement (%s:%d) : ------- \\n\",\n-\t\t       loc.file, loc.line);\n-\t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n-\t      putc ('\\n', dump_file);\n-\t    }\n+\t  fprintf (dump_file, \"beginning to process the following \"\n+\t\t   \"SWITCH statement (%s:%d) : ------- \\n\",\n+\t\t   loc.file, loc.line);\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t  putc ('\\n', dump_file);\n+\t}\n \n-\t  expanded |= try_switch_expansion (as_a<gswitch *> (stmt));\n+      gswitch *swtch = dyn_cast<gswitch *> (stmt);\n+      if (swtch)\n+\t{\n+\t  switch_decision_tree dt (swtch);\n+\t  expanded |= dt.analyze_switch_statement ();\n \t}\n     }\n \n@@ -1657,112 +2085,4 @@ make_pass_lower_switch (gcc::context *ctxt)\n   return new pass_lower_switch<false> (ctxt);\n }\n \n-/* Generate code to compare X with Y so that the condition codes are\n-   set and to jump to LABEL if the condition is true.  If X is a\n-   constant and Y is not a constant, then the comparison is swapped to\n-   ensure that the comparison RTL has the canonical form.\n \n-   UNSIGNEDP nonzero says that X and Y are unsigned; this matters if they\n-   need to be widened.  UNSIGNEDP is also used to select the proper\n-   branch condition code.\n-\n-   If X and Y have mode BLKmode, then SIZE specifies the size of both X and Y.\n-\n-   MODE is the mode of the inputs (in case they are const_int).\n-\n-   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n-   It will be potentially converted into an unsigned variant based on\n-   UNSIGNEDP to select a proper jump instruction.\n-\n-   PROB is the probability of jumping to LABEL.  */\n-\n-static basic_block\n-emit_cmp_and_jump_insns (basic_block bb, tree op0, tree op1,\n-\t\t\t tree_code comparison, basic_block label_bb,\n-\t\t\t profile_probability prob,\n-\t\t\t hash_map<tree, tree> *phi_mapping)\n-{\n-  gcond *cond = gimple_build_cond (comparison, op0, op1, NULL_TREE, NULL_TREE);\n-  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-  gsi_insert_after (&gsi, cond, GSI_NEW_STMT);\n-\n-  gcc_assert (single_succ_p (bb));\n-\n-  /* Make a new basic block where false branch will take place.  */\n-  edge false_edge = split_block (bb, cond);\n-  false_edge->flags = EDGE_FALSE_VALUE;\n-  false_edge->probability = prob.invert ();\n-\n-  edge true_edge = make_edge (bb, label_bb, EDGE_TRUE_VALUE);\n-  fix_phi_operands_for_edge (true_edge, phi_mapping);\n-  true_edge->probability = prob;\n-\n-  return false_edge->dest;\n-}\n-\n-/* Computes the conditional probability of jumping to a target if the branch\n-   instruction is executed.\n-   TARGET_PROB is the estimated probability of jumping to a target relative\n-   to some basic block BB.\n-   BASE_PROB is the probability of reaching the branch instruction relative\n-   to the same basic block BB.  */\n-\n-static inline profile_probability\n-conditional_probability (profile_probability target_prob,\n-\t\t\t profile_probability base_prob)\n-{\n-  return target_prob / base_prob;\n-}\n-\n-/* Emit step-by-step code to select a case for the value of INDEX.\n-   The thus generated decision tree follows the form of the\n-   case-node binary tree NODE, whose nodes represent test conditions.\n-   INDEX_TYPE is the type of the index of the switch.  */\n-\n-static basic_block\n-emit_case_nodes (basic_block bb, tree index, case_node_ptr node,\n-\t\t basic_block default_bb, tree default_label,\n-\t\t profile_probability default_prob, tree index_type,\n-\t\t hash_map<tree, tree> *phi_mapping)\n-{\n-  /* If node is null, we are done.  */\n-  if (node == NULL)\n-    return bb;\n-\n-  /* Branch to a label where we will handle it later.  */\n-  basic_block test_bb = split_edge (single_succ_edge (bb));\n-  redirect_edge_succ (single_pred_edge (test_bb),\n-\t\t      single_succ_edge (bb)->dest);\n-\n-  profile_probability probability\n-    = node->right ? node->right->subtree_prob : profile_probability::never ();\n-  probability\n-    = conditional_probability (probability + default_prob.apply_scale (1, 2),\n-\t\t\t       node->subtree_prob + default_prob);\n-  bb = emit_cmp_and_jump_insns (bb, index, node->high, GT_EXPR,\n-\t\t\t\ttest_bb, probability, phi_mapping);\n-  default_prob = default_prob.apply_scale (1, 2);\n-\n-  /* Value belongs to this node or to the left-hand subtree.  */\n-  probability\n-    = conditional_probability (node->prob, node->subtree_prob + default_prob);\n-  bb = emit_cmp_and_jump_insns (bb, index, node->low, GE_EXPR,\n-\t\t\t\tnode->case_bb, probability,\n-\t\t\t\tphi_mapping);\n-\n-  /* Handle the left-hand subtree.  */\n-  bb = emit_case_nodes (bb, index, node->left, default_bb,\n-\t\t\tdefault_label, default_prob, index_type,\n-\t\t\tphi_mapping);\n-\n-  /* If the left-hand subtree fell through,\n-     don't let it fall into the right-hand subtree.  */\n-  if (default_bb)\n-    emit_jump (bb, default_bb, phi_mapping);\n-\n-  bb = emit_case_nodes (test_bb, index, node->right, default_bb,\n-\t\t\tdefault_label, default_prob, index_type,\n-\t\t\tphi_mapping);\n-\n-  return bb;\n-}"}, {"sha": "946077c25ec1a8ddad53e70ccca7781d67cae972", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 543, "deletions": 0, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "patch": "@@ -22,6 +22,536 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace tree_switch_conversion {\n \n+/* Type of cluster.  */\n+\n+enum cluster_type\n+{\n+  SIMPLE_CASE,\n+  JUMP_TABLE,\n+  BIT_TEST\n+};\n+\n+#define PRINT_CASE(f,c) print_generic_expr (f, c)\n+\n+/* Abstract base class for representing a cluster of cases.  */\n+\n+struct cluster\n+{\n+  /* Constructor.  */\n+  cluster (tree case_label_expr, basic_block case_bb, profile_probability prob,\n+\t   profile_probability subtree_prob);\n+\n+  /* Destructor.  */\n+  virtual ~cluster ()\n+  {}\n+\n+  /* Return type.  */\n+  virtual cluster_type get_type () = 0;\n+\n+  /* Get low value covered by a cluster.  */\n+  virtual tree get_low () = 0;\n+\n+  /* Get high value covered by a cluster.  */\n+  virtual tree get_high () = 0;\n+\n+  /* Debug content of a cluster.  */\n+  virtual void debug () = 0;\n+\n+  /* Dump content of a cluster.  */\n+  virtual void dump (FILE *f, bool details = false) = 0;\n+\n+  /* Emit GIMPLE code to handle the cluster.  */\n+  virtual void emit (tree, tree, tree, basic_block) = 0;\n+\n+  /* Return range of a cluster.  If value would overflow in type of LOW,\n+     then return 0.  */\n+  static unsigned HOST_WIDE_INT get_range (tree low, tree high)\n+  {\n+    tree r = fold_build2 (MINUS_EXPR, TREE_TYPE (low), high, low);\n+    if (!tree_fits_uhwi_p (r))\n+      return 0;\n+\n+    return tree_to_uhwi (r) + 1;\n+  }\n+\n+  /* Case label.  */\n+  tree m_case_label_expr;\n+\n+  /* Basic block of the case.  */\n+  basic_block m_case_bb;\n+\n+  /* Probability of taking this cluster.  */\n+  profile_probability m_prob;\n+\n+  /* Probability of reaching subtree rooted at this node.  */\n+  profile_probability m_subtree_prob;\n+\n+protected:\n+  /* Default constructor.  */\n+  cluster () {}\n+};\n+\n+cluster::cluster (tree case_label_expr, basic_block case_bb,\n+\t\t  profile_probability prob, profile_probability subtree_prob):\n+  m_case_label_expr (case_label_expr), m_case_bb (case_bb), m_prob (prob),\n+  m_subtree_prob (subtree_prob)\n+{\n+}\n+\n+/* Subclass of cluster representing a simple contiguous range\n+   from [low..high].  */\n+\n+struct simple_cluster: public cluster\n+{\n+  /* Constructor.  */\n+  simple_cluster (tree low, tree high, tree case_label_expr,\n+\t\t  basic_block case_bb, profile_probability prob);\n+\n+  /* Destructor.  */\n+  ~simple_cluster ()\n+  {}\n+\n+  cluster_type\n+  get_type ()\n+  {\n+    return SIMPLE_CASE;\n+  }\n+\n+  tree\n+  get_low ()\n+  {\n+    return m_low;\n+  }\n+\n+  tree\n+  get_high ()\n+  {\n+    return m_high;\n+  }\n+\n+  void\n+  debug ()\n+  {\n+    dump (stderr);\n+  }\n+\n+  void\n+  dump (FILE *f, bool details ATTRIBUTE_UNUSED = false)\n+  {\n+    PRINT_CASE (f, get_low ());\n+    if (get_low () != get_high ())\n+      {\n+\tfprintf (f, \"-\");\n+\tPRINT_CASE (f, get_high ());\n+      }\n+    fprintf (f, \" \");\n+  }\n+\n+  void emit (tree, tree, tree, basic_block)\n+  {\n+    gcc_unreachable ();\n+  }\n+\n+  /* Low value of the case.  */\n+  tree m_low;\n+\n+  /* High value of the case.  */\n+  tree m_high;\n+\n+  /* True if case is a range.  */\n+  bool m_range_p;\n+};\n+\n+simple_cluster::simple_cluster (tree low, tree high, tree case_label_expr,\n+\t\t\t\tbasic_block case_bb, profile_probability prob):\n+  cluster (case_label_expr, case_bb, prob, prob),\n+  m_low (low), m_high (high)\n+{\n+  m_range_p = m_high != NULL;\n+  if (m_high == NULL)\n+    m_high = m_low;\n+}\n+\n+/* Abstract subclass of jump table and bit test cluster,\n+   handling a collection of simple_cluster instances.  */\n+\n+struct group_cluster: public cluster\n+{\n+  /* Constructor.  */\n+  group_cluster (vec<cluster *> &clusters, unsigned start, unsigned end);\n+\n+  /* Destructor.  */\n+  ~group_cluster ();\n+\n+  tree\n+  get_low ()\n+  {\n+    return m_cases[0]->get_low ();\n+  }\n+\n+  tree\n+  get_high ()\n+  {\n+    return m_cases[m_cases.length () - 1]->get_high ();\n+  }\n+\n+  void\n+  debug ()\n+  {\n+    dump (stderr);\n+  }\n+\n+  void dump (FILE *f, bool details = false);\n+\n+  /* List of simple clusters handled by the group.  */\n+  vec<simple_cluster *> m_cases;\n+};\n+\n+/* Concrete subclass of group_cluster representing a collection\n+   of cases to be implemented as a jump table.\n+   The \"emit\" vfunc gernerates a nested switch statement which\n+   is later lowered to a jump table.  */\n+\n+struct jump_table_cluster: public group_cluster\n+{\n+  /* Constructor.  */\n+  jump_table_cluster (vec<cluster *> &clusters, unsigned start, unsigned end)\n+  : group_cluster (clusters, start, end)\n+  {}\n+\n+  cluster_type\n+  get_type ()\n+  {\n+    return JUMP_TABLE;\n+  }\n+\n+  void emit (tree index_expr, tree index_type,\n+\t     tree default_label_expr, basic_block default_bb);\n+\n+  /* Return true when cluster starting at START and ending at END (inclusive)\n+     can build a jump-table.  */\n+  static bool can_be_handled (const vec<cluster *> &clusters, unsigned start,\n+\t\t\t      unsigned end);\n+\n+  /* Return true if cluster starting at START and ending at END (inclusive)\n+     is profitable transformation.  */\n+  static bool is_beneficial (const vec<cluster *> &clusters, unsigned start,\n+\t\t\t     unsigned end);\n+\n+  /* Return the smallest number of different values for which it is best\n+     to use a jump-table instead of a tree of conditional branches.  */\n+  static inline unsigned int case_values_threshold (void);\n+};\n+\n+/* A GIMPLE switch statement can be expanded to a short sequence of bit-wise\n+comparisons.  \"switch(x)\" is converted into \"if ((1 << (x-MINVAL)) & CST)\"\n+where CST and MINVAL are integer constants.  This is better than a series\n+of compare-and-banch insns in some cases,  e.g. we can implement:\n+\n+\tif ((x==4) || (x==6) || (x==9) || (x==11))\n+\n+as a single bit test:\n+\n+\tif ((1<<x) & ((1<<4)|(1<<6)|(1<<9)|(1<<11)))\n+\n+This transformation is only applied if the number of case targets is small,\n+if CST constains at least 3 bits, and \"1 << x\" is cheap.  The bit tests are\n+performed in \"word_mode\".\n+\n+The following example shows the code the transformation generates:\n+\n+\tint bar(int x)\n+\t{\n+\t\tswitch (x)\n+\t\t{\n+\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n+\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n+\t\tcase 'A':  case 'B':  case 'C':  case 'D':  case 'E':\n+\t\tcase 'F':\n+\t\t\treturn 1;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+==>\n+\n+\tbar (int x)\n+\t{\n+\t\ttmp1 = x - 48;\n+\t\tif (tmp1 > (70 - 48)) goto L2;\n+\t\ttmp2 = 1 << tmp1;\n+\t\ttmp3 = 0b11111100000001111111111;\n+\t\tif ((tmp2 & tmp3) != 0) goto L1 ; else goto L2;\n+\tL1:\n+\t\treturn 1;\n+\tL2:\n+\t\treturn 0;\n+\t}\n+\n+TODO: There are still some improvements to this transformation that could\n+be implemented:\n+\n+* A narrower mode than word_mode could be used if that is cheaper, e.g.\n+  for x86_64 where a narrower-mode shift may result in smaller code.\n+\n+* The compounded constant could be shifted rather than the one.  The\n+  test would be either on the sign bit or on the least significant bit,\n+  depending on the direction of the shift.  On some machines, the test\n+  for the branch would be free if the bit to test is already set by the\n+  shift operation.\n+\n+This transformation was contributed by Roger Sayle, see this e-mail:\n+   http://gcc.gnu.org/ml/gcc-patches/2003-01/msg01950.html\n+*/\n+\n+struct bit_test_cluster: public group_cluster\n+{\n+  /* Constructor.  */\n+  bit_test_cluster (vec<cluster *> &clusters, unsigned start, unsigned end)\n+  :group_cluster (clusters, start, end)\n+  {}\n+\n+  cluster_type\n+  get_type ()\n+  {\n+    return BIT_TEST;\n+  }\n+\n+/*  Expand a switch statement by a short sequence of bit-wise\n+    comparisons.  \"switch(x)\" is effectively converted into\n+    \"if ((1 << (x-MINVAL)) & CST)\" where CST and MINVAL are\n+    integer constants.\n+\n+    INDEX_EXPR is the value being switched on.\n+\n+    MINVAL is the lowest case value of in the case nodes,\n+    and RANGE is highest value minus MINVAL.  MINVAL and RANGE\n+    are not guaranteed to be of the same type as INDEX_EXPR\n+    (the gimplifier doesn't change the type of case label values,\n+    and MINVAL and RANGE are derived from those values).\n+    MAXVAL is MINVAL + RANGE.\n+\n+    There *MUST* be max_case_bit_tests or less unique case\n+    node targets.  */\n+  void emit (tree index_expr, tree index_type,\n+\t     tree default_label_expr, basic_block default_bb);\n+\n+  /* Return true when RANGE of case values with UNIQ labels\n+     can build a bit test.  */\n+  static bool can_be_handled (unsigned HOST_WIDE_INT range, unsigned uniq);\n+\n+  /* Return true when cluster starting at START and ending at END (inclusive)\n+     can build a bit test.  */\n+  static bool can_be_handled (const vec<cluster *> &clusters, unsigned start,\n+\t\t\t      unsigned end);\n+\n+  /* Return true when COUNT of cases of UNIQ labels is beneficial for bit test\n+     transformation.  */\n+  static bool is_beneficial (unsigned count, unsigned uniq);\n+\n+  /* Return true if cluster starting at START and ending at END (inclusive)\n+     is profitable transformation.  */\n+  static bool is_beneficial (const vec<cluster *> &clusters, unsigned start,\n+\t\t\t     unsigned end);\n+\n+/* Split the basic block at the statement pointed to by GSIP, and insert\n+   a branch to the target basic block of E_TRUE conditional on tree\n+   expression COND.\n+\n+   It is assumed that there is already an edge from the to-be-split\n+   basic block to E_TRUE->dest block.  This edge is removed, and the\n+   profile information on the edge is re-used for the new conditional\n+   jump.\n+\n+   The CFG is updated.  The dominator tree will not be valid after\n+   this transformation, but the immediate dominators are updated if\n+   UPDATE_DOMINATORS is true.\n+\n+   Returns the newly created basic block.  */\n+  static basic_block hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n+\t\t\t\t\t\t    tree cond,\n+\t\t\t\t\t\t    basic_block case_bb);\n+\n+  /* Maximum number of different basic blocks that can be handled by\n+     a bit test.  */\n+  static const int m_max_case_bit_tests = 3;\n+};\n+\n+/* Helper struct to find minimal clusters.  */\n+\n+struct min_cluster_item\n+{\n+  /* Constructor.  */\n+  min_cluster_item (unsigned count, unsigned start, unsigned non_jt_cases):\n+    m_count (count), m_start (start), m_non_jt_cases (non_jt_cases)\n+  {}\n+\n+  /* Count of clusters.  */\n+  unsigned m_count;\n+\n+  /* Index where is cluster boundary.  */\n+  unsigned m_start;\n+\n+  /* Total number of cases that will not be in a jump table.  */\n+  unsigned m_non_jt_cases;\n+};\n+\n+/* Helper struct to represent switch decision tree.  */\n+\n+struct case_tree_node\n+{\n+  /* Empty Constructor.  */\n+  case_tree_node ();\n+\n+  /* Left son in binary tree.  */\n+  case_tree_node *m_left;\n+\n+  /* Right son in binary tree; also node chain.  */\n+  case_tree_node *m_right;\n+\n+  /* Parent of node in binary tree.  */\n+  case_tree_node *m_parent;\n+\n+  /* Cluster represented by this tree node.  */\n+  cluster *m_c;\n+};\n+\n+inline\n+case_tree_node::case_tree_node ():\n+  m_left (NULL), m_right (NULL), m_parent (NULL), m_c (NULL)\n+{\n+}\n+\n+unsigned int\n+jump_table_cluster::case_values_threshold (void)\n+{\n+  unsigned int threshold = PARAM_VALUE (PARAM_CASE_VALUES_THRESHOLD);\n+\n+  if (threshold == 0)\n+    threshold = targetm.case_values_threshold ();\n+\n+  return threshold;\n+}\n+\n+/* A case_bit_test represents a set of case nodes that may be\n+   selected from using a bit-wise comparison.  HI and LO hold\n+   the integer to be tested against, TARGET_EDGE contains the\n+   edge to the basic block to jump to upon success and BITS\n+   counts the number of case nodes handled by this test,\n+   typically the number of bits set in HI:LO.  The LABEL field\n+   is used to quickly identify all cases in this set without\n+   looking at label_to_block for every case label.  */\n+\n+struct case_bit_test\n+{\n+  wide_int mask;\n+  basic_block target_bb;\n+  tree label;\n+  int bits;\n+\n+  /* Comparison function for qsort to order bit tests by decreasing\n+     probability of execution.  */\n+  static int cmp (const void *p1, const void *p2);\n+};\n+\n+struct switch_decision_tree\n+{\n+  /* Constructor.  */\n+  switch_decision_tree (gswitch *swtch): m_switch (swtch), m_phi_mapping (),\n+    m_case_bbs (), m_case_node_pool (\"struct case_node pool\"),\n+    m_case_list (NULL)\n+  {\n+  }\n+\n+  /* Analyze switch statement and return true when the statement is expanded\n+     as decision tree.  */\n+  bool analyze_switch_statement ();\n+\n+  /* Attempt to expand CLUSTERS as a decision tree.  Return true when\n+     expanded.  */\n+  bool try_switch_expansion (vec<cluster *> &clusters);\n+\n+  /* Reset the aux field of all outgoing edges of switch basic block.  */\n+  inline void reset_out_edges_aux ();\n+\n+  /* Compute the number of case labels that correspond to each outgoing edge of\n+     switch statement.  Record this information in the aux field of the edge.\n+     */\n+  void compute_cases_per_edge ();\n+\n+  /* Before switch transformation, record all SSA_NAMEs defined in switch BB\n+     and used in a label basic block.  */\n+  void record_phi_operand_mapping ();\n+\n+  /* Append new operands to PHI statements that were introduced due to\n+     addition of new edges to case labels.  */\n+  void fix_phi_operands_for_edges ();\n+\n+  /* Generate a decision tree, switching on INDEX_EXPR and jumping to\n+     one of the labels in CASE_LIST or to the DEFAULT_LABEL.\n+\n+     We generate a binary decision tree to select the appropriate target\n+     code.  */\n+  void emit (basic_block bb, tree index_expr,\n+\t     profile_probability default_prob, tree index_type);\n+\n+  /* Emit step-by-step code to select a case for the value of INDEX.\n+     The thus generated decision tree follows the form of the\n+     case-node binary tree NODE, whose nodes represent test conditions.\n+     DEFAULT_PROB is probability of cases leading to default BB.\n+     INDEX_TYPE is the type of the index of the switch.  */\n+  basic_block emit_case_nodes (basic_block bb, tree index,\n+\t\t\t       case_tree_node *node,\n+\t\t\t       profile_probability default_prob,\n+\t\t\t       tree index_type);\n+\n+  /* Take an ordered list of case nodes\n+     and transform them into a near optimal binary tree,\n+     on the assumption that any target code selection value is as\n+     likely as any other.\n+\n+     The transformation is performed by splitting the ordered\n+     list into two equal sections plus a pivot.  The parts are\n+     then attached to the pivot as left and right branches.  Each\n+     branch is then transformed recursively.  */\n+  static void balance_case_nodes (case_tree_node **head,\n+\t\t\t\t  case_tree_node *parent);\n+\n+  /* Dump ROOT, a list or tree of case nodes, to file F.  */\n+  static void dump_case_nodes (FILE *f, case_tree_node *root, int indent_step,\n+\t\t\t       int indent_level);\n+\n+  /* Add an unconditional jump to CASE_BB that happens in basic block BB.  */\n+  static void emit_jump (basic_block bb, basic_block case_bb);\n+\n+  /* Generate code to compare OP0 with OP1 so that the condition codes are\n+     set and to jump to LABEL_BB if the condition is true.\n+     COMPARISON is the GIMPLE comparison (EQ, NE, GT, etc.).\n+     PROB is the probability of jumping to LABEL_BB.  */\n+  static basic_block emit_cmp_and_jump_insns (basic_block bb, tree op0,\n+\t\t\t\t\t      tree op1, tree_code comparison,\n+\t\t\t\t\t      basic_block label_bb,\n+\t\t\t\t\t      profile_probability prob);\n+\n+  /* Switch statement.  */\n+  gswitch *m_switch;\n+\n+  /* Map of PHI nodes that have to be fixed after expansion.  */\n+  hash_map<tree, tree> m_phi_mapping;\n+\n+  /* List of basic blocks that belong to labels of the switch.  */\n+  auto_vec<basic_block> m_case_bbs;\n+\n+  /* Basic block with default label.  */\n+  basic_block m_default_bb;\n+\n+  /* A pool for case nodes.  */\n+  object_allocator<case_tree_node> m_case_node_pool;\n+\n+  /* Balanced tree of case nodes.  */\n+  case_tree_node *m_case_list;\n+};\n+\n /*\n      Switch initialization conversion\n \n@@ -254,13 +784,26 @@ struct switch_conversion\n      labels.  */\n   bool m_default_case_nonstandard;\n \n+  /* Number of uniq labels for non-default edges.  */\n+  unsigned int m_uniq;\n+\n   /* Count is number of non-default edges.  */\n   unsigned int m_count;\n \n   /* True if CFG has been changed.  */\n   bool m_cfg_altered;\n };\n \n+void\n+switch_decision_tree::reset_out_edges_aux ()\n+{\n+  basic_block bb = gimple_bb (m_switch);\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    e->aux = (void *) 0;\n+}\n+\n } // tree_switch_conversion namespace\n \n #endif // TREE_SWITCH_CONVERSION_H"}]}