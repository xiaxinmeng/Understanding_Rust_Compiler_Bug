{"sha": "ab43763e519ed8efbbfdac801d008c338fbcb187", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI0Mzc2M2U1MTllZDhlZmJiZmRhYzgwMWQwMDhjMzM4ZmJjYjE4Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-16T10:44:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-16T10:44:31Z"}, "message": "[AArch64] Use frame reference in aarch64_layout_frame\n\nUsing the full path \"cfun->machine->frame\" in aarch64_layout_frame\nled to awkward formatting in some follow-on patches, so it seemed\nworth using a local reference instead.\n\n2019-10-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_layout_frame): Use a local\n\t\"frame\" reference instead of always referring directly to\n\t\"cfun->machine->frame\".\n\nFrom-SVN: r277059", "tree": {"sha": "45d8b5c983037e686789893c106e1c02db50c95b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45d8b5c983037e686789893c106e1c02db50c95b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab43763e519ed8efbbfdac801d008c338fbcb187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab43763e519ed8efbbfdac801d008c338fbcb187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab43763e519ed8efbbfdac801d008c338fbcb187", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab43763e519ed8efbbfdac801d008c338fbcb187/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44af818f006a046ffadcfe39e7d475956ae55317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44af818f006a046ffadcfe39e7d475956ae55317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44af818f006a046ffadcfe39e7d475956ae55317"}], "stats": {"total": 118, "additions": 58, "deletions": 60}, "files": [{"sha": "dbdf07c88890891ba2f803689f51590e941315aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab43763e519ed8efbbfdac801d008c338fbcb187/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab43763e519ed8efbbfdac801d008c338fbcb187/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab43763e519ed8efbbfdac801d008c338fbcb187", "patch": "@@ -1,3 +1,9 @@\n+2019-10-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_layout_frame): Use a local\n+\t\"frame\" reference instead of always referring directly to\n+\t\"cfun->machine->frame\".\n+\n 2019-10-16  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92119"}, {"sha": "6d151cb4724f78ac0d78637bc3aec7188bdd976b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab43763e519ed8efbbfdac801d008c338fbcb187/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab43763e519ed8efbbfdac801d008c338fbcb187/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=ab43763e519ed8efbbfdac801d008c338fbcb187", "patch": "@@ -5321,8 +5321,9 @@ aarch64_layout_frame (void)\n   HOST_WIDE_INT offset = 0;\n   int regno, last_fp_reg = INVALID_REGNUM;\n   bool simd_function = (crtl->abi->id () == ARM_PCS_SIMD);\n+  aarch64_frame &frame = cfun->machine->frame;\n \n-  cfun->machine->frame.emit_frame_chain = aarch64_needs_frame_chain ();\n+  frame.emit_frame_chain = aarch64_needs_frame_chain ();\n \n   /* Adjust the outgoing arguments size if required.  Keep it in sync with what\n      the mid-end is doing.  */\n@@ -5331,63 +5332,61 @@ aarch64_layout_frame (void)\n #define SLOT_NOT_REQUIRED (-2)\n #define SLOT_REQUIRED     (-1)\n \n-  cfun->machine->frame.wb_candidate1 = INVALID_REGNUM;\n-  cfun->machine->frame.wb_candidate2 = INVALID_REGNUM;\n+  frame.wb_candidate1 = INVALID_REGNUM;\n+  frame.wb_candidate2 = INVALID_REGNUM;\n \n   /* First mark all the registers that really need to be saved...  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n-    cfun->machine->frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n+    frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n \n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n-    cfun->machine->frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n+    frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n \n   /* ... that includes the eh data registers (if needed)...  */\n   if (crtl->calls_eh_return)\n     for (regno = 0; EH_RETURN_DATA_REGNO (regno) != INVALID_REGNUM; regno++)\n-      cfun->machine->frame.reg_offset[EH_RETURN_DATA_REGNO (regno)]\n-\t= SLOT_REQUIRED;\n+      frame.reg_offset[EH_RETURN_DATA_REGNO (regno)] = SLOT_REQUIRED;\n \n   /* ... and any callee saved register that dataflow says is live.  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n     if (df_regs_ever_live_p (regno)\n \t&& !fixed_regs[regno]\n \t&& (regno == R30_REGNUM\n \t    || !crtl->abi->clobbers_full_reg_p (regno)))\n-      cfun->machine->frame.reg_offset[regno] = SLOT_REQUIRED;\n+      frame.reg_offset[regno] = SLOT_REQUIRED;\n \n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n     if (df_regs_ever_live_p (regno)\n \t&& !fixed_regs[regno]\n \t&& !crtl->abi->clobbers_full_reg_p (regno))\n       {\n-\tcfun->machine->frame.reg_offset[regno] = SLOT_REQUIRED;\n+\tframe.reg_offset[regno] = SLOT_REQUIRED;\n \tlast_fp_reg = regno;\n       }\n \n-  if (cfun->machine->frame.emit_frame_chain)\n+  if (frame.emit_frame_chain)\n     {\n       /* FP and LR are placed in the linkage record.  */\n-      cfun->machine->frame.reg_offset[R29_REGNUM] = 0;\n-      cfun->machine->frame.wb_candidate1 = R29_REGNUM;\n-      cfun->machine->frame.reg_offset[R30_REGNUM] = UNITS_PER_WORD;\n-      cfun->machine->frame.wb_candidate2 = R30_REGNUM;\n+      frame.reg_offset[R29_REGNUM] = 0;\n+      frame.wb_candidate1 = R29_REGNUM;\n+      frame.reg_offset[R30_REGNUM] = UNITS_PER_WORD;\n+      frame.wb_candidate2 = R30_REGNUM;\n       offset = 2 * UNITS_PER_WORD;\n     }\n \n   /* With stack-clash, LR must be saved in non-leaf functions.  */\n   gcc_assert (crtl->is_leaf\n-\t      || (cfun->machine->frame.reg_offset[R30_REGNUM]\n-\t\t  != SLOT_NOT_REQUIRED));\n+\t      || frame.reg_offset[R30_REGNUM] != SLOT_NOT_REQUIRED);\n \n   /* Now assign stack slots for them.  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n-    if (cfun->machine->frame.reg_offset[regno] == SLOT_REQUIRED)\n+    if (frame.reg_offset[regno] == SLOT_REQUIRED)\n       {\n-\tcfun->machine->frame.reg_offset[regno] = offset;\n-\tif (cfun->machine->frame.wb_candidate1 == INVALID_REGNUM)\n-\t  cfun->machine->frame.wb_candidate1 = regno;\n-\telse if (cfun->machine->frame.wb_candidate2 == INVALID_REGNUM)\n-\t  cfun->machine->frame.wb_candidate2 = regno;\n+\tframe.reg_offset[regno] = offset;\n+\tif (frame.wb_candidate1 == INVALID_REGNUM)\n+\t  frame.wb_candidate1 = regno;\n+\telse if (frame.wb_candidate2 == INVALID_REGNUM)\n+\t  frame.wb_candidate2 = regno;\n \toffset += UNITS_PER_WORD;\n       }\n \n@@ -5396,7 +5395,7 @@ aarch64_layout_frame (void)\n   bool has_align_gap = offset != max_int_offset;\n \n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n-    if (cfun->machine->frame.reg_offset[regno] == SLOT_REQUIRED)\n+    if (frame.reg_offset[regno] == SLOT_REQUIRED)\n       {\n \t/* If there is an alignment gap between integer and fp callee-saves,\n \t   allocate the last fp register to it if possible.  */\n@@ -5405,85 +5404,79 @@ aarch64_layout_frame (void)\n \t    && !simd_function\n \t    && (offset & 8) == 0)\n \t  {\n-\t    cfun->machine->frame.reg_offset[regno] = max_int_offset;\n+\t    frame.reg_offset[regno] = max_int_offset;\n \t    break;\n \t  }\n \n-\tcfun->machine->frame.reg_offset[regno] = offset;\n-\tif (cfun->machine->frame.wb_candidate1 == INVALID_REGNUM)\n-\t  cfun->machine->frame.wb_candidate1 = regno;\n-\telse if (cfun->machine->frame.wb_candidate2 == INVALID_REGNUM\n-\t\t && cfun->machine->frame.wb_candidate1 >= V0_REGNUM)\n-\t  cfun->machine->frame.wb_candidate2 = regno;\n+\tframe.reg_offset[regno] = offset;\n+\tif (frame.wb_candidate1 == INVALID_REGNUM)\n+\t  frame.wb_candidate1 = regno;\n+\telse if (frame.wb_candidate2 == INVALID_REGNUM\n+\t\t && frame.wb_candidate1 >= V0_REGNUM)\n+\t  frame.wb_candidate2 = regno;\n \toffset += simd_function ? UNITS_PER_VREG : UNITS_PER_WORD;\n       }\n \n   offset = ROUND_UP (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n \n-  cfun->machine->frame.saved_regs_size = offset;\n+  frame.saved_regs_size = offset;\n \n   HOST_WIDE_INT varargs_and_saved_regs_size\n-    = offset + cfun->machine->frame.saved_varargs_size;\n+    = offset + frame.saved_varargs_size;\n \n-  cfun->machine->frame.hard_fp_offset\n+  frame.hard_fp_offset\n     = aligned_upper_bound (varargs_and_saved_regs_size\n \t\t\t   + get_frame_size (),\n \t\t\t   STACK_BOUNDARY / BITS_PER_UNIT);\n \n   /* Both these values are already aligned.  */\n   gcc_assert (multiple_p (crtl->outgoing_args_size,\n \t\t\t  STACK_BOUNDARY / BITS_PER_UNIT));\n-  cfun->machine->frame.frame_size\n-    = (cfun->machine->frame.hard_fp_offset\n-       + crtl->outgoing_args_size);\n+  frame.frame_size = frame.hard_fp_offset + crtl->outgoing_args_size;\n \n-  cfun->machine->frame.locals_offset = cfun->machine->frame.saved_varargs_size;\n+  frame.locals_offset = frame.saved_varargs_size;\n \n-  cfun->machine->frame.initial_adjust = 0;\n-  cfun->machine->frame.final_adjust = 0;\n-  cfun->machine->frame.callee_adjust = 0;\n-  cfun->machine->frame.callee_offset = 0;\n+  frame.initial_adjust = 0;\n+  frame.final_adjust = 0;\n+  frame.callee_adjust = 0;\n+  frame.callee_offset = 0;\n \n   HOST_WIDE_INT max_push_offset = 0;\n-  if (cfun->machine->frame.wb_candidate2 != INVALID_REGNUM)\n+  if (frame.wb_candidate2 != INVALID_REGNUM)\n     max_push_offset = 512;\n-  else if (cfun->machine->frame.wb_candidate1 != INVALID_REGNUM)\n+  else if (frame.wb_candidate1 != INVALID_REGNUM)\n     max_push_offset = 256;\n \n   HOST_WIDE_INT const_size, const_fp_offset;\n-  if (cfun->machine->frame.frame_size.is_constant (&const_size)\n+  if (frame.frame_size.is_constant (&const_size)\n       && const_size < max_push_offset\n       && known_eq (crtl->outgoing_args_size, 0))\n     {\n       /* Simple, small frame with no outgoing arguments:\n \t stp reg1, reg2, [sp, -frame_size]!\n \t stp reg3, reg4, [sp, 16]  */\n-      cfun->machine->frame.callee_adjust = const_size;\n+      frame.callee_adjust = const_size;\n     }\n-  else if (known_lt (crtl->outgoing_args_size\n-\t\t     + cfun->machine->frame.saved_regs_size, 512)\n+  else if (known_lt (crtl->outgoing_args_size + frame.saved_regs_size, 512)\n \t   && !(cfun->calls_alloca\n-\t\t&& known_lt (cfun->machine->frame.hard_fp_offset,\n-\t\t\t     max_push_offset)))\n+\t\t&& known_lt (frame.hard_fp_offset, max_push_offset)))\n     {\n       /* Frame with small outgoing arguments:\n \t sub sp, sp, frame_size\n \t stp reg1, reg2, [sp, outgoing_args_size]\n \t stp reg3, reg4, [sp, outgoing_args_size + 16]  */\n-      cfun->machine->frame.initial_adjust = cfun->machine->frame.frame_size;\n-      cfun->machine->frame.callee_offset\n-\t= cfun->machine->frame.frame_size - cfun->machine->frame.hard_fp_offset;\n+      frame.initial_adjust = frame.frame_size;\n+      frame.callee_offset = frame.frame_size - frame.hard_fp_offset;\n     }\n-  else if (cfun->machine->frame.hard_fp_offset.is_constant (&const_fp_offset)\n+  else if (frame.hard_fp_offset.is_constant (&const_fp_offset)\n \t   && const_fp_offset < max_push_offset)\n     {\n       /* Frame with large outgoing arguments but a small local area:\n \t stp reg1, reg2, [sp, -hard_fp_offset]!\n \t stp reg3, reg4, [sp, 16]\n \t sub sp, sp, outgoing_args_size  */\n-      cfun->machine->frame.callee_adjust = const_fp_offset;\n-      cfun->machine->frame.final_adjust\n-\t= cfun->machine->frame.frame_size - cfun->machine->frame.callee_adjust;\n+      frame.callee_adjust = const_fp_offset;\n+      frame.final_adjust = frame.frame_size - frame.callee_adjust;\n     }\n   else\n     {\n@@ -5493,12 +5486,11 @@ aarch64_layout_frame (void)\n \t add x29, sp, 0\n \t stp reg3, reg4, [sp, 16]\n \t sub sp, sp, outgoing_args_size  */\n-      cfun->machine->frame.initial_adjust = cfun->machine->frame.hard_fp_offset;\n-      cfun->machine->frame.final_adjust\n-\t= cfun->machine->frame.frame_size - cfun->machine->frame.initial_adjust;\n+      frame.initial_adjust = frame.hard_fp_offset;\n+      frame.final_adjust = frame.frame_size - frame.initial_adjust;\n     }\n \n-  cfun->machine->frame.laid_out = true;\n+  frame.laid_out = true;\n }\n \n /* Return true if the register REGNO is saved on entry to"}]}