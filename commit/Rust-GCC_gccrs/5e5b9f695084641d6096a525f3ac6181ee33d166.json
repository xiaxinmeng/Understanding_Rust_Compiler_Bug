{"sha": "5e5b9f695084641d6096a525f3ac6181ee33d166", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU1YjlmNjk1MDg0NjQxZDYwOTZhNTI1ZjNhYzYxODFlZTMzZDE2Ng==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1997-08-01T13:06:04Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1997-08-01T13:06:04Z"}, "message": "Initial revision\n\nFrom-SVN: r14572", "tree": {"sha": "33cdd6021ea968a05b5680b537d1cbe783fc64e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33cdd6021ea968a05b5680b537d1cbe783fc64e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e5b9f695084641d6096a525f3ac6181ee33d166", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5b9f695084641d6096a525f3ac6181ee33d166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e5b9f695084641d6096a525f3ac6181ee33d166", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5b9f695084641d6096a525f3ac6181ee33d166/comments", "author": null, "committer": null, "parents": [{"sha": "e3367a77fdd6d56301f02cece97b884c5ae70057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3367a77fdd6d56301f02cece97b884c5ae70057", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3367a77fdd6d56301f02cece97b884c5ae70057"}], "stats": {"total": 262, "additions": 262, "deletions": 0}, "files": [{"sha": "867d901b8ffc53d52a2fde6b1812adf88f97d9e7", "filename": "gcc/intl/cat-compat.c", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5b9f695084641d6096a525f3ac6181ee33d166/gcc%2Fintl%2Fcat-compat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5b9f695084641d6096a525f3ac6181ee33d166/gcc%2Fintl%2Fcat-compat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Fcat-compat.c?ref=5e5b9f695084641d6096a525f3ac6181ee33d166", "patch": "@@ -0,0 +1,262 @@\n+/* Compatibility code for gettext-using-catgets interface.\n+   Copyright (C) 1995, 1997 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+\n+#ifdef STDC_HEADERS\n+# include <stdlib.h>\n+# include <string.h>\n+#else\n+char *getenv ();\n+# ifdef HAVE_MALLOC_H\n+#  include <malloc.h>\n+# endif\n+#endif\n+\n+#ifdef HAVE_NL_TYPES_H\n+# include <nl_types.h>\n+#endif\n+\n+#include \"libgettext.h\"\n+\n+/* @@ end of prolog @@ */\n+\n+/* XPG3 defines the result of `setlocale (category, NULL)' as:\n+   ``Directs `setlocale()' to query `category' and return the current\n+     setting of `local'.''\n+   However it does not specify the exact format.  And even worse: POSIX\n+   defines this not at all.  So we can use this feature only on selected\n+   system (e.g. those using GNU C Library).  */\n+#ifdef _LIBC\n+# define HAVE_LOCALE_NULL\n+#endif\n+\n+/* The catalog descriptor.  */\n+static nl_catd catalog = (nl_catd) -1;\n+\n+/* Name of the default catalog.  */\n+static const char default_catalog_name[] = \"messages\";\n+\n+/* Name of currently used catalog.  */\n+static const char *catalog_name = default_catalog_name;\n+\n+/* Get ID for given string.  If not found return -1.  */\n+static int msg_to_cat_id PARAMS ((const char *msg));\n+\n+/* Substitution for systems lacking this function in their C library.  */\n+#if !_LIBC && !HAVE_STPCPY\n+static char *stpcpy PARAMS ((char *dest, const char *src));\n+#endif\n+\n+\n+/* Set currently used domain/catalog.  */\n+char *\n+textdomain (domainname)\n+     const char *domainname;\n+{\n+  nl_catd new_catalog;\n+  char *new_name;\n+  size_t new_name_len;\n+  char *lang;\n+\n+#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES \\\n+    && defined HAVE_LOCALE_NULL\n+  lang = setlocale (LC_MESSAGES, NULL);\n+#else\n+  lang = getenv (\"LC_ALL\");\n+  if (lang == NULL || lang[0] == '\\0')\n+    {\n+      lang = getenv (\"LC_MESSAGES\");\n+      if (lang == NULL || lang[0] == '\\0')\n+\tlang = getenv (\"LANG\");\n+    }\n+#endif\n+  if (lang == NULL || lang[0] == '\\0')\n+    lang = \"C\";\n+\n+  /* See whether name of currently used domain is asked.  */\n+  if (domainname == NULL)\n+    return (char *) catalog_name;\n+\n+  if (domainname[0] == '\\0')\n+    domainname = default_catalog_name;\n+\n+  /* Compute length of added path element.  */\n+  new_name_len = sizeof (LOCALEDIR) - 1 + 1 + strlen (lang)\n+\t\t + sizeof (\"/LC_MESSAGES/\") - 1 + sizeof (PACKAGE) - 1\n+\t\t + sizeof (\".cat\");\n+\n+  new_name = (char *) malloc (new_name_len);\n+  if (new_name == NULL)\n+    return NULL;\n+\n+  strcpy (new_name, PACKAGE);\n+  new_catalog = catopen (new_name, 0);\n+\n+  if (new_catalog == (nl_catd) -1)\n+    {\n+      /* NLSPATH search didn't work, try absolute path */\n+      sprintf (new_name, \"%s/%s/LC_MESSAGES/%s.cat\", LOCALEDIR, lang,\n+\t       PACKAGE);\n+      new_catalog = catopen (new_name, 0);\n+\n+      if (new_catalog == (nl_catd) -1)\n+\t{\n+\t  free (new_name);\n+\t  return (char *) catalog_name;\n+\t}\n+    }\n+\n+  /* Close old catalog.  */\n+  if (catalog != (nl_catd) -1)\n+    catclose (catalog);\n+  if (catalog_name != default_catalog_name)\n+    free ((char *) catalog_name);\n+\n+  catalog = new_catalog;\n+  catalog_name = new_name;\n+\n+  return (char *) catalog_name;\n+}\n+\n+char *\n+bindtextdomain (domainname, dirname)\n+     const char *domainname;\n+     const char *dirname;\n+{\n+#if HAVE_SETENV || HAVE_PUTENV\n+  char *old_val, *new_val, *cp;\n+  size_t new_val_len;\n+\n+  /* This does not make much sense here but to be compatible do it.  */\n+  if (domainname == NULL)\n+    return NULL;\n+\n+  /* Compute length of added path element.  If we use setenv we don't need\n+     the first byts for NLSPATH=, but why complicate the code for this\n+     peanuts.  */\n+  new_val_len = sizeof (\"NLSPATH=\") - 1 + strlen (dirname)\n+\t\t+ sizeof (\"/%L/LC_MESSAGES/%N.cat\");\n+\n+  old_val = getenv (\"NLSPATH\");\n+  if (old_val == NULL || old_val[0] == '\\0')\n+    {\n+      old_val = NULL;\n+      new_val_len += 1 + sizeof (LOCALEDIR) - 1\n+\t             + sizeof (\"/%L/LC_MESSAGES/%N.cat\");\n+    }\n+  else\n+    new_val_len += strlen (old_val);\n+\n+  new_val = (char *) malloc (new_val_len);\n+  if (new_val == NULL)\n+    return NULL;\n+\n+# if HAVE_SETENV\n+  cp = new_val;\n+# else\n+  cp = stpcpy (new_val, \"NLSPATH=\");\n+# endif\n+\n+  cp = stpcpy (cp, dirname);\n+  cp = stpcpy (cp, \"/%L/LC_MESSAGES/%N.cat:\");\n+\n+  if (old_val == NULL)\n+    {\n+# if __STDC__\n+      stpcpy (cp, LOCALEDIR \"/%L/LC_MESSAGES/%N.cat\");\n+# else\n+\n+      cp = stpcpy (cp, LOCALEDIR);\n+      stpcpy (cp, \"/%L/LC_MESSAGES/%N.cat\");\n+# endif\n+    }\n+  else\n+    stpcpy (cp, old_val);\n+\n+# if HAVE_SETENV\n+  setenv (\"NLSPATH\", new_val, 1);\n+  free (new_val);\n+# else\n+  putenv (new_val);\n+  /* Do *not* free the environment entry we just entered.  It is used\n+     from now on.   */\n+# endif\n+\n+#endif\n+\n+  return (char *) domainname;\n+}\n+\n+#undef gettext\n+char *\n+gettext (msg)\n+     const char *msg;\n+{\n+  int msgid;\n+\n+  if (msg == NULL || catalog == (nl_catd) -1)\n+    return (char *) msg;\n+\n+  /* Get the message from the catalog.  We always use set number 1.\n+     The message ID is computed by the function `msg_to_cat_id'\n+     which works on the table generated by `po-to-tbl'.  */\n+  msgid = msg_to_cat_id (msg);\n+  if (msgid == -1)\n+    return (char *) msg;\n+\n+  return catgets (catalog, 1, msgid, (char *) msg);\n+}\n+\n+/* Look through the table `_msg_tbl' which has `_msg_tbl_length' entries\n+   for the one equal to msg.  If it is found return the ID.  In case when\n+   the string is not found return -1.  */\n+static int\n+msg_to_cat_id (msg)\n+     const char *msg;\n+{\n+  int cnt;\n+\n+  for (cnt = 0; cnt < _msg_tbl_length; ++cnt)\n+    if (strcmp (msg, _msg_tbl[cnt]._msg) == 0)\n+      return _msg_tbl[cnt]._msg_number;\n+\n+  return -1;\n+}\n+\n+\n+/* @@ begin of epilog @@ */\n+\n+/* We don't want libintl.a to depend on any other library.  So we\n+   avoid the non-standard function stpcpy.  In GNU C Library this\n+   function is available, though.  Also allow the symbol HAVE_STPCPY\n+   to be defined.  */\n+#if !_LIBC && !HAVE_STPCPY\n+static char *\n+stpcpy (dest, src)\n+     char *dest;\n+     const char *src;\n+{\n+  while ((*dest++ = *src++) != '\\0')\n+    /* Do nothing. */ ;\n+  return dest - 1;\n+}\n+#endif"}]}