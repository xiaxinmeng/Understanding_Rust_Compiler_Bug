{"sha": "c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwMTJmYmNlOTczYmViYzVjZjJhOTkwNWViZmE5ZmJhZWMxYWZhMA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-01-19T13:59:56Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2016-01-19T13:59:56Z"}, "message": "[Patch 1/4] Simplify the representation of CCMP patterns by using\n\n    2015-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n\n    gcc/\n        * target.def (gen_ccmp_first): Update documentation.\n        (gen_ccmp_next): Likewise.\n        * doc/tm.texi (gen_ccmp_first): Update documentation.\n        (gen_ccmp_next): Likewise.\n        * ccmp.c (expand_ccmp_expr): Extract cmp_code from return value of\n        expand_ccmp_expr_1.  Improve comments.\n        * config/aarch64/aarch64.md (ccmp_and): Use if_then_else for ccmp.\n        (ccmp_ior<mode>): Remove pattern.\n        (cmp<mode>): Remove expand.\n        (cmp): Globalize pattern.\n        (cstorecc4): Use cc_register.\n        (mov<mode>cc): Remove ccmp_cc_register check.\n        * config/aarch64/aarch64.c (aarch64_get_condition_code_1):\n        Simplify after removal of CC_DNE/* modes.\n        (aarch64_ccmp_mode_to_code): Remove.\n        (aarch64_print_operand): Remove 'K' case.  Merge 'm' and 'M' cases.\n        In 'k' case use integer as condition.\n        (aarch64_nzcv_codes): Remove inverted cases.\n        (aarch64_code_to_ccmode): Remove.\n        (aarch64_gen_ccmp_first): Use cmp pattern directly.  Return the correct\n        comparison with CC register to be used in folowing CCMP/branch/CSEL.\n        (aarch64_gen_ccmp_next): Use previous comparison and mode in CCMP\n        pattern.  Return the comparison with CC register.  Invert conditions\n        when bitcode is OR.\n        * config/aarch64/aarch64-modes.def: Remove CC_DNE/* modes.\n        * config/aarch64/predicates.md (ccmp_cc_register): Remove.\n\nFrom-SVN: r232561", "tree": {"sha": "40411588caf22f22a87c45f55d64e7352997b459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40411588caf22f22a87c45f55d64e7352997b459"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/comments", "author": null, "committer": null, "parents": [{"sha": "756f4e9049bb7739624a8ad7b2ff36f151a7a983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756f4e9049bb7739624a8ad7b2ff36f151a7a983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/756f4e9049bb7739624a8ad7b2ff36f151a7a983"}], "stats": {"total": 522, "additions": 157, "deletions": 365}, "files": [{"sha": "93cb42a92a6c22d5c92a64c61c98d6e03bad48b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -1,3 +1,32 @@\n+2016-01-19  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* target.def (gen_ccmp_first): Update documentation.\n+\t(gen_ccmp_next): Likewise.\n+\t* doc/tm.texi (gen_ccmp_first): Update documentation.\n+\t(gen_ccmp_next): Likewise.\n+\t* ccmp.c (expand_ccmp_expr): Extract cmp_code from return value of\n+\texpand_ccmp_expr_1.  Improve comments.\n+\t* config/aarch64/aarch64.md (ccmp_and): Use if_then_else for ccmp.\n+\t(ccmp_ior<mode>): Remove pattern.\n+\t(cmp<mode>): Remove expand.\n+\t(cmp): Globalize pattern.\n+\t(cstorecc4): Use cc_register.\n+\t(mov<mode>cc): Remove ccmp_cc_register check.\n+\t* config/aarch64/aarch64.c (aarch64_get_condition_code_1):\n+\tSimplify after removal of CC_DNE/* modes.\n+\t(aarch64_ccmp_mode_to_code): Remove.\n+\t(aarch64_print_operand): Remove 'K' case.  Merge 'm' and 'M' cases.\n+\tIn 'k' case use integer as condition.\n+\t(aarch64_nzcv_codes): Remove inverted cases.\n+\t(aarch64_code_to_ccmode): Remove.\n+\t(aarch64_gen_ccmp_first): Use cmp pattern directly.  Return the correct\n+\tcomparison with CC register to be used in folowing CCMP/branch/CSEL.\n+\t(aarch64_gen_ccmp_next): Use previous comparison and mode in CCMP\n+\tpattern.  Return the comparison with CC register.  Invert conditions\n+\twhen bitcode is OR.\n+\t* config/aarch64/aarch64-modes.def: Remove CC_DNE/* modes.\n+\t* config/aarch64/predicates.md (ccmp_cc_register): Remove.\n+\n 2016-01-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraphunit.c (cgraph_node::reset): Clear thunk info and"}, {"sha": "28fe189c67f6175e145d89a690fcfe8d66eb5b2b", "filename": "gcc/ccmp.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -49,6 +49,10 @@ along with GCC; see the file COPYING3.  If not see\n \t - gen_ccmp_first expands the first compare in CCMP.\n \t - gen_ccmp_next expands the following compares.\n \n+       Both hooks return a comparison with the CC register that is equivalent\n+       to the value of the gimple comparison.  This is used by the next CCMP\n+       and in the final conditional store.\n+\n      * We use cstorecc4 pattern to convert the CCmode intermediate to\n        the integer mode result that expand_normal is expecting.\n \n@@ -114,10 +118,12 @@ ccmp_candidate_p (gimple *g)\n   return false;\n }\n \n-/* PREV is the CC flag from precvious compares.  The function expands the\n-   next compare based on G which ops previous compare with CODE.\n+/* PREV is a comparison with the CC register which represents the\n+   result of the previous CMP or CCMP.  The function expands the\n+   next compare based on G which is ANDed/ORed with the previous\n+   compare depending on CODE.\n    PREP_SEQ returns all insns to prepare opearands for compare.\n-   GEN_SEQ returnss all compare insns.  */\n+   GEN_SEQ returns all compare insns.  */\n static rtx\n expand_ccmp_next (gimple *g, enum tree_code code, rtx prev,\n \t\t  rtx *prep_seq, rtx *gen_seq)\n@@ -210,7 +216,7 @@ expand_ccmp_expr_1 (gimple *g, rtx *prep_seq, rtx *gen_seq)\n   return NULL_RTX;\n }\n \n-/* Main entry to expand conditional compare statement G. \n+/* Main entry to expand conditional compare statement G.\n    Return NULL_RTX if G is not a legal candidate or expand fail.\n    Otherwise return the target.  */\n rtx\n@@ -233,9 +239,10 @@ expand_ccmp_expr (gimple *g)\n       enum insn_code icode;\n       enum machine_mode cc_mode = CCmode;\n       tree lhs = gimple_assign_lhs (g);\n+      rtx_code cmp_code = GET_CODE (tmp);\n \n #ifdef SELECT_CC_MODE\n-      cc_mode = SELECT_CC_MODE (NE, tmp, const0_rtx);\n+      cc_mode = SELECT_CC_MODE (cmp_code, XEXP (tmp, 0), const0_rtx);\n #endif\n       icode = optab_handler (cstore_optab, cc_mode);\n       if (icode != CODE_FOR_nothing)\n@@ -246,8 +253,8 @@ expand_ccmp_expr (gimple *g)\n \t  emit_insn (prep_seq);\n \t  emit_insn (gen_seq);\n \n-\t  tmp = emit_cstore (target, icode, NE, cc_mode, cc_mode,\n-\t\t\t     0, tmp, const0_rtx, 1, mode);\n+\t  tmp = emit_cstore (target, icode, cmp_code, cc_mode, cc_mode,\n+\t\t\t     0, XEXP (tmp, 0), const0_rtx, 1, mode);\n \t  if (tmp)\n \t    return tmp;\n \t}"}, {"sha": "3fab2053cebad9aaa915667813ab0bb0765a30cc", "filename": "gcc/config/aarch64/aarch64-modes.def", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -25,16 +25,6 @@ CC_MODE (CC_ZESWP); /* zero-extend LHS (but swap to make it RHS).  */\n CC_MODE (CC_SESWP); /* sign-extend LHS (but swap to make it RHS).  */\n CC_MODE (CC_NZ);    /* Only N and Z bits of condition flags are valid.  */\n CC_MODE (CC_Z);     /* Only Z bit of condition flags is valid.  */\n-CC_MODE (CC_DNE);\n-CC_MODE (CC_DEQ);\n-CC_MODE (CC_DLE);\n-CC_MODE (CC_DLT);\n-CC_MODE (CC_DGE);\n-CC_MODE (CC_DGT);\n-CC_MODE (CC_DLEU);\n-CC_MODE (CC_DLTU);\n-CC_MODE (CC_DGEU);\n-CC_MODE (CC_DGTU);\n \n /* Half-precision floating point for __fp16.  */\n FLOAT_MODE (HF, 2, 0);"}, {"sha": "041e642b1a0e7433fafb0e12320ac7820ff81bb5", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 63, "deletions": 242, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -4205,7 +4205,6 @@ aarch64_get_condition_code (rtx x)\n static int\n aarch64_get_condition_code_1 (enum machine_mode mode, enum rtx_code comp_code)\n {\n-  int ne = -1, eq = -1;\n   switch (mode)\n     {\n     case CCFPmode:\n@@ -4228,56 +4227,6 @@ aarch64_get_condition_code_1 (enum machine_mode mode, enum rtx_code comp_code)\n \t}\n       break;\n \n-    case CC_DNEmode:\n-      ne = AARCH64_NE;\n-      eq = AARCH64_EQ;\n-      break;\n-\n-    case CC_DEQmode:\n-      ne = AARCH64_EQ;\n-      eq = AARCH64_NE;\n-      break;\n-\n-    case CC_DGEmode:\n-      ne = AARCH64_GE;\n-      eq = AARCH64_LT;\n-      break;\n-\n-    case CC_DLTmode:\n-      ne = AARCH64_LT;\n-      eq = AARCH64_GE;\n-      break;\n-\n-    case CC_DGTmode:\n-      ne = AARCH64_GT;\n-      eq = AARCH64_LE;\n-      break;\n-\n-    case CC_DLEmode:\n-      ne = AARCH64_LE;\n-      eq = AARCH64_GT;\n-      break;\n-\n-    case CC_DGEUmode:\n-      ne = AARCH64_CS;\n-      eq = AARCH64_CC;\n-      break;\n-\n-    case CC_DLTUmode:\n-      ne = AARCH64_CC;\n-      eq = AARCH64_CS;\n-      break;\n-\n-    case CC_DGTUmode:\n-      ne = AARCH64_HI;\n-      eq = AARCH64_LS;\n-      break;\n-\n-    case CC_DLEUmode:\n-      ne = AARCH64_LS;\n-      eq = AARCH64_HI;\n-      break;\n-\n     case CCmode:\n       switch (comp_code)\n \t{\n@@ -4339,12 +4288,6 @@ aarch64_get_condition_code_1 (enum machine_mode mode, enum rtx_code comp_code)\n       break;\n     }\n \n-  if (comp_code == NE)\n-    return ne;\n-\n-  if (comp_code == EQ)\n-    return eq;\n-\n   return -1;\n }\n \n@@ -4385,69 +4328,27 @@ aarch64_const_vec_all_same_int_p (rtx x, HOST_WIDE_INT val)\n #define AARCH64_CC_Z (1 << 2)\n #define AARCH64_CC_N (1 << 3)\n \n-/* N Z C V flags for ccmp.  The first code is for AND op and the other\n-   is for IOR op.  Indexed by AARCH64_COND_CODE.  */\n-static const int aarch64_nzcv_codes[][2] =\n-{\n-  {AARCH64_CC_Z, 0}, /* EQ, Z == 1.  */\n-  {0, AARCH64_CC_Z}, /* NE, Z == 0.  */\n-  {AARCH64_CC_C, 0}, /* CS, C == 1.  */\n-  {0, AARCH64_CC_C}, /* CC, C == 0.  */\n-  {AARCH64_CC_N, 0}, /* MI, N == 1.  */\n-  {0, AARCH64_CC_N}, /* PL, N == 0.  */\n-  {AARCH64_CC_V, 0}, /* VS, V == 1.  */\n-  {0, AARCH64_CC_V}, /* VC, V == 0.  */\n-  {AARCH64_CC_C, 0}, /* HI, C ==1 && Z == 0.  */\n-  {0, AARCH64_CC_C}, /* LS, !(C == 1 && Z == 0).  */\n-  {0, AARCH64_CC_V}, /* GE, N == V.  */\n-  {AARCH64_CC_V, 0}, /* LT, N != V.  */\n-  {0, AARCH64_CC_Z}, /* GT, Z == 0 && N == V.  */\n-  {AARCH64_CC_Z, 0}, /* LE, !(Z == 0 && N == V).  */\n-  {0, 0}, /* AL, Any.  */\n-  {0, 0}, /* NV, Any.  */\n+/* N Z C V flags for ccmp.  Indexed by AARCH64_COND_CODE.  */\n+static const int aarch64_nzcv_codes[] =\n+{\n+  0,\t\t/* EQ, Z == 1.  */\n+  AARCH64_CC_Z,\t/* NE, Z == 0.  */\n+  0,\t\t/* CS, C == 1.  */\n+  AARCH64_CC_C,\t/* CC, C == 0.  */\n+  0,\t\t/* MI, N == 1.  */\n+  AARCH64_CC_N, /* PL, N == 0.  */\n+  0,\t\t/* VS, V == 1.  */\n+  AARCH64_CC_V, /* VC, V == 0.  */\n+  0,\t\t/* HI, C ==1 && Z == 0.  */\n+  AARCH64_CC_C,\t/* LS, !(C == 1 && Z == 0).  */\n+  AARCH64_CC_V,\t/* GE, N == V.  */\n+  0,\t\t/* LT, N != V.  */\n+  AARCH64_CC_Z, /* GT, Z == 0 && N == V.  */\n+  0,\t\t/* LE, !(Z == 0 && N == V).  */\n+  0,\t\t/* AL, Any.  */\n+  0\t\t/* NV, Any.  */\n };\n \n-int\n-aarch64_ccmp_mode_to_code (enum machine_mode mode)\n-{\n-  switch (mode)\n-    {\n-    case CC_DNEmode:\n-      return NE;\n-\n-    case CC_DEQmode:\n-      return EQ;\n-\n-    case CC_DLEmode:\n-      return LE;\n-\n-    case CC_DGTmode:\n-      return GT;\n-\n-    case CC_DLTmode:\n-      return LT;\n-\n-    case CC_DGEmode:\n-      return GE;\n-\n-    case CC_DLEUmode:\n-      return LEU;\n-\n-    case CC_DGTUmode:\n-      return GTU;\n-\n-    case CC_DLTUmode:\n-      return LTU;\n-\n-    case CC_DGEUmode:\n-      return GEU;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-\n static void\n aarch64_print_operand (FILE *f, rtx x, int code)\n {\n@@ -4546,36 +4447,17 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n       asm_fprintf (f, \"%s\", reg_names [REGNO (x) + 1]);\n       break;\n \n-    case 'm':\n-      {\n-        int cond_code;\n-        /* Print a condition (eq, ne, etc).  */\n-\n-        /* CONST_TRUE_RTX means always -- that's the default.  */\n-        if (x == const_true_rtx)\n-\t  return;\n-\n-        if (!COMPARISON_P (x))\n-\t  {\n-\t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n-\t    return;\n-\t  }\n-\n-        cond_code = aarch64_get_condition_code (x);\n-        gcc_assert (cond_code >= 0);\n-        fputs (aarch64_condition_codes[cond_code], f);\n-      }\n-      break;\n-\n     case 'M':\n+    case 'm':\n       {\n         int cond_code;\n-        /* Print the inverse of a condition (eq <-> ne, etc).  */\n+\t/* Print a condition (eq, ne, etc) or its inverse.  */\n \n-        /* CONST_TRUE_RTX means never -- that's the default.  */\n-        if (x == const_true_rtx)\n+\t/* CONST_TRUE_RTX means al/nv (al is the default, don't print it).  */\n+\tif (x == const_true_rtx)\n \t  {\n-\t    fputs (\"nv\", f);\n+\t    if (code == 'M')\n+\t      fputs (\"nv\", f);\n \t    return;\n \t  }\n \n@@ -4584,10 +4466,12 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n \t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n \t    return;\n \t  }\n+\n         cond_code = aarch64_get_condition_code (x);\n         gcc_assert (cond_code >= 0);\n-        fputs (aarch64_condition_codes[AARCH64_INVERSE_CONDITION_CODE\n-                                       (cond_code)], f);\n+\tif (code == 'M')\n+\t  cond_code = AARCH64_INVERSE_CONDITION_CODE (cond_code);\n+\tfputs (aarch64_condition_codes[cond_code], f);\n       }\n       break;\n \n@@ -4828,37 +4712,20 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n       output_addr_const (asm_out_file, x);\n       break;\n \n-    case 'K':\n-      {\n-\tint cond_code;\n-\t/* Print nzcv.  */\n-\n-\tif (!COMPARISON_P (x))\n-\t  {\n-\t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n-\t    return;\n-\t  }\n-\n-\tcond_code = aarch64_get_condition_code_1 (CCmode, GET_CODE (x));\n-\tgcc_assert (cond_code >= 0);\n-\tasm_fprintf (f, \"%d\", aarch64_nzcv_codes[cond_code][0]);\n-      }\n-      break;\n-\n     case 'k':\n       {\n-\tint cond_code;\n+\tHOST_WIDE_INT cond_code;\n \t/* Print nzcv.  */\n \n-\tif (!COMPARISON_P (x))\n+\tif (!CONST_INT_P (x))\n \t  {\n \t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n \t    return;\n \t  }\n \n-\tcond_code = aarch64_get_condition_code_1 (CCmode, GET_CODE (x));\n-\tgcc_assert (cond_code >= 0);\n-\tasm_fprintf (f, \"%d\", aarch64_nzcv_codes[cond_code][1]);\n+\tcond_code = INTVAL (x);\n+\tgcc_assert (cond_code >= 0 && cond_code <= AARCH64_NV);\n+\tasm_fprintf (f, \"%d\", aarch64_nzcv_codes[cond_code]);\n       }\n       break;\n \n@@ -13066,60 +12933,16 @@ aarch64_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n   return default_use_by_pieces_infrastructure_p (size, align, op, speed_p);\n }\n \n-static enum machine_mode\n-aarch64_code_to_ccmode (enum rtx_code code)\n-{\n-  switch (code)\n-    {\n-    case NE:\n-      return CC_DNEmode;\n-\n-    case EQ:\n-      return CC_DEQmode;\n-\n-    case LE:\n-      return CC_DLEmode;\n-\n-    case LT:\n-      return CC_DLTmode;\n-\n-    case GE:\n-      return CC_DGEmode;\n-\n-    case GT:\n-      return CC_DGTmode;\n-\n-    case LEU:\n-      return CC_DLEUmode;\n-\n-    case LTU:\n-      return CC_DLTUmode;\n-\n-    case GEU:\n-      return CC_DGEUmode;\n-\n-    case GTU:\n-      return CC_DGTUmode;\n-\n-    default:\n-      return CCmode;\n-    }\n-}\n-\n static rtx\n aarch64_gen_ccmp_first (rtx *prep_seq, rtx *gen_seq,\n \t\t\tint code, tree treeop0, tree treeop1)\n {\n-  enum machine_mode op_mode, cmp_mode, cc_mode;\n-  rtx op0, op1, cmp, target;\n+  machine_mode op_mode, cmp_mode, cc_mode = CCmode;\n+  rtx op0, op1;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (treeop0));\n-  enum insn_code icode;\n+  insn_code icode;\n   struct expand_operand ops[4];\n \n-  cc_mode = aarch64_code_to_ccmode ((enum rtx_code) code);\n-  if (cc_mode == CCmode)\n-    return NULL_RTX;\n-\n   start_sequence ();\n   expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \n@@ -13146,8 +12969,8 @@ aarch64_gen_ccmp_first (rtx *prep_seq, rtx *gen_seq,\n       return NULL_RTX;\n     }\n \n-  op0 = prepare_operand (icode, op0, 2, op_mode, cmp_mode, unsignedp);\n-  op1 = prepare_operand (icode, op1, 3, op_mode, cmp_mode, unsignedp);\n+  op0 = prepare_operand (icode, op0, 0, op_mode, cmp_mode, unsignedp);\n+  op1 = prepare_operand (icode, op1, 1, op_mode, cmp_mode, unsignedp);\n   if (!op0 || !op1)\n     {\n       end_sequence ();\n@@ -13156,39 +12979,32 @@ aarch64_gen_ccmp_first (rtx *prep_seq, rtx *gen_seq,\n   *prep_seq = get_insns ();\n   end_sequence ();\n \n-  cmp = gen_rtx_fmt_ee ((enum rtx_code) code, cmp_mode, op0, op1);\n-  target = gen_rtx_REG (CCmode, CC_REGNUM);\n-\n-  create_output_operand (&ops[0], target, CCmode);\n-  create_fixed_operand (&ops[1], cmp);\n-  create_fixed_operand (&ops[2], op0);\n-  create_fixed_operand (&ops[3], op1);\n+  create_fixed_operand (&ops[0], op0);\n+  create_fixed_operand (&ops[1], op1);\n \n   start_sequence ();\n-  if (!maybe_expand_insn (icode, 4, ops))\n+  if (!maybe_expand_insn (icode, 2, ops))\n     {\n       end_sequence ();\n       return NULL_RTX;\n     }\n   *gen_seq = get_insns ();\n   end_sequence ();\n \n-  return gen_rtx_REG (cc_mode, CC_REGNUM);\n+  return gen_rtx_fmt_ee ((rtx_code) code, cc_mode,\n+\t\t\t gen_rtx_REG (cc_mode, CC_REGNUM), const0_rtx);\n }\n \n static rtx\n aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n \t\t       tree treeop0, tree treeop1, int bit_code)\n {\n-  rtx op0, op1, cmp0, cmp1, target;\n-  enum machine_mode op_mode, cmp_mode, cc_mode;\n+  rtx op0, op1, target;\n+  machine_mode op_mode, cmp_mode, cc_mode = CCmode;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (treeop0));\n-  enum insn_code icode = CODE_FOR_ccmp_andsi;\n+  insn_code icode;\n   struct expand_operand ops[6];\n-\n-  cc_mode = aarch64_code_to_ccmode ((enum rtx_code) cmp_code);\n-  if (cc_mode == CCmode)\n-    return NULL_RTX;\n+  int aarch64_cond;\n \n   push_to_sequence ((rtx_insn*) *prep_seq);\n   expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n@@ -13203,14 +13019,12 @@ aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n     case HImode:\n     case SImode:\n       cmp_mode = SImode;\n-      icode = (enum rtx_code) bit_code == AND ? CODE_FOR_ccmp_andsi\n-\t\t\t\t\t\t: CODE_FOR_ccmp_iorsi;\n+      icode = CODE_FOR_ccmpsi;\n       break;\n \n     case DImode:\n       cmp_mode = DImode;\n-      icode = (enum rtx_code) bit_code == AND ? CODE_FOR_ccmp_anddi\n-\t\t\t\t\t\t: CODE_FOR_ccmp_iordi;\n+      icode = CODE_FOR_ccmpdi;\n       break;\n \n     default:\n@@ -13229,15 +13043,22 @@ aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n   end_sequence ();\n \n   target = gen_rtx_REG (cc_mode, CC_REGNUM);\n-  cmp1 = gen_rtx_fmt_ee ((enum rtx_code) cmp_code, cmp_mode, op0, op1);\n-  cmp0 = gen_rtx_fmt_ee (NE, cmp_mode, prev, const0_rtx);\n+  aarch64_cond = aarch64_get_condition_code_1 (cc_mode, (rtx_code) cmp_code);\n \n-  create_fixed_operand (&ops[0], prev);\n+  if (bit_code != AND)\n+    {\n+      prev = gen_rtx_fmt_ee (REVERSE_CONDITION (GET_CODE (prev),\n+\t\t\t\t\t\tGET_MODE (XEXP (prev, 0))),\n+\t\t\t     VOIDmode, XEXP (prev, 0), const0_rtx);\n+      aarch64_cond = AARCH64_INVERSE_CONDITION_CODE (aarch64_cond);\n+    }\n+\n+  create_fixed_operand (&ops[0], XEXP (prev, 0));\n   create_fixed_operand (&ops[1], target);\n   create_fixed_operand (&ops[2], op0);\n   create_fixed_operand (&ops[3], op1);\n-  create_fixed_operand (&ops[4], cmp0);\n-  create_fixed_operand (&ops[5], cmp1);\n+  create_fixed_operand (&ops[4], prev);\n+  create_fixed_operand (&ops[5], GEN_INT (aarch64_cond));\n \n   push_to_sequence ((rtx_insn*) *gen_seq);\n   if (!maybe_expand_insn (icode, 6, ops))\n@@ -13249,7 +13070,7 @@ aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n   *gen_seq = get_insns ();\n   end_sequence ();\n \n-  return target;\n+  return gen_rtx_fmt_ee ((rtx_code) cmp_code, VOIDmode, target, const0_rtx);\n }\n \n #undef TARGET_GEN_CCMP_FIRST"}, {"sha": "d8ae8e86cb7b99f341cfba3917f424bcfd753249", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 15, "deletions": 53, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -271,58 +271,24 @@\n   \"\"\n   \"\")\n \n-(define_insn \"ccmp_and<mode>\"\n-  [(set (match_operand 1 \"ccmp_cc_register\" \"\")\n-\t(compare\n-\t (and:SI\n+(define_insn \"ccmp<mode>\"\n+  [(set (match_operand:CC 1 \"cc_register\" \"\")\n+\t(if_then_else:CC\n \t  (match_operator 4 \"aarch64_comparison_operator\"\n-\t   [(match_operand 0 \"ccmp_cc_register\" \"\")\n+\t   [(match_operand 0 \"cc_register\" \"\")\n \t    (const_int 0)])\n-\t  (match_operator 5 \"aarch64_comparison_operator\"\n-\t   [(match_operand:GPI 2 \"register_operand\" \"r,r,r\")\n-\t    (match_operand:GPI 3 \"aarch64_ccmp_operand\" \"r,Uss,Usn\")]))\n-\t (const_int 0)))]\n-  \"aarch64_ccmp_mode_to_code (GET_MODE (operands[1])) == GET_CODE (operands[5])\"\n+\t  (compare:CC\n+\t    (match_operand:GPI 2 \"register_operand\" \"r,r,r\")\n+\t    (match_operand:GPI 3 \"aarch64_ccmp_operand\" \"r,Uss,Usn\"))\n+\t  (match_operand 5 \"immediate_operand\")))]\n+  \"\"\n   \"@\n    ccmp\\\\t%<w>2, %<w>3, %k5, %m4\n    ccmp\\\\t%<w>2, %<w>3, %k5, %m4\n    ccmn\\\\t%<w>2, #%n3, %k5, %m4\"\n   [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n )\n \n-(define_insn \"ccmp_ior<mode>\"\n-  [(set (match_operand 1 \"ccmp_cc_register\" \"\")\n-\t(compare\n-\t (ior:SI\n-\t  (match_operator 4 \"aarch64_comparison_operator\"\n-\t   [(match_operand 0 \"ccmp_cc_register\" \"\")\n-\t    (const_int 0)])\n-\t  (match_operator 5 \"aarch64_comparison_operator\"\n-\t   [(match_operand:GPI 2 \"register_operand\" \"r,r,r\")\n-\t    (match_operand:GPI 3 \"aarch64_ccmp_operand\" \"r,Uss,Usn\")]))\n-\t (const_int 0)))]\n-  \"aarch64_ccmp_mode_to_code (GET_MODE (operands[1])) == GET_CODE (operands[5])\"\n-  \"@\n-   ccmp\\\\t%<w>2, %<w>3, %K5, %M4\n-   ccmp\\\\t%<w>2, %<w>3, %K5, %M4\n-   ccmn\\\\t%<w>2, #%n3, %K5, %M4\"\n-  [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n-)\n-\n-(define_expand \"cmp<mode>\"\n-  [(set (match_operand 0 \"cc_register\" \"\")\n-        (match_operator:CC 1 \"aarch64_comparison_operator\"\n-         [(match_operand:GPI 2 \"register_operand\" \"\")\n-          (match_operand:GPI 3 \"aarch64_plus_operand\" \"\")]))]\n-  \"\"\n-  {\n-    operands[1] = gen_rtx_fmt_ee (COMPARE,\n-\t\t\t\t  SELECT_CC_MODE (GET_CODE (operands[1]),\n-\t\t\t\t\t\t  operands[2], operands[3]),\n-\t\t\t\t  operands[2], operands[3]);\n-  }\n-)\n-\n ;; Expansion of signed mod by a power of 2 using CSNEG.\n ;; For x0 % n where n is a power of 2 produce:\n ;; negs   x1, x0\n@@ -2874,7 +2840,7 @@\n ;; Comparison insns\n ;; -------------------------------------------------------------------\n \n-(define_insn \"*cmp<mode>\"\n+(define_insn \"cmp<mode>\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC (match_operand:GPI 0 \"register_operand\" \"r,r,r\")\n \t\t    (match_operand:GPI 1 \"aarch64_plus_operand\" \"r,I,J\")))]\n@@ -2961,7 +2927,7 @@\n (define_expand \"cstorecc4\"\n   [(set (match_operand:SI 0 \"register_operand\")\n        (match_operator 1 \"aarch64_comparison_operator\"\n-        [(match_operand 2 \"ccmp_cc_register\")\n+\t[(match_operand 2 \"cc_register\")\n          (match_operand 3 \"const0_operand\")]))]\n   \"\"\n \"{\n@@ -3164,19 +3130,15 @@\n \t\t\t   (match_operand:ALLI 3 \"register_operand\" \"\")))]\n   \"\"\n   {\n+    rtx ccreg;\n     enum rtx_code code = GET_CODE (operands[1]);\n \n     if (code == UNEQ || code == LTGT)\n       FAIL;\n \n-    if (!ccmp_cc_register (XEXP (operands[1], 0),\n-\t\t\t   GET_MODE (XEXP (operands[1], 0))))\n-      {\n-\trtx ccreg;\n-\tccreg = aarch64_gen_compare_reg (code, XEXP (operands[1], 0),\n-\t\t\t\t\t XEXP (operands[1], 1));\n-\toperands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n-      }\n+    ccreg = aarch64_gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\t     XEXP (operands[1], 1));\n+    operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n   }\n )\n "}, {"sha": "e96dc000bea8470daa187dfd7c44e9c9993dbb0f", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -43,23 +43,6 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"aarch64_ccmp_immediate\")))\n \n-(define_special_predicate \"ccmp_cc_register\"\n-  (and (match_code \"reg\")\n-       (and (match_test \"REGNO (op) == CC_REGNUM\")\n-\t    (ior (match_test \"mode == GET_MODE (op)\")\n-\t\t (match_test \"mode == VOIDmode\n-\t\t\t      && (GET_MODE (op) == CC_DNEmode\n-\t\t\t\t  || GET_MODE (op) == CC_DEQmode\n-\t\t\t\t  || GET_MODE (op) == CC_DLEmode\n-\t\t\t\t  || GET_MODE (op) == CC_DLTmode\n-\t\t\t\t  || GET_MODE (op) == CC_DGEmode\n-\t\t\t\t  || GET_MODE (op) == CC_DGTmode\n-\t\t\t\t  || GET_MODE (op) == CC_DLEUmode\n-\t\t\t\t  || GET_MODE (op) == CC_DLTUmode\n-\t\t\t\t  || GET_MODE (op) == CC_DGEUmode\n-\t\t\t\t  || GET_MODE (op) == CC_DGTUmode)\"))))\n-)\n-\n (define_predicate \"aarch64_simd_register\"\n   (and (match_code \"reg\")\n        (ior (match_test \"REGNO_REG_CLASS (REGNO (op)) == FP_LO_REGS\")"}, {"sha": "aae09bfc82f1f736f779a13ad6b1945c69a7f986", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -11370,27 +11370,27 @@ modes and they have different conditional execution capability, such as ARM.\n \n @deftypefn {Target Hook} rtx TARGET_GEN_CCMP_FIRST (rtx *@var{prep_seq}, rtx *@var{gen_seq}, int @var{code}, tree @var{op0}, tree @var{op1})\n This function prepares to emit a comparison insn for the first compare in a\n- sequence of conditional comparisions.  It returns a appropriate @code{CC}\n- for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to\n- prepare the compare are saved in @var{prep_seq} and the compare insns are\n- saved in @var{gen_seq}.  They will be emitted when all the compares in the\n- the conditional comparision are generated without error.  @var{code} is\n- the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\n+ sequence of conditional comparisions.  It returns an appropriate comparison\n+ with @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\n+ The insns to prepare the compare are saved in @var{prep_seq} and the compare\n+ insns are saved in @var{gen_seq}.  They will be emitted when all the\n+ compares in the the conditional comparision are generated without error.\n+ @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\n @end deftypefn\n \n @deftypefn {Target Hook} rtx TARGET_GEN_CCMP_NEXT (rtx *@var{prep_seq}, rtx *@var{gen_seq}, rtx @var{prev}, int @var{cmp_code}, tree @var{op0}, tree @var{op1}, int @var{bit_code})\n-This function prepare to emit a conditional comparison within a sequence of\n- conditional comparisons.  It returns a appropriate @code{CC} for passing to\n- @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to prepare the\n- compare are saved in @var{prep_seq} and the compare insns are saved in\n- @var{gen_seq}.  They will be emitted when all the compares in the conditional\n- comparision are generated without error.  The @var{prev} expression is the\n- result of a prior call to @code{gen_ccmp_first} or @code{gen_ccmp_next}.  It\n- may return @code{NULL} if the combination of @var{prev} and this comparison is\n- not supported, otherwise the result must be appropriate for passing to\n- @code{gen_ccmp_next} or @code{cbranch_optab}.  @var{code} is the\n- @code{rtx_code} of the compare for @var{op0} and @var{op1}.  @var{bit_code}\n- is @code{AND} or @code{IOR}, which is the op on the two compares.\n+This function prepares to emit a conditional comparison within a sequence\n+ of conditional comparisons.  It returns an appropriate comparison with\n+ @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\n+ The insns to prepare the compare are saved in @var{prep_seq} and the compare\n+ insns are saved in @var{gen_seq}.  They will be emitted when all the\n+ compares in the conditional comparision are generated without error.  The\n+ @var{prev} expression is the result of a prior call to @code{gen_ccmp_first}\n+ or @code{gen_ccmp_next}.  It may return @code{NULL} if the combination of\n+ @var{prev} and this comparison is not supported, otherwise the result must\n+ be appropriate for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\n+ @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\n+ @var{bit_code} is @code{AND} or @code{IOR}, which is the op on the compares.\n @end deftypefn\n \n @deftypefn {Target Hook} unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned @var{nunroll}, struct loop *@var{loop})"}, {"sha": "d60319e455e27d90096083f03133dd3ea270ec25", "filename": "gcc/target.def", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=c8012fbce973bebc5cf2a9905ebfa9fbaec1afa0", "patch": "@@ -2611,29 +2611,29 @@ modes and they have different conditional execution capability, such as ARM.\",\n DEFHOOK\n (gen_ccmp_first,\n  \"This function prepares to emit a comparison insn for the first compare in a\\n\\\n- sequence of conditional comparisions.  It returns a appropriate @code{CC}\\n\\\n- for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to\\n\\\n- prepare the compare are saved in @var{prep_seq} and the compare insns are\\n\\\n- saved in @var{gen_seq}.  They will be emitted when all the compares in the\\n\\\n- the conditional comparision are generated without error.  @var{code} is\\n\\\n- the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\",\n+ sequence of conditional comparisions.  It returns an appropriate comparison\\n\\\n+ with @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\\n\\\n+ The insns to prepare the compare are saved in @var{prep_seq} and the compare\\n\\\n+ insns are saved in @var{gen_seq}.  They will be emitted when all the\\n\\\n+ compares in the the conditional comparision are generated without error.\\n\\\n+ @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\",\n  rtx, (rtx *prep_seq, rtx *gen_seq, int code, tree op0, tree op1),\n  NULL)\n \n DEFHOOK\n (gen_ccmp_next,\n- \"This function prepare to emit a conditional comparison within a sequence of\\n\\\n- conditional comparisons.  It returns a appropriate @code{CC} for passing to\\n\\\n- @code{gen_ccmp_next} or @code{cbranch_optab}.  The insns to prepare the\\n\\\n- compare are saved in @var{prep_seq} and the compare insns are saved in\\n\\\n- @var{gen_seq}.  They will be emitted when all the compares in the conditional\\n\\\n- comparision are generated without error.  The @var{prev} expression is the\\n\\\n- result of a prior call to @code{gen_ccmp_first} or @code{gen_ccmp_next}.  It\\n\\\n- may return @code{NULL} if the combination of @var{prev} and this comparison is\\n\\\n- not supported, otherwise the result must be appropriate for passing to\\n\\\n- @code{gen_ccmp_next} or @code{cbranch_optab}.  @var{code} is the\\n\\\n- @code{rtx_code} of the compare for @var{op0} and @var{op1}.  @var{bit_code}\\n\\\n- is @code{AND} or @code{IOR}, which is the op on the two compares.\",\n+ \"This function prepares to emit a conditional comparison within a sequence\\n\\\n+ of conditional comparisons.  It returns an appropriate comparison with\\n\\\n+ @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\\n\\\n+ The insns to prepare the compare are saved in @var{prep_seq} and the compare\\n\\\n+ insns are saved in @var{gen_seq}.  They will be emitted when all the\\n\\\n+ compares in the conditional comparision are generated without error.  The\\n\\\n+ @var{prev} expression is the result of a prior call to @code{gen_ccmp_first}\\n\\\n+ or @code{gen_ccmp_next}.  It may return @code{NULL} if the combination of\\n\\\n+ @var{prev} and this comparison is not supported, otherwise the result must\\n\\\n+ be appropriate for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\\n\\\n+ @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\\n\\\n+ @var{bit_code} is @code{AND} or @code{IOR}, which is the op on the compares.\",\n  rtx, (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code, tree op0, tree op1, int bit_code),\n  NULL)\n "}]}