{"sha": "5932a4d411f30d1a07789f28528a2c57fb8e33e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkzMmE0ZDQxMWYzMGQxYTA3Nzg5ZjI4NTI4YTJjNTdmYjhlMzNlNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-18T09:57:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-18T09:57:53Z"}, "message": "lto-symtab.c (lto_cgraph_replace_node): Update.\n\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Update.\n\t* cgraphbuild.c (record_reference, record_type_list,\n\trecord_eh_tables, mark_address, mark_load, mark_store): Update.\n\t* cgraph.c (cgraph_same_body_alias, dump_cgraph_node,\n\tcgraph_create_virtual_clone, cgraph_for_node_thunks_and_aliases):\n\tUpdate.\n\t* cgraph.h (symtab_node_def, symtab_node, const_symtab_node): Remove.\n\t(cgraph_alias_aliased_node, varpool_alias_aliased_node): Update.\n\t* reload.c: Fix typo in comment.\n\t* rtlanal.c: Likewise.\n\t* tree-emultls.c (gen_emutls_addr): Update.\n\t* ipa-reference.c (analyze_function): Update.\n\t* cgraphunit.c (cgraph_analyze_function,\n\tcgraph_process_same_body_aliases, assemble_thunks_and_aliases):\n\tUpdate.\n\t* ipa-ref.c (ipa_record_reference): Reorg to avoid reference types.\n\t(ipa_remove_reference): Likewise.\n\t(ipa_remove_all_refering): Rename to ...\n\t(ipa_remove_all_referring): ... this one; update.\n\t(ipa_dump_references): Update.\n\t(ipa_dump_referring): Update.\n\t(ipa_clone_references): Update.\n\t(ipa_clone_refering): Rename to ...\n\t(ipa_clone_referring): ... this one; update.\n\t(ipa_ref_cannot_lead_to_return): Update.\n\t(ipa_ref_has_aliases_p): Update.\n\t* ipa-ref.h (symtab_node_def, symtab_node, const_symtab_node): New\n\tforward typedefs.\n\t(ipa_ref_type): Remove.\n\t(ipa_ref_ptr_u): Remove.\n\t(ipa_ref): Remove referencing, refered, refered_index, refering_type\n\tand refered_type; add referring, referred and referred_index.\n\t(ipa_ref_list): Rename refering to referring.\n\t(ipa_record_reference, ipa_remove_all_referring, ipa_dump_referring,\n\tipa_clone_references, ipa_clone_referring): Update prototypes.\n\t* lto-cgraph.c (referenced_from_other_partition_p): Update.\n\t(lto_output_ref): Update.\n\t(add_references): Update.\n\t(input_varpool_node): Update.\n\t(input_refs): Update.\n\t* ipa-ref-inline.h (ipa_ref_node): Update.\n\t(ipa_ref_varpool_node): Update.\n\t(ipa_ref_referring_node); Update.\n\t(ipa_ref_referring_varpool_node): Update.\n\t(ipa_ref_referring_ref_list); Update.\n\t(ipa_ref_referred_ref_list): Update.\n\t(ipa_ref_list_first_referring): Update.\n\t(ipa_empty_ref_list): Update.\n\t(ipa_ref_list_refering_iterate): Rename to ...\n\t(ipa_ref_list_referring_iterate): ... this one.\n\t* cse.c: Update comment.\n\t* ipa-utils.c (ipa_reverse_postorder): Update.\n\t* tree-ssa-alias.c: Update.\n\t* ipa-inline.c (reset_edge_caches): Update.\n\t(update_caller_keys): Update.\n\t* ipa-inline.h: Update comments.\n\t* jump.c: Update comment.\n\t* alias.c: Likewise.\n\t* ipa.c (process_references): Update.\n\t(cgraph_remove_unreachable_nodes): Likewise.\n\t(ipa_discover_readonly_nonaddressable_var): Likewise.\n\t(cgraph_address_taken_from_non_vtable_p): Likewise.\n\t* trans-mem.c (ipa_tm_execute): Update.\n\t* simplify-rtx.c: Fix comment.\n\t* rtl.c: Fix comment.\n\t* symtab.c (symtab_unregister_node): Update.\n\t* varpool.c (dump_varpool_node): Update.\n\t(varpool_analyze_pending_decls): Update.\n\t(assemble_aliases): Update.\n\t(varpool_for_node_and_aliases): Update.\n\nFrom-SVN: r186564", "tree": {"sha": "557443c354065839ba2b0035e3d525377e5293fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/557443c354065839ba2b0035e3d525377e5293fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5932a4d411f30d1a07789f28528a2c57fb8e33e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5932a4d411f30d1a07789f28528a2c57fb8e33e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5932a4d411f30d1a07789f28528a2c57fb8e33e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5932a4d411f30d1a07789f28528a2c57fb8e33e4/comments", "author": null, "committer": null, "parents": [{"sha": "f31486202790ebadffdb6f445a71f383ea5a1438", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31486202790ebadffdb6f445a71f383ea5a1438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31486202790ebadffdb6f445a71f383ea5a1438"}], "stats": {"total": 596, "additions": 301, "deletions": 295}, "files": [{"sha": "45c2641f317b05e673f55d9b2b67efade825c2f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -1,3 +1,76 @@\n+2012-04-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Update.\n+\t* cgraphbuild.c (record_reference, record_type_list,\n+\trecord_eh_tables, mark_address, mark_load, mark_store): Update.\n+\t* cgraph.c (cgraph_same_body_alias, dump_cgraph_node,\n+\tcgraph_create_virtual_clone, cgraph_for_node_thunks_and_aliases):\n+\tUpdate.\n+\t* cgraph.h (symtab_node_def, symtab_node, const_symtab_node): Remove.\n+\t(cgraph_alias_aliased_node, varpool_alias_aliased_node): Update.\n+\t* reload.c: Fix typo in comment.\n+\t* rtlanal.c: Likewise.\n+\t* tree-emultls.c (gen_emutls_addr): Update.\n+\t* ipa-reference.c (analyze_function): Update.\n+\t* cgraphunit.c (cgraph_analyze_function,\n+\tcgraph_process_same_body_aliases, assemble_thunks_and_aliases):\n+\tUpdate.\n+\t* ipa-ref.c (ipa_record_reference): Reorg to avoid reference types.\n+\t(ipa_remove_reference): Likewise.\n+\t(ipa_remove_all_refering): Rename to ...\n+\t(ipa_remove_all_referring): ... this one; update.\n+\t(ipa_dump_references): Update.\n+\t(ipa_dump_referring): Update.\n+\t(ipa_clone_references): Update.\n+\t(ipa_clone_refering): Rename to ...\n+\t(ipa_clone_referring): ... this one; update.\n+\t(ipa_ref_cannot_lead_to_return): Update.\n+\t(ipa_ref_has_aliases_p): Update.\n+\t* ipa-ref.h (symtab_node_def, symtab_node, const_symtab_node): New\n+\tforward typedefs.\n+\t(ipa_ref_type): Remove.\n+\t(ipa_ref_ptr_u): Remove.\n+\t(ipa_ref): Remove referencing, refered, refered_index, refering_type\n+\tand refered_type; add referring, referred and referred_index.\n+\t(ipa_ref_list): Rename refering to referring.\n+\t(ipa_record_reference, ipa_remove_all_referring, ipa_dump_referring,\n+\tipa_clone_references, ipa_clone_referring): Update prototypes.\n+\t* lto-cgraph.c (referenced_from_other_partition_p): Update.\n+\t(lto_output_ref): Update.\n+\t(add_references): Update.\n+\t(input_varpool_node): Update.\n+\t(input_refs): Update.\n+\t* ipa-ref-inline.h (ipa_ref_node): Update.\n+\t(ipa_ref_varpool_node): Update.\n+\t(ipa_ref_referring_node); Update.\n+\t(ipa_ref_referring_varpool_node): Update.\n+\t(ipa_ref_referring_ref_list); Update.\n+\t(ipa_ref_referred_ref_list): Update.\n+\t(ipa_ref_list_first_referring): Update.\n+\t(ipa_empty_ref_list): Update.\n+\t(ipa_ref_list_refering_iterate): Rename to ...\n+\t(ipa_ref_list_referring_iterate): ... this one.\n+\t* cse.c: Update comment.\n+\t* ipa-utils.c (ipa_reverse_postorder): Update.\n+\t* tree-ssa-alias.c: Update.\n+\t* ipa-inline.c (reset_edge_caches): Update.\n+\t(update_caller_keys): Update.\n+\t* ipa-inline.h: Update comments.\n+\t* jump.c: Update comment.\n+\t* alias.c: Likewise.\n+\t* ipa.c (process_references): Update.\n+\t(cgraph_remove_unreachable_nodes): Likewise.\n+\t(ipa_discover_readonly_nonaddressable_var): Likewise.\n+\t(cgraph_address_taken_from_non_vtable_p): Likewise.\n+\t* trans-mem.c (ipa_tm_execute): Update.\n+\t* simplify-rtx.c: Fix comment.\n+\t* rtl.c: Fix comment.\n+\t* symtab.c (symtab_unregister_node): Update.\n+\t* varpool.c (dump_varpool_node): Update.\n+\t(varpool_analyze_pending_decls): Update.\n+\t(assemble_aliases): Update.\n+\t(varpool_for_node_and_aliases): Update.\n+\n 2012-04-18  Richard Guenther  <rguenther@suse.de>\n \n \t* cfgloop.h (estimate_numbers_of_iterations_loop): Remove"}, {"sha": "09befd7eced8b6edb462dc36052ea19ab05c5e0b", "filename": "gcc/alias.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -1178,7 +1178,7 @@ find_base_value (rtx src)\n       return 0;\n \n     case TRUNCATE:\n-      /* As we do not know which address space the pointer is refering to, we can\n+      /* As we do not know which address space the pointer is referring to, we can\n \t handle this only if the target does not support different pointer or\n \t address modes depending on the address space.  */\n       if (!target_default_pointer_address_modes_p ())\n@@ -1197,7 +1197,7 @@ find_base_value (rtx src)\n \n     case ZERO_EXTEND:\n     case SIGN_EXTEND:\t/* used for NT/Alpha pointers */\n-      /* As we do not know which address space the pointer is refering to, we can\n+      /* As we do not know which address space the pointer is referring to, we can\n \t handle this only if the target does not support different pointer or\n \t address modes depending on the address space.  */\n       if (!target_default_pointer_address_modes_p ())\n@@ -1602,7 +1602,7 @@ find_base_term (rtx x)\n       return REG_BASE_VALUE (x);\n \n     case TRUNCATE:\n-      /* As we do not know which address space the pointer is refering to, we can\n+      /* As we do not know which address space the pointer is referring to, we can\n \t handle this only if the target does not support different pointer or\n \t address modes depending on the address space.  */\n       if (!target_default_pointer_address_modes_p ())\n@@ -1621,7 +1621,7 @@ find_base_term (rtx x)\n \n     case ZERO_EXTEND:\n     case SIGN_EXTEND:\t/* Used for Alpha/NT pointers */\n-      /* As we do not know which address space the pointer is refering to, we can\n+      /* As we do not know which address space the pointer is referring to, we can\n \t handle this only if the target does not support different pointer or\n \t address modes depending on the address space.  */\n       if (!target_default_pointer_address_modes_p ())\n@@ -2363,7 +2363,7 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n       && ! rtx_equal_p (rtlx, rtly))\n     return 1;\n \n-  /* If we have MEMs refering to different address spaces (which can\n+  /* If we have MEMs referring to different address spaces (which can\n      potentially overlap), we cannot easily tell from the addresses\n      whether the references overlap.  */\n   if (MEM_P (rtlx) && MEM_P (rtly)\n@@ -2471,7 +2471,7 @@ true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (MEM_READONLY_P (x))\n     return 0;\n \n-  /* If we have MEMs refering to different address spaces (which can\n+  /* If we have MEMs referring to different address spaces (which can\n      potentially overlap), we cannot easily tell from the addresses\n      whether the references overlap.  */\n   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n@@ -2589,7 +2589,7 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n   if (!writep && MEM_READONLY_P (mem))\n     return 0;\n \n-  /* If we have MEMs refering to different address spaces (which can\n+  /* If we have MEMs referring to different address spaces (which can\n      potentially overlap), we cannot easily tell from the addresses\n      whether the references overlap.  */\n   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n@@ -2676,7 +2676,7 @@ may_alias_p (const_rtx mem, const_rtx x)\n   if (MEM_READONLY_P (x))\n     return 0;\n \n-  /* If we have MEMs refering to different address spaces (which can\n+  /* If we have MEMs referring to different address spaces (which can\n      potentially overlap), we cannot easily tell from the addresses\n      whether the references overlap.  */\n   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))"}, {"sha": "8ba9c36258360918d57aa5bd99336145d6c9c54f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -528,8 +528,8 @@ cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree ali\n   n = cgraph_create_function_alias (alias, decl);\n   n->same_body_alias = true;\n   if (same_body_aliases_done)\n-    ipa_record_reference (n, NULL, cgraph_get_node (decl), NULL, IPA_REF_ALIAS,\n-\t\t\t  NULL);\n+    ipa_record_reference ((symtab_node)n, (symtab_node)cgraph_get_node (decl),\n+\t\t\t  IPA_REF_ALIAS, NULL);\n   return n;\n }\n \n@@ -1927,7 +1927,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   for (e = n->indirect_calls; e; e = e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, update_original);\n-  ipa_clone_references (new_node, NULL, &n->symbol.ref_list);\n+  ipa_clone_references ((symtab_node)new_node, &n->symbol.ref_list);\n \n   new_node->next_sibling_clone = n->clones;\n   if (n->clones)\n@@ -2023,26 +2023,24 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   FOR_EACH_VEC_ELT (ipa_replace_map_p, tree_map, i, map)\n     {\n       tree var = map->new_tree;\n+      symtab_node ref_node;\n \n       STRIP_NOPS (var);\n       if (TREE_CODE (var) != ADDR_EXPR)\n \tcontinue;\n       var = get_base_var (var);\n       if (!var)\n \tcontinue;\n+      if (TREE_CODE (var) != FUNCTION_DECL\n+\t  && TREE_CODE (var) != VAR_DECL)\n+\tcontinue;\n \n       /* Record references of the future statement initializing the constant\n \t argument.  */\n-      if (TREE_CODE (var) == FUNCTION_DECL)\n-\t{\n-\t  struct cgraph_node *ref_node = cgraph_get_node (var);\n-\t  gcc_checking_assert (ref_node);\n-\t  ipa_record_reference (new_node, NULL, ref_node, NULL, IPA_REF_ADDR,\n-\t\t\t\tNULL);\n-\t}\n-      else if (TREE_CODE (var) == VAR_DECL)\n-\tipa_record_reference (new_node, NULL, NULL, varpool_node (var),\n-\t\t\t      IPA_REF_ADDR, NULL);\n+      ref_node = symtab_get_node (var);\n+      gcc_checking_assert (ref_node);\n+      ipa_record_reference ((symtab_node)new_node, (symtab_node)ref_node,\n+\t\t\t    IPA_REF_ADDR, NULL);\n     }\n   if (!args_to_skip)\n     new_node->clone.combined_args_to_skip = old_node->clone.combined_args_to_skip;\n@@ -2249,10 +2247,10 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n       if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n \t\t\t\t\t      include_overwritable))\n \treturn true;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n \tif (include_overwritable\n \t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n \t  if (cgraph_for_node_thunks_and_aliases (alias, callback, data,\n@@ -2277,10 +2275,10 @@ cgraph_for_node_and_aliases (struct cgraph_node *node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n \tif (include_overwritable\n \t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n           if (cgraph_for_node_and_aliases (alias, callback, data,"}, {"sha": "a8132ce85a01aacb93d3711977abbdc9c7ceed02", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -38,10 +38,6 @@ enum symtab_type\n   SYMTAB_VARIABLE\n };\n \n-union symtab_node_def;\n-typedef union symtab_node_def *symtab_node;\n-typedef const union symtab_node_def *const_symtab_node;\n-\n /* Base of all entries in the symbol table.\n    The symtab_node is inherited by cgraph and varpol nodes.  */\n struct GTY(()) symtab_node_base\n@@ -1166,7 +1162,7 @@ cgraph_alias_aliased_node (struct cgraph_node *n)\n \n   ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n-  if (ref->refered_type == IPA_REF_CGRAPH)\n+  if (symtab_function_p (ref->referred))\n     return ipa_ref_node (ref);\n   return NULL;\n }\n@@ -1180,7 +1176,7 @@ varpool_alias_aliased_node (struct varpool_node *n)\n \n   ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n-  if (ref->refered_type == IPA_REF_VARPOOL)\n+  if (symtab_variable_p (ref->referred))\n     return ipa_ref_varpool_node (ref);\n   return NULL;\n }"}, {"sha": "37059a223c9053997d1152045a99661e57f8938c", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -77,7 +77,8 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  struct cgraph_node *node = cgraph_get_create_node (decl);\n \t  if (!ctx->only_vars)\n \t    cgraph_mark_address_taken_node (node);\n-\t  ipa_record_reference (NULL, ctx->varpool_node, node, NULL,\n+\t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n+\t\t\t\t(symtab_node)node,\n \t\t\t        IPA_REF_ADDR, NULL);\n \t}\n \n@@ -87,8 +88,8 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  if (lang_hooks.callgraph.analyze_expr)\n \t    lang_hooks.callgraph.analyze_expr (&decl, walk_subtrees);\n \t  varpool_mark_needed_node (vnode);\n-\t  ipa_record_reference (NULL, ctx->varpool_node,\n-\t\t\t\tNULL, vnode,\n+\t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n+\t\t\t\t(symtab_node)vnode,\n \t\t\t\tIPA_REF_ADDR, NULL);\n \t}\n       *walk_subtrees = 0;\n@@ -130,8 +131,8 @@ record_type_list (struct cgraph_node *node, tree list)\n \t    {\n \t      struct varpool_node *vnode = varpool_node (type);\n \t      varpool_mark_needed_node (vnode);\n-\t      ipa_record_reference (node, NULL,\n-\t\t\t\t    NULL, vnode,\n+\t      ipa_record_reference ((symtab_node)node,\n+\t\t\t\t    (symtab_node)vnode,\n \t\t\t\t    IPA_REF_ADDR, NULL);\n \t    }\n \t}\n@@ -151,7 +152,7 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n       struct cgraph_node *per_node;\n \n       per_node = cgraph_get_create_node (DECL_FUNCTION_PERSONALITY (node->symbol.decl));\n-      ipa_record_reference (node, NULL, per_node, NULL, IPA_REF_ADDR, NULL);\n+      ipa_record_reference ((symtab_node)node, (symtab_node)per_node, IPA_REF_ADDR, NULL);\n       cgraph_mark_address_taken_node (per_node);\n     }\n \n@@ -232,8 +233,8 @@ mark_address (gimple stmt, tree addr, void *data)\n     {\n       struct cgraph_node *node = cgraph_get_create_node (addr);\n       cgraph_mark_address_taken_node (node);\n-      ipa_record_reference ((struct cgraph_node *)data, NULL,\n-\t\t\t    node, NULL,\n+      ipa_record_reference ((symtab_node)data,\n+\t\t\t    (symtab_node)node,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n@@ -245,8 +246,8 @@ mark_address (gimple stmt, tree addr, void *data)\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&addr, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n-      ipa_record_reference ((struct cgraph_node *)data, NULL,\n-\t\t\t    NULL, vnode,\n+      ipa_record_reference ((symtab_node)data,\n+\t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n \n@@ -265,8 +266,8 @@ mark_load (gimple stmt, tree t, void *data)\n \t directly manipulated in the code.  Pretend that it's an address.  */\n       struct cgraph_node *node = cgraph_get_create_node (t);\n       cgraph_mark_address_taken_node (node);\n-      ipa_record_reference ((struct cgraph_node *)data, NULL,\n-\t\t\t    node, NULL,\n+      ipa_record_reference ((symtab_node)data,\n+\t\t\t    (symtab_node)node,\n \t\t\t    IPA_REF_ADDR, stmt);\n     }\n   else if (t && TREE_CODE (t) == VAR_DECL\n@@ -278,8 +279,8 @@ mark_load (gimple stmt, tree t, void *data)\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n-      ipa_record_reference ((struct cgraph_node *)data, NULL,\n-\t\t\t    NULL, vnode,\n+      ipa_record_reference ((symtab_node)data,\n+\t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_LOAD, stmt);\n     }\n   return false;\n@@ -300,8 +301,8 @@ mark_store (gimple stmt, tree t, void *data)\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n-      ipa_record_reference ((struct cgraph_node *)data, NULL,\n-\t\t\t    NULL, vnode,\n+      ipa_record_reference ((symtab_node)data,\n+\t\t\t    (symtab_node)vnode,\n \t\t\t    IPA_REF_STORE, stmt);\n      }\n   return false;\n@@ -348,19 +349,22 @@ build_cgraph_edges (void)\n \t      && gimple_omp_parallel_child_fn (stmt))\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n-\t      ipa_record_reference (node, NULL, cgraph_get_create_node (fn),\n-\t\t\t\t    NULL, IPA_REF_ADDR, stmt);\n+\t      ipa_record_reference ((symtab_node)node,\n+\t\t\t\t    (symtab_node)cgraph_get_create_node (fn),\n+\t\t\t\t    IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference (node, NULL, cgraph_get_create_node (fn),\n-\t\t\t\t      NULL, IPA_REF_ADDR, stmt);\n+\t\tipa_record_reference ((symtab_node)node,\n+\t\t\t\t      (symtab_node) cgraph_get_create_node (fn),\n+\t\t\t\t      IPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference (node, NULL, cgraph_get_create_node (fn),\n-\t\t\t\t      NULL, IPA_REF_ADDR, stmt);\n+\t\tipa_record_reference ((symtab_node)node,\n+\t\t\t\t      (symtab_node)cgraph_get_create_node (fn),\n+\t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t}\n       for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))"}, {"sha": "7d585e6e5f956ca8f0acd54437e4f321028828af", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -930,7 +930,8 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t    return;\n \t  }\n       if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n-        ipa_record_reference (node, NULL, tgt, NULL, IPA_REF_ALIAS, NULL);\n+        ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n+\t\t\t      IPA_REF_ALIAS, NULL);\n       if (node->same_body_alias)\n \t{ \n \t  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (node->thunk.alias);\n@@ -1031,7 +1032,8 @@ cgraph_process_same_body_aliases (void)\n \t&& !VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n       {\n         struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n-        ipa_record_reference (node, NULL, tgt, NULL, IPA_REF_ALIAS, NULL);\n+        ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n+\t\t\t      IPA_REF_ALIAS, NULL);\n       }\n   same_body_aliases_done = true;\n }\n@@ -1848,11 +1850,11 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n       }\n     else\n       e = e->next_caller;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n \t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n         bool saved_written = TREE_ASM_WRITTEN (alias->thunk.alias);\n \n \t/* Force assemble_alias to really output the alias this time instead"}, {"sha": "b7db827cf30f07b743d05d6bf2d57cb0af44e84f", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -2622,7 +2622,7 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  /* MEMs refering to different address space are not equivalent.  */\n+  /* MEMs referring to different address space are not equivalent.  */\n   if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n     return 0;\n "}, {"sha": "451bd6176034fa692ea8584b9ce81ac95337bc84", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -957,10 +957,10 @@ reset_edge_caches (struct cgraph_node *node)\n   for (edge = where->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       reset_edge_growth_cache (edge);\n-  for (i = 0; ipa_ref_list_refering_iterate (&where->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&where->symbol.ref_list,\n \t\t\t\t\t      i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n-      reset_edge_caches (ipa_ref_refering_node (ref));\n+      reset_edge_caches (ipa_ref_referring_node (ref));\n \n   if (!e)\n     return;\n@@ -1009,11 +1009,11 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n \n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n \t\t\t\t\t      i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n+\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n         update_caller_keys (heap, alias, updated_nodes, check_inlinablity_for);\n       }\n "}, {"sha": "824a6c5035069af93649be0a2e6d92b4142c1704", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    Conditions that are interesting for function body are collected into CONDS\n    vector.  They are of simple for  function_param OP VAL, where VAL is\n-   IPA invariant.  The conditions are then refered by predicates.  */\n+   IPA invariant.  The conditions are then referred by predicates.  */\n \n typedef struct GTY(()) condition\n   {"}, {"sha": "636af145789384364258c7b3e7b6ea320cbb432c", "filename": "gcc/ipa-ref-inline.h", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -19,61 +19,51 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Return callgraph node REF is refering.  */\n+/* Return callgraph node REF is referring.  */\n static inline struct cgraph_node *\n ipa_ref_node (struct ipa_ref *ref)\n {\n-  gcc_assert (ref->refered_type == IPA_REF_CGRAPH);\n-  return ref->refered.cgraph_node;\n+  return cgraph (ref->referred);\n }\n \n-/* Return varpool node REF is refering.  */\n+/* Return varpool node REF is referring.  */\n \n static inline struct varpool_node *\n ipa_ref_varpool_node (struct ipa_ref *ref)\n {\n-  gcc_assert (ref->refered_type == IPA_REF_VARPOOL);\n-  return ref->refered.varpool_node;\n+  return varpool (ref->referred);\n }\n \n /* Return cgraph node REF is in.  */\n \n static inline struct cgraph_node *\n-ipa_ref_refering_node (struct ipa_ref *ref)\n+ipa_ref_referring_node (struct ipa_ref *ref)\n {\n-  gcc_assert (ref->refering_type == IPA_REF_CGRAPH);\n-  return ref->refering.cgraph_node;\n+  return cgraph (ref->referring);\n }\n \n /* Return varpool node REF is in.  */\n \n static inline struct varpool_node *\n-ipa_ref_refering_varpool_node (struct ipa_ref *ref)\n+ipa_ref_referring_varpool_node (struct ipa_ref *ref)\n {\n-  gcc_assert (ref->refering_type == IPA_REF_VARPOOL);\n-  return ref->refering.varpool_node;\n+  return varpool (ref->referring);\n }\n \n /* Return reference list REF is in.  */\n \n static inline struct ipa_ref_list *\n-ipa_ref_refering_ref_list (struct ipa_ref *ref)\n+ipa_ref_referring_ref_list (struct ipa_ref *ref)\n {\n-  if (ref->refering_type == IPA_REF_CGRAPH)\n-    return &ipa_ref_refering_node (ref)->symbol.ref_list;\n-  else\n-    return &ipa_ref_refering_varpool_node (ref)->symbol.ref_list;\n+  return &ref->referring->symbol.ref_list;\n }\n \n /* Return reference list REF is in.  */\n \n static inline struct ipa_ref_list *\n-ipa_ref_refered_ref_list (struct ipa_ref *ref)\n+ipa_ref_referred_ref_list (struct ipa_ref *ref)\n {\n-  if (ref->refered_type == IPA_REF_CGRAPH)\n-    return &ipa_ref_node (ref)->symbol.ref_list;\n-  else\n-    return &ipa_ref_varpool_node (ref)->symbol.ref_list;\n+  return &ref->referred->symbol.ref_list;\n }\n \n /* Return first reference in LIST or NULL if empty.  */\n@@ -86,22 +76,22 @@ ipa_ref_list_first_reference (struct ipa_ref_list *list)\n   return VEC_index (ipa_ref_t, list->references, 0);\n }\n \n-/* Return first refering ref in LIST or NULL if empty.  */\n+/* Return first referring ref in LIST or NULL if empty.  */\n \n static inline struct ipa_ref *\n-ipa_ref_list_first_refering (struct ipa_ref_list *list)\n+ipa_ref_list_first_referring (struct ipa_ref_list *list)\n {\n-  if (!VEC_length (ipa_ref_ptr, list->refering))\n+  if (!VEC_length (ipa_ref_ptr, list->referring))\n     return NULL;\n-  return VEC_index (ipa_ref_ptr, list->refering, 0);\n+  return VEC_index (ipa_ref_ptr, list->referring, 0);\n }\n \n /* Clear reference list.  */\n \n static inline void\n ipa_empty_ref_list (struct ipa_ref_list *list)\n {\n-  list->refering = NULL;\n+  list->referring = NULL;\n   list->references = NULL;\n }\n \n@@ -115,5 +105,5 @@ ipa_ref_list_nreferences (struct ipa_ref_list *list)\n \n #define ipa_ref_list_reference_iterate(L,I,P) \\\n    VEC_iterate(ipa_ref_t, (L)->references, (I), (P))\n-#define ipa_ref_list_refering_iterate(L,I,P) \\\n-   VEC_iterate(ipa_ref_ptr, (L)->refering, (I), (P))\n+#define ipa_ref_list_referring_iterate(L,I,P) \\\n+   VEC_iterate(ipa_ref_ptr, (L)->referring, (I), (P))"}, {"sha": "7926eb6a7d60a221191f0a9726df63300add93e1", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 53, "deletions": 99, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -1,5 +1,5 @@\n /* Interprocedural reference lists.\n-   Copyright (C) 2010\n+   Copyright (C) 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n@@ -34,54 +34,28 @@ static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\"};\n    of the use and STMT the statement (if it exists).  */\n \n struct ipa_ref *\n-ipa_record_reference (struct cgraph_node *refering_node,\n-\t\t      struct varpool_node *refering_varpool_node,\n-\t\t      struct cgraph_node *refered_node,\n-\t\t      struct varpool_node *refered_varpool_node,\n+ipa_record_reference (symtab_node referring_node,\n+\t\t      symtab_node referred_node,\n \t\t      enum ipa_ref_use use_type, gimple stmt)\n {\n   struct ipa_ref *ref;\n   struct ipa_ref_list *list, *list2;\n   VEC(ipa_ref_t,gc) *old_references;\n-  gcc_assert ((!refering_node) ^ (!refering_varpool_node));\n-  gcc_assert ((!refered_node) ^ (!refered_varpool_node));\n-  gcc_assert (!stmt || refering_node);\n-  gcc_assert (use_type != IPA_REF_ALIAS || !stmt);\n \n-  list = (refering_node ? &refering_node->symbol.ref_list\n-\t  : &refering_varpool_node->symbol.ref_list);\n+  gcc_checking_assert (!stmt || symtab_function_p (referring_node));\n+  gcc_checking_assert (use_type != IPA_REF_ALIAS || !stmt);\n+\n+  list = &referring_node->symbol.ref_list;\n   old_references = list->references;\n   VEC_safe_grow (ipa_ref_t, gc, list->references,\n \t\t VEC_length (ipa_ref_t, list->references) + 1);\n   ref = VEC_last (ipa_ref_t, list->references);\n \n-  list2 = (refered_node ? &refered_node->symbol.ref_list\n-\t   : &refered_varpool_node->symbol.ref_list);\n-  VEC_safe_push (ipa_ref_ptr, heap, list2->refering, ref);\n-  ref->refered_index = VEC_length (ipa_ref_ptr, list2->refering) - 1;\n-  if (refering_node)\n-    {\n-      ref->refering.cgraph_node = refering_node;\n-      ref->refering_type = IPA_REF_CGRAPH;\n-    }\n-  else\n-    {\n-      ref->refering.varpool_node = refering_varpool_node;\n-      ref->refering_type = IPA_REF_VARPOOL;\n-      gcc_assert (use_type == IPA_REF_ADDR || use_type == IPA_REF_ALIAS);\n-    }\n-  if (refered_node)\n-    {\n-      ref->refered.cgraph_node = refered_node;\n-      ref->refered_type = IPA_REF_CGRAPH;\n-      gcc_assert (use_type == IPA_REF_ADDR || use_type == IPA_REF_ALIAS);\n-    }\n-  else\n-    {\n-      varpool_mark_needed_node (refered_varpool_node);\n-      ref->refered.varpool_node = refered_varpool_node;\n-      ref->refered_type = IPA_REF_VARPOOL;\n-    }\n+  list2 = &referred_node->symbol.ref_list;\n+  VEC_safe_push (ipa_ref_ptr, heap, list2->referring, ref);\n+  ref->referred_index = VEC_length (ipa_ref_ptr, list2->referring) - 1;\n+  ref->referring = referring_node;\n+  ref->referred = referred_node;\n   ref->stmt = stmt;\n   ref->use = use_type;\n \n@@ -91,8 +65,8 @@ ipa_record_reference (struct cgraph_node *refering_node,\n       int i;\n       for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n \tVEC_replace (ipa_ref_ptr,\n-\t\t     ipa_ref_refered_ref_list (ref)->refering,\n-\t\t     ref->refered_index, ref);\n+\t\t     ipa_ref_referred_ref_list (ref)->referring,\n+\t\t     ref->referred_index, ref);\n     }\n   return ref;\n }\n@@ -102,30 +76,30 @@ ipa_record_reference (struct cgraph_node *refering_node,\n void\n ipa_remove_reference (struct ipa_ref *ref)\n {\n-  struct ipa_ref_list *list = ipa_ref_refered_ref_list (ref);\n-  struct ipa_ref_list *list2 = ipa_ref_refering_ref_list (ref);\n+  struct ipa_ref_list *list = ipa_ref_referred_ref_list (ref);\n+  struct ipa_ref_list *list2 = ipa_ref_referring_ref_list (ref);\n   VEC(ipa_ref_t,gc) *old_references = list2->references;\n   struct ipa_ref *last;\n \n-  gcc_assert (VEC_index (ipa_ref_ptr, list->refering, ref->refered_index) == ref);\n-  last = VEC_last (ipa_ref_ptr, list->refering);\n+  gcc_assert (VEC_index (ipa_ref_ptr, list->referring, ref->referred_index) == ref);\n+  last = VEC_last (ipa_ref_ptr, list->referring);\n   if (ref != last)\n     {\n-      VEC_replace (ipa_ref_ptr, list->refering,\n-\t\t   ref->refered_index,\n-\t\t   VEC_last (ipa_ref_ptr, list->refering));\n-      VEC_index (ipa_ref_ptr, list->refering,\n-\t\t ref->refered_index)->refered_index = ref->refered_index;\n+      VEC_replace (ipa_ref_ptr, list->referring,\n+\t\t   ref->referred_index,\n+\t\t   VEC_last (ipa_ref_ptr, list->referring));\n+      VEC_index (ipa_ref_ptr, list->referring,\n+\t\t ref->referred_index)->referred_index = ref->referred_index;\n     }\n-  VEC_pop (ipa_ref_ptr, list->refering);\n+  VEC_pop (ipa_ref_ptr, list->referring);\n \n   last = VEC_last (ipa_ref_t, list2->references);\n   if (ref != last)\n     {\n       *ref = *last;\n       VEC_replace (ipa_ref_ptr,\n-\t\t   ipa_ref_refered_ref_list (ref)->refering,\n-\t\t   ref->refered_index, ref);\n+\t\t   ipa_ref_referred_ref_list (ref)->referring,\n+\t\t   ref->referred_index, ref);\n     }\n   VEC_pop (ipa_ref_t, list2->references);\n   gcc_assert (list2->references == old_references);\n@@ -145,12 +119,12 @@ ipa_remove_all_references (struct ipa_ref_list *list)\n /* Remove all references in ref list LIST.  */\n \n void\n-ipa_remove_all_refering (struct ipa_ref_list *list)\n+ipa_remove_all_referring (struct ipa_ref_list *list)\n {\n-  while (VEC_length (ipa_ref_ptr, list->refering))\n-    ipa_remove_reference (VEC_last (ipa_ref_ptr, list->refering));\n-  VEC_free (ipa_ref_ptr, heap, list->refering);\n-  list->refering = NULL;\n+  while (VEC_length (ipa_ref_ptr, list->referring))\n+    ipa_remove_reference (VEC_last (ipa_ref_ptr, list->referring));\n+  VEC_free (ipa_ref_ptr, heap, list->referring);\n+  list->referring = NULL;\n }\n \n /* Dump references in LIST to FILE.  */\n@@ -162,85 +136,65 @@ ipa_dump_references (FILE * file, struct ipa_ref_list *list)\n   int i;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n     {\n-      if (ref->refered_type == IPA_REF_CGRAPH)\n-\t{\n-\t  fprintf (file, \" fn:%s/%i (%s)\", cgraph_node_asm_name (ipa_ref_node (ref)),\n-\t\t   ipa_ref_node (ref)->symbol.order,\n-\t\t   ipa_ref_use_name [ref->use]);\n-\t}\n-      else\n-\tfprintf (file, \" var:%s (%s)\",\n-\t\t varpool_node_asm_name (ipa_ref_varpool_node (ref)),\n-\t\t ipa_ref_use_name [ref->use]);\n+      fprintf (file, \"%s/%i (%s)\",\n+               symtab_node_asm_name (ref->referred),\n+               ref->referred->symbol.order,\n+\t       ipa_ref_use_name [ref->use]);\n     }\n   fprintf (file, \"\\n\");\n }\n \n-/* Dump refering in LIST to FILE.  */\n+/* Dump referring in LIST to FILE.  */\n \n void\n-ipa_dump_refering (FILE * file, struct ipa_ref_list *list)\n+ipa_dump_referring (FILE * file, struct ipa_ref_list *list)\n {\n   struct ipa_ref *ref;\n   int i;\n-  for (i = 0; ipa_ref_list_refering_iterate (list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n     {\n-      if (ref->refering_type == IPA_REF_CGRAPH)\n-\tfprintf (file, \" fn:%s/%i (%s)\",\n-\t\t cgraph_node_asm_name (ipa_ref_refering_node (ref)),\n-\t\t ipa_ref_refering_node (ref)->symbol.order,\n-\t\t ipa_ref_use_name [ref->use]);\n-      else\n-\tfprintf (file, \" var:%s (%s)\",\n-\t\t varpool_node_asm_name (ipa_ref_refering_varpool_node (ref)),\n-\t\t ipa_ref_use_name [ref->use]);\n+      fprintf (file, \"%s/%i (%s)\",\n+               symtab_node_asm_name (ref->referring),\n+               ref->referring->symbol.order,\n+\t       ipa_ref_use_name [ref->use]);\n     }\n   fprintf (file, \"\\n\");\n }\n \n /* Clone all references from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n \n void\n-ipa_clone_references (struct cgraph_node *dest_node,\n-\t\t      struct varpool_node *dest_varpool_node,\n+ipa_clone_references (symtab_node dest_node,\n \t\t      struct ipa_ref_list *src)\n {\n   struct ipa_ref *ref;\n   int i;\n   for (i = 0; ipa_ref_list_reference_iterate (src, i, ref); i++)\n-    ipa_record_reference (dest_node, dest_varpool_node,\n-\t\t\t  ref->refered_type == IPA_REF_CGRAPH\n-\t\t\t  ? ipa_ref_node (ref) : NULL,\n-\t\t\t  ref->refered_type == IPA_REF_VARPOOL\n-\t\t\t  ? ipa_ref_varpool_node (ref) : NULL,\n+    ipa_record_reference (dest_node,\n+\t\t\t  ref->referred,\n \t\t\t  ref->use, ref->stmt);\n }\n \n-/* Clone all refering from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n+/* Clone all referring from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n \n void\n-ipa_clone_refering (struct cgraph_node *dest_node,\n-\t\t    struct varpool_node *dest_varpool_node,\n+ipa_clone_referring (symtab_node dest_node,\n \t\t    struct ipa_ref_list *src)\n {\n   struct ipa_ref *ref;\n   int i;\n-  for (i = 0; ipa_ref_list_refering_iterate (src, i, ref); i++)\n-    ipa_record_reference (\n-\t\t\t  ref->refering_type == IPA_REF_CGRAPH\n-\t\t\t  ? ipa_ref_refering_node (ref) : NULL,\n-\t\t\t  ref->refering_type == IPA_REF_VARPOOL\n-\t\t\t  ? ipa_ref_refering_varpool_node (ref) : NULL,\n-\t\t\t  dest_node, dest_varpool_node,\n+  for (i = 0; ipa_ref_list_referring_iterate (src, i, ref); i++)\n+    ipa_record_reference (ref->referring,\n+\t\t\t  dest_node,\n \t\t\t  ref->use, ref->stmt);\n }\n \n-/* Return true when execution of REF can load to return from\n+/* Return true when execution of REF can lead to return from\n    function. */\n bool\n ipa_ref_cannot_lead_to_return (struct ipa_ref *ref)\n {\n-  return cgraph_node_cannot_return (ipa_ref_refering_node (ref));\n+  return cgraph_node_cannot_return (ipa_ref_referring_node (ref));\n }\n \n /* Return true if list contains an alias.  */\n@@ -249,7 +203,7 @@ ipa_ref_has_aliases_p (struct ipa_ref_list *ref_list)\n {\n   struct ipa_ref *ref;\n   int i;\n-  for (i = 0; ipa_ref_list_refering_iterate (ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       return true;\n   return false;"}, {"sha": "96750ba50f61d962b294be64b51dd792781272b9", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -21,6 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n \n struct cgraph_node;\n struct varpool_node;\n+union symtab_node_def;\n+typedef union symtab_node_def *symtab_node;\n+typedef const union symtab_node_def *const_symtab_node;\n+\n \n /* How the reference is done.  */\n enum GTY(()) ipa_ref_use\n@@ -31,30 +35,13 @@ enum GTY(()) ipa_ref_use\n   IPA_REF_ALIAS\n };\n \n-/* Type of refering or refered type.  */\n-enum GTY(()) ipa_ref_type\n-{\n-  IPA_REF_CGRAPH,\n-  IPA_REF_VARPOOL\n-};\n-\n-/* We can have references spanning both callgraph and varpool,\n-   so all pointers needs to be of both types.  */\n-union GTY(()) ipa_ref_ptr_u\n-{\n-  struct cgraph_node * GTY((tag (\"IPA_REF_CGRAPH\"))) cgraph_node;\n-  struct varpool_node * GTY((tag (\"IPA_REF_VARPOOL\"))) varpool_node;\n-};\n-\n /* Record of reference in callgraph or varpool.  */\n struct GTY(()) ipa_ref\n {\n-  union ipa_ref_ptr_u GTY ((desc (\"%1.refering_type\"))) refering;\n-  union ipa_ref_ptr_u GTY ((desc (\"%1.refered_type\"))) refered;\n+  symtab_node referring;\n+  symtab_node referred;\n   gimple stmt;\n-  unsigned int refered_index;\n-  ENUM_BITFIELD (ipa_ref_type) refering_type:1;\n-  ENUM_BITFIELD (ipa_ref_type) refered_type:1;\n+  unsigned int referred_index;\n   ENUM_BITFIELD (ipa_ref_use) use:2;\n };\n \n@@ -73,21 +60,19 @@ struct GTY(()) ipa_ref_list\n   VEC(ipa_ref_t,gc) *references;\n   /* Refering is vector of pointers to references.  It must not live in GGC space\n      or GGC will try to mark middle of references vectors.  */\n-  VEC(ipa_ref_ptr,heap) * GTY((skip)) refering;\n+  VEC(ipa_ref_ptr,heap) * GTY((skip)) referring;\n };\n \n-struct ipa_ref * ipa_record_reference (struct cgraph_node *,\n-\t\t\t\t       struct varpool_node *,\n-\t\t\t\t       struct cgraph_node *,\n-\t\t\t\t       struct varpool_node *,\n+struct ipa_ref * ipa_record_reference (symtab_node,\n+\t\t\t\t       symtab_node,\n \t\t\t\t       enum ipa_ref_use, gimple);\n \n void ipa_remove_reference (struct ipa_ref *);\n void ipa_remove_all_references (struct ipa_ref_list *);\n-void ipa_remove_all_refering (struct ipa_ref_list *);\n+void ipa_remove_all_referring (struct ipa_ref_list *);\n void ipa_dump_references (FILE *, struct ipa_ref_list *);\n-void ipa_dump_refering (FILE *, struct ipa_ref_list *);\n-void ipa_clone_references (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n-void ipa_clone_refering (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n+void ipa_dump_referring (FILE *, struct ipa_ref_list *);\n+void ipa_clone_references (symtab_node, struct ipa_ref_list *);\n+void ipa_clone_referring (symtab_node, struct ipa_ref_list *);\n bool ipa_ref_cannot_lead_to_return (struct ipa_ref *);\n bool ipa_ref_has_aliases_p (struct ipa_ref_list *);"}, {"sha": "41957345bb097028adc24ad377674c94f2ca135e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -435,7 +435,7 @@ analyze_function (struct cgraph_node *fn)\n   local = init_function_info (fn);\n   for (i = 0; ipa_ref_list_reference_iterate (&fn->symbol.ref_list, i, ref); i++)\n     {\n-      if (ref->refered_type != IPA_REF_VARPOOL)\n+      if (!symtab_variable_p (ref->referred))\n \tcontinue;\n       var = ipa_ref_varpool_node (ref)->symbol.decl;\n       if (ipa_ref_varpool_node (ref)->symbol.externally_visible"}, {"sha": "e22977a07076f47fd4e49693383649ed30c4da1c", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -295,13 +295,13 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t\t\t    (cgraph_function_node (edge->callee, NULL)->symbol.decl))\n \t\t\tnode2 = NULL;\n \t\t    }\n-\t\t  for (;ipa_ref_list_refering_iterate (&stack[stack_size].node->symbol.ref_list,\n+\t\t  for (;ipa_ref_list_referring_iterate (&stack[stack_size].node->symbol.ref_list,\n \t\t\t\t\t\t       stack[stack_size].ref,\n \t\t\t\t\t\t       ref) && !node2;\n \t\t       stack[stack_size].ref++)\n \t\t    {\n \t\t      if (ref->use == IPA_REF_ALIAS)\n-\t\t\tnode2 = ipa_ref_refering_node (ref);\n+\t\t\tnode2 = ipa_ref_referring_node (ref);\n \t\t    }\n \t\t  if (!node2)\n \t\t    break;"}, {"sha": "874156275a879abe620ec6e6b19ec6d799bb1d59", "filename": "gcc/ipa.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -91,7 +91,7 @@ process_references (struct ipa_ref_list *list,\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n     {\n-      if (ref->refered_type == IPA_REF_CGRAPH)\n+      if (symtab_function_p (ref->referred))\n \t{\n \t  struct cgraph_node *node = ipa_ref_node (ref);\n \t  if (!node->reachable\n@@ -154,7 +154,7 @@ has_addr_references_p (struct cgraph_node *node,\n   int i;\n   struct ipa_ref *ref;\n \n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n \t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       return true;\n@@ -352,14 +352,14 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  for (e = node->callers; e && !found; e = e->next_caller)\n \t    if (e->caller->reachable)\n \t      found = true;\n-\t  for (i = 0; (ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+\t  for (i = 0; (ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n \t\t\t\t\t\t      i, ref)\n \t\t       && !found); i++)\n-\t    if (ref->refering_type == IPA_REF_CGRAPH\n-\t\t&& ipa_ref_refering_node (ref)->reachable)\n+\t    if (symtab_function_p (ref->referring)\n+\t\t&& ipa_ref_referring_node (ref)->reachable)\n \t      found = true;\n-\t    else if (ref->refering_type == IPA_REF_VARPOOL\n-\t\t     && ipa_ref_refering_varpool_node (ref)->needed)\n+\t    else if (symtab_variable_p (ref->referring)\n+\t\t     && ipa_ref_referring_varpool_node (ref)->needed)\n \t      found = true;\n \n \t  /* If so, we need to keep node in the callgraph.  */\n@@ -501,7 +501,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \tbool address_taken = false;\n \tint i;\n         struct ipa_ref *ref;\n-        for (i = 0; ipa_ref_list_refering_iterate (&vnode->symbol.ref_list,\n+        for (i = 0; ipa_ref_list_referring_iterate (&vnode->symbol.ref_list,\n \t\t\t\t\t\t   i, ref)\n \t\t    && (!written || !address_taken); i++)\n \t  switch (ref->use)\n@@ -542,14 +542,14 @@ cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list,\n \t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       {\n \tstruct varpool_node *node;\n-\tif (ref->refering_type == IPA_REF_CGRAPH)\n+\tif (symtab_function_p (ref->referring))\n \t  return true;\n-\tnode = ipa_ref_refering_varpool_node (ref);\n+\tnode = ipa_ref_referring_varpool_node (ref);\n \tif (!DECL_VIRTUAL_P (node->symbol.decl))\n \t  return true;\n       }"}, {"sha": "4c4b00118f4ba790db98acce7af8d8e5a011c12c", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -1764,7 +1764,7 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  /* MEMs refering to different address space are not equivalent.  */\n+  /* MEMs referring to different address space are not equivalent.  */\n   if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n     return 0;\n "}, {"sha": "18152a8af06b8c820f13d87ca24b46a02e54b4c5", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -326,18 +326,18 @@ referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set se\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_refering_iterate (list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n     {\n-      if (ref->refering_type == IPA_REF_CGRAPH)\n+      if (symtab_function_p (ref->referring))\n \t{\n-\t  if (ipa_ref_refering_node (ref)->symbol.in_other_partition\n-\t      || !cgraph_node_in_set_p (ipa_ref_refering_node (ref), set))\n+\t  if (ipa_ref_referring_node (ref)->symbol.in_other_partition\n+\t      || !cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n \t    return true;\n \t}\n       else\n \t{\n-\t  if (ipa_ref_refering_varpool_node (ref)->symbol.in_other_partition\n-\t      || !varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t  if (ipa_ref_referring_varpool_node (ref)->symbol.in_other_partition\n+\t      || !varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n \t\t\t\t         vset))\n \t    return true;\n \t}\n@@ -370,16 +370,16 @@ referenced_from_this_partition_p (struct ipa_ref_list *list, cgraph_node_set set\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_refering_iterate (list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n     {\n-      if (ref->refering_type == IPA_REF_CGRAPH)\n+      if (symtab_function_p (ref->referring))\n \t{\n-\t  if (cgraph_node_in_set_p (ipa_ref_refering_node (ref), set))\n+\t  if (cgraph_node_in_set_p (ipa_ref_referring_node (ref), set))\n \t    return true;\n \t}\n       else\n \t{\n-\t  if (varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t  if (varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n \t\t\t\t     vset))\n \t    return true;\n \t}\n@@ -614,10 +614,10 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n {\n   struct bitpack_d bp;\n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, ref->refered_type, 1);\n+  bp_pack_value (&bp, symtab_function_p (ref->referred), 1);\n   bp_pack_value (&bp, ref->use, 2);\n   streamer_write_bitpack (&bp);\n-  if (ref->refered_type == IPA_REF_CGRAPH)\n+  if (symtab_function_p (ref->referred))\n     {\n       int nref = lto_cgraph_encoder_lookup (encoder, ipa_ref_node (ref));\n       gcc_assert (nref != LCC_NOT_FOUND);\n@@ -674,7 +674,7 @@ add_references (lto_cgraph_encoder_t encoder,\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n-    if (ref->refered_type == IPA_REF_CGRAPH)\n+    if (symtab_function_p (ref->referred))\n       add_node_to (encoder, ipa_ref_node (ref), false);\n     else\n       {\n@@ -1108,27 +1108,26 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n \n static void\n input_ref (struct lto_input_block *ib,\n-\t   struct cgraph_node *refering_node,\n-\t   struct varpool_node *refering_varpool_node,\n+\t   symtab_node referring_node,\n \t   VEC(cgraph_node_ptr, heap) *nodes,\n \t   VEC(varpool_node_ptr, heap) *varpool_nodes_vec)\n {\n   struct cgraph_node *node = NULL;\n   struct varpool_node *varpool_node = NULL;\n   struct bitpack_d bp;\n-  enum ipa_ref_type type;\n+  int type;\n   enum ipa_ref_use use;\n \n   bp = streamer_read_bitpack (ib);\n-  type = (enum ipa_ref_type) bp_unpack_value (&bp, 1);\n+  type = bp_unpack_value (&bp, 1);\n   use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n-  if (type == IPA_REF_CGRAPH)\n+  if (type)\n     node = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n   else\n     varpool_node = VEC_index (varpool_node_ptr, varpool_nodes_vec,\n \t\t\t      streamer_read_hwi (ib));\n-  ipa_record_reference (refering_node, refering_varpool_node,\n-\t\t        node, varpool_node, use, NULL);\n+  ipa_record_reference (referring_node,\n+\t\t        node ? (symtab_node) node : (symtab_node) varpool_node, use, NULL);\n }\n \n /* Read an edge from IB.  NODES points to a vector of previously read nodes for\n@@ -1324,7 +1323,7 @@ input_refs (struct lto_input_block *ib,\n       node = VEC_index (cgraph_node_ptr, nodes, idx);\n       while (count)\n \t{\n-\t  input_ref (ib, node, NULL, nodes, varpool);\n+\t  input_ref (ib, (symtab_node) node, nodes, varpool);\n \t  count--;\n \t}\n     }\n@@ -1338,7 +1337,7 @@ input_refs (struct lto_input_block *ib,\n \t\t\tstreamer_read_uhwi (ib));\n       while (count)\n \t{\n-\t  input_ref (ib, NULL, node, nodes, varpool);\n+\t  input_ref (ib, (symtab_node) node, nodes, varpool);\n \t  count--;\n \t}\n     }"}, {"sha": "bbb9d1b558d8b3c14a5a9fcd839d4657d28711ad", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -249,7 +249,7 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \te->call_stmt_cannot_inline_p = 1;\n     }\n   /* Redirect incomming references.  */\n-  ipa_clone_refering (prevailing_node, NULL, &node->symbol.ref_list);\n+  ipa_clone_referring ((symtab_node)prevailing_node, &node->symbol.ref_list);\n \n   /* Finally remove the replaced node.  */\n   cgraph_remove_node (node);\n@@ -271,7 +271,7 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n   gcc_assert (!vnode->finalized || prevailing_node->finalized);\n   gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n \n-  ipa_clone_refering (NULL, prevailing_node, &vnode->symbol.ref_list);\n+  ipa_clone_referring ((symtab_node)prevailing_node, &vnode->symbol.ref_list);\n \n   /* Be sure we can garbage collect the initializer.  */\n   if (DECL_INITIAL (vnode->symbol.decl))"}, {"sha": "96a8c9755e1f349f252a35638ce94ad0dcd26d7f", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -1,3 +1,8 @@\n+2012-04-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c (add_references_to_partition, lto_balanced_map):\n+\tUpdate for new ipa-ref API.\n+\n 2012-04-16  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (read_cgraph_and_symbols): Use FOR_EACH"}, {"sha": "6fe672f2401d3fd65bcddceaa58854c616f49d2d", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -72,7 +72,7 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n     {\n-      if (ref->refered_type == IPA_REF_CGRAPH\n+      if (symtab_function_p (ref->referred)\n \t  && (DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref),\n \t\t\t   NULL)->symbol.decl)\n \t      || (ref->use == IPA_REF_ALIAS\n@@ -81,7 +81,7 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n \t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n \tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n       else\n-\tif (ref->refered_type == IPA_REF_VARPOOL\n+        if (symtab_variable_p (ref->referred)\n \t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->symbol.decl)\n \t        || (ref->use == IPA_REF_ALIAS\n \t\t    && lookup_attribute\n@@ -91,26 +91,26 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n \t\t\t\t       part->varpool_set))\n \t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n     }\n-  for (i = 0; ipa_ref_list_refering_iterate (refs, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (refs, i, ref); i++)\n     {\n-      if (ref->refering_type == IPA_REF_CGRAPH\n+      if (symtab_function_p (ref->referring)\n \t  && ref->use == IPA_REF_ALIAS\n-\t  && !cgraph_node_in_set_p (ipa_ref_refering_node (ref),\n+\t  && !cgraph_node_in_set_p (ipa_ref_referring_node (ref),\n \t\t\t\t    part->cgraph_set)\n \t  && !lookup_attribute (\"weakref\",\n \t\t\t\tDECL_ATTRIBUTES\n-\t\t\t\t  (ipa_ref_refering_node (ref)->symbol.decl)))\n-\tadd_cgraph_node_to_partition (part, ipa_ref_refering_node (ref));\n+\t\t\t\t  (ipa_ref_referring_node (ref)->symbol.decl)))\n+\tadd_cgraph_node_to_partition (part, ipa_ref_referring_node (ref));\n       else\n-\tif (ref->refering_type == IPA_REF_VARPOOL\n+        if (symtab_variable_p (ref->referring)\n \t    && ref->use == IPA_REF_ALIAS\n-\t    && !varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t    && !varpool_node_in_set_p (ipa_ref_referring_varpool_node (ref),\n \t\t\t\t       part->varpool_set)\n \t    && !lookup_attribute (\"weakref\",\n \t\t\t\t  DECL_ATTRIBUTES\n-\t\t\t\t    (ipa_ref_refering_varpool_node (ref)->symbol.decl)))\n+\t\t\t\t    (ipa_ref_referring_varpool_node (ref)->symbol.decl)))\n \t  add_varpool_node_to_partition (part,\n-\t\t\t\t\t ipa_ref_refering_varpool_node (ref));\n+\t\t\t\t\t ipa_ref_referring_varpool_node (ref));\n     }\n }\n \n@@ -612,7 +612,7 @@ lto_balanced_map (void)\n \t  /* Compute boundary cost of IPA REF edges and at the same time look into\n \t     variables referenced from current partition and try to add them.  */\n \t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n-\t    if (ref->refered_type == IPA_REF_VARPOOL)\n+\t    if (symtab_variable_p (ref->referred))\n \t      {\n \t\tvarpool_node_set_iterator vsi;\n \n@@ -643,12 +643,12 @@ lto_balanced_map (void)\n \t\telse\n \t\t  cost++;\n \t      }\n-\t  for (j = 0; ipa_ref_list_refering_iterate (refs, j, ref); j++)\n-\t    if (ref->refering_type == IPA_REF_VARPOOL)\n+\t  for (j = 0; ipa_ref_list_referring_iterate (refs, j, ref); j++)\n+\t    if (symtab_variable_p (ref->referring))\n \t      {\n \t\tvarpool_node_set_iterator vsi;\n \n-\t\tvnode = ipa_ref_refering_varpool_node (ref);\n+\t\tvnode = ipa_ref_referring_varpool_node (ref);\n \t\tgcc_assert (vnode->finalized);\n \t\tif (!vnode->symbol.aux && flag_toplevel_reorder\n \t\t    && partition_varpool_node_p (vnode))\n@@ -664,7 +664,7 @@ lto_balanced_map (void)\n \t      {\n \t\tcgraph_node_set_iterator csi;\n \n-\t\tnode = ipa_ref_refering_node (ref);\n+\t\tnode = ipa_ref_referring_node (ref);\n \t\tgcc_assert (node->analyzed);\n \t\tcsi = cgraph_node_set_find (partition->cgraph_set, node);\n \t\tif (!csi_end_p (csi)\n@@ -876,7 +876,7 @@ lto_promote_cross_file_statics (void)\n \t       ipa_ref_list_reference_iterate (&vnode->symbol.ref_list, i, ref);\n \t       i++)\n \t    {\n-\t      if (ref->refered_type == IPA_REF_CGRAPH)\n+\t      if (symtab_function_p (ref->referred))\n \t\t{\n \t\t  struct cgraph_node *n = ipa_ref_node (ref);\n \t\t  gcc_assert (!n->global.inlined_to);"}, {"sha": "6994e0d8b9b3225f68a0e4d9c6ac02c1fadc17eb", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -2258,7 +2258,7 @@ operands_match_p (rtx x, rtx y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  /* MEMs refering to different address space are not equivalent.  */\n+  /* MEMs referring to different address space are not equivalent.  */\n   if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n     return 0;\n "}, {"sha": "9ca6da2c1f60ad212a9a7ee09f1b95a12fcefc89", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -381,7 +381,7 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  /* MEMs refering to different address space are not equivalent.  */\n+  /* MEMs referring to different address space are not equivalent.  */\n   if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n     return 0;\n \n@@ -520,7 +520,7 @@ rtx_equal_p (const_rtx x, const_rtx y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  /* MEMs refering to different address space are not equivalent.  */\n+  /* MEMs referring to different address space are not equivalent.  */\n   if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))\n     return 0;\n "}, {"sha": "78365bdb9e1939dd9770f7123c95f21b99ff576d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -3981,7 +3981,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n       /* If pointers extend unsigned and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be zero.  */\n-      /* As we do not know which address space the pointer is refering to,\n+      /* As we do not know which address space the pointer is referring to,\n \t we can do this only if the target does not support different pointer\n \t or address modes depending on the address space.  */\n       if (target_default_pointer_address_modes_p ()\n@@ -4491,7 +4491,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n       /* If pointers extend signed and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be sign bit copies.  */\n-      /* As we do not know which address space the pointer is refering to,\n+      /* As we do not know which address space the pointer is referring to,\n \t we can do this only if the target does not support different pointer\n \t or address modes depending on the address space.  */\n       if (target_default_pointer_address_modes_p ()"}, {"sha": "3357ceb1024e016c212ff5b70575fc6721c63ac0", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -1140,7 +1140,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t}\n \n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n-      /* As we do not know which address space the pointer is refering to,\n+      /* As we do not know which address space the pointer is referring to,\n \t we can do this only if the target does not support different pointer\n \t or address modes depending on the address space.  */\n       if (target_default_pointer_address_modes_p ()\n@@ -1233,7 +1233,7 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t}\n \n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n-      /* As we do not know which address space the pointer is refering to,\n+      /* As we do not know which address space the pointer is referring to,\n \t we can do this only if the target does not support different pointer\n \t or address modes depending on the address space.  */\n       if (target_default_pointer_address_modes_p ()"}, {"sha": "58e11af0169815ecedc6e0b536aff5c0d6bff42d", "filename": "gcc/symtab.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -191,7 +191,7 @@ symtab_unregister_node (symtab_node node)\n {\n   void **slot;\n   ipa_remove_all_references (&node->symbol.ref_list);\n-  ipa_remove_all_refering (&node->symbol.ref_list);\n+  ipa_remove_all_referring (&node->symbol.ref_list);\n \n   if (node->symbol.same_comdat_group)\n     {\n@@ -429,8 +429,8 @@ dump_symtab_base (FILE *f, symtab_node node)\n \n   fprintf (f, \"  References: \");\n   ipa_dump_references (f, &node->symbol.ref_list);\n-  fprintf (f, \"  Refering: \");\n-  ipa_dump_refering (f, &node->symbol.ref_list);\n+  fprintf (f, \"  Referring: \");\n+  ipa_dump_referring (f, &node->symbol.ref_list);\n }\n \n /* Dump symtab node.  */"}, {"sha": "2a435856d8b89e5dc721910c42bcb0b48a3f96e6", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -4931,9 +4931,9 @@ ipa_tm_execute (void)\n \t}\n \n       /* Propagate back to referring aliases as well.  */\n-      for (j = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, j, ref); j++)\n+      for (j = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, j, ref); j++)\n \t{\n-\t  caller = ref->refering.cgraph_node;\n+\t  caller = cgraph (ref->referring);\n \t  if (ref->use == IPA_REF_ALIAS\n \t      && !caller->local.tm_may_enter_irr)\n \t    {"}, {"sha": "92b7d81e257a55c750168ffdc7c22e95b8bed8d8", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -446,7 +446,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n \n       /* We may be adding a new reference to a new variable to the function.\n          This means we have to play with the ipa-reference web.  */\n-      ipa_record_reference (d->cfun_node, NULL, NULL, cvar, IPA_REF_ADDR, x);\n+      ipa_record_reference ((symtab_node)d->cfun_node, (symtab_node)cvar, IPA_REF_ADDR, x);\n \n       /* Record this ssa_name for possible use later in the basic block.  */\n       VEC_replace (tree, access_vars, index, addr);"}, {"sha": "4a859eb9f8a89824d106c8a3d30af01b25390ab9", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -1010,7 +1010,7 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n       || CONSTANT_CLASS_P (base2))\n     return false;\n \n-  /* We can end up refering to code via function and label decls.\n+  /* We can end up referring to code via function and label decls.\n      As we likely do not properly track code aliases conservatively\n      bail out.  */\n   if (TREE_CODE (base1) == FUNCTION_DECL"}, {"sha": "5748effc04f5d8def9b9b88e9fccd010024b0741", "filename": "gcc/varpool.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5932a4d411f30d1a07789f28528a2c57fb8e33e4/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=5932a4d411f30d1a07789f28528a2c57fb8e33e4", "patch": "@@ -380,7 +380,7 @@ varpool_analyze_pending_decls (void)\n \t\tcontinue;\n \t      }\n \t  if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n-\t    ipa_record_reference (NULL, node, NULL, tgt, IPA_REF_ALIAS, NULL);\n+\t    ipa_record_reference ((symtab_node)node, (symtab_node)tgt, IPA_REF_ALIAS, NULL);\n \t  /* C++ FE sometimes change linkage flags after producing same body aliases.  */\n \t  if (node->extra_name_alias)\n \t    {\n@@ -433,10 +433,10 @@ assemble_aliases (struct varpool_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct varpool_node *alias = ipa_ref_refering_varpool_node (ref);\n+\tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);\n \tassemble_alias (alias->symbol.decl,\n \t\t\tDECL_ASSEMBLER_NAME (alias->alias_of));\n \tassemble_aliases (alias);\n@@ -676,10 +676,10 @@ varpool_for_node_and_aliases (struct varpool_node *node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_referring_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct varpool_node *alias = ipa_ref_refering_varpool_node (ref);\n+\tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);\n \tif (include_overwritable\n \t    || cgraph_variable_initializer_availability (alias) > AVAIL_OVERWRITABLE)\n           if (varpool_for_node_and_aliases (alias, callback, data,"}]}