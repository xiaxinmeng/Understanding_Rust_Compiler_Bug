{"sha": "2427fa809fb072978c49ec705588417122781805", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQyN2ZhODA5ZmIwNzI5NzhjNDllYzcwNTU4ODQxNzEyMjc4MTgwNQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2005-02-17T11:19:10Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2005-02-17T11:19:10Z"}, "message": "tree-vect-analyze.c (vect_analyze_pointer_ref_access): Use POINTER_TYPE_P when checking that type is a pointer.\n\n        * tree-vect-analyze.c (vect_analyze_pointer_ref_access): Use\n        POINTER_TYPE_P when checking that type is a pointer.\n        (vect_get_memtag): Remove.\n        (vect_address_analysis): Use POINTER_TYPE_P. Call\n        vect_object_analysis with dummy parameter for memtag.\n        (vect_object_analysis): Extract memtag (functionality that\n        used to be in vect_get_memtag and moved here). Fix printings.\n        (vect_analyze_data_refs): Fix comment. Call vect_object_analysis\n        with correct parameters. Remove call to vect_get_memtag.\n\nFrom-SVN: r95166", "tree": {"sha": "dbac0f9461092ceca53ca86ef9caadfba638c5e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbac0f9461092ceca53ca86ef9caadfba638c5e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2427fa809fb072978c49ec705588417122781805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2427fa809fb072978c49ec705588417122781805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2427fa809fb072978c49ec705588417122781805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2427fa809fb072978c49ec705588417122781805/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef4b3ba563dae984c0988adfc98676756eee15cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef4b3ba563dae984c0988adfc98676756eee15cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef4b3ba563dae984c0988adfc98676756eee15cc"}], "stats": {"total": 108, "additions": 50, "deletions": 58}, "files": [{"sha": "b9dba9e33b42dae55f54c596cf746b4dcbdc879f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2427fa809fb072978c49ec705588417122781805/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2427fa809fb072978c49ec705588417122781805/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2427fa809fb072978c49ec705588417122781805", "patch": "@@ -1,3 +1,15 @@\n+2005-02-17  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vect-analyze.c (vect_analyze_pointer_ref_access): Use\n+\tPOINTER_TYPE_P when checking that type is a pointer.\n+\t(vect_get_memtag): Remove.\n+\t(vect_address_analysis): Use POINTER_TYPE_P. Call\n+\tvect_object_analysis with dummy parameter for memtag.\n+\t(vect_object_analysis): Extract memtag (functionality that\n+\tused to be in vect_get_memtag and moved here). Fix printings.\n+\t(vect_analyze_data_refs): Fix comment. Call vect_object_analysis\n+\twith correct parameters. Remove call to vect_get_memtag.\n+\n 2005-02-17  Dorit Naishlos  <dorit@il.ibm.com>\n \n \t* Makefile.in (tree-vect-analyze.o, tree-vect-transform.o): New."}, {"sha": "5caf83231bfbc42692fefb2c8aa49bca553217f6", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 38, "deletions": 58, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2427fa809fb072978c49ec705588417122781805/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2427fa809fb072978c49ec705588417122781805/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=2427fa809fb072978c49ec705588417122781805", "patch": "@@ -70,11 +70,10 @@ static bool vect_base_addr_differ_p (struct data_reference *,\n \t\t\t\t     struct data_reference *drb, bool *);\n static tree vect_object_analysis (tree, tree, bool, tree, \n \t\t\t\t  struct data_reference **, tree *, tree *, \n-\t\t\t\t  tree *, bool *);\n+\t\t\t\t  tree *, bool *, tree *);\n static tree vect_address_analysis (tree, tree, bool, tree, \n \t\t\t\t   struct data_reference *, tree *, tree *, \n \t\t\t\t   tree *, bool *);\n-static tree vect_get_memtag (tree, struct data_reference *);\n \n \n /* Function vect_get_ptr_offset\n@@ -1303,7 +1302,7 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n     }\n \n   reftype = TREE_TYPE (TREE_OPERAND (memref, 0));\n-  if (TREE_CODE (reftype) != POINTER_TYPE) \n+  if (!POINTER_TYPE_P (reftype)) \n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n \t\t\t\tLOOP_LOC (loop_vinfo)))\n@@ -1312,7 +1311,7 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n     }\n \n   reftype = TREE_TYPE (init);\n-  if (TREE_CODE (reftype) != POINTER_TYPE) \n+  if (!POINTER_TYPE_P (reftype)) \n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n \t\t\t\tLOOP_LOC (loop_vinfo))) \n@@ -1345,38 +1344,6 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read,\n }\n \n \n-/* Function vect_get_memtag.  \n-\n-   The function returns the relevant variable for memory tag (for aliasing \n-   purposes).  */\n-\n-static tree\n-vect_get_memtag (tree memref, struct data_reference *dr)\n-{\n-  tree symbl, tag;\n-\n-  switch (TREE_CODE (memref))\n-    {\n-    case SSA_NAME:\n-      symbl = SSA_NAME_VAR (memref);\n-      tag = get_var_ann (symbl)->type_mem_tag;\n-      if (!tag)\n-\t{\n-\t  tree ptr = TREE_OPERAND (DR_REF (dr), 0);\n-\t  if (TREE_CODE (ptr) == SSA_NAME)\n-\t    tag = get_var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n-\t}\n-      return tag;\n-\n-    case ADDR_EXPR:\n-      return TREE_OPERAND (memref, 0);\n-\n-    default:\n-      return NULL_TREE;\n-    }  \n-}\n-\n-\n /* Function vect_address_analysis\n \n    Return the BASE of the address expression EXPR.\n@@ -1409,6 +1376,7 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n {\n   tree oprnd0, oprnd1, base_address, offset_expr, base_addr0, base_addr1;\n   tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n+  tree dummy;\n \n   switch (TREE_CODE (expr))\n     {\n@@ -1460,13 +1428,13 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n     case ADDR_EXPR:\n       base_address = vect_object_analysis (TREE_OPERAND (expr, 0), stmt, is_read, \n \t\t\t\t   vectype, &dr, offset, misalign, step, \n-\t\t\t\t   base_aligned);\n+\t\t\t\t   base_aligned, &dummy);\n       return base_address;\n \n     case SSA_NAME:\n-      if (TREE_CODE (TREE_TYPE (expr)) != POINTER_TYPE)\n+      if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n \treturn NULL_TREE;\n-      \n+\n       if (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (expr))) < TYPE_ALIGN (vectype)) \n \t{\n \t  if (vect_get_ptr_offset (expr, vectype, misalign))\n@@ -1538,6 +1506,7 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n               the computation is impossible\n    STEP - evolution of the DR_REF in the loop\n    BASE_ALIGNED - indicates if BASE is aligned\n+   MEMTAG - memory tag for aliasing purposes\n  \n    If something unexpected is encountered (an unsupported form of data-ref),\n    then NULL_TREE is returned.  */\n@@ -1546,7 +1515,7 @@ static tree\n vect_object_analysis (tree memref, tree stmt, bool is_read,\n \t\t      tree vectype, struct data_reference **dr,\n \t\t      tree *offset, tree *misalign, tree *step,\n-\t\t      bool *base_aligned)\n+\t\t      bool *base_aligned, tree *memtag)\n {\n   tree base = NULL_TREE, base_address = NULL_TREE;\n   tree object_offset = ssize_int (0), object_misalign = ssize_int (0);\n@@ -1643,6 +1612,7 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n \tDR_BASE_NAME ((*dr)) = memref;\n \n       base_address = build_fold_addr_expr (memref);\n+      *memtag = memref;\n     }\n \n   /* Part 1:  Case 3. INDIRECT_REFs.  */\n@@ -1698,6 +1668,29 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n       base_address = vect_address_analysis (address_to_analyze, stmt, is_read, \n \t\t\t       vectype, *dr, &address_offset, &address_misalign, \n \t\t\t       &address_step, &address_base_aligned);\n+      if (!base_address)\n+\treturn NULL_TREE;\n+\n+      switch (TREE_CODE (base_address))\n+\t{\n+\tcase SSA_NAME:\n+\t  *memtag = get_var_ann (SSA_NAME_VAR (base_address))->type_mem_tag;\n+\t  if (!(*memtag) && TREE_CODE (TREE_OPERAND (memref, 0)) == SSA_NAME)\n+\t    *memtag = get_var_ann (\n+\t\t      SSA_NAME_VAR (TREE_OPERAND (memref, 0)))->type_mem_tag;\n+\t  break;\n+\tcase ADDR_EXPR:\n+\t  *memtag = TREE_OPERAND (base_address, 0);\n+\t  break;\n+\tdefault:\n+\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\t    LOOP_LOC (loop_vinfo)))\n+\t    {\n+\t      fprintf (vect_dump, \"not vectorized: no memtag ref: \"); \n+\t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n     }\n     \t    \n   if (!base_address)\n@@ -1718,8 +1711,8 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n     {\n       fprintf (vect_dump, \"Results of object analysis for: \");\n       print_generic_expr (vect_dump, memref, TDF_SLIM);\n-      fprintf (vect_dump, \"\\n\\tbase: \");\n-      print_generic_expr (vect_dump, base, TDF_SLIM);\n+      fprintf (vect_dump, \"\\n\\tbase_address: \");\n+      print_generic_expr (vect_dump, base_address, TDF_SLIM);\n       fprintf (vect_dump, \"\\n\\toffset: \");\n       print_generic_expr (vect_dump, *offset, TDF_SLIM);\n       fprintf (vect_dump, \"\\n\\tstep: \");\n@@ -1741,14 +1734,13 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n       Find and analyze all data-refs in the loop:\n           foreach ref\n \t     base_address = vect_object_analysis(ref)\n-             ref_stmt.memtag =  vect_get_memtag(base)\n       1.1- vect_object_analysis(ref): \n            Analyze ref, and build a DR (data_referece struct) for it;\n            compute base, initial_offset, step and alignment. \n            Call get_inner_reference for refs handled in this function.\n            Call vect_addr_analysis(addr) to analyze pointer type expressions.\n-      Set ref_stmt.base, ref_stmt.initial_offset, ref_stmt.alignment, and \n-      ref_stmt.step accordingly. \n+      Set ref_stmt.base, ref_stmt.initial_offset, ref_stmt.alignment,  \n+      ref_stmt.memtag and ref_stmt.step accordingly. \n    2- vect_analyze_dependences(): apply dependence testing using ref_stmt.DR\n    3- vect_analyze_drs_alignment(): check that ref_stmt.alignment is ok.\n    4- vect_analyze_drs_access(): check that ref_stmt.step is ok.\n@@ -1850,7 +1842,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  dr = NULL; \n \t  base = vect_object_analysis (memref, stmt, is_read, vectype, &dr, \n \t\t\t\t       &offset, &misalign, &step, \n-\t\t\t\t       &base_aligned);\n+\t\t\t\t       &base_aligned, &tag);\n \t  if (!base)\n \t    {\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n@@ -1861,18 +1853,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t\t}\n \t      return false;\n \t    }\n-\t  /*  Find memtag for aliasing purposes.  */\n-\t  tag = vect_get_memtag (base, dr);\n-\t  if (!tag)\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n-\t\t\t\t\tLOOP_LOC (loop_vinfo)))\n-\t\t{\n-\t\t  fprintf (vect_dump, \"not vectorized: no memtag ref: \"); \n-\t\t  print_generic_expr (vect_dump, memref, TDF_SLIM);\n-\t\t}\n-\t      return false;\n-\t    }\n \t  STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info) = base;\n \t  STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n \t  STMT_VINFO_VECT_STEP (stmt_info) = step;"}]}