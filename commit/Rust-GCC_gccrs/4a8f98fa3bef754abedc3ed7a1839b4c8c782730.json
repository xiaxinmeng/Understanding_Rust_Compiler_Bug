{"sha": "4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "node_id": "C_kwDOANBUbNoAKDRhOGY5OGZhM2JlZjc1NGFiZWRjM2VkN2ExODM5YjRjOGM3ODI3MzA", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-29T10:20:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-30T07:27:07Z"}, "message": "Make uninit PHI processing more consistent\n\nCurrently the main working of the maybe-uninit pass is to scan over\nall PHIs with possibly undefined arguments, diagnosing whether there's\na direct not guarded use.  For not guarded uses in PHIs those are queued for\nlater processing and to make the uninit analysis PHI def handling work,\nmark the PHI def as possibly uninitialized.  But this happens only\nfor those PHI uses that happen to be seen before a direct not guarded\nuse and whether all arguments of a PHI node which are defined by a PHI\nare properly marked as maybe uninitialized depends on the processing\norder.\n\nThe following changes the uninit pass to perform an RPO walk over\nthe function, ensuring that PHI argument defs are visited before\nthe PHI node (besides backedge uses which we ignore already),\ngetting rid of the worklist.  It also makes sure to process all\nPHI uses, but recording those that are properly guarded so they\nare not treated as maybe undefined when processing the PHI use\nlater.\n\nOverall this should make behavior more consistent, avoid some\nfalse negative because of the previous early out and order issue,\nand avoid some false positive because of the missed recording\nof guarded PHI uses.\n\nThe patch correctly diagnoses an uninitalized use of 'regnum'\nin store_bit_field_1 and also diagnoses an uninitialized use of\nbest_match::m_best_candidate_len in c-decl.cc which I've chosen to\nsilence by initializing m_best_candidate_len.  The warning is\na false positive but GCC cannot see that m_best_candidate_len is\ninitialized when m_best_candidate is not NULL so from this\nperspective this was a false negative.  I've added\ng++.dg/uninit-pred-5.C with a reduced testcase that nicely shows\nhow the previous behavior missed the diagnostic because the\nworklist ended up visiting the PHI with the dependend uninit\nvalue before visiting the PHIs producing it.\n\n\t* gimple-predicate-analysis.h (uninit_analysis::operator()):\n\tRemove.\n\t* gimple-predicate-analysis.cc\n\t(uninit_analysis::collect_phi_def_edges): Use phi_arg_set,\n\tsimplify a bit.\n\t* tree-ssa-uninit.cc (defined_args): New global.\n\t(compute_uninit_opnds_pos): Mask with the recorded set\n\tof guarded maybe-uninitialized uses.\n\t(uninit_undef_val_t::operator()): Remove.\n\t(find_uninit_use): Process all PHI uses, recording the\n\tguarded ones and marking the PHI result as uninitialized\n\tconsistently.\n\t(warn_uninitialized_phi): Adjust.\n\t(execute_late_warn_uninitialized): Get rid of the PHI worklist\n\tand instead walk the function in RPO order.\n\t* spellcheck.h (best_match::m_best_candidate_len): Initialize.\n\n\t* g++.dg/uninit-pred-5.C: New testcase.", "tree": {"sha": "9f3f57754d2a717ce622be83e77d63d6ace08dfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f3f57754d2a717ce622be83e77d63d6ace08dfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ebaabde2b88d446369240ae8f03b8e6a284a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ebaabde2b88d446369240ae8f03b8e6a284a7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37ebaabde2b88d446369240ae8f03b8e6a284a7b"}], "stats": {"total": 297, "additions": 176, "deletions": 121}, "files": [{"sha": "3f9b80d9128a7a06e418c28fcb565c536d1568ae", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "patch": "@@ -543,35 +543,13 @@ uninit_analysis::collect_phi_def_edges (gphi *phi, basic_block cd_root,\n     return;\n \n   unsigned n = gimple_phi_num_args (phi);\n+  unsigned opnds_arg_phi = m_eval.phi_arg_set (phi);\n   for (unsigned i = 0; i < n; i++)\n     {\n-      edge opnd_edge = gimple_phi_arg_edge (phi, i);\n-      tree opnd = gimple_phi_arg_def (phi, i);\n-\n-      if (TREE_CODE (opnd) == SSA_NAME)\n-\t{\n-\t  gimple *def = SSA_NAME_DEF_STMT (opnd);\n-\n-\t  if (!m_eval (opnd))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"\\tFound def edge %i -> %i for cd_root %i \"\n-\t\t\t   \"and operand %u of: \",\n-\t\t\t   opnd_edge->src->index, opnd_edge->dest->index,\n-\t\t\t   cd_root->index, i);\n-\t\t  print_gimple_stmt (dump_file, phi, 0);\n-\t\t}\n-\t      edges->safe_push (opnd_edge);\n-\t    }\n-\t  else if (gimple_code (def) == GIMPLE_PHI\n-\t\t   && dominated_by_p (CDI_DOMINATORS, gimple_bb (def), cd_root))\n-\t    collect_phi_def_edges (as_a<gphi *> (def), cd_root, edges,\n-\t\t\t\t   visited);\n-\t}\n-      else\n+      if (!MASK_TEST_BIT (opnds_arg_phi, i))\n \t{\n+\t  /* Add the edge for a not maybe-undefined edge value.  */\n+\t  edge opnd_edge = gimple_phi_arg_edge (phi, i);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file,\n@@ -581,9 +559,22 @@ uninit_analysis::collect_phi_def_edges (gphi *phi, basic_block cd_root,\n \t\t       cd_root->index, i);\n \t      print_gimple_stmt (dump_file, phi, 0);\n \t    }\n-\n-\t  if (!m_eval (opnd))\n-\t    edges->safe_push (opnd_edge);\n+\t  edges->safe_push (opnd_edge);\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  tree opnd = gimple_phi_arg_def (phi, i);\n+\t  if (TREE_CODE (opnd) == SSA_NAME)\n+\t    {\n+\t      gimple *def = SSA_NAME_DEF_STMT (opnd);\n+\t      if (gimple_code (def) == GIMPLE_PHI\n+\t\t  && dominated_by_p (CDI_DOMINATORS, gimple_bb (def), cd_root))\n+\t\t/* Process PHI defs of maybe-undefined edge values\n+\t\t   recursively.  */\n+\t\tcollect_phi_def_edges (as_a<gphi *> (def), cd_root, edges,\n+\t\t\t\t       visited);\n+\t    }\n \t}\n     }\n }"}, {"sha": "48da8f70efd2cbbb030ae177597c3bdd3dcc60d2", "filename": "gcc/gimple-predicate-analysis.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Fgimple-predicate-analysis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Fgimple-predicate-analysis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.h?ref=4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "patch": "@@ -104,8 +104,6 @@ class uninit_analysis\n   {\n     typedef unsigned phi_arg_set_t;\n \n-    /* Return true if the argument is an expression of interest.  */\n-    virtual bool operator()(tree) = 0;\n     /* Return a bitset of PHI arguments of interest.  By default returns\n        bitset with a bit set for each argument.  Should be called in\n        the overriden function first and, if nonzero, the result then"}, {"sha": "1b76a54b6788c1ebfc5018383b0867a18e20c8a6", "filename": "gcc/spellcheck.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Fspellcheck.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Fspellcheck.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.h?ref=4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "patch": "@@ -95,7 +95,8 @@ class best_match\n   : m_goal (goal_traits::get_string (goal)),\n     m_goal_len (goal_traits::get_length (goal)),\n     m_best_candidate (NULL),\n-    m_best_distance (best_distance_so_far)\n+    m_best_distance (best_distance_so_far),\n+    m_best_candidate_len (0)\n   {}\n \n   /* Compare the edit distance between CANDIDATE and m_goal,"}, {"sha": "8dfd9874f65b043b6862fcfa4a206b99a4ffa90d", "filename": "gcc/testsuite/g++.dg/uninit-pred-5.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-5.C?ref=4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "patch": "@@ -0,0 +1,94 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -Wuninitialized\" }\n+\n+typedef int size_t;\n+typedef struct {\n+} max_align_t;\n+typedef struct tree_node *tree;\n+struct ht_identifier {\n+  char str;\n+  int len;\n+};\n+struct cpp_hashnode {\n+  ht_identifier ident;\n+};\n+tree get_identifier_with_length(char *, size_t);\n+struct cpp_reader *parse_in;\n+typedef int edit_distance_t;\n+edit_distance_t get_edit_distance(char *);\n+template < typename > struct edit_distance_traits;\n+edit_distance_t get_edit_distance_cutoff(size_t);\n+template < typename GOAL_TYPE, typename CANDIDATE_TYPE > class best_match {\n+public:\n+  typedef CANDIDATE_TYPE candidate_t;\n+  typedef edit_distance_traits< candidate_t > candidate_traits;\n+  best_match(GOAL_TYPE)\n+      : m_goal(), m_goal_len(), m_best_candidate(), m_best_distance() {}\n+  void consider(candidate_t candidate) {\n+    size_t candidate_len = candidate_traits::get_length(candidate);\n+    char candidate_str;\n+    edit_distance_t dist = get_edit_distance(&candidate_str);\n+    bool is_better = false;\n+    if (dist)\n+      is_better = true;\n+    if (is_better) {\n+      m_best_candidate = candidate;\n+      m_best_candidate_len = candidate_len;\n+    }\n+  }\n+  void set_best_so_far(CANDIDATE_TYPE) {}\n+  candidate_t get_best_meaningful_candidate() {\n+    edit_distance_t __trans_tmp_1;\n+    if (m_best_candidate) {\n+      size_t candidate_len = m_best_candidate_len;\n+      __trans_tmp_1 = get_edit_distance_cutoff(candidate_len); // { dg-warning \"may be used uninitialized\" }\n+    }\n+    edit_distance_t cutoff = __trans_tmp_1;\n+    if (cutoff)\n+      ;\n+    return m_best_candidate;\n+  }\n+  char m_goal;\n+  size_t m_goal_len;\n+  candidate_t m_best_candidate;\n+  edit_distance_t m_best_distance;\n+  size_t m_best_candidate_len;\n+};\n+template <> struct edit_distance_traits< tree > {\n+  static size_t get_length(tree);\n+};\n+class name_hint {};\n+class best_macro_match : public best_match< tree, cpp_hashnode * > {\n+public:\n+  best_macro_match(cpp_reader *);\n+};\n+struct c_binding {\n+  tree id;\n+  c_binding *prev;\n+};\n+struct c_scope {\n+  c_scope *outer;\n+  c_binding bindings;\n+} * current_scope;\n+tree lookup_name_fuzzy_name;\n+void lookup_name_fuzzy() {\n+  bool consider_implementation_names = 0;\n+  best_match< tree, tree > bm(lookup_name_fuzzy_name);\n+  for (c_scope *scope = current_scope; current_scope;\n+       scope = scope->outer)\n+    for (c_binding *binding = &scope->bindings; binding;\n+         binding = binding->prev)\n+      if (!consider_implementation_names)\n+        bm.consider(binding->id);\n+  best_macro_match bmm(parse_in);\n+  cpp_hashnode *best_macro = bmm.get_best_meaningful_candidate();\n+  if (best_macro) {\n+    char id = best_macro->ident.str;\n+    tree macro_as_identifier =\n+        get_identifier_with_length(&id, best_macro->ident.len);\n+    bm.set_best_so_far(macro_as_identifier);\n+  }\n+  tree best = bm.get_best_meaningful_candidate();\n+  if (best)\n+    name_hint();\n+}"}, {"sha": "3e5816f1ebba5f49356a26822cdd93ef2947fe80", "filename": "gcc/tree-ssa-uninit.cc", "status": "modified", "additions": 60, "deletions": 89, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Ftree-ssa-uninit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8f98fa3bef754abedc3ed7a1839b4c8c782730/gcc%2Ftree-ssa-uninit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.cc?ref=4a8f98fa3bef754abedc3ed7a1839b4c8c782730", "patch": "@@ -56,7 +56,8 @@ along with GCC; see the file COPYING3.  If not see\n /* Pointer set of potentially undefined ssa names, i.e.,\n    ssa names that are defined by phi with operands that\n    are not defined or potentially undefined.  */\n-static hash_set<tree> *possibly_undefined_names = 0;\n+static hash_set<tree> *possibly_undefined_names;\n+static hash_map<gphi *, uninit_analysis::func_t::phi_arg_set_t> *defined_args;\n \n /* Returns the first bit position (starting from LSB)\n    in mask that is non zero.  Returns -1 if the mask is empty.  */\n@@ -1131,6 +1132,9 @@ compute_uninit_opnds_pos (gphi *phi)\n \t  MASK_SET_BIT (uninit_opnds, i);\n \t}\n     }\n+  /* If we have recorded guarded uses of may-uninit values mask those.  */\n+  if (auto *def_mask = defined_args->get (phi))\n+    uninit_opnds &= ~*def_mask;\n   return uninit_opnds;\n }\n \n@@ -1139,21 +1143,9 @@ compute_uninit_opnds_pos (gphi *phi)\n \n struct uninit_undef_val_t: public uninit_analysis::func_t\n {\n-  virtual bool operator()(tree) override;\n   virtual unsigned phi_arg_set (gphi *) override;\n };\n \n-/* Return true if the argument is an expression of interest.  */\n-\n-bool\n-uninit_undef_val_t::operator()(tree val)\n-{\n-  if (TREE_CODE (val) == SSA_NAME)\n-    return uninit_undefined_value_p (val);\n-\n-  return false;\n-}\n-\n /* Return a bitset of PHI arguments of interest.  */\n \n unsigned\n@@ -1166,14 +1158,10 @@ uninit_undef_val_t::phi_arg_set (gphi *phi)\n    uninitialized variable defined by PHI and returns a use\n    statement if the use is not properly guarded.  It returns\n    NULL if all uses are guarded.  UNINIT_OPNDS is a bitvector\n-   holding the position(s) of uninit PHI operands.  WORKLIST\n-   is the vector of candidate phis that may be updated by this\n-   function.  ADDED_TO_WORKLIST is the pointer set tracking\n-   if the new phi is already in the worklist.  */\n+   holding the position(s) of uninit PHI operands.  */\n \n static gimple *\n-find_uninit_use (gphi *phi, unsigned uninit_opnds,\n-\t\t vec<gphi *> *worklist, hash_set<gphi *> *added_to_worklist)\n+find_uninit_use (gphi *phi, unsigned uninit_opnds)\n {\n   /* The Boolean predicate guarding the PHI definition.  Initialized\n      lazily from PHI in the first call to is_use_guarded() and cached\n@@ -1184,6 +1172,7 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n   use_operand_p use_p;\n   imm_use_iterator iter;\n   tree phi_result = gimple_phi_result (phi);\n+  gimple *uninit_use = NULL;\n   FOR_EACH_IMM_USE_FAST (use_p, iter, phi_result)\n     {\n       gimple *use_stmt = USE_STMT (use_p);\n@@ -1202,71 +1191,68 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n \t  if (e->flags & EDGE_DFS_BACK)\n \t    continue;\n \t}\n+      else if (uninit_use)\n+\t/* Only process the first real uninitialized use, but continue\n+\t   looking for unguarded uses in PHIs.  */\n+\tcontinue;\n       else\n \tuse_bb = gimple_bb (use_stmt);\n \n       if (def_preds.is_use_guarded (use_stmt, use_bb, phi, uninit_opnds))\n-\tcontinue;\n+\t{\n+\t  /* For a guarded use in a PHI record the PHI argument as\n+\t     initialized.  */\n+\t  if (gphi *use_phi = dyn_cast<gphi *> (use_stmt))\n+\t    {\n+\t      unsigned idx = PHI_ARG_INDEX_FROM_USE (use_p);\n+\t      if (idx < uninit_analysis::func_t::max_phi_args)\n+\t\t{\n+\t\t  bool existed_p;\n+\t\t  auto &def_mask\n+\t\t    = defined_args->get_or_insert (use_phi, &existed_p);\n+\t\t  if (!existed_p)\n+\t\t    def_mask = 0;\n+\t\t  MASK_SET_BIT (def_mask, idx);\n+\t\t}\n+\t    }\n+\t  continue;\n+\t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Found unguarded use in bb %u: \",\n \t\t   use_bb->index);\n \t  print_gimple_stmt (dump_file, use_stmt, 0);\n \t}\n-      /* Found one real use, return.  */\n-      if (gimple_code (use_stmt) != GIMPLE_PHI)\n-\treturn use_stmt;\n-\n-      /* Found a phi use that is not guarded,\n-\t add the phi to the worklist.  */\n-      if (!added_to_worklist->add (as_a<gphi *> (use_stmt)))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"[WORKLIST]: Update worklist with phi: \");\n-\t      print_gimple_stmt (dump_file, use_stmt, 0);\n-\t    }\n-\n-\t  worklist->safe_push (as_a<gphi *> (use_stmt));\n-\t  possibly_undefined_names->add (phi_result);\n-\t}\n+      /* Found a phi use that is not guarded, mark the phi_result as\n+\t possibly undefined.  */\n+      if (is_a <gphi *> (use_stmt))\n+\tpossibly_undefined_names->add (phi_result);\n+      else\n+\tuninit_use = use_stmt;\n     }\n \n-  return NULL;\n+  return uninit_use;\n }\n \n /* Look for inputs to PHI that are SSA_NAMEs that have empty definitions\n    and gives warning if there exists a runtime path from the entry to a\n    use of the PHI def that does not contain a definition.  In other words,\n    the warning is on the real use.  The more dead paths that can be pruned\n-   by the compiler, the fewer false positives the warning is.  WORKLIST\n-   is a vector of candidate phis to be examined.  ADDED_TO_WORKLIST is\n-   a pointer set tracking if the new phi is added to the worklist or not.  */\n+   by the compiler, the fewer false positives the warning is.  */\n \n static void\n-warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n-\t\t\thash_set<gphi *> *added_to_worklist)\n+warn_uninitialized_phi (gphi *phi, unsigned uninit_opnds)\n {\n-  /* Don't look at virtual operands.  */\n-  if (virtual_operand_p (gimple_phi_result (phi)))\n-    return;\n-\n-  unsigned uninit_opnds = compute_uninit_opnds_pos (phi);\n-  if (MASK_EMPTY (uninit_opnds))\n-    return;\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Examining phi: \");\n       print_gimple_stmt (dump_file, phi, 0);\n     }\n \n-  gimple *uninit_use_stmt = find_uninit_use (phi, uninit_opnds,\n-\t\t\t\t\t     worklist, added_to_worklist);\n+  gimple *uninit_use_stmt = find_uninit_use (phi, uninit_opnds);\n \n-  /* All uses are properly guarded but a new PHI may have been added\n-     to WORKLIST.  */\n+  /* All uses are properly guarded.  */\n   if (!uninit_use_stmt)\n     return;\n \n@@ -1341,17 +1327,15 @@ class pass_late_warn_uninitialized : public gimple_opt_pass\n static void\n execute_late_warn_uninitialized (function *fun)\n {\n-  basic_block bb;\n-  gphi_iterator gsi;\n-  vec<gphi *> worklist = vNULL;\n-\n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   /* Mark all edges executable, warn_uninitialized_vars will skip\n      unreachable blocks.  */\n   set_all_edges_as_executable (fun);\n   mark_dfs_back_edges (fun);\n+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n+  int n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n \n   /* Re-do the plain uninitialized variable check, as optimization may have\n      straightened control flow.  Do this first so that we don't accidentally\n@@ -1361,47 +1345,34 @@ execute_late_warn_uninitialized (function *fun)\n   timevar_push (TV_TREE_UNINIT);\n \n   possibly_undefined_names = new hash_set<tree>;\n-  hash_set<gphi *> added_to_worklist;\n-\n-  /* Initialize worklist  */\n-  FOR_EACH_BB_FN (bb, fun)\n-    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  defined_args = new hash_map<gphi *, uninit_analysis::func_t::phi_arg_set_t>;\n+\n+  /* Walk the CFG in RPO order so we visit PHIs with defs that are\n+     possibly uninitialized from other PHIs after those.  The uninit\n+     predicate analysis will then expand the PHIs predicate with\n+     the predicates of the edges from such PHI defs.  */\n+  for (int i = 0; i < n; ++i)\n+    for (auto gsi = gsi_start_phis (BASIC_BLOCK_FOR_FN (fun, rpo[i]));\n+\t !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n \tgphi *phi = gsi.phi ();\n \n \t/* Don't look at virtual operands.  */\n \tif (virtual_operand_p (gimple_phi_result (phi)))\n \t  continue;\n \n-\tunsigned n = gimple_phi_num_args (phi);\n-\tfor (unsigned i = 0; i < n; ++i)\n-\t  {\n-\t    tree op = gimple_phi_arg_def (phi, i);\n-\t    if (TREE_CODE (op) == SSA_NAME && uninit_undefined_value_p (op))\n-\t      {\n-\t\tworklist.safe_push (phi);\n-\t\tadded_to_worklist.add (phi);\n-\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t  {\n-\t\t    fprintf (dump_file, \"[WORKLIST]: add to initial list \"\n-\t\t\t     \"for operand %u of: \", i);\n-\t\t    print_gimple_stmt (dump_file, phi, 0);\n-\t\t  }\n-\t\tbreak;\n-\t      }\n-\t  }\n-      }\n+\tunsigned uninit_opnds = compute_uninit_opnds_pos (phi);\n+\tif (MASK_EMPTY (uninit_opnds))\n+\t  continue;\n \n-  while (worklist.length () != 0)\n-    {\n-      gphi *cur_phi = 0;\n-      cur_phi = worklist.pop ();\n-      warn_uninitialized_phi (cur_phi, &worklist, &added_to_worklist);\n-    }\n+\twarn_uninitialized_phi (phi, uninit_opnds);\n+      }\n \n-  worklist.release ();\n+  free (rpo);\n   delete possibly_undefined_names;\n   possibly_undefined_names = NULL;\n+  delete defined_args;\n+  defined_args = NULL;\n   free_dominance_info (CDI_POST_DOMINATORS);\n   timevar_pop (TV_TREE_UNINIT);\n }"}]}