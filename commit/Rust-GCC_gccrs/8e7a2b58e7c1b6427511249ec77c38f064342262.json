{"sha": "8e7a2b58e7c1b6427511249ec77c38f064342262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU3YTJiNThlN2MxYjY0Mjc1MTEyNDllYzc3YzM4ZjA2NDM0MjI2Mg==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2006-04-07T23:04:15Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2006-04-07T23:04:15Z"}, "message": "For PR 26483, IA-64 denorm failure due to unwanted rounding.\n\n* testsuite/libffi.call/float4.c: New testcase.\n\nFrom-SVN: r112768", "tree": {"sha": "a943312c35d8921cd128be1e1ae3f14c41b92cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a943312c35d8921cd128be1e1ae3f14c41b92cdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e7a2b58e7c1b6427511249ec77c38f064342262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7a2b58e7c1b6427511249ec77c38f064342262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7a2b58e7c1b6427511249ec77c38f064342262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7a2b58e7c1b6427511249ec77c38f064342262/comments", "author": null, "committer": null, "parents": [{"sha": "a05906031a66c96a5647f8ce6fe0a180b9a8021f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05906031a66c96a5647f8ce6fe0a180b9a8021f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05906031a66c96a5647f8ce6fe0a180b9a8021f"}], "stats": {"total": 64, "additions": 64, "deletions": 0}, "files": [{"sha": "def8e5c97b976fac203d5d3e4b94b75ab0bd5c65", "filename": "libffi/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7a2b58e7c1b6427511249ec77c38f064342262/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7a2b58e7c1b6427511249ec77c38f064342262/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=8e7a2b58e7c1b6427511249ec77c38f064342262", "patch": "@@ -1,3 +1,7 @@\n+2006-04-07  James E Wilson  <wilson@specifix.com>\n+\n+\t* testsuite/libffi.call/float4.c: New testcase.\n+\n 2006-04-05  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \t    Andreas Tobler  <a.tobler@schweiz.ch>\n "}, {"sha": "febad5eb917af88dbb4a1bcd6c9f2daa9f6c09fc", "filename": "libffi/testsuite/libffi.call/float4.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7a2b58e7c1b6427511249ec77c38f064342262/libffi%2Ftestsuite%2Flibffi.call%2Ffloat4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7a2b58e7c1b6427511249ec77c38f064342262/libffi%2Ftestsuite%2Flibffi.call%2Ffloat4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat4.c?ref=8e7a2b58e7c1b6427511249ec77c38f064342262", "patch": "@@ -0,0 +1,60 @@\n+/* Area:\tffi_call\n+   Purpose:\tCheck denorm double value.\n+   Limitations:\tnone.\n+   PR:\t\tPR26483.\n+   Originator:\tFrom the original ffitest.c  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+#include \"float.h\"\n+\n+typedef union\n+{\n+  double d;\n+  unsigned char c[sizeof (double)];\n+} value_type;\n+\n+#define CANARY 0xba\n+\n+static double dblit(double d)\n+{\n+  return d;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  double d;\n+  value_type result[2];\n+  unsigned int i;\n+\n+  args[0] = &ffi_type_double;\n+  values[0] = &d;\n+  \n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ffi_type_double, args) == FFI_OK);\n+  \n+  d = DBL_MIN / 2;\n+  \n+  /* Put a canary in the return array.  This is a regression test for\n+     a buffer overrun.  */\n+  memset(result[1].c, CANARY, sizeof (double));\n+\n+  ffi_call(&cif, FFI_FN(dblit), &result[0].d, values);\n+  \n+  /* The standard delta check doesn't work for denorms.  Since we didn't do\n+     any arithmetic, we should get the original result back, and hence an\n+     exact check should be OK here.  */\n+ \n+  CHECK(result[0].d == dblit(d));\n+\n+  /* Check the canary.  */\n+  for (i = 0; i < sizeof (double); ++i)\n+    CHECK(result[1].c[i] == CANARY);\n+\n+  exit(0);\n+\n+}"}]}