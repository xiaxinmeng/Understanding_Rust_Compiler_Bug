{"sha": "3a94c984014fb9b7f2b6937ea0028a0f0eea8dec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E5NGM5ODQwMTRmYjliN2YyYjY5MzdlYTAwMjhhMGYwZWVhOGRlYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-06T17:48:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-06T17:48:30Z"}, "message": "* expr.c: Fix formatting.\n\nFrom-SVN: r35523", "tree": {"sha": "30b36735f6d0ca92d7bad12305dbb5fe0734cd29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30b36735f6d0ca92d7bad12305dbb5fe0734cd29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec/comments", "author": null, "committer": null, "parents": [{"sha": "e50f5f3d6970b0877bcef9129267814e97427384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e50f5f3d6970b0877bcef9129267814e97427384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e50f5f3d6970b0877bcef9129267814e97427384"}], "stats": {"total": 347, "additions": 173, "deletions": 174}, "files": [{"sha": "64782cb56a2374096f24dd127152746deca37c2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a94c984014fb9b7f2b6937ea0028a0f0eea8dec", "patch": "@@ -1,3 +1,7 @@\n+2000-08-06  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* expr.c: Fix formatting.\n+\n 2000-08-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* rs6000.c (rs6000_maybe_dead): Prototype."}, {"sha": "02a27ba6b10b21fcdd2dccb5079a436e214273e2", "filename": "gcc/expr.c", "status": "modified", "additions": 169, "deletions": 174, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a94c984014fb9b7f2b6937ea0028a0f0eea8dec/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3a94c984014fb9b7f2b6937ea0028a0f0eea8dec", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"machmode.h\"\n@@ -34,7 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n #include \"insn-config.h\"\n-/* Include expr.h after insn-config.h so we get HAVE_conditional_move. */\n+/* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */\n #include \"expr.h\"\n #include \"recog.h\"\n #include \"reload.h\"\n@@ -68,7 +67,7 @@ Boston, MA 02111-1307, USA.  */\n #ifdef PUSH_ROUNDING\n \n #if defined (STACK_GROWS_DOWNWARD) != defined (ARGS_GROW_DOWNWARD)\n-#define PUSH_ARGS_REVERSED\t/* If it's last to first */\n+#define PUSH_ARGS_REVERSED\t/* If it's last to first.  */\n #endif\n \n #endif\n@@ -196,13 +195,13 @@ static char direct_store[NUM_MACHINE_MODES];\n #if defined (HAVE_movstrqi) || defined (HAVE_movstrhi) || defined (HAVE_movstrsi) || defined (HAVE_movstrdi) || defined (HAVE_movstrti)\n #define MOVE_RATIO 2\n #else\n-/* If we are optimizing for space (-Os), cut down the default move ratio */\n+/* If we are optimizing for space (-Os), cut down the default move ratio.  */\n #define MOVE_RATIO (optimize_size ? 3 : 15)\n #endif\n #endif\n \n /* This macro is used to determine whether move_by_pieces should be called\n-   to perform a structure copy. */\n+   to perform a structure copy.  */\n #ifndef MOVE_BY_PIECES_P\n #define MOVE_BY_PIECES_P(SIZE, ALIGN) \\\n   (move_by_pieces_ninsns (SIZE, ALIGN) < MOVE_RATIO)\n@@ -549,7 +548,7 @@ convert_move (to, from, unsignedp)\n     {\n       if (GET_MODE_BITSIZE (from_mode) != GET_MODE_BITSIZE (to_mode))\n \tabort ();\n-      \n+\n       if (VECTOR_MODE_P (to_mode))\n \tfrom = gen_rtx_SUBREG (to_mode, from, 0);\n       else\n@@ -576,7 +575,7 @@ convert_move (to, from, unsignedp)\n \t      return;\n \t    }\n \t}\n- \n+\n #ifdef HAVE_trunchfqf2\n       if (HAVE_trunchfqf2 && from_mode == HFmode && to_mode == QFmode)\n \t{\n@@ -738,7 +737,7 @@ convert_move (to, from, unsignedp)\n \t    case TFmode:\n \t      libcall = extendsftf2_libfunc;\n \t      break;\n-\t      \n+\n \t    default:\n \t      break;\n \t    }\n@@ -758,7 +757,7 @@ convert_move (to, from, unsignedp)\n \t    case TFmode:\n \t      libcall = extenddftf2_libfunc;\n \t      break;\n-\t      \n+\n \t    default:\n \t      break;\n \t    }\n@@ -774,7 +773,7 @@ convert_move (to, from, unsignedp)\n \t    case DFmode:\n \t      libcall = truncxfdf2_libfunc;\n \t      break;\n-\t      \n+\n \t    default:\n \t      break;\n \t    }\n@@ -790,12 +789,12 @@ convert_move (to, from, unsignedp)\n \t    case DFmode:\n \t      libcall = trunctfdf2_libfunc;\n \t      break;\n-\t      \n+\n \t    default:\n \t      break;\n \t    }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -932,7 +931,7 @@ convert_move (to, from, unsignedp)\n       return;\n     }\n \n-  /* Handle pointer conversion */\t\t\t/* SPEE 900220 */\n+  /* Handle pointer conversion.  */\t\t\t/* SPEE 900220.  */\n   if (to_mode == PQImode)\n     {\n       if (from_mode != QImode)\n@@ -1093,21 +1092,21 @@ convert_move (to, from, unsignedp)\n \t      }\n \n \t  /* No suitable intermediate mode.\n-\t     Generate what we need with\tshifts. */\n+\t     Generate what we need with\tshifts.  */\n \t  shift_amount = build_int_2 (GET_MODE_BITSIZE (to_mode)\n \t\t\t\t      - GET_MODE_BITSIZE (from_mode), 0);\n \t  from = gen_lowpart (to_mode, force_reg (from_mode, from));\n \t  tmp = expand_shift (LSHIFT_EXPR, to_mode, from, shift_amount,\n \t\t\t      to, unsignedp);\n-\t  tmp = expand_shift (RSHIFT_EXPR, to_mode, tmp,  shift_amount,\n+\t  tmp = expand_shift (RSHIFT_EXPR, to_mode, tmp, shift_amount,\n \t\t\t      to, unsignedp);\n \t  if (tmp != to)\n \t    emit_move_insn (to, tmp);\n \t  return;\n \t}\n     }\n \n-  /* Support special truncate insns for certain modes.  */ \n+  /* Support special truncate insns for certain modes.  */\n \n   if (from_mode == DImode && to_mode == SImode)\n     {\n@@ -1303,7 +1302,7 @@ convert_modes (mode, oldmode, x, unsignedp)\n \n   if (GET_MODE (x) != VOIDmode)\n     oldmode = GET_MODE (x);\n- \n+\n   if (mode == oldmode)\n     return x;\n \n@@ -1375,13 +1374,12 @@ convert_modes (mode, oldmode, x, unsignedp)\n   return temp;\n }\n \f\n-\n /* This macro is used to determine what the largest unit size that\n-   move_by_pieces can use is. */\n+   move_by_pieces can use is.  */\n \n /* MOVE_MAX_PIECES is the number of bytes at a time which we can\n    move efficiently, as opposed to  MOVE_MAX which is the maximum\n-   number of bytes we can move with a single instruction. */\n+   number of bytes we can move with a single instruction.  */\n \n #ifndef MOVE_MAX_PIECES\n #define MOVE_MAX_PIECES   MOVE_MAX\n@@ -1431,7 +1429,7 @@ move_by_pieces (to, from, len, align)\n   if (!(data.autinc_from && data.autinc_to)\n       && move_by_pieces_ninsns (len, align) > 2)\n     {\n-      /* Find the mode of the largest move... */\n+      /* Find the mode of the largest move...  */\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n \tif (GET_MODE_SIZE (tmode) < max_size)\n@@ -1702,7 +1700,7 @@ emit_block_move (x, y, size, align)\n \t To avoid this problem we go ahead and emit code to copy X, Y &\n \t SIZE into new pseudos.  We can then place those new pseudos\n \t into an RTL_EXPR and use them later, even after a call to\n-\t emit_queue. \n+\t emit_queue.\n \n \t Note this is not strictly needed for library calls since they\n \t do not call emit_queue before loading their arguments.  However,\n@@ -1728,7 +1726,7 @@ emit_block_move (x, y, size, align)\n \t examine the return value from memcpy.\n \n \t For targets where libcalls and normal calls have different conventions\n-\t for returning pointers, we could end up generating incorrect code. \n+\t for returning pointers, we could end up generating incorrect code.\n \n \t So instead of using a libcall sequence we build up a suitable\n \t CALL_EXPR and expand the call in the normal fashion.  */\n@@ -1744,7 +1742,7 @@ emit_block_move (x, y, size, align)\n \t  fntype = build_pointer_type (void_type_node);\n \t  fntype = build_function_type (fntype, NULL_TREE);\n \t  fn = build_decl (FUNCTION_DECL, fn, fntype);\n- \t  ggc_add_tree_root (&fn, 1);\n+\t  ggc_add_tree_root (&fn, 1);\n \t  DECL_EXTERNAL (fn) = 1;\n \t  TREE_PUBLIC (fn) = 1;\n \t  DECL_ARTIFICIAL (fn) = 1;\n@@ -1753,7 +1751,7 @@ emit_block_move (x, y, size, align)\n \t  pop_obstacks ();\n \t}\n \n-      /* We need to make an argument list for the function call. \n+      /* We need to make an argument list for the function call.\n \n \t memcpy has three arguments, the first two are void * addresses and\n \t the last is a size_t byte count for the copy.  */\n@@ -1798,7 +1796,7 @@ move_block_to_reg (regno, x, nregs, mode)\n {\n   int i;\n #ifdef HAVE_load_multiple\n-  rtx pat; \n+  rtx pat;\n   rtx last;\n #endif\n \n@@ -1834,7 +1832,6 @@ move_block_to_reg (regno, x, nregs, mode)\n    The number of registers to be filled is NREGS.  SIZE indicates the number\n    of bytes in the object X.  */\n \n-\n void\n move_block_from_reg (regno, x, nregs, size)\n      int regno;\n@@ -1844,7 +1841,7 @@ move_block_from_reg (regno, x, nregs, size)\n {\n   int i;\n #ifdef HAVE_store_multiple\n-  rtx pat; \n+  rtx pat;\n   rtx last;\n #endif\n   enum machine_mode mode;\n@@ -1858,7 +1855,7 @@ move_block_from_reg (regno, x, nregs, size)\n \t\t      gen_rtx_REG (mode, regno));\n       return;\n     }\n-    \n+\n   /* Blocks smaller than a word on a BYTES_BIG_ENDIAN machine must be aligned\n      to the left before storing to memory.  Note that the previous test\n      doesn't handle all cases (e.g. SIZE == 3).  */\n@@ -1936,7 +1933,7 @@ emit_group_load (dst, orig_src, ssize, align)\n   else\n     start = 1;\n \n-  tmps = (rtx *) alloca (sizeof(rtx) * XVECLEN (dst, 0));\n+  tmps = (rtx *) alloca (sizeof (rtx) * XVECLEN (dst, 0));\n \n   /* If we won't be loading directly from memory, protect the real source\n      from strange tricks we might play.  */\n@@ -2000,7 +1997,7 @@ emit_group_load (dst, orig_src, ssize, align)\n \t\t      tmps[i], 0, OPTAB_WIDEN);\n     }\n \n-  emit_queue();\n+  emit_queue ();\n \n   /* Copy the extracted pieces into the proper (probable) hard regs.  */\n   for (i = start; i < XVECLEN (dst, 0); i++)\n@@ -2030,7 +2027,7 @@ emit_group_store (orig_dst, src, ssize, align)\n   else\n     start = 1;\n \n-  tmps = (rtx *) alloca (sizeof(rtx) * XVECLEN (src, 0));\n+  tmps = (rtx *) alloca (sizeof (rtx) * XVECLEN (src, 0));\n \n   /* Copy the (probable) hard regs into pseudos.  */\n   for (i = start; i < XVECLEN (src, 0); i++)\n@@ -2039,7 +2036,7 @@ emit_group_store (orig_dst, src, ssize, align)\n       tmps[i] = gen_reg_rtx (GET_MODE (reg));\n       emit_move_insn (tmps[i], reg);\n     }\n-  emit_queue();\n+  emit_queue ();\n \n   /* If we won't be storing directly into memory, protect the real destination\n      from strange tricks we might play.  */\n@@ -2111,7 +2108,7 @@ emit_group_store (orig_dst, src, ssize, align)\n \t\t\t   mode, tmps[i], align, ssize);\n     }\n \n-  emit_queue();\n+  emit_queue ();\n \n   /* Copy from the pseudo into the (probable) hard reg.  */\n   if (GET_CODE (dst) == REG)\n@@ -2125,7 +2122,7 @@ emit_group_store (orig_dst, src, ssize, align)\n    The primary purpose of this routine is to handle functions\n    that return BLKmode structures in registers.  Some machines\n    (the PA for example) want to return all small structures\n-   in registers regardless of the structure's alignment. */\n+   in registers regardless of the structure's alignment.  */\n \n rtx\n copy_blkmode_from_reg (tgtblk, srcreg, type)\n@@ -2144,7 +2141,7 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n       MEM_SET_IN_STRUCT_P (tgtblk, AGGREGATE_TYPE_P (type));\n       preserve_temp_slots (tgtblk);\n     }\n-      \n+\n   /* This code assumes srcreg is at least a full word.  If it isn't,\n      copy it into a new pseudo which is a full word.  */\n   if (GET_MODE (srcreg) != BLKmode\n@@ -2160,15 +2157,15 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n       = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD) * BITS_PER_UNIT));\n \n   /* Copy the structure BITSIZE bites at a time.\n-     \n+\n      We could probably emit more efficient code for machines which do not use\n      strict alignment, but it doesn't seem worth the effort at the current\n      time.  */\n   for (bitpos = 0, xbitpos = big_endian_correction;\n        bitpos < bytes * BITS_PER_UNIT;\n        bitpos += bitsize, xbitpos += bitsize)\n     {\n-      /* We need a new source operand each time xbitpos is on a \n+      /* We need a new source operand each time xbitpos is on a\n \t word boundary and when xbitpos == big_endian_correction\n \t (the first time through).  */\n       if (xbitpos % BITS_PER_WORD == 0\n@@ -2179,7 +2176,7 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n \t a word boundary.  */\n       if (bitpos % BITS_PER_WORD == 0)\n \tdst = operand_subword (tgtblk, bitpos / BITS_PER_WORD, 1, BLKmode);\n-\t      \n+\n       /* Use xbitpos for the source extraction (right justified) and\n \t xbitpos for the destination store (left justified).  */\n       store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, word_mode,\n@@ -2202,7 +2199,7 @@ use_reg (call_fusage, reg)\n {\n   if (GET_CODE (reg) != REG\n       || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    abort();\n+    abort ();\n \n   *call_fusage\n     = gen_rtx_EXPR_LIST (VOIDmode,\n@@ -2276,7 +2273,8 @@ clear_by_pieces (to, len, align)\n   data.explicit_inc_to = 0;\n   data.reverse\n     = (GET_CODE (to_addr) == PRE_DEC || GET_CODE (to_addr) == POST_DEC);\n-  if (data.reverse) data.offset = len;\n+  if (data.reverse)\n+    data.offset = len;\n   data.len = len;\n \n   /* If copying requires more than two move insns,\n@@ -2285,7 +2283,7 @@ clear_by_pieces (to, len, align)\n   if (!data.autinc_to\n       && move_by_pieces_ninsns (len, align) > 2)\n     {\n-      /* Determine the main mode we'll be using */\n+      /* Determine the main mode we'll be using.  */\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n \tif (GET_MODE_SIZE (tmode) < max_size)\n@@ -2362,7 +2360,7 @@ clear_by_pieces_1 (genfun, mode, data)\n \t  to1 = gen_rtx_MEM (mode, data->to_addr);\n \t  MEM_COPY_ATTRIBUTES (to1, data->to);\n \t}\n-      else \n+      else\n \tto1 = change_address (data->to, mode,\n \t\t\t      plus_constant (data->to_addr, data->offset));\n \n@@ -2485,7 +2483,6 @@ clear_storage (object, size, align)\n \t  size = copy_to_mode_reg (TYPE_MODE (integer_type_node), size);\n #endif\n \n-\n #ifdef TARGET_MEM_FUNCTIONS\n \t  /* It is incorrect to use the libcall calling conventions to call\n \t     memset in this context.\n@@ -2495,7 +2492,7 @@ clear_storage (object, size, align)\n \n \t     For targets where libcalls and normal calls have different\n \t     conventions for returning pointers, we could end up generating\n-\t      incorrect code. \n+\t      incorrect code.\n \n \t     So instead of using a libcall sequence we build up a suitable\n \t     CALL_EXPR and expand the call in the normal fashion.  */\n@@ -2520,7 +2517,7 @@ clear_storage (object, size, align)\n \t      pop_obstacks ();\n \t    }\n \n-\t  /* We need to make an argument list for the function call. \n+\t  /* We need to make an argument list for the function call.\n \n \t     memset has three arguments, the first is a void * addresses, the\n \t     second a integer with the initialization value, the last is a\n@@ -2531,7 +2528,7 @@ clear_storage (object, size, align)\n \t\t\t\t\t  object));\n \t  TREE_CHAIN (arg_list)\n \t    = build_tree_list (NULL_TREE,\n-\t\t\t        make_tree (integer_type_node, const0_rtx));\n+\t\t\t       make_tree (integer_type_node, const0_rtx));\n \t  TREE_CHAIN (TREE_CHAIN (arg_list))\n \t    = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n \t  TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n@@ -2617,7 +2614,7 @@ emit_move_insn_1 (x, y)\n   unsigned int i;\n \n   if (mode >= MAX_MACHINE_MODE)\n-      abort ();\n+    abort ();\n \n   if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     return\n@@ -2675,7 +2672,7 @@ emit_move_insn_1 (x, y)\n \t     memory and reload.  FIXME, we should see about using extract and\n \t     insert on integer registers, but complex short and complex char\n \t     variables should be rarely used.  */\n-\t  if (GET_MODE_BITSIZE (mode) < 2*BITS_PER_WORD\n+\t  if (GET_MODE_BITSIZE (mode) < 2 * BITS_PER_WORD\n \t      && (reload_in_progress | reload_completed) == 0)\n \t    {\n \t      int packed_dest_p = (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER);\n@@ -2686,7 +2683,7 @@ emit_move_insn_1 (x, y)\n \t\t  enum mode_class reg_class = ((class == MODE_COMPLEX_FLOAT)\n \t\t\t\t\t       ? MODE_FLOAT : MODE_INT);\n \n-\t\t  enum machine_mode reg_mode = \n+\t\t  enum machine_mode reg_mode =\n \t\t    mode_for_size (GET_MODE_BITSIZE (mode), reg_class, 1);\n \n \t\t  if (reg_mode != BLKmode)\n@@ -2748,7 +2745,7 @@ emit_move_insn_1 (x, y)\n       rtx last_insn = 0;\n       rtx seq, inner;\n       int need_clobber;\n-      \n+\n #ifdef PUSH_ROUNDING\n \n       /* If X is a push on the stack, do the push now and replace\n@@ -2759,7 +2756,7 @@ emit_move_insn_1 (x, y)\n \t  x = change_address (x, VOIDmode, stack_pointer_rtx);\n \t}\n #endif\n-\t\t\t     \n+\n       /* If we are in reload, see if either operand is a MEM whose address\n \t is scheduled for replacement.  */\n       if (reload_in_progress && GET_CODE (x) == MEM\n@@ -2783,7 +2780,7 @@ emit_move_insn_1 (x, y)\n \n       need_clobber = 0;\n       for (i = 0;\n-\t   i < (GET_MODE_SIZE (mode)  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\t   i < (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n \t   i++)\n \t{\n \t  rtx xpart = operand_subword (x, i, 1, mode);\n@@ -2883,7 +2880,7 @@ push_block (size, extra, below)\n     {\n       if (GET_CODE (size) == CONST_INT)\n \ttemp = plus_constant (virtual_outgoing_args_rtx,\n-\t\t\t      - INTVAL (size) - (below ? 0 : extra));\n+\t\t\t      -INTVAL (size) - (below ? 0 : extra));\n       else if (extra != 0 && !below)\n \ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n \t\t\t     negate_rtx (Pmode, plus_constant (size, extra)));\n@@ -2906,7 +2903,7 @@ gen_push_operand ()\n \n static rtx\n get_push_address (size)\n-\tint size;\n+     int size;\n {\n   register rtx temp;\n \n@@ -2997,7 +2994,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n       int used = partial * UNITS_PER_WORD;\n       int offset = used % (PARM_BOUNDARY / BITS_PER_UNIT);\n       int skip;\n-      \n+\n       if (size == 0)\n \tabort ();\n \n@@ -3047,27 +3044,27 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  if (current_function_check_memory_usage && ! in_check_memory_usage)\n \t    {\n \t      rtx temp;\n-\t      \n+\n \t      in_check_memory_usage = 1;\n-\t      temp = get_push_address (INTVAL(size) - used);\n+\t      temp = get_push_address (INTVAL (size) - used);\n \t      if (GET_CODE (x) == MEM && type && AGGREGATE_TYPE_P (type))\n \t\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n \t\t\t\t   temp, Pmode,\n \t\t\t\t   XEXP (xinner, 0), Pmode,\n-\t\t\t\t   GEN_INT (INTVAL(size) - used),\n+\t\t\t\t   GEN_INT (INTVAL (size) - used),\n \t\t\t\t   TYPE_MODE (sizetype));\n \t      else\n \t\temit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t\t   temp, Pmode,\n-\t\t\t \t   GEN_INT (INTVAL(size) - used),\n+\t\t\t \t   GEN_INT (INTVAL (size) - used),\n \t\t\t\t   TYPE_MODE (sizetype),\n \t\t\t\t   GEN_INT (MEMORY_USE_RW),\n \t\t\t\t   TYPE_MODE (integer_type_node));\n \t      in_check_memory_usage = 0;\n \t    }\n \t}\n       else\n-#endif /* PUSH_ROUNDING */\n+#endif /* PUSH_ROUNDING  */\n \t{\n \t  rtx target;\n \n@@ -3121,17 +3118,17 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      in_check_memory_usage = 0;\n \t    }\n \n-\t    target = gen_rtx_MEM (BLKmode, temp);\n+\t  target = gen_rtx_MEM (BLKmode, temp);\n \n-\t    if (type != 0)\n-\t      {\n-\t\tset_mem_attributes (target, type, 1);\n-\t\t/* Function incoming arguments may overlap with sibling call\n-\t\t   outgoing arguments and we cannot allow reordering of reads\n-\t\t   from function arguments with stores to outgoing arguments\n-\t\t   of sibling calls.  */\n-\t\tMEM_ALIAS_SET (target) = 0;\n-\t      }\n+\t  if (type != 0)\n+\t    {\n+\t      set_mem_attributes (target, type, 1);\n+\t      /* Function incoming arguments may overlap with sibling call\n+\t\t outgoing arguments and we cannot allow reordering of reads\n+\t\t from function arguments with stores to outgoing arguments\n+\t\t of sibling calls.  */\n+\t      MEM_ALIAS_SET (target) = 0;\n+\t    }\n \n \t  /* TEMP is the address of the block.  Copy the data there.  */\n \t  if (GET_CODE (size) == CONST_INT\n@@ -3302,9 +3299,9 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  if (GET_CODE (args_so_far) == CONST_INT)\n \t    addr\n \t      = memory_address (mode,\n-\t\t\t\tplus_constant (args_addr, \n+\t\t\t\tplus_constant (args_addr,\n \t\t\t\t\t       INTVAL (args_so_far)));\n-          else\n+\t  else\n \t    addr = memory_address (mode, gen_rtx_PLUS (Pmode, args_addr,\n \t\t\t\t\t\t       args_so_far));\n \t  target = addr;\n@@ -3362,7 +3359,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n   if (extra && args_addr == 0 && where_pad == stack_direction)\n     anti_adjust_stack (GEN_INT (extra));\n- \n+\n   if (alignment_pad && args_addr == 0)\n     anti_adjust_stack (alignment_pad);\n }\n@@ -3465,7 +3462,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t      && GET_MODE (to_rtx) == BLKmode\n \t      && GET_MODE (XEXP (to_rtx, 0)) != VOIDmode\n \t      && bitsize\n-\t      && (bitpos % bitsize) == 0 \n+\t      && (bitpos % bitsize) == 0\n \t      && (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n \t      && alignment == GET_MODE_ALIGNMENT (mode1))\n \t    {\n@@ -3853,7 +3850,7 @@ store_expr (exp, target, want_value)\n \t\t\t\t\tSUBREG_PROMOTED_UNSIGNED_P (target)),\n \t\t\t exp);\n \t}\n-\t \n+\n       temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n       /* If TEMP is a volatile MEM and we want a result value, make\n@@ -3923,15 +3920,15 @@ store_expr (exp, target, want_value)\n     {\n       in_check_memory_usage = 1;\n       if (GET_CODE (temp) == MEM)\n-        emit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n \t\t\t   XEXP (target, 0), Pmode,\n \t\t\t   XEXP (temp, 0), Pmode,\n \t\t\t   expr_size (exp), TYPE_MODE (sizetype));\n       else\n-        emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n-\t\t\t   XEXP (target, 0), Pmode, \n+\temit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t   XEXP (target, 0), Pmode,\n \t\t\t   expr_size (exp), TYPE_MODE (sizetype),\n-\t\t\t   GEN_INT (MEMORY_USE_WO), \n+\t\t\t   GEN_INT (MEMORY_USE_WO),\n \t\t\t   TYPE_MODE (integer_type_node));\n       in_check_memory_usage = 0;\n     }\n@@ -4011,7 +4008,7 @@ store_expr (exp, target, want_value)\n \t      if (GET_CODE (copy_size_rtx) == CONST_INT)\n \t\t{\n \t\t  addr = plus_constant (addr, TREE_STRING_LENGTH (exp));\n-\t\t  size = plus_constant (size, - TREE_STRING_LENGTH (exp));\n+\t\t  size = plus_constant (size, -TREE_STRING_LENGTH (exp));\n \t\t  align = MIN (align, (BITS_PER_UNIT\n \t\t\t\t       * (INTVAL (copy_size_rtx)\n \t\t\t\t\t  & - INTVAL (copy_size_rtx))));\n@@ -4046,7 +4043,7 @@ store_expr (exp, target, want_value)\n \t\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n \t\t\t\t       addr, Pmode,\n \t\t\t\t       size, TYPE_MODE (sizetype),\n- \t\t\t\t       GEN_INT (MEMORY_USE_WO), \n+ \t\t\t\t       GEN_INT (MEMORY_USE_WO),\n \t\t\t\t       TYPE_MODE (integer_type_node));\n \t\t  in_check_memory_usage = 0;\n \t\t  clear_storage (dest, size, align);\n@@ -4082,7 +4079,7 @@ store_expr (exp, target, want_value)\n \t   && ! (GET_CODE (target) == REG\n \t\t && REGNO (target) < FIRST_PSEUDO_REGISTER))\n     return copy_to_reg (target);\n-  \n+\n   else\n     return target;\n }\n@@ -4120,7 +4117,7 @@ is_zeros_p (exp)\n \t  return 0;\n \n       return 1;\n-      \n+\n     default:\n       return 0;\n     }\n@@ -4329,7 +4326,7 @@ store_constructor (exp, target, align, cleared, size)\n \t    }\n \t  else\n \t    bitpos = tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 0);\n-\t\t\t      \n+\n \t  if (offset)\n \t    {\n \t      rtx offset_rtx;\n@@ -4342,8 +4339,8 @@ store_constructor (exp, target, align, cleared, size)\n \t      if (GET_CODE (to_rtx) != MEM)\n \t\tabort ();\n \n-              if (GET_MODE (offset_rtx) != ptr_mode)\n-                {\n+\t      if (GET_MODE (offset_rtx) != ptr_mode)\n+\t\t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n                   offset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n #else\n@@ -4611,7 +4608,7 @@ store_constructor (exp, target, align, cleared, size)\n \t}\n     }\n \n-  /* Set constructor assignments */\n+  /* Set constructor assignments.  */\n   else if (TREE_CODE (type) == SET_TYPE)\n     {\n       tree elt = CONSTRUCTOR_ELTS (exp);\n@@ -4628,7 +4625,7 @@ store_constructor (exp, target, align, cleared, size)\n \t Also, if a large set has just a single range, it may also be\n \t better to first clear all the first clear the set (using\n \t bzero/memset), and set the bits we want.  */\n-       \n+\n       /* Check for all zeros.  */\n       if (elt == NULL_TREE && size > 0)\n \t{\n@@ -4647,7 +4644,7 @@ store_constructor (exp, target, align, cleared, size)\n \n       /* For \"small\" sets, or \"medium-sized\" (up to 32 bytes) sets that\n \t are \"complicated\" (more than one range), initialize (the\n-\t constant parts) by copying from a constant.  */\t \n+\t constant parts) by copying from a constant.  */\n       if (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD\n \t  || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))\n \t{\n@@ -4686,7 +4683,7 @@ store_constructor (exp, target, align, cleared, size)\n \t\t\t  to_rtx = plus_constant (XEXP (target, 0), offset);\n \t\t\t  to_rtx = change_address (target, mode, to_rtx);\n \t\t\t}\n-\t\t      else if (offset == 0) \n+\t\t      else if (offset == 0)\n \t\t\tto_rtx = target;\n \t\t      else\n \t\t\tabort ();\n@@ -4712,12 +4709,12 @@ store_constructor (exp, target, align, cleared, size)\n \t\t       - tree_low_cst (TREE_PURPOSE (elt), 0) + 1\n \t\t       != (HOST_WIDE_INT) nbits))))\n \t  clear_storage (target, expr_size (exp), TYPE_ALIGN (type));\n-\t  \n+\n       for (; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n \t{\n-\t  /* start of range of element or NULL */\n+\t  /* Start of range of element or NULL.  */\n \t  tree startbit = TREE_PURPOSE (elt);\n-\t  /* end of range of element, or element value */\n+\t  /* End of range of element, or element value.  */\n \t  tree endbit   = TREE_VALUE (elt);\n #ifdef TARGET_MEM_FUNCTIONS\n \t  HOST_WIDE_INT startb, endb;\n@@ -4727,7 +4724,7 @@ store_constructor (exp, target, align, cleared, size)\n \t  bitlength_rtx = expand_expr (bitlength,\n \t\t\t\t       NULL_RTX, MEM, EXPAND_CONST_ADDRESS);\n \n-\t  /* handle non-range tuple element like [ expr ]  */\n+\t  /* Handle non-range tuple element like [ expr ].  */\n \t  if (startbit == NULL_TREE)\n \t    {\n \t      startbit = save_expr (endbit);\n@@ -4741,9 +4738,9 @@ store_constructor (exp, target, align, cleared, size)\n \t      startbit = size_binop (MINUS_EXPR, startbit, domain_min);\n \t      endbit = size_binop (MINUS_EXPR, endbit, domain_min);\n \t    }\n-\t  startbit_rtx = expand_expr (startbit, NULL_RTX, MEM, \n+\t  startbit_rtx = expand_expr (startbit, NULL_RTX, MEM,\n \t\t\t\t      EXPAND_CONST_ADDRESS);\n-\t  endbit_rtx = expand_expr (endbit, NULL_RTX, MEM, \n+\t  endbit_rtx = expand_expr (endbit, NULL_RTX, MEM,\n \t\t\t\t    EXPAND_CONST_ADDRESS);\n \n \t  if (REG_P (target))\n@@ -4807,7 +4804,7 @@ store_constructor (exp, target, align, cleared, size)\n    In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.\n \n    ALIGN is the alignment that TARGET is known to have.\n-   TOTAL_SIZE is the size in bytes of the structure, or -1 if varying.  \n+   TOTAL_SIZE is the size in bytes of the structure, or -1 if varying.\n \n    ALIAS_SET is the alias set for the destination.  This value will\n    (in general) be different from that for TARGET, since TARGET is a\n@@ -5080,7 +5077,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n       else\n \t*pbitsize = GET_MODE_BITSIZE (mode);\n     }\n-      \n+\n   if (size_tree != 0)\n     {\n       if (! host_integerp (size_tree, 1))\n@@ -5300,7 +5297,7 @@ force_operand (value, target)\n \t\t\t       force_operand (XEXP (XEXP (value, 0), 1), 0),\n \t\t\t       target, 0, OPTAB_LIB_WIDEN);\n \t}\n-\t\t\t\t   \n+\n       tmp = force_operand (XEXP (value, 0), subtarget);\n       return expand_binop (GET_MODE (value), binoptab, tmp,\n \t\t\t   force_operand (op2, NULL_RTX),\n@@ -5540,7 +5537,7 @@ safe_from_p (x, exp, top_p)\n \t     where it is so we can turn it back in the top-level safe_from_p()\n \t     when we're done.  */\n \n-\t  /* For now, don't bother re-sizing the array. */\n+\t  /* For now, don't bother re-sizing the array.  */\n \t  if (save_expr_count >= save_expr_size)\n \t    return 0;\n \t  save_expr_rewritten[save_expr_count++] = exp;\n@@ -5567,7 +5564,7 @@ safe_from_p (x, exp, top_p)\n \tcase METHOD_CALL_EXPR:\n \t  /* This takes a rtx argument, but shouldn't appear here.  */\n \t  abort ();\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -5643,7 +5640,7 @@ var_rtx (exp)\n #ifdef MAX_INTEGER_COMPUTATION_MODE\n void\n check_max_integer_computation_mode (exp)\n-    tree exp;\n+     tree exp;\n {\n   enum tree_code code;\n   enum machine_mode mode;\n@@ -5677,7 +5674,7 @@ check_max_integer_computation_mode (exp)\n \t  && mode > MAX_INTEGER_COMPUTATION_MODE)\n \tfatal (\"unsupported wide integer operation\");\n     }\n-\t\n+\n   /* Check operands of a binary/comparison op.  */\n   if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')\n     {\n@@ -5693,7 +5690,6 @@ check_max_integer_computation_mode (exp)\n     }\n }\n #endif\n-\n \f\n /* Utility function used by expand_expr to see if TYPE, a RECORD_TYPE,\n    has any readonly fields.  If any of the fields have types that\n@@ -5706,7 +5702,7 @@ readonly_fields_p (type)\n   tree field;\n \n   for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n-    if (TREE_CODE (field) == FIELD_DECL \n+    if (TREE_CODE (field) == FIELD_DECL\n \t&& (TREE_READONLY (field)\n \t    || (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n \t\t&& readonly_fields_p (TREE_TYPE (field)))))\n@@ -5769,7 +5765,7 @@ expand_expr (exp, target, tmode, modifier)\n   /* Used by check-memory-usage to make modifier read only.  */\n   enum expand_modifier ro_modifier;\n \n-  /* Handle ERROR_MARK before anybody tries to access its type. */\n+  /* Handle ERROR_MARK before anybody tries to access its type.  */\n   if (TREE_CODE (exp) == ERROR_MARK)\n     {\n       op0 = CONST0_RTX (tmode);\n@@ -5824,7 +5820,7 @@ expand_expr (exp, target, tmode, modifier)\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n \t\t\t    VOIDmode, ro_modifier);\n       else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<'\n-\t     || code == ARRAY_REF)\n+\t       || code == ARRAY_REF)\n \t{\n \t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, ro_modifier);\n \t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, ro_modifier);\n@@ -5843,7 +5839,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  expand_expr (TREE_OPERAND (exp, 2), const0_rtx, VOIDmode, ro_modifier);\n \t  return const0_rtx;\n \t}\n-;\n+      ;\n       target = 0;\n     }\n \n@@ -6026,7 +6022,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    abort ();\n \t  addr = XEXP (DECL_RTL (exp), 0);\n \t  if (GET_CODE (addr) == MEM)\n-\t    addr = change_address (addr, Pmode, \n+\t    addr = change_address (addr, Pmode,\n \t\t\t\t   fix_lexical_addr (XEXP (addr, 0), exp));\n \t  else\n \t    addr = fix_lexical_addr (addr, exp);\n@@ -6095,12 +6091,12 @@ expand_expr (exp, target, tmode, modifier)\n \n     case CONST_DECL:\n       return expand_expr (DECL_INITIAL (exp), target, VOIDmode,\n-      \t\t\t  EXPAND_MEMORY_USE_BAD);\n+\t\t\t  EXPAND_MEMORY_USE_BAD);\n \n     case REAL_CST:\n       /* If optimized, generate immediate CONST_DOUBLE\n-\t which will be turned into memory by reload if necessary. \n-     \n+\t which will be turned into memory by reload if necessary.\n+\n \t We used to force a register so that loop.c could see it.  But\n \t this does not allow gen_* patterns to perform optimizations with\n \t the constants.  It also produces two insns in cases like \"x = 1.0;\".\n@@ -6138,7 +6134,7 @@ expand_expr (exp, target, tmode, modifier)\n \tlineno = EXPR_WFL_LINENO (exp);\n \tif (EXPR_WFL_EMIT_LINE_NOTE (exp))\n \t  emit_line_note (input_filename, lineno);\n-\t/* Possibly avoid switching back and force here */\n+\t/* Possibly avoid switching back and force here.  */\n \tto_return = expand_expr (EXPR_WFL_NODE (exp), target, tmode, modifier);\n \tinput_filename = saved_input_filename;\n \tlineno = saved_lineno;\n@@ -6254,7 +6250,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    tree elt;\n \n \t    /* Find the outermost reference that is of the type we want.\n-\t       If none, see if any object has a type that is a pointer to \n+\t       If none, see if any object has a type that is a pointer to\n \t       the type we want.  */\n \t    for (elt = TREE_PURPOSE (placeholder_expr);\n \t\t elt != 0 && object == 0;\n@@ -6416,7 +6412,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t     && ! (target != 0 && safe_from_p (target, exp, 1)))\n \t\t    || TREE_ADDRESSABLE (exp)\n \t\t    || (host_integerp (TYPE_SIZE_UNIT (type), 1)\n-\t\t\t&& (! MOVE_BY_PIECES_P \n+\t\t\t&& (! MOVE_BY_PIECES_P\n \t\t\t    (tree_low_cst (TYPE_SIZE_UNIT (type), 1),\n \t\t\t     TYPE_ALIGN (type)))\n \t\t\t&& ! mostly_zeros_p (exp))))\n@@ -6466,8 +6462,8 @@ expand_expr (exp, target, tmode, modifier)\n       {\n \ttree exp1 = TREE_OPERAND (exp, 0);\n \ttree index;\n- \ttree string = string_constant (exp1, &index);\n- \n+\ttree string = string_constant (exp1, &index);\n+\n \t/* Try to optimize reads from const strings.  */\n  \tif (string\n  \t    && TREE_CODE (string) == STRING_CST\n@@ -6563,7 +6559,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n \t    && TREE_CODE (index) == INTEGER_CST\n-\t    && 0 > compare_tree_int (index, \n+\t    && 0 > compare_tree_int (index,\n \t\t\t\t     list_length (CONSTRUCTOR_ELTS\n \t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))))\n \t  {\n@@ -6578,7 +6574,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      return expand_expr (fold (TREE_VALUE (elem)), target,\n \t\t\t\t  tmode, ro_modifier);\n \t  }\n-\t  \n+\n \telse if (optimize >= 1\n \t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n \t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n@@ -6611,8 +6607,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      }\n \t  }\n       }\n-\n-      /* ... fall through ... */\n+      /* Fall through.  */\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -6642,7 +6637,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t&& (GET_MODE_BITSIZE (DECL_MODE (TREE_PURPOSE (elt)))\n \t\t\t    <= HOST_BITS_PER_WIDE_INT))))\n \t      {\n-\t\top0 =  expand_expr (TREE_VALUE (elt), target, tmode, modifier);\n+\t\top0 = expand_expr (TREE_VALUE (elt), target, tmode, modifier);\n \t\tif (DECL_BIT_FIELD (TREE_PURPOSE (elt)))\n \t\t  {\n \t\t    HOST_WIDE_INT bitsize\n@@ -6691,7 +6686,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* If TEM's type is a union of variable size, pass TARGET to the inner\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n-  \n+\n \top0 = expand_expr (tem,\n \t\t\t   (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n \t\t\t    && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n@@ -6750,7 +6745,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t&& GET_MODE (op0) == BLKmode\n \t\t&& GET_MODE (XEXP (op0, 0)) != VOIDmode\n \t\t&& bitsize != 0\n-\t\t&& (bitpos % bitsize) == 0 \n+\t\t&& (bitpos % bitsize) == 0\n \t\t&& (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n \t\t&& alignment == GET_MODE_ALIGNMENT (mode1))\n \t      {\n@@ -6767,7 +6762,6 @@ expand_expr (exp, target, tmode, modifier)\n \t\tbitpos = 0;\n \t      }\n \n-\n \t    op0 = change_address (op0, VOIDmode,\n \t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (op0, 0),\n \t\t\t\t\t\tforce_reg (ptr_mode,\n@@ -6784,7 +6778,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Check the access.  */\n \tif (cfun != 0 && current_function_check_memory_usage\n \t    && GET_CODE (op0) == MEM)\n-          {\n+\t  {\n \t    enum memory_use_mode memory_usage;\n \t    memory_usage = get_memory_usage_from_modifier (modifier);\n \n@@ -6803,7 +6797,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t     to, Pmode,\n \t\t\t\t     GEN_INT (size / BITS_PER_UNIT),\n \t\t\t\t     TYPE_MODE (sizetype),\n-\t\t\t\t     GEN_INT (memory_usage), \n+\t\t\t\t     GEN_INT (memory_usage),\n \t\t\t\t     TYPE_MODE (integer_type_node));\n \t\tin_check_memory_usage = 0;\n \t      }\n@@ -6873,7 +6867,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n \t\t\t\t\t  / BITS_PER_UNIT),\n \t\t\t\t BITS_PER_UNIT);\n-\t\t\n+\n \t\treturn target;\n \t      }\n \n@@ -7017,7 +7011,7 @@ expand_expr (exp, target, tmode, modifier)\n \t   of the set.  */\n \tif (GET_CODE (lo_r) == CONST_INT)\n \t  rlow = GEN_INT (INTVAL (lo_r)\n-\t\t\t  & ~ ((HOST_WIDE_INT) 1 << BITS_PER_UNIT));\n+\t\t\t  & ~((HOST_WIDE_INT) 1 << BITS_PER_UNIT));\n \telse\n \t  rlow = expand_binop (index_mode, and_optab, lo_r,\n \t\t\t       GEN_INT (~((HOST_WIDE_INT) 1 << BITS_PER_UNIT)),\n@@ -7036,7 +7030,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t     setaddr, NULL_RTX, iunsignedp,\n \t\t\t\t\t     OPTAB_LIB_WIDEN));\n \n-\t/* Extract the bit we want to examine */\n+\t/* Extract the bit we want to examine.  */\n \tbit = expand_shift (RSHIFT_EXPR, byte_mode,\n \t\t\t    gen_rtx_MEM (byte_mode, addr),\n \t\t\t    make_tree (TREE_TYPE (index), rem),\n@@ -7327,7 +7321,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  op0 = eliminate_constant_term (op0, &constant_term);\n \n \t  /* CONSTANT_TERM and XEXP (op1, 1) are known to be constant, so\n-\t     their sum should be a constant.  Form it into OP1, since the \n+\t     their sum should be a constant.  Form it into OP1, since the\n \t     result we want will then be OP0 + OP1.  */\n \n \t  temp = simplify_binary_operation (PLUS, mode, constant_term,\n@@ -7612,7 +7606,7 @@ expand_expr (exp, target, tmode, modifier)\n \n       /* At this point, a MEM target is no longer useful; we will get better\n \t code without it.  */\n-\t \n+\n       if (GET_CODE (target) == MEM)\n \ttarget = gen_reg_rtx (mode);\n \n@@ -7867,7 +7861,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t/* If we are not to produce a result, we have no target.  Otherwise,\n \t   if a target was specified use it; it will not be used as an\n-\t   intermediate target unless it is safe.  If no target, use a \n+\t   intermediate target unless it is safe.  If no target, use a\n \t   temporary.  */\n \n \tif (ignore)\n@@ -7945,7 +7939,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      TREE_OPERAND (exp, 0)\n \t\t= invert_truthvalue (TREE_OPERAND (exp, 0));\n \t  }\n-\t    \n+\n \tdo_pending_stack_adjust ();\n \tNO_DEFER_POP;\n \top0 = gen_label_rtx ();\n@@ -8002,7 +7996,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t     || TREE_CODE (TREE_OPERAND (exp, 1)) == SAVE_EXPR)\n \t\t && safe_from_p (temp, TREE_OPERAND (exp, 2), 1))\n \t  {\n-\t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n+\t    if (GET_CODE (temp) == REG\n+\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    jumpif (TREE_OPERAND (exp, 0), op0);\n@@ -8020,7 +8015,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t     || TREE_CODE (TREE_OPERAND (exp, 2)) == SAVE_EXPR)\n \t\t && safe_from_p (temp, TREE_OPERAND (exp, 1), 1))\n \t  {\n-\t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n+\t    if (GET_CODE (temp) == REG\n+\t\t&& REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n@@ -8035,11 +8031,11 @@ expand_expr (exp, target, tmode, modifier)\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n \t    start_cleanup_deferral ();\n-\t    \n+\n \t    /* One branch of the cond can be void, if it never returns. For\n-               example A ? throw : E  */\n+\t       example A ? throw : E  */\n \t    if (temp != 0\n-\t        && TREE_TYPE (TREE_OPERAND (exp, 1)) != void_type_node)\n+\t\t&& TREE_TYPE (TREE_OPERAND (exp, 1)) != void_type_node)\n \t      store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 1),\n@@ -8051,7 +8047,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    emit_label (op0);\n \t    start_cleanup_deferral ();\n \t    if (temp != 0\n-\t        && TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node)\n+\t\t&& TREE_TYPE (TREE_OPERAND (exp, 2)) != void_type_node)\n \t      store_expr (TREE_OPERAND (exp, 2), temp, 0);\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 2),\n@@ -8090,7 +8086,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t/* Set this here so that if we get a target that refers to a\n \t   register variable that's already been used, put_reg_into_stack\n-\t   knows that it should fix up those uses.  */\t   \n+\t   knows that it should fix up those uses.  */\n \tTREE_USED (slot) = 1;\n \n \tif (target == 0)\n@@ -8138,12 +8134,12 @@ expand_expr (exp, target, tmode, modifier)\n \t       not target that we were passed in, as our target\n \t       parameter is only a hint.  */\n \t    if (DECL_RTL (slot) != 0)\n-              {\n-                target = DECL_RTL (slot);\n-                /* If we have already expanded the slot, so don't do\n+\t      {\n+\t\ttarget = DECL_RTL (slot);\n+\t\t/* If we have already expanded the slot, so don't do\n                    it again.  (mrs)  */\n-                if (TREE_OPERAND (exp, 1) == NULL_TREE)\n-                  return target;\n+\t\tif (TREE_OPERAND (exp, 1) == NULL_TREE)\n+\t\t  return target;\n \t      }\n \t    else\n \t      {\n@@ -8165,7 +8161,7 @@ expand_expr (exp, target, tmode, modifier)\n \tstore_expr (exp1, target, 0);\n \n \texpand_decl_cleanup (NULL_TREE, cleanups);\n-\t\n+\n \treturn target;\n       }\n \n@@ -8338,7 +8334,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  if (GET_CODE (op0) != MEM)\n \t    abort ();\n-  \n+\n \t  if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n \t    {\n \t      temp = XEXP (op0, 0);\n@@ -8413,7 +8409,7 @@ expand_expr (exp, target, tmode, modifier)\n     case REALPART_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n       return gen_realpart (mode, op0);\n-      \n+\n     case IMAGPART_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n       return gen_imagpart (mode, op0);\n@@ -8423,12 +8419,12 @@ expand_expr (exp, target, tmode, modifier)\n \tenum machine_mode partmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \trtx imag_t;\n \trtx insns;\n-\t\n-\top0  = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n \n \tif (! target)\n \t  target = gen_reg_rtx (mode);\n-\t\t\t\t\t\t\t\t    \n+\n \tstart_sequence ();\n \n \t/* Store the realpart and the negated imagpart to target.  */\n@@ -8437,14 +8433,14 @@ expand_expr (exp, target, tmode, modifier)\n \n \timag_t = gen_imagpart (partmode, target);\n \ttemp = expand_unop (partmode, neg_optab,\n-\t\t\t       gen_imagpart (partmode, op0), imag_t, 0);\n+\t\t\t    gen_imagpart (partmode, op0), imag_t, 0);\n \tif (temp != imag_t)\n \t  emit_move_insn (imag_t, temp);\n \n \tinsns = get_insns ();\n \tend_sequence ();\n \n-\t/* Conjugate should appear as a single unit \n+\t/* Conjugate should appear as a single unit\n \t   If TARGET is a CONCAT, we got insns like RD = RS, ID = - IS,\n \t   each with a separate pseudo as destination.\n \t   It's not correct for flow to treat them as a unit.  */\n@@ -8499,12 +8495,13 @@ expand_expr (exp, target, tmode, modifier)\n \treturn op0;\n       }\n \n-      case GOTO_SUBROUTINE_EXPR:\n+    case GOTO_SUBROUTINE_EXPR:\n       {\n \trtx subr = (rtx) TREE_OPERAND (exp, 0);\n \trtx return_link = *(rtx *) &TREE_OPERAND (exp, 1);\n \trtx return_address = gen_label_rtx ();\n-\temit_move_insn (return_link, gen_rtx_LABEL_REF (Pmode, return_address));\n+\temit_move_insn (return_link,\n+\t\t\tgen_rtx_LABEL_REF (Pmode, return_address));\n \temit_jump (subr);\n \temit_label (return_address);\n \treturn const0_rtx;\n@@ -8613,7 +8610,7 @@ expand_expr_unaligned (exp, palign)\n \t   that was declared const.  */\n \n \tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n-\t    && 0 > compare_tree_int (index, \n+\t    && 0 > compare_tree_int (index,\n \t\t\t\t     list_length (CONSTRUCTOR_ELTS\n \t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))))\n \t  {\n@@ -8627,7 +8624,7 @@ expand_expr_unaligned (exp, palign)\n \t    if (elem)\n \t      return expand_expr_unaligned (fold (TREE_VALUE (elem)), palign);\n \t  }\n-\t  \n+\n \telse if (optimize >= 1\n \t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n \t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n@@ -8653,8 +8650,7 @@ expand_expr_unaligned (exp, palign)\n \t      }\n \t  }\n       }\n-\n-      /* ... fall through ... */\n+      /* Fall through.  */\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -8753,7 +8749,7 @@ expand_expr_unaligned (exp, palign)\n \n \t/* Check the access.  */\n \tif (current_function_check_memory_usage && GET_CODE (op0) == MEM)\n-          {\n+\t  {\n \t    rtx to;\n \t    int size;\n \n@@ -8766,7 +8762,7 @@ expand_expr_unaligned (exp, palign)\n \t      emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n \t\t\t\t to, ptr_mode, GEN_INT (size / BITS_PER_UNIT),\n \t\t\t\t TYPE_MODE (sizetype),\n-\t\t\t\t GEN_INT (MEMORY_USE_RO), \n+\t\t\t\t GEN_INT (MEMORY_USE_RO),\n \t\t\t\t TYPE_MODE (integer_type_node));\n \t    in_check_memory_usage = 0;\n \t  }\n@@ -8820,7 +8816,6 @@ expand_expr_unaligned (exp, palign)\n \t\t\t\t\t\t- bitsize),\n \t\t\t\t      op0, 1);\n \n-\n \t\temit_move_insn (new, op0);\n \t\top0 = copy_rtx (new);\n \t\tPUT_MODE (op0, BLKmode);\n@@ -8829,8 +8824,8 @@ expand_expr_unaligned (exp, palign)\n \telse\n \t  /* Get a reference to just this component.  */\n \t  op0 = change_address (op0, mode1,\n-\t\t\t\t  plus_constant (XEXP (op0, 0),\n-\t\t\t\t\t\t (bitpos / BITS_PER_UNIT)));\n+\t\t\t\tplus_constant (XEXP (op0, 0),\n+\t\t\t\t\t       (bitpos / BITS_PER_UNIT)));\n \n \tMEM_ALIAS_SET (op0) = get_alias_set (exp);\n \n@@ -8986,7 +8981,7 @@ expand_increment (exp, post, ignore)\n   if (this_optab == sub_optab\n       && GET_CODE (op1) == CONST_INT)\n     {\n-      op1 = GEN_INT (- INTVAL (op1));\n+      op1 = GEN_INT (-INTVAL (op1));\n       this_optab = add_optab;\n     }\n \n@@ -9094,7 +9089,7 @@ expand_increment (exp, post, ignore)\n \n   /* Increment however we can.  */\n   op1 = expand_binop (mode, this_optab, value, op1,\n-  \t\t      current_function_check_memory_usage ? NULL_RTX : op0,\n+\t\t      current_function_check_memory_usage ? NULL_RTX : op0,\n \t\t      TREE_UNSIGNED (TREE_TYPE (exp)), OPTAB_LIB_WIDEN);\n   /* Make sure the value is stored into OP0.  */\n   if (op1 != op0)\n@@ -9163,7 +9158,7 @@ preexpand_calls (exp)\n     case SAVE_EXPR:\n       if (SAVE_EXPR_RTL (exp) != 0)\n \treturn;\n-      \n+\n     default:\n       break;\n     }\n@@ -9602,7 +9597,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  cmp = UNORDERED, rcmp = ORDERED;\n \telse\n \t  cmp = ORDERED, rcmp = UNORDERED;\n-        mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\tmode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \n \tdo_rev = 0;\n \tif (! can_compare_p (cmp, mode, ccp_jump)\n@@ -9655,7 +9650,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t    tree op1 = save_expr (TREE_OPERAND (exp, 1));\n \t    tree cmp0, cmp1;\n \n-\t    /* If the target doesn't support combined unordered \n+\t    /* If the target doesn't support combined unordered\n \t       compares, decompose into UNORDERED + comparison.  */\n \t    cmp0 = fold (build (UNORDERED_EXPR, TREE_TYPE (exp), op0, op1));\n \t    cmp1 = fold (build (tcode2, TREE_TYPE (exp), op0, op1));\n@@ -9934,7 +9929,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n       unsignedp = 1;\n     }\n #endif\n-\t\n+\n   emit_cmp_insn (op0, op1, code, size, mode, unsignedp, align);\n \n   return gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n@@ -10350,7 +10345,7 @@ do_store_flag (exp, target, mode, only_cheap)\n       else\n \treturn 0;\n     }\n-      \n+\n   preexpand_calls (exp);\n   if (! get_subtarget (target)\n       || GET_MODE (subtarget) != operand_mode\n@@ -10479,4 +10474,4 @@ do_tablejump (index, mode, range, table_label, default_label)\n     emit_barrier ();\n }\n \n-#endif /* HAVE_tablejump */\n+#endif /* HAVE_tablejump  */"}]}