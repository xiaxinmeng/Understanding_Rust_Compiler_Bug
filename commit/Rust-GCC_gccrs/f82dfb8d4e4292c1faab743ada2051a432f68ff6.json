{"sha": "f82dfb8d4e4292c1faab743ada2051a432f68ff6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyZGZiOGQ0ZTQyOTJjMWZhYWI3NDNhZGEyMDUxYTQzMmY2OGZmNg==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-09-12T15:48:07Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-09-12T15:48:07Z"}, "message": "Implement C++17 string searchers.\n\n\t* include/std/functional: (unordered_map, vector): New includes\n\tin C++17 mode.\n\t(array, bits/stl_algo.h): Likewise.\n\t(default_searcher, __boyer_moore_map_base): New.\n\t(__boyer_moore_array_base, __is_std_equal_to): Likewise.\n\t(__boyer_moore_base_t, boyer_moore_searcher): Likewise.\n\t(boyer_moore_horspool_searcher, make_default_searcher): Likewise.\n\t(make_boyer_moore_searcher): Likewise.\n\t(make_boyer_moore_horspool_searcher): Likewise.\n\t* testsuite/20_util/function_objects/searchers.cc: New.\n\nFrom-SVN: r240093", "tree": {"sha": "e0e342f9a5086386dbb386847c418ecb46fb2b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0e342f9a5086386dbb386847c418ecb46fb2b88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f82dfb8d4e4292c1faab743ada2051a432f68ff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82dfb8d4e4292c1faab743ada2051a432f68ff6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82dfb8d4e4292c1faab743ada2051a432f68ff6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82dfb8d4e4292c1faab743ada2051a432f68ff6/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f3675f855e0e95366ef53c6291835cc2fb597f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3675f855e0e95366ef53c6291835cc2fb597f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f3675f855e0e95366ef53c6291835cc2fb597f7"}], "stats": {"total": 461, "additions": 461, "deletions": 0}, "files": [{"sha": "594cf1336d19165292e5911ddce7a9c666292d0d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82dfb8d4e4292c1faab743ada2051a432f68ff6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82dfb8d4e4292c1faab743ada2051a432f68ff6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f82dfb8d4e4292c1faab743ada2051a432f68ff6", "patch": "@@ -1,3 +1,17 @@\n+2016-09-12  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement C++17 string searchers.\n+\t* include/std/functional: (unordered_map, vector): New includes\n+\tin C++17 mode.\n+\t(array, bits/stl_algo.h): Likewise.\n+\t(default_searcher, __boyer_moore_map_base): New.\n+\t(__boyer_moore_array_base, __is_std_equal_to): Likewise.\n+\t(__boyer_moore_base_t, boyer_moore_searcher): Likewise.\n+\t(boyer_moore_horspool_searcher, make_default_searcher): Likewise.\n+\t(make_boyer_moore_searcher): Likewise.\n+\t(make_boyer_moore_horspool_searcher): Likewise.\n+\t* testsuite/20_util/function_objects/searchers.cc: New.\n+\n 2016-09-12  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* testsuite/22_locale/codecvt/codecvt_utf16/requirements/1.cc:"}, {"sha": "3f0c1a8b2ef1184c8f1a5d80cd05758138021bb0", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82dfb8d4e4292c1faab743ada2051a432f68ff6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82dfb8d4e4292c1faab743ada2051a432f68ff6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=f82dfb8d4e4292c1faab743ada2051a432f68ff6", "patch": "@@ -58,6 +58,13 @@\n #include <bits/functional_hash.h>\n #include <bits/invoke.h>\n \n+#if __cplusplus > 201402L\n+#include <unordered_map>\n+#include <vector>\n+#include <array>\n+#include <bits/stl_algo.h>\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -2197,6 +2204,308 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n       return _Not_fn<std::decay_t<_Fn>>{std::forward<_Fn>(__fn)};\n     }\n \n+  // Searchers\n+\n+  template<typename _ForwardIterator1, typename _BinaryPredicate = equal_to<>>\n+    class default_searcher\n+    {\n+    public:\n+      default_searcher(_ForwardIterator1 __pat_first,\n+\t\t       _ForwardIterator1 __pat_last,\n+\t\t       _BinaryPredicate __pred = _BinaryPredicate())\n+      : _M_m(__pat_first, __pat_last, std::move(__pred))\n+      { }\n+\n+      template<typename _ForwardIterator2>\n+\t_ForwardIterator2\n+\toperator()(_ForwardIterator2 __first, _ForwardIterator2 __last) const\n+\t{\n+\t  return std::search(__first, __last,\n+\t\t\t     std::get<0>(_M_m), std::get<1>(_M_m),\n+\t\t\t     std::get<2>(_M_m));\n+\t}\n+\n+    private:\n+      std::tuple<_ForwardIterator1, _ForwardIterator1, _BinaryPredicate> _M_m;\n+    };\n+\n+  template<typename _Key, typename _Tp, typename _Hash, typename _Pred>\n+    struct __boyer_moore_map_base\n+    {\n+      template<typename _RAIter>\n+\t__boyer_moore_map_base(_RAIter __pat, size_t __patlen,\n+\t\t\t       _Hash&& __hf, _Pred&& __pred)\n+\t: _M_bad_char{ __patlen, std::move(__hf), std::move(__pred) }\n+\t{\n+\t  if (__patlen > 0)\n+\t    for (__diff_type __i = 0; __i < __patlen - 1; ++__i)\n+\t      _M_bad_char[__pat[__i]] = __patlen - 1 - __i;\n+\t}\n+\n+      using __diff_type = _Tp;\n+\n+      __diff_type\n+      _M_lookup(_Key __key, __diff_type __not_found) const\n+      {\n+\tauto __iter = _M_bad_char.find(__key);\n+\tif (__iter == _M_bad_char.end())\n+\t  return __not_found;\n+\treturn __iter->second;\n+      }\n+\n+      _Pred\n+      _M_pred() const { return _M_bad_char.key_eq(); }\n+\n+      std::unordered_map<_Key, _Tp, _Hash, _Pred> _M_bad_char;\n+    };\n+\n+  template<typename _Tp, size_t _Len, typename _Pred>\n+    struct __boyer_moore_array_base\n+    {\n+      template<typename _RAIter, typename _Unused>\n+\t__boyer_moore_array_base(_RAIter __pat, size_t __patlen,\n+\t\t\t\t _Unused&&, _Pred&& __pred)\n+\t: _M_bad_char{ std::array<_Tp, _Len>{}, std::move(__pred) }\n+\t{\n+\t  std::get<0>(_M_bad_char).fill(__patlen);\n+\t  if (__patlen > 0)\n+\t    for (__diff_type __i = 0; __i < __patlen - 1; ++__i)\n+\t      {\n+\t\tauto __ch = __pat[__i];\n+\t\tusing _UCh = std::make_unsigned_t<decltype(__ch)>;\n+\t\tauto __uch = static_cast<_UCh>(__ch);\n+\t\tstd::get<0>(_M_bad_char)[__uch] = __patlen - 1 - __i;\n+\t      }\n+\t}\n+\n+      using __diff_type = _Tp;\n+\n+      template<typename _Key>\n+\t__diff_type\n+\t_M_lookup(_Key __key, __diff_type __not_found) const\n+\t{\n+\t  auto __ukey = static_cast<std::make_unsigned_t<_Key>>(__key);\n+\t  if (__ukey >= _Len)\n+\t    return __not_found;\n+\t  return std::get<0>(_M_bad_char)[__ukey];\n+\t}\n+\n+      const _Pred&\n+      _M_pred() const { return std::get<1>(_M_bad_char); }\n+\n+      std::tuple<std::array<_Tp, _Len>, _Pred> _M_bad_char;\n+    };\n+\n+  template<typename _Pred>\n+    struct __is_std_equal_to : std::false_type { };\n+\n+  template<>\n+    struct __is_std_equal_to<std::equal_to<void>> : std::true_type { };\n+\n+  // Use __boyer_moore_array_base when pattern consists of narrow characters\n+  // and uses std::equal_to as the predicate.\n+  template<typename _RAIter, typename _Hash, typename _Pred,\n+           typename _Val = typename iterator_traits<_RAIter>::value_type,\n+\t   typename _Diff = typename iterator_traits<_RAIter>::difference_type>\n+    using __boyer_moore_base_t\n+      = std::conditional_t<sizeof(_Val) == 1 && is_integral<_Val>::value\n+\t\t\t   && __is_std_equal_to<_Pred>::value,\n+\t\t\t   __boyer_moore_array_base<_Diff, 256, _Pred>,\n+\t\t\t   __boyer_moore_map_base<_Val, _Diff, _Hash, _Pred>>;\n+\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = std::equal_to<>>\n+    class boyer_moore_searcher\n+    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>\n+    {\n+      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;\n+      using typename _Base::__diff_type;\n+\n+    public:\n+      boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,\n+\t\t\t   _Hash __hf = _Hash(),\n+\t\t\t   _BinaryPredicate __pred = _BinaryPredicate());\n+\n+      template<typename _RandomAccessIterator2>\n+\t_RandomAccessIterator2\n+\toperator()(_RandomAccessIterator2 __first,\n+\t\t   _RandomAccessIterator2 __last) const;\n+\n+    private:\n+      bool\n+      _M_is_prefix(_RAIter __word, __diff_type __len,\n+\t\t   __diff_type __pos)\n+      {\n+\tconst auto& __pred = this->_M_pred();\n+\t__diff_type __suffixlen = __len - __pos;\n+\tfor (__diff_type __i = 0; __i < __suffixlen; ++__i)\n+\t  if (!__pred(__word[__i], __word[__pos + __i]))\n+\t    return false;\n+\treturn true;\n+      }\n+\n+      __diff_type\n+      _M_suffix_length(_RAIter __word, __diff_type __len,\n+\t\t       __diff_type __pos)\n+      {\n+\tconst auto& __pred = this->_M_pred();\n+\t__diff_type __i = 0;\n+\twhile (__pred(__word[__pos - __i], __word[__len - 1 - __i])\n+\t       && __i < __pos)\n+\t  {\n+\t    ++__i;\n+\t  }\n+\treturn __i;\n+      }\n+\n+      template<typename _Tp>\n+\t__diff_type\n+\t_M_bad_char_shift(_Tp __c) const\n+\t{ return this->_M_lookup(__c, _M_pat_end - _M_pat); }\n+\n+      _RAIter _M_pat;\n+      _RAIter _M_pat_end;\n+      std::vector<__diff_type> _M_good_suffix;\n+    };\n+\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = std::equal_to<>>\n+    class boyer_moore_horspool_searcher\n+    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>\n+    {\n+      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;\n+      using typename _Base::__diff_type;\n+\n+    public:\n+      boyer_moore_horspool_searcher(_RAIter __pat,\n+\t\t\t\t    _RAIter __pat_end,\n+\t\t\t\t    _Hash __hf = _Hash(),\n+\t\t\t\t    _BinaryPredicate __pred\n+\t\t\t\t    = _BinaryPredicate())\n+      : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),\n+\t_M_pat(__pat), _M_pat_end(__pat_end)\n+      { }\n+\n+      template<typename _RandomAccessIterator2>\n+\t_RandomAccessIterator2\n+\toperator()(_RandomAccessIterator2 __first,\n+\t\t   _RandomAccessIterator2 __last) const\n+\t{\n+\t  const auto& __pred = this->_M_pred();\n+\t  auto __patlen = _M_pat_end - _M_pat;\n+\t  if (__patlen == 0)\n+\t    return __first;\n+\t  auto __len = __last - __first;\n+\t  while (__len >= __patlen)\n+\t    {\n+\t      for (auto __scan = __patlen - 1;\n+\t\t   __pred(__first[__scan], _M_pat[__scan]); --__scan)\n+\t\tif (__scan == 0)\n+\t\t  return __first;\n+\t      auto __shift = _M_bad_char_shift(__first[__patlen - 1]);\n+\t      __len -= __shift;\n+\t      __first += __shift;\n+\t    }\n+\t  return __last;\n+\t}\n+\n+    private:\n+      template<typename _Tp>\n+\t__diff_type\n+\t_M_bad_char_shift(_Tp __c) const\n+\t{ return this->_M_lookup(__c, _M_pat_end - _M_pat); }\n+\n+      _RAIter _M_pat;\n+      _RAIter _M_pat_end;\n+    };\n+\n+  /// Generator function for default_searcher\n+  template<typename _ForwardIterator,\n+\t   typename _BinaryPredicate = std::equal_to<>>\n+    inline default_searcher<_ForwardIterator, _BinaryPredicate>\n+    make_default_searcher(_ForwardIterator __pat_first,\n+\t\t\t  _ForwardIterator __pat_last,\n+\t\t\t  _BinaryPredicate __pred = _BinaryPredicate())\n+    { return { __pat_first, __pat_last, __pred }; }\n+\n+  /// Generator function for boyer_moore_searcher\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = equal_to<>>\n+    inline boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>\n+    make_boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,\n+\t\t\t      _Hash __hf = _Hash(),\n+\t\t\t      _BinaryPredicate __pred = _BinaryPredicate())\n+    { return { __pat_first, __pat_last, std::move(__hf), std::move(__pred) }; }\n+\n+  /// Generator function for boyer_moore_horspool_searcher\n+  template<typename _RAIter, typename _Hash\n+\t     = std::hash<typename std::iterator_traits<_RAIter>::value_type>,\n+\t   typename _BinaryPredicate = equal_to<>>\n+    inline boyer_moore_horspool_searcher<_RAIter, _Hash, _BinaryPredicate>\n+    make_boyer_moore_horspool_searcher(_RAIter __pat_first, _RAIter __pat_last,\n+\t\t\t\t       _Hash __hf = _Hash(),\n+\t\t\t\t       _BinaryPredicate __pred\n+\t\t\t\t       = _BinaryPredicate())\n+    { return { __pat_first, __pat_last, std::move(__hf), std::move(__pred) }; }\n+\n+  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>\n+    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::\n+    boyer_moore_searcher(_RAIter __pat, _RAIter __pat_end,\n+\t\t\t _Hash __hf, _BinaryPredicate __pred)\n+    : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),\n+      _M_pat(__pat), _M_pat_end(__pat_end), _M_good_suffix(__pat_end - __pat)\n+    {\n+      auto __patlen = __pat_end - __pat;\n+      if (__patlen == 0)\n+\treturn;\n+      __diff_type __last_prefix = __patlen - 1;\n+      for (__diff_type __p = __patlen - 1; __p >= 0; --__p)\n+\t{\n+\t  if (_M_is_prefix(__pat, __patlen, __p + 1))\n+\t    __last_prefix = __p + 1;\n+\t  _M_good_suffix[__p] = __last_prefix + (__patlen - 1 - __p);\n+\t}\n+      for (__diff_type __p = 0; __p < __patlen - 1; ++__p)\n+\t{\n+\t  auto __slen = _M_suffix_length(__pat, __patlen, __p);\n+\t  auto __pos = __patlen - 1 - __slen;\n+\t  if (!__pred(__pat[__p - __slen], __pat[__pos]))\n+\t    _M_good_suffix[__pos] = __patlen - 1 - __p + __slen;\n+\t}\n+    }\n+\n+  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>\n+  template<typename _RandomAccessIterator2>\n+    _RandomAccessIterator2\n+    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::\n+    operator()(_RandomAccessIterator2 __first,\n+\t       _RandomAccessIterator2 __last) const\n+    {\n+      auto __patlen = _M_pat_end - _M_pat;\n+      if (__patlen == 0)\n+\treturn __first;\n+      const auto& __pred = this->_M_pred();\n+      __diff_type __i = __patlen - 1;\n+      auto __stringlen = __last - __first;\n+      while (__i < __stringlen)\n+\t{\n+\t  __diff_type __j = __patlen - 1;\n+\t  while (__j >= 0 && __pred(__first[__i], _M_pat[__j]))\n+\t    {\n+\t      --__i;\n+\t      --__j;\n+\t    }\n+\t  if (__j < 0)\n+\t    return __first + __i + 1;\n+\t  __i += std::max(_M_bad_char_shift(__first[__i]),\n+\t\t\t  _M_good_suffix[__j]);\n+\t}\n+      return __last;\n+    }\n+\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "62a636a69f20b41a4ecf61fe5b87363b9b4c4ce3", "filename": "libstdc++-v3/testsuite/20_util/function_objects/searchers.cc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82dfb8d4e4292c1faab743ada2051a432f68ff6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fsearchers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82dfb8d4e4292c1faab743ada2051a432f68ff6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fsearchers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fsearchers.cc?ref=f82dfb8d4e4292c1faab743ada2051a432f68ff6", "patch": "@@ -0,0 +1,138 @@\n+// Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+\n+#include <functional>\n+#include <cstring>\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+# include <cwchar>\n+#endif\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+using std::make_default_searcher;\n+using std::make_boyer_moore_searcher;\n+using std::make_boyer_moore_horspool_searcher;\n+\n+void\n+test01()\n+{\n+  const char s[] = { 'a', (char)-97, 'a', '\\0' };\n+  const char* needles[] = {\n+    s, \"\", \"a\", \"aa\", \"aaa\", \"ab\", \"cd\", \"abcd\", \"abcdabcd\", \"abcabcd\"\n+  };\n+  const char* haystacks[] = {\n+    s, \"\", \"a\", \"aa\", \"aaa\", \"ab\", \"cd\", \"abcd\", \"abcdabcd\", \"abcabcd\",\n+    \"aaaaaaa\", \"aabaa\", \"aaacab\", \"cdabcdab\", \"abcdabcd\", \"xyzabcdxyz\"\n+  };\n+\n+  for (auto n : needles)\n+  {\n+    auto ne = n + std::strlen(n);\n+    auto d = make_default_searcher(n, ne);\n+    auto bm = make_boyer_moore_searcher(n, ne);\n+    auto bmh = make_boyer_moore_horspool_searcher(n, ne);\n+    for (auto h : haystacks)\n+    {\n+      auto he = h + std::strlen(h);\n+      auto res = std::search(h, he, n, ne);\n+      auto d_res = d(h, he);\n+      VERIFY( d_res == res );\n+      auto bm_res = bm(h, he);\n+      VERIFY( bm_res == res );\n+      auto bmh_res = bmh(h, he);\n+      VERIFY( bmh_res == res );\n+    }\n+  }\n+}\n+\n+void\n+test02()\n+{\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  const wchar_t s[] = { L'a', (wchar_t)-97, L'a', L'\\0' };\n+  const wchar_t* needles[] = {\n+    s, L\"\", L\"a\", L\"aa\", L\"aaa\", L\"ab\", L\"cd\", L\"abcd\", L\"abcdabcd\", L\"abcabcd\"\n+  };\n+  const wchar_t* haystacks[] = {\n+    s, L\"\", L\"a\", L\"aa\", L\"aaa\", L\"ab\", L\"cd\", L\"abcd\", L\"abcdabcd\", L\"abcabcd\",\n+    L\"aaaaaaa\", L\"aabaa\", L\"aaacab\", L\"cdabcdab\", L\"abcdabcd\", L\"xyzabcdxyz\"\n+  };\n+\n+  for (auto n : needles)\n+  {\n+    auto ne = n + std::wcslen(n);\n+    auto d = make_default_searcher(n, ne);\n+    auto bm = make_boyer_moore_searcher(n, ne);\n+    auto bmh = make_boyer_moore_horspool_searcher(n, ne);\n+    for (auto h : haystacks)\n+    {\n+      auto he = h + std::wcslen(h);\n+      auto res = std::search(h, he, n, ne);\n+      auto d_res = d(h, he);\n+      VERIFY( d_res == res );\n+      auto bm_res = bm(h, he);\n+      VERIFY( bm_res == res );\n+      auto bmh_res = bmh(h, he);\n+      VERIFY( bmh_res == res );\n+    }\n+  }\n+#endif\n+}\n+\n+void\n+test03()\n+{\n+  // custom predicate\n+  struct\n+  {\n+    static unsigned char\n+    norm(unsigned char c) { return std::isalnum(c) ? c : '#'; }\n+\n+    // equality\n+    bool operator()(char l, char r) const { return norm(l) == norm(r); }\n+\n+    // hash\n+    std::size_t operator()(char c) const { return std::hash<char>{}(norm(c)); }\n+  } eq;\n+\n+  const char* needle = \" foo 123 \";\n+  const char* haystack = \"*****foo*123******\";\n+  const char* ne = needle + std::strlen(needle);\n+  const char* he = haystack + std::strlen(haystack);\n+\n+  auto d = make_default_searcher(needle, ne, eq);\n+  auto bm = make_boyer_moore_searcher(needle, ne, eq, eq);\n+  auto bmh = make_boyer_moore_horspool_searcher(needle, ne, eq, eq);\n+\n+  auto res = std::search(haystack, he, needle, ne, eq);\n+  auto d_res = d(haystack, he);\n+  VERIFY( d_res == res );\n+  auto bm_res = bm(haystack, he);\n+  VERIFY( bm_res == res );\n+  auto bmh_res = bmh(haystack, he);\n+  VERIFY( bmh_res == res );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}