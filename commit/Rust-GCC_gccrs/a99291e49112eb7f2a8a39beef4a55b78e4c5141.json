{"sha": "a99291e49112eb7f2a8a39beef4a55b78e4c5141", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk5MjkxZTQ5MTEyZWI3ZjJhOGEzOWJlZWY0YTU1Yjc4ZTRjNTE0MQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-11-13T12:50:37Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-11-13T12:50:37Z"}, "message": "don't emit debug sections until they are required\n\ngcc:\n\n\t* dwarf2out.c (macinfo_entry): New struct.\n\t(output_comp_unit): Emit the section start label here and flag that we\n\twill emit an info section.\n\t(dwarf2out_start_source_file): Save data in a macinfo entry rather than\n\temitting directly.\n\t(dwarf2out_end_source_file): Likewise.\n\t(dwarf2out_define): Likewise.\n\t(dwarf2out_undef): Likewise.\n\t(output_macinfo): New.\n\t(dwarf2out_init): Do not emit debug section switches here, allocate a\n\tvec for macinfo, when required.\n\t(dwarf2out_finish): First switch to debug_abbrev_section here.\n\tdebug_line_section,  debug_macinfo_section, Likewise.  \n\tCheck that the pubtypes table has at least one unpruned entry before\n\ttrying to emit it.\n\nFrom-SVN: r166704", "tree": {"sha": "35512607cf06e5b5845e20b30e999f543e51cf78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35512607cf06e5b5845e20b30e999f543e51cf78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a99291e49112eb7f2a8a39beef4a55b78e4c5141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a99291e49112eb7f2a8a39beef4a55b78e4c5141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a99291e49112eb7f2a8a39beef4a55b78e4c5141", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a99291e49112eb7f2a8a39beef4a55b78e4c5141/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0f20be4d0ca67fa82f1060bd97b5b2f3b81f3ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0f20be4d0ca67fa82f1060bd97b5b2f3b81f3ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0f20be4d0ca67fa82f1060bd97b5b2f3b81f3ec"}], "stats": {"total": 181, "additions": 143, "deletions": 38}, "files": [{"sha": "b093e5461de9906e33526c90c9171c041798dc1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99291e49112eb7f2a8a39beef4a55b78e4c5141/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99291e49112eb7f2a8a39beef4a55b78e4c5141/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a99291e49112eb7f2a8a39beef4a55b78e4c5141", "patch": "@@ -1,3 +1,21 @@\n+2010-11-13  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* dwarf2out.c (macinfo_entry): New struct.\n+\t(output_comp_unit): Emit the section start label here and flag that we\n+\twill emit an info section.\n+\t(dwarf2out_start_source_file): Save data in a macinfo entry rather than\n+\temitting directly.\n+\t(dwarf2out_end_source_file): Likewise.\n+\t(dwarf2out_define): Likewise.\n+\t(dwarf2out_undef): Likewise.\n+\t(output_macinfo): New.\n+\t(dwarf2out_init): Do not emit debug section switches here, allocate a\n+\tvec for macinfo, when required.\n+\t(dwarf2out_finish): First switch to debug_abbrev_section here.\n+\tdebug_line_section,  debug_macinfo_section, Likewise.  \n+\tCheck that the pubtypes table has at least one unpruned entry before\n+\ttrying to emit it.\n+\n 2010-10-30  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR c/20385"}, {"sha": "144c28624223c51ec72e19a708b48b3027e7adc4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 125, "deletions": 38, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a99291e49112eb7f2a8a39beef4a55b78e4c5141/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a99291e49112eb7f2a8a39beef4a55b78e4c5141/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a99291e49112eb7f2a8a39beef4a55b78e4c5141", "patch": "@@ -5760,6 +5760,18 @@ struct GTY(()) dw_ranges_struct {\n   int num;\n };\n \n+/* A structure to hold a macinfo entry.  */\n+\n+typedef struct GTY(()) macinfo_struct {\n+  unsigned HOST_WIDE_INT code;\n+  unsigned HOST_WIDE_INT lineno;\n+  const char *info;\n+}\n+macinfo_entry;\n+\n+DEF_VEC_O(macinfo_entry);\n+DEF_VEC_ALLOC_O(macinfo_entry, gc);\n+\n struct GTY(()) dw_ranges_by_label_struct {\n   const char *begin;\n   const char *end;\n@@ -5989,6 +6001,10 @@ static GTY(()) unsigned separate_line_info_table_in_use;\n    line_info_table.  */\n #define LINE_INFO_TABLE_INCREMENT 1024\n \n+/* A flag to tell pubnames/types export if there is an info section to\n+   refer to.  */\n+static bool info_section_emitted;\n+\n /* A pointer to the base of a table that contains a list of publicly\n    accessible names.  */\n static GTY (()) VEC (pubname_entry, gc) *  pubname_table;\n@@ -5997,6 +6013,10 @@ static GTY (()) VEC (pubname_entry, gc) *  pubname_table;\n    accessible types.  */\n static GTY (()) VEC (pubname_entry, gc) * pubtype_table;\n \n+/* A pointer to the base of a table that contains a list of macro\n+   defines/undefines (and file start/end markers).  */\n+static GTY (()) VEC (macinfo_entry, gc) * macinfo_table;\n+\n /* Array of dies for which we should generate .debug_arange info.  */\n static GTY((length (\"arange_table_allocated\"))) dw_die_ref *arange_table;\n \n@@ -11263,7 +11283,11 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n       switch_to_section (get_section (secname, SECTION_DEBUG, NULL));\n     }\n   else\n-    switch_to_section (debug_info_section);\n+    {\n+      switch_to_section (debug_info_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, debug_info_section_label);\n+      info_section_emitted = true;\n+    }\n \n   /* Output debugging information.  */\n   output_compilation_unit_header ();\n@@ -21666,14 +21690,11 @@ dwarf2out_start_source_file (unsigned int lineno, const char *filename)\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n-      int file_num = maybe_emit_file (lookup_filename (filename));\n-\n-      switch_to_section (debug_macinfo_section);\n-      dw2_asm_output_data (1, DW_MACINFO_start_file, \"Start new file\");\n-      dw2_asm_output_data_uleb128 (lineno, \"Included from line number %d\",\n-\t\t\t\t   lineno);\n-\n-      dw2_asm_output_data_uleb128 (file_num, \"file %s\", filename);\n+      macinfo_entry e;\n+      e.code = DW_MACINFO_start_file;\n+      e.lineno = lineno;\n+      e.info = xstrdup (filename);\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n     }\n }\n \n@@ -21688,8 +21709,11 @@ dwarf2out_end_source_file (unsigned int lineno ATTRIBUTE_UNUSED)\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n-      switch_to_section (debug_macinfo_section);\n-      dw2_asm_output_data (1, DW_MACINFO_end_file, \"End file\");\n+      macinfo_entry e;\n+      e.code = DW_MACINFO_end_file;\n+      e.lineno = lineno;\n+      e.info = NULL;\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n     }\n }\n \n@@ -21703,10 +21727,11 @@ dwarf2out_define (unsigned int lineno ATTRIBUTE_UNUSED,\n {\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n-      switch_to_section (debug_macinfo_section);\n-      dw2_asm_output_data (1, DW_MACINFO_define, \"Define macro\");\n-      dw2_asm_output_data_uleb128 (lineno, \"At line number %d\", lineno);\n-      dw2_asm_output_nstring (buffer, -1, \"The macro\");\n+      macinfo_entry e;\n+      e.code = DW_MACINFO_define;\n+      e.lineno = lineno;\n+      e.info = xstrdup (buffer);;\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n     }\n }\n \n@@ -21720,10 +21745,58 @@ dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,\n {\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n-      switch_to_section (debug_macinfo_section);\n-      dw2_asm_output_data (1, DW_MACINFO_undef, \"Undefine macro\");\n-      dw2_asm_output_data_uleb128 (lineno, \"At line number %d\", lineno);\n-      dw2_asm_output_nstring (buffer, -1, \"The macro\");\n+      macinfo_entry e;\n+      e.code = DW_MACINFO_undef;\n+      e.lineno = lineno;\n+      e.info = xstrdup (buffer);;\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+    }\n+}\n+\n+static void\n+output_macinfo (void)\n+{\n+  unsigned i;\n+  unsigned long length = VEC_length (macinfo_entry, macinfo_table);\n+  macinfo_entry *ref;\n+\n+  if (! length)\n+    return;\n+\n+  for (i = 0; VEC_iterate (macinfo_entry, macinfo_table, i, ref); i++)\n+    {\n+      switch (ref->code)\n+\t{\n+\t  case DW_MACINFO_start_file:\n+\t    {\n+\t      int file_num = maybe_emit_file (lookup_filename (ref->info));\n+\t      dw2_asm_output_data (1, DW_MACINFO_start_file, \"Start new file\");\n+\t      dw2_asm_output_data_uleb128 \n+\t\t\t(ref->lineno, \"Included from line number %lu\", \n+\t\t\t \t\t\t(unsigned long)ref->lineno);\n+\t      dw2_asm_output_data_uleb128 (file_num, \"file %s\", ref->info);\n+\t    }\n+\t    break;\n+\t  case DW_MACINFO_end_file:\n+\t    dw2_asm_output_data (1, DW_MACINFO_end_file, \"End file\");\n+\t    break;\n+\t  case DW_MACINFO_define:\n+\t    dw2_asm_output_data (1, DW_MACINFO_define, \"Define macro\");\n+\t    dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\", \n+\t\t\t \t\t\t(unsigned long)ref->lineno);\n+\t    dw2_asm_output_nstring (ref->info, -1, \"The macro\");\n+\t    break;\n+\t  case DW_MACINFO_undef:\n+\t    dw2_asm_output_data (1, DW_MACINFO_undef, \"Undefine macro\");\n+\t    dw2_asm_output_data_uleb128 (ref->lineno, \"At line number %lu\",\n+\t\t\t \t\t\t(unsigned long)ref->lineno);\n+\t    dw2_asm_output_nstring (ref->info, -1, \"The macro\");\n+\t    break;\n+\t  default:\n+\t   fprintf (asm_out_file, \"%s unrecognized macinfo code %lu\\n\",\n+\t     ASM_COMMENT_START, (unsigned long)ref->code);\n+\t  break;\n+\t}\n     }\n }\n \n@@ -21815,20 +21888,11 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \t\t\t       DEBUG_LINE_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (ranges_section_label,\n \t\t\t       DEBUG_RANGES_SECTION_LABEL, 0);\n-  switch_to_section (debug_abbrev_section);\n-  ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);\n-  switch_to_section (debug_info_section);\n-  ASM_OUTPUT_LABEL (asm_out_file, debug_info_section_label);\n-  switch_to_section (debug_line_section);\n-  ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);\n+  ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,\n+\t\t\t       DEBUG_MACINFO_SECTION_LABEL, 0);\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-    {\n-      switch_to_section (debug_macinfo_section);\n-      ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,\n-\t\t\t\t   DEBUG_MACINFO_SECTION_LABEL, 0);\n-      ASM_OUTPUT_LABEL (asm_out_file, macinfo_section_label);\n-    }\n+    macinfo_table = VEC_alloc (macinfo_entry, gc, 64);\n \n   switch_to_section (text_section);\n   ASM_OUTPUT_LABEL (asm_out_file, text_section_label);\n@@ -23042,11 +23106,12 @@ dwarf2out_finish (const char *filename)\n   htab_delete (comdat_type_table);\n \n   /* Output the main compilation unit if non-empty or if .debug_macinfo\n-     has been emitted.  */\n+     will be emitted.  */\n   output_comp_unit (comp_unit_die (), debug_info_level >= DINFO_LEVEL_VERBOSE);\n \n   /* Output the abbreviation table.  */\n   switch_to_section (debug_abbrev_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);\n   output_abbrev_section ();\n \n   /* Output location list section if necessary.  */\n@@ -23063,6 +23128,7 @@ dwarf2out_finish (const char *filename)\n   /* Output public names table if necessary.  */\n   if (!VEC_empty (pubname_entry, pubname_table))\n     {\n+      gcc_assert (info_section_emitted);\n       switch_to_section (debug_pubnames_section);\n       output_pubnames (pubname_table);\n     }\n@@ -23073,8 +23139,27 @@ dwarf2out_finish (const char *filename)\n      simply won't look for the section.  */\n   if (!VEC_empty (pubname_entry, pubtype_table))\n     {\n-      switch_to_section (debug_pubtypes_section);\n-      output_pubnames (pubtype_table);\n+      bool empty = false;\n+      \n+      if (flag_eliminate_unused_debug_types)\n+\t{\n+\t  /* The pubtypes table might be emptied by pruning unused items.  */\n+\t  unsigned i;\n+\t  pubname_ref p;\n+\t  empty = true;\n+\t  FOR_EACH_VEC_ELT (pubname_entry, pubtype_table, i, p)\n+\t    if (p->die->die_offset != 0)\n+\t      {\n+\t\tempty = false;\n+\t\tbreak;\n+\t      }\n+\t}\n+      if (!empty)\n+\t{\n+\t  gcc_assert (info_section_emitted);\n+\t  switch_to_section (debug_pubtypes_section);\n+\t  output_pubnames (pubtype_table);\n+\t}\n     }\n \n   /* Output direct and virtual call tables if necessary.  */\n@@ -23111,16 +23196,18 @@ dwarf2out_finish (const char *filename)\n      .debug_info section.  IRIX 6.5 `nm' will then complain when\n      examining the file.  This is done late so that any filenames\n      used by the debug_info section are marked as 'used'.  */\n+  switch_to_section (debug_line_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);\n   if (! DWARF2_ASM_LINE_DEBUG_INFO)\n-    {\n-      switch_to_section (debug_line_section);\n-      output_line_info ();\n-    }\n+    output_line_info ();\n \n   /* Have to end the macro section.  */\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n       switch_to_section (debug_macinfo_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, macinfo_section_label);\n+      if (!VEC_empty (macinfo_entry, macinfo_table))\n+        output_macinfo ();\n       dw2_asm_output_data (1, 0, \"End compilation unit\");\n     }\n "}]}