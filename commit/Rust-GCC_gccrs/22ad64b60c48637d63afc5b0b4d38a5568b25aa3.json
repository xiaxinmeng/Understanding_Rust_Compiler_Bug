{"sha": "22ad64b60c48637d63afc5b0b4d38a5568b25aa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJhZDY0YjYwYzQ4NjM3ZDYzYWZjNWIwYjRkMzhhNTU2OGIyNWFhMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-02-04T13:01:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-02-04T13:01:13Z"}, "message": "ipa-inline.c (try_inline): Improve debug output; work on already inline edges too.\n\n\t* ipa-inline.c (try_inline): Improve debug output; work on already\n\tinline edges too.\n\t(cgraph_decide_inlining_incrementally): Indent; improve debug output;\n\tcall try_inline for already inlined edges too when flattening; \n\tinline also functions that make callee growth but overall unit size\n\treduce.\n\nFrom-SVN: r121570", "tree": {"sha": "5663b5a6e6336ac592ef1f5f46fbac6ce0756dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5663b5a6e6336ac592ef1f5f46fbac6ce0756dcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22ad64b60c48637d63afc5b0b4d38a5568b25aa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ad64b60c48637d63afc5b0b4d38a5568b25aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22ad64b60c48637d63afc5b0b4d38a5568b25aa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ad64b60c48637d63afc5b0b4d38a5568b25aa3/comments", "author": null, "committer": null, "parents": [{"sha": "3075a4cd0815b333358a14fd16d326efc5267a8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3075a4cd0815b333358a14fd16d326efc5267a8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3075a4cd0815b333358a14fd16d326efc5267a8d"}], "stats": {"total": 176, "additions": 140, "deletions": 36}, "files": [{"sha": "821430bcd8d7766e6b2880b60346194f512adee6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ad64b60c48637d63afc5b0b4d38a5568b25aa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ad64b60c48637d63afc5b0b4d38a5568b25aa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22ad64b60c48637d63afc5b0b4d38a5568b25aa3", "patch": "@@ -1,3 +1,12 @@\n+2007-02-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (try_inline): Improve debug output; work on already\n+\tinline edges too.\n+\t(cgraph_decide_inlining_incrementally): Indent; improve debug output;\n+\tcall try_inline for already inlined edges too when flattening; \n+\tinline also functions that make callee growth but overall unit size\n+\treduce.\n+\n 2007-02-04  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/m32c/bitops.md, config/m32c/jump.md,"}, {"sha": "5e6a7e68457ae18d651a6cc7f3a2e375ddaf2a31", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 131, "deletions": 36, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22ad64b60c48637d63afc5b0b4d38a5568b25aa3/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22ad64b60c48637d63afc5b0b4d38a5568b25aa3/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=22ad64b60c48637d63afc5b0b4d38a5568b25aa3", "patch": "@@ -1144,7 +1144,16 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n       /* It is first time we see it and we are not in ALWAY_INLINE only\n \t mode yet.  and the function in question is always_inline.  */\n       if (always_inline && mode != INLINE_ALWAYS_INLINE)\n-\tmode = INLINE_ALWAYS_INLINE;\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      indent_to (dump_file, depth);\n+\t      fprintf (dump_file,\n+\t\t       \"Hit cycle in %s, switching to always inline only.\\n\",\n+\t\t       cgraph_node_name (callee));\n+\t    }\n+\t  mode = INLINE_ALWAYS_INLINE;\n+\t}\n       /* Otherwise it is time to give up.  */\n       else\n \t{\n@@ -1170,7 +1179,8 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n \t       cgraph_node_name (e->callee),\n \t       cgraph_node_name (e->caller));\n     }\n-  cgraph_mark_inline (e);\n+  if (e->inline_failed)\n+    cgraph_mark_inline (e);\n \n   /* In order to fully inline always_inline functions at -O0, we need to\n      recurse here, since the inlined functions might not be processed by\n@@ -1189,7 +1199,8 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n    DEPTH is depth of recursion, used only for debug output.  */\n \n static bool\n-cgraph_decide_inlining_incrementally (struct cgraph_node *node, enum inlining_mode mode,\n+cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n+\t\t\t\t      enum inlining_mode mode,\n \t\t\t\t      int depth)\n {\n   struct cgraph_edge *e;\n@@ -1207,7 +1218,10 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, enum inlining_mo\n       && lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \" Flattening %s\\n\", cgraph_node_name (node));\n+\t{\n+\t  indent_to (dump_file, depth);\n+\t  fprintf (dump_file, \"Flattening %s\\n\", cgraph_node_name (node));\n+\t}\n       mode = INLINE_ALL;\n     }\n \n@@ -1216,49 +1230,130 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, enum inlining_mo\n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      if (dump_file && e->callee->local.inlinable\n-\t  && (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t      != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl))))\n+      if (!e->callee->local.disregard_inline_limits\n+\t  && (mode != INLINE_ALL || !e->callee->local.inlinable))\n+\tcontinue;\n+      /* When the edge is already inlined, we just need to recurse into\n+\t it in order to fully flatten the leaves.  */\n+      if (!e->inline_failed && mode == INLINE_ALL)\n \t{\n-\t  fprintf (dump_file, \"  Ignoring %s: SSA form not computed yet.\\n\",\n+          inlined |= try_inline (e, mode, depth);\n+\t  continue;\n+\t}\n+      if (dump_file)\n+\t{\n+\t  indent_to (dump_file, depth);\n+\t  fprintf (dump_file,\n+\t\t   \"Considering to always inline inline candidate %s.\\n\",\n \t\t   cgraph_node_name (e->callee));\n \t}\n-      if ((e->callee->local.disregard_inline_limits\n-\t   || (mode == INLINE_ALL && e->callee->local.inlinable))\n-\t  && e->inline_failed\n-\t  && (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t      == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-\t  && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n-\t  /* ??? It is possible that renaming variable removed the function body\n-\t     in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n-\t  && (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n+      if (cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed))\n \t{\n-\t  inlined |= try_inline (e, mode, depth);\n+\t  if (dump_file)\n+\t    {\n+\t      indent_to (dump_file, depth);\n+\t      fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n+\t    }\n+\t  continue;\n+\t}\n+      if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      indent_to (dump_file, depth);\n+\t      fprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n+\t    }\n+\t  continue;\n \t}\n+      if (!DECL_SAVED_TREE (e->callee->decl) && !e->callee->inline_decl)\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      indent_to (dump_file, depth);\n+\t      fprintf (dump_file,\n+\t\t       \"Not inlining: Function body no longer available.\\n\");\n+\t    }\n+\t  continue;\n+\t}\n+      inlined |= try_inline (e, mode, depth);\n     }\n \n   /* Now do the automatic inlining.  */\n   if (!flag_really_no_inline && mode != INLINE_ALL\n       && mode != INLINE_ALWAYS_INLINE)\n     for (e = node->callees; e; e = e->next_callee)\n-      if (e->callee->local.inlinable\n-\t  && e->inline_failed\n-\t  && !e->callee->local.disregard_inline_limits\n-\t  && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n-\t  && (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t      == gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-\t  && (mode != INLINE_SIZE\n-\t      || (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n-\t          <= e->caller->global.insns))\n-\t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n-\t    \t\t\t         false)\n-\t  && (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n-\t{\n-\t  if (cgraph_default_inline_p (e->callee, &failed_reason))\n-\t    inlined |= try_inline (e, mode, depth);\n-\t  else if (!flag_unit_at_a_time)\n-\t    e->inline_failed = failed_reason;\n-\t}\n+      {\n+\tif (!e->callee->local.inlinable\n+\t    || !e->inline_failed\n+\t    || e->callee->local.disregard_inline_limits)\n+\t  continue;\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"Considering inline candidate %s.\\n\",\n+\t\t   cgraph_node_name (e->callee));\n+\tif (cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed))\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file, \"Not inlining: recursive call.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t    != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n+\t/* When the function body would grow and inlining the function won't\n+\t   elliminate the need for offline copy of the function, don't inline.\n+\t */\n+\tif (mode == INLINE_SIZE\n+\t    && (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n+\t\t> e->caller->global.insns)\n+\t    && cgraph_estimate_growth (e->callee) > 0)\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file,\n+\t\t\t \"Not inlining: code size would grow by %i insns.\\n\",\n+\t\t\t cgraph_estimate_size_after_inlining (1, e->caller,\n+\t\t\t\t\t\t\t      e->callee)\n+\t\t\t - e->caller->global.insns);\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n+\t\t\t\t        false))\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file, \"Not inlining: %s.\\n\", e->inline_failed);\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (!DECL_SAVED_TREE (e->callee->decl) && !e->callee->inline_decl)\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file,\n+\t\t\t \"Not inlining: Function body no longer available.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (cgraph_default_inline_p (e->callee, &failed_reason))\n+\t  inlined |= try_inline (e, mode, depth);\n+\telse if (!flag_unit_at_a_time)\n+\t  e->inline_failed = failed_reason;\n+      }\n   node->aux = (void *)(size_t) old_mode;\n   return inlined;\n }"}]}