{"sha": "c19de7aa687c199eb6e9e9a76bf733d74cfacd2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE5ZGU3YWE2ODdjMTk5ZWI2ZTllOWE3NmJmNzMzZDc0Y2ZhY2QyYg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2003-03-10T18:03:17Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2003-03-10T18:03:17Z"}, "message": "rs6000.h (DWARF_FRAME_REGISTERS): Define.\n\n2003-03-10  Aldy Hernandez  <aldyh@redhat.com>\n\n        * config/rs6000/rs6000.h (DWARF_FRAME_REGISTERS): Define.\n        (rs6000_stack_t): Add spe_64bit_regs_used.\n\n        * config/rs6000/rs6000.c (rs6000_stack_info): Calculate\n        spe_64bit_regs_used, and use it to determine the size of the\n        frame.\n        (spe_func_has_64bit_regs_p): New.\n        (spe_synthesize_frame_save): New.\n        (rs6000_frame_related): Handle SPE synthetic registers.\n        (rs6000_emit_prologue): Only save in 64-bits if the function used\n        any registers in 64-bit mode.\n        (rs6000_emit_epilogue): Same, but for restore.\n\nFrom-SVN: r64102", "tree": {"sha": "3e827ced6eb53af1d844b2d1a61baa5b23a9ae4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e827ced6eb53af1d844b2d1a61baa5b23a9ae4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29ad9694303d826163fd471c5e4bfc2fe3391481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ad9694303d826163fd471c5e4bfc2fe3391481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ad9694303d826163fd471c5e4bfc2fe3391481"}], "stats": {"total": 172, "additions": 156, "deletions": 16}, "files": [{"sha": "8ac10a2b98611d6aef2611eca9eb0a07adf6b013", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c19de7aa687c199eb6e9e9a76bf733d74cfacd2b", "patch": "@@ -1,3 +1,18 @@\n+2003-03-10  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/rs6000/rs6000.h (DWARF_FRAME_REGISTERS): Define.\n+        (rs6000_stack_t): Add spe_64bit_regs_used.\n+\n+        * config/rs6000/rs6000.c (rs6000_stack_info): Calculate\n+        spe_64bit_regs_used, and use it to determine the size of the\n+        frame.\n+        (spe_func_has_64bit_regs_p): New.\n+        (spe_synthesize_frame_save): New.\n+        (rs6000_frame_related): Handle SPE synthetic registers.\n+        (rs6000_emit_prologue): Only save in 64-bits if the function used\n+        any registers in 64-bit mode.\n+        (rs6000_emit_epilogue): Same, but for restore.\n+\n 2003-03-10  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.h (enum floating_point_type): Delete.  Replace with..."}, {"sha": "91c91ad7ba4a9015f09539a937a183f8c78e8ec2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 136, "deletions": 16, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c19de7aa687c199eb6e9e9a76bf733d74cfacd2b", "patch": "@@ -175,6 +175,8 @@ static rtx rs6000_generate_compare PARAMS ((enum rtx_code));\n static void rs6000_maybe_dead PARAMS ((rtx));\n static void rs6000_emit_stack_tie PARAMS ((void));\n static void rs6000_frame_related PARAMS ((rtx, rtx, HOST_WIDE_INT, rtx, rtx));\n+static rtx spe_synthesize_frame_save PARAMS ((rtx));\n+static bool spe_func_has_64bit_regs_p PARAMS ((void));\n static void emit_frame_save PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t     unsigned int, int, int));\n static rtx gen_frame_mem_offset PARAMS ((enum machine_mode, rtx, int));\n@@ -9134,10 +9136,19 @@ rs6000_stack_info ()\n   enum rs6000_abi abi;\n   int ehrd_size;\n   int total_raw_size;\n+  static int insn_chain_scanned = -1;\n \n   /* Zero all fields portably.  */\n   info = zero_info;\n \n+  if (TARGET_SPE)\n+    {\n+      /* Cache value so we don't rescan instruction chain over and over.  */\n+      if (insn_chain_scanned < 0)\n+\tinsn_chain_scanned = (int) spe_func_has_64bit_regs_p ();\n+      info_ptr->spe_64bit_regs_used = insn_chain_scanned;\n+    }\n+\n   /* Select which calling sequence.  */\n   info_ptr->abi = abi = DEFAULT_ABI;\n \n@@ -9159,12 +9170,13 @@ rs6000_stack_info ()\n      registers live (not the size they are used in), this proves\n      difficult because we'd have to traverse the instruction chain at\n      the right time, taking reload into account.  This is a real pain,\n-     so we opt to save the GPRs in 64-bits always.  Anyone overly\n-     concerned with frame size can fix this.  ;-).\n+     so we opt to save the GPRs in 64-bits always if but one register\n+     gets used in 64-bits.  Otherwise, all the registers in the frame\n+     get saved in 32-bits.\n \n-     So... since we save all GPRs (except the SP) in 64-bits, the\n+     So... since when we save all GPRs (except the SP) in 64-bits, the\n      traditional GP save area will be empty.  */\n-  if (TARGET_SPE_ABI)\n+  if (TARGET_SPE_ABI && info_ptr->spe_64bit_regs_used != 0)\n     info_ptr->gp_size = 0;\n \n   info_ptr->first_fp_reg_save = first_fp_reg_to_save ();\n@@ -9217,7 +9229,9 @@ rs6000_stack_info ()\n \tcontinue;\n \n       /* SPE saves EH registers in 64-bits.  */\n-      ehrd_size = i * (TARGET_SPE_ABI ? UNITS_PER_SPE_WORD : UNITS_PER_WORD);\n+      ehrd_size = i * (TARGET_SPE_ABI\n+\t\t       && info_ptr->spe_64bit_regs_used != 0\n+\t\t       ? UNITS_PER_SPE_WORD : UNITS_PER_WORD);\n     }\n   else\n     ehrd_size = 0;\n@@ -9230,7 +9244,7 @@ rs6000_stack_info ()\n   info_ptr->parm_size    = RS6000_ALIGN (current_function_outgoing_args_size,\n \t\t\t\t\t 8);\n \n-  if (TARGET_SPE_ABI)\n+  if (TARGET_SPE_ABI && info_ptr->spe_64bit_regs_used != 0)\n     info_ptr->spe_gp_size = 8 * (32 - info_ptr->first_gp_reg_save);\n   else\n     info_ptr->spe_gp_size = 0;\n@@ -9290,7 +9304,7 @@ rs6000_stack_info ()\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n       info_ptr->cr_save_offset   = info_ptr->gp_save_offset - info_ptr->cr_size;\n \n-      if (TARGET_SPE_ABI)\n+      if (TARGET_SPE_ABI && info_ptr->spe_64bit_regs_used != 0)\n       {\n         /* Align stack so SPE GPR save area is aligned on a\n            double-word boundary.  */\n@@ -9398,7 +9412,9 @@ rs6000_stack_info ()\n   if (! TARGET_ALTIVEC_ABI || info_ptr->vrsave_mask == 0)\n     info_ptr->vrsave_save_offset = 0;\n \n-  if (! TARGET_SPE_ABI || info_ptr->spe_gp_size == 0)\n+  if (! TARGET_SPE_ABI\n+      || info_ptr->spe_64bit_regs_used == 0\n+      || info_ptr->spe_gp_size == 0)\n     info_ptr->spe_gp_save_offset = 0;\n \n   if (! info_ptr->lr_save_p)\n@@ -9413,6 +9429,39 @@ rs6000_stack_info ()\n   return info_ptr;\n }\n \n+/* Return true if the current function uses any GPRs in 64-bit SIMD\n+   mode.  */\n+\n+static bool\n+spe_func_has_64bit_regs_p ()\n+{\n+  rtx insns, insn;\n+\n+  /* Functions that save and restore all the call-saved registers will\n+     need to save/restore the registers in 64-bits.  */\n+  if (current_function_calls_eh_return\n+      || current_function_calls_setjmp\n+      || current_function_has_nonlocal_goto)\n+    return true;\n+\n+  insns = get_insns ();\n+\n+  for (insn = NEXT_INSN (insns); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\t{\n+\t  rtx i;\n+\n+\t  i = PATTERN (insn);\n+\t  if (GET_CODE (i) == SET\n+\t      && SPE_VECTOR_MODE (GET_MODE (SET_SRC (i))))\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n void\n debug_stack_info (info)\n      rs6000_stack_t *info;\n@@ -10159,13 +10208,81 @@ rs6000_frame_related (insn, reg, val, reg2, rreg)\n     }\n   else\n     abort ();\n-  \n+\n+  if (TARGET_SPE)\n+    real = spe_synthesize_frame_save (real);\n+\n   RTX_FRAME_RELATED_P (insn) = 1;\n   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t\t\treal,\n \t\t\t\t\tREG_NOTES (insn));\n }\n \n+/* Given an SPE frame note, return a PARALLEL of SETs with the\n+   original note, plus a synthetic register save.  */\n+\n+static rtx\n+spe_synthesize_frame_save (real)\n+     rtx real;\n+{\n+  rtx synth, offset, reg, real2;\n+\n+  if (GET_CODE (real) != SET\n+      || GET_MODE (SET_SRC (real)) != V2SImode)\n+    return real;\n+\n+  /* For the SPE, registers saved in 64-bits, get a PARALLEL for their\n+     frame related note.  The parallel contains a set of the register\n+     being saved, and another set to a synthetic register (n+113).\n+     This is so we can differentiate between 64-bit and 32-bit saves.\n+     Words cannot describe this nastiness.  */\n+\n+  if (GET_CODE (SET_DEST (real)) != MEM\n+      || GET_CODE (XEXP (SET_DEST (real), 0)) != PLUS\n+      || GET_CODE (SET_SRC (real)) != REG)\n+    abort ();\n+\n+  /* Transform:\n+       (set (mem (plus (reg x) (const y)))\n+            (reg z))\n+     into:\n+       (set (mem (plus (reg x) (const y+4)))\n+            (reg z+113))\n+  */\n+\n+  real2 = copy_rtx (real);\n+  PUT_MODE (SET_DEST (real2), SImode);\n+  reg = SET_SRC (real2);\n+  real2 = replace_rtx (real2, reg, gen_rtx_REG (SImode, REGNO (reg)));\n+  synth = copy_rtx (real2);\n+\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      offset = XEXP (XEXP (SET_DEST (real2), 0), 1);\n+      real2 = replace_rtx (real2, offset, GEN_INT (INTVAL (offset) + 4));\n+    }\n+\n+  reg = SET_SRC (synth);\n+  /* FIXME: the ABI says REGNO+1200, but this creates a huge hole\n+     in the unwinder tables.  I'm still unsure what to do.  */\n+  synth = replace_rtx (synth, reg,\n+\t\t       gen_rtx_REG (SImode, REGNO (reg) + 113));\n+\n+  offset = XEXP (XEXP (SET_DEST (synth), 0), 1);\n+  synth = replace_rtx (synth, offset,\n+\t\t       GEN_INT (INTVAL (offset)\n+\t\t\t\t+ (BYTES_BIG_ENDIAN ? 0 : 4)));\n+\n+  RTX_FRAME_RELATED_P (synth) = 1;\n+  RTX_FRAME_RELATED_P (real2) = 1;\n+  if (BYTES_BIG_ENDIAN)\n+    real = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, synth, real2));\n+  else\n+    real = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, real2, synth));\n+\n+  return real;\n+}\n+\n /* Returns an insn that has a vrsave set operation with the\n    appropriate CLOBBERs.  */\n \n@@ -10317,14 +10434,15 @@ rs6000_emit_prologue ()\n   int using_store_multiple;\n   HOST_WIDE_INT sp_offset = 0;\n   \n-   if (TARGET_SPE_ABI)\n+   if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n      {\n        reg_mode = V2SImode;\n        reg_size = 8;\n      }\n \n   using_store_multiple = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n-\t\t\t  && !TARGET_SPE_ABI\n+\t\t\t  && (!TARGET_SPE_ABI\n+\t\t\t      || info->spe_64bit_regs_used == 0)\n \t\t\t  && info->first_gp_reg_save < 31);\n   saving_FPRs_inline = (info->first_fp_reg_save == 64\n \t\t\t|| FP_SAVE_INLINE (info->first_fp_reg_save));\n@@ -10510,7 +10628,7 @@ rs6000_emit_prologue ()\n \t    rtx addr, reg, mem;\n \t    reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n \n-\t    if (TARGET_SPE_ABI)\n+\t    if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n \t      {\n \t\tint offset = info->spe_gp_save_offset + sp_offset + 8 * i;\n \t\trtx b;\n@@ -10752,15 +10870,17 @@ rs6000_emit_epilogue (sibcall)\n   int reg_size = TARGET_POWERPC64 ? 8 : 4;\n   int i;\n \n-  if (TARGET_SPE_ABI)\n+  info = rs6000_stack_info ();\n+\n+  if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n     {\n       reg_mode = V2SImode;\n       reg_size = 8;\n     }\n \n-  info = rs6000_stack_info ();\n   using_load_multiple = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n-\t\t\t && !TARGET_SPE_ABI\n+\t\t\t && (!TARGET_SPE_ABI\n+\t\t\t     || info->spe_64bit_regs_used == 0)\n \t\t\t && info->first_gp_reg_save < 31);\n   restoring_FPRs_inline = (sibcall\n \t\t\t   || current_function_calls_eh_return\n@@ -10930,7 +11050,7 @@ rs6000_emit_epilogue (sibcall)\n \t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n \n \t  /* Restore 64-bit quantities for SPE.  */\n-\t  if (TARGET_SPE_ABI)\n+\t  if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n \t    {\n \t      int offset = info->spe_gp_save_offset + sp_offset + 8 * i;\n \t      rtx b;"}, {"sha": "923adfb46c8005dbeb514a165fb5d768c3553c1e", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c19de7aa687c199eb6e9e9a76bf733d74cfacd2b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c19de7aa687c199eb6e9e9a76bf733d74cfacd2b", "patch": "@@ -704,6 +704,10 @@ extern int rs6000_default_long_calls;\n /* This must be included for pre gcc 3.0 glibc compatibility.  */\n #define PRE_GCC3_DWARF_FRAME_REGISTERS 77\n \n+/* Add 32 dwarf columns for synthetic SPE registers.  The SPE\n+   synthetic registers are 113 through 145.  */\n+#define DWARF_FRAME_REGISTERS (FIRST_PSEUDO_REGISTER + 32)\n+\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n \n@@ -1395,6 +1399,7 @@ typedef struct rs6000_stack {\n   int spe_padding_size;\n   int toc_size;\t\t\t/* size to hold TOC if not in save_size */\n   int total_size;\t\t/* total bytes allocated for stack */\n+  int spe_64bit_regs_used;\n } rs6000_stack_t;\n \n /* Define this if pushing a word on the stack"}]}