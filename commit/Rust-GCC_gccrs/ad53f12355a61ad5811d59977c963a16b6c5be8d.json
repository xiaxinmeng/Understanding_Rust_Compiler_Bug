{"sha": "ad53f12355a61ad5811d59977c963a16b6c5be8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ1M2YxMjM1NWE2MWFkNTgxMWQ1OTk3N2M5NjNhMTZiNmM1YmU4ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-05-02T19:03:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-05-02T19:03:56Z"}, "message": "Support fix-it hints that add new lines\n\nPreviously fix-it hints couldn't contain newlines.  This is\ndue to the need to print something user-readable for them\nwithin diagnostic-show-locus, and for handling them within\nedit-context for printing diffs and regenerating content.\n\nThis patch enables limited support for fix-it hints with newlines,\nfor suggesting adding new lines.\nSuch a fix-it hint must have exactly one newline character, at the\nend of the content.  It must be an insertion at the beginning of\na line (so that e.g. fix-its that split a pre-existing line are\nstill rejected).\n\nThey are printed by diagnostic-show-locus with a '+' in the\nleft-hand margin, like this:\n\ntest.c:42:4: note: suggest adding 'break;' here\n+      break;\n     case 'b':\n     ^~~~~~~~~\n\nand the printer injects \"spans\" if the insertion location is not\nnear the primary range of the diagnostic e.g.:\n\ntest.c:4:2: note: unrecognized 'putchar'; suggest including '<stdio.h>'\ntest.c:1:1:\n+#include <stdio.h>\n\ntest.c:4:2:\n  putchar (ch);\n  ^~~~~~~\n\ngcc/ChangeLog:\n\t* diagnostic-show-locus.c\n\t(layout::should_print_annotation_line_p): Make private.\n\t(layout::print_annotation_line): Make private.\n\t(layout::annotation_line_showed_range_p): Make private.\n\t(layout::show_ruler): Make private.\n\t(layout::print_source_line): Make private.  Pass in line and\n\tline_width, rather than calling location_get_source_line.  Drop\n\treturned value.\n\t(layout::print_leading_fixits): New method.\n\t(layout::print_any_fixits): Rename to...\n\t(layout::print_trailing_fixits): ...this, and make private.\n\tDon't print newline fixits.\n\t(diagnostic_show_locus): Move logic for printing one row into...\n\t(layout::print_line): ...this new function.  Move the\n\tlocation_get_source_line call and error-handling from\n\tprint_source_line to here.  Call print_leading_fixits, and rename\n\tprint_any_fixits to print_trailing_fixits.\n\t(selftest::test_fixit_insert_containing_newline): Update now that\n\tnewlines are partially supported.\n\t(selftest::test_fixit_insert_containing_newline_2): New test.\n\t(selftest::test_fixit_replace_containing_newline): Update comments.\n\t(selftest::diagnostic_show_locus_c_tests): Call the new test.\n\t* edit-context.c (class added_line): New class.\n\t(class edited_line): Describe newline handling in comment.\n\t(edited_line::actually_edited_p): New method.\n\t(edited_line::print_content): Delete redundant decl.\n\t(edited_line::m_predecessors): New field.\n\t(edited_file::print_content): Call edited_line::print_content.\n\t(edited_file::print_diff): Update to support newlines.\n\t(edited_file::print_diff_hunk): Likewise.\n\t(edited_file::print_run_of_changed_lines): New function.\n\t(edited_file::print_diff_line): Convert to...\n\t(print_diff_line): ...this.\n\t(edited_file::get_effective_line_count): New function.\n\t(edited_line::edited_line): Initialize new field m_predecessors.\n\t(edited_line::~edited_line): Clean up m_predecessors.\n\t(edited_line::apply_fixit): Handle newlines.\n\t(edited_line::get_effective_line_count): New function.\n\t(edited_line::print_content): New function.\n\t(edited_line::print_diff_lines): New function.\n\t(selftest::test_applying_fixits_insert_containing_newline): New\n\ttest.\n\t(selftest::test_applying_fixits_replace_containing_newline): New\n\ttest.\n\t(selftest::insert_line): New function.\n\t(selftest::test_applying_fixits_multiple_lines): Add example of\n\tinserting a line.\n\t(selftest::edit_context_c_tests): Call the new tests.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/diagnostic-test-show-locus-bw.c\n\t(test_fixit_insert_newline): New function.\n\t* gcc.dg/plugin/diagnostic-test-show-locus-color.c\n\t(test_fixit_insert_newline): New function.\n\t* gcc.dg/plugin/diagnostic-test-show-locus-generate-patch.c\n\t(test_fixit_insert_newline): New function.\n\t* gcc.dg/plugin/diagnostic-test-show-locus-parseable-fixits.c\n\t(test_fixit_insert_newline): New function.\n\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n\t(test_show_locus): Handle test_fixit_insert_newline.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (class rich_location): Update description of\n\tnewline handling.\n\t(class fixit_hint): Likewise.\n\t(fixit_hint::ends_with_newline_p): New decl.\n\t* line-map.c (rich_location::maybe_add_fixit): Support newlines\n\tin fix-it hints that are insertions of single lines at the start\n\tof a line.  Don't consolidate into such fix-it hints.\n\t(fixit_hint::ends_with_newline_p): New method.\n\nFrom-SVN: r247522", "tree": {"sha": "fbb33622c1d2ca1c3acfafe4aab4578465d8f35d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbb33622c1d2ca1c3acfafe4aab4578465d8f35d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad53f12355a61ad5811d59977c963a16b6c5be8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad53f12355a61ad5811d59977c963a16b6c5be8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad53f12355a61ad5811d59977c963a16b6c5be8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad53f12355a61ad5811d59977c963a16b6c5be8d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19576ba7408ccd45fea5f1ad2171ab2b8403f59e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19576ba7408ccd45fea5f1ad2171ab2b8403f59e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19576ba7408ccd45fea5f1ad2171ab2b8403f59e"}], "stats": {"total": 835, "additions": 727, "deletions": 108}, "files": [{"sha": "2b6dfb3a45c2ff19946c9da24bfea0d7e3731324", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -1,3 +1,54 @@\n+2017-05-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-show-locus.c\n+\t(layout::should_print_annotation_line_p): Make private.\n+\t(layout::print_annotation_line): Make private.\n+\t(layout::annotation_line_showed_range_p): Make private.\n+\t(layout::show_ruler): Make private.\n+\t(layout::print_source_line): Make private.  Pass in line and\n+\tline_width, rather than calling location_get_source_line.  Drop\n+\treturned value.\n+\t(layout::print_leading_fixits): New method.\n+\t(layout::print_any_fixits): Rename to...\n+\t(layout::print_trailing_fixits): ...this, and make private.\n+\tDon't print newline fixits.\n+\t(diagnostic_show_locus): Move logic for printing one row into...\n+\t(layout::print_line): ...this new function.  Move the\n+\tlocation_get_source_line call and error-handling from\n+\tprint_source_line to here.  Call print_leading_fixits, and rename\n+\tprint_any_fixits to print_trailing_fixits.\n+\t(selftest::test_fixit_insert_containing_newline): Update now that\n+\tnewlines are partially supported.\n+\t(selftest::test_fixit_insert_containing_newline_2): New test.\n+\t(selftest::test_fixit_replace_containing_newline): Update comments.\n+\t(selftest::diagnostic_show_locus_c_tests): Call the new test.\n+\t* edit-context.c (class added_line): New class.\n+\t(class edited_line): Describe newline handling in comment.\n+\t(edited_line::actually_edited_p): New method.\n+\t(edited_line::print_content): Delete redundant decl.\n+\t(edited_line::m_predecessors): New field.\n+\t(edited_file::print_content): Call edited_line::print_content.\n+\t(edited_file::print_diff): Update to support newlines.\n+\t(edited_file::print_diff_hunk): Likewise.\n+\t(edited_file::print_run_of_changed_lines): New function.\n+\t(edited_file::print_diff_line): Convert to...\n+\t(print_diff_line): ...this.\n+\t(edited_file::get_effective_line_count): New function.\n+\t(edited_line::edited_line): Initialize new field m_predecessors.\n+\t(edited_line::~edited_line): Clean up m_predecessors.\n+\t(edited_line::apply_fixit): Handle newlines.\n+\t(edited_line::get_effective_line_count): New function.\n+\t(edited_line::print_content): New function.\n+\t(edited_line::print_diff_lines): New function.\n+\t(selftest::test_applying_fixits_insert_containing_newline): New\n+\ttest.\n+\t(selftest::test_applying_fixits_replace_containing_newline): New\n+\ttest.\n+\t(selftest::insert_line): New function.\n+\t(selftest::test_applying_fixits_multiple_lines): Add example of\n+\tinserting a line.\n+\t(selftest::edit_context_c_tests): Call the new tests.\n+\n 2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (get_scaled_computation_cost_at): Delete"}, {"sha": "b91c9d55da305f27d54d1d49b7f2c0c4cc7f47e8", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 164, "deletions": 47, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -203,16 +203,20 @@ class layout\n \n   expanded_location get_expanded_location (const line_span *) const;\n \n-  bool print_source_line (int row, line_bounds *lbounds_out);\n+  void print_line (int row);\n+\n+ private:\n+  void print_leading_fixits (int row);\n+  void print_source_line (int row, const char *line, int line_width,\n+\t\t\t  line_bounds *lbounds_out);\n   bool should_print_annotation_line_p (int row) const;\n   void print_annotation_line (int row, const line_bounds lbounds);\n+  void print_trailing_fixits (int row);\n+\n   bool annotation_line_showed_range_p (int line, int start_column,\n \t\t\t\t       int finish_column) const;\n-  void print_any_fixits (int row);\n-\n   void show_ruler (int max_column) const;\n \n- private:\n   bool validate_fixit_hint_p (const fixit_hint *hint);\n \n   void calculate_line_spans ();\n@@ -1055,21 +1059,15 @@ layout::calculate_line_spans ()\n     }\n }\n \n-/* Attempt to print line ROW of source code, potentially colorized at any\n-   ranges.\n-   Return true if the line was printed, populating *LBOUNDS_OUT.\n-   Return false if the source line could not be read, leaving *LBOUNDS_OUT\n-   untouched.  */\n+/* Print line ROW of source code, potentially colorized at any ranges, and\n+   populate *LBOUNDS_OUT.\n+   LINE is the source line (not necessarily 0-terminated) and LINE_WIDTH\n+   is its width.  */\n \n-bool\n-layout::print_source_line (int row, line_bounds *lbounds_out)\n+void\n+layout::print_source_line (int row, const char *line, int line_width,\n+\t\t\t   line_bounds *lbounds_out)\n {\n-  int line_width;\n-  const char *line = location_get_source_line (m_exploc.file, row,\n-\t\t\t\t\t       &line_width);\n-  if (!line)\n-    return false;\n-\n   m_colorizer.set_normal_text ();\n \n   /* We will stop printing the source line at any trailing\n@@ -1124,7 +1122,6 @@ layout::print_source_line (int row, line_bounds *lbounds_out)\n \n   lbounds_out->m_first_non_ws = first_non_ws;\n   lbounds_out->m_last_non_ws = last_non_ws;\n-  return true;\n }\n \n /* Determine if we should print an annotation line for ROW.\n@@ -1186,7 +1183,46 @@ layout::print_annotation_line (int row, const line_bounds lbounds)\n   print_newline ();\n }\n \n-/* Subroutine of layout::print_any_fixits.\n+/* If there are any fixit hints inserting new lines before source line ROW,\n+   print them.\n+\n+   They are printed on lines of their own, before the source line\n+   itself, with a leading '+'.  */\n+\n+void\n+layout::print_leading_fixits (int row)\n+{\n+  for (unsigned int i = 0; i < m_fixit_hints.length (); i++)\n+    {\n+      const fixit_hint *hint = m_fixit_hints[i];\n+\n+      if (!hint->ends_with_newline_p ())\n+\t/* Not a newline fixit; print it in print_trailing_fixits.  */\n+\tcontinue;\n+\n+      gcc_assert (hint->insertion_p ());\n+\n+      if (hint->affects_line_p (m_exploc.file, row))\n+\t{\n+\t  /* Printing the '+' with normal colorization\n+\t     and the inserted line with \"insert\" colorization\n+\t     helps them stand out from each other, and from\n+\t     the surrounding text.  */\n+\t  m_colorizer.set_normal_text ();\n+\t  pp_character (m_pp, '+');\n+\t  m_colorizer.set_fixit_insert ();\n+\t  /* Print all but the trailing newline of the fix-it hint.\n+\t     We have to print the newline separately to avoid\n+\t     getting additional pp prefixes printed.  */\n+\t  for (size_t i = 0; i < hint->get_length () - 1; i++)\n+\t    pp_character (m_pp, hint->get_string ()[i]);\n+\t  m_colorizer.set_normal_text ();\n+\t  pp_newline (m_pp);\n+\t}\n+    }\n+}\n+\n+/* Subroutine of layout::print_trailing_fixits.\n \n    Determine if the annotation line printed for LINE contained\n    the exact range from START_COLUMN to FINISH_COLUMN.  */\n@@ -1208,15 +1244,21 @@ layout::annotation_line_showed_range_p (int line, int start_column,\n \n /* If there are any fixit hints on source line ROW, print them.\n    They are printed in order, attempting to combine them onto lines, but\n-   starting new lines if necessary.  */\n+   starting new lines if necessary.\n+   Fix-it hints that insert new lines are handled separately,\n+   in layout::print_leading_fixits.  */\n \n void\n-layout::print_any_fixits (int row)\n+layout::print_trailing_fixits (int row)\n {\n   int column = 0;\n   for (unsigned int i = 0; i < m_fixit_hints.length (); i++)\n     {\n       const fixit_hint *hint = m_fixit_hints[i];\n+\n+      if (hint->ends_with_newline_p ())\n+\tcontinue;\n+\n       if (hint->affects_line_p (m_exploc.file, row))\n \t{\n \t  /* For now we assume each fixit hint can only touch one line.  */\n@@ -1416,6 +1458,27 @@ layout::show_ruler (int max_column) const\n   pp_newline (m_pp);\n }\n \n+/* Print leading fix-its (for new lines inserted before the source line)\n+   then the source line, followed by an annotation line\n+   consisting of any caret/underlines, then any fixits.\n+   If the source line can't be read, print nothing.  */\n+void\n+layout::print_line (int row)\n+{\n+  int line_width;\n+  const char *line = location_get_source_line (m_exploc.file, row,\n+\t\t\t\t\t       &line_width);\n+  if (!line)\n+    return;\n+\n+  line_bounds lbounds;\n+  print_leading_fixits (row);\n+  print_source_line (row, line, line_width, &lbounds);\n+  if (should_print_annotation_line_p (row))\n+    print_annotation_line (row, lbounds);\n+  print_trailing_fixits (row);\n+}\n+\n } /* End of anonymous namespace.  */\n \n /* Print the physical source code corresponding to the location of\n@@ -1460,18 +1523,7 @@ diagnostic_show_locus (diagnostic_context * context,\n \t}\n       int last_line = line_span->get_last_line ();\n       for (int row = line_span->get_first_line (); row <= last_line; row++)\n-\t{\n-\t  /* Print the source line, followed by an annotation line\n-\t     consisting of any caret/underlines, then any fixits.\n-\t     If the source line can't be read, print nothing.  */\n-\t  line_bounds lbounds;\n-\t  if (layout.print_source_line (row, &lbounds))\n-\t    {\n-\t      if (layout.should_print_annotation_line_p (row))\n-\t\tlayout.print_annotation_line (row, lbounds);\n-\t      layout.print_any_fixits (row);\n-\t    }\n-\t}\n+\tlayout.print_line (row);\n     }\n \n   pp_set_prefix (context->printer, saved_prefix);\n@@ -2101,8 +2153,7 @@ test_fixit_consolidation (const line_table_case &case_)\n   }\n }\n \n-/* Insertion fix-it hint: adding a \"break;\" on a line by itself.\n-   This will fail, as newlines aren't yet supported.  */\n+/* Insertion fix-it hint: adding a \"break;\" on a line by itself.  */\n \n static void\n test_fixit_insert_containing_newline (const line_table_case &case_)\n@@ -2119,32 +2170,97 @@ test_fixit_insert_containing_newline (const line_table_case &case_)\n   line_table_test ltt (case_);\n   linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 3);\n \n-  /* Add a \"break;\" on a line by itself before line 3 i.e. before\n-     column 1 of line 3. */\n   location_t case_start = linemap_position_for_column (line_table, 5);\n   location_t case_finish = linemap_position_for_column (line_table, 13);\n   location_t case_loc = make_location (case_start, case_start, case_finish);\n-  rich_location richloc (line_table, case_loc);\n   location_t line_start = linemap_position_for_column (line_table, 1);\n-  richloc.add_fixit_insert_before (line_start, \"      break;\\n\");\n-\n-  /* Newlines are not yet supported within fix-it hints, so\n-     the fix-it should not be displayed.  */\n-  ASSERT_TRUE (richloc.seen_impossible_fixit_p ());\n \n   if (case_finish > LINE_MAP_MAX_LOCATION_WITH_COLS)\n     return;\n \n+  /* Add a \"break;\" on a line by itself before line 3 i.e. before\n+     column 1 of line 3. */\n+  {\n+    rich_location richloc (line_table, case_loc);\n+    richloc.add_fixit_insert_before (line_start, \"      break;\\n\");\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"+      break;\\n\"\n+\t\t  \"     case 'b':\\n\"\n+\t\t  \"     ^~~~~~~~~\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Verify that attempts to add text with a newline fail when the\n+     insertion point is *not* at the start of a line.  */\n+  {\n+    rich_location richloc (line_table, case_loc);\n+    richloc.add_fixit_insert_before (case_start, \"break;\\n\");\n+    ASSERT_TRUE (richloc.seen_impossible_fixit_p ());\n+    test_diagnostic_context dc;\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"     case 'b':\\n\"\n+\t\t  \"     ^~~~~~~~~\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n+/* Insertion fix-it hint: adding a \"#include <stdio.h>\\n\" to the top\n+   of the file, where the fix-it is printed in a different line-span\n+   to the primary range of the diagnostic.  */\n+\n+static void\n+test_fixit_insert_containing_newline_2 (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................0000000001111111.\n+     .........................1234567890123456.  */\n+  const char *old_content = (\"test (int ch)\\n\"  /* line 1. */\n+\t\t\t     \"{\\n\"              /* line 2. */\n+\t\t\t     \" putchar (ch);\\n\" /* line 3. */\n+\t\t\t     \"}\\n\");            /* line 4. */\n+\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  line_table_test ltt (case_);\n+\n+  const line_map_ordinary *ord_map = linemap_check_ordinary\n+    (linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 0));\n+  linemap_line_start (line_table, 1, 100);\n+\n+  /* The primary range is the \"putchar\" token.  */\n+  location_t putchar_start\n+    = linemap_position_for_line_and_column (line_table, ord_map, 3, 2);\n+  location_t putchar_finish\n+    = linemap_position_for_line_and_column (line_table, ord_map, 3, 8);\n+  location_t putchar_loc\n+    = make_location (putchar_start, putchar_start, putchar_finish);\n+  rich_location richloc (line_table, putchar_loc);\n+\n+  /* Add a \"#include <stdio.h>\" on a line by itself at the top of the file.  */\n+  location_t file_start\n+     = linemap_position_for_line_and_column (line_table, ord_map,  1, 1);\n+  richloc.add_fixit_insert_before (file_start, \"#include <stdio.h>\\n\");\n+\n+  if (putchar_finish > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n   test_diagnostic_context dc;\n   diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n   ASSERT_STREQ (\"\\n\"\n-\t\t\"     case 'b':\\n\"\n-\t\t\"     ^~~~~~~~~\\n\",\n+\t\t\"FILENAME:1:1:\\n\"\n+\t\t\"+#include <stdio.h>\\n\"\n+\t\t\" test (int ch)\\n\"\n+\t\t\"FILENAME:3:2:\\n\"\n+\t\t\"  putchar (ch);\\n\"\n+\t\t\"  ^~~~~~~\\n\",\n \t\tpp_formatted_text (dc.printer));\n }\n \n /* Replacement fix-it hint containing a newline.\n-   This will fail, as newlines aren't yet supported.  */\n+   This will fail, as newlines are only supported when inserting at the\n+   beginning of a line.  */\n \n static void\n test_fixit_replace_containing_newline (const line_table_case &case_)\n@@ -2167,7 +2283,7 @@ test_fixit_replace_containing_newline (const line_table_case &case_)\n   source_range range = source_range::from_locations (start, finish);\n   richloc.add_fixit_replace (range, \"\\n =\");\n \n-  /* Newlines are not yet supported within fix-it hints, so\n+  /* Arbitrary newlines are not yet supported within fix-it hints, so\n      the fix-it should not be displayed.  */\n   ASSERT_TRUE (richloc.seen_impossible_fixit_p ());\n \n@@ -2199,6 +2315,7 @@ diagnostic_show_locus_c_tests ()\n   for_each_line_table_case (test_diagnostic_show_locus_fixit_lines);\n   for_each_line_table_case (test_fixit_consolidation);\n   for_each_line_table_case (test_fixit_insert_containing_newline);\n+  for_each_line_table_case (test_fixit_insert_containing_newline_2);\n   for_each_line_table_case (test_fixit_replace_containing_newline);\n }\n "}, {"sha": "6f35ca291f1c2fe181dcec64ea172fc11c6c2d52", "filename": "gcc/edit-context.c", "status": "modified", "additions": 341, "deletions": 53, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Fedit-context.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Fedit-context.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fedit-context.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -86,23 +86,52 @@ class edited_file\n  private:\n   bool print_content (pretty_printer *pp);\n   void print_diff (pretty_printer *pp, bool show_filenames);\n-  void print_diff_hunk (pretty_printer *pp, int start_of_hunk,\n-\t\t\tint end_of_hunk);\n-  void print_diff_line (pretty_printer *pp, char prefix_char,\n-\t\t\tconst char *line, int line_size);\n+  int print_diff_hunk (pretty_printer *pp, int old_start_of_hunk,\n+\t\t       int old_end_of_hunk, int new_start_of_hunk);\n   edited_line *get_line (int line);\n   edited_line *get_or_insert_line (int line);\n   int get_num_lines (bool *missing_trailing_newline);\n \n+  int get_effective_line_count (int old_start_of_hunk,\n+\t\t\t\tint old_end_of_hunk);\n+\n+  void print_run_of_changed_lines (pretty_printer *pp,\n+\t\t\t\t   int start_of_run,\n+\t\t\t\t   int end_of_run);\n+\n   const char *m_filename;\n   typed_splay_tree<int, edited_line *> m_edited_lines;\n   int m_num_lines;\n };\n \n+/* A line added before an edited_line.  */\n+\n+class added_line\n+{\n+ public:\n+  added_line (const char *content, int len)\n+  : m_content (xstrndup (content, len)), m_len (len) {}\n+  ~added_line () { free (m_content); }\n+\n+  const char *get_content () const { return m_content; }\n+  int get_len () const { return m_len; }\n+\n+ private:\n+  char *m_content;\n+  int m_len;\n+};\n+\n /* The state of one edited line within an edited_file.\n    As well as the current content of the line, it contains a record of\n    the changes, so that further changes can be applied in the correct\n-   place.  */\n+   place.\n+\n+   When handling fix-it hints containing newlines, new lines are added\n+   as added_line predecessors to an edited_line.  Hence it's possible\n+   for an \"edited_line\" to not actually have been changed, but to merely\n+   be a placeholder for the lines added before it.  This can be tested\n+   for with actuall_edited_p, and has a slight effect on how diff hunks\n+   are generated.  */\n \n class edited_line\n {\n@@ -121,16 +150,25 @@ class edited_line\n \t\t    const char *replacement_str,\n \t\t    int replacement_len);\n \n+  int get_effective_line_count () const;\n+\n+  /* Has the content of this line actually changed, or are we merely\n+     recording predecessor added_lines?  */\n+  bool actually_edited_p () const { return m_line_events.length () > 0; }\n+\n+  void print_content (pretty_printer *pp) const;\n+  void print_diff_lines (pretty_printer *pp) const;\n+\n  private:\n   void ensure_capacity (int len);\n   void ensure_terminated ();\n-  void print_content (pretty_printer *pp) const;\n \n   int m_line_num;\n   char *m_content;\n   int m_len;\n   int m_alloc_sz;\n   auto_vec <line_event> m_line_events;\n+  auto_vec <added_line *> m_predecessors;\n };\n \n /* Class for representing edit events that have occurred on one line of\n@@ -160,6 +198,12 @@ class line_event\n   int m_delta;\n };\n \n+/* Forward decls.  */\n+\n+static void\n+print_diff_line (pretty_printer *pp, char prefix_char,\n+\t\t const char *line, int line_size);\n+\n /* Implementation of class edit_context.  */\n \n /* edit_context's ctor.  */\n@@ -375,7 +419,7 @@ edited_file::print_content (pretty_printer *pp)\n     {\n       edited_line *el = get_line (line_num);\n       if (el)\n-\tpp_string (pp, el->get_content ());\n+\tel->print_content (pp);\n       else\n \t{\n \t  int len;\n@@ -417,6 +461,10 @@ edited_file::print_diff (pretty_printer *pp, bool show_filenames)\n \n   const int context_lines = 3;\n \n+  /* Track new line numbers minus old line numbers.  */\n+\n+  int line_delta = 0;\n+\n   while (el)\n     {\n       int start_of_hunk = el->get_line_num ();\n@@ -432,39 +480,53 @@ edited_file::print_diff (pretty_printer *pp, bool show_filenames)\n \t    = m_edited_lines.successor (el->get_line_num ());\n \t  if (!next_el)\n \t    break;\n-\t  if (el->get_line_num () + context_lines\n+\n+\t  int end_of_printed_hunk = el->get_line_num () + context_lines;\n+\t  if (!el->actually_edited_p ())\n+\t    end_of_printed_hunk--;\n+\n+\t  if (end_of_printed_hunk\n \t      >= next_el->get_line_num () - context_lines)\n \t    el = next_el;\n \t  else\n \t    break;\n \t}\n+\n       int end_of_hunk = el->get_line_num ();\n       end_of_hunk += context_lines;\n+      if (!el->actually_edited_p ())\n+\tend_of_hunk--;\n       if (end_of_hunk > line_count)\n \tend_of_hunk = line_count;\n \n-      print_diff_hunk (pp, start_of_hunk, end_of_hunk);\n-\n+      int new_start_of_hunk = start_of_hunk + line_delta;\n+      line_delta += print_diff_hunk (pp, start_of_hunk, end_of_hunk,\n+\t\t\t\t     new_start_of_hunk);\n       el = m_edited_lines.successor (el->get_line_num ());\n     }\n }\n \n /* Print one hunk within a unified diff to PP, covering the\n-   given range of lines.  */\n+   given range of lines.  OLD_START_OF_HUNK and OLD_END_OF_HUNK are\n+   line numbers in the unedited version of the file.\n+   NEW_START_OF_HUNK is a line number in the edited version of the file.\n+   Return the change in the line count within the hunk.  */\n \n-void\n-edited_file::print_diff_hunk (pretty_printer *pp, int start_of_hunk,\n-\t\t\t      int end_of_hunk)\n+int\n+edited_file::print_diff_hunk (pretty_printer *pp, int old_start_of_hunk,\n+\t\t\t      int old_end_of_hunk, int new_start_of_hunk)\n {\n-  int num_lines = end_of_hunk - start_of_hunk + 1;\n+  int old_num_lines = old_end_of_hunk - old_start_of_hunk + 1;\n+  int new_num_lines\n+    = get_effective_line_count (old_start_of_hunk, old_end_of_hunk);\n \n   pp_string (pp, colorize_start (pp_show_color (pp), \"diff-hunk\"));\n-  pp_printf (pp, \"@@ -%i,%i +%i,%i @@\\n\", start_of_hunk, num_lines,\n-\t     start_of_hunk, num_lines);\n+  pp_printf (pp, \"@@ -%i,%i +%i,%i @@\\n\", old_start_of_hunk, old_num_lines,\n+\t     new_start_of_hunk, new_num_lines);\n   pp_string (pp, colorize_stop (pp_show_color (pp)));\n \n-  int line_num = start_of_hunk;\n-  while (line_num <= end_of_hunk)\n+  int line_num = old_start_of_hunk;\n+  while (line_num <= old_end_of_hunk)\n     {\n       edited_line *el = get_line (line_num);\n       if (el)\n@@ -475,34 +537,8 @@ edited_file::print_diff_hunk (pretty_printer *pp, int start_of_hunk,\n \t  while (get_line (line_num))\n \t    line_num++;\n \t  const int last_changed_line_in_run = line_num - 1;\n-\n-\t  /* Show old version of lines.  */\n-\t  pp_string (pp, colorize_start (pp_show_color (pp),\n-\t\t\t\t\t \"diff-delete\"));\n-\t  for (line_num = first_changed_line_in_run;\n-\t       line_num <= last_changed_line_in_run;\n-\t       line_num++)\n-\t    {\n-\t      int line_len;\n-\t      const char *old_line\n-\t\t= location_get_source_line (m_filename, line_num, &line_len);\n-\t      print_diff_line (pp, '-', old_line, line_len);\n-\t    }\n-\t  pp_string (pp, colorize_stop (pp_show_color (pp)));\n-\n-\t  /* Show new version of lines.  */\n-\t  pp_string (pp, colorize_start (pp_show_color (pp),\n-\t\t\t\t\t \"diff-insert\"));\n-\t  for (line_num = first_changed_line_in_run;\n-\t       line_num <= last_changed_line_in_run;\n-\t       line_num++)\n-\t    {\n-\t      edited_line *el_in_run = get_line (line_num);\n-\t      gcc_assert (el_in_run);\n-\t      print_diff_line (pp, '+', el_in_run->get_content (),\n-\t\t\t       el_in_run->get_len ());\n-\t    }\n-\t  pp_string (pp, colorize_stop (pp_show_color (pp)));\n+\t  print_run_of_changed_lines (pp, first_changed_line_in_run,\n+\t\t\t\t      last_changed_line_in_run);\n \t}\n       else\n \t{\n@@ -514,22 +550,87 @@ edited_file::print_diff_hunk (pretty_printer *pp, int start_of_hunk,\n \t  line_num++;\n \t}\n     }\n+\n+  return new_num_lines - old_num_lines;\n+}\n+\n+/* Subroutine of edited_file::print_diff_hunk: given a run of lines\n+   from START_OF_RUN to END_OF_RUN that all have edited_line instances,\n+   print the diff to PP.  */\n+\n+void\n+edited_file::print_run_of_changed_lines (pretty_printer *pp,\n+\t\t\t\t\t int start_of_run,\n+\t\t\t\t\t int end_of_run)\n+{\n+  /* Show old version of lines.  */\n+  pp_string (pp, colorize_start (pp_show_color (pp),\n+\t\t\t\t \"diff-delete\"));\n+  for (int line_num = start_of_run;\n+       line_num <= end_of_run;\n+       line_num++)\n+    {\n+      edited_line *el_in_run = get_line (line_num);\n+      gcc_assert (el_in_run);\n+      if (el_in_run->actually_edited_p ())\n+\t{\n+\t  int line_len;\n+\t  const char *old_line\n+\t    = location_get_source_line (m_filename, line_num, &line_len);\n+\t  print_diff_line (pp, '-', old_line, line_len);\n+\t}\n+    }\n+  pp_string (pp, colorize_stop (pp_show_color (pp)));\n+\n+  /* Show new version of lines.  */\n+  pp_string (pp, colorize_start (pp_show_color (pp),\n+\t\t\t\t \"diff-insert\"));\n+  for (int line_num = start_of_run;\n+       line_num <= end_of_run;\n+       line_num++)\n+    {\n+      edited_line *el_in_run = get_line (line_num);\n+      gcc_assert (el_in_run);\n+      el_in_run->print_diff_lines (pp);\n+    }\n+  pp_string (pp, colorize_stop (pp_show_color (pp)));\n }\n \n /* Print one line within a diff, starting with PREFIX_CHAR,\n    followed by the LINE of content, of length LEN.  LINE is\n    not necessarily 0-terminated.  Print a trailing newline.  */\n \n-void\n-edited_file::print_diff_line (pretty_printer *pp, char prefix_char,\n-\t\t\t      const char *line, int len)\n+static void\n+print_diff_line (pretty_printer *pp, char prefix_char,\n+\t\t const char *line, int len)\n {\n   pp_character (pp, prefix_char);\n   for (int i = 0; i < len; i++)\n     pp_character (pp, line[i]);\n   pp_character (pp, '\\n');\n }\n \n+/* Determine the number of lines that will be present after\n+   editing for the range of lines from OLD_START_OF_HUNK to\n+   OLD_END_OF_HUNK inclusive.  */\n+\n+int\n+edited_file::get_effective_line_count (int old_start_of_hunk,\n+\t\t\t\t       int old_end_of_hunk)\n+{\n+  int line_count = 0;\n+  for (int old_line_num = old_start_of_hunk; old_line_num <= old_end_of_hunk;\n+       old_line_num++)\n+    {\n+      edited_line *el = get_line (old_line_num);\n+      if (el)\n+\tline_count += el->get_effective_line_count ();\n+      else\n+\tline_count++;\n+    }\n+  return line_count;\n+}\n+\n /* Get the state of LINE within the file, or NULL if it is untouched.  */\n \n edited_line *\n@@ -591,7 +692,8 @@ edited_file::get_num_lines (bool *missing_trailing_newline)\n edited_line::edited_line (const char *filename, int line_num)\n : m_line_num (line_num),\n   m_content (NULL), m_len (0), m_alloc_sz (0),\n-  m_line_events ()\n+  m_line_events (),\n+  m_predecessors ()\n {\n   const char *line = location_get_source_line (filename, line_num,\n \t\t\t\t\t       &m_len);\n@@ -606,7 +708,12 @@ edited_line::edited_line (const char *filename, int line_num)\n \n edited_line::~edited_line ()\n {\n+  unsigned i;\n+  added_line *pred;\n+\n   free (m_content);\n+  FOR_EACH_VEC_ELT (m_predecessors, i, pred)\n+    delete pred;\n }\n \n /* A callback for deleting edited_line *, for use as a\n@@ -643,6 +750,17 @@ edited_line::apply_fixit (int start_column,\n \t\t\t  const char *replacement_str,\n \t\t\t  int replacement_len)\n {\n+  /* Handle newlines.  They will only ever be at the end of the\n+     replacement text, thanks to the filtering in rich_location.  */\n+  if (replacement_len > 1)\n+    if (replacement_str[replacement_len - 1] == '\\n')\n+      {\n+\t/* Stash in m_predecessors, stripping off newline.  */\n+\tm_predecessors.safe_push (new added_line (replacement_str,\n+\t\t\t\t\t\t  replacement_len - 1));\n+\treturn true;\n+      }\n+\n   start_column = get_effective_column (start_column);\n   next_column = get_effective_column (next_column);\n \n@@ -689,6 +807,57 @@ edited_line::apply_fixit (int start_column,\n   return true;\n }\n \n+/* Determine the number of lines that will be present after\n+   editing for this line.  Typically this is just 1, but\n+   if newlines have been added before this line, they will\n+   also be counted.  */\n+\n+int\n+edited_line::get_effective_line_count () const\n+{\n+  return m_predecessors.length () + 1;\n+}\n+\n+/* Subroutine of edited_file::print_content.\n+   Print this line and any new lines added before it, to PP.  */\n+\n+void\n+edited_line::print_content (pretty_printer *pp) const\n+{\n+  unsigned i;\n+  added_line *pred;\n+  FOR_EACH_VEC_ELT (m_predecessors, i, pred)\n+    {\n+      pp_string (pp, pred->get_content ());\n+      pp_newline (pp);\n+    }\n+  pp_string (pp, m_content);\n+}\n+\n+/* Subroutine of edited_file::print_run_of_changed_lines for\n+   printing diff hunks to PP.\n+   Print the '+' line for this line, and any newlines added\n+   before it.\n+   Note that if this edited_line was actually edited, the '-'\n+   line has already been printed.  If it wasn't, then we merely\n+   have a placeholder edited_line for adding newlines to, and\n+   we need to print a ' ' line for the edited_line as we haven't\n+   printed it yet.  */\n+\n+void\n+edited_line::print_diff_lines (pretty_printer *pp) const\n+{\n+  unsigned i;\n+  added_line *pred;\n+  FOR_EACH_VEC_ELT (m_predecessors, i, pred)\n+    print_diff_line (pp, '+', pred->get_content (),\n+\t\t     pred->get_len ());\n+  if (actually_edited_p ())\n+    print_diff_line (pp, '+', m_content, m_len);\n+  else\n+    print_diff_line (pp, ' ', m_content, m_len);\n+}\n+\n /* Ensure that the buffer for m_content is at least large enough to hold\n    a string of length LEN and its 0-terminator, doubling on repeated\n    allocations.  */\n@@ -967,6 +1136,57 @@ test_applying_fixits_insert_after_failure (const line_table_case &case_)\n   ASSERT_EQ (NULL, edit.generate_diff (false));\n }\n \n+/* Test applying an \"insert\" fixit that adds a newline.  */\n+\n+static void\n+test_applying_fixits_insert_containing_newline (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     .........................0000000001111111.\n+     .........................1234567890123456.  */\n+  const char *old_content = (\"    case 'a':\\n\" /* line 1. */\n+\t\t\t     \"      x = a;\\n\"  /* line 2. */\n+\t\t\t     \"    case 'b':\\n\" /* line 3. */\n+\t\t\t     \"      x = b;\\n\");/* line 4. */\n+\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 3);\n+\n+  /* Add a \"break;\" on a line by itself before line 3 i.e. before\n+     column 1 of line 3. */\n+  location_t case_start = linemap_position_for_column (line_table, 5);\n+  location_t case_finish = linemap_position_for_column (line_table, 13);\n+  location_t case_loc = make_location (case_start, case_start, case_finish);\n+  rich_location richloc (line_table, case_loc);\n+  location_t line_start = linemap_position_for_column (line_table, 1);\n+  richloc.add_fixit_insert_before (line_start, \"      break;\\n\");\n+\n+  if (case_finish > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  edit_context edit;\n+  edit.add_fixits (&richloc);\n+  auto_free <char *> new_content = edit.get_content (filename);\n+  ASSERT_STREQ ((\"    case 'a':\\n\"\n+\t\t \"      x = a;\\n\"\n+\t\t \"      break;\\n\"\n+\t\t \"    case 'b':\\n\"\n+\t\t \"      x = b;\\n\"),\n+\t\tnew_content);\n+\n+  /* Verify diff.  */\n+  auto_free <char *> diff = edit.generate_diff (false);\n+  ASSERT_STREQ ((\"@@ -1,4 +1,5 @@\\n\"\n+\t\t \"     case 'a':\\n\"\n+\t\t \"       x = a;\\n\"\n+\t\t \"+      break;\\n\"\n+\t\t \"     case 'b':\\n\"\n+\t\t \"       x = b;\\n\"),\n+\t\tdiff);\n+}\n+\n /* Test applying a \"replace\" fixit that grows the affected line.  */\n \n static void\n@@ -1057,6 +1277,44 @@ test_applying_fixits_shrinking_replace (const line_table_case &case_)\n     }\n }\n \n+/* Replacement fix-it hint containing a newline.  */\n+\n+static void\n+test_applying_fixits_replace_containing_newline (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+    .........................0000000001111.\n+    .........................1234567890123.  */\n+  const char *old_content = \"foo = bar ();\\n\";\n+\n+  temp_source_file tmp (SELFTEST_LOCATION, \".c\", old_content);\n+  const char *filename = tmp.get_filename ();\n+  line_table_test ltt (case_);\n+  linemap_add (line_table, LC_ENTER, false, filename, 1);\n+\n+  /* Replace the \" = \" with \"\\n  = \", as if we were reformatting an\n+     overly long line.  */\n+  location_t start = linemap_position_for_column (line_table, 4);\n+  location_t finish = linemap_position_for_column (line_table, 6);\n+  location_t loc = linemap_position_for_column (line_table, 13);\n+  rich_location richloc (line_table, loc);\n+  source_range range = source_range::from_locations (start, finish);\n+  richloc.add_fixit_replace (range, \"\\n  = \");\n+\n+  /* Newlines are only supported within fix-it hints that\n+     are at the start of lines (for entirely new lines), hence\n+     this fix-it should not be displayed.  */\n+  ASSERT_TRUE (richloc.seen_impossible_fixit_p ());\n+\n+  if (finish > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  edit_context edit;\n+  edit.add_fixits (&richloc);\n+  auto_free <char *> new_content = edit.get_content (filename);\n+  //ASSERT_STREQ (\"foo\\n  = bar ();\\n\", new_content);\n+}\n+\n /* Test applying a \"remove\" fixit.  */\n \n static void\n@@ -1204,6 +1462,32 @@ change_line (edit_context &edit, int line_num)\n   return loc;\n }\n \n+/* Subroutine of test_applying_fixits_multiple_lines.\n+   Add the text \"INSERTED\\n\" in front of the given line.  */\n+\n+static location_t\n+insert_line (edit_context &edit, int line_num)\n+{\n+  const line_map_ordinary *ord_map\n+    = LINEMAPS_LAST_ORDINARY_MAP (line_table);\n+  const int column = 1;\n+  location_t loc =\n+    linemap_position_for_line_and_column (line_table, ord_map,\n+\t\t\t\t\t  line_num, column);\n+\n+  expanded_location exploc = expand_location (loc);\n+  if (loc <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    {\n+      ASSERT_EQ (line_num, exploc.line);\n+      ASSERT_EQ (column, exploc.column);\n+    }\n+\n+  rich_location insert (line_table, loc);\n+  insert.add_fixit_insert_before (\"INSERTED\\n\");\n+  edit.add_fixits (&insert);\n+  return loc;\n+}\n+\n /* Test of editing multiple lines within a long file,\n    to ensure that diffs are generated as expected.  */\n \n@@ -1229,6 +1513,7 @@ test_applying_fixits_multiple_lines (const line_table_case &case_)\n   change_line (edit, 2);\n   change_line (edit, 3);\n   change_line (edit, 4);\n+  insert_line (edit, 5);\n \n   /* A run of nearby lines, within the contextual limit.  */\n   change_line (edit, 150);\n@@ -1240,18 +1525,19 @@ test_applying_fixits_multiple_lines (const line_table_case &case_)\n \n   /* Verify diff.  */\n   auto_free <char *> diff = edit.generate_diff (false);\n-  ASSERT_STREQ (\"@@ -1,7 +1,7 @@\\n\"\n+  ASSERT_STREQ (\"@@ -1,7 +1,8 @@\\n\"\n \t\t\" line 1\\n\"\n \t\t\"-line 2\\n\"\n \t\t\"-line 3\\n\"\n \t\t\"-line 4\\n\"\n \t\t\"+CHANGED: line 2\\n\"\n \t\t\"+CHANGED: line 3\\n\"\n \t\t\"+CHANGED: line 4\\n\"\n+\t\t\"+INSERTED\\n\"\n \t\t\" line 5\\n\"\n \t\t\" line 6\\n\"\n \t\t\" line 7\\n\"\n-\t\t\"@@ -147,10 +147,10 @@\\n\"\n+\t\t\"@@ -147,10 +148,10 @@\\n\"\n \t\t\" line 147\\n\"\n \t\t\" line 148\\n\"\n \t\t\" line 149\\n\"\n@@ -1510,8 +1796,10 @@ edit_context_c_tests ()\n   for_each_line_table_case (test_applying_fixits_insert_after);\n   for_each_line_table_case (test_applying_fixits_insert_after_at_line_end);\n   for_each_line_table_case (test_applying_fixits_insert_after_failure);\n+  for_each_line_table_case (test_applying_fixits_insert_containing_newline);\n   for_each_line_table_case (test_applying_fixits_growing_replace);\n   for_each_line_table_case (test_applying_fixits_shrinking_replace);\n+  for_each_line_table_case (test_applying_fixits_replace_containing_newline);\n   for_each_line_table_case (test_applying_fixits_remove);\n   for_each_line_table_case (test_applying_fixits_multiple);\n   for_each_line_table_case (test_applying_fixits_multiple_lines);"}, {"sha": "33a5cde0ab1f24a5624cd74007f3edc99c0668fe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -1,3 +1,16 @@\n+2017-05-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/diagnostic-test-show-locus-bw.c\n+\t(test_fixit_insert_newline): New function.\n+\t* gcc.dg/plugin/diagnostic-test-show-locus-color.c\n+\t(test_fixit_insert_newline): New function.\n+\t* gcc.dg/plugin/diagnostic-test-show-locus-generate-patch.c\n+\t(test_fixit_insert_newline): New function.\n+\t* gcc.dg/plugin/diagnostic-test-show-locus-parseable-fixits.c\n+\t(test_fixit_insert_newline): New function.\n+\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c\n+\t(test_show_locus): Handle test_fixit_insert_newline.\n+\n 2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n \n \t* g++.dg/tree-ssa/ivopts-3.C: Adjust test string."}, {"sha": "25b9d6cb3826d47fd139fee80e06b8a9f6e50ab2", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-locus-bw.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -249,3 +249,23 @@ void test_many_nested_locations (void)\n      MOLLIT ANIM ID EST LABORUM\n    { dg-end-multiline-output \"\" } */\n }\n+\n+/* Unit test for rendering of fix-it hints that add new lines.  */\n+\n+void test_fixit_insert_newline (void)\n+{\n+#if 0\n+  switch (op)\n+    {\n+    case 'a':\n+      x = a;\n+    case 'b':  /* { dg-warning \"newline insertion\" } */\n+      x = b;\n+    }\n+/* { dg-begin-multiline-output \"\" }\n++      break;\n+     case 'b':\n+     ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}"}, {"sha": "3fb1c240238e50f29fd3a4a4a0dce023fba2c392", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-locus-color.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-color.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -193,3 +193,23 @@ void test_fixit_replace (void)\n    { dg-end-multiline-output \"\" } */\n #endif\n }\n+\n+/* Unit test for rendering of fix-it hints that add new lines.  */\n+\n+void test_fixit_insert_newline (void)\n+{\n+#if 0\n+  switch (op)\n+    {\n+    case 'a':\n+      x = a;\n+    case 'b':  /* { dg-warning \"newline insertion\" } */\n+      x = b;\n+    }\n+/* { dg-begin-multiline-output \"\" }\n++\u001b[32m\u001b[K      break;\u001b[m\u001b[K\n+     \u001b[01;35m\u001b[Kcase 'b'\u001b[m\u001b[K:\n+     \u001b[01;35m\u001b[K^~~~~~~~\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}"}, {"sha": "4522dcd350e7189aac42b98817021253d0718100", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-locus-generate-patch.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-generate-patch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-generate-patch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-generate-patch.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -36,7 +36,20 @@ void test_fixit_replace (void)\n #endif\n }\n \n+/* Unit test for rendering of fix-it hints that add new lines.  */\n \n+void test_fixit_insert_newline (void)\n+{\n+#if 0\n+  switch (op)\n+    {\n+    case 'a':\n+      x = a;\n+    case 'b': /* { dg-warning \"newline insertion\" } */\n+      x = b;\n+    }\n+#endif\n+}\n \n /* Verify the output from -fdiagnostics-generate-patch.\n    We expect a header, containing the filename.  This is the absolute path,\n@@ -74,4 +87,12 @@ void test_fixit_replace (void)\n  #endif\n  }\n  \n+@@ -45,6 +45,7 @@\n+     {\n+     case 'a':\n+       x = a;\n++      break;\n+     case 'b':\n+       x = b;\n+     }\n    { dg-end-multiline-output \"\" } */"}, {"sha": "25a7c3c507216221738b98df5e22c789077e1ae8", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-locus-parseable-fixits.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-parseable-fixits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-parseable-fixits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-parseable-fixits.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -39,3 +39,19 @@ void test_fixit_replace (void)\n /* { dg-regexp \"fix-it:.*\\\\{38:3-38:21\\\\}:.*\" } */\n #endif\n }\n+\n+/* Unit test for rendering of fix-it hints that add new lines.  */\n+\n+void test_fixit_insert_newline (void)\n+{\n+#if 0\n+  switch (op)\n+    {\n+    case 'a':\n+      x = a;\n+    case 'b': /* { dg-warning \"newline insertion\" } */\n+      x = b;\n+    }\n+/* { dg-regexp \"fix-it:.*\\\\{52:1-52:1\\\\}:.*\\\\n\" } */\n+#endif\n+}"}, {"sha": "6afb58414f0b6e80398a47c428165c9ac0d45417", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_show_locus.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -268,6 +268,18 @@ test_show_locus (function *fun)\n       warning_at_rich_loc (&richloc, 0, \"example of insertion hints\");\n     }\n \n+  if (0 == strcmp (fnname, \"test_fixit_insert_newline\"))\n+    {\n+      const int line = fnstart_line + 6;\n+      location_t line_start = get_loc (line, 0);\n+      location_t case_start = get_loc (line, 4);\n+      location_t case_finish = get_loc (line, 11);\n+      location_t case_loc = make_location (case_start, case_start, case_finish);\n+      rich_location richloc (line_table, case_loc);\n+      richloc.add_fixit_insert_before (line_start, \"      break;\\n\");\n+      warning_at_rich_loc (&richloc, 0, \"example of newline insertion hint\");\n+    }\n+\n   if (0 == strcmp (fnname, \"test_fixit_remove\"))\n     {\n       const int line = fnstart_line + 2;"}, {"sha": "c01ab44d3f7cc11edc5caedaa51d31096e204753", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -1,3 +1,14 @@\n+2017-05-02  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (class rich_location): Update description of\n+\tnewline handling.\n+\t(class fixit_hint): Likewise.\n+\t(fixit_hint::ends_with_newline_p): New decl.\n+\t* line-map.c (rich_location::maybe_add_fixit): Support newlines\n+\tin fix-it hints that are insertions of single lines at the start\n+\tof a line.  Don't consolidate into such fix-it hints.\n+\t(fixit_hint::ends_with_newline_p): New method.\n+\n 2017-05-01  David Malcolm  <dmalcolm@redhat.com>\n \n \t* include/line-map.h (source_range::intersects_line_p): Delete."}, {"sha": "90d65d746ab43df5badd06223c0c7be307ada0ee", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -1551,7 +1551,11 @@ class fixit_hint;\n \n    Attempts to add a fix-it hint within a macro expansion will fail.\n \n-   We do not yet support newlines in fix-it text; attempts to do so will fail.\n+   There is only limited support for newline characters in fix-it hints:\n+   only hints with newlines which insert an entire new line are permitted,\n+   inserting at the start of a line, and finishing with a newline\n+   (with no interior newline characters).  Other attempts to add\n+   fix-it hints containing newline characters will fail.\n \n    The rich_location API handles these failures gracefully, so that\n    diagnostics can attempt to add fix-it hints without each needing\n@@ -1690,7 +1694,13 @@ class rich_location\n        [start, next_loc)\n    Insertions have start == next_loc: \"replace\" the empty string at the\n    start location with the new string.\n-   Deletions are replacement with the empty string.  */\n+   Deletions are replacement with the empty string.\n+\n+   There is only limited support for newline characters in fix-it hints\n+   as noted above in the comment for class rich_location.\n+   A fixit_hint instance can have at most one newline character; if\n+   present, the newline character must be the final character of\n+   the content (preventing e.g. fix-its that split a pre-existing line).  */\n \n class fixit_hint\n {\n@@ -1712,6 +1722,8 @@ class fixit_hint\n \n   bool insertion_p () const { return m_start == m_next_loc; }\n \n+  bool ends_with_newline_p () const;\n+\n  private:\n   /* We don't use source_range here since, unlike most places,\n      this is a half-open/half-closed range:"}, {"sha": "c4b7cb2365126d51bc5ad861eba41c6ee807555a", "filename": "libcpp/line-map.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad53f12355a61ad5811d59977c963a16b6c5be8d/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad53f12355a61ad5811d59977c963a16b6c5be8d/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=ad53f12355a61ad5811d59977c963a16b6c5be8d", "patch": "@@ -2325,16 +2325,44 @@ rich_location::maybe_add_fixit (source_location start,\n   if (reject_impossible_fixit (next_loc))\n     return;\n \n-  /* We do not yet support newlines within fix-it hints.  */\n-  if (strchr (new_content, '\\n'))\n+  const char *newline = strchr (new_content, '\\n');\n+  if (newline)\n     {\n-      stop_supporting_fixits ();\n-      return;\n+      /* For now, we can only support insertion of whole lines\n+\t i.e. starts at start of line, and the newline is at the end of\n+\t the insertion point.  */\n+\n+      /* It must be an insertion, not a replacement/deletion.  */\n+      if (start != next_loc)\n+\t{\n+\t  stop_supporting_fixits ();\n+\t  return;\n+\t}\n+\n+      /* The insertion must be at the start of a line.  */\n+      expanded_location exploc_start\n+\t= linemap_client_expand_location_to_spelling_point (start);\n+      if (exploc_start.column != 1)\n+\t{\n+\t  stop_supporting_fixits ();\n+\t  return;\n+\t}\n+\n+      /* The newline must be at end of NEW_CONTENT.\n+\t We could eventually split up fix-its at newlines if we wanted\n+\t to allow more generality (e.g. to allow adding multiple lines\n+\t with one add_fixit call.  */\n+      if (newline[1] != '\\0')\n+\t{\n+\t  stop_supporting_fixits ();\n+\t  return;\n+\t}\n     }\n \n-  /* Consolidate neighboring fixits.  */\n+  /* Consolidate neighboring fixits.\n+     Don't consolidate into newline-insertion fixits.  */\n   fixit_hint *prev = get_last_fixit_hint ();\n-  if (prev)\n+  if (prev && !prev->ends_with_newline_p ())\n     if (prev->maybe_append (start, next_loc, new_content))\n       return;\n \n@@ -2398,3 +2426,13 @@ fixit_hint::maybe_append (source_location start,\n   m_bytes[m_len] = '\\0';\n   return true;\n }\n+\n+/* Return true iff this hint's content ends with a newline.  */\n+\n+bool\n+fixit_hint::ends_with_newline_p () const\n+{\n+  if (m_len == 0)\n+    return false;\n+  return m_bytes[m_len - 1] == '\\n';\n+}"}]}