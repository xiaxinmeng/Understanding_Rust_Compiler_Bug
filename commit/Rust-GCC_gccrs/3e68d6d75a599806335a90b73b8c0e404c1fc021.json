{"sha": "3e68d6d75a599806335a90b73b8c0e404c1fc021", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2OGQ2ZDc1YTU5OTgwNjMzNWE5MGI3M2I4YzBlNDA0YzFmYzAyMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-01T08:06:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-01T08:06:16Z"}, "message": "compiler/runtime: Copy channel implementation from master library.\n\nFrom-SVN: r181874", "tree": {"sha": "4be7e6271bd15650eafafeac4e96b4899f1d47d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4be7e6271bd15650eafafeac4e96b4899f1d47d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e68d6d75a599806335a90b73b8c0e404c1fc021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e68d6d75a599806335a90b73b8c0e404c1fc021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e68d6d75a599806335a90b73b8c0e404c1fc021", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e68d6d75a599806335a90b73b8c0e404c1fc021/comments", "author": null, "committer": null, "parents": [{"sha": "04f7a48eddb72c733d6ae586bcaace89773b3172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f7a48eddb72c733d6ae586bcaace89773b3172", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04f7a48eddb72c733d6ae586bcaace89773b3172"}], "stats": {"total": 4416, "additions": 1621, "deletions": 2795}, "files": [{"sha": "a80c82375ce597919bbc975fed366a3af66444b8", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -13493,12 +13493,18 @@ Receive_expression::do_check_types(Gogo*)\n tree\n Receive_expression::do_get_tree(Translate_context* context)\n {\n+  Location loc = this->location();\n+\n   Channel_type* channel_type = this->channel_->type()->channel_type();\n   if (channel_type == NULL)\n     {\n       go_assert(this->channel_->type()->is_error());\n       return error_mark_node;\n     }\n+\n+  Expression* td = Expression::make_type_descriptor(channel_type, loc);\n+  tree td_tree = td->get_tree(context);\n+\n   Type* element_type = channel_type->element_type();\n   Btype* element_type_btype = element_type->get_backend(context->gogo());\n   tree element_type_tree = type_to_tree(element_type_btype);\n@@ -13507,8 +13513,7 @@ Receive_expression::do_get_tree(Translate_context* context)\n   if (element_type_tree == error_mark_node || channel == error_mark_node)\n     return error_mark_node;\n \n-  return Gogo::receive_from_channel(element_type_tree, channel,\n-\t\t\t\t    this->for_select_, this->location());\n+  return Gogo::receive_from_channel(element_type_tree, td_tree, channel, loc);\n }\n \n // Dump ast representation for a receive expression."}, {"sha": "6da507b57ca49c34132ef1262ac8fb77131b8e5e", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -1947,19 +1947,14 @@ class Receive_expression : public Expression\n  public:\n   Receive_expression(Expression* channel, Location location)\n     : Expression(EXPRESSION_RECEIVE, location),\n-      channel_(channel), for_select_(false)\n+      channel_(channel)\n   { }\n \n   // Return the channel.\n   Expression*\n   channel()\n   { return this->channel_; }\n \n-  // Note that this is for a select statement.\n-  void\n-  set_for_select()\n-  { this->for_select_ = true; }\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse)\n@@ -1998,8 +1993,6 @@ class Receive_expression : public Expression\n  private:\n   // The channel from which we are receiving.\n   Expression* channel_;\n-  // Whether this is for a select statement.\n-  bool for_select_;\n };\n \n #endif // !defined(GO_EXPRESSIONS_H)"}, {"sha": "dd66a7f6832701a31684daf00be95e32e11d3d18", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -2201,13 +2201,12 @@ Gogo::runtime_error(int code, Location location)\n }\n \n // Return a tree for receiving a value of type TYPE_TREE on CHANNEL.\n-// This does a blocking receive and returns the value read from the\n-// channel.  If FOR_SELECT is true, this is being done because it was\n-// chosen in a select statement.\n+// TYPE_DESCRIPTOR_TREE is the channel's type descriptor.  This does a\n+// blocking receive and returns the value read from the channel.\n \n tree\n-Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n-\t\t\t   Location location)\n+Gogo::receive_from_channel(tree type_tree, tree type_descriptor_tree,\n+\t\t\t   tree channel, Location location)\n {\n   if (type_tree == error_mark_node || channel == error_mark_node)\n     return error_mark_node;\n@@ -2222,12 +2221,10 @@ Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n \t\t\t\t     \"__go_receive_small\",\n \t\t\t\t     2,\n \t\t\t\t     uint64_type_node,\n+\t\t\t\t     TREE_TYPE(type_descriptor_tree),\n+\t\t\t\t     type_descriptor_tree,\n \t\t\t\t     ptr_type_node,\n-\t\t\t\t     channel,\n-\t\t\t\t     boolean_type_node,\n-\t\t\t\t     (for_select\n-\t\t\t\t      ? boolean_true_node\n-\t\t\t\t      : boolean_false_node));\n+\t\t\t\t     channel);\n       if (call == error_mark_node)\n \treturn error_mark_node;\n       // This can panic if there are too many operations on a closed\n@@ -2253,15 +2250,13 @@ Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n \t\t\t\t     location,\n \t\t\t\t     \"__go_receive_big\",\n \t\t\t\t     3,\n-\t\t\t\t     boolean_type_node,\n+\t\t\t\t     void_type_node,\n+\t\t\t\t     TREE_TYPE(type_descriptor_tree),\n+\t\t\t\t     type_descriptor_tree,\n \t\t\t\t     ptr_type_node,\n \t\t\t\t     channel,\n \t\t\t\t     ptr_type_node,\n-\t\t\t\t     tmpaddr,\n-\t\t\t\t     boolean_type_node,\n-\t\t\t\t     (for_select\n-\t\t\t\t      ? boolean_true_node\n-\t\t\t\t      : boolean_false_node));\n+\t\t\t\t     tmpaddr);\n       if (call == error_mark_node)\n \treturn error_mark_node;\n       // This can panic if there are too many operations on a closed"}, {"sha": "6efce18cfac1121dd90d146ed882060af35c4ed3", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -527,14 +527,9 @@ class Gogo\n \n   // Receive a value from a channel.\n   static tree\n-  receive_from_channel(tree type_tree, tree channel, bool for_select,\n+  receive_from_channel(tree type_tree, tree type_descriptor_tree, tree channel,\n \t\t       Location);\n \n-  // Return a tree for receiving an integer on a channel.\n-  static tree\n-  receive_as_64bit_integer(tree type, tree channel, bool blocking,\n-\t\t\t   bool for_select);\n-\n   // Make a trampoline which calls FNADDR passing CLOSURE.\n   tree\n   make_trampoline(tree fnaddr, tree closure, Location);"}, {"sha": "37a97825bcd09c45aed0e5038cf6818951488387", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -1780,7 +1780,6 @@ Parse::init_vars_from_receive(const Typed_identifier_list* vars, Type* type,\n   Statement* s = Statement::make_tuple_receive_assignment(val_var,\n \t\t\t\t\t\t\t  received_var,\n \t\t\t\t\t\t\t  receive->channel(),\n-\t\t\t\t\t\t\t  false,\n \t\t\t\t\t\t\t  location);\n \n   if (!this->gogo_->in_global_scope())\n@@ -3769,7 +3768,6 @@ Parse::tuple_assignment(Expression_list* lhs, Range_clause* p_range_clause)\n       Expression* channel = receive->channel();\n       Statement* s = Statement::make_tuple_receive_assignment(val, success,\n \t\t\t\t\t\t\t      channel,\n-\t\t\t\t\t\t\t      false,\n \t\t\t\t\t\t\t      location);\n       this->gogo_->add_statement(s);\n     }"}, {"sha": "bffefbb051309e8411475130a8c6eb6be57de92b", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -54,8 +54,6 @@ enum Runtime_function_type\n   RFT_MAPITER,\n   // Go type chan any, C type struct __go_channel *.\n   RFT_CHAN,\n-  // Go type *chan any, C type struct __go_channel **.\n-  RFT_CHANPTR,\n   // Go type non-empty interface, C type struct __go_interface.\n   RFT_IFACE,\n   // Go type interface{}, C type struct __go_empty_interface.\n@@ -148,10 +146,6 @@ runtime_function_type(Runtime_function_type bft)\n \t  t = Type::make_channel_type(true, true, Type::make_void_type());\n \t  break;\n \n-\tcase RFT_CHANPTR:\n-\t  t = Type::make_pointer_type(runtime_function_type(RFT_CHAN));\n-\t  break;\n-\n \tcase RFT_IFACE:\n \t  {\n \t    Typed_identifier_list* methods = new Typed_identifier_list();\n@@ -223,7 +217,6 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_SLICE:\n     case RFT_MAP:\n     case RFT_CHAN:\n-    case RFT_CHANPTR:\n     case RFT_IFACE:\n     case RFT_EFACE:\n       return Expression::make_unsafe_cast(runtime_function_type(bft), e, loc);\n@@ -393,12 +386,3 @@ Runtime::map_iteration_type()\n \n   return Type::make_array_type(runtime_function_type(RFT_POINTER), iexpr);\n }\n-\n-// Return the type used to pass a list of general channels to the\n-// select runtime function.\n-\n-Type*\n-Runtime::chanptr_type()\n-{\n-  return runtime_function_type(RFT_CHANPTR);\n-}"}, {"sha": "fe842c93b9bf0858f904ab819912462f03bfb260", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -121,31 +121,44 @@ DEF_GO_RUNTIME(CHAN_LEN, \"__go_chan_len\", P1(CHAN), R1(INT))\n DEF_GO_RUNTIME(CHAN_CAP, \"__go_chan_cap\", P1(CHAN), R1(INT))\n \n // Send a small value on a channel.\n-DEF_GO_RUNTIME(SEND_SMALL, \"__go_send_small\", P3(CHAN, UINT64, BOOL), R0())\n-\n-// Send a small value on a channel without blocking.\n-DEF_GO_RUNTIME(SEND_NONBLOCKING_SMALL, \"__go_send_nonblocking_small\",\n-\t       P2(CHAN, UINT64), R1(BOOL))\n+DEF_GO_RUNTIME(SEND_SMALL, \"__go_send_small\", P3(TYPE, CHAN, UINT64), R0())\n \n // Send a big value on a channel.\n-DEF_GO_RUNTIME(SEND_BIG, \"__go_send_big\", P3(CHAN, POINTER, BOOL), R0())\n-\n-// Send a big value on a channel without blocking.\n-DEF_GO_RUNTIME(SEND_NONBLOCKING_BIG, \"__go_send_nonblocking_big\",\n-\t       P2(CHAN, POINTER), R1(BOOL))\n+DEF_GO_RUNTIME(SEND_BIG, \"__go_send_big\", P3(TYPE, CHAN, POINTER), R0())\n \n // Receive a small value from a channel.\n-DEF_GO_RUNTIME(RECEIVE_SMALL, \"__go_receive_small\", P2(CHAN, BOOL), R1(UINT64))\n+DEF_GO_RUNTIME(RECEIVE_SMALL, \"__go_receive_small\", P2(TYPE, CHAN), R1(UINT64))\n \n // Receive a big value from a channel.\n-DEF_GO_RUNTIME(RECEIVE_BIG, \"__go_receive_big\", P3(CHAN, POINTER, BOOL),\n-\t       R1(BOOL))\n+DEF_GO_RUNTIME(RECEIVE_BIG, \"__go_receive_big\", P3(TYPE, CHAN, POINTER), R0())\n \n // Receive a value from a channel returning whether it is closed.\n-DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P2(CHAN, POINTER), R1(BOOL))\n+DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P3(TYPE, CHAN, POINTER),\n+\t       R1(BOOL))\n+\n+\n+// Start building a select statement.\n+DEF_GO_RUNTIME(NEWSELECT, \"runtime.newselect\", P1(INT), R1(POINTER))\n \n-// Receive a value from a channel returning whether it is closed, for select.\n-DEF_GO_RUNTIME(CHANRECV3, \"runtime.chanrecv3\", P2(CHAN, POINTER), R1(BOOL))\n+// Add a default clause to a select statement.\n+DEF_GO_RUNTIME(SELECTDEFAULT, \"runtime.selectdefault\", P2(POINTER, INT), R0())\n+\n+// Add a send clause to a select statement.\n+DEF_GO_RUNTIME(SELECTSEND, \"runtime.selectsend\",\n+\t       P4(POINTER, CHAN, POINTER, INT), R0())\n+\n+// Add a receive clause to a select statement, for a clause which does\n+// not check whether the channel is closed.\n+DEF_GO_RUNTIME(SELECTRECV, \"runtime.selectrecv\",\n+\t       P4(POINTER, CHAN, POINTER, INT), R0())\n+\n+// Add a receive clause to a select statement, for a clause which does\n+// check whether the channel is closed.\n+DEF_GO_RUNTIME(SELECTRECV2, \"runtime.selectrecv2\",\n+\t       P5(POINTER, CHAN, POINTER, BOOLPTR, INT), R0())\n+\n+// Run a select, returning the index of the selected clause.\n+DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P1(POINTER), R1(INT))\n \n \n // Panic.\n@@ -213,11 +226,6 @@ DEF_GO_RUNTIME(GO, \"__go_go\", P2(FUNC_PTR, POINTER), R0())\n DEF_GO_RUNTIME(DEFER, \"__go_defer\", P3(BOOLPTR, FUNC_PTR, POINTER), R0())\n \n \n-// Run a select statement.\n-DEF_GO_RUNTIME(SELECT, \"__go_select\", P4(UINTPTR, BOOL, CHANPTR, BOOLPTR),\n-\t       R1(UINTPTR))\n-\n-\n // Convert an empty interface to an empty interface, returning ok.\n DEF_GO_RUNTIME(IFACEE2E2, \"runtime.ifaceE2E2\", P1(EFACE), R2(EFACE, BOOL))\n "}, {"sha": "be5dcbe25d07166deef57d1e995e2f229ae28801", "filename": "gcc/go/gofrontend/runtime.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.h?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -43,11 +43,6 @@ class Runtime\n   static Type*\n   map_iteration_type();\n \n-  // Return the type used to pass a list of general channels to the\n-  // select runtime function.\n-  static Type*\n-  chanptr_type();\n-\n  private:\n   static Named_object*\n   runtime_declaration(Function);"}, {"sha": "964b394c3bdb9e087c135dfc27ecf09686c132aa", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 239, "deletions": 305, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -1329,10 +1329,9 @@ class Tuple_receive_assignment_statement : public Statement\n {\n  public:\n   Tuple_receive_assignment_statement(Expression* val, Expression* closed,\n-\t\t\t\t     Expression* channel, bool for_select,\n-\t\t\t\t     Location location)\n+\t\t\t\t     Expression* channel, Location location)\n     : Statement(STATEMENT_TUPLE_RECEIVE_ASSIGNMENT, location),\n-      val_(val), closed_(closed), channel_(channel), for_select_(for_select)\n+      val_(val), closed_(closed), channel_(channel)\n   { }\n \n  protected:\n@@ -1360,8 +1359,6 @@ class Tuple_receive_assignment_statement : public Statement\n   Expression* closed_;\n   // The channel on which we receive the value.\n   Expression* channel_;\n-  // Whether this is for a select statement.\n-  bool for_select_;\n };\n \n // Traversal.\n@@ -1414,14 +1411,14 @@ Tuple_receive_assignment_statement::do_lower(Gogo*, Named_object*,\n     Statement::make_temporary(Type::lookup_bool_type(), NULL, loc);\n   b->add_statement(closed_temp);\n \n-  // closed_temp = chanrecv[23](channel, &val_temp)\n+  // closed_temp = chanrecv2(type, channel, &val_temp)\n+  Expression* td = Expression::make_type_descriptor(this->channel_->type(),\n+\t\t\t\t\t\t    loc);\n   Temporary_reference_expression* ref =\n     Expression::make_temporary_reference(val_temp, loc);\n   Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  Expression* call = Runtime::make_call((this->for_select_\n-\t\t\t\t\t ? Runtime::CHANRECV3\n-\t\t\t\t\t : Runtime::CHANRECV2),\n-\t\t\t\t\tloc, 2, this->channel_, p2);\n+  Expression* call = Runtime::make_call(Runtime::CHANRECV2,\n+\t\t\t\t\tloc, 3, td, this->channel_, p2);\n   ref = Expression::make_temporary_reference(closed_temp, loc);\n   ref->set_is_lvalue();\n   Statement* s = Statement::make_assignment(ref, call, loc);\n@@ -1460,11 +1457,10 @@ Tuple_receive_assignment_statement::do_dump_statement(\n Statement*\n Statement::make_tuple_receive_assignment(Expression* val, Expression* closed,\n \t\t\t\t\t Expression* channel,\n-\t\t\t\t\t bool for_select,\n \t\t\t\t\t Location location)\n {\n   return new Tuple_receive_assignment_statement(val, closed, channel,\n-\t\t\t\t\t\tfor_select, location);\n+\t\t\t\t\t\tlocation);\n }\n \n // An assignment to a pair of values from a type guard.  This is a\n@@ -4391,9 +4387,11 @@ Send_statement::do_get_backend(Translate_context* context)\n       && val->temporary_reference_expression() == NULL)\n     can_take_address = false;\n \n+  Expression* td = Expression::make_type_descriptor(this->channel_->type(),\n+\t\t\t\t\t\t    loc);\n+\n   Runtime::Function code;\n   Bstatement* btemp = NULL;\n-  Expression* call;\n   if (is_small)\n       {\n \t// Type is small enough to handle as uint64.\n@@ -4421,8 +4419,7 @@ Send_statement::do_get_backend(Translate_context* context)\n       btemp = temp->get_backend(context);\n     }\n \n-  call = Runtime::make_call(code, loc, 3, this->channel_, val,\n-\t\t\t    Expression::make_boolean(this->for_select_, loc));\n+  Expression* call = Runtime::make_call(code, loc, 3, td, this->channel_, val);\n \n   context->gogo()->lower_expression(context->function(), NULL, &call);\n   Bexpression* bcall = tree_to_expr(call->get_tree(context));\n@@ -4490,134 +4487,178 @@ Select_clauses::Select_clause::traverse(Traverse* traverse)\n   return TRAVERSE_CONTINUE;\n }\n \n-// Lowering.  Here we pull out the channel and the send values, to\n-// enforce the order of evaluation.  We also add explicit send and\n-// receive statements to the clauses.\n+// Lowering.  We call a function to register this clause, and arrange\n+// to set any variables in any receive clause.\n \n void\n Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n-\t\t\t\t     Block* b)\n+\t\t\t\t     Block* b, Temporary_statement* sel)\n {\n+  Location loc = this->location_;\n+\n+  Expression* selref = Expression::make_temporary_reference(sel, loc);\n+\n+  mpz_t ival;\n+  mpz_init_set_ui(ival, this->index_);\n+  Expression* index_expr = Expression::make_integer(&ival, NULL, loc);\n+  mpz_clear(ival);\n+\n   if (this->is_default_)\n     {\n       go_assert(this->channel_ == NULL && this->val_ == NULL);\n+      this->lower_default(b, selref, index_expr);\n       this->is_lowered_ = true;\n       return;\n     }\n \n-  Location loc = this->location_;\n-\n   // Evaluate the channel before the select statement.\n   Temporary_statement* channel_temp = Statement::make_temporary(NULL,\n \t\t\t\t\t\t\t\tthis->channel_,\n \t\t\t\t\t\t\t\tloc);\n   b->add_statement(channel_temp);\n-  this->channel_ = Expression::make_temporary_reference(channel_temp, loc);\n-\n-  // If this is a send clause, evaluate the value to send before the\n-  // select statement.\n-  Temporary_statement* val_temp = NULL;\n-  if (this->is_send_ && !this->val_->is_constant())\n-    {\n-      val_temp = Statement::make_temporary(NULL, this->val_, loc);\n-      b->add_statement(val_temp);\n-    }\n+  Expression* chanref = Expression::make_temporary_reference(channel_temp,\n+\t\t\t\t\t\t\t     loc);\n \n-  // Add the send or receive before the rest of the statements if any.\n-  Block *init = new Block(b, loc);\n-  Expression* ref = Expression::make_temporary_reference(channel_temp, loc);\n   if (this->is_send_)\n-    {\n-      Expression* ref2;\n-      if (val_temp == NULL)\n-\tref2 = this->val_;\n-      else\n-\tref2 = Expression::make_temporary_reference(val_temp, loc);\n-      Send_statement* send = Statement::make_send_statement(ref, ref2, loc);\n-      send->set_for_select();\n-      init->add_statement(send);\n-    }\n-  else if (this->closed_ != NULL && !this->closed_->is_sink_expression())\n-    {\n-      go_assert(this->var_ == NULL && this->closedvar_ == NULL);\n-      if (this->val_ == NULL)\n-\tthis->val_ = Expression::make_sink(loc);\n-      Statement* s = Statement::make_tuple_receive_assignment(this->val_,\n-\t\t\t\t\t\t\t      this->closed_,\n-\t\t\t\t\t\t\t      ref, true, loc);\n-      init->add_statement(s);\n-    }\n-  else if (this->closedvar_ != NULL)\n-    {\n-      go_assert(this->val_ == NULL);\n-      Expression* val;\n-      if (this->var_ == NULL)\n-\tval = Expression::make_sink(loc);\n-      else\n-\tval = Expression::make_var_reference(this->var_, loc);\n-      Expression* closed = Expression::make_var_reference(this->closedvar_,\n-\t\t\t\t\t\t\t  loc);\n-      Statement* s = Statement::make_tuple_receive_assignment(val, closed, ref,\n-\t\t\t\t\t\t\t      true, loc);\n+    this->lower_send(b, selref, chanref, index_expr);\n+  else\n+    this->lower_recv(gogo, function, b, selref, chanref, index_expr);\n \n-      // We have to put S in STATEMENTS_, because that is where the\n-      // variables are declared.\n+  // Now all references should be handled through the statements, not\n+  // through here.\n+  this->is_lowered_ = true;\n+  this->val_ = NULL;\n+  this->var_ = NULL;\n+}\n \n-      go_assert(this->statements_ != NULL);\n+// Lower a default clause in a select statement.\n \n-      // Skip the variable declaration statements themselves.\n-      size_t skip = 1;\n-      if (this->var_ != NULL)\n-\tskip = 2;\n+void\n+Select_clauses::Select_clause::lower_default(Block* b, Expression* selref,\n+\t\t\t\t\t     Expression* index_expr)\n+{\n+  Location loc = this->location_;\n+  Expression* call = Runtime::make_call(Runtime::SELECTDEFAULT, loc, 2, selref,\n+\t\t\t\t\tindex_expr);\n+  b->add_statement(Statement::make_statement(call, true));\n+}\n \n-      // Verify that we are only skipping variable declarations.\n-      size_t i = 0;\n-      for (Block::iterator p = this->statements_->begin();\n-\t   i < skip && p != this->statements_->end();\n-\t   ++p, ++i)\n-\tgo_assert((*p)->variable_declaration_statement() != NULL);\n+// Lower a send clause in a select statement.\n \n-      this->statements_->insert_statement_before(skip, s);\n+void\n+Select_clauses::Select_clause::lower_send(Block* b, Expression* selref,\n+\t\t\t\t\t  Expression* chanref,\n+\t\t\t\t\t  Expression* index_expr)\n+{\n+  Location loc = this->location_;\n \n-      // We have to lower STATEMENTS_ again, to lower the tuple\n-      // receive assignment we just added.\n-      gogo->lower_block(function, this->statements_);\n-    }\n+  Channel_type* ct = this->channel_->type()->channel_type();\n+  if (ct == NULL)\n+    return;\n+\n+  Type* valtype = ct->element_type();\n+\n+  // Note that copying the value to a temporary here means that we\n+  // evaluate the send values in the required order.\n+  Temporary_statement* val = Statement::make_temporary(valtype, this->val_,\n+\t\t\t\t\t\t       loc);\n+  b->add_statement(val);\n+\n+  Expression* valref = Expression::make_temporary_reference(val, loc);\n+  Expression* valaddr = Expression::make_unary(OPERATOR_AND, valref, loc);\n+\n+  Expression* call = Runtime::make_call(Runtime::SELECTSEND, loc, 4, selref,\n+\t\t\t\t\tchanref, valaddr, index_expr);\n+  b->add_statement(Statement::make_statement(call, true));\n+}\n+\n+// Lower a receive clause in a select statement.\n+\n+void\n+Select_clauses::Select_clause::lower_recv(Gogo* gogo, Named_object* function,\n+\t\t\t\t\t  Block* b, Expression* selref,\n+\t\t\t\t\t  Expression* chanref,\n+\t\t\t\t\t  Expression* index_expr)\n+{\n+  Location loc = this->location_;\n+\n+  Channel_type* ct = this->channel_->type()->channel_type();\n+  if (ct == NULL)\n+    return;\n+\n+  Type* valtype = ct->element_type();\n+  Temporary_statement* val = Statement::make_temporary(valtype, NULL, loc);\n+  b->add_statement(val);\n+\n+  Expression* valref = Expression::make_temporary_reference(val, loc);\n+  Expression* valaddr = Expression::make_unary(OPERATOR_AND, valref, loc);\n+\n+  Temporary_statement* closed_temp = NULL;\n+\n+  Expression* call;\n+  if (this->closed_ == NULL && this->closedvar_ == NULL)\n+    call = Runtime::make_call(Runtime::SELECTRECV, loc, 4, selref, chanref,\n+\t\t\t      valaddr, index_expr);\n   else\n     {\n-      Receive_expression* recv = Expression::make_receive(ref, loc);\n-      recv->set_for_select();\n-      if (this->val_ != NULL)\n-\t{\n-\t  go_assert(this->var_ == NULL);\n-\t  init->add_statement(Statement::make_assignment(this->val_, recv,\n-\t\t\t\t\t\t\t loc));\n-\t}\n-      else if (this->var_ != NULL)\n-\t{\n-\t  this->var_->var_value()->set_init(recv);\n-\t  this->var_->var_value()->clear_type_from_chan_element();\n-\t}\n-      else\n-\t{\n-\t  init->add_statement(Statement::make_statement(recv, true));\n-\t}\n+      closed_temp = Statement::make_temporary(Type::lookup_bool_type(), NULL,\n+\t\t\t\t\t      loc);\n+      b->add_statement(closed_temp);\n+      Expression* cref = Expression::make_temporary_reference(closed_temp,\n+\t\t\t\t\t\t\t      loc);\n+      Expression* caddr = Expression::make_unary(OPERATOR_AND, cref, loc);\n+      call = Runtime::make_call(Runtime::SELECTRECV2, loc, 5, selref, chanref,\n+\t\t\t\tvaladdr, caddr, index_expr);\n     }\n \n-  // Lower any statements we just created.\n-  gogo->lower_block(function, init);\n+  b->add_statement(Statement::make_statement(call, true));\n \n-  if (this->statements_ != NULL)\n-    init->add_statement(Statement::make_block_statement(this->statements_,\n-\t\t\t\t\t\t\tloc));\n+  // If the block of statements is executed, arrange for the received\n+  // value to move from VAL to the place where the statements expect\n+  // it.\n \n-  this->statements_ = init;\n+  Block* init = NULL;\n \n-  // Now all references should be handled through the statements, not\n-  // through here.\n-  this->is_lowered_ = true;\n-  this->val_ = NULL;\n-  this->var_ = NULL;\n+  if (this->var_ != NULL)\n+    {\n+      go_assert(this->val_ == NULL);\n+      valref = Expression::make_temporary_reference(val, loc);\n+      this->var_->var_value()->set_init(valref);\n+      this->var_->var_value()->clear_type_from_chan_element();\n+    }\n+  else if (this->val_ != NULL && !this->val_->is_sink_expression())\n+    {\n+      init = new Block(b, loc);\n+      valref = Expression::make_temporary_reference(val, loc);\n+      init->add_statement(Statement::make_assignment(this->val_, valref, loc));\n+    }\n+\n+  if (this->closedvar_ != NULL)\n+    {\n+      go_assert(this->closed_ == NULL);\n+      Expression* cref = Expression::make_temporary_reference(closed_temp,\n+\t\t\t\t\t\t\t      loc);\n+      this->closedvar_->var_value()->set_init(cref);\n+    }\n+  else if (this->closed_ != NULL && !this->closed_->is_sink_expression())\n+    {\n+      if (init == NULL)\n+\tinit = new Block(b, loc);\n+      Expression* cref = Expression::make_temporary_reference(closed_temp,\n+\t\t\t\t\t\t\t      loc);\n+      init->add_statement(Statement::make_assignment(this->closed_, cref,\n+\t\t\t\t\t\t     loc));\n+    }\n+\n+  if (init != NULL)\n+    {\n+      gogo->lower_block(function, init);\n+\n+      if (this->statements_ != NULL)\n+\tinit->add_statement(Statement::make_block_statement(this->statements_,\n+\t\t\t\t\t\t\t    loc));\n+      this->statements_ = init;\n+    }\n }\n \n // Determine types.\n@@ -4630,6 +4671,27 @@ Select_clauses::Select_clause::determine_types()\n     this->statements_->determine_types();\n }\n \n+// Check types.\n+\n+void\n+Select_clauses::Select_clause::check_types()\n+{\n+  if (this->is_default_)\n+    return;\n+\n+  Channel_type* ct = this->channel_->type()->channel_type();\n+  if (ct == NULL)\n+    {\n+      error_at(this->channel_->location(), \"expected channel\");\n+      return;\n+    }\n+\n+  if (this->is_send_ && !ct->may_send())\n+    error_at(this->location(), \"invalid send on receive-only channel\");\n+  else if (!this->is_send_ && !ct->may_receive())\n+    error_at(this->location(), \"invalid receive on send-only channel\");\n+}\n+\n // Whether this clause may fall through to the statement which follows\n // the overall select statement.\n \n@@ -4717,12 +4779,13 @@ Select_clauses::traverse(Traverse* traverse)\n // receive statements to the clauses.\n \n void\n-Select_clauses::lower(Gogo* gogo, Named_object* function, Block* b)\n+Select_clauses::lower(Gogo* gogo, Named_object* function, Block* b,\n+\t\t      Temporary_statement* sel)\n {\n   for (Clauses::iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n        ++p)\n-    p->lower(gogo, function, b);\n+    p->lower(gogo, function, b, sel);\n }\n \n // Determine types.\n@@ -4736,6 +4799,17 @@ Select_clauses::determine_types()\n     p->determine_types();\n }\n \n+// Check types.\n+\n+void\n+Select_clauses::check_types()\n+{\n+  for (Clauses::iterator p = this->clauses_.begin();\n+       p != this->clauses_.end();\n+       ++p)\n+    p->check_types();\n+}\n+\n // Return whether these select clauses fall through to the statement\n // following the overall select statement.\n \n@@ -4750,179 +4824,55 @@ Select_clauses::may_fall_through() const\n   return false;\n }\n \n-// Convert to the backend representation.  We build a call to\n-//   size_t __go_select(size_t count, _Bool has_default,\n-//                      channel* channels, _Bool* is_send)\n-//\n-// There are COUNT entries in the CHANNELS and IS_SEND arrays.  The\n-// value in the IS_SEND array is true for send, false for receive.\n-// __go_select returns an integer from 0 to COUNT, inclusive.  A\n-// return of 0 means that the default case should be run; this only\n-// happens if HAS_DEFAULT is non-zero.  Otherwise the number indicates\n-// the case to run.\n-\n-// FIXME: This doesn't handle channels which send interface types\n-// where the receiver has a static type which matches that interface.\n+// Convert to the backend representation.  We have already accumulated\n+// all the select information.  Now we call selectgo, which will\n+// return the index of the clause to execute.\n \n Bstatement*\n Select_clauses::get_backend(Translate_context* context,\n+\t\t\t    Temporary_statement* sel,\n \t\t\t    Unnamed_label *break_label,\n \t\t\t    Location location)\n {\n   size_t count = this->clauses_.size();\n+  std::vector<std::vector<Bexpression*> > cases(count);\n+  std::vector<Bstatement*> clauses(count);\n \n-  Expression_list* chan_init = new Expression_list();\n-  chan_init->reserve(count);\n-\n-  Expression_list* is_send_init = new Expression_list();\n-  is_send_init->reserve(count);\n-\n-  Select_clause *default_clause = NULL;\n-\n-  Type* runtime_chanptr_type = Runtime::chanptr_type();\n-  Type* runtime_chan_type = runtime_chanptr_type->points_to();\n-\n+  int i = 0;\n   for (Clauses::iterator p = this->clauses_.begin();\n        p != this->clauses_.end();\n-       ++p)\n+       ++p, ++i)\n     {\n-      if (p->is_default())\n-\t{\n-\t  default_clause = &*p;\n-\t  --count;\n-\t  continue;\n-\t}\n-\n-      if (p->channel()->type()->channel_type() == NULL)\n-\t{\n-\t  // We should have given an error in the send or receive\n-\t  // statement we created via lowering.\n-\t  go_assert(saw_errors());\n-\t  return context->backend()->error_statement();\n-\t}\n-\n-      Expression* c = p->channel();\n-      c = Expression::make_unsafe_cast(runtime_chan_type, c, p->location());\n-      chan_init->push_back(c);\n+      int index = p->index();\n+      mpz_t ival;\n+      mpz_init_set_ui(ival, index);\n+      Expression* index_expr = Expression::make_integer(&ival, NULL, location);\n+      mpz_clear(ival);\n+      cases[i].push_back(tree_to_expr(index_expr->get_tree(context)));\n \n-      is_send_init->push_back(Expression::make_boolean(p->is_send(),\n-\t\t\t\t\t\t       p->location()));\n-    }\n+      Bstatement* s = p->get_statements_backend(context);\n+      Location gloc = (p->statements() == NULL\n+\t\t       ? p->location()\n+\t\t       : p->statements()->end_location());\n+      Bstatement* g = break_label->get_goto(context, gloc);\n \n-  if (chan_init->empty())\n-    {\n-      go_assert(count == 0);\n-      Bstatement* s;\n-      Bstatement* ldef = break_label->get_definition(context);\n-      if (default_clause != NULL)\n-\t{\n-\t  // There is a default clause and no cases.  Just execute the\n-\t  // default clause.\n-\t  s = default_clause->get_statements_backend(context);\n-\t}\n-      else\n-\t{\n-\t  // There isn't even a default clause.  In this case select\n-\t  // pauses forever.  Call the runtime function with nils.\n-\t  mpz_t zval;\n-\t  mpz_init_set_ui(zval, 0);\n-\t  Expression* zero = Expression::make_integer(&zval, NULL, location);\n-\t  mpz_clear(zval);\n-\t  Expression* default_arg = Expression::make_boolean(false, location);\n-\t  Expression* nil1 = Expression::make_nil(location);\n-\t  Expression* nil2 = nil1->copy();\n-\t  Expression* call = Runtime::make_call(Runtime::SELECT, location, 4,\n-\t\t\t\t\t\tzero, default_arg, nil1, nil2);\n-\t  context->gogo()->lower_expression(context->function(), NULL, &call);\n-\t  Bexpression* bcall = tree_to_expr(call->get_tree(context));\n-\t  s = context->backend()->expression_statement(bcall);\n-\t}\n       if (s == NULL)\n-\treturn ldef;\n-      return context->backend()->compound_statement(s, ldef);\n+\tclauses[i] = g;\n+      else\n+\tclauses[i] = context->backend()->compound_statement(s, g);\n     }\n-  go_assert(count > 0);\n-\n-  std::vector<Bstatement*> statements;\n \n-  mpz_t ival;\n-  mpz_init_set_ui(ival, count);\n-  Expression* ecount = Expression::make_integer(&ival, NULL, location);\n-  mpz_clear(ival);\n-\n-  Type* chan_array_type = Type::make_array_type(runtime_chan_type, ecount);\n-  Expression* chans = Expression::make_composite_literal(chan_array_type, 0,\n-\t\t\t\t\t\t\t false, chan_init,\n-\t\t\t\t\t\t\t location);\n-  context->gogo()->lower_expression(context->function(), NULL, &chans);\n-  Temporary_statement* chan_temp = Statement::make_temporary(chan_array_type,\n-\t\t\t\t\t\t\t     chans,\n-\t\t\t\t\t\t\t     location);\n-  statements.push_back(chan_temp->get_backend(context));\n-\n-  Type* is_send_array_type = Type::make_array_type(Type::lookup_bool_type(),\n-\t\t\t\t\t\t   ecount->copy());\n-  Expression* is_sends = Expression::make_composite_literal(is_send_array_type,\n-\t\t\t\t\t\t\t    0, false,\n-\t\t\t\t\t\t\t    is_send_init,\n-\t\t\t\t\t\t\t    location);\n-  context->gogo()->lower_expression(context->function(), NULL, &is_sends);\n-  Temporary_statement* is_send_temp =\n-    Statement::make_temporary(is_send_array_type, is_sends, location);\n-  statements.push_back(is_send_temp->get_backend(context));\n-\n-  mpz_init_set_ui(ival, 0);\n-  Expression* zero = Expression::make_integer(&ival, NULL, location);\n-  mpz_clear(ival);\n-\n-  Expression* ref = Expression::make_temporary_reference(chan_temp, location);\n-  Expression* chan_arg = Expression::make_array_index(ref, zero, NULL,\n-\t\t\t\t\t\t      location);\n-  chan_arg = Expression::make_unary(OPERATOR_AND, chan_arg, location);\n-  chan_arg = Expression::make_unsafe_cast(runtime_chanptr_type, chan_arg,\n-\t\t\t\t\t  location);\n-\n-  ref = Expression::make_temporary_reference(is_send_temp, location);\n-  Expression* is_send_arg = Expression::make_array_index(ref, zero->copy(),\n-\t\t\t\t\t\t\t NULL, location);\n-  is_send_arg = Expression::make_unary(OPERATOR_AND, is_send_arg, location);\n-\n-  Expression* default_arg = Expression::make_boolean(default_clause != NULL,\n-\t\t\t\t\t\t     location);\n-  Expression* call = Runtime::make_call(Runtime::SELECT, location, 4,\n-\t\t\t\t\tecount->copy(), default_arg,\n-\t\t\t\t\tchan_arg, is_send_arg);\n+  Expression* selref = Expression::make_temporary_reference(sel, location);\n+  Expression* call = Runtime::make_call(Runtime::SELECTGO, location, 1,\n+\t\t\t\t\tselref);\n   context->gogo()->lower_expression(context->function(), NULL, &call);\n   Bexpression* bcall = tree_to_expr(call->get_tree(context));\n \n-  std::vector<std::vector<Bexpression*> > cases;\n-  std::vector<Bstatement*> clauses;\n+  if (count == 0)\n+    return context->backend()->expression_statement(bcall);\n \n-  cases.resize(count + (default_clause != NULL ? 1 : 0));\n-  clauses.resize(count + (default_clause != NULL ? 1 : 0));\n-\n-  int index = 0;\n-\n-  if (default_clause != NULL)\n-    {\n-      this->add_clause_backend(context, location, index, 0, default_clause,\n-\t\t\t       break_label, &cases, &clauses);\n-      ++index;\n-    }\n-\n-  int i = 1;\n-  for (Clauses::iterator p = this->clauses_.begin();\n-       p != this->clauses_.end();\n-       ++p)\n-    {\n-      if (!p->is_default())\n-\t{\n-\t  this->add_clause_backend(context, location, index, i, &*p,\n-\t\t\t\t   break_label, &cases, &clauses);\n-\t  ++i;\n-\t  ++index;\n-\t}\n-    }\n+  std::vector<Bstatement*> statements;\n+  statements.reserve(2);\n \n   Bstatement* switch_stmt = context->backend()->switch_statement(bcall,\n \t\t\t\t\t\t\t\t cases,\n@@ -4935,39 +4885,6 @@ Select_clauses::get_backend(Translate_context* context,\n \n   return context->backend()->statement_list(statements);\n }\n-\n-// Add CLAUSE to CASES/CLAUSES at INDEX.\n-\n-void\n-Select_clauses::add_clause_backend(\n-    Translate_context* context,\n-    Location location,\n-    int index,\n-    int case_value,\n-    Select_clause* clause,\n-    Unnamed_label* bottom_label,\n-    std::vector<std::vector<Bexpression*> > *cases,\n-    std::vector<Bstatement*>* clauses)\n-{\n-  mpz_t ival;\n-  mpz_init_set_ui(ival, case_value);\n-  Expression* e = Expression::make_integer(&ival, NULL, location);\n-  mpz_clear(ival);\n-  (*cases)[index].push_back(tree_to_expr(e->get_tree(context)));\n-\n-  Bstatement* s = clause->get_statements_backend(context);\n-\n-  Location gloc = (clause->statements() == NULL\n-\t\t\t  ? clause->location()\n-\t\t\t  : clause->statements()->end_location());\n-  Bstatement* g = bottom_label->get_goto(context, gloc);\n-\n-  if (s == NULL)\n-    (*clauses)[index] = g;\n-  else\n-    (*clauses)[index] = context->backend()->compound_statement(s, g);\n-}\n-\n // Dump the AST representation for select clauses.\n \n void\n@@ -5003,19 +4920,36 @@ Select_statement::do_lower(Gogo* gogo, Named_object* function,\n {\n   if (this->is_lowered_)\n     return this;\n-  Block* b = new Block(enclosing, this->location());\n-  this->clauses_->lower(gogo, function, b);\n+\n+  Location loc = this->location();\n+\n+  Block* b = new Block(enclosing, loc);\n+\n+  go_assert(this->sel_ == NULL);\n+\n+  mpz_t ival;\n+  mpz_init_set_ui(ival, this->clauses_->size());\n+  Expression* size_expr = Expression::make_integer(&ival, NULL, loc);\n+  mpz_clear(ival);\n+\n+  Expression* call = Runtime::make_call(Runtime::NEWSELECT, loc, 1, size_expr);\n+\n+  this->sel_ = Statement::make_temporary(NULL, call, loc);\n+  b->add_statement(this->sel_);\n+\n+  this->clauses_->lower(gogo, function, b, this->sel_);\n   this->is_lowered_ = true;\n   b->add_statement(this);\n-  return Statement::make_block_statement(b, this->location());\n+\n+  return Statement::make_block_statement(b, loc);\n }\n \n // Return the backend representation for a select statement.\n \n Bstatement*\n Select_statement::do_get_backend(Translate_context* context)\n {\n-  return this->clauses_->get_backend(context, this->break_label(),\n+  return this->clauses_->get_backend(context, this->sel_, this->break_label(),\n \t\t\t\t     this->location());\n }\n \n@@ -5790,7 +5724,7 @@ For_range_statement::lower_range_channel(Gogo*,\n     Expression::make_temporary_reference(ok_temp, loc);\n   oref->set_is_lvalue();\n   Statement* s = Statement::make_tuple_receive_assignment(iref, oref, cref,\n-\t\t\t\t\t\t\t  false, loc);\n+\t\t\t\t\t\t\t  loc);\n   iter_init->add_statement(s);\n \n   Block* then_block = new Block(iter_init, loc);"}, {"sha": "4548ba6f56c8fa06c3a49293bb36b77febca284e", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -165,12 +165,10 @@ class Statement\n \t\t      Expression* should_set, Location);\n \n   // Make an assignment from a nonblocking receive to a pair of\n-  // variables.  FOR_SELECT is true is this is being created for a\n-  // case x, ok := <-c in a select statement.\n+  // variables.\n   static Statement*\n   make_tuple_receive_assignment(Expression* val, Expression* closed,\n-\t\t\t\tExpression* channel, bool for_select,\n-\t\t\t\tLocation);\n+\t\t\t\tExpression* channel, Location);\n \n   // Make an assignment from a type guard to a pair of variables.\n   static Statement*\n@@ -634,14 +632,9 @@ class Send_statement : public Statement\n   Send_statement(Expression* channel, Expression* val,\n \t\t Location location)\n     : Statement(STATEMENT_SEND, location),\n-      channel_(channel), val_(val), for_select_(false)\n+      channel_(channel), val_(val)\n   { }\n \n-  // Note that this is for a select statement.\n-  void\n-  set_for_select()\n-  { this->for_select_ = true; }\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -663,8 +656,6 @@ class Send_statement : public Statement\n   Expression* channel_;\n   // The value to send.\n   Expression* val_;\n-  // Whether this is for a select statement.\n-  bool for_select_;\n };\n \n // Select_clauses holds the clauses of a select statement.  This is\n@@ -693,31 +684,41 @@ class Select_clauses\n       Named_object* var, Named_object* closedvar, bool is_default,\n       Block* statements, Location location)\n   {\n-    this->clauses_.push_back(Select_clause(is_send, channel, val, closed, var,\n-\t\t\t\t\t   closedvar, is_default, statements,\n-\t\t\t\t\t   location));\n+    int index = static_cast<int>(this->clauses_.size());\n+    this->clauses_.push_back(Select_clause(index, is_send, channel, val,\n+\t\t\t\t\t   closed, var, closedvar, is_default,\n+\t\t\t\t\t   statements, location));\n   }\n \n+  size_t\n+  size() const\n+  { return this->clauses_.size(); }\n+\n   // Traverse the select clauses.\n   int\n   traverse(Traverse*);\n \n   // Lower statements.\n   void\n-  lower(Gogo*, Named_object*, Block*);\n+  lower(Gogo*, Named_object*, Block*, Temporary_statement*);\n \n   // Determine types.\n   void\n   determine_types();\n \n+  // Check types.\n+  void\n+  check_types();\n+\n   // Whether the select clauses may fall through to the statement\n   // which follows the overall select statement.\n   bool\n   may_fall_through() const;\n \n   // Convert to the backend representation.\n   Bstatement*\n-  get_backend(Translate_context*, Unnamed_label* break_label, Location);\n+  get_backend(Translate_context*, Temporary_statement* sel,\n+\t      Unnamed_label* break_label, Location);\n \n   // Dump AST representation.\n   void\n@@ -734,27 +735,37 @@ class Select_clauses\n \tis_default_(false)\n     { }\n \n-    Select_clause(bool is_send, Expression* channel, Expression* val,\n-\t\t  Expression* closed, Named_object* var,\n+    Select_clause(int index, bool is_send, Expression* channel,\n+\t\t  Expression* val, Expression* closed, Named_object* var,\n \t\t  Named_object* closedvar, bool is_default, Block* statements,\n \t\t  Location location)\n-      : channel_(channel), val_(val), closed_(closed), var_(var),\n-\tclosedvar_(closedvar), statements_(statements), location_(location),\n-\tis_send_(is_send), is_default_(is_default), is_lowered_(false)\n+      : index_(index), channel_(channel), val_(val), closed_(closed),\n+\tvar_(var), closedvar_(closedvar), statements_(statements),\n+\tlocation_(location), is_send_(is_send), is_default_(is_default),\n+\tis_lowered_(false)\n     { go_assert(is_default ? channel == NULL : channel != NULL); }\n \n+    // Return the index of this clause.\n+    int\n+    index() const\n+    { return this->index_; }\n+\n     // Traverse the select clause.\n     int\n     traverse(Traverse*);\n \n     // Lower statements.\n     void\n-    lower(Gogo*, Named_object*, Block*);\n+    lower(Gogo*, Named_object*, Block*, Temporary_statement*);\n \n     // Determine types.\n     void\n     determine_types();\n \n+    // Check types.\n+    void\n+    check_types();\n+\n     // Return true if this is the default clause.\n     bool\n     is_default() const\n@@ -798,6 +809,18 @@ class Select_clauses\n     dump_clause(Ast_dump_context*) const;\n \n    private:\n+    void\n+    lower_default(Block*, Expression*, Expression*);\n+\n+    void\n+    lower_send(Block*, Expression*, Expression*, Expression*);\n+\n+    void\n+    lower_recv(Gogo*, Named_object*, Block*, Expression*, Expression*,\n+\t       Expression*);\n+\n+    // The index of this case in the generated switch statement.\n+    int index_;\n     // The channel.\n     Expression* channel_;\n     // The value to send or the lvalue to receive into.\n@@ -822,12 +845,6 @@ class Select_clauses\n     bool is_lowered_;\n   };\n \n-  void\n-  add_clause_backend(Translate_context*, Location, int index,\n-\t\t     int case_value, Select_clause*, Unnamed_label*,\n-\t\t     std::vector<std::vector<Bexpression*> >* cases,\n-\t\t     std::vector<Bstatement*>* clauses);\n-\n   typedef std::vector<Select_clause> Clauses;\n \n   Clauses clauses_;\n@@ -840,7 +857,7 @@ class Select_statement : public Statement\n  public:\n   Select_statement(Location location)\n     : Statement(STATEMENT_SELECT, location),\n-      clauses_(NULL), break_label_(NULL), is_lowered_(false)\n+      clauses_(NULL), sel_(NULL), break_label_(NULL), is_lowered_(false)\n   { }\n \n   // Add the clauses.\n@@ -867,6 +884,10 @@ class Select_statement : public Statement\n   do_determine_types()\n   { this->clauses_->determine_types(); }\n \n+  void\n+  do_check_types(Gogo*)\n+  { this->clauses_->check_types(); }\n+\n   bool\n   do_may_fall_through() const\n   { return this->clauses_->may_fall_through(); }\n@@ -880,6 +901,8 @@ class Select_statement : public Statement\n  private:\n   // The select clauses.\n   Select_clauses* clauses_;\n+  // A temporary which holds the select structure we build up at runtime.\n+  Temporary_statement* sel_;\n   // The break label.\n   Unnamed_label* break_label_;\n   // Whether this statement has been lowered."}, {"sha": "19ce7152cf1ba30d57c8f42552c55a65709c6c1d", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -409,10 +409,7 @@ runtime_files = \\\n \truntime/go-caller.c \\\n \truntime/go-can-convert-interface.c \\\n \truntime/go-cgo.c \\\n-\truntime/go-chan-cap.c \\\n-\truntime/go-chan-len.c \\\n \truntime/go-check-interface.c \\\n-\truntime/go-close.c \\\n \truntime/go-construct-map.c \\\n \truntime/go-convert-interface.c \\\n \truntime/go-copy.c \\\n@@ -432,27 +429,16 @@ runtime_files = \\\n \truntime/go-map-len.c \\\n \truntime/go-map-range.c \\\n \truntime/go-nanotime.c \\\n-\truntime/go-new-channel.c \\\n \truntime/go-new-map.c \\\n \truntime/go-new.c \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n-\truntime/go-rec-big.c \\\n-\truntime/go-rec-nb-big.c \\\n-\truntime/go-rec-nb-small.c \\\n-\truntime/go-rec-small.c \\\n \truntime/go-recover.c \\\n \truntime/go-reflect.c \\\n \truntime/go-reflect-call.c \\\n-\truntime/go-reflect-chan.c \\\n \truntime/go-reflect-map.c \\\n \truntime/go-rune.c \\\n \truntime/go-runtime-error.c \\\n-\truntime/go-select.c \\\n-\truntime/go-send-big.c \\\n-\truntime/go-send-nb-big.c \\\n-\truntime/go-send-nb-small.c \\\n-\truntime/go-send-small.c \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strcmp.c \\\n@@ -473,6 +459,7 @@ runtime_files = \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n \truntime/go-unwind.c \\\n+\truntime/chan.c \\\n \truntime/cpuprof.c \\\n \t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n@@ -488,7 +475,6 @@ runtime_files = \\\n \truntime/thread.c \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n-\tchan.c \\\n \tiface.c \\\n \tmalloc.c \\\n \tmap.c \\"}, {"sha": "1a76f0b5a20cf1a9d821621a44a764c0b8600264", "filename": "libgo/Makefile.in", "status": "modified", "additions": 26, "deletions": 156, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -183,8 +183,7 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-assert-interface.c \\\n \truntime/go-byte-array-to-string.c runtime/go-breakpoint.c \\\n \truntime/go-caller.c runtime/go-can-convert-interface.c \\\n-\truntime/go-cgo.c runtime/go-chan-cap.c runtime/go-chan-len.c \\\n-\truntime/go-check-interface.c runtime/go-close.c \\\n+\truntime/go-cgo.c runtime/go-check-interface.c \\\n \truntime/go-construct-map.c runtime/go-convert-interface.c \\\n \truntime/go-copy.c runtime/go-defer.c \\\n \truntime/go-deferred-recover.c runtime/go-eface-compare.c \\\n@@ -195,17 +194,11 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-interface-val-compare.c runtime/go-make-slice.c \\\n \truntime/go-map-delete.c runtime/go-map-index.c \\\n \truntime/go-map-len.c runtime/go-map-range.c \\\n-\truntime/go-nanotime.c runtime/go-new-channel.c \\\n-\truntime/go-new-map.c runtime/go-new.c runtime/go-panic.c \\\n-\truntime/go-print.c runtime/go-rec-big.c \\\n-\truntime/go-rec-nb-big.c runtime/go-rec-nb-small.c \\\n-\truntime/go-rec-small.c runtime/go-recover.c \\\n+\truntime/go-nanotime.c runtime/go-new-map.c runtime/go-new.c \\\n+\truntime/go-panic.c runtime/go-print.c runtime/go-recover.c \\\n \truntime/go-reflect.c runtime/go-reflect-call.c \\\n-\truntime/go-reflect-chan.c runtime/go-reflect-map.c \\\n-\truntime/go-rune.c runtime/go-runtime-error.c \\\n-\truntime/go-select.c runtime/go-send-big.c \\\n-\truntime/go-send-nb-big.c runtime/go-send-nb-small.c \\\n-\truntime/go-send-small.c runtime/go-setenv.c \\\n+\truntime/go-reflect-map.c runtime/go-rune.c \\\n+\truntime/go-runtime-error.c runtime/go-setenv.c \\\n \truntime/go-signal.c runtime/go-strcmp.c \\\n \truntime/go-string-to-byte-array.c \\\n \truntime/go-string-to-int-array.c runtime/go-strplus.c \\\n@@ -215,48 +208,44 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-type-string.c runtime/go-typedesc-equal.c \\\n \truntime/go-typestring.c runtime/go-unreflect.c \\\n \truntime/go-unsafe-new.c runtime/go-unsafe-newarray.c \\\n-\truntime/go-unsafe-pointer.c runtime/go-unwind.c \\\n+\truntime/go-unsafe-pointer.c runtime/go-unwind.c runtime/chan.c \\\n \truntime/cpuprof.c runtime/lock_sema.c runtime/thread-sema.c \\\n \truntime/lock_futex.c runtime/thread-linux.c runtime/mcache.c \\\n \truntime/mcentral.c runtime/mem_posix_memalign.c runtime/mem.c \\\n \truntime/mfinal.c runtime/mfixalloc.c runtime/mgc0.c \\\n \truntime/mheap.c runtime/msize.c runtime/proc.c \\\n \truntime/runtime.c runtime/thread.c runtime/yield.c \\\n-\truntime/rtems-task-variable-add.c chan.c iface.c malloc.c \\\n-\tmap.c mprof.c reflect.c runtime1.c sema.c sigqueue.c string.c\n+\truntime/rtems-task-variable-add.c iface.c malloc.c map.c \\\n+\tmprof.c reflect.c runtime1.c sema.c sigqueue.c string.c\n @LIBGO_IS_LINUX_FALSE@am__objects_1 = lock_sema.lo thread-sema.lo\n @LIBGO_IS_LINUX_TRUE@am__objects_1 = lock_futex.lo thread-linux.lo\n @HAVE_SYS_MMAN_H_FALSE@am__objects_2 = mem_posix_memalign.lo\n @HAVE_SYS_MMAN_H_TRUE@am__objects_2 = mem.lo\n @LIBGO_IS_RTEMS_TRUE@am__objects_3 = rtems-task-variable-add.lo\n am__objects_4 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-byte-array-to-string.lo go-breakpoint.lo go-caller.lo \\\n-\tgo-can-convert-interface.lo go-cgo.lo go-chan-cap.lo \\\n-\tgo-chan-len.lo go-check-interface.lo go-close.lo \\\n+\tgo-can-convert-interface.lo go-cgo.lo go-check-interface.lo \\\n \tgo-construct-map.lo go-convert-interface.lo go-copy.lo \\\n \tgo-defer.lo go-deferred-recover.lo go-eface-compare.lo \\\n \tgo-eface-val-compare.lo go-getgoroot.lo \\\n \tgo-int-array-to-string.lo go-int-to-string.lo \\\n \tgo-interface-compare.lo go-interface-eface-compare.lo \\\n \tgo-interface-val-compare.lo go-make-slice.lo go-map-delete.lo \\\n \tgo-map-index.lo go-map-len.lo go-map-range.lo go-nanotime.lo \\\n-\tgo-new-channel.lo go-new-map.lo go-new.lo go-panic.lo \\\n-\tgo-print.lo go-rec-big.lo go-rec-nb-big.lo go-rec-nb-small.lo \\\n-\tgo-rec-small.lo go-recover.lo go-reflect.lo go-reflect-call.lo \\\n-\tgo-reflect-chan.lo go-reflect-map.lo go-rune.lo \\\n-\tgo-runtime-error.lo go-select.lo go-send-big.lo \\\n-\tgo-send-nb-big.lo go-send-nb-small.lo go-send-small.lo \\\n-\tgo-setenv.lo go-signal.lo go-strcmp.lo \\\n+\tgo-new-map.lo go-new.lo go-panic.lo go-print.lo go-recover.lo \\\n+\tgo-reflect.lo go-reflect-call.lo go-reflect-map.lo go-rune.lo \\\n+\tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n \tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n \tgo-strplus.lo go-strslice.lo go-trampoline.lo go-type-eface.lo \\\n \tgo-type-error.lo go-type-identity.lo go-type-interface.lo \\\n \tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n \tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unwind.lo cpuprof.lo $(am__objects_1) \\\n-\tmcache.lo mcentral.lo $(am__objects_2) mfinal.lo mfixalloc.lo \\\n-\tmgc0.lo mheap.lo msize.lo proc.lo runtime.lo thread.lo \\\n-\tyield.lo $(am__objects_3) chan.lo iface.lo malloc.lo map.lo \\\n-\tmprof.lo reflect.lo runtime1.lo sema.lo sigqueue.lo string.lo\n+\tgo-unsafe-pointer.lo go-unwind.lo chan.lo cpuprof.lo \\\n+\t$(am__objects_1) mcache.lo mcentral.lo $(am__objects_2) \\\n+\tmfinal.lo mfixalloc.lo mgc0.lo mheap.lo msize.lo proc.lo \\\n+\truntime.lo thread.lo yield.lo $(am__objects_3) iface.lo \\\n+\tmalloc.lo map.lo mprof.lo reflect.lo runtime1.lo sema.lo \\\n+\tsigqueue.lo string.lo\n am_libgo_la_OBJECTS = $(am__objects_4)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -836,10 +825,7 @@ runtime_files = \\\n \truntime/go-caller.c \\\n \truntime/go-can-convert-interface.c \\\n \truntime/go-cgo.c \\\n-\truntime/go-chan-cap.c \\\n-\truntime/go-chan-len.c \\\n \truntime/go-check-interface.c \\\n-\truntime/go-close.c \\\n \truntime/go-construct-map.c \\\n \truntime/go-convert-interface.c \\\n \truntime/go-copy.c \\\n@@ -859,27 +845,16 @@ runtime_files = \\\n \truntime/go-map-len.c \\\n \truntime/go-map-range.c \\\n \truntime/go-nanotime.c \\\n-\truntime/go-new-channel.c \\\n \truntime/go-new-map.c \\\n \truntime/go-new.c \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n-\truntime/go-rec-big.c \\\n-\truntime/go-rec-nb-big.c \\\n-\truntime/go-rec-nb-small.c \\\n-\truntime/go-rec-small.c \\\n \truntime/go-recover.c \\\n \truntime/go-reflect.c \\\n \truntime/go-reflect-call.c \\\n-\truntime/go-reflect-chan.c \\\n \truntime/go-reflect-map.c \\\n \truntime/go-rune.c \\\n \truntime/go-runtime-error.c \\\n-\truntime/go-select.c \\\n-\truntime/go-send-big.c \\\n-\truntime/go-send-nb-big.c \\\n-\truntime/go-send-nb-small.c \\\n-\truntime/go-send-small.c \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strcmp.c \\\n@@ -900,6 +875,7 @@ runtime_files = \\\n \truntime/go-unsafe-newarray.c \\\n \truntime/go-unsafe-pointer.c \\\n \truntime/go-unwind.c \\\n+\truntime/chan.c \\\n \truntime/cpuprof.c \\\n \t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n@@ -915,7 +891,6 @@ runtime_files = \\\n \truntime/thread.c \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n-\tchan.c \\\n \tiface.c \\\n \tmalloc.c \\\n \tmap.c \\\n@@ -2461,10 +2436,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-caller.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-can-convert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cgo.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-chan-cap.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-chan-len.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-check-interface.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-close.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-construct-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-convert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-copy.Plo@am__quote@\n@@ -2485,27 +2457,16 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-len.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-range.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-nanotime.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new-channel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-print.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-big.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-nb-big.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-nb-small.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rec-small.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-call.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-chan.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rune.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-runtime-error.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-select.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-send-big.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-send-nb-big.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-send-nb-small.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-send-small.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-signal.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strcmp.Plo@am__quote@\n@@ -2645,34 +2606,13 @@ go-cgo.lo: runtime/go-cgo.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-cgo.lo `test -f 'runtime/go-cgo.c' || echo '$(srcdir)/'`runtime/go-cgo.c\n \n-go-chan-cap.lo: runtime/go-chan-cap.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-chan-cap.lo -MD -MP -MF $(DEPDIR)/go-chan-cap.Tpo -c -o go-chan-cap.lo `test -f 'runtime/go-chan-cap.c' || echo '$(srcdir)/'`runtime/go-chan-cap.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-chan-cap.Tpo $(DEPDIR)/go-chan-cap.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-chan-cap.c' object='go-chan-cap.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-chan-cap.lo `test -f 'runtime/go-chan-cap.c' || echo '$(srcdir)/'`runtime/go-chan-cap.c\n-\n-go-chan-len.lo: runtime/go-chan-len.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-chan-len.lo -MD -MP -MF $(DEPDIR)/go-chan-len.Tpo -c -o go-chan-len.lo `test -f 'runtime/go-chan-len.c' || echo '$(srcdir)/'`runtime/go-chan-len.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-chan-len.Tpo $(DEPDIR)/go-chan-len.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-chan-len.c' object='go-chan-len.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-chan-len.lo `test -f 'runtime/go-chan-len.c' || echo '$(srcdir)/'`runtime/go-chan-len.c\n-\n go-check-interface.lo: runtime/go-check-interface.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-check-interface.lo -MD -MP -MF $(DEPDIR)/go-check-interface.Tpo -c -o go-check-interface.lo `test -f 'runtime/go-check-interface.c' || echo '$(srcdir)/'`runtime/go-check-interface.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-check-interface.Tpo $(DEPDIR)/go-check-interface.Plo\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-check-interface.c' object='go-check-interface.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-check-interface.lo `test -f 'runtime/go-check-interface.c' || echo '$(srcdir)/'`runtime/go-check-interface.c\n \n-go-close.lo: runtime/go-close.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-close.lo -MD -MP -MF $(DEPDIR)/go-close.Tpo -c -o go-close.lo `test -f 'runtime/go-close.c' || echo '$(srcdir)/'`runtime/go-close.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-close.Tpo $(DEPDIR)/go-close.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-close.c' object='go-close.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-close.lo `test -f 'runtime/go-close.c' || echo '$(srcdir)/'`runtime/go-close.c\n-\n go-construct-map.lo: runtime/go-construct-map.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-construct-map.lo -MD -MP -MF $(DEPDIR)/go-construct-map.Tpo -c -o go-construct-map.lo `test -f 'runtime/go-construct-map.c' || echo '$(srcdir)/'`runtime/go-construct-map.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-construct-map.Tpo $(DEPDIR)/go-construct-map.Plo\n@@ -2806,13 +2746,6 @@ go-nanotime.lo: runtime/go-nanotime.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-nanotime.lo `test -f 'runtime/go-nanotime.c' || echo '$(srcdir)/'`runtime/go-nanotime.c\n \n-go-new-channel.lo: runtime/go-new-channel.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-new-channel.lo -MD -MP -MF $(DEPDIR)/go-new-channel.Tpo -c -o go-new-channel.lo `test -f 'runtime/go-new-channel.c' || echo '$(srcdir)/'`runtime/go-new-channel.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-new-channel.Tpo $(DEPDIR)/go-new-channel.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-new-channel.c' object='go-new-channel.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-new-channel.lo `test -f 'runtime/go-new-channel.c' || echo '$(srcdir)/'`runtime/go-new-channel.c\n-\n go-new-map.lo: runtime/go-new-map.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-new-map.lo -MD -MP -MF $(DEPDIR)/go-new-map.Tpo -c -o go-new-map.lo `test -f 'runtime/go-new-map.c' || echo '$(srcdir)/'`runtime/go-new-map.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-new-map.Tpo $(DEPDIR)/go-new-map.Plo\n@@ -2841,34 +2774,6 @@ go-print.lo: runtime/go-print.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-print.lo `test -f 'runtime/go-print.c' || echo '$(srcdir)/'`runtime/go-print.c\n \n-go-rec-big.lo: runtime/go-rec-big.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rec-big.lo -MD -MP -MF $(DEPDIR)/go-rec-big.Tpo -c -o go-rec-big.lo `test -f 'runtime/go-rec-big.c' || echo '$(srcdir)/'`runtime/go-rec-big.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rec-big.Tpo $(DEPDIR)/go-rec-big.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-rec-big.c' object='go-rec-big.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-rec-big.lo `test -f 'runtime/go-rec-big.c' || echo '$(srcdir)/'`runtime/go-rec-big.c\n-\n-go-rec-nb-big.lo: runtime/go-rec-nb-big.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rec-nb-big.lo -MD -MP -MF $(DEPDIR)/go-rec-nb-big.Tpo -c -o go-rec-nb-big.lo `test -f 'runtime/go-rec-nb-big.c' || echo '$(srcdir)/'`runtime/go-rec-nb-big.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rec-nb-big.Tpo $(DEPDIR)/go-rec-nb-big.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-rec-nb-big.c' object='go-rec-nb-big.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-rec-nb-big.lo `test -f 'runtime/go-rec-nb-big.c' || echo '$(srcdir)/'`runtime/go-rec-nb-big.c\n-\n-go-rec-nb-small.lo: runtime/go-rec-nb-small.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rec-nb-small.lo -MD -MP -MF $(DEPDIR)/go-rec-nb-small.Tpo -c -o go-rec-nb-small.lo `test -f 'runtime/go-rec-nb-small.c' || echo '$(srcdir)/'`runtime/go-rec-nb-small.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rec-nb-small.Tpo $(DEPDIR)/go-rec-nb-small.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-rec-nb-small.c' object='go-rec-nb-small.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-rec-nb-small.lo `test -f 'runtime/go-rec-nb-small.c' || echo '$(srcdir)/'`runtime/go-rec-nb-small.c\n-\n-go-rec-small.lo: runtime/go-rec-small.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rec-small.lo -MD -MP -MF $(DEPDIR)/go-rec-small.Tpo -c -o go-rec-small.lo `test -f 'runtime/go-rec-small.c' || echo '$(srcdir)/'`runtime/go-rec-small.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rec-small.Tpo $(DEPDIR)/go-rec-small.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-rec-small.c' object='go-rec-small.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-rec-small.lo `test -f 'runtime/go-rec-small.c' || echo '$(srcdir)/'`runtime/go-rec-small.c\n-\n go-recover.lo: runtime/go-recover.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-recover.lo -MD -MP -MF $(DEPDIR)/go-recover.Tpo -c -o go-recover.lo `test -f 'runtime/go-recover.c' || echo '$(srcdir)/'`runtime/go-recover.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-recover.Tpo $(DEPDIR)/go-recover.Plo\n@@ -2890,13 +2795,6 @@ go-reflect-call.lo: runtime/go-reflect-call.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-reflect-call.lo `test -f 'runtime/go-reflect-call.c' || echo '$(srcdir)/'`runtime/go-reflect-call.c\n \n-go-reflect-chan.lo: runtime/go-reflect-chan.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-reflect-chan.lo -MD -MP -MF $(DEPDIR)/go-reflect-chan.Tpo -c -o go-reflect-chan.lo `test -f 'runtime/go-reflect-chan.c' || echo '$(srcdir)/'`runtime/go-reflect-chan.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-reflect-chan.Tpo $(DEPDIR)/go-reflect-chan.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-reflect-chan.c' object='go-reflect-chan.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-reflect-chan.lo `test -f 'runtime/go-reflect-chan.c' || echo '$(srcdir)/'`runtime/go-reflect-chan.c\n-\n go-reflect-map.lo: runtime/go-reflect-map.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-reflect-map.lo -MD -MP -MF $(DEPDIR)/go-reflect-map.Tpo -c -o go-reflect-map.lo `test -f 'runtime/go-reflect-map.c' || echo '$(srcdir)/'`runtime/go-reflect-map.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-reflect-map.Tpo $(DEPDIR)/go-reflect-map.Plo\n@@ -2918,41 +2816,6 @@ go-runtime-error.lo: runtime/go-runtime-error.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-runtime-error.lo `test -f 'runtime/go-runtime-error.c' || echo '$(srcdir)/'`runtime/go-runtime-error.c\n \n-go-select.lo: runtime/go-select.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-select.lo -MD -MP -MF $(DEPDIR)/go-select.Tpo -c -o go-select.lo `test -f 'runtime/go-select.c' || echo '$(srcdir)/'`runtime/go-select.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-select.Tpo $(DEPDIR)/go-select.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-select.c' object='go-select.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-select.lo `test -f 'runtime/go-select.c' || echo '$(srcdir)/'`runtime/go-select.c\n-\n-go-send-big.lo: runtime/go-send-big.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-send-big.lo -MD -MP -MF $(DEPDIR)/go-send-big.Tpo -c -o go-send-big.lo `test -f 'runtime/go-send-big.c' || echo '$(srcdir)/'`runtime/go-send-big.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-send-big.Tpo $(DEPDIR)/go-send-big.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-send-big.c' object='go-send-big.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-send-big.lo `test -f 'runtime/go-send-big.c' || echo '$(srcdir)/'`runtime/go-send-big.c\n-\n-go-send-nb-big.lo: runtime/go-send-nb-big.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-send-nb-big.lo -MD -MP -MF $(DEPDIR)/go-send-nb-big.Tpo -c -o go-send-nb-big.lo `test -f 'runtime/go-send-nb-big.c' || echo '$(srcdir)/'`runtime/go-send-nb-big.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-send-nb-big.Tpo $(DEPDIR)/go-send-nb-big.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-send-nb-big.c' object='go-send-nb-big.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-send-nb-big.lo `test -f 'runtime/go-send-nb-big.c' || echo '$(srcdir)/'`runtime/go-send-nb-big.c\n-\n-go-send-nb-small.lo: runtime/go-send-nb-small.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-send-nb-small.lo -MD -MP -MF $(DEPDIR)/go-send-nb-small.Tpo -c -o go-send-nb-small.lo `test -f 'runtime/go-send-nb-small.c' || echo '$(srcdir)/'`runtime/go-send-nb-small.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-send-nb-small.Tpo $(DEPDIR)/go-send-nb-small.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-send-nb-small.c' object='go-send-nb-small.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-send-nb-small.lo `test -f 'runtime/go-send-nb-small.c' || echo '$(srcdir)/'`runtime/go-send-nb-small.c\n-\n-go-send-small.lo: runtime/go-send-small.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-send-small.lo -MD -MP -MF $(DEPDIR)/go-send-small.Tpo -c -o go-send-small.lo `test -f 'runtime/go-send-small.c' || echo '$(srcdir)/'`runtime/go-send-small.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-send-small.Tpo $(DEPDIR)/go-send-small.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-send-small.c' object='go-send-small.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-send-small.lo `test -f 'runtime/go-send-small.c' || echo '$(srcdir)/'`runtime/go-send-small.c\n-\n go-setenv.lo: runtime/go-setenv.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-setenv.lo -MD -MP -MF $(DEPDIR)/go-setenv.Tpo -c -o go-setenv.lo `test -f 'runtime/go-setenv.c' || echo '$(srcdir)/'`runtime/go-setenv.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-setenv.Tpo $(DEPDIR)/go-setenv.Plo\n@@ -3093,6 +2956,13 @@ go-unwind.lo: runtime/go-unwind.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-unwind.lo `test -f 'runtime/go-unwind.c' || echo '$(srcdir)/'`runtime/go-unwind.c\n \n+chan.lo: runtime/chan.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT chan.lo -MD -MP -MF $(DEPDIR)/chan.Tpo -c -o chan.lo `test -f 'runtime/chan.c' || echo '$(srcdir)/'`runtime/chan.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/chan.Tpo $(DEPDIR)/chan.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/chan.c' object='chan.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o chan.lo `test -f 'runtime/chan.c' || echo '$(srcdir)/'`runtime/chan.c\n+\n cpuprof.lo: runtime/cpuprof.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cpuprof.lo -MD -MP -MF $(DEPDIR)/cpuprof.Tpo -c -o cpuprof.lo `test -f 'runtime/cpuprof.c' || echo '$(srcdir)/'`runtime/cpuprof.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/cpuprof.Tpo $(DEPDIR)/cpuprof.Plo"}, {"sha": "a246992c60b4111e50789b663bda62b3855686b0", "filename": "libgo/runtime/chan.c", "status": "added", "additions": 1248, "deletions": 0, "changes": 1248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2Fruntime%2Fchan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2Fruntime%2Fchan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.c?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -0,0 +1,1248 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"runtime.h\"\n+#include \"go-type.h\"\n+\n+#define\tNOSELGEN\t1\n+\n+static\tint32\tdebug\t= 0;\n+\n+typedef\tstruct\tWaitQ\tWaitQ;\n+typedef\tstruct\tSudoG\tSudoG;\n+typedef\tstruct\tSelect\tSelect;\n+typedef\tstruct\tScase\tScase;\n+\n+typedef struct\t__go_type_descriptor\tType;\n+typedef struct\t__go_channel_type\tChanType;\n+\n+struct\tSudoG\n+{\n+\tG*\tg;\t\t// g and selgen constitute\n+\tuint32\tselgen;\t\t// a weak pointer to g\n+\tSudoG*\tlink;\n+\tbyte*\telem;\t\t// data element\n+};\n+\n+struct\tWaitQ\n+{\n+\tSudoG*\tfirst;\n+\tSudoG*\tlast;\n+};\n+\n+struct\tHchan\n+{\n+\tuint32\tqcount;\t\t\t// total data in the q\n+\tuint32\tdataqsiz;\t\t// size of the circular q\n+\tuint16\telemsize;\n+\tbool\tclosed;\n+\tuint8\telemalign;\n+\tuint32\tsendx;\t\t\t// send index\n+\tuint32\trecvx;\t\t\t// receive index\n+\tWaitQ\trecvq;\t\t\t// list of recv waiters\n+\tWaitQ\tsendq;\t\t\t// list of send waiters\n+\tLock;\n+};\n+\n+// Buffer follows Hchan immediately in memory.\n+// chanbuf(c, i) is pointer to the i'th slot in the buffer.\n+#define chanbuf(c, i) ((byte*)((c)+1)+(uintptr)(c)->elemsize*(i))\n+\n+enum\n+{\n+\t// Scase.kind\n+\tCaseRecv,\n+\tCaseSend,\n+\tCaseDefault,\n+};\n+\n+struct\tScase\n+{\n+\tSudoG\tsg;\t\t\t// must be first member (cast to Scase)\n+\tHchan*\tchan;\t\t\t// chan\n+\tuint16\tkind;\n+\tuint16\tindex;\t\t\t// index to return\n+\tbool*\treceivedp;\t\t// pointer to received bool (recv2)\n+};\n+\n+struct\tSelect\n+{\n+\tuint16\ttcase;\t\t\t// total count of scase[]\n+\tuint16\tncase;\t\t\t// currently filled scase[]\n+\tuint16*\tpollorder;\t\t// case poll order\n+\tHchan**\tlockorder;\t\t// channel lock order\n+\tScase\tscase[1];\t\t// one per case (in order of appearance)\n+};\n+\n+static\tvoid\tdequeueg(WaitQ*);\n+static\tSudoG*\tdequeue(WaitQ*);\n+static\tvoid\tenqueue(WaitQ*, SudoG*);\n+\n+Hchan*\n+runtime_makechan_c(ChanType *t, int64 hint)\n+{\n+\tHchan *c;\n+\tint32 n;\n+\tconst Type *elem;\n+\t\n+\telem = t->__element_type;\n+\n+\tif(hint < 0 || (int32)hint != hint || (elem->__size > 0 && (uintptr)hint > ((uintptr)-1) / elem->__size))\n+\t\truntime_panicstring(\"makechan: size out of range\");\n+\n+\tn = sizeof(*c);\n+\n+\t// allocate memory in one call\n+\tc = (Hchan*)runtime_mal(n + hint*elem->__size);\n+\tc->elemsize = elem->__size;\n+\tc->elemalign = elem->__align;\n+\tc->dataqsiz = hint;\n+\n+\tif(debug)\n+\t\truntime_printf(\"makechan: chan=%p; elemsize=%lld; elemalign=%d; dataqsiz=%d\\n\",\n+\t\t\tc, (long long)elem->__size, elem->__align, c->dataqsiz);\n+\n+\treturn c;\n+}\n+\n+// For reflect\n+//\tfunc makechan(typ *ChanType, size uint32) (chan)\n+uintptr reflect_makechan(ChanType *, uint32)\n+  asm (\"libgo_reflect.reflect.makechan\");\n+\n+uintptr\n+reflect_makechan(ChanType *t, uint32 size)\n+{\n+\tvoid *ret;\n+\tHchan *c;\n+\n+\tc = runtime_makechan_c(t, size);\n+\tret = runtime_mal(sizeof(void*));\n+\t__builtin_memcpy(ret, &c, sizeof(void*));\n+\treturn (uintptr)ret;\n+}\n+\n+// makechan(t *ChanType, hint int64) (hchan *chan any);\n+Hchan*\n+__go_new_channel(ChanType *t, uintptr hint)\n+{\n+\treturn runtime_makechan_c(t, hint);\n+}\n+\n+/*\n+ * generic single channel send/recv\n+ * if the bool pointer is nil,\n+ * then the full exchange will\n+ * occur. if pres is not nil,\n+ * then the protocol will not\n+ * sleep but return if it could\n+ * not complete.\n+ *\n+ * sleep can wake up with g->param == nil\n+ * when a channel involved in the sleep has\n+ * been closed.  it is easiest to loop and re-run\n+ * the operation; we'll see that it's now closed.\n+ */\n+void\n+runtime_chansend(ChanType *t, Hchan *c, byte *ep, bool *pres)\n+{\n+\tSudoG *sg;\n+\tSudoG mysg;\n+\tG* gp;\n+\tG* g;\n+\n+\tg = runtime_g();\n+\n+\tif(c == nil) {\n+\t\tUSED(t);\n+\t\tif(pres != nil) {\n+\t\t\t*pres = false;\n+\t\t\treturn;\n+\t\t}\n+\t\tg->status = Gwaiting;\n+\t\tg->waitreason = \"chan send (nil chan)\";\n+\t\truntime_gosched();\n+\t\treturn;  // not reached\n+\t}\n+\n+\tif(runtime_gcwaiting)\n+\t\truntime_gosched();\n+\n+\tif(debug) {\n+\t\truntime_printf(\"chansend: chan=%p\\n\", c);\n+\t}\n+\n+\truntime_lock(c);\n+\tif(c->closed)\n+\t\tgoto closed;\n+\n+\tif(c->dataqsiz > 0)\n+\t\tgoto asynch;\n+\n+\tsg = dequeue(&c->recvq);\n+\tif(sg != nil) {\n+\t\truntime_unlock(c);\n+\t\t\n+\t\tgp = sg->g;\n+\t\tgp->param = sg;\n+\t\tif(sg->elem != nil)\n+\t\t\truntime_memmove(sg->elem, ep, c->elemsize);\n+\t\truntime_ready(gp);\n+\n+\t\tif(pres != nil)\n+\t\t\t*pres = true;\n+\t\treturn;\n+\t}\n+\n+\tif(pres != nil) {\n+\t\truntime_unlock(c);\n+\t\t*pres = false;\n+\t\treturn;\n+\t}\n+\n+\tmysg.elem = ep;\n+\tmysg.g = g;\n+\tmysg.selgen = NOSELGEN;\n+\tg->param = nil;\n+\tg->status = Gwaiting;\n+\tg->waitreason = \"chan send\";\n+\tenqueue(&c->sendq, &mysg);\n+\truntime_unlock(c);\n+\truntime_gosched();\n+\n+\tif(g->param == nil) {\n+\t\truntime_lock(c);\n+\t\tif(!c->closed)\n+\t\t\truntime_throw(\"chansend: spurious wakeup\");\n+\t\tgoto closed;\n+\t}\n+\n+\treturn;\n+\n+asynch:\n+\tif(c->closed)\n+\t\tgoto closed;\n+\n+\tif(c->qcount >= c->dataqsiz) {\n+\t\tif(pres != nil) {\n+\t\t\truntime_unlock(c);\n+\t\t\t*pres = false;\n+\t\t\treturn;\n+\t\t}\n+\t\tmysg.g = g;\n+\t\tmysg.elem = nil;\n+\t\tmysg.selgen = NOSELGEN;\n+\t\tg->status = Gwaiting;\n+\t\tg->waitreason = \"chan send\";\n+\t\tenqueue(&c->sendq, &mysg);\n+\t\truntime_unlock(c);\n+\t\truntime_gosched();\n+\n+\t\truntime_lock(c);\n+\t\tgoto asynch;\n+\t}\n+\truntime_memmove(chanbuf(c, c->sendx), ep, c->elemsize);\n+\tif(++c->sendx == c->dataqsiz)\n+\t\tc->sendx = 0;\n+\tc->qcount++;\n+\n+\tsg = dequeue(&c->recvq);\n+\tif(sg != nil) {\n+\t\tgp = sg->g;\n+\t\truntime_unlock(c);\n+\t\truntime_ready(gp);\n+\t} else\n+\t\truntime_unlock(c);\n+\tif(pres != nil)\n+\t\t*pres = true;\n+\treturn;\n+\n+closed:\n+\truntime_unlock(c);\n+\truntime_panicstring(\"send on closed channel\");\n+}\n+\n+\n+void\n+runtime_chanrecv(ChanType *t, Hchan* c, byte *ep, bool *selected, bool *received)\n+{\n+\tSudoG *sg;\n+\tSudoG mysg;\n+\tG *gp;\n+\tG *g;\n+\n+\tif(runtime_gcwaiting)\n+\t\truntime_gosched();\n+\n+\tif(debug)\n+\t\truntime_printf(\"chanrecv: chan=%p\\n\", c);\n+\n+\tg = runtime_g();\n+\n+\tif(c == nil) {\n+\t\tUSED(t);\n+\t\tif(selected != nil) {\n+\t\t\t*selected = false;\n+\t\t\treturn;\n+\t\t}\n+\t\tg->status = Gwaiting;\n+\t\tg->waitreason = \"chan receive (nil chan)\";\n+\t\truntime_gosched();\n+\t\treturn;  // not reached\n+\t}\n+\n+\truntime_lock(c);\n+\tif(c->dataqsiz > 0)\n+\t\tgoto asynch;\n+\n+\tif(c->closed)\n+\t\tgoto closed;\n+\n+\tsg = dequeue(&c->sendq);\n+\tif(sg != nil) {\n+\t\truntime_unlock(c);\n+\n+\t\tif(ep != nil)\n+\t\t\truntime_memmove(ep, sg->elem, c->elemsize);\n+\t\tgp = sg->g;\n+\t\tgp->param = sg;\n+\t\truntime_ready(gp);\n+\n+\t\tif(selected != nil)\n+\t\t\t*selected = true;\n+\t\tif(received != nil)\n+\t\t\t*received = true;\n+\t\treturn;\n+\t}\n+\n+\tif(selected != nil) {\n+\t\truntime_unlock(c);\n+\t\t*selected = false;\n+\t\treturn;\n+\t}\n+\n+\tmysg.elem = ep;\n+\tmysg.g = g;\n+\tmysg.selgen = NOSELGEN;\n+\tg->param = nil;\n+\tg->status = Gwaiting;\n+\tg->waitreason = \"chan receive\";\n+\tenqueue(&c->recvq, &mysg);\n+\truntime_unlock(c);\n+\truntime_gosched();\n+\n+\tif(g->param == nil) {\n+\t\truntime_lock(c);\n+\t\tif(!c->closed)\n+\t\t\truntime_throw(\"chanrecv: spurious wakeup\");\n+\t\tgoto closed;\n+\t}\n+\n+\tif(received != nil)\n+\t\t*received = true;\n+\treturn;\n+\n+asynch:\n+\tif(c->qcount <= 0) {\n+\t\tif(c->closed)\n+\t\t\tgoto closed;\n+\n+\t\tif(selected != nil) {\n+\t\t\truntime_unlock(c);\n+\t\t\t*selected = false;\n+\t\t\tif(received != nil)\n+\t\t\t\t*received = false;\n+\t\t\treturn;\n+\t\t}\n+\t\tmysg.g = g;\n+\t\tmysg.elem = nil;\n+\t\tmysg.selgen = NOSELGEN;\n+\t\tg->status = Gwaiting;\n+\t\tg->waitreason = \"chan receive\";\n+\t\tenqueue(&c->recvq, &mysg);\n+\t\truntime_unlock(c);\n+\t\truntime_gosched();\n+\n+\t\truntime_lock(c);\n+\t\tgoto asynch;\n+\t}\n+\tif(ep != nil)\n+\t\truntime_memmove(ep, chanbuf(c, c->recvx), c->elemsize);\n+\truntime_memclr(chanbuf(c, c->recvx), c->elemsize);\n+\tif(++c->recvx == c->dataqsiz)\n+\t\tc->recvx = 0;\n+\tc->qcount--;\n+\n+\tsg = dequeue(&c->sendq);\n+\tif(sg != nil) {\n+\t\tgp = sg->g;\n+\t\truntime_unlock(c);\n+\t\truntime_ready(gp);\n+\t} else\n+\t\truntime_unlock(c);\n+\n+\tif(selected != nil)\n+\t\t*selected = true;\n+\tif(received != nil)\n+\t\t*received = true;\n+\treturn;\n+\n+closed:\n+\tif(ep != nil)\n+\t\truntime_memclr(ep, c->elemsize);\n+\tif(selected != nil)\n+\t\t*selected = true;\n+\tif(received != nil)\n+\t\t*received = false;\n+\truntime_unlock(c);\n+}\n+\n+// The compiler generates a call to __go_send_small to send a value 8\n+// bytes or smaller.\n+void\n+__go_send_small(ChanType *t, Hchan* c, uint64 val)\n+{\n+\tbyte b[sizeof(uint64)];\n+\n+\truntime_memclr(b, sizeof(uint64));\n+\t__builtin_memcpy(b, &val, t->__element_type->__size);\n+\truntime_chansend(t, c, b, nil);\n+}\n+\n+// The compiler generates a call to __go_send_big to send a value\n+// larger than 8 bytes or smaller.\n+void\n+__go_send_big(ChanType *t, Hchan* c, byte* p)\n+{\n+\truntime_chansend(t, c, p, nil);\n+}\n+\n+// The compiler generates a call to __go_receive_small to receive a\n+// value 8 bytes or smaller.\n+uint64\n+__go_receive_small(ChanType *t, Hchan* c)\n+{\n+\tunion {\n+\t\tbyte b[sizeof(uint64)];\n+\t\tuint64 v;\n+\t} u;\n+\n+\tu.v = 0;\n+\truntime_chanrecv(t, c, u.b, nil, nil);\n+\treturn u.v;\n+}\n+\n+// The compiler generates a call to __go_receive_big to receive a\n+// value larger than 8 bytes.\n+void\n+__go_receive_big(ChanType *t, Hchan* c, byte* p)\n+{\n+\truntime_chanrecv(t, c, p, nil, nil);\n+}\n+\n+_Bool runtime_chanrecv2(ChanType *t, Hchan* c, byte* p)\n+  __asm__(\"runtime.chanrecv2\");\n+\n+_Bool\n+runtime_chanrecv2(ChanType *t, Hchan* c, byte* p)\n+{\n+\tbool received;\n+\n+\truntime_chanrecv(t, c, p, nil, &received);\n+\treturn received;\n+}\n+\n+// func selectnbsend(c chan any, elem any) bool\n+//\n+// compiler implements\n+//\n+//\tselect {\n+//\tcase c <- v:\n+//\t\t... foo\n+//\tdefault:\n+//\t\t... bar\n+//\t}\n+//\n+// as\n+//\n+//\tif selectnbsend(c, v) {\n+//\t\t... foo\n+//\t} else {\n+//\t\t... bar\n+//\t}\n+//\n+_Bool\n+runtime_selectnbsend(ChanType *t, Hchan *c, byte *p)\n+{\n+\tbool res;\n+\n+\truntime_chansend(t, c, p, &res);\n+\treturn res;\n+}\n+\n+// func selectnbrecv(elem *any, c chan any) bool\n+//\n+// compiler implements\n+//\n+//\tselect {\n+//\tcase v = <-c:\n+//\t\t... foo\n+//\tdefault:\n+//\t\t... bar\n+//\t}\n+//\n+// as\n+//\n+//\tif selectnbrecv(&v, c) {\n+//\t\t... foo\n+//\t} else {\n+//\t\t... bar\n+//\t}\n+//\n+_Bool\n+runtime_selectnbrecv(ChanType *t, byte *v, Hchan *c)\n+{\n+\tbool selected;\n+\n+\truntime_chanrecv(t, c, v, &selected, nil);\n+\treturn selected;\n+}\t\n+\n+// func selectnbrecv2(elem *any, ok *bool, c chan any) bool\n+//\n+// compiler implements\n+//\n+//\tselect {\n+//\tcase v, ok = <-c:\n+//\t\t... foo\n+//\tdefault:\n+//\t\t... bar\n+//\t}\n+//\n+// as\n+//\n+//\tif c != nil && selectnbrecv2(&v, &ok, c) {\n+//\t\t... foo\n+//\t} else {\n+//\t\t... bar\n+//\t}\n+//\n+_Bool\n+runtime_selectnbrecv2(ChanType *t, byte *v, _Bool *received, Hchan *c)\n+{\n+\tbool selected;\n+\tbool r;\n+\n+\tr = false;\n+\truntime_chanrecv(t, c, v, &selected, received == nil ? nil : &r);\n+\tif(received != nil)\n+\t\t*received = r;\n+\treturn selected;\n+}\t\n+\n+// For reflect:\n+//\tfunc chansend(c chan, val iword, nb bool) (selected bool)\n+// where an iword is the same word an interface value would use:\n+// the actual data if it fits, or else a pointer to the data.\n+\n+_Bool reflect_chansend(ChanType *, Hchan *, uintptr, _Bool)\n+  __asm__(\"libgo_reflect.reflect.chansend\");\n+\n+_Bool\n+reflect_chansend(ChanType *t, Hchan *c, uintptr val, _Bool nb)\n+{\n+\tbool selected;\n+\tbool *sp;\n+\tbyte *vp;\n+\t\n+\tif(nb) {\n+\t\tselected = false;\n+\t\tsp = (bool*)&selected;\n+\t} else {\n+\t\tselected = true;\n+\t\tsp = nil;\n+\t}\n+\tif(__go_is_pointer_type(t->__element_type))\n+\t\tvp = (byte*)&val;\n+\telse\n+\t\tvp = (byte*)val;\n+\truntime_chansend(t, c, vp, sp);\n+\treturn selected;\n+}\n+\n+// For reflect:\n+//\tfunc chanrecv(c chan, nb bool) (val iword, selected, received bool)\n+// where an iword is the same word an interface value would use:\n+// the actual data if it fits, or else a pointer to the data.\n+\n+struct chanrecv_ret\n+{\n+\tuintptr val;\n+\t_Bool selected;\n+\t_Bool received;\n+};\n+\n+struct chanrecv_ret reflect_chanrecv(ChanType *, Hchan *, _Bool)\n+  __asm__(\"libgo_reflect.reflect.chanrecv\");\n+\n+struct chanrecv_ret\n+reflect_chanrecv(ChanType *t, Hchan *c, _Bool nb)\n+{\n+\tstruct chanrecv_ret ret;\n+\tbyte *vp;\n+\tbool *sp;\n+\tbool selected;\n+\tbool received;\n+\n+\tif(nb) {\n+\t\tselected = false;\n+\t\tsp = &selected;\n+\t} else {\n+\t\tret.selected = true;\n+\t\tsp = nil;\n+\t}\n+\treceived = false;\n+\tif(__go_is_pointer_type(t->__element_type)) {\n+\t\tvp = (byte*)&ret.val;\n+\t} else {\n+\t\tvp = runtime_mal(t->__element_type->__size);\n+\t\tret.val = (uintptr)vp;\n+\t}\n+\truntime_chanrecv(t, c, vp, sp, &received);\n+\tif(nb)\n+\t\tret.selected = selected;\n+\tret.received = received;\n+\treturn ret;\n+}\n+\n+static void newselect(int32, Select**);\n+\n+// newselect(size uint32) (sel *byte);\n+\n+void* runtime_newselect(int) __asm__(\"runtime.newselect\");\n+\n+void*\n+runtime_newselect(int size)\n+{\n+\tSelect *sel;\n+\n+\tnewselect(size, &sel);\n+\treturn (void*)sel;\n+}\n+\n+static void\n+newselect(int32 size, Select **selp)\n+{\n+\tint32 n;\n+\tSelect *sel;\n+\n+\tn = 0;\n+\tif(size > 1)\n+\t\tn = size-1;\n+\n+\tsel = runtime_mal(sizeof(*sel) +\n+\t\tn*sizeof(sel->scase[0]) +\n+\t\tsize*sizeof(sel->lockorder[0]) +\n+\t\tsize*sizeof(sel->pollorder[0]));\n+\n+\tsel->tcase = size;\n+\tsel->ncase = 0;\n+\tsel->pollorder = (void*)(sel->scase + size);\n+\tsel->lockorder = (void*)(sel->pollorder + size);\n+\t*selp = sel;\n+\n+\tif(debug)\n+\t\truntime_printf(\"newselect s=%p size=%d\\n\", sel, size);\n+}\n+\n+// cut in half to give stack a chance to split\n+static void selectsend(Select *sel, Hchan *c, int index, void *elem);\n+\n+// selectsend(sel *byte, hchan *chan any, elem *any) (selected bool);\n+\n+void runtime_selectsend(Select *, Hchan *, void *, int)\n+  __asm__(\"runtime.selectsend\");\n+\n+void\n+runtime_selectsend(Select *sel, Hchan *c, void *elem, int index)\n+{\n+\t// nil cases do not compete\n+\tif(c == nil)\n+\t\treturn;\n+\t\n+\tselectsend(sel, c, index, elem);\n+}\n+\n+static void\n+selectsend(Select *sel, Hchan *c, int index, void *elem)\n+{\n+\tint32 i;\n+\tScase *cas;\n+\t\n+\ti = sel->ncase;\n+\tif(i >= sel->tcase)\n+\t\truntime_throw(\"selectsend: too many cases\");\n+\tsel->ncase = i+1;\n+\tcas = &sel->scase[i];\n+\n+\tcas->index = index;\n+\tcas->chan = c;\n+\tcas->kind = CaseSend;\n+\tcas->sg.elem = elem;\n+\n+\tif(debug)\n+\t\truntime_printf(\"selectsend s=%p index=%d chan=%p\\n\",\n+\t\t\tsel, cas->index, cas->chan);\n+}\n+\n+// cut in half to give stack a chance to split\n+static void selectrecv(Select *sel, Hchan *c, int index, void *elem, bool*);\n+\n+// selectrecv(sel *byte, hchan *chan any, elem *any) (selected bool);\n+\n+void runtime_selectrecv(Select *, Hchan *, void *, int)\n+  __asm__(\"runtime.selectrecv\");\n+\n+void\n+runtime_selectrecv(Select *sel, Hchan *c, void *elem, int index)\n+{\n+\t// nil cases do not compete\n+\tif(c == nil)\n+\t\treturn;\n+\n+\tselectrecv(sel, c, index, elem, nil);\n+}\n+\n+// selectrecv2(sel *byte, hchan *chan any, elem *any, received *bool) (selected bool);\n+\n+void runtime_selectrecv2(Select *, Hchan *, void *, bool *, int)\n+  __asm__(\"runtime.selectrecv2\");\n+\n+void\n+runtime_selectrecv2(Select *sel, Hchan *c, void *elem, bool *received, int index)\n+{\n+\t// nil cases do not compete\n+\tif(c == nil)\n+\t\treturn;\n+\n+\tselectrecv(sel, c, index, elem, received);\n+}\n+\n+static void\n+selectrecv(Select *sel, Hchan *c, int index, void *elem, bool *received)\n+{\n+\tint32 i;\n+\tScase *cas;\n+\n+\ti = sel->ncase;\n+\tif(i >= sel->tcase)\n+\t\truntime_throw(\"selectrecv: too many cases\");\n+\tsel->ncase = i+1;\n+\tcas = &sel->scase[i];\n+\tcas->index = index;\n+\tcas->chan = c;\n+\n+\tcas->kind = CaseRecv;\n+\tcas->sg.elem = elem;\n+\tcas->receivedp = received;\n+\n+\tif(debug)\n+\t\truntime_printf(\"selectrecv s=%p index=%d chan=%p\\n\",\n+\t\t\tsel, cas->index, cas->chan);\n+}\n+\n+// cut in half to give stack a chance to split\n+static void selectdefault(Select*, int);\n+\n+// selectdefault(sel *byte) (selected bool);\n+\n+void runtime_selectdefault(Select *, int) __asm__(\"runtime.selectdefault\");\n+\n+void\n+runtime_selectdefault(Select *sel, int index)\n+{\n+\tselectdefault(sel, index);\n+}\n+\n+static void\n+selectdefault(Select *sel, int index)\n+{\n+\tint32 i;\n+\tScase *cas;\n+\n+\ti = sel->ncase;\n+\tif(i >= sel->tcase)\n+\t\truntime_throw(\"selectdefault: too many cases\");\n+\tsel->ncase = i+1;\n+\tcas = &sel->scase[i];\n+\tcas->index = index;\n+\tcas->chan = nil;\n+\n+\tcas->kind = CaseDefault;\n+\n+\tif(debug)\n+\t\truntime_printf(\"selectdefault s=%p index=%d\\n\",\n+\t\t\tsel, cas->index);\n+}\n+\n+static void\n+sellock(Select *sel)\n+{\n+\tuint32 i;\n+\tHchan *c, *c0;\n+\n+\tc = nil;\n+\tfor(i=0; i<sel->ncase; i++) {\n+\t\tc0 = sel->lockorder[i];\n+\t\tif(c0 && c0 != c) {\n+\t\t\tc = sel->lockorder[i];\n+\t\t\truntime_lock(c);\n+\t\t}\n+\t}\n+}\n+\n+static void\n+selunlock(Select *sel)\n+{\n+\tuint32 i;\n+\tHchan *c, *c0;\n+\n+\tc = nil;\n+\tfor(i=sel->ncase; i-->0;) {\n+\t\tc0 = sel->lockorder[i];\n+\t\tif(c0 && c0 != c) {\n+\t\t\tc = c0;\n+\t\t\truntime_unlock(c);\n+\t\t}\n+\t}\n+}\n+\n+void\n+runtime_block(void)\n+{\n+\tG *g;\n+\n+\tg = runtime_g();\n+\tg->status = Gwaiting;\t// forever\n+\tg->waitreason = \"select (no cases)\";\n+\truntime_gosched();\n+}\n+\n+static int selectgo(Select**);\n+\n+// selectgo(sel *byte);\n+\n+int runtime_selectgo(Select *) __asm__(\"runtime.selectgo\");\n+\n+int\n+runtime_selectgo(Select *sel)\n+{\n+\treturn selectgo(&sel);\n+}\n+\n+static int\n+selectgo(Select **selp)\n+{\n+\tSelect *sel;\n+\tuint32 o, i, j;\n+\tScase *cas, *dfl;\n+\tHchan *c;\n+\tSudoG *sg;\n+\tG *gp;\n+\tint index;\n+\tG *g;\n+\n+\tsel = *selp;\n+\tif(runtime_gcwaiting)\n+\t\truntime_gosched();\n+\n+\tif(debug)\n+\t\truntime_printf(\"select: sel=%p\\n\", sel);\n+\n+\tg = runtime_g();\n+\n+\t// The compiler rewrites selects that statically have\n+\t// only 0 or 1 cases plus default into simpler constructs.\n+\t// The only way we can end up with such small sel->ncase\n+\t// values here is for a larger select in which most channels\n+\t// have been nilled out.  The general code handles those\n+\t// cases correctly, and they are rare enough not to bother\n+\t// optimizing (and needing to test).\n+\n+\t// generate permuted order\n+\tfor(i=0; i<sel->ncase; i++)\n+\t\tsel->pollorder[i] = i;\n+\tfor(i=1; i<sel->ncase; i++) {\n+\t\to = sel->pollorder[i];\n+\t\tj = runtime_fastrand1()%(i+1);\n+\t\tsel->pollorder[i] = sel->pollorder[j];\n+\t\tsel->pollorder[j] = o;\n+\t}\n+\n+\t// sort the cases by Hchan address to get the locking order.\n+\tfor(i=0; i<sel->ncase; i++) {\n+\t\tc = sel->scase[i].chan;\n+\t\tfor(j=i; j>0 && sel->lockorder[j-1] >= c; j--)\n+\t\t\tsel->lockorder[j] = sel->lockorder[j-1];\n+\t\tsel->lockorder[j] = c;\n+\t}\n+\tsellock(sel);\n+\n+loop:\n+\t// pass 1 - look for something already waiting\n+\tdfl = nil;\n+\tfor(i=0; i<sel->ncase; i++) {\n+\t\to = sel->pollorder[i];\n+\t\tcas = &sel->scase[o];\n+\t\tc = cas->chan;\n+\n+\t\tswitch(cas->kind) {\n+\t\tcase CaseRecv:\n+\t\t\tif(c->dataqsiz > 0) {\n+\t\t\t\tif(c->qcount > 0)\n+\t\t\t\t\tgoto asyncrecv;\n+\t\t\t} else {\n+\t\t\t\tsg = dequeue(&c->sendq);\n+\t\t\t\tif(sg != nil)\n+\t\t\t\t\tgoto syncrecv;\n+\t\t\t}\n+\t\t\tif(c->closed)\n+\t\t\t\tgoto rclose;\n+\t\t\tbreak;\n+\n+\t\tcase CaseSend:\n+\t\t\tif(c->closed)\n+\t\t\t\tgoto sclose;\n+\t\t\tif(c->dataqsiz > 0) {\n+\t\t\t\tif(c->qcount < c->dataqsiz)\n+\t\t\t\t\tgoto asyncsend;\n+\t\t\t} else {\n+\t\t\t\tsg = dequeue(&c->recvq);\n+\t\t\t\tif(sg != nil)\n+\t\t\t\t\tgoto syncsend;\n+\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tcase CaseDefault:\n+\t\t\tdfl = cas;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif(dfl != nil) {\n+\t\tselunlock(sel);\n+\t\tcas = dfl;\n+\t\tgoto retc;\n+\t}\n+\n+\n+\t// pass 2 - enqueue on all chans\n+\tfor(i=0; i<sel->ncase; i++) {\n+\t\to = sel->pollorder[i];\n+\t\tcas = &sel->scase[o];\n+\t\tc = cas->chan;\n+\t\tsg = &cas->sg;\n+\t\tsg->g = g;\n+\t\tsg->selgen = g->selgen;\n+\n+\t\tswitch(cas->kind) {\n+\t\tcase CaseRecv:\n+\t\t\tenqueue(&c->recvq, sg);\n+\t\t\tbreak;\n+\t\t\n+\t\tcase CaseSend:\n+\t\t\tenqueue(&c->sendq, sg);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tg->param = nil;\n+\tg->status = Gwaiting;\n+\tg->waitreason = \"select\";\n+\tselunlock(sel);\n+\truntime_gosched();\n+\n+\tsellock(sel);\n+\tsg = g->param;\n+\n+\t// pass 3 - dequeue from unsuccessful chans\n+\t// otherwise they stack up on quiet channels\n+\tfor(i=0; i<sel->ncase; i++) {\n+\t\tcas = &sel->scase[i];\n+\t\tif(cas != (Scase*)sg) {\n+\t\t\tc = cas->chan;\n+\t\t\tif(cas->kind == CaseSend)\n+\t\t\t\tdequeueg(&c->sendq);\n+\t\t\telse\n+\t\t\t\tdequeueg(&c->recvq);\n+\t\t}\n+\t}\n+\n+\tif(sg == nil)\n+\t\tgoto loop;\n+\n+\tcas = (Scase*)sg;\n+\tc = cas->chan;\n+\n+\tif(c->dataqsiz > 0)\n+\t\truntime_throw(\"selectgo: shouldnt happen\");\n+\n+\tif(debug)\n+\t\truntime_printf(\"wait-return: sel=%p c=%p cas=%p kind=%d\\n\",\n+\t\t\tsel, c, cas, cas->kind);\n+\n+\tif(cas->kind == CaseRecv) {\n+\t\tif(cas->receivedp != nil)\n+\t\t\t*cas->receivedp = true;\n+\t}\n+\n+\tselunlock(sel);\n+\tgoto retc;\n+\n+asyncrecv:\n+\t// can receive from buffer\n+\tif(cas->receivedp != nil)\n+\t\t*cas->receivedp = true;\n+\tif(cas->sg.elem != nil)\n+\t\truntime_memmove(cas->sg.elem, chanbuf(c, c->recvx), c->elemsize);\n+\truntime_memclr(chanbuf(c, c->recvx), c->elemsize);\n+\tif(++c->recvx == c->dataqsiz)\n+\t\tc->recvx = 0;\n+\tc->qcount--;\n+\tsg = dequeue(&c->sendq);\n+\tif(sg != nil) {\n+\t\tgp = sg->g;\n+\t\tselunlock(sel);\n+\t\truntime_ready(gp);\n+\t} else {\n+\t\tselunlock(sel);\n+\t}\n+\tgoto retc;\n+\n+asyncsend:\n+\t// can send to buffer\n+\truntime_memmove(chanbuf(c, c->sendx), cas->sg.elem, c->elemsize);\n+\tif(++c->sendx == c->dataqsiz)\n+\t\tc->sendx = 0;\n+\tc->qcount++;\n+\tsg = dequeue(&c->recvq);\n+\tif(sg != nil) {\n+\t\tgp = sg->g;\n+\t\tselunlock(sel);\n+\t\truntime_ready(gp);\n+\t} else {\n+\t\tselunlock(sel);\n+\t}\n+\tgoto retc;\n+\n+syncrecv:\n+\t// can receive from sleeping sender (sg)\n+\tselunlock(sel);\n+\tif(debug)\n+\t\truntime_printf(\"syncrecv: sel=%p c=%p o=%d\\n\", sel, c, o);\n+\tif(cas->receivedp != nil)\n+\t\t*cas->receivedp = true;\n+\tif(cas->sg.elem != nil)\n+\t\truntime_memmove(cas->sg.elem, sg->elem, c->elemsize);\n+\tgp = sg->g;\n+\tgp->param = sg;\n+\truntime_ready(gp);\n+\tgoto retc;\n+\n+rclose:\n+\t// read at end of closed channel\n+\tselunlock(sel);\n+\tif(cas->receivedp != nil)\n+\t\t*cas->receivedp = false;\n+\tif(cas->sg.elem != nil)\n+\t\truntime_memclr(cas->sg.elem, c->elemsize);\n+\tgoto retc;\n+\n+syncsend:\n+\t// can send to sleeping receiver (sg)\n+\tselunlock(sel);\n+\tif(debug)\n+\t\truntime_printf(\"syncsend: sel=%p c=%p o=%d\\n\", sel, c, o);\n+\tif(sg->elem != nil)\n+\t\truntime_memmove(sg->elem, cas->sg.elem, c->elemsize);\n+\tgp = sg->g;\n+\tgp->param = sg;\n+\truntime_ready(gp);\n+\n+retc:\n+\t// return index corresponding to chosen case\n+\tindex = cas->index;\n+\truntime_free(sel);\n+\treturn index;\n+\n+sclose:\n+\t// send on closed channel\n+\tselunlock(sel);\n+\truntime_panicstring(\"send on closed channel\");\n+\treturn 0;  // not reached\n+}\n+\n+// closechan(sel *byte);\n+void\n+runtime_closechan(Hchan *c)\n+{\n+\tSudoG *sg;\n+\tG* gp;\n+\n+\tif(c == nil)\n+\t\truntime_panicstring(\"close of nil channel\");\n+\n+\tif(runtime_gcwaiting)\n+\t\truntime_gosched();\n+\n+\truntime_lock(c);\n+\tif(c->closed) {\n+\t\truntime_unlock(c);\n+\t\truntime_panicstring(\"close of closed channel\");\n+\t}\n+\n+\tc->closed = true;\n+\n+\t// release all readers\n+\tfor(;;) {\n+\t\tsg = dequeue(&c->recvq);\n+\t\tif(sg == nil)\n+\t\t\tbreak;\n+\t\tgp = sg->g;\n+\t\tgp->param = nil;\n+\t\truntime_ready(gp);\n+\t}\n+\n+\t// release all writers\n+\tfor(;;) {\n+\t\tsg = dequeue(&c->sendq);\n+\t\tif(sg == nil)\n+\t\t\tbreak;\n+\t\tgp = sg->g;\n+\t\tgp->param = nil;\n+\t\truntime_ready(gp);\n+\t}\n+\n+\truntime_unlock(c);\n+}\n+\n+void\n+__go_builtin_close(Hchan *c)\n+{\n+\truntime_closechan(c);\n+}\n+\n+// For reflect\n+//\tfunc chanclose(c chan)\n+\n+void reflect_chanclose(uintptr) __asm__(\"libgo_reflect.reflect.chanclose\");\n+\n+void\n+reflect_chanclose(uintptr c)\n+{\n+\truntime_closechan((Hchan*)c);\n+}\n+\n+// For reflect\n+//\tfunc chanlen(c chan) (len int32)\n+\n+int32 reflect_chanlen(uintptr) __asm__(\"libgo_reflect.reflect.chanlen\");\n+\n+int32\n+reflect_chanlen(uintptr ca)\n+{\n+\tHchan *c;\n+\tint32 len;\n+\n+\tc = (Hchan*)ca;\n+\tif(c == nil)\n+\t\tlen = 0;\n+\telse\n+\t\tlen = c->qcount;\n+\treturn len;\n+}\n+\n+int\n+__go_chan_len(Hchan *c)\n+{\n+\treturn reflect_chanlen((uintptr)c);\n+}\n+\n+// For reflect\n+//\tfunc chancap(c chan) (cap int32)\n+\n+int32 reflect_chancap(uintptr) __asm__(\"libgo_reflect.reflect.chancap\");\n+\n+int32\n+reflect_chancap(uintptr ca)\n+{\n+\tHchan *c;\n+\tint32 cap;\n+\n+\tc = (Hchan*)ca;\n+\tif(c == nil)\n+\t\tcap = 0;\n+\telse\n+\t\tcap = c->dataqsiz;\n+\treturn cap;\n+}\n+\n+int\n+__go_chan_cap(Hchan *c)\n+{\n+\treturn reflect_chancap((uintptr)c);\n+}\n+\n+static SudoG*\n+dequeue(WaitQ *q)\n+{\n+\tSudoG *sgp;\n+\n+loop:\n+\tsgp = q->first;\n+\tif(sgp == nil)\n+\t\treturn nil;\n+\tq->first = sgp->link;\n+\n+\t// if sgp is stale, ignore it\n+\tif(sgp->selgen != NOSELGEN &&\n+\t\t(sgp->selgen != sgp->g->selgen ||\n+\t\t!runtime_cas(&sgp->g->selgen, sgp->selgen, sgp->selgen + 2))) {\n+\t\t//prints(\"INVALID PSEUDOG POINTER\\n\");\n+\t\tgoto loop;\n+\t}\n+\n+\treturn sgp;\n+}\n+\n+static void\n+dequeueg(WaitQ *q)\n+{\n+\tSudoG **l, *sgp, *prevsgp;\n+\tG *g;\n+\n+\tg = runtime_g();\n+\tprevsgp = nil;\n+\tfor(l=&q->first; (sgp=*l) != nil; l=&sgp->link, prevsgp=sgp) {\n+\t\tif(sgp->g == g) {\n+\t\t\t*l = sgp->link;\n+\t\t\tif(q->last == sgp)\n+\t\t\t\tq->last = prevsgp;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+\n+static void\n+enqueue(WaitQ *q, SudoG *sgp)\n+{\n+\tsgp->link = nil;\n+\tif(q->first == nil) {\n+\t\tq->first = sgp;\n+\t\tq->last = sgp;\n+\t\treturn;\n+\t}\n+\tq->last->link = sgp;\n+\tq->last = sgp;\n+}"}, {"sha": "c3cc3e39879121209576e7742d7701200b077084", "filename": "libgo/runtime/chan.goc", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fchan.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fchan.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.goc?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-#include \"config.h\"\n-#include \"channel.h\"\n-\n-#define nil NULL\n-\n-typedef _Bool bool;\n-typedef unsigned char byte;\n-typedef struct __go_channel chan;\n-\n-/* Do a channel receive with closed status.  */\n-\n-func chanrecv2(c *chan, val *byte) (received bool) {\n-\tuintptr_t element_size = c == nil ? 0 : c->element_type->__size;\n-\tif (element_size > 8) {\n-\t\treturn __go_receive_big(c, val, 0);\n-\t} else {\n-\t\tunion {\n-\t\t\tchar b[8];\n-\t\t\tuint64_t v;\n-\t\t} u;\n-\n-\t\tu.v = __go_receive_small_closed(c, 0, &received);\n-#ifndef WORDS_BIGENDIAN\n-\t\t__builtin_memcpy(val, u.b, element_size);\n-#else\n-\t\t__builtin_memcpy(val, u.b + 8 - element_size, element_size);\n-#endif\n-\t\treturn received;\n-\t}\n-}\n-\n-/* Do a channel receive with closed status for a select statement.  */\n-\n-func chanrecv3(c *chan, val *byte) (received bool) {\n-\tuintptr_t element_size = c->element_type->__size;\n-\tif (element_size > 8) {\n-\t\treturn __go_receive_big(c, val, 1);\n-\t} else {\n-\t\tunion {\n-\t\t\tchar b[8];\n-\t\t\tuint64_t v;\n-\t\t} u;\n-\n-\t\tu.v = __go_receive_small_closed(c, 1, &received);\n-#ifndef WORDS_BIGENDIAN\n-\t\t__builtin_memcpy(val, u.b, element_size);\n-#else\n-\t\t__builtin_memcpy(val, u.b + 8 - element_size, element_size);\n-#endif\n-\t\treturn received;\n-\t}\n-}"}, {"sha": "9176c68f692f2f5cede8a17d8aa8e4cc2ddc4401", "filename": "libgo/runtime/channel.h", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fchannel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fchannel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchannel.h?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,152 +0,0 @@\n-/* channel.h -- the channel type for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-#include <pthread.h>\n-\n-#include \"go-type.h\"\n-\n-/* This structure is used when a select is waiting for a synchronous\n-   channel.  */\n-\n-struct __go_channel_select\n-{\n-  /* A pointer to the next select waiting for this channel.  */\n-  struct __go_channel_select *next;\n-  /* A pointer to the channel which this select will use.  This starts\n-     out as NULL and is set to the first channel which synchs up with\n-     this one.  This variable to which this points may only be\n-     accessed when __go_select_data_mutex is held.  */\n-  struct __go_channel **selected;\n-  /* A pointer to a variable which must be set to true if the\n-     goroutine which sets *SELECTED wants to read from the channel,\n-     false if it wants to write to it.  */\n-  _Bool *is_read;\n-};\n-\n-/* A channel is a pointer to this structure.  */\n-\n-struct __go_channel\n-{\n-  /* A mutex to control access to the channel.  */\n-  pthread_mutex_t lock;\n-  /* A condition variable.  This is signalled when data is added to\n-     the channel and when data is removed from the channel.  */\n-  pthread_cond_t cond;\n-  /* The type of elements on this channel.  */\n-  const struct __go_type_descriptor *element_type;\n-  /* True if a goroutine is waiting to send on a synchronous\n-     channel.  */\n-  _Bool waiting_to_send;\n-  /* True if a goroutine is waiting to receive on a synchronous\n-     channel.  */\n-  _Bool waiting_to_receive;\n-  /* True if this channel was selected for send in a select statement.\n-     This looks out all other sends.  */\n-  _Bool selected_for_send;\n-  /* True if this channel was selected for receive in a select\n-     statement.  This locks out all other receives.  */\n-  _Bool selected_for_receive;\n-  /* True if this channel has been closed.  */\n-  _Bool is_closed;\n-  /* The list of select statements waiting to send on a synchronous\n-     channel.  */\n-  struct __go_channel_select *select_send_queue;\n-  /* The list of select statements waiting to receive on a synchronous\n-     channel.  */\n-  struct __go_channel_select *select_receive_queue;\n-  /* If a select statement is waiting for this channel, it sets these\n-     pointers.  When something happens on the channel, the channel\n-     locks the mutex, signals the condition, and unlocks the\n-     mutex.  */\n-  pthread_mutex_t *select_mutex;\n-  pthread_cond_t *select_cond;\n-  /* The number of entries in the circular buffer.  */\n-  unsigned int num_entries;\n-  /* Where to store the next value.  */\n-  unsigned int next_store;\n-  /* Where to fetch the next value.  If next_fetch == next_store, the\n-     buffer is empty.  If next_store + 1 == next_fetch, the buffer is\n-     full.  */\n-  unsigned int next_fetch;\n-  /* The circular buffer.  */\n-  uint64_t data[];\n-};\n-\n-/* Try to link up with the structure generated by the frontend.  */\n-typedef struct __go_channel __go_channel;\n-\n-/* The mutex used to control access to the value pointed to by the\n-   __go_channel_select selected field.  No additional mutexes may be\n-   acquired while this mutex is held.  */\n-extern pthread_mutex_t __go_select_data_mutex;\n-\n-extern struct __go_channel *\n-__go_new_channel (const struct __go_type_descriptor *, uintptr_t);\n-\n-extern _Bool __go_synch_with_select (struct __go_channel *, _Bool);\n-\n-extern void __go_broadcast_to_select (struct __go_channel *);\n-\n-extern void __go_send_acquire (struct __go_channel *, _Bool);\n-\n-extern _Bool __go_send_nonblocking_acquire (struct __go_channel *);\n-\n-extern void __go_send_release (struct __go_channel *);\n-\n-extern void __go_send_small (struct __go_channel *, uint64_t, _Bool);\n-\n-extern _Bool __go_send_nonblocking_small (struct __go_channel *, uint64_t);\n-\n-extern void __go_send_big (struct __go_channel *, const void *, _Bool);\n-\n-extern _Bool __go_send_nonblocking_big (struct __go_channel *, const void *);\n-\n-extern _Bool __go_receive_acquire (struct __go_channel *, _Bool);\n-\n-#define RECEIVE_NONBLOCKING_ACQUIRE_DATA 0\n-#define RECEIVE_NONBLOCKING_ACQUIRE_NODATA 1\n-#define RECEIVE_NONBLOCKING_ACQUIRE_CLOSED 2\n-\n-extern int __go_receive_nonblocking_acquire (struct __go_channel *);\n-\n-extern uint64_t __go_receive_small (struct __go_channel *, _Bool);\n-\n-extern uint64_t __go_receive_small_closed (struct __go_channel *, _Bool,\n-\t\t\t\t\t   _Bool *);\n-\n-extern void __go_receive_release (struct __go_channel *);\n-\n-struct __go_receive_nonblocking_small\n-{\n-  /* Value read from channel, or 0.  */\n-  uint64_t __val;\n-  /* True if value was read from channel.  */\n-  _Bool __success;\n-  /* True if channel is closed.  */\n-  _Bool __closed;\n-};\n-\n-extern struct __go_receive_nonblocking_small\n-__go_receive_nonblocking_small (struct __go_channel *);\n-\n-extern _Bool __go_receive_big (struct __go_channel *, void *, _Bool);\n-\n-extern _Bool __go_receive_nonblocking_big (struct __go_channel *, void *,\n-\t\t\t\t\t   _Bool *);\n-\n-extern void __go_unlock_and_notify_selects (struct __go_channel *);\n-\n-extern _Bool __go_builtin_closed (struct __go_channel *);\n-\n-extern void __go_builtin_close (struct __go_channel *);\n-\n-extern int __go_chan_len (struct __go_channel *);\n-\n-extern int __go_chan_cap (struct __go_channel *);\n-\n-extern uintptr_t __go_select (uintptr_t, _Bool, struct __go_channel **,\n-\t\t\t      _Bool *);"}, {"sha": "2c7958dd9fc444518ebf841a71457d5969163789", "filename": "libgo/runtime/go-chan-cap.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-chan-cap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-chan-cap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-chan-cap.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,41 +0,0 @@\n-/* go-chan-cap.c -- the cap function applied to a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"go-assert.h\"\n-#include \"channel.h\"\n-\n-/* Return the cap function applied to a channel--the size of the\n-   buffer.  This could be done inline but I'm doing it as a function\n-   for now to make it easy to change the channel structure.  */\n-\n-int\n-__go_chan_cap (struct __go_channel *channel)\n-{\n-  int i;\n-  int ret;\n-\n-  if (channel == NULL)\n-    return 0;\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  if (channel->num_entries == 0)\n-    ret = 0;\n-  else\n-    {\n-      /* One slot is always unused.  We added 1 when we created the\n-\t channel.  */\n-      ret = channel->num_entries - 1;\n-    }\n-\n-  i = pthread_mutex_unlock (&channel->lock);\n-  __go_assert  (i == 0);\n-\n-  return ret;\n-}"}, {"sha": "b3ced98aa050ebafd172b50ae66948cd5ec1e9f4", "filename": "libgo/runtime/go-chan-len.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-chan-len.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-chan-len.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-chan-len.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,41 +0,0 @@\n-/* go-chan-len.c -- the len function applied to a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"go-assert.h\"\n-#include \"channel.h\"\n-\n-/* Return the len function applied to a channel--the number of\n-   elements in the buffer.  This could be done inline but I'm doing it\n-   as a function for now to make it easy to change the channel\n-   structure.  */\n-\n-int\n-__go_chan_len (struct __go_channel *channel)\n-{\n-  int i;\n-  int ret;\n-\n-  if (channel == NULL)\n-    return 0;\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  if (channel->num_entries == 0)\n-    ret = 0;\n-  else if (channel->next_fetch == channel->next_store)\n-    ret = 0;\n-  else\n-    ret = ((channel->next_store + channel->num_entries - channel->next_fetch)\n-\t   % channel->num_entries);\n-\n-  i = pthread_mutex_unlock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  return ret;\n-}"}, {"sha": "7e32286dae09f8366e7403093c35a4c9f9ace549", "filename": "libgo/runtime/go-close.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-close.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-close.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-close.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,42 +0,0 @@\n-/* go-close.c -- the builtin close function.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"channel.h\"\n-\n-/* Close a channel.  After a channel is closed, sends are no longer\n-   permitted.  Receives always return zero.  */\n-\n-void\n-__go_builtin_close (struct __go_channel *channel)\n-{\n-  int i;\n-\n-  if (channel == NULL)\n-    runtime_panicstring (\"close of nil channel\");\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  while (channel->selected_for_send)\n-    runtime_cond_wait (&channel->cond, &channel->lock);\n-\n-  if (channel->is_closed)\n-    {\n-      i = pthread_mutex_unlock (&channel->lock);\n-      __go_assert (i == 0);\n-      runtime_panicstring (\"close of closed channel\");\n-    }\n-\n-  channel->is_closed = 1;\n-\n-  i = pthread_cond_broadcast (&channel->cond);\n-  __go_assert (i == 0);\n-\n-  __go_unlock_and_notify_selects (channel);\n-}"}, {"sha": "fe13c5efab62db8984462b50c919ab3776747081", "filename": "libgo/runtime/go-new-channel.c", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-new-channel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-new-channel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-channel.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,70 +0,0 @@\n-/* go-new-channel.c -- allocate a new channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"channel.h\"\n-\n-struct __go_channel*\n-__go_new_channel (const struct __go_type_descriptor *channel_type,\n-\t\t  uintptr_t entries)\n-{\n-  const struct __go_channel_type *ctd;\n-  const struct __go_type_descriptor *element_type;\n-  uintptr_t element_size;\n-  int ientries;\n-  struct __go_channel* ret;\n-  size_t alloc_size;\n-  int i;\n-\n-  __go_assert (channel_type->__code == GO_CHAN);\n-  ctd = (const struct __go_channel_type *) channel_type;\n-  element_type = ctd->__element_type;\n-\n-  element_size = element_type->__size;\n-\n-  ientries = (int) entries;\n-  if (ientries < 0\n-      || (uintptr_t) ientries != entries\n-      || (element_size > 0 && entries > (uintptr_t) -1 / element_size))\n-    runtime_panicstring (\"chan size out of range\");\n-\n-  alloc_size = (element_size + sizeof (uint64_t) - 1) / sizeof (uint64_t);\n-\n-  /* We use a circular buffer which means that when next_fetch ==\n-     next_store we don't know whether the buffer is empty or full.  So\n-     we allocate an extra space, and always leave a space open.\n-     FIXME.  */\n-  if (entries != 0)\n-    ++entries;\n-\n-  ret = (struct __go_channel*) __go_alloc (sizeof (struct __go_channel)\n-\t\t\t\t\t   + ((entries == 0 ? 1 : entries)\n-\t\t\t\t\t      * alloc_size\n-\t\t\t\t\t      * sizeof (uint64_t)));\n-  i = pthread_mutex_init (&ret->lock, NULL);\n-  __go_assert (i == 0);\n-  i = pthread_cond_init (&ret->cond, NULL);\n-  __go_assert (i == 0);\n-  ret->element_type = element_type;\n-  ret->waiting_to_send = 0;\n-  ret->waiting_to_receive = 0;\n-  ret->selected_for_send = 0;\n-  ret->selected_for_receive = 0;\n-  ret->is_closed = 0;\n-  ret->select_send_queue = NULL;\n-  ret->select_receive_queue = NULL;\n-  ret->select_mutex = NULL;\n-  ret->select_cond = NULL;\n-  ret->num_entries = entries;\n-  ret->next_store = 0;\n-  ret->next_fetch = 0;\n-  return ret;\n-}"}, {"sha": "d45e90af476d2281e66120db3ed4cb4021909906", "filename": "libgo/runtime/go-rec-big.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-big.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,43 +0,0 @@\n-/* go-rec-big.c -- receive something larger than 64 bits on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"go-panic.h\"\n-#include \"channel.h\"\n-\n-/* Returns true if a value was received, false if the channel is\n-   closed.  */\n-\n-_Bool\n-__go_receive_big (struct __go_channel *channel, void *val, _Bool for_select)\n-{\n-  uintptr_t element_size;\n-  size_t alloc_size;\n-  size_t offset;\n-\n-  if (channel == NULL)\n-    {\n-      /* Block forever.  */\n-      __go_select (0, 0, NULL, NULL);\n-    }\n-\n-  element_size = channel->element_type->__size;\n-  alloc_size = (element_size + sizeof (uint64_t) - 1) / sizeof (uint64_t);\n-\n-  if (!__go_receive_acquire (channel, for_select))\n-    {\n-      __builtin_memset (val, 0, element_size);\n-      return 0;\n-    }\n-\n-  offset = channel->next_fetch * alloc_size;\n-  __builtin_memcpy (val, &channel->data[offset], element_size);\n-\n-  __go_receive_release (channel);\n-\n-  return 1;\n-}"}, {"sha": "659ea1dc33db5da24d650ad812ccc4e1fb136c05", "filename": "libgo/runtime/go-rec-nb-big.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-nb-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-nb-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-nb-big.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,46 +0,0 @@\n-/* go-rec-nb-big.c -- nonblocking receive of something big on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"channel.h\"\n-\n-/* Return true if a value was received, false if not.  */\n-\n-_Bool\n-__go_receive_nonblocking_big (struct __go_channel* channel, void *val,\n-\t\t\t      _Bool *closed)\n-{\n-  uintptr_t element_size;\n-  size_t alloc_size;\n-  size_t offset;\n-\n-  if (channel == NULL)\n-    {\n-      if (closed != NULL)\n-\t*closed = 0;\n-      return 0;\n-    }\n-\n-  element_size = channel->element_type->__size;\n-  alloc_size = (element_size + sizeof (uint64_t) - 1) / sizeof (uint64_t);\n-\n-  int data = __go_receive_nonblocking_acquire (channel);\n-  if (data != RECEIVE_NONBLOCKING_ACQUIRE_DATA)\n-    {\n-      __builtin_memset (val, 0, element_size);\n-      if (closed != NULL)\n-\t*closed = data == RECEIVE_NONBLOCKING_ACQUIRE_CLOSED;\n-      return 0;\n-    }\n-\n-  offset = channel->next_fetch * alloc_size;\n-  __builtin_memcpy (val, &channel->data[offset], element_size);\n-\n-  __go_receive_release (channel);\n-\n-  return 1;\n-}"}, {"sha": "c21878ce131b247a395d64613dfcd3374328d719", "filename": "libgo/runtime/go-rec-nb-small.c", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-nb-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-nb-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-nb-small.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,123 +0,0 @@\n-/* go-rec-nb-small.c -- nonblocking receive of something smal on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"channel.h\"\n-\n-/* Prepare to receive something on a nonblocking channel.  */\n-\n-int\n-__go_receive_nonblocking_acquire (struct __go_channel *channel)\n-{\n-  int i;\n-  _Bool has_data;\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  while (channel->selected_for_receive)\n-    runtime_cond_wait (&channel->cond, &channel->lock);\n-\n-  if (channel->is_closed\n-      && (channel->num_entries == 0\n-\t  ? channel->next_store == 0\n-\t  : channel->next_fetch == channel->next_store))\n-    {\n-      __go_unlock_and_notify_selects (channel);\n-      return RECEIVE_NONBLOCKING_ACQUIRE_CLOSED;\n-    }\n-\n-  if (channel->num_entries > 0)\n-    has_data = channel->next_fetch != channel->next_store;\n-  else\n-    {\n-      if (channel->waiting_to_receive)\n-\t{\n-\t  /* Some other goroutine is already waiting for data on this\n-\t     channel, so we can't pick it up.  */\n-\t  has_data = 0;\n-\t}\n-      else if (channel->next_store > 0)\n-\t{\n-\t  /* There is data on the channel.  */\n-\t  has_data = 1;\n-\t}\n-      else if (__go_synch_with_select (channel, 0))\n-\t{\n-\t  /* We synched up with a select sending data, so there will\n-\t     be data for us shortly.  Tell the select to go, and then\n-\t     wait for the data.  */\n-\t  __go_broadcast_to_select (channel);\n-\n-\t  while (channel->next_store == 0)\n-\t    runtime_cond_wait (&channel->cond, &channel->lock);\n-\n-\t  has_data = 1;\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise there is no data.  */\n-\t  has_data = 0;\n-\t}\n-\n-      if (has_data)\n-\t{\n-\t  channel->waiting_to_receive = 1;\n-\t  __go_assert (channel->next_store == 1);\n-\t}\n-    }\n-\n-  if (!has_data)\n-    {\n-      i = pthread_mutex_unlock (&channel->lock);\n-      __go_assert (i == 0);\n-      return RECEIVE_NONBLOCKING_ACQUIRE_NODATA;\n-    }\n-\n-  return RECEIVE_NONBLOCKING_ACQUIRE_DATA;\n-}\n-\n-/* Receive something 64 bits or smaller on a nonblocking channel.  */\n-\n-struct __go_receive_nonblocking_small\n-__go_receive_nonblocking_small (struct __go_channel *channel)\n-{\n-  uintptr_t element_size;\n-  struct __go_receive_nonblocking_small ret;\n-\n-  if (channel == NULL)\n-    {\n-      ret.__val = 0;\n-      ret.__success = 0;\n-      ret.__closed = 0;\n-      return ret;\n-    }\n-\n-  element_size = channel->element_type->__size;\n-  __go_assert (element_size <= sizeof (uint64_t));\n-\n-  int data = __go_receive_nonblocking_acquire (channel);\n-  if (data != RECEIVE_NONBLOCKING_ACQUIRE_DATA)\n-    {\n-      ret.__val = 0;\n-      ret.__success = 0;\n-      ret.__closed = data == RECEIVE_NONBLOCKING_ACQUIRE_CLOSED;\n-      return ret;\n-    }\n-\n-  ret.__val = channel->data[channel->next_fetch];\n-\n-  __go_receive_release (channel);\n-\n-  ret.__success = 1;\n-  ret.__closed = 0;\n-\n-  return ret;\n-}"}, {"sha": "f26dbcdd99388644a3de66625e23a0024596025b", "filename": "libgo/runtime/go-rec-small.c", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-rec-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-small.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,304 +0,0 @@\n-/* go-rec-small.c -- receive something smaller than 64 bits on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"channel.h\"\n-\n-/* This mutex controls access to the selected field of struct\n-   __go_channel_select.  While this mutex is held, no other mutexes\n-   may be acquired.  */\n-\n-pthread_mutex_t __go_select_data_mutex = PTHREAD_MUTEX_INITIALIZER;\n-\n-/* Try to synchronize with a select waiting on a sychronized channel.\n-   This is used by a send or receive.  The channel is locked.  This\n-   returns true if it was able to synch.  */\n-\n-_Bool\n-__go_synch_with_select (struct __go_channel *channel, _Bool is_send)\n-{\n-  struct __go_channel_select *p;\n-  int i;\n-\n-  __go_assert (channel->num_entries == 0);\n-\n-  i = pthread_mutex_lock (&__go_select_data_mutex);\n-  __go_assert (i == 0);\n-\n-  for (p = (is_send\n-\t    ? channel->select_receive_queue\n-\t    : channel->select_send_queue);\n-       p != NULL;\n-       p = p->next)\n-    {\n-      if (*p->selected == NULL)\n-\t{\n-\t  *p->selected = channel;\n-\t  *p->is_read = !is_send;\n-\t  if (is_send)\n-\t    channel->selected_for_receive = 1;\n-\t  else\n-\t    channel->selected_for_send = 1;\n-\t  break;\n-\t}\n-    }\n-\n-  i = pthread_mutex_unlock (&__go_select_data_mutex);\n-  __go_assert (i == 0);\n-\n-  /* The caller is responsible for signalling the select condition\n-     variable so that the other select knows that something has\n-     changed.  We can't signal it here because we can't acquire the\n-     select mutex while we hold a channel lock.  */\n-\n-  return p != NULL;\n-}\n-\n-/* If we synch with a select, then we need to signal the select that\n-   something has changed.  This requires grabbing the select mutex,\n-   which can only be done when the channel is unlocked.  This routine\n-   does the signalling.  It is called with the channel locked.  It\n-   unlocks the channel, broadcasts the signal and relocks the\n-   channel.  */\n-\n-void\n-__go_broadcast_to_select (struct __go_channel *channel)\n-{\n-  pthread_mutex_t *select_mutex;\n-  pthread_cond_t *select_cond;\n-  int i;\n-\n-  select_mutex = channel->select_mutex;\n-  select_cond = channel->select_cond;\n-\n-  i = pthread_mutex_unlock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  __go_assert (select_mutex != NULL && select_cond != NULL);\n-\n-  i = pthread_mutex_lock (select_mutex);\n-  __go_assert (i == 0);\n-\n-  i = pthread_cond_broadcast (select_cond);\n-  __go_assert (i == 0);\n-\n-  i = pthread_mutex_unlock (select_mutex);\n-  __go_assert (i == 0);\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-}\n-\n-/* Prepare to receive something on a channel.  Return true if the\n-   channel is acquired (which implies that there is data available),\n-   false if it is closed.  */\n-\n-_Bool\n-__go_receive_acquire (struct __go_channel *channel, _Bool for_select)\n-{\n-  int i;\n-  _Bool my_wait_lock;\n-  _Bool synched_with_select;\n-\n-  my_wait_lock = 0;\n-  synched_with_select = 0;\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  while (1)\n-    {\n-      _Bool need_broadcast;\n-\n-      need_broadcast = 0;\n-\n-      /* Check whether the channel is closed.  */\n-      if (channel->is_closed\n-\t  && (channel->num_entries == 0\n-\t      ? channel->next_store == 0\n-\t      : channel->next_fetch == channel->next_store))\n-\t{\n-\t  channel->selected_for_receive = 0;\n-\t  __go_unlock_and_notify_selects (channel);\n-\t  return 0;\n-\t}\n-\n-      /* If somebody else has the channel locked for receiving, we\n-\t have to wait.  If FOR_SELECT is true, then we are the one\n-\t with the lock.  */\n-      if (!channel->selected_for_receive || for_select)\n-\t{\n-\t  if (channel->num_entries == 0)\n-\t    {\n-\t      /* If somebody else is waiting to receive, we have to\n-\t\t wait.  */\n-\t      if (!channel->waiting_to_receive || my_wait_lock)\n-\t\t{\n-\t\t  _Bool was_marked;\n-\n-\t\t  /* Lock the channel so that we get to receive\n-\t\t     next.  */\n-\t\t  was_marked = channel->waiting_to_receive;\n-\t\t  channel->waiting_to_receive = 1;\n-\t\t  my_wait_lock = 1;\n-\n-\t\t  /* See if there is a value to receive.  */\n-\t\t  if (channel->next_store > 0)\n-\t\t    return 1;\n-\n-\t\t  /* If we haven't already done so, try to synch with\n-\t\t     a select waiting to send on this channel.  If we\n-\t\t     have already synched with a select, we are just\n-\t\t     looping until the select eventually causes\n-\t\t     something to be sent.  */\n-\t\t  if (!synched_with_select && !for_select)\n-\t\t    {\n-\t\t      if (__go_synch_with_select (channel, 0))\n-\t\t\t{\n-\t\t\t  synched_with_select = 1;\n-\t\t\t  need_broadcast = 1;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  /* If we marked the channel as waiting, we need to\n-\t\t     signal, because something changed.  It needs to\n-\t\t     be a broadcast since there might be other\n-\t\t     receivers waiting.  */\n-\t\t  if (!was_marked)\n-\t\t    {\n-\t\t      i = pthread_cond_broadcast (&channel->cond);\n-\t\t      __go_assert (i == 0);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If there is a value on the channel, we are OK.  */\n-\t      if (channel->next_fetch != channel->next_store)\n-\t\treturn 1;\n-\t    }\n-\t}\n-\n-      /* If we just synched with a select, then we need to signal the\n-\t select condition variable.  We can only do that if we unlock\n-\t the channel.  So we need to unlock, signal, lock, and go\n-\t around the loop again without waiting.  */\n-      if (need_broadcast)\n-\t{\n-\t  __go_broadcast_to_select (channel);\n-\t  continue;\n-\t}\n-\n-      /* Wait for something to change, then loop around and try\n-\t again.  */\n-\n-      runtime_cond_wait (&channel->cond, &channel->lock);\n-    }\n-}\n-\n-/* Finished receiving something on a channel.  */\n-\n-void\n-__go_receive_release (struct __go_channel *channel)\n-{\n-  int i;\n-\n-  if (channel->num_entries != 0)\n-    channel->next_fetch = (channel->next_fetch + 1) % channel->num_entries;\n-  else\n-    {\n-      /* For a synchronous receiver, we tell the sender that we picked\n-\t up the value by setting the next_store field back to 0.\n-\t Using the mutexes should implement a memory barrier.  */\n-      __go_assert (channel->next_store == 1);\n-      channel->next_store = 0;\n-\n-      channel->waiting_to_receive = 0;\n-    }\n-\n-  channel->selected_for_receive = 0;\n-\n-  /* This is a broadcast to make sure that a synchronous sender sees\n-     it.  */\n-  i = pthread_cond_broadcast (&channel->cond);\n-  __go_assert (i == 0);\n-\n-  __go_unlock_and_notify_selects (channel);\n-}\n-\n-/* Unlock a channel and notify any waiting selects that something\n-   happened.  */\n-\n-void\n-__go_unlock_and_notify_selects (struct __go_channel *channel)\n-{\n-  pthread_mutex_t* select_mutex;\n-  pthread_cond_t* select_cond;\n-  int i;\n-\n-  select_mutex = channel->select_mutex;\n-  select_cond = channel->select_cond;\n-\n-  i = pthread_mutex_unlock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  if (select_mutex != NULL)\n-    {\n-      i = pthread_mutex_lock (select_mutex);\n-      __go_assert (i == 0);\n-      i = pthread_cond_broadcast (select_cond);\n-      __go_assert (i == 0);\n-      i = pthread_mutex_unlock (select_mutex);\n-      __go_assert (i == 0);\n-    }\n-}\n-\n-/* Receive something 64 bits or smaller on a channel.  */\n-\n-uint64_t\n-__go_receive_small_closed (struct __go_channel *channel, _Bool for_select,\n-\t\t\t   _Bool *received)\n-{\n-  uintptr_t element_size;\n-  uint64_t ret;\n-\n-  if (channel == NULL)\n-    {\n-      /* Block forever.  */\n-      __go_select (0, 0, NULL, NULL);\n-    }\n-\n-  element_size = channel->element_type->__size;\n-  __go_assert (element_size <= sizeof (uint64_t));\n-\n-  if (!__go_receive_acquire (channel, for_select))\n-    {\n-      if (received != NULL)\n-\t*received = 0;\n-      return 0;\n-    }\n-\n-  ret = channel->data[channel->next_fetch];\n-\n-  __go_receive_release (channel);\n-\n-  if (received != NULL)\n-    *received = 1;\n-\n-  return ret;\n-}\n-\n-/* Called by the compiler.  */\n-\n-uint64_t\n-__go_receive_small (struct __go_channel *channel, _Bool for_select)\n-{\n-  return __go_receive_small_closed (channel, for_select, NULL);\n-}"}, {"sha": "6f6693b6b54a61d3abba059a70a7cd3359e18d50", "filename": "libgo/runtime/go-reflect-chan.c", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-reflect-chan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-reflect-chan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-chan.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,200 +0,0 @@\n-/* go-reflect-chan.c -- channel reflection support for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdlib.h>\n-#include <stdint.h>\n-\n-#include \"config.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"go-type.h\"\n-#include \"channel.h\"\n-\n-/* This file implements support for reflection on channels.  These\n-   functions are called from reflect/value.go.  */\n-\n-extern uintptr_t makechan (const struct __go_type_descriptor *, uint32_t)\n-  asm (\"libgo_reflect.reflect.makechan\");\n-\n-uintptr_t\n-makechan (const struct __go_type_descriptor *typ, uint32_t size)\n-{\n-  struct __go_channel *channel;\n-  void *ret;\n-\n-  channel = __go_new_channel (typ, size);\n-\n-  ret = __go_alloc (sizeof (void *));\n-  __builtin_memcpy (ret, &channel, sizeof (void *));\n-  return (uintptr_t) ret;\n-}\n-\n-extern _Bool chansend (struct __go_channel_type *, uintptr_t, uintptr_t, _Bool)\n-  asm (\"libgo_reflect.reflect.chansend\");\n-\n-_Bool\n-chansend (struct __go_channel_type *ct, uintptr_t ch, uintptr_t val_i,\n-\t  _Bool nb)\n-{\n-  struct __go_channel *channel = (struct __go_channel *) ch;\n-  uintptr_t element_size;\n-  void *pv;\n-\n-  __go_assert (ct->__common.__code == GO_CHAN);\n-\n-  if (__go_is_pointer_type (ct->__element_type))\n-    pv = &val_i;\n-  else\n-    pv = (void *) val_i;\n-\n-  element_size = ct->__element_type->__size;\n-  if (element_size <= sizeof (uint64_t))\n-    {\n-      union\n-      {\n-\tchar b[sizeof (uint64_t)];\n-\tuint64_t v;\n-      } u;\n-\n-      __builtin_memset (u.b, 0, sizeof (uint64_t));\n-#ifndef WORDS_BIGENDIAN\n-      __builtin_memcpy (u.b, pv, element_size);\n-#else\n-      __builtin_memcpy (u.b + sizeof (uint64_t) - element_size, pv,\n-\t\t\telement_size);\n-#endif\n-      if (nb)\n-\treturn __go_send_nonblocking_small (channel, u.v);\n-      else\n-\t{\n-\t  __go_send_small (channel, u.v, 0);\n-\t  return 1;\n-\t}\n-    }\n-  else\n-    {\n-      if (nb)\n-\treturn __go_send_nonblocking_big (channel, pv);\n-      else\n-\t{\n-\t  __go_send_big (channel, pv, 0);\n-\t  return 1;\n-\t}\n-    }\n-}\n-\n-struct chanrecv_ret\n-{\n-  uintptr_t val;\n-  _Bool selected;\n-  _Bool received;\n-};\n-\n-extern struct chanrecv_ret chanrecv (struct __go_channel_type *, uintptr_t,\n-\t\t\t\t     _Bool)\n-  asm (\"libgo_reflect.reflect.chanrecv\");\n-\n-struct chanrecv_ret\n-chanrecv (struct __go_channel_type *ct, uintptr_t ch, _Bool nb)\n-{\n-  struct __go_channel *channel = (struct __go_channel *) ch;\n-  void *pv;\n-  uintptr_t element_size;\n-  struct chanrecv_ret ret;\n-\n-  __go_assert (ct->__common.__code == GO_CHAN);\n-\n-  element_size = ct->__element_type->__size;\n-\n-  if (__go_is_pointer_type (ct->__element_type))\n-    pv = &ret.val;\n-  else\n-    {\n-      pv = __go_alloc (element_size);\n-      ret.val = (uintptr_t) pv;\n-    }\n-\n-  if (element_size <= sizeof (uint64_t))\n-    {\n-      union\n-      {\n-\tchar b[sizeof (uint64_t)];\n-\tuint64_t v;\n-      } u;\n-\n-      if (!nb)\n-\t{\n-\t  u.v = __go_receive_small_closed (channel, 0, &ret.received);\n-\t  ret.selected = 1;\n-\t}\n-      else\n-\t{\n-\t  struct __go_receive_nonblocking_small s;\n-\n-\t  s = __go_receive_nonblocking_small (channel);\n-\t  ret.selected = s.__success || s.__closed;\n-\t  ret.received = s.__success;\n-\t  u.v = s.__val;\n-\t}\n-\n-#ifndef WORDS_BIGENDIAN\n-      __builtin_memcpy (pv, u.b, element_size);\n-#else\n-      __builtin_memcpy (pv, u.b + sizeof (uint64_t) - element_size,\n-\t\t\telement_size);\n-#endif\n-    }\n-  else\n-    {\n-      if (!nb)\n-\t{\n-\t  ret.received = __go_receive_big (channel, pv, 0);\n-\t  ret.selected = 1;\n-\t}\n-      else\n-\t{\n-\t  _Bool got;\n-\t  _Bool closed;\n-\n-\t  got = __go_receive_nonblocking_big (channel, pv, &closed);\n-\t  ret.selected = got || closed;\n-\t  ret.received = got;\n-\t}\n-    }\n-\n-  return ret;\n-}\n-\n-extern void chanclose (uintptr_t) asm (\"libgo_reflect.reflect.chanclose\");\n-\n-void\n-chanclose (uintptr_t ch)\n-{\n-  struct __go_channel *channel = (struct __go_channel *) ch;\n-\n-  __go_builtin_close (channel);\n-}\n-\n-extern int32_t chanlen (uintptr_t) asm (\"libgo_reflect.reflect.chanlen\");\n-\n-int32_t\n-chanlen (uintptr_t ch)\n-{\n-  struct __go_channel *channel = (struct __go_channel *) ch;\n-\n-  return (int32_t) __go_chan_len (channel);\n-}\n-\n-extern int32_t chancap (uintptr_t) asm (\"libgo_reflect.reflect.chancap\");\n-\n-int32_t\n-chancap (uintptr_t ch)\n-{\n-  struct __go_channel *channel = (struct __go_channel *) ch;\n-\n-  return (int32_t) __go_chan_cap (channel);\n-}"}, {"sha": "677c699b52c39c168fd69dd32fbd28dcd5ae67c8", "filename": "libgo/runtime/go-select.c", "status": "removed", "additions": 0, "deletions": 758, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-select.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-select.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-select.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,758 +0,0 @@\n-/* go-select.c -- implement select.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <pthread.h>\n-#include <stdarg.h>\n-#include <stddef.h>\n-#include <stdint.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-\n-#include \"runtime.h\"\n-#include \"config.h\"\n-#include \"go-assert.h\"\n-#include \"channel.h\"\n-\n-/* __go_select builds an array of these structures.  */\n-\n-struct select_channel\n-{\n-  /* The channel being selected.  */\n-  struct __go_channel* channel;\n-  /* If this channel is selected, the value to return.  */\n-  uintptr_t retval;\n-  /* If this channel is a duplicate of one which appears earlier in\n-     the array, this is the array index of the earlier channel.  This\n-     is -1UL if this is not a dup.  */\n-  uintptr_t dup_index;\n-  /* An entry to put on the send or receive queue.  */\n-  struct __go_channel_select queue_entry;\n-  /* True if selected for send.  */\n-  _Bool is_send;\n-  /* True if channel is ready--it has data to receive or space to\n-     send.  */\n-  _Bool is_ready;\n-};\n-\n-/* This mutex controls access to __go_select_cond.  This mutex may not\n-   be acquired if any channel locks are held.  */\n-\n-static pthread_mutex_t __go_select_mutex = PTHREAD_MUTEX_INITIALIZER;\n-\n-/* When we have to wait for channels, we tell them to trigger this\n-   condition variable when they send or receive something.  */\n-\n-static pthread_cond_t __go_select_cond = PTHREAD_COND_INITIALIZER;\n-\n-/* Sort the channels by address.  This avoids deadlock when multiple\n-   selects are running on overlapping sets of channels.  */\n-\n-static int\n-channel_sort (const void *p1, const void *p2)\n-{\n-  const struct select_channel *c1 = (const struct select_channel *) p1;\n-  const struct select_channel *c2 = (const struct select_channel *) p2;\n-\n-  if ((uintptr_t) c1->channel < (uintptr_t) c2->channel)\n-    return -1;\n-  else if ((uintptr_t) c1->channel > (uintptr_t) c2->channel)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Return whether there is an entry on QUEUE which can be used for a\n-   synchronous send or receive.  */\n-\n-static _Bool\n-is_queue_ready (struct __go_channel_select *queue)\n-{\n-  int x;\n-\n-  if (queue == NULL)\n-    return 0;\n-\n-  x = pthread_mutex_lock (&__go_select_data_mutex);\n-  __go_assert (x == 0);\n-\n-  while (queue != NULL)\n-    {\n-      if (*queue->selected == NULL)\n-\tbreak;\n-      queue = queue->next;\n-    }\n-\n-  x = pthread_mutex_unlock (&__go_select_data_mutex);\n-  __go_assert (x == 0);\n-\n-  return queue != NULL;\n-}\n-\n-/* Return whether CHAN is ready.  If IS_SEND is true check whether it\n-   has space to send, otherwise check whether it has a value to\n-   receive.  */\n-\n-static _Bool\n-is_channel_ready (struct __go_channel* channel, _Bool is_send)\n-{\n-  if (is_send)\n-    {\n-      if (channel->selected_for_send)\n-\treturn 0;\n-      if (channel->is_closed)\n-\treturn 1;\n-      if (channel->num_entries > 0)\n-\t{\n-\t  /* An asynchronous channel is ready for sending if there is\n-\t     room in the buffer.  */\n-\t  return ((channel->next_store + 1) % channel->num_entries\n-\t\t  != channel->next_fetch);\n-\t}\n-      else\n-\t{\n-\t  if (channel->waiting_to_send)\n-\t    {\n-\t      /* Some other goroutine is waiting to send on this\n-\t\t channel, so we can't.  */\n-\t      return 0;\n-\t    }\n-\t  if (channel->waiting_to_receive)\n-\t    {\n-\t      /* Some other goroutine is waiting to receive a value,\n-\t\t so we can send one.  */\n-\t      return 1;\n-\t    }\n-\t  if (is_queue_ready (channel->select_receive_queue))\n-\t    {\n-\t      /* There is a select statement waiting to synchronize\n-\t\t with this one.  */\n-\t      return 1;\n-\t    }\n-\t  return 0;\n-\t}\n-    }\n-  else\n-    {\n-      if (channel->selected_for_receive)\n-\treturn 0;\n-      if (channel->is_closed)\n-\treturn 1;\n-      if (channel->num_entries > 0)\n-\t{\n-\t  /* An asynchronous channel is ready for receiving if there\n-\t     is a value in the buffer.  */\n-\t  return channel->next_fetch != channel->next_store;\n-\t}\n-      else\n-\t{\n-\t  if (channel->waiting_to_receive)\n-\t    {\n-\t      /* Some other goroutine is waiting to receive from this\n-\t\t channel, so it is not ready for us to receive.  */\n-\t      return 0;\n-\t    }\n-\t  if (channel->next_store > 0)\n-\t    {\n-\t      /* There is data on the channel.  */\n-\t      return 1;\n-\t    }\n-\t  if (is_queue_ready (channel->select_send_queue))\n-\t    {\n-\t      /* There is a select statement waiting to synchronize\n-\t\t with this one.  */\n-\t      return 1;\n-\t    }\n-\t  return 0;\n-\t}\n-    }\n-}\n-\n-/* Mark a channel as selected.  The channel is locked.  IS_SELECTED is\n-   true if the channel was selected for us by another goroutine.  We\n-   set *NEEDS_BROADCAST if we need to broadcast on the select\n-   condition variable.  Return true if we got it.  */\n-\n-static _Bool\n-mark_channel_selected (struct __go_channel *channel, _Bool is_send,\n-\t\t       _Bool is_selected, _Bool *needs_broadcast)\n-{\n-  if (channel->num_entries == 0)\n-    {\n-      /* This is a synchronous channel.  If there is no goroutine\n-\t currently waiting, but there is another select waiting, then\n-\t we need to tell that select to use this channel.  That may\n-\t fail--there may be no other goroutines currently waiting--as\n-\t a third goroutine may already have claimed the select.  */\n-      if (!is_selected\n-\t  && !channel->is_closed\n-\t  && (is_send\n-\t      ? !channel->waiting_to_receive\n-\t      : channel->next_store == 0))\n-\t{\n-\t  int x;\n-\t  struct __go_channel_select *queue;\n-\n-\t  x = pthread_mutex_lock (&__go_select_data_mutex);\n-\t  __go_assert (x == 0);\n-\n-\t  queue = (is_send\n-\t\t   ? channel->select_receive_queue\n-\t\t   : channel->select_send_queue);\n-\t  __go_assert (queue != NULL);\n-\n-\t  while (queue != NULL)\n-\t    {\n-\t      if (*queue->selected == NULL)\n-\t\t{\n-\t\t  *queue->selected = channel;\n-\t\t  *queue->is_read = !is_send;\n-\t\t  break;\n-\t\t}\n-\t      queue = queue->next;\n-\t    }\n-\n-\t  x = pthread_mutex_unlock (&__go_select_data_mutex);\n-\t  __go_assert (x == 0);\n-\n-\t  if (queue == NULL)\n-\t    return 0;\n-\n-\t  if (is_send)\n-\t    channel->selected_for_receive = 1;\n-\t  else\n-\t    channel->selected_for_send = 1;\n-\n-\t  /* We are going to have to tell the other select that there\n-\t     is something to do.  */\n-\t  *needs_broadcast = 1;\n-\t}\n-    }\n-\n-  if (is_send)\n-    channel->selected_for_send = 1;\n-  else\n-    channel->selected_for_receive = 1;\n-\n-  return 1;\n-}\n-\n-/* Mark a channel to indicate that a select is waiting.  The channel\n-   is locked.  */\n-\n-static void\n-mark_select_waiting (struct select_channel *sc,\n-\t\t     struct __go_channel **selected_pointer,\n-\t\t     _Bool *selected_for_read_pointer)\n-{\n-  struct __go_channel *channel = sc->channel;\n-  _Bool is_send = sc->is_send;\n-\n-  if (channel->num_entries == 0)\n-    {\n-      struct __go_channel_select **pp;\n-\n-      pp = (is_send\n-\t    ? &channel->select_send_queue\n-\t    : &channel->select_receive_queue);\n-\n-      /* Add an entry to the queue of selects on this channel.  */\n-      sc->queue_entry.next = *pp;\n-      sc->queue_entry.selected = selected_pointer;\n-      sc->queue_entry.is_read = selected_for_read_pointer;\n-\n-      *pp = &sc->queue_entry;\n-    }\n-\n-  channel->select_mutex = &__go_select_mutex;\n-  channel->select_cond = &__go_select_cond;\n-\n-  /* We never actually clear the select_mutex and select_cond fields.\n-     In order to clear them safely, we would need to have some way of\n-     knowing when no select is waiting for the channel.  Thus we\n-     introduce a bit of inefficiency for every channel that select\n-     needs to wait for.  This is harmless other than the performance\n-     cost.  */\n-}\n-\n-/* Remove the entry for this select waiting on this channel.  The\n-   channel is locked.  We check both queues, because the channel may\n-   be selected for both reading and writing.  */\n-\n-static void\n-clear_select_waiting (struct select_channel *sc,\n-\t\t      struct __go_channel **selected_pointer)\n-{\n-  struct __go_channel *channel = sc->channel;\n-\n-  if (channel->num_entries == 0)\n-    {\n-      _Bool found;\n-      struct __go_channel_select **pp;\n-\n-      found = 0;\n-\n-      for (pp = &channel->select_send_queue; *pp != NULL; pp = &(*pp)->next)\n-\t{\n-\t  if ((*pp)->selected == selected_pointer)\n-\t    {\n-\t      *pp = (*pp)->next;\n-\t      found = 1;\n-\t      break;\n-\t    }\n-\t}\n-\n-      for (pp = &channel->select_receive_queue; *pp != NULL; pp = &(*pp)->next)\n-\t{\n-\t  if ((*pp)->selected == selected_pointer)\n-\t    {\n-\t      *pp = (*pp)->next;\n-\t      found = 1;\n-\t      break;\n-\t    }\n-\t}\n-\n-      __go_assert (found);\n-    }\n-}\n-\n-/* Look through the list of channels to see which ones are ready.\n-   Lock each channels, and set the is_ready flag.  Return the number\n-   of ready channels.  */\n-\n-static uintptr_t\n-lock_channels_find_ready (struct select_channel *channels, uintptr_t count)\n-{\n-  uintptr_t ready_count;\n-  uintptr_t i;\n-\n-  ready_count = 0;\n-  for (i = 0; i < count; ++i)\n-    {\n-      struct __go_channel *channel = channels[i].channel;\n-      _Bool is_send = channels[i].is_send;\n-      uintptr_t dup_index = channels[i].dup_index;\n-      int x;\n-\n-      if (channel == NULL)\n-\tcontinue;\n-\n-      if (dup_index != (uintptr_t) -1UL)\n-\t{\n-\t  if (channels[dup_index].is_ready)\n-\t    {\n-\t      channels[i].is_ready = 1;\n-\t      ++ready_count;\n-\t    }\n-\t  continue;\n-\t}\n-\n-      x = pthread_mutex_lock (&channel->lock);\n-      __go_assert (x == 0);\n-\n-      if (is_channel_ready (channel, is_send))\n-\t{\n-\t  channels[i].is_ready = 1;\n-\t  ++ready_count;\n-\t}\n-    }\n-\n-  return ready_count;\n-}\n-\n-/* The channel we are going to select has been forced by some other\n-   goroutine.  SELECTED_CHANNEL is the channel we will use,\n-   SELECTED_FOR_READ is whether the other goroutine wants to read from\n-   the channel.  Note that the channel could be specified multiple\n-   times in this select, so we must mark each appropriate entry for\n-   this channel as ready.  Every other channel is marked as not ready.\n-   All the channels are locked before this routine is called.  This\n-   returns the number of ready channels.  */\n-\n-uintptr_t\n-force_selected_channel_ready (struct select_channel *channels, uintptr_t count,\n-\t\t\t      struct __go_channel *selected_channel,\n-\t\t\t      _Bool selected_for_read)\n-{\n-  uintptr_t ready_count;\n-  uintptr_t i;\n-\n-  ready_count = 0;\n-  for (i = 0; i < count; ++i)\n-    {\n-      struct __go_channel *channel = channels[i].channel;\n-      _Bool is_send = channels[i].is_send;\n-\n-      if (channel == NULL)\n-\tcontinue;\n-\n-      if (channel != selected_channel\n-\t  || (is_send ? !selected_for_read : selected_for_read))\n-\tchannels[i].is_ready = 0;\n-      else\n-\t{\n-\t  channels[i].is_ready = 1;\n-\t  ++ready_count;\n-\t}\n-    }\n-  __go_assert (ready_count > 0);\n-  return ready_count;\n-}\n-\n-/* Unlock all the channels.  */\n-\n-static void\n-unlock_channels (struct select_channel *channels, uintptr_t count)\n-{\n-  uintptr_t i;\n-  int x;\n-\n-  for (i = 0; i < count; ++i)\n-    {\n-      struct __go_channel *channel = channels[i].channel;\n-\n-      if (channel == NULL)\n-\tcontinue;\n-\n-      if (channels[i].dup_index != (uintptr_t) -1UL)\n-\tcontinue;\n-\n-      x = pthread_mutex_unlock (&channel->lock);\n-      __go_assert (x == 0);\n-    }\n-}\n-\n-/* At least one channel is ready.  Randomly pick a channel to return.\n-   Unlock all the channels.  IS_SELECTED is true if the channel was\n-   picked for us by some other goroutine.  If SELECTED_POINTER is not\n-   NULL, remove it from the queue for all the channels.  Return the\n-   retval field of the selected channel.  This will return 0 if we\n-   can't use the selected channel, because it relied on synchronizing\n-   with some other select, and that select already synchronized with a\n-   different channel.  */\n-\n-static uintptr_t\n-unlock_channels_and_select (struct select_channel *channels,\n-\t\t\t    uintptr_t count, uintptr_t ready_count,\n-\t\t\t    _Bool is_selected,\n-\t\t\t    struct __go_channel **selected_pointer)\n-{\n-  uintptr_t selected;\n-  uintptr_t ret;\n-  _Bool needs_broadcast;\n-  uintptr_t i;\n-  int x;\n-\n-  /* Pick which channel we are going to return.  */\n-#if defined(HAVE_RANDOM)\n-  selected = (uintptr_t) random () % ready_count;\n-#else\n-  selected = (uintptr_t) rand () % ready_count;\n-#endif\n-  ret = 0;\n-  needs_broadcast = 0;\n-\n-  /* Look at the channels in reverse order so that we don't unlock a\n-     duplicated channel until we have seen all its dups.  */\n-  for (i = 0; i < count; ++i)\n-    {\n-      uintptr_t j = count - i - 1;\n-      struct __go_channel *channel = channels[j].channel;\n-      _Bool is_send = channels[j].is_send;\n-\n-      if (channel == NULL)\n-\tcontinue;\n-\n-      if (channels[j].is_ready)\n-\t{\n-\t  if (selected == 0)\n-\t    {\n-\t      if (mark_channel_selected (channel, is_send, is_selected,\n-\t\t\t\t\t &needs_broadcast))\n-\t\tret = channels[j].retval;\n-\t    }\n-\n-\t  --selected;\n-\t}\n-\n-      if (channels[j].dup_index == (uintptr_t) -1UL)\n-\t{\n-\t  if (selected_pointer != NULL)\n-\t    clear_select_waiting (&channels[j], selected_pointer);\n-\n-\t  x = pthread_mutex_unlock (&channel->lock);\n-\t  __go_assert (x == 0);\n-\t}\n-    }\n-\n-  /* The NEEDS_BROADCAST variable is set if we are synchronizing with\n-     some other select statement.  We can't do the actual broadcast\n-     until we have unlocked all the channels.  */\n-\n-  if (needs_broadcast)\n-    {\n-      x = pthread_mutex_lock (&__go_select_mutex);\n-      __go_assert (x == 0);\n-\n-      x = pthread_cond_broadcast (&__go_select_cond);\n-      __go_assert (x == 0);\n-\n-      x = pthread_mutex_unlock (&__go_select_mutex);\n-      __go_assert (x == 0);\n-    }\n-\n-  return ret;\n-}\n-\n-/* Mark all channels to show that we are waiting for them.  This is\n-   called with the select mutex held, but none of the channels are\n-   locked.  This returns true if some channel was found to be\n-   ready.  */\n-\n-static _Bool\n-mark_all_channels_waiting (struct select_channel* channels, uintptr_t count,\n-\t\t\t   struct __go_channel **selected_pointer,\n-\t\t\t   _Bool *selected_for_read_pointer)\n-{\n-  _Bool ret;\n-  int x;\n-  uintptr_t i;\n-\n-  ret = 0;\n-  for (i = 0; i < count; ++i)\n-    {\n-      struct __go_channel *channel = channels[i].channel;\n-      _Bool is_send = channels[i].is_send;\n-\n-      if (channel == NULL)\n-\tcontinue;\n-\n-      if (channels[i].dup_index != (uintptr_t) -1UL)\n-\t{\n-\t  uintptr_t j;\n-\n-\t  /* A channel may be selected for both read and write.  */\n-\t  if (channels[channels[i].dup_index].is_send == is_send)\n-\t    continue;\n-\t  else\n-\t    {\n-\t      for (j = channels[i].dup_index + 1; j < i; ++j)\n-\t\t{\n-\t\t  if (channels[j].channel == channel\n-\t\t      && channels[j].is_send == is_send)\n-\t\t    break;\n-\t\t}\n-\t      if (j < i)\n-\t\tcontinue;\n-\t    }\n-\t}\n-\n-      x = pthread_mutex_lock (&channel->lock);\n-      __go_assert (x == 0);\n-\n-      /* To avoid a race condition, we have to check again whether the\n-\t channel is ready.  It may have become ready since we did the\n-\t first set of checks but before we acquired the select mutex.\n-\t If we don't check here, we could sleep forever on the select\n-\t condition variable.  */\n-      if (is_channel_ready (channel, is_send))\n-\tret = 1;\n-\n-      /* If SELECTED_POINTER is NULL, then we have already marked the\n-\t channel as waiting.  */\n-      if (selected_pointer != NULL)\n-\tmark_select_waiting (&channels[i], selected_pointer,\n-\t\t\t     selected_for_read_pointer);\n-\n-      x = pthread_mutex_unlock (&channel->lock);\n-      __go_assert (x == 0);\n-    }\n-\n-  return ret;\n-}\n-\n-/* Implement select.  This is called by the compiler-generated code\n-   with pairs of arguments: a pointer to a channel, and an int which\n-   is non-zero for send, zero for receive.  */\n-\n-uintptr_t\n-__go_select (uintptr_t count, _Bool has_default,\n-\t     struct __go_channel **channel_args, _Bool *is_send_args)\n-{\n-  struct select_channel stack_buffer[16];\n-  struct select_channel *allocated_buffer;\n-  struct select_channel *channels;\n-  uintptr_t i;\n-  int x;\n-  struct __go_channel *selected_channel;\n-  _Bool selected_for_read;\n-  _Bool is_queued;\n-\n-  if (count < sizeof stack_buffer / sizeof stack_buffer[0])\n-    {\n-      channels = &stack_buffer[0];\n-      allocated_buffer = NULL;\n-    }\n-  else\n-    {\n-      allocated_buffer = ((struct select_channel *)\n-\t\t\t  malloc (count * sizeof (struct select_channel)));\n-      channels = allocated_buffer;\n-    }\n-\n-  for (i = 0; i < count; ++i)\n-    {\n-      struct __go_channel *channel_arg = channel_args[i];\n-      _Bool is_send = is_send_args[i];\n-\n-      channels[i].channel = (struct __go_channel*) channel_arg;\n-      channels[i].retval = i + 1;\n-      channels[i].dup_index = (uintptr_t) -1UL;\n-      channels[i].queue_entry.next = NULL;\n-      channels[i].queue_entry.selected = NULL;\n-      channels[i].is_send = is_send;\n-      channels[i].is_ready = 0;\n-    }\n-\n-  qsort (channels, count, sizeof (struct select_channel), channel_sort);\n-\n-  for (i = 0; i < count; ++i)\n-    {\n-      uintptr_t j;\n-\n-      for (j = 0; j < i; ++j)\n-\t{\n-\t  if (channels[j].channel == channels[i].channel)\n-\t    {\n-\t      channels[i].dup_index = j;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  /* SELECT_CHANNEL is used to select synchronized channels.  If no\n-     channels are ready, we store a pointer to this variable on the\n-     select queue for each synchronized channel.  Because the variable\n-     may be set by channel operations running in other goroutines,\n-     SELECT_CHANNEL may only be accessed when all the channels are\n-     locked and/or when the select_data_mutex is locked.  */\n-  selected_channel = NULL;\n-\n-  /* SELECTED_FOR_READ is set to true if SELECTED_CHANNEL was set by a\n-     goroutine which wants to read from the channel.  The access\n-     restrictions for this are like those for SELECTED_CHANNEL.  */\n-  selected_for_read = 0;\n-\n-  /* IS_QUEUED is true if we have queued up this select on the queues\n-     for any associated synchronous channels.  We only do this if no\n-     channels are ready the first time around the loop.  */\n-  is_queued = 0;\n-\n-  while (1)\n-    {\n-      int ready_count;\n-      _Bool is_selected;\n-\n-      /* Lock all channels, identify which ones are ready.  */\n-      ready_count = lock_channels_find_ready (channels, count);\n-\n-      /* All the channels are locked, so we can look at\n-\t SELECTED_CHANNEL.  If it is not NULL, then our choice has\n-\t been forced by some other goroutine.  This can only happen\n-\t after the first time through the loop.  */\n-      is_selected = selected_channel != NULL;\n-      if (is_selected)\n-\tready_count = force_selected_channel_ready (channels, count,\n-\t\t\t\t\t\t    selected_channel,\n-\t\t\t\t\t\t    selected_for_read);\n-\n-      if (ready_count > 0)\n-\t{\n-\t  uintptr_t ret;\n-\n-\t  ret = unlock_channels_and_select (channels, count, ready_count,\n-\t\t\t\t\t    is_selected,\n-\t\t\t\t\t    (is_queued\n-\t\t\t\t\t     ? &selected_channel\n-\t\t\t\t\t     : NULL));\n-\n-\t  /* If RET is zero, it means that the channel we picked\n-\t     turned out not to be ready, because some other select\n-\t     grabbed it during our traversal.  Loop around and try\n-\t     again.  */\n-\t  if (ret == 0)\n-\t    {\n-\t      is_queued = 0;\n-\t      /* We are no longer on any channel queues, so it is safe\n-\t\t to touch SELECTED_CHANNEL here.  It must be NULL,\n-\t\t because otherwise that would somebody has promised to\n-\t\t synch up with us and then failed to do so.  */\n-\t      __go_assert (selected_channel == NULL);\n-\t      continue;\n-\t    }\n-\n-\t  if (allocated_buffer != NULL)\n-\t    free (allocated_buffer);\n-\n-\t  return ret;\n-\t}\n-\n-      /* No channels were ready.  */\n-\n-      unlock_channels (channels, count);\n-\n-      if (has_default)\n-\t{\n-\t  /* Use the default clause.  */\n-\t  if (allocated_buffer != NULL)\n-\t    free (allocated_buffer);\n-\t  return 0;\n-\t}\n-\n-      /* This is a blocking select.  Grab the select lock, tell all\n-\t the channels to notify us when something happens, and wait\n-\t for something to happen.  */\n-\n-      x = pthread_mutex_lock (&__go_select_mutex);\n-      __go_assert (x == 0);\n-\n-      /* Check whether CHANNEL_SELECTED was set while the channels\n-\t were unlocked.  If it was set, then we can simply loop around\n-\t again.  We need to check this while the select mutex is held.\n-\t It is possible that something will set CHANNEL_SELECTED while\n-\t we mark the channels as waiting.  If this happens, that\n-\t goroutine is required to signal the select condition\n-\t variable, which means acquiring the select mutex.  Since we\n-\t have the select mutex locked ourselves, we can not miss that\n-\t signal.  */\n-\n-      x = pthread_mutex_lock (&__go_select_data_mutex);\n-      __go_assert (x == 0);\n-\n-      is_selected = selected_channel != NULL;\n-\n-      x = pthread_mutex_unlock (&__go_select_data_mutex);\n-      __go_assert (x == 0);\n-\n-      if (!is_selected)\n-\t{\n-\t  /* Mark the channels as waiting, and check whether they have\n-\t     become ready.  */\n-\t  if (!mark_all_channels_waiting (channels, count,\n-\t\t\t\t\t  (is_queued\n-\t\t\t\t\t   ? NULL\n-\t\t\t\t\t   : &selected_channel),\n-\t\t\t\t\t  (is_queued\n-\t\t\t\t\t   ? NULL\n-\t\t\t\t\t   : &selected_for_read)))\n-\t    runtime_cond_wait (&__go_select_cond, &__go_select_mutex);\n-\n-\t  is_queued = 1;\n-\t}\n-\n-      x = pthread_mutex_unlock (&__go_select_mutex);\n-      __go_assert (x == 0);\n-    }\n-}"}, {"sha": "61d4a0f13d9247afa2c1abbf8e65dc12c80bcc20", "filename": "libgo/runtime/go-send-big.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-big.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,34 +0,0 @@\n-/* go-send-big.c -- send something bigger than uint64_t on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"go-panic.h\"\n-#include \"channel.h\"\n-\n-void\n-__go_send_big (struct __go_channel* channel, const void *val, _Bool for_select)\n-{\n-  uintptr_t element_size;\n-  size_t alloc_size;\n-  size_t offset;\n-\n-  if (channel == NULL)\n-    {\n-      // Block forever.\n-      __go_select (0, 0, NULL, NULL);\n-    }\n-\n-  element_size = channel->element_type->__size;\n-  alloc_size = (element_size + sizeof (uint64_t) - 1) / sizeof (uint64_t);\n-\n-  __go_send_acquire (channel, for_select);\n-\n-  offset = channel->next_store * alloc_size;\n-  __builtin_memcpy (&channel->data[offset], val, element_size);\n-\n-  __go_send_release (channel);\n-}"}, {"sha": "e039874ef9abe704b18b5b2c4d24bef6867dcde4", "filename": "libgo/runtime/go-send-nb-big.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-nb-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-nb-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-nb-big.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,33 +0,0 @@\n-/* go-send-nb-big.c -- nonblocking send of something big on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"channel.h\"\n-\n-_Bool\n-__go_send_nonblocking_big (struct __go_channel* channel, const void *val)\n-{\n-  uintptr_t element_size;\n-  size_t alloc_size;\n-  size_t offset;\n-\n-  if (channel == NULL)\n-    return 0;\n-\n-  element_size = channel->element_type->__size;\n-  alloc_size = (element_size + sizeof (uint64_t) - 1) / sizeof (uint64_t);\n-\n-  if (!__go_send_nonblocking_acquire (channel))\n-    return 0;\n-\n-  offset = channel->next_store * alloc_size;\n-  __builtin_memcpy (&channel->data[offset], val, element_size);\n-\n-  __go_send_release (channel);\n-\n-  return 1;\n-}"}, {"sha": "c77ee9183e20b9814a2eb23d16287ee3a0040155", "filename": "libgo/runtime/go-send-nb-small.c", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-nb-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-nb-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-nb-small.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,107 +0,0 @@\n-/* go-send-nb-small.c -- nonblocking send of something small on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"channel.h\"\n-\n-/* Prepare to send something on a nonblocking channel.  Return true if\n-   we acquired the channel, false if we did not acquire it because\n-   there is no space to send a value.  */\n-\n-_Bool\n-__go_send_nonblocking_acquire (struct __go_channel *channel)\n-{\n-  int i;\n-  _Bool has_space;\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  while (channel->selected_for_send)\n-    runtime_cond_wait (&channel->cond, &channel->lock);\n-\n-  if (channel->is_closed)\n-    {\n-      i = pthread_mutex_unlock (&channel->lock);\n-      __go_assert (i == 0);\n-      runtime_panicstring (\"send on closed channel\");\n-    }\n-\n-  if (channel->num_entries > 0)\n-      has_space = ((channel->next_store + 1) % channel->num_entries\n-\t\t   != channel->next_fetch);\n-  else\n-    {\n-      /* This is a synchronous channel.  If somebody is current\n-\t sending, then we can't send.  Otherwise, see if somebody is\n-\t waiting to receive, or see if we can synch with a select.  */\n-      if (channel->waiting_to_send)\n-\t{\n-\t  /* Some other goroutine is currently sending on this\n-\t     channel, which means that we can't.  */\n-\t  has_space = 0;\n-\t}\n-      else if (channel->waiting_to_receive)\n-\t{\n-\t  /* Some other goroutine is waiting to receive a value, so we\n-\t     can send directly to them.  */\n-\t  has_space = 1;\n-\t}\n-      else if (__go_synch_with_select (channel, 1))\n-\t{\n-\t  /* We found a select waiting to receive data, so we can send\n-\t     to that.  */\n-\t  __go_broadcast_to_select (channel);\n-\t  has_space = 1;\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise, we can't send, because nobody is waiting to\n-\t     receive.  */\n-\t  has_space = 0;\n-\t}\n-\n-      if (has_space)\n-\t{\n-\t  channel->waiting_to_send = 1;\n-\t  __go_assert (channel->next_store == 0);\n-\t}\n-    }\n-\n-  if (!has_space)\n-    {\n-      i = pthread_mutex_unlock (&channel->lock);\n-      __go_assert (i == 0);\n-\n-      return 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Send something 64 bits or smaller on a channel.  */\n-\n-_Bool\n-__go_send_nonblocking_small (struct __go_channel *channel, uint64_t val)\n-{\n-  if (channel == NULL)\n-    return 0;\n-\n-  __go_assert (channel->element_type->__size <= sizeof (uint64_t));\n-\n-  if (!__go_send_nonblocking_acquire (channel))\n-    return 0;\n-\n-  channel->data[channel->next_store] = val;\n-\n-  __go_send_release (channel);\n-\n-  return 1;\n-}"}, {"sha": "06bcb41b9add6613c9d0d2c39558241494be5c1a", "filename": "libgo/runtime/go-send-small.c", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f7a48eddb72c733d6ae586bcaace89773b3172/libgo%2Fruntime%2Fgo-send-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-small.c?ref=04f7a48eddb72c733d6ae586bcaace89773b3172", "patch": "@@ -1,159 +0,0 @@\n-/* go-send-small.c -- send something 64 bits or smaller on a channel.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"channel.h\"\n-\n-/* Prepare to send something on a channel.  FOR_SELECT is true if this\n-   call is being made after a select statement returned with this\n-   channel selected.  */\n-\n-void\n-__go_send_acquire (struct __go_channel *channel, _Bool for_select)\n-{\n-  int i;\n-\n-  i = pthread_mutex_lock (&channel->lock);\n-  __go_assert (i == 0);\n-\n-  while (1)\n-    {\n-      if (channel->is_closed)\n-\t{\n-\t  if (for_select)\n-\t    channel->selected_for_send = 0;\n-\t  i = pthread_mutex_unlock (&channel->lock);\n-\t  __go_assert (i == 0);\n-\t  runtime_panicstring (\"send on closed channel\");\n-\t}\n-\n-      /* If somebody else has the channel locked for sending, we have\n-\t to wait.  If FOR_SELECT is true, then we are the one with the\n-\t lock.  */\n-      if (!channel->selected_for_send || for_select)\n-\t{\n-\t  if (channel->num_entries == 0)\n-\t    {\n-\t      /* This is a synchronous channel.  If nobody else is\n-\t\t waiting to send, we grab the channel and tell the\n-\t\t caller to send the data.  We will then wait for a\n-\t\t receiver.  */\n-\t      if (!channel->waiting_to_send)\n-\t\t{\n-\t\t  __go_assert (channel->next_store == 0);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If there is room on the channel, we are OK.  */\n-\t      if ((channel->next_store + 1) % channel->num_entries\n-\t\t  != channel->next_fetch)\n-\t\treturn;\n-\t    }\n-\t}\n-\n-      /* Wait for something to change, then loop around and try\n-\t again.  */\n-\n-      runtime_cond_wait (&channel->cond, &channel->lock);\n-    }\n-}\n-\n-/* Finished sending something on a channel.  */\n-\n-void\n-__go_send_release (struct __go_channel *channel)\n-{\n-  int i;\n-\n-  if (channel->num_entries != 0)\n-    {\n-      /* This is a buffered channel.  Bump the store count and signal\n-\t the condition variable.  */\n-      channel->next_store = (channel->next_store + 1) % channel->num_entries;\n-\n-      i = pthread_cond_signal (&channel->cond);\n-      __go_assert (i == 0);\n-    }\n-  else\n-    {\n-      _Bool synched_with_select;\n-\n-      /* This is a synchronous channel.  Indicate that we have a value\n-\t waiting.  */\n-      channel->next_store = 1;\n-      channel->waiting_to_send = 1;\n-\n-      /* Tell everybody else to do something.  This has to be a\n-\t broadcast because we might have both senders and receivers\n-\t waiting on the condition, but senders won't send another\n-\t signal.  */\n-      i = pthread_cond_broadcast (&channel->cond);\n-      __go_assert (i == 0);\n-\n-      /* Wait until the value is received.  */\n-      synched_with_select = 0;\n-      while (1)\n-\t{\n-\t  if (channel->next_store == 0)\n-\t    break;\n-\n-\t  /* If nobody is currently waiting to receive, try to synch\n-\t     up with a select.  */\n-\t  if (!channel->waiting_to_receive && !synched_with_select)\n-\t    {\n-\t      if (__go_synch_with_select (channel, 1))\n-\t\t{\n-\t\t  synched_with_select = 1;\n-\t\t  __go_broadcast_to_select (channel);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n-\t  runtime_cond_wait (&channel->cond, &channel->lock);\n-\t}\n-\n-      channel->waiting_to_send = 0;\n-\n-      /* Using the mutexes should implement a memory barrier.  */\n-\n-      /* We have to signal again since we cleared the waiting_to_send\n-\t field.  This has to be a broadcast because both senders and\n-\t receivers might be waiting, but only senders will be able to\n-\t act.  */\n-      i = pthread_cond_broadcast (&channel->cond);\n-      __go_assert (i == 0);\n-    }\n-\n-  channel->selected_for_send = 0;\n-\n-  __go_unlock_and_notify_selects (channel);\n-}\n-\n-/* Send something 64 bits or smaller on a channel.  */\n-\n-void\n-__go_send_small (struct __go_channel *channel, uint64_t val, _Bool for_select)\n-{\n-  if (channel == NULL)\n-    {\n-      // Block forever.\n-      __go_select (0, 0, NULL, NULL);\n-    }\n-\n-  __go_assert (channel->element_type->__size <= sizeof (uint64_t));\n-\n-  __go_send_acquire (channel, for_select);\n-\n-  channel->data[channel->next_store] = val;\n-\n-  __go_send_release (channel);\n-}"}, {"sha": "db59be5d062cb7c6af8e05997249fbacdcce1fed", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e68d6d75a599806335a90b73b8c0e404c1fc021/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=3e68d6d75a599806335a90b73b8c0e404c1fc021", "patch": "@@ -55,14 +55,15 @@ typedef\tstruct\tM\t\tM;\n typedef\tunion\tNote\t\tNote;\n typedef\tstruct\tMCache\t\tMCache;\n typedef struct\tFixAlloc\tFixAlloc;\n+typedef\tstruct\tHchan\t\tHchan;\n \n-typedef\tstruct\t__go_defer_stack\tDefer;\n+typedef\tstruct\t__go_open_array\t\tSlice;\n+typedef\tstruct\t__go_string\t\tString;\n typedef struct\t__go_interface\t\tIface;\n typedef\tstruct\t__go_empty_interface\tEface;\n typedef\tstruct\t__go_type_descriptor\tType;\n+typedef\tstruct\t__go_defer_stack\tDefer;\n typedef\tstruct\t__go_panic_stack\tPanic;\n-typedef\tstruct\t__go_open_array\t\tSlice;\n-typedef\tstruct\t__go_string\t\tString;\n \n typedef struct\t__go_func_type\t\tFuncType;\n typedef struct\t__go_map_type\t\tMapType;\n@@ -131,6 +132,7 @@ struct\tG\n \tbool\tfromgogo;\t// reached from gogo\n \tint16\tstatus;\n \tint32\tgoid;\n+\tuint32\tselgen;\t\t// valid sudog pointer\n \tconst char*\twaitreason;\t// if status==Gwaiting\n \tG*\tschedlink;\n \tbool\treadyonstop;"}]}