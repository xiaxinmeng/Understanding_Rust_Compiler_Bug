{"sha": "93f8cb4965cebee125f96376367f05e18ee5749b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmOGNiNDk2NWNlYmVlMTI1Zjk2Mzc2MzY3ZjA1ZTE4ZWU1NzQ5Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-04T10:47:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-04T10:54:13Z"}, "message": "Reuse non-gimple_reg variable for inlining\n\nWhen a call to a function is inlined and takes a parameter whose type is not\ngimple_reg, a local variable is created in the caller to hold a copy of the\nargument passed in the call with the following comment:\n\n      /* We may produce non-gimple trees by adding NOPs or introduce\n         invalid sharing when operand is not really constant.\n         It is not big deal to prohibit constant propagation here as\n         we will constant propagate in DOM1 pass anyway.  *\n\nOf course the second sentence of the comment does not apply to non-gimple_reg\nvalues, unless they get SRAed later, because we don't do constant propagation\nfor them.  This for example prevents two identical calls to a pure function\nfrom being merged in the attached Ada testcase.\n\nTherefore the attached patch attempts to reuse a read-only or non-addressable\nlocal DECL of the caller, the hitch being that expand_call_inline needs to be\nprevented from creating a CLOBBER for the case where it ends uo being reused.\n\ngcc/\n\t* tree-inline.c (insert_debug_decl_map): Delete.\n\t(copy_debug_stmt): Minor tweak.\n\t(setup_one_parameter): Do not use a variable if the value is either\n\ta read-only DECL or a non-addressable local variable in the caller.\n\tIn this case, insert the debug-only variable in the map manually.\n\t(expand_call_inline): Do not generate a CLOBBER for these values.\n\t* tree-inline.h (debug_map): Minor tweak.", "tree": {"sha": "7c2e52b252af7e8b29870529caa3cd0bc6236701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c2e52b252af7e8b29870529caa3cd0bc6236701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93f8cb4965cebee125f96376367f05e18ee5749b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f8cb4965cebee125f96376367f05e18ee5749b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f8cb4965cebee125f96376367f05e18ee5749b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f8cb4965cebee125f96376367f05e18ee5749b/comments", "author": null, "committer": null, "parents": [{"sha": "f418bc3cd173bc4e679469928d4d96ffcc05fc7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f418bc3cd173bc4e679469928d4d96ffcc05fc7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f418bc3cd173bc4e679469928d4d96ffcc05fc7e"}], "stats": {"total": 121, "additions": 83, "deletions": 38}, "files": [{"sha": "547bef3a918552cd799776a98c592c47f98fc684", "filename": "gcc/testsuite/gnat.dg/opt94.adb", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94.adb?ref=93f8cb4965cebee125f96376367f05e18ee5749b", "patch": "@@ -0,0 +1,17 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -gnatn -fdump-tree-optimized\" }\n+\n+with Opt94_Pkg; use Opt94_Pkg;\n+\n+function Opt94 (S : String) return Integer is\n+  A : constant String := Get;\n+\n+begin\n+  if Valid_Result (A) then\n+    return Result (A);\n+  else\n+    return -1;\n+  end if;\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"worker\" 1 \"optimized\" } }"}, {"sha": "670291712fb8cbee24771bd15c8ccab40f1d333b", "filename": "gcc/testsuite/gnat.dg/opt94_pkg.adb", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94_pkg.adb?ref=93f8cb4965cebee125f96376367f05e18ee5749b", "patch": "@@ -0,0 +1,31 @@\n+package body Opt94_Pkg is\n+\n+  function Worker (S : String) return Integer;\n+  pragma Pure_Function (Worker);\n+\n+  function Valid_Result (S : String) return Boolean is\n+  begin\n+    return Worker (S) > 0;\n+  end;\n+\n+  function Result (S : String) return Integer is\n+    R : constant Integer := Worker (S);\n+  begin\n+    if R > 0 then\n+      return R;\n+    else\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+  function Worker (S : String) return Integer is\n+  begin\n+    return Character'Pos (S (S'First));\n+  end;\n+\n+  function Get return String is\n+  begin\n+    return \"\";\n+  end;\n+\n+end Opt94_Pkg;"}, {"sha": "16e34338d55258857eab2d79b170b37d93c56468", "filename": "gcc/testsuite/gnat.dg/opt94_pkg.ads", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt94_pkg.ads?ref=93f8cb4965cebee125f96376367f05e18ee5749b", "patch": "@@ -0,0 +1,11 @@\n+package Opt94_Pkg is\n+\n+  function Valid_Result (S : String) return Boolean;\n+  pragma Inline (Valid_Result);\n+\n+  function Result (S : String) return Integer;\n+  pragma Inline (Result);\n+\n+  function Get return String;\n+\n+end Opt94_Pkg;"}, {"sha": "49a5850f41048154dafbad3b762c4f6b2ad13c15", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=93f8cb4965cebee125f96376367f05e18ee5749b", "patch": "@@ -152,30 +152,6 @@ insert_decl_map (copy_body_data *id, tree key, tree value)\n     id->decl_map->put (value, value);\n }\n \n-/* Insert a tree->tree mapping for ID.  This is only used for\n-   variables.  */\n-\n-static void\n-insert_debug_decl_map (copy_body_data *id, tree key, tree value)\n-{\n-  if (!gimple_in_ssa_p (id->src_cfun))\n-    return;\n-\n-  if (!opt_for_fn (id->dst_fn, flag_var_tracking_assignments))\n-    return;\n-\n-  if (!target_for_debug_bind (key))\n-    return;\n-\n-  gcc_assert (TREE_CODE (key) == PARM_DECL);\n-  gcc_assert (VAR_P (value));\n-\n-  if (!id->debug_map)\n-    id->debug_map = new hash_map<tree, tree>;\n-\n-  id->debug_map->put (key, value);\n-}\n-\n /* If nonzero, we're remapping the contents of inlined debug\n    statements.  If negative, an error has occurred, such as a\n    reference to a variable that isn't available in the inlined\n@@ -3190,7 +3166,8 @@ copy_debug_stmt (gdebug *stmt, copy_body_data *id)\n   else\n     gcc_unreachable ();\n \n-  if (TREE_CODE (t) == PARM_DECL && id->debug_map\n+  if (TREE_CODE (t) == PARM_DECL\n+      && id->debug_map\n       && (n = id->debug_map->get (t)))\n     {\n       gcc_assert (VAR_P (*n));\n@@ -3460,16 +3437,18 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n      value.  */\n   if (TREE_READONLY (p)\n       && !TREE_ADDRESSABLE (p)\n-      && value && !TREE_SIDE_EFFECTS (value)\n+      && value\n+      && !TREE_SIDE_EFFECTS (value)\n       && !def)\n     {\n-      /* We may produce non-gimple trees by adding NOPs or introduce\n-\t invalid sharing when operand is not really constant.\n-\t It is not big deal to prohibit constant propagation here as\n-\t we will constant propagate in DOM1 pass anyway.  */\n-      if (is_gimple_min_invariant (value)\n-\t  && useless_type_conversion_p (TREE_TYPE (p),\n-\t\t\t\t\t\t TREE_TYPE (value))\n+      /* We may produce non-gimple trees by adding NOPs or introduce invalid\n+\t sharing when the value is not constant or DECL.  And we need to make\n+\t sure that it cannot be modified from another path in the callee.  */\n+      if ((is_gimple_min_invariant (value)\n+\t   || (DECL_P (value) && TREE_READONLY (value))\n+\t   || (auto_var_in_fn_p (value, id->src_fn)\n+\t       && !TREE_ADDRESSABLE (value)))\n+\t  && useless_type_conversion_p (TREE_TYPE (p), TREE_TYPE (value))\n \t  /* We have to be very careful about ADDR_EXPR.  Make sure\n \t     the base variable isn't a local variable of the inlined\n \t     function, e.g., when doing recursive inlining, direct or\n@@ -3478,7 +3457,9 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t  && ! self_inlining_addr_expr (value, fn))\n \t{\n \t  insert_decl_map (id, p, value);\n-\t  insert_debug_decl_map (id, p, var);\n+\t  if (!id->debug_map)\n+\t    id->debug_map = new hash_map<tree, tree>;\n+\t  id->debug_map->put (p, var);\n \t  return insert_init_debug_bind (id, bb, var, value, NULL);\n \t}\n     }\n@@ -5128,8 +5109,13 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n     for (tree p = DECL_ARGUMENTS (id->src_fn); p; p = DECL_CHAIN (p))\n       if (!TREE_THIS_VOLATILE (p))\n \t{\n+\t  /* The value associated with P is a local temporary only if\n+\t     there is no value associated with P in the debug map.  */\n \t  tree *varp = id->decl_map->get (p);\n-\t  if (varp && VAR_P (*varp) && !is_gimple_reg (*varp))\n+\t  if (varp\n+\t      && VAR_P (*varp)\n+\t      && !is_gimple_reg (*varp)\n+\t      && !(id->debug_map && id->debug_map->get (p)))\n \t    {\n \t      tree clobber = build_clobber (TREE_TYPE (*varp));\n \t      gimple *clobber_stmt;"}, {"sha": "ec0e82fe865e41c582cd85ffca82bcc2288e9cde", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f8cb4965cebee125f96376367f05e18ee5749b/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=93f8cb4965cebee125f96376367f05e18ee5749b", "patch": "@@ -150,9 +150,9 @@ struct copy_body_data\n   vec<gdebug *> debug_stmts;\n \n   /* A map from local declarations in the inlined function to\n-     equivalents in the function into which it is being inlined, where\n-     the originals have been mapped to a value rather than to a\n-     variable.  */\n+     equivalents in the function into which it is being inlined,\n+     where the originals have been mapped to a value rather than\n+     to a variable.  */\n   hash_map<tree, tree> *debug_map;\n \n   /* A map from the inlined functions dependence info cliques to"}]}