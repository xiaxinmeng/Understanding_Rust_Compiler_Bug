{"sha": "b6e7e9af0465df9134110217990127a47bc5f5c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZlN2U5YWYwNDY1ZGY5MTM0MTEwMjE3OTkwMTI3YTQ3YmM1ZjVjNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-06-07T14:30:25Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-06-07T14:30:25Z"}, "message": "sbitmap.h (sbitmap_iterator, [...]): New.\n\n\t* sbitmap.h (sbitmap_iterator, sbitmap_iter_init,\n\tsbitmap_iter_cond, sbitmap_iter_next): New.\n\t* bt-load.c, cfganal.c, combine.c, ddg.c, flow.c,\n\tmodulo-sched.c, sbitmap.c, sched-rgn.c, tree-into-ssa.c,\n\ttree-outof-ssa.c, tree-ssa-alias.c, tree-ssa-live.c: Update\n\tuses of EXECUTE_IF_SET_IN_SBITMAP to the new style.\n\nFrom-SVN: r100709", "tree": {"sha": "562f4507f40d0b9cd1ffaff1ad4960266f21f391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/562f4507f40d0b9cd1ffaff1ad4960266f21f391"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6e7e9af0465df9134110217990127a47bc5f5c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e7e9af0465df9134110217990127a47bc5f5c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e7e9af0465df9134110217990127a47bc5f5c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e7e9af0465df9134110217990127a47bc5f5c5/comments", "author": null, "committer": null, "parents": [{"sha": "ac1826887e12c3e8ea95414455f882838a518d11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1826887e12c3e8ea95414455f882838a518d11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1826887e12c3e8ea95414455f882838a518d11"}], "stats": {"total": 344, "additions": 225, "deletions": 119}, "files": [{"sha": "9e99ca669b70de563f3f1f99b3f4b31815e26728", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -1,3 +1,12 @@\n+2005-06-07  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* sbitmap.h (sbitmap_iterator, sbitmap_iter_init,\n+\tsbitmap_iter_cond, sbitmap_iter_next): New.\n+\t* bt-load.c, cfganal.c, combine.c, ddg.c, flow.c,\n+\tmodulo-sched.c, sbitmap.c, sched-rgn.c, tree-into-ssa.c,\n+\ttree-outof-ssa.c, tree-ssa-alias.c, tree-ssa-live.c: Update\n+\tuses of EXECUTE_IF_SET_IN_SBITMAP to the new style.\n+\n 2005-06-07  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-ssa-address.c: New file."}, {"sha": "d58dab7a1f008e36e3a0a174cdb84eb752a450a1", "filename": "gcc/bt-load.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -699,7 +699,8 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t{\n \t\t  /* Find all the reaching defs for this use.  */\n \t\t  sbitmap reaching_defs_of_reg = sbitmap_alloc(max_uid);\n-\t\t  int uid;\n+\t\t  unsigned int uid;\n+\t\t  sbitmap_iterator sbi;\n \n \t\t  if (user->use)\n \t\t    sbitmap_a_and_b (\n@@ -720,7 +721,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t\t    reaching_defs,\n \t\t\t    btr_defset[reg - first_btr]);\n \t\t    }\n-\t\t  EXECUTE_IF_SET_IN_SBITMAP (reaching_defs_of_reg, 0, uid,\n+\t\t  EXECUTE_IF_SET_IN_SBITMAP (reaching_defs_of_reg, 0, uid, sbi)\n \t\t    {\n \t\t      btr_def def = def_array[uid];\n \n@@ -752,7 +753,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t\tdef->other_btr_uses_after_use = 1;\n \t\t      user->next = def->uses;\n \t\t      def->uses = user;\n-\t\t    });\n+\t\t    }\n \t\t  sbitmap_free (reaching_defs_of_reg);\n \t\t}\n "}, {"sha": "0db040fe8ec643915c391fcadc32919ac055625f", "filename": "gcc/cfganal.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -521,13 +521,15 @@ find_edge_index (struct edge_list *edge_list, basic_block pred, basic_block succ\n void\n flow_nodes_print (const char *str, const sbitmap nodes, FILE *file)\n {\n-  int node;\n+  unsigned int node;\n+  sbitmap_iterator sbi;\n \n   if (! nodes)\n     return;\n \n   fprintf (file, \"%s { \", str);\n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {fprintf (file, \"%d \", node);});\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, sbi)\n+    fprintf (file, \"%d \", node);\n   fputs (\"}\\n\", file);\n }\n "}, {"sha": "2f0b787ee5759be3c93d4d6c09d26ab4b4133339", "filename": "gcc/combine.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -639,7 +639,9 @@ combine_instructions (rtx f, unsigned int nregs)\n   rtx prev;\n #endif\n   int i;\n+  unsigned int j;\n   rtx links, nextlinks;\n+  sbitmap_iterator sbi;\n \n   int new_direct_jump_p = 0;\n \n@@ -884,8 +886,8 @@ combine_instructions (rtx f, unsigned int nregs)\n     }\n   clear_bb_flags ();\n \n-  EXECUTE_IF_SET_IN_SBITMAP (refresh_blocks, 0, i,\n-\t\t\t     BASIC_BLOCK (i)->flags |= BB_DIRTY);\n+  EXECUTE_IF_SET_IN_SBITMAP (refresh_blocks, 0, j, sbi)\n+    BASIC_BLOCK (j)->flags |= BB_DIRTY;\n   new_direct_jump_p |= purge_all_dead_edges ();\n   delete_noop_moves ();\n "}, {"sha": "5d32b89c1439af7a0d8347237579d0bc6e64f9ee", "filename": "gcc/ddg.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -692,7 +692,8 @@ static ddg_scc_ptr\n create_scc (ddg_ptr g, sbitmap nodes)\n {\n   ddg_scc_ptr scc;\n-  int u;\n+  unsigned int u;\n+  sbitmap_iterator sbi;\n \n   scc = (ddg_scc_ptr) xmalloc (sizeof (struct ddg_scc));\n   scc->backarcs = NULL;\n@@ -701,7 +702,7 @@ create_scc (ddg_ptr g, sbitmap nodes)\n   sbitmap_copy (scc->nodes, nodes);\n \n   /* Mark the backarcs that belong to this SCC.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u,\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u, sbi)\n     {\n       ddg_edge_ptr e;\n       ddg_node_ptr n = &g->nodes[u];\n@@ -713,7 +714,7 @@ create_scc (ddg_ptr g, sbitmap nodes)\n \t    if (e->distance > 0)\n \t      add_backarc_to_scc (scc, e);\n \t  }\n-    });\n+    }\n \n   set_recurrence_length (scc, g);\n   return scc;\n@@ -782,13 +783,14 @@ get_node_of_insn (ddg_ptr g, rtx insn)\n void\n find_successors (sbitmap succ, ddg_ptr g, sbitmap ops)\n {\n-  int i;\n+  unsigned int i;\n+  sbitmap_iterator sbi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (ops, 0, i,\n+  EXECUTE_IF_SET_IN_SBITMAP (ops, 0, i, sbi)\n     {\n       const sbitmap node_succ = NODE_SUCCESSORS (&g->nodes[i]);\n       sbitmap_a_or_b (succ, succ, node_succ);\n-    });\n+    };\n \n   /* We want those that are not in ops.  */\n   sbitmap_difference (succ, succ, ops);\n@@ -800,13 +802,14 @@ find_successors (sbitmap succ, ddg_ptr g, sbitmap ops)\n void\n find_predecessors (sbitmap preds, ddg_ptr g, sbitmap ops)\n {\n-  int i;\n+  unsigned int i;\n+  sbitmap_iterator sbi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (ops, 0, i,\n+  EXECUTE_IF_SET_IN_SBITMAP (ops, 0, i, sbi)\n     {\n       const sbitmap node_preds = NODE_PREDECESSORS (&g->nodes[i]);\n       sbitmap_a_or_b (preds, preds, node_preds);\n-    });\n+    };\n \n   /* We want those that are not in ops.  */\n   sbitmap_difference (preds, preds, ops);\n@@ -901,8 +904,11 @@ int\n find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n {\n   int answer;\n-  int change, u;\n+  int change;\n+  unsigned int u;\n   int num_nodes = g->num_nodes;\n+  sbitmap_iterator sbi;\n+\n   sbitmap workset = sbitmap_alloc (num_nodes);\n   sbitmap reachable_from = sbitmap_alloc (num_nodes);\n   sbitmap reach_to = sbitmap_alloc (num_nodes);\n@@ -917,7 +923,7 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n       change = 0;\n       sbitmap_copy (workset, tmp);\n       sbitmap_zero (tmp);\n-      EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u,\n+      EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u, sbi)\n \t{\n \t  ddg_edge_ptr e;\n \t  ddg_node_ptr u_node = &g->nodes[u];\n@@ -934,7 +940,7 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n \t\t  change = 1;\n \t\t}\n \t    }\n-\t});\n+\t}\n     }\n \n   sbitmap_copy (reach_to, to);\n@@ -946,7 +952,7 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n       change = 0;\n       sbitmap_copy (workset, tmp);\n       sbitmap_zero (tmp);\n-      EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u,\n+      EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u, sbi)\n \t{\n \t  ddg_edge_ptr e;\n \t  ddg_node_ptr u_node = &g->nodes[u];\n@@ -963,7 +969,7 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n \t\t  change = 1;\n \t\t}\n \t    }\n-\t});\n+\t}\n     }\n \n   answer = sbitmap_a_and_b_cg (result, reachable_from, reach_to);\n@@ -1008,7 +1014,8 @@ update_dist_to_successors (ddg_node_ptr u_node, sbitmap nodes, sbitmap tmp)\n int\n longest_simple_path (struct ddg * g, int src, int dest, sbitmap nodes)\n {\n-  int i, u;\n+  int i;\n+  unsigned int u;\n   int change = 1;\n   int result;\n   int num_nodes = g->num_nodes;\n@@ -1027,15 +1034,17 @@ longest_simple_path (struct ddg * g, int src, int dest, sbitmap nodes)\n \n   while (change)\n     {\n+      sbitmap_iterator sbi;\n+\n       change = 0;\n       sbitmap_copy (workset, tmp);\n       sbitmap_zero (tmp);\n-      EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u,\n+      EXECUTE_IF_SET_IN_SBITMAP (workset, 0, u, sbi)\n \t{\n \t  ddg_node_ptr u_node = &g->nodes[u];\n \n \t  change |= update_dist_to_successors (u_node, nodes, tmp);\n-\t});\n+\t}\n     }\n   result = g->nodes[dest].aux.count;\n   sbitmap_free (workset);"}, {"sha": "b73ac4d09bcbf887f4f0221902c0f9637fc852b7", "filename": "gcc/flow.c", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -653,7 +653,9 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \n   if (blocks)\n     {\n-      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n+      sbitmap_iterator sbi;\n+\n+      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i, sbi)\n \t{\n \t  bb = BASIC_BLOCK (i);\n \n@@ -662,7 +664,7 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \n \t  if (extent == UPDATE_LIFE_LOCAL)\n \t    verify_local_live_at_start (tmp, bb);\n-\t});\n+\t};\n     }\n   else\n     {\n@@ -1032,7 +1034,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n      In other words, regs that are set only as part of a COND_EXEC.  */\n   regset *cond_local_sets;\n \n-  int i;\n+  unsigned int i;\n \n   /* Some passes used to forget clear aux field of basic block causing\n      sick behavior here.  */\n@@ -1406,12 +1408,14 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \n   if (blocks_out)\n     {\n-      EXECUTE_IF_SET_IN_SBITMAP (blocks_out, 0, i,\n+      sbitmap_iterator sbi;\n+\n+      EXECUTE_IF_SET_IN_SBITMAP (blocks_out, 0, i, sbi)\n \t{\n \t  basic_block bb = BASIC_BLOCK (i);\n \t  FREE_REG_SET (local_sets[bb->index - (INVALID_BLOCK + 1)]);\n \t  FREE_REG_SET (cond_local_sets[bb->index - (INVALID_BLOCK + 1)]);\n-\t});\n+\t};\n     }\n   else\n     {\n@@ -4355,7 +4359,7 @@ int\n count_or_remove_death_notes (sbitmap blocks, int kill)\n {\n   int count = 0;\n-  int i;\n+  unsigned int i;\n   basic_block bb;\n \n   /* This used to be a loop over all the blocks with a membership test\n@@ -4367,10 +4371,12 @@ count_or_remove_death_notes (sbitmap blocks, int kill)\n      than an sbitmap.  */\n   if (blocks)\n     {\n-      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n+      sbitmap_iterator sbi;\n+\n+      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i, sbi)\n \t{\n \t  count += count_or_remove_death_notes_bb (BASIC_BLOCK (i), kill);\n-\t});\n+\t};\n     }\n   else\n     {\n@@ -4450,7 +4456,6 @@ static void\n clear_log_links (sbitmap blocks)\n {\n   rtx insn;\n-  int i;\n \n   if (!blocks)\n     {\n@@ -4459,15 +4464,20 @@ clear_log_links (sbitmap blocks)\n \t  free_INSN_LIST_list (&LOG_LINKS (insn));\n     }\n   else\n-    EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i,\n-      {\n-\tbasic_block bb = BASIC_BLOCK (i);\n+    {\n+      unsigned int i;\n+      sbitmap_iterator sbi;\n \n-\tfor (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n-\t     insn = NEXT_INSN (insn))\n-\t  if (INSN_P (insn))\n-\t    free_INSN_LIST_list (&LOG_LINKS (insn));\n-      });\n+      EXECUTE_IF_SET_IN_SBITMAP (blocks, 0, i, sbi)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\n+\t  for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n+\t       insn = NEXT_INSN (insn))\n+\t    if (INSN_P (insn))\n+\t      free_INSN_LIST_list (&LOG_LINKS (insn));\n+\t}\n+    }\n }\n \n /* Given a register bitmap, turn on the bits in a HARD_REG_SET that"}, {"sha": "39549b93cb0090a309944ac629ff163d4f5ad40a", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -499,17 +499,18 @@ generate_reg_moves (partial_schedule_ptr ps)\n \n       for (i_reg_move = 0; i_reg_move < nreg_moves; i_reg_move++)\n \t{\n-\t  int i_use;\n+\t  unsigned int i_use;\n \t  rtx new_reg = gen_reg_rtx (GET_MODE (prev_reg));\n \t  rtx reg_move = gen_move_insn (new_reg, prev_reg);\n+\t  sbitmap_iterator sbi;\n \n \t  add_insn_before (reg_move, last_reg_move);\n \t  last_reg_move = reg_move;\n \n \t  if (!SCHED_FIRST_REG_MOVE (u))\n \t    SCHED_FIRST_REG_MOVE (u) = reg_move;\n \n-\t  EXECUTE_IF_SET_IN_SBITMAP (uses_of_defs[i_reg_move], 0, i_use,\n+\t  EXECUTE_IF_SET_IN_SBITMAP (uses_of_defs[i_reg_move], 0, i_use, sbi)\n \t    {\n \t      struct undo_replace_buff_elem *rep;\n \n@@ -528,7 +529,7 @@ generate_reg_moves (partial_schedule_ptr ps)\n \t\t}\n \n \t      replace_rtx (g->nodes[i_use].insn, old_reg, new_reg);\n-\t    });\n+\t    }\n \n \t  prev_reg = new_reg;\n \t}\n@@ -1842,11 +1843,12 @@ calculate_order_params (ddg_ptr g, int mii ATTRIBUTE_UNUSED)\n static int\n find_max_asap (ddg_ptr g, sbitmap nodes)\n {\n-  int u;\n+  unsigned int u;\n   int max_asap = -1;\n   int result = -1;\n+  sbitmap_iterator sbi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u,\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u, sbi)\n     {\n       ddg_node_ptr u_node = &g->nodes[u];\n \n@@ -1855,19 +1857,20 @@ find_max_asap (ddg_ptr g, sbitmap nodes)\n \t  max_asap = ASAP (u_node);\n \t  result = u;\n \t}\n-    });\n+    }\n   return result;\n }\n \n static int\n find_max_hv_min_mob (ddg_ptr g, sbitmap nodes)\n {\n-  int u;\n+  unsigned int u;\n   int max_hv = -1;\n   int min_mob = INT_MAX;\n   int result = -1;\n+  sbitmap_iterator sbi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u,\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u, sbi)\n     {\n       ddg_node_ptr u_node = &g->nodes[u];\n \n@@ -1883,19 +1886,20 @@ find_max_hv_min_mob (ddg_ptr g, sbitmap nodes)\n \t  min_mob = MOB (u_node);\n \t  result = u;\n \t}\n-    });\n+    }\n   return result;\n }\n \n static int\n find_max_dv_min_mob (ddg_ptr g, sbitmap nodes)\n {\n-  int u;\n+  unsigned int u;\n   int max_dv = -1;\n   int min_mob = INT_MAX;\n   int result = -1;\n+  sbitmap_iterator sbi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u,\n+  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, u, sbi)\n     {\n       ddg_node_ptr u_node = &g->nodes[u];\n \n@@ -1911,7 +1915,7 @@ find_max_dv_min_mob (ddg_ptr g, sbitmap nodes)\n \t  min_mob = MOB (u_node);\n \t  result = u;\n \t}\n-    });\n+    }\n   return result;\n }\n "}, {"sha": "cbc5775dbb631c04c464f9dc194d4f439544918a", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -691,8 +691,10 @@ int\n sbitmap_first_set_bit (sbitmap bmap)\n {\n   unsigned int n;\n+  sbitmap_iterator sbi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (bmap, 0, n, { return n; });\n+  EXECUTE_IF_SET_IN_SBITMAP (bmap, 0, n, sbi)\n+    return n;\n   return -1;\n }\n "}, {"sha": "fe23cbf91fae20b6639ad1cd7f8542f4ba9f691e", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 80, "deletions": 30, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -55,36 +55,86 @@ typedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n   ((BITMAP)->elms [(BITNO) / SBITMAP_ELT_BITS]\t\t\t\\\n    &= ~((SBITMAP_ELT_TYPE) 1 << (BITNO) % SBITMAP_ELT_BITS))\n \n-/* Loop over all elements of SBITSET, starting with MIN.  */\n-#define EXECUTE_IF_SET_IN_SBITMAP(SBITMAP, MIN, N, CODE)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  unsigned int word_num_ = (MIN) / (unsigned int) SBITMAP_ELT_BITS;\t\\\n-  unsigned int bit_num_ = (MIN) % (unsigned int) SBITMAP_ELT_BITS;\t\\\n-  unsigned int size_ = (SBITMAP)->size;\t\t\t\t\t\\\n-  SBITMAP_ELT_TYPE *ptr_ = (SBITMAP)->elms;\t\t\t\t\\\n-  SBITMAP_ELT_TYPE word_;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (word_num_ < size_)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      word_ = ptr_[word_num_] >> bit_num_;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      while (1)\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  for (; word_ != 0; word_ >>= 1, bit_num_++)\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if ((word_ & 1) != 0)\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  (N) = word_num_ * SBITMAP_ELT_BITS + bit_num_;\t\\\n-\t\t  CODE;\t\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  word_num_++;\t\t\t\t\t\t\t\\\n-\t  if (word_num_ >= size_)\t\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n-\t  bit_num_ = 0, word_ = ptr_[word_num_];\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+/* The iterator for sbitmap.  */\n+typedef struct {\n+  /* The pointer to the first word of the bitmap.  */\n+  SBITMAP_ELT_TYPE *ptr;\n+\n+  /* The size of the bitmap.  */\n+  unsigned int size;\n+\n+  /* The current word index.  */\n+  unsigned int word_num;\n+\n+  /* The current bit index.  */\n+  unsigned int bit_num;\n+\n+  /* The words currently visited.  */\n+  SBITMAP_ELT_TYPE word;\n+} sbitmap_iterator;\n+\n+/* Initialize the iterator I with sbitmap BMP and the initial index\n+   MIN.  */\n+\n+static inline void\n+sbitmap_iter_init (sbitmap_iterator *i, sbitmap bmp, unsigned int min)\n+{\n+  i->word_num = min / (unsigned int) SBITMAP_ELT_BITS;\n+  i->bit_num = min % (unsigned int) SBITMAP_ELT_BITS;\n+  i->size = bmp->size;\n+  i->ptr = bmp->elms;\n+\n+  if (i->word_num >= i->size)\n+    i->word = 0;\n+  else\n+    i->word = i->ptr[i->word_num] >> i->bit_num;\n+}\n+\n+/* Return true if we have more bits to visit, in which case *N is set\n+   to the index of the bit to be visited.  Otherwise, return\n+   false.  */\n+\n+static inline bool\n+sbitmap_iter_cond (sbitmap_iterator *i, unsigned int *n)\n+{\n+  /* Skip words that are zeros.  */\n+  for (; i->word == 0; i->word = i->ptr[i->word_num])\n+    {\n+      i->word_num++;\n+\n+      /* If we have reached the end, break.  */\n+      if (i->word_num >= i->size)\n+\treturn false;\n+\n+      i->bit_num = i->word_num * SBITMAP_ELT_BITS;\n+    }\n+\n+  /* Skip bits that are zero.  */\n+  for (; (i->word & 1) == 0; i->word >>= 1)\n+    i->bit_num++;\n+\n+  *n = i->bit_num;\n+\n+  return true;\n+}\n+\n+/* Advance to the next bit.  */\n+\n+static inline void\n+sbitmap_iter_next (sbitmap_iterator *i)\n+{\n+  i->word >>= 1;\n+  i->bit_num++;\n+}\n+\n+/* Loop over all elements of SBITMAP, starting with MIN.  In each\n+   iteration, N is set to the index of the bit being visited.  ITER is\n+   an instance of sbitmap_iterator used to iterate the bitmap.  */\n+\n+#define EXECUTE_IF_SET_IN_SBITMAP(SBITMAP, MIN, N, ITER)\t\\\n+  for (sbitmap_iter_init (&(ITER), (SBITMAP), (MIN));\t\t\\\n+       sbitmap_iter_cond (&(ITER), &(N));\t\t\t\\\n+       sbitmap_iter_next (&(ITER)))\n \n #define EXECUTE_IF_SET_IN_SBITMAP_REV(SBITMAP, N, CODE)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "4196e6d7e93929509bff38b627c745310419a022", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -351,7 +351,8 @@ is_cfg_nonregular (void)\n static void\n extract_edgelst (sbitmap set, edgelst *el)\n {\n-  int i;\n+  unsigned int i;\n+  sbitmap_iterator sbi;\n \n   /* edgelst table space is reused in each call to extract_edgelst.  */\n   edgelst_last = 0;\n@@ -360,11 +361,11 @@ extract_edgelst (sbitmap set, edgelst *el)\n   el->nr_members = 0;\n \n   /* Iterate over each word in the bitset.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (set, 0, i,\n-  {\n-    edgelst_table[edgelst_last++] = rgn_edges[i];\n-    el->nr_members++;\n-  });\n+  EXECUTE_IF_SET_IN_SBITMAP (set, 0, i, sbi)\n+    {\n+      edgelst_table[edgelst_last++] = rgn_edges[i];\n+      el->nr_members++;\n+    }\n }\n \n /* Functions for the construction of regions.  */"}, {"sha": "1daea76b02c7e5862ba775dee19e95b10fc6a180", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -2033,6 +2033,7 @@ prepare_names_to_update (bitmap blocks, bool insert_phi_p)\n {\n   unsigned i;\n   bitmap_iterator bi;\n+  sbitmap_iterator sbi;\n \n   /* If a name N from NEW_SSA_NAMES is also marked to be released,\n      remove it from NEW_SSA_NAMES so that we don't try to visit its\n@@ -2046,17 +2047,17 @@ prepare_names_to_update (bitmap blocks, bool insert_phi_p)\n   /* First process names in NEW_SSA_NAMES.  Otherwise, uses of old\n      names may be considered to be live-in on blocks that contain\n      definitions for their replacements.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n-    prepare_def_site_for (ssa_name (i), blocks, insert_phi_p));\n+  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i, sbi)\n+    prepare_def_site_for (ssa_name (i), blocks, insert_phi_p);\n \n   /* If an old name is in NAMES_TO_RELEASE, we cannot remove it from\n      OLD_SSA_NAMES, but we have to ignore its definition site.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i, sbi)\n     {\n       if (names_to_release == NULL || !bitmap_bit_p (names_to_release, i))\n \tprepare_def_site_for (ssa_name (i), blocks, insert_phi_p);\n       prepare_use_sites_for (ssa_name (i), blocks, insert_phi_p);\n-    });\n+    }\n }\n \n \n@@ -2105,12 +2106,14 @@ dump_update_ssa (FILE *file)\n \n   if (new_ssa_names && sbitmap_first_set_bit (new_ssa_names) >= 0)\n     {\n+      sbitmap_iterator sbi;\n+\n       fprintf (file, \"\\nSSA replacement table\\n\");\n       fprintf (file, \"N_i -> { O_1 ... O_j } means that N_i replaces \"\n \t             \"O_1, ..., O_j\\n\\n\");\n \n-      EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n-\tdump_names_replaced_by (file, ssa_name (i)));\n+      EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i, sbi)\n+\tdump_names_replaced_by (file, ssa_name (i));\n \n       fprintf (file, \"\\n\");\n       fprintf (file, \"Number of virtual NEW -> OLD mappings: %7u\\n\",\n@@ -2346,10 +2349,11 @@ ssa_names_to_replace (void)\n {\n   unsigned i;\n   bitmap ret;\n+  sbitmap_iterator sbi;\n   \n   ret = BITMAP_ALLOC (NULL);\n-  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n-    bitmap_set_bit (ret, i));\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i, sbi)\n+    bitmap_set_bit (ret, i);\n \n   return ret;\n }\n@@ -2516,6 +2520,7 @@ static void\n switch_virtuals_to_full_rewrite (void)\n {\n   unsigned i;\n+  sbitmap_iterator sbi;\n \n   if (dump_file)\n     {\n@@ -2531,13 +2536,13 @@ switch_virtuals_to_full_rewrite (void)\n   /* Remove all virtual names from NEW_SSA_NAMES and OLD_SSA_NAMES.\n      Note that it is not really necessary to remove the mappings from\n      REPL_TBL, that would only waste time.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i,\n+  EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i, sbi)\n     if (!is_gimple_reg (ssa_name (i)))\n-      RESET_BIT (new_ssa_names, i));\n+      RESET_BIT (new_ssa_names, i);\n \n-  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i, sbi)\n     if (!is_gimple_reg (ssa_name (i)))\n-      RESET_BIT (old_ssa_names, i));\n+      RESET_BIT (old_ssa_names, i);\n \n   bitmap_ior_into (syms_to_rename, update_ssa_stats.virtual_symbols);\n }\n@@ -2616,6 +2621,7 @@ update_ssa (unsigned update_flags)\n   unsigned i;\n   sbitmap tmp;\n   bool insert_phi_p;\n+  sbitmap_iterator sbi;\n \n   if (!need_ssa_update_p ())\n     return;\n@@ -2746,16 +2752,18 @@ update_ssa (unsigned update_flags)\n \n       if (sbitmap_first_set_bit (old_ssa_names) >= 0)\n \t{\n+\t  sbitmap_iterator sbi;\n+\n \t  /* insert_update_phi_nodes_for will call add_new_name_mapping\n \t     when inserting new PHI nodes, so the set OLD_SSA_NAMES\n \t     will grow while we are traversing it (but it will not\n \t     gain any new members).  Copy OLD_SSA_NAMES to a temporary\n \t     for traversal.  */\n \t  sbitmap tmp = sbitmap_alloc (old_ssa_names->n_bits);\n \t  sbitmap_copy (tmp, old_ssa_names);\n-\t  EXECUTE_IF_SET_IN_SBITMAP (tmp, 0, i,\n+\t  EXECUTE_IF_SET_IN_SBITMAP (tmp, 0, i, sbi)\n \t    insert_updated_phi_nodes_for (ssa_name (i), dfs, blocks,\n-\t                                  update_flags));\n+\t                                  update_flags);\n \t  sbitmap_free (tmp);\n \t}\n \n@@ -2776,8 +2784,8 @@ update_ssa (unsigned update_flags)\n \n   /* Reset the current definition for name and symbol before renaming\n      the sub-graph.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i,\n-      set_current_def (ssa_name (i), NULL_TREE));\n+  EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i, sbi)\n+    set_current_def (ssa_name (i), NULL_TREE);\n \n   EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n     set_current_def (referenced_var (i), NULL_TREE);"}, {"sha": "a7b4f3f26a76bf567da3958c6220bea445c6c162", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -695,6 +695,7 @@ coalesce_ssa_name (var_map map, int flags)\n   conflict_graph graph;\n   basic_block bb;\n   coalesce_list_p cl = NULL;\n+  sbitmap_iterator sbi;\n \n   if (num_var_partitions (map) <= 1)\n     return NULL;\n@@ -797,7 +798,7 @@ coalesce_ssa_name (var_map map, int flags)\n \n   /* Assign root variable as partition representative for each live on entry\n      partition.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (live, 0, x, \n+  EXECUTE_IF_SET_IN_SBITMAP (live, 0, x, sbi)\n     {\n       var = root_var (rv, root_var_find (rv, x));\n       ann = var_ann (var);\n@@ -817,7 +818,7 @@ coalesce_ssa_name (var_map map, int flags)\n \n \t  change_partition_var (map, var, x);\n \t}\n-    });\n+    }\n \n   sbitmap_free (live);\n "}, {"sha": "ab23cd0bab8aef216416ca06eff299dbe3c9b2db", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -1073,12 +1073,13 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \n \t  if (sbitmap_first_set_bit (may_aliases2) >= 0)\n \t    {\n-\t      size_t k;\n+\t      unsigned int k;\n+\t      sbitmap_iterator sbi;\n \n \t      /* Add all the aliases for TAG2 into TAG1's alias set.\n \t\t FIXME, update grouping heuristic counters.  */\n-\t      EXECUTE_IF_SET_IN_SBITMAP (may_aliases2, 0, k,\n-\t\t  add_may_alias (tag1, referenced_var (k)));\n+\t      EXECUTE_IF_SET_IN_SBITMAP (may_aliases2, 0, k, sbi)\n+\t\tadd_may_alias (tag1, referenced_var (k));\n \t      sbitmap_a_or_b (may_aliases1, may_aliases1, may_aliases2);\n \t    }\n \t  else\n@@ -1133,11 +1134,12 @@ total_alias_vops_cmp (const void *p, const void *q)\n static void\n group_aliases_into (tree tag, sbitmap tag_aliases, struct alias_info *ai)\n {\n-  size_t i;\n+  unsigned int i;\n   var_ann_t tag_ann = var_ann (tag);\n   size_t num_tag_refs = VARRAY_UINT (ai->num_references, tag_ann->uid);\n+  sbitmap_iterator sbi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (tag_aliases, 0, i,\n+  EXECUTE_IF_SET_IN_SBITMAP (tag_aliases, 0, i, sbi)\n     {\n       tree var = referenced_var (i);\n       var_ann_t ann = var_ann (var);\n@@ -1157,7 +1159,7 @@ group_aliases_into (tree tag, sbitmap tag_aliases, struct alias_info *ai)\n \t itself won't be removed.  We will merely replace them with\n \t references to TAG.  */\n       ai->total_alias_vops -= num_tag_refs;\n-    });\n+    }\n \n   /* We have reduced the number of virtual operands that TAG makes on\n      behalf of all the variables formerly aliased with it.  However,"}, {"sha": "8f7bf77cda05e72bc84fcdd90ccb55138813dcc8", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e7e9af0465df9134110217990127a47bc5f5c5/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=b6e7e9af0465df9134110217990127a47bc5f5c5", "patch": "@@ -185,7 +185,8 @@ void\n compact_var_map (var_map map, int flags)\n {\n   sbitmap used;\n-  int x, limit, count, tmp, root, root_i;\n+  int tmp, root, root_i;\n+  unsigned int x, limit, count;\n   tree var;\n   root_var_p rv = NULL;\n \n@@ -238,18 +239,20 @@ compact_var_map (var_map map, int flags)\n   /* Build a compacted partitioning.  */\n   if (count != limit)\n     {\n+      sbitmap_iterator sbi;\n+\n       map->compact_to_partition = (int *)xmalloc (count * sizeof (int));\n       count = 0;\n       /* SSA renaming begins at 1, so skip 0 when compacting.  */\n-      EXECUTE_IF_SET_IN_SBITMAP (used, 1, x,\n+      EXECUTE_IF_SET_IN_SBITMAP (used, 1, x, sbi)\n \t{\n \t  map->partition_to_compact[x] = count;\n \t  map->compact_to_partition[count] = x;\n \t  var = map->partition_to_var[x];\n \t  if (TREE_CODE (var) != SSA_NAME)\n \t    change_partition_var (map, var, count);\n \t  count++;\n-\t});\n+\t}\n     }\n   else\n     {\n@@ -408,9 +411,11 @@ create_ssa_var_map (int flags)\n     sbitmap_a_and_b (both, used_in_real_ops, used_in_virtual_ops);\n     if (sbitmap_first_set_bit (both) >= 0)\n       {\n-\tEXECUTE_IF_SET_IN_SBITMAP (both, 0, i,\n+\tsbitmap_iterator sbi;\n+\n+\tEXECUTE_IF_SET_IN_SBITMAP (both, 0, i, sbi)\n \t  fprintf (stderr, \"Variable %s used in real and virtual operands\\n\",\n-\t\t   get_name (referenced_var (i))));\n+\t\t   get_name (referenced_var (i)));\n \tinternal_error (\"SSA corruption\");\n       }\n "}]}