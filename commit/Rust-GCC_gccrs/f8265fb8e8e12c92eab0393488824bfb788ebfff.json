{"sha": "f8265fb8e8e12c92eab0393488824bfb788ebfff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyNjVmYjhlOGUxMmM5MmVhYjAzOTM0ODg4MjRiZmI3ODhlYmZmZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:17:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:17:01Z"}, "message": "[48/77] Make subroutines of num_sign_bit_copies operate on scalar_int_mode\n\nSimilarly to the nonzero_bits patch, this one moves the mode\nclass check and VOIDmode handling from num_sign_bit_copies1\nto num_sign_bit_copies itself, then changes the subroutines\nto operate on scalar_int_modes.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtlanal.c (num_sign_bit_copies): Handle VOIDmode here rather\n\tthan in subroutines.  Return 1 for non-integer modes.\n\t(cached_num_sign_bit_copies): Change the type of the mode parameter\n\tto scalar_int_mode.\n\t(num_sign_bit_copies1): Likewise.  Remove early exit for other mode\n\tclasses.  Handle CONST_INT_P first and then check whether X also\n\thas a scalar integer mode.  Check the same thing for inner registers\n\tof a SUBREG and for values that are being extended or truncated.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251500", "tree": {"sha": "683737625050797f802f8d3dd4a2d0a2a64f7705", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/683737625050797f802f8d3dd4a2d0a2a64f7705"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8265fb8e8e12c92eab0393488824bfb788ebfff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8265fb8e8e12c92eab0393488824bfb788ebfff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8265fb8e8e12c92eab0393488824bfb788ebfff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8265fb8e8e12c92eab0393488824bfb788ebfff/comments", "author": null, "committer": null, "parents": [{"sha": "22527b59dbb10204626aeb8660a8e262377ac354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22527b59dbb10204626aeb8660a8e262377ac354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22527b59dbb10204626aeb8660a8e262377ac354"}], "stats": {"total": 168, "additions": 91, "deletions": 77}, "files": [{"sha": "ca176fc5e393c1c4afe44d8f29a9b8663d09158a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8265fb8e8e12c92eab0393488824bfb788ebfff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8265fb8e8e12c92eab0393488824bfb788ebfff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8265fb8e8e12c92eab0393488824bfb788ebfff", "patch": "@@ -1,3 +1,16 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtlanal.c (num_sign_bit_copies): Handle VOIDmode here rather\n+\tthan in subroutines.  Return 1 for non-integer modes.\n+\t(cached_num_sign_bit_copies): Change the type of the mode parameter\n+\tto scalar_int_mode.\n+\t(num_sign_bit_copies1): Likewise.  Remove early exit for other mode\n+\tclasses.  Handle CONST_INT_P first and then check whether X also\n+\thas a scalar integer mode.  Check the same thing for inner registers\n+\tof a SUBREG and for values that are being extended or truncated.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "605fd973d0b129d9b991eddb9fc2996fdcd34590", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 78, "deletions": 77, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8265fb8e8e12c92eab0393488824bfb788ebfff/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8265fb8e8e12c92eab0393488824bfb788ebfff/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=f8265fb8e8e12c92eab0393488824bfb788ebfff", "patch": "@@ -49,11 +49,12 @@ static unsigned HOST_WIDE_INT cached_nonzero_bits (const_rtx, scalar_int_mode,\n static unsigned HOST_WIDE_INT nonzero_bits1 (const_rtx, scalar_int_mode,\n \t\t\t\t\t     const_rtx, machine_mode,\n                                              unsigned HOST_WIDE_INT);\n-static unsigned int cached_num_sign_bit_copies (const_rtx, machine_mode, const_rtx,\n-                                                machine_mode,\n+static unsigned int cached_num_sign_bit_copies (const_rtx, scalar_int_mode,\n+\t\t\t\t\t\tconst_rtx, machine_mode,\n                                                 unsigned int);\n-static unsigned int num_sign_bit_copies1 (const_rtx, machine_mode, const_rtx,\n-                                          machine_mode, unsigned int);\n+static unsigned int num_sign_bit_copies1 (const_rtx, scalar_int_mode,\n+\t\t\t\t\t  const_rtx, machine_mode,\n+\t\t\t\t\t  unsigned int);\n \n rtx_subrtx_bound_info rtx_all_subrtx_bounds[NUM_RTX_CODE];\n rtx_subrtx_bound_info rtx_nonconst_subrtx_bounds[NUM_RTX_CODE];\n@@ -4248,7 +4249,12 @@ nonzero_bits (const_rtx x, machine_mode mode)\n unsigned int\n num_sign_bit_copies (const_rtx x, machine_mode mode)\n {\n-  return cached_num_sign_bit_copies (x, mode, NULL_RTX, VOIDmode, 0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (x);\n+  scalar_int_mode int_mode;\n+  if (!is_a <scalar_int_mode> (mode, &int_mode))\n+    return 1;\n+  return cached_num_sign_bit_copies (x, int_mode, NULL_RTX, VOIDmode, 0);\n }\n \n /* Return true if nonzero_bits1 might recurse into both operands\n@@ -4815,8 +4821,8 @@ num_sign_bit_copies_binary_arith_p (const_rtx x)\n    first or the second level.  */\n \n static unsigned int\n-cached_num_sign_bit_copies (const_rtx x, machine_mode mode, const_rtx known_x,\n-\t\t\t    machine_mode known_mode,\n+cached_num_sign_bit_copies (const_rtx x, scalar_int_mode mode,\n+\t\t\t    const_rtx known_x, machine_mode known_mode,\n \t\t\t    unsigned int known_ret)\n {\n   if (x == known_x && mode == known_mode)\n@@ -4861,44 +4867,46 @@ cached_num_sign_bit_copies (const_rtx x, machine_mode mode, const_rtx known_x,\n }\n \n /* Return the number of bits at the high-order end of X that are known to\n-   be equal to the sign bit.  X will be used in mode MODE; if MODE is\n-   VOIDmode, X will be used in its own mode.  The returned value  will always\n-   be between 1 and the number of bits in MODE.  */\n+   be equal to the sign bit.  X will be used in mode MODE.  The returned\n+   value will always be between 1 and the number of bits in MODE.  */\n \n static unsigned int\n-num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n+num_sign_bit_copies1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t\t      machine_mode known_mode,\n \t\t      unsigned int known_ret)\n {\n   enum rtx_code code = GET_CODE (x);\n-  machine_mode inner_mode;\n+  unsigned int bitwidth = GET_MODE_PRECISION (mode);\n   int num0, num1, result;\n   unsigned HOST_WIDE_INT nonzero;\n \n-  /* If we weren't given a mode, use the mode of X.  If the mode is still\n-     VOIDmode, we don't know anything.  Likewise if one of the modes is\n-     floating-point.  */\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n+  if (CONST_INT_P (x))\n+    {\n+      /* If the constant is negative, take its 1's complement and remask.\n+\t Then see how many zero bits we have.  */\n+      nonzero = UINTVAL (x) & GET_MODE_MASK (mode);\n+      if (bitwidth <= HOST_BITS_PER_WIDE_INT\n+\t  && (nonzero & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n+\tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n \n-  gcc_checking_assert (mode != BLKmode);\n+      return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n+    }\n \n-  if (mode == VOIDmode || FLOAT_MODE_P (mode) || FLOAT_MODE_P (GET_MODE (x))\n-      || VECTOR_MODE_P (GET_MODE (x)) || VECTOR_MODE_P (mode))\n+  scalar_int_mode xmode, inner_mode;\n+  if (!is_a <scalar_int_mode> (GET_MODE (x), &xmode))\n     return 1;\n \n+  unsigned int xmode_width = GET_MODE_PRECISION (xmode);\n+\n   /* For a smaller mode, just ignore the high bits.  */\n-  unsigned int bitwidth = GET_MODE_PRECISION (mode);\n-  if (bitwidth < GET_MODE_PRECISION (GET_MODE (x)))\n+  if (bitwidth < xmode_width)\n     {\n-      num0 = cached_num_sign_bit_copies (x, GET_MODE (x),\n+      num0 = cached_num_sign_bit_copies (x, xmode,\n \t\t\t\t\t known_x, known_mode, known_ret);\n-      return MAX (1,\n-\t\t  num0 - (int) (GET_MODE_PRECISION (GET_MODE (x)) - bitwidth));\n+      return MAX (1, num0 - (int) (xmode_width - bitwidth));\n     }\n \n-  if (GET_MODE (x) != VOIDmode && bitwidth > GET_MODE_PRECISION (GET_MODE (x)))\n+  if (bitwidth > xmode_width)\n     {\n       /* If this machine does not do all register operations on the entire\n \t register and MODE is wider than the mode of X, we can say nothing\n@@ -4909,8 +4917,8 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       /* Likewise on machines that do, if the mode of the object is smaller\n \t than a word and loads of that size don't sign extend, we can say\n \t nothing about the high order bits.  */\n-      if (GET_MODE_PRECISION (GET_MODE (x)) < BITS_PER_WORD\n-\t  && load_extend_op (GET_MODE (x)) != SIGN_EXTEND)\n+      if (xmode_width < BITS_PER_WORD\n+\t  && load_extend_op (xmode) != SIGN_EXTEND)\n \treturn 1;\n     }\n \n@@ -4927,7 +4935,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t we can do this only if the target does not support different pointer\n \t or address modes depending on the address space.  */\n       if (target_default_pointer_address_modes_p ()\n-\t  && ! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n+\t  && ! POINTERS_EXTEND_UNSIGNED && xmode == Pmode\n \t  && mode == Pmode && REG_POINTER (x)\n \t  && !targetm.have_ptr_extend ())\n \treturn GET_MODE_PRECISION (Pmode) - GET_MODE_PRECISION (ptr_mode) + 1;\n@@ -4952,21 +4960,10 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \n     case MEM:\n       /* Some RISC machines sign-extend all loads of smaller than a word.  */\n-      if (load_extend_op (GET_MODE (x)) == SIGN_EXTEND)\n-\treturn MAX (1, ((int) bitwidth\n-\t\t\t- (int) GET_MODE_PRECISION (GET_MODE (x)) + 1));\n+      if (load_extend_op (xmode) == SIGN_EXTEND)\n+\treturn MAX (1, ((int) bitwidth - (int) xmode_width + 1));\n       break;\n \n-    case CONST_INT:\n-      /* If the constant is negative, take its 1's complement and remask.\n-\t Then see how many zero bits we have.  */\n-      nonzero = UINTVAL (x) & GET_MODE_MASK (mode);\n-      if (bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero & (HOST_WIDE_INT_1U << (bitwidth - 1))) != 0)\n-\tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n-\n-      return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n-\n     case SUBREG:\n       /* If this is a SUBREG for a promoted object that is sign-extended\n \t and we are looking at it in a wider mode, we know that at least the\n@@ -4976,37 +4973,38 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t{\n \t  num0 = cached_num_sign_bit_copies (SUBREG_REG (x), mode,\n \t\t\t\t\t     known_x, known_mode, known_ret);\n-\t  return MAX ((int) bitwidth\n-\t\t      - (int) GET_MODE_PRECISION (GET_MODE (x)) + 1,\n-\t\t      num0);\n+\t  return MAX ((int) bitwidth - (int) xmode_width + 1, num0);\n \t}\n \n-      /* For a smaller object, just ignore the high bits.  */\n-      inner_mode = GET_MODE (SUBREG_REG (x));\n-      if (bitwidth <= GET_MODE_PRECISION (inner_mode))\n+      if (is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (x)), &inner_mode))\n \t{\n-\t  num0 = cached_num_sign_bit_copies (SUBREG_REG (x), VOIDmode,\n-\t\t\t\t\t     known_x, known_mode, known_ret);\n-\t  return\n-\t    MAX (1, num0 - (int) (GET_MODE_PRECISION (inner_mode) - bitwidth));\n-\t}\n+\t  /* For a smaller object, just ignore the high bits.  */\n+\t  if (bitwidth <= GET_MODE_PRECISION (inner_mode))\n+\t    {\n+\t      num0 = cached_num_sign_bit_copies (SUBREG_REG (x), inner_mode,\n+\t\t\t\t\t\t known_x, known_mode,\n+\t\t\t\t\t\t known_ret);\n+\t      return MAX (1, num0 - (int) (GET_MODE_PRECISION (inner_mode)\n+\t\t\t\t\t   - bitwidth));\n+\t    }\n \n-      /* For paradoxical SUBREGs on machines where all register operations\n-\t affect the entire register, just look inside.  Note that we are\n-\t passing MODE to the recursive call, so the number of sign bit copies\n-\t will remain relative to that mode, not the inner mode.  */\n-\n-      /* This works only if loads sign extend.  Otherwise, if we get a\n-\t reload for the inner part, it may be loaded from the stack, and\n-\t then we lose all sign bit copies that existed before the store\n-\t to the stack.  */\n-\n-      if (WORD_REGISTER_OPERATIONS\n-\t  && load_extend_op (inner_mode) == SIGN_EXTEND\n-\t  && paradoxical_subreg_p (x)\n-\t  && (MEM_P (SUBREG_REG (x)) || REG_P (SUBREG_REG (x))))\n-\treturn cached_num_sign_bit_copies (SUBREG_REG (x), mode,\n-\t\t\t\t\t   known_x, known_mode, known_ret);\n+\t  /* For paradoxical SUBREGs on machines where all register operations\n+\t     affect the entire register, just look inside.  Note that we are\n+\t     passing MODE to the recursive call, so the number of sign bit\n+\t     copies will remain relative to that mode, not the inner mode.  */\n+\n+\t  /* This works only if loads sign extend.  Otherwise, if we get a\n+\t     reload for the inner part, it may be loaded from the stack, and\n+\t     then we lose all sign bit copies that existed before the store\n+\t     to the stack.  */\n+\n+\t  if (WORD_REGISTER_OPERATIONS\n+\t      && load_extend_op (inner_mode) == SIGN_EXTEND\n+\t      && paradoxical_subreg_p (x)\n+\t      && (MEM_P (SUBREG_REG (x)) || REG_P (SUBREG_REG (x))))\n+\t    return cached_num_sign_bit_copies (SUBREG_REG (x), mode,\n+\t\t\t\t\t       known_x, known_mode, known_ret);\n+\t}\n       break;\n \n     case SIGN_EXTRACT:\n@@ -5015,15 +5013,18 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       break;\n \n     case SIGN_EXTEND:\n-      return (bitwidth - GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)))\n-\t      + cached_num_sign_bit_copies (XEXP (x, 0), VOIDmode,\n-\t\t\t\t\t    known_x, known_mode, known_ret));\n+      if (is_a <scalar_int_mode> (GET_MODE (XEXP (x, 0)), &inner_mode))\n+\treturn (bitwidth - GET_MODE_PRECISION (inner_mode)\n+\t\t+ cached_num_sign_bit_copies (XEXP (x, 0), inner_mode,\n+\t\t\t\t\t      known_x, known_mode, known_ret));\n+      break;\n \n     case TRUNCATE:\n       /* For a smaller object, just ignore the high bits.  */\n-      num0 = cached_num_sign_bit_copies (XEXP (x, 0), VOIDmode,\n+      inner_mode = as_a <scalar_int_mode> (GET_MODE (XEXP (x, 0)));\n+      num0 = cached_num_sign_bit_copies (XEXP (x, 0), inner_mode,\n \t\t\t\t\t known_x, known_mode, known_ret);\n-      return MAX (1, (num0 - (int) (GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)))\n+      return MAX (1, (num0 - (int) (GET_MODE_PRECISION (inner_mode)\n \t\t\t\t    - bitwidth)));\n \n     case NOT:\n@@ -5200,7 +5201,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t\t\t\t\t known_x, known_mode, known_ret);\n       if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) > 0\n-\t  && INTVAL (XEXP (x, 1)) < GET_MODE_PRECISION (GET_MODE (x)))\n+\t  && INTVAL (XEXP (x, 1)) < xmode_width)\n \tnum0 = MIN ((int) bitwidth, num0 + INTVAL (XEXP (x, 1)));\n \n       return num0;\n@@ -5210,7 +5211,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       if (!CONST_INT_P (XEXP (x, 1))\n \t  || INTVAL (XEXP (x, 1)) < 0\n \t  || INTVAL (XEXP (x, 1)) >= (int) bitwidth\n-\t  || INTVAL (XEXP (x, 1)) >= GET_MODE_PRECISION (GET_MODE (x)))\n+\t  || INTVAL (XEXP (x, 1)) >= xmode_width)\n \treturn 1;\n \n       num0 = cached_num_sign_bit_copies (XEXP (x, 0), mode,"}]}