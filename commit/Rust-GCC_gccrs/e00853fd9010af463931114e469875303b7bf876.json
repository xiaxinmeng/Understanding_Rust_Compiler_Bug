{"sha": "e00853fd9010af463931114e469875303b7bf876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAwODUzZmQ5MDEwYWY0NjM5MzExMTRlNDY5ODc1MzAzYjdiZjg3Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-12-12T18:22:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-12-12T18:22:23Z"}, "message": "re PR c++/13118 ([ABI] Missed covariant return thunk)\n\ncp:\n\tPR c++/13118\n\t* cp-tree.h (lang_decl_u): Add thunk_alias member.\n\t(THUNK_VIRTUAL_OFFSET): Must be a FUNCTION_DECL.\n\t(THUNK_ALIAS_P): Remove.\n\t(THUNK_ALIAS): Adjust.\n\t* class.c (update_vtable_entry_for_fn): Get the vbase within the\n\toverriding function's return type.\n\t(dump_thunk): Adjust THUNK_ALIAS printing.\n\t(build_vtbl_initializer): Adjust THUNK_ALIAS use.\n\t* method.c (make_thunk): Revert 12881 test change. Clear\n\tTHUNK_ALIAS.\n\t(finish_thunk): Adjust THUNK_ALIAS setting.\n\t(use_thunk): Adjust THUNK_ALIAS use.\n\t* semantics.c (emit_associated_thunks): Likewise.\ntestsuite:\n\tPR c++/13118\n\t* g++.dg/abi/covariant3.C: New.\n\nFrom-SVN: r74576", "tree": {"sha": "e4c56658ea817e7905726e5e9476381df44a1c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4c56658ea817e7905726e5e9476381df44a1c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e00853fd9010af463931114e469875303b7bf876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e00853fd9010af463931114e469875303b7bf876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e00853fd9010af463931114e469875303b7bf876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e00853fd9010af463931114e469875303b7bf876/comments", "author": null, "committer": null, "parents": [{"sha": "3950dcdfccd66e077b1be064826aac76122f4bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3950dcdfccd66e077b1be064826aac76122f4bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3950dcdfccd66e077b1be064826aac76122f4bb4"}], "stats": {"total": 223, "additions": 153, "deletions": 70}, "files": [{"sha": "427a36b165e150746b3744dac18d3704817e0a10", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e00853fd9010af463931114e469875303b7bf876", "patch": "@@ -1,5 +1,20 @@\n 2003-12-12  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\tPR c++/13118\n+\t* cp-tree.h (lang_decl_u): Add thunk_alias member.\n+\t(THUNK_VIRTUAL_OFFSET): Must be a FUNCTION_DECL.\n+\t(THUNK_ALIAS_P): Remove.\n+\t(THUNK_ALIAS): Adjust.\n+\t* class.c (update_vtable_entry_for_fn): Get the vbase within the\n+\toverriding function's return type.\n+\t(dump_thunk): Adjust THUNK_ALIAS printing.\n+\t(build_vtbl_initializer): Adjust THUNK_ALIAS use.\n+\t* method.c (make_thunk): Revert 12881 test change. Clear\n+\tTHUNK_ALIAS.\n+\t(finish_thunk): Adjust THUNK_ALIAS setting.\n+\t(use_thunk): Adjust THUNK_ALIAS use.\n+\t* semantics.c (emit_associated_thunks): Likewise.\n+\n \tPR c++/13114, c++/13115\n \t* class.c (layout_empty_base): Propagate the move of an empty base\n \tto offset zero."}, {"sha": "ff615fe2c3b50def100c50170bca24f88863c345", "filename": "gcc/cp/class.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e00853fd9010af463931114e469875303b7bf876", "patch": "@@ -2168,13 +2168,22 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       \n       if (DECL_THUNK_P (fn))\n \t{\n+\t  my_friendly_assert (DECL_RESULT_THUNK_P (fn), 20031211);\n \t  fixed_offset = ssize_int (THUNK_FIXED_OFFSET (fn));\n \t  virtual_offset = THUNK_VIRTUAL_OFFSET (fn);\n \t}\n       else\n \tfixed_offset = virtual_offset = NULL_TREE;\n \n-      if (!virtual_offset)\n+      if (virtual_offset)\n+\t/* Find the equivalent binfo within the return type of the\n+\t   overriding function. We will want the vbase offset from\n+\t   there.  */\n+\tvirtual_offset =\n+\t  TREE_VALUE (purpose_member\n+\t\t      (BINFO_TYPE (virtual_offset),\n+\t\t       CLASSTYPE_VBASECLASSES (TREE_TYPE (over_return))));\n+      else\n \t{\n \t  /* There was no existing virtual thunk (which takes\n \t     precedence).  */\n@@ -6715,11 +6724,7 @@ dump_thunk (FILE *stream, int indent, tree thunk)\n \t   !DECL_THUNK_P (thunk) ? \"function\"\n \t   : DECL_THIS_THUNK_P (thunk) ? \"this-thunk\" : \"covariant-thunk\",\n \t   name ? IDENTIFIER_POINTER (name) : \"<unset>\");\n-  if (!DECL_THUNK_P (thunk))\n-    /*NOP*/;\n-  else if (THUNK_ALIAS_P (thunk))\n-    fprintf (stream, \" alias to %p\", (void *)THUNK_ALIAS (thunk));\n-  else\n+  if (DECL_THUNK_P (thunk))\n     {\n       HOST_WIDE_INT fixed_adjust = THUNK_FIXED_OFFSET (thunk);\n       tree virtual_adjust = THUNK_VIRTUAL_OFFSET (thunk);\n@@ -6734,6 +6739,8 @@ dump_thunk (FILE *stream, int indent, tree thunk)\n \tfprintf (stream, \" vbase=\" HOST_WIDE_INT_PRINT_DEC \"(%s)\",\n \t\t tree_low_cst (BINFO_VPTR_FIELD (virtual_adjust), 0),\n \t\t type_as_string (BINFO_TYPE (virtual_adjust), TFF_SCOPE));\n+      if (THUNK_ALIAS (thunk))\n+\tfprintf (stream, \" alias to %p\", (void *)THUNK_ALIAS (thunk));\n     }\n   fprintf (stream, \"\\n\");\n   for (thunks = DECL_THUNKS (thunk); thunks; thunks = TREE_CHAIN (thunks))\n@@ -7406,7 +7413,7 @@ build_vtbl_initializer (tree binfo,\n \t{\n \t  if (!DECL_NAME (fn))\n \t    finish_thunk (fn);\n-\t  if (THUNK_ALIAS_P (fn))\n+\t  if (THUNK_ALIAS (fn))\n \t    {\n \t      fn = THUNK_ALIAS (fn);\n \t      BV_FN (v) = fn;"}, {"sha": "250318e721c5388ea987b68f59e6230f900fd88c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e00853fd9010af463931114e469875303b7bf876", "patch": "@@ -1634,12 +1634,17 @@ struct lang_decl_flags GTY(())\n   unsigned this_thunk_p : 1;\n \n   union lang_decl_u {\n-    /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n-       is DECL_TEMPLATE_INFO.  */\n+    /* In a FUNCTION_DECL for which DECL_THUNK_P does not hold,\n+       VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this is\n+       DECL_TEMPLATE_INFO.  */\n     tree GTY ((tag (\"0\"))) template_info;\n \n     /* In a NAMESPACE_DECL, this is NAMESPACE_LEVEL.  */\n     struct cp_binding_level * GTY ((tag (\"1\"))) level;\n+\n+    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n+       THUNK_ALIAS.  */\n+    tree GTY ((tag (\"2\"))) thunk_alias;\n   } GTY ((desc (\"%1.u1sel\"))) u;\n \n   union lang_decl_u2 {\n@@ -2859,12 +2864,17 @@ struct lang_decl GTY(())\n    for the result pointer adjustment.\n \n    The constant adjustment is given by THUNK_FIXED_OFFSET.  If the\n-   vcall or vbase offset is required, the index into the vtable is given by\n-   THUNK_VIRTUAL_OFFSET.\n-\n-   Due to ordering constraints in class layout, it is possible to have\n-   equivalent covariant thunks. THUNK_ALIAS_P and THUNK_ALIAS are used\n-   in those cases.  */\n+   vcall or vbase offset is required, THUNK_VIRTUAL_OFFSET is\n+   used. For this pointer adjusting thunks, it is the vcall offset\n+   into the vtable.  For result pointer adjusting thunks it is the\n+   binfo of the virtual base to convert to.  Use that binfo's vbase\n+   offset.\n+\n+   It is possible to have equivalent covariant thunks.  These are\n+   distinct virtual covariant thunks whose vbase offsets happen to\n+   have the same value.  THUNK_ALIAS is used to pick one as the\n+   canonical thunk, which will get all the this pointer adjusting\n+   thunks attached to it.  */\n \n /* An integer indicating how many bytes should be subtracted from the\n    this or result pointer when this function is called.  */\n@@ -2882,15 +2892,11 @@ struct lang_decl GTY(())\n    binfos.)  */\n \n #define THUNK_VIRTUAL_OFFSET(DECL) \\\n-  (LANG_DECL_U2_CHECK (VAR_OR_FUNCTION_DECL_CHECK (DECL), 0)->virtual_offset)\n+  (LANG_DECL_U2_CHECK (FUNCTION_DECL_CHECK (DECL), 0)->virtual_offset)\n \n /* A thunk which is equivalent to another thunk. */\n-#define THUNK_ALIAS_P(DECL) \\\n-  (THUNK_VIRTUAL_OFFSET (DECL) && DECL_P (THUNK_VIRTUAL_OFFSET (DECL)))\n-\n-/* When THUNK_ALIAS_P is true, this indicates the thunk which is\n-   aliased.  */\n-#define THUNK_ALIAS(DECL) THUNK_VIRTUAL_OFFSET (DECL)\n+#define THUNK_ALIAS(DECL) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.u.thunk_alias)\n \n /* For thunk NODE, this is the FUNCTION_DECL thunked to.  */\n #define THUNK_TARGET(NODE)\t\t\t\t\\"}, {"sha": "bd1e2ad9ec5cf8d2e26f5eeb9012579d95ad6616", "filename": "gcc/cp/method.c", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e00853fd9010af463931114e469875303b7bf876", "patch": "@@ -124,51 +124,15 @@ make_thunk (tree function, bool this_adjusting,\n      thunks VIRTUAL_OFFSET will be an INTEGER_CST, for covariant thunks it\n      will be a BINFO.  */\n   for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n-    {\n-      if (DECL_THIS_THUNK_P (thunk) != this_adjusting\n-\t  || THUNK_FIXED_OFFSET (thunk) != d)\n-\t/*not me*/;\n-      else if (this_adjusting)\n-\t{\n-\t  if (!virtual_offset)\n-\t    {\n-\t      /* We want a non-virtual covariant thunk.  */\n-\t      if (!THUNK_VIRTUAL_OFFSET (thunk))\n-\t\treturn thunk;\n-\t    }\n-\t  else if (THUNK_VIRTUAL_OFFSET (thunk))\n-\t    {\n-\t      if (tree_int_cst_equal (THUNK_VIRTUAL_OFFSET (thunk),\n-\t\t\t\t      virtual_offset))\n-\t\treturn thunk;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (!virtual_offset)\n-\t    {\n-\t      /* We want a non-virtual covariant thunk.  */\n-\t      if (!THUNK_VIRTUAL_OFFSET (thunk))\n-\t\treturn thunk;\n-\t    }\n-\t  else if (!THUNK_VIRTUAL_OFFSET (thunk))\n-\t    /*not me*/;\n-\t  else if (THUNK_ALIAS_P (thunk))\n-\t    {\n-\t      /* We have already determined the thunks for FUNCTION,\n-\t         and there is a virtual covariant thunk alias.  We\n-\t         must compare the vbase offsets of the binfo we have\n-\t         been given, and the binfo of the thunk.  */\n-\t      tree binfo = THUNK_VIRTUAL_OFFSET (THUNK_ALIAS (thunk));\n-\t      \n-\t      if (tree_int_cst_equal (BINFO_VPTR_FIELD (virtual_offset),\n-\t\t\t\t      BINFO_VPTR_FIELD (binfo)))\n-\t\treturn THUNK_ALIAS (thunk);\n-\t    }\n-\t  else if (THUNK_VIRTUAL_OFFSET (thunk) == virtual_offset)\n-\t    return thunk;\n-\t}\n-    }\n+    if (DECL_THIS_THUNK_P (thunk) == this_adjusting\n+\t&& THUNK_FIXED_OFFSET (thunk) == d\n+\t&& !virtual_offset == !THUNK_VIRTUAL_OFFSET (thunk)\n+\t&& (!virtual_offset\n+\t    || (this_adjusting\n+\t\t? tree_int_cst_equal (THUNK_VIRTUAL_OFFSET (thunk),\n+\t\t\t\t      virtual_offset)\n+\t\t: THUNK_VIRTUAL_OFFSET (thunk) == virtual_offset)))\n+      return thunk;\n   \n   /* All thunks must be created before FUNCTION is actually emitted;\n      the ABI requires that all thunks be emitted together with the\n@@ -195,6 +159,7 @@ make_thunk (tree function, bool this_adjusting,\n   THUNK_TARGET (thunk) = function;\n   THUNK_FIXED_OFFSET (thunk) = d;\n   THUNK_VIRTUAL_OFFSET (thunk) = virtual_offset;\n+  THUNK_ALIAS (thunk) = NULL_TREE;\n   \n   /* The thunk itself is not a constructor or destructor, even if\n      the thing it is thunking to is.  */\n@@ -254,7 +219,7 @@ finish_thunk (tree thunk)\n \tif (DECL_NAME (cov_probe) == name)\n \t  {\n \t    my_friendly_assert (!DECL_THUNKS (thunk), 20031023);\n-\t    THUNK_ALIAS (thunk) = (THUNK_ALIAS_P (cov_probe)\n+\t    THUNK_ALIAS (thunk) = (THUNK_ALIAS (cov_probe)\n \t\t\t\t   ? THUNK_ALIAS (cov_probe) : cov_probe);\n \t    break;\n \t  }\n@@ -376,7 +341,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n   /* We should never be using an alias, always refer to the\n      aliased thunk.  */\n-  my_friendly_assert (!THUNK_ALIAS_P (thunk_fndecl), 20031023);\n+  my_friendly_assert (!THUNK_ALIAS (thunk_fndecl), 20031023);\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;"}, {"sha": "8039ca78368c0e6ec08b48a68da75b17f4201b3f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00853fd9010af463931114e469875303b7bf876/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e00853fd9010af463931114e469875303b7bf876", "patch": "@@ -2836,7 +2836,7 @@ emit_associated_thunks (tree fn)\n       \n       for (thunk = DECL_THUNKS (fn); thunk; thunk = TREE_CHAIN (thunk))\n \t{\n-\t  if (!THUNK_ALIAS_P (thunk))\n+\t  if (!THUNK_ALIAS (thunk))\n \t    {\n \t      use_thunk (thunk, /*emit_p=*/1);\n \t      if (DECL_RESULT_THUNK_P (thunk))"}, {"sha": "cabc671b40dc006f74f3a7965d73f3fa8fdb1027", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00853fd9010af463931114e469875303b7bf876/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00853fd9010af463931114e469875303b7bf876/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e00853fd9010af463931114e469875303b7bf876", "patch": "@@ -1,3 +1,8 @@\n+2003-12-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/13118\n+\t* g++.dg/abi/covariant3.C: New.\n+\n 2003-12-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/eh/ia64-1.C: New test."}, {"sha": "178157c58b2ff367f85c5c48a0b8f4761656c459", "filename": "gcc/testsuite/g++.dg/abi/covariant3.C", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00853fd9010af463931114e469875303b7bf876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00853fd9010af463931114e469875303b7bf876/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant3.C?ref=e00853fd9010af463931114e469875303b7bf876", "patch": "@@ -0,0 +1,85 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 12 Dec 2003 <nathan@codesourcery.com>\n+// Origin:  grigory@stl.sarov.ru\n+\n+// PR c++/13118. Missing covariant thunk.\n+\n+struct c0 {};\n+struct c1 : virtual c0 {\n+  virtual c0* f6();\n+};\n+\n+struct c5 {\n+    virtual void foo();\n+};\n+\n+struct c10 : virtual c1 {\n+    virtual void foo();\n+};\n+\n+struct c1a : c1 {}; // disambiguation\n+\n+struct c11 : virtual c10, c1a {\n+  int i;\n+  virtual c1* f6 () = 0;\n+};\n+\n+struct c18 : c5, virtual c1 {\n+    virtual void bar();\n+};\n+\n+struct c28 : virtual c0, virtual c11 {\n+    virtual c18* f6();\n+};\n+\n+c0 *c1::f6 () {}\n+void c5::foo () {}\n+void c10::foo () {}\n+void c18::bar () {}\n+\n+c18 ret;\n+\n+c18 *c28::f6 ()\n+{\n+  return &ret;\n+}\n+\n+bool check_c1 (c1 *ptr)\n+{\n+  c0 *r = ptr->f6 ();\n+  return r != &ret;\n+}\n+bool check_c10 (c10 *ptr)\n+{\n+  c0 *r = ptr->f6 ();\n+  return r != &ret;\n+}\n+bool check_c11 (c11 *ptr)\n+{\n+  c1 *r = ptr->f6 ();\n+  return r != &ret;\n+}\n+bool check_c28 (c28 *ptr)\n+{\n+  c18 *r = ptr->f6 ();\n+  return r != &ret;\n+}\n+\n+int main ()\n+{\n+  c28 obj;\n+  \n+  if (check_c1 (static_cast<c1a *> (&obj)))\n+    return 1;\n+  if (check_c1 (static_cast<c10 *> (&obj)))\n+    return 2;\n+  if (check_c10 (&obj))\n+    return 3;\n+  if (check_c11 (&obj))\n+    return 4;\n+  if (check_c28 (&obj))\n+    return 5;\n+  return 0;\n+}"}]}