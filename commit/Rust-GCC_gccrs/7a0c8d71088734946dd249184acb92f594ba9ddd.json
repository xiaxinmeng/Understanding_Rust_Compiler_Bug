{"sha": "7a0c8d71088734946dd249184acb92f594ba9ddd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EwYzhkNzEwODg3MzQ5NDZkZDI0OTE4NGFjYjkyZjU5NGJhOWRkZA==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2001-12-02T14:38:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-02T14:38:07Z"}, "message": "vms.h (VMS_DEBUGGING_INFO): New macro.\n\n\t* config/alpha/vms.h (VMS_DEBUGGING_INFO): New macro.\n\t(PREFERRED_DEBUGGING_TYPE): Define as VMS_AND_DWARF2_DEBUG.\n\t(ASM_SPEC): Don't redefine.\n\t(OPTIMIZATION_OPTIONS, OVERRIDE_OPTIONS, LINK_SPEC): Define.\n\t* config/alpha/t-vms (EXTRA_PARTS): Use; add rule for vms-dwarf2.asm.\n\t* config/alpha/vms-dwarf2.asm: New file.\n\t* Makefile.in (OBJS): Add vmsdbgout.c and its rule.\n\t* c-lex.c (init_c_lex): Test for VMS_AND_DWARF2_DEBUG.\n\t* debug.h (gcc_debug_hooks): Add vmsdbg_debug_hooks.\n\t(vmsdbgout_after_prologue): New declaration.\n\t* defaults.h (VMS_DEBUGGING_INFO): Add to PREFERRED_DEBUGGING_TYPE.\n\t* dwarf2.h (dwarf_attribute): New DW_AT_VMS_rtnbeg_pd_address.\n\t* dwarf2out.c (dwarf2out_do_frame): Test for VMS_AND_DWARF2_DEBUG.\n\t(dwarf2out_frame_finish): Test for VMS_AND_DWARF2_DEBUG.\n\t(dwarf_attr_name): Use DW_AT_VMS_rtnbeg_pd_address.\n\t(add_name_and_src_coords_attributes): Test VMS_DEBUGGING_INFO\n\t* final.c (final_start_function): Test for VMS_AND_DWARF2_DEBUG.\n\tTest VMS_DEBUGGING_INFO.\n\t(final_end_function): Test for VMS_AND_DWARF2_DEBUG.\n\t(final_scan_insn): Test for VMS_AND_DWARF2_DEBUG and VMS_DEBUG.\n\t* flags.h (debug_info_type): Add VMS_DEBUG and VMS_AND_DWARF2_DEBUG.\n\t* toplev.c (compile_file): Test VMS_DEBUGGING_INFO, VMS_DEBUG, and\n\tVMS_AND_DWARF2_DEBUG.\n\t(rest_of_type_compilation): Test for VMS_AND_DWARF2_DEBUG.\n\t(decode_g_option): Add \"vms\" to debug_type_names.\n\t(process_options): Set vmsdbg_debug_hooks if -gvms.\n\t(lang_independent_init): Emit line number for VMS unless -g0.\n\t* tree.c: (build_complex_type): Test for VMS_AND_DWARF2_DEBUG.\n\t* vmsdbg.h, vmsdbgout.c: New files.\n\nFrom-SVN: r47532", "tree": {"sha": "e42e03bca7b1d30a4e1957a95213853fa5c9a849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e42e03bca7b1d30a4e1957a95213853fa5c9a849"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a0c8d71088734946dd249184acb92f594ba9ddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0c8d71088734946dd249184acb92f594ba9ddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a0c8d71088734946dd249184acb92f594ba9ddd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0c8d71088734946dd249184acb92f594ba9ddd/comments", "author": null, "committer": null, "parents": [{"sha": "e773246d9c11d0d34f03a921959e9db75ed7a84b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e773246d9c11d0d34f03a921959e9db75ed7a84b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e773246d9c11d0d34f03a921959e9db75ed7a84b"}], "stats": {"total": 2093, "additions": 2063, "deletions": 30}, "files": [{"sha": "2b5f1b7d620db87494f732ad7d3584e7a6dbbafb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -1,3 +1,36 @@\n+Sun Dec  2 09:22:25 2001  Douglas B. Rupp  <rupp@gnat.com>\n+\n+\t* config/alpha/vms.h (VMS_DEBUGGING_INFO): New macro.\n+\t(PREFERRED_DEBUGGING_TYPE): Define as VMS_AND_DWARF2_DEBUG.\n+\t(ASM_SPEC): Don't redefine.\n+\t(OPTIMIZATION_OPTIONS, OVERRIDE_OPTIONS, LINK_SPEC): Define.\n+\t* config/alpha/t-vms (EXTRA_PARTS): Use; add rule for vms-dwarf2.asm.\n+\t* config/alpha/vms-dwarf2.asm: New file.\n+\n+\t* Makefile.in (OBJS): Add vmsdbgout.c and its rule.\n+\t* c-lex.c (init_c_lex): Test for VMS_AND_DWARF2_DEBUG.\n+\t* debug.h (gcc_debug_hooks): Add vmsdbg_debug_hooks.\n+\t(vmsdbgout_after_prologue): New declaration.\n+\t* defaults.h (VMS_DEBUGGING_INFO): Add to PREFERRED_DEBUGGING_TYPE.\n+\t* dwarf2.h (dwarf_attribute): New DW_AT_VMS_rtnbeg_pd_address.\n+\t* dwarf2out.c (dwarf2out_do_frame): Test for VMS_AND_DWARF2_DEBUG.\n+\t(dwarf2out_frame_finish): Test for VMS_AND_DWARF2_DEBUG.\n+\t(dwarf_attr_name): Use DW_AT_VMS_rtnbeg_pd_address.\n+\t(add_name_and_src_coords_attributes): Test VMS_DEBUGGING_INFO\n+\t* final.c (final_start_function): Test for VMS_AND_DWARF2_DEBUG.\n+\tTest VMS_DEBUGGING_INFO.\n+\t(final_end_function): Test for VMS_AND_DWARF2_DEBUG.\n+\t(final_scan_insn): Test for VMS_AND_DWARF2_DEBUG and VMS_DEBUG.\n+\t* flags.h (debug_info_type): Add VMS_DEBUG and VMS_AND_DWARF2_DEBUG.\n+\t* toplev.c (compile_file): Test VMS_DEBUGGING_INFO, VMS_DEBUG, and\n+\tVMS_AND_DWARF2_DEBUG.\n+\t(rest_of_type_compilation): Test for VMS_AND_DWARF2_DEBUG.\n+\t(decode_g_option): Add \"vms\" to debug_type_names.\n+\t(process_options): Set vmsdbg_debug_hooks if -gvms.\n+\t(lang_independent_init): Emit line number for VMS unless -g0.\n+\t* tree.c: (build_complex_type): Test for VMS_AND_DWARF2_DEBUG.\n+\t* vmsdbg.h, vmsdbgout.c: New files.\n+\n Sun Dec  2 09:03:06 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* cfgbuild.c (SET_STATE): Add cast to eliminate warning.a"}, {"sha": "32ed60ab69b5c01179686691c8fe0d742b4a0c7b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -728,7 +728,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t\\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t\\\n  sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\\\n  stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-dump.o \t\\\n- tree-inline.o unroll.o varasm.o varray.o version.o xcoffout.o \t\t\\\n+ tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n BACKEND = main.o libbackend.a\n@@ -1395,6 +1395,8 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) dwarf2.h \\\n    $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) flags.h $(RTL_H) $(TREE_H) \\\n    output.h dwarf2asm.h $(TM_P_H)\n+vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\\n+   output.h vmsdbg.h debug.h langhooks.h\n xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h $(GGC_H)\n emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\"}, {"sha": "e70be7028e67d258bd01b59aaee8be0f2de9c631", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -133,7 +133,8 @@ init_c_lex (filename)\n \n   /* Set the debug callbacks if we can use them.  */\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n-      && (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG))\n+      && (write_symbols == DWARF_DEBUG || write_symbols == DWARF2_DEBUG\n+          || write_symbols == VMS_AND_DWARF2_DEBUG))\n     {\n       cb->define = cb_define;\n       cb->undef = cb_undef;"}, {"sha": "3b079f0096eb38751047b5c3032169ab1e2441dc", "filename": "gcc/config/alpha/t-vms", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fconfig%2Falpha%2Ft-vms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fconfig%2Falpha%2Ft-vms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-vms?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -1 +1,7 @@\n LIB2FUNCS_EXTRA = $(srcdir)/config/alpha/vms_tramp.asm\n+EXTRA_PARTS = vms-dwarf2.o\n+\n+# This object must be linked in in order to make the executable debuggable.\n+# vms-ld handles it automatically when passed -g.\n+vms-dwarf2.o : $(srcdir)/config/alpha/vms-dwarf2.asm\n+\tgcc -c -x assembler $<"}, {"sha": "a94ae24b15214ff705ae6ccb17d0c86c2a272ba7", "filename": "gcc/config/alpha/vms-dwarf2.asm", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fconfig%2Falpha%2Fvms-dwarf2.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fconfig%2Falpha%2Fvms-dwarf2.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-dwarf2.asm?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -0,0 +1,82 @@\n+/* VMS dwarf2 section sequentializer.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Douglas B. Rupp (rupp@gnat.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Linking with this file forces Dwarf2 debug sections to be\n+   sequentially loaded by the VMS linker, enabling GDB to read them.  */\n+\n+.section\t.debug_abbrev,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_abbrev\n+$dwarf2.debug_abbrev:\n+\t\n+.section\t.debug_aranges,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_aranges\n+$dwarf2.debug_aranges:\n+\t\n+.section\t.debug_frame,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_frame\n+$dwarf2.debug_frame:\t\t\n+\t\n+.section\t.debug_info,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_info\n+$dwarf2.debug_info:\t\t\n+\t\n+.section\t.debug_line,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_line\n+$dwarf2.debug_line:\t\t\n+\t\n+.section\t.debug_loc,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_loc\n+$dwarf2.debug_loc:\t\t\n+\t\n+.section\t.debug_macinfo,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_macinfo\n+$dwarf2.debug_macinfo:\t\t\n+\t\n+.section\t.debug_pubnames,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_pubnames\n+$dwarf2.debug_pubnames:\t\t\n+\t\n+.section\t.debug_str,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_str\n+$dwarf2.debug_str:\t\t\n+\t\n+.section\t.debug_zzzzzz,NOWRT\n+\t\t.align 0\n+\t\t.globl\t$dwarf2.debug_zzzzzz\n+$dwarf2.debug_zzzzzz:\t\t"}, {"sha": "d53deb3102c6174b685164e084b0b66c636235e4", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -403,6 +403,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef DBX_DEBUGGING_INFO\n \n #define DWARF2_DEBUGGING_INFO\n+#define VMS_DEBUGGING_INFO\n \n /* This is how to output an assembler line\n    that says to advance the location counter\n@@ -425,7 +426,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n #undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+#define PREFERRED_DEBUGGING_TYPE VMS_AND_DWARF2_DEBUG\n \n #undef ASM_FORMAT_PRIVATE_NAME\n #define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n@@ -437,10 +438,33 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #undef ASM_SPEC\n #undef ASM_FINAL_SPEC\n+\n+/* The VMS convention is to always provide minimal debug info\n+   for a traceback unless specifically overridden.  Defaulting this here\n+   is a kludge.  */\n+\n+#define OPTIMIZATION_OPTIONS(OPTIMIZE, OPTIMIZE_SIZE) \\\n+{                                                  \\\n+   write_symbols = VMS_DEBUG;                      \\\n+   debug_info_level = (enum debug_info_level) 1;   \\\n+}\n+\n+/* Override traceback debug info on -g0.  */\n+#undef OVERRIDE_OPTIONS\n+#define OVERRIDE_OPTIONS                           \\\n+{                                                  \\\n+   if (write_symbols == NO_DEBUG)                  \\\n+     debug_info_level = (enum debug_info_level) 0; \\\n+   override_options ();                            \\\n+}\n+\n+/* Link with vms-dwarf2.o if -g (except -g0). This causes the\n+   VMS link to pull all the dwarf2 debug sections together. */\n #undef LINK_SPEC\n+#define LINK_SPEC \"%{g:-g vms-dwarf2.o%s} %{g0} %{g1:-g1 vms-dwarf2.o%s} \\\n+%{g2:-g2 vms-dwarf2.o%s} %{g3:-g3 vms-dwarf2.o%s} %{shared} %{v} %{map}\"\n+\n #undef STARTFILE_SPEC\n-#define ASM_SPEC \"-nocpp %{pg}\"\n-#define LINK_SPEC \"%{g3:-g3} %{g0:-g0} %{shared:-shared} %{v:-v}\"\n \n /* Define the names of the division and modulus functions.  */\n #define DIVSI3_LIBCALL \"OTS$DIV_I\""}, {"sha": "865e5f86e1b00445c6bc70d9dc1aca513e1513b8", "filename": "gcc/debug.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -133,22 +133,22 @@ extern struct gcc_debug_hooks sdb_debug_hooks;\n extern struct gcc_debug_hooks xcoff_debug_hooks;\n extern struct gcc_debug_hooks dwarf_debug_hooks;\n extern struct gcc_debug_hooks dwarf2_debug_hooks;\n+extern struct gcc_debug_hooks vmsdbg_debug_hooks;\n \n /* Dwarf2 frame information.  */\n \n-/* FILE is NULL iff being called for frame information for non-dwarf\n-   debug output.  */\n-extern void dwarf2out_begin_prologue\n-  PARAMS ((unsigned int, const char * file));\n-extern void dwarf2out_end_epilogue\n-  PARAMS ((void));\n-extern void dwarf2out_frame_init\n-  PARAMS ((void));\n-extern void dwarf2out_frame_finish\n-  PARAMS ((void));\n+extern void dwarf2out_begin_prologue\tPARAMS ((unsigned int, const char *));\n+extern void dwarf2out_end_epilogue\tPARAMS ((void));\n+extern void dwarf2out_frame_init\tPARAMS ((void));\n+extern void dwarf2out_frame_finish\tPARAMS ((void));\n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n-extern int dwarf2out_do_frame\n-  PARAMS ((void));\n+extern int dwarf2out_do_frame\t\tPARAMS ((void));\n+\n+/* When writing VMS debug info, output label after the prologue of the\n+   function.  */\n+extern void vmsdbgout_after_prologue\tPARAMS ((void));\n+\n+\n \n #endif /* !GCC_DEBUG_H  */"}, {"sha": "f23b0ab8a434ad8a0c12184b28026008bb522bbd", "filename": "gcc/defaults.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -425,7 +425,7 @@ do {\t\t\t\t\t\t\t\t\\\n    PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.\n \n    This is one long line cause VAXC can't handle a \\-newline.  */\n-#if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO))\n+#if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO) + defined (VMS_DEBUGGING_INFO))\n #ifndef PREFERRED_DEBUGGING_TYPE\n You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #endif /* no PREFERRED_DEBUGGING_TYPE */\n@@ -443,6 +443,9 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #ifdef DWARF2_DEBUGGING_INFO\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n #endif\n+#ifdef VMS_DEBUGGING_INFO\n+#define PREFERRED_DEBUGGING_TYPE VMS_AND_DWARF2_DEBUG\n+#endif\n #ifdef XCOFF_DEBUGGING_INFO\n #define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG\n #endif"}, {"sha": "d73866ca5c1ed193918467656fde2527e97f49dc", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -232,7 +232,9 @@ enum dwarf_attribute\n     DW_AT_mac_info = 0x2103,\n     DW_AT_src_coords = 0x2104,\n     DW_AT_body_begin = 0x2105,\n-    DW_AT_body_end = 0x2106\n+    DW_AT_body_end = 0x2106,\n+    /* VMS Extensions */\n+    DW_AT_VMS_rtnbeg_pd_address = 0x2201\n   };\n \n #define DW_AT_lo_user\t0x2000\t/* implementation-defined range start */"}, {"sha": "a10367381e160c3a2fde313249585cf0e4c9500e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -91,6 +91,7 @@ int\n dwarf2out_do_frame ()\n {\n   return (write_symbols == DWARF2_DEBUG\n+\t  || write_symbols == VMS_AND_DWARF2_DEBUG\n #ifdef DWARF2_FRAME_INFO\n \t  || DWARF2_FRAME_INFO\n #endif\n@@ -2115,7 +2116,7 @@ void\n dwarf2out_frame_finish ()\n {\n   /* Output call frame information.  */\n-  if (write_symbols == DWARF2_DEBUG)\n+  if (write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n     output_call_frame_info (0);\n   if (! USING_SJLJ_EXCEPTIONS && (flag_unwind_tables || flag_exceptions))\n     output_call_frame_info (1);\n@@ -4099,6 +4100,9 @@ dwarf_attr_name (attr)\n       return \"DW_AT_body_begin\";\n     case DW_AT_body_end:\n       return \"DW_AT_body_end\";\n+    case DW_AT_VMS_rtnbeg_pd_address:\n+      return \"DW_AT_VMS_rtnbeg_pd_address\";\n+\n     default:\n       return \"DW_AT_<unknown>\";\n     }\n@@ -9311,6 +9315,15 @@ add_name_and_src_coords_attributes (die, decl)\n \tadd_AT_string (die, DW_AT_MIPS_linkage_name,\n \t\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n     }\n+\n+#ifdef VMS_DEBUGGING_INFO\n+\n+  /* Get the function's name, as described by its RTL.  This may be different\n+     from the DECL_NAME name used in the source file.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL && TREE_ASM_WRITTEN (decl))\n+    add_AT_string (die, DW_AT_VMS_rtnbeg_pd_address,\n+\t\t   xstrdup (XSTR (XEXP (DECL_RTL (decl), 0), 0)));\n+#endif\n }\n \n /* Push a new declaration scope.  */"}, {"sha": "7af2c1f66a56f555e05afba777a87bb32d13b5ba", "filename": "gcc/final.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -1678,7 +1678,7 @@ final_start_function (first, file, optimize)\n   (*debug_hooks->begin_prologue) (last_linenum, last_filename);\n \n #if defined (DWARF2_UNWIND_INFO) || defined (IA64_UNWIND_INFO)\n-  if (write_symbols != DWARF2_DEBUG)\n+  if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG)\n     dwarf2out_begin_prologue (0, NULL);\n #endif\n \n@@ -1715,6 +1715,12 @@ final_start_function (first, file, optimize)\n   /* First output the function prologue: code to set up the stack frame.  */\n   (*targetm.asm_out.function_prologue) (file, get_frame_size ());\n \n+#ifdef VMS_DEBUGGING_INFO\n+  /* Output label after the prologue of the function.  */\n+  if (write_symbols == VMS_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n+    vmsdbgout_after_prologue ();\n+#endif\n+\n   /* If the machine represents the prologue as RTL, the profiling code must\n      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n #ifdef HAVE_prologue\n@@ -1846,7 +1852,8 @@ final_end_function ()\n   (*debug_hooks->end_epilogue) ();\n \n #if defined (DWARF2_UNWIND_INFO)\n-  if (write_symbols != DWARF2_DEBUG && dwarf2out_do_frame ())\n+  if (write_symbols != DWARF2_DEBUG && write_symbols != VMS_AND_DWARF2_DEBUG\n+      && dwarf2out_do_frame ())\n     dwarf2out_end_epilogue ();\n #endif\n \n@@ -2160,7 +2167,9 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  if (debug_info_level == DINFO_LEVEL_NORMAL\n \t      || debug_info_level == DINFO_LEVEL_VERBOSE\n \t      || write_symbols == DWARF_DEBUG\n-\t      || write_symbols == DWARF2_DEBUG)\n+\t      || write_symbols == DWARF2_DEBUG\n+\t      || write_symbols == VMS_AND_DWARF2_DEBUG\n+\t      || write_symbols == VMS_DEBUG)\n \t    {\n \t      int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n \n@@ -2180,7 +2189,9 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  if (debug_info_level == DINFO_LEVEL_NORMAL\n \t      || debug_info_level == DINFO_LEVEL_VERBOSE\n \t      || write_symbols == DWARF_DEBUG\n-\t      || write_symbols == DWARF2_DEBUG)\n+\t      || write_symbols == DWARF2_DEBUG\n+\t      || write_symbols == VMS_AND_DWARF2_DEBUG\n+\t      || write_symbols == VMS_DEBUG)\n \t    {\n \t      int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n "}, {"sha": "8c8fa2648868d680be8996f8c95bc3453226f891", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -32,7 +32,10 @@ enum debug_info_type\n   SDB_DEBUG,\t    /* Write COFF for (old) SDB (using sdbout.c).  */\n   DWARF_DEBUG,\t    /* Write Dwarf debug info (using dwarfout.c).  */\n   DWARF2_DEBUG,\t    /* Write Dwarf v2 debug info (using dwarf2out.c).  */\n-  XCOFF_DEBUG\t    /* Write IBM/Xcoff debug info (using dbxout.c).  */\n+  XCOFF_DEBUG,\t    /* Write IBM/Xcoff debug info (using dbxout.c).  */\n+  VMS_DEBUG,        /* Write VMS debug info (using vmsdbgout.c). */\n+  VMS_AND_DWARF2_DEBUG /* Write VMS debug info (using vmsdbgout.c).\n+                          and DWARF v2 debug info (using dwarf2out.c). */\n };\n \n /* Specify which kind of debugging info to generate.  */"}, {"sha": "54582dc4784042bd6cf7fd9d4f97296ddff03106", "filename": "gcc/toplev.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -2332,7 +2332,9 @@ rest_of_type_compilation (type, toplev)\n     sdbout_symbol (TYPE_STUB_DECL (type), !toplev);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n-  if (write_symbols == DWARF2_DEBUG && toplev)\n+  if ((write_symbols == DWARF2_DEBUG\n+       || write_symbols == VMS_AND_DWARF2_DEBUG)\n+      && toplev)\n     dwarf2out_decl (TYPE_STUB_DECL (type));\n #endif\n   timevar_pop (TV_SYMOUT);\n@@ -3974,7 +3976,7 @@ decode_g_option (arg)\n   /* Indexed by enum debug_info_type.  */\n   static const char *const debug_type_names[] =\n   {\n-    \"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\"\n+    \"none\", \"stabs\", \"coff\", \"dwarf-1\", \"dwarf-2\", \"xcoff\", \"vms\"\n   };\n \n   /* The maximum admissible debug level value.  */\n@@ -4937,6 +4939,10 @@ process_options ()\n   if (write_symbols == DWARF2_DEBUG)\n     debug_hooks = &dwarf2_debug_hooks;\n #endif\n+#ifdef VMS_DEBUGGING_INFO\n+  if (write_symbols == VMS_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n+    debug_hooks = &vmsdbg_debug_hooks;\n+#endif\n \n   /* If auxiliary info generation is desired, open the output file.\n      This goes in the same directory as the source file--unlike\n@@ -4999,8 +5005,12 @@ lang_independent_init ()\n \n   init_emit_once (debug_info_level == DINFO_LEVEL_NORMAL\n \t\t  || debug_info_level == DINFO_LEVEL_VERBOSE\n-\t\t  || flag_test_coverage\n-\t\t  || warn_notreached);\n+#ifdef VMS_DEBUGGING_INFO\n+\t\t    /* Enable line number info for traceback */\n+\t\t    || debug_info_level > DINFO_LEVEL_NONE\n+#endif\n+\t\t    || flag_test_coverage\n+\t\t    || warn_notreached);\n   init_regs ();\n   init_alias_once ();\n   init_stmt ();"}, {"sha": "3cc52c03f5fd54a30853df070408bb0c2188305a", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -3997,7 +3997,8 @@ build_complex_type (component_type)\n \n   /* If we are writing Dwarf2 output we need to create a name,\n      since complex is a fundamental type.  */\n-  if (write_symbols == DWARF2_DEBUG && ! TYPE_NAME (t))\n+  if ((write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n+      && ! TYPE_NAME (t))\n     {\n       const char *name;\n       if (component_type == char_type_node)"}, {"sha": "65147a6cf5d4720180091e2b1dd6f0f653e407b2", "filename": "gcc/vmsdbg.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fvmsdbg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fvmsdbg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbg.h?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -0,0 +1,173 @@\n+/* This file contains definitions for the data structures and codes used in\n+   VMS debugging information.  */\n+\n+#ifndef VMSDBG_H\n+#define VMSDBG_H 1\n+\t\n+typedef unsigned short int DST_DTYPE;\n+#define DST_K_SOURCE 155\n+#define DST_K_PROLOG 162\n+#define DST_K_BLKBEG 176\n+#define DST_K_BLKEND 177\n+#define DST_K_LINE_NUM 185\n+#define DST_K_MODBEG 188\n+#define DST_K_MODEND 189\n+#define DST_K_RTNBEG 190\n+#define DST_K_RTNEND 191\n+\n+typedef struct _DST_HEADER {\n+  union  {\n+    unsigned short int dst_w_length;\n+    unsigned short int dst_x_length;\n+  } dst__header_length;\n+  union  {\n+    DST_DTYPE dst_w_type;\n+    DST_DTYPE dst_x_type;\n+  } dst__header_type;\n+} DST_HEADER;\n+#define DST_K_DST_HEADER_SIZE 4\n+\t\n+typedef unsigned int DST_LANGUAGE;\n+#define DST_K_FORTRAN 1\n+#define DST_K_C 7\n+#define DST_K_ADA 9\n+#define DST_K_UNKNOWN 10\n+#define DST_K_CXX 15\n+typedef struct _DST_MODULE_BEGIN {\n+  DST_HEADER dst_a_modbeg_header;\n+  struct  {\n+    unsigned dst_v_modbeg_hide : 1;\n+    unsigned dst_v_modbeg_version : 1;\n+    unsigned dst_v_modbeg_unused : 6;\n+  } dst_b_modbeg_flags;\n+  unsigned char dst_b_modbeg_unused;\n+  DST_LANGUAGE dst_l_modbeg_language;\n+  unsigned short int dst_w_version_major;\n+  unsigned short int dst_w_version_minor;\n+  unsigned char dst_b_modbeg_name;\n+} DST_MODULE_BEGIN;\n+#define DST_K_MODBEG_SIZE 15\n+\t\n+typedef struct _DST_MB_TRLR {\n+  unsigned char dst_b_compiler;\n+} DST_MB_TRLR;\n+#define DST_K_MB_TRLR_SIZE 1\n+#define DST_K_VERSION_MAJOR 1\n+#define DST_K_VERSION_MINOR 13\n+typedef struct _DST_MODULE_END {\n+  DST_HEADER dst_a_modend_header;\n+} DST_MODULE_END;\n+#define DST_K_MODEND_SIZE 4\n+typedef struct _DST_ROUTINE_BEGIN {\n+  DST_HEADER dst_a_rtnbeg_header;\n+  struct  {\n+    unsigned dst_v_rtnbeg_unused : 4;\n+    unsigned dst_v_rtnbeg_unalloc : 1;\n+    unsigned dst_v_rtnbeg_prototype : 1;\n+    unsigned dst_v_rtnbeg_inlined : 1;\n+    unsigned dst_v_rtnbeg_no_call : 1;\n+  } dst_b_rtnbeg_flags;\n+  int *dst_l_rtnbeg_address;\n+  int *dst_l_rtnbeg_pd_address;\n+  unsigned char dst_b_rtnbeg_name;\n+} DST_ROUTINE_BEGIN;\n+#define DST_K_RTNBEG_SIZE 14\n+typedef struct _DST_ROUTINE_END {\n+  DST_HEADER dst_a_rtnend_header;\n+  char dst_b_rtnend_unused;\n+  unsigned int dst_l_rtnend_size;\n+} DST_ROUTINE_END;\n+#define DST_K_RTNEND_SIZE 9\n+typedef struct _DST_BLOCK_BEGIN {\n+  DST_HEADER dst_a_blkbeg_header;\n+  unsigned char dst_b_blkbeg_unused;\n+  int *dst_l_blkbeg_address;\n+  unsigned char dst_b_blkbeg_name;\n+} DST_BLOCK_BEGIN;\n+#define DST_K_BLKBEG_SIZE 10\n+typedef struct _DST_BLOCK_END {\n+  DST_HEADER dst_a_blkend_header;\n+  unsigned char dst_b_blkend_unused;\n+  unsigned int dst_l_blkend_size;\n+} DST_BLOCK_END;\n+#define DST_K_BLKEND_SIZE 9\n+typedef struct _DST_LINE_NUM_HEADER {\n+  DST_HEADER dst_a_line_num_header;\n+} DST_LINE_NUM_HEADER;\n+#define DST_K_LINE_NUM_HEADER_SIZE 4\n+\n+typedef struct _DST_PCLINE_COMMANDS {\n+  char dst_b_pcline_command;\n+  union  {\n+    unsigned int dst_l_pcline_unslong;\n+    unsigned short int dst_w_pcline_unsword;\n+    unsigned char dst_b_pcline_unsbyte;\n+  } dst_a_pcline_access_fields;\n+} DST_PCLINE_COMMANDS;\n+#define DST_K_PCLINE_COMMANDS_SIZE 5\n+#define DST_K_PCLINE_COMMANDS_SIZE_MIN 2\n+#define DST_K_PCLINE_COMMANDS_SIZE_MAX 5\n+#define DST_K_DELTA_PC_LOW -128\n+#define DST_K_DELTA_PC_HIGH 0\n+#define DST_K_DELTA_PC_W 1\n+#define DST_K_INCR_LINUM 2\n+#define DST_K_INCR_LINUM_W 3\n+#define DST_K_SET_LINUM 9\n+#define DST_K_SET_ABS_PC 16\n+#define DST_K_DELTA_PC_L 17\n+#define DST_K_INCR_LINUM_L 18\n+#define DST_K_SET_LINUM_B 19\n+#define DST_K_SET_LINUM_L 20\n+typedef struct _DST_SOURCE_CORR {\n+  DST_HEADER dst_a_source_corr_header;\n+} DST_SOURCE_CORR;\n+#define DST_K_SOURCE_CORR_HEADER_SIZE 4\n+\t\n+#define DST_K_SRC_DECLFILE 1\n+#define DST_K_SRC_SETFILE 2\n+#define DST_K_SRC_SETREC_L 3\n+#define DST_K_SRC_SETREC_W 4\n+#define DST_K_SRC_SETLNUM_L 5\n+#define DST_K_SRC_SETLNUM_W 6\n+#define DST_K_SRC_INCRLNUM_B 7\n+#define DST_K_SRC_DEFLINES_W 10\n+#define DST_K_SRC_DEFLINES_B 11\n+#define DST_K_SRC_FORMFEED 16\n+#define DST_K_SRC_MIN_CMD 1\n+#define DST_K_SRC_MAX_CMD 16\n+typedef struct _DST_SRC_COMMAND {\n+  unsigned char dst_b_src_command;\n+  union  {\n+    struct  {\n+      unsigned char dst_b_src_df_length;\n+      unsigned char dst_b_src_df_flags;\n+      unsigned short int dst_w_src_df_fileid;\n+#ifdef __GNUC__\n+      long long dst_q_src_df_rms_cdt;\n+#else\n+      __int64 dst_q_src_df_rms_cdt;\n+#endif\n+      unsigned int dst_l_src_df_rms_ebk;\n+      unsigned short int dst_w_src_df_rms_ffb;\n+      unsigned char dst_b_src_df_rms_rfo;\n+      unsigned char dst_b_src_df_filename;\n+    } dst_a_src_decl_src;\n+    unsigned int dst_l_src_unslong;\n+    unsigned short int dst_w_src_unsword;\n+    unsigned char dst_b_src_unsbyte;\n+  } dst_a_src_cmd_fields;\n+} DST_SRC_COMMAND;\n+#define DST_K_SRC_COMMAND_SIZE 21\n+\t\n+typedef struct _DST_SRC_CMDTRLR {\n+  unsigned char dst_b_src_df_libmodname;\n+} DST_SRC_CMDTRLR;\n+#define DST_K_SRC_CMDTRLR_SIZE 1\n+\t\n+typedef struct _DST_PROLOG {\n+  DST_HEADER dst_a_prolog_header;\n+  unsigned int dst_l_prolog_bkpt_addr;\n+} DST_PROLOG;\n+#define DST_K_PROLOG_SIZE 8\n+\t\n+#endif /* VMSDBG_H */"}, {"sha": "afc17f5a01f39792cbf20dcc4f3f45aa3561d22c", "filename": "gcc/vmsdbgout.c", "status": "added", "additions": 1669, "deletions": 0, "changes": 1669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0c8d71088734946dd249184acb92f594ba9ddd/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=7a0c8d71088734946dd249184acb92f594ba9ddd", "patch": "@@ -0,0 +1,1669 @@\n+/* Output VMS debug format symbol table information from the GNU C compiler.\n+   Copyright (C) 1997-2001 Free Software Foundation, Inc.\n+   Contributed by Douglas B. Rupp (rupp@gnat.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+\n+#ifdef VMS_DEBUGGING_INFO\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"vmsdbg.h\"\n+#include \"debug.h\"\n+#include \"langhooks.h\"\n+\n+/* Difference in seconds between the VMS Epoch and the Unix Epoch */\n+static const long long vms_epoch_offset = 3506716800ll;\n+\n+/* NOTE: In the comments in this file, many references are made to \"Debug\n+   Symbol Table\".  This term is abbreviated as `DST' throughout the remainder\n+   of this file.  */\n+\n+typedef struct dst_line_info_struct *dst_line_info_ref;\n+\n+/* Each entry in the line_info_table maintains the file and\n+   line number associated with the label generated for that\n+   entry.  The label gives the PC value associated with\n+   the line number entry.  */\n+typedef struct dst_line_info_struct\n+{\n+  unsigned long dst_file_num;\n+  unsigned long dst_line_num;\n+}\n+dst_line_info_entry;\n+\n+typedef struct dst_file_info_struct *dst_file_info_ref;\n+\n+typedef struct dst_file_info_struct\n+{\n+  char *file_name;\n+  unsigned int max_line;\n+  unsigned int listing_line_start;\n+  long long cdt;\n+  long ebk;\n+  short ffb;\n+  char rfo;\n+  char flen;\n+}\n+dst_file_info_entry;\n+\n+/* How to start an assembler comment.  */\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \";#\"\n+#endif\n+\n+/* Maximum size (in bytes) of an artificially generated label.   */\n+#define MAX_ARTIFICIAL_LABEL_BYTES\t30\n+\n+/* Make sure we know the sizes of the various types debug can describe. These\n+   are only defaults.  If the sizes are different for your target, you should\n+   override these values by defining the appropriate symbols in your tm.h\n+   file.  */\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+#ifndef PTR_SIZE\n+#define PTR_SIZE 4 /* Must be 32 bits for VMS debug info */\n+#endif\n+\n+/* Pointer to an structure of filenames referenced by this compilation unit. */\n+static dst_file_info_ref file_info_table;\n+\n+/* Total number of entries in the table (i.e. array) pointed to by\n+   `file_info_table'.  This is the *total* and includes both used and unused\n+   slots.  */\n+static unsigned int file_info_table_allocated;\n+\n+/* Number of entries in the file_info_table which are actually in use.  */\n+static unsigned int file_info_table_in_use;\n+\n+/* Size (in elements) of increments by which we may expand the filename\n+   table.  */\n+#define FILE_TABLE_INCREMENT 64\n+\n+static char **func_table;\n+static unsigned int func_table_allocated;\n+static unsigned int func_table_in_use;\n+#define FUNC_TABLE_INCREMENT 256\n+\n+/* Local pointer to the name of the main input file.  Initialized in\n+   avmdbgout_init.  */\n+static const char *primary_filename;\n+\n+static char *module_producer;\n+static unsigned int module_language;\n+\n+/* A pointer to the base of a table that contains line information\n+   for each source code line in .text in the compilation unit.  */\n+static dst_line_info_ref line_info_table;\n+\n+/* Number of elements currently allocated for line_info_table.  */\n+static unsigned int line_info_table_allocated;\n+\n+/* Number of elements in line_info_table currently in use.  */\n+static unsigned int line_info_table_in_use;\n+\n+/* Size (in elements) of increments by which we may expand line_info_table.  */\n+#define LINE_INFO_TABLE_INCREMENT 1024\n+\n+/* The number of the current function definition for which debugging\n+   information is being generated.  These numbers range from 1 up to the\n+   maximum number of function definitions contained within the current\n+   compilation unit.  These numbers are used to create unique label id's unique\n+   to each function definition.  */\n+static unsigned int current_funcdef_number = 0;\n+\n+/* Forward declarations for functions defined in this file.  */\n+static char *full_name \t\tPARAMS ((const char *));\n+static unsigned int lookup_filename PARAMS ((const char *));\n+static void addr_const_to_string PARAMS ((char *, rtx));\n+static int write_debug_header\tPARAMS ((DST_HEADER *, const char *, int));\n+static int write_debug_addr\tPARAMS ((char *, const char *, int));\n+static int write_debug_data1\tPARAMS ((unsigned int, const char *, int));\n+static int write_debug_data2\tPARAMS ((unsigned int, const char *, int));\n+static int write_debug_data4\tPARAMS ((unsigned long, const char *, int));\n+static int write_debug_data8\tPARAMS ((unsigned long long, const char *,\n+\t\t\t\t\t int));\n+static int write_debug_delta4\tPARAMS ((char *, char *, const char *, int));\n+static int write_debug_string\tPARAMS ((char *, const char *, int));\n+static int write_modbeg\t\tPARAMS ((int));\n+static int write_modend\t\tPARAMS ((int));\n+static int write_rtnbeg\t\tPARAMS ((int, int));\n+static int write_rtnend\t\tPARAMS ((int, int));\n+static int write_pclines\tPARAMS ((int));\n+static int write_srccorr\tPARAMS ((int, dst_file_info_entry, int));\n+static int write_srccorrs\tPARAMS ((int));\n+\n+static void vmsdbgout_init\t\tPARAMS ((const char *));\n+static void vmsdbgout_finish\t\tPARAMS ((const char *));\n+static void vmsdbgout_define\t\tPARAMS ((unsigned int, const char *));\n+static void vmsdbgout_undef\t\tPARAMS ((unsigned int, const char *));\n+static void vmsdbgout_start_source_file PARAMS ((unsigned int, const char *));\n+static void vmsdbgout_end_source_file\tPARAMS ((unsigned int));\n+static void vmsdbgout_begin_block\tPARAMS ((unsigned int, unsigned int));\n+static void vmsdbgout_end_block\t\tPARAMS ((unsigned int, unsigned int));\n+static bool vmsdbgout_ignore_block\tPARAMS ((tree));\n+static void vmsdbgout_source_line\tPARAMS ((unsigned int, const char *));\n+static void vmsdbgout_begin_prologue\tPARAMS ((unsigned int, const char *));\n+static void vmsdbgout_end_epilogue\tPARAMS ((void));\n+static void vmsdbgout_begin_function\tPARAMS ((tree));\n+static void vmsdbgout_decl\t\tPARAMS ((tree));\n+static void vmsdbgout_global_decl\tPARAMS ((tree));\n+static void vmsdbgout_abstract_function PARAMS ((tree));\n+\n+\n+/* The debug hooks structure.  */\n+\n+struct gcc_debug_hooks vmsdbg_debug_hooks\n+= {vmsdbgout_init,\n+   vmsdbgout_finish,\n+   vmsdbgout_define,\n+   vmsdbgout_undef,\n+   vmsdbgout_start_source_file,\n+   vmsdbgout_end_source_file,\n+   vmsdbgout_begin_block,\n+   vmsdbgout_end_block,\n+   vmsdbgout_ignore_block,\n+   vmsdbgout_source_line,\n+   vmsdbgout_begin_prologue,\n+   debug_nothing_int,\t\t/* end_prologue */\n+   vmsdbgout_end_epilogue,\t/* end_epilogue */\n+   vmsdbgout_begin_function,\t/* begin_function */\n+   debug_nothing_int,\t\t/* end_function */\n+   vmsdbgout_decl,\n+   vmsdbgout_global_decl,\n+   debug_nothing_tree,\t\t/* deferred_inline_function */\n+   vmsdbgout_abstract_function,\n+   debug_nothing_rtx\t\t/* label */\n+};\n+\n+/* Definitions of defaults for assembler-dependent names of various\n+   pseudo-ops and section names.\n+   Theses may be overridden in the tm.h file (if necessary) for a particular\n+   assembler.  */\n+#ifdef UNALIGNED_SHORT_ASM_OP\n+#undef UNALIGNED_SHORT_ASM_OP\n+#endif\n+#define UNALIGNED_SHORT_ASM_OP\t\".word\"\n+\n+#ifdef UNALIGNED_INT_ASM_OP\n+#undef UNALIGNED_INT_ASM_OP\n+#endif\n+#define UNALIGNED_INT_ASM_OP\t\".long\"\n+\n+#ifdef UNALIGNED_LONG_ASM_OP\n+#undef UNALIGNED_LONG_ASM_OP\n+#endif\n+#define UNALIGNED_LONG_ASM_OP\t\".long\"\n+\n+#ifdef UNALIGNED_DOUBLE_INT_ASM_OP\n+#undef UNALIGNED_DOUBLE_INT_ASM_OP\n+#endif\n+#define UNALIGNED_DOUBLE_INT_ASM_OP\t\".quad\"\n+\n+#ifdef ASM_BYTE_OP\n+#undef ASM_BYTE_OP\n+#endif\n+#define ASM_BYTE_OP\t\".byte\"\n+\n+#define NUMBYTES(I) ((I) < 256 ? 1 : (I) < 65536 ? 2 : 4)\n+\n+#define NUMBYTES0(I) ((I) < 128 ? 0 : (I) < 65536 ? 2 : 4)\n+\n+#ifndef UNALIGNED_PTR_ASM_OP\n+#define UNALIGNED_PTR_ASM_OP \\\n+  (PTR_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n+#endif\n+\n+#ifndef UNALIGNED_OFFSET_ASM_OP\n+#define UNALIGNED_OFFSET_ASM_OP(OFFSET) \\\n+  (NUMBYTES(OFFSET) == 4 \\\n+   ? UNALIGNED_LONG_ASM_OP \\\n+   : (NUMBYTES(OFFSET) == 2 ? UNALIGNED_SHORT_ASM_OP : ASM_BYTE_OP))\n+#endif\n+\n+/* Pseudo-op for defining a new section.  */\n+#ifndef SECTION_ASM_OP\n+#define SECTION_ASM_OP\t\".section\"\n+#endif\n+\n+/* Definitions of defaults for formats and names of various special\n+   (artificial) labels which may be generated within this file (when the -g\n+   options is used and VMS_DEBUGGING_INFO is in effect.  If necessary, these\n+   may be overridden from within the tm.h file, but typically, overriding these\n+   defaults is unnecessary.  */\n+\n+static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+#ifndef TEXT_END_LABEL\n+#define TEXT_END_LABEL\t\t\"Lvetext\"\n+#endif\n+#ifndef FUNC_BEGIN_LABEL\n+#define FUNC_BEGIN_LABEL\t\"LVFB\"\n+#endif\n+#ifndef FUNC_PROLOG_LABEL\n+#define FUNC_PROLOG_LABEL\t\"LVFP\"\n+#endif\n+#ifndef FUNC_END_LABEL\n+#define FUNC_END_LABEL\t\t\"LVFE\"\n+#endif\n+#ifndef BLOCK_BEGIN_LABEL\n+#define BLOCK_BEGIN_LABEL\t\"LVBB\"\n+#endif\n+#ifndef BLOCK_END_LABEL\n+#define BLOCK_END_LABEL\t\t\"LVBE\"\n+#endif\n+#ifndef LINE_CODE_LABEL\n+#define LINE_CODE_LABEL\t\t\"LVM\"\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_DELTA2\n+#define ASM_OUTPUT_DEBUG_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_SHORT_ASM_OP);\t\t\\\n+\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_DELTA4\n+#define ASM_OUTPUT_DEBUG_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_INT_ASM_OP);\t\t\\\n+\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_ADDR_DELTA\n+#define ASM_OUTPUT_DEBUG_ADDR_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_PTR_ASM_OP);\t\t\\\n+\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_ADDR\n+#define ASM_OUTPUT_DEBUG_ADDR(FILE,LABEL)\t\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t%s\\t\", UNALIGNED_PTR_ASM_OP);\t\t\\\n+\tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_ADDR_CONST\n+#define ASM_OUTPUT_DEBUG_ADDR_CONST(FILE,ADDR)\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t%s\", UNALIGNED_PTR_ASM_OP, (ADDR))\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_DATA1\n+#define ASM_OUTPUT_DEBUG_DATA1(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%x\", ASM_BYTE_OP, (unsigned char) VALUE)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_DATA2\n+#define ASM_OUTPUT_DEBUG_DATA2(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%x\", UNALIGNED_SHORT_ASM_OP, \\\n+\t   (unsigned short) VALUE)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_DATA4\n+#define ASM_OUTPUT_DEBUG_DATA4(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%lx\", UNALIGNED_INT_ASM_OP, (unsigned long) VALUE)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_DATA\n+#define ASM_OUTPUT_DEBUG_DATA(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%lx\", UNALIGNED_OFFSET_ASM_OP(VALUE), VALUE)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_ADDR_DATA\n+#define ASM_OUTPUT_DEBUG_ADDR_DATA(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%lx\", UNALIGNED_PTR_ASM_OP, \\\n+\t   (unsigned long) VALUE)\n+#endif\n+\n+#ifndef ASM_OUTPUT_DEBUG_DATA8\n+#define ASM_OUTPUT_DEBUG_DATA8(FILE,VALUE) \\\n+  fprintf ((FILE), \"\\t%s\\t0x%llx\", UNALIGNED_DOUBLE_INT_ASM_OP, \\\n+                                 (unsigned long long) VALUE)\n+#endif\n+\n+/* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing\n+   newline is produced.  When flag_verbose_asm is asserted, we add commnetary\n+   at the end of the line, so we must avoid output of a newline here.  */\n+#ifndef ASM_OUTPUT_DEBUG_STRING\n+#define ASM_OUTPUT_DEBUG_STRING(FILE,P)\t\\\n+  do {\t\t\t\t\t\\\n+    register int slen = strlen(P);      \\\n+    register char *p = (P);  \t        \\\n+    register int i;\t\t\t\\\n+    fprintf (FILE, \"\\t.ascii \\\"\");\t\\\n+    for (i = 0; i < slen; i++)\t\t\\\n+      {\t\t\t\t\t\\\n+\t  register int c = p[i];\t\\\n+\t  if (c == '\\\"' || c == '\\\\')\t\\\n+\t    putc ('\\\\', FILE);\t\t\\\n+\t  if (c >= ' ' && c < 0177)\t\\\n+\t    putc (c, FILE);\t\t\\\n+\t  else\t\t\t\t\\\n+\t    fprintf (FILE, \"\\\\%o\", c);\t\\\n+      }\t\t\t\t\t\\\n+    fprintf (FILE, \"\\\"\");\t\t\\\n+  }\t\t\t\t\t\\\n+  while (0)\n+#endif\n+\n+/* Convert a reference to the assembler name of a C-level name.  This\n+   macro has the same effect as ASM_OUTPUT_LABELREF, but copies to\n+   a string rather than writing to a file.  */\n+#ifndef ASM_NAME_TO_STRING\n+#define ASM_NAME_TO_STRING(STR, NAME) \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+      if ((NAME)[0] == '*')\t\t\t\t\t\t      \\\n+\tstrcpy (STR, NAME+1);\t\t\t\t\t\t      \\\n+      else\t\t\t\t\t\t\t\t      \\\n+\tstrcpy (STR, NAME);                                                   \\\n+  }                                                                           \\\n+  while (0)\n+#endif\n+\n+\f\n+/* General utility functions.  */\n+\n+/* Convert an integer constant expression into assembler syntax.  Addition and\n+   subtraction are the only arithmetic that may appear in these expressions.\n+   This is an adaptation of output_addr_const in final.c.  Here, the target\n+   of the conversion is a string buffer.  We can't use output_addr_const\n+   directly, because it writes to a file.  */\n+\n+static void\n+addr_const_to_string (str, x)\n+     char *str;\n+     rtx x;\n+{\n+  char buf1[256];\n+  char buf2[256];\n+\n+restart:\n+  str[0] = '\\0';\n+  switch (GET_CODE (x))\n+    {\n+    case PC:\n+      if (flag_pic)\n+\tstrcat (str, \",\");\n+      else\n+\tabort ();\n+      break;\n+\n+    case SYMBOL_REF:\n+      ASM_NAME_TO_STRING (buf1, XSTR (x, 0));\n+      strcat (str, buf1);\n+      break;\n+\n+    case LABEL_REF:\n+      ASM_GENERATE_INTERNAL_LABEL (buf1, \"L\", CODE_LABEL_NUMBER (XEXP (x, 0)));\n+      ASM_NAME_TO_STRING (buf2, buf1);\n+      strcat (str, buf2);\n+      break;\n+\n+    case CODE_LABEL:\n+      ASM_GENERATE_INTERNAL_LABEL (buf1, \"L\", CODE_LABEL_NUMBER (x));\n+      ASM_NAME_TO_STRING (buf2, buf1);\n+      strcat (str, buf2);\n+      break;\n+\n+    case CONST_INT:\n+      sprintf (buf1, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n+      strcat (str, buf1);\n+      break;\n+\n+    case CONST:\n+      /* This used to output parentheses around the expression, but that does \n+         not work on the 386 (either ATT or BSD assembler).  */\n+      addr_const_to_string (buf1, XEXP (x, 0));\n+      strcat (str, buf1);\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) == VOIDmode)\n+\t{\n+\t  /* We can use %d if the number is one word and positive.  */\n+\t  if (CONST_DOUBLE_HIGH (x))\n+\t    sprintf (buf1, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n+\t\t     CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));\n+\t  else if (CONST_DOUBLE_LOW (x) < 0)\n+\t    sprintf (buf1, HOST_WIDE_INT_PRINT_HEX, CONST_DOUBLE_LOW (x));\n+\t  else\n+\t    sprintf (buf1, HOST_WIDE_INT_PRINT_DEC,\n+\t\t     CONST_DOUBLE_LOW (x));\n+\t  strcat (str, buf1);\n+\t}\n+      else\n+\t/* We can't handle floating point constants; PRINT_OPERAND must\n+\t   handle them.  */\n+\toutput_operand_lossage (\"floating constant misused\");\n+      break;\n+\n+    case PLUS:\n+      /* Some assemblers need integer constants to appear last (eg masm).  */\n+      if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n+\t{\n+\t  addr_const_to_string (buf1, XEXP (x, 1));\n+\t  strcat (str, buf1);\n+\t  if (INTVAL (XEXP (x, 0)) >= 0)\n+\t    strcat (str, \"+\");\n+\t  addr_const_to_string (buf1, XEXP (x, 0));\n+\t  strcat (str, buf1);\n+\t}\n+      else\n+\t{\n+\t  addr_const_to_string (buf1, XEXP (x, 0));\n+\t  strcat (str, buf1);\n+\t  if (INTVAL (XEXP (x, 1)) >= 0)\n+\t    strcat (str, \"+\");\n+\t  addr_const_to_string (buf1, XEXP (x, 1));\n+\t  strcat (str, buf1);\n+\t}\n+      break;\n+\n+    case MINUS:\n+      /* Avoid outputting things like x-x or x+5-x, since some assemblers\n+         can't handle that.  */\n+      x = simplify_subtraction (x);\n+      if (GET_CODE (x) != MINUS)\n+\tgoto restart;\n+\n+      addr_const_to_string (buf1, XEXP (x, 0));\n+      strcat (str, buf1);\n+      strcat (str, \"-\");\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) < 0)\n+\t{\n+\t  strcat (str, \"(\");\n+\t  addr_const_to_string (buf1, XEXP (x, 1));\n+\t  strcat (str, buf1);\n+\t  strcat (str, \")\");\n+\t}\n+      else\n+\t{\n+\t  addr_const_to_string (buf1, XEXP (x, 1));\n+\t  strcat (str, buf1);\n+\t}\n+      break;\n+\n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\n+      addr_const_to_string (buf1, XEXP (x, 0));\n+      strcat (str, buf1);\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"invalid expression as operand\");\n+    }\n+}\n+\n+static int\n+write_debug_header (header, comment, dosizeonly)\n+     DST_HEADER *header;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return 4;\n+\n+  ASM_OUTPUT_DEBUG_DATA2 (asm_out_file,\n+\t\t\t  header->dst__header_length.dst_w_length);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s record length\", ASM_COMMENT_START);\n+  fputc ('\\n', asm_out_file);\n+\n+  ASM_OUTPUT_DEBUG_DATA2 (asm_out_file,\n+\t\t\t  header->dst__header_type.dst_w_type);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s record type (%s)\", ASM_COMMENT_START,\n+\t     comment);\n+\n+  fputc ('\\n', asm_out_file);\n+\n+  return 4;\n+}\n+\n+static int\n+write_debug_addr (symbol, comment, dosizeonly)\n+     char *symbol;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return PTR_SIZE;\n+\n+  ASM_OUTPUT_DEBUG_ADDR (asm_out_file, symbol);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+  fputc ('\\n', asm_out_file);\n+  \n+  return PTR_SIZE;\n+}\n+\n+static int\n+write_debug_data1 (data1, comment, dosizeonly)\n+     unsigned int data1;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return 1;\n+\n+  ASM_OUTPUT_DEBUG_DATA1 (asm_out_file, data1);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+  fputc ('\\n', asm_out_file);\n+  \n+  return 1;\n+}\n+\n+static int\n+write_debug_data2 (data2, comment, dosizeonly)\n+     unsigned int data2;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return 2;\n+\n+  ASM_OUTPUT_DEBUG_DATA2 (asm_out_file, data2);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+  fputc ('\\n', asm_out_file);\n+  \n+  return 2;\n+}\n+\n+static int\n+write_debug_data4 (data4, comment, dosizeonly)\n+     unsigned long data4;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return 4;\n+\n+  ASM_OUTPUT_DEBUG_DATA4 (asm_out_file, data4);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+  fputc ('\\n', asm_out_file);\n+  \n+  return 4;\n+}\n+\n+static int\n+write_debug_data8 (data8, comment, dosizeonly)\n+     unsigned long long data8;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return 8;\n+\n+  ASM_OUTPUT_DEBUG_DATA8 (asm_out_file, data8);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+  fputc ('\\n', asm_out_file);\n+  \n+  return 8;\n+}\n+\n+static int\n+write_debug_delta4 (label1, label2, comment, dosizeonly)\n+     char *label1;\n+     char *label2;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return 4;\n+\n+  ASM_OUTPUT_DEBUG_DELTA4(asm_out_file, label1, label2);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+  fputc ('\\n', asm_out_file);\n+  \n+  return 4;\n+}\n+\n+static int\n+write_debug_string (string, comment, dosizeonly)\n+     char *string;\n+     const char *comment;\n+     int dosizeonly;\n+{\n+  if (dosizeonly)\n+    return strlen (string);\n+\n+  ASM_OUTPUT_DEBUG_STRING (asm_out_file, string);\n+  if (flag_verbose_asm)\n+    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+  fputc ('\\n', asm_out_file);\n+  \n+  return strlen (string);\n+}\n+\n+static int\n+write_modbeg (dosizeonly)\n+     int dosizeonly;\n+{\n+\n+  DST_MODULE_BEGIN modbeg;\n+  DST_MB_TRLR mb_trlr;\n+  int i;\n+  char *module_name, *m;\n+  int modnamelen;\n+  int prodnamelen;\n+  int totsize = 0;\n+\n+  /* Assumes primary filename has Unix syntax file spec. */\n+  module_name = xstrdup (basename ((char *) primary_filename));\n+\n+  m = strrchr (module_name, '.');\n+  if (m)\n+    *m = 0;\n+\n+  modnamelen = strlen (module_name);\n+  for (i = 0; i < modnamelen; i++)\n+    module_name[i] = TOUPPER (module_name[i]);\n+\n+  prodnamelen = strlen (module_producer);\n+\n+  modbeg.dst_a_modbeg_header.dst__header_length.dst_w_length\n+    = DST_K_MODBEG_SIZE + modnamelen + DST_K_MB_TRLR_SIZE + prodnamelen - 1;\n+  modbeg.dst_a_modbeg_header.dst__header_type.dst_w_type = DST_K_MODBEG;\n+  modbeg.dst_b_modbeg_flags.dst_v_modbeg_hide = 0;\n+  modbeg.dst_b_modbeg_flags.dst_v_modbeg_version = 1;\n+  modbeg.dst_b_modbeg_flags.dst_v_modbeg_unused = 0;\n+  modbeg.dst_b_modbeg_unused = 0;\n+  modbeg.dst_l_modbeg_language = module_language;\n+  modbeg.dst_w_version_major = DST_K_VERSION_MAJOR;\n+  modbeg.dst_w_version_minor = DST_K_VERSION_MINOR;\n+  modbeg.dst_b_modbeg_name = strlen (module_name);\n+\n+  mb_trlr.dst_b_compiler = strlen (module_producer);\n+\n+  totsize += write_debug_header (&modbeg.dst_a_modbeg_header,\n+\t\t\t\t \"modbeg\", dosizeonly);\n+  totsize += write_debug_data1 (*((char *) &modbeg.dst_b_modbeg_flags),\n+\t\t\t\t\"flags\", dosizeonly);\n+  totsize += write_debug_data1 (modbeg.dst_b_modbeg_unused,\n+\t\t\t\t\"unused\", dosizeonly);\n+  totsize += write_debug_data4 (modbeg.dst_l_modbeg_language,\n+\t\t\t\t\"language\", dosizeonly);\n+  totsize += write_debug_data2 (modbeg.dst_w_version_major,\n+\t\t\t\t\"DST major version\", dosizeonly);\n+  totsize += write_debug_data2 (modbeg.dst_w_version_minor,\n+\t\t\t\t\"DST minor version\", dosizeonly);\n+  totsize += write_debug_data1 (modbeg.dst_b_modbeg_name,\n+\t\t\t\t\"length of module name\", dosizeonly);\n+  totsize += write_debug_string (module_name, \"module name\", dosizeonly);\n+  totsize += write_debug_data1 (mb_trlr.dst_b_compiler,\n+\t\t\t\t\"length of compiler name\", dosizeonly);\n+  totsize += write_debug_string (module_producer, \"compiler name\", dosizeonly);\n+\n+  return totsize;\n+}\n+\n+static int\n+write_modend (dosizeonly)\n+     int dosizeonly;\n+{\n+  DST_MODULE_END modend;\n+  int totsize = 0;\n+\n+  modend.dst_a_modend_header.dst__header_length.dst_w_length\n+   = DST_K_MODEND_SIZE - 1;\n+  modend.dst_a_modend_header.dst__header_type.dst_w_type = DST_K_MODEND;\n+\n+  totsize += write_debug_header (&modend.dst_a_modend_header, \"modend\",\n+\t\t\t\t dosizeonly);\n+\n+  return totsize;\n+}\n+\n+static int\n+write_rtnbeg (rtnnum, dosizeonly)\n+     int rtnnum;\n+     int dosizeonly;\n+{\n+  char *rtnname;\n+  int rtnnamelen, rtnentrynamelen;\n+  char *rtnentryname;\n+  int totsize = 0;\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  DST_ROUTINE_BEGIN rtnbeg;\n+  DST_PROLOG prolog;\n+\n+  rtnname = func_table[rtnnum];\n+  rtnnamelen = strlen (rtnname);\n+  rtnentrynamelen = rtnnamelen + 4; /* \"..en\" */\n+  rtnentryname = (char *) xmalloc (rtnentrynamelen + 1);\n+  strcpy (rtnentryname, rtnname);\n+  strcat (rtnentryname, \"..en\");\n+\n+  if (!strcmp (rtnname, \"main\"))\n+    {\n+      DST_HEADER header;\n+      const char *go = \"TRANSFER$BREAK$GO\";\n+\n+      /* This command isn't documented in DSTRECORDS, so it's made to\n+\t look like what DEC C does */\n+\n+      /* header size - 1st byte + flag byte + STO_LW size\n+\t + string count byte + string length */\n+      header.dst__header_length.dst_w_length\n+        = DST_K_DST_HEADER_SIZE - 1 + 1 + 4 + 1 + strlen (go);\n+      header.dst__header_type.dst_w_type = 0x17;\n+\n+      totsize += write_debug_header (&header, \"transfer\", dosizeonly);\n+\n+      /* I think this is a flag byte, but I don't know what this flag means */\n+      totsize += write_debug_data1 (0x1, \"flags ???\", dosizeonly);\n+\n+      /* Routine Begin PD Address */\n+      totsize += write_debug_addr (rtnname, \"main procedure descriptor\",\n+\t\t\t\t   dosizeonly);\n+      totsize += write_debug_data1 (strlen (go), \"length of main_name\",\n+\t\t\t\t    dosizeonly);\n+      totsize += write_debug_string ((char *) go, \"main name\", dosizeonly);\n+    }\n+\n+  /* The header length never includes the length byte */\n+  rtnbeg.dst_a_rtnbeg_header.dst__header_length.dst_w_length\n+   = DST_K_RTNBEG_SIZE + rtnnamelen - 1;\n+  rtnbeg.dst_a_rtnbeg_header.dst__header_type.dst_w_type = DST_K_RTNBEG;\n+  rtnbeg.dst_b_rtnbeg_flags.dst_v_rtnbeg_unused = 0;\n+  rtnbeg.dst_b_rtnbeg_flags.dst_v_rtnbeg_unalloc = 0;\n+  rtnbeg.dst_b_rtnbeg_flags.dst_v_rtnbeg_prototype = 0;\n+  rtnbeg.dst_b_rtnbeg_flags.dst_v_rtnbeg_inlined = 0;\n+  rtnbeg.dst_b_rtnbeg_flags.dst_v_rtnbeg_no_call = 1;\n+  rtnbeg.dst_b_rtnbeg_name = rtnnamelen;\n+\n+  totsize += write_debug_header (&rtnbeg.dst_a_rtnbeg_header, \"rtnbeg\",\n+\t\t\t\t dosizeonly);\n+  totsize += write_debug_data1 (*((char *) &rtnbeg.dst_b_rtnbeg_flags),\n+\t\t\t\t\"flags\", dosizeonly);\n+\n+  /* Routine Begin Address */\n+  totsize += write_debug_addr (rtnentryname, \"routine entry name\", dosizeonly);\n+\n+  /* Routine Begin PD Address */\n+  totsize += write_debug_addr (rtnname, \"routine procedure descriptor\",\n+\t\t\t       dosizeonly);\n+\n+  /* Routine Begin Name */\n+  totsize += write_debug_data1 (rtnbeg.dst_b_rtnbeg_name,\n+\t\t\t\t\"length of routine name\", dosizeonly);\n+\n+  totsize += write_debug_string (rtnname, \"routine name\", dosizeonly);\n+\n+  free (rtnentryname);\n+\n+  if (debug_info_level > DINFO_LEVEL_TERSE)\n+    {\n+      prolog.dst_a_prolog_header.dst__header_length.dst_w_length\n+\t= DST_K_PROLOG_SIZE - 1;\n+      prolog.dst_a_prolog_header.dst__header_type.dst_w_type = DST_K_PROLOG;\n+\n+      totsize += write_debug_header (&prolog.dst_a_prolog_header, \"prolog\",\n+\t\t\t\t     dosizeonly);\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label, FUNC_PROLOG_LABEL, rtnnum);\n+      totsize += write_debug_addr (label, \"prolog breakpoint addr\",\n+\t\t\t\t   dosizeonly);\n+    }\n+\n+  return totsize;\n+}\n+\n+static int\n+write_rtnend (rtnnum, dosizeonly)\n+     int rtnnum;\n+     int dosizeonly;\n+{\n+  DST_ROUTINE_END rtnend;\n+  char label1[MAX_ARTIFICIAL_LABEL_BYTES];\n+  char label2[MAX_ARTIFICIAL_LABEL_BYTES];\n+  int totsize;\n+\n+  totsize = 0;\n+\n+  rtnend.dst_a_rtnend_header.dst__header_length.dst_w_length\n+   = DST_K_RTNEND_SIZE - 1;\n+  rtnend.dst_a_rtnend_header.dst__header_type.dst_w_type = DST_K_RTNEND;\n+  rtnend.dst_b_rtnend_unused = 0;\n+  rtnend.dst_l_rtnend_size = 0; /* Calculated below.  */\n+\n+  totsize += write_debug_header (&rtnend.dst_a_rtnend_header, \"rtnend\",\n+\t\t\t\t dosizeonly);\n+  totsize += write_debug_data1 (rtnend.dst_b_rtnend_unused, \"unused\",\n+\t\t\t\tdosizeonly);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label1, FUNC_BEGIN_LABEL, rtnnum);\n+  ASM_GENERATE_INTERNAL_LABEL (label2, FUNC_END_LABEL, rtnnum);\n+  totsize += write_debug_delta4 (label2, label1, \"routine size\", dosizeonly);\n+\n+  return totsize;\n+}\n+\n+#define K_DELTA_PC(I) \\\n+ ((I) < 128 ? -(I) : (I) < 65536 ? DST_K_DELTA_PC_W : DST_K_DELTA_PC_L)\n+\n+#define K_SET_LINUM(I) \\\n+ ((I) < 256 ? DST_K_SET_LINUM_B \\\n+  : (I) < 65536 ? DST_K_SET_LINUM : DST_K_SET_LINUM_L)\n+\n+#define K_INCR_LINUM(I) \\\n+ ((I) < 256 ? DST_K_INCR_LINUM \\\n+  : (I) < 65536 ? DST_K_INCR_LINUM_W : DST_K_INCR_LINUM_L)\n+\n+static int\n+write_pclines (dosizeonly)\n+     int dosizeonly;\n+{\n+  unsigned i;\n+  int fn;\n+  int ln, lastln;\n+  int linestart = 0;\n+  int max_line;\n+  DST_LINE_NUM_HEADER line_num;\n+  DST_PCLINE_COMMANDS pcline;\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  char lastlabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+  int totsize = 0;\n+  char buff[256];\n+\n+  max_line = file_info_table[1].max_line;\n+  file_info_table[1].listing_line_start = linestart;\n+  linestart = linestart + ((max_line / 100000) + 1) * 100000;\n+\n+  for (i = 2; i < file_info_table_in_use; i++)\n+    {\n+      max_line = file_info_table[i].max_line;\n+      file_info_table[i].listing_line_start = linestart;\n+      linestart = linestart + ((max_line / 10000) + 1) * 10000;\n+    }\n+\n+  /* Set starting address to beginning of text section */\n+  line_num.dst_a_line_num_header.dst__header_length.dst_w_length = 8;\n+  line_num.dst_a_line_num_header.dst__header_type.dst_w_type = DST_K_LINE_NUM;\n+  pcline.dst_b_pcline_command = DST_K_SET_ABS_PC;\n+\n+  totsize += write_debug_header (&line_num.dst_a_line_num_header,\n+\t\t\t\t \"line_num\", dosizeonly);\n+  totsize += write_debug_data1 (pcline.dst_b_pcline_command,\n+\t\t\t\t\"line_num (SET ABS PC)\", dosizeonly);\n+\n+  if (dosizeonly)\n+    totsize += 4;\n+  else\n+    {\n+      ASM_OUTPUT_DEBUG_ADDR (asm_out_file, TEXT_SECTION_ASM_OP);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s line_num\", ASM_COMMENT_START);\n+      fputc ('\\n', asm_out_file);\n+    }\n+\n+  fn = line_info_table[1].dst_file_num;\n+  ln = (file_info_table[fn].listing_line_start\n+\t+ line_info_table[1].dst_line_num);\n+  line_num.dst_a_line_num_header.dst__header_length.dst_w_length = 4 + 4;\n+  pcline.dst_b_pcline_command = DST_K_SET_LINUM_L;\n+\n+  totsize += write_debug_header (&line_num.dst_a_line_num_header,\n+\t\t\t\t \"line_num\", dosizeonly);\n+  totsize += write_debug_data1 (pcline.dst_b_pcline_command,\n+\t\t\t\t\"line_num (SET LINUM LONG)\", dosizeonly);\n+\n+  sprintf (buff, \"line_num (%d)\", ln - 1);\n+  totsize += write_debug_data4 (ln - 1, buff, dosizeonly);\n+\n+  lastln = ln;\n+  strcpy (lastlabel, TEXT_SECTION_ASM_OP);\n+  for (i = 1; i < line_info_table_in_use; i++)\n+    {\n+      int extrabytes;\n+\n+      fn = line_info_table[i].dst_file_num;\n+      ln = (file_info_table[fn].listing_line_start\n+\t    + line_info_table[i].dst_line_num);\n+\n+      if (ln - lastln > 1)\n+\textrabytes = 5; /* NUMBYTES (ln - lastln - 1) + 1; */\n+      else if (ln <= lastln)\n+\textrabytes = 5; /* NUMBYTES (ln - 1) + 1; */\n+      else\n+\textrabytes = 0;\n+\n+      line_num.dst_a_line_num_header.dst__header_length.dst_w_length\n+\t= 8 + extrabytes;\n+\n+      totsize += write_debug_header\n+\t(&line_num.dst_a_line_num_header, \"line_num\", dosizeonly);\n+\n+      if (ln - lastln > 1)\n+\t{\n+\t  int lndif = ln - lastln - 1;\n+\n+\t  /* K_INCR_LINUM (lndif); */\n+\t  pcline.dst_b_pcline_command = DST_K_INCR_LINUM_L;\n+\n+\t  totsize += write_debug_data1 (pcline.dst_b_pcline_command,\n+\t\t\t\t\t\"line_num (INCR LINUM LONG)\",\n+\t\t\t\t\tdosizeonly);\n+\n+\t  sprintf (buff, \"line_num (%d)\", lndif);\n+\t  totsize += write_debug_data4 (lndif, buff, dosizeonly);\n+\t}\n+      else if (ln <= lastln)\n+\t{\n+\t  /* K_SET_LINUM (ln-1); */\n+\t  pcline.dst_b_pcline_command = DST_K_SET_LINUM_L;\n+\n+\t  totsize += write_debug_data1 (pcline.dst_b_pcline_command,\n+\t\t\t\t\t\"line_num (SET LINUM LONG)\",\n+\t\t\t\t\tdosizeonly);\n+\n+\t  sprintf (buff, \"line_num (%d)\", ln - 1);\n+\t  totsize += write_debug_data4 (ln - 1, buff, dosizeonly);\n+\t}\n+\n+      pcline.dst_b_pcline_command = DST_K_DELTA_PC_L;\n+\n+      totsize += write_debug_data1 (pcline.dst_b_pcline_command,\n+\t\t\t\t    \"line_num (DELTA PC LONG)\", dosizeonly);\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label, LINE_CODE_LABEL, i);\n+      totsize += write_debug_delta4 (label, lastlabel, \"increment line_num\",\n+\t\t\t\t     dosizeonly);\n+\n+      lastln = ln;\n+      strcpy (lastlabel, label);\n+    }\n+\n+  return totsize;\n+}\n+\n+static int\n+write_srccorr (fileid, file_info_entry, dosizeonly)\n+     int fileid;\n+     dst_file_info_entry file_info_entry;\n+     int dosizeonly;\n+{\n+  int src_command_size;\n+  int linesleft = file_info_entry.max_line;\n+  int linestart = file_info_entry.listing_line_start;\n+  int flen = file_info_entry.flen;\n+  int linestodo = 0;\n+  DST_SOURCE_CORR src_header;\n+  DST_SRC_COMMAND src_command;\n+  DST_SRC_COMMAND src_command_sf;\n+  DST_SRC_COMMAND src_command_sl;\n+  DST_SRC_COMMAND src_command_sr;\n+  DST_SRC_COMMAND src_command_dl;\n+  DST_SRC_CMDTRLR src_cmdtrlr;\n+  char buff[256];\n+  int totsize = 0;\n+\n+  if (fileid == 1)\n+    {\n+      src_header.dst_a_source_corr_header.dst__header_length.dst_w_length\n+\t= DST_K_SOURCE_CORR_HEADER_SIZE + 1 - 1;\n+      src_header.dst_a_source_corr_header.dst__header_type.dst_w_type\n+\t= DST_K_SOURCE;\n+      src_command.dst_b_src_command = DST_K_SRC_FORMFEED;\n+\n+      totsize += write_debug_header (&src_header.dst_a_source_corr_header,\n+\t\t\t\t     \"source corr\", dosizeonly);\n+\n+      totsize += write_debug_data1 (src_command.dst_b_src_command,\n+\t\t\t\t    \"source_corr (SRC FORMFEED)\",\n+\t\t\t\t    dosizeonly);\n+    }\n+\n+  src_command_size\n+    = DST_K_SRC_COMMAND_SIZE + flen + DST_K_SRC_CMDTRLR_SIZE;\n+  src_command.dst_b_src_command = DST_K_SRC_DECLFILE;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_length\n+    = src_command_size - 2;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_flags = 0;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_w_src_df_fileid\n+    = fileid;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_q_src_df_rms_cdt\n+    = file_info_entry.cdt;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_l_src_df_rms_ebk\n+    = file_info_entry.ebk;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_w_src_df_rms_ffb\n+    = file_info_entry.ffb;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_rms_rfo\n+    = file_info_entry.rfo;\n+  src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_filename\n+    = file_info_entry.flen;\n+\n+  src_header.dst_a_source_corr_header.dst__header_length.dst_w_length\n+    = DST_K_SOURCE_CORR_HEADER_SIZE + src_command_size - 1;\n+  src_header.dst_a_source_corr_header.dst__header_type.dst_w_type\n+    = DST_K_SOURCE;\n+\n+  src_cmdtrlr.dst_b_src_df_libmodname = 0;\n+  \n+  totsize += write_debug_header (&src_header.dst_a_source_corr_header,\n+\t\t\t\t \"source corr\", dosizeonly);\n+  totsize += write_debug_data1 (src_command.dst_b_src_command,\n+\t\t\t\t\"source_corr (DECL SRC FILE)\", dosizeonly);\n+  totsize += write_debug_data1\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_length,\n+     \"source_corr (length)\", dosizeonly);\n+\n+  totsize += write_debug_data1\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_flags,\n+     \"source_corr (flags)\", dosizeonly);\n+\n+  totsize += write_debug_data2\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_w_src_df_fileid,\n+     \"source_corr (fileid)\", dosizeonly);\n+\n+  totsize += write_debug_data8\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_q_src_df_rms_cdt,\n+     \"source_corr (creation date)\", dosizeonly);\n+  \n+  totsize += write_debug_data4\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_l_src_df_rms_ebk,\n+     \"source_corr (EOF block number)\", dosizeonly);\n+\n+  totsize += write_debug_data2\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_w_src_df_rms_ffb,\n+     \"source_corr (first free byte)\", dosizeonly);\n+\n+  totsize += write_debug_data1\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_rms_rfo,\n+     \"source_corr (record and file organization)\", dosizeonly);\n+\n+  totsize += write_debug_data1\n+    (src_command.dst_a_src_cmd_fields.dst_a_src_decl_src.dst_b_src_df_filename,\n+     \"source_corr (filename length)\", dosizeonly);\n+\n+  totsize += write_debug_string (file_info_entry.file_name,\n+\t\t\t\t \"source file name\", dosizeonly);\n+  totsize += write_debug_data1 (src_cmdtrlr.dst_b_src_df_libmodname,\n+\t\t\t\t\"source_corr (libmodname)\", dosizeonly);\n+\n+  src_command_sf.dst_b_src_command = DST_K_SRC_SETFILE;\n+  src_command_sf.dst_a_src_cmd_fields.dst_w_src_unsword = fileid;\n+\n+  src_command_sr.dst_b_src_command = DST_K_SRC_SETREC_W;\n+  src_command_sr.dst_a_src_cmd_fields.dst_w_src_unsword = 1;\n+\n+  src_command_sl.dst_b_src_command = DST_K_SRC_SETLNUM_L;\n+  src_command_sl.dst_a_src_cmd_fields.dst_l_src_unslong = linestart + 1;\n+\n+  src_command_dl.dst_b_src_command = DST_K_SRC_DEFLINES_W;\n+\n+  if (linesleft > 65534)\n+    linesleft = linesleft - 65534, linestodo = 65534;\n+  else\n+    linestodo = linesleft, linesleft = 0;\n+\n+  src_command_dl.dst_a_src_cmd_fields.dst_w_src_unsword = linestodo;\n+\n+  src_header.dst_a_source_corr_header.dst__header_length.dst_w_length\n+    = DST_K_SOURCE_CORR_HEADER_SIZE + 3 + 3 + 5 + 3 - 1;\n+  src_header.dst_a_source_corr_header.dst__header_type.dst_w_type\n+    = DST_K_SOURCE;\n+\n+  totsize += write_debug_header (&src_header.dst_a_source_corr_header,\n+\t\t\t\t \"source corr\", dosizeonly);\n+\n+  totsize += write_debug_data1 (src_command_sf.dst_b_src_command,\n+\t\t\t\t\"source_corr (src setfile)\", dosizeonly);\n+\n+  totsize += write_debug_data2\n+    (src_command_sf.dst_a_src_cmd_fields.dst_w_src_unsword,\n+     \"source_corr (fileid)\", dosizeonly);\n+\n+  totsize += write_debug_data1 (src_command_sr.dst_b_src_command,\n+\t\t\t\t\"source_corr (setrec)\", dosizeonly);\n+\n+  totsize += write_debug_data2\n+    (src_command_sr.dst_a_src_cmd_fields.dst_w_src_unsword,\n+     \"source_corr (recnum)\", dosizeonly);\n+\n+  totsize += write_debug_data1 (src_command_sl.dst_b_src_command,\n+\t\t\t\t\"source_corr (setlnum)\", dosizeonly);\n+\n+  totsize += write_debug_data4\n+    (src_command_sl.dst_a_src_cmd_fields.dst_l_src_unslong,\n+     \"source_corr (linenum)\", dosizeonly);\n+\n+  totsize += write_debug_data1 (src_command_dl.dst_b_src_command,\n+\t\t\t\t\"source_corr (deflines)\", dosizeonly);\n+\n+  sprintf (buff, \"source_corr (%d)\",\n+\t   src_command_dl.dst_a_src_cmd_fields.dst_w_src_unsword);\n+  totsize += write_debug_data2\n+    (src_command_dl.dst_a_src_cmd_fields.dst_w_src_unsword, buff, dosizeonly);\n+\n+  while (linesleft > 0)\n+    {\n+      src_header.dst_a_source_corr_header.dst__header_length.dst_w_length\n+\t= DST_K_SOURCE_CORR_HEADER_SIZE + 3 - 1;\n+      src_header.dst_a_source_corr_header.dst__header_type.dst_w_type\n+\t= DST_K_SOURCE;\n+      src_command_dl.dst_b_src_command = DST_K_SRC_DEFLINES_W;\n+\n+      if (linesleft > 65534)\n+\tlinesleft = linesleft - 65534, linestodo = 65534;\n+      else\n+\tlinestodo = linesleft, linesleft = 0;\n+\n+      src_command_dl.dst_a_src_cmd_fields.dst_w_src_unsword = linestodo;\n+\n+      totsize += write_debug_header (&src_header.dst_a_source_corr_header,\n+\t\t\t\t     \"source corr\", dosizeonly);\n+      totsize += write_debug_data1 (src_command_dl.dst_b_src_command,\n+\t\t\t\t    \"source_corr (deflines)\", dosizeonly);\n+      sprintf (buff, \"source_corr (%d)\",\n+\t       src_command_dl.dst_a_src_cmd_fields.dst_w_src_unsword);\n+      totsize += write_debug_data2\n+\t(src_command_dl.dst_a_src_cmd_fields.dst_w_src_unsword,\n+\t buff, dosizeonly);\n+    }\n+\n+  return totsize;\n+}\n+\n+static int\n+write_srccorrs (dosizeonly)\n+     int dosizeonly;\n+{\n+  unsigned int i;\n+  int totsize = 0;\n+\n+  for (i = 1; i < file_info_table_in_use; i++)\n+    totsize += write_srccorr (i, file_info_table[i], dosizeonly);\n+\n+  return totsize;\n+}     \n+\n+\f\n+/* Output a marker (i.e. a label) for the beginning of a function, before\n+   the prologue.  */\n+\n+static void\n+vmsdbgout_begin_prologue (line, file)\n+     unsigned int line;\n+     const char *file;\n+{\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.begin_prologue) (line, file);\n+\n+  if (debug_info_level > DINFO_LEVEL_NONE)\n+    {\n+      current_funcdef_number++;\n+      ASM_GENERATE_INTERNAL_LABEL (label, FUNC_BEGIN_LABEL,\n+\t\t\t\t   current_funcdef_number);\n+      ASM_OUTPUT_LABEL (asm_out_file, label);\n+    }\n+}\n+\n+/* Output a marker (i.e. a label) for the beginning of a function, after\n+   the prologue.  */\n+\n+void\n+vmsdbgout_after_prologue ()\n+{\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  if (debug_info_level > DINFO_LEVEL_TERSE)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (label, FUNC_PROLOG_LABEL,\n+\t\t\t\t   current_funcdef_number);\n+      ASM_OUTPUT_LABEL (asm_out_file, label);\n+    }\n+}\n+\n+/* Output a marker (i.e. a label) for the absolute end of the generated code\n+   for a function definition.  This gets called *after* the epilogue code has\n+   been generated.  */\n+\n+static void\n+vmsdbgout_end_epilogue ()\n+{\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.end_epilogue) ();\n+\n+  if (debug_info_level > DINFO_LEVEL_NONE)\n+    {\n+      /* Output a label to mark the endpoint of the code generated for this\n+         function.        */\n+      ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL,\n+\t\t\t\t   current_funcdef_number);\n+      ASM_OUTPUT_LABEL (asm_out_file, label);\n+    }\n+}\n+\n+/* Output a marker (i.e. a label) for the beginning of the generated code for\n+   a lexical block.  */\n+\n+static void\n+vmsdbgout_begin_block (line, blocknum)\n+     register unsigned line;\n+     register unsigned blocknum;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.begin_block) (line, blocknum);\n+\n+  if (debug_info_level > DINFO_LEVEL_TERSE)\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);\n+}\n+\n+/* Output a marker (i.e. a label) for the end of the generated code for a\n+   lexical block.  */\n+\n+static void\n+vmsdbgout_end_block (line, blocknum)\n+     register unsigned line;\n+     register unsigned blocknum;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.end_block) (line, blocknum);\n+\n+  if (debug_info_level > DINFO_LEVEL_TERSE)\n+    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BLOCK_END_LABEL, blocknum);\n+}\n+\n+static bool\n+vmsdbgout_ignore_block (block)\n+     tree block;\n+{\n+  bool retval = 0;\n+\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    retval = (*dwarf2_debug_hooks.ignore_block) (block);\n+\n+  return retval;\n+}\n+\n+static void\n+vmsdbgout_begin_function (decl)\n+     tree decl;\n+{\n+  const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.begin_function) (decl);\n+\n+  if (func_table_in_use == func_table_allocated)\n+    {\n+      func_table_allocated += FUNC_TABLE_INCREMENT;\n+      func_table = (char **) xrealloc (func_table,\n+\t\t\t\t       func_table_allocated * sizeof (char *));\n+    }\n+\n+  /* Add the new entry to the end of the function name table.  */\n+  func_table[func_table_in_use++] = xstrdup (name);\n+}\n+\n+static char fullname_buff [4096];\n+\n+static char *\n+full_name (filename)\n+     const char *filename;\n+{\n+#ifdef VMS\n+  FILE *fp = fopen (filename, \"r\");\n+\n+  fgetname (fp, fullname_buff, 1);\n+  fclose (fp);\n+#else\n+  getcwd (fullname_buff, sizeof (fullname_buff));\n+\n+  strcat (fullname_buff, \"/\");\n+  strcat (fullname_buff, filename);\n+\n+  /* ??? Insert hairy code here to translate Unix style file specification\n+     to VMS style.  */\n+#endif\n+\n+  return fullname_buff;\n+}\n+\n+/* Lookup a filename (in the list of filenames that we know about here in\n+   vmsdbgout.c) and return its \"index\".  The index of each (known) filename is\n+   just a unique number which is associated with only that one filename.  We\n+   need such numbers for the sake of generating labels (in the .debug_sfnames\n+   section) and references to those files numbers (in the .debug_srcinfo\n+   and.debug_macinfo sections).  If the filename given as an argument is not\n+   found in our current list, add it to the list and assign it the next\n+   available unique index number.  In order to speed up searches, we remember\n+   the index of the filename was looked up last.  This handles the majority of\n+   all searches.  */\n+\n+static unsigned int\n+lookup_filename (file_name)\n+     const char *file_name;\n+{\n+  static unsigned int last_file_lookup_index = 0;\n+  register char *fn;\n+  register unsigned i;\n+  char *fnam;\n+  long long cdt;\n+  long ebk;\n+  short ffb;\n+  char rfo;\n+  char flen;\n+  struct stat statbuf;\n+\n+  if (stat (file_name, &statbuf) == 0)\n+    {\n+      cdt = 10000000 * (statbuf.st_ctime + vms_epoch_offset);\n+      ebk = statbuf.st_size / 512 + 1;\n+      ffb = statbuf.st_size - ((statbuf.st_size / 512) * 512);\n+#ifdef VMS\n+      rfo = statbuf.st_fab_rfm;\n+#else\n+      /* Assume stream LF type file */\n+      rfo = 2;\n+#endif\n+      fnam = full_name (file_name);\n+      flen = strlen (fnam);\n+    }\n+  else\n+    {\n+      cdt = 0;\n+      ebk = 0;\n+      ffb = 0;\n+      rfo = 0;\n+      fnam = (char *) 0;\n+      flen = 0;\n+    }\n+\n+  /* Check to see if the file name that was searched on the previous call\n+     matches this file name. If so, return the index.  */\n+  if (last_file_lookup_index != 0)\n+    {\n+      fn = file_info_table[last_file_lookup_index].file_name;\n+      if (strcmp (fnam, fn) == 0)\n+\treturn last_file_lookup_index;\n+    }\n+\n+  /* Didn't match the previous lookup, search the table */\n+  for (i = 1; i < file_info_table_in_use; ++i)\n+    {\n+      fn = file_info_table[i].file_name;\n+      if (strcmp (fnam, fn) == 0)\n+\t{\n+\t  last_file_lookup_index = i;\n+\t  return i;\n+\t}\n+    }\n+\n+  /* Prepare to add a new table entry by making sure there is enough space in \n+     the table to do so.  If not, expand the current table.  */\n+  if (file_info_table_in_use == file_info_table_allocated)\n+    {\n+\n+      file_info_table_allocated += FILE_TABLE_INCREMENT;\n+      file_info_table\n+\t= (dst_file_info_ref) xrealloc (file_info_table,\n+\t\t\t\t\t(file_info_table_allocated\n+\t\t\t\t\t * sizeof (dst_file_info_entry)));\n+    }\n+\n+  /* Add the new entry to the end of the filename table.  */\n+  file_info_table[file_info_table_in_use].file_name = xstrdup (fnam);\n+  file_info_table[file_info_table_in_use].max_line = 0;\n+  file_info_table[file_info_table_in_use].cdt = cdt;\n+  file_info_table[file_info_table_in_use].ebk = ebk;\n+  file_info_table[file_info_table_in_use].ffb = ffb;\n+  file_info_table[file_info_table_in_use].rfo = rfo;\n+  file_info_table[file_info_table_in_use].flen = flen;\n+\n+  last_file_lookup_index = file_info_table_in_use++;\n+  return last_file_lookup_index;\n+}\n+\n+/* Output a label to mark the beginning of a source code line entry\n+   and record information relating to this source line, in\n+   'line_info_table' for later output of the .debug_line section.  */\n+\n+static void\n+vmsdbgout_source_line (line, filename)\n+     register unsigned line;\n+     register const char *filename;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.source_line) (line, filename);\n+\n+  if (debug_info_level >= DINFO_LEVEL_TERSE)\n+    {\n+      dst_line_info_ref line_info;\n+\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, LINE_CODE_LABEL,\n+\t\t\t\t line_info_table_in_use);\n+\n+      /* Expand the line info table if necessary.  */\n+      if (line_info_table_in_use == line_info_table_allocated)\n+\t{\n+\t  line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n+\t  line_info_table\n+\t    = (dst_line_info_ref) xrealloc (line_info_table,\n+\t\t\t\t\t    (line_info_table_allocated\n+\t\t\t\t\t     * sizeof (dst_line_info_entry)));\n+\t  }\n+\n+      /* Add the new entry at the end of the line_info_table.  */\n+      line_info = &line_info_table[line_info_table_in_use++];\n+      line_info->dst_file_num = lookup_filename (filename);\n+      line_info->dst_line_num = line;\n+      if (line > file_info_table[line_info->dst_file_num].max_line)\n+\tfile_info_table[line_info->dst_file_num].max_line = line;\n+    }\n+}\n+\n+/* Record the beginning of a new source file, for later output.\n+   At present, unimplemented.  */\n+\n+static void\n+vmsdbgout_start_source_file (lineno, filename)\n+     unsigned int lineno;\n+     const char *filename;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.start_source_file) (lineno, filename);\n+}\n+\n+/* Record the end of a source file, for later output.\n+   At present, unimplemented.  */\n+\n+static void\n+vmsdbgout_end_source_file (lineno)\n+     unsigned int lineno ATTRIBUTE_UNUSED;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.end_source_file) (lineno);\n+}\n+\n+/* Set up for Debug output at the start of compilation.  */\n+\n+static void\n+vmsdbgout_init (main_input_filename)\n+     const char *main_input_filename;\n+{\n+  const char *language_string = lang_hooks.name;\n+\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.init) (main_input_filename);\n+\n+  if (debug_info_level == DINFO_LEVEL_NONE)\n+    return;\n+\n+  /* Remember the name of the primary input file.  */\n+  primary_filename = main_input_filename;\n+\n+  /* Allocate the initial hunk of the file_info_table.  */\n+  file_info_table\n+    = (dst_file_info_ref) xcalloc (FILE_TABLE_INCREMENT,\n+\t\t\t\t   sizeof (dst_file_info_entry));\n+  file_info_table_allocated = FILE_TABLE_INCREMENT;\n+\n+  /* Skip the first entry - file numbers begin at 1 */\n+  file_info_table_in_use = 1;\n+\n+  func_table = (char **) xcalloc (FUNC_TABLE_INCREMENT, sizeof (char *));\n+  func_table_allocated = FUNC_TABLE_INCREMENT;\n+  func_table_in_use = 1;\n+\n+  /* Allocate the initial hunk of the line_info_table.  */\n+  line_info_table\n+    = (dst_line_info_ref) xcalloc (LINE_INFO_TABLE_INCREMENT,\n+\t\t\t\t   sizeof (dst_line_info_entry));\n+  line_info_table_allocated = LINE_INFO_TABLE_INCREMENT;\n+  /* zero-th entry is allocated, but unused */\n+  line_info_table_in_use = 1;\n+\n+  lookup_filename (primary_filename);\n+\n+  if (!strcmp (language_string, \"GNU C\"))\n+    module_language = DST_K_C;\n+  else if (!strcmp (language_string, \"GNU C++\"))\n+    module_language = DST_K_CXX;\n+  else if (!strcmp (language_string, \"GNU Ada\"))\n+    module_language = DST_K_ADA;\n+  else if (!strcmp (language_string, \"GNU F77\"))\n+    module_language = DST_K_FORTRAN;\n+  else\n+    module_language = DST_K_UNKNOWN;\n+\n+  module_producer\n+    = (char *) xmalloc (strlen (language_string) + 1\n+\t\t\t+ strlen (version_string + 1));\n+  sprintf (module_producer, \"%s %s\", language_string, version_string);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n+\n+}\n+\n+static void\n+vmsdbgout_define (lineno, buffer)\n+     unsigned int lineno;\n+     const char *buffer;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.define) (lineno, buffer);\n+}\n+\n+static void\n+vmsdbgout_undef (lineno, buffer)\n+     unsigned int lineno;\n+     const char *buffer;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.undef) (lineno, buffer);\n+}\n+\n+static void\n+vmsdbgout_decl (decl)\n+     tree decl;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.function_decl) (decl);\n+}\n+\n+static void\n+vmsdbgout_global_decl (decl)\n+     tree decl;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.global_decl) (decl);\n+}\n+\n+static void\n+vmsdbgout_abstract_function (decl)\n+     tree decl;\n+{\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.outlining_inline_function) (decl);\n+}\n+\n+/* Output stuff that Debug requires at the end of every file,\n+   and generate the VMS Debug debugging info.  */\n+\n+static void\n+vmsdbgout_finish (input_filename)\n+     const char *input_filename ATTRIBUTE_UNUSED;\n+{\n+  unsigned int i;\n+  int totsize;\n+\n+  if (write_symbols == VMS_AND_DWARF2_DEBUG)\n+    (*dwarf2_debug_hooks.finish) (input_filename);\n+\n+  if (debug_info_level == DINFO_LEVEL_NONE)\n+    return;\n+\n+  /* Output a terminator label for the .text section.  */\n+  text_section ();\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, TEXT_END_LABEL, 0);\n+\n+  /* Output debugging information.\n+     Warning! Do not change the name of the .vmsdebug section without\n+     changing it in the assembler also. */\n+  named_section (NULL_TREE, \".vmsdebug\", 0);\n+  ASM_OUTPUT_ALIGN (asm_out_file, 0);\n+\n+  totsize = write_modbeg (1);\n+  for (i = 1; i < func_table_in_use; i++)\n+    {\n+      totsize += write_rtnbeg (i, 1);\n+      totsize += write_rtnend (i, 1);\n+    }\n+  totsize += write_pclines (1);\n+\n+  write_modbeg (0);\n+  for (i = 1; i < func_table_in_use; i++)\n+    {\n+      write_rtnbeg (i, 0);\n+      write_rtnend (i, 0);\n+    }\n+  write_pclines (0);\n+\n+  if (debug_info_level > DINFO_LEVEL_TERSE)\n+    {\n+      totsize = write_srccorrs (1);\n+      write_srccorrs (0);\n+    }\n+\n+  totsize = write_modend (1);\n+  write_modend (0);\n+}\n+#endif /* VMS_DEBUGGING_INFO */"}]}