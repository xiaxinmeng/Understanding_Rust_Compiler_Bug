{"sha": "5579170b40876cbf8af7a369a7b1ea98e76e8b59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU3OTE3MGI0MDg3NmNiZjhhZjdhMzY5YTdiMWVhOThlNzZlOGI1OQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-10-13T10:37:13Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-10-13T10:37:13Z"}, "message": "Replace __bind_simple with std::thread::__make_invoker\n\n\t* include/std/functional (_Bind_simple, _Bind_simple_helper)\n\t(__bind_simple): Remove.\n\t* include/std/future: Include <bits/invoke.h> instead of <functional>.\n\t(__future_base::_Task_state::_M_run)\n\t(__future_base::_Task_state::_M_run_delayed): Use lambda expressions\n\tinstead of __bind_simple.\n\t(__future_base::_Task_state::_S_maybe_wrap_ref): Remove.\n\t(async): Use thread::__make_invoker instead of __bind_simple.\n\t* include/std/thread: Include <tuple> and <bits/invoke.h> instead of\n\t<functional>.\n\t(thread::_Invoker, thread::__make_invoker): Define helpers to do\n\tINVOKE(DECAY_COPY(f), DECAY_COPY(args)...).\n\nFrom-SVN: r241093", "tree": {"sha": "e224e63919b7a4272a576db1a4dac93cabaebf69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e224e63919b7a4272a576db1a4dac93cabaebf69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5579170b40876cbf8af7a369a7b1ea98e76e8b59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5579170b40876cbf8af7a369a7b1ea98e76e8b59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5579170b40876cbf8af7a369a7b1ea98e76e8b59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5579170b40876cbf8af7a369a7b1ea98e76e8b59/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62fdbf29a32779122e7dc5ebef22ca0854f4f99a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62fdbf29a32779122e7dc5ebef22ca0854f4f99a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62fdbf29a32779122e7dc5ebef22ca0854f4f99a"}], "stats": {"total": 168, "additions": 80, "deletions": 88}, "files": [{"sha": "d08a8b1d96660df33e3908ebd779f5303641c178", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5579170b40876cbf8af7a369a7b1ea98e76e8b59", "patch": "@@ -1,5 +1,18 @@\n 2016-10-13  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/std/functional (_Bind_simple, _Bind_simple_helper)\n+\t(__bind_simple): Remove.\n+\t* include/std/future: Include <bits/invoke.h> instead of <functional>.\n+\t(__future_base::_Task_state::_M_run)\n+\t(__future_base::_Task_state::_M_run_delayed): Use lambda expressions\n+\tinstead of __bind_simple.\n+\t(__future_base::_Task_state::_S_maybe_wrap_ref): Remove.\n+\t(async): Use thread::__make_invoker instead of __bind_simple.\n+\t* include/std/thread: Include <tuple> and <bits/invoke.h> instead of\n+\t<functional>.\n+\t(thread::_Invoker, thread::__make_invoker): Define helpers to do\n+\tINVOKE(DECAY_COPY(f), DECAY_COPY(args)...).\n+\n \t* include/std/functional (_Not_fn): Make exception specifications\n \tdepend on whether negating the result can throw.\n \t* testsuite/20_util/not_fn/1.cc: Move to ..."}, {"sha": "38770336c04bc8c33290528b0c6e33e19fd48eab", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=5579170b40876cbf8af7a369a7b1ea98e76e8b59", "patch": "@@ -1300,69 +1300,6 @@ _GLIBCXX_MEM_FN_TRAITS(&&, false_type, true_type)\n \t\t\t   std::forward<_BoundArgs>(__args)...);\n     }\n \n-  template<typename _Signature>\n-    struct _Bind_simple;\n-\n-  template<typename _Callable, typename... _Args>\n-    struct _Bind_simple<_Callable(_Args...)>\n-    {\n-      typedef typename result_of<_Callable(_Args...)>::type result_type;\n-\n-      template<typename _Tp, typename... _Up>\n-        explicit\n-        _Bind_simple(_Tp&& __f, _Up&&... __args)\n-        : _M_bound(std::forward<_Tp>(__f), std::forward<_Up>(__args)...)\n-        { }\n-\n-      _Bind_simple(const _Bind_simple&) = default;\n-      _Bind_simple(_Bind_simple&&) = default;\n-\n-      result_type\n-      operator()()\n-      {\n-        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;\n-        return _M_invoke(_Indices());\n-      }\n-\n-    private:\n-      template<std::size_t... _Indices>\n-        typename result_of<_Callable(_Args...)>::type\n-        _M_invoke(_Index_tuple<_Indices...>)\n-        {\n-\t  // std::bind always forwards bound arguments as lvalues,\n-\t  // but this type can call functions which only accept rvalues.\n-          return std::forward<_Callable>(std::get<0>(_M_bound))(\n-              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);\n-        }\n-\n-      std::tuple<_Callable, _Args...> _M_bound;\n-    };\n-\n-  template<typename _Func, typename... _BoundArgs>\n-    struct _Bind_simple_helper\n-    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>\n-    {\n-      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>\n-        __maybe_type;\n-      typedef typename __maybe_type::type __func_type;\n-      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>\n-       \t__type;\n-    };\n-\n-  // Simplified version of std::bind for internal use, without support for\n-  // unbound arguments, placeholders or nested bind expressions.\n-  template<typename _Callable, typename... _Args>\n-    typename _Bind_simple_helper<_Callable, _Args...>::__type\n-    __bind_simple(_Callable&& __callable, _Args&&... __args)\n-    {\n-      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;\n-      typedef typename __helper_type::__maybe_type __maybe_type;\n-      typedef typename __helper_type::__type __result_type;\n-      return __result_type(\n-          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),\n-          std::forward<_Args>(__args)...);\n-    }\n-\n   /**\n    *  @brief Exception class thrown when class template function's\n    *  operator() is called with an empty target."}, {"sha": "fffbdbb70520e11c13922291b573646fcf87c5ff", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=5579170b40876cbf8af7a369a7b1ea98e76e8b59", "patch": "@@ -35,14 +35,14 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <functional>\n #include <mutex>\n #include <thread>\n #include <condition_variable>\n #include <system_error>\n #include <atomic>\n #include <bits/atomic_futex.h>\n #include <bits/functexcept.h>\n+#include <bits/invoke.h>\n #include <bits/unique_ptr.h>\n #include <bits/shared_ptr.h>\n #include <bits/uses_allocator.h>\n@@ -1403,36 +1403,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       virtual void\n       _M_run(_Args&&... __args)\n       {\n-\t// bound arguments decay so wrap lvalue references\n-\tauto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),\n-\t    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n+\tauto __boundfn = [&] () -> typename result_of<_Fn(_Args&&...)>::type {\n+\t    return std::__invoke(_M_impl._M_fn, std::forward<_Args>(__args)...);\n+\t};\n \tthis->_M_set_result(_S_task_setter(this->_M_result, __boundfn));\n       }\n \n       virtual void\n       _M_run_delayed(_Args&&... __args, weak_ptr<_State_base> __self)\n       {\n-\t// bound arguments decay so wrap lvalue references\n-\tauto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),\n-\t    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n+\tauto __boundfn = [&] () -> typename result_of<_Fn(_Args&&...)>::type {\n+\t    return std::__invoke(_M_impl._M_fn, std::forward<_Args>(__args)...);\n+\t};\n \tthis->_M_set_delayed_result(_S_task_setter(this->_M_result, __boundfn),\n \t\t\t\t    std::move(__self));\n       }\n \n       virtual shared_ptr<_Task_state_base<_Res(_Args...)>>\n       _M_reset();\n \n-      template<typename _Tp>\n-\tstatic reference_wrapper<_Tp>\n-\t_S_maybe_wrap_ref(_Tp& __t)\n-\t{ return std::ref(__t); }\n-\n-      template<typename _Tp>\n-\tstatic\n-\ttypename enable_if<!is_lvalue_reference<_Tp>::value, _Tp>::type&&\n-\t_S_maybe_wrap_ref(_Tp&& __t)\n-\t{ return std::forward<_Tp>(__t); }\n-\n       struct _Impl : _Alloc\n       {\n \ttemplate<typename _Fn2>\n@@ -1713,8 +1702,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  __try\n \t    {\n-\t      __state = __future_base::_S_make_async_state(std::__bind_simple(\n-\t\t  std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));\n+\t      __state = __future_base::_S_make_async_state(\n+\t\t  std::thread::__make_invoker(std::forward<_Fn>(__fn),\n+\t\t\t\t\t      std::forward<_Args>(__args)...)\n+\t\t  );\n \t    }\n #if __cpp_exceptions\n \t  catch(const system_error& __e)\n@@ -1727,8 +1718,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       if (!__state)\n \t{\n-\t  __state = __future_base::_S_make_deferred_state(std::__bind_simple(\n-              std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));\n+\t  __state = __future_base::_S_make_deferred_state(\n+\t      std::thread::__make_invoker(std::forward<_Fn>(__fn),\n+\t\t\t\t\t  std::forward<_Args>(__args)...));\n \t}\n       return future<__async_result_of<_Fn, _Args...>>(__state);\n     }"}, {"sha": "7a3c4078cc123c5df28c8621112642e0f7b4072f", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5579170b40876cbf8af7a369a7b1ea98e76e8b59/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=5579170b40876cbf8af7a369a7b1ea98e76e8b59", "patch": "@@ -36,11 +36,12 @@\n #else\n \n #include <chrono>\n-#include <functional>\n #include <memory>\n+#include <tuple>\n #include <cerrno>\n #include <bits/functexcept.h>\n #include <bits/functional_hash.h>\n+#include <bits/invoke.h>\n #include <bits/gthr.h>\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n@@ -122,8 +123,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tauto __depend = nullptr;\n #endif\n         _M_start_thread(_S_make_state(\n-\t      std::__bind_simple(std::forward<_Callable>(__f),\n-\t\t\t\t std::forward<_Args>(__args)...)),\n+\t      __make_invoker(std::forward<_Callable>(__f),\n+\t\t\t     std::forward<_Args>(__args)...)),\n \t    __depend);\n       }\n \n@@ -212,6 +213,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _M_start_thread(__shared_base_type);\n #endif\n+\n+  private:\n+    // A call wrapper that does INVOKE(forwarded tuple elements...)\n+    template<typename _Tuple>\n+      struct _Invoker\n+      {\n+\t_Tuple _M_t;\n+\n+\ttemplate<size_t _Index>\n+\t  static __tuple_element_t<_Index, _Tuple>&&\n+\t  _S_declval();\n+\n+\ttemplate<size_t... _Ind>\n+\t  auto\n+\t  _M_invoke(_Index_tuple<_Ind...>)\n+\t  noexcept(noexcept(std::__invoke(_S_declval<_Ind>()...)))\n+\t  -> decltype(std::__invoke(_S_declval<_Ind>()...))\n+\t  { return std::__invoke(std::get<_Ind>(std::move(_M_t))...); }\n+\n+\tusing _Indices\n+\t  = typename _Build_index_tuple<tuple_size<_Tuple>::value>::__type;\n+\n+\tusing result_type\n+\t  = decltype(std::declval<_Invoker>()._M_invoke(_Indices()));\n+\n+\tresult_type\n+\toperator()()\n+\tnoexcept(noexcept(std::declval<_Invoker>()._M_invoke(_Indices())))\n+\t{ return _M_invoke(_Indices()); }\n+\n+      };\n+\n+    // Alias for _Invoker<tuple<DECAY_COPY(_Tp)...>>\n+    template<typename... _Tp>\n+      using __invoker_type\n+\t= _Invoker<decltype(std::make_tuple(std::declval<_Tp>()...))>;\n+\n+  public:\n+    // Returns a call wrapper that does\n+    // INVOKE(DECAY_COPY(__callable), DECAY_COPY(__args)).\n+    template<typename _Callable, typename... _Args>\n+      static __invoker_type<_Callable, _Args...>\n+      __make_invoker(_Callable&& __callable, _Args&&... __args)\n+      {\n+\treturn { {\n+\t    std::make_tuple(std::forward<_Callable>(__callable),\n+\t\t\t    std::forward<_Args>(__args)...)\n+\t} };\n+      }\n   };\n \n   inline void"}]}