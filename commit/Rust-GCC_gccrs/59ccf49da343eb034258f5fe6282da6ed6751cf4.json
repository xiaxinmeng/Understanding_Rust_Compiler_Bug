{"sha": "59ccf49da343eb034258f5fe6282da6ed6751cf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTljY2Y0OWRhMzQzZWIwMzQyNThmNWZlNjI4MmRhNmVkNjc1MWNmNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-27T01:27:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-27T01:27:18Z"}, "message": "cp-tree.h (expand_throw): Remove prototype.\n\n\t* cp-tree.h (expand_throw): Remove prototype.\n\t* except.c (expand_throw): Make it static.  Use tree-generation\n\tfunctions, rather than RTL-generation functions.\n\t(build_throw): Use it.\n\t* expr.c: Include except.h.\n\t(cplus_expand_expr): Don't call expand_throw here.\n\t* Makefile.in (expr.o): Depend on except.h.\n\t* ir.texi: Update documentation for THROW_EXPR.\n\n\t* decl.c (start_function): Set x_dont_save_pending_sizes rather\n\tthan calling get_pending_sizes.\n\t* init.c (build_new): Don't save and restore\n\timmediate_size_expand; instead, assert that it has the expected\n\tvalue already.\n\nFrom-SVN: r29671", "tree": {"sha": "1b29796b2aee3f4dfa3db27106f7aebfefc0e732", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b29796b2aee3f4dfa3db27106f7aebfefc0e732"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59ccf49da343eb034258f5fe6282da6ed6751cf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ccf49da343eb034258f5fe6282da6ed6751cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ccf49da343eb034258f5fe6282da6ed6751cf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ccf49da343eb034258f5fe6282da6ed6751cf4/comments", "author": null, "committer": null, "parents": [{"sha": "bfcccecc564752b7ef55ac9ca32ab8df0c5ba1dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfcccecc564752b7ef55ac9ca32ab8df0c5ba1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfcccecc564752b7ef55ac9ca32ab8df0c5ba1dc"}], "stats": {"total": 79, "additions": 44, "deletions": 35}, "files": [{"sha": "19e4dd3208622867278fbd7d697704d4183c3d7d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=59ccf49da343eb034258f5fe6282da6ed6751cf4", "patch": "@@ -1,5 +1,14 @@\n 1999-09-26  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (expand_throw): Remove prototype.\n+\t* except.c (expand_throw): Make it static.  Use tree-generation\n+\tfunctions, rather than RTL-generation functions.\n+\t(build_throw): Use it.\n+\t* expr.c: Include except.h.\n+\t(cplus_expand_expr): Don't call expand_throw here.\n+\t* Makefile.in (expr.o): Depend on except.h.\n+\t* ir.texi: Update documentation for THROW_EXPR.\n+\t\n \t* decl.c (start_function): Set x_dont_save_pending_sizes rather\n \tthan calling get_pending_sizes.\n \t* init.c (build_new): Don't save and restore"}, {"sha": "047f391eb865d7757bc4def6374990a35da3440f", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=59ccf49da343eb034258f5fe6282da6ed6751cf4", "patch": "@@ -282,7 +282,7 @@ rtti.o : rtti.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n except.o : except.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n-  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../except.h\n xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H) lex.h \\"}, {"sha": "3abea7d5e88871a315d600520137729b838d3b20", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=59ccf49da343eb034258f5fe6282da6ed6751cf4", "patch": "@@ -3456,7 +3456,6 @@ extern void expand_end_eh_spec\t\t        PROTO((tree, tree));\n extern void expand_exception_blocks\t\tPROTO((void));\n extern tree start_anon_func\t\t\tPROTO((void));\n extern void end_anon_func\t\t\tPROTO((void));\n-extern void expand_throw\t\t\tPROTO((tree));\n extern tree build_throw\t\t\t\tPROTO((tree));\n extern void mark_all_runtime_matches            PROTO((void));\n "}, {"sha": "eec0d7c5e167a3f63b7fbd02362ec3af52495c31", "filename": "gcc/cp/except.c", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=59ccf49da343eb034258f5fe6282da6ed6751cf4", "patch": "@@ -54,6 +54,7 @@ static tree build_terminate_handler PROTO((void));\n static tree alloc_eh_object PROTO((tree));\n static int complete_ptr_ref_or_void_ptr_p PROTO((tree, tree));\n static void initialize_handler_parm PROTO((tree));\n+static tree expand_throw PROTO((tree));\n \n #if 0\n /* This is the startup, and finish stuff per exception table.  */\n@@ -825,19 +826,24 @@ alloc_eh_object (type)\n \t\tgenerate a label for the throw block\n \t4. jump to the throw block label.  */\n \n-void\n+tree\n expand_throw (exp)\n      tree exp;\n {\n   tree fn;\n \n   if (! doing_eh (1))\n-    return;\n+    return error_mark_node;\n \n   if (exp)\n     {\n       tree throw_type;\n       tree cleanup = NULL_TREE, e;\n+      tree stmt_expr;\n+      tree compound_stmt;\n+      tree try_block;\n+\n+      begin_init_stmts (&stmt_expr, &compound_stmt);\n \n       /* throw expression */\n       /* First, decay it.  */\n@@ -846,15 +852,11 @@ expand_throw (exp)\n       /* cleanup_type is void (*)(void *, int),\n \t the internal type of a destructor. */\n       if (cleanup_type == NULL_TREE)\n-\t{\n-\t  push_permanent_obstack ();\n-\t  cleanup_type = build_pointer_type\n-\t    (build_function_type\n-\t     (void_type_node, tree_cons\n-\t      (NULL_TREE, ptr_type_node, tree_cons\n-\t       (NULL_TREE, integer_type_node, void_list_node))));\n-\t  pop_obstacks ();\n-\t}\n+\tcleanup_type = build_pointer_type\n+\t  (build_function_type\n+\t   (void_type_node, tree_cons\n+\t    (NULL_TREE, ptr_type_node, tree_cons\n+\t     (NULL_TREE, integer_type_node, void_list_node))));\n \n       if (TYPE_PTR_P (TREE_TYPE (exp)))\n \tthrow_type = build_eh_type (exp);\n@@ -876,12 +878,8 @@ expand_throw (exp)\n \t     first.  Since there could be temps in the expression, we need\n \t     to handle that, too.  */\n \n-\t  expand_start_target_temps ();\n+\t  my_friendly_assert (stmts_are_full_exprs_p == 1, 19990926);\n \n-#if 0\n-\t  /* Unfortunately, this doesn't work.  */\n-\t  preexpand_calls (exp);\n-#else\n \t  /* Store the throw expression into a temp.  This can be less\n \t     efficient than storing it into the allocated space directly, but\n \t     oh well.  To do this efficiently we would need to insinuate\n@@ -893,23 +891,21 @@ expand_throw (exp)\n \t      cp_finish_decl (temp, exp, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n \t      exp = temp;\n \t    }\n-#endif\n \n \t  /* Allocate the space for the exception.  */\n \t  ptr = save_expr (alloc_eh_object (TREE_TYPE (exp)));\n-\t  expand_expr (ptr, const0_rtx, VOIDmode, 0);\n-\n-\t  expand_eh_region_start ();\n+\t  finish_expr_stmt (ptr);\n \n+\t  try_block = begin_try_block ();\n \t  object = build_indirect_ref (ptr, NULL_PTR);\n \t  exp = build_modify_expr (object, INIT_EXPR, exp);\n \n \t  if (exp == error_mark_node)\n \t    error (\"  in thrown expression\");\n \n-\t  expand_expr (exp, const0_rtx, VOIDmode, 0);\n-\t  expand_eh_region_end (build_terminate_handler ());\n-\t  expand_end_target_temps ();\n+\t  finish_expr_stmt (exp);\n+\t  finish_cleanup_try_block (try_block);\n+\t  finish_cleanup (build_terminate_handler (), try_block);\n \n \t  throw_type = build_eh_type (object);\n \n@@ -964,8 +960,9 @@ expand_throw (exp)\n       e = tree_cons (NULL_TREE, exp, tree_cons\n \t\t     (NULL_TREE, throw_type, tree_cons\n \t\t      (NULL_TREE, cleanup, NULL_TREE)));\n-      e = build_function_call (fn, e);\n-      expand_expr (e, const0_rtx, VOIDmode, 0);\n+      finish_expr_stmt (build_function_call (fn, e));\n+\n+      exp = finish_init_stmts (stmt_expr, compound_stmt);\n     }\n   else\n     {\n@@ -992,10 +989,9 @@ expand_throw (exp)\n \n       mark_used (fn);\n       exp = build_function_call (fn, NULL_TREE);\n-      expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n-  expand_internal_throw ();\n+  return exp;\n }\n \n /* Build a throw expression.  */\n@@ -1019,6 +1015,7 @@ build_throw (e)\n         return error_mark_node;\n     }\n \n+  e = expand_throw (e);\n   e = build1 (THROW_EXPR, void_type_node, e);\n   TREE_SIDE_EFFECTS (e) = 1;\n   TREE_USED (e) = 1;"}, {"sha": "5b5352ef4d5b90eb4ecccca342486f684ffae30e", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=59ccf49da343eb034258f5fe6282da6ed6751cf4", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"cp-tree.h\"\n #include \"toplev.h\"\n+#include \"except.h\"\n \n #if 0\n static tree extract_aggr_init PROTO((tree, tree));\n@@ -228,7 +229,8 @@ cplus_expand_expr (exp, target, tmode, modifier)\n       return DECL_RTL (exp);\n \n     case THROW_EXPR:\n-      expand_throw (TREE_OPERAND (exp, 0));\n+      expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n+      expand_internal_throw ();\n       return NULL;\n \n     case VEC_INIT_EXPR:"}, {"sha": "32a0bf382bf09d8f16a3db001635d7b7fbf4d080", "filename": "gcc/cp/ir.texi", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fir.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ccf49da343eb034258f5fe6282da6ed6751cf4/gcc%2Fcp%2Fir.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fir.texi?ref=59ccf49da343eb034258f5fe6282da6ed6751cf4", "patch": "@@ -1621,11 +1621,13 @@ function calls are made explicit.\n \n @item THROW_EXPR\n These nodes represent @code{throw} expressions.  The single operand is\n-the expression to be thrown.  If the throw expression is of the form \n-@example\n-throw;\n-@end example\n-then the operand is @code{NULL_TREE}.\n+an expression for the code that should be executed to throw the\n+exception.  However, there is one implicit action not represented in\n+that expression; namely the call to @code{__throw}.  This function takes\n+no arguments.  If @code{setjmp}/@code{longjmp} exceptiosn are used, the\n+function @code{__sjthrow} is called instead.  The normal G++ back-end\n+uses the function @code{emit_throw} to generate this code; you can\n+examine this function to see what needs to be done.\n \n @item LSHIFT_EXPR\n @itemx RSHIFT_EXPR"}]}