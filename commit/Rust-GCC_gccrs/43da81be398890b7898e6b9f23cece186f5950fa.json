{"sha": "43da81be398890b7898e6b9f23cece186f5950fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNkYTgxYmUzOTg4OTBiNzg5OGU2YjlmMjNjZWNlMTg2ZjU5NTBmYQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-05-16T01:12:07Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-05-16T01:12:07Z"}, "message": "re PR tree-optimization/21576 (FRE does not eliminate a redundant builtin call.)\n\n2005-05-15  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/21576\n\n\t* tree-ssa-pre.c (expression_node_pool): New pool.\n\t(comparison_node_pool): Ditto.\n\t(list_node_pool): Ditto.\n\t(pool_copy_list): New function.\n\t(phi_translate): Handle CALL_EXPR.\n\t(valid_in_set): Ditto.\n\t(create_expression_by_pieces): Ditto.\n\t(insert_into_preds_of_block): Ditto.\n\t(insert_aux): Ditto.\n\t(compute_avail): Ditto.\n\t(create_value_expr_from): Handle TREE_LIST and CALL_EXPR.\n\t(can_value_number_call): New function.\n\t(find_leader): Update comment.\n\t(init_pre): Create new pools.\n\t(fini_pre): Free new pools.\n\t(pass_pre): Add TODO_update_ssa for the future when we are going\n\tto need vops.\n\t* tree-vn.c (expressions_equal_p): Handle TREE_LIST.\n\t(set_value_handle): Ditto.\n\t(get_value_handle): Ditto.\n\nFrom-SVN: r99759", "tree": {"sha": "9ae1ca4cfd3a16282eccd4a1235eecbb784104c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ae1ca4cfd3a16282eccd4a1235eecbb784104c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43da81be398890b7898e6b9f23cece186f5950fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43da81be398890b7898e6b9f23cece186f5950fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43da81be398890b7898e6b9f23cece186f5950fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43da81be398890b7898e6b9f23cece186f5950fa/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cea02b6e7ee16a7f4e568dc63c3f8b27144a5a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea02b6e7ee16a7f4e568dc63c3f8b27144a5a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea02b6e7ee16a7f4e568dc63c3f8b27144a5a13"}], "stats": {"total": 439, "additions": 419, "deletions": 20}, "files": [{"sha": "24444470364104dd14c027862325d875e344baee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -1,3 +1,28 @@\n+2005-05-15  Daniel Berlin  <dberlin@dberlin.org>\n+\t    \n+\tFix PR tree-optimization/21576\n+\t\n+\t* tree-ssa-pre.c (expression_node_pool): New pool.\n+\t(comparison_node_pool): Ditto.\n+\t(list_node_pool): Ditto.\n+\t(pool_copy_list): New function.\n+\t(phi_translate): Handle CALL_EXPR.\n+\t(valid_in_set): Ditto.\n+\t(create_expression_by_pieces): Ditto.\n+\t(insert_into_preds_of_block): Ditto.\n+\t(insert_aux): Ditto.\n+\t(compute_avail): Ditto.\n+\t(create_value_expr_from): Handle TREE_LIST and CALL_EXPR.\n+\t(can_value_number_call): New function.\n+\t(find_leader): Update comment.\n+\t(init_pre): Create new pools.\n+\t(fini_pre): Free new pools.\n+\t(pass_pre): Add TODO_update_ssa for the future when we are going\n+\tto need vops.\n+\t* tree-vn.c (expressions_equal_p): Handle TREE_LIST.\n+\t(set_value_handle): Ditto.\n+\t(get_value_handle): Ditto.\n+\n 2005-05-15  Richard Earnshaw  <richard.earnshaw@arm.com>\n \n \t* arm.c (thumb_unexpanded_epilogue): Delete unused variable 'mode'."}, {"sha": "5bbfd3d17fb807fdd65e6274a864fe313bfcf13a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-cse-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-cse-1.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-dom1-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-fre-details\" } */\n int t(int a) __attribute__ ((const));\n void q (void);\n void\n@@ -12,5 +12,5 @@ threading(int a,int b)\n \t}\n }\n /* We should thread the jump twice and eliminate it.  */\n-/* { dg-final { scan-tree-dump-times \"Replaced.* t \" 1 \"dom1\"} } */\n-/* { dg-final { cleanup-tree-dump \"dom1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replaced.* t \" 1 \"fre\"} } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "127caa6cd6b8ee5b064d61d864267be876ab3036", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-10.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-10.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-fre-stats\" } */\n+double cos (double);\n+void link_error();\n+void f(double a)\n+{\n+  double b = cos (a);\n+  double c = cos (a);\n+  if (b != c)\n+    link_error();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"fre\"} } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "26c47b1830ba52aaf7363a9c9521f939c16266a5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-11.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-11.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+double cos (double);\n+double f(double a)\n+{\n+  double b;\n+  double c,d;\n+ if (a < 2.0)\n+   {\n+     c = cos (a);\n+   }\n+ else\n+   {\n+     c = 1.0; \n+   }\n+ d = cos (a);\n+ return d + c;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "fd80e3d8d505409548694a0032f7582b2b647153", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-12.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-12.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+double cos (double) __attribute__ ((const));\n+double sin (double) __attribute__ ((const));\n+double f(double a)\n+{\n+  double b;\n+  double c,d;\n+  double (*fp) (double) __attribute__ ((const));\n+  /* Fully redundant call, but we need a phi node to merge the results.  */\n+  if (a < 2.0)\n+    {\n+      fp = sin;\n+      c = fp (a);\n+    }\n+  else\n+    {\n+      c = 1.0; \n+      fp = cos;\n+      c = fp (a);\n+    }\n+  d = fp (a);\n+  return d + c;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "dfce46b9907720e4d02eb925dce93690d0fc4335", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-13.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-13.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+double cos (double) __attribute__ ((const));\n+double sin (double) __attribute__ ((const));\n+double f(double a)\n+{\n+  double b;\n+  double c,d;\n+  double (*fp) (double) __attribute__ ((const));\n+  /* Partially redundant call */\n+  if (a < 2.0)\n+    {\n+      fp = sin;\n+      c = fp (a);\n+    }\n+  else\n+    {\n+      c = 1.0; \n+      fp = cos;\n+    }\n+  d = fp (a);\n+  return d + c;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "32e37b997039d21214e340cf93c79dbc97f53daf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-9.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-9.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-fre-stats\" } */\n+int\n+foo (unsigned long a)\n+{\n+  int b = __builtin_clzl (a);\n+  int c = __builtin_clzl (a);\n+  if (b == c)\n+    return 1;\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"fre\"} } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "859bf096210a298813dcafa8351d5650c38a087d", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 269, "deletions": 12, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -305,6 +305,9 @@ static alloc_pool value_set_node_pool;\n static alloc_pool binary_node_pool;\n static alloc_pool unary_node_pool;\n static alloc_pool reference_node_pool;\n+static alloc_pool comparison_node_pool;\n+static alloc_pool expression_node_pool;\n+static alloc_pool list_node_pool;\n static bitmap_obstack grand_bitmap_obstack;\n \n /* Set of blocks with statements that have had its EH information\n@@ -855,6 +858,35 @@ fully_constant_expression (tree t)\n   return t;\n }\n \n+/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.\n+   For example, this can copy a list made of TREE_LIST nodes.  \n+   Allocates the nodes in list_node_pool*/\n+\n+static tree\n+pool_copy_list (tree list)\n+{\n+  tree head;\n+  tree prev, next;\n+\n+  if (list == 0)\n+    return 0;\n+  head = pool_alloc (list_node_pool);\n+  \n+  memcpy (head, list, tree_size (list));\n+  prev = head;\n+  \n+  next = TREE_CHAIN (list);\n+  while (next)\n+    {\n+      TREE_CHAIN (prev) = pool_alloc (list_node_pool);\n+      memcpy (TREE_CHAIN (prev), next, tree_size (next));\n+      prev = TREE_CHAIN (prev);\n+      next = TREE_CHAIN (next);\n+    }\n+  return head;\n+}\n+\n+\n /* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n    the phis in PRED.  Return NULL if we can't find a leader for each\n    part of the translated expression.  */\n@@ -879,6 +911,89 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n   \n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n+    case tcc_expression:\n+      {\n+\tif (TREE_CODE (expr) != CALL_EXPR)\n+\t  return NULL;\n+\telse\n+\t  {\n+\t    tree oldop0 = TREE_OPERAND (expr, 0);\n+\t    tree oldarglist = TREE_OPERAND (expr, 1);\n+\t    tree oldop2 = TREE_OPERAND (expr, 2);\n+\t    tree newop0;\n+\t    tree newarglist;\n+\t    tree newop2 = NULL;\n+\t    tree oldwalker;\n+\t    tree newwalker;\n+\t    tree newexpr;\n+\t    bool listchanged = false;\n+\n+\t    /* Call expressions are kind of weird because they have an\n+\t       argument list.  We don't want to value number the list\n+\t       as one value number, because that doesn't make much\n+\t       sense, and just breaks the support functions we call,\n+\t       which expect TREE_OPERAND (call_expr, 2) to be a\n+\t       TREE_LIST. */\t      \n+\t    \n+\t    newop0 = phi_translate (find_leader (set, oldop0),\n+\t\t\t\t    set, pred, phiblock);\n+\t    if (newop0 == NULL)\n+\t      return NULL;\n+\t    if (oldop2)\n+\t      {\n+\t\tnewop2 = phi_translate (find_leader (set, oldop2),\n+\t\t\t\t\tset, pred, phiblock);\n+\t\tif (newop2 == NULL)\n+\t\t  return NULL;\n+\t      }\n+\n+\t    /* phi translate the argument list piece by piece.\n+\t       \n+\t      We could actually build the list piece by piece here,\n+\t      but it's likely to not be worth the memory we will save,\n+\t      unless you have millions of call arguments.  */\n+\n+\t    newarglist = pool_copy_list (oldarglist);\n+\t    for (oldwalker = oldarglist, newwalker = newarglist;\n+\t\t oldwalker && newwalker;\n+\t\t oldwalker = TREE_CHAIN (oldwalker), \n+\t\t   newwalker = TREE_CHAIN (newwalker))\n+\t      {\n+\t\t\n+\t\ttree oldval = TREE_VALUE (oldwalker);\n+\t\ttree newval;\n+\t\tif (oldval)\n+\t\t  {\n+\t\t    newval = phi_translate (find_leader (set, oldval),\n+\t\t\t\t\t    set, pred, phiblock);\n+\t\t    if (newval == NULL)\n+\t\t      return NULL;\n+\t\t    if (newval != oldval)\n+\t\t      {\n+\t\t\tlistchanged = true;\n+\t\t\tTREE_VALUE (newwalker) = get_value_handle (newval);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    if (listchanged)\n+\t      vn_lookup_or_add (newarglist, NULL);\n+\t    \n+\t    if (listchanged || (newop0 != oldop0) || (oldop2 != newop2))\n+\t      {\n+\t\tnewexpr = pool_alloc (expression_node_pool);\n+\t\tmemcpy (newexpr, expr, tree_size (expr));\n+\t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldop0 : get_value_handle (newop0);\n+\t\tTREE_OPERAND (newexpr, 1) = listchanged ? newarglist : oldarglist;\n+\t\tTREE_OPERAND (newexpr, 2) = newop2 == oldop2 ? oldop2 : get_value_handle (newop2);\n+\t\tcreate_tree_ann (newexpr);\t \n+\t\tvn_lookup_or_add (newexpr, NULL);\n+\t\texpr = newexpr;\n+\t\tphi_trans_add (oldexpr, newexpr, pred);\n+\t      }\n+\t  }\n+      }\n+      return expr;\n+\n     case tcc_reference:\n       /* XXX: Until we have PRE of loads working, none will be ANTIC.  */\n       return NULL;\n@@ -1084,10 +1199,10 @@ find_leader (value_set_t set, tree val)\n    we have a leader for each part of the expression (if it consists of\n    values), or the expression is an SSA_NAME.  \n \n-   NB:  We never should run into a case where we have SSA_NAME +\n+   NB: We never should run into a case where we have SSA_NAME +\n    SSA_NAME or SSA_NAME + value.  The sets valid_in_set is called on,\n-   the ANTIC sets, will only ever have SSA_NAME's or binary value\n-   expression (IE VALUE1 + VALUE2)  */\n+   the ANTIC sets, will only ever have SSA_NAME's or value expressions\n+   (IE VALUE1 + VALUE2, *VALUE1, VALUE1 < VALUE2)  */\n \n static bool\n valid_in_set (value_set_t set, tree expr)\n@@ -1107,7 +1222,31 @@ valid_in_set (value_set_t set, tree expr)\n \ttree op1 = TREE_OPERAND (expr, 0);\n \treturn set_contains_value (set, op1);\n       }\n+      \n+    case tcc_expression:\n+      {\n+\tif (TREE_CODE (expr) == CALL_EXPR)\n+\t  {\n+\t    tree op0 = TREE_OPERAND (expr, 0);\n+\t    tree arglist = TREE_OPERAND (expr, 1);\n+\t    tree op2 = TREE_OPERAND (expr, 2);\n \n+\t    /* Check the non-list operands first.  */\n+\t    if (!set_contains_value (set, op0)\n+\t\t|| (op2 && !set_contains_value (set, op2)))\n+\t      return false;\n+\n+\t    /* Now check the operands.  */\n+\t    for (; arglist; arglist = TREE_CHAIN (arglist))\n+\t      {\n+\t\tif (!set_contains_value (set, TREE_VALUE (arglist)))\n+\t\t  return false;\n+\t      }\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+      \n     case tcc_reference:\n       /* XXX: Until PRE of loads works, no reference nodes are ANTIC.  */\n       return false;\n@@ -1189,7 +1328,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n      translate through.  */\n   else if (single_succ_p (block))\n     {\n-      phi_translate_set (ANTIC_OUT, ANTIC_IN(single_succ (block)),\n+      phi_translate_set (ANTIC_OUT, ANTIC_IN (single_succ (block)),\n \t\t\t block, single_succ (block));\n     }\n   /* If we have multiple successors, we take the intersection of all of\n@@ -1359,6 +1498,42 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n+    case tcc_expression:\n+      {\n+\ttree op0, op2;\n+\ttree arglist;\n+\ttree genop0, genop2;\n+\ttree genarglist;\n+\ttree walker, genwalker;\n+\t\n+\tgcc_assert (TREE_CODE (expr) == CALL_EXPR);\n+\tgenop2 = NULL;\n+\t\n+\top0 = TREE_OPERAND (expr, 0);\n+\targlist = TREE_OPERAND (expr, 1);\n+\top2 = TREE_OPERAND (expr, 2);\n+\t\n+\tgenop0 = find_or_generate_expression (block, op0, stmts);\n+\tgenarglist = copy_list (arglist);\n+\tfor (walker = arglist, genwalker = genarglist;\n+\t     genwalker && walker;\n+\t     genwalker = TREE_CHAIN (genwalker), walker = TREE_CHAIN (walker))\n+\t  {\n+\t    TREE_VALUE (genwalker) = find_or_generate_expression (block, \n+\t\t\t\t\t\t\t\t  TREE_VALUE (walker), \n+\t\t\t\t\t\t\t\t  stmts);\n+\t  }\n+\n+\tif (op2)\t  \n+\t  genop2 = find_or_generate_expression (block, op2, stmts);\n+\tfolded = fold (build (TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t      genop0, genarglist, genop2));\n+\tbreak;\n+\t\n+\t\n+      }\n+      break;\n+      \n     case tcc_binary:\n     case tcc_comparison:\n       {\n@@ -1499,7 +1674,8 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n       eprime = avail[bprime->index];\n       if (BINARY_CLASS_P (eprime)\n \t  || COMPARISON_CLASS_P (eprime)\n-\t  || UNARY_CLASS_P (eprime))\n+\t  || UNARY_CLASS_P (eprime)\n+\t  || TREE_CODE (eprime) == CALL_EXPR)\n \t{\n \t  builtexpr = create_expression_by_pieces (bprime,\n \t\t\t\t\t\t   eprime,\n@@ -1613,7 +1789,8 @@ insert_aux (basic_block block)\n \t\t{\n \t\t  if (BINARY_CLASS_P (node->expr)\n \t\t      || COMPARISON_CLASS_P (node->expr)\n-\t\t      || UNARY_CLASS_P (node->expr))\n+\t\t      || UNARY_CLASS_P (node->expr)\n+\t\t      || TREE_CODE (node->expr) == CALL_EXPR)\n \t\t    {\n \t\t      tree *avail;\n \t\t      tree val;\n@@ -1817,17 +1994,55 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n   gcc_assert (TREE_CODE_CLASS (code) == tcc_unary\n \t      || TREE_CODE_CLASS (code) == tcc_binary\n \t      || TREE_CODE_CLASS (code) == tcc_comparison\n-\t      || TREE_CODE_CLASS (code) == tcc_reference);\n+\t      || TREE_CODE_CLASS (code) == tcc_reference\n+\t      || TREE_CODE_CLASS (code) == tcc_expression\n+\t      || TREE_CODE_CLASS (code) == tcc_exceptional);\n \n   if (TREE_CODE_CLASS (code) == tcc_unary)\n     pool = unary_node_pool;\n   else if (TREE_CODE_CLASS (code) == tcc_reference)\n     pool = reference_node_pool;\n-  else\n+  else if (TREE_CODE_CLASS (code) == tcc_binary)\n     pool = binary_node_pool;\n+  else if (TREE_CODE_CLASS (code) == tcc_comparison)\n+    pool = comparison_node_pool;\n+  else if (TREE_CODE_CLASS (code) == tcc_exceptional)\n+    {\n+      gcc_assert (code == TREE_LIST);\n+      pool = list_node_pool;\n+    }\n+  else \n+    {\n+      gcc_assert (code == CALL_EXPR);\n+      pool = expression_node_pool;\n+    }\n \n   vexpr = pool_alloc (pool);\n   memcpy (vexpr, expr, tree_size (expr));\n+  \n+  /* This case is only for TREE_LIST's that appear as part of\n+     CALL_EXPR's.  Anything else is a bug, but we can't easily verify\n+     this, hence tihs comment.  TREE_LIST is not handled by the\n+     general case below is because they don't have a fixed length, or\n+     operands, so you can't access purpose/value/chain through\n+     TREE_OPERAND macros.  */\n+\n+  if (code == TREE_LIST)\n+    {\n+      tree temp = NULL_TREE;\n+      if (TREE_CHAIN (vexpr))\n+\ttemp = create_value_expr_from (TREE_CHAIN (vexpr), block, stmt);      \n+      TREE_CHAIN (vexpr) = temp ? temp : TREE_CHAIN (vexpr);\n+      \n+      /* This is the equivalent of inserting op into EXP_GEN like we\n+\t do below */\n+      if (!is_undefined_value (TREE_VALUE (vexpr)))\n+\tvalue_insert_into_set (EXP_GEN (block), TREE_VALUE (vexpr));      \n+\t  \n+      TREE_VALUE (vexpr) = vn_lookup_or_add (TREE_VALUE (vexpr), NULL);\n+\n+      return vexpr;\n+    }\n \n   for (i = 0; i < TREE_CODE_LENGTH (code); i++)\n     {\n@@ -1846,18 +2061,32 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \t  return NULL;\n \t}\n \n-      /* Recursively value-numberize reference ops */\n+      /* Recursively value-numberize reference ops and tree lists.  */\n       if (REFERENCE_CLASS_P (op))\n \t{\n \t  tree tempop = create_value_expr_from (op, block, stmt);\n \t  op = tempop ? tempop : op;\n \t  val = vn_lookup_or_add (op, stmt);\n \t}\n+      else if (TREE_CODE (op) == TREE_LIST)\n+\t{\n+\t  tree tempop;\n+\t  \n+\t  gcc_assert (TREE_CODE (expr) == CALL_EXPR);\n+\t  tempop = create_value_expr_from (op, block, stmt);\n+\t  \n+\t  op = tempop ? tempop : op;\n+\t  vn_lookup_or_add (op, NULL);\n+\t  /* Unlike everywhere else, we do *not* want to replace the\n+\t     TREE_LIST itself with a value number, because support\n+\t     functions we call will blow up.  */\n+\t  val = op;\n+\t}\n       else       \n \t/* Create a value handle for OP and add it to VEXPR.  */\n \tval = vn_lookup_or_add (op, NULL);\n \n-      if (!is_undefined_value (op))\n+      if (!is_undefined_value (op) && TREE_CODE (op) != TREE_LIST)\n \tvalue_insert_into_set (EXP_GEN (block), op);\n \n       if (TREE_CODE (val) == VALUE_HANDLE)\n@@ -1870,6 +2099,22 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n }\n \n \n+/* Return true if we can value number a call.  This is true if we have\n+   a pure or constant call.  */\n+static bool\n+can_value_number_call (tree stmt)\n+{\n+  tree call = get_call_expr_in (stmt);\n+\n+  /* This is a temporary restriction until we translate vuses through\n+     phi nodes.  */\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+    return false;  \n+  if (call_expr_flags (call)  & (ECF_PURE | ECF_CONST))\n+    return true;\n+  return false;\n+}\n+\n /* Compute the AVAIL set for all basic blocks.\n \n    This function performs value numbering of the statements in each basic\n@@ -1964,7 +2209,9 @@ compute_avail (void)\n \t      if (UNARY_CLASS_P (rhs)\n \t\t  || BINARY_CLASS_P (rhs)\n \t\t  || COMPARISON_CLASS_P (rhs)\n-\t\t  || REFERENCE_CLASS_P (rhs))\n+\t\t  || REFERENCE_CLASS_P (rhs)\n+\t\t  || (TREE_CODE (rhs) == CALL_EXPR\n+\t\t      && can_value_number_call (stmt)))\n \t\t{\n \t\t  /* For binary, unary, and reference expressions,\n \t\t     create a duplicate expression with the operands\n@@ -2245,6 +2492,12 @@ init_pre (bool do_fre)\n \t\t\t\t       tree_code_size (NEGATE_EXPR), 30);\n   reference_node_pool = create_alloc_pool (\"Reference tree nodes\",\n \t\t\t\t\t   tree_code_size (ARRAY_REF), 30);\n+  expression_node_pool = create_alloc_pool (\"Expression tree nodes\",\n+\t\t\t\t\t    tree_code_size (CALL_EXPR), 30);\n+  list_node_pool = create_alloc_pool (\"List tree nodes\",\n+\t\t\t\t      tree_code_size (TREE_LIST), 30);  \n+  comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n+      \t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n   FOR_ALL_BB (bb)\n     {\n       EXP_GEN (bb) = set_new (true);\n@@ -2273,6 +2526,9 @@ fini_pre (bool do_fre)\n   free_alloc_pool (binary_node_pool);\n   free_alloc_pool (reference_node_pool);\n   free_alloc_pool (unary_node_pool);\n+  free_alloc_pool (list_node_pool);\n+  free_alloc_pool (expression_node_pool);\n+  free_alloc_pool (comparison_node_pool);\n   htab_delete (phi_translate_table);\n   remove_fake_exit_edges ();\n \n@@ -2398,7 +2654,8 @@ struct tree_opt_pass pass_pre =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n+  TODO_update_ssa | TODO_dump_func | TODO_ggc_collect \n+  | TODO_verify_ssa, /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "e46fafaf30879c22cfcfb6b3203a5d71dcbd8c3e", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43da81be398890b7898e6b9f23cece186f5950fa/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=43da81be398890b7898e6b9f23cece186f5950fa", "patch": "@@ -119,9 +119,25 @@ expressions_equal_p (tree e1, tree e2)\n   te1 = TREE_TYPE (e1);\n   te2 = TREE_TYPE (e2);\n \n-  if (TREE_CODE (e1) == TREE_CODE (e2) \n-      && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n-      && operand_equal_p (e1, e2, OEP_PURE_SAME))\n+  if (TREE_CODE (e1) == TREE_LIST && TREE_CODE (e2) == TREE_LIST)\n+    {\n+      tree lop1 = e1;\n+      tree lop2 = e2;\n+      for (lop1 = e1, lop2 = e2;\n+\t   lop1 || lop2;\n+\t   lop1 = TREE_CHAIN (lop1), lop2 = TREE_CHAIN (lop2))\n+\t{\n+\t  if (!lop1 || !lop2)\n+\t    return false;\n+\t  if (!expressions_equal_p (TREE_VALUE (lop1), TREE_VALUE (lop2)))\n+\t    return false;\n+\t}\n+      return true;\n+\n+    }\n+  else if (TREE_CODE (e1) == TREE_CODE (e2) \n+\t   && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n+\t   && operand_equal_p (e1, e2, OEP_PURE_SAME))\n     return true;\n \n   return false;\n@@ -166,7 +182,7 @@ set_value_handle (tree e, tree v)\n {\n   if (TREE_CODE (e) == SSA_NAME)\n     SSA_NAME_VALUE (e) = v;\n-  else if (EXPR_P (e) || DECL_P (e))\n+  else if (EXPR_P (e) || DECL_P (e) || TREE_CODE (e) == TREE_LIST)\n     get_tree_ann (e)->common.value_handle = v;\n   else\n     /* Do nothing.  Constants are their own value handles.  */\n@@ -271,7 +287,7 @@ get_value_handle (tree expr)\n \n   if (TREE_CODE (expr) == SSA_NAME)\n     return SSA_NAME_VALUE (expr);\n-  else if (EXPR_P (expr) || DECL_P (expr))\n+  else if (EXPR_P (expr) || DECL_P (expr) || TREE_CODE (expr) == TREE_LIST)\n     {\n       tree_ann_t ann = tree_ann (expr);\n       return ((ann) ? ann->common.value_handle : NULL_TREE);"}]}