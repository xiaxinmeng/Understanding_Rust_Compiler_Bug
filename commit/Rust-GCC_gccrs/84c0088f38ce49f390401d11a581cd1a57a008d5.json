{"sha": "84c0088f38ce49f390401d11a581cd1a57a008d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRjMDA4OGYzOGNlNDlmMzkwNDAxZDExYTU4MWNkMWE1N2EwMDhkNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-06-22T18:40:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-06-22T18:40:56Z"}, "message": "Reorder IDENTIFIER flags\n\n\tReorder IDENTIFIER flags\n\tgcc/cp/\n\t* cp-tree.h (enum cp_identifier_kind): New.\n\t(IDENTIFIER_KIND_BIT_0, IDENTIFIER_KIND_BIT_1,\n\tIDENTIFIER_KIND_BIT_2): New.\n\t(IDENTIFIER_MARKED): Move to TREE_LANG_FLAG_4.\n\t(IDENTIFIER_VIRTUAL_P, IDENTIFIER_REPO_CHOSEN): Add\n\tIDENTIFIER_CHECK.\n\t(C_IS_RESERVED_WORD): Replace with ...\n\t(IDENTIFIER_KEYWORD_P): ... this.\n\t(IDENTIFIER_CTOR_OR_DTOR_P): Replace with ...\n\t(IDENTIFIER_CDTOR_P): ... this.\n\t(IDENTIFIER_CTOR_P, IDENTIFIER_DTOR_P): New.\n\t(IDENTIFIER_OPNAME_P): Replace with ...\n\t(IDENTIFIER_ANY_OP_P): ... this.\n\t(IDENTIFIER_ASSIGN_OP_P): New.\n\t(IDENTIFIER_TYPENAME_P): Replace with ...\n\t(IDENTIFIER_CONV_OP_P): ... this.\n\t(NEW_DELETE_OPNAME_P): Replace with ...\n\t(IDENTIFIER_NEWDEL_OP_P): ... this.\n\t(DECL_CONV_FN_P, DECL_OVERLOADED_OPERATOR_P): Adjust.\n\t(get_identifier_kind_name, set_identifier_kind): Declare.\n\t* lex.c (get_identifier_kind_name, set_identifier_kind): New.\n\t(init_operators): Adjust to avoid keywords, use\n\tset_identifier_kind. Copy TYPE_EXPR slot.\n\t(init_reswords): Call set_identifier_kind.\n\t(unqualified_name_lookup_error): Adjust.\n\t* operators.def (TYPE_EXPR): Remove.\n\t* decl.c (struct predefined_identifier): Move into ...\n\t(initialize_predefined_identifiers): ... here.  Call\n\tset_identifier_kind.\n\t(grokfndecl, check_var_type, grokdeclarator): Adjust.\n\t(grok_op_properties): Use IDENTIFIER_ANY_ASSIGN_OP to halve search\n\tspace.  Adjust.\n\t* call.c (name_as_c_string): Adjust.\n\t(build_new_method_call_1): Likewise.\n\t* cp-cilkplus.c (is_conversion_operator_function_decl_p):\n\tLikewise.\n\t* cxx-pretty-print.c (pp_cxx_unqualified_id): Adjust.\n\t* dump.c (cp_dump_tree): Adjust.\n\t* error.c (dump_decl_name): Adjust.\n\t* mangle.c (write_unqualified_id, write_member_name)\n\twrite_expression): Adjust.\n\t(mangle_conv_op_name_for_type): Use set_identifier_kind.\n\t* name-lookup.c (do_class_using_decl): Adjust.\n\t(lookup_name_fuzzy, lookup_name_real_1): Likewise.\n\t* parser.c (cp_lexer_get_preprocessor_token)\n\tcp_parser_direct_declarator): Likewise.\n\t* pt.c (push_template_decl_real, tsubst_decl, tsubst_baselink)\n\ttsubst_copy, tsubst_copy_and_build): Adjust.\n\t* ptree.c (cxx_print_identifier): Print identifier kind.\n\t* search.c (lookup_field_r, lookup_member)\n\tlookup_fnfields_idx_nolazy): Adjust.\n\t* semantics.c (finish_id_expression): Adjust..\n\t* typeck.c (cp_build_addr_expr_1): Adjust.\n\nFrom-SVN: r249571", "tree": {"sha": "cd6adfd3e1e3f4244a38c183860b2efd2b25593c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd6adfd3e1e3f4244a38c183860b2efd2b25593c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84c0088f38ce49f390401d11a581cd1a57a008d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c0088f38ce49f390401d11a581cd1a57a008d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84c0088f38ce49f390401d11a581cd1a57a008d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c0088f38ce49f390401d11a581cd1a57a008d5/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "13f752b27354d0b8f7ff0148973c6b478e6fdd9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f752b27354d0b8f7ff0148973c6b478e6fdd9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f752b27354d0b8f7ff0148973c6b478e6fdd9e"}], "stats": {"total": 564, "additions": 340, "deletions": 224}, "files": [{"sha": "6acbe8b6f706a09973cfad0315c905a229fa910e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -1,3 +1,59 @@\n+2017-06-22  Nathan Sidwell  <nathan@acm.org>\n+\n+\tReorder IDENTIFIER flags\n+\tgcc/cp/\n+\t* cp-tree.h (enum cp_identifier_kind): New.\n+\t(IDENTIFIER_KIND_BIT_0, IDENTIFIER_KIND_BIT_1,\n+\tIDENTIFIER_KIND_BIT_2): New.\n+\t(IDENTIFIER_MARKED): Move to TREE_LANG_FLAG_4.\n+\t(IDENTIFIER_VIRTUAL_P, IDENTIFIER_REPO_CHOSEN): Add IDENTIFIER_CHECK.\n+\t(C_IS_RESERVED_WORD): Replace with ...\n+\t(IDENTIFIER_KEYWORD_P): ... this.\n+\t(IDENTIFIER_CTOR_OR_DTOR_P): Replace with ...\n+\t(IDENTIFIER_CDTOR_P): ... this.\n+\t(IDENTIFIER_CTOR_P, IDENTIFIER_DTOR_P): New.\n+\t(IDENTIFIER_OPNAME_P): Replace with ...\n+\t(IDENTIFIER_ANY_OP_P): ... this.\n+\t(IDENTIFIER_ASSIGN_OP_P): New.\n+\t(IDENTIFIER_TYPENAME_P): Replace with ...\n+\t(IDENTIFIER_CONV_OP_P): ... this.\n+\t(NEW_DELETE_OPNAME_P): Replace with ...\n+\t(IDENTIFIER_NEWDEL_OP_P): ... this.\n+\t(DECL_CONV_FN_P, DECL_OVERLOADED_OPERATOR_P): Adjust.\n+\t(get_identifier_kind_name, set_identifier_kind): Declare.\n+\t* lex.c (get_identifier_kind_name, set_identifier_kind): New.\n+\t(init_operators): Adjust to avoid keywords, use\n+\tset_identifier_kind. Copy TYPE_EXPR slot.\n+\t(init_reswords): Call set_identifier_kind.\n+\t(unqualified_name_lookup_error): Adjust.\n+\t* operators.def (TYPE_EXPR): Remove.\n+\t* decl.c (struct predefined_identifier): Move into ...\n+\t(initialize_predefined_identifiers): ... here.  Call\n+\tset_identifier_kind.\n+\t(grokfndecl, check_var_type, grokdeclarator): Adjust.\n+\t(grok_op_properties): Use IDENTIFIER_ANY_ASSIGN_OP to halve search\n+\tspace.  Adjust.\n+\t* call.c (name_as_c_string): Adjust.\n+\t(build_new_method_call_1): Likewise.\n+\t* cp-cilkplus.c (is_conversion_operator_function_decl_p): Likewise.\n+\t* cxx-pretty-print.c (pp_cxx_unqualified_id): Adjust.\n+\t* dump.c (cp_dump_tree): Adjust.\n+\t* error.c (dump_decl_name): Adjust.\n+\t* mangle.c (write_unqualified_id, write_member_name,\n+\twrite_expression): Adjust.\n+\t(mangle_conv_op_name_for_type): Use set_identifier_kind.\n+\t* name-lookup.c (do_class_using_decl): Adjust.\n+\t(lookup_name_fuzzy, lookup_name_real_1): Likewise.\n+\t* parser.c (cp_lexer_get_preprocessor_token,\n+\tcp_parser_direct_declarator): Likewise.\n+\t* pt.c (push_template_decl_real, tsubst_decl, tsubst_baselink,\n+\ttsubst_copy, tsubst_copy_and_build): Adjust.\n+\t* ptree.c (cxx_print_identifier): Print identifier kind.\n+\t* search.c (lookup_field_r, lookup_member,\n+\tlookup_fnfields_idx_nolazy): Adjust.\n+\t* semantics.c (finish_id_expression): Adjust..\n+\t* typeck.c (cp_build_addr_expr_1): Adjust.\n+\n 2017-06-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/81154"}, {"sha": "2fc29da1c7ae329a79e9350e5e5d4cb817ee38b7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -8884,21 +8884,19 @@ name_as_c_string (tree name, tree type, bool *free_p)\n   /* Assume that we will not allocate memory.  */\n   *free_p = false;\n   /* Constructors and destructors are special.  */\n-  if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n+  if (IDENTIFIER_CDTOR_P (name))\n     {\n       pretty_name\n \t= CONST_CAST (char *, identifier_to_locale (IDENTIFIER_POINTER (constructor_name (type))));\n       /* For a destructor, add the '~'.  */\n-      if (name == complete_dtor_identifier\n-\t  || name == base_dtor_identifier\n-\t  || name == deleting_dtor_identifier)\n+      if (IDENTIFIER_DTOR_P (name))\n \t{\n \t  pretty_name = concat (\"~\", pretty_name, NULL);\n \t  /* Remember that we need to free the memory allocated.  */\n \t  *free_p = true;\n \t}\n     }\n-  else if (IDENTIFIER_TYPENAME_P (name))\n+  else if (IDENTIFIER_CONV_OP_P (name))\n     {\n       pretty_name = concat (\"operator \",\n \t\t\t    type_as_string_translate (TREE_TYPE (name),\n@@ -9015,7 +9013,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n      pointer if this is a call to a base-class constructor or\n      destructor.  */\n   skip_first_for_error = false;\n-  if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n+  if (IDENTIFIER_CDTOR_P (name))\n     {\n       /* Callers should explicitly indicate whether they want to construct\n \t the complete object or just the part without virtual bases.  */\n@@ -9143,7 +9141,7 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n \t    {\n \t      tree arglist = build_tree_list_vec (user_args);\n \t      tree errname = name;\n-\t      if (IDENTIFIER_CTOR_OR_DTOR_P (errname))\n+\t      if (IDENTIFIER_CDTOR_P (errname))\n \t\t{\n \t\t  tree fn = DECL_ORIGIN (OVL_FIRST (fns));\n \t\t  errname = DECL_NAME (fn);"}, {"sha": "5ccf5d3385dff08bf118a44541811804cb58ec82", "filename": "gcc/cp/cp-cilkplus.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcp-cilkplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcp-cilkplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-cilkplus.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -36,7 +36,7 @@ is_conversion_operator_function_decl_p (tree t)\n   if (TREE_CODE (t) != FUNCTION_DECL)\n     return false;\n \n-  return DECL_NAME (t) && IDENTIFIER_TYPENAME_P (DECL_NAME (t));\n+  return DECL_CONV_FN_P (t);\n }\n \n /* Recursively traverse EXP to search for a CILK_SPAWN_STMT subtree."}, {"sha": "40c113b2c10346eace501a263527ec352e0abb93", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 85, "deletions": 40, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -298,7 +298,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #include \"name-lookup.h\"\n \n /* Usage of TREE_LANG_FLAG_?:\n-   0: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n+   0: IDENTIFIER_KIND_BIT_0 (in IDENTIFIER_NODE)\n       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).\n       COND_EXPR_IS_VEC_DELETE (in COND_EXPR).\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n@@ -339,7 +339,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       IF_STMT_CONSTEXPR_P (IF_STMT)\n       TEMPLATE_TYPE_PARM_FOR_CLASS (TEMPLATE_TYPE_PARM)\n       DECL_NAMESPACE_INLINE_P (in NAMESPACE_DECL)\n-   1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n+   1: IDENTIFIER_KIND_BIT_1 (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n       DELETE_EXPR_USE_VEC (in DELETE_EXPR).\n@@ -357,7 +357,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)\n       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)\n       OVL_USING_P (in OVERLOAD)\n-   2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n+   2: IDENTIFIER_KIND_BIT_2 (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n@@ -372,21 +372,20 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n-      IDENTIFIER_CTOR_OR_DTOR_P (in IDENTIFIER_NODE)\n       BIND_EXPR_BODY_BLOCK (in BIND_EXPR)\n       DECL_NON_TRIVIALLY_INITIALIZED_P (in VAR_DECL)\n       CALL_EXPR_ORDERED_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n       DECLTYPE_FOR_REF_CAPTURE (in DECLTYPE_TYPE)\n       CONSTUCTOR_C99_COMPOUND_LITERAL (in CONSTRUCTOR)\n       OVL_NESTED_P (in OVERLOAD)\n-   4: TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n+   4: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n+      TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n \t  CALL_EXPR, or FIELD_DECL).\n-      IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n       DECL_TINFO_P (in VAR_DECL)\n       FUNCTION_REF_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n       OVL_LOOKUP_P (in OVERLOAD)\n       LOOKUP_FOUND_P (in RECORD_TYPE, UNION_TYPE, NAMESPACE_DECL)\n-   5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n+   5: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n       FUNCTION_RVALUE_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n       CALL_EXPR_REVERSE_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n@@ -566,11 +565,6 @@ struct default_hash_traits <lang_identifier *>\n   static void remove (value_type) { gcc_unreachable (); }\n };\n \n-/* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n-   keyword.  C_RID_CODE (node) is then the RID_* value of the keyword.  */\n-\n-#define C_IS_RESERVED_WORD(ID) TREE_LANG_FLAG_5 (ID)\n-\n #define LANG_IDENTIFIER_CAST(NODE) \\\n \t((struct lang_identifier*)IDENTIFIER_NODE_CHECK (NODE))\n \n@@ -987,29 +981,89 @@ enum GTY(()) abstract_class_use {\n #define SET_IDENTIFIER_LABEL_VALUE(NODE, VALUE)   \\\n   IDENTIFIER_LABEL_VALUE (NODE) = (VALUE)\n \n-/* Nonzero if this identifier is used as a virtual function name somewhere\n-   (optimizes searches).  */\n-#define IDENTIFIER_VIRTUAL_P(NODE) TREE_LANG_FLAG_1 (NODE)\n+/* Kinds of identifiers.  Values are carefully chosen.  */\n+enum cp_identifier_kind {\n+  cik_normal = 0,\t/* Not a special identifier.  */\n+  cik_keyword = 1,\t/* A keyword.  */\n+  cik_ctor = 2,\t\t/* Constructor (in-chg, complete or base).  */\n+  cik_dtor = 3,\t\t/* Destructor (in-chg, deleting, complete or\n+\t\t\t   base).  */\n+  cik_simple_op = 4,\t/* Non-assignment operator name.  */\n+  cik_newdel_op = 5,\t/* New or delete operator name.  */\n+  cik_assign_op = 6,\t/* An assignment operator name.  */\n+  cik_conv_op = 7,\t/* Conversion operator name.  */\n+  cik_max\n+};\n \n-/* Nonzero if this identifier is the prefix for a mangled C++ operator\n-   name.  */\n-#define IDENTIFIER_OPNAME_P(NODE) TREE_LANG_FLAG_2 (NODE)\n+/* Kind bits.  */\n+#define IDENTIFIER_KIND_BIT_0(NODE) \\\n+  TREE_LANG_FLAG_0 (IDENTIFIER_NODE_CHECK (NODE))\n+#define IDENTIFIER_KIND_BIT_1(NODE) \\\n+  TREE_LANG_FLAG_1 (IDENTIFIER_NODE_CHECK (NODE))\n+#define IDENTIFIER_KIND_BIT_2(NODE) \\\n+  TREE_LANG_FLAG_2 (IDENTIFIER_NODE_CHECK (NODE))\n \n-/* Nonzero if this identifier is the name of a type-conversion\n-   operator.  */\n-#define IDENTIFIER_TYPENAME_P(NODE) \\\n-  TREE_LANG_FLAG_4 (NODE)\n+/* Used by various search routines.  */\n+#define IDENTIFIER_MARKED(NODE) \\\n+  TREE_LANG_FLAG_4 (IDENTIFIER_NODE_CHECK (NODE))\n \n-/* Nonzero if this identifier is the name of a constructor or\n-   destructor.  */\n-#define IDENTIFIER_CTOR_OR_DTOR_P(NODE) \\\n-  TREE_LANG_FLAG_3 (NODE)\n+/* Nonzero if this identifier is used as a virtual function name somewhere\n+   (optimizes searches).  */\n+#define IDENTIFIER_VIRTUAL_P(NODE) \\\n+  TREE_LANG_FLAG_5 (IDENTIFIER_NODE_CHECK (NODE))\n \n /* True iff NAME is the DECL_ASSEMBLER_NAME for an entity with vague\n    linkage which the prelinker has assigned to this translation\n    unit.  */\n #define IDENTIFIER_REPO_CHOSEN(NAME) \\\n-  (TREE_LANG_FLAG_6 (NAME))\n+  (TREE_LANG_FLAG_6 (IDENTIFIER_NODE_CHECK (NAME)))\n+\n+/* True if this identifier is a reserved word.  C_RID_CODE (node) is\n+   then the RID_* value of the keyword.  Value 1.  */\n+#define IDENTIFIER_KEYWORD_P(NODE)\t\t\\\n+  ((!IDENTIFIER_KIND_BIT_2 (NODE))\t\t\\\n+   & (!IDENTIFIER_KIND_BIT_1 (NODE))\t\t\\\n+   & IDENTIFIER_KIND_BIT_0 (NODE))\n+\n+/* True if this identifier is the name of a constructor or\n+   destructor.  Value 2 or 3.  */\n+#define IDENTIFIER_CDTOR_P(NODE)\t\t\\\n+  ((!IDENTIFIER_KIND_BIT_2 (NODE))\t\t\\\n+   & IDENTIFIER_KIND_BIT_1 (NODE))\n+\n+/* True if this identifier is the name of a constructor.  Value 2.  */\n+#define IDENTIFIER_CTOR_P(NODE)\t\t\t\\\n+  (IDENTIFIER_CDTOR_P(NODE)\t\t\t\\\n+    & (!IDENTIFIER_KIND_BIT_0 (NODE)))\n+\n+/* True if this identifier is the name of a destructor.  Value 3.  */\n+#define IDENTIFIER_DTOR_P(NODE)\t\t\t\\\n+  (IDENTIFIER_CDTOR_P(NODE)\t\t\t\\\n+    & IDENTIFIER_KIND_BIT_0 (NODE))\n+\n+/* True if this identifier is for any operator name (including\n+   conversions).  Value 4, 5, 6 or 7.  */\n+#define IDENTIFIER_ANY_OP_P(NODE)\t\t\\\n+  (IDENTIFIER_KIND_BIT_2 (NODE))\n+\n+/* True if this identifier is for new or delete operator.  Value 5.  */\n+#define IDENTIFIER_NEWDEL_OP_P(NODE)\t\t\\\n+  (IDENTIFIER_KIND_BIT_2 (NODE)\t\t\t\\\n+   & (!IDENTIFIER_KIND_BIT_1 (NODE))\t\t\\\n+   & IDENTIFIER_KIND_BIT_0 (NODE))\n+\n+/* True if this identifier is for any assignment. Values 6.  */\n+#define IDENTIFIER_ASSIGN_OP_P(NODE)\t\t\\\n+  (IDENTIFIER_KIND_BIT_2 (NODE)\t\t\t\\\n+   & IDENTIFIER_KIND_BIT_1 (NODE)\t\t\\\n+   & (!IDENTIFIER_KIND_BIT_0 (NODE)))\n+\n+/* True if this identifier is the name of a type-conversion\n+   operator.  Value 7.  */\n+#define IDENTIFIER_CONV_OP_P(NODE)\t\t\\\n+  (IDENTIFIER_KIND_BIT_2 (NODE)\t\t\t\\\n+   & IDENTIFIER_KIND_BIT_1 (NODE)\t\t\\\n+   & IDENTIFIER_KIND_BIT_0 (NODE))\n \n /* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n #define C_TYPE_FIELDS_READONLY(TYPE) \\\n@@ -1718,14 +1772,6 @@ struct GTY(()) language_function {\n #define current_function_auto_return_pattern \\\n   (cp_function_chain->x_auto_return_pattern)\n \n-/* True if NAME is the IDENTIFIER_NODE for an overloaded \"operator\n-   new\" or \"operator delete\".  */\n-#define NEW_DELETE_OPNAME_P(NAME)\t\t\\\n-  ((NAME) == cp_operator_id (NEW_EXPR)\t\t\\\n-   || (NAME) == cp_operator_id (VEC_NEW_EXPR)\t\\\n-   || (NAME) == cp_operator_id (DELETE_EXPR)\t\\\n-   || (NAME) == cp_operator_id (VEC_DELETE_EXPR))\n-\n #define cp_operator_id(CODE) \\\n   (operator_name_info[(int) (CODE)].identifier)\n #define cp_assignment_operator_id(CODE) \\\n@@ -2313,9 +2359,6 @@ struct GTY(()) lang_type {\n \n /* Nonzero if this BINFO is a primary base class.  */\n #define BINFO_PRIMARY_P(NODE) BINFO_FLAG_5(NODE)\n-\n-/* Used by various search routines.  */\n-#define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n /* A vec<tree_pair_s> of the vcall indices associated with the class\n    NODE.  The PURPOSE of each element is a FUNCTION_DECL for a virtual\n@@ -2766,7 +2809,7 @@ struct GTY(()) lang_decl {\n \n /* Nonzero if NODE is a user-defined conversion operator.  */\n #define DECL_CONV_FN_P(NODE) \\\n-  (DECL_NAME (NODE) && IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)))\n+  (DECL_NAME (NODE) && IDENTIFIER_CONV_OP_P (DECL_NAME (NODE)))\n \n /* If FN is a conversion operator, the type to which it converts.\n    Otherwise, NULL_TREE.  */\n@@ -2800,7 +2843,7 @@ struct GTY(()) lang_decl {\n    value of ERROR_MARK is zero, this macro can be used as a predicate\n    to test whether or not NODE is an overloaded operator.  */\n #define DECL_OVERLOADED_OPERATOR_P(NODE)\t\t\\\n-  (IDENTIFIER_OPNAME_P (DECL_NAME (NODE))\t\t\\\n+  (IDENTIFIER_ANY_OP_P (DECL_NAME (NODE))\t\t\\\n    ? LANG_DECL_FN_CHECK (NODE)->operator_code : ERROR_MARK)\n \n /* Nonzero if NODE is an assignment operator (including += and such).  */\n@@ -6305,6 +6348,8 @@ extern tree copy_decl\t\t\t\t(tree CXX_MEM_STAT_INFO);\n extern tree copy_type\t\t\t\t(tree CXX_MEM_STAT_INFO);\n extern tree cxx_make_type\t\t\t(enum tree_code);\n extern tree make_class_type\t\t\t(enum tree_code);\n+extern const char *get_identifier_kind_name\t(tree);\n+extern void set_identifier_kind\t\t\t(tree, cp_identifier_kind);\n extern bool cxx_init\t\t\t\t(void);\n extern void cxx_finish\t\t\t\t(void);\n extern bool in_main_input_context\t\t(void);"}, {"sha": "5398e3dd87df03ab66b1f431be90233f35e9196e", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -159,7 +159,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n     case IDENTIFIER_NODE:\n       if (t == NULL)\n \tpp->translate_string (\"<unnamed>\");\n-      else if (IDENTIFIER_TYPENAME_P (t))\n+      else if (IDENTIFIER_CONV_OP_P (t))\n \tpp_cxx_conversion_function_id (pp, t);\n       else\n \t{"}, {"sha": "b0a34de5dd9303eda21660fc777d0c243603ecec", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 90, "deletions": 105, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -3948,62 +3948,56 @@ record_unknown_type (tree type, const char* name)\n   SET_TYPE_MODE (type, TYPE_MODE (void_type_node));\n }\n \n-/* A string for which we should create an IDENTIFIER_NODE at\n-   startup.  */\n-\n-struct predefined_identifier\n-{\n-  /* The name of the identifier.  */\n-  const char *const name;\n-  /* The place where the IDENTIFIER_NODE should be stored.  */\n-  tree *const node;\n-  /* Nonzero if this is the name of a constructor or destructor.  */\n-  const int ctor_or_dtor_p;\n-};\n-\n /* Create all the predefined identifiers.  */\n \n static void\n initialize_predefined_identifiers (void)\n {\n-  const predefined_identifier *pid;\n+  struct predefined_identifier\n+  {\n+    const char *name; /* Name.  */\n+    tree *node;  /* Node to store it in.  */\n+    cp_identifier_kind kind;  /* Kind of identifier.  */\n+  };\n \n   /* A table of identifiers to create at startup.  */\n   static const predefined_identifier predefined_identifiers[] = {\n-    { \"C++\", &lang_name_cplusplus, 0 },\n-    { \"C\", &lang_name_c, 0 },\n+    {\"C++\", &lang_name_cplusplus, cik_normal},\n+    {\"C\", &lang_name_c, cik_normal},\n     /* Some of these names have a trailing space so that it is\n        impossible for them to conflict with names written by users.  */\n-    { \"__ct \", &ctor_identifier, 1 },\n-    { \"__base_ctor \", &base_ctor_identifier, 1 },\n-    { \"__comp_ctor \", &complete_ctor_identifier, 1 },\n-    { \"__dt \", &dtor_identifier, 1 },\n-    { \"__comp_dtor \", &complete_dtor_identifier, 1 },\n-    { \"__base_dtor \", &base_dtor_identifier, 1 },\n-    { \"__deleting_dtor \", &deleting_dtor_identifier, 1 },\n-    { IN_CHARGE_NAME, &in_charge_identifier, 0 },\n-    { THIS_NAME, &this_identifier, 0 },\n-    { VTABLE_DELTA_NAME, &delta_identifier, 0 },\n-    { VTABLE_PFN_NAME, &pfn_identifier, 0 },\n-    { \"_vptr\", &vptr_identifier, 0 },\n-    { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n-    { \"::\", &global_identifier, 0 },\n-    { \"std\", &std_identifier, 0 },\n+    {\"__ct \", &ctor_identifier, cik_ctor},\n+    {\"__base_ctor \", &base_ctor_identifier, cik_ctor},\n+    {\"__comp_ctor \", &complete_ctor_identifier, cik_ctor},\n+    {\"__dt \", &dtor_identifier, cik_dtor},\n+    {\"__comp_dtor \", &complete_dtor_identifier, cik_dtor},\n+    {\"__base_dtor \", &base_dtor_identifier, cik_dtor},\n+    {\"__deleting_dtor \", &deleting_dtor_identifier, cik_dtor},\n+    {IN_CHARGE_NAME, &in_charge_identifier, cik_normal},\n+    {THIS_NAME, &this_identifier, cik_normal},\n+    {VTABLE_DELTA_NAME, &delta_identifier, cik_normal},\n+    {VTABLE_PFN_NAME, &pfn_identifier, cik_normal},\n+    {\"_vptr\", &vptr_identifier, cik_normal},\n+    {\"__vtt_parm\", &vtt_parm_identifier, cik_normal},\n+    {\"::\", &global_identifier, cik_normal},\n+    {\"std\", &std_identifier, cik_normal},\n       /* The demangler expects anonymous namespaces to be called\n \t something starting with '_GLOBAL__N_'.  It no longer needs\n \t to be unique to the TU.  */\n-    { \"_GLOBAL__N_1\", &anon_identifier, 0 },\n-    { \"auto\", &auto_identifier, 0 },\n-    { \"decltype(auto)\", &decltype_auto_identifier, 0 },\n-    { \"initializer_list\", &init_list_identifier, 0 },\n-    { NULL, NULL, 0 }\n+    {\"_GLOBAL__N_1\", &anon_identifier, cik_normal},\n+    {\"auto\", &auto_identifier, cik_normal},\n+    {\"decltype(auto)\", &decltype_auto_identifier, cik_normal},\n+    {\"initializer_list\", &init_list_identifier, cik_normal},\n+    {NULL, NULL, cik_normal}\n   };\n \n-  for (pid = predefined_identifiers; pid->name; ++pid)\n+  for (const predefined_identifier *pid = predefined_identifiers;\n+       pid->name; ++pid)\n     {\n       *pid->node = get_identifier (pid->name);\n-      if (pid->ctor_or_dtor_p)\n-\tIDENTIFIER_CTOR_OR_DTOR_P (*pid->node) = 1;\n+      /* Some of these identifiers already have a special kind.  */\n+      if (pid->kind != cik_normal)\n+\tset_identifier_kind (*pid->node, pid->kind);\n     }\n }\n \n@@ -8721,7 +8715,7 @@ grokfndecl (tree ctype,\n \terror_at (location,\n \t\t  \"deduction guide %qD must not have a function body\", decl);\n     }\n-  else if (IDENTIFIER_OPNAME_P (DECL_NAME (decl))\n+  else if (IDENTIFIER_ANY_OP_P (DECL_NAME (decl))\n       && !grok_op_properties (decl, /*complain=*/true))\n     return NULL_TREE;\n   else if (UDLIT_OPER_P (DECL_NAME (decl)))\n@@ -9773,7 +9767,7 @@ check_var_type (tree identifier, tree type)\n \terror (\"unnamed variable or field declared void\");\n       else if (identifier_p (identifier))\n \t{\n-\t  gcc_assert (!IDENTIFIER_OPNAME_P (identifier));\n+\t  gcc_assert (!IDENTIFIER_ANY_OP_P (identifier));\n \t  error (\"variable or field %qE declared void\", identifier);\n \t}\n       else\n@@ -10114,26 +10108,21 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t\t  dname = fns;\n \t\t  if (!identifier_p (dname))\n-\t\t    {\n-\t\t      if (variable_template_p (dname))\n-\t\t\tdname = DECL_NAME (dname);\n-\t\t      else\n-\t\t\tdname = OVL_NAME (dname);\n-\t\t    }\n+\t\t    dname = OVL_NAME (dname);\n \t\t}\n \t\t/* Fall through.  */\n \n \t      case IDENTIFIER_NODE:\n \t\tif (identifier_p (decl))\n \t\t  dname = decl;\n \n-\t\tif (C_IS_RESERVED_WORD (dname))\n+\t\tif (IDENTIFIER_KEYWORD_P (dname))\n \t\t  {\n \t\t    error (\"declarator-id missing; using reserved word %qD\",\n \t\t\t   dname);\n \t\t    name = identifier_to_locale (IDENTIFIER_POINTER (dname));\n \t\t  }\n-\t\telse if (!IDENTIFIER_TYPENAME_P (dname))\n+\t\telse if (!IDENTIFIER_CONV_OP_P (dname))\n \t\t  name = identifier_to_locale (IDENTIFIER_POINTER (dname));\n \t\telse\n \t\t  {\n@@ -10192,26 +10181,27 @@ grokdeclarator (const cp_declarator *declarator,\n       return error_mark_node;\n     }\n \n-  if (dname\n-      && identifier_p (dname)\n-      && UDLIT_OPER_P (dname)\n-      && innermost_code != cdk_function)\n-    {\n-      error (\"declaration of %qD as non-function\", dname);\n-      return error_mark_node;\n-    }\n-\n-  if (dname && IDENTIFIER_OPNAME_P (dname))\n+  if (dname && identifier_p (dname))\n     {\n-      if (typedef_p)\n+      if (UDLIT_OPER_P (dname)\n+\t  && innermost_code != cdk_function)\n \t{\n-\t  error (\"declaration of %qD as %<typedef%>\", dname);\n+\t  error (\"declaration of %qD as non-function\", dname);\n \t  return error_mark_node;\n \t}\n-      else if (decl_context == PARM || decl_context == CATCHPARM)\n+\n+      if (IDENTIFIER_ANY_OP_P (dname))\n \t{\n-\t  error (\"declaration of %qD as parameter\", dname);\n-\t  return error_mark_node;\n+\t  if (typedef_p)\n+\t    {\n+\t      error (\"declaration of %qD as %<typedef%>\", dname);\n+\t      return error_mark_node;\n+\t    }\n+\t  else if (decl_context == PARM || decl_context == CATCHPARM)\n+\t    {\n+\t      error (\"declaration of %qD as parameter\", dname);\n+\t      return error_mark_node;\n+\t    }\n \t}\n     }\n \n@@ -11708,22 +11698,20 @@ grokdeclarator (const cp_declarator *declarator,\n       return error_mark_node;\n     }\n \n-  /* Only functions may be declared using an operator-function-id.  */\n-  if (unqualified_id\n-      && IDENTIFIER_OPNAME_P (unqualified_id)\n-      && TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != METHOD_TYPE)\n+  if (!FUNC_OR_METHOD_TYPE_P (type))\n     {\n-      error (\"declaration of %qD as non-function\", unqualified_id);\n-      return error_mark_node;\n-    }\n+      /* Only functions may be declared using an operator-function-id.  */\n+      if (dname && IDENTIFIER_ANY_OP_P (dname))\n+\t{\n+\t  error (\"declaration of %qD as non-function\", dname);\n+\t  return error_mark_node;\n+\t}\n \n-  if (reqs\n-      && TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != METHOD_TYPE)\n-    error_at (location_of (reqs),\n-\t      \"requires-clause on declaration of non-function type %qT\",\n-\t      type);\n+      if (reqs)\n+\terror_at (location_of (reqs),\n+\t\t  \"requires-clause on declaration of non-function type %qT\",\n+\t\t  type);\n+    }\n \n   /* We don't check parameter types here because we can emit a better\n      error message later.  */\n@@ -11768,7 +11756,8 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   if (ctype && TREE_CODE (type) == FUNCTION_TYPE && staticp < 2\n-      && !NEW_DELETE_OPNAME_P (unqualified_id))\n+      && !(identifier_p (unqualified_id)\n+\t   && IDENTIFIER_NEWDEL_OP_P (unqualified_id)))\n     {\n       cp_cv_quals real_quals = memfn_quals;\n       if (cxx_dialect < cxx14 && constexpr_p\n@@ -11879,15 +11868,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    return error_mark_node;\n \t\t  }\n \n-\t\tif (NEW_DELETE_OPNAME_P (unqualified_id))\n+\t\tif (virtualp\n+\t\t    && identifier_p (unqualified_id)\n+\t\t    && IDENTIFIER_NEWDEL_OP_P (unqualified_id))\n \t\t  {\n-\t\t    if (virtualp)\n-\t\t      {\n-\t\t\terror (\"%qD cannot be declared %<virtual%>, since it \"\n-\t\t\t       \"is always static\",\n-\t\t\t       unqualified_id);\n-\t\t\tvirtualp = 0;\n-\t\t      }\n+\t\t    error (\"%qD cannot be declared %<virtual%>, since it \"\n+\t\t\t   \"is always static\", unqualified_id);\n+\t\t    virtualp = 0;\n \t\t  }\n \t      }\n \n@@ -12149,6 +12136,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  original_name = dname;\n \telse\n \t  original_name = unqualified_id;\n+\t// FIXME:gcc_assert (original_name == dname);\n \n \tif (storage_class == sc_auto)\n \t  error (\"storage class %<auto%> invalid for function %qs\", name);\n@@ -12943,27 +12931,24 @@ grok_op_properties (tree decl, bool complain)\n   if (class_type && !CLASS_TYPE_P (class_type))\n     class_type = NULL_TREE;\n \n-  if (DECL_CONV_FN_P (decl))\n+  if (IDENTIFIER_CONV_OP_P (name))\n     operator_code = TYPE_EXPR;\n   else\n-    do\n-      {\n-#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, ASSN_P)\t\\\n-\tif (cp_operator_id (CODE) == name)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    operator_code = (CODE);\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\telse if (cp_assignment_operator_id (CODE) == name)\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    operator_code = (CODE);\t\t\t\t\\\n-\t    DECL_ASSIGNMENT_OPERATOR_P (decl) = 1;\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t  }\n-\n+    {\n+      /* It'd be nice to hang something else of the identifier to\n+\t find CODE more directly.  */\n+      const operator_name_info_t *oni\n+\t= (IDENTIFIER_ASSIGN_OP_P (name)\n+\t   ? assignment_operator_name_info : operator_name_info);\n+      DECL_ASSIGNMENT_OPERATOR_P (decl) = IDENTIFIER_ASSIGN_OP_P (name);\n+      if (false)\n+\t;\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, KIND)\t\t\\\n+      else if (oni[int (CODE)].identifier == name)\t\t\\\n+\toperator_code = (CODE);\n #include \"operators.def\"\n #undef DEF_OPERATOR\n-\n+      else\n \tgcc_unreachable ();\n       }\n     while (0);\n@@ -13082,7 +13067,7 @@ grok_op_properties (tree decl, bool complain)\n \treturn true;\n \n       /* Warn about conversion operators that will never be used.  */\n-      if (IDENTIFIER_TYPENAME_P (name)\n+      if (IDENTIFIER_CONV_OP_P (name)\n \t  && ! DECL_TEMPLATE_INFO (decl)\n \t  && warn_conversion\n \t  /* Warn only declaring the function; there is no need to"}, {"sha": "6fafa5b792ec8cef5bebba95062025d50c35f98c", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -226,12 +226,12 @@ cp_dump_tree (void* dump_info, tree t)\n   switch (code)\n     {\n     case IDENTIFIER_NODE:\n-      if (IDENTIFIER_OPNAME_P (t))\n+      if (IDENTIFIER_ANY_OP_P (t))\n \t{\n \t  dump_string_field (di, \"note\", \"operator\");\n \t  return true;\n \t}\n-      else if (IDENTIFIER_TYPENAME_P (t))\n+      else if (IDENTIFIER_CONV_OP_P (t))\n \t{\n \t  dump_child (\"tynm\", TREE_TYPE (t));\n \t  return true;"}, {"sha": "86fa804b317a895e7a1e54f1fa1c8feb395d0721", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -1051,7 +1051,7 @@ dump_decl_name (cxx_pretty_printer *pp, tree t, int flags)\n {\n   /* These special cases are duplicated here so that other functions\n      can feed identifiers to error and get them demangled properly.  */\n-  if (IDENTIFIER_TYPENAME_P (t))\n+  if (IDENTIFIER_CONV_OP_P (t))\n     {\n       pp_cxx_ws_string (pp, \"operator\");\n       /* Not exactly IDENTIFIER_TYPE_VALUE.  */"}, {"sha": "2fa26739c8076870b68c43f3812e1f3239d85c9d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -89,29 +89,64 @@ operator_name_info_t assignment_operator_name_info[(int) MAX_TREE_CODES];\n #include \"operators.def\"\n #undef DEF_OPERATOR\n \n+/* Get the name of the kind of identifier T.  */\n+\n+const char *\n+get_identifier_kind_name (tree id)\n+{\n+  /* Keep in sync with cp_id_kind enumeration.  */\n+  static const char *const names[cik_max] = {\n+    \"normal\", \"keyword\", \"constructor\", \"destructor\",\n+    \"assign-op\", \"op-assign-op\", \"simple-op\", \"conv-op\", };\n+\n+  unsigned kind = 0;\n+  kind |= IDENTIFIER_KIND_BIT_2 (id) << 2;\n+  kind |= IDENTIFIER_KIND_BIT_1 (id) << 1;\n+  kind |= IDENTIFIER_KIND_BIT_0 (id) << 0;\n+\n+  return names[kind];\n+}\n+\n+/* Set the identifier kind, which we expect to currently be zero.  */\n+\n+void\n+set_identifier_kind (tree id, cp_identifier_kind kind)\n+{\n+  gcc_checking_assert (!IDENTIFIER_KIND_BIT_2 (id)\n+\t\t       & !IDENTIFIER_KIND_BIT_1 (id)\n+\t\t       & !IDENTIFIER_KIND_BIT_0 (id));\n+  IDENTIFIER_KIND_BIT_2 (id) |= (kind >> 2) & 1;\n+  IDENTIFIER_KIND_BIT_1 (id) |= (kind >> 1) & 1;\n+  IDENTIFIER_KIND_BIT_0 (id) |= (kind >> 0) & 1;\n+}\n+\n static void\n init_operators (void)\n {\n   tree identifier;\n   char buffer[256];\n   struct operator_name_info_t *oni;\n \n-#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, ASSN_P)\t\t    \\\n-  sprintf (buffer, ISALPHA (NAME[0]) ? \"operator %s\" : \"operator%s\", NAME); \\\n-  identifier = get_identifier (buffer);\t\t\t\t\t    \\\n-  IDENTIFIER_OPNAME_P (identifier) = 1;\t\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-  oni = (ASSN_P\t\t\t\t\t\t\t\t    \\\n-\t ? &assignment_operator_name_info[(int) CODE]\t\t\t    \\\n-\t : &operator_name_info[(int) CODE]);\t\t\t\t    \\\n-  oni->identifier = identifier;\t\t\t\t\t\t    \\\n-  oni->name = NAME;\t\t\t\t\t\t\t    \\\n-  oni->mangled_name = MANGLING;\t\t\t\t\t\t    \\\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, KIND)\t\t\t\\\n+  sprintf (buffer, \"operator%s%s\", !NAME[0]\t\t\t\t\\\n+\t   || NAME[0] == '_' || ISALPHA (NAME[0]) ? \" \" : \"\", NAME);\t\\\n+  identifier = get_identifier (buffer);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (KIND != cik_simple_op || !IDENTIFIER_ANY_OP_P (identifier))\t\\\n+    set_identifier_kind (identifier, KIND);\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  oni = (KIND == cik_assign_op\t\t\t\t\t\t\\\n+\t ? &assignment_operator_name_info[(int) CODE]\t\t\t\\\n+\t : &operator_name_info[(int) CODE]);\t\t\t\t\\\n+  oni->identifier = identifier;\t\t\t\t\t\t\\\n+  oni->name = NAME;\t\t\t\t\t\t\t\\\n+  oni->mangled_name = MANGLING;\t\t\t\t\t\t\\\n   oni->arity = ARITY;\n \n #include \"operators.def\"\n #undef DEF_OPERATOR\n \n+  operator_name_info[(int) TYPE_EXPR] = operator_name_info[(int) CAST_EXPR];\n   operator_name_info[(int) ERROR_MARK].identifier\n     = get_identifier (\"<invalid operator>\");\n \n@@ -123,33 +158,28 @@ init_operators (void)\n \n   operator_name_info [(int) INIT_EXPR].name\n     = operator_name_info [(int) MODIFY_EXPR].name;\n+\n   operator_name_info [(int) EXACT_DIV_EXPR].name = \"(ceiling /)\";\n   operator_name_info [(int) CEIL_DIV_EXPR].name = \"(ceiling /)\";\n   operator_name_info [(int) FLOOR_DIV_EXPR].name = \"(floor /)\";\n   operator_name_info [(int) ROUND_DIV_EXPR].name = \"(round /)\";\n   operator_name_info [(int) CEIL_MOD_EXPR].name = \"(ceiling %)\";\n   operator_name_info [(int) FLOOR_MOD_EXPR].name = \"(floor %)\";\n   operator_name_info [(int) ROUND_MOD_EXPR].name = \"(round %)\";\n+\n   operator_name_info [(int) ABS_EXPR].name = \"abs\";\n   operator_name_info [(int) TRUTH_AND_EXPR].name = \"strict &&\";\n   operator_name_info [(int) TRUTH_OR_EXPR].name = \"strict ||\";\n   operator_name_info [(int) RANGE_EXPR].name = \"...\";\n   operator_name_info [(int) UNARY_PLUS_EXPR].name = \"+\";\n \n-  assignment_operator_name_info [(int) EXACT_DIV_EXPR].name\n-    = \"(exact /=)\";\n-  assignment_operator_name_info [(int) CEIL_DIV_EXPR].name\n-    = \"(ceiling /=)\";\n-  assignment_operator_name_info [(int) FLOOR_DIV_EXPR].name\n-    = \"(floor /=)\";\n-  assignment_operator_name_info [(int) ROUND_DIV_EXPR].name\n-    = \"(round /=)\";\n-  assignment_operator_name_info [(int) CEIL_MOD_EXPR].name\n-    = \"(ceiling %=)\";\n-  assignment_operator_name_info [(int) FLOOR_MOD_EXPR].name\n-    = \"(floor %=)\";\n-  assignment_operator_name_info [(int) ROUND_MOD_EXPR].name\n-    = \"(round %=)\";\n+  assignment_operator_name_info [(int) EXACT_DIV_EXPR].name = \"(exact /=)\";\n+  assignment_operator_name_info [(int) CEIL_DIV_EXPR].name = \"(ceiling /=)\";\n+  assignment_operator_name_info [(int) FLOOR_DIV_EXPR].name = \"(floor /=)\";\n+  assignment_operator_name_info [(int) ROUND_DIV_EXPR].name = \"(round /=)\";\n+  assignment_operator_name_info [(int) CEIL_MOD_EXPR].name = \"(ceiling %=)\";\n+  assignment_operator_name_info [(int) FLOOR_MOD_EXPR].name = \"(floor %=)\";\n+  assignment_operator_name_info [(int) ROUND_MOD_EXPR].name = \"(round %=)\";\n }\n \n /* Initialize the reserved words.  */\n@@ -184,7 +214,7 @@ init_reswords (void)\n       C_SET_RID_CODE (id, c_common_reswords[i].rid);\n       ridpointers [(int) c_common_reswords[i].rid] = id;\n       if (! (c_common_reswords[i].disable & mask))\n-\tC_IS_RESERVED_WORD (id) = 1;\n+\tset_identifier_kind (id, cik_keyword);\n     }\n \n   for (i = 0; i < NUM_INT_N_ENTS; i++)\n@@ -193,7 +223,7 @@ init_reswords (void)\n       sprintf (name, \"__int%d\", int_n_data[i].bitsize);\n       id = get_identifier (name);\n       C_SET_RID_CODE (id, RID_FIRST_INT_N + i);\n-      C_IS_RESERVED_WORD (id) = 1;\n+      set_identifier_kind (id, cik_keyword);\n     }\n }\n \n@@ -431,7 +461,7 @@ unqualified_name_lookup_error (tree name, location_t loc)\n   if (loc == UNKNOWN_LOCATION)\n     loc = EXPR_LOC_OR_LOC (name, input_location);\n \n-  if (IDENTIFIER_OPNAME_P (name))\n+  if (IDENTIFIER_ANY_OP_P (name))\n     {\n       if (name != cp_operator_id (ERROR_MARK))\n \terror_at (loc, \"%qD not defined\", name);"}, {"sha": "e23591315c93861765e93375b3f6ab543dad26cd", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -1261,9 +1261,9 @@ write_template_prefix (const tree node)\n static void\n write_unqualified_id (tree identifier)\n {\n-  if (IDENTIFIER_TYPENAME_P (identifier))\n+  if (IDENTIFIER_CONV_OP_P (identifier))\n     write_conversion_operator_name (TREE_TYPE (identifier));\n-  else if (IDENTIFIER_OPNAME_P (identifier))\n+  else if (IDENTIFIER_ANY_OP_P (identifier))\n     {\n       int i;\n       const char *mangled_name = NULL;\n@@ -2825,14 +2825,16 @@ write_template_args (tree args)\n static void\n write_member_name (tree member)\n {\n-  if (abi_version_at_least (11) && IDENTIFIER_OPNAME_P (member))\n+  if (identifier_p (member))\n     {\n-      write_string (\"on\");\n-      if (abi_warn_or_compat_version_crosses (11))\n-\tG.need_abi_warning = 1;\n+      if (abi_version_at_least (11) && IDENTIFIER_ANY_OP_P (member))\n+\t{\n+\t  write_string (\"on\");\n+\t  if (abi_warn_or_compat_version_crosses (11))\n+\t    G.need_abi_warning = 1;\n+\t}\n+      write_unqualified_id (member);\n     }\n-  if (identifier_p (member))\n-    write_unqualified_id (member);\n   else if (DECL_P (member))\n     write_unqualified_name (member);\n   else if (TREE_CODE (member) == TEMPLATE_ID_EXPR)\n@@ -3050,15 +3052,15 @@ write_expression (tree expr)\n       /* An operator name appearing as a dependent name needs to be\n \t specially marked to disambiguate between a use of the operator\n \t name and a use of the operator in an expression.  */\n-      if (IDENTIFIER_OPNAME_P (expr))\n+      if (IDENTIFIER_ANY_OP_P (expr))\n \twrite_string (\"on\");\n       write_unqualified_id (expr);\n     }\n   else if (TREE_CODE (expr) == TEMPLATE_ID_EXPR)\n     {\n       tree fn = TREE_OPERAND (expr, 0);\n       fn = OVL_NAME (fn);\n-      if (IDENTIFIER_OPNAME_P (fn))\n+      if (IDENTIFIER_ANY_OP_P (fn))\n \twrite_string (\"on\");\n       write_unqualified_id (fn);\n       write_template_args (TREE_OPERAND (expr, 1));\n@@ -4241,9 +4243,8 @@ mangle_conv_op_name_for_type (const tree type)\n \t when performing conversions.  */\n       TREE_TYPE (identifier) = type;\n \n-      /* Set bits on the identifier so we know later it's a conversion.  */\n-      IDENTIFIER_OPNAME_P (identifier) = 1;\n-      IDENTIFIER_TYPENAME_P (identifier) = 1;\n+      /* Set the identifier kind so we know later it's a conversion.  */\n+      set_identifier_kind (identifier, cik_conv_op);\n     }\n \n   return identifier;"}, {"sha": "0df546a2e6a463c6ebd8c0982d8d234b799cdbdc", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -4161,7 +4161,7 @@ do_class_using_decl (tree scope, tree name)\n \n   scope_dependent_p = dependent_scope_p (scope);\n   name_dependent_p = (scope_dependent_p\n-\t\t      || (IDENTIFIER_TYPENAME_P (name)\n+\t\t      || (IDENTIFIER_CONV_OP_P (name)\n \t\t\t  && dependent_type_p (TREE_TYPE (name))));\n \n   bases_dependent_p = any_dependent_bases_p ();\n@@ -5066,7 +5066,7 @@ lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind)\n \n       /* Only consider reserved words that survived the\n \t filtering in init_reswords (e.g. for -std).  */\n-      if (!C_IS_RESERVED_WORD (resword_identifier))\n+      if (!IDENTIFIER_KEYWORD_P (resword_identifier))\n \tcontinue;\n \n       bm.consider (IDENTIFIER_POINTER (resword_identifier));\n@@ -5228,7 +5228,7 @@ lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n   /* Conversion operators are handled specially because ordinary\n      unqualified name lookup will not find template conversion\n      operators.  */\n-  if (IDENTIFIER_TYPENAME_P (name))\n+  if (IDENTIFIER_CONV_OP_P (name))\n     {\n       cp_binding_level *level;\n "}, {"sha": "7dfdd2272411c4710d24d8a36d63f7e1942f134f", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -67,20 +67,20 @@ along with GCC; see the file COPYING3.  If not see\n    an ASSIGNMENT_P argument; it is always zero.  */\n \n #define DEF_SIMPLE_OPERATOR(NAME, CODE, MANGLING, ARITY) \\\n-  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, 0)\n+  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, cik_simple_op)\n \n /* Use DEF_ASSN_OPERATOR to define an assignment operator.  Its\n    arguments are as for DEF_OPERATOR, but there is no need to provide\n    an ASSIGNMENT_P argument; it is always one.  */\n \n #define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING, ARITY) \\\n-  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, 1)\n+  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, cik_assign_op)\n \n /* Memory allocation operators.  */\n-DEF_SIMPLE_OPERATOR (\"new\", NEW_EXPR, \"nw\", -1)\n-DEF_SIMPLE_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\", -1)\n-DEF_SIMPLE_OPERATOR (\"delete\", DELETE_EXPR, \"dl\", -1)\n-DEF_SIMPLE_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\", -1)\n+DEF_OPERATOR (\"new\", NEW_EXPR, \"nw\", -1, cik_newdel_op)\n+DEF_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\", -1, cik_newdel_op)\n+DEF_OPERATOR (\"delete\", DELETE_EXPR, \"dl\", -1, cik_newdel_op)\n+DEF_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\", -1, cik_newdel_op)\n \n /* Unary operators.  */\n DEF_SIMPLE_OPERATOR (\"+\", UNARY_PLUS_EXPR, \"ps\", 1)\n@@ -97,8 +97,7 @@ DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"az\", 1)\n DEF_SIMPLE_OPERATOR (\"__imag__\", IMAGPART_EXPR, \"v18__imag__\", 1)\n DEF_SIMPLE_OPERATOR (\"__real__\", REALPART_EXPR, \"v18__real__\", 1)\n \n-/* The cast operator.  */\n-DEF_SIMPLE_OPERATOR (\"\", TYPE_EXPR, \"cv\", 1)\n+/* The cast operators.  */\n DEF_SIMPLE_OPERATOR (\"\", CAST_EXPR, \"cv\", 1)\n DEF_SIMPLE_OPERATOR (\"dynamic_cast\", DYNAMIC_CAST_EXPR, \"dc\", 1)\n DEF_SIMPLE_OPERATOR (\"reinterpret_cast\", REINTERPRET_CAST_EXPR, \"rc\", 1)"}, {"sha": "ddb1cf3d5d67888736d2e5dc576e4b900ebb3628", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -806,7 +806,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n   /* Check to see if this token is a keyword.  */\n   if (token->type == CPP_NAME)\n     {\n-      if (C_IS_RESERVED_WORD (token->u.value))\n+      if (IDENTIFIER_KEYWORD_P (token->u.value))\n \t{\n \t  /* Mark this token as a keyword.  */\n \t  token->type = CPP_KEYWORD;\n@@ -20089,7 +20089,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  {\n \t\t    if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR)\n \t\t      sfk = sfk_destructor;\n-\t\t    else if (IDENTIFIER_TYPENAME_P (unqualified_name))\n+\t\t    else if (identifier_p (unqualified_name)\n+\t\t\t     && IDENTIFIER_CONV_OP_P (unqualified_name))\n \t\t      sfk = sfk_conversion;\n \t\t    else if (/* There's no way to declare a constructor\n \t\t\t\tfor an unnamed type, even if the type"}, {"sha": "fba7fb1d0678ac7e124c50a5762253084762ad77", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -5333,11 +5333,11 @@ push_template_decl_real (tree decl, bool is_friend)\n \t      error (\"destructor %qD declared as member template\", decl);\n \t      return error_mark_node;\n \t    }\n-\t  if (NEW_DELETE_OPNAME_P (DECL_NAME (decl))\n+\t  if (IDENTIFIER_NEWDEL_OP_P (DECL_NAME (decl))\n \t      && (!prototype_p (TREE_TYPE (decl))\n \t\t  || TYPE_ARG_TYPES (TREE_TYPE (decl)) == void_list_node\n \t\t  || !TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n-\t\t  || (TREE_CHAIN (TYPE_ARG_TYPES ((TREE_TYPE (decl))))\n+\t\t  || (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl)))\n \t\t      == void_list_node)))\n \t    {\n \t      /* [basic.stc.dynamic.allocation]\n@@ -12416,7 +12416,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t/* If we aren't complaining now, return on error before we register\n \t   the specialization so that we'll complain eventually.  */\n \tif ((complain & tf_error) == 0\n-\t    && IDENTIFIER_OPNAME_P (DECL_NAME (r))\n+\t    && IDENTIFIER_ANY_OP_P (DECL_NAME (r))\n \t    && !grok_op_properties (r, /*complain=*/false))\n \t  RETURN (error_mark_node);\n \n@@ -12487,7 +12487,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t      clone_function_decl (r, /*update_methods=*/false);\n \t  }\n \telse if ((complain & tf_error) != 0\n-\t\t && IDENTIFIER_OPNAME_P (DECL_NAME (r))\n+\t\t && IDENTIFIER_ANY_OP_P (DECL_NAME (r))\n \t\t && !grok_op_properties (r, /*complain=*/true))\n \t  RETURN (error_mark_node);\n \n@@ -14247,7 +14247,7 @@ tsubst_baselink (tree baselink, tree object_type,\n     }\n \n   tree name = OVL_NAME (fns);\n-  if (IDENTIFIER_TYPENAME_P (name))\n+  if (IDENTIFIER_CONV_OP_P (name))\n     name = mangle_conv_op_name_for_type (optype);\n \n   baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n@@ -15035,7 +15035,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       t = DECL_NAME (t);\n       /* Fall through.  */\n     case IDENTIFIER_NODE:\n-      if (IDENTIFIER_TYPENAME_P (t))\n+      if (IDENTIFIER_CONV_OP_P (t))\n \t{\n \t  tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t  return mangle_conv_op_name_for_type (new_type);\n@@ -16668,7 +16668,7 @@ tsubst_copy_and_build (tree t,\n \tbool non_integral_constant_expression_p;\n \tconst char *error_msg;\n \n-\tif (IDENTIFIER_TYPENAME_P (t))\n+\tif (IDENTIFIER_CONV_OP_P (t))\n \t  {\n \t    tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    t = mangle_conv_op_name_for_type (new_type);"}, {"sha": "7b69dbe2b890a236c59c71e521d7f3d13ab5e01a", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -178,7 +178,8 @@ cxx_print_identifier (FILE *file, tree node, int indent)\n     fprintf (file, \" \");\n   else\n     indent_to (file, indent + 4);\n-  fprintf (file, \"local bindings <%p>\", (void *) IDENTIFIER_BINDING (node));\n+  fprintf (file, \"%s local bindings <%p>\", get_identifier_kind_name (node),\n+\t   (void *) IDENTIFIER_BINDING (node));\n   print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);\n   print_node (file, \"template\", IDENTIFIER_TEMPLATE (node), indent + 4);\n }"}, {"sha": "00f895c5d7d83b0bcd0407c8bc97d717c1ac49c2", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -1187,7 +1187,7 @@ lookup_field_r (tree binfo, void *data)\n \n  done:\n   /* Don't look for constructors or destructors in base classes.  */\n-  if (IDENTIFIER_CTOR_OR_DTOR_P (lfi->name))\n+  if (IDENTIFIER_CDTOR_P (lfi->name))\n     return dfs_skip_bases;\n   return NULL_TREE;\n }\n@@ -1352,7 +1352,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n \n   if (rval && is_overloaded_fn (rval))\n     rval = build_baselink (rval_binfo, basetype_path, rval,\n-\t\t\t   (IDENTIFIER_TYPENAME_P (name)\n+\t\t\t   (IDENTIFIER_CONV_OP_P (name)\n \t\t\t   ? TREE_TYPE (name): NULL_TREE));\n   return rval;\n }\n@@ -1595,7 +1595,7 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n       fn = CLASSTYPE_DESTRUCTORS (type);\n       return fn ? CLASSTYPE_DESTRUCTOR_SLOT : -1;\n     }\n-  if (IDENTIFIER_TYPENAME_P (name))\n+  if (IDENTIFIER_CONV_OP_P (name))\n     return lookup_conversion_operator (type, TREE_TYPE (name));\n \n   /* Skip the conversion operators.  */"}, {"sha": "9589b47dd649851d52429724d66133e7982e2acb", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -3496,7 +3496,7 @@ finish_id_expression (tree id_expression,\n \t      && (!TYPE_P (scope)\n \t\t  || (!dependent_type_p (scope)\n \t\t      && !(identifier_p (id_expression)\n-\t\t\t   && IDENTIFIER_TYPENAME_P (id_expression)\n+\t\t\t   && IDENTIFIER_CONV_OP_P (id_expression)\n \t\t\t   && dependent_type_p (TREE_TYPE (id_expression))))))\n \t    {\n \t      /* If the qualifying type is non-dependent (and the name"}, {"sha": "1c15f29eb3db5e7aa30d204aba6ec27a5958f3a9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c0088f38ce49f390401d11a581cd1a57a008d5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=84c0088f38ce49f390401d11a581cd1a57a008d5", "patch": "@@ -5652,7 +5652,7 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n   arg = mark_lvalue_use (arg);\n   argtype = lvalue_type (arg);\n \n-  gcc_assert (!identifier_p (arg) || !IDENTIFIER_OPNAME_P (arg));\n+  gcc_assert (!(identifier_p (arg) && IDENTIFIER_ANY_OP_P (arg)));\n \n   if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n       && !really_overloaded_fn (arg))"}]}