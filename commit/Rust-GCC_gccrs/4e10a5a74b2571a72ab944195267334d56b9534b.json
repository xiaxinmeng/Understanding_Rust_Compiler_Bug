{"sha": "4e10a5a74b2571a72ab944195267334d56b9534b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUxMGE1YTc0YjI1NzFhNzJhYjk0NDE5NTI2NzMzNGQ1NmI5NTM0Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:08:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:08:28Z"}, "message": "[2/77] Add an E_ prefix to case statements\n\nAll case statements need to be updated to use the prefixed names,\nsince the unprefixed names will eventually not be integer constant\nexpressions.  This patch does a mechanical substitution over the whole\ncodebase.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-builtins.c (aarch64_simd_builtin_std_type):\n\tPrefix mode names with E_ in case statements.\n\t* config/aarch64/aarch64-elf.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_split_simd_combine): Likewise.\n\t(aarch64_split_simd_move): Likewise.\n\t(aarch64_gen_storewb_pair): Likewise.\n\t(aarch64_gen_loadwb_pair): Likewise.\n\t(aarch64_gen_store_pair): Likewise.\n\t(aarch64_gen_load_pair): Likewise.\n\t(aarch64_get_condition_code_1): Likewise.\n\t(aarch64_constant_pool_reload_icode): Likewise.\n\t(get_rsqrte_type): Likewise.\n\t(get_rsqrts_type): Likewise.\n\t(get_recpe_type): Likewise.\n\t(get_recps_type): Likewise.\n\t(aarch64_gimplify_va_arg_expr): Likewise.\n\t(aarch64_simd_container_mode): Likewise.\n\t(aarch64_emit_load_exclusive): Likewise.\n\t(aarch64_emit_store_exclusive): Likewise.\n\t(aarch64_expand_compare_and_swap): Likewise.\n\t(aarch64_gen_atomic_cas): Likewise.\n\t(aarch64_emit_bic): Likewise.\n\t(aarch64_emit_atomic_swap): Likewise.\n\t(aarch64_emit_atomic_load_op): Likewise.\n\t(aarch64_evpc_trn): Likewise.\n\t(aarch64_evpc_uzp): Likewise.\n\t(aarch64_evpc_zip): Likewise.\n\t(aarch64_evpc_ext): Likewise.\n\t(aarch64_evpc_rev): Likewise.\n\t(aarch64_evpc_dup): Likewise.\n\t(aarch64_gen_ccmp_first): Likewise.\n\t(aarch64_gen_ccmp_next): Likewise.\n\t* config/alpha/alpha.c (alpha_scalar_mode_supported_p): Likewise.\n\t(alpha_emit_xfloating_libcall): Likewise.\n\t(emit_insxl): Likewise.\n\t(alpha_arg_type): Likewise.\n\t* config/arc/arc.c (arc_vector_mode_supported_p): Likewise.\n\t(arc_preferred_simd_mode): Likewise.\n\t(arc_secondary_reload): Likewise.\n\t(get_arc_condition_code): Likewise.\n\t(arc_print_operand): Likewise.\n\t(arc_legitimate_constant_p): Likewise.\n\t* config/arc/arc.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\t* config/arc/arc.md (casesi_load): Likewise.\n\t(casesi_compact_jump): Likewise.\n\t* config/arc/predicates.md (proper_comparison_operator): Likewise.\n\t(cc_use_register): Likewise.\n\t* config/arm/aout.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\t* config/arm/arm-builtins.c (arm_simd_builtin_std_type): Likewise.\n\t(arm_init_iwmmxt_builtins): Likewise.\n\t* config/arm/arm.c (thumb1_size_rtx_costs): Likewise.\n\t(neon_expand_vector_init): Likewise.\n\t(arm_attr_length_move_neon): Likewise.\n\t(maybe_get_arm_condition_code): Likewise.\n\t(arm_emit_vector_const): Likewise.\n\t(arm_preferred_simd_mode): Likewise.\n\t(arm_output_iwmmxt_tinsr): Likewise.\n\t(thumb1_output_casesi): Likewise.\n\t(thumb2_output_casesi): Likewise.\n\t(arm_emit_load_exclusive): Likewise.\n\t(arm_emit_store_exclusive): Likewise.\n\t(arm_expand_compare_and_swap): Likewise.\n\t(arm_evpc_neon_vuzp): Likewise.\n\t(arm_evpc_neon_vzip): Likewise.\n\t(arm_evpc_neon_vrev): Likewise.\n\t(arm_evpc_neon_vtrn): Likewise.\n\t(arm_evpc_neon_vext): Likewise.\n\t(arm_validize_comparison): Likewise.\n\t* config/arm/neon.md (neon_vc<cmp_op><mode>): Likewise.\n\t* config/avr/avr-c.c (avr_resolve_overloaded_builtin): Likewise.\n\t* config/avr/avr.c (avr_rtx_costs_1): Likewise.\n\t* config/c6x/c6x.c (c6x_vector_mode_supported_p): Likewise.\n\t(c6x_preferred_simd_mode): Likewise.\n\t* config/epiphany/epiphany.c (get_epiphany_condition_code): Likewise.\n\t(epiphany_rtx_costs): Likewise.\n\t* config/epiphany/predicates.md (proper_comparison_operator):\n\tLikewise.\n\t* config/frv/frv.c (condexec_memory_operand): Likewise.\n\t(frv_emit_move): Likewise.\n\t(output_move_single): Likewise.\n\t(output_condmove_single): Likewise.\n\t(frv_hard_regno_mode_ok): Likewise.\n\t(frv_matching_accg_mode): Likewise.\n\t* config/h8300/h8300.c (split_adds_subs): Likewise.\n\t(h8300_rtx_costs): Likewise.\n\t(h8300_print_operand): Likewise.\n\t(compute_mov_length): Likewise.\n\t(output_logical_op): Likewise.\n\t(compute_logical_op_length): Likewise.\n\t(compute_logical_op_cc): Likewise.\n\t(h8300_shift_needs_scratch_p): Likewise.\n\t(output_a_shift): Likewise.\n\t(compute_a_shift_length): Likewise.\n\t(compute_a_shift_cc): Likewise.\n\t(expand_a_rotate): Likewise.\n\t(output_a_rotate): Likewise.\n\t* config/i386/i386.c (classify_argument): Likewise.\n\t(function_arg_advance_32): Likewise.\n\t(function_arg_32): Likewise.\n\t(function_arg_64): Likewise.\n\t(function_value_64): Likewise.\n\t(ix86_gimplify_va_arg): Likewise.\n\t(ix86_legitimate_constant_p): Likewise.\n\t(put_condition_code): Likewise.\n\t(split_double_mode): Likewise.\n\t(ix86_avx256_split_vector_move_misalign): Likewise.\n\t(ix86_expand_vector_logical_operator): Likewise.\n\t(ix86_split_idivmod): Likewise.\n\t(ix86_expand_adjust_ufix_to_sfix_si): Likewise.\n\t(ix86_build_const_vector): Likewise.\n\t(ix86_build_signbit_mask): Likewise.\n\t(ix86_match_ccmode): Likewise.\n\t(ix86_cc_modes_compatible): Likewise.\n\t(ix86_expand_branch): Likewise.\n\t(ix86_expand_sse_cmp): Likewise.\n\t(ix86_expand_sse_movcc): Likewise.\n\t(ix86_expand_int_sse_cmp): Likewise.\n\t(ix86_expand_vec_perm_vpermi2): Likewise.\n\t(ix86_expand_vec_perm): Likewise.\n\t(ix86_expand_sse_unpack): Likewise.\n\t(ix86_expand_int_addcc): Likewise.\n\t(ix86_split_to_parts): Likewise.\n\t(ix86_vectorize_builtin_gather): Likewise.\n\t(ix86_vectorize_builtin_scatter): Likewise.\n\t(avx_vpermilp_parallel): Likewise.\n\t(inline_memory_move_cost): Likewise.\n\t(ix86_tieable_integer_mode_p): Likewise.\n\t(x86_maybe_negate_const_int): Likewise.\n\t(ix86_expand_vector_init_duplicate): Likewise.\n\t(ix86_expand_vector_init_one_nonzero): Likewise.\n\t(ix86_expand_vector_init_one_var): Likewise.\n\t(ix86_expand_vector_init_concat): Likewise.\n\t(ix86_expand_vector_init_interleave): Likewise.\n\t(ix86_expand_vector_init_general): Likewise.\n\t(ix86_expand_vector_set): Likewise.\n\t(ix86_expand_vector_extract): Likewise.\n\t(emit_reduc_half): Likewise.\n\t(ix86_emit_i387_round): Likewise.\n\t(ix86_mangle_type): Likewise.\n\t(ix86_expand_round_sse4): Likewise.\n\t(expand_vec_perm_blend): Likewise.\n\t(canonicalize_vector_int_perm): Likewise.\n\t(ix86_expand_vec_one_operand_perm_avx512): Likewise.\n\t(expand_vec_perm_1): Likewise.\n\t(expand_vec_perm_interleave3): Likewise.\n\t(expand_vec_perm_even_odd_pack): Likewise.\n\t(expand_vec_perm_even_odd_1): Likewise.\n\t(expand_vec_perm_broadcast_1): Likewise.\n\t(ix86_vectorize_vec_perm_const_ok): Likewise.\n\t(ix86_expand_vecop_qihi): Likewise.\n\t(ix86_expand_mul_widen_hilo): Likewise.\n\t(ix86_expand_sse2_abs): Likewise.\n\t(ix86_expand_pextr): Likewise.\n\t(ix86_expand_pinsr): Likewise.\n\t(ix86_preferred_simd_mode): Likewise.\n\t(ix86_simd_clone_compute_vecsize_and_simdlen): Likewise.\n\t* config/i386/sse.md (*andnot<mode>3): Likewise.\n\t(<mask_codefor><code><mode>3<mask_name>): Likewise.\n\t(*<code><mode>3): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_vecint_compare): Likewise.\n\t(ia64_expand_atomic_op): Likewise.\n\t(ia64_arg_type): Likewise.\n\t(ia64_mode_to_int): Likewise.\n\t(ia64_scalar_mode_supported_p): Likewise.\n\t(ia64_vector_mode_supported_p): Likewise.\n\t(expand_vec_perm_broadcast): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_move_1word): Likewise.\n\t(iq2000_function_arg_advance): Likewise.\n\t(iq2000_function_arg): Likewise.\n\t* config/m32c/m32c.c (m32c_preferred_reload_class): Likewise.\n\t* config/m68k/m68k.c (output_dbcc_and_branch): Likewise.\n\t(m68k_libcall_value): Likewise.\n\t(m68k_function_value): Likewise.\n\t(sched_attr_op_type): Likewise.\n\t* config/mcore/mcore.c (mcore_output_move): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_function_arg_advance):\n\tLikewise.\n\t(microblaze_function_arg): Likewise.\n\t* config/mips/mips.c (mips16_build_call_stub): Likewise.\n\t(mips_print_operand): Likewise.\n\t(mips_mode_ok_for_mov_fmt_p): Likewise.\n\t(mips_vector_mode_supported_p): Likewise.\n\t(mips_preferred_simd_mode): Likewise.\n\t(mips_expand_vpc_loongson_even_odd): Likewise.\n\t(mips_expand_vec_unpack): Likewise.\n\t(mips_expand_vi_broadcast): Likewise.\n\t(mips_expand_vector_init): Likewise.\n\t(mips_expand_vec_reduc): Likewise.\n\t(mips_expand_msa_cmp): Likewise.\n\t* config/mips/mips.md (casesi_internal_mips16_<mode>): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_print_operand): Likewise.\n\t(cc_flags_for_mode): Likewise.\n\t* config/msp430/msp430.c (msp430_print_operand): Likewise.\n\t* config/nds32/nds32-md-auxiliary.c (nds32_mem_format): Likewise.\n\t(nds32_output_casesi_pc_relative): Likewise.\n\t* config/nds32/nds32.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\t* config/nvptx/nvptx.c (nvptx_ptx_type_from_mode): Likewise.\n\t(nvptx_gen_unpack): Likewise.\n\t(nvptx_gen_pack): Likewise.\n\t(nvptx_gen_shuffle): Likewise.\n\t(nvptx_gen_wcast): Likewise.\n\t(nvptx_preferred_simd_mode): Likewise.\n\t* config/pa/pa.c (pa_secondary_reload): Likewise.\n\t* config/pa/predicates.md (base14_operand): Likewise.\n\t* config/powerpcspe/powerpcspe-c.c\n\t(altivec_resolve_overloaded_builtin): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_setup_reg_addr_masks):\n\tLikewise.\n\t(rs6000_preferred_simd_mode): Likewise.\n\t(output_vec_const_move): Likewise.\n\t(rs6000_expand_vector_extract): Likewise.\n\t(rs6000_split_vec_extract_var): Likewise.\n\t(reg_offset_addressing_ok_p): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_emit_set_const): Likewise.\n\t(rs6000_const_vec): Likewise.\n\t(rs6000_emit_move): Likewise.\n\t(spe_build_register_parallel): Likewise.\n\t(rs6000_darwin64_record_arg_recurse): Likewise.\n\t(swap_selector_for_mode): Likewise.\n\t(spe_init_builtins): Likewise.\n\t(paired_init_builtins): Likewise.\n\t(altivec_init_builtins): Likewise.\n\t(do_load_for_compare): Likewise.\n\t(rs6000_generate_compare): Likewise.\n\t(rs6000_expand_float128_convert): Likewise.\n\t(emit_load_locked): Likewise.\n\t(emit_store_conditional): Likewise.\n\t(rs6000_output_function_epilogue): Likewise.\n\t(rs6000_handle_altivec_attribute): Likewise.\n\t(rs6000_function_value): Likewise.\n\t(emit_fusion_gpr_load): Likewise.\n\t(emit_fusion_p9_load): Likewise.\n\t(emit_fusion_p9_store): Likewise.\n\t* config/powerpcspe/predicates.md (easy_fp_constant): Likewise.\n\t(fusion_gpr_mem_load): Likewise.\n\t(fusion_addis_mem_combo_load): Likewise.\n\t(fusion_addis_mem_combo_store): Likewise.\n\t* config/rs6000/predicates.md (easy_fp_constant): Likewise.\n\t(fusion_gpr_mem_load): Likewise.\n\t(fusion_addis_mem_combo_load): Likewise.\n\t(fusion_addis_mem_combo_store): Likewise.\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tLikewise.\n\t* config/rs6000/rs6000-string.c (do_load_for_compare): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): Likewise.\n\t(rs6000_preferred_simd_mode): Likewise.\n\t(output_vec_const_move): Likewise.\n\t(rs6000_expand_vector_extract): Likewise.\n\t(rs6000_split_vec_extract_var): Likewise.\n\t(reg_offset_addressing_ok_p): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_emit_set_const): Likewise.\n\t(rs6000_const_vec): Likewise.\n\t(rs6000_emit_move): Likewise.\n\t(rs6000_darwin64_record_arg_recurse): Likewise.\n\t(swap_selector_for_mode): Likewise.\n\t(paired_init_builtins): Likewise.\n\t(altivec_init_builtins): Likewise.\n\t(rs6000_expand_float128_convert): Likewise.\n\t(emit_load_locked): Likewise.\n\t(emit_store_conditional): Likewise.\n\t(rs6000_output_function_epilogue): Likewise.\n\t(rs6000_handle_altivec_attribute): Likewise.\n\t(rs6000_function_value): Likewise.\n\t(emit_fusion_gpr_load): Likewise.\n\t(emit_fusion_p9_load): Likewise.\n\t(emit_fusion_p9_store): Likewise.\n\t* config/rx/rx.c (rx_gen_move_template): Likewise.\n\t(flags_from_mode): Likewise.\n\t* config/s390/predicates.md (s390_alc_comparison): Likewise.\n\t(s390_slb_comparison): Likewise.\n\t* config/s390/s390.c (s390_handle_vectorbool_attribute): Likewise.\n\t(s390_vector_mode_supported_p): Likewise.\n\t(s390_cc_modes_compatible): Likewise.\n\t(s390_match_ccmode_set): Likewise.\n\t(s390_canonicalize_comparison): Likewise.\n\t(s390_emit_compare_and_swap): Likewise.\n\t(s390_branch_condition_mask): Likewise.\n\t(s390_rtx_costs): Likewise.\n\t(s390_secondary_reload): Likewise.\n\t(__SECONDARY_RELOAD_CASE): Likewise.\n\t(s390_expand_cs): Likewise.\n\t(s390_preferred_simd_mode): Likewise.\n\t* config/s390/vx-builtins.md (vec_packsu_u<mode>): Likewise.\n\t* config/sh/sh.c (sh_print_operand): Likewise.\n\t(dump_table): Likewise.\n\t(sh_secondary_reload): Likewise.\n\t* config/sh/sh.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\t* config/sh/sh.md (casesi_worker_1): Likewise.\n\t(casesi_worker_2): Likewise.\n\t* config/sparc/predicates.md (icc_comparison_operator): Likewise.\n\t(fcc_comparison_operator): Likewise.\n\t* config/sparc/sparc.c (sparc_expand_move): Likewise.\n\t(emit_soft_tfmode_cvt): Likewise.\n\t(sparc_preferred_simd_mode): Likewise.\n\t(output_cbranch): Likewise.\n\t(sparc_print_operand): Likewise.\n\t(sparc_expand_vec_perm_bmask): Likewise.\n\t(vector_init_bshuffle): Likewise.\n\t* config/spu/spu.c (spu_scalar_mode_supported_p): Likewise.\n\t(spu_vector_mode_supported_p): Likewise.\n\t(spu_expand_insv): Likewise.\n\t(spu_emit_branch_or_set): Likewise.\n\t(spu_handle_vector_attribute): Likewise.\n\t(spu_builtin_splats): Likewise.\n\t(spu_builtin_extract): Likewise.\n\t(spu_builtin_promote): Likewise.\n\t(spu_expand_sign_extend): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_scalar_mode_supported_p): Likewise.\n\t(tilegx_simd_int): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_scalar_mode_supported_p): Likewise.\n\t(tilepro_simd_int): Likewise.\n\t* config/v850/v850.c (const_double_split): Likewise.\n\t(v850_print_operand): Likewise.\n\t(ep_memory_offset): Likewise.\n\t* config/vax/vax.c (vax_rtx_costs): Likewise.\n\t(vax_output_int_move): Likewise.\n\t(vax_output_int_add): Likewise.\n\t(vax_output_int_subtract): Likewise.\n\t* config/visium/predicates.md (visium_branch_operator): Likewise.\n\t* config/visium/visium.c (rtx_ok_for_offset_p): Likewise.\n\t(visium_print_operand_address): Likewise.\n\t* config/visium/visium.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_mem_offset): Likewise.\n\t(xtensa_expand_conditional_branch): Likewise.\n\t(xtensa_copy_incoming_a7): Likewise.\n\t(xtensa_output_literal): Likewise.\n\t* dfp.c (decimal_real_maxval): Likewise.\n\t* targhooks.c (default_libgcc_floating_mode_supported_p): Likewise.\n\ngcc/c-family/\n\t* c-cppbuiltin.c (mode_has_fma): Prefix mode names with E_ in\n\tcase statements.\n\ngcc/objc/\n\t* objc-encoding.c (encode_gnu_bitfield): Prefix mode names with E_ in\n\tcase statements.\n\nlibobjc/\n\t* encoding.c (_darwin_rs6000_special_round_type_align): Prefix mode\n\tnames with E_ in case statements.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251453", "tree": {"sha": "23efa6a4e98eaaccca95487c94427d89d2c7d21d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23efa6a4e98eaaccca95487c94427d89d2c7d21d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e10a5a74b2571a72ab944195267334d56b9534b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e10a5a74b2571a72ab944195267334d56b9534b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e10a5a74b2571a72ab944195267334d56b9534b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e10a5a74b2571a72ab944195267334d56b9534b/comments", "author": null, "committer": null, "parents": [{"sha": "0d4a1197ba24d4f95b5c5f1face695806075a0c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4a1197ba24d4f95b5c5f1face695806075a0c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4a1197ba24d4f95b5c5f1face695806075a0c6"}], "stats": {"total": 5635, "additions": 3001, "deletions": 2634}, "files": [{"sha": "6e24d2677cd1e85dd69c9ec8288f9a0d025842db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1,3 +1,340 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64-builtins.c (aarch64_simd_builtin_std_type):\n+\tPrefix mode names with E_ in case statements.\n+\t* config/aarch64/aarch64-elf.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_split_simd_combine): Likewise.\n+\t(aarch64_split_simd_move): Likewise.\n+\t(aarch64_gen_storewb_pair): Likewise.\n+\t(aarch64_gen_loadwb_pair): Likewise.\n+\t(aarch64_gen_store_pair): Likewise.\n+\t(aarch64_gen_load_pair): Likewise.\n+\t(aarch64_get_condition_code_1): Likewise.\n+\t(aarch64_constant_pool_reload_icode): Likewise.\n+\t(get_rsqrte_type): Likewise.\n+\t(get_rsqrts_type): Likewise.\n+\t(get_recpe_type): Likewise.\n+\t(get_recps_type): Likewise.\n+\t(aarch64_gimplify_va_arg_expr): Likewise.\n+\t(aarch64_simd_container_mode): Likewise.\n+\t(aarch64_emit_load_exclusive): Likewise.\n+\t(aarch64_emit_store_exclusive): Likewise.\n+\t(aarch64_expand_compare_and_swap): Likewise.\n+\t(aarch64_gen_atomic_cas): Likewise.\n+\t(aarch64_emit_bic): Likewise.\n+\t(aarch64_emit_atomic_swap): Likewise.\n+\t(aarch64_emit_atomic_load_op): Likewise.\n+\t(aarch64_evpc_trn): Likewise.\n+\t(aarch64_evpc_uzp): Likewise.\n+\t(aarch64_evpc_zip): Likewise.\n+\t(aarch64_evpc_ext): Likewise.\n+\t(aarch64_evpc_rev): Likewise.\n+\t(aarch64_evpc_dup): Likewise.\n+\t(aarch64_gen_ccmp_first): Likewise.\n+\t(aarch64_gen_ccmp_next): Likewise.\n+\t* config/alpha/alpha.c (alpha_scalar_mode_supported_p): Likewise.\n+\t(alpha_emit_xfloating_libcall): Likewise.\n+\t(emit_insxl): Likewise.\n+\t(alpha_arg_type): Likewise.\n+\t* config/arc/arc.c (arc_vector_mode_supported_p): Likewise.\n+\t(arc_preferred_simd_mode): Likewise.\n+\t(arc_secondary_reload): Likewise.\n+\t(get_arc_condition_code): Likewise.\n+\t(arc_print_operand): Likewise.\n+\t(arc_legitimate_constant_p): Likewise.\n+\t* config/arc/arc.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t* config/arc/arc.md (casesi_load): Likewise.\n+\t(casesi_compact_jump): Likewise.\n+\t* config/arc/predicates.md (proper_comparison_operator): Likewise.\n+\t(cc_use_register): Likewise.\n+\t* config/arm/aout.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t* config/arm/arm-builtins.c (arm_simd_builtin_std_type): Likewise.\n+\t(arm_init_iwmmxt_builtins): Likewise.\n+\t* config/arm/arm.c (thumb1_size_rtx_costs): Likewise.\n+\t(neon_expand_vector_init): Likewise.\n+\t(arm_attr_length_move_neon): Likewise.\n+\t(maybe_get_arm_condition_code): Likewise.\n+\t(arm_emit_vector_const): Likewise.\n+\t(arm_preferred_simd_mode): Likewise.\n+\t(arm_output_iwmmxt_tinsr): Likewise.\n+\t(thumb1_output_casesi): Likewise.\n+\t(thumb2_output_casesi): Likewise.\n+\t(arm_emit_load_exclusive): Likewise.\n+\t(arm_emit_store_exclusive): Likewise.\n+\t(arm_expand_compare_and_swap): Likewise.\n+\t(arm_evpc_neon_vuzp): Likewise.\n+\t(arm_evpc_neon_vzip): Likewise.\n+\t(arm_evpc_neon_vrev): Likewise.\n+\t(arm_evpc_neon_vtrn): Likewise.\n+\t(arm_evpc_neon_vext): Likewise.\n+\t(arm_validize_comparison): Likewise.\n+\t* config/arm/neon.md (neon_vc<cmp_op><mode>): Likewise.\n+\t* config/avr/avr-c.c (avr_resolve_overloaded_builtin): Likewise.\n+\t* config/avr/avr.c (avr_rtx_costs_1): Likewise.\n+\t* config/c6x/c6x.c (c6x_vector_mode_supported_p): Likewise.\n+\t(c6x_preferred_simd_mode): Likewise.\n+\t* config/epiphany/epiphany.c (get_epiphany_condition_code): Likewise.\n+\t(epiphany_rtx_costs): Likewise.\n+\t* config/epiphany/predicates.md (proper_comparison_operator):\n+\tLikewise.\n+\t* config/frv/frv.c (condexec_memory_operand): Likewise.\n+\t(frv_emit_move): Likewise.\n+\t(output_move_single): Likewise.\n+\t(output_condmove_single): Likewise.\n+\t(frv_hard_regno_mode_ok): Likewise.\n+\t(frv_matching_accg_mode): Likewise.\n+\t* config/h8300/h8300.c (split_adds_subs): Likewise.\n+\t(h8300_rtx_costs): Likewise.\n+\t(h8300_print_operand): Likewise.\n+\t(compute_mov_length): Likewise.\n+\t(output_logical_op): Likewise.\n+\t(compute_logical_op_length): Likewise.\n+\t(compute_logical_op_cc): Likewise.\n+\t(h8300_shift_needs_scratch_p): Likewise.\n+\t(output_a_shift): Likewise.\n+\t(compute_a_shift_length): Likewise.\n+\t(compute_a_shift_cc): Likewise.\n+\t(expand_a_rotate): Likewise.\n+\t(output_a_rotate): Likewise.\n+\t* config/i386/i386.c (classify_argument): Likewise.\n+\t(function_arg_advance_32): Likewise.\n+\t(function_arg_32): Likewise.\n+\t(function_arg_64): Likewise.\n+\t(function_value_64): Likewise.\n+\t(ix86_gimplify_va_arg): Likewise.\n+\t(ix86_legitimate_constant_p): Likewise.\n+\t(put_condition_code): Likewise.\n+\t(split_double_mode): Likewise.\n+\t(ix86_avx256_split_vector_move_misalign): Likewise.\n+\t(ix86_expand_vector_logical_operator): Likewise.\n+\t(ix86_split_idivmod): Likewise.\n+\t(ix86_expand_adjust_ufix_to_sfix_si): Likewise.\n+\t(ix86_build_const_vector): Likewise.\n+\t(ix86_build_signbit_mask): Likewise.\n+\t(ix86_match_ccmode): Likewise.\n+\t(ix86_cc_modes_compatible): Likewise.\n+\t(ix86_expand_branch): Likewise.\n+\t(ix86_expand_sse_cmp): Likewise.\n+\t(ix86_expand_sse_movcc): Likewise.\n+\t(ix86_expand_int_sse_cmp): Likewise.\n+\t(ix86_expand_vec_perm_vpermi2): Likewise.\n+\t(ix86_expand_vec_perm): Likewise.\n+\t(ix86_expand_sse_unpack): Likewise.\n+\t(ix86_expand_int_addcc): Likewise.\n+\t(ix86_split_to_parts): Likewise.\n+\t(ix86_vectorize_builtin_gather): Likewise.\n+\t(ix86_vectorize_builtin_scatter): Likewise.\n+\t(avx_vpermilp_parallel): Likewise.\n+\t(inline_memory_move_cost): Likewise.\n+\t(ix86_tieable_integer_mode_p): Likewise.\n+\t(x86_maybe_negate_const_int): Likewise.\n+\t(ix86_expand_vector_init_duplicate): Likewise.\n+\t(ix86_expand_vector_init_one_nonzero): Likewise.\n+\t(ix86_expand_vector_init_one_var): Likewise.\n+\t(ix86_expand_vector_init_concat): Likewise.\n+\t(ix86_expand_vector_init_interleave): Likewise.\n+\t(ix86_expand_vector_init_general): Likewise.\n+\t(ix86_expand_vector_set): Likewise.\n+\t(ix86_expand_vector_extract): Likewise.\n+\t(emit_reduc_half): Likewise.\n+\t(ix86_emit_i387_round): Likewise.\n+\t(ix86_mangle_type): Likewise.\n+\t(ix86_expand_round_sse4): Likewise.\n+\t(expand_vec_perm_blend): Likewise.\n+\t(canonicalize_vector_int_perm): Likewise.\n+\t(ix86_expand_vec_one_operand_perm_avx512): Likewise.\n+\t(expand_vec_perm_1): Likewise.\n+\t(expand_vec_perm_interleave3): Likewise.\n+\t(expand_vec_perm_even_odd_pack): Likewise.\n+\t(expand_vec_perm_even_odd_1): Likewise.\n+\t(expand_vec_perm_broadcast_1): Likewise.\n+\t(ix86_vectorize_vec_perm_const_ok): Likewise.\n+\t(ix86_expand_vecop_qihi): Likewise.\n+\t(ix86_expand_mul_widen_hilo): Likewise.\n+\t(ix86_expand_sse2_abs): Likewise.\n+\t(ix86_expand_pextr): Likewise.\n+\t(ix86_expand_pinsr): Likewise.\n+\t(ix86_preferred_simd_mode): Likewise.\n+\t(ix86_simd_clone_compute_vecsize_and_simdlen): Likewise.\n+\t* config/i386/sse.md (*andnot<mode>3): Likewise.\n+\t(<mask_codefor><code><mode>3<mask_name>): Likewise.\n+\t(*<code><mode>3): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_vecint_compare): Likewise.\n+\t(ia64_expand_atomic_op): Likewise.\n+\t(ia64_arg_type): Likewise.\n+\t(ia64_mode_to_int): Likewise.\n+\t(ia64_scalar_mode_supported_p): Likewise.\n+\t(ia64_vector_mode_supported_p): Likewise.\n+\t(expand_vec_perm_broadcast): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_move_1word): Likewise.\n+\t(iq2000_function_arg_advance): Likewise.\n+\t(iq2000_function_arg): Likewise.\n+\t* config/m32c/m32c.c (m32c_preferred_reload_class): Likewise.\n+\t* config/m68k/m68k.c (output_dbcc_and_branch): Likewise.\n+\t(m68k_libcall_value): Likewise.\n+\t(m68k_function_value): Likewise.\n+\t(sched_attr_op_type): Likewise.\n+\t* config/mcore/mcore.c (mcore_output_move): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_function_arg_advance):\n+\tLikewise.\n+\t(microblaze_function_arg): Likewise.\n+\t* config/mips/mips.c (mips16_build_call_stub): Likewise.\n+\t(mips_print_operand): Likewise.\n+\t(mips_mode_ok_for_mov_fmt_p): Likewise.\n+\t(mips_vector_mode_supported_p): Likewise.\n+\t(mips_preferred_simd_mode): Likewise.\n+\t(mips_expand_vpc_loongson_even_odd): Likewise.\n+\t(mips_expand_vec_unpack): Likewise.\n+\t(mips_expand_vi_broadcast): Likewise.\n+\t(mips_expand_vector_init): Likewise.\n+\t(mips_expand_vec_reduc): Likewise.\n+\t(mips_expand_msa_cmp): Likewise.\n+\t* config/mips/mips.md (casesi_internal_mips16_<mode>): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_print_operand): Likewise.\n+\t(cc_flags_for_mode): Likewise.\n+\t* config/msp430/msp430.c (msp430_print_operand): Likewise.\n+\t* config/nds32/nds32-md-auxiliary.c (nds32_mem_format): Likewise.\n+\t(nds32_output_casesi_pc_relative): Likewise.\n+\t* config/nds32/nds32.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t* config/nvptx/nvptx.c (nvptx_ptx_type_from_mode): Likewise.\n+\t(nvptx_gen_unpack): Likewise.\n+\t(nvptx_gen_pack): Likewise.\n+\t(nvptx_gen_shuffle): Likewise.\n+\t(nvptx_gen_wcast): Likewise.\n+\t(nvptx_preferred_simd_mode): Likewise.\n+\t* config/pa/pa.c (pa_secondary_reload): Likewise.\n+\t* config/pa/predicates.md (base14_operand): Likewise.\n+\t* config/powerpcspe/powerpcspe-c.c\n+\t(altivec_resolve_overloaded_builtin): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_setup_reg_addr_masks):\n+\tLikewise.\n+\t(rs6000_preferred_simd_mode): Likewise.\n+\t(output_vec_const_move): Likewise.\n+\t(rs6000_expand_vector_extract): Likewise.\n+\t(rs6000_split_vec_extract_var): Likewise.\n+\t(reg_offset_addressing_ok_p): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_emit_set_const): Likewise.\n+\t(rs6000_const_vec): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t(spe_build_register_parallel): Likewise.\n+\t(rs6000_darwin64_record_arg_recurse): Likewise.\n+\t(swap_selector_for_mode): Likewise.\n+\t(spe_init_builtins): Likewise.\n+\t(paired_init_builtins): Likewise.\n+\t(altivec_init_builtins): Likewise.\n+\t(do_load_for_compare): Likewise.\n+\t(rs6000_generate_compare): Likewise.\n+\t(rs6000_expand_float128_convert): Likewise.\n+\t(emit_load_locked): Likewise.\n+\t(emit_store_conditional): Likewise.\n+\t(rs6000_output_function_epilogue): Likewise.\n+\t(rs6000_handle_altivec_attribute): Likewise.\n+\t(rs6000_function_value): Likewise.\n+\t(emit_fusion_gpr_load): Likewise.\n+\t(emit_fusion_p9_load): Likewise.\n+\t(emit_fusion_p9_store): Likewise.\n+\t* config/powerpcspe/predicates.md (easy_fp_constant): Likewise.\n+\t(fusion_gpr_mem_load): Likewise.\n+\t(fusion_addis_mem_combo_load): Likewise.\n+\t(fusion_addis_mem_combo_store): Likewise.\n+\t* config/rs6000/predicates.md (easy_fp_constant): Likewise.\n+\t(fusion_gpr_mem_load): Likewise.\n+\t(fusion_addis_mem_combo_load): Likewise.\n+\t(fusion_addis_mem_combo_store): Likewise.\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tLikewise.\n+\t* config/rs6000/rs6000-string.c (do_load_for_compare): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): Likewise.\n+\t(rs6000_preferred_simd_mode): Likewise.\n+\t(output_vec_const_move): Likewise.\n+\t(rs6000_expand_vector_extract): Likewise.\n+\t(rs6000_split_vec_extract_var): Likewise.\n+\t(reg_offset_addressing_ok_p): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_emit_set_const): Likewise.\n+\t(rs6000_const_vec): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t(rs6000_darwin64_record_arg_recurse): Likewise.\n+\t(swap_selector_for_mode): Likewise.\n+\t(paired_init_builtins): Likewise.\n+\t(altivec_init_builtins): Likewise.\n+\t(rs6000_expand_float128_convert): Likewise.\n+\t(emit_load_locked): Likewise.\n+\t(emit_store_conditional): Likewise.\n+\t(rs6000_output_function_epilogue): Likewise.\n+\t(rs6000_handle_altivec_attribute): Likewise.\n+\t(rs6000_function_value): Likewise.\n+\t(emit_fusion_gpr_load): Likewise.\n+\t(emit_fusion_p9_load): Likewise.\n+\t(emit_fusion_p9_store): Likewise.\n+\t* config/rx/rx.c (rx_gen_move_template): Likewise.\n+\t(flags_from_mode): Likewise.\n+\t* config/s390/predicates.md (s390_alc_comparison): Likewise.\n+\t(s390_slb_comparison): Likewise.\n+\t* config/s390/s390.c (s390_handle_vectorbool_attribute): Likewise.\n+\t(s390_vector_mode_supported_p): Likewise.\n+\t(s390_cc_modes_compatible): Likewise.\n+\t(s390_match_ccmode_set): Likewise.\n+\t(s390_canonicalize_comparison): Likewise.\n+\t(s390_emit_compare_and_swap): Likewise.\n+\t(s390_branch_condition_mask): Likewise.\n+\t(s390_rtx_costs): Likewise.\n+\t(s390_secondary_reload): Likewise.\n+\t(__SECONDARY_RELOAD_CASE): Likewise.\n+\t(s390_expand_cs): Likewise.\n+\t(s390_preferred_simd_mode): Likewise.\n+\t* config/s390/vx-builtins.md (vec_packsu_u<mode>): Likewise.\n+\t* config/sh/sh.c (sh_print_operand): Likewise.\n+\t(dump_table): Likewise.\n+\t(sh_secondary_reload): Likewise.\n+\t* config/sh/sh.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t* config/sh/sh.md (casesi_worker_1): Likewise.\n+\t(casesi_worker_2): Likewise.\n+\t* config/sparc/predicates.md (icc_comparison_operator): Likewise.\n+\t(fcc_comparison_operator): Likewise.\n+\t* config/sparc/sparc.c (sparc_expand_move): Likewise.\n+\t(emit_soft_tfmode_cvt): Likewise.\n+\t(sparc_preferred_simd_mode): Likewise.\n+\t(output_cbranch): Likewise.\n+\t(sparc_print_operand): Likewise.\n+\t(sparc_expand_vec_perm_bmask): Likewise.\n+\t(vector_init_bshuffle): Likewise.\n+\t* config/spu/spu.c (spu_scalar_mode_supported_p): Likewise.\n+\t(spu_vector_mode_supported_p): Likewise.\n+\t(spu_expand_insv): Likewise.\n+\t(spu_emit_branch_or_set): Likewise.\n+\t(spu_handle_vector_attribute): Likewise.\n+\t(spu_builtin_splats): Likewise.\n+\t(spu_builtin_extract): Likewise.\n+\t(spu_builtin_promote): Likewise.\n+\t(spu_expand_sign_extend): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_scalar_mode_supported_p): Likewise.\n+\t(tilegx_simd_int): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_scalar_mode_supported_p): Likewise.\n+\t(tilepro_simd_int): Likewise.\n+\t* config/v850/v850.c (const_double_split): Likewise.\n+\t(v850_print_operand): Likewise.\n+\t(ep_memory_offset): Likewise.\n+\t* config/vax/vax.c (vax_rtx_costs): Likewise.\n+\t(vax_output_int_move): Likewise.\n+\t(vax_output_int_add): Likewise.\n+\t(vax_output_int_subtract): Likewise.\n+\t* config/visium/predicates.md (visium_branch_operator): Likewise.\n+\t* config/visium/visium.c (rtx_ok_for_offset_p): Likewise.\n+\t(visium_print_operand_address): Likewise.\n+\t* config/visium/visium.h (ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_mem_offset): Likewise.\n+\t(xtensa_expand_conditional_branch): Likewise.\n+\t(xtensa_copy_incoming_a7): Likewise.\n+\t(xtensa_output_literal): Likewise.\n+\t* dfp.c (decimal_real_maxval): Likewise.\n+\t* targhooks.c (default_libgcc_floating_mode_supported_p): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e8bf5c3149314b5810ddcb38394cf2e7c01be501", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* c-cppbuiltin.c (mode_has_fma): Prefix mode names with E_ in\n+\tcase statements.\n+\n 2017-08-29  Martin Liska  <mliska@suse.cz>\n \n \tPR other/39851"}, {"sha": "6dc1559877b945528901ec1f6f7053b1456bd2b4", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -73,22 +73,22 @@ mode_has_fma (machine_mode mode)\n   switch (mode)\n     {\n #ifdef HAVE_fmasf4\n-    case SFmode:\n+    case E_SFmode:\n       return !!HAVE_fmasf4;\n #endif\n \n #ifdef HAVE_fmadf4\n-    case DFmode:\n+    case E_DFmode:\n       return !!HAVE_fmadf4;\n #endif\n \n #ifdef HAVE_fmaxf4\n-    case XFmode:\n+    case E_XFmode:\n       return !!HAVE_fmaxf4;\n #endif\n \n #ifdef HAVE_fmatf4\n-    case TFmode:\n+    case E_TFmode:\n       return !!HAVE_fmatf4;\n #endif\n "}, {"sha": "25ee5129f62d24ec494b15719d44a48f7374067a", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -537,27 +537,27 @@ aarch64_simd_builtin_std_type (machine_mode mode,\n   ((q == qualifier_none) ? int##M##_type_node : unsigned_int##M##_type_node);\n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       return QUAL_TYPE (QI);\n-    case HImode:\n+    case E_HImode:\n       return QUAL_TYPE (HI);\n-    case SImode:\n+    case E_SImode:\n       return QUAL_TYPE (SI);\n-    case DImode:\n+    case E_DImode:\n       return QUAL_TYPE (DI);\n-    case TImode:\n+    case E_TImode:\n       return QUAL_TYPE (TI);\n-    case OImode:\n+    case E_OImode:\n       return aarch64_simd_intOI_type_node;\n-    case CImode:\n+    case E_CImode:\n       return aarch64_simd_intCI_type_node;\n-    case XImode:\n+    case E_XImode:\n       return aarch64_simd_intXI_type_node;\n-    case HFmode:\n+    case E_HFmode:\n       return aarch64_fp16_type_node;\n-    case SFmode:\n+    case E_SFmode:\n       return float_type_node;\n-    case DFmode:\n+    case E_DFmode:\n       return double_type_node;\n     default:\n       gcc_unreachable ();"}, {"sha": "12d67a09f64a4ec83ad03ebc350e341db706340f", "filename": "gcc/config/aarch64/aarch64-elf.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -74,16 +74,16 @@\n   do {\t\t\t\t\t\t\t\t\t\\\n     switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-      case QImode:\t\t\t\t\t\t\t\\\n+      case E_QImode:\t\t\t\t\t\t\t\\\n \tasm_fprintf (STREAM, \"\\t.byte\\t(%LL%d - %LLrtx%d) / 4\\n\",\t\\\n \t\t     VALUE, REL);\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n-      case HImode:\t\t\t\t\t\t\t\\\n+      case E_HImode:\t\t\t\t\t\t\t\\\n \tasm_fprintf (STREAM, \"\\t.2byte\\t(%LL%d - %LLrtx%d) / 4\\n\",\t\\\n \t\t     VALUE, REL);\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n-      case SImode:\t\t\t\t\t\t\t\\\n-      case DImode: /* See comment in aarch64_output_casesi.  */\t\t\\\n+      case E_SImode:\t\t\t\t\t\t\t\\\n+      case E_DImode: /* See comment in aarch64_output_casesi.  */\t\t\\\n \tasm_fprintf (STREAM, \"\\t.word\\t(%LL%d - %LLrtx%d) / 4\\n\",\t\\\n \t\t     VALUE, REL);\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\"}, {"sha": "ced6f9bf82948b3c3da022f360f03fd2268551d6", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 234, "deletions": 234, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1698,25 +1698,25 @@ aarch64_split_simd_combine (rtx dst, rtx src1, rtx src2)\n \n   switch (src_mode)\n     {\n-    case V8QImode:\n+    case E_V8QImode:\n       gen = gen_aarch64_simd_combinev8qi;\n       break;\n-    case V4HImode:\n+    case E_V4HImode:\n       gen = gen_aarch64_simd_combinev4hi;\n       break;\n-    case V2SImode:\n+    case E_V2SImode:\n       gen = gen_aarch64_simd_combinev2si;\n       break;\n-    case V4HFmode:\n+    case E_V4HFmode:\n       gen = gen_aarch64_simd_combinev4hf;\n       break;\n-    case V2SFmode:\n+    case E_V2SFmode:\n       gen = gen_aarch64_simd_combinev2sf;\n       break;\n-    case DImode:\n+    case E_DImode:\n       gen = gen_aarch64_simd_combinedi;\n       break;\n-    case DFmode:\n+    case E_DFmode:\n       gen = gen_aarch64_simd_combinedf;\n       break;\n     default:\n@@ -1745,25 +1745,25 @@ aarch64_split_simd_move (rtx dst, rtx src)\n \n       switch (src_mode)\n \t{\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  gen = gen_aarch64_split_simd_movv16qi;\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  gen = gen_aarch64_split_simd_movv8hi;\n \t  break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  gen = gen_aarch64_split_simd_movv4si;\n \t  break;\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  gen = gen_aarch64_split_simd_movv2di;\n \t  break;\n-\tcase V8HFmode:\n+\tcase E_V8HFmode:\n \t  gen = gen_aarch64_split_simd_movv8hf;\n \t  break;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  gen = gen_aarch64_split_simd_movv4sf;\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  gen = gen_aarch64_split_simd_movv2df;\n \t  break;\n \tdefault:\n@@ -3086,11 +3086,11 @@ aarch64_gen_storewb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n {\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       return gen_storewb_pairdi_di (base, base, reg, reg2,\n \t\t\t\t    GEN_INT (-adjustment),\n \t\t\t\t    GEN_INT (UNITS_PER_WORD - adjustment));\n-    case DFmode:\n+    case E_DFmode:\n       return gen_storewb_pairdf_di (base, base, reg, reg2,\n \t\t\t\t    GEN_INT (-adjustment),\n \t\t\t\t    GEN_INT (UNITS_PER_WORD - adjustment));\n@@ -3130,10 +3130,10 @@ aarch64_gen_loadwb_pair (machine_mode mode, rtx base, rtx reg, rtx reg2,\n {\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       return gen_loadwb_pairdi_di (base, base, reg, reg2, GEN_INT (adjustment),\n \t\t\t\t   GEN_INT (UNITS_PER_WORD));\n-    case DFmode:\n+    case E_DFmode:\n       return gen_loadwb_pairdf_di (base, base, reg, reg2, GEN_INT (adjustment),\n \t\t\t\t   GEN_INT (UNITS_PER_WORD));\n     default:\n@@ -3178,10 +3178,10 @@ aarch64_gen_store_pair (machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n {\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       return gen_store_pairdi (mem1, reg1, mem2, reg2);\n \n-    case DFmode:\n+    case E_DFmode:\n       return gen_store_pairdf (mem1, reg1, mem2, reg2);\n \n     default:\n@@ -3198,10 +3198,10 @@ aarch64_gen_load_pair (machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n {\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       return gen_load_pairdi (reg1, mem1, reg2, mem2);\n \n-    case DFmode:\n+    case E_DFmode:\n       return gen_load_pairdf (reg1, mem1, reg2, mem2);\n \n     default:\n@@ -4994,8 +4994,8 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n {\n   switch (mode)\n     {\n-    case CCFPmode:\n-    case CCFPEmode:\n+    case E_CCFPmode:\n+    case E_CCFPEmode:\n       switch (comp_code)\n \t{\n \tcase GE: return AARCH64_GE;\n@@ -5014,7 +5014,7 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n \t}\n       break;\n \n-    case CCmode:\n+    case E_CCmode:\n       switch (comp_code)\n \t{\n \tcase NE: return AARCH64_NE;\n@@ -5031,7 +5031,7 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n \t}\n       break;\n \n-    case CC_SWPmode:\n+    case E_CC_SWPmode:\n       switch (comp_code)\n \t{\n \tcase NE: return AARCH64_NE;\n@@ -5048,7 +5048,7 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n \t}\n       break;\n \n-    case CC_NZmode:\n+    case E_CC_NZmode:\n       switch (comp_code)\n \t{\n \tcase NE: return AARCH64_NE;\n@@ -5059,7 +5059,7 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n \t}\n       break;\n \n-    case CC_Zmode:\n+    case E_CC_Zmode:\n       switch (comp_code)\n \t{\n \tcase NE: return AARCH64_NE;\n@@ -5068,7 +5068,7 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n \t}\n       break;\n \n-    case CC_Cmode:\n+    case E_CC_Cmode:\n       switch (comp_code)\n \t{\n \tcase NE: return AARCH64_CS;\n@@ -5776,37 +5776,37 @@ aarch64_constant_pool_reload_icode (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case SFmode:\n+    case E_SFmode:\n       return CODE_FOR_aarch64_reload_movcpsfdi;\n \n-    case DFmode:\n+    case E_DFmode:\n       return CODE_FOR_aarch64_reload_movcpdfdi;\n \n-    case TFmode:\n+    case E_TFmode:\n       return CODE_FOR_aarch64_reload_movcptfdi;\n \n-    case V8QImode:\n+    case E_V8QImode:\n       return CODE_FOR_aarch64_reload_movcpv8qidi;\n \n-    case V16QImode:\n+    case E_V16QImode:\n       return CODE_FOR_aarch64_reload_movcpv16qidi;\n \n-    case V4HImode:\n+    case E_V4HImode:\n       return CODE_FOR_aarch64_reload_movcpv4hidi;\n \n-    case V8HImode:\n+    case E_V8HImode:\n       return CODE_FOR_aarch64_reload_movcpv8hidi;\n \n-    case V2SImode:\n+    case E_V2SImode:\n       return CODE_FOR_aarch64_reload_movcpv2sidi;\n \n-    case V4SImode:\n+    case E_V4SImode:\n       return CODE_FOR_aarch64_reload_movcpv4sidi;\n \n-    case V2DImode:\n+    case E_V2DImode:\n       return CODE_FOR_aarch64_reload_movcpv2didi;\n \n-    case V2DFmode:\n+    case E_V2DFmode:\n       return CODE_FOR_aarch64_reload_movcpv2dfdi;\n \n     default:\n@@ -8222,11 +8222,11 @@ get_rsqrte_type (machine_mode mode)\n {\n   switch (mode)\n   {\n-    case DFmode:   return gen_aarch64_rsqrtedf;\n-    case SFmode:   return gen_aarch64_rsqrtesf;\n-    case V2DFmode: return gen_aarch64_rsqrtev2df;\n-    case V2SFmode: return gen_aarch64_rsqrtev2sf;\n-    case V4SFmode: return gen_aarch64_rsqrtev4sf;\n+    case E_DFmode:   return gen_aarch64_rsqrtedf;\n+    case E_SFmode:   return gen_aarch64_rsqrtesf;\n+    case E_V2DFmode: return gen_aarch64_rsqrtev2df;\n+    case E_V2SFmode: return gen_aarch64_rsqrtev2sf;\n+    case E_V4SFmode: return gen_aarch64_rsqrtev4sf;\n     default: gcc_unreachable ();\n   }\n }\n@@ -8240,11 +8240,11 @@ get_rsqrts_type (machine_mode mode)\n {\n   switch (mode)\n   {\n-    case DFmode:   return gen_aarch64_rsqrtsdf;\n-    case SFmode:   return gen_aarch64_rsqrtssf;\n-    case V2DFmode: return gen_aarch64_rsqrtsv2df;\n-    case V2SFmode: return gen_aarch64_rsqrtsv2sf;\n-    case V4SFmode: return gen_aarch64_rsqrtsv4sf;\n+    case E_DFmode:   return gen_aarch64_rsqrtsdf;\n+    case E_SFmode:   return gen_aarch64_rsqrtssf;\n+    case E_V2DFmode: return gen_aarch64_rsqrtsv2df;\n+    case E_V2SFmode: return gen_aarch64_rsqrtsv2sf;\n+    case E_V4SFmode: return gen_aarch64_rsqrtsv4sf;\n     default: gcc_unreachable ();\n   }\n }\n@@ -8349,12 +8349,12 @@ get_recpe_type (machine_mode mode)\n {\n   switch (mode)\n   {\n-    case SFmode:   return (gen_aarch64_frecpesf);\n-    case V2SFmode: return (gen_aarch64_frecpev2sf);\n-    case V4SFmode: return (gen_aarch64_frecpev4sf);\n-    case DFmode:   return (gen_aarch64_frecpedf);\n-    case V2DFmode: return (gen_aarch64_frecpev2df);\n-    default:       gcc_unreachable ();\n+    case E_SFmode:   return (gen_aarch64_frecpesf);\n+    case E_V2SFmode: return (gen_aarch64_frecpev2sf);\n+    case E_V4SFmode: return (gen_aarch64_frecpev4sf);\n+    case E_DFmode:   return (gen_aarch64_frecpedf);\n+    case E_V2DFmode: return (gen_aarch64_frecpev2df);\n+    default:         gcc_unreachable ();\n   }\n }\n \n@@ -8367,12 +8367,12 @@ get_recps_type (machine_mode mode)\n {\n   switch (mode)\n   {\n-    case SFmode:   return (gen_aarch64_frecpssf);\n-    case V2SFmode: return (gen_aarch64_frecpsv2sf);\n-    case V4SFmode: return (gen_aarch64_frecpsv4sf);\n-    case DFmode:   return (gen_aarch64_frecpsdf);\n-    case V2DFmode: return (gen_aarch64_frecpsv2df);\n-    default:       gcc_unreachable ();\n+    case E_SFmode:   return (gen_aarch64_frecpssf);\n+    case E_V2SFmode: return (gen_aarch64_frecpsv2sf);\n+    case E_V4SFmode: return (gen_aarch64_frecpsv4sf);\n+    case E_DFmode:   return (gen_aarch64_frecpsdf);\n+    case E_V2DFmode: return (gen_aarch64_frecpsv2df);\n+    default:         gcc_unreachable ();\n   }\n }\n \n@@ -10743,24 +10743,24 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       /* Establish the base type.  */\n       switch (ag_mode)\n \t{\n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  field_t = float_type_node;\n \t  field_ptr_t = float_ptr_type_node;\n \t  break;\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  field_t = double_type_node;\n \t  field_ptr_t = double_ptr_type_node;\n \t  break;\n-\tcase TFmode:\n+\tcase E_TFmode:\n \t  field_t = long_double_type_node;\n \t  field_ptr_t = long_double_ptr_type_node;\n \t  break;\n-\tcase HFmode:\n+\tcase E_HFmode:\n \t  field_t = aarch64_fp16_type_node;\n \t  field_ptr_t = aarch64_fp16_ptr_type_node;\n \t  break;\n-\tcase V2SImode:\n-\tcase V4SImode:\n+\tcase E_V2SImode:\n+\tcase E_V4SImode:\n \t    {\n \t      tree innertype = make_signed_type (GET_MODE_PRECISION (SImode));\n \t      field_t = build_vector_type_for_mode (innertype, ag_mode);\n@@ -11217,35 +11217,35 @@ aarch64_simd_container_mode (machine_mode mode, unsigned width)\n       if (width == 128)\n \tswitch (mode)\n \t  {\n-\t  case DFmode:\n+\t  case E_DFmode:\n \t    return V2DFmode;\n-\t  case SFmode:\n+\t  case E_SFmode:\n \t    return V4SFmode;\n-\t  case HFmode:\n+\t  case E_HFmode:\n \t    return V8HFmode;\n-\t  case SImode:\n+\t  case E_SImode:\n \t    return V4SImode;\n-\t  case HImode:\n+\t  case E_HImode:\n \t    return V8HImode;\n-\t  case QImode:\n+\t  case E_QImode:\n \t    return V16QImode;\n-\t  case DImode:\n+\t  case E_DImode:\n \t    return V2DImode;\n \t  default:\n \t    break;\n \t  }\n       else\n \tswitch (mode)\n \t  {\n-\t  case SFmode:\n+\t  case E_SFmode:\n \t    return V2SFmode;\n-\t  case HFmode:\n+\t  case E_HFmode:\n \t    return V4HFmode;\n-\t  case SImode:\n+\t  case E_SImode:\n \t    return V2SImode;\n-\t  case HImode:\n+\t  case E_HImode:\n \t    return V4HImode;\n-\t  case QImode:\n+\t  case E_QImode:\n \t    return V8QImode;\n \t  default:\n \t    break;\n@@ -12211,10 +12211,10 @@ aarch64_emit_load_exclusive (machine_mode mode, rtx rval,\n \n   switch (mode)\n     {\n-    case QImode: gen = gen_aarch64_load_exclusiveqi; break;\n-    case HImode: gen = gen_aarch64_load_exclusivehi; break;\n-    case SImode: gen = gen_aarch64_load_exclusivesi; break;\n-    case DImode: gen = gen_aarch64_load_exclusivedi; break;\n+    case E_QImode: gen = gen_aarch64_load_exclusiveqi; break;\n+    case E_HImode: gen = gen_aarch64_load_exclusivehi; break;\n+    case E_SImode: gen = gen_aarch64_load_exclusivesi; break;\n+    case E_DImode: gen = gen_aarch64_load_exclusivedi; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -12232,10 +12232,10 @@ aarch64_emit_store_exclusive (machine_mode mode, rtx bval,\n \n   switch (mode)\n     {\n-    case QImode: gen = gen_aarch64_store_exclusiveqi; break;\n-    case HImode: gen = gen_aarch64_store_exclusivehi; break;\n-    case SImode: gen = gen_aarch64_store_exclusivesi; break;\n-    case DImode: gen = gen_aarch64_store_exclusivedi; break;\n+    case E_QImode: gen = gen_aarch64_store_exclusiveqi; break;\n+    case E_HImode: gen = gen_aarch64_store_exclusivehi; break;\n+    case E_SImode: gen = gen_aarch64_store_exclusivesi; break;\n+    case E_DImode: gen = gen_aarch64_store_exclusivedi; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -12298,17 +12298,17 @@ aarch64_expand_compare_and_swap (rtx operands[])\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n+    case E_QImode:\n+    case E_HImode:\n       /* For short modes, we're going to perform the comparison in SImode,\n \t so do the zero-extension now.  */\n       cmp_mode = SImode;\n       rval = gen_reg_rtx (SImode);\n       oldval = convert_modes (SImode, mode, oldval, true);\n       /* Fall through.  */\n \n-    case SImode:\n-    case DImode:\n+    case E_SImode:\n+    case E_DImode:\n       /* Force the value into a register if needed.  */\n       if (!aarch64_plus_operand (oldval, mode))\n \toldval = force_reg (cmp_mode, oldval);\n@@ -12320,10 +12320,10 @@ aarch64_expand_compare_and_swap (rtx operands[])\n \n   switch (mode)\n     {\n-    case QImode: idx = 0; break;\n-    case HImode: idx = 1; break;\n-    case SImode: idx = 2; break;\n-    case DImode: idx = 3; break;\n+    case E_QImode: idx = 0; break;\n+    case E_HImode: idx = 1; break;\n+    case E_SImode: idx = 2; break;\n+    case E_DImode: idx = 3; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -12402,10 +12402,10 @@ aarch64_gen_atomic_cas (rtx rval, rtx mem,\n \n   switch (mode)\n     {\n-    case QImode: gen = gen_aarch64_atomic_casqi; break;\n-    case HImode: gen = gen_aarch64_atomic_cashi; break;\n-    case SImode: gen = gen_aarch64_atomic_cassi; break;\n-    case DImode: gen = gen_aarch64_atomic_casdi; break;\n+    case E_QImode: gen = gen_aarch64_atomic_casqi; break;\n+    case E_HImode: gen = gen_aarch64_atomic_cashi; break;\n+    case E_SImode: gen = gen_aarch64_atomic_cassi; break;\n+    case E_DImode: gen = gen_aarch64_atomic_casdi; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -12528,8 +12528,8 @@ aarch64_emit_bic (machine_mode mode, rtx dst, rtx s1, rtx s2, int shift)\n \n   switch (mode)\n     {\n-    case SImode: gen = gen_and_one_cmpl_lshrsi3; break;\n-    case DImode: gen = gen_and_one_cmpl_lshrdi3; break;\n+    case E_SImode: gen = gen_and_one_cmpl_lshrsi3; break;\n+    case E_DImode: gen = gen_and_one_cmpl_lshrdi3; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -12547,10 +12547,10 @@ aarch64_emit_atomic_swap (machine_mode mode, rtx dst, rtx value,\n \n   switch (mode)\n     {\n-    case QImode: gen = gen_aarch64_atomic_swpqi; break;\n-    case HImode: gen = gen_aarch64_atomic_swphi; break;\n-    case SImode: gen = gen_aarch64_atomic_swpsi; break;\n-    case DImode: gen = gen_aarch64_atomic_swpdi; break;\n+    case E_QImode: gen = gen_aarch64_atomic_swpqi; break;\n+    case E_HImode: gen = gen_aarch64_atomic_swphi; break;\n+    case E_SImode: gen = gen_aarch64_atomic_swpsi; break;\n+    case E_DImode: gen = gen_aarch64_atomic_swpdi; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -12609,10 +12609,10 @@ aarch64_emit_atomic_load_op (enum aarch64_atomic_load_op_code code,\n \n   switch (mode)\n     {\n-    case QImode: idx = 0; break;\n-    case HImode: idx = 1; break;\n-    case SImode: idx = 2; break;\n-    case DImode: idx = 3; break;\n+    case E_QImode: idx = 0; break;\n+    case E_HImode: idx = 1; break;\n+    case E_SImode: idx = 2; break;\n+    case E_DImode: idx = 3; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -13243,18 +13243,18 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n     {\n       switch (vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_trn2v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_trn2v8qi; break;\n-\tcase V8HImode: gen = gen_aarch64_trn2v8hi; break;\n-\tcase V4HImode: gen = gen_aarch64_trn2v4hi; break;\n-\tcase V4SImode: gen = gen_aarch64_trn2v4si; break;\n-\tcase V2SImode: gen = gen_aarch64_trn2v2si; break;\n-\tcase V2DImode: gen = gen_aarch64_trn2v2di; break;\n-\tcase V4HFmode: gen = gen_aarch64_trn2v4hf; break;\n-\tcase V8HFmode: gen = gen_aarch64_trn2v8hf; break;\n-\tcase V4SFmode: gen = gen_aarch64_trn2v4sf; break;\n-\tcase V2SFmode: gen = gen_aarch64_trn2v2sf; break;\n-\tcase V2DFmode: gen = gen_aarch64_trn2v2df; break;\n+\tcase E_V16QImode: gen = gen_aarch64_trn2v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_trn2v8qi; break;\n+\tcase E_V8HImode: gen = gen_aarch64_trn2v8hi; break;\n+\tcase E_V4HImode: gen = gen_aarch64_trn2v4hi; break;\n+\tcase E_V4SImode: gen = gen_aarch64_trn2v4si; break;\n+\tcase E_V2SImode: gen = gen_aarch64_trn2v2si; break;\n+\tcase E_V2DImode: gen = gen_aarch64_trn2v2di; break;\n+\tcase E_V4HFmode: gen = gen_aarch64_trn2v4hf; break;\n+\tcase E_V8HFmode: gen = gen_aarch64_trn2v8hf; break;\n+\tcase E_V4SFmode: gen = gen_aarch64_trn2v4sf; break;\n+\tcase E_V2SFmode: gen = gen_aarch64_trn2v2sf; break;\n+\tcase E_V2DFmode: gen = gen_aarch64_trn2v2df; break;\n \tdefault:\n \t  return false;\n \t}\n@@ -13263,18 +13263,18 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n     {\n       switch (vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_trn1v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_trn1v8qi; break;\n-\tcase V8HImode: gen = gen_aarch64_trn1v8hi; break;\n-\tcase V4HImode: gen = gen_aarch64_trn1v4hi; break;\n-\tcase V4SImode: gen = gen_aarch64_trn1v4si; break;\n-\tcase V2SImode: gen = gen_aarch64_trn1v2si; break;\n-\tcase V2DImode: gen = gen_aarch64_trn1v2di; break;\n-\tcase V4HFmode: gen = gen_aarch64_trn1v4hf; break;\n-\tcase V8HFmode: gen = gen_aarch64_trn1v8hf; break;\n-\tcase V4SFmode: gen = gen_aarch64_trn1v4sf; break;\n-\tcase V2SFmode: gen = gen_aarch64_trn1v2sf; break;\n-\tcase V2DFmode: gen = gen_aarch64_trn1v2df; break;\n+\tcase E_V16QImode: gen = gen_aarch64_trn1v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_trn1v8qi; break;\n+\tcase E_V8HImode: gen = gen_aarch64_trn1v8hi; break;\n+\tcase E_V4HImode: gen = gen_aarch64_trn1v4hi; break;\n+\tcase E_V4SImode: gen = gen_aarch64_trn1v4si; break;\n+\tcase E_V2SImode: gen = gen_aarch64_trn1v2si; break;\n+\tcase E_V2DImode: gen = gen_aarch64_trn1v2di; break;\n+\tcase E_V4HFmode: gen = gen_aarch64_trn1v4hf; break;\n+\tcase E_V8HFmode: gen = gen_aarch64_trn1v8hf; break;\n+\tcase E_V4SFmode: gen = gen_aarch64_trn1v4sf; break;\n+\tcase E_V2SFmode: gen = gen_aarch64_trn1v2sf; break;\n+\tcase E_V2DFmode: gen = gen_aarch64_trn1v2df; break;\n \tdefault:\n \t  return false;\n \t}\n@@ -13330,18 +13330,18 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n     {\n       switch (vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_uzp2v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_uzp2v8qi; break;\n-\tcase V8HImode: gen = gen_aarch64_uzp2v8hi; break;\n-\tcase V4HImode: gen = gen_aarch64_uzp2v4hi; break;\n-\tcase V4SImode: gen = gen_aarch64_uzp2v4si; break;\n-\tcase V2SImode: gen = gen_aarch64_uzp2v2si; break;\n-\tcase V2DImode: gen = gen_aarch64_uzp2v2di; break;\n-\tcase V4HFmode: gen = gen_aarch64_uzp2v4hf; break;\n-\tcase V8HFmode: gen = gen_aarch64_uzp2v8hf; break;\n-\tcase V4SFmode: gen = gen_aarch64_uzp2v4sf; break;\n-\tcase V2SFmode: gen = gen_aarch64_uzp2v2sf; break;\n-\tcase V2DFmode: gen = gen_aarch64_uzp2v2df; break;\n+\tcase E_V16QImode: gen = gen_aarch64_uzp2v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_uzp2v8qi; break;\n+\tcase E_V8HImode: gen = gen_aarch64_uzp2v8hi; break;\n+\tcase E_V4HImode: gen = gen_aarch64_uzp2v4hi; break;\n+\tcase E_V4SImode: gen = gen_aarch64_uzp2v4si; break;\n+\tcase E_V2SImode: gen = gen_aarch64_uzp2v2si; break;\n+\tcase E_V2DImode: gen = gen_aarch64_uzp2v2di; break;\n+\tcase E_V4HFmode: gen = gen_aarch64_uzp2v4hf; break;\n+\tcase E_V8HFmode: gen = gen_aarch64_uzp2v8hf; break;\n+\tcase E_V4SFmode: gen = gen_aarch64_uzp2v4sf; break;\n+\tcase E_V2SFmode: gen = gen_aarch64_uzp2v2sf; break;\n+\tcase E_V2DFmode: gen = gen_aarch64_uzp2v2df; break;\n \tdefault:\n \t  return false;\n \t}\n@@ -13350,18 +13350,18 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n     {\n       switch (vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_uzp1v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_uzp1v8qi; break;\n-\tcase V8HImode: gen = gen_aarch64_uzp1v8hi; break;\n-\tcase V4HImode: gen = gen_aarch64_uzp1v4hi; break;\n-\tcase V4SImode: gen = gen_aarch64_uzp1v4si; break;\n-\tcase V2SImode: gen = gen_aarch64_uzp1v2si; break;\n-\tcase V2DImode: gen = gen_aarch64_uzp1v2di; break;\n-\tcase V4HFmode: gen = gen_aarch64_uzp1v4hf; break;\n-\tcase V8HFmode: gen = gen_aarch64_uzp1v8hf; break;\n-\tcase V4SFmode: gen = gen_aarch64_uzp1v4sf; break;\n-\tcase V2SFmode: gen = gen_aarch64_uzp1v2sf; break;\n-\tcase V2DFmode: gen = gen_aarch64_uzp1v2df; break;\n+\tcase E_V16QImode: gen = gen_aarch64_uzp1v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_uzp1v8qi; break;\n+\tcase E_V8HImode: gen = gen_aarch64_uzp1v8hi; break;\n+\tcase E_V4HImode: gen = gen_aarch64_uzp1v4hi; break;\n+\tcase E_V4SImode: gen = gen_aarch64_uzp1v4si; break;\n+\tcase E_V2SImode: gen = gen_aarch64_uzp1v2si; break;\n+\tcase E_V2DImode: gen = gen_aarch64_uzp1v2di; break;\n+\tcase E_V4HFmode: gen = gen_aarch64_uzp1v4hf; break;\n+\tcase E_V8HFmode: gen = gen_aarch64_uzp1v8hf; break;\n+\tcase E_V4SFmode: gen = gen_aarch64_uzp1v4sf; break;\n+\tcase E_V2SFmode: gen = gen_aarch64_uzp1v2sf; break;\n+\tcase E_V2DFmode: gen = gen_aarch64_uzp1v2df; break;\n \tdefault:\n \t  return false;\n \t}\n@@ -13422,18 +13422,18 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n     {\n       switch (vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_zip2v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_zip2v8qi; break;\n-\tcase V8HImode: gen = gen_aarch64_zip2v8hi; break;\n-\tcase V4HImode: gen = gen_aarch64_zip2v4hi; break;\n-\tcase V4SImode: gen = gen_aarch64_zip2v4si; break;\n-\tcase V2SImode: gen = gen_aarch64_zip2v2si; break;\n-\tcase V2DImode: gen = gen_aarch64_zip2v2di; break;\n-\tcase V4HFmode: gen = gen_aarch64_zip2v4hf; break;\n-\tcase V8HFmode: gen = gen_aarch64_zip2v8hf; break;\n-\tcase V4SFmode: gen = gen_aarch64_zip2v4sf; break;\n-\tcase V2SFmode: gen = gen_aarch64_zip2v2sf; break;\n-\tcase V2DFmode: gen = gen_aarch64_zip2v2df; break;\n+\tcase E_V16QImode: gen = gen_aarch64_zip2v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_zip2v8qi; break;\n+\tcase E_V8HImode: gen = gen_aarch64_zip2v8hi; break;\n+\tcase E_V4HImode: gen = gen_aarch64_zip2v4hi; break;\n+\tcase E_V4SImode: gen = gen_aarch64_zip2v4si; break;\n+\tcase E_V2SImode: gen = gen_aarch64_zip2v2si; break;\n+\tcase E_V2DImode: gen = gen_aarch64_zip2v2di; break;\n+\tcase E_V4HFmode: gen = gen_aarch64_zip2v4hf; break;\n+\tcase E_V8HFmode: gen = gen_aarch64_zip2v8hf; break;\n+\tcase E_V4SFmode: gen = gen_aarch64_zip2v4sf; break;\n+\tcase E_V2SFmode: gen = gen_aarch64_zip2v2sf; break;\n+\tcase E_V2DFmode: gen = gen_aarch64_zip2v2df; break;\n \tdefault:\n \t  return false;\n \t}\n@@ -13442,18 +13442,18 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n     {\n       switch (vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_zip1v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_zip1v8qi; break;\n-\tcase V8HImode: gen = gen_aarch64_zip1v8hi; break;\n-\tcase V4HImode: gen = gen_aarch64_zip1v4hi; break;\n-\tcase V4SImode: gen = gen_aarch64_zip1v4si; break;\n-\tcase V2SImode: gen = gen_aarch64_zip1v2si; break;\n-\tcase V2DImode: gen = gen_aarch64_zip1v2di; break;\n-\tcase V4HFmode: gen = gen_aarch64_zip1v4hf; break;\n-\tcase V8HFmode: gen = gen_aarch64_zip1v8hf; break;\n-\tcase V4SFmode: gen = gen_aarch64_zip1v4sf; break;\n-\tcase V2SFmode: gen = gen_aarch64_zip1v2sf; break;\n-\tcase V2DFmode: gen = gen_aarch64_zip1v2df; break;\n+\tcase E_V16QImode: gen = gen_aarch64_zip1v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_zip1v8qi; break;\n+\tcase E_V8HImode: gen = gen_aarch64_zip1v8hi; break;\n+\tcase E_V4HImode: gen = gen_aarch64_zip1v4hi; break;\n+\tcase E_V4SImode: gen = gen_aarch64_zip1v4si; break;\n+\tcase E_V2SImode: gen = gen_aarch64_zip1v2si; break;\n+\tcase E_V2DImode: gen = gen_aarch64_zip1v2di; break;\n+\tcase E_V4HFmode: gen = gen_aarch64_zip1v4hf; break;\n+\tcase E_V8HFmode: gen = gen_aarch64_zip1v8hf; break;\n+\tcase E_V4SFmode: gen = gen_aarch64_zip1v4sf; break;\n+\tcase E_V2SFmode: gen = gen_aarch64_zip1v2sf; break;\n+\tcase E_V2DFmode: gen = gen_aarch64_zip1v2df; break;\n \tdefault:\n \t  return false;\n \t}\n@@ -13489,18 +13489,18 @@ aarch64_evpc_ext (struct expand_vec_perm_d *d)\n \n   switch (d->vmode)\n     {\n-    case V16QImode: gen = gen_aarch64_extv16qi; break;\n-    case V8QImode: gen = gen_aarch64_extv8qi; break;\n-    case V4HImode: gen = gen_aarch64_extv4hi; break;\n-    case V8HImode: gen = gen_aarch64_extv8hi; break;\n-    case V2SImode: gen = gen_aarch64_extv2si; break;\n-    case V4SImode: gen = gen_aarch64_extv4si; break;\n-    case V4HFmode: gen = gen_aarch64_extv4hf; break;\n-    case V8HFmode: gen = gen_aarch64_extv8hf; break;\n-    case V2SFmode: gen = gen_aarch64_extv2sf; break;\n-    case V4SFmode: gen = gen_aarch64_extv4sf; break;\n-    case V2DImode: gen = gen_aarch64_extv2di; break;\n-    case V2DFmode: gen = gen_aarch64_extv2df; break;\n+    case E_V16QImode: gen = gen_aarch64_extv16qi; break;\n+    case E_V8QImode: gen = gen_aarch64_extv8qi; break;\n+    case E_V4HImode: gen = gen_aarch64_extv4hi; break;\n+    case E_V8HImode: gen = gen_aarch64_extv8hi; break;\n+    case E_V2SImode: gen = gen_aarch64_extv2si; break;\n+    case E_V4SImode: gen = gen_aarch64_extv4si; break;\n+    case E_V4HFmode: gen = gen_aarch64_extv4hf; break;\n+    case E_V8HFmode: gen = gen_aarch64_extv8hf; break;\n+    case E_V2SFmode: gen = gen_aarch64_extv2sf; break;\n+    case E_V4SFmode: gen = gen_aarch64_extv4sf; break;\n+    case E_V2DImode: gen = gen_aarch64_extv2di; break;\n+    case E_V2DFmode: gen = gen_aarch64_extv2df; break;\n     default:\n       return false;\n     }\n@@ -13544,36 +13544,36 @@ aarch64_evpc_rev (struct expand_vec_perm_d *d)\n     case 7:\n       switch (d->vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_rev64v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_rev64v8qi;  break;\n+\tcase E_V16QImode: gen = gen_aarch64_rev64v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_rev64v8qi;  break;\n \tdefault:\n \t  return false;\n \t}\n       break;\n     case 3:\n       switch (d->vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_rev32v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_rev32v8qi;  break;\n-\tcase V8HImode: gen = gen_aarch64_rev64v8hi;  break;\n-\tcase V4HImode: gen = gen_aarch64_rev64v4hi;  break;\n+\tcase E_V16QImode: gen = gen_aarch64_rev32v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_rev32v8qi;  break;\n+\tcase E_V8HImode: gen = gen_aarch64_rev64v8hi;  break;\n+\tcase E_V4HImode: gen = gen_aarch64_rev64v4hi;  break;\n \tdefault:\n \t  return false;\n \t}\n       break;\n     case 1:\n       switch (d->vmode)\n \t{\n-\tcase V16QImode: gen = gen_aarch64_rev16v16qi; break;\n-\tcase V8QImode: gen = gen_aarch64_rev16v8qi;  break;\n-\tcase V8HImode: gen = gen_aarch64_rev32v8hi;  break;\n-\tcase V4HImode: gen = gen_aarch64_rev32v4hi;  break;\n-\tcase V4SImode: gen = gen_aarch64_rev64v4si;  break;\n-\tcase V2SImode: gen = gen_aarch64_rev64v2si;  break;\n-\tcase V4SFmode: gen = gen_aarch64_rev64v4sf;  break;\n-\tcase V2SFmode: gen = gen_aarch64_rev64v2sf;  break;\n-\tcase V8HFmode: gen = gen_aarch64_rev64v8hf;  break;\n-\tcase V4HFmode: gen = gen_aarch64_rev64v4hf;  break;\n+\tcase E_V16QImode: gen = gen_aarch64_rev16v16qi; break;\n+\tcase E_V8QImode: gen = gen_aarch64_rev16v8qi;  break;\n+\tcase E_V8HImode: gen = gen_aarch64_rev32v8hi;  break;\n+\tcase E_V4HImode: gen = gen_aarch64_rev32v4hi;  break;\n+\tcase E_V4SImode: gen = gen_aarch64_rev64v4si;  break;\n+\tcase E_V2SImode: gen = gen_aarch64_rev64v2si;  break;\n+\tcase E_V4SFmode: gen = gen_aarch64_rev64v4sf;  break;\n+\tcase E_V2SFmode: gen = gen_aarch64_rev64v2sf;  break;\n+\tcase E_V8HFmode: gen = gen_aarch64_rev64v8hf;  break;\n+\tcase E_V4HFmode: gen = gen_aarch64_rev64v4hf;  break;\n \tdefault:\n \t  return false;\n \t}\n@@ -13630,18 +13630,18 @@ aarch64_evpc_dup (struct expand_vec_perm_d *d)\n \n   switch (vmode)\n     {\n-    case V16QImode: gen = gen_aarch64_dup_lanev16qi; break;\n-    case V8QImode: gen = gen_aarch64_dup_lanev8qi; break;\n-    case V8HImode: gen = gen_aarch64_dup_lanev8hi; break;\n-    case V4HImode: gen = gen_aarch64_dup_lanev4hi; break;\n-    case V4SImode: gen = gen_aarch64_dup_lanev4si; break;\n-    case V2SImode: gen = gen_aarch64_dup_lanev2si; break;\n-    case V2DImode: gen = gen_aarch64_dup_lanev2di; break;\n-    case V8HFmode: gen = gen_aarch64_dup_lanev8hf; break;\n-    case V4HFmode: gen = gen_aarch64_dup_lanev4hf; break;\n-    case V4SFmode: gen = gen_aarch64_dup_lanev4sf; break;\n-    case V2SFmode: gen = gen_aarch64_dup_lanev2sf; break;\n-    case V2DFmode: gen = gen_aarch64_dup_lanev2df; break;\n+    case E_V16QImode: gen = gen_aarch64_dup_lanev16qi; break;\n+    case E_V8QImode: gen = gen_aarch64_dup_lanev8qi; break;\n+    case E_V8HImode: gen = gen_aarch64_dup_lanev8hi; break;\n+    case E_V4HImode: gen = gen_aarch64_dup_lanev4hi; break;\n+    case E_V4SImode: gen = gen_aarch64_dup_lanev4si; break;\n+    case E_V2SImode: gen = gen_aarch64_dup_lanev2si; break;\n+    case E_V2DImode: gen = gen_aarch64_dup_lanev2di; break;\n+    case E_V8HFmode: gen = gen_aarch64_dup_lanev8hf; break;\n+    case E_V4HFmode: gen = gen_aarch64_dup_lanev4hf; break;\n+    case E_V4SFmode: gen = gen_aarch64_dup_lanev4sf; break;\n+    case E_V2SFmode: gen = gen_aarch64_dup_lanev2sf; break;\n+    case E_V2DFmode: gen = gen_aarch64_dup_lanev2df; break;\n     default:\n       return false;\n     }\n@@ -14125,25 +14125,25 @@ aarch64_gen_ccmp_first (rtx_insn **prep_seq, rtx_insn **gen_seq,\n \n   switch (op_mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       cmp_mode = SImode;\n       icode = CODE_FOR_cmpsi;\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       cmp_mode = DImode;\n       icode = CODE_FOR_cmpdi;\n       break;\n \n-    case SFmode:\n+    case E_SFmode:\n       cmp_mode = SFmode;\n       cc_mode = aarch64_select_cc_mode ((rtx_code) code, op0, op1);\n       icode = cc_mode == CCFPEmode ? CODE_FOR_fcmpesf : CODE_FOR_fcmpsf;\n       break;\n \n-    case DFmode:\n+    case E_DFmode:\n       cmp_mode = DFmode;\n       cc_mode = aarch64_select_cc_mode ((rtx_code) code, op0, op1);\n       icode = cc_mode == CCFPEmode ? CODE_FOR_fcmpedf : CODE_FOR_fcmpdf;\n@@ -14200,25 +14200,25 @@ aarch64_gen_ccmp_next (rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev,\n \n   switch (op_mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       cmp_mode = SImode;\n       icode = CODE_FOR_ccmpsi;\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       cmp_mode = DImode;\n       icode = CODE_FOR_ccmpdi;\n       break;\n \n-    case SFmode:\n+    case E_SFmode:\n       cmp_mode = SFmode;\n       cc_mode = aarch64_select_cc_mode ((rtx_code) cmp_code, op0, op1);\n       icode = cc_mode == CCFPEmode ? CODE_FOR_fccmpesf : CODE_FOR_fccmpsf;\n       break;\n \n-    case DFmode:\n+    case E_DFmode:\n       cmp_mode = DFmode;\n       cc_mode = aarch64_select_cc_mode ((rtx_code) cmp_code, op0, op1);\n       icode = cc_mode == CCFPEmode ? CODE_FOR_fccmpedf : CODE_FOR_fccmpdf;"}, {"sha": "64d80a684f0457086153fa1e1d5d8da40611db6b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -695,18 +695,18 @@ alpha_scalar_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case DImode:\n-    case TImode: /* via optabs.c */\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_DImode:\n+    case E_TImode: /* via optabs.c */\n       return true;\n \n-    case SFmode:\n-    case DFmode:\n+    case E_SFmode:\n+    case E_DFmode:\n       return true;\n \n-    case TFmode:\n+    case E_TFmode:\n       return TARGET_HAS_XFLOATING_LIBS;\n \n     default:\n@@ -3076,20 +3076,20 @@ alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n     {\n       switch (GET_MODE (operands[i]))\n \t{\n-\tcase TFmode:\n+\tcase E_TFmode:\n \t  reg = gen_rtx_REG (TFmode, regno);\n \t  regno += 2;\n \t  break;\n \n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  reg = gen_rtx_REG (DFmode, regno + 32);\n \t  regno += 1;\n \t  break;\n \n-\tcase VOIDmode:\n+\tcase E_VOIDmode:\n \t  gcc_assert (CONST_INT_P (operands[i]));\n \t  /* FALLTHRU */\n-\tcase DImode:\n+\tcase E_DImode:\n \t  reg = gen_rtx_REG (DImode, regno);\n \t  regno += 1;\n \t  break;\n@@ -3104,13 +3104,13 @@ alpha_emit_xfloating_libcall (rtx func, rtx target, rtx operands[],\n \n   switch (GET_MODE (target))\n     {\n-    case TFmode:\n+    case E_TFmode:\n       reg = gen_rtx_REG (TFmode, 16);\n       break;\n-    case DFmode:\n+    case E_DFmode:\n       reg = gen_rtx_REG (DFmode, 32);\n       break;\n-    case DImode:\n+    case E_DImode:\n       reg = gen_rtx_REG (DImode, 0);\n       break;\n     default:\n@@ -4383,16 +4383,16 @@ emit_insxl (machine_mode mode, rtx op1, rtx op2)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       fn = gen_insbl;\n       break;\n-    case HImode:\n+    case E_HImode:\n       fn = gen_inswl;\n       break;\n-    case SImode:\n+    case E_SImode:\n       fn = gen_insll;\n       break;\n-    case DImode:\n+    case E_DImode:\n       fn = gen_insql;\n       break;\n     default:\n@@ -9574,9 +9574,9 @@ alpha_arg_type (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case SFmode:\n+    case E_SFmode:\n       return TARGET_FLOAT_VAX ? FF : FS;\n-    case DFmode:\n+    case E_DFmode:\n       return TARGET_FLOAT_VAX ? FD : FT;\n     default:\n       return I64;"}, {"sha": "c072bda257b1069234a5557acc7cd18badfe0630", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -315,13 +315,13 @@ arc_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V2HImode:\n+    case E_V2HImode:\n       return TARGET_PLUS_DMPY;\n-    case V4HImode:\n-    case V2SImode:\n+    case E_V4HImode:\n+    case E_V2SImode:\n       return TARGET_PLUS_QMACW;\n-    case V4SImode:\n-    case V8HImode:\n+    case E_V4SImode:\n+    case E_V8HImode:\n       return TARGET_SIMD_SET;\n \n     default:\n@@ -336,9 +336,9 @@ arc_preferred_simd_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case HImode:\n+    case E_HImode:\n       return TARGET_PLUS_QMACW ? V4HImode : V2HImode;\n-    case SImode:\n+    case E_SImode:\n       return V2SImode;\n \n     default:\n@@ -622,11 +622,11 @@ arc_secondary_reload (bool in_p,\n \t{\n \t  switch (mode)\n \t    {\n-\t    case QImode:\n+\t    case E_QImode:\n \t      sri->icode =\n \t\tin_p ? CODE_FOR_reload_qi_load : CODE_FOR_reload_qi_store;\n \t      break;\n-\t    case HImode:\n+\t    case E_HImode:\n \t      sri->icode =\n \t\tin_p ? CODE_FOR_reload_hi_load : CODE_FOR_reload_hi_store;\n \t      break;\n@@ -1149,8 +1149,8 @@ get_arc_condition_code (rtx comparison)\n {\n   switch (GET_MODE (XEXP (comparison, 0)))\n     {\n-    case CCmode:\n-    case SImode: /* For BRcc.  */\n+    case E_CCmode:\n+    case E_SImode: /* For BRcc.  */\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ : return ARC_CC_EQ;\n@@ -1165,7 +1165,7 @@ get_arc_condition_code (rtx comparison)\n \tcase GEU : return ARC_CC_HS;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_ZNmode:\n+    case E_CC_ZNmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ : return ARC_CC_EQ;\n@@ -1175,21 +1175,21 @@ get_arc_condition_code (rtx comparison)\n \tcase GT : return ARC_CC_PNZ;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_Zmode:\n+    case E_CC_Zmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ : return ARC_CC_EQ;\n \tcase NE : return ARC_CC_NE;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_Cmode:\n+    case E_CC_Cmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase LTU : return ARC_CC_C;\n \tcase GEU : return ARC_CC_NC;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_FP_GTmode:\n+    case E_CC_FP_GTmode:\n       if (TARGET_ARGONAUT_SET && TARGET_SPFP)\n \tswitch (GET_CODE (comparison))\n \t  {\n@@ -1204,29 +1204,29 @@ get_arc_condition_code (rtx comparison)\n \t  case UNLE : return ARC_CC_LS;\n \t  default : gcc_unreachable ();\n \t}\n-    case CC_FP_GEmode:\n+    case E_CC_FP_GEmode:\n       /* Same for FPX and non-FPX.  */\n       switch (GET_CODE (comparison))\n \t{\n \tcase GE   : return ARC_CC_HS;\n \tcase UNLT : return ARC_CC_LO;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_FP_UNEQmode:\n+    case E_CC_FP_UNEQmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase UNEQ : return ARC_CC_EQ;\n \tcase LTGT : return ARC_CC_NE;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_FP_ORDmode:\n+    case E_CC_FP_ORDmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase UNORDERED : return ARC_CC_C;\n \tcase ORDERED   : return ARC_CC_NC;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_FPXmode:\n+    case E_CC_FPXmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ        : return ARC_CC_EQ;\n@@ -1237,7 +1237,7 @@ get_arc_condition_code (rtx comparison)\n \tcase UNEQ      : return ARC_CC_LS;\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_FPUmode:\n+    case E_CC_FPUmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ\t       : return ARC_CC_EQ;\n@@ -1257,7 +1257,7 @@ get_arc_condition_code (rtx comparison)\n \tcase UNEQ      : /* Fall through.  */\n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_FPU_UNEQmode:\n+    case E_CC_FPU_UNEQmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase LTGT : return ARC_CC_NE;\n@@ -3869,8 +3869,8 @@ arc_print_operand (FILE *file, rtx x, int code)\n \tsize_suffix:\n \t  switch (GET_MODE (XEXP (x, 0)))\n \t    {\n-\t    case QImode: fputs (\"b\", file); return;\n-\t    case HImode: fputs (\"w\", file); return;\n+\t    case E_QImode: fputs (\"b\", file); return;\n+\t    case E_HImode: fputs (\"w\", file); return;\n \t    default: break;\n \t    }\n \t  break;\n@@ -5814,10 +5814,10 @@ arc_legitimate_constant_p (machine_mode mode, rtx x)\n     case CONST_VECTOR:\n       switch (mode)\n \t{\n-\tcase V2HImode:\n+\tcase E_V2HImode:\n \t  return TARGET_PLUS_DMPY;\n-\tcase V2SImode:\n-\tcase V4HImode:\n+\tcase E_V2SImode:\n+\tcase E_V4HImode:\n \t  return TARGET_PLUS_QMACW;\n \tdefault:\n \t  return false;"}, {"sha": "82cd0ad621796b352ebe7aa3d85ca15725056048", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1314,9 +1314,9 @@ do {\t\t\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n   switch (GET_MODE (BODY))\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-    case QImode: fprintf (FILE, \"\\t.byte \"); break;\t\\\n-    case HImode: fprintf (FILE, \"\\t.hword \"); break;\t\\\n-    case SImode: fprintf (FILE, \"\\t.word \"); break;\t\\\n+    case E_QImode: fprintf (FILE, \"\\t.byte \"); break;\t\\\n+    case E_HImode: fprintf (FILE, \"\\t.hword \"); break;\t\\\n+    case E_SImode: fprintf (FILE, \"\\t.word \"); break;\t\\\n     default: gcc_unreachable ();\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   assemble_name (FILE, label);\t\t\t\t\\"}, {"sha": "566c560ef6164f6a9cd42ce2ef13275e8958c989", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -4043,13 +4043,13 @@\n \n   switch (GET_MODE (diff_vec))\n     {\n-    case SImode:\n+    case E_SImode:\n       return \\\"ld.as %0,[%1,%2]%&\\\";\n-    case HImode:\n+    case E_HImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \treturn \\\"ld%_.as %0,[%1,%2]\\\";\n       return \\\"ld%_.x.as %0,[%1,%2]\\\";\n-    case QImode:\n+    case E_QImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \treturn \\\"ldb%? %0,[%1,%2]%&\\\";\n       return \\\"ldb.x %0,[%1,%2]\\\";\n@@ -4112,7 +4112,7 @@\n \n   switch (GET_MODE (diff_vec))\n     {\n-    case SImode:\n+    case E_SImode:\n       /* Max length can be 12 in this case, but this is OK because\n \t 2 of these are for alignment, and are anticipated in the length\n \t of the ADDR_DIFF_VEC.  */\n@@ -4124,7 +4124,7 @@\n \ts = \\\"add %2,%0,2\\n\\tld.as %2,[pcl,%2]\\\";\n       arc_clear_unalign ();\n       break;\n-    case HImode:\n+    case E_HImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \t{\n \t  if (satisfies_constraint_Rcq (xop[0]))\n@@ -4153,7 +4153,7 @@\n \t}\n       arc_toggle_unalign ();\n       break;\n-    case QImode:\n+    case E_QImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \t{\n \t  if ((rtx_equal_p (xop[2], xop[0])"}, {"sha": "3e4ff80d4fcd4ac88a40581428066c22cbbb6edf", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -430,37 +430,37 @@\n      a peephole.  */\n   switch (GET_MODE (XEXP (op, 0)))\n     {\n-    case CC_ZNmode:\n+    case E_CC_ZNmode:\n       return (code == EQ || code == NE || code == GE || code == LT\n \t      || code == GT);\n-    case CC_Zmode:\n+    case E_CC_Zmode:\n       return code == EQ || code == NE;\n-    case CC_Cmode:\n+    case E_CC_Cmode:\n       return code == LTU || code == GEU;\n-    case CC_FP_GTmode:\n+    case E_CC_FP_GTmode:\n       return code == GT || code == UNLE;\n-    case CC_FP_GEmode:\n+    case E_CC_FP_GEmode:\n       return code == GE || code == UNLT;\n-    case CC_FP_ORDmode:\n+    case E_CC_FP_ORDmode:\n       return code == ORDERED || code == UNORDERED;\n-    case CC_FP_UNEQmode:\n+    case E_CC_FP_UNEQmode:\n       return code == UNEQ || code == LTGT;\n-    case CC_FPXmode:\n+    case E_CC_FPXmode:\n       return (code == EQ || code == NE || code == UNEQ || code == LTGT\n \t      || code == ORDERED || code == UNORDERED);\n \n-    case CC_FPUmode:\n+    case E_CC_FPUmode:\n       return 1;\n-    case CC_FPU_UNEQmode:\n+    case E_CC_FPU_UNEQmode:\n       return 1;\n \n-    case CCmode:\n-    case SImode: /* Used for BRcc.  */\n+    case E_CCmode:\n+    case E_SImode: /* Used for BRcc.  */\n       return 1;\n     /* From combiner.  */\n-    case QImode: case HImode: case DImode: case SFmode: case DFmode:\n+    case E_QImode: case E_HImode: case E_DImode: case E_SFmode: case E_DFmode:\n       return 0;\n-    case VOIDmode:\n+    case E_VOIDmode:\n       return 0;\n     default:\n       gcc_unreachable ();\n@@ -537,11 +537,11 @@\n     return 1;\n   switch (mode)\n     {\n-    case CC_Zmode:\n+    case E_CC_Zmode:\n       if (GET_MODE (op) == CC_ZNmode)\n \treturn 1;\n       /* Fall through.  */\n-    case CC_ZNmode: case CC_Cmode:\n+    case E_CC_ZNmode: case E_CC_Cmode:\n       return GET_MODE (op) == CCmode;\n     default:\n       gcc_unreachable ();"}, {"sha": "f23c5707a828d356957a357160968792f49c3388", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -196,15 +196,15 @@\n \t    {\t\t\t\t\t\t\t\t\\\n \t      switch (GET_MODE(body))\t\t\t\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n-\t\tcase QImode:\t\t\t\t\t\t\\\n+\t\tcase E_QImode:\t\t\t\t\t\t\\\n \t\t  asm_fprintf (STREAM, \"\\t.byte\\t(%LL%d-%LL%d)/2\\n\",\t\\\n \t\t\t       VALUE, REL);\t\t\t\t\\\n \t\t  break;\t\t\t\t\t\t\\\n-\t\tcase HImode: /* TBH */\t\t\t\t\t\\\n+\t\tcase E_HImode: /* TBH */\t\t\t\t\t\\\n \t\t  asm_fprintf (STREAM, \"\\t.2byte\\t(%LL%d-%LL%d)/2\\n\",\t\\\n \t\t\t       VALUE, REL);\t\t\t\t\\\n \t\t  break;\t\t\t\t\t\t\\\n-\t\tcase SImode:\t\t\t\t\t\t\\\n+\t\tcase E_SImode:\t\t\t\t\t\t\\\n \t\t  asm_fprintf (STREAM, \"\\t.word\\t%LL%d-%LL%d\\n\",\t\\\n \t\t\t       VALUE, REL);\t\t\t\t\\\n \t\t  break;\t\t\t\t\t\t\\\n@@ -219,15 +219,15 @@\n \t{\t\t\t\t\t\t\t\t\\\n \t  switch (GET_MODE(body))\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t    case QImode: /* TBB */\t\t\t\t\t\\\n+\t    case E_QImode: /* TBB */\t\t\t\t\t\\\n \t      asm_fprintf (STREAM, \"\\t.byte\\t(%LL%d-%LL%d)/2\\n\",\t\\\n \t\t\t   VALUE, REL);\t\t\t\t\t\\\n \t      break;\t\t\t\t\t\t\t\\\n-\t    case HImode: /* TBH */\t\t\t\t\t\\\n+\t    case E_HImode: /* TBH */\t\t\t\t\t\\\n \t      asm_fprintf (STREAM, \"\\t.2byte\\t(%LL%d-%LL%d)/2\\n\",\t\\\n \t\t\t   VALUE, REL);\t\t\t\t\t\\\n \t      break;\t\t\t\t\t\t\t\\\n-\t    case SImode:\t\t\t\t\t\t\\\n+\t    case E_SImode:\t\t\t\t\t\t\\\n \t      if (flag_pic)\t\t\t\t\t\t\\\n \t\tasm_fprintf (STREAM, \"\\t.word\\t%LL%d+1-%LL%d\\n\", VALUE, REL); \\\n \t      else\t\t\t\t\t\t\t\\"}, {"sha": "569f960fd2e534df6e972245b35ae6def5bec033", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -815,29 +815,29 @@ arm_simd_builtin_std_type (machine_mode mode,\n   ((q == qualifier_none) ? int##M##_type_node : unsigned_int##M##_type_node);\n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       return QUAL_TYPE (QI);\n-    case HImode:\n+    case E_HImode:\n       return QUAL_TYPE (HI);\n-    case SImode:\n+    case E_SImode:\n       return QUAL_TYPE (SI);\n-    case DImode:\n+    case E_DImode:\n       return QUAL_TYPE (DI);\n-    case TImode:\n+    case E_TImode:\n       return QUAL_TYPE (TI);\n-    case OImode:\n+    case E_OImode:\n       return arm_simd_intOI_type_node;\n-    case EImode:\n+    case E_EImode:\n       return arm_simd_intEI_type_node;\n-    case CImode:\n+    case E_CImode:\n       return arm_simd_intCI_type_node;\n-    case XImode:\n+    case E_XImode:\n       return arm_simd_intXI_type_node;\n-    case HFmode:\n+    case E_HFmode:\n       return arm_fp16_type_node;\n-    case SFmode:\n+    case E_SFmode:\n       return float_type_node;\n-    case DFmode:\n+    case E_DFmode:\n       return double_type_node;\n     default:\n       gcc_unreachable ();\n@@ -1677,16 +1677,16 @@ arm_init_iwmmxt_builtins (void)\n \n       switch (mode)\n \t{\n-\tcase V8QImode:\n+\tcase E_V8QImode:\n \t  type = v8qi_ftype_v8qi_v8qi;\n \t  break;\n-\tcase V4HImode:\n+\tcase E_V4HImode:\n \t  type = v4hi_ftype_v4hi_v4hi;\n \t  break;\n-\tcase V2SImode:\n+\tcase E_V2SImode:\n \t  type = v2si_ftype_v2si_v2si;\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  type = di_ftype_di_di;\n \t  break;\n "}, {"sha": "b1e9ed259ed986527c8ffec3eac3f3ad45f09856", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -9069,15 +9069,15 @@ thumb1_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n       /* XXX still guessing.  */\n       switch (GET_MODE (XEXP (x, 0)))\n         {\n-          case QImode:\n+          case E_QImode:\n             return (1 + (mode == DImode ? 4 : 0)\n                     + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n \n-          case HImode:\n+          case E_HImode:\n             return (4 + (mode == DImode ? 4 : 0)\n                     + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n \n-          case SImode:\n+          case E_SImode:\n             return (1 + (MEM_P (XEXP (x, 0)) ? 10 : 0));\n \n           default:\n@@ -12243,31 +12243,31 @@ neon_expand_vector_init (rtx target, rtx vals)\n       x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, one_var));\n       switch (mode)\n \t{\n-\tcase V8QImode:\n+\tcase E_V8QImode:\n \t  emit_insn (gen_neon_vset_lanev8qi (target, x, target, index));\n \t  break;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  emit_insn (gen_neon_vset_lanev16qi (target, x, target, index));\n \t  break;\n-\tcase V4HImode:\n+\tcase E_V4HImode:\n \t  emit_insn (gen_neon_vset_lanev4hi (target, x, target, index));\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  emit_insn (gen_neon_vset_lanev8hi (target, x, target, index));\n \t  break;\n-\tcase V2SImode:\n+\tcase E_V2SImode:\n \t  emit_insn (gen_neon_vset_lanev2si (target, x, target, index));\n \t  break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  emit_insn (gen_neon_vset_lanev4si (target, x, target, index));\n \t  break;\n-\tcase V2SFmode:\n+\tcase E_V2SFmode:\n \t  emit_insn (gen_neon_vset_lanev2sf (target, x, target, index));\n \t  break;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  emit_insn (gen_neon_vset_lanev4sf (target, x, target, index));\n \t  break;\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_neon_vset_lanev2di (target, x, target, index));\n \t  break;\n \tdefault:\n@@ -18699,12 +18699,12 @@ arm_attr_length_move_neon (rtx_insn *insn)\n       mode = GET_MODE (recog_data.operand[0]);\n       switch (mode)\n \t{\n-\tcase EImode:\n-\tcase OImode:\n+\tcase E_EImode:\n+\tcase E_OImode:\n \t  return 8;\n-\tcase CImode:\n+\tcase E_CImode:\n \t  return 12;\n-\tcase XImode:\n+\tcase E_XImode:\n \t  return 16;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -22783,16 +22783,16 @@ maybe_get_arm_condition_code (rtx comparison)\n \n   switch (mode)\n     {\n-    case CC_DNEmode: code = ARM_NE; goto dominance;\n-    case CC_DEQmode: code = ARM_EQ; goto dominance;\n-    case CC_DGEmode: code = ARM_GE; goto dominance;\n-    case CC_DGTmode: code = ARM_GT; goto dominance;\n-    case CC_DLEmode: code = ARM_LE; goto dominance;\n-    case CC_DLTmode: code = ARM_LT; goto dominance;\n-    case CC_DGEUmode: code = ARM_CS; goto dominance;\n-    case CC_DGTUmode: code = ARM_HI; goto dominance;\n-    case CC_DLEUmode: code = ARM_LS; goto dominance;\n-    case CC_DLTUmode: code = ARM_CC;\n+    case E_CC_DNEmode: code = ARM_NE; goto dominance;\n+    case E_CC_DEQmode: code = ARM_EQ; goto dominance;\n+    case E_CC_DGEmode: code = ARM_GE; goto dominance;\n+    case E_CC_DGTmode: code = ARM_GT; goto dominance;\n+    case E_CC_DLEmode: code = ARM_LE; goto dominance;\n+    case E_CC_DLTmode: code = ARM_LT; goto dominance;\n+    case E_CC_DGEUmode: code = ARM_CS; goto dominance;\n+    case E_CC_DGTUmode: code = ARM_HI; goto dominance;\n+    case E_CC_DLEUmode: code = ARM_LS; goto dominance;\n+    case E_CC_DLTUmode: code = ARM_CC;\n \n     dominance:\n       if (comp_code == EQ)\n@@ -22801,7 +22801,7 @@ maybe_get_arm_condition_code (rtx comparison)\n \treturn code;\n       return ARM_NV;\n \n-    case CC_NOOVmode:\n+    case E_CC_NOOVmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;\n@@ -22811,24 +22811,24 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case CC_Zmode:\n+    case E_CC_Zmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;\n \tcase EQ: return ARM_EQ;\n \tdefault: return ARM_NV;\n \t}\n \n-    case CC_Nmode:\n+    case E_CC_Nmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_MI;\n \tcase EQ: return ARM_PL;\n \tdefault: return ARM_NV;\n \t}\n \n-    case CCFPEmode:\n-    case CCFPmode:\n+    case E_CCFPEmode:\n+    case E_CCFPmode:\n       /* We can handle all cases except UNEQ and LTGT.  */\n       switch (comp_code)\n \t{\n@@ -22850,7 +22850,7 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case CC_SWPmode:\n+    case E_CC_SWPmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;\n@@ -22866,7 +22866,7 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case CC_Cmode:\n+    case E_CC_Cmode:\n       switch (comp_code)\n \t{\n \tcase LTU: return ARM_CS;\n@@ -22876,7 +22876,7 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case CC_CZmode:\n+    case E_CC_CZmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;\n@@ -22888,7 +22888,7 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case CC_NCVmode:\n+    case E_CC_NCVmode:\n       switch (comp_code)\n \t{\n \tcase GE: return ARM_GE;\n@@ -22898,15 +22898,15 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n-    case CC_Vmode:\n+    case E_CC_Vmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_VS;\n \tcase EQ: return ARM_VC;\n \tdefault: return ARM_NV;\n \t}\n \n-    case CCmode:\n+    case E_CCmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;\n@@ -26565,9 +26565,9 @@ arm_emit_vector_const (FILE *file, rtx x)\n \n   switch (GET_MODE (x))\n     {\n-    case V2SImode: pattern = \"%08x\"; break;\n-    case V4HImode: pattern = \"%04x\"; break;\n-    case V8QImode: pattern = \"%02x\"; break;\n+    case E_V2SImode: pattern = \"%08x\"; break;\n+    case E_V4HImode: pattern = \"%04x\"; break;\n+    case E_V8QImode: pattern = \"%02x\"; break;\n     default:       gcc_unreachable ();\n     }\n \n@@ -26950,15 +26950,15 @@ arm_preferred_simd_mode (machine_mode mode)\n   if (TARGET_NEON)\n     switch (mode)\n       {\n-      case SFmode:\n+      case E_SFmode:\n \treturn TARGET_NEON_VECTORIZE_DOUBLE ? V2SFmode : V4SFmode;\n-      case SImode:\n+      case E_SImode:\n \treturn TARGET_NEON_VECTORIZE_DOUBLE ? V2SImode : V4SImode;\n-      case HImode:\n+      case E_HImode:\n \treturn TARGET_NEON_VECTORIZE_DOUBLE ? V4HImode : V8HImode;\n-      case QImode:\n+      case E_QImode:\n \treturn TARGET_NEON_VECTORIZE_DOUBLE ? V8QImode : V16QImode;\n-      case DImode:\n+      case E_DImode:\n \tif (!TARGET_NEON_VECTORIZE_DOUBLE)\n \t  return V2DImode;\n \tbreak;\n@@ -26969,11 +26969,11 @@ arm_preferred_simd_mode (machine_mode mode)\n   if (TARGET_REALLY_IWMMXT)\n     switch (mode)\n       {\n-      case SImode:\n+      case E_SImode:\n \treturn V2SImode;\n-      case HImode:\n+      case E_HImode:\n \treturn V4HImode;\n-      case QImode:\n+      case E_QImode:\n \treturn V8QImode;\n \n       default:;\n@@ -27675,13 +27675,13 @@ arm_output_iwmmxt_tinsr (rtx *operands)\n   {\n     switch (GET_MODE (operands[0]))\n       {\n-      case V8QImode:\n+      case E_V8QImode:\n \tsprintf (templ, \"tinsrb%%?\\t%%0, %%2, #%d\", i);\n \tbreak;\n-      case V4HImode:\n+      case E_V4HImode:\n \tsprintf (templ, \"tinsrh%%?\\t%%0, %%2, #%d\", i);\n \tbreak;\n-      case V2SImode:\n+      case E_V2SImode:\n \tsprintf (templ, \"tinsrw%%?\\t%%0, %%2, #%d\", i);\n \tbreak;\n       default:\n@@ -27703,13 +27703,13 @@ thumb1_output_casesi (rtx *operands)\n \n   switch (GET_MODE(diff_vec))\n     {\n-    case QImode:\n+    case E_QImode:\n       return (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned ?\n \t      \"bl\\t%___gnu_thumb1_case_uqi\" : \"bl\\t%___gnu_thumb1_case_sqi\");\n-    case HImode:\n+    case E_HImode:\n       return (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned ?\n \t      \"bl\\t%___gnu_thumb1_case_uhi\" : \"bl\\t%___gnu_thumb1_case_shi\");\n-    case SImode:\n+    case E_SImode:\n       return \"bl\\t%___gnu_thumb1_case_si\";\n     default:\n       gcc_unreachable ();\n@@ -27728,11 +27728,11 @@ thumb2_output_casesi (rtx *operands)\n   output_asm_insn (\"bhi\\t%l3\", operands);\n   switch (GET_MODE(diff_vec))\n     {\n-    case QImode:\n+    case E_QImode:\n       return \"tbb\\t[%|pc, %0]\";\n-    case HImode:\n+    case E_HImode:\n       return \"tbh\\t[%|pc, %0, lsl #1]\";\n-    case SImode:\n+    case E_SImode:\n       if (flag_pic)\n \t{\n \t  output_asm_insn (\"adr\\t%4, %l2\", operands);\n@@ -28208,10 +28208,10 @@ arm_emit_load_exclusive (machine_mode mode, rtx rval, rtx mem, bool acq)\n     {\n       switch (mode)\n         {\n-        case QImode: gen = gen_arm_load_acquire_exclusiveqi; break;\n-        case HImode: gen = gen_arm_load_acquire_exclusivehi; break;\n-        case SImode: gen = gen_arm_load_acquire_exclusivesi; break;\n-        case DImode: gen = gen_arm_load_acquire_exclusivedi; break;\n+        case E_QImode: gen = gen_arm_load_acquire_exclusiveqi; break;\n+        case E_HImode: gen = gen_arm_load_acquire_exclusivehi; break;\n+        case E_SImode: gen = gen_arm_load_acquire_exclusivesi; break;\n+        case E_DImode: gen = gen_arm_load_acquire_exclusivedi; break;\n         default:\n           gcc_unreachable ();\n         }\n@@ -28220,10 +28220,10 @@ arm_emit_load_exclusive (machine_mode mode, rtx rval, rtx mem, bool acq)\n     {\n       switch (mode)\n         {\n-        case QImode: gen = gen_arm_load_exclusiveqi; break;\n-        case HImode: gen = gen_arm_load_exclusivehi; break;\n-        case SImode: gen = gen_arm_load_exclusivesi; break;\n-        case DImode: gen = gen_arm_load_exclusivedi; break;\n+        case E_QImode: gen = gen_arm_load_exclusiveqi; break;\n+        case E_HImode: gen = gen_arm_load_exclusivehi; break;\n+        case E_SImode: gen = gen_arm_load_exclusivesi; break;\n+        case E_DImode: gen = gen_arm_load_exclusivedi; break;\n         default:\n           gcc_unreachable ();\n         }\n@@ -28242,10 +28242,10 @@ arm_emit_store_exclusive (machine_mode mode, rtx bval, rtx rval,\n     {\n       switch (mode)\n         {\n-        case QImode: gen = gen_arm_store_release_exclusiveqi; break;\n-        case HImode: gen = gen_arm_store_release_exclusivehi; break;\n-        case SImode: gen = gen_arm_store_release_exclusivesi; break;\n-        case DImode: gen = gen_arm_store_release_exclusivedi; break;\n+        case E_QImode: gen = gen_arm_store_release_exclusiveqi; break;\n+        case E_HImode: gen = gen_arm_store_release_exclusivehi; break;\n+        case E_SImode: gen = gen_arm_store_release_exclusivesi; break;\n+        case E_DImode: gen = gen_arm_store_release_exclusivedi; break;\n         default:\n           gcc_unreachable ();\n         }\n@@ -28254,10 +28254,10 @@ arm_emit_store_exclusive (machine_mode mode, rtx bval, rtx rval,\n     {\n       switch (mode)\n         {\n-        case QImode: gen = gen_arm_store_exclusiveqi; break;\n-        case HImode: gen = gen_arm_store_exclusivehi; break;\n-        case SImode: gen = gen_arm_store_exclusivesi; break;\n-        case DImode: gen = gen_arm_store_exclusivedi; break;\n+        case E_QImode: gen = gen_arm_store_exclusiveqi; break;\n+        case E_HImode: gen = gen_arm_store_exclusivehi; break;\n+        case E_SImode: gen = gen_arm_store_exclusivesi; break;\n+        case E_DImode: gen = gen_arm_store_exclusivedi; break;\n         default:\n           gcc_unreachable ();\n         }\n@@ -28305,22 +28305,22 @@ arm_expand_compare_and_swap (rtx operands[])\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n+    case E_QImode:\n+    case E_HImode:\n       /* For narrow modes, we're going to perform the comparison in SImode,\n \t so do the zero-extension now.  */\n       rval = gen_reg_rtx (SImode);\n       oldval = convert_modes (SImode, mode, oldval, true);\n       /* FALLTHRU */\n \n-    case SImode:\n+    case E_SImode:\n       /* Force the value into a register if needed.  We waited until after\n \t the zero-extension above to do this properly.  */\n       if (!arm_add_operand (oldval, SImode))\n \toldval = force_reg (SImode, oldval);\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       if (!cmpdi_operand (oldval, mode))\n \toldval = force_reg (mode, oldval);\n       break;\n@@ -28333,10 +28333,10 @@ arm_expand_compare_and_swap (rtx operands[])\n     {\n       switch (mode)\n \t{\n-\tcase QImode: gen = gen_atomic_compare_and_swapt1qi_1; break;\n-\tcase HImode: gen = gen_atomic_compare_and_swapt1hi_1; break;\n-\tcase SImode: gen = gen_atomic_compare_and_swapt1si_1; break;\n-\tcase DImode: gen = gen_atomic_compare_and_swapt1di_1; break;\n+\tcase E_QImode: gen = gen_atomic_compare_and_swapt1qi_1; break;\n+\tcase E_HImode: gen = gen_atomic_compare_and_swapt1hi_1; break;\n+\tcase E_SImode: gen = gen_atomic_compare_and_swapt1si_1; break;\n+\tcase E_DImode: gen = gen_atomic_compare_and_swapt1di_1; break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -28345,10 +28345,10 @@ arm_expand_compare_and_swap (rtx operands[])\n     {\n       switch (mode)\n \t{\n-\tcase QImode: gen = gen_atomic_compare_and_swap32qi_1; break;\n-\tcase HImode: gen = gen_atomic_compare_and_swap32hi_1; break;\n-\tcase SImode: gen = gen_atomic_compare_and_swap32si_1; break;\n-\tcase DImode: gen = gen_atomic_compare_and_swap32di_1; break;\n+\tcase E_QImode: gen = gen_atomic_compare_and_swap32qi_1; break;\n+\tcase E_HImode: gen = gen_atomic_compare_and_swap32hi_1; break;\n+\tcase E_SImode: gen = gen_atomic_compare_and_swap32si_1; break;\n+\tcase E_DImode: gen = gen_atomic_compare_and_swap32di_1; break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -28769,16 +28769,16 @@ arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n \n   switch (d->vmode)\n     {\n-    case V16QImode: gen = gen_neon_vuzpv16qi_internal; break;\n-    case V8QImode:  gen = gen_neon_vuzpv8qi_internal;  break;\n-    case V8HImode:  gen = gen_neon_vuzpv8hi_internal;  break;\n-    case V4HImode:  gen = gen_neon_vuzpv4hi_internal;  break;\n-    case V8HFmode:  gen = gen_neon_vuzpv8hf_internal;  break;\n-    case V4HFmode:  gen = gen_neon_vuzpv4hf_internal;  break;\n-    case V4SImode:  gen = gen_neon_vuzpv4si_internal;  break;\n-    case V2SImode:  gen = gen_neon_vuzpv2si_internal;  break;\n-    case V2SFmode:  gen = gen_neon_vuzpv2sf_internal;  break;\n-    case V4SFmode:  gen = gen_neon_vuzpv4sf_internal;  break;\n+    case E_V16QImode: gen = gen_neon_vuzpv16qi_internal; break;\n+    case E_V8QImode:  gen = gen_neon_vuzpv8qi_internal;  break;\n+    case E_V8HImode:  gen = gen_neon_vuzpv8hi_internal;  break;\n+    case E_V4HImode:  gen = gen_neon_vuzpv4hi_internal;  break;\n+    case E_V8HFmode:  gen = gen_neon_vuzpv8hf_internal;  break;\n+    case E_V4HFmode:  gen = gen_neon_vuzpv4hf_internal;  break;\n+    case E_V4SImode:  gen = gen_neon_vuzpv4si_internal;  break;\n+    case E_V2SImode:  gen = gen_neon_vuzpv2si_internal;  break;\n+    case E_V2SFmode:  gen = gen_neon_vuzpv2sf_internal;  break;\n+    case E_V4SFmode:  gen = gen_neon_vuzpv4sf_internal;  break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -28844,16 +28844,16 @@ arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n \n   switch (d->vmode)\n     {\n-    case V16QImode: gen = gen_neon_vzipv16qi_internal; break;\n-    case V8QImode:  gen = gen_neon_vzipv8qi_internal;  break;\n-    case V8HImode:  gen = gen_neon_vzipv8hi_internal;  break;\n-    case V4HImode:  gen = gen_neon_vzipv4hi_internal;  break;\n-    case V8HFmode:  gen = gen_neon_vzipv8hf_internal;  break;\n-    case V4HFmode:  gen = gen_neon_vzipv4hf_internal;  break;\n-    case V4SImode:  gen = gen_neon_vzipv4si_internal;  break;\n-    case V2SImode:  gen = gen_neon_vzipv2si_internal;  break;\n-    case V2SFmode:  gen = gen_neon_vzipv2sf_internal;  break;\n-    case V4SFmode:  gen = gen_neon_vzipv4sf_internal;  break;\n+    case E_V16QImode: gen = gen_neon_vzipv16qi_internal; break;\n+    case E_V8QImode:  gen = gen_neon_vzipv8qi_internal;  break;\n+    case E_V8HImode:  gen = gen_neon_vzipv8hi_internal;  break;\n+    case E_V4HImode:  gen = gen_neon_vzipv4hi_internal;  break;\n+    case E_V8HFmode:  gen = gen_neon_vzipv8hf_internal;  break;\n+    case E_V4HFmode:  gen = gen_neon_vzipv4hf_internal;  break;\n+    case E_V4SImode:  gen = gen_neon_vzipv4si_internal;  break;\n+    case E_V2SImode:  gen = gen_neon_vzipv2si_internal;  break;\n+    case E_V2SFmode:  gen = gen_neon_vzipv2sf_internal;  break;\n+    case E_V4SFmode:  gen = gen_neon_vzipv4sf_internal;  break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -28889,36 +28889,36 @@ arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n     case 7:\n       switch (d->vmode)\n \t{\n-\tcase V16QImode: gen = gen_neon_vrev64v16qi; break;\n-\tcase V8QImode:  gen = gen_neon_vrev64v8qi;  break;\n+\tcase E_V16QImode: gen = gen_neon_vrev64v16qi; break;\n+\tcase E_V8QImode:  gen = gen_neon_vrev64v8qi;  break;\n \tdefault:\n \t  return false;\n \t}\n       break;\n     case 3:\n       switch (d->vmode)\n \t{\n-\tcase V16QImode: gen = gen_neon_vrev32v16qi; break;\n-\tcase V8QImode:  gen = gen_neon_vrev32v8qi;  break;\n-\tcase V8HImode:  gen = gen_neon_vrev64v8hi;  break;\n-\tcase V4HImode:  gen = gen_neon_vrev64v4hi;  break;\n-\tcase V8HFmode:  gen = gen_neon_vrev64v8hf;  break;\n-\tcase V4HFmode:  gen = gen_neon_vrev64v4hf;  break;\n+\tcase E_V16QImode: gen = gen_neon_vrev32v16qi; break;\n+\tcase E_V8QImode:  gen = gen_neon_vrev32v8qi;  break;\n+\tcase E_V8HImode:  gen = gen_neon_vrev64v8hi;  break;\n+\tcase E_V4HImode:  gen = gen_neon_vrev64v4hi;  break;\n+\tcase E_V8HFmode:  gen = gen_neon_vrev64v8hf;  break;\n+\tcase E_V4HFmode:  gen = gen_neon_vrev64v4hf;  break;\n \tdefault:\n \t  return false;\n \t}\n       break;\n     case 1:\n       switch (d->vmode)\n \t{\n-\tcase V16QImode: gen = gen_neon_vrev16v16qi; break;\n-\tcase V8QImode:  gen = gen_neon_vrev16v8qi;  break;\n-\tcase V8HImode:  gen = gen_neon_vrev32v8hi;  break;\n-\tcase V4HImode:  gen = gen_neon_vrev32v4hi;  break;\n-\tcase V4SImode:  gen = gen_neon_vrev64v4si;  break;\n-\tcase V2SImode:  gen = gen_neon_vrev64v2si;  break;\n-\tcase V4SFmode:  gen = gen_neon_vrev64v4sf;  break;\n-\tcase V2SFmode:  gen = gen_neon_vrev64v2sf;  break;\n+\tcase E_V16QImode: gen = gen_neon_vrev16v16qi; break;\n+\tcase E_V8QImode:  gen = gen_neon_vrev16v8qi;  break;\n+\tcase E_V8HImode:  gen = gen_neon_vrev32v8hi;  break;\n+\tcase E_V4HImode:  gen = gen_neon_vrev32v4hi;  break;\n+\tcase E_V4SImode:  gen = gen_neon_vrev64v4si;  break;\n+\tcase E_V2SImode:  gen = gen_neon_vrev64v2si;  break;\n+\tcase E_V4SFmode:  gen = gen_neon_vrev64v4sf;  break;\n+\tcase E_V2SFmode:  gen = gen_neon_vrev64v2sf;  break;\n \tdefault:\n \t  return false;\n \t}\n@@ -28983,16 +28983,16 @@ arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n \n   switch (d->vmode)\n     {\n-    case V16QImode: gen = gen_neon_vtrnv16qi_internal; break;\n-    case V8QImode:  gen = gen_neon_vtrnv8qi_internal;  break;\n-    case V8HImode:  gen = gen_neon_vtrnv8hi_internal;  break;\n-    case V4HImode:  gen = gen_neon_vtrnv4hi_internal;  break;\n-    case V8HFmode:  gen = gen_neon_vtrnv8hf_internal;  break;\n-    case V4HFmode:  gen = gen_neon_vtrnv4hf_internal;  break;\n-    case V4SImode:  gen = gen_neon_vtrnv4si_internal;  break;\n-    case V2SImode:  gen = gen_neon_vtrnv2si_internal;  break;\n-    case V2SFmode:  gen = gen_neon_vtrnv2sf_internal;  break;\n-    case V4SFmode:  gen = gen_neon_vtrnv4sf_internal;  break;\n+    case E_V16QImode: gen = gen_neon_vtrnv16qi_internal; break;\n+    case E_V8QImode:  gen = gen_neon_vtrnv8qi_internal;  break;\n+    case E_V8HImode:  gen = gen_neon_vtrnv8hi_internal;  break;\n+    case E_V4HImode:  gen = gen_neon_vtrnv4hi_internal;  break;\n+    case E_V8HFmode:  gen = gen_neon_vtrnv8hf_internal;  break;\n+    case E_V4HFmode:  gen = gen_neon_vtrnv4hf_internal;  break;\n+    case E_V4SImode:  gen = gen_neon_vtrnv4si_internal;  break;\n+    case E_V2SImode:  gen = gen_neon_vtrnv2si_internal;  break;\n+    case E_V2SFmode:  gen = gen_neon_vtrnv2sf_internal;  break;\n+    case E_V4SFmode:  gen = gen_neon_vtrnv4sf_internal;  break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -29058,17 +29058,17 @@ arm_evpc_neon_vext (struct expand_vec_perm_d *d)\n \n   switch (d->vmode)\n     {\n-    case V16QImode: gen = gen_neon_vextv16qi; break;\n-    case V8QImode: gen = gen_neon_vextv8qi; break;\n-    case V4HImode: gen = gen_neon_vextv4hi; break;\n-    case V8HImode: gen = gen_neon_vextv8hi; break;\n-    case V2SImode: gen = gen_neon_vextv2si; break;\n-    case V4SImode: gen = gen_neon_vextv4si; break;\n-    case V4HFmode: gen = gen_neon_vextv4hf; break;\n-    case V8HFmode: gen = gen_neon_vextv8hf; break;\n-    case V2SFmode: gen = gen_neon_vextv2sf; break;\n-    case V4SFmode: gen = gen_neon_vextv4sf; break;\n-    case V2DImode: gen = gen_neon_vextv2di; break;\n+    case E_V16QImode: gen = gen_neon_vextv16qi; break;\n+    case E_V8QImode: gen = gen_neon_vextv8qi; break;\n+    case E_V4HImode: gen = gen_neon_vextv4hi; break;\n+    case E_V8HImode: gen = gen_neon_vextv8hi; break;\n+    case E_V2SImode: gen = gen_neon_vextv2si; break;\n+    case E_V4SImode: gen = gen_neon_vextv4si; break;\n+    case E_V4HFmode: gen = gen_neon_vextv4hf; break;\n+    case E_V8HFmode: gen = gen_neon_vextv8hf; break;\n+    case E_V2SFmode: gen = gen_neon_vextv2sf; break;\n+    case E_V4SFmode: gen = gen_neon_vextv4sf; break;\n+    case E_V2DImode: gen = gen_neon_vextv2di; break;\n     default:\n       return false;\n     }\n@@ -29613,30 +29613,30 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n \n   switch (mode)\n     {\n-    case SImode:\n+    case E_SImode:\n       if (!arm_add_operand (*op1, mode))\n \t*op1 = force_reg (mode, *op1);\n       if (!arm_add_operand (*op2, mode))\n \t*op2 = force_reg (mode, *op2);\n       return true;\n \n-    case DImode:\n+    case E_DImode:\n       if (!cmpdi_operand (*op1, mode))\n \t*op1 = force_reg (mode, *op1);\n       if (!cmpdi_operand (*op2, mode))\n \t*op2 = force_reg (mode, *op2);\n       return true;\n \n-    case HFmode:\n+    case E_HFmode:\n       if (!TARGET_VFP_FP16INST)\n \tbreak;\n       /* FP16 comparisons are done in SF mode.  */\n       mode = SFmode;\n       *op1 = convert_to_mode (mode, *op1, 1);\n       *op2 = convert_to_mode (mode, *op2, 1);\n       /* Fall through.  */\n-    case SFmode:\n-    case DFmode:\n+    case E_SFmode:\n+    case E_DFmode:\n       if (!vfp_compare_operand (*op1, mode))\n \t*op1 = force_reg (mode, *op1);\n       if (!vfp_compare_operand (*op2, mode))"}, {"sha": "9213c1ef788ffd8ff7d09238d5cee4ec36600c0f", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -2532,12 +2532,12 @@\n            but we will never expand to UNSPECs for the integer comparisons.  */\n         switch (<MODE>mode)\n           {\n-            case V2SFmode:\n+            case E_V2SFmode:\n               emit_insn (gen_neon_vc<cmp_op>v2sf_insn_unspec (operands[0],\n                                                               operands[1],\n                                                               operands[2]));\n               break;\n-            case V4SFmode:\n+            case E_V4SFmode:\n               emit_insn (gen_neon_vc<cmp_op>v4sf_insn_unspec (operands[0],\n                                                               operands[1],\n                                                               operands[2]));"}, {"sha": "e47cefaae2e246fe4f800b830d81f38b2b8f3a17", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -79,24 +79,24 @@ avr_resolve_overloaded_builtin (unsigned int iloc, tree fndecl, void *vargs)\n \n       switch (TYPE_MODE (type0))\n         {\n-        case QQmode: id = AVR_BUILTIN_ABSHR; break;\n-        case HQmode: id = AVR_BUILTIN_ABSR; break;\n-        case SQmode: id = AVR_BUILTIN_ABSLR; break;\n-        case DQmode: id = AVR_BUILTIN_ABSLLR; break;\n-\n-        case HAmode: id = AVR_BUILTIN_ABSHK; break;\n-        case SAmode: id = AVR_BUILTIN_ABSK; break;\n-        case DAmode: id = AVR_BUILTIN_ABSLK; break;\n-        case TAmode: id = AVR_BUILTIN_ABSLLK; break;\n-\n-        case UQQmode:\n-        case UHQmode:\n-        case USQmode:\n-        case UDQmode:\n-        case UHAmode:\n-        case USAmode:\n-        case UDAmode:\n-        case UTAmode:\n+        case E_QQmode: id = AVR_BUILTIN_ABSHR; break;\n+        case E_HQmode: id = AVR_BUILTIN_ABSR; break;\n+        case E_SQmode: id = AVR_BUILTIN_ABSLR; break;\n+        case E_DQmode: id = AVR_BUILTIN_ABSLLR; break;\n+\n+        case E_HAmode: id = AVR_BUILTIN_ABSHK; break;\n+        case E_SAmode: id = AVR_BUILTIN_ABSK; break;\n+        case E_DAmode: id = AVR_BUILTIN_ABSLK; break;\n+        case E_TAmode: id = AVR_BUILTIN_ABSLLK; break;\n+\n+        case E_UQQmode:\n+        case E_UHQmode:\n+        case E_USQmode:\n+        case E_UDQmode:\n+        case E_UHAmode:\n+        case E_USAmode:\n+        case E_UDAmode:\n+        case E_UTAmode:\n           warning_at (loc, 0, \"using %qs with unsigned type has no effect\",\n                       \"absfx\");\n           return args[0];\n@@ -147,25 +147,25 @@ avr_resolve_overloaded_builtin (unsigned int iloc, tree fndecl, void *vargs)\n \n       switch (TYPE_MODE (type0))\n         {\n-        case QQmode: id = AVR_BUILTIN_ROUNDHR; break;\n-        case HQmode: id = AVR_BUILTIN_ROUNDR; break;\n-        case SQmode: id = AVR_BUILTIN_ROUNDLR; break;\n-        case DQmode: id = AVR_BUILTIN_ROUNDLLR; break;\n-\n-        case UQQmode: id = AVR_BUILTIN_ROUNDUHR; break;\n-        case UHQmode: id = AVR_BUILTIN_ROUNDUR; break;\n-        case USQmode: id = AVR_BUILTIN_ROUNDULR; break;\n-        case UDQmode: id = AVR_BUILTIN_ROUNDULLR; break;\n-\n-        case HAmode: id = AVR_BUILTIN_ROUNDHK; break;\n-        case SAmode: id = AVR_BUILTIN_ROUNDK; break;\n-        case DAmode: id = AVR_BUILTIN_ROUNDLK; break;\n-        case TAmode: id = AVR_BUILTIN_ROUNDLLK; break;\n-\n-        case UHAmode: id = AVR_BUILTIN_ROUNDUHK; break;\n-        case USAmode: id = AVR_BUILTIN_ROUNDUK; break;\n-        case UDAmode: id = AVR_BUILTIN_ROUNDULK; break;\n-        case UTAmode: id = AVR_BUILTIN_ROUNDULLK; break;\n+        case E_QQmode: id = AVR_BUILTIN_ROUNDHR; break;\n+        case E_HQmode: id = AVR_BUILTIN_ROUNDR; break;\n+        case E_SQmode: id = AVR_BUILTIN_ROUNDLR; break;\n+        case E_DQmode: id = AVR_BUILTIN_ROUNDLLR; break;\n+\n+        case E_UQQmode: id = AVR_BUILTIN_ROUNDUHR; break;\n+        case E_UHQmode: id = AVR_BUILTIN_ROUNDUR; break;\n+        case E_USQmode: id = AVR_BUILTIN_ROUNDULR; break;\n+        case E_UDQmode: id = AVR_BUILTIN_ROUNDULLR; break;\n+\n+        case E_HAmode: id = AVR_BUILTIN_ROUNDHK; break;\n+        case E_SAmode: id = AVR_BUILTIN_ROUNDK; break;\n+        case E_DAmode: id = AVR_BUILTIN_ROUNDLK; break;\n+        case E_TAmode: id = AVR_BUILTIN_ROUNDLLK; break;\n+\n+        case E_UHAmode: id = AVR_BUILTIN_ROUNDUHK; break;\n+        case E_USAmode: id = AVR_BUILTIN_ROUNDUK; break;\n+        case E_UDAmode: id = AVR_BUILTIN_ROUNDULK; break;\n+        case E_UTAmode: id = AVR_BUILTIN_ROUNDULLK; break;\n \n         default:\n           error_at (loc, \"no matching fixed-point overload found for %qs\",\n@@ -204,25 +204,25 @@ avr_resolve_overloaded_builtin (unsigned int iloc, tree fndecl, void *vargs)\n \n       switch (TYPE_MODE (type0))\n         {\n-        case QQmode: id = AVR_BUILTIN_COUNTLSHR; break;\n-        case HQmode: id = AVR_BUILTIN_COUNTLSR; break;\n-        case SQmode: id = AVR_BUILTIN_COUNTLSLR; break;\n-        case DQmode: id = AVR_BUILTIN_COUNTLSLLR; break;\n-\n-        case UQQmode: id = AVR_BUILTIN_COUNTLSUHR; break;\n-        case UHQmode: id = AVR_BUILTIN_COUNTLSUR; break;\n-        case USQmode: id = AVR_BUILTIN_COUNTLSULR; break;\n-        case UDQmode: id = AVR_BUILTIN_COUNTLSULLR; break;\n-\n-        case HAmode: id = AVR_BUILTIN_COUNTLSHK; break;\n-        case SAmode: id = AVR_BUILTIN_COUNTLSK; break;\n-        case DAmode: id = AVR_BUILTIN_COUNTLSLK; break;\n-        case TAmode: id = AVR_BUILTIN_COUNTLSLLK; break;\n-\n-        case UHAmode: id = AVR_BUILTIN_COUNTLSUHK; break;\n-        case USAmode: id = AVR_BUILTIN_COUNTLSUK; break;\n-        case UDAmode: id = AVR_BUILTIN_COUNTLSULK; break;\n-        case UTAmode: id = AVR_BUILTIN_COUNTLSULLK; break;\n+        case E_QQmode: id = AVR_BUILTIN_COUNTLSHR; break;\n+        case E_HQmode: id = AVR_BUILTIN_COUNTLSR; break;\n+        case E_SQmode: id = AVR_BUILTIN_COUNTLSLR; break;\n+        case E_DQmode: id = AVR_BUILTIN_COUNTLSLLR; break;\n+\n+        case E_UQQmode: id = AVR_BUILTIN_COUNTLSUHR; break;\n+        case E_UHQmode: id = AVR_BUILTIN_COUNTLSUR; break;\n+        case E_USQmode: id = AVR_BUILTIN_COUNTLSULR; break;\n+        case E_UDQmode: id = AVR_BUILTIN_COUNTLSULLR; break;\n+\n+        case E_HAmode: id = AVR_BUILTIN_COUNTLSHK; break;\n+        case E_SAmode: id = AVR_BUILTIN_COUNTLSK; break;\n+        case E_DAmode: id = AVR_BUILTIN_COUNTLSLK; break;\n+        case E_TAmode: id = AVR_BUILTIN_COUNTLSLLK; break;\n+\n+        case E_UHAmode: id = AVR_BUILTIN_COUNTLSUHK; break;\n+        case E_USAmode: id = AVR_BUILTIN_COUNTLSUK; break;\n+        case E_UDAmode: id = AVR_BUILTIN_COUNTLSULK; break;\n+        case E_UTAmode: id = AVR_BUILTIN_COUNTLSULLK; break;\n \n         default:\n           error_at (loc, \"no matching fixed-point overload found for %qs\","}, {"sha": "0f91e794689335f4580509e18b0011d8b523007d", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -10806,14 +10806,14 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case NEG:\n       switch (mode)\n \t{\n-\tcase QImode:\n-\tcase SFmode:\n+\tcase E_QImode:\n+\tcase E_SFmode:\n \t  *total = COSTS_N_INSNS (1);\n \t  break;\n \n-        case HImode:\n-        case PSImode:\n-        case SImode:\n+        case E_HImode:\n+        case E_PSImode:\n+        case E_SImode:\n           *total = COSTS_N_INSNS (2 * GET_MODE_SIZE (mode) - 1);\n           break;\n \n@@ -10826,8 +10826,8 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case ABS:\n       switch (mode)\n \t{\n-\tcase QImode:\n-\tcase SFmode:\n+\tcase E_QImode:\n+\tcase E_SFmode:\n \t  *total = COSTS_N_INSNS (1);\n \t  break;\n \n@@ -10859,7 +10859,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case PLUS:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n           if (AVR_HAVE_MUL\n               && MULT == GET_CODE (XEXP (x, 0))\n               && register_operand (XEXP (x, 1), QImode))\n@@ -10876,7 +10876,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1, speed);\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n           if (AVR_HAVE_MUL\n               && (MULT == GET_CODE (XEXP (x, 0))\n                   || ASHIFT == GET_CODE (XEXP (x, 0)))\n@@ -10903,7 +10903,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    *total = COSTS_N_INSNS (2);\n \t  break;\n \n-        case PSImode:\n+        case E_PSImode:\n           if (!CONST_INT_P (XEXP (x, 1)))\n             {\n               *total = COSTS_N_INSNS (3);\n@@ -10916,7 +10916,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n             *total = COSTS_N_INSNS (3);\n           break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (4);\n@@ -10994,7 +10994,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case MULT:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  if (AVR_HAVE_MUL)\n \t    *total = COSTS_N_INSNS (!speed ? 3 : 4);\n \t  else if (!speed)\n@@ -11003,7 +11003,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    return false;\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  if (AVR_HAVE_MUL)\n             {\n               rtx op0 = XEXP (x, 0);\n@@ -11047,15 +11047,15 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    return false;\n \t  break;\n \n-        case PSImode:\n+        case E_PSImode:\n           if (!speed)\n             *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);\n           else\n             *total = 10;\n           break;\n \n-\tcase SImode:\n-\tcase DImode:\n+\tcase E_SImode:\n+\tcase E_DImode:\n \t  if (AVR_HAVE_MUL)\n             {\n               if (!speed)\n@@ -11113,19 +11113,19 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case ROTATE:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  if (CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) == 4)\n \t    *total = COSTS_N_INSNS (1);\n \n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  if (CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) == 8)\n \t    *total = COSTS_N_INSNS (3);\n \n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (CONST_INT_P (XEXP (x, 1)))\n \t    switch (INTVAL (XEXP (x, 1)))\n \t      {\n@@ -11148,7 +11148,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case ASHIFT:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 4 : 17);\n@@ -11167,7 +11167,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    }\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n           if (AVR_HAVE_MUL)\n             {\n               if (const_2_to_7_operand (XEXP (x, 1), HImode)\n@@ -11232,7 +11232,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t      }\n \t  break;\n \n-        case PSImode:\n+        case E_PSImode:\n           if (!CONST_INT_P (XEXP (x, 1)))\n             {\n               *total = COSTS_N_INSNS (!speed ? 6 : 73);\n@@ -11257,7 +11257,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n               }\n           break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 7 : 113);\n@@ -11300,7 +11300,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case ASHIFTRT:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 4 : 17);\n@@ -11321,7 +11321,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    }\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 5 : 41);\n@@ -11367,7 +11367,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t      }\n \t  break;\n \n-        case PSImode:\n+        case E_PSImode:\n           if (!CONST_INT_P (XEXP (x, 1)))\n             {\n               *total = COSTS_N_INSNS (!speed ? 6 : 73);\n@@ -11394,7 +11394,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n               }\n           break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 7 : 113);\n@@ -11443,7 +11443,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 4 : 17);\n@@ -11462,7 +11462,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    }\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 5 : 41);\n@@ -11511,7 +11511,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t      }\n \t  break;\n \n-        case PSImode:\n+        case E_PSImode:\n           if (!CONST_INT_P (XEXP (x, 1)))\n             {\n               *total = COSTS_N_INSNS (!speed ? 6 : 73);\n@@ -11536,7 +11536,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n               }\n           break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    {\n \t      *total = COSTS_N_INSNS (!speed ? 7 : 113);\n@@ -11579,14 +11579,14 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n     case COMPARE:\n       switch (GET_MODE (XEXP (x, 0)))\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  *total = COSTS_N_INSNS (1);\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n \t    *total += avr_operand_rtx_cost (XEXP (x, 1), QImode, code,\n \t\t\t\t\t    1, speed);\n \t  break;\n \n-        case HImode:\n+        case E_HImode:\n \t  *total = COSTS_N_INSNS (2);\n \t  if (!CONST_INT_P (XEXP (x, 1)))\n             *total += avr_operand_rtx_cost (XEXP (x, 1), HImode, code,\n@@ -11595,13 +11595,13 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,\n \t    *total += COSTS_N_INSNS (1);\n           break;\n \n-        case PSImode:\n+        case E_PSImode:\n           *total = COSTS_N_INSNS (3);\n           if (CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) != 0)\n             *total += COSTS_N_INSNS (2);\n           break;\n \n-        case SImode:\n+        case E_SImode:\n           *total = COSTS_N_INSNS (4);\n           if (!CONST_INT_P (XEXP (x, 1)))\n             *total += avr_operand_rtx_cost (XEXP (x, 1), SImode, code,"}, {"sha": "4f64df262ca035299dd8c4eb8cdf79e9c678eb9d", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -6226,11 +6226,11 @@ c6x_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V2HImode:\n-    case V4QImode:\n-    case V2SImode:\n-    case V4HImode:\n-    case V8QImode:\n+    case E_V2HImode:\n+    case E_V4QImode:\n+    case E_V2SImode:\n+    case E_V4HImode:\n+    case E_V8QImode:\n       return true;\n     default:\n       return false;\n@@ -6243,9 +6243,9 @@ c6x_preferred_simd_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case HImode:\n+    case E_HImode:\n       return V2HImode;\n-    case QImode:\n+    case E_QImode:\n       return V4QImode;\n \n     default:"}, {"sha": "a35c00173961c85463bfd66e135f27b495c36075", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -270,7 +270,7 @@ get_epiphany_condition_code (rtx comparison)\n {\n   switch (GET_MODE (XEXP (comparison, 0)))\n     {\n-    case CCmode:\n+    case E_CCmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ  : return 0;\n@@ -286,28 +286,28 @@ get_epiphany_condition_code (rtx comparison)\n \n \tdefault : gcc_unreachable ();\n \t}\n-    case CC_N_NEmode:\n+    case E_CC_N_NEmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ: return 6;\n \tcase NE: return 7;\n \tdefault: gcc_unreachable ();\n \t}\n-    case CC_C_LTUmode:\n+    case E_CC_C_LTUmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase GEU: return 2;\n \tcase LTU: return 3;\n \tdefault: gcc_unreachable ();\n \t}\n-    case CC_C_GTUmode:\n+    case E_CC_C_GTUmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase LEU: return 3;\n \tcase GTU: return 2;\n \tdefault: gcc_unreachable ();\n \t}\n-    case CC_FPmode:\n+    case E_CC_FPmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ: return 10;\n@@ -316,14 +316,14 @@ get_epiphany_condition_code (rtx comparison)\n \tcase LE: return 13;\n \tdefault: gcc_unreachable ();\n \t}\n-    case CC_FP_EQmode:\n+    case E_CC_FP_EQmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ: return 0;\n \tcase NE: return 1;\n \tdefault: gcc_unreachable ();\n \t}\n-    case CC_FP_GTEmode:\n+    case E_CC_FP_GTEmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase EQ: return 0;\n@@ -334,14 +334,14 @@ get_epiphany_condition_code (rtx comparison)\n \tcase UNLT : return 7;\n \tdefault: gcc_unreachable ();\n \t}\n-    case CC_FP_ORDmode:\n+    case E_CC_FP_ORDmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase ORDERED: return 9;\n \tcase UNORDERED: return 8;\n \tdefault: gcc_unreachable ();\n \t}\n-    case CC_FP_UNEQmode:\n+    case E_CC_FP_UNEQmode:\n       switch (GET_CODE (comparison))\n \t{\n \tcase UNEQ: return 9;\n@@ -803,9 +803,9 @@ epiphany_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t{\n \t/* There are a number of single-insn combiner patterns that use\n \t   the flag side effects of arithmetic.  */\n-\tcase CC_N_NEmode:\n-\tcase CC_C_LTUmode:\n-\tcase CC_C_GTUmode:\n+\tcase E_CC_N_NEmode:\n+\tcase E_CC_C_LTUmode:\n+\tcase E_CC_C_GTUmode:\n \t  return true;\n \tdefault:\n \t  return false;"}, {"sha": "16b41570355c88728950a390db69f36a1b39aa74", "filename": "gcc/config/epiphany/predicates.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fepiphany%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fepiphany%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -223,31 +223,31 @@\n     return 0;\n   switch (GET_MODE (cc))\n     {\n-    case CC_Zmode:\n-    case CC_N_NEmode:\n-    case CC_FP_EQmode:\n+    case E_CC_Zmode:\n+    case E_CC_N_NEmode:\n+    case E_CC_FP_EQmode:\n       return REGNO (cc) == CC_REGNUM && (code == EQ || code == NE);\n-    case CC_C_LTUmode:\n+    case E_CC_C_LTUmode:\n       return REGNO (cc) == CC_REGNUM && (code == LTU || code == GEU);\n-    case CC_C_GTUmode:\n+    case E_CC_C_GTUmode:\n       return REGNO (cc) == CC_REGNUM && (code == GTU || code == LEU);\n-    case CC_FPmode:\n+    case E_CC_FPmode:\n       return (REGNO (cc) == CCFP_REGNUM\n \t      && (code == EQ || code == NE || code == LT || code == LE));\n-    case CC_FP_GTEmode:\n+    case E_CC_FP_GTEmode:\n       return (REGNO (cc) == CC_REGNUM\n \t      && (code == EQ || code == NE || code == GT || code == GE\n \t\t  || code == UNLE || code == UNLT));\n-    case CC_FP_ORDmode:\n+    case E_CC_FP_ORDmode:\n       return REGNO (cc) == CC_REGNUM && (code == ORDERED || code == UNORDERED);\n-    case CC_FP_UNEQmode:\n+    case E_CC_FP_UNEQmode:\n       return REGNO (cc) == CC_REGNUM && (code == UNEQ || code == LTGT);\n-    case CCmode:\n+    case E_CCmode:\n       return REGNO (cc) == CC_REGNUM;\n     /* From combiner.  */\n-    case QImode: case SImode: case SFmode: case HImode:\n+    case E_QImode: case E_SImode: case E_SFmode: case E_HImode:\n     /* From cse.c:dead_libcall_p.  */\n-    case DFmode:\n+    case E_DFmode:\n       return 0;\n     default:\n       gcc_unreachable ();"}, {"sha": "89ab54de2f76cbf6c5b764d5f9289f50d3f14dab", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -3893,10 +3893,10 @@ condexec_memory_operand (rtx op, machine_mode mode)\n     default:\n       return FALSE;\n \n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case SFmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_SFmode:\n       break;\n     }\n \n@@ -3935,16 +3935,16 @@ frv_emit_move (machine_mode mode, rtx dest, rtx src)\n \n   switch (mode)\n     {\n-    case SImode:\n+    case E_SImode:\n       if (frv_emit_movsi (dest, src))\n \treturn;\n       break;\n \n-    case QImode:\n-    case HImode:\n-    case DImode:\n-    case SFmode:\n-    case DFmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_DImode:\n+    case E_SFmode:\n+    case E_DFmode:\n       if (!reload_in_progress\n \t  && !reload_completed\n \t  && !register_operand (dest, mode)\n@@ -4249,14 +4249,14 @@ output_move_single (rtx operands[], rtx insn)\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase QImode:\n+\t\tcase E_QImode:\n \t\t  return \"ldsb%I1%U1 %M1,%0\";\n \n-\t\tcase HImode:\n+\t\tcase E_HImode:\n \t\t  return \"ldsh%I1%U1 %M1,%0\";\n \n-\t\tcase SImode:\n-\t\tcase SFmode:\n+\t\tcase E_SImode:\n+\t\tcase E_SFmode:\n \t\t  return \"ld%I1%U1 %M1, %0\";\n \t\t}\n \t    }\n@@ -4323,14 +4323,14 @@ output_move_single (rtx operands[], rtx insn)\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase QImode:\n+\t\tcase E_QImode:\n \t\t  return \"ldbf%I1%U1 %M1,%0\";\n \n-\t\tcase HImode:\n+\t\tcase E_HImode:\n \t\t  return \"ldhf%I1%U1 %M1,%0\";\n \n-\t\tcase SImode:\n-\t\tcase SFmode:\n+\t\tcase E_SImode:\n+\t\tcase E_SFmode:\n \t\t  return \"ldf%I1%U1 %M1, %0\";\n \t\t}\n \t    }\n@@ -4368,14 +4368,14 @@ output_move_single (rtx operands[], rtx insn)\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase QImode:\n+\t\tcase E_QImode:\n \t\t  return \"stb%I0%U0 %1, %M0\";\n \n-\t\tcase HImode:\n+\t\tcase E_HImode:\n \t\t  return \"sth%I0%U0 %1, %M0\";\n \n-\t\tcase SImode:\n-\t\tcase SFmode:\n+\t\tcase E_SImode:\n+\t\tcase E_SFmode:\n \t\t  return \"st%I0%U0 %1, %M0\";\n \t\t}\n \t    }\n@@ -4387,14 +4387,14 @@ output_move_single (rtx operands[], rtx insn)\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase QImode:\n+\t\tcase E_QImode:\n \t\t  return \"stbf%I0%U0 %1, %M0\";\n \n-\t\tcase HImode:\n+\t\tcase E_HImode:\n \t\t  return \"sthf%I0%U0 %1, %M0\";\n \n-\t\tcase SImode:\n-\t\tcase SFmode:\n+\t\tcase E_SImode:\n+\t\tcase E_SFmode:\n \t\t  return \"stf%I0%U0 %1, %M0\";\n \t\t}\n \t    }\n@@ -4407,14 +4407,14 @@ output_move_single (rtx operands[], rtx insn)\n \t    default:\n \t      break;\n \n-\t    case QImode:\n+\t    case E_QImode:\n \t      return \"stb%I0%U0 %., %M0\";\n \n-\t    case HImode:\n+\t    case E_HImode:\n \t      return \"sth%I0%U0 %., %M0\";\n \n-\t    case SImode:\n-\t    case SFmode:\n+\t    case E_SImode:\n+\t    case E_SFmode:\n \t      return \"st%I0%U0 %., %M0\";\n \t    }\n \t}\n@@ -4591,14 +4591,14 @@ output_condmove_single (rtx operands[], rtx insn)\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase QImode:\n+\t\tcase E_QImode:\n \t\t  return \"cldsb%I3%U3 %M3, %2, %1, %e0\";\n \n-\t\tcase HImode:\n+\t\tcase E_HImode:\n \t\t  return \"cldsh%I3%U3 %M3, %2, %1, %e0\";\n \n-\t\tcase SImode:\n-\t\tcase SFmode:\n+\t\tcase E_SImode:\n+\t\tcase E_SFmode:\n \t\t  return \"cld%I3%U3 %M3, %2, %1, %e0\";\n \t\t}\n \t    }\n@@ -4652,14 +4652,14 @@ output_condmove_single (rtx operands[], rtx insn)\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase QImode:\n+\t\tcase E_QImode:\n \t\t  return \"cstb%I2%U2 %3, %M2, %1, %e0\";\n \n-\t\tcase HImode:\n+\t\tcase E_HImode:\n \t\t  return \"csth%I2%U2 %3, %M2, %1, %e0\";\n \n-\t\tcase SImode:\n-\t\tcase SFmode:\n+\t\tcase E_SImode:\n+\t\tcase E_SFmode:\n \t\t  return \"cst%I2%U2 %3, %M2, %1, %e0\";\n \t\t}\n \t    }\n@@ -4676,14 +4676,14 @@ output_condmove_single (rtx operands[], rtx insn)\n \t    default:\n \t      break;\n \n-\t    case QImode:\n+\t    case E_QImode:\n \t      return \"cstb%I2%U2 %., %M2, %1, %e0\";\n \n-\t    case HImode:\n+\t    case E_HImode:\n \t      return \"csth%I2%U2 %., %M2, %1, %e0\";\n \n-\t    case SImode:\n-\t    case SFmode:\n+\t    case E_SImode:\n+\t    case E_SFmode:\n \t      return \"cst%I2%U2 %., %M2, %1, %e0\";\n \t    }\n \t}\n@@ -6579,15 +6579,15 @@ frv_hard_regno_mode_ok (int regno, machine_mode mode)\n \n   switch (mode)\n     {\n-    case CCmode:\n-    case CC_UNSmode:\n-    case CC_NZmode:\n+    case E_CCmode:\n+    case E_CC_UNSmode:\n+    case E_CC_NZmode:\n       return ICC_P (regno) || GPR_P (regno);\n \n-    case CC_CCRmode:\n+    case E_CC_CCRmode:\n       return CR_P (regno) || GPR_P (regno);\n \n-    case CC_FPmode:\n+    case E_CC_FPmode:\n       return FCC_P (regno) || GPR_P (regno);\n \n     default:\n@@ -8619,13 +8619,13 @@ frv_matching_accg_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V4SImode:\n+    case E_V4SImode:\n       return V4QImode;\n \n-    case DImode:\n+    case E_DImode:\n       return HImode;\n \n-    case SImode:\n+    case E_SImode:\n       return QImode;\n \n     default:"}, {"sha": "4ca58b20b05dc48a6c7ea650f2a7dccbbe110c86", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1033,11 +1033,11 @@ split_adds_subs (machine_mode mode, rtx *operands)\n \n   switch (mode)\n     {\n-    case HImode:\n+    case E_HImode:\n       gen_add = gen_addhi3;\n       break;\n \n-    case SImode:\n+    case E_SImode:\n       gen_add = gen_addsi3;\n       break;\n \n@@ -1328,12 +1328,12 @@ h8300_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n       if (TARGET_H8300SX)\n \tswitch (GET_MODE (x))\n \t  {\n-\t  case QImode:\n-\t  case HImode:\n+\t  case E_QImode:\n+\t  case E_HImode:\n \t    *total = COSTS_N_INSNS (!speed ? 4 : 10);\n \t    return false;\n \n-\t  case SImode:\n+\t  case E_SImode:\n \t    *total = COSTS_N_INSNS (!speed ? 4 : 18);\n \t    return false;\n \n@@ -1347,12 +1347,12 @@ h8300_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,\n       if (TARGET_H8300SX)\n \tswitch (GET_MODE (x))\n \t  {\n-\t  case QImode:\n-\t  case HImode:\n+\t  case E_QImode:\n+\t  case E_HImode:\n \t    *total = COSTS_N_INSNS (2);\n \t    return false;\n \n-\t  case SImode:\n+\t  case E_SImode:\n \t    *total = COSTS_N_INSNS (5);\n \t    return false;\n \n@@ -1697,18 +1697,18 @@ h8300_print_operand (FILE *file, rtx x, int code)\n \tcase REG:\n \t  switch (GET_MODE (x))\n \t    {\n-\t    case QImode:\n+\t    case E_QImode:\n #if 0 /* Is it asm (\"mov.b %0,r2l\", ...) */\n \t      fprintf (file, \"%s\", byte_reg (x, 0));\n #else /* ... or is it asm (\"mov.b %0l,r2l\", ...) */\n \t      fprintf (file, \"%s\", names_big[REGNO (x)]);\n #endif\n \t      break;\n-\t    case HImode:\n+\t    case E_HImode:\n \t      fprintf (file, \"%s\", names_big[REGNO (x)]);\n \t      break;\n-\t    case SImode:\n-\t    case SFmode:\n+\t    case E_SImode:\n+\t    case E_SFmode:\n \t      fprintf (file, \"%s\", names_extended[REGNO (x)]);\n \t      break;\n \t    default:\n@@ -2808,7 +2808,7 @@ compute_mov_length (rtx *operands)\n \n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  if (addr == NULL_RTX)\n \t    return 2;\n \n@@ -2820,7 +2820,7 @@ compute_mov_length (rtx *operands)\n \t  base_length = 4;\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  if (addr == NULL_RTX)\n \t    {\n \t      if (REG_P (src))\n@@ -2835,7 +2835,7 @@ compute_mov_length (rtx *operands)\n \t  base_length = 4;\n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (addr == NULL_RTX)\n \t    {\n \t      if (REG_P (src))\n@@ -2862,7 +2862,7 @@ compute_mov_length (rtx *operands)\n \t  base_length = 8;\n \t  break;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  if (addr == NULL_RTX)\n \t    {\n \t      if (REG_P (src))\n@@ -2914,7 +2914,7 @@ compute_mov_length (rtx *operands)\n \n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  if (addr == NULL_RTX)\n \t    return 2;\n \n@@ -2926,7 +2926,7 @@ compute_mov_length (rtx *operands)\n \t  base_length = 8;\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  if (addr == NULL_RTX)\n \t    {\n \t      if (REG_P (src))\n@@ -2941,7 +2941,7 @@ compute_mov_length (rtx *operands)\n \t  base_length = 8;\n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (addr == NULL_RTX)\n \t    {\n \t      if (REG_P (src))\n@@ -2982,7 +2982,7 @@ compute_mov_length (rtx *operands)\n \t  base_length = 10;\n \t  break;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  if (addr == NULL_RTX)\n \t    {\n \t      if (REG_P (src))\n@@ -3304,7 +3304,7 @@ output_logical_op (machine_mode mode, rtx *operands)\n \n   switch (mode)\n     {\n-    case HImode:\n+    case E_HImode:\n       /* First, see if we can finish with one insn.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n \t  && b0 != 0\n@@ -3329,7 +3329,7 @@ output_logical_op (machine_mode mode, rtx *operands)\n \t    }\n \t}\n       break;\n-    case SImode:\n+    case E_SImode:\n       if (TARGET_H8300H || TARGET_H8300S)\n \t{\n \t  /* Determine if the lower half can be taken care of in no more\n@@ -3469,7 +3469,7 @@ compute_logical_op_length (machine_mode mode, rtx *operands)\n \n   switch (mode)\n     {\n-    case HImode:\n+    case E_HImode:\n       /* First, see if we can finish with one insn.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n \t  && b0 != 0\n@@ -3489,7 +3489,7 @@ compute_logical_op_length (machine_mode mode, rtx *operands)\n \t    length += 2;\n \t}\n       break;\n-    case SImode:\n+    case E_SImode:\n       if (TARGET_H8300H || TARGET_H8300S)\n \t{\n \t  /* Determine if the lower half can be taken care of in no more\n@@ -3613,7 +3613,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)\n \n   switch (mode)\n     {\n-    case HImode:\n+    case E_HImode:\n       /* First, see if we can finish with one insn.  */\n       if ((TARGET_H8300H || TARGET_H8300S)\n \t  && b0 != 0\n@@ -3622,7 +3622,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)\n \t  cc = CC_SET_ZNV;\n \t}\n       break;\n-    case SImode:\n+    case E_SImode:\n       if (TARGET_H8300H || TARGET_H8300S)\n \t{\n \t  /* Determine if the lower half can be taken care of in no more\n@@ -4533,19 +4533,19 @@ h8300_shift_needs_scratch_p (int count, machine_mode mode)\n   /* Find the shift algorithm.  */\n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       a  = shift_alg_qi[cpu][SHIFT_ASHIFT][count];\n       lr = shift_alg_qi[cpu][SHIFT_LSHIFTRT][count];\n       ar = shift_alg_qi[cpu][SHIFT_ASHIFTRT][count];\n       break;\n \n-    case HImode:\n+    case E_HImode:\n       a  = shift_alg_hi[cpu][SHIFT_ASHIFT][count];\n       lr = shift_alg_hi[cpu][SHIFT_LSHIFTRT][count];\n       ar = shift_alg_hi[cpu][SHIFT_ASHIFTRT][count];\n       break;\n \n-    case SImode:\n+    case E_SImode:\n       a  = shift_alg_si[cpu][SHIFT_ASHIFT][count];\n       lr = shift_alg_si[cpu][SHIFT_LSHIFTRT][count];\n       ar = shift_alg_si[cpu][SHIFT_ASHIFTRT][count];\n@@ -4578,13 +4578,13 @@ output_a_shift (rtx *operands)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       shift_mode = QIshift;\n       break;\n-    case HImode:\n+    case E_HImode:\n       shift_mode = HIshift;\n       break;\n-    case SImode:\n+    case E_SImode:\n       shift_mode = SIshift;\n       break;\n     default:\n@@ -4670,11 +4670,11 @@ output_a_shift (rtx *operands)\n \t/* Now mask off the high bits.  */\n \tswitch (mode)\n \t  {\n-\t  case QImode:\n+\t  case E_QImode:\n \t    sprintf (insn_buf, \"and\\t#%d,%%X0\", mask);\n \t    break;\n \n-\t  case HImode:\n+\t  case E_HImode:\n \t    gcc_assert (TARGET_H8300H || TARGET_H8300S);\n \t    sprintf (insn_buf, \"and.w\\t#%d,%%T0\", mask);\n \t    break;\n@@ -4746,13 +4746,13 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       shift_mode = QIshift;\n       break;\n-    case HImode:\n+    case E_HImode:\n       shift_mode = HIshift;\n       break;\n-    case SImode:\n+    case E_SImode:\n       shift_mode = SIshift;\n       break;\n     default:\n@@ -4842,13 +4842,13 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n \t    /* Now mask off the high bits.  */\n \t    switch (mode)\n \t      {\n-\t      case QImode:\n+\t      case E_QImode:\n \t\twlength += 1;\n \t\tbreak;\n-\t      case HImode:\n+\t      case E_HImode:\n \t\twlength += 2;\n \t\tbreak;\n-\t      case SImode:\n+\t      case E_SImode:\n \t\tgcc_assert (!TARGET_H8300);\n \t\twlength += 3;\n \t\tbreak;\n@@ -4894,13 +4894,13 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)\n   \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       shift_mode = QIshift;\n       break;\n-    case HImode:\n+    case E_HImode:\n       shift_mode = HIshift;\n       break;\n-    case SImode:\n+    case E_SImode:\n       shift_mode = SIshift;\n       break;\n     default:\n@@ -5007,13 +5007,13 @@ expand_a_rotate (rtx operands[])\n       /* Rotate by one bit.  */\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  emit_insn (gen_rotlqi3_1 (dst, dst, const1_rtx));\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  emit_insn (gen_rotlhi3_1 (dst, dst, const1_rtx));\n \t  break;\n-\tcase SImode:\n+\tcase E_SImode:\n \t  emit_insn (gen_rotlsi3_1 (dst, dst, const1_rtx));\n \t  break;\n \tdefault:\n@@ -5035,13 +5035,13 @@ expand_a_rotate (rtx operands[])\n       /* Rotate by AMOUNT bits.  */\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  emit_insn (gen_rotlqi3_1 (dst, dst, rotate_amount));\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  emit_insn (gen_rotlhi3_1 (dst, dst, rotate_amount));\n \t  break;\n-\tcase SImode:\n+\tcase E_SImode:\n \t  emit_insn (gen_rotlsi3_1 (dst, dst, rotate_amount));\n \t  break;\n \tdefault:\n@@ -5070,13 +5070,13 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       rotate_mode = QIshift;\n       break;\n-    case HImode:\n+    case E_HImode:\n       rotate_mode = HIshift;\n       break;\n-    case SImode:\n+    case E_SImode:\n       rotate_mode = SIshift;\n       break;\n     default:\n@@ -5123,13 +5123,13 @@ output_a_rotate (enum rtx_code code, rtx *operands)\n     {\n       switch (mode)\n \t{\n-\tcase HImode:\n+\tcase E_HImode:\n \t  /* This code works on any family.  */\n \t  insn_buf = \"xor.b\\t%s0,%t0\\n\\txor.b\\t%t0,%s0\\n\\txor.b\\t%s0,%t0\";\n \t  output_asm_insn (insn_buf, operands);\n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  /* This code works on the H8/300H and H8S.  */\n \t  insn_buf = \"xor.w\\t%e0,%f0\\n\\txor.w\\t%f0,%e0\\n\\txor.w\\t%e0,%f0\";\n \t  output_asm_insn (insn_buf, operands);"}, {"sha": "69d6be4c3d44817541e8d54f9e75b4509bd63556", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 739, "deletions": 739, "changes": 1478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b"}, {"sha": "d61afcff0f4e4c5da299e4d94204229adfd7c7ed", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -11592,20 +11592,20 @@\n       tmp = \"pandn\";\n       switch (<MODE>mode)\n \t{\n-\tcase V64QImode:\n-\tcase V32HImode:\n+\tcase E_V64QImode:\n+\tcase E_V32HImode:\n \t  /* There is no vpandnb or vpandnw instruction, nor vpandn for\n \t     512-bit vectors. Use vpandnq instead.  */\n \t  ssesuffix = \"q\";\n \t  break;\n-\tcase V16SImode:\n-\tcase V8DImode:\n+\tcase E_V16SImode:\n+\tcase E_V8DImode:\n \t  ssesuffix = \"<ssemodesuffix>\";\n \t  break;\n-\tcase V8SImode:\n-\tcase V4DImode:\n-\tcase V4SImode:\n-\tcase V2DImode:\n+\tcase E_V8SImode:\n+\tcase E_V4DImode:\n+\tcase E_V4SImode:\n+\tcase E_V2DImode:\n \t  ssesuffix = TARGET_AVX512VL ? \"<ssemodesuffix>\" : \"\";\n \t  break;\n \tdefault:\n@@ -11722,14 +11722,14 @@\n       tmp = \"p<logic>\";\n       switch (<MODE>mode)\n \t{\n-\tcase V16SImode:\n-\tcase V8DImode:\n+\tcase E_V16SImode:\n+\tcase E_V8DImode:\n \t  ssesuffix = \"<ssemodesuffix>\";\n \t  break;\n-\tcase V8SImode:\n-\tcase V4DImode:\n-\tcase V4SImode:\n-\tcase V2DImode:\n+\tcase E_V8SImode:\n+\tcase E_V4DImode:\n+\tcase E_V4SImode:\n+\tcase E_V2DImode:\n \t  ssesuffix = TARGET_AVX512VL ? \"<ssemodesuffix>\" : \"\";\n \t  break;\n \tdefault:\n@@ -11819,14 +11819,14 @@\n       tmp = \"p<logic>\";\n       switch (<MODE>mode)\n \t{\n-\tcase V64QImode:\n-\tcase V32HImode:\n+\tcase E_V64QImode:\n+\tcase E_V32HImode:\n \t  ssesuffix = \"q\";\n \t  break;\n-\tcase V32QImode:\n-\tcase V16HImode:\n-\tcase V16QImode:\n-\tcase V8HImode:\n+\tcase E_V32QImode:\n+\tcase E_V16HImode:\n+\tcase E_V16QImode:\n+\tcase E_V8HImode:\n \t  ssesuffix = TARGET_AVX512VL ? \"q\" : \"\";\n \t  break;\n \tdefault:"}, {"sha": "455b50e1fb81006a21a609cd4f4e66f1d682c44b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1909,7 +1909,7 @@ ia64_expand_vecint_compare (enum rtx_code code, machine_mode mode,\n     {\n       switch (mode)\n \t{\n-\tcase V2SImode:\n+\tcase E_V2SImode:\n \t  {\n \t    rtx t1, t2, mask;\n \n@@ -1928,8 +1928,8 @@ ia64_expand_vecint_compare (enum rtx_code code, machine_mode mode,\n \t  }\n \t  break;\n \n-\tcase V8QImode:\n-\tcase V4HImode:\n+\tcase E_V8QImode:\n+\tcase E_V4HImode:\n \t  /* Perform a parallel unsigned saturating subtraction.  */\n \t  x = gen_reg_rtx (mode);\n \t  emit_insn (gen_rtx_SET (x, gen_rtx_US_MINUS (mode, op0, op1)));\n@@ -2447,10 +2447,10 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n     case MEMMODEL_CONSUME:\n       switch (mode)\n \t{\n-\tcase QImode: icode = CODE_FOR_cmpxchg_acq_qi;  break;\n-\tcase HImode: icode = CODE_FOR_cmpxchg_acq_hi;  break;\n-\tcase SImode: icode = CODE_FOR_cmpxchg_acq_si;  break;\n-\tcase DImode: icode = CODE_FOR_cmpxchg_acq_di;  break;\n+\tcase E_QImode: icode = CODE_FOR_cmpxchg_acq_qi;  break;\n+\tcase E_HImode: icode = CODE_FOR_cmpxchg_acq_hi;  break;\n+\tcase E_SImode: icode = CODE_FOR_cmpxchg_acq_si;  break;\n+\tcase E_DImode: icode = CODE_FOR_cmpxchg_acq_di;  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -2463,10 +2463,10 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n     case MEMMODEL_SYNC_SEQ_CST:\n       switch (mode)\n \t{\n-\tcase QImode: icode = CODE_FOR_cmpxchg_rel_qi;  break;\n-\tcase HImode: icode = CODE_FOR_cmpxchg_rel_hi;  break;\n-\tcase SImode: icode = CODE_FOR_cmpxchg_rel_si;  break;\n-\tcase DImode: icode = CODE_FOR_cmpxchg_rel_di;  break;\n+\tcase E_QImode: icode = CODE_FOR_cmpxchg_rel_qi;  break;\n+\tcase E_HImode: icode = CODE_FOR_cmpxchg_rel_hi;  break;\n+\tcase E_SImode: icode = CODE_FOR_cmpxchg_rel_si;  break;\n+\tcase E_DImode: icode = CODE_FOR_cmpxchg_rel_di;  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -4899,9 +4899,9 @@ ia64_arg_type (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case SFmode:\n+    case E_SFmode:\n       return FS;\n-    case DFmode:\n+    case E_DFmode:\n       return FT;\n     default:\n       return I64;\n@@ -7895,15 +7895,15 @@ ia64_mode_to_int (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case BImode: return 0; /* SPEC_MODE_FIRST  */\n-    case QImode: return 1; /* SPEC_MODE_FOR_EXTEND_FIRST  */\n-    case HImode: return 2;\n-    case SImode: return 3; /* SPEC_MODE_FOR_EXTEND_LAST  */\n-    case DImode: return 4;\n-    case SFmode: return 5;\n-    case DFmode: return 6;\n-    case XFmode: return 7;\n-    case TImode:\n+    case E_BImode: return 0; /* SPEC_MODE_FIRST  */\n+    case E_QImode: return 1; /* SPEC_MODE_FOR_EXTEND_FIRST  */\n+    case E_HImode: return 2;\n+    case E_SImode: return 3; /* SPEC_MODE_FOR_EXTEND_LAST  */\n+    case E_DImode: return 4;\n+    case E_SFmode: return 5;\n+    case E_DFmode: return 6;\n+    case E_XFmode: return 7;\n+    case E_TImode:\n       /* ??? This mode needs testing.  Bypasses for ldfp8 instruction are not\n \t mentioned in itanium[12].md.  Predicate fp_register_operand also\n \t needs to be defined.  Bottom line: better disable for now.  */\n@@ -10968,20 +10968,20 @@ ia64_scalar_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case DImode:\n-    case TImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_DImode:\n+    case E_TImode:\n       return true;\n \n-    case SFmode:\n-    case DFmode:\n-    case XFmode:\n-    case RFmode:\n+    case E_SFmode:\n+    case E_DFmode:\n+    case E_XFmode:\n+    case E_RFmode:\n       return true;\n \n-    case TFmode:\n+    case E_TFmode:\n       return true;\n \n     default:\n@@ -10994,12 +10994,12 @@ ia64_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V8QImode:\n-    case V4HImode:\n-    case V2SImode:\n+    case E_V8QImode:\n+    case E_V4HImode:\n+    case E_V2SImode:\n       return true;\n \n-    case V2SFmode:\n+    case E_V2SFmode:\n       return true;\n \n     default:\n@@ -11438,16 +11438,16 @@ expand_vec_perm_broadcast (struct expand_vec_perm_d *d)\n \n   switch (d->vmode)\n     {\n-    case V2SImode:\n-    case V2SFmode:\n+    case E_V2SImode:\n+    case E_V2SFmode:\n       /* Implementable by interleave.  */\n       perm2[0] = elt;\n       perm2[1] = elt + 2;\n       ok = expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, 2);\n       gcc_assert (ok);\n       break;\n \n-    case V8QImode:\n+    case E_V8QImode:\n       /* Implementable by extract + broadcast.  */\n       if (BYTES_BIG_ENDIAN)\n \telt = 7 - elt;\n@@ -11458,7 +11458,7 @@ expand_vec_perm_broadcast (struct expand_vec_perm_d *d)\n       emit_insn (gen_mux1_brcst_qi (d->target, gen_lowpart (QImode, temp)));\n       break;\n \n-    case V4HImode:\n+    case E_V4HImode:\n       /* Should have been matched directly by vec_select.  */\n     default:\n       gcc_unreachable ();"}, {"sha": "3e010a9729abee7103ff7987a3098bdf6b26874a", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -624,17 +624,17 @@ iq2000_move_1word (rtx operands[], rtx_insn *insn, int unsignedp)\n \t\t{\n \t\tdefault:\n \t\t  break;\n-\t\tcase SFmode:\n+\t\tcase E_SFmode:\n \t\t  ret = \"lw\\t%0,%1\";\n \t\t  break;\n-\t\tcase SImode:\n-\t\tcase CCmode:\n+\t\tcase E_SImode:\n+\t\tcase E_CCmode:\n \t\t  ret = \"lw\\t%0,%1\";\n \t\t  break;\n-\t\tcase HImode:\n+\t\tcase E_HImode:\n \t\t  ret = (unsignedp) ? \"lhu\\t%0,%1\" : \"lh\\t%0,%1\";\n \t\t  break;\n-\t\tcase QImode:\n+\t\tcase E_QImode:\n \t\t  ret = (unsignedp) ? \"lbu\\t%0,%1\" : \"lb\\t%0,%1\";\n \t\t  break;\n \t\t}\n@@ -734,10 +734,10 @@ iq2000_move_1word (rtx operands[], rtx_insn *insn, int unsignedp)\n \t    {\n \t      switch (mode)\n \t\t{\n-\t\tcase SFmode: ret = \"sw\\t%1,%0\"; break;\n-\t\tcase SImode: ret = \"sw\\t%1,%0\"; break;\n-\t\tcase HImode: ret = \"sh\\t%1,%0\"; break;\n-\t\tcase QImode: ret = \"sb\\t%1,%0\"; break;\n+\t\tcase E_SFmode: ret = \"sw\\t%1,%0\"; break;\n+\t\tcase E_SImode: ret = \"sw\\t%1,%0\"; break;\n+\t\tcase E_HImode: ret = \"sh\\t%1,%0\"; break;\n+\t\tcase E_QImode: ret = \"sb\\t%1,%0\"; break;\n \t\tdefault: break;\n \t\t}\n \t    }\n@@ -747,10 +747,10 @@ iq2000_move_1word (rtx operands[], rtx_insn *insn, int unsignedp)\n \t{\n \t  switch (mode)\n \t    {\n-\t    case SFmode: ret = \"sw\\t%z1,%0\"; break;\n-\t    case SImode: ret = \"sw\\t%z1,%0\"; break;\n-\t    case HImode: ret = \"sh\\t%z1,%0\"; break;\n-\t    case QImode: ret = \"sb\\t%z1,%0\"; break;\n+\t    case E_SFmode: ret = \"sw\\t%z1,%0\"; break;\n+\t    case E_SImode: ret = \"sw\\t%z1,%0\"; break;\n+\t    case E_HImode: ret = \"sh\\t%z1,%0\"; break;\n+\t    case E_QImode: ret = \"sb\\t%z1,%0\"; break;\n \t    default: break;\n \t    }\n \t}\n@@ -759,10 +759,10 @@ iq2000_move_1word (rtx operands[], rtx_insn *insn, int unsignedp)\n \t{\n \t  switch (mode)\n \t    {\n-\t    case SFmode: ret = \"sw\\t%.,%0\"; break;\n-\t    case SImode: ret = \"sw\\t%.,%0\"; break;\n-\t    case HImode: ret = \"sh\\t%.,%0\"; break;\n-\t    case QImode: ret = \"sb\\t%.,%0\"; break;\n+\t    case E_SFmode: ret = \"sw\\t%.,%0\"; break;\n+\t    case E_SImode: ret = \"sw\\t%.,%0\"; break;\n+\t    case E_HImode: ret = \"sh\\t%.,%0\"; break;\n+\t    case E_QImode: ret = \"sb\\t%.,%0\"; break;\n \t    default: break;\n \t    }\n \t}\n@@ -1152,7 +1152,7 @@ iq2000_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n   cum->arg_number++;\n   switch (mode)\n     {\n-    case VOIDmode:\n+    case E_VOIDmode:\n       break;\n \n     default:\n@@ -1164,37 +1164,37 @@ iq2000_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n-    case BLKmode:\n+    case E_BLKmode:\n       cum->gp_reg_found = 1;\n       cum->arg_words += ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n-    case SFmode:\n+    case E_SFmode:\n       cum->arg_words ++;\n       if (! cum->gp_reg_found && cum->arg_number <= 2)\n \tcum->fp_code += 1 << ((cum->arg_number - 1) * 2);\n       break;\n \n-    case DFmode:\n+    case E_DFmode:\n       cum->arg_words += 2;\n       if (! cum->gp_reg_found && cum->arg_number <= 2)\n \tcum->fp_code += 2 << ((cum->arg_number - 1) * 2);\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       cum->gp_reg_found = 1;\n       cum->arg_words += 2;\n       break;\n \n-    case TImode:\n+    case E_TImode:\n       cum->gp_reg_found = 1;\n       cum->arg_words += 4;\n       break;\n \n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       cum->gp_reg_found = 1;\n       cum->arg_words ++;\n       break;\n@@ -1232,11 +1232,11 @@ iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   cum->last_arg_fp = 0;\n   switch (mode)\n     {\n-    case SFmode:\n+    case E_SFmode:\n       regbase = GP_ARG_FIRST;\n       break;\n \n-    case DFmode:\n+    case E_DFmode:\n       cum->arg_words += cum->arg_words & 1;\n \n       regbase = GP_ARG_FIRST;\n@@ -1247,25 +1247,25 @@ iq2000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t\t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n \n       /* FALLTHRU */\n-    case BLKmode:\n+    case E_BLKmode:\n       if (type != NULL_TREE && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD)\n \tcum->arg_words += (cum->arg_words & 1);\n       regbase = GP_ARG_FIRST;\n       break;\n \n-    case VOIDmode:\n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_VOIDmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       regbase = GP_ARG_FIRST;\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       cum->arg_words += (cum->arg_words & 1);\n       regbase = GP_ARG_FIRST;\n       break;\n \n-    case TImode:\n+    case E_TImode:\n       cum->arg_words += (cum->arg_words & 3);\n       regbase = GP_ARG_FIRST;\n       break;"}, {"sha": "aceefe0f17a217f02363903c06d5fef749965dd3", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -666,7 +666,7 @@ m32c_preferred_reload_class (rtx x, reg_class_t rclass)\n     {\n       switch (GET_MODE (x))\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  newclass = HL_REGS;\n \t  break;\n \tdefault:"}, {"sha": "fbec453708cf834768aa1b3a3f5901d4fa6e4cc8", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1621,11 +1621,11 @@ output_dbcc_and_branch (rtx *operands)\n      to compensate for the fact that dbcc decrements in HImode.  */\n   switch (GET_MODE (operands[0]))\n     {\n-      case SImode:\n+      case E_SImode:\n         output_asm_insn (\"clr%.w %0\\n\\tsubq%.l #1,%0\\n\\tjpl %l1\", operands);\n         break;\n \n-      case HImode:\n+      case E_HImode:\n         break;\n \n       default:\n@@ -5270,9 +5270,9 @@ rtx\n m68k_libcall_value (machine_mode mode)\n {\n   switch (mode) {\n-  case SFmode:\n-  case DFmode:\n-  case XFmode:\n+  case E_SFmode:\n+  case E_DFmode:\n+  case E_XFmode:\n     if (TARGET_68881)\n       return gen_rtx_REG (mode, FP0_REG);\n     break;\n@@ -5293,9 +5293,9 @@ m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n \n   mode = TYPE_MODE (valtype);\n   switch (mode) {\n-  case SFmode:\n-  case DFmode:\n-  case XFmode:\n+  case E_SFmode:\n+  case E_DFmode:\n+  case E_XFmode:\n     if (TARGET_68881)\n       return gen_rtx_REG (mode, FP0_REG);\n     break;\n@@ -5521,11 +5521,11 @@ sched_attr_op_type (rtx_insn *insn, bool opx_p, bool address_p)\n     {\n       switch (GET_MODE (op))\n \t{\n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  return OP_TYPE_IMM_W;\n \n-\tcase VOIDmode:\n-\tcase DFmode:\n+\tcase E_VOIDmode:\n+\tcase E_DFmode:\n \t  return OP_TYPE_IMM_L;\n \n \tdefault:\n@@ -5539,13 +5539,13 @@ sched_attr_op_type (rtx_insn *insn, bool opx_p, bool address_p)\n     {\n       switch (GET_MODE (op))\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  return OP_TYPE_IMM_Q;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  return OP_TYPE_IMM_W;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  return OP_TYPE_IMM_L;\n \n \tdefault:"}, {"sha": "97fbb8c87686b74acd2830e892b16bfafd1bf6ef", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1282,11 +1282,11 @@ mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \t  else\n \t    switch (GET_MODE (src))\t\t/* r-m */\n \t      {\n-\t      case SImode:\n+\t      case E_SImode:\n \t\treturn \"ldw\\t%0,%1\";\n-\t      case HImode:\n+\t      case E_HImode:\n \t\treturn \"ld.h\\t%0,%1\";\n-\t      case QImode:\n+\t      case E_QImode:\n \t\treturn \"ld.b\\t%0,%1\";\n \t      default:\n \t\tgcc_unreachable ();\n@@ -1313,11 +1313,11 @@ mcore_output_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n   else if (GET_CODE (dst) == MEM)               /* m-r */\n     switch (GET_MODE (dst))\n       {\n-      case SImode:\n+      case E_SImode:\n \treturn \"stw\\t%1,%0\";\n-      case HImode:\n+      case E_HImode:\n \treturn \"st.h\\t%1,%0\";\n-      case QImode:\n+      case E_QImode:\n \treturn \"st.b\\t%1,%0\";\n       default:\n \tgcc_unreachable ();"}, {"sha": "cb61ae5dd2229411e100b33769735c8c76988ffc", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1481,7 +1481,7 @@ microblaze_function_arg_advance (cumulative_args_t cum_v,\n   cum->arg_number++;\n   switch (mode)\n     {\n-    case VOIDmode:\n+    case E_VOIDmode:\n       break;\n \n     default:\n@@ -1493,33 +1493,33 @@ microblaze_function_arg_advance (cumulative_args_t cum_v,\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n-    case BLKmode:\n+    case E_BLKmode:\n       cum->gp_reg_found = 1;\n       cum->arg_words += ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n-    case SFmode:\n+    case E_SFmode:\n       cum->arg_words++;\n       if (!cum->gp_reg_found && cum->arg_number <= 2)\n \tcum->fp_code += 1 << ((cum->arg_number - 1) * 2);\n       break;\n \n-    case DFmode:\n+    case E_DFmode:\n       cum->arg_words += 2;\n       if (!cum->gp_reg_found && cum->arg_number <= 2)\n \tcum->fp_code += 2 << ((cum->arg_number - 1) * 2);\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       cum->gp_reg_found = 1;\n       cum->arg_words += 2;\n       break;\n \n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case TImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_TImode:\n       cum->gp_reg_found = 1;\n       cum->arg_words++;\n       break;\n@@ -1543,21 +1543,21 @@ microblaze_function_arg (cumulative_args_t cum_v, machine_mode mode,\n   cum->last_arg_fp = 0;\n   switch (mode)\n     {\n-    case SFmode:\n-    case DFmode:\n-    case VOIDmode:\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case DImode:\n-    case TImode:\n+    case E_SFmode:\n+    case E_DFmode:\n+    case E_VOIDmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_DImode:\n+    case E_TImode:\n       regbase = GP_ARG_FIRST;\n       break;\n     default:\n       gcc_assert (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n \t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n       /* FALLTHRU */\n-    case BLKmode:\n+    case E_BLKmode:\n       regbase = GP_ARG_FIRST;\n       break;\n     }"}, {"sha": "af7cd184a66568c40f2606839a3a50197266918f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -7611,7 +7611,7 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n \t     general registers.  */\n \t  switch (GET_MODE (retval))\n \t    {\n-\t    case SCmode:\n+\t    case E_SCmode:\n \t      mips_output_32bit_xfer ('f', GP_RETURN + TARGET_BIG_ENDIAN,\n \t\t\t\t      TARGET_BIG_ENDIAN\n \t\t\t\t      ? FP_REG_FIRST + 2\n@@ -7641,16 +7641,16 @@ mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n \t\t}\n \t      break;\n \n-\t    case SFmode:\n+\t    case E_SFmode:\n \t      mips_output_32bit_xfer ('f', GP_RETURN, FP_REG_FIRST);\n \t      break;\n \n-\t    case DCmode:\n+\t    case E_DCmode:\n \t      mips_output_64bit_xfer ('f', GP_RETURN + (8 / UNITS_PER_WORD),\n \t\t\t\t      FP_REG_FIRST + 2);\n \t      /* FALLTHRU */\n- \t    case DFmode:\n-\t    case V2SFmode:\n+ \t    case E_DFmode:\n+\t    case E_V2SFmode:\n \t      gcc_assert (TARGET_PAIRED_SINGLE_FLOAT\n \t\t\t  || GET_MODE (retval) != V2SFmode);\n \t      mips_output_64bit_xfer ('f', GP_RETURN, FP_REG_FIRST);\n@@ -9116,18 +9116,18 @@ mips_print_operand (FILE *file, rtx op, int letter)\n     case 'v':\n       switch (GET_MODE (op))\n \t{\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  fprintf (file, \"b\");\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  fprintf (file, \"h\");\n \t  break;\n-\tcase V4SImode:\n-\tcase V4SFmode:\n+\tcase E_V4SImode:\n+\tcase E_V4SFmode:\n \t  fprintf (file, \"w\");\n \t  break;\n-\tcase V2DImode:\n-\tcase V2DFmode:\n+\tcase E_V2DImode:\n+\tcase E_V2DFmode:\n \t  fprintf (file, \"d\");\n \t  break;\n \tdefault:\n@@ -12974,14 +12974,14 @@ mips_mode_ok_for_mov_fmt_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case CCFmode:\n-    case SFmode:\n+    case E_CCFmode:\n+    case E_SFmode:\n       return TARGET_HARD_FLOAT;\n \n-    case DFmode:\n+    case E_DFmode:\n       return TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT;\n \n-    case V2SFmode:\n+    case E_V2SFmode:\n       return TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT;\n \n     default:\n@@ -13286,22 +13286,22 @@ mips_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V2SFmode:\n+    case E_V2SFmode:\n       return TARGET_PAIRED_SINGLE_FLOAT;\n \n-    case V2HImode:\n-    case V4QImode:\n-    case V2HQmode:\n-    case V2UHQmode:\n-    case V2HAmode:\n-    case V2UHAmode:\n-    case V4QQmode:\n-    case V4UQQmode:\n+    case E_V2HImode:\n+    case E_V4QImode:\n+    case E_V2HQmode:\n+    case E_V2UHQmode:\n+    case E_V2HAmode:\n+    case E_V2UHAmode:\n+    case E_V4QQmode:\n+    case E_V4UQQmode:\n       return TARGET_DSP;\n \n-    case V2SImode:\n-    case V4HImode:\n-    case V8QImode:\n+    case E_V2SImode:\n+    case E_V4HImode:\n+    case E_V8QImode:\n       return TARGET_LOONGSON_VECTORS;\n \n     default:\n@@ -13335,19 +13335,19 @@ mips_preferred_simd_mode (machine_mode mode)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       return V16QImode;\n-    case HImode:\n+    case E_HImode:\n       return V8HImode;\n-    case SImode:\n+    case E_SImode:\n       return V4SImode;\n-    case DImode:\n+    case E_DImode:\n       return V2DImode;\n \n-    case SFmode:\n+    case E_SFmode:\n       return V4SFmode;\n \n-    case DFmode:\n+    case E_DFmode:\n       return V2DFmode;\n \n     default:\n@@ -21139,7 +21139,7 @@ mips_expand_vpc_loongson_even_odd (struct expand_vec_perm_d *d)\n   t1 = gen_reg_rtx (d->vmode);\n   switch (d->vmode)\n     {\n-    case V4HImode:\n+    case E_V4HImode:\n       emit_insn (gen_loongson_punpckhhw (t0, d->op0, d->op1));\n       emit_insn (gen_loongson_punpcklhw (t1, d->op0, d->op1));\n       if (odd)\n@@ -21148,7 +21148,7 @@ mips_expand_vpc_loongson_even_odd (struct expand_vec_perm_d *d)\n \temit_insn (gen_loongson_punpcklhw (d->target, t1, t0));\n       break;\n \n-    case V8QImode:\n+    case E_V8QImode:\n       t2 = gen_reg_rtx (d->vmode);\n       t3 = gen_reg_rtx (d->vmode);\n       emit_insn (gen_loongson_punpckhbh (t0, d->op0, d->op1));\n@@ -21481,7 +21481,7 @@ mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n     {\n       switch (imode)\n \t{\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  if (BYTES_BIG_ENDIAN != high_p)\n \t    unpack = gen_msa_ilvl_w;\n \t  else\n@@ -21490,7 +21490,7 @@ mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n \t  cmpFunc = gen_msa_clt_s_w;\n \t  break;\n \n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  if (BYTES_BIG_ENDIAN != high_p)\n \t    unpack = gen_msa_ilvl_h;\n \t  else\n@@ -21499,7 +21499,7 @@ mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n \t  cmpFunc = gen_msa_clt_s_h;\n \t  break;\n \n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  if (BYTES_BIG_ENDIAN != high_p)\n \t    unpack = gen_msa_ilvl_b;\n \t  else\n@@ -21532,14 +21532,14 @@ mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n \n   switch (imode)\n     {\n-    case V8QImode:\n+    case E_V8QImode:\n       if (high_p)\n \tunpack = gen_loongson_punpckhbh;\n       else\n \tunpack = gen_loongson_punpcklbh;\n       cmpFunc = gen_loongson_pcmpgtb;\n       break;\n-    case V4HImode:\n+    case E_V4HImode:\n       if (high_p)\n \tunpack = gen_loongson_punpckhhw;\n       else\n@@ -21612,10 +21612,10 @@ mips_expand_vi_broadcast (machine_mode vmode, rtx target, rtx elt)\n   t1 = gen_reg_rtx (vmode);\n   switch (vmode)\n     {\n-    case V8QImode:\n+    case E_V8QImode:\n       emit_insn (gen_loongson_vec_init1_v8qi (t1, elt));\n       break;\n-    case V4HImode:\n+    case E_V4HImode:\n       emit_insn (gen_loongson_vec_init1_v4hi (t1, elt));\n       break;\n     default:\n@@ -21757,10 +21757,10 @@ mips_expand_vector_init (rtx target, rtx vals)\n \t    {\n \t      switch (vmode)\n \t\t{\n-\t\tcase V16QImode:\n-\t\tcase V8HImode:\n-\t\tcase V4SImode:\n-\t\tcase V2DImode:\n+\t\tcase E_V16QImode:\n+\t\tcase E_V8HImode:\n+\t\tcase E_V4SImode:\n+\t\tcase E_V2DImode:\n \t\t  temp = gen_rtx_CONST_VECTOR (vmode, XVEC (vals, 0));\n \t\t  emit_move_insn (target, temp);\n \t\t  return;\n@@ -21780,18 +21780,18 @@ mips_expand_vector_init (rtx target, rtx vals)\n \n \t  switch (vmode)\n \t    {\n-\t    case V16QImode:\n-\t    case V8HImode:\n-\t    case V4SImode:\n-\t    case V2DImode:\n+\t    case E_V16QImode:\n+\t    case E_V8HImode:\n+\t    case E_V4SImode:\n+\t    case E_V2DImode:\n \t      mips_emit_move (target, gen_rtx_VEC_DUPLICATE (vmode, temp));\n \t      break;\n \n-\t    case V4SFmode:\n+\t    case E_V4SFmode:\n \t      emit_insn (gen_msa_splati_w_f_scalar (target, temp));\n \t      break;\n \n-\t    case V2DFmode:\n+\t    case E_V2DFmode:\n \t      emit_insn (gen_msa_splati_d_f_scalar (target, temp));\n \t      break;\n \n@@ -21814,27 +21814,27 @@ mips_expand_vector_init (rtx target, rtx vals)\n \t      emit_move_insn (temp, XVECEXP (vals, 0, i));\n \t      switch (vmode)\n \t\t{\n-\t\tcase V16QImode:\n+\t\tcase E_V16QImode:\n \t\t  emit_insn (gen_vec_setv16qi (target, temp, GEN_INT (i)));\n \t\t  break;\n \n-\t\tcase V8HImode:\n+\t\tcase E_V8HImode:\n \t\t  emit_insn (gen_vec_setv8hi (target, temp, GEN_INT (i)));\n \t\t  break;\n \n-\t\tcase V4SImode:\n+\t\tcase E_V4SImode:\n \t\t  emit_insn (gen_vec_setv4si (target, temp, GEN_INT (i)));\n \t\t  break;\n \n-\t\tcase V2DImode:\n+\t\tcase E_V2DImode:\n \t\t  emit_insn (gen_vec_setv2di (target, temp, GEN_INT (i)));\n \t\t  break;\n \n-\t\tcase V4SFmode:\n+\t\tcase E_V4SFmode:\n \t\t  emit_insn (gen_vec_setv4sf (target, temp, GEN_INT (i)));\n \t\t  break;\n \n-\t\tcase V2DFmode:\n+\t\tcase E_V2DFmode:\n \t\t  emit_insn (gen_vec_setv2df (target, temp, GEN_INT (i)));\n \t\t  break;\n \n@@ -21897,7 +21897,7 @@ mips_expand_vec_reduc (rtx target, rtx in, rtx (*gen)(rtx, rtx, rtx))\n   fold = gen_reg_rtx (vmode);\n   switch (vmode)\n     {\n-    case V2SFmode:\n+    case E_V2SFmode:\n       /* Use PUL/PLU to produce { L, H } op { H, L }.\n \t By reversing the pair order, rather than a pure interleave high,\n \t we avoid erroneous exceptional conditions that we might otherwise\n@@ -21908,12 +21908,12 @@ mips_expand_vec_reduc (rtx target, rtx in, rtx (*gen)(rtx, rtx, rtx))\n       gcc_assert (ok);\n       break;\n \n-    case V2SImode:\n+    case E_V2SImode:\n       /* Use interleave to produce { H, L } op { H, H }.  */\n       emit_insn (gen_loongson_punpckhwd (fold, last, last));\n       break;\n \n-    case V4HImode:\n+    case E_V4HImode:\n       /* Perform the first reduction with interleave,\n \t and subsequent reductions with shifts.  */\n       emit_insn (gen_loongson_punpckhwd_hi (fold, last, last));\n@@ -21927,7 +21927,7 @@ mips_expand_vec_reduc (rtx target, rtx in, rtx (*gen)(rtx, rtx, rtx))\n       emit_insn (gen_vec_shr_v4hi (fold, last, x));\n       break;\n \n-    case V8QImode:\n+    case E_V8QImode:\n       emit_insn (gen_loongson_punpckhwd_qi (fold, last, last));\n \n       next = gen_reg_rtx (vmode);\n@@ -22008,10 +22008,10 @@ mips_expand_msa_cmp (rtx dest, enum rtx_code cond, rtx op0, rtx op1)\n \n   switch (cmp_mode)\n     {\n-    case V16QImode:\n-    case V8HImode:\n-    case V4SImode:\n-    case V2DImode:\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SImode:\n+    case E_V2DImode:\n       switch (cond)\n \t{\n \tcase NE:\n@@ -22039,8 +22039,8 @@ mips_expand_msa_cmp (rtx dest, enum rtx_code cond, rtx op0, rtx op1)\n \temit_move_insn (dest, gen_rtx_NOT (GET_MODE (dest), dest));\n       break;\n \n-    case V4SFmode:\n-    case V2DFmode:\n+    case E_V4SFmode:\n+    case E_V2DFmode:\n       switch (cond)\n \t{\n \tcase UNORDERED:"}, {"sha": "52326c9cd7fedb39372c81390905a7763331e0c0", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -6415,14 +6415,14 @@\n \n   switch (GET_MODE (diff_vec))\n     {\n-    case HImode:\n+    case E_HImode:\n       output_asm_insn (\"sll\\t%3,%0,1\", operands);\n       output_asm_insn (\"<d>la\\t%2,%1\", operands);\n       output_asm_insn (\"<d>addu\\t%3,%2,%3\", operands);\n       output_asm_insn (\"lh\\t%3,0(%3)\", operands);\n       break;\n \n-    case SImode:\n+    case E_SImode:\n       output_asm_insn (\"sll\\t%3,%0,2\", operands);\n       output_asm_insn (\"<d>la\\t%2,%1\", operands);\n       output_asm_insn (\"<d>addu\\t%3,%2,%3\", operands);"}, {"sha": "53adf33cb5fa8b232f784c15137bf0d44b27eb5f", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -279,18 +279,18 @@ mn10300_print_operand (FILE *file, rtx x, int code)\n \n \t    switch (GET_MODE (x))\n \t      {\n-\t      case DFmode:\n+\t      case E_DFmode:\n \t\tREAL_VALUE_TO_TARGET_DOUBLE\n \t\t  (*CONST_DOUBLE_REAL_VALUE (x), val);\n \t\tfprintf (file, \"0x%lx\", val[0]);\n \t\tbreak;;\n-\t      case SFmode:\n+\t      case E_SFmode:\n \t\tREAL_VALUE_TO_TARGET_SINGLE\n \t\t  (*CONST_DOUBLE_REAL_VALUE (x), val[0]);\n \t\tfprintf (file, \"0x%lx\", val[0]);\n \t\tbreak;;\n-\t      case VOIDmode:\n-\t      case DImode:\n+\t      case E_VOIDmode:\n+\t      case E_DImode:\n \t\tmn10300_print_operand_address (file,\n \t\t\t\t\t       GEN_INT (CONST_DOUBLE_LOW (x)));\n \t\tbreak;\n@@ -338,15 +338,15 @@ mn10300_print_operand (FILE *file, rtx x, int code)\n \n \t    switch (GET_MODE (x))\n \t      {\n-\t      case DFmode:\n+\t      case E_DFmode:\n \t\tREAL_VALUE_TO_TARGET_DOUBLE\n \t\t  (*CONST_DOUBLE_REAL_VALUE (x), val);\n \t\tfprintf (file, \"0x%lx\", val[1]);\n \t\tbreak;;\n-\t      case SFmode:\n+\t      case E_SFmode:\n \t\tgcc_unreachable ();\n-\t      case VOIDmode:\n-\t      case DImode:\n+\t      case E_VOIDmode:\n+\t      case E_DImode:\n \t\tmn10300_print_operand_address (file,\n \t\t\t\t\t       GEN_INT (CONST_DOUBLE_HIGH (x)));\n \t\tbreak;\n@@ -2672,13 +2672,13 @@ cc_flags_for_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case CCmode:\n+    case E_CCmode:\n       return CC_FLAG_Z | CC_FLAG_N | CC_FLAG_C | CC_FLAG_V;\n-    case CCZNCmode:\n+    case E_CCZNCmode:\n       return CC_FLAG_Z | CC_FLAG_N | CC_FLAG_C;\n-    case CCZNmode:\n+    case E_CCZNmode:\n       return CC_FLAG_Z | CC_FLAG_N;\n-    case CC_FLOATmode:\n+    case E_CC_FLOATmode:\n       return -1;\n     default:\n       gcc_unreachable ();"}, {"sha": "dc803e003e0f11876deda56850c407d392d84365", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -3547,10 +3547,10 @@ msp430_print_operand (FILE * file, rtx op, int letter)\n     case 'b':\n       switch (GET_MODE (op))\n \t{\n-\tcase QImode: fprintf (file, \".B\"); return;\n-\tcase HImode: fprintf (file, \".W\"); return;\n-\tcase PSImode: fprintf (file, \".A\"); return;\n-\tcase SImode: fprintf (file, \".A\"); return;\n+\tcase E_QImode: fprintf (file, \".B\"); return;\n+\tcase E_HImode: fprintf (file, \".W\"); return;\n+\tcase E_PSImode: fprintf (file, \".A\"); return;\n+\tcase E_SImode: fprintf (file, \".A\"); return;\n \tdefault:\n \t  return;\n \t}"}, {"sha": "d873900367fbcb5930c83b8452a639659925e1fc", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -114,21 +114,21 @@ nds32_mem_format (rtx op)\n \n       switch (mode_test)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  /* 333 format.  */\n \t  if (val >= 0 && val < 8 && regno < 8)\n \t    return ADDRESS_LO_REG_IMM3U;\n \t  break;\n \n-\tcase HImode:\n+\tcase E_HImode:\n \t  /* 333 format.  */\n \t  if (val >= 0 && val < 16 && (val % 2 == 0) && regno < 8)\n \t    return ADDRESS_LO_REG_IMM3U;\n \t  break;\n \n-\tcase SImode:\n-\tcase SFmode:\n-\tcase DFmode:\n+\tcase E_SImode:\n+\tcase E_SFmode:\n+\tcase E_DFmode:\n \t  /* fp imply 37 format.  */\n \t  if ((regno == FP_REGNUM) &&\n \t      (val >= 0 && val < 512 && (val % 4 == 0)))\n@@ -802,13 +802,13 @@ nds32_output_casesi_pc_relative (rtx *operands)\n      where m is 0, 1, or 2 to load address-diff value from table.  */\n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       output_asm_insn (\"lb\\t%2, [$ta + %0 << 0]\", operands);\n       break;\n-    case HImode:\n+    case E_HImode:\n       output_asm_insn (\"lh\\t%2, [$ta + %0 << 1]\", operands);\n       break;\n-    case SImode:\n+    case E_SImode:\n       output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n       break;\n     default:"}, {"sha": "5b970b76234ffd535efeb32e4878981a8ebc589b", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -897,13 +897,13 @@ enum reg_class\n     {                                                                   \\\n       switch (GET_MODE (body))                                          \\\n         {                                                               \\\n-        case QImode:                                                    \\\n+        case E_QImode:                                                    \\\n           asm_fprintf (stream, \"\\t.byte\\t.L%d-.L%d\\n\", value, rel);     \\\n           break;                                                        \\\n-        case HImode:                                                    \\\n+        case E_HImode:                                                    \\\n           asm_fprintf (stream, \"\\t.short\\t.L%d-.L%d\\n\", value, rel);    \\\n           break;                                                        \\\n-        case SImode:                                                    \\\n+        case E_SImode:                                                    \\\n           asm_fprintf (stream, \"\\t.word\\t.L%d-.L%d\\n\", value, rel);     \\\n           break;                                                        \\\n         default:                                                        \\"}, {"sha": "043d197d6a8d1c5666e32be6b8cd1198c03e4401", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -220,30 +220,30 @@ nvptx_ptx_type_from_mode (machine_mode mode, bool promote)\n {\n   switch (mode)\n     {\n-    case BLKmode:\n+    case E_BLKmode:\n       return \".b8\";\n-    case BImode:\n+    case E_BImode:\n       return \".pred\";\n-    case QImode:\n+    case E_QImode:\n       if (promote)\n \treturn \".u32\";\n       else\n \treturn \".u8\";\n-    case HImode:\n+    case E_HImode:\n       return \".u16\";\n-    case SImode:\n+    case E_SImode:\n       return \".u32\";\n-    case DImode:\n+    case E_DImode:\n       return \".u64\";\n \n-    case SFmode:\n+    case E_SFmode:\n       return \".f32\";\n-    case DFmode:\n+    case E_DFmode:\n       return \".f64\";\n \n-    case V2SImode:\n+    case E_V2SImode:\n       return \".v2.u32\";\n-    case V2DImode:\n+    case E_V2DImode:\n       return \".v2.u64\";\n \n     default:\n@@ -1638,10 +1638,10 @@ nvptx_gen_unpack (rtx dst0, rtx dst1, rtx src)\n   \n   switch (GET_MODE (src))\n     {\n-    case DImode:\n+    case E_DImode:\n       res = gen_unpackdisi2 (dst0, dst1, src);\n       break;\n-    case DFmode:\n+    case E_DFmode:\n       res = gen_unpackdfsi2 (dst0, dst1, src);\n       break;\n     default: gcc_unreachable ();\n@@ -1659,10 +1659,10 @@ nvptx_gen_pack (rtx dst, rtx src0, rtx src1)\n   \n   switch (GET_MODE (dst))\n     {\n-    case DImode:\n+    case E_DImode:\n       res = gen_packsidi2 (dst, src0, src1);\n       break;\n-    case DFmode:\n+    case E_DFmode:\n       res = gen_packsidf2 (dst, src0, src1);\n       break;\n     default: gcc_unreachable ();\n@@ -1680,14 +1680,14 @@ nvptx_gen_shuffle (rtx dst, rtx src, rtx idx, nvptx_shuffle_kind kind)\n \n   switch (GET_MODE (dst))\n     {\n-    case SImode:\n+    case E_SImode:\n       res = gen_nvptx_shufflesi (dst, src, idx, GEN_INT (kind));\n       break;\n-    case SFmode:\n+    case E_SFmode:\n       res = gen_nvptx_shufflesf (dst, src, idx, GEN_INT (kind));\n       break;\n-    case DImode:\n-    case DFmode:\n+    case E_DImode:\n+    case E_DFmode:\n       {\n \trtx tmp0 = gen_reg_rtx (SImode);\n \trtx tmp1 = gen_reg_rtx (SImode);\n@@ -1701,7 +1701,7 @@ nvptx_gen_shuffle (rtx dst, rtx src, rtx idx, nvptx_shuffle_kind kind)\n \tend_sequence ();\n       }\n       break;\n-    case BImode:\n+    case E_BImode:\n       {\n \trtx tmp = gen_reg_rtx (SImode);\n \t\n@@ -1713,8 +1713,8 @@ nvptx_gen_shuffle (rtx dst, rtx src, rtx idx, nvptx_shuffle_kind kind)\n \tend_sequence ();\n       }\n       break;\n-    case QImode:\n-    case HImode:\n+    case E_QImode:\n+    case E_HImode:\n       {\n \trtx tmp = gen_reg_rtx (SImode);\n \n@@ -1776,7 +1776,7 @@ nvptx_gen_wcast (rtx reg, propagate_mask pm, unsigned rep, wcast_data_t *data)\n \n   switch (mode)\n     {\n-    case BImode:\n+    case E_BImode:\n       {\n \trtx tmp = gen_reg_rtx (SImode);\n \t\n@@ -5490,9 +5490,9 @@ nvptx_preferred_simd_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       return V2DImode;\n-    case SImode:\n+    case E_SImode:\n       return V2SImode;\n \n     default:"}, {"sha": "c6af3736e7560efe59022cca9b613f3269865edd", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -6067,19 +6067,19 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n     {\n       switch (mode)\n \t{\n-\tcase SImode:\n+\tcase E_SImode:\n \t  sri->icode = CODE_FOR_reload_insi_r1;\n \t  break;\n \n-\tcase DImode:\n+\tcase E_DImode:\n \t  sri->icode = CODE_FOR_reload_indi_r1;\n \t  break;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  sri->icode = CODE_FOR_reload_insf_r1;\n \t  break;\n \n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  sri->icode = CODE_FOR_reload_indf_r1;\n \t  break;\n \n@@ -6101,11 +6101,11 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t{\n \t  switch (mode)\n \t    {\n-\t    case SImode:\n+\t    case E_SImode:\n \t      sri->icode = CODE_FOR_reload_insi_r1;\n \t      break;\n \n-\t    case DImode:\n+\t    case E_DImode:\n \t      sri->icode = CODE_FOR_reload_indi_r1;\n \t      break;\n "}, {"sha": "d69cf04d9d86d00d1c87699a25993c4894c15daf", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -272,9 +272,9 @@\n      assumed in the instruction encoding.  */\n   switch (mode)\n     {\n-    case BLKmode:\n-    case QImode:\n-    case HImode:\n+    case E_BLKmode:\n+    case E_QImode:\n+    case E_HImode:\n       return true;\n \n     default:"}, {"sha": "0da84adcaadecd47ef78c8fac2698c4203d97892", "filename": "gcc/config/powerpcspe/powerpcspe-c.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -5687,23 +5687,23 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \n       switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n \t{\n-\t  case QImode:\n-\t  case HImode:\n-\t  case SImode:\n-\t  case DImode:\n-\t  case TImode:\n+\t  case E_QImode:\n+\t  case E_HImode:\n+\t  case E_SImode:\n+\t  case E_DImode:\n+\t  case E_TImode:\n \t    {\n \t      /* For scalar types just use a multiply expression.  */\n \t      return fold_build2_loc (loc, MULT_EXPR, TREE_TYPE (arg0), arg0,\n \t\t\t\t      fold_convert (TREE_TYPE (arg0), arg1));\n \t    }\n-\t  case SFmode:\n+\t  case E_SFmode:\n \t    {\n \t      /* For floats use the xvmulsp instruction directly.  */\n \t      tree call = rs6000_builtin_decls[VSX_BUILTIN_XVMULSP];\n \t      return build_call_expr (call, 2, arg0, arg1);\n \t    }\n-\t  case DFmode:\n+\t  case E_DFmode:\n \t    {\n \t      /* For doubles use the xvmuldp instruction directly.  */\n \t      tree call = rs6000_builtin_decls[VSX_BUILTIN_XVMULDP];\n@@ -5751,13 +5751,13 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t vec_cmpeq (va, vb)).  */\n \t      /* Note:  vec_nand also works but opt changes vec_nand's\n \t\t to vec_nor's anyway.  */\n-\t    case QImode:\n-\t    case HImode:\n-\t    case SImode:\n-\t    case DImode:\n-\t    case TImode:\n-\t    case SFmode:\n-\t    case DFmode:\n+\t    case E_QImode:\n+\t    case E_HImode:\n+\t    case E_SImode:\n+\t    case E_DImode:\n+\t    case E_TImode:\n+\t    case E_SFmode:\n+\t    case E_DFmode:\n \t      {\n \t\t/* call = vec_cmpeq (va, vb)\n \t\t   result = vec_nor (call, call).  */\n@@ -5815,7 +5815,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  /* For {un}signed ints,\n \t     vec_adde (va, vb, carryv) == vec_add (vec_add (va, vb),\n \t\t\t\t\t\t   vec_and (carryv, 0x1)).  */\n-\t  case SImode:\n+\t  case E_SImode:\n \t    {\n \t      vec<tree, va_gc> *params = make_tree_vector ();\n \t      vec_safe_push (params, arg0);\n@@ -5835,7 +5835,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    }\n \t  /* For {un}signed __int128s use the vaddeuqm instruction\n \t\tdirectly.  */\n-\t  case TImode:\n+\t  case E_TImode:\n \t    {\n \t      tree adde_bii = rs6000_builtin_decls[P8V_BUILTIN_VEC_VADDEUQM];\n \t      return altivec_resolve_overloaded_builtin (loc, adde_bii,\n@@ -5881,7 +5881,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\tvec_or (vec_addc (va, vb),\n \t\t\t\t\tvec_addc (vec_add (va, vb),\n \t\t\t\t\t\t  vec_and (carryv, 0x1))).  */\n-\t  case SImode:\n+\t  case E_SImode:\n \t    {\n \t    /* Use save_expr to ensure that operands used more than once\n \t\tthat may have side effects (like calls) are only evaluated\n@@ -5917,7 +5917,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\t\t\t       params);\n \t    }\n \t  /* For {un}signed __int128s use the vaddecuq instruction.  */\n-\t  case TImode:\n+\t  case E_TImode:\n \t    {\n \t    tree VADDECUQ_bii = rs6000_builtin_decls[P8V_BUILTIN_VEC_VADDECUQ];\n \t    return altivec_resolve_overloaded_builtin (loc, VADDECUQ_bii,\n@@ -5969,28 +5969,28 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       unsigned_p = TYPE_UNSIGNED (type);\n       switch (TYPE_MODE (type))\n \t{\n-\t  case TImode:\n+\t  case E_TImode:\n \t    type = (unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node);\n \t    size = 1;\n \t    break;\n-\t  case DImode:\n+\t  case E_DImode:\n \t    type = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n \t    size = 2;\n \t    break;\n-\t  case SImode:\n+\t  case E_SImode:\n \t    type = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n \t    size = 4;\n \t    break;\n-\t  case HImode:\n+\t  case E_HImode:\n \t    type = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n \t    size = 8;\n \t    break;\n-\t  case QImode:\n+\t  case E_QImode:\n \t    type = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n \t    size = 16;\n \t    break;\n-\t  case SFmode: type = V4SF_type_node; size = 4; break;\n-\t  case DFmode: type = V2DF_type_node; size = 2; break;\n+\t  case E_SFmode: type = V4SF_type_node; size = 4; break;\n+\t  case E_DFmode: type = V2DF_type_node; size = 2; break;\n \t  default:\n \t    goto bad;\n \t}\n@@ -6062,33 +6062,33 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase V1TImode:\n+\t\tcase E_V1TImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V1TI];\n \t\t  break;\n \n-\t\tcase V2DFmode:\n+\t\tcase E_V2DFmode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n \t\t  break;\n \n-\t\tcase V2DImode:\n+\t\tcase E_V2DImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n \t\t  break;\n \n-\t\tcase V4SFmode:\n+\t\tcase E_V4SFmode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n \t\t  break;\n \n-\t\tcase V4SImode:\n+\t\tcase E_V4SImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n \t\t  break;\n \n-\t\tcase V8HImode:\n+\t\tcase E_V8HImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n \t\t  break;\n \n-\t\tcase V16QImode:\n+\t\tcase E_V16QImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n \t\t  break;\n@@ -6104,27 +6104,27 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase V2DFmode:\n+\t\tcase E_V2DFmode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n \t\t  break;\n \n-\t\tcase V2DImode:\n+\t\tcase E_V2DImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n \t\t  break;\n \n-\t\tcase V4SFmode:\n+\t\tcase E_V4SFmode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n \t\t  break;\n \n-\t\tcase V4SImode:\n+\t\tcase E_V4SImode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n \t\t  break;\n \n-\t\tcase V8HImode:\n+\t\tcase E_V8HImode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n \t\t  break;\n \n-\t\tcase V16QImode:\n+\t\tcase E_V16QImode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n \t\t  break;\n \t\t}"}, {"sha": "a104b4ce697c531e8574fdd110f9554e05d61515", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 233, "deletions": 233, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -2963,13 +2963,13 @@ rs6000_setup_reg_addr_masks (void)\n \t\t      addr_mask |= RELOAD_REG_PRE_MODIFY;\n \t\t      break;\n \n-\t\t    case DImode:\n+\t\t    case E_DImode:\n \t\t      if (TARGET_POWERPC64)\n \t\t\taddr_mask |= RELOAD_REG_PRE_MODIFY;\n \t\t      break;\n \n-\t\t    case DFmode:\n-\t\t    case DDmode:\n+\t\t    case E_DFmode:\n+\t\t    case E_DDmode:\n \t\t      if (TARGET_DF_INSN)\n \t\t\taddr_mask |= RELOAD_REG_PRE_MODIFY;\n \t\t      break;\n@@ -5883,33 +5883,33 @@ rs6000_preferred_simd_mode (machine_mode mode)\n   if (TARGET_VSX)\n     switch (mode)\n       {\n-      case DFmode:\n+      case E_DFmode:\n \treturn V2DFmode;\n       default:;\n       }\n   if (TARGET_ALTIVEC || TARGET_VSX)\n     switch (mode)\n       {\n-      case SFmode:\n+      case E_SFmode:\n \treturn V4SFmode;\n-      case TImode:\n+      case E_TImode:\n \treturn V1TImode;\n-      case DImode:\n+      case E_DImode:\n \treturn V2DImode;\n-      case SImode:\n+      case E_SImode:\n \treturn V4SImode;\n-      case HImode:\n+      case E_HImode:\n \treturn V8HImode;\n-      case QImode:\n+      case E_QImode:\n \treturn V16QImode;\n       default:;\n       }\n   if (TARGET_SPE)\n     switch (mode)\n       {\n-      case SFmode:\n+      case E_SFmode:\n \treturn V2SFmode;\n-      case SImode:\n+      case E_SImode:\n \treturn V2SImode;\n       default:;\n       }\n@@ -7095,13 +7095,13 @@ output_vec_const_move (rtx *operands)\n \n       switch (GET_MODE (splat_vec))\n \t{\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  return \"vspltisw %0,%1\";\n \n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  return \"vspltish %0,%1\";\n \n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  return \"vspltisb %0,%1\";\n \n \tdefault:\n@@ -7669,36 +7669,36 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \t{\n \tdefault:\n \t  break;\n-\tcase V1TImode:\n+\tcase E_V1TImode:\n \t  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);\n \t  emit_move_insn (target, gen_lowpart (TImode, vec));\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_vsx_extract_v2df (target, vec, elt));\n \t  return;\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_vsx_extract_v2di (target, vec, elt));\n \t  return;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  emit_insn (gen_vsx_extract_v4sf (target, vec, elt));\n \t  return;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v16qi (target, vec, elt));\n \t      return;\n \t    }\n \t  else\n \t    break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v8hi (target, vec, elt));\n \t      return;\n \t    }\n \t  else\n \t    break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v4si (target, vec, elt));\n@@ -7721,27 +7721,27 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \n       switch (mode)\n \t{\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));\n \t  return;\n \n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_vsx_extract_v2di_var (target, vec, elt));\n \t  return;\n \n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  emit_insn (gen_vsx_extract_v4sf_var (target, vec, elt));\n \t  return;\n \n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  emit_insn (gen_vsx_extract_v4si_var (target, vec, elt));\n \t  return;\n \n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  emit_insn (gen_vsx_extract_v8hi_var (target, vec, elt));\n \t  return;\n \n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  emit_insn (gen_vsx_extract_v16qi_var (target, vec, elt));\n \t  return;\n \n@@ -8065,15 +8065,15 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n       /* Do the VSLO to get the value into the final location.  */\n       switch (mode)\n \t{\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_vsx_vslo_v2df (dest, src, tmp_altivec));\n \t  return;\n \n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_vsx_vslo_v2di (dest, src, tmp_altivec));\n \t  return;\n \n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  {\n \t    rtx tmp_altivec_di = gen_rtx_REG (DImode, REGNO (tmp_altivec));\n \t    rtx tmp_altivec_v4sf = gen_rtx_REG (V4SFmode, REGNO (tmp_altivec));\n@@ -8085,9 +8085,9 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n \t    return;\n \t  }\n \n-\tcase V4SImode:\n-\tcase V8HImode:\n-\tcase V16QImode:\n+\tcase E_V4SImode:\n+\tcase E_V8HImode:\n+\tcase E_V16QImode:\n \t  {\n \t    rtx tmp_altivec_di = gen_rtx_REG (DImode, REGNO (tmp_altivec));\n \t    rtx src_v2di = gen_rtx_REG (V2DImode, REGNO (src));\n@@ -8652,16 +8652,16 @@ reg_offset_addressing_ok_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V16QImode:\n-    case V8HImode:\n-    case V4SFmode:\n-    case V4SImode:\n-    case V2DFmode:\n-    case V2DImode:\n-    case V1TImode:\n-    case TImode:\n-    case TFmode:\n-    case KFmode:\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n+    case E_V1TImode:\n+    case E_TImode:\n+    case E_TFmode:\n+    case E_KFmode:\n       /* AltiVec/VSX vector modes.  Only reg+reg addressing was valid until the\n \t ISA 3.0 vector d-form addressing mode was added.  While TImode is not\n \t a vector mode, if we want to use the VSX registers to move it around,\n@@ -8672,16 +8672,16 @@ reg_offset_addressing_ok_p (machine_mode mode)\n \treturn mode_supports_vsx_dform_quad (mode);\n       break;\n \n-    case V4HImode:\n-    case V2SImode:\n-    case V1DImode:\n-    case V2SFmode:\n+    case E_V4HImode:\n+    case E_V2SImode:\n+    case E_V1DImode:\n+    case E_V2SFmode:\n        /* Paired vector modes.  Only reg+reg addressing is valid.  */\n       if (TARGET_PAIRED_FLOAT)\n         return false;\n       break;\n \n-    case SDmode:\n+    case E_SDmode:\n       /* If we can do direct load/stores of SDmode, restrict it to reg+reg\n \t addressing for the LFIWZX and STFIWX instructions.  */\n       if (TARGET_NO_SDMODE_STACK)\n@@ -8912,16 +8912,16 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n   extra = 0;\n   switch (mode)\n     {\n-    case V4HImode:\n-    case V2SImode:\n-    case V1DImode:\n-    case V2SFmode:\n+    case E_V4HImode:\n+    case E_V2SImode:\n+    case E_V1DImode:\n+    case E_V2SFmode:\n       /* SPE vector modes.  */\n       return SPE_CONST_OFFSET_OK (offset);\n \n-    case DFmode:\n-    case DDmode:\n-    case DImode:\n+    case E_DFmode:\n+    case E_DDmode:\n+    case E_DImode:\n       /* On e500v2, we may have:\n \n \t   (subreg:DF (mem:DI (plus (reg) (const_int))) 0).\n@@ -8943,12 +8943,12 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n \treturn false;\n       break;\n \n-    case TFmode:\n-    case IFmode:\n-    case KFmode:\n-    case TDmode:\n-    case TImode:\n-    case PTImode:\n+    case E_TFmode:\n+    case E_IFmode:\n+    case E_KFmode:\n+    case E_TDmode:\n+    case E_TImode:\n+    case E_PTImode:\n       if (TARGET_E500_DOUBLE)\n \treturn (SPE_CONST_OFFSET_OK (offset)\n \t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n@@ -9138,12 +9138,12 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   extra = 0;\n   switch (mode)\n     {\n-    case TFmode:\n-    case TDmode:\n-    case TImode:\n-    case PTImode:\n-    case IFmode:\n-    case KFmode:\n+    case E_TFmode:\n+    case E_TDmode:\n+    case E_TImode:\n+    case E_PTImode:\n+    case E_IFmode:\n+    case E_KFmode:\n       /* As in legitimate_offset_address_p we do not assume\n \t worst-case.  The mode here is just a hint as to the registers\n \t used.  A TImode is usually in gprs, but may actually be in\n@@ -10519,12 +10519,12 @@ rs6000_emit_set_const (rtx dest, rtx source)\n   c = INTVAL (source);\n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n+    case E_QImode:\n+    case E_HImode:\n       emit_insn (gen_rtx_SET (dest, source));\n       return true;\n \n-    case SImode:\n+    case E_SImode:\n       temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (SImode);\n \n       emit_insn (gen_rtx_SET (copy_rtx (temp),\n@@ -10534,7 +10534,7 @@ rs6000_emit_set_const (rtx dest, rtx source)\n \t\t\t\t\t   GEN_INT (c & 0xffff))));\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \t{\n \t  rtx hi, lo;\n@@ -10693,21 +10693,21 @@ rs6000_const_vec (machine_mode mode)\n \n   switch (mode)\n     {\n-    case V1TImode:\n+    case E_V1TImode:\n       subparts = 1;\n       break;\n-    case V2DFmode:\n-    case V2DImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n       subparts = 2;\n       break;\n-    case V4SFmode:\n-    case V4SImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n       subparts = 4;\n       break;\n-    case V8HImode:\n+    case E_V8HImode:\n       subparts = 8;\n       break;\n-    case V16QImode:\n+    case E_V16QImode:\n       subparts = 16;\n       break;\n     default:\n@@ -11174,48 +11174,48 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n      mode == Pmode.  */\n   switch (mode)\n     {\n-    case HImode:\n-    case QImode:\n+    case E_HImode:\n+    case E_QImode:\n       if (CONSTANT_P (operands[1])\n \t  && GET_CODE (operands[1]) != CONST_INT)\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n-    case TFmode:\n-    case TDmode:\n-    case IFmode:\n-    case KFmode:\n+    case E_TFmode:\n+    case E_TDmode:\n+    case E_IFmode:\n+    case E_KFmode:\n       if (FLOAT128_2REG_P (mode))\n \trs6000_eliminate_indexed_memrefs (operands);\n       /* fall through */\n \n-    case DFmode:\n-    case DDmode:\n-    case SFmode:\n-    case SDmode:\n+    case E_DFmode:\n+    case E_DDmode:\n+    case E_SFmode:\n+    case E_SDmode:\n       if (CONSTANT_P (operands[1])\n \t  && ! easy_fp_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n-    case V16QImode:\n-    case V8HImode:\n-    case V4SFmode:\n-    case V4SImode:\n-    case V4HImode:\n-    case V2SFmode:\n-    case V2SImode:\n-    case V1DImode:\n-    case V2DFmode:\n-    case V2DImode:\n-    case V1TImode:\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n+    case E_V4HImode:\n+    case E_V2SFmode:\n+    case E_V2SImode:\n+    case E_V1DImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n+    case E_V1TImode:\n       if (CONSTANT_P (operands[1])\n \t  && !easy_vector_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n-    case SImode:\n-    case DImode:\n+    case E_SImode:\n+    case E_DImode:\n       /* Use default pattern for address of ELF small data */\n       if (TARGET_ELF\n \t  && mode == Pmode\n@@ -11362,12 +11362,12 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t}\n       break;\n \n-    case TImode:\n+    case E_TImode:\n       if (!VECTOR_MEM_VSX_P (TImode))\n \trs6000_eliminate_indexed_memrefs (operands);\n       break;\n \n-    case PTImode:\n+    case E_PTImode:\n       rs6000_eliminate_indexed_memrefs (operands);\n       break;\n \n@@ -12525,20 +12525,20 @@ spe_build_register_parallel (machine_mode mode, int gregno)\n \n   switch (mode)\n     {\n-    case DFmode:\n+    case E_DFmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       return gen_rtx_PARALLEL (mode, gen_rtvec (1, r1));\n \n-    case DCmode:\n-    case TFmode:\n+    case E_DCmode:\n+    case E_TFmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       r3 = gen_rtx_REG (DImode, gregno + 2);\n       r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n       return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r3));\n \n-    case TCmode:\n+    case E_TCmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       r3 = gen_rtx_REG (DImode, gregno + 2);\n@@ -12711,9 +12711,9 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, const_tree type,\n #if 0\n \t    switch (mode)\n \t      {\n-\t      case SCmode: mode = SFmode; break;\n-\t      case DCmode: mode = DFmode; break;\n-\t      case TCmode: mode = TFmode; break;\n+\t      case E_SCmode: mode = SFmode; break;\n+\t      case E_DCmode: mode = DFmode; break;\n+\t      case E_TCmode: mode = TFmode; break;\n \t      default: break;\n \t      }\n #endif\n@@ -15013,18 +15013,18 @@ swap_selector_for_mode (machine_mode mode)\n \n   switch (mode)\n     {\n-    case V2DFmode:\n-    case V2DImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n       swaparray = swap2;\n       break;\n-    case V4SFmode:\n-    case V4SImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n       swaparray = swap4;\n       break;\n-    case V8HImode:\n+    case E_V8HImode:\n       swaparray = swap8;\n       break;\n-    case V16QImode:\n+    case E_V16QImode:\n       swaparray = swap16;\n       break;\n     default:\n@@ -18049,10 +18049,10 @@ spe_init_builtins (void)\n       gcc_assert (d->icode != CODE_FOR_nothing);\n       switch (insn_data[d->icode].operand[1].mode)\n \t{\n-\tcase V2SImode:\n+\tcase E_V2SImode:\n \t  type = int_ftype_int_v2si_v2si;\n \t  break;\n-\tcase V2SFmode:\n+\tcase E_V2SFmode:\n \t  type = int_ftype_int_v2sf_v2sf;\n \t  break;\n \tdefault:\n@@ -18081,10 +18081,10 @@ spe_init_builtins (void)\n       gcc_assert (d->icode != CODE_FOR_nothing);\n       switch (insn_data[d->icode].operand[1].mode)\n \t{\n-\tcase V2SImode:\n+\tcase E_V2SImode:\n \t  type = v2si_ftype_4_v2si;\n \t  break;\n-\tcase V2SFmode:\n+\tcase E_V2SFmode:\n \t  type = v2sf_ftype_4_v2sf;\n \t  break;\n \tdefault:\n@@ -18156,7 +18156,7 @@ paired_init_builtins (void)\n \n       switch (insn_data[d->icode].operand[1].mode)\n \t{\n-\tcase V2SFmode:\n+\tcase E_V2SFmode:\n \t  type = int_ftype_int_v2sf_v2sf;\n \t  break;\n \tdefault:\n@@ -18568,25 +18568,25 @@ altivec_init_builtins (void)\n \n       switch (mode1)\n \t{\n-\tcase VOIDmode:\n+\tcase E_VOIDmode:\n \t  type = int_ftype_int_opaque_opaque;\n \t  break;\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  type = int_ftype_int_v2di_v2di;\n \t  break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  type = int_ftype_int_v4si_v4si;\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  type = int_ftype_int_v8hi_v8hi;\n \t  break;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  type = int_ftype_int_v16qi_v16qi;\n \t  break;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  type = int_ftype_int_v4sf_v4sf;\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  type = int_ftype_int_v2df_v2df;\n \t  break;\n \tdefault:\n@@ -18618,22 +18618,22 @@ altivec_init_builtins (void)\n \n       switch (mode0)\n \t{\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  type = v2di_ftype_v2di;\n \t  break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  type = v4si_ftype_v4si;\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  type = v8hi_ftype_v8hi;\n \t  break;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  type = v16qi_ftype_v16qi;\n \t  break;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  type = v4sf_ftype_v4sf;\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  type = v2df_ftype_v2df;\n \t  break;\n \tdefault:\n@@ -19727,13 +19727,13 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n {\n   switch (GET_MODE (reg))\n     {\n-    case DImode:\n+    case E_DImode:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  emit_insn (gen_zero_extendqidi2 (reg, mem));\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  {\n \t    rtx src = mem;\n \t    if (!BYTES_BIG_ENDIAN)\n@@ -19744,7 +19744,7 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t    emit_insn (gen_zero_extendhidi2 (reg, src));\n \t    break;\n \t  }\n-\tcase SImode:\n+\tcase E_SImode:\n \t  {\n \t    rtx src = mem;\n \t    if (!BYTES_BIG_ENDIAN)\n@@ -19755,7 +19755,7 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t    emit_insn (gen_zero_extendsidi2 (reg, src));\n \t  }\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  if (!BYTES_BIG_ENDIAN)\n \t    emit_insn (gen_bswapdi2 (reg, mem));\n \t  else\n@@ -19766,13 +19766,13 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t}\n       break;\n \n-    case SImode:\n+    case E_SImode:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  emit_insn (gen_zero_extendqisi2 (reg, mem));\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  {\n \t    rtx src = mem;\n \t    if (!BYTES_BIG_ENDIAN)\n@@ -19783,13 +19783,13 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t    emit_insn (gen_zero_extendhisi2 (reg, src));\n \t    break;\n \t  }\n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (!BYTES_BIG_ENDIAN)\n \t    emit_insn (gen_bswapsi2 (reg, mem));\n \t  else\n \t    emit_insn (gen_movsi (reg, mem));\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  /* DImode is larger than the destination reg so is not expected.  */\n \t  gcc_unreachable ();\n \t  break;\n@@ -24526,21 +24526,21 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \tcase EQ:\n \t  switch (op_mode)\n \t    {\n-\t    case SFmode:\n+\t    case E_SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstsfeq_gpr (compare_result, op0, op1)\n \t\t: gen_cmpsfeq_gpr (compare_result, op0, op1);\n \t      break;\n \n-\t    case DFmode:\n+\t    case E_DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstdfeq_gpr (compare_result, op0, op1)\n \t\t: gen_cmpdfeq_gpr (compare_result, op0, op1);\n \t      break;\n \n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n+\t    case E_TFmode:\n+\t    case E_IFmode:\n+\t    case E_KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttfeq_gpr (compare_result, op0, op1)\n \t\t: gen_cmptfeq_gpr (compare_result, op0, op1);\n@@ -24555,21 +24555,21 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \tcase GE:\n \t  switch (op_mode)\n \t    {\n-\t    case SFmode:\n+\t    case E_SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstsfgt_gpr (compare_result, op0, op1)\n \t\t: gen_cmpsfgt_gpr (compare_result, op0, op1);\n \t      break;\n \n-\t    case DFmode:\n+\t    case E_DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstdfgt_gpr (compare_result, op0, op1)\n \t\t: gen_cmpdfgt_gpr (compare_result, op0, op1);\n \t      break;\n \n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n+\t    case E_TFmode:\n+\t    case E_IFmode:\n+\t    case E_KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttfgt_gpr (compare_result, op0, op1)\n \t\t: gen_cmptfgt_gpr (compare_result, op0, op1);\n@@ -24584,21 +24584,21 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \tcase LE:\n \t  switch (op_mode)\n \t    {\n-\t    case SFmode:\n+\t    case E_SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstsflt_gpr (compare_result, op0, op1)\n \t\t: gen_cmpsflt_gpr (compare_result, op0, op1);\n \t      break;\n \n-\t    case DFmode:\n+\t    case E_DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstdflt_gpr (compare_result, op0, op1)\n \t\t: gen_cmpdflt_gpr (compare_result, op0, op1);\n \t      break;\n \n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n+\t    case E_TFmode:\n+\t    case E_IFmode:\n+\t    case E_KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttflt_gpr (compare_result, op0, op1)\n \t\t: gen_cmptflt_gpr (compare_result, op0, op1);\n@@ -24623,21 +24623,21 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t  /* Do the EQ.  */\n \t  switch (op_mode)\n \t    {\n-\t    case SFmode:\n+\t    case E_SFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstsfeq_gpr (compare_result2, op0, op1)\n \t\t: gen_cmpsfeq_gpr (compare_result2, op0, op1);\n \t      break;\n \n-\t    case DFmode:\n+\t    case E_DFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tstdfeq_gpr (compare_result2, op0, op1)\n \t\t: gen_cmpdfeq_gpr (compare_result2, op0, op1);\n \t      break;\n \n-\t    case TFmode:\n-\t    case IFmode:\n-\t    case KFmode:\n+\t    case E_TFmode:\n+\t    case E_IFmode:\n+\t    case E_KFmode:\n \t      cmp = (flag_finite_math_only && !flag_trapping_math)\n \t\t? gen_tsttfeq_gpr (compare_result2, op0, op1)\n \t\t: gen_cmptfeq_gpr (compare_result2, op0, op1);\n@@ -24989,26 +24989,26 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \n       switch (src_mode)\n \t{\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  cvt = sext_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].from_df;\n \t  break;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  cvt = sext_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].from_sf;\n \t  break;\n \n-\tcase KFmode:\n-\tcase IFmode:\n-\tcase TFmode:\n+\tcase E_KFmode:\n+\tcase E_IFmode:\n+\tcase E_TFmode:\n \t  if (FLOAT128_IBM_P (src_mode))\n \t    cvt = sext_optab;\n \t  else\n \t    do_move = true;\n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufloat_optab;\n@@ -25021,7 +25021,7 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \t    }\n \t  break;\n \n-\tcase DImode:\n+\tcase E_DImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufloat_optab;\n@@ -25051,26 +25051,26 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \n       switch (dest_mode)\n \t{\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  cvt = trunc_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].to_df;\n \t  break;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  cvt = trunc_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].to_sf;\n \t  break;\n \n-\tcase KFmode:\n-\tcase IFmode:\n-\tcase TFmode:\n+\tcase E_KFmode:\n+\tcase E_IFmode:\n+\tcase E_TFmode:\n \t  if (FLOAT128_IBM_P (dest_mode))\n \t    cvt = trunc_optab;\n \t  else\n \t    do_move = true;\n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufix_optab;\n@@ -25083,7 +25083,7 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \t    }\n \t  break;\n \n-\tcase DImode:\n+\tcase E_DImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufix_optab;\n@@ -26141,24 +26141,24 @@ emit_load_locked (machine_mode mode, rtx reg, rtx mem)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       fn = gen_load_lockedqi;\n       break;\n-    case HImode:\n+    case E_HImode:\n       fn = gen_load_lockedhi;\n       break;\n-    case SImode:\n+    case E_SImode:\n       if (GET_MODE (mem) == QImode)\n \tfn = gen_load_lockedqi_si;\n       else if (GET_MODE (mem) == HImode)\n \tfn = gen_load_lockedhi_si;\n       else\n \tfn = gen_load_lockedsi;\n       break;\n-    case DImode:\n+    case E_DImode:\n       fn = gen_load_lockeddi;\n       break;\n-    case TImode:\n+    case E_TImode:\n       fn = gen_load_lockedti;\n       break;\n     default:\n@@ -26177,19 +26177,19 @@ emit_store_conditional (machine_mode mode, rtx res, rtx mem, rtx val)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       fn = gen_store_conditionalqi;\n       break;\n-    case HImode:\n+    case E_HImode:\n       fn = gen_store_conditionalhi;\n       break;\n-    case SImode:\n+    case E_SImode:\n       fn = gen_store_conditionalsi;\n       break;\n-    case DImode:\n+    case E_DImode:\n       fn = gen_store_conditionaldi;\n       break;\n-    case TImode:\n+    case E_TImode:\n       fn = gen_store_conditionalti;\n       break;\n     default:\n@@ -31997,17 +31997,17 @@ rs6000_output_function_epilogue (FILE *file)\n \n \t\t      switch (mode)\n \t\t\t{\n-\t\t\tcase SFmode:\n-\t\t\tcase SDmode:\n+\t\t\tcase E_SFmode:\n+\t\t\tcase E_SDmode:\n \t\t\t  bits = 0x2;\n \t\t\t  break;\n \n-\t\t\tcase DFmode:\n-\t\t\tcase DDmode:\n-\t\t\tcase TFmode:\n-\t\t\tcase TDmode:\n-\t\t\tcase IFmode:\n-\t\t\tcase KFmode:\n+\t\t\tcase E_DFmode:\n+\t\t\tcase E_DDmode:\n+\t\t\tcase E_TFmode:\n+\t\t\tcase E_TDmode:\n+\t\t\tcase E_IFmode:\n+\t\t\tcase E_KFmode:\n \t\t\t  bits = 0x3;\n \t\t\t  break;\n \n@@ -35552,46 +35552,46 @@ rs6000_handle_altivec_attribute (tree *node,\n       unsigned_p = TYPE_UNSIGNED (type);\n       switch (mode)\n \t{\n-\tcase TImode:\n+\tcase E_TImode:\n \t  result = (unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node);\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  result = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n \t  break;\n-\tcase SImode:\n+\tcase E_SImode:\n \t  result = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  result = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n \t  break;\n-\tcase QImode:\n+\tcase E_QImode:\n \t  result = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n \t  break;\n-\tcase SFmode: result = V4SF_type_node; break;\n-\tcase DFmode: result = V2DF_type_node; break;\n+\tcase E_SFmode: result = V4SF_type_node; break;\n+\tcase E_DFmode: result = V2DF_type_node; break;\n \t  /* If the user says 'vector int bool', we may be handed the 'bool'\n \t     attribute _before_ the 'vector' attribute, and so select the\n \t     proper type in the 'b' case below.  */\n-\tcase V4SImode: case V8HImode: case V16QImode: case V4SFmode:\n-\tcase V2DImode: case V2DFmode:\n+\tcase E_V4SImode: case E_V8HImode: case E_V16QImode: case E_V4SFmode:\n+\tcase E_V2DImode: case E_V2DFmode:\n \t  result = type;\n \tdefault: break;\n \t}\n       break;\n     case 'b':\n       switch (mode)\n \t{\n-\tcase DImode: case V2DImode: result = bool_V2DI_type_node; break;\n-\tcase SImode: case V4SImode: result = bool_V4SI_type_node; break;\n-\tcase HImode: case V8HImode: result = bool_V8HI_type_node; break;\n-\tcase QImode: case V16QImode: result = bool_V16QI_type_node;\n+\tcase E_DImode: case E_V2DImode: result = bool_V2DI_type_node; break;\n+\tcase E_SImode: case E_V4SImode: result = bool_V4SI_type_node; break;\n+\tcase E_HImode: case E_V8HImode: result = bool_V8HI_type_node; break;\n+\tcase E_QImode: case E_V16QImode: result = bool_V16QI_type_node;\n \tdefault: break;\n \t}\n       break;\n     case 'p':\n       switch (mode)\n \t{\n-\tcase V8HImode: result = pixel_V8HI_type_node;\n+\tcase E_V8HImode: result = pixel_V8HI_type_node;\n \tdefault: break;\n \t}\n     default: break;\n@@ -38850,10 +38850,10 @@ rs6000_function_value (const_tree valtype,\n       {\n       default:\n \tbreak;\n-      case DImode:\n-      case SCmode:\n-      case DCmode:\n-      case TCmode:\n+      case E_DImode:\n+      case E_SCmode:\n+      case E_DCmode:\n+      case E_TCmode:\n \tint count = GET_MODE_SIZE (mode) / 4;\n \treturn rs6000_parallel_return (mode, count, SImode, GP_ARG_RETURN, 1);\n       }\n@@ -41234,24 +41234,24 @@ emit_fusion_gpr_load (rtx target, rtx mem)\n   mode = GET_MODE (mem);\n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       mode_name = \"char\";\n       load_str = \"lbz\";\n       break;\n \n-    case HImode:\n+    case E_HImode:\n       mode_name = \"short\";\n       load_str = \"lhz\";\n       break;\n \n-    case SImode:\n-    case SFmode:\n+    case E_SImode:\n+    case E_SFmode:\n       mode_name = (mode == SFmode) ? \"float\" : \"int\";\n       load_str = \"lwz\";\n       break;\n \n-    case DImode:\n-    case DFmode:\n+    case E_DImode:\n+    case E_DFmode:\n       gcc_assert (TARGET_POWERPC64);\n       mode_name = (mode == DFmode) ? \"double\" : \"long\";\n       load_str = \"ld\";\n@@ -41501,18 +41501,18 @@ emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n     {\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  load_string = \"lbz\";\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  load_string = \"lhz\";\n \t  break;\n-\tcase SImode:\n-\tcase SFmode:\n+\tcase E_SImode:\n+\tcase E_SFmode:\n \t  load_string = \"lwz\";\n \t  break;\n-\tcase DImode:\n-\tcase DFmode:\n+\tcase E_DImode:\n+\tcase E_DFmode:\n \t  if (!TARGET_POWERPC64)\n \t    gcc_unreachable ();\n \t  load_string = \"ld\";\n@@ -41588,18 +41588,18 @@ emit_fusion_p9_store (rtx mem, rtx reg, rtx tmp_reg)\n     {\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  store_string = \"stb\";\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  store_string = \"sth\";\n \t  break;\n-\tcase SImode:\n-\tcase SFmode:\n+\tcase E_SImode:\n+\tcase E_SFmode:\n \t  store_string = \"stw\";\n \t  break;\n-\tcase DImode:\n-\tcase DFmode:\n+\tcase E_DImode:\n+\tcase E_DFmode:\n \t  if (!TARGET_POWERPC64)\n \t    gcc_unreachable ();\n \t  store_string = \"std\";"}, {"sha": "c2eb307ab58543d8af00a5bc8d77b63965fc1a7e", "filename": "gcc/config/powerpcspe/predicates.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpowerpcspe%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fpowerpcspe%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -650,17 +650,17 @@\n \n   switch (mode)\n     {\n-    case KFmode:\n-    case IFmode:\n-    case TFmode:\n-    case DFmode:\n-    case SFmode:\n+    case E_KFmode:\n+    case E_IFmode:\n+    case E_TFmode:\n+    case E_DFmode:\n+    case E_SFmode:\n       return 0;\n \n-    case DImode:\n+    case E_DImode:\n       return (num_insns_constant (op, DImode) <= 2);\n \n-    case SImode:\n+    case E_SImode:\n       return 1;\n \n     default:\n@@ -1932,12 +1932,12 @@\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n@@ -1992,28 +1992,28 @@\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       break;\n \n     /* Do not fuse 64-bit DImode in 32-bit since it splits into two\n        separate instructions.  */\n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n \n     /* ISA 2.08/power8 only had fusion of GPR loads.  */\n-    case SFmode:\n+    case E_SFmode:\n       if (!TARGET_P9_FUSION)\n \treturn 0;\n       break;\n \n     /* ISA 2.08/power8 only had fusion of GPR loads.  Do not allow 64-bit\n        DFmode in 32-bit if -msoft-float since it splits into two separate\n        instructions.  */\n-    case DFmode:\n+    case E_DFmode:\n       if ((!TARGET_POWERPC64 && !TARGET_DF_FPR) || !TARGET_P9_FUSION)\n \treturn 0;\n       break;\n@@ -2057,23 +2057,23 @@\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case SFmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_SFmode:\n       break;\n \n     /* Do not fuse 64-bit DImode in 32-bit since it splits into two\n        separate instructions.  */\n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n \n     /* Do not allow 64-bit DFmode in 32-bit if -msoft-float since it splits\n        into two separate instructions.  Do allow fusion if we have hardware\n        floating point.  */\n-    case DFmode:\n+    case E_DFmode:\n       if (!TARGET_POWERPC64 && !TARGET_DF_FPR)\n \treturn 0;\n       break;"}, {"sha": "237b4323b4ced9b13805c4e8b8d466cfca46eb70", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -622,17 +622,17 @@\n \n   switch (mode)\n     {\n-    case KFmode:\n-    case IFmode:\n-    case TFmode:\n-    case DFmode:\n-    case SFmode:\n+    case E_KFmode:\n+    case E_IFmode:\n+    case E_TFmode:\n+    case E_DFmode:\n+    case E_SFmode:\n       return 0;\n \n-    case DImode:\n+    case E_DImode:\n       return (num_insns_constant (op, DImode) <= 2);\n \n-    case SImode:\n+    case E_SImode:\n       return 1;\n \n     default:\n@@ -1834,12 +1834,12 @@\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n@@ -1894,28 +1894,28 @@\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n       break;\n \n     /* Do not fuse 64-bit DImode in 32-bit since it splits into two\n        separate instructions.  */\n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n \n     /* ISA 2.08/power8 only had fusion of GPR loads.  */\n-    case SFmode:\n+    case E_SFmode:\n       if (!TARGET_P9_FUSION)\n \treturn 0;\n       break;\n \n     /* ISA 2.08/power8 only had fusion of GPR loads.  Do not allow 64-bit\n        DFmode in 32-bit if -msoft-float since it splits into two separate\n        instructions.  */\n-    case DFmode:\n+    case E_DFmode:\n       if ((!TARGET_POWERPC64 && !TARGET_DF_FPR) || !TARGET_P9_FUSION)\n \treturn 0;\n       break;\n@@ -1959,23 +1959,23 @@\n \n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case SFmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_SFmode:\n       break;\n \n     /* Do not fuse 64-bit DImode in 32-bit since it splits into two\n        separate instructions.  */\n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n \n     /* Do not allow 64-bit DFmode in 32-bit if -msoft-float since it splits\n        into two separate instructions.  Do allow fusion if we have hardware\n        floating point.  */\n-    case DFmode:\n+    case E_DFmode:\n       if (!TARGET_POWERPC64 && !TARGET_DF_FPR)\n \treturn 0;\n       break;"}, {"sha": "897306cc48860233fc3d1ecc0848572c766045d2", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -5828,23 +5828,23 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \n       switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n \t{\n-\t  case QImode:\n-\t  case HImode:\n-\t  case SImode:\n-\t  case DImode:\n-\t  case TImode:\n+\t  case E_QImode:\n+\t  case E_HImode:\n+\t  case E_SImode:\n+\t  case E_DImode:\n+\t  case E_TImode:\n \t    {\n \t      /* For scalar types just use a multiply expression.  */\n \t      return fold_build2_loc (loc, MULT_EXPR, TREE_TYPE (arg0), arg0,\n \t\t\t\t      fold_convert (TREE_TYPE (arg0), arg1));\n \t    }\n-\t  case SFmode:\n+\t  case E_SFmode:\n \t    {\n \t      /* For floats use the xvmulsp instruction directly.  */\n \t      tree call = rs6000_builtin_decls[VSX_BUILTIN_XVMULSP];\n \t      return build_call_expr (call, 2, arg0, arg1);\n \t    }\n-\t  case DFmode:\n+\t  case E_DFmode:\n \t    {\n \t      /* For doubles use the xvmuldp instruction directly.  */\n \t      tree call = rs6000_builtin_decls[VSX_BUILTIN_XVMULDP];\n@@ -5892,13 +5892,13 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t vec_cmpeq (va, vb)).  */\n \t      /* Note:  vec_nand also works but opt changes vec_nand's\n \t\t to vec_nor's anyway.  */\n-\t    case QImode:\n-\t    case HImode:\n-\t    case SImode:\n-\t    case DImode:\n-\t    case TImode:\n-\t    case SFmode:\n-\t    case DFmode:\n+\t    case E_QImode:\n+\t    case E_HImode:\n+\t    case E_SImode:\n+\t    case E_DImode:\n+\t    case E_TImode:\n+\t    case E_SFmode:\n+\t    case E_DFmode:\n \t      {\n \t\t/* call = vec_cmpeq (va, vb)\n \t\t   result = vec_nor (call, call).  */\n@@ -5961,7 +5961,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\t\t\t   vec_and (carryv, 1)).\n \t     vec_sube (va, vb, carryv) == vec_sub (vec_sub (va, vb),\n \t\t\t\t\t\t   vec_and (carryv, 1)).  */\n-\t  case SImode:\n+\t  case E_SImode:\n \t    {\n \t      tree add_sub_builtin;\n \n@@ -5989,7 +5989,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    }\n \t  /* For {un}signed __int128s use the vaddeuqm instruction\n \t\tdirectly.  */\n-\t  case TImode:\n+\t  case E_TImode:\n \t    {\n \t       tree bii;\n \n@@ -6044,7 +6044,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t\t\tvec_or (vec_addc (va, vb),\n \t\t\t\t\tvec_addc (vec_add (va, vb),\n \t\t\t\t\t\t  vec_and (carryv, 0x1))).  */\n-\t  case SImode:\n+\t  case E_SImode:\n \t    {\n \t    /* Use save_expr to ensure that operands used more than once\n \t\tthat may have side effects (like calls) are only evaluated\n@@ -6095,7 +6095,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    }\n \t  /* For {un}signed __int128s use the vaddecuq/vsubbecuq\n \t     instructions.  */\n-\t  case TImode:\n+\t  case E_TImode:\n \t    {\n \t       tree bii;\n \n@@ -6148,28 +6148,28 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       unsigned_p = TYPE_UNSIGNED (type);\n       switch (TYPE_MODE (type))\n \t{\n-\t  case TImode:\n+\t  case E_TImode:\n \t    type = (unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node);\n \t    size = 1;\n \t    break;\n-\t  case DImode:\n+\t  case E_DImode:\n \t    type = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n \t    size = 2;\n \t    break;\n-\t  case SImode:\n+\t  case E_SImode:\n \t    type = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n \t    size = 4;\n \t    break;\n-\t  case HImode:\n+\t  case E_HImode:\n \t    type = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n \t    size = 8;\n \t    break;\n-\t  case QImode:\n+\t  case E_QImode:\n \t    type = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n \t    size = 16;\n \t    break;\n-\t  case SFmode: type = V4SF_type_node; size = 4; break;\n-\t  case DFmode: type = V2DF_type_node; size = 2; break;\n+\t  case E_SFmode: type = V4SF_type_node; size = 4; break;\n+\t  case E_DFmode: type = V2DF_type_node; size = 2; break;\n \t  default:\n \t    goto bad;\n \t}\n@@ -6241,33 +6241,33 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase V1TImode:\n+\t\tcase E_V1TImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V1TI];\n \t\t  break;\n \n-\t\tcase V2DFmode:\n+\t\tcase E_V2DFmode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n \t\t  break;\n \n-\t\tcase V2DImode:\n+\t\tcase E_V2DImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n \t\t  break;\n \n-\t\tcase V4SFmode:\n+\t\tcase E_V4SFmode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n \t\t  break;\n \n-\t\tcase V4SImode:\n+\t\tcase E_V4SImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n \t\t  break;\n \n-\t\tcase V8HImode:\n+\t\tcase E_V8HImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n \t\t  break;\n \n-\t\tcase V16QImode:\n+\t\tcase E_V16QImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n \t\t  break;\n@@ -6283,27 +6283,27 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tdefault:\n \t\t  break;\n \n-\t\tcase V2DFmode:\n+\t\tcase E_V2DFmode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DF];\n \t\t  break;\n \n-\t\tcase V2DImode:\n+\t\tcase E_V2DImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n \t\t  break;\n \n-\t\tcase V4SFmode:\n+\t\tcase E_V4SFmode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n \t\t  break;\n \n-\t\tcase V4SImode:\n+\t\tcase E_V4SImode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n \t\t  break;\n \n-\t\tcase V8HImode:\n+\t\tcase E_V8HImode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n \t\t  break;\n \n-\t\tcase V16QImode:\n+\t\tcase E_V16QImode:\n \t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n \t\t  break;\n \t\t}"}, {"sha": "b71a4a3aa114214e8949e2a3e75c2c599d18b8cb", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -152,13 +152,13 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n {\n   switch (GET_MODE (reg))\n     {\n-    case DImode:\n+    case E_DImode:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  emit_insn (gen_zero_extendqidi2 (reg, mem));\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  {\n \t    rtx src = mem;\n \t    if (!BYTES_BIG_ENDIAN)\n@@ -169,7 +169,7 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t    emit_insn (gen_zero_extendhidi2 (reg, src));\n \t    break;\n \t  }\n-\tcase SImode:\n+\tcase E_SImode:\n \t  {\n \t    rtx src = mem;\n \t    if (!BYTES_BIG_ENDIAN)\n@@ -180,7 +180,7 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t    emit_insn (gen_zero_extendsidi2 (reg, src));\n \t  }\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  if (!BYTES_BIG_ENDIAN)\n \t    emit_insn (gen_bswapdi2 (reg, mem));\n \t  else\n@@ -191,13 +191,13 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t}\n       break;\n \n-    case SImode:\n+    case E_SImode:\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  emit_insn (gen_zero_extendqisi2 (reg, mem));\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  {\n \t    rtx src = mem;\n \t    if (!BYTES_BIG_ENDIAN)\n@@ -208,13 +208,13 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \t    emit_insn (gen_zero_extendhisi2 (reg, src));\n \t    break;\n \t  }\n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (!BYTES_BIG_ENDIAN)\n \t    emit_insn (gen_bswapsi2 (reg, mem));\n \t  else\n \t    emit_insn (gen_movsi (reg, mem));\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  /* DImode is larger than the destination reg so is not expected.  */\n \t  gcc_unreachable ();\n \t  break;"}, {"sha": "d39295cef034b59dcac0383d063d3c29abaadc0b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 187, "deletions": 187, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -2904,13 +2904,13 @@ rs6000_setup_reg_addr_masks (void)\n \t\t      addr_mask |= RELOAD_REG_PRE_MODIFY;\n \t\t      break;\n \n-\t\t    case DImode:\n+\t\t    case E_DImode:\n \t\t      if (TARGET_POWERPC64)\n \t\t\taddr_mask |= RELOAD_REG_PRE_MODIFY;\n \t\t      break;\n \n-\t\t    case DFmode:\n-\t\t    case DDmode:\n+\t\t    case E_DFmode:\n+\t\t    case E_DDmode:\n \t\t      if (TARGET_DF_INSN)\n \t\t\taddr_mask |= RELOAD_REG_PRE_MODIFY;\n \t\t      break;\n@@ -5533,24 +5533,24 @@ rs6000_preferred_simd_mode (machine_mode mode)\n   if (TARGET_VSX)\n     switch (mode)\n       {\n-      case DFmode:\n+      case E_DFmode:\n \treturn V2DFmode;\n       default:;\n       }\n   if (TARGET_ALTIVEC || TARGET_VSX)\n     switch (mode)\n       {\n-      case SFmode:\n+      case E_SFmode:\n \treturn V4SFmode;\n-      case TImode:\n+      case E_TImode:\n \treturn V1TImode;\n-      case DImode:\n+      case E_DImode:\n \treturn V2DImode;\n-      case SImode:\n+      case E_SImode:\n \treturn V4SImode;\n-      case HImode:\n+      case E_HImode:\n \treturn V8HImode;\n-      case QImode:\n+      case E_QImode:\n \treturn V16QImode;\n       default:;\n       }\n@@ -6734,13 +6734,13 @@ output_vec_const_move (rtx *operands)\n \n       switch (GET_MODE (splat_vec))\n \t{\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  return \"vspltisw %0,%1\";\n \n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  return \"vspltish %0,%1\";\n \n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  return \"vspltisb %0,%1\";\n \n \tdefault:\n@@ -7293,36 +7293,36 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \t{\n \tdefault:\n \t  break;\n-\tcase V1TImode:\n+\tcase E_V1TImode:\n \t  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);\n \t  emit_move_insn (target, gen_lowpart (TImode, vec));\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_vsx_extract_v2df (target, vec, elt));\n \t  return;\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_vsx_extract_v2di (target, vec, elt));\n \t  return;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  emit_insn (gen_vsx_extract_v4sf (target, vec, elt));\n \t  return;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v16qi (target, vec, elt));\n \t      return;\n \t    }\n \t  else\n \t    break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v8hi (target, vec, elt));\n \t      return;\n \t    }\n \t  else\n \t    break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v4si (target, vec, elt));\n@@ -7345,27 +7345,27 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \n       switch (mode)\n \t{\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));\n \t  return;\n \n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_vsx_extract_v2di_var (target, vec, elt));\n \t  return;\n \n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  emit_insn (gen_vsx_extract_v4sf_var (target, vec, elt));\n \t  return;\n \n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  emit_insn (gen_vsx_extract_v4si_var (target, vec, elt));\n \t  return;\n \n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  emit_insn (gen_vsx_extract_v8hi_var (target, vec, elt));\n \t  return;\n \n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  emit_insn (gen_vsx_extract_v16qi_var (target, vec, elt));\n \t  return;\n \n@@ -7689,15 +7689,15 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n       /* Do the VSLO to get the value into the final location.  */\n       switch (mode)\n \t{\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_vsx_vslo_v2df (dest, src, tmp_altivec));\n \t  return;\n \n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_vsx_vslo_v2di (dest, src, tmp_altivec));\n \t  return;\n \n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  {\n \t    rtx tmp_altivec_di = gen_rtx_REG (DImode, REGNO (tmp_altivec));\n \t    rtx tmp_altivec_v4sf = gen_rtx_REG (V4SFmode, REGNO (tmp_altivec));\n@@ -7709,9 +7709,9 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n \t    return;\n \t  }\n \n-\tcase V4SImode:\n-\tcase V8HImode:\n-\tcase V16QImode:\n+\tcase E_V4SImode:\n+\tcase E_V8HImode:\n+\tcase E_V16QImode:\n \t  {\n \t    rtx tmp_altivec_di = gen_rtx_REG (DImode, REGNO (tmp_altivec));\n \t    rtx src_v2di = gen_rtx_REG (V2DImode, REGNO (src));\n@@ -8216,16 +8216,16 @@ reg_offset_addressing_ok_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V16QImode:\n-    case V8HImode:\n-    case V4SFmode:\n-    case V4SImode:\n-    case V2DFmode:\n-    case V2DImode:\n-    case V1TImode:\n-    case TImode:\n-    case TFmode:\n-    case KFmode:\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n+    case E_V1TImode:\n+    case E_TImode:\n+    case E_TFmode:\n+    case E_KFmode:\n       /* AltiVec/VSX vector modes.  Only reg+reg addressing was valid until the\n \t ISA 3.0 vector d-form addressing mode was added.  While TImode is not\n \t a vector mode, if we want to use the VSX registers to move it around,\n@@ -8236,14 +8236,14 @@ reg_offset_addressing_ok_p (machine_mode mode)\n \treturn mode_supports_vsx_dform_quad (mode);\n       break;\n \n-    case V2SImode:\n-    case V2SFmode:\n+    case E_V2SImode:\n+    case E_V2SFmode:\n        /* Paired vector modes.  Only reg+reg addressing is valid.  */\n       if (TARGET_PAIRED_FLOAT)\n         return false;\n       break;\n \n-    case SDmode:\n+    case E_SDmode:\n       /* If we can do direct load/stores of SDmode, restrict it to reg+reg\n \t addressing for the LFIWZX and STFIWX instructions.  */\n       if (TARGET_NO_SDMODE_STACK)\n@@ -8484,14 +8484,14 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n   extra = 0;\n   switch (mode)\n     {\n-    case V2SImode:\n-    case V2SFmode:\n+    case E_V2SImode:\n+    case E_V2SFmode:\n       /* Paired single modes: offset addressing isn't valid.  */\n       return false;\n \n-    case DFmode:\n-    case DDmode:\n-    case DImode:\n+    case E_DFmode:\n+    case E_DDmode:\n+    case E_DImode:\n       /* If we are using VSX scalar loads, restrict ourselves to reg+reg\n \t addressing.  */\n       if (VECTOR_MEM_VSX_P (mode))\n@@ -8505,12 +8505,12 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n \treturn false;\n       break;\n \n-    case TFmode:\n-    case IFmode:\n-    case KFmode:\n-    case TDmode:\n-    case TImode:\n-    case PTImode:\n+    case E_TFmode:\n+    case E_IFmode:\n+    case E_KFmode:\n+    case E_TDmode:\n+    case E_TImode:\n+    case E_PTImode:\n       extra = 8;\n       if (!worst_case)\n \tbreak;\n@@ -8685,12 +8685,12 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   extra = 0;\n   switch (mode)\n     {\n-    case TFmode:\n-    case TDmode:\n-    case TImode:\n-    case PTImode:\n-    case IFmode:\n-    case KFmode:\n+    case E_TFmode:\n+    case E_TDmode:\n+    case E_TImode:\n+    case E_PTImode:\n+    case E_IFmode:\n+    case E_KFmode:\n       /* As in legitimate_offset_address_p we do not assume\n \t worst-case.  The mode here is just a hint as to the registers\n \t used.  A TImode is usually in gprs, but may actually be in\n@@ -10040,12 +10040,12 @@ rs6000_emit_set_const (rtx dest, rtx source)\n   c = INTVAL (source);\n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n+    case E_QImode:\n+    case E_HImode:\n       emit_insn (gen_rtx_SET (dest, source));\n       return true;\n \n-    case SImode:\n+    case E_SImode:\n       temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (SImode);\n \n       emit_insn (gen_rtx_SET (copy_rtx (temp),\n@@ -10055,7 +10055,7 @@ rs6000_emit_set_const (rtx dest, rtx source)\n \t\t\t\t\t   GEN_INT (c & 0xffff))));\n       break;\n \n-    case DImode:\n+    case E_DImode:\n       if (!TARGET_POWERPC64)\n \t{\n \t  rtx hi, lo;\n@@ -10211,21 +10211,21 @@ rs6000_const_vec (machine_mode mode)\n \n   switch (mode)\n     {\n-    case V1TImode:\n+    case E_V1TImode:\n       subparts = 1;\n       break;\n-    case V2DFmode:\n-    case V2DImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n       subparts = 2;\n       break;\n-    case V4SFmode:\n-    case V4SImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n       subparts = 4;\n       break;\n-    case V8HImode:\n+    case E_V8HImode:\n       subparts = 8;\n       break;\n-    case V16QImode:\n+    case E_V16QImode:\n       subparts = 16;\n       break;\n     default:\n@@ -10632,46 +10632,46 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n      mode == Pmode.  */\n   switch (mode)\n     {\n-    case HImode:\n-    case QImode:\n+    case E_HImode:\n+    case E_QImode:\n       if (CONSTANT_P (operands[1])\n \t  && GET_CODE (operands[1]) != CONST_INT)\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n-    case TFmode:\n-    case TDmode:\n-    case IFmode:\n-    case KFmode:\n+    case E_TFmode:\n+    case E_TDmode:\n+    case E_IFmode:\n+    case E_KFmode:\n       if (FLOAT128_2REG_P (mode))\n \trs6000_eliminate_indexed_memrefs (operands);\n       /* fall through */\n \n-    case DFmode:\n-    case DDmode:\n-    case SFmode:\n-    case SDmode:\n+    case E_DFmode:\n+    case E_DDmode:\n+    case E_SFmode:\n+    case E_SDmode:\n       if (CONSTANT_P (operands[1])\n \t  && ! easy_fp_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n-    case V16QImode:\n-    case V8HImode:\n-    case V4SFmode:\n-    case V4SImode:\n-    case V2SFmode:\n-    case V2SImode:\n-    case V2DFmode:\n-    case V2DImode:\n-    case V1TImode:\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n+    case E_V2SFmode:\n+    case E_V2SImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n+    case E_V1TImode:\n       if (CONSTANT_P (operands[1])\n \t  && !easy_vector_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n-    case SImode:\n-    case DImode:\n+    case E_SImode:\n+    case E_DImode:\n       /* Use default pattern for address of ELF small data */\n       if (TARGET_ELF\n \t  && mode == Pmode\n@@ -10817,12 +10817,12 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \t}\n       break;\n \n-    case TImode:\n+    case E_TImode:\n       if (!VECTOR_MEM_VSX_P (TImode))\n \trs6000_eliminate_indexed_memrefs (operands);\n       break;\n \n-    case PTImode:\n+    case E_PTImode:\n       rs6000_eliminate_indexed_memrefs (operands);\n       break;\n \n@@ -12047,9 +12047,9 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, const_tree type,\n #if 0\n \t    switch (mode)\n \t      {\n-\t      case SCmode: mode = SFmode; break;\n-\t      case DCmode: mode = DFmode; break;\n-\t      case TCmode: mode = TFmode; break;\n+\t      case E_SCmode: mode = SFmode; break;\n+\t      case E_DCmode: mode = DFmode; break;\n+\t      case E_TCmode: mode = TFmode; break;\n \t      default: break;\n \t      }\n #endif\n@@ -14230,18 +14230,18 @@ swap_selector_for_mode (machine_mode mode)\n \n   switch (mode)\n     {\n-    case V2DFmode:\n-    case V2DImode:\n+    case E_V2DFmode:\n+    case E_V2DImode:\n       swaparray = swap2;\n       break;\n-    case V4SFmode:\n-    case V4SImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n       swaparray = swap4;\n       break;\n-    case V8HImode:\n+    case E_V8HImode:\n       swaparray = swap8;\n       break;\n-    case V16QImode:\n+    case E_V16QImode:\n       swaparray = swap16;\n       break;\n     default:\n@@ -17078,7 +17078,7 @@ paired_init_builtins (void)\n \n       switch (insn_data[d->icode].operand[1].mode)\n \t{\n-\tcase V2SFmode:\n+\tcase E_V2SFmode:\n \t  type = int_ftype_int_v2sf_v2sf;\n \t  break;\n \tdefault:\n@@ -17509,25 +17509,25 @@ altivec_init_builtins (void)\n \n       switch (mode1)\n \t{\n-\tcase VOIDmode:\n+\tcase E_VOIDmode:\n \t  type = int_ftype_int_opaque_opaque;\n \t  break;\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  type = int_ftype_int_v2di_v2di;\n \t  break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  type = int_ftype_int_v4si_v4si;\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  type = int_ftype_int_v8hi_v8hi;\n \t  break;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  type = int_ftype_int_v16qi_v16qi;\n \t  break;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  type = int_ftype_int_v4sf_v4sf;\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  type = int_ftype_int_v2df_v2df;\n \t  break;\n \tdefault:\n@@ -17559,22 +17559,22 @@ altivec_init_builtins (void)\n \n       switch (mode0)\n \t{\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  type = v2di_ftype_v2di;\n \t  break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  type = v4si_ftype_v4si;\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  type = v8hi_ftype_v8hi;\n \t  break;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  type = v16qi_ftype_v16qi;\n \t  break;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  type = v4sf_ftype_v4sf;\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  type = v2df_ftype_v2df;\n \t  break;\n \tdefault:\n@@ -22156,26 +22156,26 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \n       switch (src_mode)\n \t{\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  cvt = sext_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].from_df;\n \t  break;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  cvt = sext_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].from_sf;\n \t  break;\n \n-\tcase KFmode:\n-\tcase IFmode:\n-\tcase TFmode:\n+\tcase E_KFmode:\n+\tcase E_IFmode:\n+\tcase E_TFmode:\n \t  if (FLOAT128_IBM_P (src_mode))\n \t    cvt = sext_optab;\n \t  else\n \t    do_move = true;\n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufloat_optab;\n@@ -22188,7 +22188,7 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \t    }\n \t  break;\n \n-\tcase DImode:\n+\tcase E_DImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufloat_optab;\n@@ -22218,26 +22218,26 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \n       switch (dest_mode)\n \t{\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  cvt = trunc_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].to_df;\n \t  break;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  cvt = trunc_optab;\n \t  hw_convert = hw_conversions[kf_or_tf].to_sf;\n \t  break;\n \n-\tcase KFmode:\n-\tcase IFmode:\n-\tcase TFmode:\n+\tcase E_KFmode:\n+\tcase E_IFmode:\n+\tcase E_TFmode:\n \t  if (FLOAT128_IBM_P (dest_mode))\n \t    cvt = trunc_optab;\n \t  else\n \t    do_move = true;\n \t  break;\n \n-\tcase SImode:\n+\tcase E_SImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufix_optab;\n@@ -22250,7 +22250,7 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \t    }\n \t  break;\n \n-\tcase DImode:\n+\tcase E_DImode:\n \t  if (unsigned_p)\n \t    {\n \t      cvt = ufix_optab;\n@@ -23250,24 +23250,24 @@ emit_load_locked (machine_mode mode, rtx reg, rtx mem)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       fn = gen_load_lockedqi;\n       break;\n-    case HImode:\n+    case E_HImode:\n       fn = gen_load_lockedhi;\n       break;\n-    case SImode:\n+    case E_SImode:\n       if (GET_MODE (mem) == QImode)\n \tfn = gen_load_lockedqi_si;\n       else if (GET_MODE (mem) == HImode)\n \tfn = gen_load_lockedhi_si;\n       else\n \tfn = gen_load_lockedsi;\n       break;\n-    case DImode:\n+    case E_DImode:\n       fn = gen_load_lockeddi;\n       break;\n-    case TImode:\n+    case E_TImode:\n       fn = gen_load_lockedti;\n       break;\n     default:\n@@ -23286,19 +23286,19 @@ emit_store_conditional (machine_mode mode, rtx res, rtx mem, rtx val)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       fn = gen_store_conditionalqi;\n       break;\n-    case HImode:\n+    case E_HImode:\n       fn = gen_store_conditionalhi;\n       break;\n-    case SImode:\n+    case E_SImode:\n       fn = gen_store_conditionalsi;\n       break;\n-    case DImode:\n+    case E_DImode:\n       fn = gen_store_conditionaldi;\n       break;\n-    case TImode:\n+    case E_TImode:\n       fn = gen_store_conditionalti;\n       break;\n     default:\n@@ -28839,17 +28839,17 @@ rs6000_output_function_epilogue (FILE *file)\n \n \t\t      switch (mode)\n \t\t\t{\n-\t\t\tcase SFmode:\n-\t\t\tcase SDmode:\n+\t\t\tcase E_SFmode:\n+\t\t\tcase E_SDmode:\n \t\t\t  bits = 0x2;\n \t\t\t  break;\n \n-\t\t\tcase DFmode:\n-\t\t\tcase DDmode:\n-\t\t\tcase TFmode:\n-\t\t\tcase TDmode:\n-\t\t\tcase IFmode:\n-\t\t\tcase KFmode:\n+\t\t\tcase E_DFmode:\n+\t\t\tcase E_DDmode:\n+\t\t\tcase E_TFmode:\n+\t\t\tcase E_TDmode:\n+\t\t\tcase E_IFmode:\n+\t\t\tcase E_KFmode:\n \t\t\t  bits = 0x3;\n \t\t\t  break;\n \n@@ -32395,46 +32395,46 @@ rs6000_handle_altivec_attribute (tree *node,\n       unsigned_p = TYPE_UNSIGNED (type);\n       switch (mode)\n \t{\n-\tcase TImode:\n+\tcase E_TImode:\n \t  result = (unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node);\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  result = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n \t  break;\n-\tcase SImode:\n+\tcase E_SImode:\n \t  result = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  result = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n \t  break;\n-\tcase QImode:\n+\tcase E_QImode:\n \t  result = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n \t  break;\n-\tcase SFmode: result = V4SF_type_node; break;\n-\tcase DFmode: result = V2DF_type_node; break;\n+\tcase E_SFmode: result = V4SF_type_node; break;\n+\tcase E_DFmode: result = V2DF_type_node; break;\n \t  /* If the user says 'vector int bool', we may be handed the 'bool'\n \t     attribute _before_ the 'vector' attribute, and so select the\n \t     proper type in the 'b' case below.  */\n-\tcase V4SImode: case V8HImode: case V16QImode: case V4SFmode:\n-\tcase V2DImode: case V2DFmode:\n+\tcase E_V4SImode: case E_V8HImode: case E_V16QImode: case E_V4SFmode:\n+\tcase E_V2DImode: case E_V2DFmode:\n \t  result = type;\n \tdefault: break;\n \t}\n       break;\n     case 'b':\n       switch (mode)\n \t{\n-\tcase DImode: case V2DImode: result = bool_V2DI_type_node; break;\n-\tcase SImode: case V4SImode: result = bool_V4SI_type_node; break;\n-\tcase HImode: case V8HImode: result = bool_V8HI_type_node; break;\n-\tcase QImode: case V16QImode: result = bool_V16QI_type_node;\n+\tcase E_DImode: case E_V2DImode: result = bool_V2DI_type_node; break;\n+\tcase E_SImode: case E_V4SImode: result = bool_V4SI_type_node; break;\n+\tcase E_HImode: case E_V8HImode: result = bool_V8HI_type_node; break;\n+\tcase E_QImode: case E_V16QImode: result = bool_V16QI_type_node;\n \tdefault: break;\n \t}\n       break;\n     case 'p':\n       switch (mode)\n \t{\n-\tcase V8HImode: result = pixel_V8HI_type_node;\n+\tcase E_V8HImode: result = pixel_V8HI_type_node;\n \tdefault: break;\n \t}\n     default: break;\n@@ -35691,10 +35691,10 @@ rs6000_function_value (const_tree valtype,\n       {\n       default:\n \tbreak;\n-      case DImode:\n-      case SCmode:\n-      case DCmode:\n-      case TCmode:\n+      case E_DImode:\n+      case E_SCmode:\n+      case E_DCmode:\n+      case E_TCmode:\n \tint count = GET_MODE_SIZE (mode) / 4;\n \treturn rs6000_parallel_return (mode, count, SImode, GP_ARG_RETURN, 1);\n       }\n@@ -38367,24 +38367,24 @@ emit_fusion_gpr_load (rtx target, rtx mem)\n   mode = GET_MODE (mem);\n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       mode_name = \"char\";\n       load_str = \"lbz\";\n       break;\n \n-    case HImode:\n+    case E_HImode:\n       mode_name = \"short\";\n       load_str = \"lhz\";\n       break;\n \n-    case SImode:\n-    case SFmode:\n+    case E_SImode:\n+    case E_SFmode:\n       mode_name = (mode == SFmode) ? \"float\" : \"int\";\n       load_str = \"lwz\";\n       break;\n \n-    case DImode:\n-    case DFmode:\n+    case E_DImode:\n+    case E_DFmode:\n       gcc_assert (TARGET_POWERPC64);\n       mode_name = (mode == DFmode) ? \"double\" : \"long\";\n       load_str = \"ld\";\n@@ -38634,18 +38634,18 @@ emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n     {\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  load_string = \"lbz\";\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  load_string = \"lhz\";\n \t  break;\n-\tcase SImode:\n-\tcase SFmode:\n+\tcase E_SImode:\n+\tcase E_SFmode:\n \t  load_string = \"lwz\";\n \t  break;\n-\tcase DImode:\n-\tcase DFmode:\n+\tcase E_DImode:\n+\tcase E_DFmode:\n \t  if (!TARGET_POWERPC64)\n \t    gcc_unreachable ();\n \t  load_string = \"ld\";\n@@ -38721,18 +38721,18 @@ emit_fusion_p9_store (rtx mem, rtx reg, rtx tmp_reg)\n     {\n       switch (mode)\n \t{\n-\tcase QImode:\n+\tcase E_QImode:\n \t  store_string = \"stb\";\n \t  break;\n-\tcase HImode:\n+\tcase E_HImode:\n \t  store_string = \"sth\";\n \t  break;\n-\tcase SImode:\n-\tcase SFmode:\n+\tcase E_SImode:\n+\tcase E_SFmode:\n \t  store_string = \"stw\";\n \t  break;\n-\tcase DImode:\n-\tcase DFmode:\n+\tcase E_DImode:\n+\tcase E_DFmode:\n \t  if (!TARGET_POWERPC64)\n \t    gcc_unreachable ();\n \t  store_string = \"std\";"}, {"sha": "06406f68f048843f40d43ab196093d44117c2e11", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -966,25 +966,25 @@ rx_gen_move_template (rtx * operands, bool is_movu)\n   /* Decide which extension, if any, should be given to the move instruction.  */\n   switch (CONST_INT_P (src) ? GET_MODE (dest) : GET_MODE (src))\n     {\n-    case QImode:\n+    case E_QImode:\n       /* The .B extension is not valid when\n \t loading an immediate into a register.  */\n       if (! REG_P (dest) || ! CONST_INT_P (src))\n \textension = \".B\";\n       break;\n-    case HImode:\n+    case E_HImode:\n       if (! REG_P (dest) || ! CONST_INT_P (src))\n \t/* The .W extension is not valid when\n \t   loading an immediate into a register.  */\n \textension = \".W\";\n       break;\n-    case DFmode:\n-    case DImode:\n-    case SFmode:\n-    case SImode:\n+    case E_DFmode:\n+    case E_DImode:\n+    case E_SFmode:\n+    case E_SImode:\n       extension = \".L\";\n       break;\n-    case VOIDmode:\n+    case E_VOIDmode:\n       /* This mode is used by constants.  */\n       break;\n     default:\n@@ -3079,15 +3079,15 @@ flags_from_mode (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case CC_ZSmode:\n+    case E_CC_ZSmode:\n       return CC_FLAG_S | CC_FLAG_Z;\n-    case CC_ZSOmode:\n+    case E_CC_ZSOmode:\n       return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;\n-    case CC_ZSCmode:\n+    case E_CC_ZSCmode:\n       return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_C;\n-    case CCmode:\n+    case E_CCmode:\n       return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O | CC_FLAG_C;\n-    case CC_Fmode:\n+    case E_CC_Fmode:\n       return CC_FLAG_FP;\n     default:\n       gcc_unreachable ();"}, {"sha": "db966dd6bcbccc901b80c4ef4d4b9e4734551747", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -278,25 +278,25 @@\n \n   switch (GET_MODE (XEXP (op, 0)))\n     {\n-    case CCL1mode:\n+    case E_CCL1mode:\n       return GET_CODE (op) == LTU;\n \n-    case CCL2mode:\n+    case E_CCL2mode:\n       return GET_CODE (op) == LEU;\n \n-    case CCL3mode:\n+    case E_CCL3mode:\n       return GET_CODE (op) == GEU;\n \n-    case CCUmode:\n+    case E_CCUmode:\n       return GET_CODE (op) == GTU;\n \n-    case CCURmode:\n+    case E_CCURmode:\n       return GET_CODE (op) == LTU;\n \n-    case CCSmode:\n+    case E_CCSmode:\n       return GET_CODE (op) == UNGT;\n \n-    case CCSRmode:\n+    case E_CCSRmode:\n       return GET_CODE (op) == UNLT;\n \n     default:\n@@ -323,25 +323,25 @@\n \n   switch (GET_MODE (XEXP (op, 0)))\n     {\n-    case CCL1mode:\n+    case E_CCL1mode:\n       return GET_CODE (op) == GEU;\n \n-    case CCL2mode:\n+    case E_CCL2mode:\n       return GET_CODE (op) == GTU;\n \n-    case CCL3mode:\n+    case E_CCL3mode:\n       return GET_CODE (op) == LTU;\n \n-    case CCUmode:\n+    case E_CCUmode:\n       return GET_CODE (op) == LEU;\n \n-    case CCURmode:\n+    case E_CCURmode:\n       return GET_CODE (op) == GEU;\n \n-    case CCSmode:\n+    case E_CCSmode:\n       return GET_CODE (op) == LE;\n \n-    case CCSRmode:\n+    case E_CCSRmode:\n       return GET_CODE (op) == GE;\n \n     default:"}, {"sha": "1f19298ba6e22e02a0dddc813eb15aa382bf4443", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 94, "deletions": 85, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1134,11 +1134,20 @@ s390_handle_vectorbool_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n   mode = TYPE_MODE (type);\n   switch (mode)\n     {\n-    case DImode: case V2DImode: result = s390_builtin_types[BT_BV2DI]; break;\n-    case SImode: case V4SImode: result = s390_builtin_types[BT_BV4SI]; break;\n-    case HImode: case V8HImode: result = s390_builtin_types[BT_BV8HI]; break;\n-    case QImode: case V16QImode: result = s390_builtin_types[BT_BV16QI];\n-    default: break;\n+    case E_DImode: case E_V2DImode:\n+      result = s390_builtin_types[BT_BV2DI];\n+      break;\n+    case E_SImode: case E_V4SImode:\n+      result = s390_builtin_types[BT_BV4SI];\n+      break;\n+    case E_HImode: case E_V8HImode:\n+      result = s390_builtin_types[BT_BV8HI];\n+      break;\n+    case E_QImode: case E_V16QImode:\n+      result = s390_builtin_types[BT_BV16QI];\n+      break;\n+    default:\n+      break;\n     }\n \n   *no_add_attrs = true;  /* No need to hang on to the attribute.  */\n@@ -1248,14 +1257,14 @@ s390_vector_mode_supported_p (machine_mode mode)\n \n   switch (inner)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case DImode:\n-    case TImode:\n-    case SFmode:\n-    case DFmode:\n-    case TFmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_DImode:\n+    case E_TImode:\n+    case E_SFmode:\n+    case E_DFmode:\n+    case E_TFmode:\n       return true;\n     default:\n       return false;\n@@ -1282,18 +1291,18 @@ s390_cc_modes_compatible (machine_mode m1, machine_mode m2)\n \n   switch (m1)\n     {\n-    case CCZmode:\n+    case E_CCZmode:\n       if (m2 == CCUmode || m2 == CCTmode || m2 == CCZ1mode\n \t  || m2 == CCSmode || m2 == CCSRmode || m2 == CCURmode)\n         return m2;\n       return VOIDmode;\n \n-    case CCSmode:\n-    case CCUmode:\n-    case CCTmode:\n-    case CCSRmode:\n-    case CCURmode:\n-    case CCZ1mode:\n+    case E_CCSmode:\n+    case E_CCUmode:\n+    case E_CCTmode:\n+    case E_CCSRmode:\n+    case E_CCURmode:\n+    case E_CCZ1mode:\n       if (m2 == CCZmode)\n \treturn m1;\n \n@@ -1327,36 +1336,36 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n   set_mode = GET_MODE (SET_DEST (set));\n   switch (set_mode)\n     {\n-    case CCZ1mode:\n-    case CCSmode:\n-    case CCSRmode:\n-    case CCUmode:\n-    case CCURmode:\n-    case CCLmode:\n-    case CCL1mode:\n-    case CCL2mode:\n-    case CCL3mode:\n-    case CCT1mode:\n-    case CCT2mode:\n-    case CCT3mode:\n-    case CCVEQmode:\n-    case CCVIHmode:\n-    case CCVIHUmode:\n-    case CCVFHmode:\n-    case CCVFHEmode:\n+    case E_CCZ1mode:\n+    case E_CCSmode:\n+    case E_CCSRmode:\n+    case E_CCUmode:\n+    case E_CCURmode:\n+    case E_CCLmode:\n+    case E_CCL1mode:\n+    case E_CCL2mode:\n+    case E_CCL3mode:\n+    case E_CCT1mode:\n+    case E_CCT2mode:\n+    case E_CCT3mode:\n+    case E_CCVEQmode:\n+    case E_CCVIHmode:\n+    case E_CCVIHUmode:\n+    case E_CCVFHmode:\n+    case E_CCVFHEmode:\n       if (req_mode != set_mode)\n         return 0;\n       break;\n \n-    case CCZmode:\n+    case E_CCZmode:\n       if (req_mode != CCSmode && req_mode != CCUmode && req_mode != CCTmode\n \t  && req_mode != CCSRmode && req_mode != CCURmode\n \t  && req_mode != CCZ1mode)\n         return 0;\n       break;\n \n-    case CCAPmode:\n-    case CCANmode:\n+    case E_CCAPmode:\n+    case E_CCANmode:\n       if (req_mode != CCAmode)\n         return 0;\n       break;\n@@ -1675,8 +1684,8 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n       enum rtx_code new_code = UNKNOWN;\n       switch (GET_MODE (XVECEXP (*op0, 0, 0)))\n \t{\n-\tcase CCZmode:\n-\tcase CCRAWmode:\n+\tcase E_CCZmode:\n+\tcase E_CCRAWmode:\n \t  switch (*code)\n \t    {\n \t    case EQ: new_code = EQ;  break;\n@@ -1792,20 +1801,20 @@ s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem,\n   cc = gen_rtx_REG (ccmode, CC_REGNUM);\n   switch (GET_MODE (mem))\n     {\n-    case SImode:\n+    case E_SImode:\n       emit_insn (gen_atomic_compare_and_swapsi_internal (old, mem, cmp,\n \t\t\t\t\t\t\t new_rtx, cc));\n       break;\n-    case DImode:\n+    case E_DImode:\n       emit_insn (gen_atomic_compare_and_swapdi_internal (old, mem, cmp,\n \t\t\t\t\t\t\t new_rtx, cc));\n       break;\n-    case TImode:\n+    case E_TImode:\n \temit_insn (gen_atomic_compare_and_swapti_internal (old, mem, cmp,\n \t\t\t\t\t\t\t   new_rtx, cc));\n       break;\n-    case QImode:\n-    case HImode:\n+    case E_QImode:\n+    case E_HImode:\n     default:\n       gcc_unreachable ();\n     }\n@@ -1849,8 +1858,8 @@ s390_branch_condition_mask (rtx code)\n \n   switch (GET_MODE (XEXP (code, 0)))\n     {\n-    case CCZmode:\n-    case CCZ1mode:\n+    case E_CCZmode:\n+    case E_CCZ1mode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -1859,7 +1868,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCT1mode:\n+    case E_CCT1mode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC1;\n@@ -1868,7 +1877,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCT2mode:\n+    case E_CCT2mode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC2;\n@@ -1877,7 +1886,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCT3mode:\n+    case E_CCT3mode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC3;\n@@ -1886,7 +1895,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCLmode:\n+    case E_CCLmode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0 | CC2;\n@@ -1895,7 +1904,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCL1mode:\n+    case E_CCL1mode:\n       switch (GET_CODE (code))\n         {\n \tcase LTU:\treturn CC2 | CC3;  /* carry */\n@@ -1904,7 +1913,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCL2mode:\n+    case E_CCL2mode:\n       switch (GET_CODE (code))\n         {\n \tcase GTU:\treturn CC0 | CC1;  /* borrow */\n@@ -1913,7 +1922,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCL3mode:\n+    case E_CCL3mode:\n       switch (GET_CODE (code))\n \t{\n \tcase EQ:\treturn CC0 | CC2;\n@@ -1925,7 +1934,7 @@ s390_branch_condition_mask (rtx code)\n \tdefault:\treturn -1;\n \t}\n \n-    case CCUmode:\n+    case E_CCUmode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -1938,7 +1947,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCURmode:\n+    case E_CCURmode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -1951,7 +1960,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCAPmode:\n+    case E_CCAPmode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -1964,7 +1973,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCANmode:\n+    case E_CCANmode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -1977,7 +1986,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCSmode:\n+    case E_CCSmode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -1998,7 +2007,7 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n-    case CCSRmode:\n+    case E_CCSRmode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -2022,7 +2031,7 @@ s390_branch_condition_mask (rtx code)\n       /* Vector comparison modes.  */\n       /* CC2 will never be set.  It however is part of the negated\n \t masks.  */\n-    case CCVIALLmode:\n+    case E_CCVIALLmode:\n       switch (GET_CODE (code))\n \t{\n \tcase EQ:\n@@ -2037,7 +2046,7 @@ s390_branch_condition_mask (rtx code)\n \tdefault:        return -1;\n \t}\n \n-    case CCVIANYmode:\n+    case E_CCVIANYmode:\n       switch (GET_CODE (code))\n \t{\n \tcase EQ:\n@@ -2051,7 +2060,7 @@ s390_branch_condition_mask (rtx code)\n \tcase LT:        return CC3 | CC2;\n \tdefault:        return -1;\n \t}\n-    case CCVFALLmode:\n+    case E_CCVFALLmode:\n       switch (GET_CODE (code))\n \t{\n \tcase EQ:\n@@ -2064,7 +2073,7 @@ s390_branch_condition_mask (rtx code)\n \tdefault:        return -1;\n \t}\n \n-    case CCVFANYmode:\n+    case E_CCVFANYmode:\n       switch (GET_CODE (code))\n \t{\n \tcase EQ:\n@@ -2077,7 +2086,7 @@ s390_branch_condition_mask (rtx code)\n \tdefault:        return -1;\n \t}\n \n-    case CCRAWmode:\n+    case E_CCRAWmode:\n       switch (GET_CODE (code))\n \t{\n \tcase EQ:\n@@ -3510,7 +3519,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     case MULT:\n       switch (mode)\n \t{\n-\tcase SImode:\n+\tcase E_SImode:\n \t  {\n \t    rtx left = XEXP (x, 0);\n \t    rtx right = XEXP (x, 1);\n@@ -3523,7 +3532,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t      *total = s390_cost->ms;  /* msr, ms, msy */\n \t    break;\n \t  }\n-\tcase DImode:\n+\tcase E_DImode:\n \t  {\n \t    rtx left = XEXP (x, 0);\n \t    rtx right = XEXP (x, 1);\n@@ -3554,11 +3563,11 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t      }\n \t    break;\n \t  }\n-\tcase SFmode:\n-\tcase DFmode:\n+\tcase E_SFmode:\n+\tcase E_DFmode:\n \t  *total = s390_cost->mult_df;\n \t  break;\n-\tcase TFmode:\n+\tcase E_TFmode:\n \t  *total = s390_cost->mxbr;\n \t  break;\n \tdefault:\n@@ -3569,10 +3578,10 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     case FMA:\n       switch (mode)\n \t{\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  *total = s390_cost->madbr;\n \t  break;\n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  *total = s390_cost->maebr;\n \t  break;\n \tdefault:\n@@ -4292,7 +4301,7 @@ s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t\t\t\t       GET_MODE_SIZE (mode))))\n \t{\n #define __SECONDARY_RELOAD_CASE(M,m)\t\t\t\t\t\\\n-\t  case M##mode:\t\t\t\t\t\t\t\\\n+\t  case E_##M##mode:\t\t\t\t\t\t\\\n \t    if (TARGET_64BIT)\t\t\t\t\t\t\\\n \t      sri->icode = in_p ? CODE_FOR_reload##m##di_toreg_z10 :\t\\\n                                   CODE_FOR_reload##m##di_tomem_z10;\t\\\n@@ -7006,13 +7015,13 @@ s390_expand_cs (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n {\n   switch (mode)\n     {\n-    case TImode:\n-    case DImode:\n-    case SImode:\n+    case E_TImode:\n+    case E_DImode:\n+    case E_SImode:\n       s390_expand_cs_tdsi (mode, btarget, vtarget, mem, cmp, new_rtx, is_weak);\n       break;\n-    case HImode:\n-    case QImode:\n+    case E_HImode:\n+    case E_QImode:\n       s390_expand_cs_hqi (mode, btarget, vtarget, mem, cmp, new_rtx, is_weak);\n       break;\n     default:\n@@ -15490,15 +15499,15 @@ s390_preferred_simd_mode (machine_mode mode)\n   if (TARGET_VX)\n     switch (mode)\n       {\n-      case DFmode:\n+      case E_DFmode:\n \treturn V2DFmode;\n-      case DImode:\n+      case E_DImode:\n \treturn V2DImode;\n-      case SImode:\n+      case E_SImode:\n \treturn V4SImode;\n-      case HImode:\n+      case E_HImode:\n \treturn V8HImode;\n-      case QImode:\n+      case E_QImode:\n \treturn V16QImode;\n       default:;\n       }"}, {"sha": "54796df041b6e3a69beadc75bb5c0943a09e6ad4", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -314,9 +314,9 @@\n    machine_mode half_mode;\n    switch (<MODE>mode)\n    {\n-     case V8HImode: half_mode = V16QImode; break;\n-     case V4SImode: half_mode = V8HImode; break;\n-     case V2DImode: half_mode = V4SImode; break;\n+     case E_V8HImode: half_mode = V16QImode; break;\n+     case E_V4SImode: half_mode = V8HImode; break;\n+     case E_V2DImode: half_mode = V4SImode; break;\n      default: gcc_unreachable ();\n    }\n    s390_expand_vcond (operands[1], operands[1], null_vec,"}, {"sha": "2d906a244f5e46ffdccb20026044a8feb584d5dd", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1272,11 +1272,11 @@ sh_print_operand (FILE *stream, rtx x, int code)\n \t{\n \t  switch (GET_MODE (x))\n \t    {\n-\t    case QImode: fputs (\".b\", stream); break;\n-\t    case HImode: fputs (\".w\", stream); break;\n-\t    case SImode: fputs (\".l\", stream); break;\n-\t    case SFmode: fputs (\".s\", stream); break;\n-\t    case DFmode: fputs (\".d\", stream); break;\n+\t    case E_QImode: fputs (\".b\", stream); break;\n+\t    case E_HImode: fputs (\".w\", stream); break;\n+\t    case E_SImode: fputs (\".l\", stream); break;\n+\t    case E_SFmode: fputs (\".s\", stream); break;\n+\t    case E_DFmode: fputs (\".d\", stream); break;\n \t    default: gcc_unreachable ();\n \t    }\n \t}\n@@ -4622,10 +4622,10 @@ dump_table (rtx_insn *start, rtx_insn *barrier)\n \n \t  switch (p->mode)\n \t    {\n-\t    case HImode:\n+\t    case E_HImode:\n \t      break;\n-\t    case SImode:\n-\t    case SFmode:\n+\t    case E_SImode:\n+\t    case E_SFmode:\n \t      if (align_insn && !p->part_of_sequence_p)\n \t\t{\n \t\t  for (lab = p->label; lab; lab = LABEL_REFS (lab))\n@@ -4651,15 +4651,15 @@ dump_table (rtx_insn *start, rtx_insn *barrier)\n \t\t  need_align = ! need_align;\n \t\t}\n \t      break;\n-\t    case DFmode:\n+\t    case E_DFmode:\n \t      if (need_align)\n \t\t{\n \t\t  scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);\n \t\t  align_insn = scan;\n \t\t  need_align = false;\n \t\t}\n \t      /* FALLTHRU */\n-\t    case DImode:\n+\t    case E_DImode:\n \t      for (lab = p->label; lab; lab = LABEL_REFS (lab))\n \t\tscan = emit_label_after (lab, scan);\n \t      scan = emit_insn_after (gen_consttable_8 (p->value, const0_rtx),\n@@ -4689,10 +4689,10 @@ dump_table (rtx_insn *start, rtx_insn *barrier)\n \n       switch (p->mode)\n \t{\n-\tcase HImode:\n+\tcase E_HImode:\n \t  break;\n-\tcase SImode:\n-\tcase SFmode:\n+\tcase E_SImode:\n+\tcase E_SFmode:\n \t  if (need_align)\n \t    {\n \t      need_align = false;\n@@ -4704,8 +4704,8 @@ dump_table (rtx_insn *start, rtx_insn *barrier)\n \t  scan = emit_insn_after (gen_consttable_4 (p->value, const0_rtx),\n \t\t\t\t  scan);\n \t  break;\n-\tcase DFmode:\n-\tcase DImode:\n+\tcase E_DFmode:\n+\tcase E_DImode:\n \t  if (need_align)\n \t    {\n \t      need_align = false;\n@@ -11239,13 +11239,13 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t  && ! ((fp_zero_operand (x) || fp_one_operand (x)) && mode == SFmode))\n \tswitch (mode)\n \t  {\n-\t  case SFmode:\n+\t  case E_SFmode:\n \t    sri->icode = CODE_FOR_reload_insf__frn;\n \t    return NO_REGS;\n-\t  case DFmode:\n+\t  case E_DFmode:\n \t    sri->icode = CODE_FOR_reload_indf__frn;\n \t    return NO_REGS;\n-\t  case SImode:\n+\t  case E_SImode:\n \t    /* ??? If we knew that we are in the appropriate mode -\n \t       single precision - we could use a reload pattern directly.  */\n \t    return FPUL_REGS;"}, {"sha": "da0c354e1d308098999de8d0cbd695a13165460f", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1793,13 +1793,13 @@ extern bool current_function_interrupt;\n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)\t\t\t\\\n   switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-    case SImode:\t\t\t\t\t\t\t\\\n+    case E_SImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n-    case HImode:\t\t\t\t\t\t\t\\\n+    case E_HImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.word\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n-    case QImode:\t\t\t\t\t\t\t\\\n+    case E_QImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     default:\t\t\t\t\t\t\t\t\\"}, {"sha": "15d99f16332a380fd23e017b04cd729f411683bc", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -7976,13 +7976,13 @@\n \n   switch (GET_MODE (diff_vec))\n     {\n-    case SImode:\n+    case E_SImode:\n       return   \"shll2\t%1\"\t\"\\n\"\n \t     \"\tmov.l\t@(r0,%1),%0\";\n-    case HImode:\n+    case E_HImode:\n       return   \"add\t%1,%1\"\t\"\\n\"\n \t     \"\tmov.w\t@(r0,%1),%0\";\n-    case QImode:\n+    case E_QImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \treturn         \"mov.b\t@(r0,%1),%0\"\t\"\\n\"\n \t       \"\textu.b\t%0,%0\";\n@@ -8011,17 +8011,17 @@\n \n   switch (GET_MODE (diff_vec))\n     {\n-    case SImode:\n+    case E_SImode:\n       return   \"shll2\t%1\"\t\t\"\\n\"\n \t     \"\tadd\tr0,%1\"\t\t\"\\n\"\n \t     \"\tmova\t%O3,r0\"\t\t\"\\n\"\n \t     \"  mov.l\t@(r0,%1),%0\";\n-    case HImode:\n+    case E_HImode:\n       return   \"add\t%1,%1\"\t\t\"\\n\"\n \t     \"\tadd\tr0,%1\"\t\t\"\\n\"\n \t     \"\tmova\t%O3,r0\"\t\t\"\\n\"\n \t     \"\tmov.w\t@(r0,%1),%0\";\n-    case QImode:\n+    case E_QImode:\n       if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \treturn\t       \"add\tr0,%1\"\t\t\"\\n\"\n \t\t\"\tmova\t%O3,r0\"\t\t\"\\n\""}, {"sha": "e3e7edabb27d554dfa3a00b13e26a99af811dcb3", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -466,17 +466,17 @@\n {\n   switch (GET_MODE (XEXP (op, 0)))\n     {\n-    case CCmode:\n-    case CCXmode:\n+    case E_CCmode:\n+    case E_CCXmode:\n       return true;\n-    case CCNZmode:\n-    case CCXNZmode:\n+    case E_CCNZmode:\n+    case E_CCXNZmode:\n       return nz_comparison_operator (op, mode);\n-    case CCCmode:\n-    case CCXCmode:\n+    case E_CCCmode:\n+    case E_CCXCmode:\n       return c_comparison_operator (op, mode);\n-    case CCVmode:\n-    case CCXVmode:\n+    case E_CCVmode:\n+    case E_CCXVmode:\n       return v_comparison_operator (op, mode);\n     default:\n       return false;\n@@ -489,8 +489,8 @@\n {\n   switch (GET_MODE (XEXP (op, 0)))\n     {\n-    case CCFPmode:\n-    case CCFPEmode:\n+    case E_CCFPmode:\n+    case E_CCFPEmode:\n       return true;\n     default:\n       return false;"}, {"sha": "c6efe19c2a8881190b79f80e284a18e84935c744", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -2068,21 +2068,21 @@ sparc_expand_move (machine_mode mode, rtx *operands)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       /* All QImode constants require only one insn, so proceed.  */\n       break;\n \n-    case HImode:\n-    case SImode:\n+    case E_HImode:\n+    case E_SImode:\n       sparc_emit_set_const32 (operands[0], operands[1]);\n       return true;\n \n-    case DImode:\n+    case E_DImode:\n       /* input_operand should have filtered out 32-bit mode.  */\n       sparc_emit_set_const64 (operands[0], operands[1]);\n       return true;\n \n-    case TImode:\n+    case E_TImode:\n       {\n \trtx high, low;\n \t/* TImode isn't available in 32-bit mode.  */\n@@ -3475,10 +3475,10 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n     case FLOAT_EXTEND:\n       switch (GET_MODE (operands[1]))\n \t{\n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  func = \"_Qp_stoq\";\n \t  break;\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  func = \"_Qp_dtoq\";\n \t  break;\n \tdefault:\n@@ -3489,10 +3489,10 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n     case FLOAT_TRUNCATE:\n       switch (GET_MODE (operands[0]))\n \t{\n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  func = \"_Qp_qtos\";\n \t  break;\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  func = \"_Qp_qtod\";\n \t  break;\n \tdefault:\n@@ -3503,12 +3503,12 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n     case FLOAT:\n       switch (GET_MODE (operands[1]))\n \t{\n-\tcase SImode:\n+\tcase E_SImode:\n \t  func = \"_Qp_itoq\";\n \t  if (TARGET_ARCH64)\n \t    operands[1] = gen_rtx_SIGN_EXTEND (DImode, operands[1]);\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  func = \"_Qp_xtoq\";\n \t  break;\n \tdefault:\n@@ -3519,12 +3519,12 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n     case UNSIGNED_FLOAT:\n       switch (GET_MODE (operands[1]))\n \t{\n-\tcase SImode:\n+\tcase E_SImode:\n \t  func = \"_Qp_uitoq\";\n \t  if (TARGET_ARCH64)\n \t    operands[1] = gen_rtx_ZERO_EXTEND (DImode, operands[1]);\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  func = \"_Qp_uxtoq\";\n \t  break;\n \tdefault:\n@@ -3535,10 +3535,10 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n     case FIX:\n       switch (GET_MODE (operands[0]))\n \t{\n-\tcase SImode:\n+\tcase E_SImode:\n \t  func = \"_Qp_qtoi\";\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  func = \"_Qp_qtox\";\n \t  break;\n \tdefault:\n@@ -3549,10 +3549,10 @@ emit_soft_tfmode_cvt (enum rtx_code code, rtx *operands)\n     case UNSIGNED_FIX:\n       switch (GET_MODE (operands[0]))\n \t{\n-\tcase SImode:\n+\tcase E_SImode:\n \t  func = \"_Qp_qtoui\";\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  func = \"_Qp_qtoux\";\n \t  break;\n \tdefault:\n@@ -7699,11 +7699,11 @@ sparc_preferred_simd_mode (machine_mode mode)\n   if (TARGET_VIS)\n     switch (mode)\n       {\n-      case SImode:\n+      case E_SImode:\n \treturn V2SImode;\n-      case HImode:\n+      case E_HImode:\n \treturn V4HImode;\n-      case QImode:\n+      case E_QImode:\n \treturn V8QImode;\n \n       default:;\n@@ -7973,23 +7973,23 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n \n       switch (mode)\n \t{\n-\tcase CCmode:\n-\tcase CCNZmode:\n-\tcase CCCmode:\n-\tcase CCVmode:\n+\tcase E_CCmode:\n+\tcase E_CCNZmode:\n+\tcase E_CCCmode:\n+\tcase E_CCVmode:\n \t  labelno = \"%%icc, \";\n \t  if (v8)\n \t    labelno = \"\";\n \t  break;\n-\tcase CCXmode:\n-\tcase CCXNZmode:\n-\tcase CCXCmode:\n-\tcase CCXVmode:\n+\tcase E_CCXmode:\n+\tcase E_CCXNZmode:\n+\tcase E_CCXCmode:\n+\tcase E_CCXVmode:\n \t  labelno = \"%%xcc, \";\n \t  gcc_assert (!v8);\n \t  break;\n-\tcase CCFPmode:\n-\tcase CCFPEmode:\n+\tcase E_CCFPmode:\n+\tcase E_CCFPEmode:\n \t  {\n \t    static char v9_fcc_labelno[] = \"%%fccX, \";\n \t    /* Set the char indicating the number of the fcc reg to use.  */\n@@ -9047,16 +9047,16 @@ sparc_print_operand (FILE *file, rtx x, int code)\n \t{\n \t  switch (GET_MODE (x))\n \t    {\n-\t    case CCmode:\n-\t    case CCNZmode:\n-\t    case CCCmode:\n-\t    case CCVmode:\n+\t    case E_CCmode:\n+\t    case E_CCNZmode:\n+\t    case E_CCCmode:\n+\t    case E_CCVmode:\n \t      s = \"%icc\";\n \t      break;\n-\t    case CCXmode:\n-\t    case CCXNZmode:\n-\t    case CCXCmode:\n-\t    case CCXVmode:\n+\t    case E_CCXmode:\n+\t    case E_CCXNZmode:\n+\t    case E_CCXCmode:\n+\t    case E_CCXVmode:\n \t      s = \"%xcc\";\n \t      break;\n \t    default:\n@@ -12439,7 +12439,7 @@ sparc_expand_vec_perm_bmask (machine_mode vmode, rtx sel)\n   sel = gen_lowpart (DImode, sel);\n   switch (vmode)\n     {\n-    case V2SImode:\n+    case E_V2SImode:\n       /* inp = xxxxxxxAxxxxxxxB */\n       t_1 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (16),\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n@@ -12458,7 +12458,7 @@ sparc_expand_vec_perm_bmask (machine_mode vmode, rtx sel)\n       /* sel = { A*4, A*4+1, A*4+2, ... } */\n       break;\n \n-    case V4HImode:\n+    case E_V4HImode:\n       /* inp = xxxAxxxBxxxCxxxD */\n       t_1 = expand_simple_binop (DImode, LSHIFTRT, sel, GEN_INT (8),\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n@@ -12495,7 +12495,7 @@ sparc_expand_vec_perm_bmask (machine_mode vmode, rtx sel)\n       /* sel = { A*2, A*2+1, B*2, B*2+1, ... } */\n       break;\n   \n-    case V8QImode:\n+    case E_V8QImode:\n       /* input = xAxBxCxDxExFxGxH */\n       sel = expand_simple_binop (DImode, AND, sel,\n \t\t\t\t GEN_INT ((HOST_WIDE_INT)0x0f0f0f0f << 32\n@@ -12793,15 +12793,15 @@ vector_init_bshuffle (rtx target, rtx elt, machine_mode mode,\n \n   switch (mode)\n     {\n-    case V2SImode:\n+    case E_V2SImode:\n       final_insn = gen_bshufflev2si_vis (target, t1, t1);\n       bmask = 0x45674567;\n       break;\n-    case V4HImode:\n+    case E_V4HImode:\n       final_insn = gen_bshufflev4hi_vis (target, t1, t1);\n       bmask = 0x67676767;\n       break;\n-    case V8QImode:\n+    case E_V8QImode:\n       final_insn = gen_bshufflev8qi_vis (target, t1, t1);\n       bmask = 0x77777777;\n       break;"}, {"sha": "72169374668bc700f2038f86f4bb1ec81298125d", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -292,13 +292,13 @@ spu_scalar_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case SFmode:\n-    case DImode:\n-    case TImode:\n-    case DFmode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_SFmode:\n+    case E_DImode:\n+    case E_TImode:\n+    case E_DFmode:\n       return true;\n \n     default:\n@@ -314,12 +314,12 @@ spu_vector_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case V16QImode:\n-    case V8HImode:\n-    case V4SImode:\n-    case V2DImode:\n-    case V4SFmode:\n-    case V2DFmode:\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SImode:\n+    case E_V2DImode:\n+    case E_V4SFmode:\n+    case E_V2DFmode:\n       return true;\n \n     default:\n@@ -496,13 +496,13 @@ spu_expand_insv (rtx ops[])\n     {\n       switch (dst_mode)\n \t{\n-\tcase SImode:\n+\tcase E_SImode:\n \t  emit_insn (gen_ashlsi3 (shift_reg, shift_reg, GEN_INT (shift)));\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  emit_insn (gen_ashldi3 (shift_reg, shift_reg, GEN_INT (shift)));\n \t  break;\n-\tcase TImode:\n+\tcase E_TImode:\n \t  emit_insn (gen_ashlti3 (shift_reg, shift_reg, GEN_INT (shift)));\n \t  break;\n \tdefault:\n@@ -802,50 +802,50 @@ spu_emit_branch_or_set (int is_set, rtx cmp, rtx operands[])\n \n   switch (op_mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       index = 0;\n       comp_mode = QImode;\n       break;\n-    case HImode:\n+    case E_HImode:\n       index = 1;\n       comp_mode = HImode;\n       break;\n-    case SImode:\n+    case E_SImode:\n       index = 2;\n       break;\n-    case DImode:\n+    case E_DImode:\n       index = 3;\n       break;\n-    case TImode:\n+    case E_TImode:\n       index = 4;\n       break;\n-    case SFmode:\n+    case E_SFmode:\n       index = 5;\n       break;\n-    case DFmode:\n+    case E_DFmode:\n       index = 6;\n       break;\n-    case V16QImode:\n+    case E_V16QImode:\n       index = 7;\n       comp_mode = op_mode;\n       break;\n-    case V8HImode:\n+    case E_V8HImode:\n       index = 8;\n       comp_mode = op_mode;\n       break;\n-    case V4SImode:\n+    case E_V4SImode:\n       index = 9;\n       comp_mode = op_mode;\n       break;\n-    case V4SFmode:\n+    case E_V4SFmode:\n       index = 10;\n       comp_mode = V4SImode;\n       break;\n-    case V2DFmode:\n+    case E_V2DFmode:\n       index = 11;\n       comp_mode = V2DImode;\n       break;\n-    case V2DImode:\n+    case E_V2DImode:\n     default:\n       abort ();\n     }\n@@ -3710,22 +3710,22 @@ spu_handle_vector_attribute (tree * node, tree name,\n   unsigned_p = TYPE_UNSIGNED (type);\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       result = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n       break;\n-    case SImode:\n+    case E_SImode:\n       result = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n       break;\n-    case HImode:\n+    case E_HImode:\n       result = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n       break;\n-    case QImode:\n+    case E_QImode:\n       result = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n       break;\n-    case SFmode:\n+    case E_SFmode:\n       result = V4SF_type_node;\n       break;\n-    case DFmode:\n+    case E_DFmode:\n       result = V2DF_type_node;\n       break;\n     default:\n@@ -5642,24 +5642,24 @@ spu_builtin_splats (rtx ops[])\n \tops[1] = force_reg (GET_MODE_INNER (mode), ops[1]);\n       switch (mode)\n \t{\n-\tcase V2DImode:\n-\tcase V2DFmode:\n+\tcase E_V2DImode:\n+\tcase E_V2DFmode:\n \t  shuf =\n \t    immed_double_const (0x0001020304050607ll, 0x1011121314151617ll,\n \t\t\t\tTImode);\n \t  break;\n-\tcase V4SImode:\n-\tcase V4SFmode:\n+\tcase E_V4SImode:\n+\tcase E_V4SFmode:\n \t  shuf =\n \t    immed_double_const (0x0001020300010203ll, 0x0001020300010203ll,\n \t\t\t\tTImode);\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  shuf =\n \t    immed_double_const (0x0203020302030203ll, 0x0203020302030203ll,\n \t\t\t\tTImode);\n \t  break;\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  shuf =\n \t    immed_double_const (0x0303030303030303ll, 0x0303030303030303ll,\n \t\t\t\tTImode);\n@@ -5684,22 +5684,22 @@ spu_builtin_extract (rtx ops[])\n     {\n       switch (mode)\n \t{\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  emit_insn (gen_vec_extractv16qiqi (ops[0], ops[1], ops[2]));\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  emit_insn (gen_vec_extractv8hihi (ops[0], ops[1], ops[2]));\n \t  break;\n-\tcase V4SFmode:\n+\tcase E_V4SFmode:\n \t  emit_insn (gen_vec_extractv4sfsf (ops[0], ops[1], ops[2]));\n \t  break;\n-\tcase V4SImode:\n+\tcase E_V4SImode:\n \t  emit_insn (gen_vec_extractv4sisi (ops[0], ops[1], ops[2]));\n \t  break;\n-\tcase V2DImode:\n+\tcase E_V2DImode:\n \t  emit_insn (gen_vec_extractv2didi (ops[0], ops[1], ops[2]));\n \t  break;\n-\tcase V2DFmode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_vec_extractv2dfdf (ops[0], ops[1], ops[2]));\n \t  break;\n \tdefault:\n@@ -5714,19 +5714,19 @@ spu_builtin_extract (rtx ops[])\n \n   switch (mode)\n     {\n-    case V16QImode:\n+    case E_V16QImode:\n       emit_insn (gen_addsi3 (tmp, ops[2], GEN_INT (-3)));\n       break;\n-    case V8HImode:\n+    case E_V8HImode:\n       emit_insn (gen_addsi3 (tmp, ops[2], ops[2]));\n       emit_insn (gen_addsi3 (tmp, tmp, GEN_INT (-2)));\n       break;\n-    case V4SFmode:\n-    case V4SImode:\n+    case E_V4SFmode:\n+    case E_V4SImode:\n       emit_insn (gen_ashlsi3 (tmp, ops[2], GEN_INT (2)));\n       break;\n-    case V2DImode:\n-    case V2DFmode:\n+    case E_V2DImode:\n+    case E_V2DFmode:\n       emit_insn (gen_ashlsi3 (tmp, ops[2], GEN_INT (3)));\n       break;\n     default:\n@@ -5786,20 +5786,20 @@ spu_builtin_promote (rtx ops[])\n       offset = gen_reg_rtx (SImode);\n       switch (mode)\n \t{\n-\tcase V16QImode:\n+\tcase E_V16QImode:\n \t  emit_insn (gen_subsi3 (offset, GEN_INT (3), ops[2]));\n \t  break;\n-\tcase V8HImode:\n+\tcase E_V8HImode:\n \t  emit_insn (gen_subsi3 (offset, GEN_INT (1), ops[2]));\n \t  emit_insn (gen_addsi3 (offset, offset, offset));\n \t  break;\n-\tcase V4SFmode:\n-\tcase V4SImode:\n+\tcase E_V4SFmode:\n+\tcase E_V4SImode:\n \t  emit_insn (gen_subsi3 (offset, GEN_INT (0), ops[2]));\n \t  emit_insn (gen_ashlsi3 (offset, offset, GEN_INT (2)));\n \t  break;\n-\tcase V2DImode:\n-\tcase V2DFmode:\n+\tcase E_V2DImode:\n+\tcase E_V2DFmode:\n \t  emit_insn (gen_ashlsi3 (offset, ops[2], GEN_INT (3)));\n \t  break;\n \tdefault:\n@@ -5915,19 +5915,19 @@ spu_expand_sign_extend (rtx ops[])\n \tarr[i] = 0x10;\n       switch (GET_MODE (ops[1]))\n \t{\n-\tcase HImode:\n+\tcase E_HImode:\n \t  sign = gen_reg_rtx (SImode);\n \t  emit_insn (gen_extendhisi2 (sign, ops[1]));\n \t  arr[last] = 0x03;\n \t  arr[last - 1] = 0x02;\n \t  break;\n-\tcase SImode:\n+\tcase E_SImode:\n \t  sign = gen_reg_rtx (SImode);\n \t  emit_insn (gen_ashrsi3 (sign, ops[1], GEN_INT (31)));\n \t  for (i = 0; i < 4; i++)\n \t    arr[last - i] = 3 - i;\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  sign = gen_reg_rtx (SImode);\n \t  c = gen_reg_rtx (SImode);\n \t  emit_insn (gen_spu_convert (c, ops[1]));"}, {"sha": "1dcac599967e4aed98d700d9222ab668882f0fdb", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -111,15 +111,15 @@ tilegx_scalar_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case DImode:\n-    case TImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_DImode:\n+    case E_TImode:\n       return true;\n \n-    case SFmode:\n-    case DFmode:\n+    case E_SFmode:\n+    case E_DFmode:\n       return true;\n \n     default:\n@@ -1466,16 +1466,16 @@ tilegx_simd_int (rtx num, machine_mode mode)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       n = 0x0101010101010101LL * (n & 0x000000FF);\n       break;\n-    case HImode:\n+    case E_HImode:\n       n = 0x0001000100010001LL * (n & 0x0000FFFF);\n       break;\n-    case SImode:\n+    case E_SImode:\n       n = 0x0000000100000001LL * (n & 0xFFFFFFFF);\n       break;\n-    case DImode:\n+    case E_DImode:\n       break;\n     default:\n       gcc_unreachable ();"}, {"sha": "b63fc57c9ea59718bcde8b960e5b121807769aa8", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -88,14 +88,14 @@ tilepro_scalar_mode_supported_p (machine_mode mode)\n {\n   switch (mode)\n     {\n-    case QImode:\n-    case HImode:\n-    case SImode:\n-    case DImode:\n+    case E_QImode:\n+    case E_HImode:\n+    case E_SImode:\n+    case E_DImode:\n       return true;\n \n-    case SFmode:\n-    case DFmode:\n+    case E_SFmode:\n+    case E_DFmode:\n       return true;\n \n     default:\n@@ -1208,15 +1208,15 @@ tilepro_simd_int (rtx num, machine_mode mode)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       n = 0x01010101 * (n & 0x000000FF);\n       break;\n-    case HImode:\n+    case E_HImode:\n       n = 0x00010001 * (n & 0x0000FFFF);\n       break;\n-    case SImode:\n+    case E_SImode:\n       break;\n-    case DImode:\n+    case E_DImode:\n       break;\n     default:\n       gcc_unreachable ();"}, {"sha": "ffdce9887744361c661c545ca9930ac3b677ef8f", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -270,19 +270,19 @@ const_double_split (rtx x, HOST_WIDE_INT * p_high, HOST_WIDE_INT * p_low)\n \n       switch (GET_MODE (x))\n \t{\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  REAL_VALUE_TO_TARGET_DOUBLE (*CONST_DOUBLE_REAL_VALUE (x), t);\n \t  *p_high = t[1];\t/* since v850 is little endian */\n \t  *p_low = t[0];\t/* high is second word */\n \t  return;\n \n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (x), *p_high);\n \t  *p_low = 0;\n \t  return;\n \n-\tcase VOIDmode:\n-\tcase DImode:\n+\tcase E_VOIDmode:\n+\tcase E_DImode:\n \t  *p_high = CONST_DOUBLE_HIGH (x);\n \t  *p_low  = CONST_DOUBLE_LOW (x);\n \t  return;\n@@ -594,10 +594,10 @@ v850_print_operand (FILE * file, rtx x, int code)\n \tdefault:\n \t  gcc_unreachable ();\n \n-\tcase QImode: fputs (\".b\", file); break;\n-\tcase HImode: fputs (\".h\", file); break;\n-\tcase SImode: fputs (\".w\", file); break;\n-\tcase SFmode: fputs (\".w\", file); break;\n+\tcase E_QImode: fputs (\".b\", file); break;\n+\tcase E_HImode: fputs (\".h\", file); break;\n+\tcase E_SImode: fputs (\".w\", file); break;\n+\tcase E_SFmode: fputs (\".w\", file); break;\n \t}\n       break;\n     case '.':\t\t\t/* Register r0.  */\n@@ -1020,7 +1020,7 @@ ep_memory_offset (machine_mode mode, int unsignedp ATTRIBUTE_UNUSED)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       if (TARGET_SMALL_SLD)\n \tmax_offset = (1 << 4);\n       else if ((TARGET_V850E_UP)\n@@ -1030,7 +1030,7 @@ ep_memory_offset (machine_mode mode, int unsignedp ATTRIBUTE_UNUSED)\n \tmax_offset = (1 << 7);\n       break;\n \n-    case HImode:\n+    case E_HImode:\n       if (TARGET_SMALL_SLD)\n \tmax_offset = (1 << 5);\n       else if ((TARGET_V850E_UP)\n@@ -1040,8 +1040,8 @@ ep_memory_offset (machine_mode mode, int unsignedp ATTRIBUTE_UNUSED)\n \tmax_offset = (1 << 8);\n       break;\n \n-    case SImode:\n-    case SFmode:\n+    case E_SImode:\n+    case E_SFmode:\n       max_offset = (1 << 8);\n       break;\n       "}, {"sha": "5989607be75bee7149c72a34165e5eebaa61f445", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -822,18 +822,18 @@ vax_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     case MULT:\n       switch (mode)\n \t{\n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  *total = 16;\t\t/* 4 on VAX 9000 */\n \t  break;\n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  *total = 9;\t\t/* 4 on VAX 9000, 12 on VAX 2 */\n \t  break;\n-\tcase DImode:\n+\tcase E_DImode:\n \t  *total = 16;\t\t/* 6 on VAX 9000, 28 on VAX 2 */\n \t  break;\n-\tcase SImode:\n-\tcase HImode:\n-\tcase QImode:\n+\tcase E_SImode:\n+\tcase E_HImode:\n+\tcase E_QImode:\n \t  *total = 10;\t\t/* 3-4 on VAX 9000, 20-28 on VAX 2 */\n \t  break;\n \tdefault:\n@@ -1144,7 +1144,7 @@ vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       if (operands[1] == const0_rtx)\n \treturn \"clrq %0\";\n       if (TARGET_QMATH && optimize_size\n@@ -1257,7 +1257,7 @@ vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t}\n       return \"movq %1,%0\";\n \n-    case SImode:\n+    case E_SImode:\n       if (symbolic_operand (operands[1], SImode))\n \t{\n \t  if (push_operand (operands[0], SImode))\n@@ -1300,7 +1300,7 @@ vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \treturn \"pushl %1\";\n       return \"movl %1,%0\";\n \n-    case HImode:\n+    case E_HImode:\n       if (CONST_INT_P (operands[1]))\n \t{\n \t  HOST_WIDE_INT i = INTVAL (operands[1]);\n@@ -1317,7 +1317,7 @@ vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t}\n       return \"movw %1,%0\";\n \n-    case QImode:\n+    case E_QImode:\n       if (CONST_INT_P (operands[1]))\n \t{\n \t  HOST_WIDE_INT i = INTVAL (operands[1]);\n@@ -1352,7 +1352,7 @@ vax_output_int_add (rtx insn, rtx *operands, machine_mode mode)\n {\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       {\n \trtx low[3];\n \tconst char *pattern;\n@@ -1438,7 +1438,7 @@ vax_output_int_add (rtx insn, rtx *operands, machine_mode mode)\n \treturn \"adwc %2,%0\";\n       }\n \n-    case SImode:\n+    case E_SImode:\n       if (rtx_equal_p (operands[0], operands[1]))\n \t{\n \t  if (operands[2] == const1_rtx)\n@@ -1514,7 +1514,7 @@ vax_output_int_add (rtx insn, rtx *operands, machine_mode mode)\n \n       return \"addl3 %1,%2,%0\";\n \n-    case HImode:\n+    case E_HImode:\n       if (rtx_equal_p (operands[0], operands[1]))\n \t{\n \t  if (operands[2] == const1_rtx)\n@@ -1533,7 +1533,7 @@ vax_output_int_add (rtx insn, rtx *operands, machine_mode mode)\n \treturn \"subw3 $%n2,%1,%0\";\n       return \"addw3 %1,%2,%0\";\n \n-    case QImode:\n+    case E_QImode:\n       if (rtx_equal_p (operands[0], operands[1]))\n \t{\n \t  if (operands[2] == const1_rtx)\n@@ -1562,7 +1562,7 @@ vax_output_int_subtract (rtx insn, rtx *operands, machine_mode mode)\n {\n   switch (mode)\n     {\n-    case DImode:\n+    case E_DImode:\n       {\n \trtx low[3];\n \tconst char *pattern;"}, {"sha": "a24e0321a7dce0afbeadc2a46341b423e6493bff", "filename": "gcc/config/visium/predicates.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fpredicates.md?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -153,16 +153,16 @@\n {\n   switch (GET_MODE (XEXP (op, 0)))\n     {\n-    case CCmode:\n+    case E_CCmode:\n       return ordered_comparison_operator (op, mode);\n-    case CCNZmode:\n+    case E_CCNZmode:\n       return visium_nz_comparison_operator (op, mode);\n-    case CCCmode:\n+    case E_CCCmode:\n       return visium_c_comparison_operator (op, mode);\n-    case CCVmode:\n+    case E_CCVmode:\n       return visium_v_comparison_operator (op, mode);\n-    case CCFPmode:\n-    case CCFPEmode:\n+    case E_CCFPmode:\n+    case E_CCFPEmode:\n       return visium_fp_comparison_operator (op, mode);\n     default:\n       return false;"}, {"sha": "aa14d2b5c4987a1ec177a5059178e4f84c5d135b", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1719,18 +1719,18 @@ rtx_ok_for_offset_p (machine_mode mode, rtx op)\n \n   switch (mode)\n     {\n-    case QImode:\n+    case E_QImode:\n       return INTVAL (op) <= 31;\n \n-    case HImode:\n+    case E_HImode:\n       return (INTVAL (op) % 2) == 0 && INTVAL (op) < 63;\n \n-    case SImode:\n-    case SFmode:\n+    case E_SImode:\n+    case E_SFmode:\n       return (INTVAL (op) % 4) == 0 && INTVAL (op) < 127;\n \n-    case DImode:\n-    case DFmode:\n+    case E_DImode:\n+    case E_DFmode:\n       return (INTVAL (op) % 4) == 0 && INTVAL (op) < 123;\n \n     default:\n@@ -3323,18 +3323,18 @@ visium_print_operand_address (FILE *file, machine_mode mode, rtx addr)\n \t\tHOST_WIDE_INT val = INTVAL (y);\n \t\tswitch (mode)\n \t\t  {\n-\t\t  case SImode:\n-\t\t  case DImode:\n-\t\t  case SFmode:\n-\t\t  case DFmode:\n+\t\t  case E_SImode:\n+\t\t  case E_DImode:\n+\t\t  case E_SFmode:\n+\t\t  case E_DFmode:\n \t\t    val >>= 2;\n \t\t    break;\n \n-\t\t  case HImode:\n+\t\t  case E_HImode:\n \t\t    val >>= 1;\n \t\t    break;\n \n-\t\t  case QImode:\n+\t\t  case E_QImode:\n \t\t  default:\n \t\t    break;\n \t\t  }"}, {"sha": "1f055fa903cc0a7dd98961ecac93252b53fb81eb", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1528,13 +1528,13 @@ do\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \t\t\\\n   switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-    case SImode:\t\t\t\t\t\t\t\\\n+    case E_SImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n-    case HImode:\t\t\t\t\t\t\t\\\n+    case E_HImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.word\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n-    case QImode:\t\t\t\t\t\t\t\\\n+    case E_QImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     default:\t\t\t\t\t\t\t\t\\"}, {"sha": "14219bcdb116eef4dd8a17f48eb30901a874a805", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -591,7 +591,7 @@ xtensa_mem_offset (unsigned v, machine_mode mode)\n {\n   switch (mode)\n     {\n-    case BLKmode:\n+    case E_BLKmode:\n       /* Handle the worst case for block moves.  See xtensa_expand_block_move\n \t where we emit an optimized block move operation if the block can be\n \t moved in < \"move_ratio\" pieces.  The worst case is when the block is\n@@ -600,13 +600,13 @@ xtensa_mem_offset (unsigned v, machine_mode mode)\n       return (xtensa_uimm8 (v)\n \t      && xtensa_uimm8 (v + MOVE_MAX * LARGEST_MOVE_RATIO));\n \n-    case QImode:\n+    case E_QImode:\n       return xtensa_uimm8 (v);\n \n-    case HImode:\n+    case E_HImode:\n       return xtensa_uimm8x2 (v);\n \n-    case DFmode:\n+    case E_DFmode:\n       return (xtensa_uimm8x4 (v) && xtensa_uimm8x4 (v + 4));\n \n     default:\n@@ -802,16 +802,16 @@ xtensa_expand_conditional_branch (rtx *operands, machine_mode mode)\n \n   switch (mode)\n     {\n-    case DFmode:\n+    case E_DFmode:\n     default:\n       fatal_insn (\"bad test\", gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));\n \n-    case SImode:\n+    case E_SImode:\n       invert = FALSE;\n       cmp = gen_int_relational (test_code, cmp0, cmp1, &invert);\n       break;\n \n-    case SFmode:\n+    case E_SFmode:\n       if (!TARGET_HARD_FLOAT)\n \tfatal_insn (\"bad test\", gen_rtx_fmt_ee (test_code, VOIDmode,\n \t\t\t\t\t\tcmp0, cmp1));\n@@ -1161,25 +1161,25 @@ xtensa_copy_incoming_a7 (rtx opnd)\n \n   switch (mode)\n     {\n-    case DFmode:\n-    case DImode:\n+    case E_DFmode:\n+    case E_DImode:\n       /* Copy the value out of A7 here but keep the first word in A6 until\n \t after the set_frame_ptr insn.  Otherwise, the register allocator\n \t may decide to put \"subreg (tmp, 0)\" in A7 and clobber the incoming\n \t value.  */\n       emit_insn (gen_movsi_internal (gen_rtx_SUBREG (SImode, tmp, 4),\n \t\t\t\t     gen_raw_REG (SImode, A7_REG)));\n       break;\n-    case SFmode:\n+    case E_SFmode:\n       emit_insn (gen_movsf_internal (tmp, gen_raw_REG (mode, A7_REG)));\n       break;\n-    case SImode:\n+    case E_SImode:\n       emit_insn (gen_movsi_internal (tmp, gen_raw_REG (mode, A7_REG)));\n       break;\n-    case HImode:\n+    case E_HImode:\n       emit_insn (gen_movhi_internal (tmp, gen_raw_REG (mode, A7_REG)));\n       break;\n-    case QImode:\n+    case E_QImode:\n       emit_insn (gen_movqi_internal (tmp, gen_raw_REG (mode, A7_REG)));\n       break;\n     default:\n@@ -2581,15 +2581,15 @@ xtensa_output_literal (FILE *file, rtx x, machine_mode mode, int labelno)\n \n       switch (mode)\n \t{\n-\tcase SFmode:\n+\tcase E_SFmode:\n \t  REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (x),\n \t\t\t\t       value_long[0]);\n \t  if (HOST_BITS_PER_LONG > 32)\n \t    value_long[0] &= 0xffffffff;\n \t  fprintf (file, \"0x%08lx\\n\", value_long[0]);\n \t  break;\n \n-\tcase DFmode:\n+\tcase E_DFmode:\n \t  REAL_VALUE_TO_TARGET_DOUBLE (*CONST_DOUBLE_REAL_VALUE (x),\n \t\t\t\t       value_long);\n \t  if (HOST_BITS_PER_LONG > 32)"}, {"sha": "3c98f56cf6910fab18868e62098b650c16291839", "filename": "gcc/dfp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -720,13 +720,13 @@ decimal_real_maxval (REAL_VALUE_TYPE *r, int sign, machine_mode mode)\n \n   switch (mode)\n     {\n-    case SDmode:\n+    case E_SDmode:\n       max = \"9.999999E96\";\n       break;\n-    case DDmode:\n+    case E_DDmode:\n       max = \"9.999999999999999E384\";\n       break;\n-    case TDmode:\n+    case E_TDmode:\n       max = \"9.999999999999999999999999999999999E6144\";\n       break;\n     default:"}, {"sha": "0e59ebf65daf9fd03f6dcb7d3f98f6edb9117596", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* objc-encoding.c (encode_gnu_bitfield): Prefix mode names with E_ in\n+\tcase statements.\n+\n 2017-08-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/81417"}, {"sha": "fa15c315f1f4fbeb590ddb30d8bced8e7174addd", "filename": "gcc/objc/objc-encoding.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fobjc%2Fobjc-encoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Fobjc%2Fobjc-encoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-encoding.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -756,19 +756,19 @@ encode_gnu_bitfield (int position, tree type, int size)\n \t{\n \t  switch (TYPE_MODE (type))\n \t    {\n-\t    case QImode:\n+\t    case E_QImode:\n \t      charType = 'C'; break;\n-\t    case HImode:\n+\t    case E_HImode:\n \t      charType = 'S'; break;\n-\t    case SImode:\n+\t    case E_SImode:\n \t      {\n \t\tif (type == long_unsigned_type_node)\n \t\t  charType = 'L';\n \t\telse\n \t\t  charType = 'I';\n \t\tbreak;\n \t      }\n-\t    case DImode:\n+\t    case E_DImode:\n \t      charType = 'Q'; break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -779,19 +779,19 @@ encode_gnu_bitfield (int position, tree type, int size)\n \t{\n \t  switch (TYPE_MODE (type))\n \t    {\n-\t    case QImode:\n+\t    case E_QImode:\n \t      charType = 'c'; break;\n-\t    case HImode:\n+\t    case E_HImode:\n \t      charType = 's'; break;\n-\t    case SImode:\n+\t    case E_SImode:\n \t      {\n \t\tif (type == long_integer_type_node)\n \t\t  charType = 'l';\n \t\telse\n \t\t  charType = 'i';\n \t\tbreak;\n \t      }\n-\t    case DImode:\n+\t    case E_DImode:\n \t      charType = 'q'; break;\n \t    default:\n \t      gcc_unreachable ();"}, {"sha": "1be139f1afe24d106200a2158964dae46144242e", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -448,16 +448,16 @@ default_libgcc_floating_mode_supported_p (machine_mode mode)\n   switch (mode)\n     {\n #ifdef HAVE_SFmode\n-    case SFmode:\n+    case E_SFmode:\n #endif\n #ifdef HAVE_DFmode\n-    case DFmode:\n+    case E_DFmode:\n #endif\n #ifdef HAVE_XFmode\n-    case XFmode:\n+    case E_XFmode:\n #endif\n #ifdef HAVE_TFmode\n-    case TFmode:\n+    case E_TFmode:\n #endif\n       return true;\n "}, {"sha": "b36962c1c847dc0d1594b2f00ccfd3d565db5115", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* encoding.c (_darwin_rs6000_special_round_type_align): Prefix mode\n+\tnames with E_ in case statements.\n+\n 2017-02-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/79256"}, {"sha": "776b82d001630f343380bad6ce4076a3154000cd", "filename": "libobjc/encoding.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e10a5a74b2571a72ab944195267334d56b9534b/libobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e10a5a74b2571a72ab944195267334d56b9534b/libobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.c?ref=4e10a5a74b2571a72ab944195267334d56b9534b", "patch": "@@ -162,7 +162,7 @@ _darwin_rs6000_special_round_type_align (const char *struc, int comp, int spec)\n       case UNION_TYPE:\n \treturn MAX (MAX (comp, spec), objc_alignof_type (_stp) * __CHAR_BIT__);\n \tbreak;\n-      case DFmode:\n+      case E_DFmode:\n       case _C_LNG_LNG:\n       case _C_ULNG_LNG:\n \treturn MAX (MAX (comp, spec), 64);"}]}