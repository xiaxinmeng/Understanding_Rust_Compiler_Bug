{"sha": "e67051746fe23e90166655680af3bfe0b0e3f48f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY3MDUxNzQ2ZmUyM2U5MDE2NjY1NTY4MGFmM2JmZTBiMGUzZjQ4Zg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-01-26T01:55:09Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-01-26T01:55:09Z"}, "message": "fstream.tcc (filebuf::close()): Fix close for input streams.\n\n\n2002-01-25  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/fstream.tcc (filebuf::close()): Fix close for input\n\tstreams.\n\t(filebuf::_M_really_overflow): Match indeterminate and sync calls.\n\t* testsuite/27_io/filebuf.cc: Compile only.\n\t* testsuite/27_io/filebuf_members.cc: Move tests to here.\n\t* testsuite/27_io/filebuf_virtuals.cc: And here.\n\tRevert sungetc, sync changes for expected values.\n\t* testsuite/27_io/filebuf-*: Move to...\n\t* testsuite/27_io/filebuf_virtuals-*: ...here.\n\t* testsuite/27_io/istream.cc: Compile only, activate.\n\t* testsuite/27_io/ostream.cc: Same.\n\t* testsuite/27_io/iostream.cc: New.\n\t* testsuite/27_io/iostream_members.cc: New.\n\nFrom-SVN: r49236", "tree": {"sha": "022ed42d506533c4a2fe00704fafb57484582599", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/022ed42d506533c4a2fe00704fafb57484582599"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e67051746fe23e90166655680af3bfe0b0e3f48f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67051746fe23e90166655680af3bfe0b0e3f48f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67051746fe23e90166655680af3bfe0b0e3f48f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67051746fe23e90166655680af3bfe0b0e3f48f/comments", "author": null, "committer": null, "parents": [{"sha": "751551d5c6134b8297e3862e27b332e7d3399f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/751551d5c6134b8297e3862e27b332e7d3399f41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/751551d5c6134b8297e3862e27b332e7d3399f41"}], "stats": {"total": 1345, "additions": 715, "deletions": 630}, "files": [{"sha": "47e43bdbf473e0bbd864c98a76f95ef92030a217", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -1,3 +1,19 @@\n+2002-01-25  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/fstream.tcc (filebuf::close()): Fix close for input\n+\tstreams.\n+\t(filebuf::_M_really_overflow): Match indeterminate and sync calls.\n+\t* testsuite/27_io/filebuf.cc: Compile only.\n+\t* testsuite/27_io/filebuf_members.cc: Move tests to here.\n+\t* testsuite/27_io/filebuf_virtuals.cc: And here.\n+\tRevert sungetc, sync changes for expected values.\n+\t* testsuite/27_io/filebuf-*: Move to...\n+\t* testsuite/27_io/filebuf_virtuals-*: ...here.\n+\t* testsuite/27_io/istream.cc: Compile only, activate.\n+\t* testsuite/27_io/ostream.cc: Same.\n+\t* testsuite/27_io/iostream.cc: New.\n+\t* testsuite/27_io/iostream_members.cc: New.\n+\n 2002-01-25  David Billinghurst <David.Billinghurst@riotinto.com>\n \n \t* testsuite/thread/pthread1.cc: Enable on cygwin."}, {"sha": "420516bb50173b3d285a3a9277c1d5b55c70d4d6", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -1,6 +1,7 @@\n // File based streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -181,31 +182,31 @@ namespace std\n       __filebuf_type *__ret = NULL;\n       if (this->is_open())\n \t{\n+\t  const int_type __eof = traits_type::eof();\n \t  bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n-\t  if (__testput\n-\t      && _M_really_overflow(traits_type::eof()) != traits_type::eof())\n-\t    {\n-\t      // NB: Do this here so that re-opened filebufs will be cool...\n-\t      _M_mode = ios_base::openmode(0);\n-\t      _M_destroy_internal_buffer();\n-\t      \n-\t      _M_pback_destroy();\n-\t      if (_M_pback)\n-\t\t{\n-\t\t  delete [] _M_pback;\n-\t\t  _M_pback = NULL;\n-\t\t}\n+\t  if (__testput && _M_really_overflow(__eof) == __eof)\n+\t    return __ret;\n \n+\t  // NB: Do this here so that re-opened filebufs will be cool...\n+\t  _M_mode = ios_base::openmode(0);\n+\t  _M_destroy_internal_buffer();\n+\t  \n+\t  _M_pback_destroy();\n+\t  if (_M_pback)\n+\t    {\n+\t      delete [] _M_pback;\n+\t      _M_pback = NULL;\n+\t    }\n+\t  \n #if 0\n \t  // XXX not done\n \t  if (_M_last_overflowed)\n \t    {\n \t      _M_output_unshift();\n-\t      _M_really_overflow(traits_type::eof());\n+\t      _M_really_overflow(__eof);\n \t    }\n #endif\n-\t      __ret = this;\n-\t    }\n+\t  __ret = this;\n \t}\n \n       // Can actually allocate this file as part of an open and never\n@@ -429,11 +430,11 @@ namespace std\n \n \t  // NB: Need this so that external byte sequence reflects\n \t  // internal buffer.\n-\t  if (__len == __plen)\n-\t    _M_set_indeterminate();\n-\n-\t  if (!_M_file->sync())\n-\t    __ret = traits_type::not_eof(__c);\n+\t  if (__len == __plen && !_M_file->sync())\n+\t    {\n+\t      _M_set_indeterminate();\n+\t      __ret = traits_type::not_eof(__c);\n+\t    }\n #else\n \t  // Part one: Allocate temporary conversion buffer on\n \t  // stack. Convert internal buffer plus __c (ie,\n@@ -609,3 +610,8 @@ namespace std\n #endif // _CPP_BITS_FSTREAM_TCC\n \n \n+\n+\n+\n+\n+"}, {"sha": "558d196f9fb359de9dc8a8522b397a55cb102f62", "filename": "libstdc++-v3/testsuite/27_io/filebuf.cc", "status": "modified", "additions": 9, "deletions": 555, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -1,6 +1,7 @@\n-// 990117 bkoz test functionality of basic_filebuf for char_type == char\n+// 1999-01-17 bkoz test functionality of basic_filebuf for char_type == char\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 \n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,578 +22,31 @@\n // NB: this test assumes that _M_buf_size == 40, and not the usual\n // buffer_size length of BUFSIZ (8192), so that overflow/underflow can be\n // simulated a bit more readily.\n-// NRB (Nota Really Bene): setting it to 40 breaks the test, as intended.\n-\n-// @require@ %-*.tst %-*.txt\n-// @diff@ %-*.tst %*.txt\n-\n-const int buffer_size = 8192;\n-//const int buffer_size = 40;\n \n #include <fstream>\n-#include <iostream>\n #include <testsuite_hooks.h>\n \n-const char carray_01[] = \"santa cruz or sandiego?\";\n-const char carray_02[] = \"memphis, new orleans, and savanah\";\n-const char name_01[] = \"filebuf-1.txt\"; // file with data in it\n-const char name_02[] = \"filebuf-2.txt\"; // empty file, need to create\n-const char name_03[] = \"filebuf-3.txt\"; // empty file, need to create\n-\n-class derived_filebuf: public std::filebuf\n-{\n- public:\n-  void\n-  set_size(int_type __size) { _M_buf_size_opt = __size; }\n-};\n-\n-derived_filebuf fb_01; // in \n-derived_filebuf fb_02; // out\n-derived_filebuf fb_03; // in | out\n-\n-\n-// initialize filebufs to be the same size regardless of platform\n-void test00()\n-{\n-  fb_01.set_size(buffer_size);\n-  fb_02.set_size(buffer_size);\n-  fb_03.set_size(buffer_size);\n-}\n-\n-\n-// test the filebuf/stringbuf locale settings\n-bool test01() {\n-  std::locale loc_tmp;\n-  loc_tmp = fb_01.getloc();\n-  fb_01.pubimbue(loc_tmp); //This should initialize _M_init to true\n-  fb_01.getloc(); //This should just return _M_locale\n-\n-  return true;\n-}\n-\n-\n-// test member functions functions\n-bool test02() {\n-  bool \t\t\ttest = true;\n-\n-  // bool is_open()\n-  VERIFY( !fb_01.is_open() );\n-  VERIFY( !fb_02.is_open() );\n-  VERIFY( !fb_03.is_open() );\n-\n-  // filebuf_type* open(const char* __s, ios_base::openmode __mode)\n-  fb_01.open(name_01, std::ios_base::in | std::ios_base::ate);\n-  fb_02.open(name_02, std::ios_base::in | std::ios_base::out | std::ios_base::trunc);\n-  // Try to open two different files without closing the first:\n-  // Should keep the old file attached, and disregard attempt to overthrow.\n-  fb_02.open(name_03, std::ios_base::in | std::ios_base::out);\n-  fb_03.open(name_03, std::ios_base::out | std::ios_base::trunc);\n-  VERIFY( fb_01.is_open() );\n-  VERIFY( fb_02.is_open() );\n-  VERIFY( fb_03.is_open() );\n-\n-  // filebuf_type* close()\n-  fb_01.close();\n-  fb_02.close();\n-  fb_03.close();\n-  VERIFY( !fb_01.is_open() );\n-  VERIFY( !fb_02.is_open() );\n-  VERIFY( !fb_03.is_open() );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n-  return test;\n-}\n-\n-\n-// test overloaded virtual functions\n-bool test03() {\n-  typedef std::filebuf::int_type \tint_type;\n-  typedef std::filebuf::traits_type \ttraits_type;\n-  typedef std::filebuf::pos_type \tpos_type;\n-  typedef std::filebuf::off_type \toff_type;\n-  typedef size_t \t\t\tsize_type;\n-\n-  bool \t\t\t\t\ttest = true;\n-  std::filebuf \t\t\t\tf_tmp;\n-  std::streamsize \t\t\tstrmsz_1, strmsz_2;\n-  std::streamoff  \t\t\tstrmof_1, strmof_2;\n-  int \t\t\t\t\ti = 0, j = 0, k = 0;\n-\n-  // GET\n-  // int showmanyc()\n-  // returns an estimate of the numbers of chars in the seq, or -1.\n-  // if __retval > 0, then calls to underflow won't return\n-  // traits_type::eof() till at least __retval chars. \n-  // if __retval == -1, then calls to underflow or uflow will fail.\n-  // NB overriding def if it can determine more chars can be read from \n-  // the input sequence.\n-\n-  // int in_avail()\n-  // if a read position is available, return _M_in_end - _M_in_cur.\n-  // else return showmanyc.\n-  strmof_1 = fb_01.in_avail();\n-  strmof_2 = fb_02.in_avail();\n-  VERIFY( strmof_1 == -1 );\n-  VERIFY( strmof_1 == strmof_2 ); //fail because not open\n-  strmof_1 = fb_03.in_avail();\n-  VERIFY( strmof_1 == strmof_2 );\n-  fb_01.open(name_01, std::ios_base::in);\n-  fb_02.open(name_02, std::ios_base::out | std::ios_base::trunc);\n-  fb_03.open(name_03, std::ios_base::out | std::ios_base::in | std::ios_base::trunc); \n-  strmof_1 = fb_01.in_avail();\n-  strmof_2 = fb_02.in_avail();\n-  VERIFY( strmof_1 != strmof_2 );\n-  VERIFY( strmof_1 >= 0 );\n-  VERIFY( strmof_2 == -1 );  // empty file\n-  strmof_1 = fb_03.in_avail(); \n-  VERIFY( strmof_1  == 0 ); // empty file\n-\n-  // int_type sbumpc()\n-  // if read_cur not avail returns uflow(), else return *read_cur & increment\n-  int_type c1 = fb_01.sbumpc();\n-  int_type c2 = fb_02.sbumpc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c1 == '/' );\n-  VERIFY( c2 == -1 );\n-  int_type c3 = fb_01.sbumpc();\n-  int_type c4 = fb_02.sbumpc();\n-  VERIFY( c3 != c4 );\n-  VERIFY( c1 == c3 ); // fluke, both happen to be '/'\n-  VERIFY( c2 == c4 );\n-  int_type c5 = fb_03.sbumpc();\n-  VERIFY( c5 == traits_type::eof() );\n-  // XXX should do some kind of test to make sure that internal\n-  // buffers point ot the same thing, to check consistancy.\n-\n-  // int_type sgetc()\n-  // if read_cur not avail, return uflow(), else return *read_cur  \n-  int_type c6 = fb_01.sgetc();\n-  int_type c7 = fb_02.sgetc();\n-  VERIFY( c6 != c3 );\n-  VERIFY( c7 == c4 ); // both -1\n-  int_type c8 = fb_01.sgetc();\n-  int_type c9 = fb_02.sgetc();\n-  VERIFY( c6 == c8 );\n-  VERIFY( c7 == c9 );\n-  c5 = fb_03.sgetc();\n-  VERIFY( c5 == traits_type::eof() );\n-\n-  // int_type snextc()\n-  // calls sbumpc and if sbumpc != eof, return sgetc\n-  c6 = fb_01.snextc();\n-  c7 = fb_02.snextc();\n-  VERIFY( c6 != c8 );\n-  VERIFY( c7 == c9 ); // -1\n-  VERIFY( c6 == '9' );\n-  c6 = fb_01.snextc();\n-  c7 = fb_02.snextc();\n-  VERIFY( c6 != c8 );\n-  VERIFY( c7 == c9 ); // -1\n-  VERIFY( c6 == '9' );\n-  c5 = fb_03.snextc();\n-  VERIFY( c5 == traits_type::eof() );\n-\n-  // streamsize sgetn(char_type *s, streamsize n)\n-  // streamsize xsgetn(char_type *s, streamsize n)\n-  // assign up to n chars to s from input sequence, indexing in_cur as\n-  // approp and returning the number of chars assigned\n-  strmsz_1 = fb_01.in_avail();\n-  strmsz_2 = fb_02.in_avail();\n-  test = strmsz_1 != strmsz_2;\n-  char carray1[13] = \"\";\n-  strmsz_1 = fb_01.sgetn(carray1, 10);\n-  char carray2[buffer_size] = \"\";\n-  strmsz_2 = fb_02.sgetn(carray2, 10);\n-  VERIFY( strmsz_1 != strmsz_2 );\n-  VERIFY( strmsz_1 == 10 );\n-  VERIFY( strmsz_2 == 0 );\n-  c1 = fb_01.sgetc();\n-  c2 = fb_02.sgetc();\n-  VERIFY( c1 == '\\n' );  \n-  VERIFY( c7 == c2 ); // n != i\n-  strmsz_1 = fb_03.sgetn(carray1, 10);\n-  VERIFY( !strmsz_1 ); //zero\n-  strmsz_1 = fb_01.in_avail();\n-  strmsz_2 = fb_01.sgetn(carray2, strmsz_1 + 5);\n-  VERIFY( strmsz_1 == strmsz_2 - 5 ); \n-  c4 = fb_01.sgetc(); // buffer should have underflowed from above.\n-  VERIFY( c4 == 'i' );\n-  strmsz_1 = fb_01.in_avail();\n-  VERIFY( strmsz_1 > 0 );\n-  strmsz_2 = fb_01.sgetn(carray2, strmsz_1 + 5);\n-  VERIFY( strmsz_1 == strmsz_2 ); //at the end of the actual file \n-  strmsz_1 = fb_02.in_avail();\n-  strmsz_2 = fb_02.sgetn(carray2, strmsz_1 + 5);\n-  VERIFY( strmsz_1 == -1 );\n-  VERIFY( strmsz_2 == 0 );\n-  c4 = fb_02.sgetc(); // should be EOF\n-  VERIFY( c4 == traits_type::eof() );\n-\n-  // PUT\n-  // int_type sputc(char_type c)\n-  // if out_cur not avail, return overflow(traits_type::to_int_type(c)) \n-  // else, stores c at out_cur,\n-  // increments out_cur, and returns c as int_type\n-  // strmsz_1 = fb_03.in_avail();  // XXX valid for in|out??\n-  c1 = fb_02.sputc('a'); \n-  c2 = fb_03.sputc('b'); \n-  VERIFY( c1 != c2 );\n-  c1 = fb_02.sputc('c'); \n-  c2 = fb_03.sputc('d'); \n-  VERIFY( c1 != c2 );\n-  // strmsz_2 = fb_03.in_avail();\n-  // VERIFY( strmsz_1 != strmsz_2 );\n-  for (int i = 50; i <= 90; ++i) \n-    c2 = fb_02.sputc(char(i));\n-  // 27filebuf-2.txt == ac23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWX\n-  // fb_02._M_out_cur = '2'\n-  strmsz_1 = fb_03.in_avail();\n-  for (int i = 50; i <= 90; ++i) \n-    c2 = fb_03.sputc(char(i));\n-  strmsz_2 = fb_03.in_avail();\n-  // VERIFY( strmsz_1 != strmsz_2 );\n-  // VERIFY( strmsz_1 > 0 );\n-  // VERIFY( strmsz_2 > 0 );\n-  // 27filebuf-2.txt == bd23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWX\n-  // fb_02._M_out_cur = '2'\n-  c3 = fb_01.sputc('a'); // should be EOF because this is read-only\n-  VERIFY( c3 == traits_type::eof() );\n-\n-  // streamsize sputn(const char_typs* s, streamsize n)\n-  // write up to n chars to out_cur from s, returning number assigned\n-  // NB *sputn will happily put '\\0' into your stream if you give it a chance*\n-  strmsz_1 = fb_03.sputn(\"racadabras\", 10);//\"abracadabras or what?\"\n-  VERIFY( strmsz_1 == 10 );\n-  strmsz_2 = fb_03.sputn(\", i wanna reach out and\", 10);\n-  VERIFY( strmsz_2 == 10 );\n-  VERIFY( strmsz_1 == strmsz_2 ); \n-  // fb_03._M_out_beg = \"YZracadabras, i wanna FGHIJKLMNOPQRSTUVW\"\n-  // fb_03._M_out_cur = \"FGHIJKLMNOPQRSTUVW\"\n-  strmsz_1 = fb_02.sputn(\"racadabras\", 10);\n-  VERIFY( strmsz_1 == 10 );  \n-  // fb_02._M_out_beg = \"YZracadabras<=>?@ABCDEFGHIJKLMNOPQRSTUVW\"\n-  // fb_02._M_out_cur = \"<=>?@ABCDEFGHIJKLMNOPQRSTUVW\"\n-  strmsz_1 = fb_01.sputn(\"racadabra\", 10);\n-  VERIFY( strmsz_1 == 0 );  \n-\n-  // PUTBACK\n-  // int_type pbfail(int_type c)\n-  // called when gptr() null, gptr() == eback(), or traits::eq(*gptr, c) false\n-  // \"pending sequence\" is:\n-  //\t1) everything as defined in underflow\n-  // \t2) + if (traits::eq_int_type(c, traits::eof()), then input\n-  // \tsequence is backed up one char before the pending sequence is\n-  // \tdetermined.\n-  //\t3) + if (not 2) then c is prepended. Left unspecified is\n-  //\twhether the input sequence is backedup or modified in any way\n-  // returns traits::eof() for failure, unspecified other value for success\n-\n-  // int_type sputbackc(char_type c)\n-  // if in_cur not avail || ! traits::eq(c, gptr() [-1]), return pbfail\n-  // otherwise decrements in_cur and returns *gptr()\n-  c1 = fb_03.sgetc(); // -1\n-  c2 = fb_03.sputbackc('z');\n-  strmsz_2 = fb_03.in_avail();\n-  c3 = fb_03.sgetc();\n-  VERIFY( c3 == c2 );\n-  VERIFY( c1 != c3 );\n-  VERIFY( 1 == strmsz_2 );\n-  //test for _in_cur == _in_beg\n-  // fb_03._M_out_beg = \"bd23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZracada\" etc\n-  fb_03.pubseekoff(10, std::ios_base::beg, \n-\t\t   std::ios_base::in | std::ios_base::out);\n-  fb_03.sputc('m');\n-  strmsz_1 = fb_03.in_avail(); \n-  c1 = fb_03.sgetc(); \n-  fb_03.snextc();\n-  c2 = fb_03.sputbackc('z');  \n-  strmsz_2 = fb_03.in_avail(); \n-  c3 = fb_03.sgetc();  \n-  VERIFY( c1 != c2 );\n-  VERIFY( c3 == c2 );\n-  VERIFY( c1 != c3 );\n-  VERIFY( c2 == 'z' );\n-  //  VERIFY( strmsz_1 == strmsz_2 );\n-  // test for replacing char with identical one\n-  fb_03.snextc();\n-  fb_03.sputc('u');\n-  fb_03.sputc('v');\n-  fb_03.sputc('a');\n-  strmsz_1 = fb_03.in_avail();\n-  c2 = fb_03.sputbackc('a');\n-  strmsz_2 = fb_03.in_avail();\n-  c3 = fb_03.sgetc();\n-  VERIFY( c3 == c2 );\n-  VERIFY( strmsz_1 + 1 == strmsz_2 );\n-  //test for ios_base::out\n-  c1 = fb_02.sgetc(); // undefined\n-  c2 = fb_02.sputbackc('a');\n-  VERIFY( c1 == c2 );\n-  VERIFY( c1 == -1 );\n-\n-  // int_type sungetc()\n-  // if in_cur not avail, return pbackfail(), else decrement and\n-  // return to_int_type(*gptr())\n-  // fb_03._M_out_beg = \"uvaacadabras, i wannaZ[\\\\]^_`abcdefghijkl\"\n-  // fb_03._M_out_cur = \"aacadabras, i wannaZ[\\\\]^_`abcdefghijkl\"\n-  strmsz_1 = fb_03.in_avail();\n-  c2 = fb_03.sungetc(); // delete the 'a'\n-  strmsz_2 = fb_03.in_avail();\n-  VERIFY( c2 == 'v' ); //  VERIFY( c2 != traits_type::eof() );\n-  VERIFY( strmsz_1 + 1 == strmsz_2 );\n-  //test for _in_cur == _in_beg\n-  for (int i = 50; i < 32 + 29; ++i)\n-    fb_02.sputc(char(i));\n-  fb_02.pubseekoff(0, std::ios_base::beg, std::ios_base::out);\n-  c1 = fb_02.sgetc(); \n-  strmsz_1 = fb_02.in_avail();\n-  c2 = fb_02.sungetc();\n-  c3 = fb_02.sgetc();\n-  strmsz_2 = fb_02.in_avail();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c2 == c3 );\n-  VERIFY( c1 == traits_type::eof() );\n-  VERIFY( strmsz_1 != strmsz_2 );\n-  //test for _in_cur == _in_end\n-  fb_03.pubseekoff(0, std::ios_base::end);\n-  strmsz_1 = fb_03.in_avail(); // -1 cuz at the end\n-  c1 = fb_03.sgetc(); \n-  c2 = fb_03.sungetc();\n-  strmsz_2 = fb_03.in_avail(); // 1\n-  c3 = fb_03.sgetc();\n-  VERIFY( c1 != c2 );\n-  // VERIFY( c2 == c3 || c2 == traits_type::not_eof(int(c3)) );\n-  VERIFY( strmsz_2 != strmsz_1 );\n-  VERIFY( strmsz_2 == 1 );\n-  //test for ios_base::out\n-\n-  // BUFFER MANAGEMENT & POSITIONING\n-  // int sync()\n-  // if a put area exists, overflow. \n-  // if a get area exists, do something undefined. (like, nothing)\n-  strmsz_1 = fb_01.in_avail(); \n-  fb_01.pubsync();\n-  strmsz_2 = fb_01.in_avail();\n-  VERIFY( strmsz_2 == strmsz_1 );\n-  strmsz_1 = fb_02.in_avail(); \n-  fb_02.pubsync();\t\t\n-  // 27filebuf-2.txt == 53 bytes after this.\n-  strmsz_2 = fb_02.in_avail();\n-  VERIFY( strmsz_2 == 1 );\n-  VERIFY( strmsz_2 == strmsz_1 );\n-  strmsz_1 = fb_03.in_avail(); \n-  fb_03.pubsync();\n-  // 27filebuf-3.txt \n-  // bd23456789mzuva?@ABCDEFGHIJKLMNOPQRSTUVWXYZracadabras, i wannaz \n-  // 63 bytes.\n-  strmsz_2 = fb_03.in_avail();\n-  VERIFY( strmsz_1 == 1 );\n-  // VERIFY( strmsz_2 == 1 );\n-\n-  // setbuf\n-  // pubsetbuf(char_type* s, streamsize n)\n-  fb_01.pubsetbuf(0,0);\n-  fb_02.pubsetbuf(0,0);\n-  fb_03.pubsetbuf(0,0);\n-  // Need to test unbuffered output, which means calling this on some\n-  // things that have just been opened.\n-\n-\n-  // seekoff\n-  // pubseekoff(off_type off, ios_base::seekdir way, ios_base::openmode which)\n-  // alters the stream position to off\n-  pos_type pt_1(off_type(-1));\n-  pos_type pt_2(off_type(0));\n-  off_type off_1 = 0;\n-  off_type off_2 = 0;\n-  //IN|OUT\n-  // 27filebuf-3.txt = bd23456789:;<=>?...\n-  //beg\n-  strmsz_1 = fb_03.in_avail(); \n-  pt_1 = fb_03.pubseekoff(2, std::ios_base::beg);\n-  strmsz_2 = fb_03.in_avail(); \n-  off_1 = pt_1;\n-  VERIFY( off_1 > 0 );\n-  c1 = fb_03.snextc(); //current in pointer +1\n-  VERIFY( c1 == '3' );\n-  c2 = fb_03.sputc('\\n');  //current in pointer +1\n-  c3 = fb_03.sgetc();\n-  VERIFY( c2 != c3 ); \n-  VERIFY( c3 == '4' );\n-  fb_03.pubsync(); \n-  c1 = fb_03.sgetc();\n-  VERIFY( c1 == c3 );\n-  //cur\n-  // 27filebuf-3.txt = bd2\\n456789:;<=>?...\n-  pt_2 = fb_03.pubseekoff(2, std::ios_base::cur);\n-  off_2 = pt_2;\n-  VERIFY( (off_2 == (off_1 + 2 + 1 + 1)) );\n-  c1 = fb_03.snextc(); //current in pointer +1\n-  VERIFY( c1 == '7' );\n-  c2 = fb_03.sputc('x');  //test current out pointer\n-  c3 = fb_03.sputc('\\n');\n-  c1 = fb_03.sgetc();\n-  fb_03.pubsync(); \n-  c3 = fb_03.sgetc();\n-  VERIFY( c1 == c3 );\n-  //end\n-  // 27filebuf-3.txt = \"bd2\\n456x\\n9\" \n-  pt_2 = fb_03.pubseekoff(0, std::ios_base::end, \n-\t\t\t  std::ios_base::in|std::ios_base::out);\n-  off_1 = pt_2;\n-  VERIFY( off_1 > off_2 ); //weak, but don't know exactly where it ends\n-  c3 = fb_03.sputc('\\n');\n-  strmsz_1 = fb_03.sputn(\"because because because. . .\", 28);  \n-  VERIFY( strmsz_1 == 28 );\n-  c1 = fb_03.sungetc();\n-  fb_03.pubsync(); \n-  c3 = fb_03.sgetc();\n-  VERIFY( c1 == c3 );\n-  // IN\n-  // OUT\n-\n-\n-  // seekpos\n-  // pubseekpos(pos_type sp, ios_base::openmode)\n-  // alters the stream position to sp\n-  //IN|OUT\n-  //beg\n-  pt_1 = fb_03.pubseekoff(78, std::ios_base::beg);\n-  off_1 = pt_1;\n-  VERIFY( off_1 > 0 );\n-  c1 = fb_03.snextc(); \t\t//current in pointer +1\n-  VERIFY( c1 == ' ' );\n-  c2 = fb_03.sputc('\\n');  \t//test current out pointer\n-  c3 = fb_03.sgetc();\n-  fb_03.pubsync(); \t\t//resets pointers\n-  pt_2 = fb_03.pubseekpos(pt_1);\n-  off_2 = pt_2;\n-  VERIFY( off_1 == off_2 );\n-  c3 = fb_03.snextc(); \t\t//current in pointer +1\n-  VERIFY( c2 == c3 );\n-  pt_1 = fb_03.pubseekoff(0, std::ios_base::end);\n-  off_1 = pt_1;\n-  VERIFY( off_1 > off_2 );\n-  fb_03.sputn(\"\\nof the wonderful things he does!!\\nok\", 37);\n-  fb_03.pubsync();\n-\n-  // IN\n-  // OUT\n-\n-  // VIRTUALS (indirectly tested)\n-  // underflow\n-  // if read position avail, returns *gptr()\n-\n-  // pbackfail(int_type c)\n-  // put c back into input sequence\n-\n-  // overflow\n-  // appends c to output seq\n-\n-  // NB Have to close these suckers. . .\n-  // filebuf_type* close()\n-  fb_01.close();\n-  fb_02.close();\n-  fb_03.close();\n-  VERIFY( !fb_01.is_open() );\n-  VERIFY( !fb_02.is_open() );\n-  VERIFY( !fb_03.is_open() );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n-  return test;\n-}\n-\n-bool test04()\n-{\n-  using namespace std;\n-  typedef istream::int_type\tint_type;\n-\n-  bool test = true;\n-  ifstream ifs(name_02);\n-  char buffer[] = \"xxxxxxxxxx\";\n-  int_type len1 = ifs.rdbuf()->sgetn(buffer, sizeof(buffer));\n-  VERIFY( len1 == sizeof(buffer) );\n-  VERIFY( buffer[0] == 'a' );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-  return test;\n-}\n+// { dg-do compile }\n \n // test05\n // libstdc++/1886\n // should be able to instantiate basic_filebuf for non-standard types.\n template class std::basic_filebuf<short, std::char_traits<short> >;\n \n-// test06\n-// libstdc++/2020\n-// should be able to use custom char_type\n-class gnu_char_type\n+int main() \n {\n-  unsigned long character;\n-public:\n-  // operator ==\n-  bool\n-  operator==(const gnu_char_type& __lhs) \n-  { return character == __lhs.character; }\n+  return 0;\n+}\n \n-  // operator <\n-  bool\n-  operator<(const gnu_char_type& __lhs) \n-  { return character < __lhs.character; }\n \n-  // default ctor\n-  gnu_char_type() { }\n \n-  // to_char_type\n-  gnu_char_type(const unsigned long& __l) : character(__l) { } \n+// more surf!!!\n+\n \n-  // to_int_type\n-  operator unsigned long() const { return character; }\n-};\n \n-bool test06()\n-{\n-  bool test = true;\n-  typedef std::basic_filebuf<gnu_char_type> gnu_filebuf;\n-  \n-  try\n-    { gnu_filebuf obj; }\n-  catch(std::exception& obj)\n-    { \n-      test = false; \n-      VERIFY( test );\n-    }\n-  return test;\n-}\n \n-// libstdc++/3647\n-void test07()\n-{\n-  // Should not block.\n-  std::cout << std::cin.rdbuf()->in_avail() << std::endl;\n-}\n \n-int main() \n-{\n-  test00();\n-  test01();\n-  test02();\n-  test03();\n-  test04();\n \n-  test06();\n-  test07();\n-  return 0;\n-}\n \n \n \n-// more surf!!!"}, {"sha": "66c5a15f25220cc5c5238d476413798c52baea2a", "filename": "libstdc++-v3/testsuite/27_io/filebuf_members.cc", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_members.cc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,21 +32,55 @@\n #include <sys/stat.h>\n #include <testsuite_hooks.h>\n \n-// verify that std::filebuf doesn't close files that it didn't open\n+const char name_01[] = \"filebuf_members-1.tst\";\n+const char name_02[] = \"filebuf_members-1.txt\";\n+\n+// Test member functions.\n+void test_01() \n+{\n+  bool \t\t\ttest = true;\n+  const char* name_03 = \"filebuf_members-3\"; // empty file, need to create\n+\n+  std::filebuf fb_01; // in \n+  std::filebuf fb_02; // out\n+  std::filebuf fb_03; // in | out\n+\n+  // bool is_open()\n+  VERIFY( !fb_01.is_open() );\n+  VERIFY( !fb_02.is_open() );\n+  VERIFY( !fb_03.is_open() );\n+\n+  // filebuf_type* open(const char* __s, ios_base::openmode __mode)\n+  fb_01.open(name_01, std::ios_base::in | std::ios_base::ate);\n+  fb_02.open(name_02, std::ios_base::in | std::ios_base::out \n+\t     | std::ios_base::trunc);\n+  // Try to open two different files without closing the first:\n+  // Should keep the old file attached, and disregard attempt to overthrow.\n+  fb_02.open(name_03, std::ios_base::in | std::ios_base::out);\n+  fb_03.open(name_03, std::ios_base::out | std::ios_base::trunc);\n+  VERIFY( fb_01.is_open() );\n+  VERIFY( fb_02.is_open() );\n+  VERIFY( fb_03.is_open() );\n+\n+  // filebuf_type* close()\n+  fb_01.close();\n+  fb_02.close();\n+  fb_03.close();\n+  VERIFY( !fb_01.is_open() );\n+  VERIFY( !fb_02.is_open() );\n+  VERIFY( !fb_03.is_open() );\n+}\n+\n+// Verify that std::filebuf doesn't close files that it didn't open\n // when using the following std::filebuf ctor:\n //\n //      std::filebuf(__c_file_type*  __f,\n //                   ios_base::openmode __mode,\n //                   int_type  __s);\n //\n-// thanks to \"George T. Talbot\" <george@moberg.com> for uncovering\n+// Thanks to \"George T. Talbot\" <george@moberg.com> for uncovering\n // this bug/situation. \n-\n-const char name_01[] = \"filebuf_members-1.tst\";\n-const char name_02[] = \"filebuf_members-1.txt\";\n-\n-int\n-test_01()\n+void test_02()\n {\n   bool test = true;\n   int close_num;\n@@ -72,17 +106,9 @@ test_01()\n   }\n   close_num = fclose(f);\n   VERIFY( close_num == 0 );\n-\n-  \n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n-  return test;\n }\n \n-int\n-test_02()\n+void test_03()\n {\n   bool test = true;\n   int first_fd = ::open(name_01, O_RDONLY);\n@@ -93,19 +119,13 @@ test_02()\n \n   int second_fd = fb.fd();\n \n-  test = first_fd == second_fd;\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n-  return test;\n+  VERIFY( first_fd == second_fd );\n }\n \n // libstdc++/2913, libstdc++/4879\n // John Fardo  <jfardo@laurelnetworks.com>, Brad Garcia <garsh@attbi.com>\n void\n-test_03()\n+test_04()\n {\n   signal(SIGPIPE, SIG_IGN);\n   \n@@ -159,7 +179,9 @@ main()\n {\n   test_01();\n   test_02();\n-\n   test_03();\n+  test_04();\n   return 0;\n }\n+\n+"}, {"sha": "cb3c57f7dfd3a38e23d0c6ad3b6b55713db4626b", "filename": "libstdc++-v3/testsuite/27_io/filebuf_virtuals-1.tst", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-1.tst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-1.tst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-1.tst?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "previous_filename": "libstdc++-v3/testsuite/27_io/filebuf-1.tst"}, {"sha": "cb3c57f7dfd3a38e23d0c6ad3b6b55713db4626b", "filename": "libstdc++-v3/testsuite/27_io/filebuf_virtuals-1.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-1.txt?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "previous_filename": "libstdc++-v3/testsuite/27_io/filebuf-1.txt"}, {"sha": "f25bba46d928b13388ea8d0e0933427b48b07715", "filename": "libstdc++-v3/testsuite/27_io/filebuf_virtuals-2.tst", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-2.tst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-2.tst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-2.tst?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "previous_filename": "libstdc++-v3/testsuite/27_io/filebuf-2.tst"}, {"sha": "0a81f51129010b2252bec02b5d237dfe4f89b2bf", "filename": "libstdc++-v3/testsuite/27_io/filebuf_virtuals-3.tst", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-3.tst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-3.tst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals-3.tst?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "previous_filename": "libstdc++-v3/testsuite/27_io/filebuf-3.tst"}, {"sha": "778dd861a923ca27ab1e2c0ca6bf7354f5cefb4d", "filename": "libstdc++-v3/testsuite/27_io/filebuf_virtuals.cc", "status": "modified", "additions": 506, "deletions": 1, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -1,6 +1,6 @@\n // 2001-05-21 Benjamin Kosnik  <bkoz@redhat.com>\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -23,6 +23,9 @@\n #include <fstream>\n #include <testsuite_hooks.h>\n \n+// @require@ %-*.tst %-*.txt\n+// @diff@ %-*.tst %*.txt\n+\n void test01()\n {\n   using namespace std;\n@@ -54,9 +57,511 @@ void test02()\n   VERIFY( std::strncmp(strlit, buf, strlitsize) == 0 );\n }\n \n+\n+// NB: This test assumes that _M_buf_size == 40, and not the usual\n+// buffer_size length of BUFSIZ (8192), so that overflow/underflow can be\n+// simulated a bit more readily.\n+// NRB (Nota Really Bene): setting it to 40 breaks the test, as intended.\n+const int buffer_size = 8192;\n+//const int buffer_size = 40;\n+\n+const char carray_01[] = \"santa cruz or sandiego?\";\n+const char carray_02[] = \"memphis, new orleans, and savanah\";\n+const char name_01[] = \"filebuf_virtuals-1.txt\"; // file with data in it\n+const char name_02[] = \"filebuf_virtuals-2.txt\"; // empty file, need to create\n+const char name_03[] = \"filebuf_virtuals-3.txt\"; // empty file, need to create\n+\n+\n+class derived_filebuf: public std::filebuf\n+{\n+ public:\n+  void\n+  set_size(int_type __size) { _M_buf_size_opt = __size; }\n+};\n+\n+derived_filebuf fb_01; // in \n+derived_filebuf fb_02; // out\n+derived_filebuf fb_03; // in | out\n+\n+\n+// Initialize filebufs to be the same size regardless of platform.\n+void test03()\n+{\n+  fb_01.set_size(buffer_size);\n+  fb_02.set_size(buffer_size);\n+  fb_03.set_size(buffer_size);\n+}\n+\n+\n+// Test the filebuf/stringbuf locale settings.\n+void test04() \n+{\n+  std::locale loc_tmp;\n+  loc_tmp = fb_01.getloc();\n+  fb_01.pubimbue(loc_tmp); //This should initialize _M_init to true\n+  fb_01.getloc(); //This should just return _M_locale\n+}\n+\n+// Test overloaded virtual functions.\n+void test05() \n+{\n+  typedef std::filebuf::int_type \tint_type;\n+  typedef std::filebuf::traits_type \ttraits_type;\n+  typedef std::filebuf::pos_type \tpos_type;\n+  typedef std::filebuf::off_type \toff_type;\n+  typedef size_t \t\t\tsize_type;\n+\n+  bool \t\t\t\t\ttest = true;\n+  std::filebuf \t\t\t\tf_tmp;\n+  std::streamsize \t\t\tstrmsz_1, strmsz_2;\n+  std::streamoff  \t\t\tstrmof_1, strmof_2;\n+  int \t\t\t\t\ti = 0, j = 0, k = 0;\n+\n+  // GET\n+  // int showmanyc()\n+  // returns an estimate of the numbers of chars in the seq, or -1.\n+  // if __retval > 0, then calls to underflow won't return\n+  // traits_type::eof() till at least __retval chars. \n+  // if __retval == -1, then calls to underflow or uflow will fail.\n+  // NB overriding def if it can determine more chars can be read from \n+  // the input sequence.\n+\n+  // int in_avail()\n+  // if a read position is available, return _M_in_end - _M_in_cur.\n+  // else return showmanyc.\n+  strmof_1 = fb_01.in_avail();\n+  strmof_2 = fb_02.in_avail();\n+  VERIFY( strmof_1 == -1 );\n+  VERIFY( strmof_1 == strmof_2 ); //fail because not open\n+  strmof_1 = fb_03.in_avail();\n+  VERIFY( strmof_1 == strmof_2 );\n+  fb_01.open(name_01, std::ios_base::in);\n+  fb_02.open(name_02, std::ios_base::out | std::ios_base::trunc);\n+  fb_03.open(name_03, std::ios_base::out | std::ios_base::in | std::ios_base::trunc); \n+  strmof_1 = fb_01.in_avail();\n+  strmof_2 = fb_02.in_avail();\n+  VERIFY( strmof_1 != strmof_2 );\n+  VERIFY( strmof_1 >= 0 );\n+  VERIFY( strmof_2 == -1 );  // empty file\n+  strmof_1 = fb_03.in_avail(); \n+  VERIFY( strmof_1  == 0 ); // empty file\n+\n+  // int_type sbumpc()\n+  // if read_cur not avail returns uflow(), else return *read_cur & increment\n+  int_type c1 = fb_01.sbumpc();\n+  int_type c2 = fb_02.sbumpc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c1 == '/' );\n+  VERIFY( c2 == -1 );\n+  int_type c3 = fb_01.sbumpc();\n+  int_type c4 = fb_02.sbumpc();\n+  VERIFY( c3 != c4 );\n+  VERIFY( c1 == c3 ); // fluke, both happen to be '/'\n+  VERIFY( c2 == c4 );\n+  int_type c5 = fb_03.sbumpc();\n+  VERIFY( c5 == traits_type::eof() );\n+  // XXX should do some kind of test to make sure that internal\n+  // buffers point ot the same thing, to check consistancy.\n+\n+  // int_type sgetc()\n+  // if read_cur not avail, return uflow(), else return *read_cur  \n+  int_type c6 = fb_01.sgetc();\n+  int_type c7 = fb_02.sgetc();\n+  VERIFY( c6 != c3 );\n+  VERIFY( c7 == c4 ); // both -1\n+  int_type c8 = fb_01.sgetc();\n+  int_type c9 = fb_02.sgetc();\n+  VERIFY( c6 == c8 );\n+  VERIFY( c7 == c9 );\n+  c5 = fb_03.sgetc();\n+  VERIFY( c5 == traits_type::eof() );\n+\n+  // int_type snextc()\n+  // calls sbumpc and if sbumpc != eof, return sgetc\n+  c6 = fb_01.snextc();\n+  c7 = fb_02.snextc();\n+  VERIFY( c6 != c8 );\n+  VERIFY( c7 == c9 ); // -1\n+  VERIFY( c6 == '9' );\n+  c6 = fb_01.snextc();\n+  c7 = fb_02.snextc();\n+  VERIFY( c6 != c8 );\n+  VERIFY( c7 == c9 ); // -1\n+  VERIFY( c6 == '9' );\n+  c5 = fb_03.snextc();\n+  VERIFY( c5 == traits_type::eof() );\n+\n+  // streamsize sgetn(char_type *s, streamsize n)\n+  // streamsize xsgetn(char_type *s, streamsize n)\n+  // assign up to n chars to s from input sequence, indexing in_cur as\n+  // approp and returning the number of chars assigned\n+  strmsz_1 = fb_01.in_avail();\n+  strmsz_2 = fb_02.in_avail();\n+  test = strmsz_1 != strmsz_2;\n+  char carray1[13] = \"\";\n+  strmsz_1 = fb_01.sgetn(carray1, 10);\n+  char carray2[buffer_size] = \"\";\n+  strmsz_2 = fb_02.sgetn(carray2, 10);\n+  VERIFY( strmsz_1 != strmsz_2 );\n+  VERIFY( strmsz_1 == 10 );\n+  VERIFY( strmsz_2 == 0 );\n+  c1 = fb_01.sgetc();\n+  c2 = fb_02.sgetc();\n+  VERIFY( c1 == '\\n' );  \n+  VERIFY( c7 == c2 ); // n != i\n+  strmsz_1 = fb_03.sgetn(carray1, 10);\n+  VERIFY( !strmsz_1 ); //zero\n+  strmsz_1 = fb_01.in_avail();\n+  strmsz_2 = fb_01.sgetn(carray2, strmsz_1 + 5);\n+  VERIFY( strmsz_1 == strmsz_2 - 5 ); \n+  c4 = fb_01.sgetc(); // buffer should have underflowed from above.\n+  VERIFY( c4 == 'i' );\n+  strmsz_1 = fb_01.in_avail();\n+  VERIFY( strmsz_1 > 0 );\n+  strmsz_2 = fb_01.sgetn(carray2, strmsz_1 + 5);\n+  VERIFY( strmsz_1 == strmsz_2 ); //at the end of the actual file \n+  strmsz_1 = fb_02.in_avail();\n+  strmsz_2 = fb_02.sgetn(carray2, strmsz_1 + 5);\n+  VERIFY( strmsz_1 == -1 );\n+  VERIFY( strmsz_2 == 0 );\n+  c4 = fb_02.sgetc(); // should be EOF\n+  VERIFY( c4 == traits_type::eof() );\n+\n+  // PUT\n+  // int_type sputc(char_type c)\n+  // if out_cur not avail, return overflow(traits_type::to_int_type(c)) \n+  // else, stores c at out_cur,\n+  // increments out_cur, and returns c as int_type\n+  // strmsz_1 = fb_03.in_avail();  // XXX valid for in|out??\n+  c1 = fb_02.sputc('a'); \n+  c2 = fb_03.sputc('b'); \n+  VERIFY( c1 != c2 );\n+  c1 = fb_02.sputc('c'); \n+  c2 = fb_03.sputc('d'); \n+  VERIFY( c1 != c2 );\n+  // strmsz_2 = fb_03.in_avail();\n+  // VERIFY( strmsz_1 != strmsz_2 );\n+  for (int i = 50; i <= 90; ++i) \n+    c2 = fb_02.sputc(char(i));\n+  // 27filebuf-2.txt == ac23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWX\n+  // fb_02._M_out_cur = '2'\n+  strmsz_1 = fb_03.in_avail();\n+  for (int i = 50; i <= 90; ++i) \n+    c2 = fb_03.sputc(char(i));\n+  strmsz_2 = fb_03.in_avail();\n+  // VERIFY( strmsz_1 != strmsz_2 );\n+  // VERIFY( strmsz_1 > 0 );\n+  // VERIFY( strmsz_2 > 0 );\n+  // 27filebuf-2.txt == bd23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWX\n+  // fb_02._M_out_cur = '2'\n+  c3 = fb_01.sputc('a'); // should be EOF because this is read-only\n+  VERIFY( c3 == traits_type::eof() );\n+\n+  // streamsize sputn(const char_typs* s, streamsize n)\n+  // write up to n chars to out_cur from s, returning number assigned\n+  // NB *sputn will happily put '\\0' into your stream if you give it a chance*\n+  strmsz_1 = fb_03.sputn(\"racadabras\", 10);//\"abracadabras or what?\"\n+  VERIFY( strmsz_1 == 10 );\n+  strmsz_2 = fb_03.sputn(\", i wanna reach out and\", 10);\n+  VERIFY( strmsz_2 == 10 );\n+  VERIFY( strmsz_1 == strmsz_2 ); \n+  // fb_03._M_out_beg = \"YZracadabras, i wanna FGHIJKLMNOPQRSTUVW\"\n+  // fb_03._M_out_cur = \"FGHIJKLMNOPQRSTUVW\"\n+  strmsz_1 = fb_02.sputn(\"racadabras\", 10);\n+  VERIFY( strmsz_1 == 10 );  \n+  // fb_02._M_out_beg = \"YZracadabras<=>?@ABCDEFGHIJKLMNOPQRSTUVW\"\n+  // fb_02._M_out_cur = \"<=>?@ABCDEFGHIJKLMNOPQRSTUVW\"\n+  strmsz_1 = fb_01.sputn(\"racadabra\", 10);\n+  VERIFY( strmsz_1 == 0 );  \n+\n+  // PUTBACK\n+  // int_type pbfail(int_type c)\n+  // called when gptr() null, gptr() == eback(), or traits::eq(*gptr, c) false\n+  // \"pending sequence\" is:\n+  //\t1) everything as defined in underflow\n+  // \t2) + if (traits::eq_int_type(c, traits::eof()), then input\n+  // \tsequence is backed up one char before the pending sequence is\n+  // \tdetermined.\n+  //\t3) + if (not 2) then c is prepended. Left unspecified is\n+  //\twhether the input sequence is backedup or modified in any way\n+  // returns traits::eof() for failure, unspecified other value for success\n+\n+  // int_type sputbackc(char_type c)\n+  // if in_cur not avail || ! traits::eq(c, gptr() [-1]), return pbfail\n+  // otherwise decrements in_cur and returns *gptr()\n+  c1 = fb_03.sgetc(); // -1\n+  c2 = fb_03.sputbackc('z');\n+  strmsz_2 = fb_03.in_avail();\n+  c3 = fb_03.sgetc();\n+  VERIFY( c3 == c2 );\n+  VERIFY( c1 != c3 );\n+  VERIFY( 1 == strmsz_2 );\n+  //test for _in_cur == _in_beg\n+  // fb_03._M_out_beg = \"bd23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZracada\" etc\n+  fb_03.pubseekoff(10, std::ios_base::beg, \n+\t\t   std::ios_base::in | std::ios_base::out);\n+  fb_03.sputc('m');\n+  strmsz_1 = fb_03.in_avail(); \n+  c1 = fb_03.sgetc(); \n+  fb_03.snextc();\n+  c2 = fb_03.sputbackc('z');  \n+  strmsz_2 = fb_03.in_avail(); \n+  c3 = fb_03.sgetc();  \n+  VERIFY( c1 != c2 );\n+  VERIFY( c3 == c2 );\n+  VERIFY( c1 != c3 );\n+  VERIFY( c2 == 'z' );\n+  //  VERIFY( strmsz_1 == strmsz_2 );\n+  // test for replacing char with identical one\n+  fb_03.snextc();\n+  fb_03.sputc('u');\n+  fb_03.sputc('v');\n+  fb_03.sputc('a');\n+  strmsz_1 = fb_03.in_avail();\n+  c2 = fb_03.sputbackc('a');\n+  strmsz_2 = fb_03.in_avail();\n+  c3 = fb_03.sgetc();\n+  VERIFY( c3 == c2 );\n+  VERIFY( strmsz_1 + 1 == strmsz_2 );\n+  //test for ios_base::out\n+  c1 = fb_02.sgetc(); // undefined\n+  c2 = fb_02.sputbackc('a');\n+  VERIFY( c1 == c2 );\n+  VERIFY( c1 == -1 );\n+\n+  // int_type sungetc()\n+  // if in_cur not avail, return pbackfail(), else decrement and\n+  // return to_int_type(*gptr())\n+  // fb_03._M_out_beg = \"uvaacadabras, i wannaZ[\\\\]^_`abcdefghijkl\"\n+  // fb_03._M_out_cur = \"aacadabras, i wannaZ[\\\\]^_`abcdefghijkl\"\n+  strmsz_1 = fb_03.in_avail();\n+  c2 = fb_03.sungetc(); // delete the 'a'\n+  strmsz_2 = fb_03.in_avail();\n+  VERIFY( c2 == 'v' ); //  VERIFY( c2 != traits_type::eof() );\n+  VERIFY( strmsz_1 + 1 == strmsz_2 );\n+  //test for _in_cur == _in_beg\n+  for (int i = 50; i < 32 + 29; ++i)\n+    fb_02.sputc(char(i));\n+  fb_02.pubseekoff(0, std::ios_base::beg, std::ios_base::out);\n+  c1 = fb_02.sgetc(); \n+  strmsz_1 = fb_02.in_avail();\n+  c2 = fb_02.sungetc();\n+  c3 = fb_02.sgetc();\n+  strmsz_2 = fb_02.in_avail();\n+  VERIFY( c1 == c2 );\n+  VERIFY( c2 == c3 );\n+  VERIFY( c1 == traits_type::eof() );\n+  VERIFY( strmsz_1 == strmsz_2 );\n+  //test for _in_cur == _in_end\n+  fb_03.pubseekoff(0, std::ios_base::end);\n+  strmsz_1 = fb_03.in_avail(); // -1 cuz at the end\n+  c1 = fb_03.sgetc(); \n+  c2 = fb_03.sungetc();\n+  strmsz_2 = fb_03.in_avail(); // 1\n+  c3 = fb_03.sgetc();\n+  VERIFY( c1 != c2 );\n+  // VERIFY( c2 == c3 || c2 == traits_type::not_eof(int(c3)) );\n+  VERIFY( strmsz_2 != strmsz_1 );\n+  VERIFY( strmsz_2 == 1 );\n+  //test for ios_base::out\n+\n+  // BUFFER MANAGEMENT & POSITIONING\n+  // int sync()\n+  // if a put area exists, overflow. \n+  // if a get area exists, do something undefined. (like, nothing)\n+  strmsz_1 = fb_01.in_avail(); \n+  fb_01.pubsync();\n+  strmsz_2 = fb_01.in_avail();\n+  VERIFY( strmsz_2 == strmsz_1 );\n+  strmsz_1 = fb_02.in_avail(); \n+  fb_02.pubsync();\t\t\n+  // 27filebuf-2.txt == 53 bytes after this.\n+  strmsz_2 = fb_02.in_avail();\n+  VERIFY( strmsz_2 == -1 );\n+  VERIFY( strmsz_2 == strmsz_1 );\n+  strmsz_1 = fb_03.in_avail(); \n+  fb_03.pubsync();\n+  // 27filebuf-3.txt \n+  // bd23456789mzuva?@ABCDEFGHIJKLMNOPQRSTUVWXYZracadabras, i wannaz \n+  // 63 bytes.\n+  strmsz_2 = fb_03.in_avail();\n+  VERIFY( strmsz_1 == 1 );\n+  // VERIFY( strmsz_2 == 1 );\n+\n+  // setbuf\n+  // pubsetbuf(char_type* s, streamsize n)\n+  fb_01.pubsetbuf(0,0);\n+  fb_02.pubsetbuf(0,0);\n+  fb_03.pubsetbuf(0,0);\n+  // Need to test unbuffered output, which means calling this on some\n+  // things that have just been opened.\n+\n+\n+  // seekoff\n+  // pubseekoff(off_type off, ios_base::seekdir way, ios_base::openmode which)\n+  // alters the stream position to off\n+  pos_type pt_1(off_type(-1));\n+  pos_type pt_2(off_type(0));\n+  off_type off_1 = 0;\n+  off_type off_2 = 0;\n+  //IN|OUT\n+  // 27filebuf-3.txt = bd23456789:;<=>?...\n+  //beg\n+  strmsz_1 = fb_03.in_avail(); \n+  pt_1 = fb_03.pubseekoff(2, std::ios_base::beg);\n+  strmsz_2 = fb_03.in_avail(); \n+  off_1 = pt_1;\n+  VERIFY( off_1 > 0 );\n+  c1 = fb_03.snextc(); //current in pointer +1\n+  VERIFY( c1 == '3' );\n+  c2 = fb_03.sputc('\\n');  //current in pointer +1\n+  c3 = fb_03.sgetc();\n+  VERIFY( c2 != c3 ); \n+  VERIFY( c3 == '4' );\n+  fb_03.pubsync(); \n+  c1 = fb_03.sgetc();\n+  VERIFY( c1 == c3 );\n+  //cur\n+  // 27filebuf-3.txt = bd2\\n456789:;<=>?...\n+  pt_2 = fb_03.pubseekoff(2, std::ios_base::cur);\n+  off_2 = pt_2;\n+  VERIFY( (off_2 == (off_1 + 2 + 1 + 1)) );\n+  c1 = fb_03.snextc(); //current in pointer +1\n+  VERIFY( c1 == '7' );\n+  c2 = fb_03.sputc('x');  //test current out pointer\n+  c3 = fb_03.sputc('\\n');\n+  c1 = fb_03.sgetc();\n+  fb_03.pubsync(); \n+  c3 = fb_03.sgetc();\n+  VERIFY( c1 == c3 );\n+  //end\n+  // 27filebuf-3.txt = \"bd2\\n456x\\n9\" \n+  pt_2 = fb_03.pubseekoff(0, std::ios_base::end, \n+\t\t\t  std::ios_base::in|std::ios_base::out);\n+  off_1 = pt_2;\n+  VERIFY( off_1 > off_2 ); //weak, but don't know exactly where it ends\n+  c3 = fb_03.sputc('\\n');\n+  strmsz_1 = fb_03.sputn(\"because because because. . .\", 28);  \n+  VERIFY( strmsz_1 == 28 );\n+  c1 = fb_03.sungetc();\n+  fb_03.pubsync(); \n+  c3 = fb_03.sgetc();\n+  VERIFY( c1 == c3 );\n+  // IN\n+  // OUT\n+\n+\n+  // seekpos\n+  // pubseekpos(pos_type sp, ios_base::openmode)\n+  // alters the stream position to sp\n+  //IN|OUT\n+  //beg\n+  pt_1 = fb_03.pubseekoff(78, std::ios_base::beg);\n+  off_1 = pt_1;\n+  VERIFY( off_1 > 0 );\n+  c1 = fb_03.snextc(); \t\t//current in pointer +1\n+  VERIFY( c1 == ' ' );\n+  c2 = fb_03.sputc('\\n');  \t//test current out pointer\n+  c3 = fb_03.sgetc();\n+  fb_03.pubsync(); \t\t//resets pointers\n+  pt_2 = fb_03.pubseekpos(pt_1);\n+  off_2 = pt_2;\n+  VERIFY( off_1 == off_2 );\n+  c3 = fb_03.snextc(); \t\t//current in pointer +1\n+  VERIFY( c2 == c3 );\n+  pt_1 = fb_03.pubseekoff(0, std::ios_base::end);\n+  off_1 = pt_1;\n+  VERIFY( off_1 > off_2 );\n+  fb_03.sputn(\"\\nof the wonderful things he does!!\\nok\", 37);\n+  fb_03.pubsync();\n+\n+  // IN\n+  // OUT\n+\n+  // VIRTUALS (indirectly tested)\n+  // underflow\n+  // if read position avail, returns *gptr()\n+\n+  // pbackfail(int_type c)\n+  // put c back into input sequence\n+\n+  // overflow\n+  // appends c to output seq\n+\n+  // NB Have to close these suckers. . .\n+  // filebuf_type* close()\n+  fb_01.close();\n+  fb_02.close();\n+  fb_03.close();\n+  VERIFY( !fb_01.is_open() );\n+  VERIFY( !fb_02.is_open() );\n+  VERIFY( !fb_03.is_open() );\n+}\n+\n+void test06()\n+{\n+  using namespace std;\n+  typedef istream::int_type\tint_type;\n+\n+  bool test = true;\n+  ifstream ifs(name_02);\n+  char buffer[] = \"xxxxxxxxxx\";\n+  int_type len1 = ifs.rdbuf()->sgetn(buffer, sizeof(buffer));\n+  VERIFY( len1 == sizeof(buffer) );\n+  VERIFY( buffer[0] == 'a' );\n+}\n+\n+// test06\n+// libstdc++/2020\n+// should be able to use custom char_type\n+class gnu_char_type\n+{\n+  unsigned long character;\n+public:\n+  // operator ==\n+  bool\n+  operator==(const gnu_char_type& __lhs) \n+  { return character == __lhs.character; }\n+\n+  // operator <\n+  bool\n+  operator<(const gnu_char_type& __lhs) \n+  { return character < __lhs.character; }\n+\n+  // default ctor\n+  gnu_char_type() { }\n+\n+  // to_char_type\n+  gnu_char_type(const unsigned long& __l) : character(__l) { } \n+\n+  // to_int_type\n+  operator unsigned long() const { return character; }\n+};\n+\n+void test07()\n+{\n+  bool test = true;\n+  typedef std::basic_filebuf<gnu_char_type> gnu_filebuf;\n+  \n+  try\n+    { gnu_filebuf obj; }\n+  catch(std::exception& obj)\n+    { \n+      test = false; \n+      VERIFY( test );\n+    }\n+}\n+\n main() \n {\n   test01();\n   test02();\n+  \n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+\n   return 0;\n }"}, {"sha": "26849ac0fd2f318bd7ffb0bf29c50c8c01142043", "filename": "libstdc++-v3/testsuite/27_io/iostream.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream.cc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -0,0 +1,47 @@\n+// 2002-01-08 bkoz\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.6.1.5 - Template class basic_iostream\n+// NB: This file is for testing iostream with NO OTHER INCLUDES.\n+\n+// { dg-do compile }\n+\n+#include <istream>\n+\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_iostream<type_t, char_traits<type_t> >;\n+} // test\n+\n+int main() \n+{\n+  return 0;\n+}"}, {"sha": "4cdcc82af4cf81d0745778d1509587552726c13b", "filename": "libstdc++-v3/testsuite/27_io/iostream_members.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream_members.cc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -0,0 +1,46 @@\n+// 2002-01-08 bkoz\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.6.1.5 - Template class basic_iostream\n+// NB: This file is for testing iostream with NO OTHER INCLUDES.\n+\n+#include <iostream>\n+\n+// libstdc++/3647\n+void test07()\n+{\n+  // Should not block.\n+  std::cout << std::cin.rdbuf()->in_avail() << std::endl;\n+}\n+\n+int main() \n+{\n+  test07();\n+  return 0;\n+}"}, {"sha": "ef88a39f727e00004799d1f9ffb5f0b5ea988af1", "filename": "libstdc++-v3/testsuite/27_io/istream.cc", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -1,6 +1,6 @@\n // 1999-09-20 bkoz\n \n-// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,26 +32,16 @@\n \n #include <istream>\n \n-namespace test {\n- \n-#if 0\n-  // XXX Should work, but doesn't.\n+// { dg-do compile }\n+\n+namespace test \n+{\n   using namespace std;\n   typedef short type_t;\n   template class basic_istream<type_t, char_traits<type_t> >;\n-\n-  template\n-    const ctype<type_t>& \n-    use_facet<ctype<type_t> >(const locale&);\n-\n-  typedef istreambuf_iterator<type_t, char_traits<type_t> > traits_t;\n-  template \n-    const num_get<type_t, traits_t>& \n-    use_facet<num_get<type_t, traits_t> >(const locale&);\n-#endif\n-\n } // test\n \n-int main() {\n+int main() \n+{\n   return 0;\n }"}, {"sha": "cbc4a6739c2b8f47f43bef8be605ec9df17f27d2", "filename": "libstdc++-v3/testsuite/27_io/ostream.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67051746fe23e90166655680af3bfe0b0e3f48f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc?ref=e67051746fe23e90166655680af3bfe0b0e3f48f", "patch": "@@ -1,6 +1,6 @@\n // 1999-09-20 bkoz\n \n-// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,17 +32,16 @@\n \n #include <ostream>\n \n-namespace test {\n- \n-#if 0\n-  // XXX Should work, but doesn't.\n+// { dg-do compile }\n+\n+namespace test \n+{\n   using namespace std;\n   typedef short type_t;\n   template class basic_ostream<type_t, char_traits<type_t> >;\n-#endif\n-\n } // test\n \n-int main() {\n+int main() \n+{\n   return 0;\n }"}]}