{"sha": "e28d52cffbb2abc7a5764ed4c97a25c376913fee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4ZDUyY2ZmYmIyYWJjN2E1NzY0ZWQ0Yzk3YTI1YzM3NjkxM2ZlZQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-10-08T09:29:05Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-10-08T09:29:05Z"}, "message": "PR c++/53528 C++11 attribute support\n\nThis patch implements the c++-11 generalized attributes, described in\nthe N2761 paper[1].\n\nThe idea is to modify the front-end to accept the new attribute syntax\n(including alignas expressions) and to build an internal\nrepresentation similar to the one we already have for GNU attributes.\n\nThis lets us re-use our existing GNU attribute mechanisms to support\nthe generalized c++11 attributes.\n\nThe patch does change the existing internal representation to support\nscoped attribute (aka attributes with namespaces), which is a concept\nthat doesn't exist in GNU attributes.  I have thus put all existing\nGNU extension attributes into the \"gnu\" namespace.  For instance, in\nC++-11, the \"unused\" attribute would be represented as\n\"[[gnu::unused]]\".  Because there is no syntax for scoped attributes\nin C, writting \"__attribute__((unused))\" unconditionnally refers to\nthe \"unused\" attribute in the \"gnu\" namespace.\n\nNote that this patch follows a conservative understanding of the\nspecification by disallowing attributes appertaining to types, unless\nthey apply to a type definition.\n\nTested on x86_64-unknown-linux-gnu and powerpc64-unknown-linux-gnu.\n\n[1]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf\n\ngcc/\n\t* plugin.h (register_scoped_attributes): Declare new function.\n\t* tree.h (enu attribute_flags::ATTR_FLAG_CXX_11): New flag.\n\t(lookup_scoped_attribute_spec, cxx_11_attribute_p)\n\t(get_attribute_name, get_attribute_namespace): Declare new functions.\n\t(struct attribute_spec): Remove const qualifier from the members.\n\t* tree.c (comp_type_attributes, private_lookup_attribute)\n\t(lookup_ident_attribute, remove_attribute, merge_attribute)\n\t(attribute_hash_list, attribute_list_contained): Use\n\tget_attribute_name.\n\t* attribs.c (decl_attributes): Don't crash on error_mark_node.\n\tForbid c++11 attributes appertaining to type-specifiers.\n\t(attribute_hash): Remove global variable.\n\t(attributes_table): New global variable.\n\t(find_attribute_namespace, register_scoped_attribute): New static\n\tfunctions.\n\t(register_scoped_attributes, lookup_scoped_attribute_spec)\n\t(cxx11_attribute_p, get_attribute_name, get_attribute_namespace):\n\tNew public functions.\n\t(init_attributes): Register all the GNU attributes into the \"gnu\"\n\tnamespace.\n\t(register_attribute): Use register_scoped_attribute to register\n\tthe attribute into the \"gnu\" namespace.\n\t(lookup_attribute_spec): Use lookup_scoped_attribute_spec to\n\tlookup the attribute in the \"gnu\" namespace.\n\t(decl_attributes): Use new get_attribute_namespace and\n\tlookup_scoped_attribute_spec to consider attribute namespaces when\n\tlooking up attributes.  When operating in c++-11 mode, pass flag\n\tATTR_FLAG_CXX11 to the spec handler.\n\ngcc/c-family/\n\n\t* c-common.h (bitfield_p, cxx_fundamental_alignment_p): Declare\n\tnew functions.\n\t* c-common.c (check_cxx_fundamental_alignment_constraints): New\n\tstatic function.\n\t(handle_aligned_attribute): In choose strictest alignment\n\tamong many.  Use new check_cxx_fundamental_alignment_constraints.\n\t(handle_transparent_union_attribute): In c++11 attribute syntax,\n\tdon't look through typedefs.\n\ngcc/cp/\n\n\t* cp-tree.h (enum cpp0x_warn_str::CPP0X_ATTRIBUTES): New member.\n\t(enum cp_decl_spec::ds_std_attribute): New enumerator.\n\t(struct cp_decl_specifier_seq::std_attributes): New field.\n\t(cxx_alignas_expr, warn_misplaced_attr_for_class_type): Declare\n\tnew functions.\n\t(check_tag_decl): Take an extra parameter for explicit\n\tinstantiations.\n\t* decl.c (warn_misplaced_attr_for_class_type): Extract from ...\n\t(check_tag_decl): ... here.  Add check for c++11 attributes being\n\tapplied to an explicit instantiation.  Take an extra parameter for\n\texplicit instantiations.\n\t(grokdeclarator): Make sure a c++11 attribute after an array\n\tdeclarator appertains to the array, an attribute after a function\n\tdeclarator appertains to the function type, an attribute after a\n\tdeclarator-id appertains to the entity being declared, and an\n\tattribute after a pointer declarator appertains to the pointer.\n\t* decl2.c (is_late_template_attribute): Use get_attribute_name.\n\t* error.c (maybe_warn_cpp0x): Support\n\tCPP0X_GENERALIZED_ATTRIBUTES.\n\t* parser.c (cp_next_tokens_can_be_attribute_p)\n\t(cp_next_tokens_can_be_gnu_attribute_p)\n\t(cp_next_tokens_can_be_std_attribute_p)\n\t(cp_nth_tokens_can_be_attribute_p)\n\t(cp_nth_tokens_can_be_gnu_attribute_p)\n\t(cp_nth_tokens_can_be_std_attribute_p)\n\t(cp_parser_gnu_attribute_list, cp_parser_std_attribute)\n\t(cp_parser_std_attribute_spec, cp_parser_std_attribute_spec_seq)\n\t(cp_parser_attributes_opt, cp_parser_std_attribute_list): New\n\tstatic functions.\n\t(cp_parser_gnu_attributes_opt): Replace cp_parser_attributes_opt.\n\t(cp_parser_gnu_attribute_list): Replace cp_parser_attribute_list.\n\t(cp_parser_postfix_expression): Disallow \"[[\" tokens here.\n\t(cp_parser_label_for_labeled_statement): Use take an extra\n\tparameter for attributes.\n\t(cp_parser_block_declaration): Use\n\tcp_nth_tokens_can_be_std_attribute_p here.\n\t(cp_parser_decl_specifier_seq): Likewise.  Store C++11 attributes\n\tthat appears in in decl specifiers in cp_decl_specifier_seq::std_attributes.\n\tdeclaration.  Emit proper warning about misplaced c++11 attributes\n\tfor class type.\n\t(cp_parser_explicit_instantiation): Adjust call to check_tag_decl.\n\t(cp_parser_init_declarator):  Parsing attributes here is no more a\n\tGNU extension in c++-11.\n\t(cp_parser_type_specifier_seq): Use\n\tcp_next_tokens_can_be_attribute_p.\n\t(cp_parser_direct_declarator): Likewise.  Hang c++11 attributes\n\tfollowing the declarator to its syntactic construct.  It'll later\n\tbe applied to the proper appertaining entity by grokdeclarator.\n\t(cp_parser_ptr_operator): Likewise.\n\t(make_declarator): Initialize cp_declarator::std_attribute.\n\t(make_pointer_declarator, make_reference_declarator)\n\t(make_ptrmem_declarator, cp_parser_make_indirect_declarator): Take\n\tattributes that appertain to the pointer/reference in argument.\n\t(cp_parser_ptr_operator): Take an out parameter for c++11\n\tattributes.  Update comments.\n\t(cp_parser_new_declarator_opt)\n\t(cp_parser_conversion_declarator_opt): Adjust.\n\t(cp_parser_declarator): Likewise.  Handle C++11 attributes.\n\tRename attributes to gnu_attribute for better legibility.\n\t(cp_parser_simple_declaration): Update comment.\n\t(cp_parser_class_specifier_1): Parse GNU attributes specifically\n\t(cp_parser_enum_specifier): Accept only gnu attributes after the\n\tspecifier.\n\t(cp_parser_member_declaration): Don't clear attributes -- intended\n\tfor the entity being declared -- too early because check_tag_decl\n\tneeds them.\n\t(cp_parser_statement): Update comment.  Parse optional c++11\n\tattributes at the beginning of the relevant kind of statements and\n\tignore them, for now, unless when calling\n\tcp_parser_label_for_labeled_statement.\n\t(cp_parser_label_for_labeled_statement): Take c++11 attributes\n\tin parameter.\n\t* semantics.c (potential_constant_expression_1): Likewise.\n\t* typeck.c (fundamental_alignment_p, cxx_alignas_expr): New public\n\tfunctions.\n\ngcc/testsuite/\n\n\t* g++.dg/cpp0x/gen-attrs-1.C: New test.\n\t* g++.dg/cpp0x/gen-attrs-2.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-2-1.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-3.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-4.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-5.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-6.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-7.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-8.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-9.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-10.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-11.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-12.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-13.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-14.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-15.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-16.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-17.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-18.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-19.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-20.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-21.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-22.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-23.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-24.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-25.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-26.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-27.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-28.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-29.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-30.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-31.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-32.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-33.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-34.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-35.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-36.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-36-1.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-37.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-38.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-39.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-39-1.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-40.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-41.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-42.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-43.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-44.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-45.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-46.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-47.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-47-1.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-48.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-49.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-50.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-51.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-52.C: Likewise.\n\t* g++.dg/cpp0x/gen-attrs-53.C: Likewise.\n\nFrom-SVN: r192199", "tree": {"sha": "1a1442f932577112e42d0c3a2bb905d3ce01d5de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a1442f932577112e42d0c3a2bb905d3ce01d5de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e28d52cffbb2abc7a5764ed4c97a25c376913fee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28d52cffbb2abc7a5764ed4c97a25c376913fee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28d52cffbb2abc7a5764ed4c97a25c376913fee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28d52cffbb2abc7a5764ed4c97a25c376913fee/comments", "author": null, "committer": null, "parents": [{"sha": "f70308d411efebfce8f15b54fedd21c17d44740c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70308d411efebfce8f15b54fedd21c17d44740c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70308d411efebfce8f15b54fedd21c17d44740c"}], "stats": {"total": 2221, "additions": 2084, "deletions": 137}, "files": [{"sha": "460ed8416bfe836dce6aaade53fd8cdbace8c34a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -1,3 +1,35 @@\n+2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/53528 C++11 attribute support\n+\t* plugin.h (register_scoped_attributes): Declare new function.\n+\t* tree.h (enu attribute_flags::ATTR_FLAG_CXX_11): New flag.\n+\t(lookup_scoped_attribute_spec, cxx_11_attribute_p)\n+\t(get_attribute_name, get_attribute_namespace): Declare new functions.\n+\t(struct attribute_spec): Remove const qualifier from the members.\n+\t* tree.c (comp_type_attributes, private_lookup_attribute)\n+\t(lookup_ident_attribute, remove_attribute, merge_attribute)\n+\t(attribute_hash_list, attribute_list_contained): Use\n+\tget_attribute_name.\n+\t* attribs.c (decl_attributes): Don't crash on error_mark_node.\n+\tForbid c++11 attributes appertaining to type-specifiers.\n+\t(attribute_hash): Remove global variable.\n+\t(attributes_table): New global variable.\n+\t(find_attribute_namespace, register_scoped_attribute): New static\n+\tfunctions.\n+\t(register_scoped_attributes, lookup_scoped_attribute_spec)\n+\t(cxx11_attribute_p, get_attribute_name, get_attribute_namespace):\n+\tNew public functions.\n+\t(init_attributes): Register all the GNU attributes into the \"gnu\"\n+\tnamespace.\n+\t(register_attribute): Use register_scoped_attribute to register\n+\tthe attribute into the \"gnu\" namespace.\n+\t(lookup_attribute_spec): Use lookup_scoped_attribute_spec to\n+\tlookup the attribute in the \"gnu\" namespace.\n+\t(decl_attributes): Use new get_attribute_namespace and\n+\tlookup_scoped_attribute_spec to consider attribute namespaces when\n+\tlooking up attributes.  When operating in c++-11 mode, pass flag\n+\tATTR_FLAG_CXX11 to the spec handler.\n+\n 2012-10-08  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/54815"}, {"sha": "b330f27d89d2ab9c8db9dfa92bad89a7c1fffddd", "filename": "gcc/attribs.c", "status": "modified", "additions": 207, "deletions": 22, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -38,9 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n    searched.  */\n static const struct attribute_spec *attribute_tables[4];\n \n-/* Hashtable mapping names (represented as substrings) to attribute specs. */\n-static htab_t attribute_hash;\n-\n /* Substring representation.  */\n \n struct substring\n@@ -49,6 +46,28 @@ struct substring\n   int length;\n };\n \n+DEF_VEC_O (attribute_spec);\n+DEF_VEC_ALLOC_O (attribute_spec, heap);\n+\n+/* Scoped attribute name representation.  */\n+\n+struct scoped_attributes\n+{\n+  const char *ns;\n+  VEC (attribute_spec, heap) *attributes;\n+  htab_t attribute_hash;\n+};\n+\n+DEF_VEC_O (scoped_attributes);\n+DEF_VEC_ALLOC_O (scoped_attributes, heap);\n+\n+/* The table of scope attributes.  */\n+static VEC(scoped_attributes, heap) *attributes_table;\n+\n+static scoped_attributes* find_attribute_namespace (const char*);\n+static void register_scoped_attribute (const struct attribute_spec *,\n+\t\t\t\t       scoped_attributes *);\n+\n static bool attributes_initialized = false;\n \n /* Default empty table of attributes.  */\n@@ -102,14 +121,71 @@ eq_attr (const void *p, const void *q)\n   return (!strncmp (spec->name, str->str, str->length) && !spec->name[str->length]);\n }\n \n+/* Insert an array of attributes ATTRIBUTES into a namespace.  This\n+   array must be NULL terminated.  NS is the name of attribute\n+   namespace.  The function returns the namespace into which the\n+   attributes have been registered.  */\n+\n+scoped_attributes*\n+register_scoped_attributes (const struct attribute_spec * attributes,\n+\t\t\t    const char* ns)\n+{\n+  scoped_attributes *result = NULL;\n+\n+  /* See if we already have attributes in the namespace NS.  */\n+  result = find_attribute_namespace (ns);\n+\n+  if (result == NULL)\n+    {\n+      /* We don't have any namespace NS yet.  Create one.  */\n+      scoped_attributes sa;\n+\n+      if (attributes_table == NULL)\n+\tattributes_table = VEC_alloc (scoped_attributes, heap, 64);\n+\n+      memset (&sa, 0, sizeof (sa));\n+      sa.ns = ns;\n+      sa.attributes = VEC_alloc (attribute_spec, heap, 64);\n+      result = VEC_safe_push (scoped_attributes, heap, attributes_table, sa);      \n+    }\n+\n+  /* Really add the attributes to their namespace now.  */\n+  for (unsigned i = 0; attributes[i].name != NULL; ++i)\n+    {\n+      VEC_safe_push (attribute_spec, heap,\n+\t\t     result->attributes, attributes[i]);\n+      register_scoped_attribute (&attributes[i], result);\n+    }\n+\n+  gcc_assert (result != NULL);\n+\n+  return result;\n+}\n+\n+/* Return the namespace which name is NS, NULL if none exist.  */\n+\n+static scoped_attributes*\n+find_attribute_namespace (const char* ns)\n+{\n+  unsigned ix;\n+  scoped_attributes *iter;\n+\n+  FOR_EACH_VEC_ELT (scoped_attributes, attributes_table, ix, iter)\n+    if (ns == iter->ns\n+\t|| (iter->ns != NULL\n+\t    && ns != NULL\n+\t    && !strcmp (iter->ns, ns)))\n+      return iter;\n+  return NULL;\n+}\n+\n /* Initialize attribute tables, and make some sanity checks\n    if --enable-checking.  */\n \n void\n init_attributes (void)\n {\n   size_t i;\n-  int k;\n \n   if (attributes_initialized)\n     return;\n@@ -181,12 +257,10 @@ init_attributes (void)\n     }\n #endif\n \n-  attribute_hash = htab_create (200, hash_attr, eq_attr, NULL);\n-  for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n-    for (k = 0; attribute_tables[i][k].name != NULL; k++)\n-      {\n-        register_attribute (&attribute_tables[i][k]);\n-      }\n+  for (i = 0; i < ARRAY_SIZE (attribute_tables); ++i)\n+    /* Put all the GNU attributes into the \"gnu\" namespace.  */\n+    register_scoped_attributes (attribute_tables[i], \"gnu\");\n+\n   invoke_plugin_callbacks (PLUGIN_ATTRIBUTES, NULL);\n   attributes_initialized = true;\n }\n@@ -195,38 +269,70 @@ init_attributes (void)\n \n void\n register_attribute (const struct attribute_spec *attr)\n+{\n+  register_scoped_attribute (attr, find_attribute_namespace (\"gnu\"));\n+}\n+\n+/* Insert a single attribute ATTR into a namespace of attributes.  */\n+\n+static void\n+register_scoped_attribute (const struct attribute_spec *attr,\n+\t\t\t   scoped_attributes *name_space)\n {\n   struct substring str;\n   void **slot;\n \n+  gcc_assert (attr != NULL && name_space != NULL);\n+\n+  if (name_space->attribute_hash == NULL)\n+   name_space->attribute_hash = htab_create (200, hash_attr, eq_attr, NULL);\n+\n   str.str = attr->name;\n   str.length = strlen (str.str);\n \n   /* Attribute names in the table must be in the form 'text' and not\n      in the form '__text__'.  */\n   gcc_assert (str.length > 0 && str.str[0] != '_');\n \n-  slot = htab_find_slot_with_hash (attribute_hash, &str,\n+  slot = htab_find_slot_with_hash (name_space->attribute_hash, &str,\n \t\t\t\t   substring_hash (str.str, str.length),\n \t\t\t\t   INSERT);\n   gcc_assert (!*slot || attr->name[0] == '*');\n   *slot = (void *) CONST_CAST (struct attribute_spec *, attr);\n }\n \n-/* Return the spec for the attribute named NAME.  */\n+/* Return the spec for the scoped attribute with namespace NS and\n+   name NAME.   */\n \n const struct attribute_spec *\n-lookup_attribute_spec (const_tree name)\n+lookup_scoped_attribute_spec (const_tree ns, const_tree name)\n {\n   struct substring attr;\n+  scoped_attributes *attrs;\n+\n+  const char *ns_str = (ns != NULL_TREE) ? IDENTIFIER_POINTER (ns): NULL;\n+\n+  attrs = find_attribute_namespace (ns_str);\n+\n+  if (attrs == NULL)\n+    return NULL;\n \n   attr.str = IDENTIFIER_POINTER (name);\n   attr.length = IDENTIFIER_LENGTH (name);\n   extract_attribute_substring (&attr);\n   return (const struct attribute_spec *)\n-    htab_find_with_hash (attribute_hash, &attr,\n+    htab_find_with_hash (attrs->attribute_hash, &attr,\n \t\t\t substring_hash (attr.str, attr.length));\n }\n+\n+/* Return the spec for the attribute named NAME.  */\n+\n+const struct attribute_spec *\n+lookup_attribute_spec (const_tree name)\n+{\n+  return lookup_scoped_attribute_spec (get_identifier (\"gnu\"), name);\n+}\n+\n \f\n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n@@ -243,7 +349,7 @@ decl_attributes (tree *node, tree attributes, int flags)\n   tree a;\n   tree returned_attrs = NULL_TREE;\n \n-  if (TREE_TYPE (*node) == error_mark_node)\n+  if (TREE_TYPE (*node) == error_mark_node || attributes == error_mark_node)\n     return NULL_TREE;\n \n   if (!attributes_initialized)\n@@ -302,19 +408,28 @@ decl_attributes (tree *node, tree attributes, int flags)\n \n   for (a = attributes; a; a = TREE_CHAIN (a))\n     {\n-      tree name = TREE_PURPOSE (a);\n+      tree ns = get_attribute_namespace (a);\n+      tree name = get_attribute_name (a);\n       tree args = TREE_VALUE (a);\n       tree *anode = node;\n-      const struct attribute_spec *spec = lookup_attribute_spec (name);\n+      const struct attribute_spec *spec =\n+\tlookup_scoped_attribute_spec (ns, name);\n       bool no_add_attrs = 0;\n       int fn_ptr_quals = 0;\n       tree fn_ptr_tmp = NULL_TREE;\n \n       if (spec == NULL)\n \t{\n \t  if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n-\t    warning (OPT_Wattributes, \"%qE attribute directive ignored\",\n-\t\t     name);\n+\t    {\n+\t      if (ns == NULL_TREE || !cxx11_attribute_p (a))\n+\t\twarning (OPT_Wattributes, \"%qE attribute directive ignored\",\n+\t\t\t name);\n+\t      else\n+\t\twarning (OPT_Wattributes,\n+\t\t\t \"%<%E::%E%> scoped attribute directive ignored\",\n+\t\t\t ns, name);\n+\t    }\n \t  continue;\n \t}\n       else if (list_length (args) < spec->min_length\n@@ -327,6 +442,20 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t}\n       gcc_assert (is_attribute_p (spec->name, name));\n \n+      if (TYPE_P (*node)\n+\t  && cxx11_attribute_p (a)\n+\t  && !(flags & ATTR_FLAG_TYPE_IN_PLACE))\n+\t{\n+\t  /* This is a c++11 attribute that appertains to a\n+\t     type-specifier, outside of the definition of, a class\n+\t     type.  Ignore it.  */\n+\t  warning (OPT_Wattributes, \"attribute ignored\");\n+\t  inform (input_location,\n+\t\t  \"an attribute that appertains to a type-specifier \"\n+\t\t  \"is ignored\");\n+\t  continue;\n+\t}\n+\n       if (spec->decl_required && !DECL_P (*anode))\n \t{\n \t  if (flags & ((int) ATTR_FLAG_DECL_NEXT\n@@ -406,9 +535,15 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t}\n \n       if (spec->handler != NULL)\n-\treturned_attrs = chainon ((*spec->handler) (anode, name, args,\n-\t\t\t\t\t\t    flags, &no_add_attrs),\n-\t\t\t\t  returned_attrs);\n+\t{\n+\t  int cxx11_flag =\n+\t    cxx11_attribute_p (a) ? ATTR_FLAG_CXX11 : 0;\n+\n+\t  returned_attrs = chainon ((*spec->handler) (anode, name, args,\n+\t\t\t\t\t\t      flags|cxx11_flag,\n+\t\t\t\t\t\t      &no_add_attrs),\n+\t\t\t\t    returned_attrs);\n+\t}\n \n       /* Layout the decl in case anything changed.  */\n       if (spec->type_required && DECL_P (*node)\n@@ -488,6 +623,56 @@ decl_attributes (tree *node, tree attributes, int flags)\n   return returned_attrs;\n }\n \n+/* Return TRUE iff ATTR has been parsed by the front-end as a C++-11\n+   attribute.\n+\n+   When G++ parses a C++11 attribute, it is represented as\n+   a TREE_LIST which TREE_PURPOSE is itself a TREE_LIST.  TREE_PURPOSE\n+   (TREE_PURPOSE (ATTR)) is the namespace of the attribute, and the\n+   TREE_VALUE (TREE_PURPOSE (ATTR)) is its non-qualified name.  Please\n+   use get_attribute_namespace and get_attribute_name to retrieve the\n+   namespace and name of the attribute, as these accessors work with\n+   GNU attributes as well.  */\n+\n+bool\n+cxx11_attribute_p (const_tree attr)\n+{\n+  if (attr == NULL_TREE\n+      || TREE_CODE (attr) != TREE_LIST)\n+    return false;\n+\n+  return (TREE_CODE (TREE_PURPOSE (attr)) == TREE_LIST);\n+}\n+\n+/* Return the name of the attribute ATTR.  This accessor works on GNU\n+   and C++11 (scoped) attributes.\n+\n+   Please read the comments of cxx11_attribute_p to understand the\n+   format of attributes.  */\n+\n+tree\n+get_attribute_name (const_tree attr)\n+{\n+  if (cxx11_attribute_p (attr))\n+    return TREE_VALUE (TREE_PURPOSE (attr));\n+  return TREE_PURPOSE (attr);\n+}\n+\n+/* Return the namespace of the attribute ATTR.  This accessor works on\n+   GNU and C++11 (scoped) attributes.  On GNU attributes,\n+   it returns an identifier tree for the string \"gnu\".\n+\n+   Please read the comments of cxx11_attribute_p to understand the\n+   format of attributes.  */\n+\n+tree\n+get_attribute_namespace (const_tree attr)\n+{\n+  if (cxx11_attribute_p (attr))\n+    return TREE_PURPOSE (TREE_PURPOSE (attr));\n+  return get_identifier (\"gnu\");\n+}\n+\n /* Subroutine of set_method_tm_attributes.  Apply TM attribute ATTR\n    to the method FNDECL.  */\n "}, {"sha": "b49388df86df1f6edc8b74f5035f7d03deb6509f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -1,3 +1,15 @@\n+2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/53528 C++11 attribute support\n+\t* c-common.h (bitfield_p, cxx_fundamental_alignment_p): Declare\n+\tnew functions.\n+\t* c-common.c (check_cxx_fundamental_alignment_constraints): New\n+\tstatic function.\n+\t(handle_aligned_attribute): In choose strictest alignment\n+\tamong many.  Use new check_cxx_fundamental_alignment_constraints.\n+\t(handle_transparent_union_attribute): In c++11 attribute syntax,\n+\tdon't look through typedefs.\n+\n 2012-10-04  Arnaud Charlet  <charlet@adacore.com>\n \n \t* c-ada-spec.c (print_ada_declaration): Remove handling of TDF_RAW."}, {"sha": "e24278951dabc262d0bdef96871d54ef21e848dd", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 118, "deletions": 2, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -484,6 +484,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__underlying_type\", RID_UNDERLYING_TYPE, D_CXXONLY },\n   { \"__volatile\",\tRID_VOLATILE,\t0 },\n   { \"__volatile__\",\tRID_VOLATILE,\t0 },\n+  { \"alignas\",\t\tRID_ALIGNAS,\tD_CXXONLY | D_CXX0X | D_CXXWARN },\n   { \"alignof\",\t\tRID_ALIGNOF,\tD_CXXONLY | D_CXX0X | D_CXXWARN },\n   { \"asm\",\t\tRID_ASM,\tD_ASM },\n   { \"auto\",\t\tRID_AUTO,\t0 },\n@@ -6665,7 +6666,9 @@ handle_transparent_union_attribute (tree *node, tree name,\n \n   *no_add_attrs = true;\n \n-  if (TREE_CODE (*node) == TYPE_DECL)\n+\n+  if (TREE_CODE (*node) == TYPE_DECL\n+      && ! (flags & ATTR_FLAG_CXX11))\n     node = &TREE_TYPE (*node);\n   type = *node;\n \n@@ -7137,6 +7140,89 @@ check_user_alignment (const_tree align, bool allow_zero)\n   return i;\n }\n \n+/* \n+   If in c++-11, check if the c++-11 alignment constraint with respect\n+   to fundamental alignment (in [dcl.align]) are satisfied.  If not in\n+   c++-11 mode, does nothing.\n+\n+   [dcl.align]2/ says:\n+\n+   [* if the constant expression evaluates to a fundamental alignment,\n+   the alignment requirement of the declared entity shall be the\n+   specified fundamental alignment.\n+\n+   * if the constant expression evaluates to an extended alignment\n+   and the implementation supports that alignment in the context\n+   of the declaration, the alignment of the declared entity shall\n+   be that alignment\n+\n+   * if the constant expression evaluates to an extended alignment\n+   and the implementation does not support that alignment in the\n+   context of the declaration, the program is ill-formed].  */\n+\n+static bool\n+check_cxx_fundamental_alignment_constraints (tree node,\n+\t\t\t\t\t     unsigned align_log,\n+\t\t\t\t\t     int flags)\n+{\n+  bool alignment_too_large_p = false;\n+  unsigned requested_alignment = 1U << align_log;\n+  unsigned max_align = 0;\n+\n+  if ((!(flags & ATTR_FLAG_CXX11) && !warn_cxx_compat)\n+      || (node == NULL_TREE || node == error_mark_node))\n+    return true;\n+\n+  if (cxx_fundamental_alignment_p (requested_alignment))\n+    return true;\n+\n+  if (DECL_P (node))\n+    {\n+      if (TREE_STATIC (node))\n+\t{\n+\t  /* For file scope variables and static members, the target\n+\t     supports alignments that are at most\n+\t     MAX_OFILE_ALIGNMENT.  */\n+\t  if (requested_alignment > (max_align = MAX_OFILE_ALIGNMENT))\n+\t    alignment_too_large_p = true;\n+\t}\n+      else\n+\t{\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+#define MAX_TARGET_FIELD_ALIGNMENT BIGGEST_FIELD_ALIGNMENT\n+#else\n+#define MAX_TARGET_FIELD_ALIGNMENT BIGGEST_ALIGNMENT\n+#endif\n+\t  /* For non-static members, the target supports either\n+\t     alignments that at most either BIGGEST_FIELD_ALIGNMENT\n+\t     if it is defined or BIGGEST_ALIGNMENT.  */\n+\t  max_align = MAX_TARGET_FIELD_ALIGNMENT;\n+\t  if (TREE_CODE (node) == FIELD_DECL\n+\t      && requested_alignment > (max_align = MAX_TARGET_FIELD_ALIGNMENT))\n+\t    alignment_too_large_p = true;\n+#undef MAX_TARGET_FIELD_ALIGNMENT\n+\t  /* For stack variables, the target supports at most\n+\t     MAX_STACK_ALIGNMENT.  */\n+\t  else if (decl_function_context (node) != NULL\n+\t\t   && requested_alignment > (max_align = MAX_STACK_ALIGNMENT))\n+\t    alignment_too_large_p = true;\n+\t}\n+    }\n+  else if (TYPE_P (node))\n+    {\n+      /* Let's be liberal for types.  */\n+      if (requested_alignment > (max_align = BIGGEST_ALIGNMENT))\n+\talignment_too_large_p = true;\n+    }\n+\n+  if (alignment_too_large_p)\n+    pedwarn (input_location, OPT_Wattributes,\n+\t     \"requested alignment %d is larger than %d\",\n+\t     requested_alignment, max_align);\n+\n+  return !alignment_too_large_p;\n+}\n+\n /* Handle a \"aligned\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n@@ -7160,7 +7246,8 @@ handle_aligned_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   else if (TYPE_P (*node))\n     type = node, is_type = 1;\n \n-  if ((i = check_user_alignment (align_expr, false)) == -1)\n+  if ((i = check_user_alignment (align_expr, false)) == -1\n+      || !check_cxx_fundamental_alignment_constraints (*node, i, flags))\n     *no_add_attrs = true;\n   else if (is_type)\n     {\n@@ -7190,6 +7277,17 @@ handle_aligned_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       error (\"alignment may not be specified for %q+D\", decl);\n       *no_add_attrs = true;\n     }\n+  else if (DECL_USER_ALIGN (decl)\n+\t   && DECL_ALIGN (decl) > (1U << i) * BITS_PER_UNIT)\n+    /* C++-11 [dcl.align/4]:\n+\n+           When multiple alignment-specifiers are specified for an\n+\t   entity, the alignment requirement shall be set to the\n+\t   strictest specified alignment.\n+\n+      This formally comes from the c++11 specification but we are\n+      doing it for the GNU attribute syntax as well.  */\n+    *no_add_attrs = true;\n   else if (TREE_CODE (decl) == FUNCTION_DECL\n \t   && DECL_ALIGN (decl) > (1U << i) * BITS_PER_UNIT)\n     {\n@@ -11154,4 +11252,22 @@ convert_vector_to_pointer_for_subscript (location_t loc,\n     }\n }\n \n+/* Return true iff ALIGN is an integral constant that is a fundamental\n+   alignment, as defined by [basic.align] in the c++-11\n+   specifications.\n+\n+   That is:\n+\n+       [A fundamental alignment is represented by an alignment less than or\n+        equal to the greatest alignment supported by the implementation\n+        in all contexts, which is equal to\n+        alignof(max_align_t)].  */\n+\n+bool\n+cxx_fundamental_alignment_p  (unsigned align)\n+{\n+  return (align <=  MAX (TYPE_ALIGN (long_long_integer_type_node),\n+\t\t\t TYPE_ALIGN (long_double_type_node)));\n+}\n+\n #include \"gt-c-family-c-common.h\""}, {"sha": "5b23bd3c2faf1b3044b6a12752c609add4cb7c88", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -789,6 +789,7 @@ extern bool keyword_begins_type_specifier (enum rid);\n extern bool keyword_is_storage_class_specifier (enum rid);\n extern bool keyword_is_type_qualifier (enum rid);\n extern bool keyword_is_decl_specifier (enum rid);\n+extern bool cxx_fundamental_alignment_p (unsigned);\n \n #define c_sizeof(LOC, T)  c_sizeof_or_alignof_type (LOC, T, true, 1)\n #define c_alignof(LOC, T) c_sizeof_or_alignof_type (LOC, T, false, 1)"}, {"sha": "660a2199c8fb3495b60979a4c42e9a1b6b3754b7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -1,3 +1,82 @@\n+2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/53528 C++11 attribute support\n+\t* cp-tree.h (enum cpp0x_warn_str::CPP0X_ATTRIBUTES): New member.\n+\t(enum cp_decl_spec::ds_std_attribute): New enumerator.\n+\t(struct cp_decl_specifier_seq::std_attributes): New field.\n+\t(cxx_alignas_expr, warn_misplaced_attr_for_class_type): Declare\n+\tnew functions.\n+\t(check_tag_decl): Take an extra parameter for explicit\n+\tinstantiations.\n+\t* decl.c (warn_misplaced_attr_for_class_type): Extract from ...\n+\t(check_tag_decl): ... here.  Add check for c++11 attributes being\n+\tapplied to an explicit instantiation.  Take an extra parameter for\n+\texplicit instantiations.\n+\t(grokdeclarator): Make sure a c++11 attribute after an array\n+\tdeclarator appertains to the array, an attribute after a function\n+\tdeclarator appertains to the function type, an attribute after a\n+\tdeclarator-id appertains to the entity being declared, and an\n+\tattribute after a pointer declarator appertain to the pointer.\n+\t* decl2.c (is_late_template_attribute): Use get_attribute_name.\n+\t* error.c (maybe_warn_cpp0x): Support\n+\tCPP0X_GENERALIZED_ATTRIBUTES.\n+\t* parser.c (cp_next_tokens_can_be_attribute_p)\n+\t(cp_next_tokens_can_be_gnu_attribute_p)\n+\t(cp_next_tokens_can_be_std_attribute_p)\n+\t(cp_nth_tokens_can_be_attribute_p)\n+\t(cp_nth_tokens_can_be_gnu_attribute_p)\n+\t(cp_nth_tokens_can_be_std_attribute_p)\n+\t(cp_parser_gnu_attribute_list, cp_parser_std_attribute)\n+\t(cp_parser_std_attribute_spec, cp_parser_std_attribute_spec_seq)\n+\t(cp_parser_attributes_opt, cp_parser_std_attribute_list): New\n+\tstatic functions.\n+\t(cp_parser_gnu_attributes_opt): Replace cp_parser_attributes_opt.\n+\t(cp_parser_gnu_attribute_list): Replace cp_parser_attribute_list.\n+\t(cp_parser_postfix_expression): Disallow \"[[\" tokens here.\n+\t(cp_parser_label_for_labeled_statement): Use take an extra\n+\tparameter for attributes.\n+\t(cp_parser_block_declaration): Use\n+\tcp_nth_tokens_can_be_std_attribute_p here.\n+\t(cp_parser_decl_specifier_seq): Likewise.  Store C++11 attributes\n+\tthat appears in in decl specifiers in cp_decl_specifier_seq::std_attributes.\n+\tdeclaration.  Emit proper warning about misplaced c++11 attributes\n+\tfor class type.\n+\t(cp_parser_explicit_instantiation): Adjust call to check_tag_decl.\n+\t(cp_parser_init_declarator):  Parsing attributes here is no more a\n+\tGNU extension in c++-11.\n+\t(cp_parser_type_specifier_seq): Use\n+\tcp_next_tokens_can_be_attribute_p.\n+\t(cp_parser_direct_declarator): Likewise.  Hang c++11 attributes\n+\tfollowing the declarator to its syntactic construct.  It'll later\n+\tbe applied to the proper appertaining entity by grokdeclarator.\n+\t(cp_parser_ptr_operator): Likewise.\n+\t(make_declarator): Initialize cp_declarator::std_attribute.\n+\t(make_pointer_declarator, make_reference_declarator)\n+\t(make_ptrmem_declarator, cp_parser_make_indirect_declarator): Take\n+\tattributes that appertain to the pointer/reference in argument.\n+\t(cp_parser_ptr_operator): Take an out parameter for c++11\n+\tattributes.  Update comments.\n+\t(cp_parser_new_declarator_opt)\n+\t(cp_parser_conversion_declarator_opt): Adjust.\n+\t(cp_parser_declarator): Likewise.  Handle C++11 attributes.\n+\tRename attributes to gnu_attribute for better legibility.\n+\t(cp_parser_simple_declaration): Update comment.\n+\t(cp_parser_class_specifier_1): Parse GNU attributes specifically\n+\t(cp_parser_enum_specifier): Accept only gnu attributes after the\n+\tspecifier.\n+\t(cp_parser_member_declaration): Don't clear attributes -- intended\n+\tfor the entity being declared -- too early because check_tag_decl\n+\tneeds them.\n+\t(cp_parser_statement): Update comment.  Parse optional c++11\n+\tattributes at the beginning of the relevant kind of statements and\n+\tignore them, for now, unless when calling\n+\tcp_parser_label_for_labeled_statement.\n+\t(cp_parser_label_for_labeled_statement): Take c++11 attributes\n+\tin parameter.\n+\t* semantics.c (potential_constant_expression_1): Likewise.\n+\t* typeck.c (fundamental_alignment_p, cxx_alignas_expr): New public\n+\tfunctions.\n+\n 2012-10-07  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* pt.c (fold_non_dependent_expr_sfinae): Remove static specifier."}, {"sha": "a1d4424018901a9baaaf2c74cce50cde7847aef2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -418,7 +418,9 @@ typedef enum cpp0x_warn_str\n   /* user defined literals */\n   CPP0X_USER_DEFINED_LITERALS,\n   /* delegating constructors */\n-  CPP0X_DELEGATING_CTORS\n+  CPP0X_DELEGATING_CTORS,\n+  /* C++11 attributes */\n+  CPP0X_ATTRIBUTES\n } cpp0x_warn_str;\n   \n /* The various kinds of operation used by composite_pointer_type. */\n@@ -4684,6 +4686,7 @@ typedef enum cp_decl_spec {\n   ds_type_spec,\n   ds_redefined_builtin_type_spec,\n   ds_attribute,\n+  ds_std_attribute,\n   ds_storage_class,\n   ds_long_long,\n   ds_last /* This enumerator must always be the last one.  */\n@@ -4702,6 +4705,8 @@ typedef struct cp_decl_specifier_seq {\n   tree type;\n   /* The attributes, if any, provided with the specifier sequence.  */\n   tree attributes;\n+  /* The c++11 attributes that follows the type specifier.  */\n+  tree std_attributes;\n   /* If non-NULL, a built-in type that the user attempted to redefine\n      to some other type.  */\n   tree redefined_builtin_type;\n@@ -4770,8 +4775,14 @@ struct cp_declarator {\n      to indicate this is a parameter pack.  */\n   BOOL_BITFIELD parameter_pack_p : 1;\n   location_t id_loc; /* Currently only set for cdk_id and cdk_function. */\n-  /* Attributes that apply to this declarator.  */\n+  /* GNU Attributes that apply to this declarator.  If the declarator\n+     is a pointer or a reference, these attribute apply to the type\n+     pointed to.  */\n   tree attributes;\n+  /* Standard C++11 attributes that apply to this declarator.  If the\n+     declarator is a pointer or a reference, these attributes apply\n+     to the pointer, rather than to the type pointed to.  */\n+  tree std_attributes;\n   /* For all but cdk_id and cdk_error, the contained declarator.  For\n      cdk_id and cdk_error, guaranteed to be NULL.  */\n   cp_declarator *declarator;\n@@ -5068,7 +5079,9 @@ extern tree build_cp_library_fn_ptr\t\t(const char *, tree);\n extern tree push_library_fn\t\t\t(tree, tree, tree);\n extern tree push_void_library_fn\t\t(tree, tree);\n extern tree push_throw_library_fn\t\t(tree, tree);\n-extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *);\n+extern void warn_misplaced_attr_for_class_type  (source_location location,\n+\t\t\t\t\t\t tree class_type);\n+extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *, bool);\n extern tree shadow_tag\t\t\t\t(cp_decl_specifier_seq *);\n extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, bool);\n extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree, tree *);\n@@ -5829,6 +5842,7 @@ extern int comp_cv_qualification\t\t(const_tree, const_tree);\n extern int comp_cv_qual_signature\t\t(tree, tree);\n extern tree cxx_sizeof_or_alignof_expr\t\t(tree, enum tree_code, bool);\n extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n+extern tree cxx_alignas_expr                    (tree);\n extern tree cxx_sizeof_nowarn                   (tree);\n extern tree is_bitfield_expr_with_lowered_type  (const_tree);\n extern tree unlowered_expr_type                 (const_tree);"}, {"sha": "2848ad5b7be1d1f06574693d42f59688336ab06c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 79, "deletions": 6, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -4132,13 +4132,32 @@ fixup_anonymous_aggr (tree t)\n     }\n }\n \n+/* Warn for an attribute located at LOCATION that appertains to the\n+   class type CLASS_TYPE that has not been properly placed after its\n+   class-key, in it class-specifier.  */\n+\n+void\n+warn_misplaced_attr_for_class_type (source_location location,\n+\t\t\t\t    tree class_type)\n+{\n+  gcc_assert (TAGGED_TYPE_P (class_type));\n+\n+  warning_at (location, OPT_Wattributes,\n+\t      \"attribute ignored in declaration \"\n+\t      \"of %q#T\", class_type);\n+  inform (location,\n+\t  \"attribute for %q#T must follow the %qs keyword\",\n+\t  class_type, class_key_or_enum_as_string (class_type));\n+}\n+\n /* Make sure that a declaration with no declarator is well-formed, i.e.\n    just declares a tagged type or anonymous union.\n \n    Returns the type declared; or NULL_TREE if none.  */\n \n tree\n-check_tag_decl (cp_decl_specifier_seq *declspecs)\n+check_tag_decl (cp_decl_specifier_seq *declspecs,\n+\t\tbool explicit_type_instantiation_p)\n {\n   int saw_friend = decl_spec_seq_has_spec_p (declspecs, ds_friend);\n   int saw_typedef = decl_spec_seq_has_spec_p (declspecs, ds_typedef);\n@@ -4247,10 +4266,22 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n \t/* For a template class (an explicit instantiation), use the\n \t   current location.  */\n \tloc = input_location;\n-      warning_at (loc, OPT_Wattributes, \"attribute ignored in declaration \"\n-\t\t  \"of %q#T\", declared_type);\n-      inform (loc, \"attribute for %q#T must follow the %qs keyword\",\n-\t      declared_type, class_key_or_enum_as_string (declared_type));\n+\n+      if (explicit_type_instantiation_p)\n+\t/* [dcl.attr.grammar]/4:\n+\n+\t       No attribute-specifier-seq shall appertain to an explicit\n+\t       instantiation.  */\n+\t{\n+\t  warning_at (loc, OPT_Wattributes,\n+\t\t      \"attribute ignored in explicit instantiation %q#T\",\n+\t\t      declared_type);\n+\t  inform (loc,\n+\t\t  \"no attribute can be applied to \"\n+\t\t  \"an explicit instantiation\");\n+\t}\n+      else\n+\twarn_misplaced_attr_for_class_type (loc, declared_type);\n     }\n \n   return declared_type;\n@@ -4272,7 +4303,8 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n tree\n shadow_tag (cp_decl_specifier_seq *declspecs)\n {\n-  tree t = check_tag_decl (declspecs);\n+  tree t = check_tag_decl (declspecs,\n+\t\t\t   /*explicit_type_instantiation_p=*/false);\n \n   if (!t)\n     return NULL_TREE;\n@@ -9178,6 +9210,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t}\n     }\n \n+  if (declspecs->std_attributes)\n+    {\n+      /* Apply the c++11 attributes to the type preceding them.  */\n+      source_location saved_loc = input_location;\n+      input_location = declspecs->locations[ds_std_attribute];\n+      decl_attributes (&type, declspecs->std_attributes, 0);\n+      input_location = saved_loc;\n+    }\n+\n   /* Determine the type of the entity declared by recurring on the\n      declarator.  */\n   for (; declarator; declarator = declarator->declarator)\n@@ -9215,6 +9256,13 @@ grokdeclarator (const cp_declarator *declarator,\n \tcase cdk_array:\n \t  type = create_array_type_for_decl (dname, type,\n \t\t\t\t\t     declarator->u.array.bounds);\n+\t  if (declarator->std_attributes)\n+\t    /* [dcl.array]/1:\n+\n+\t       The optional attribute-specifier-seq appertains to the\n+\t       array.  */\n+\t    returned_attrs = chainon (returned_attrs,\n+\t\t\t\t      declarator->std_attributes);\n \t  break;\n \n \tcase cdk_function:\n@@ -9411,6 +9459,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \n \t    type = build_function_type (type, arg_types);\n+\t    if (declarator->std_attributes)\n+\t      /* [dcl.fct]/2:\n+\n+\t\t The optional attribute-specifier-seq appertains to\n+\t\t the function type.  */\n+\t      decl_attributes (&type, declarator->std_attributes,\n+\t\t\t       0);\n \t  }\n \t  break;\n \n@@ -9573,6 +9628,17 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t\t\t   declarator->u.pointer.qualifiers);\n \t      type_quals = cp_type_quals (type);\n \t    }\n+\n+\t  /* Apply C++11 attributes to the pointer, and not to the\n+\t     type pointed to.  This is unlike what is done for GNU\n+\t     attributes above.  It is to comply with [dcl.ptr]/1:\n+\n+\t\t [the optional attribute-specifier-seq (7.6.1) appertains\n+\t\t  to the pointer and not to the object pointed to].  */\n+\t  if (declarator->std_attributes)\n+\t    decl_attributes (&type, declarator->std_attributes,\n+\t\t\t     0);\n+\n \t  ctype = NULL_TREE;\n \t  break;\n \n@@ -9698,6 +9764,13 @@ grokdeclarator (const cp_declarator *declarator,\n \tattrlist = &returned_attrs;\n     }\n \n+  if (declarator\n+      && declarator->kind == cdk_id\n+      && declarator->std_attributes)\n+    /* [dcl.meaning]/1: The optional attribute-specifier-seq following\n+       a declarator-id appertains to the entity that is declared.  */\n+    *attrlist = chainon (*attrlist, declarator->std_attributes);\n+\n   /* Handle parameter packs. */\n   if (parameter_pack_p)\n     {"}, {"sha": "aad3d0b26f751e861b86b71ccab39281ab999376", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -1091,7 +1091,7 @@ grokbitfield (const cp_declarator *declarator,\n static bool\n is_late_template_attribute (tree attr, tree decl)\n {\n-  tree name = TREE_PURPOSE (attr);\n+  tree name = get_attribute_name (attr);\n   tree args = TREE_VALUE (attr);\n   const struct attribute_spec *spec = lookup_attribute_spec (name);\n   tree arg;"}, {"sha": "2934c9b10783c40b1217eb1b2bffed128f95197b", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -3374,6 +3374,11 @@ maybe_warn_cpp0x (cpp0x_warn_str str)\n \t\t \"delegating constructors \"\n \t\t \"only available with -std=c++11 or -std=gnu++11\");\n         break;\n+      case CPP0X_ATTRIBUTES:\n+\tpedwarn (input_location, 0,\n+\t\t \"c++11 attributes \"\n+\t\t \"only available with -std=c++11 or -std=gnu++11\");\n+\tbreak;\n       default:\n \tgcc_unreachable ();\n       }"}, {"sha": "07f76e39ec6e60316473200f0be88efb261a78f6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 584, "deletions": 76, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -1197,13 +1197,13 @@ static cp_declarator *make_call_declarator\n static cp_declarator *make_array_declarator\n   (cp_declarator *, tree);\n static cp_declarator *make_pointer_declarator\n-  (cp_cv_quals, cp_declarator *);\n+  (cp_cv_quals, cp_declarator *, tree);\n static cp_declarator *make_reference_declarator\n-  (cp_cv_quals, cp_declarator *, bool);\n+  (cp_cv_quals, cp_declarator *, bool, tree);\n static cp_parameter_declarator *make_parameter_declarator\n   (cp_decl_specifier_seq *, cp_declarator *, tree);\n static cp_declarator *make_ptrmem_declarator\n-  (cp_cv_quals, tree, cp_declarator *);\n+  (cp_cv_quals, tree, cp_declarator *, tree);\n \n /* An erroneous declarator.  */\n static cp_declarator *cp_error_declarator;\n@@ -1231,6 +1231,7 @@ make_declarator (cp_declarator_kind kind)\n   declarator = (cp_declarator *) alloc_declarator (sizeof (cp_declarator));\n   declarator->kind = kind;\n   declarator->attributes = NULL_TREE;\n+  declarator->std_attributes = NULL_TREE;\n   declarator->declarator = NULL;\n   declarator->parameter_pack_p = false;\n   declarator->id_loc = UNKNOWN_LOCATION;\n@@ -1277,10 +1278,12 @@ make_id_declarator (tree qualifying_scope, tree unqualified_name,\n \n /* Make a declarator for a pointer to TARGET.  CV_QUALIFIERS is a list\n    of modifiers such as const or volatile to apply to the pointer\n-   type, represented as identifiers.  */\n+   type, represented as identifiers.  ATTRIBUTES represent the attributes that\n+   appertain to the pointer or reference.  */\n \n cp_declarator *\n-make_pointer_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n+make_pointer_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target,\n+\t\t\t tree attributes)\n {\n   cp_declarator *declarator;\n \n@@ -1297,14 +1300,18 @@ make_pointer_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n   else\n     declarator->parameter_pack_p = false;\n \n+  declarator->std_attributes = attributes;\n+\n   return declarator;\n }\n \n-/* Like make_pointer_declarator -- but for references.  */\n+/* Like make_pointer_declarator -- but for references.  ATTRIBUTES\n+   represent the attributes that appertain to the pointer or\n+   reference.  */\n \n cp_declarator *\n make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target,\n-\t\t\t   bool rvalue_ref)\n+\t\t\t   bool rvalue_ref, tree attributes)\n {\n   cp_declarator *declarator;\n \n@@ -1321,15 +1328,19 @@ make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target,\n   else\n     declarator->parameter_pack_p = false;\n \n+  declarator->std_attributes = attributes;\n+\n   return declarator;\n }\n \n /* Like make_pointer_declarator -- but for a pointer to a non-static\n-   member of CLASS_TYPE.  */\n+   member of CLASS_TYPE.  ATTRIBUTES represent the attributes that\n+   appertain to the pointer or reference.  */\n \n cp_declarator *\n make_ptrmem_declarator (cp_cv_quals cv_qualifiers, tree class_type,\n-\t\t\tcp_declarator *pointee)\n+\t\t\tcp_declarator *pointee,\n+\t\t\ttree attributes)\n {\n   cp_declarator *declarator;\n \n@@ -1346,6 +1357,8 @@ make_ptrmem_declarator (cp_cv_quals cv_qualifiers, tree class_type,\n   else\n     declarator->parameter_pack_p = false;\n \n+  declarator->std_attributes = attributes;\n+\n   return declarator;\n }\n \n@@ -1853,7 +1866,7 @@ static void cp_parser_lambda_body\n static void cp_parser_statement\n   (cp_parser *, tree, bool, bool *);\n static void cp_parser_label_for_labeled_statement\n-  (cp_parser *);\n+(cp_parser *, tree);\n static tree cp_parser_expression_statement\n   (cp_parser *, tree);\n static tree cp_parser_compound_statement\n@@ -1957,7 +1970,7 @@ static cp_declarator *cp_parser_declarator\n static cp_declarator *cp_parser_direct_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool);\n static enum tree_code cp_parser_ptr_operator\n-  (cp_parser *, tree *, cp_cv_quals *);\n+  (cp_parser *, tree *, cp_cv_quals *, tree *);\n static cp_cv_quals cp_parser_cv_qualifier_seq_opt\n   (cp_parser *);\n static cp_virt_specifiers cp_parser_virt_specifier_seq_opt\n@@ -2099,9 +2112,29 @@ static tree cp_parser_asm_clobber_list\n   (cp_parser *);\n static tree cp_parser_asm_label_list\n   (cp_parser *);\n+static bool cp_next_tokens_can_be_attribute_p\n+  (cp_parser *);\n+static bool cp_next_tokens_can_be_gnu_attribute_p\n+  (cp_parser *);\n+static bool cp_next_tokens_can_be_std_attribute_p\n+  (cp_parser *);\n+static bool cp_nth_tokens_can_be_std_attribute_p\n+  (cp_parser *, size_t);\n+static bool cp_nth_tokens_can_be_gnu_attribute_p\n+  (cp_parser *, size_t);\n+static bool cp_nth_tokens_can_be_attribute_p\n+  (cp_parser *, size_t);\n static tree cp_parser_attributes_opt\n   (cp_parser *);\n-static tree cp_parser_attribute_list\n+static tree cp_parser_gnu_attributes_opt\n+  (cp_parser *);\n+static tree cp_parser_gnu_attribute_list\n+  (cp_parser *);\n+static tree cp_parser_std_attribute\n+  (cp_parser *);\n+static tree cp_parser_std_attribute_spec\n+  (cp_parser *);\n+static tree cp_parser_std_attribute_spec_seq\n   (cp_parser *);\n static bool cp_parser_extension_opt\n   (cp_parser *, int *);\n@@ -2308,7 +2341,7 @@ static bool cp_parser_is_keyword\n static tree cp_parser_make_typename_type\n   (cp_parser *, tree, tree, location_t location);\n static cp_declarator * cp_parser_make_indirect_declarator\n-  (enum tree_code, tree, cp_cv_quals, cp_declarator *);\n+ (enum tree_code, tree, cp_cv_quals, cp_declarator *, tree);\n \n /* Returns nonzero if we are parsing tentatively.  */\n \n@@ -3178,24 +3211,30 @@ cp_parser_make_typename_type (cp_parser *parser, tree scope,\n    make_{pointer,ptrmem,reference}_declarator functions that decides\n    which one to call based on the CODE and CLASS_TYPE arguments. The\n    CODE argument should be one of the values returned by\n-   cp_parser_ptr_operator. */\n+   cp_parser_ptr_operator.  ATTRIBUTES represent the attributes that\n+   appertain to the pointer or reference.  */\n+\n static cp_declarator *\n cp_parser_make_indirect_declarator (enum tree_code code, tree class_type,\n \t\t\t\t    cp_cv_quals cv_qualifiers,\n-\t\t\t\t    cp_declarator *target)\n+\t\t\t\t    cp_declarator *target,\n+\t\t\t\t    tree attributes)\n {\n   if (code == ERROR_MARK)\n     return cp_error_declarator;\n \n   if (code == INDIRECT_REF)\n     if (class_type == NULL_TREE)\n-      return make_pointer_declarator (cv_qualifiers, target);\n+      return make_pointer_declarator (cv_qualifiers, target, attributes);\n     else\n-      return make_ptrmem_declarator (cv_qualifiers, class_type, target);\n+      return make_ptrmem_declarator (cv_qualifiers, class_type,\n+\t\t\t\t     target, attributes);\n   else if (code == ADDR_EXPR && class_type == NULL_TREE)\n-    return make_reference_declarator (cv_qualifiers, target, false);\n+    return make_reference_declarator (cv_qualifiers, target,\n+\t\t\t\t      false, attributes);\n   else if (code == NON_LVALUE_EXPR && class_type == NULL_TREE)\n-    return make_reference_declarator (cv_qualifiers, target, true);\n+    return make_reference_declarator (cv_qualifiers, target,\n+\t\t\t\t      true, attributes);\n   gcc_unreachable ();\n }\n \n@@ -5605,6 +5644,13 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n       switch (token->type)\n \t{\n \tcase CPP_OPEN_SQUARE:\n+\t  if (cp_next_tokens_can_be_std_attribute_p (parser))\n+\t    {\n+\t      cp_parser_error (parser,\n+\t\t\t       \"two consecutive %<[%> shall \"\n+\t\t\t       \"only introduce an attribute\");\n+\t      return error_mark_node;\n+\t    }\n \t  postfix_expression\n \t    = cp_parser_postfix_open_square_expression (parser,\n \t\t\t\t\t\t\tpostfix_expression,\n@@ -6873,13 +6919,13 @@ static cp_declarator *\n cp_parser_new_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n-  tree type;\n-  cp_cv_quals cv_quals;\n+  tree type, std_attributes = NULL_TREE;\n+  cp_cv_quals cv_quals;  \n \n   /* We don't know if there's a ptr-operator next, or not.  */\n   cp_parser_parse_tentatively (parser);\n   /* Look for a ptr-operator.  */\n-  code = cp_parser_ptr_operator (parser, &type, &cv_quals);\n+  code = cp_parser_ptr_operator (parser, &type, &cv_quals, &std_attributes);\n   /* If that worked, look for more new-declarators.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n@@ -6888,8 +6934,10 @@ cp_parser_new_declarator_opt (cp_parser* parser)\n       /* Parse another optional declarator.  */\n       declarator = cp_parser_new_declarator_opt (parser);\n \n-      return cp_parser_make_indirect_declarator\n-\t(code, type, cv_quals, declarator);\n+      declarator = cp_parser_make_indirect_declarator\n+\t(code, type, cv_quals, declarator, std_attributes);\n+\n+      return declarator;\n     }\n \n   /* If the next token is a `[', there is a direct-new-declarator.  */\n@@ -8628,6 +8676,18 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n      declaration-statement\n      try-block\n \n+  C++11:\n+\n+  statement:\n+    labeled-statement\n+    attribute-specifier-seq (opt) expression-statement\n+    attribute-specifier-seq (opt) compound-statement\n+    attribute-specifier-seq (opt) selection-statement\n+    attribute-specifier-seq (opt) iteration-statement\n+    attribute-specifier-seq (opt) jump-statement\n+    declaration-statement\n+    attribute-specifier-seq (opt) try-block\n+\n   TM Extension:\n \n    statement:\n@@ -8644,15 +8704,20 @@ static void\n cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t\t     bool in_compound, bool *if_p)\n {\n-  tree statement;\n+  tree statement, std_attrs = NULL_TREE;\n   cp_token *token;\n-  location_t statement_location;\n+  location_t statement_location, attrs_location;\n \n  restart:\n   if (if_p != NULL)\n     *if_p = false;\n   /* There is no statement yet.  */\n   statement = NULL_TREE;\n+\n+  cp_lexer_save_tokens (parser->lexer);\n+  attrs_location = cp_lexer_peek_token (parser->lexer)->location;\n+  std_attrs = cp_parser_std_attribute_spec_seq (parser);\n+\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Remember the location of the first token in the statement.  */\n@@ -8670,7 +8735,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  /* Looks like a labeled-statement with a case label.\n \t     Parse the label, and then use tail recursion to parse\n \t     the statement.  */\n-\t  cp_parser_label_for_labeled_statement (parser);\n+\t  cp_parser_label_for_labeled_statement (parser, std_attrs);\n \t  goto restart;\n \n \tcase RID_IF:\n@@ -8733,7 +8798,8 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  /* Looks like a labeled-statement with an ordinary label.\n \t     Parse the label, and then use tail recursion to parse\n \t     the statement.  */\n-\t  cp_parser_label_for_labeled_statement (parser);\n+\n+\t  cp_parser_label_for_labeled_statement (parser, std_attrs);\n \t  goto restart;\n \t}\n     }\n@@ -8769,6 +8835,14 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n     {\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n \t{\n+\t  if (std_attrs != NULL_TREE)\n+\t    {\n+\t      /*  Attributes should be parsed as part of the the\n+\t\t  declaration, so let's un-parse them.  */\n+\t      cp_lexer_rollback_tokens (parser->lexer);\n+\t      std_attrs = NULL_TREE;\n+\t    }\n+\n \t  cp_parser_parse_tentatively (parser);\n \t  /* Try to parse the declaration-statement.  */\n \t  cp_parser_declaration_statement (parser);\n@@ -8783,6 +8857,13 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n   /* Set the line number for the statement.  */\n   if (statement && STATEMENT_CODE_P (TREE_CODE (statement)))\n     SET_EXPR_LOCATION (statement, statement_location);\n+\n+  /* Note that for now, we don't do anything with c++11 statements\n+     parsed at this level.  */\n+  if (std_attrs != NULL_TREE)\n+    warning_at (attrs_location,\n+\t\tOPT_Wattributes,\n+\t\t\"attributes at the beginning of statement are ignored\");\n }\n \n /* Parse the label for a labeled-statement, i.e.\n@@ -8799,7 +8880,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n    have to return the label.  */\n \n static void\n-cp_parser_label_for_labeled_statement (cp_parser* parser)\n+cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n {\n   cp_token *token;\n   tree label = NULL_TREE;\n@@ -8879,21 +8960,23 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n        lab: __attribute__ ((unused)) int i;\n      we want the attribute to attach to \"i\", not \"lab\".  */\n   if (label != NULL_TREE\n-      && cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n+      && cp_next_tokens_can_be_gnu_attribute_p (parser))\n     {\n       tree attrs;\n-\n       cp_parser_parse_tentatively (parser);\n-      attrs = cp_parser_attributes_opt (parser);\n+      attrs = cp_parser_gnu_attributes_opt (parser);\n       if (attrs == NULL_TREE\n \t  || cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n \tcp_parser_abort_tentative_parse (parser);\n       else if (!cp_parser_parse_definitely (parser))\n \t;\n       else\n-\tcplus_decl_attributes (&label, attrs, 0);\n+\tattributes = chainon (attributes, attrs);\n     }\n \n+  if (attributes != NULL_TREE)\n+    cplus_decl_attributes (&label, attributes, 0);\n+\n   parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n }\n \n@@ -10319,8 +10402,7 @@ cp_parser_block_declaration (cp_parser *parser,\n       else if (cxx_dialect >= cxx0x\n \t       && token2->type == CPP_NAME\n \t       && ((cp_lexer_peek_nth_token (parser->lexer, 3)->type == CPP_EQ)\n-\t\t   || (cp_lexer_peek_nth_token (parser->lexer, 3)->keyword\n-\t\t       == RID_ATTRIBUTE)))\n+\t\t   || (cp_nth_tokens_can_be_attribute_p (parser, 3))))\n \tcp_parser_alias_declaration (parser);\n       /* Otherwise, it's a using-declaration.  */\n       else\n@@ -10550,6 +10632,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \n    decl-specifier-seq:\n      decl-specifier-seq [opt] decl-specifier\n+     decl-specifier attribute-specifier-seq [opt] (C++11)\n \n    decl-specifier:\n      storage-class-specifier\n@@ -10584,6 +10667,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t\t\t      int* declares_class_or_enum)\n {\n   bool constructor_possible_p = !parser->in_declarator_p;\n+  bool found_decl_spec = false;\n   cp_token *start_token = NULL;\n   cp_decl_spec ds;\n \n@@ -10597,7 +10681,6 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n   while (true)\n     {\n       bool constructor_p;\n-      bool found_decl_spec;\n       cp_token *token;\n       ds = ds_last;\n \n@@ -10609,12 +10692,55 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       if (!start_token)\n \tstart_token = token;\n       /* Handle attributes.  */\n-      if (token->keyword == RID_ATTRIBUTE)\n+      if (cp_next_tokens_can_be_attribute_p (parser))\n \t{\n \t  /* Parse the attributes.  */\n-\t  decl_specs->attributes\n-\t    = chainon (decl_specs->attributes,\n-\t\t       cp_parser_attributes_opt (parser));\n+\t  tree attrs = cp_parser_attributes_opt (parser);\n+\n+\t  /* In a sequence of declaration specifiers, c++11 attributes\n+\t     appertain to the type that precede them. In that case\n+\t     [dcl.spec]/1 says:\n+\n+\t         The attribute-specifier-seq affects the type only for\n+\t\t the declaration it appears in, not other declarations\n+\t\t involving the same type.\n+\n+             But for now let's force the user to position the\n+             attribute either at the beginning of the declaration or\n+             after the declarator-id, which would clearly mean that it\n+             applies to the declarator.  */\n+\t  if (cxx11_attribute_p (attrs))\n+\t    {\n+\t      if (!found_decl_spec)\n+\t\t/* The c++11 attribute is at the beginning of the\n+\t\t   declaration.  It appertains to the entity being\n+\t\t   declared.  */;\n+\t      else\n+\t\t{\n+\t\t  if (decl_specs->type && CLASS_TYPE_P (decl_specs->type))\n+\t\t    {\n+\t\t      /*  This is an attribute following a\n+\t\t\t  class-specifier.  */\n+\t\t      if (decl_specs->type_definition_p)\n+\t\t\twarn_misplaced_attr_for_class_type (token->location,\n+\t\t\t\t\t\t\t    decl_specs->type);\n+\t\t      attrs = NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      decl_specs->std_attributes\n+\t\t\t= chainon (decl_specs->std_attributes,\n+\t\t\t\t   attrs);\n+\t\t      if (decl_specs->locations[ds_std_attribute] == 0)\n+\t\t\tdecl_specs->locations[ds_std_attribute] = token->location;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t    decl_specs->attributes\n+\t      = chainon (decl_specs->attributes,\n+\t\t\t attrs);\n \t  if (decl_specs->locations[ds_attribute] == 0)\n \t    decl_specs->locations[ds_attribute] = token->location;\n \t  continue;\n@@ -11341,13 +11467,14 @@ static cp_declarator *\n cp_parser_conversion_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n-  tree class_type;\n+  tree class_type, std_attributes = NULL_TREE;\n   cp_cv_quals cv_quals;\n \n   /* We don't know if there's a ptr-operator next, or not.  */\n   cp_parser_parse_tentatively (parser);\n   /* Try the ptr-operator.  */\n-  code = cp_parser_ptr_operator (parser, &class_type, &cv_quals);\n+  code = cp_parser_ptr_operator (parser, &class_type, &cv_quals,\n+\t\t\t\t &std_attributes);\n   /* If it worked, look for more conversion-declarators.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n@@ -11356,8 +11483,10 @@ cp_parser_conversion_declarator_opt (cp_parser* parser)\n       /* Parse another optional declarator.  */\n       declarator = cp_parser_conversion_declarator_opt (parser);\n \n-      return cp_parser_make_indirect_declarator\n-\t(code, class_type, cv_quals, declarator);\n+      declarator = cp_parser_make_indirect_declarator\n+\t(code, class_type, cv_quals, declarator, std_attributes);\n+\n+      return declarator;\n    }\n \n   return NULL;\n@@ -13188,7 +13317,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n     {\n       tree type;\n \n-      type = check_tag_decl (&decl_specifiers);\n+      type = check_tag_decl (&decl_specifiers,\n+\t\t\t     /*explicit_type_instantiation_p=*/true);\n       /* Turn access control back on for names used during\n \t template instantiation.  */\n       pop_deferring_access_checks ();\n@@ -14619,7 +14749,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n      apply them if appropriate.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     {\n-      tree trailing_attr = cp_parser_attributes_opt (parser);\n+      tree trailing_attr = cp_parser_gnu_attributes_opt (parser);\n       trailing_attr = chainon (trailing_attr, attributes);\n       cplus_decl_attributes (&type,\n \t\t\t     trailing_attr,\n@@ -15521,7 +15651,7 @@ cp_parser_init_declarator (cp_parser* parser,\n            *attributes_start_token = NULL;\n   cp_declarator *declarator;\n   tree prefix_attributes;\n-  tree attributes;\n+  tree attributes = NULL;\n   tree asm_specification;\n   tree initializer;\n   tree decl = NULL_TREE;\n@@ -15587,22 +15717,20 @@ cp_parser_init_declarator (cp_parser* parser,\n   decl_specifiers->type\n     = maybe_update_decl_type (decl_specifiers->type, scope);\n \n-  /* If we're allowing GNU extensions, look for an asm-specification\n-     and attributes.  */\n+  /* If we're allowing GNU extensions, look for an\n+     asm-specification.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     {\n       /* Look for an asm-specification.  */\n       asm_spec_start_token = cp_lexer_peek_token (parser->lexer);\n       asm_specification = cp_parser_asm_specification_opt (parser);\n-      /* And attributes.  */\n-      attributes_start_token = cp_lexer_peek_token (parser->lexer);\n-      attributes = cp_parser_attributes_opt (parser);\n     }\n   else\n-    {\n-      asm_specification = NULL_TREE;\n-      attributes = NULL_TREE;\n-    }\n+    asm_specification = NULL_TREE;\n+\n+  /* Look for attributes.  */\n+  attributes_start_token = cp_lexer_peek_token (parser->lexer);\n+  attributes = cp_parser_attributes_opt (parser);\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -15931,22 +16059,24 @@ cp_parser_declarator (cp_parser* parser,\n   enum tree_code code;\n   cp_cv_quals cv_quals;\n   tree class_type;\n-  tree attributes = NULL_TREE;\n+  tree gnu_attributes = NULL_TREE, std_attributes = NULL_TREE;\n \n   /* Assume this is not a constructor, destructor, or type-conversion\n      operator.  */\n   if (ctor_dtor_or_conv_p)\n     *ctor_dtor_or_conv_p = 0;\n \n   if (cp_parser_allow_gnu_extensions_p (parser))\n-    attributes = cp_parser_attributes_opt (parser);\n+    gnu_attributes = cp_parser_gnu_attributes_opt (parser);\n \n   /* Check for the ptr-operator production.  */\n   cp_parser_parse_tentatively (parser);\n   /* Parse the ptr-operator.  */\n   code = cp_parser_ptr_operator (parser,\n \t\t\t\t &class_type,\n-\t\t\t\t &cv_quals);\n+\t\t\t\t &cv_quals,\n+\t\t\t\t &std_attributes);\n+\n   /* If that worked, then we have a ptr-operator.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n@@ -15972,7 +16102,7 @@ cp_parser_declarator (cp_parser* parser,\n \tdeclarator = NULL;\n \n       declarator = cp_parser_make_indirect_declarator\n-\t(code, class_type, cv_quals, declarator);\n+\t(code, class_type, cv_quals, declarator, std_attributes);\n     }\n   /* Everything else is a direct-declarator.  */\n   else\n@@ -15985,9 +16115,8 @@ cp_parser_declarator (cp_parser* parser,\n \t\t\t\t\t\tmember_p);\n     }\n \n-  if (attributes && declarator && declarator != cp_error_declarator)\n-    declarator->attributes = attributes;\n-\n+  if (gnu_attributes && declarator && declarator != cp_error_declarator)\n+    declarator->attributes = gnu_attributes;\n   return declarator;\n }\n \n@@ -16127,6 +16256,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  cp_virt_specifiers virt_specifiers;\n \t\t  tree exception_specification;\n \t\t  tree late_return;\n+\t\t  tree attrs;\n \n \t\t  is_declarator = true;\n \n@@ -16140,6 +16270,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  exception_specification\n \t\t    = cp_parser_exception_specification_opt (parser);\n \n+\t\t  attrs = cp_parser_std_attribute_spec_seq (parser);\n+\n \t\t  late_return = (cp_parser_late_return_type_opt\n \t\t\t\t (parser, member_p ? cv_quals : -1));\n \n@@ -16153,6 +16285,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t     virt_specifiers,\n \t\t\t\t\t\t     exception_specification,\n \t\t\t\t\t\t     late_return);\n+\t\t  declarator->std_attributes = attrs;\n \t\t  /* Any subsequent parameter lists are to do with\n \t\t     return type, so are not those of the declared\n \t\t     function.  */\n@@ -16202,10 +16335,11 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t    break;\n \t}\n       else if ((!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n-\t       && token->type == CPP_OPEN_SQUARE)\n+\t       && token->type == CPP_OPEN_SQUARE\n+\t       && !cp_next_tokens_can_be_attribute_p (parser))\n \t{\n \t  /* Parse an array-declarator.  */\n-\t  tree bounds;\n+\t  tree bounds, attrs;\n \n \t  if (ctor_dtor_or_conv_p)\n \t    *ctor_dtor_or_conv_p = 0;\n@@ -16258,13 +16392,16 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      break;\n \t    }\n \n+\t  attrs = cp_parser_std_attribute_spec_seq (parser);\n \t  declarator = make_array_declarator (declarator, bounds);\n+\t  declarator->std_attributes = attrs;\n \t}\n       else if (first && dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)\n \t{\n \t  {\n \t    tree qualifying_scope;\n \t    tree unqualified_name;\n+\t    tree attrs;\n \t    special_function_kind sfk;\n \t    bool abstract_ok;\n \t    bool pack_expansion_p = false;\n@@ -16331,6 +16468,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\tbreak;\n \t      }\n \n+\t    attrs = cp_parser_std_attribute_spec_seq (parser);\n+\n \t    if (qualifying_scope && at_namespace_scope_p ()\n \t\t&& TREE_CODE (qualifying_scope) == TYPENAME_TYPE)\n \t      {\n@@ -16445,6 +16584,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t    declarator = make_id_declarator (qualifying_scope,\n \t\t\t\t\t     unqualified_name,\n \t\t\t\t\t     sfk);\n+\t    declarator->std_attributes = attrs;\n \t    declarator->id_loc = token->location;\n \t    declarator->parameter_pack_p = pack_expansion_p;\n \n@@ -16492,9 +16632,11 @@ cp_parser_direct_declarator (cp_parser* parser,\n /* Parse a ptr-operator.\n \n    ptr-operator:\n+     * attribute-specifier-seq [opt] cv-qualifier-seq [opt] (C++11)\n      * cv-qualifier-seq [opt]\n      &\n      :: [opt] nested-name-specifier * cv-qualifier-seq [opt]\n+     nested-name-specifier * attribute-specifier-seq [opt] cv-qualifier-seq [opt] (C++11)\n \n    GNU Extension:\n \n@@ -16514,10 +16656,12 @@ cp_parser_direct_declarator (cp_parser* parser,\n static enum tree_code\n cp_parser_ptr_operator (cp_parser* parser,\n \t\t\ttree* type,\n-\t\t\tcp_cv_quals *cv_quals)\n+\t\t\tcp_cv_quals *cv_quals,\n+\t\t\ttree *attributes)\n {\n   enum tree_code code = ERROR_MARK;\n   cp_token *token;\n+  tree attrs = NULL_TREE;\n \n   /* Assume that it's not a pointer-to-member.  */\n   *type = NULL_TREE;\n@@ -16548,6 +16692,10 @@ cp_parser_ptr_operator (cp_parser* parser,\n       if (code == INDIRECT_REF\n \t  || cp_parser_allow_gnu_extensions_p (parser))\n \t*cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n+\n+      attrs = cp_parser_std_attribute_spec_seq (parser);\n+      if (attributes != NULL)\n+\t*attributes = attrs;\n     }\n   else\n     {\n@@ -16585,6 +16733,10 @@ cp_parser_ptr_operator (cp_parser* parser,\n \t      parser->scope = NULL_TREE;\n \t      parser->qualifying_scope = NULL_TREE;\n \t      parser->object_scope = NULL_TREE;\n+\t      /* Look for optional c++11 attributes.  */\n+\t      attrs = cp_parser_std_attribute_spec_seq (parser);\n+\t      if (attributes != NULL)\n+\t\t*attributes = attrs;\n \t      /* Look for the optional cv-qualifier-seq.  */\n \t      *cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n \t    }\n@@ -16944,7 +17096,7 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n       bool is_cv_qualifier;\n \n       /* Check for attributes first.  */\n-      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n+      if (cp_next_tokens_can_be_attribute_p (parser))\n \t{\n \t  type_specifier_seq->attributes =\n \t    chainon (type_specifier_seq->attributes,\n@@ -18050,7 +18202,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n   closing_brace = cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n   /* Look for trailing attributes to apply to this class.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n-    attributes = cp_parser_attributes_opt (parser);\n+    attributes = cp_parser_gnu_attributes_opt (parser);\n   if (type != error_mark_node)\n     type = finish_struct (type, attributes);\n   if (nested_name_specifier_p)\n@@ -18071,6 +18223,12 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n     cp_token *token = cp_lexer_peek_token (parser->lexer);\n     bool want_semicolon = true;\n \n+    if (cp_next_tokens_can_be_std_attribute_p (parser))\n+      /* Don't try to parse c++11 attributes here.  As per the\n+\t grammar, that should be a task for\n+\t cp_parser_decl_specifier_seq.  */\n+      want_semicolon = false;\n+\n     switch (token->type)\n       {\n       case CPP_NAME:\n@@ -18921,8 +19079,6 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t&decl_specifiers,\n \t\t\t\t&declares_class_or_enum);\n-  prefix_attributes = decl_specifiers.attributes;\n-  decl_specifiers.attributes = NULL_TREE;\n   /* Check for an invalid type-name.  */\n   if (!decl_specifiers.any_type_specifiers_p\n       && cp_parser_parse_and_diagnose_invalid_type_name (parser))\n@@ -18954,7 +19110,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  friend_p = cp_parser_friend_p (&decl_specifiers);\n \t  /* If there were decl-specifiers, check to see if there was\n \t     a class-declaration.  */\n-\t  type = check_tag_decl (&decl_specifiers);\n+\t  type = check_tag_decl (&decl_specifiers,\n+\t\t\t\t /*explicit_type_instantiation_p=*/false);\n \t  /* Nested classes have already been added to the class, but\n \t     a `friend' needs to be explicitly registered.  */\n \t  if (friend_p)\n@@ -19021,6 +19178,12 @@ cp_parser_member_declaration (cp_parser* parser)\n     {\n       bool assume_semicolon = false;\n \n+      /* Clear attributes from the decl_specifiers but keep them\n+\t around as prefix attributes that apply them to the entity\n+\t being declared.  */\n+      prefix_attributes = decl_specifiers.attributes;\n+      decl_specifiers.attributes = NULL_TREE;\n+\n       /* See if these declarations will be friends.  */\n       friend_p = cp_parser_friend_p (&decl_specifiers);\n \n@@ -20127,6 +20290,80 @@ cp_parser_asm_label_list (cp_parser* parser)\n   return nreverse (labels);\n }\n \n+/* Return TRUE iff the next tokens in the stream are possibly the\n+   beginning of a GNU extension attribute. */\n+\n+static bool\n+cp_next_tokens_can_be_gnu_attribute_p (cp_parser *parser)\n+{\n+  return cp_nth_tokens_can_be_gnu_attribute_p (parser, 1);\n+}\n+\n+/* Return TRUE iff the next tokens in the stream are possibly the\n+   beginning of a standard C++-11 attribute.  */\n+\n+static bool\n+cp_next_tokens_can_be_std_attribute_p (cp_parser *parser)\n+{\n+  return cp_nth_tokens_can_be_std_attribute_p (parser, 1);\n+}\n+\n+/* Return TRUE iff the next Nth tokens in the stream are possibly the\n+   beginning of a standard C++-11 attribute.  */\n+\n+static bool\n+cp_nth_tokens_can_be_std_attribute_p (cp_parser *parser, size_t n)\n+{\n+  cp_token *token = cp_lexer_peek_nth_token (parser->lexer, n);\n+\n+  return (cxx_dialect >= cxx0x\n+\t  && token->type == CPP_OPEN_SQUARE\n+\t  && (token = cp_lexer_peek_nth_token (parser->lexer, n + 1))\n+\t  && token->type == CPP_OPEN_SQUARE);\n+}\n+\n+/* Return TRUE iff the next Nth tokens in the stream are possibly the\n+   beginning of a GNU extension attribute.  */\n+\n+static bool\n+cp_nth_tokens_can_be_gnu_attribute_p (cp_parser *parser, size_t n)\n+{\n+  cp_token *token = cp_lexer_peek_nth_token (parser->lexer, n);\n+\n+  return token->type == CPP_KEYWORD && token->keyword == RID_ATTRIBUTE;\n+}\n+\n+/* Return true iff the next tokens can be the beginning of either a\n+   GNU attribute list, or a standard C++11 attribute sequence.  */\n+\n+static bool\n+cp_next_tokens_can_be_attribute_p (cp_parser *parser)\n+{\n+  return (cp_next_tokens_can_be_gnu_attribute_p (parser)\n+\t  || cp_next_tokens_can_be_std_attribute_p (parser));\n+}\n+\n+/* Return true iff the next Nth tokens can be the beginning of either\n+   a GNU attribute list, or a standard C++11 attribute sequence.  */\n+\n+static bool\n+cp_nth_tokens_can_be_attribute_p (cp_parser *parser, size_t n)\n+{\n+  return (cp_nth_tokens_can_be_gnu_attribute_p (parser, n)\n+\t  || cp_nth_tokens_can_be_std_attribute_p (parser, n));\n+}\n+\n+/* Parse either a standard C++-11 attribute-specifier-seq, or a series\n+   of GNU attributes, or return NULL.  */\n+\n+static tree\n+cp_parser_attributes_opt (cp_parser *parser)\n+{\n+  if (cp_next_tokens_can_be_gnu_attribute_p (parser))\n+      return cp_parser_gnu_attributes_opt (parser);\n+  return cp_parser_std_attribute_spec_seq (parser);\n+}\n+\n /* Parse an (optional) series of attributes.\n \n    attributes:\n@@ -20135,10 +20372,10 @@ cp_parser_asm_label_list (cp_parser* parser)\n    attribute:\n      __attribute__ (( attribute-list [opt] ))\n \n-   The return value is as for cp_parser_attribute_list.  */\n+   The return value is as for cp_parser_gnu_attribute_list.  */\n \n static tree\n-cp_parser_attributes_opt (cp_parser* parser)\n+cp_parser_gnu_attributes_opt (cp_parser* parser)\n {\n   tree attributes = NULL_TREE;\n \n@@ -20164,7 +20401,7 @@ cp_parser_attributes_opt (cp_parser* parser)\n       token = cp_lexer_peek_token (parser->lexer);\n       if (token->type != CPP_CLOSE_PAREN)\n \t/* Parse the attribute-list.  */\n-\tattribute_list = cp_parser_attribute_list (parser);\n+\tattribute_list = cp_parser_gnu_attribute_list (parser);\n       else\n \t/* If the next token is a `)', then there is no attribute\n \t   list.  */\n@@ -20185,7 +20422,7 @@ cp_parser_attributes_opt (cp_parser* parser)\n   return attributes;\n }\n \n-/* Parse an attribute-list.\n+/* Parse a GNU attribute-list.\n \n    attribute-list:\n      attribute\n@@ -20203,7 +20440,7 @@ cp_parser_attributes_opt (cp_parser* parser)\n    the arguments, if any.  */\n \n static tree\n-cp_parser_attribute_list (cp_parser* parser)\n+cp_parser_gnu_attribute_list (cp_parser* parser)\n {\n   tree attribute_list = NULL_TREE;\n   bool save_translate_strings_p = parser->translate_strings_p;\n@@ -20282,6 +20519,277 @@ cp_parser_attribute_list (cp_parser* parser)\n   return nreverse (attribute_list);\n }\n \n+/*  Parse a standard C++11 attribute.\n+\n+    The returned representation is a TREE_LIST which TREE_PURPOSE is\n+    the scoped name of the attribute, and the TREE_VALUE is its\n+    arguments list.\n+\n+    Note that the scoped name of the attribute is itself a TREE_LIST\n+    which TREE_PURPOSE is the namespace of the attribute, and\n+    TREE_VALUE its name.  This is unlike a GNU attribute -- as parsed\n+    by cp_parser_gnu_attribute_list -- that doesn't have any namespace\n+    and which TREE_PURPOSE is directly the attribute name.\n+\n+    Clients of the attribute code should use get_attribute_namespace\n+    and get_attribute_name to get the actual namespace and name of\n+    attributes, regardless of their being GNU or C++11 attributes.\n+\n+    attribute:\n+      attribute-token attribute-argument-clause [opt]\n+\n+    attribute-token:\n+      identifier\n+      attribute-scoped-token\n+\n+    attribute-scoped-token:\n+      attribute-namespace :: identifier\n+\n+    attribute-namespace:\n+      identifier\n+\n+    attribute-argument-clause:\n+      ( balanced-token-seq )\n+\n+    balanced-token-seq:\n+      balanced-token [opt]\n+      balanced-token-seq balanced-token\n+\n+    balanced-token:\n+      ( balanced-token-seq )\n+      [ balanced-token-seq ]\n+      { balanced-token-seq }.  */\n+\n+static tree\n+cp_parser_std_attribute (cp_parser *parser)\n+{\n+  tree attribute, attr_ns = NULL_TREE, attr_id = NULL_TREE, arguments;\n+  cp_token *token;\n+\n+  /* First, parse name of the the attribute, a.k.a\n+     attribute-token.  */\n+\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_NAME)\n+    attr_id = token->u.value;\n+  else if (token->type == CPP_KEYWORD)\n+    attr_id = ridpointers[(int) token->keyword];\n+  else if (token->flags & NAMED_OP)\n+    attr_id = get_identifier (cpp_type2name (token->type, token->flags));\n+\n+  if (attr_id == NULL_TREE)\n+    return NULL_TREE;\n+\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_SCOPE)\n+    {\n+      /* We are seeing a scoped attribute token.  */\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      attr_ns = attr_id;\n+\n+      token = cp_lexer_consume_token (parser->lexer);\n+      if (token->type == CPP_NAME)\n+\tattr_id = token->u.value;\n+      else if (token->type == CPP_KEYWORD)\n+\tattr_id = ridpointers[(int) token->keyword];\n+      else\n+\t{\n+\t  error_at (token->location,\n+\t\t    \"expected an identifier for the attribute name\");\n+\t  return error_mark_node;\n+\t}\n+      attribute = build_tree_list (build_tree_list (attr_ns, attr_id),\n+\t\t\t\t   NULL_TREE);\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+  else\n+    attribute = build_tree_list (build_tree_list (NULL_TREE, attr_id),\n+\t\t\t\t NULL_TREE);\n+\n+  /* Now parse the optional argument clause of the attribute.  */\n+\n+  if (token->type != CPP_OPEN_PAREN)\n+    return attribute;\n+\n+  {\n+    VEC(tree, gc) *vec;\n+    int attr_flag = normal_attr;\n+\n+    if (attr_ns == get_identifier (\"gnu\")\n+\t&& attribute_takes_identifier_p (attr_id))\n+      /* A GNU attribute that takes an identifier in parameter.  */\n+      attr_flag = id_attr;\n+\n+    vec = cp_parser_parenthesized_expression_list\n+      (parser, attr_flag, /*cast_p=*/false,\n+       /*allow_expansion_p=*/true,\n+       /*non_constant_p=*/NULL);\n+    if (vec == NULL)\n+      arguments = error_mark_node;\n+    else\n+      {\n+\targuments = build_tree_list_vec (vec);\n+\trelease_tree_vector (vec);\n+      }\n+\n+    if (arguments == error_mark_node)\n+      attribute = error_mark_node;\n+    else\n+      TREE_VALUE (attribute) = arguments;\n+  }\n+\n+  return attribute;\n+}\n+\n+/* Parse a list of standard C++-11 attributes.\n+\n+   attribute-list:\n+     attribute [opt]\n+     attribute-list , attribute[opt]\n+     attribute ...\n+     attribute-list , attribute ...\n+*/\n+\n+static tree\n+cp_parser_std_attribute_list (cp_parser *parser)\n+{\n+  tree attributes = NULL_TREE, attribute = NULL_TREE;\n+  cp_token *token = NULL;\n+\n+  while (true)\n+    {\n+      attribute = cp_parser_std_attribute (parser);\n+      if (attribute == error_mark_node)\n+\tbreak;\n+      if (attribute != NULL_TREE)\n+\t{\n+\t  TREE_CHAIN (attribute) = attributes;\n+\t  attributes = attribute;\n+\t}\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type != CPP_COMMA)\n+\tbreak;\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+  attributes = nreverse (attributes);\n+  return attributes;\n+}\n+\n+/* Parse a standard C++-11 attribute specifier.\n+\n+   attribute-specifier:\n+     [ [ attribute-list ] ]\n+     alignment-specifier\n+\n+   alignment-specifier:\n+     alignas ( type-id ... [opt] )\n+     alignas ( alignment-expression ... [opt] ).  */\n+\n+static tree\n+cp_parser_std_attribute_spec (cp_parser *parser)\n+{\n+  tree attributes = NULL_TREE;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (token->type == CPP_OPEN_SQUARE\n+      && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_OPEN_SQUARE)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      maybe_warn_cpp0x (CPP0X_ATTRIBUTES);\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      attributes = cp_parser_std_attribute_list (parser);\n+\n+      if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE)\n+\t  || !cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))\n+\tcp_parser_skip_to_end_of_statement (parser);\n+    }\n+  else\n+    {\n+      tree alignas_expr;\n+\n+      /* Look for an alignment-specifier.  */\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+\n+      if (token->type != CPP_KEYWORD\n+\t  || token->keyword != RID_ALIGNAS)\n+\treturn NULL_TREE;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      maybe_warn_cpp0x (CPP0X_ATTRIBUTES);\n+\n+      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN) == NULL)\n+\t{\n+\t  cp_parser_error (parser, \"expected %<(%>\");\n+\t  return error_mark_node;\n+\t}\n+\n+      cp_parser_parse_tentatively (parser);\n+      alignas_expr = cp_parser_type_id (parser);\n+\n+      if (!cp_parser_parse_definitely (parser))\n+\t{\n+\t  gcc_assert (alignas_expr == error_mark_node\n+\t\t      || alignas_expr == NULL_TREE);\n+\n+\t  alignas_expr =\n+\t    cp_parser_assignment_expression (parser, /*cast_p=*/false,\n+\t\t\t\t\t     /**cp_id_kind=*/NULL);\n+\t  if (alignas_expr == NULL_TREE\n+\t      || alignas_expr == error_mark_node)\n+\t    return alignas_expr;\n+\t}\n+\n+      if (cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN) == NULL)\n+\t{\n+\t  cp_parser_error (parser, \"expected %<)%>\");\n+\t  return error_mark_node;\n+\t}\n+\n+      alignas_expr = cxx_alignas_expr (alignas_expr);\n+\n+      /* Build the C++-11 representation of an 'aligned'\n+\t attribute.  */\n+      attributes =\n+\tbuild_tree_list (build_tree_list (get_identifier (\"gnu\"),\n+\t\t\t\t\t  get_identifier (\"aligned\")),\n+\t\t\t build_tree_list (NULL_TREE, alignas_expr));\n+    }\n+\n+  return attributes;\n+}\n+\n+/* Parse a standard C++-11 attribute-specifier-seq.\n+\n+   attribute-specifier-seq:\n+     attribute-specifier-seq [opt] attribute-specifier\n+ */\n+\n+static tree\n+cp_parser_std_attribute_spec_seq (cp_parser *parser)\n+{\n+  tree attr_specs = NULL;\n+\n+  while (true)\n+    {\n+      tree attr_spec = cp_parser_std_attribute_spec (parser);\n+      if (attr_spec == NULL_TREE)\n+\tbreak;\n+      if (attr_spec == error_mark_node)\n+\treturn error_mark_node;\n+\n+      TREE_CHAIN (attr_spec) = attr_specs;\n+      attr_specs = attr_spec;\n+    }\n+\n+  attr_specs = nreverse (attr_specs);\n+  return attr_specs;\n+}\n+\n /* Parse an optional `__extension__' keyword.  Returns TRUE if it is\n    present, and FALSE otherwise.  *SAVED_PEDANTIC is set to the\n    current value of the PEDANTIC flag, regardless of whether or not"}, {"sha": "ae4d0a44589a220567987c4c44d4e24b9ceda3ce", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -1701,6 +1701,56 @@ cxx_sizeof_or_alignof_expr (tree e, enum tree_code op, bool complain)\n   else\n     return cxx_alignof_expr (e, complain? tf_warning_or_error : tf_none);\n }\n+\n+/*  Build a representation of an expression 'alignas(E).'  Return the\n+    folded integer value of E if it is an integral constant expression\n+    that resolves to a valid alignment.  If E depends on a template\n+    parameter, return a syntactic representation tree of kind\n+    ALIGNOF_EXPR.  Otherwise, return an error_mark_node if the\n+    expression is ill formed, or NULL_TREE if E is NULL_TREE.  */\n+\n+tree\n+cxx_alignas_expr (tree e)\n+{\n+  if (e == NULL_TREE || e == error_mark_node\n+      || (!TYPE_P (e) && !require_potential_rvalue_constant_expression (e)))\n+    return e;\n+  \n+  if (TYPE_P (e))\n+    /* [dcl.align]/3:\n+       \n+\t   When the alignment-specifier is of the form\n+\t   alignas(type-id ), it shall have the same effect as\n+\t   alignas( alignof(type-id )).  */\n+\n+    return cxx_sizeof_or_alignof_type (e, ALIGNOF_EXPR, false);\n+  \n+\n+  /* If we reach this point, it means the alignas expression if of\n+     the form \"alignas(assignment-expression)\", so we should follow\n+     what is stated by [dcl.align]/2.  */\n+\n+  e = mark_rvalue_use (e);\n+\n+  /* [dcl.align]/2 says:\n+\n+         the assignment-expression shall be an integral constant\n+\t expression.  */\n+  \n+  e = fold_non_dependent_expr (e);\n+  if (value_dependent_expression_p (e))\n+    /* Leave value-dependent expression alone for now. */;\n+  else\n+    e = cxx_constant_value (e);\n+\n+  if (e == NULL_TREE\n+      || e == error_mark_node\n+      || TREE_CODE (e) != INTEGER_CST)\n+    return error_mark_node;\n+\n+  return e;\n+}\n+\n \f\n /* EXPR is being used in a context that is not a function call.\n    Enforce:"}, {"sha": "c514e67d0316665b33ea4d525011c25070ff0997", "filename": "gcc/plugin.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fplugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Fplugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.h?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcc-plugin.h\"\n \n struct attribute_spec;\n+struct scoped_attributes;\n \n extern void add_new_plugin (const char *);\n extern void parse_plugin_arg_opt (const char *);\n@@ -64,5 +65,7 @@ invoke_plugin_callbacks (int event ATTRIBUTE_UNUSED,\n /* In attribs.c.  */\n \n extern void register_attribute (const struct attribute_spec *attr);\n+extern struct scoped_attributes* register_scoped_attributes (const struct attribute_spec *,\n+\t\t\t\t\t\t\t     const char *);\n \n #endif /* PLUGIN_H */"}, {"sha": "d20a9e89304ea5c6f6bae745ad2846e323b6c0a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -1,3 +1,64 @@\n+2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/53528 C++11 attribute support\n+\t* g++.dg/cpp0x/gen-attrs-1.C: New test.\n+\t* g++.dg/cpp0x/gen-attrs-2.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-2-1.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-3.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-4.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-5.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-6.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-7.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-8.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-9.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-10.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-11.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-12.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-13.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-14.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-15.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-16.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-17.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-18.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-19.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-20.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-21.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-22.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-23.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-24.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-25.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-26.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-27.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-28.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-29.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-30.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-31.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-32.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-33.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-34.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-35.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-36.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-36-1.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-37.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-38.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-39.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-39-1.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-40.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-41.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-42.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-43.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-44.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-45.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-46.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-47.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-47-1.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-48.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-49.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-50.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-51.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-52.C: Likewise.\n+\t* g++.dg/cpp0x/gen-attrs-53.C: Likewise.\n+\n 2012-10-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/tree-ssa/slsr-30.c: Use correct cleanup directive."}, {"sha": "a55698c93833bda745cfbf17a6fd6801459474a0", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-1.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-1.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do compile { target c++11 } }\n+\n+int **** [[gnu::format(printf, 1, 2)]] foo(const char *, ...); // { dg-warning \"ignored\" }"}, {"sha": "cac568e0b7a3c396820a9da88af8efa5c20204b0", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-10.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-10.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/12795\n+// { dg-do compile { target c++11 } }\n+// { dg-require-alias \"\" }\n+\n+void foo()\n+{\n+  extern void bar [[gnu::__alias__ (\"BAR\")]] (); // { dg-warning \"ignored\" }\n+  bar ();\n+}"}, {"sha": "504b4565679c489469a7663e9d108e6987911cfd", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-11.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-11.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/13791\n+\n+template <typename T> struct O {\n+  struct [[gnu::packed]] I {\n+    int i;\n+    char c;\n+  };\n+\n+  I* foo();\n+};\n+\n+template <typename T>\n+typename O<T>::I*\n+O<T>::foo() { return 0; }\n+\n+template class O<int>;"}, {"sha": "504b4565679c489469a7663e9d108e6987911cfd", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-12.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-12.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/13791\n+\n+template <typename T> struct O {\n+  struct [[gnu::packed]] I {\n+    int i;\n+    char c;\n+  };\n+\n+  I* foo();\n+};\n+\n+template <typename T>\n+typename O<T>::I*\n+O<T>::foo() { return 0; }\n+\n+template class O<int>;"}, {"sha": "a1b4a84b7e5494f252ea4fa4888635117ec09f9b", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-13.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-13.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/13854\n+\n+extern char *rindex [[gnu::__pure__]] (__const char *__s, int __c) throw ();\n+extern char *rindex [[gnu::__pure__]] (__const char *__s, int __c) throw ();"}, {"sha": "d646d274df0422a791fc419f3bc5a442acdae886", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-14.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-14.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/13170\n+// The bogus attribute is ignored, but was in TYPE_ATTRIBUTES during\n+// parsing of the class, causing some variants to have it and some not.\n+\n+struct [[gnu::bogus]] A\t// { dg-warning \"ignored\" \"\" }\n+{\n+    virtual ~A();\n+    void foo(const A&);\n+    void bar(const A&);\n+};\n+\n+void A::foo(const A&)   {}\n+void A::bar(const A& a) { foo(a); }"}, {"sha": "bf05dbeb31b96ff9ac72f8cb36abb56a4ed55ec3", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-15.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-15.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/15317\n+\n+struct A\n+{\n+  A(char);\n+};\n+A::A([[gnu::unused]] char i2)\n+{}"}, {"sha": "4adefdb32d5f1ca2baa3ed42a32bd8785283d564", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-16.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-16.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target c++11 } }\n+// Origin: <rguenth at tat dot physik dot uni-tuebingen dot de>\n+// PR c++/10479: use of non dependent expressions in attributes in templates\n+\n+template <int i>\n+struct foo2 {\n+  float bar [[gnu::aligned(alignof(double))]];\n+};"}, {"sha": "636f9a9ac8bd2535a7d5973ba34a0bb64d0478b9", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-17.2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-17.2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-17.2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-17.2.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile { target c++11 } }\n+// Origin: Benjamin Kosnik <bkoz at gcc dot gnu dot org>\n+// PR c++/17743: Attributes applied to typedefs.\n+\n+struct A {\n+  typedef char layout_type[sizeof(double)]\n+  [[gnu::aligned(alignof(double)]]); // { dg-error \"expected\" }\n+  layout_type data;\n+};\n+\n+struct B {\n+  typedef char layout_type[sizeof(double)];\n+  layout_type data  [[gnu::aligned(alignof(double))]];\n+};\n+\n+template<bool> struct StaticAssert;\n+template<> struct StaticAssert<true> {};\n+\n+StaticAssert<alignof(A) == alignof(B)> a1;// { dg-error \"incomplete type and cannot be defined\" }"}, {"sha": "566461b0e7f3028c9136d9ca1dd673b0ba9dc180", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-17.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-17.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile { target c++11 } }\n+// Origin: Benjamin Kosnik <bkoz at gcc dot gnu dot org>\n+// PR c++/17743: Attributes applied to typedefs.\n+\n+struct A {\n+  typedef char layout_type[sizeof(double)]\n+  [[gnu::aligned(alignof(double))]];\n+  layout_type data;\n+};\n+\n+struct B {\n+  typedef char layout_type[sizeof(double)];\n+  layout_type data  [[gnu::aligned(alignof(double))]];\n+};\n+\n+template<bool> struct StaticAssert;\n+template<> struct StaticAssert<true> {};\n+\n+StaticAssert<alignof(A) == alignof(B)> a1;"}, {"sha": "3df13e6440b8c304e588af8b34cac2d1f83823f9", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-18.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-18.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/17542\n+// Test that we warn when an attribute preceding the class-key is ignored.\n+// { dg-do compile { target c++11 } }\n+\n+[[gnu::packed]] struct A // { dg-warning \"attribute\" }\n+{\n+  char c;\n+  int x;\n+  void f();\n+};"}, {"sha": "5ac93d845909d6d993a3e6059d4a8131ca002ef1", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-19.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-19.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/19739\n+// { dg-do compile { target c++11 } }\n+\n+void Dummy() [[ , ]];\n+void Dummy() {}\n+\n+int main (int argc, char **argv)\n+{\n+    Dummy();\n+    return 0;\n+}"}, {"sha": "2f47b3255799832303f93ae0c4b2684f168d3c3d", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-2-1.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-2-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-2-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-2-1.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,3 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct [[gnu::unused]] A {};"}, {"sha": "8c777c1df8b06fa645229a5e0ffa54427304b576", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-2.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct [[gnu::packed]] A\n+{\n+  void f () const;\n+};\n+\n+void\n+A::f () const\n+{\n+}"}, {"sha": "f989ab20789da180a95083cbd39a30c8ce5fca28", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-20.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-20.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-g\" }\n+// Origin: <jan at etpmod dot phys dot tue dot nl>\n+// PR c++/19508: avoid attributes for template parameters\n+\n+template <typename T>\n+struct BVector\n+{\n+  typedef T T2;\n+    typedef T value_type [[gnu::aligned(8)]];    // { dg-bogus \"attribute\" \"attribute\" }\n+    typedef T2 value_type2 [[gnu::aligned(8)]];  // { dg-bogus \"attribute\" \"attribute\" }\n+  value_type v;\n+};\n+BVector<int> m;\n+\n+template <template <class> class T>\n+struct BV2\n+{\n+    typedef T<float> value_type [[gnu::aligned(8)]]; // { dg-bogus \"attribute\" \"attribute\" }\n+  value_type v;\n+};\n+BV2<BVector> m2;"}, {"sha": "2d5ad04b02c65c739c8e0d127b3b2d91f6dadc57", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-21.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-21.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/20763\n+// { dg-do compile { target c++11 } }\n+\n+typedef void *voidp;\n+\n+struct S\n+{\n+  char a;\n+  voidp b [[gnu::aligned (16)]];\n+};\n+\n+struct T\n+{\n+  char a;\n+  void * b [[gnu::aligned (16)]];\n+};\n+\n+static_assert (sizeof (S) == sizeof (T),\n+\t       \"struct S and T should have the same size\");\n+\n+static_assert (sizeof (S) == 32, \"sizeof (S) == 8 + 16 + 8\");"}, {"sha": "4c07df995c75aabe8bb22e5a46f8755539ed08a0", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-22.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-22.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/27648\n+// { dg-do compile { target c++11 } }\n+\n+void f()\n+{\n+  static_cast<float *[[gnu::unused]]>(0); // { dg-warning \"ignored\" }\n+}"}, {"sha": "57ea6b8097fe47e6d4ad552f2a6f014cd54d06e3", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-23.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-23.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/28112\n+// { dg-do compile { target c++11 } }\n+\n+int i       [[gnu::init_priority(;)]];  // { dg-error \"before\" }\n+int j       [[gnu::vector_size(;)]];    // { dg-error \"before\" }\n+int k       [[gnu::visibility(;)]];     // { dg-error \"before\" }\n+struct A {} [[gnu::aligned(;)]];        // { dg-error \"before\" }\n+struct B {} [[gnu::mode(;)]];           // { dg-error \"before\" }\n+void foo()  [[gnu::alias(;)]];          // { dg-error \"before\" }\n+void bar()  [[gnu::nonnull(;)]];        // { dg-error \"before\" }\n+void baz()  [[gnu::section(;)]];        // { dg-error \"before\" }"}, {"sha": "e1f26c3d3377a6eb68b2ccd8e43aaa9829371b10", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-24.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-24.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/28387\n+// { dg-do compile { target c++11 } }\n+\n+enum [[gnu::unused]] E;  // { dg-error \"without previous declaration\" }"}, {"sha": "09486d66b76800770f774dd4f37de46d457e0b6c", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-25.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-25.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/28559\n+// { dg-do compile { target c++11 } }\n+\n+template<typename T> struct A\n+{\n+  struct B;\n+};\n+\n+struct C\n+{\n+  template<typename T> friend struct [[gnu::packed]] A<T>::B; // { dg-warning \"uninstantiated\" }\n+};"}, {"sha": "00069b8f518b80ec9d38e5aae131f65533577d87", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-26.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-26.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/28659\n+// The attribute was causing us to get confused in merge_types when\n+// combining the template type with an uninstantiated version.\n+// { dg-do compile { target c++11 } }\n+\n+template<class T>\n+struct [[gnu::aligned(1)]] A\n+{\n+  A& operator=(const A &t);\n+};\n+\n+template<class T>\n+A<T>& A<T>::operator=(const A<T> &t)\n+{\n+}"}, {"sha": "e38d8d3f6d983aa2aef8f9d7d0dad0ba81de34bb", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-27.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-27.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,6 @@\n+//PR c++/29980\n+// { dg-do compile { target c++11 } }\n+\n+struct A { typedef int X; };            // { dg-message \"previous declaration\" }\n+\n+struct [[gnu::unused]] A::X;    // { dg-error \"typedef-name\" }"}, {"sha": "94f1756ae2bf220cf72905d1591ed63b619c22b7", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-28.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-28.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/28558\n+// { dg-options \"\" }\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  A(int) { }\n+};\n+\n+int main()\n+{\n+    A a = (A [[gnu::unused]])0; // { dg-warning \"attribute\" }\n+}"}, {"sha": "f3da4522994de0af3fb24d53b100dab8eb897351", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-29.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-29.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/33506\n+// { dg-do compile { target c++11 } }\n+\n+extern int f1 [[gnu::warn_unused_result]] (char *) ;\n+extern int f2 [[gnu::warn_unused_result]] (char *) throw () ;\n+extern int f2 (char *) throw ();\n+\n+extern int f3 [[gnu::nonnull (1)]] (char *) ;\n+extern int f4 [[gnu::nonnull (1)]] (char *) throw ();\n+extern int f4 (char *) throw ();"}, {"sha": "edd10672636581356dc64c31877fcc0d3280a3a1", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-3.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-3.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,22 @@\n+// Test that attributes work in a variety of situations.\n+// { dg-options \"-O -ftrack-macro-expansion=0\" }\n+// { dg-do run { target c++11 } }\n+\n+#define attrib [[gnu::mode (QI)]]\n+#define gnu_attrib __attribute((mode (QI)))\n+\n+attrib signed int a;\n+static unsigned int b attrib;\n+\n+int foo(attrib int o)\n+{\n+  return (sizeof (a) != 1\n+\t  || sizeof (b) != 1\n+\t  || sizeof (o) != 1\n+\t  || sizeof ((gnu_attrib signed int) b) != 1);\n+}\n+\n+int main ()\n+{\n+  return foo (42);\n+}"}, {"sha": "537dec50e97c7eb16bf63e82ae5a01170e72f754", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-30.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-30.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/35074\n+\n+template<typename T> struct A\n+{\n+  void foo() const;\n+} [[gnu::aligned(4)]]; // { dg-warning \"ignored\" }\n+\n+template<typename T> void A<T>::foo() const {}"}, {"sha": "ab58e6e2b27c09cb4282749d5cf21d50cd4f4125", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-31.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-31.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/35097\n+// { dg-do compile { target c++11 } }\n+\n+template<int> struct A;\n+\n+template<> struct A<0>\n+{\n+  typedef int X [[gnu::aligned(4)]];\n+};\n+\n+template<typename T> void foo(const A<0>::X&, T);\n+\n+void bar()\n+{\n+  foo(A<0>::X(), 0);\n+}"}, {"sha": "f34466117483eeb1ef83111ddc8b152a52d4ceab", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-32.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-32.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/35315\n+// { dg-do compile { target c++11 } }\n+\n+typedef union { int i; } U [[gnu::transparent_union]]; // { dg-warning \"ignored\" }\n+\n+static void foo(U) {}\n+static void foo(int) {}\n+\n+void bar()\n+{\n+  foo(0);\n+}\n+\n+typedef union U1 { int i; } U2 [[gnu::transparent_union]]; // { dg-warning \"ignored\" }\n+\n+static void foo2(U1) {}\t\t// { dg-error \"previously defined\" }\n+static void foo2(U2) {}\t\t// { dg-error \"redefinition\" }\n+\n+void bar2(U1 u1, U2 u2)\n+{\n+  foo2(u1);\n+  foo2(u2);\n+}\n+\n+// PR c++/36410\n+struct A\n+{\n+  typedef union [[gnu::transparent_union]]\n+  {\n+    int i;\n+  } B;\n+};\n+\n+void foo(A::B b)\n+{\n+  b.i;\n+}"}, {"sha": "efb2a1ad6d068e3946d519b4e59565cb18f1eab7", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-33.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-33.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/35546\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-g\" }\n+\n+template <int N>\n+struct T\n+{\n+  void foo [[gnu::format (printf,2,3)]] (char const * ...);\n+};\n+\n+template struct T<3>;\n+\n+template <typename T>\n+struct U\n+{\n+  typedef T V [[gnu::mode (SI)]];\n+};\n+\n+U<int>::V v;"}, {"sha": "ae8e99090e95274a8bc742d49afd01b95ec8b945", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-34.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-34.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,19 @@\n+// PR c/37171\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+unsigned int f1 [[gnu::const]] ();\n+unsigned int f2 [[gnu::__const]] () ;\n+unsigned int f3 [[gnu::__const__]] () ;\n+\n+unsigned int f4 ()\n+{\n+  return f1 () + f1 () + f1 () + f1 ()\n+\t + f2 () + f2 () + f2 () + f2 ()\n+\t + f3 () + f3 () + f3 () + f3 ();\n+}\n+\n+// { dg-final { scan-tree-dump-times \"= f1 \\\\(\\\\)\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"= f2 \\\\(\\\\)\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"= f3 \\\\(\\\\)\" 1 \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "34f20cf3076009716f3717fd2136a0676da718b9", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-35.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-35.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target i?86-*-* x86_64-*-* } }\n+// { dg-options \"-O3 -msse2 -std=c++11\" }\n+// { dg-require-effective-target sse2 }\n+\n+// You can make NON-template typedefs with a large alignment.\n+typedef double AlignedDoubleType [[gnu::aligned(16)]];\n+\n+template <typename RealType>\n+RealType f(const RealType* p)\n+{\n+  // But if you use a template parameter it complains.\n+  typedef RealType AlignedRealType [[gnu::aligned(16)]];\n+\n+  return p[0];\n+}\n+\n+double f2(const double* p)\n+{\n+  return f<double>(p);\n+}"}, {"sha": "2aae9cae00b4caed090ba4d8eaa203adf90460a2", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-36-1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-36-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-36-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-36-1.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct S;\n+\n+typedef int (*F [[gnu::warn_unused_result]]) (int);\n+\n+typedef int (*F2 [[gnu::warn_unused_result]]) (int);\n+\n+typedef int (S::*F3 [[gnu::warn_unused_result]]) (int); // { dg-warning \"only applies to function types\" }\n+\n+typedef int [[gnu::warn_unused_result]] (*F5) (int); // { dg-warning \"ignored\" }"}, {"sha": "2665188a63001042d592cecfb6a39ebad5d6dd7d", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-36.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-36.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/43031\n+// { dg-options \"-std=c++11 -pedantic\" }\n+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ia32 } } }\n+\n+class T;\n+class L { };\n+class P : public L\n+{\n+  typedef void (T::* [[gnu::__stdcall__]] F2) (L*); // { dg-warning \"only applies to function types\" }\n+  typedef void (T::*F) (L*) [[gnu::__stdcall__]];\n+  void f(bool aAdd);\n+};\n+\n+class T\n+{\n+public:\n+  virtual void  A(L *listener) [[gnu::__stdcall__]] = 0;\n+  virtual void R(L *listener)  [[gnu::__stdcall__]] = 0;\n+};\n+void P::f(bool aAdd)\n+{\n+  F addRemoveEventListener = (aAdd ? &T::A : &T::R);\n+}"}, {"sha": "15d69e8175e4be7aafba5a910b5429e1561366d3", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-37.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-37.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/43093\n+// { dg-options \"-std=c++11 -pedantic\" }\n+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ia32 } } }\n+\n+struct S {\n+  int x;\n+  S(const S &s) {}\n+};\n+\n+S getS() [[gnu::__stdcall__]];\n+\n+void test()\n+{\n+  S s = getS();\n+}"}, {"sha": "3db981aeb224d68ea576889d35fca7801d0a68fb", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-38.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-38.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-38.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-38.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/36625\n+\n+template <int N>\n+struct A {\n+  struct S { short f[3]; } [[gnu::aligned (N)]]; // { dg-warning \"ignored\" }\n+};\n+\n+int main ()\n+{\n+  A<4>::S s;\n+}"}, {"sha": "453fc01a2e994fff433d6636a70421e174c14f42", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-39-1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-39-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-39-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-39-1.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++11 } }\n+\n+int fragile_block(void) {\n+  typedef \n+  [[gnu::aligned (16)]] // { dg-warning \"ignored\" }\n+  struct  {\n+    int i;\n+  } XmmUint16;\n+  return 0;\n+}"}, {"sha": "83fa8b5e66d8407b4ef0a03ef1d1fa842ec7ed8c", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-39.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-39.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,10 @@\n+// PR debug/43370\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-g\" }\n+\n+int fragile_block(void) {\n+  typedef struct [[gnu::aligned (16)]] {\n+    int i;\n+  } XmmUint16;\n+  return 0;\n+}"}, {"sha": "bad33d6e822e1e5a988f932f7e1ca9906453ae60", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-4.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-4.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=c++11 -Wunused -pedantic-errors\" }\n+// { dg-do compile }\n+// Test for syntax support of various attribute permutations.\n+\n+int\n+[[gnu::noreturn]] // { dg-warning \"ignored\" }\n+one\n+[[gnu::unused]]\n+(void);\n+\n+int one_third [[gnu::noreturn]] [[gnu::unused]] (void);\n+\n+int [[gnu::unused]] one_half(); // { dg-warning \"ignored\" }\n+\n+static\n+[[gnu::noreturn]] // { dg-warning \"ignored\" }\n+void two [[gnu::unused]] (void) {}\n+\n+\n+\n+[[gnu::unused]]\n+int\n+five(void)\n+[[gnu::noreturn]] // { dg-warning \"ignored\" }\n+{}\n+\n+[[gnu::noreturn]]\n+void\n+six (void)\n+;"}, {"sha": "f3ccb727dfaa643b284be0f01332db26e5cd07f0", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-40.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-40.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/46803\n+// { dg-do compile { target c++11 } }\n+\n+int strftime(char *, int, const char *, const struct tm *)\n+        [[gnu::__bounded__(__string__,1,2)]]; // { dg-warning \"ignored\" }"}, {"sha": "6e47a1e3d7541246a16cb89e36a9ba156995f936", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-41.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-41.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/45267\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O\" }\n+\n+template<typename T> struct Vector {\n+  Vector(long long x);\n+  inline Vector<T> operator<< [[gnu::always_inline]] (int x) const;\n+};\n+long long bar (long long);\n+template<> inline Vector<int> Vector<int>::operator<<(int x) const {\n+  return bar(x);\n+}\n+bool b;\n+int main() {\n+  Vector<int> a(1);\n+  if ((a << 2), b) {\n+    a << 2;\n+    throw 1;\n+  }\n+}"}, {"sha": "7df63cf675e8b4942d854d9e30e8f45fec11a823", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-42.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-42.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-42.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-42.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++11 -pedantic\" }\n+// { dg-do compile { target { i?86-*-* && ilp32 } } }\n+\n+struct A {\n+  [[gnu::fastcall]]\n+  void f();\n+};\n+\n+int main()\n+{\n+    typedef void (A::*FP)();\n+    FP fp[] = {&A::f};\t\t// { dg-error \"cannot convert\" }\n+}"}, {"sha": "c850622723eba15167e2f949b26f36a6ff93d484", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-43.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-43.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do compile { target c++11 } }\n+template <class T> struct A { };\n+\n+template [[gnu::packed]] struct A<int>;  // { dg-warning \"ignored in explicit instantiation\" }"}, {"sha": "81d70e52b0ebc4324a45a742647b6b62e99653ab", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-44.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-44.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,3 @@\n+// PR c++/52671\n+// { dg-do compile { target c++11 } }\n+[[gnu::deprecated]] enum E { E0 };\t// { dg-warning \"ignored in declaration\" }"}, {"sha": "573a1ab6cb075ec46a6eaef5b6440b4dcd995781", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-45.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-45.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/52906\n+// { dg-do compile { target c++11 } }\n+\n+[[gnu::deprecated]]; // { dg-error \"does not declare anything\" }"}, {"sha": "53fcb77ff7b685421b7fbb366d9c16612af29d3c", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-46.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-46.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-46.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-46.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/40821\n+// { dg-do compile { target c++11 } }\n+\n+struct [[gnu::aligned(8)] S1 { int i; }; // { dg-error \"\" }\n+struct  [aligned(8)  S2 { int i; }; // { dg-error \"\" }"}, {"sha": "4a5d73a192747b3d1ac8ca1be3b6e1259684b94f", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-47-1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-47-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-47-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-47-1.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target c++11 } }\n+int\n+foo ()\n+{\n+  int i [[and, bitor, xor_eq, compl, bitand]]; // { dg-warning \"ignored\" }\n+  i = 0;\n+  return i;\n+}"}, {"sha": "af74abd1862230fd530a8bc2cbcf49de3e060e9b", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-47.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-47.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-47.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-47.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++11 } }\n+// Example taken from dcl.attr.grammar:\n+\n+int p[10];\n+void f()\n+{\n+    int x = 42, y[5];\n+    /* Here, the '[[' should have introduced an attribute, on a\n+       lambda invocation an array subscripting expression.  */\n+    int(p[[x] { return x; }()]); // { dg-error \"expected|consecutive\" }\n+    /* Likewise, the '[[gnu::' is invalid here.  */\n+    y[[] { return 2; }()] = 2; // { dg-error \"expected|consecutive\" }\n+}"}, {"sha": "360c093bf5a3dd4b153b616867333b9f23358988", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-48.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-48.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-48.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-48.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+\n+typedef char layout_type;\n+\n+struct A {\n+  layout_type member alignas (double);\n+};\n+\n+static_assert (alignof (A) == alignof (double),\n+\t       \"alignment of struct A must be alignof (double)\");\n+\n+struct alignas (alignof (long double)) B {\n+  layout_type member;\n+};\n+\n+static_assert (alignof (B) == alignof (long double),\n+\t       \"alignment of struct A must be alignof (double double)\");"}, {"sha": "8b68f927368717f4d92233e46c4b59b6be851306", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-49.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-49.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-49.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-49.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+\n+typedef char layout_type;\n+\n+template<class> struct A {\n+  layout_type member alignas (double);\n+};\n+\n+static_assert (alignof (A<int>) == alignof (double),\n+\t       \"alignment of struct A must be alignof (double)\");\n+\n+template<class> struct alignas (alignof (long double)) B {\n+  layout_type member;\n+};\n+\n+static_assert (alignof (B<int>) == alignof (long double),\n+\t       \"alignment of struct A must be alignof (double double)\");"}, {"sha": "83de121dfbf150ffa70a77812891e7f5c0aa0608", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-5.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-5.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile { target c++11 } }\n+//\n+// There were two related problems here, depending on the vintage.  At\n+// one time:\n+//\n+//    typedef struct A { ... } A [[gnu::aligned (16)]];\n+//\n+// would cause original_types to go into an infinite loop.  At other\n+// times, the attributes applied to an explicit typedef would be lost\n+// (check_b3 would have a negative size).\n+\n+// First check that the declaration is accepted and has an effect.\n+typedef struct A { int i; } A [[gnu::aligned (16)]];\n+int check_A[alignof (A) >= 16 ? 1 : -1];\n+\n+// Check that the alignment is only applied to the typedef.\n+struct B { int i; };\n+struct B b1;\n+typedef struct B B [[gnu::aligned (16)]];\n+struct B b2;\n+B b3;\n+int check_b1[__alignof__ (b1) == __alignof__ (b2) ? 1 : -1];\n+int check_b3[__alignof__ (b3) >= 16 ? 1 : -1];"}, {"sha": "2479dfdf19c13b8b1c58d246e8ffb5cab5f1118d", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-50.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-50.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-50.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-50.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile { target c++11 } }\n+\n+typedef char layout_type;\n+\n+template<class> struct A {\n+  layout_type member alignas (double) alignas (int);\n+};\n+\n+// Here, the spec says that A<int> should have the stricter alignment,\n+// so that would be the alignment of 'double', not 'int'.\n+static_assert (alignof (A<int>) == alignof (double),\n+\t       \"alignment of struct A must be alignof (double)\");\n+\n+template<class> struct alignas (1) alignas (alignof (long double)) B {\n+  layout_type member;\n+};\n+\n+// Similarly, the B<int> should have the stricter alignment, so that would\n+// so that would be the alignment of 'long double', not '1'.\n+static_assert (alignof (B<int>) == alignof (long double),\n+\t       \"alignment of struct A must be alignof (double double)\");\n+"}, {"sha": "f2b66029e5a06ed87ccbbc49b348b545d32c4e6b", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-51.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-51.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-51.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-51.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile { target c++11 } }\n+\n+typedef char layout_type;\n+struct A\n+{\n+    layout_type member [[gnu::aligned (16)]];\n+};\n+\n+static_assert (sizeof (A) == 16, \"Alignment should be 16\");"}, {"sha": "0f87fd490e5993ce7c839055952c80c4e3747d7e", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-52.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-52.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-52.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-52.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A {int i;}  a [[gnu::aligned(16)]];\n+struct B {int i;} __attribute__((aligned(16))) b;\n+\n+int\n+main ()\n+{\n+ A aa;\n+ B bb;\n+\n+ static_assert (sizeof (a) == 4, \"sizeof (a) should be 4\");\n+ static_assert (sizeof (b) == 16, \"sizeof (b) should be 16\");\n+ static_assert (sizeof (aa) == 4, \"sizeof (aa) should be 4\");\n+ static_assert (sizeof (bb) == 16, \"sizeof (bb) should be 16\");\n+\n+ static_assert (__alignof__  (a) == 16, \"alignof (a) should be 16\");\n+ static_assert (__alignof__  (b) == 16, \"alignof (b) should be 16\");\n+ static_assert (__alignof__  (aa) == 4, \"alignof (aa) should be 4\");\n+ static_assert (__alignof__  (bb) == 16, \"alignof (bb) should be 16\");\n+}"}, {"sha": "723c8ef8ec06868df7d70d65a4196c564d68222b", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-53.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-53.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-53.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-53.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile { target c++11 } }\n+\n+int\n+toto ()\n+{\n+  [[gnu::unused]] good:\n+    return 0;\n+}\n+\n+int\n+foo ()\n+{\n+  [[gnu::unused]] good:\n+    int i = 0;\n+\n+  // A C++11 attribute at the beginning of the return statement is\n+  // syntactically correct, appertains to the return statement (not to\n+  // the label) but is currently ignored by this implementation.\n+ good_ignored : [[gnu::unused]] // { dg-warning \"attributes at the beginning of statement are ignored\" }\n+    return i;\n+}\n+\n+int\n+bar ()\n+{\n+  // A GNU attribute after the label appertains to the label.\n+ good: __attribute__((unused));\n+  return 0;\n+}\n+\n+int\n+baz ()\n+{\n+  // The c++ attribute after the label appertains to the (empty)\n+  // statement.\n+ bad: [[gnu::unused]]; // { dg-warning \"attributes at the beginning of statement are ignored\" }\n+  return 0;\n+}\n+"}, {"sha": "54071d5ed1491602047423e181d017591b0b8c2c", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-6.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-6.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,20 @@\n+// Copyright (C) 2002  Free Software Foundation.\n+//\n+// Test that the nothrow attribute is working correctly.\n+//\n+// Written by Richard Henderson, 26 May 2002.\n+\n+// { dg-do link { target c++11} }\n+extern void foo [[gnu::nothrow]] ();\n+extern void link_error();\n+\n+int main()\n+{\n+  try {\n+    foo();\n+  } catch (...) {\n+    link_error();\n+  }\n+}\n+\n+void foo() { }"}, {"sha": "33412506852aae8807d8a0792a470984c20cfa9e", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-7.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-7.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,4 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wunused-parameter\" }\n+\n+void f (int i [[gnu::__unused__]]) {}"}, {"sha": "a842b5352cc5014421bafe11623304cb68129285", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-8.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-8.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options \"-std=c++11 -pedantic\" }\n+// { dg-do compile { target { { i?86-*-* x86_64-*-* } && ia32 } } }\n+\n+extern int * ([[gnu::stdcall]] *fooPtr)( void); // { dg-error \"expected\" }\n+int * [[gnu::stdcall]] myFn01( void) { return 0; }// { dg-warning \"attribute only applies to function types\" }\n+"}, {"sha": "3dc51eef9e8938808692eca291666f0349234365", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-9.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-9.C?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++11 } }\n+\n+class C;\n+struct S;\n+union U;\n+enum e {};\n+enum [[gnu::unused]] e;\t// { dg-warning \"already defined\" }\n+\n+struct [[gnu::unused]] B *p;\t//  { dg-warning \"attributes\" }\n+\n+template <class T> struct A { };\n+struct [[gnu::unused]] A<int>;\t//  { dg-warning \"attributes\" }"}, {"sha": "8df1b86d2be18638d9a142cc14e6f9faf36bdf53", "filename": "gcc/tree.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -4350,7 +4350,7 @@ comp_type_attributes (const_tree type1, const_tree type2)\n       const struct attribute_spec *as;\n       const_tree attr;\n \n-      as = lookup_attribute_spec (TREE_PURPOSE (a));\n+      as = lookup_attribute_spec (get_attribute_name (a));\n       if (!as || as->affects_type_identity == false)\n         continue;\n \n@@ -4364,7 +4364,7 @@ comp_type_attributes (const_tree type1, const_tree type2)\n \t{\n \t  const struct attribute_spec *as;\n \n-\t  as = lookup_attribute_spec (TREE_PURPOSE (a));\n+\t  as = lookup_attribute_spec (get_attribute_name (a));\n \t  if (!as || as->affects_type_identity == false)\n \t    continue;\n \n@@ -5287,19 +5287,20 @@ private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n {\n   while (list)\n     {\n-      size_t ident_len = IDENTIFIER_LENGTH (TREE_PURPOSE (list));\n+      size_t ident_len = IDENTIFIER_LENGTH (get_attribute_name (list));\n \n       if (ident_len == attr_len)\n \t{\n-\t  if (strcmp (attr_name, IDENTIFIER_POINTER (TREE_PURPOSE (list))) == 0)\n+\t  if (!strcmp (attr_name,\n+\t\t       IDENTIFIER_POINTER (get_attribute_name (list))))\n \t    break;\n \t}\n       /* TODO: If we made sure that attributes were stored in the\n \t canonical form without '__...__' (ie, as in 'text' as opposed\n \t to '__text__') then we could avoid the following case.  */\n       else if (ident_len == attr_len + 4)\n \t{\n-\t  const char *p = IDENTIFIER_POINTER (TREE_PURPOSE (list));\n+\t  const char *p = IDENTIFIER_POINTER (get_attribute_name (list));\n \t  if (p[0] == '_' && p[1] == '_'\n \t      && p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n \t      && strncmp (attr_name, p + 2, attr_len) == 0)\n@@ -5329,10 +5330,11 @@ lookup_ident_attribute (tree attr_identifier, tree list)\n \n   while (list)\n     {\n-      gcc_checking_assert (TREE_CODE (TREE_PURPOSE (list)) == IDENTIFIER_NODE);\n+      gcc_checking_assert (TREE_CODE (get_attribute_name (list))\n+\t\t\t   == IDENTIFIER_NODE);\n \n       /* Identifiers can be compared directly for equality.  */\n-      if (attr_identifier == TREE_PURPOSE (list))\n+      if (attr_identifier == get_attribute_name (list))\n \tbreak;\n \n       /* If they are not equal, they may still be one in the form\n@@ -5342,11 +5344,11 @@ lookup_ident_attribute (tree attr_identifier, tree list)\n \t the fact that we're comparing identifiers. :-)  */\n       {\n \tsize_t attr_len = IDENTIFIER_LENGTH (attr_identifier);\n-\tsize_t ident_len = IDENTIFIER_LENGTH (TREE_PURPOSE (list));\n+\tsize_t ident_len = IDENTIFIER_LENGTH (get_attribute_name (list));\n \n \tif (ident_len == attr_len + 4)\n \t  {\n-\t    const char *p = IDENTIFIER_POINTER (TREE_PURPOSE (list));\n+\t    const char *p = IDENTIFIER_POINTER (get_attribute_name (list));\n \t    const char *q = IDENTIFIER_POINTER (attr_identifier);\n \t    if (p[0] == '_' && p[1] == '_'\n \t\t&& p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n@@ -5355,7 +5357,7 @@ lookup_ident_attribute (tree attr_identifier, tree list)\n \t  }\n \telse if (ident_len + 4 == attr_len)\n \t  {\n-\t    const char *p = IDENTIFIER_POINTER (TREE_PURPOSE (list));\n+\t    const char *p = IDENTIFIER_POINTER (get_attribute_name (list));\n \t    const char *q = IDENTIFIER_POINTER (attr_identifier);\n \t    if (q[0] == '_' && q[1] == '_'\n \t\t&& q[attr_len - 2] == '_' && q[attr_len - 1] == '_'\n@@ -5385,7 +5387,7 @@ remove_attribute (const char *attr_name, tree list)\n       tree l = *p;\n       /* TODO: If we were storing attributes in normalized form, here\n \t we could use a simple strcmp().  */\n-      if (private_is_attribute_p (attr_name, attr_len, TREE_PURPOSE (l)))\n+      if (private_is_attribute_p (attr_name, attr_len, get_attribute_name (l)))\n \t*p = TREE_CHAIN (l);\n       else\n \tp = &TREE_CHAIN (l);\n@@ -5422,9 +5424,11 @@ merge_attributes (tree a1, tree a2)\n \t  for (; a2 != 0; a2 = TREE_CHAIN (a2))\n \t    {\n \t      tree a;\n-\t      for (a = lookup_ident_attribute (TREE_PURPOSE (a2), attributes);\n+\t      for (a = lookup_ident_attribute (get_attribute_name (a2),\n+\t\t\t\t\t       attributes);\n \t\t   a != NULL_TREE && !attribute_value_equal (a, a2);\n-\t\t   a = lookup_ident_attribute (TREE_PURPOSE (a2), TREE_CHAIN (a)))\n+\t\t   a = lookup_ident_attribute (get_attribute_name (a2),\n+\t\t\t\t\t       TREE_CHAIN (a)))\n \t\t;\n \t      if (a == NULL_TREE)\n \t\t{\n@@ -6346,7 +6350,7 @@ attribute_hash_list (const_tree list, hashval_t hashcode)\n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n     /* ??? Do we want to add in TREE_VALUE too? */\n     hashcode = iterative_hash_object\n-      (IDENTIFIER_HASH_VALUE (TREE_PURPOSE (tail)), hashcode);\n+      (IDENTIFIER_HASH_VALUE (get_attribute_name (tail)), hashcode);\n   return hashcode;\n }\n \n@@ -6383,7 +6387,7 @@ attribute_list_contained (const_tree l1, const_tree l2)\n   /* Maybe the lists are similar.  */\n   for (t1 = l1, t2 = l2;\n        t1 != 0 && t2 != 0\n-        && TREE_PURPOSE (t1) == TREE_PURPOSE (t2)\n+        && get_attribute_name (t1) == get_attribute_name (t2)\n         && TREE_VALUE (t1) == TREE_VALUE (t2);\n        t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n     ;\n@@ -6398,9 +6402,9 @@ attribute_list_contained (const_tree l1, const_tree l2)\n       /* This CONST_CAST is okay because lookup_attribute does not\n \t modify its argument and the return value is assigned to a\n \t const_tree.  */\n-      for (attr = lookup_ident_attribute (TREE_PURPOSE (t2), CONST_CAST_TREE(l1));\n+      for (attr = lookup_ident_attribute (get_attribute_name (t2), CONST_CAST_TREE(l1));\n \t   attr != NULL_TREE && !attribute_value_equal (t2, attr);\n-\t   attr = lookup_ident_attribute (TREE_PURPOSE (t2), TREE_CHAIN (attr)))\n+\t   attr = lookup_ident_attribute (get_attribute_name (t2), TREE_CHAIN (attr)))\n \t;\n \n       if (attr == NULL_TREE)"}, {"sha": "e7cef1857936c2f6dca290290840b9b0c7766f6c", "filename": "gcc/tree.h", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28d52cffbb2abc7a5764ed4c97a25c376913fee/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e28d52cffbb2abc7a5764ed4c97a25c376913fee", "patch": "@@ -4903,28 +4903,28 @@ struct attribute_spec\n {\n   /* The name of the attribute (without any leading or trailing __),\n      or NULL to mark the end of a table of attributes.  */\n-  const char *const name;\n+  const char *name;\n   /* The minimum length of the list of arguments of the attribute.  */\n-  const int min_length;\n+  int min_length;\n   /* The maximum length of the list of arguments of the attribute\n      (-1 for no maximum).  */\n-  const int max_length;\n+  int max_length;\n   /* Whether this attribute requires a DECL.  If it does, it will be passed\n      from types of DECLs, function return types and array element types to\n      the DECLs, function types and array types respectively; but when\n      applied to a type in any other circumstances, it will be ignored with\n      a warning.  (If greater control is desired for a given attribute,\n      this should be false, and the flags argument to the handler may be\n      used to gain greater control in that case.)  */\n-  const bool decl_required;\n+  bool decl_required;\n   /* Whether this attribute requires a type.  If it does, it will be passed\n      from a DECL to the type of that DECL.  */\n-  const bool type_required;\n+  bool type_required;\n   /* Whether this attribute requires a function (or method) type.  If it does,\n      it will be passed from a function pointer type to the target type,\n      and from a function return type (which is not itself a function\n      pointer type) to the function type.  */\n-  const bool function_type_required;\n+  bool function_type_required;\n   /* Function to handle this attribute.  NODE points to the node to which\n      the attribute is to be applied.  If a DECL, it should be modified in\n      place; if a TYPE, a copy should be created.  NAME is the name of the\n@@ -4939,10 +4939,10 @@ struct attribute_spec\n      otherwise the return value should be NULL_TREE.  This pointer may be\n      NULL if no special handling is required beyond the checks implied\n      by the rest of this structure.  */\n-  tree (*const handler) (tree *node, tree name, tree args,\n-\t\t\t\t int flags, bool *no_add_attrs);\n+  tree (*handler) (tree *node, tree name, tree args,\n+\t\t   int flags, bool *no_add_attrs);\n   /* Specifies if attribute affects type's identity.  */\n-  const bool affects_type_identity;\n+  bool affects_type_identity;\n };\n \n /* Flags that may be passed in the third argument of decl_attributes, and\n@@ -4967,7 +4967,9 @@ enum attribute_flags\n   /* The attributes are being applied by default to a library function whose\n      name indicates known behavior, and should be silently ignored if they\n      are not in fact compatible with the function type.  */\n-  ATTR_FLAG_BUILT_IN = 16\n+  ATTR_FLAG_BUILT_IN = 16,\n+  /* A given attribute has been parsed as a C++-11 attribute.  */\n+  ATTR_FLAG_CXX11 = 32\n };\n \n /* Default versions of target-overridable functions.  */\n@@ -6054,6 +6056,8 @@ extern bool must_pass_in_stack_var_size_or_pad (enum machine_mode, const_tree);\n /* In attribs.c.  */\n \n extern const struct attribute_spec *lookup_attribute_spec (const_tree);\n+extern const struct attribute_spec *lookup_scoped_attribute_spec (const_tree,\n+\t\t\t\t\t\t\t\t  const_tree);\n \n extern void init_attributes (void);\n \n@@ -6067,6 +6071,12 @@ extern void init_attributes (void);\n    a decl attribute to the declaration rather than to its type).  */\n extern tree decl_attributes (tree *, tree, int);\n \n+extern bool cxx11_attribute_p (const_tree);\n+\n+extern tree get_attribute_name (const_tree);\n+\n+extern tree get_attribute_namespace (const_tree);\n+\n extern void apply_tm_attr (tree, tree);\n \n /* In stor-layout.c */"}]}