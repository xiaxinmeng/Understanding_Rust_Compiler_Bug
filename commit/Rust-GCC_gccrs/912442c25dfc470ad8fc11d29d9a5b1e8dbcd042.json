{"sha": "912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEyNDQyYzI1ZGZjNDcwYWQ4ZmMxMWQyOWQ5YTViMWU4ZGJjZDA0Mg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-11-18T18:33:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-18T18:33:38Z"}, "message": "nvptx.c (bb_pair_t, [...]): New types.\n\n\tgcc/\n\t* config/nvptx/nvptx.c (bb_pair_t, bb_pair_vec_t): New types.\n\t(pseudo_node_t, struct bracket, bracket_vec_t): New types.\n\t(struct bb_sese): New struct.\n\t(bb_sese::~bb_sese, bb_sese::append, bb_sese::remove): New.\n\t(BB_GET_SESE, BB_SET_SESE): Define.\n\t(nvptx_sese_number, nvptx_sese_pseudo, nvptx_sese_color): New.\n\t(nvptx_find_sese): New.\n\t(nvptx_neuter_pars): Find SESE regions when optimizing.\n\n\tgcc/testsuite/\n\t* gcc.dg/goacc/nvptx-sese-1.c: New.\n\nFrom-SVN: r230561", "tree": {"sha": "538fa8aef03cc3d746cf94efc077a9b722e19eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/538fa8aef03cc3d746cf94efc077a9b722e19eed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/comments", "author": null, "committer": null, "parents": [{"sha": "482a338d0113756c63035861fa05aa003b49cf65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482a338d0113756c63035861fa05aa003b49cf65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/482a338d0113756c63035861fa05aa003b49cf65"}], "stats": {"total": 707, "additions": 702, "deletions": 5}, "files": [{"sha": "1f566825407d34a3dbac52114f746e513c5c4b3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "patch": "@@ -1,3 +1,14 @@\n+2015-11-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/nvptx/nvptx.c (bb_pair_t, bb_pair_vec_t): New types.\n+\t(pseudo_node_t, struct bracket, bracket_vec_t): New types.\n+\t(struct bb_sese): New struct.\n+\t(bb_sese::~bb_sese, bb_sese::append, bb_sese::remove): New.\n+\t(BB_GET_SESE, BB_SET_SESE): Define.\n+\t(nvptx_sese_number, nvptx_sese_pseudo, nvptx_sese_color): New.\n+\t(nvptx_find_sese): New.\n+\t(nvptx_neuter_pars): Find SESE regions when optimizing.\n+\n 2015-11-18  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (use_toc_relative_ref): Ignore"}, {"sha": "211f43574283251f2f1bbfaff493454a79b5e994", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 652, "deletions": 5, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "patch": "@@ -2605,6 +2605,631 @@ nvptx_discover_pars (bb_insn_map_t *map)\n   return par;\n }\n \n+/* Analyse a group of BBs within a partitioned region and create N\n+   Single-Entry-Single-Exit regions.  Some of those regions will be\n+   trivial ones consisting of a single BB.  The blocks of a\n+   partitioned region might form a set of disjoint graphs -- because\n+   the region encloses a differently partitoned sub region.\n+\n+   We use the linear time algorithm described in 'Finding Regions Fast:\n+   Single Entry Single Exit and control Regions in Linear Time'\n+   Johnson, Pearson & Pingali.  That algorithm deals with complete\n+   CFGs, where a back edge is inserted from END to START, and thus the\n+   problem becomes one of finding equivalent loops.\n+\n+   In this case we have a partial CFG.  We complete it by redirecting\n+   any incoming edge to the graph to be from an arbitrary external BB,\n+   and similarly redirecting any outgoing edge to be to  that BB.\n+   Thus we end up with a closed graph.\n+\n+   The algorithm works by building a spanning tree of an undirected\n+   graph and keeping track of back edges from nodes further from the\n+   root in the tree to nodes nearer to the root in the tree.  In the\n+   description below, the root is up and the tree grows downwards.\n+\n+   We avoid having to deal with degenerate back-edges to the same\n+   block, by splitting each BB into 3 -- one for input edges, one for\n+   the node itself and one for the output edges.  Such back edges are\n+   referred to as 'Brackets'.  Cycle equivalent nodes will have the\n+   same set of brackets.\n+   \n+   Determining bracket equivalency is done by maintaining a list of\n+   brackets in such a manner that the list length and final bracket\n+   uniquely identify the set.\n+\n+   We use coloring to mark all BBs with cycle equivalency with the\n+   same color.  This is the output of the 'Finding Regions Fast'\n+   algorithm.  Notice it doesn't actually find the set of nodes within\n+   a particular region, just unorderd sets of nodes that are the\n+   entries and exits of SESE regions.\n+   \n+   After determining cycle equivalency, we need to find the minimal\n+   set of SESE regions.  Do this with a DFS coloring walk of the\n+   complete graph.  We're either 'looking' or 'coloring'.  When\n+   looking, and we're in the subgraph, we start coloring the color of\n+   the current node, and remember that node as the start of the\n+   current color's SESE region.  Every time we go to a new node, we\n+   decrement the count of nodes with thet color.  If it reaches zero,\n+   we remember that node as the end of the current color's SESE region\n+   and return to 'looking'.  Otherwise we color the node the current\n+   color.\n+\n+   This way we end up with coloring the inside of non-trivial SESE\n+   regions with the color of that region.  */\n+\n+/* A pair of BBs.  We use this to represent SESE regions.  */\n+typedef std::pair<basic_block, basic_block> bb_pair_t;\n+typedef auto_vec<bb_pair_t> bb_pair_vec_t;\n+\n+/* A node in the undirected CFG.  The discriminator SECOND indicates just\n+   above or just below the BB idicated by FIRST.  */\n+typedef std::pair<basic_block, int> pseudo_node_t;\n+\n+/* A bracket indicates an edge towards the root of the spanning tree of the\n+   undirected graph.  Each bracket has a color, determined\n+   from the currrent set of brackets.  */\n+struct bracket\n+{\n+  pseudo_node_t back; /* Back target */\n+\n+  /* Current color and size of set.  */\n+  unsigned color;\n+  unsigned size;\n+\n+  bracket (pseudo_node_t back_)\n+  : back (back_), color (~0u), size (~0u)\n+  {\n+  }\n+\n+  unsigned get_color (auto_vec<unsigned> &color_counts, unsigned length)\n+  {\n+    if (length != size)\n+      {\n+\tsize = length;\n+\tcolor = color_counts.length ();\n+\tcolor_counts.quick_push (0);\n+      }\n+    color_counts[color]++;\n+    return color;\n+  }\n+};\n+\n+typedef auto_vec<bracket> bracket_vec_t;\n+\n+/* Basic block info for finding SESE regions.    */\n+\n+struct bb_sese\n+{\n+  int node;  /* Node number in spanning tree.  */\n+  int parent; /* Parent node number.  */\n+\n+  /* The algorithm splits each node A into Ai, A', Ao. The incoming\n+     edges arrive at pseudo-node Ai and the outgoing edges leave at\n+     pseudo-node Ao.  We have to remember which way we arrived at a\n+     particular node when generating the spanning tree.  dir > 0 means\n+     we arrived at Ai, dir < 0 means we arrived at Ao.  */\n+  int dir;\n+\n+  /* Lowest numbered pseudo-node reached via a backedge from thsis\n+     node, or any descendant.  */\n+  pseudo_node_t high;\n+\n+  int color;  /* Cycle-equivalence color  */\n+\n+  /* Stack of brackets for this node.  */\n+  bracket_vec_t brackets;\n+\n+  bb_sese (unsigned node_, unsigned p, int dir_)\n+  :node (node_), parent (p), dir (dir_)\n+  {\n+  }\n+  ~bb_sese ();\n+\n+  /* Push a bracket ending at BACK.  */\n+  void push (const pseudo_node_t &back)\n+  {\n+    if (dump_file)\n+      fprintf (dump_file, \"Pushing backedge %d:%+d\\n\",\n+\t       back.first ? back.first->index : 0, back.second);\n+    brackets.safe_push (bracket (back));\n+  }\n+  \n+  void append (bb_sese *child);\n+  void remove (const pseudo_node_t &);\n+\n+  /* Set node's color.  */\n+  void set_color (auto_vec<unsigned> &color_counts)\n+  {\n+    color = brackets.last ().get_color (color_counts, brackets.length ());\n+  }\n+};\n+\n+bb_sese::~bb_sese ()\n+{\n+}\n+\n+/* Destructively append CHILD's brackets.  */\n+\n+void\n+bb_sese::append (bb_sese *child)\n+{\n+  if (int len = child->brackets.length ())\n+    {\n+      int ix;\n+\n+      if (dump_file)\n+\t{\n+\t  for (ix = 0; ix < len; ix++)\n+\t    {\n+\t      const pseudo_node_t &pseudo = child->brackets[ix].back;\n+\t      fprintf (dump_file, \"Appending (%d)'s backedge %d:%+d\\n\",\n+\t\t       child->node, pseudo.first ? pseudo.first->index : 0,\n+\t\t       pseudo.second);\n+\t    }\n+\t}\n+      if (!brackets.length ())\n+\tstd::swap (brackets, child->brackets);\n+      else\n+\t{\n+\t  brackets.reserve (len);\n+\t  for (ix = 0; ix < len; ix++)\n+\t    brackets.quick_push (child->brackets[ix]);\n+\t}\n+    }\n+}\n+\n+/* Remove brackets that terminate at PSEUDO.  */\n+\n+void\n+bb_sese::remove (const pseudo_node_t &pseudo)\n+{\n+  unsigned removed = 0;\n+  int len = brackets.length ();\n+\n+  for (int ix = 0; ix < len; ix++)\n+    {\n+      if (brackets[ix].back == pseudo)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Removing backedge %d:%+d\\n\",\n+\t\t     pseudo.first ? pseudo.first->index : 0, pseudo.second);\n+\t  removed++;\n+\t}\n+      else if (removed)\n+\tbrackets[ix-removed] = brackets[ix];\n+    }\n+  while (removed--)\n+    brackets.pop ();\n+}\n+\n+/* Accessors for BB's aux pointer.  */\n+#define BB_SET_SESE(B, S) ((B)->aux = (S))\n+#define BB_GET_SESE(B) ((bb_sese *)(B)->aux)\n+\n+/* DFS walk creating SESE data structures.  Only cover nodes with\n+   BB_VISITED set.  Append discovered blocks to LIST.  We number in\n+   increments of 3 so that the above and below pseudo nodes can be\n+   implicitly numbered too.  */\n+\n+static int\n+nvptx_sese_number (int n, int p, int dir, basic_block b,\n+\t\t   auto_vec<basic_block> *list)\n+{\n+  if (BB_GET_SESE (b))\n+    return n;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Block %d(%d), parent (%d), orientation %+d\\n\",\n+\t     b->index, n, p, dir);\n+  \n+  BB_SET_SESE (b, new bb_sese (n, p, dir));\n+  p = n;\n+      \n+  n += 3;\n+  list->quick_push (b);\n+\n+  /* First walk the nodes on the 'other side' of this node, then walk\n+     the nodes on the same side.  */\n+  for (unsigned ix = 2; ix; ix--)\n+    {\n+      vec<edge, va_gc> *edges = dir > 0 ? b->succs : b->preds;\n+      size_t offset = (dir > 0 ? offsetof (edge_def, dest)\n+\t\t       : offsetof (edge_def, src));\n+      edge e;\n+      edge_iterator (ei);\n+\n+      FOR_EACH_EDGE (e, ei, edges)\n+\t{\n+\t  basic_block target = *(basic_block *)((char *)e + offset);\n+\t  \n+\t  if (target->flags & BB_VISITED)\n+\t    n = nvptx_sese_number (n, p, dir, target, list);\n+\t}\n+      dir = -dir;\n+    }\n+  return n;\n+}\n+\n+/* Process pseudo node above (DIR < 0) or below (DIR > 0) ME.\n+   EDGES are the outgoing edges and OFFSET is the offset to the src\n+   or dst block on the edges.   */\n+\n+static void\n+nvptx_sese_pseudo (basic_block me, bb_sese *sese, int depth, int dir,\n+\t\t   vec<edge, va_gc> *edges, size_t offset)\n+{\n+  edge e;\n+  edge_iterator (ei);\n+  int hi_back = depth;\n+  pseudo_node_t node_back (0, depth);\n+  int hi_child = depth;\n+  pseudo_node_t node_child (0, depth);\n+  basic_block child = NULL;\n+  unsigned num_children = 0;\n+  int usd = -dir * sese->dir;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nProcessing %d(%d) %+d\\n\",\n+\t     me->index, sese->node, dir);\n+\n+  if (dir < 0)\n+    {\n+      /* This is the above pseudo-child.  It has the BB itself as an\n+\t additional child node.  */\n+      node_child = sese->high;\n+      hi_child = node_child.second;\n+      if (node_child.first)\n+\thi_child += BB_GET_SESE (node_child.first)->node;\n+      num_children++;\n+    }\n+\n+  /* Examine each edge.\n+     - if it is a child (a) append its bracket list and (b) record\n+          whether it is the child with the highest reaching bracket.\n+     - if it is an edge to ancestor, record whether it's the highest\n+          reaching backlink.  */\n+  FOR_EACH_EDGE (e, ei, edges)\n+    {\n+      basic_block target = *(basic_block *)((char *)e + offset);\n+\n+      if (bb_sese *t_sese = BB_GET_SESE (target))\n+\t{\n+\t  if (t_sese->parent == sese->node && !(t_sese->dir + usd))\n+\t    {\n+\t      /* Child node.  Append its bracket list. */\n+\t      num_children++;\n+\t      sese->append (t_sese);\n+\n+\t      /* Compare it's hi value.  */\n+\t      int t_hi = t_sese->high.second;\n+\n+\t      if (basic_block child_hi_block = t_sese->high.first)\n+\t\tt_hi += BB_GET_SESE (child_hi_block)->node;\n+\n+\t      if (hi_child > t_hi)\n+\t\t{\n+\t\t  hi_child = t_hi;\n+\t\t  node_child = t_sese->high;\n+\t\t  child = target;\n+\t\t}\n+\t    }\n+\t  else if (t_sese->node < sese->node + dir\n+\t\t   && !(dir < 0 && sese->parent == t_sese->node))\n+\t    {\n+\t      /* Non-parental ancestor node -- a backlink.  */\n+\t      int d = usd * t_sese->dir;\n+\t      int back = t_sese->node + d;\n+\t\n+\t      if (hi_back > back)\n+\t\t{\n+\t\t  hi_back = back;\n+\t\t  node_back = pseudo_node_t (target, d);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{ /* Fallen off graph, backlink to entry node.  */\n+\t  hi_back = 0;\n+\t  node_back = pseudo_node_t (0, 0);\n+\t}\n+    }\n+\n+  /* Remove any brackets that terminate at this pseudo node.  */\n+  sese->remove (pseudo_node_t (me, dir));\n+\n+  /* Now push any backlinks from this pseudo node.  */\n+  FOR_EACH_EDGE (e, ei, edges)\n+    {\n+      basic_block target = *(basic_block *)((char *)e + offset);\n+      if (bb_sese *t_sese = BB_GET_SESE (target))\n+\t{\n+\t  if (t_sese->node < sese->node + dir\n+\t      && !(dir < 0 && sese->parent == t_sese->node))\n+\t    /* Non-parental ancestor node - backedge from me.  */\n+\t    sese->push (pseudo_node_t (target, usd * t_sese->dir));\n+\t}\n+      else\n+\t{\n+\t  /* back edge to entry node */\n+\t  sese->push (pseudo_node_t (0, 0));\n+\t}\n+    }\n+  \n+ /* If this node leads directly or indirectly to a no-return region of\n+     the graph, then fake a backedge to entry node.  */\n+  if (!sese->brackets.length () || !edges || !edges->length ())\n+    {\n+      hi_back = 0;\n+      node_back = pseudo_node_t (0, 0);\n+      sese->push (node_back);\n+    }\n+\n+  /* Record the highest reaching backedge from us or a descendant.  */\n+  sese->high = hi_back < hi_child ? node_back : node_child;\n+\n+  if (num_children > 1)\n+    {\n+      /* There is more than one child -- this is a Y shaped piece of\n+\t spanning tree.  We have to insert a fake backedge from this\n+\t node to the highest ancestor reached by not-the-highest\n+\t reaching child.  Note that there may be multiple children\n+\t with backedges to the same highest node.  That's ok and we\n+\t insert the edge to that highest node.  */\n+      hi_child = depth;\n+      if (dir < 0 && child)\n+\t{\n+\t  node_child = sese->high;\n+\t  hi_child = node_child.second;\n+\t  if (node_child.first)\n+\t    hi_child += BB_GET_SESE (node_child.first)->node;\n+\t}\n+\n+      FOR_EACH_EDGE (e, ei, edges)\n+\t{\n+\t  basic_block target = *(basic_block *)((char *)e + offset);\n+\n+\t  if (target == child)\n+\t    /* Ignore the highest child. */\n+\t    continue;\n+\n+\t  bb_sese *t_sese = BB_GET_SESE (target);\n+\t  if (!t_sese)\n+\t    continue;\n+\t  if (t_sese->parent != sese->node)\n+\t    /* Not a child. */\n+\t    continue;\n+\n+\t  /* Compare its hi value.  */\n+\t  int t_hi = t_sese->high.second;\n+\n+\t  if (basic_block child_hi_block = t_sese->high.first)\n+\t    t_hi += BB_GET_SESE (child_hi_block)->node;\n+\n+\t  if (hi_child > t_hi)\n+\t    {\n+\t      hi_child = t_hi;\n+\t      node_child = t_sese->high;\n+\t    }\n+\t}\n+      \n+      sese->push (node_child);\n+    }\n+}\n+\n+\n+/* DFS walk of BB graph.  Color node BLOCK according to COLORING then\n+   proceed to successors.  Set SESE entry and exit nodes of\n+   REGIONS.  */\n+\n+static void\n+nvptx_sese_color (auto_vec<unsigned> &color_counts, bb_pair_vec_t &regions,\n+\t\t  basic_block block, int coloring)\n+{\n+  bb_sese *sese = BB_GET_SESE (block);\n+\n+  if (block->flags & BB_VISITED)\n+    {\n+      /* If we've already encountered this block, either we must not\n+\t be coloring, or it must have been colored the current color.  */\n+      gcc_assert (coloring < 0 || (sese && coloring == sese->color));\n+      return;\n+    }\n+  \n+  block->flags |= BB_VISITED;\n+\n+  if (sese)\n+    {\n+      if (coloring < 0)\n+\t{\n+\t  /* Start coloring a region.  */\n+\t  regions[sese->color].first = block;\n+\t  coloring = sese->color;\n+\t}\n+\n+      if (!--color_counts[sese->color] && sese->color == coloring)\n+\t{\n+\t  /* Found final block of SESE region.  */\n+\t  regions[sese->color].second = block;\n+\t  coloring = -1;\n+\t}\n+      else\n+\t/* Color the node, so we can assert on revisiting the node\n+\t   that the graph is indeed SESE.  */\n+\tsese->color = coloring;\n+    }\n+  else\n+    /* Fallen off the subgraph, we cannot be coloring.  */\n+    gcc_assert (coloring < 0);\n+\n+  /* Walk each successor block.  */\n+  if (block->succs && block->succs->length ())\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      \n+      FOR_EACH_EDGE (e, ei, block->succs)\n+\tnvptx_sese_color (color_counts, regions, e->dest, coloring);\n+    }\n+  else\n+    gcc_assert (coloring < 0);\n+}\n+\n+/* Find minimal set of SESE regions covering BLOCKS.  REGIONS might\n+   end up with NULL entries in it.  */\n+\n+static void\n+nvptx_find_sese (auto_vec<basic_block> &blocks, bb_pair_vec_t &regions)\n+{\n+  basic_block block;\n+  int ix;\n+\n+  /* First clear each BB of the whole function.  */ \n+  FOR_EACH_BB_FN (block, cfun)\n+    {\n+      block->flags &= ~BB_VISITED;\n+      BB_SET_SESE (block, 0);\n+    }\n+  block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  block->flags &= ~BB_VISITED;\n+  BB_SET_SESE (block, 0);\n+  block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  block->flags &= ~BB_VISITED;\n+  BB_SET_SESE (block, 0);\n+\n+  /* Mark blocks in the function that are in this graph.  */\n+  for (ix = 0; blocks.iterate (ix, &block); ix++)\n+    block->flags |= BB_VISITED;\n+\n+  /* Counts of nodes assigned to each color.  There cannot be more\n+     colors than blocks (and hopefully there will be fewer).  */\n+  auto_vec<unsigned> color_counts;\n+  color_counts.reserve (blocks.length ());\n+\n+  /* Worklist of nodes in the spanning tree.  Again, there cannot be\n+     more nodes in the tree than blocks (there will be fewer if the\n+     CFG of blocks is disjoint).  */\n+  auto_vec<basic_block> spanlist;\n+  spanlist.reserve (blocks.length ());\n+\n+  /* Make sure every block has its cycle class determined.  */\n+  for (ix = 0; blocks.iterate (ix, &block); ix++)\n+    {\n+      if (BB_GET_SESE (block))\n+\t/* We already met this block in an earlier graph solve.  */\n+\tcontinue;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Searching graph starting at %d\\n\", block->index);\n+      \n+      /* Number the nodes reachable from block initial DFS order.  */\n+      int depth = nvptx_sese_number (2, 0, +1, block, &spanlist);\n+\n+      /* Now walk in reverse DFS order to find cycle equivalents.  */\n+      while (spanlist.length ())\n+\t{\n+\t  block = spanlist.pop ();\n+\t  bb_sese *sese = BB_GET_SESE (block);\n+\n+\t  /* Do the pseudo node below.  */\n+\t  nvptx_sese_pseudo (block, sese, depth, +1,\n+\t\t\t     sese->dir > 0 ? block->succs : block->preds,\n+\t\t\t     (sese->dir > 0 ? offsetof (edge_def, dest)\n+\t\t\t      : offsetof (edge_def, src)));\n+\t  sese->set_color (color_counts);\n+\t  /* Do the pseudo node above.  */\n+\t  nvptx_sese_pseudo (block, sese, depth, -1,\n+\t\t\t     sese->dir < 0 ? block->succs : block->preds,\n+\t\t\t     (sese->dir < 0 ? offsetof (edge_def, dest)\n+\t\t\t      : offsetof (edge_def, src)));\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (dump_file)\n+    {\n+      unsigned count;\n+      const char *comma = \"\";\n+      \n+      fprintf (dump_file, \"Found %d cycle equivalents\\n\",\n+\t       color_counts.length ());\n+      for (ix = 0; color_counts.iterate (ix, &count); ix++)\n+\t{\n+\t  fprintf (dump_file, \"%s%d[%d]={\", comma, ix, count);\n+\n+\t  comma = \"\";\n+\t  for (unsigned jx = 0; blocks.iterate (jx, &block); jx++)\n+\t    if (BB_GET_SESE (block)->color == ix)\n+\t      {\n+\t\tblock->flags |= BB_VISITED;\n+\t\tfprintf (dump_file, \"%s%d\", comma, block->index);\n+\t\tcomma=\",\";\n+\t      }\n+\t  fprintf (dump_file, \"}\");\n+\t  comma = \", \";\n+\t}\n+      fprintf (dump_file, \"\\n\");\n+   }\n+  \n+  /* Now we've colored every block in the subgraph.  We now need to\n+     determine the minimal set of SESE regions that cover that\n+     subgraph.  Do this with a DFS walk of the complete function.\n+     During the walk we're either 'looking' or 'coloring'.  When we\n+     reach the last node of a particular color, we stop coloring and\n+     return to looking.  */\n+\n+  /* There cannot be more SESE regions than colors.  */\n+  regions.reserve (color_counts.length ());\n+  for (ix = color_counts.length (); ix--;)\n+    regions.quick_push (bb_pair_t (0, 0));\n+\n+  for (ix = 0; blocks.iterate (ix, &block); ix++)\n+    block->flags &= ~BB_VISITED;\n+\n+  nvptx_sese_color (color_counts, regions, ENTRY_BLOCK_PTR_FOR_FN (cfun), -1);\n+\n+  if (dump_file)\n+    {\n+      const char *comma = \"\";\n+      int len = regions.length ();\n+      \n+      fprintf (dump_file, \"SESE regions:\");\n+      for (ix = 0; ix != len; ix++)\n+\t{\n+\t  basic_block from = regions[ix].first;\n+\t  basic_block to = regions[ix].second;\n+\n+\t  if (from)\n+\t    {\n+\t      fprintf (dump_file, \"%s %d{%d\", comma, ix, from->index);\n+\t      if (to != from)\n+\t\tfprintf (dump_file, \"->%d\", to->index);\n+\n+\t      int color = BB_GET_SESE (from)->color;\n+\n+\t      /* Print the blocks within the region (excluding ends).  */\n+\t      FOR_EACH_BB_FN (block, cfun)\n+\t\t{\n+\t\t  bb_sese *sese = BB_GET_SESE (block);\n+\n+\t\t  if (sese && sese->color == color\n+\t\t      && block != from && block != to)\n+\t\t    fprintf (dump_file, \".%d\", block->index);\n+\t\t}\n+\t      fprintf (dump_file, \"}\");\n+\t    }\n+\t  comma = \",\";\n+\t}\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+  \n+  for (ix = 0; blocks.iterate (ix, &block); ix++)\n+    delete BB_GET_SESE (block);\n+}\n+\n+#undef BB_SET_SESE\n+#undef BB_GET_SESE\n+\n /* Propagate live state at the start of a partitioned region.  BLOCK\n    provides the live register information, and might not contain\n    INSN. Propagation is inserted just after INSN. RW indicates whether\n@@ -3086,14 +3711,36 @@ nvptx_neuter_pars (parallel *par, unsigned modes, unsigned outer)\n \n   if (neuter_mask)\n     {\n-      int ix;\n-      int len = par->blocks.length ();\n+      int ix, len;\n \n-      for (ix = 0; ix != len; ix++)\n+      if (nvptx_optimize)\n+\t{\n+\t  /* Neuter whole SESE regions.  */\n+\t  bb_pair_vec_t regions;\n+\n+\t  nvptx_find_sese (par->blocks, regions);\n+\t  len = regions.length ();\n+\t  for (ix = 0; ix != len; ix++)\n+\t    {\n+\t      basic_block from = regions[ix].first;\n+\t      basic_block to = regions[ix].second;\n+\n+\t      if (from)\n+\t\tnvptx_single (neuter_mask, from, to);\n+\t      else\n+\t\tgcc_assert (!to);\n+\t    }\n+\t}\n+      else\n \t{\n-\t  basic_block block = par->blocks[ix];\n+\t  /* Neuter each BB individually.  */\n+\t  len = par->blocks.length ();\n+\t  for (ix = 0; ix != len; ix++)\n+\t    {\n+\t      basic_block block = par->blocks[ix];\n \n-\t  nvptx_single (neuter_mask, block, block);\n+\t      nvptx_single (neuter_mask, block, block);\n+\t    }\n \t}\n     }\n "}, {"sha": "e9a5adf4703b17f36846b86c4ee682666f138d19", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "patch": "@@ -1,3 +1,7 @@\n+2015-11-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcc.dg/goacc/nvptx-sese-1.c: New.\n+\n 2015-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/renaming7.adb: New test."}, {"sha": "7e67fe78f069dec5eb8861790dac7f65e6ca5327", "filename": "gcc/testsuite/gcc.dg/goacc/nvptx-sese-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Fnvptx-sese-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912442c25dfc470ad8fc11d29d9a5b1e8dbcd042/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Fnvptx-sese-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Fnvptx-sese-1.c?ref=912442c25dfc470ad8fc11d29d9a5b1e8dbcd042", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target offload_nvptx } */\n+/* { dg-options \"-fopenacc -O2 -foffload=-fdump-rtl-mach\\\\ -dumpbase\\\\ nvptx-sese-1.c\\\\ -Wa,--no-verify\" } */\n+\n+#pragma acc routine  seq\n+int __attribute__((noinline)) foo (int x)\n+{\n+  return x & 2;\n+}\n+\n+int main ()\n+{\n+  int r = 0;\n+  \n+#pragma acc parallel copy(r) vector_length(32)\n+  {\n+#pragma acc loop vector reduction (+:r)\n+    for (int i = 00; i < 40; i++)\n+      r += i;\n+\n+    /* This piece is a multi-block SESE region */\n+    if (foo (r))\n+      r *= 2;\n+\n+    if (r & 1) /* to here. */\n+#pragma acc loop vector reduction (+:r)\n+      for (int i = 00; i < 40; i++)\n+\tr += i;\n+  }\n+\n+  return 0;\n+}\n+\n+/* Match {N->N(.N)+} */\n+/* { dg-final { scan-rtl-dump \"SESE regions:.* \\[0-9\\]+{\\[0-9\\]+->\\[0-9\\]+(\\\\.\\[0-9\\]+)+}\" \"mach\" } } */"}]}