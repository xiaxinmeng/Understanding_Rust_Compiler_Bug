{"sha": "fc36b97af05ef74b0889ba49090c2f52f00e0e77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMzNmI5N2FmMDVlZjc0YjA4ODliYTQ5MDkwYzJmNTJmMDBlMGU3Nw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-06-18T08:37:14Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-06-27T12:11:41Z"}, "message": "Move simplification of statements using ranges into its own class.\n\nThis moves all the simplification code from vr_values into a separate\nclass (simplify_using_ranges).  In doing so, we get rid of a bunch of\ndependencies on the internals of vr_values.  The goal is to (a) remove\nunnecessary interdependendcies (b) be able to use this engine with any\nrange infrastructure, as all it needs is a method to get the range for\nan SSA name (get_value_range).\n\nI also removed as many dependencies on value_range_equiv as possible,\npreferring value_range.  A few value_range_equiv uses remain, but for\ncases where equivalences are actually used (folding conditionals, etc).\n\ngcc/ChangeLog:\n\n\t* gimple-ssa-evrp-analyze.h (vrp_visit_cond_stmt): Use\n\tsimplify_using_ranges class.\n\t* gimple-ssa-evrp.c (class evrp_folder): New simplify_using_ranges\n\tfield.  Adjust all methods to use new field.\n\t* tree-ssa-dom.c (simplify_stmt_for_jump_threading): Use\n\tsimplify_using_ranges class.\n\t* tree-vrp.c (class vrp_folder): New simplify_using_ranges\n\tfield.  Adjust all methods to use new field.\n\t(simplify_stmt_for_jump_threading): Use simplify_using_ranges class.\n\t(vrp_prop::vrp_finalize): New vrp_folder argument.\n\t(execute_vrp): Pass folder to vrp_finalize.  Use\n\tsimplify_using_ranges class.\n\tRemove cleanup_edges_and_switches call.\n\t* vr-values.c (vr_values::op_with_boolean_value_range_p): Change\n\tvalue_range_equiv uses to value_range.\n\t(simplify_using_ranges::op_with_boolean_value_range_p): Use\n\tsimplify_using_ranges class.\n\t(check_for_binary_op_overflow): Make static.\n\t(vr_values::extract_range_basic): Pass this to\n\tcheck_for_binary_op_overflow.\n\t(compare_range_with_value): Change value_range_equiv uses to\n\tvalue_range.\n\t(vr_values::vr_values): Initialize simplifier field.\n\tRemove uses of to_remove_edges and to_update_switch_stmts.\n\t(vr_values::~vr_values): Remove uses of to_remove_edges and\n\tto_update_switch_stmts.\n\t(vr_values::get_vr_for_comparison): Move to simplify_using_ranges\n\tclass.\n\t(vr_values::compare_name_with_value): Same.\n\t(vr_values::compare_names): Same.\n\t(vr_values::vrp_evaluate_conditional_warnv_with_ops): Same.\n\t(vr_values::vrp_evaluate_conditional): Same.\n\t(vr_values::vrp_visit_cond_stmt): Same.\n\t(find_case_label_ranges): Change value_range_equiv uses to\n\tvalue_range.\n\t(vr_values::extract_range_from_stmt): Use simplify_using_ranges class.\n\t(vr_values::simplify_truth_ops_using_ranges): Move to\n\tsimplify_using_ranges class.\n\t(vr_values::simplify_div_or_mod_using_ranges): Same.\n\t(vr_values::simplify_min_or_max_using_ranges): Same.\n\t(vr_values::simplify_abs_using_ranges): Same.\n\t(vr_values::simplify_bit_ops_using_ranges): Same.\n\t(test_for_singularity): Change value_range_equiv uses to\n\tvalue_range.\n\t(range_fits_type_p): Same.\n\t(vr_values::simplify_cond_using_ranges_1): Same.\n\t(vr_values::simplify_cond_using_ranges_2): Make extern.\n\t(vr_values::fold_cond): Move to simplify_using_ranges class.\n\t(vr_values::simplify_switch_using_ranges): Same.\n\t(vr_values::cleanup_edges_and_switches): Same.\n\t(vr_values::simplify_float_conversion_using_ranges): Same.\n\t(vr_values::simplify_internal_call_using_ranges): Same.\n\t(vr_values::two_valued_val_range_p): Same.\n\t(vr_values::simplify_stmt_using_ranges): Move to...\n\t(simplify_using_ranges::simplify): ...here.\n\t* vr-values.h (class vr_values): Move all the simplification of\n\tstatements using ranges methods and code from here...\n\t(class simplify_using_ranges): ...to here.\n\t(simplify_cond_using_ranges_2): New extern prototype.", "tree": {"sha": "56791637843a2bcbb21cd928008a014f163e7a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56791637843a2bcbb21cd928008a014f163e7a12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc36b97af05ef74b0889ba49090c2f52f00e0e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc36b97af05ef74b0889ba49090c2f52f00e0e77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc36b97af05ef74b0889ba49090c2f52f00e0e77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc36b97af05ef74b0889ba49090c2f52f00e0e77/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35"}], "stats": {"total": 333, "additions": 190, "deletions": 143}, "files": [{"sha": "8abbbe3180d2f91156cbbbb14ac49b06a3e2178b", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=fc36b97af05ef74b0889ba49090c2f52f00e0e77", "patch": "@@ -50,7 +50,10 @@ class evrp_range_analyzer\n \n   /* A bit of a wart.  This should ideally go away.  */\n   void vrp_visit_cond_stmt (gcond *cond, edge *e)\n-    { return vr_values->vrp_visit_cond_stmt (cond, e); }\n+  {\n+    simplify_using_ranges simpl (vr_values);\n+    simpl.vrp_visit_cond_stmt (cond, e);\n+  }\n \n   /* Get the underlying vr_values class instance.  If TRANSFER is\n      true, then we are transferring ownership.  Else we keep ownership."}, {"sha": "e8fde63aa3448305e25076ec8e89238db115ebf0", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=fc36b97af05ef74b0889ba49090c2f52f00e0e77", "patch": "@@ -46,14 +46,13 @@ class evrp_folder : public substitute_and_fold_engine\n {\n public:\n   evrp_folder () : m_range_analyzer (/*update_global_ranges=*/true),\n-    m_vr_values (m_range_analyzer.get_vr_values ())\n+    m_vr_values (m_range_analyzer.get_vr_values ()),\n+    simplifier (m_vr_values)\n   {\n   }\n \n   ~evrp_folder ()\n   {\n-    m_vr_values->cleanup_edges_and_switches ();\n-\n     if (dump_file)\n       {\n \tfprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n@@ -86,7 +85,7 @@ class evrp_folder : public substitute_and_fold_engine\n \n   bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n   {\n-    return m_vr_values->simplify_stmt_using_ranges (gsi);\n+    return simplifier.simplify (gsi);\n   }\n \n   void post_fold_bb (basic_block bb) OVERRIDE\n@@ -96,13 +95,15 @@ class evrp_folder : public substitute_and_fold_engine\n \n   void post_new_stmt (gimple *stmt) OVERRIDE\n   {\n-    m_vr_values->set_defs_to_varying (stmt);\n+    m_range_analyzer.get_vr_values ()->set_defs_to_varying (stmt);\n   }\n \n private:\n   DISABLE_COPY_AND_ASSIGN (evrp_folder);\n   class evrp_range_analyzer m_range_analyzer;\n   class vr_values *m_vr_values;\n+\n+  simplify_using_ranges simplifier;\n };\n \n /* Main entry point for the early vrp pass which is a simplified non-iterative"}, {"sha": "69eaec345bf45a7f4ee784b5baea3bdbe6b1f70a", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=fc36b97af05ef74b0889ba49090c2f52f00e0e77", "patch": "@@ -887,12 +887,11 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n      copy in tree-vrp is scheduled for removal in gcc-9.  */\n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {\n-      cached_lhs\n-\t= x_vr_values->vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t\t\t gimple_cond_lhs (cond_stmt),\n-\t\t\t\t\t\t gimple_cond_rhs (cond_stmt),\n-\t\t\t\t\t\t within_stmt);\n-      return cached_lhs;\n+      simplify_using_ranges simplifier (x_vr_values);\n+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t\t\t  gimple_cond_lhs (cond_stmt),\n+\t\t\t\t\t\t  gimple_cond_rhs (cond_stmt),\n+\t\t\t\t\t\t  within_stmt);\n     }\n \n   if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))"}, {"sha": "7193ca4ad5e7e95129b2a2dc9204a57233a5d41a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=fc36b97af05ef74b0889ba49090c2f52f00e0e77", "patch": "@@ -3373,7 +3373,7 @@ class vrp_prop : public ssa_propagation_engine\n   struct function *fun;\n \n   void vrp_initialize (struct function *);\n-  void vrp_finalize (bool);\n+  void vrp_finalize (class vrp_folder *, bool);\n \n   class vr_values vr_values;\n \n@@ -3938,23 +3938,28 @@ vrp_prop::visit_phi (gphi *phi)\n \n class vrp_folder : public substitute_and_fold_engine\n {\n-public:\n-  vrp_folder () : substitute_and_fold_engine (/* Fold all stmts.  */ true) {  }\n+ public:\n+  vrp_folder (vr_values *v)\n+    : substitute_and_fold_engine (/* Fold all stmts.  */ true),\n+      m_vr_values (v), simplifier (v)\n+    {  }\n   tree get_value (tree, gimple *stmt) FINAL OVERRIDE;\n   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n \n-  class vr_values *vr_values;\n+  class vr_values *m_vr_values;\n \n private:\n   bool fold_predicate_in (gimple_stmt_iterator *);\n   /* Delegators.  */\n   tree vrp_evaluate_conditional (tree_code code, tree op0,\n \t\t\t\t tree op1, gimple *stmt)\n-    { return vr_values->vrp_evaluate_conditional (code, op0, op1, stmt); }\n+    { return simplifier.vrp_evaluate_conditional (code, op0, op1, stmt); }\n   bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n-    { return vr_values->simplify_stmt_using_ranges (gsi); }\n+    { return simplifier.simplify (gsi); }\n  tree op_with_constant_singleton_value_range (tree op)\n-    { return vr_values->op_with_constant_singleton_value_range (op); }\n+    { return m_vr_values->op_with_constant_singleton_value_range (op); }\n+\n+  simplify_using_ranges simplifier;\n };\n \n /* If the statement pointed by SI has a predicate whose value can be\n@@ -4096,7 +4101,8 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n       tree op1 = gimple_cond_rhs (cond_stmt);\n       op1 = lhs_of_dominating_assert (op1, bb, stmt);\n \n-      return vr_values->vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+      simplify_using_ranges simplifier (vr_values);\n+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n \t\t\t\t\t\t  op0, op1, within_stmt);\n     }\n \n@@ -4332,7 +4338,7 @@ identify_jump_threads (struct function *fun, class vr_values *vr_values)\n /* Traverse all the blocks folding conditionals with known ranges.  */\n \n void\n-vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n+vrp_prop::vrp_finalize (vrp_folder *folder, bool warn_array_bounds_p)\n {\n   size_t i;\n \n@@ -4376,9 +4382,7 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n   if (warn_array_bounds && warn_array_bounds_p)\n     set_all_edges_as_executable (fun);\n \n-  class vrp_folder vrp_folder;\n-  vrp_folder.vr_values = &vr_values;\n-  vrp_folder.substitute_and_fold ();\n+  folder->substitute_and_fold ();\n \n   if (warn_array_bounds && warn_array_bounds_p)\n     {\n@@ -4453,7 +4457,10 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n   class vrp_prop vrp_prop;\n   vrp_prop.vrp_initialize (fun);\n   vrp_prop.ssa_propagate ();\n-  vrp_prop.vrp_finalize (warn_array_bounds_p);\n+  /* Instantiate the folder here, so that edge cleanups happen at the\n+     end of this function.  */\n+  vrp_folder folder (&vrp_prop.vr_values);\n+  vrp_prop.vrp_finalize (&folder, warn_array_bounds_p);\n \n   /* We must identify jump threading opportunities before we release\n      the datastructures built by VRP.  */\n@@ -4471,7 +4478,8 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n     {\n       gimple *last = last_stmt (bb);\n       if (last && gimple_code (last) == GIMPLE_COND)\n-\tvrp_prop.vr_values.simplify_cond_using_ranges_2 (as_a <gcond *> (last));\n+\tsimplify_cond_using_ranges_2 (&vrp_prop.vr_values,\n+\t\t\t\t      as_a <gcond *> (last));\n     }\n \n   free_numbers_of_iterations_estimates (fun);\n@@ -4496,7 +4504,6 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n      processing by the pass manager.  */\n   thread_through_all_blocks (false);\n \n-  vrp_prop.vr_values.cleanup_edges_and_switches ();\n   threadedge_finalize_values ();\n \n   scev_finalize ();"}, {"sha": "d0303599002604ff02268eab66b17237525ff7f7", "filename": "gcc/vr-values.c", "status": "modified", "additions": 83, "deletions": 71, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=fc36b97af05ef74b0889ba49090c2f52f00e0e77", "patch": "@@ -435,10 +435,8 @@ vr_values::op_with_constant_singleton_value_range (tree op)\n /* Return true if op is in a boolean [0, 1] value-range.  */\n \n bool\n-vr_values::op_with_boolean_value_range_p (tree op)\n+simplify_using_ranges::op_with_boolean_value_range_p (tree op)\n {\n-  const value_range_equiv *vr;\n-\n   if (TYPE_PRECISION (TREE_TYPE (op)) == 1)\n     return true;\n \n@@ -449,7 +447,7 @@ vr_values::op_with_boolean_value_range_p (tree op)\n   if (TREE_CODE (op) != SSA_NAME)\n     return false;\n \n-  vr = get_value_range (op);\n+  const value_range *vr = get_value_range (op);\n   return (vr->kind () == VR_RANGE\n \t  && integer_zerop (vr->min ())\n \t  && integer_onep (vr->max ()));\n@@ -976,10 +974,9 @@ vr_values::extract_range_from_comparison (value_range_equiv *vr,\n \t\t\t\t\t  tree type, tree op0, tree op1)\n {\n   bool sop;\n-  tree val;\n-\n-  val = vrp_evaluate_conditional_warnv_with_ops (code, op0, op1, false, &sop,\n-  \t\t\t\t\t\t NULL);\n+  tree val\n+    = simplifier.vrp_evaluate_conditional_warnv_with_ops (code, op0, op1,\n+\t\t\t\t\t\t\t  false, &sop, NULL);\n   if (val)\n     {\n       /* Since this expression was found on the RHS of an assignment,\n@@ -1002,20 +999,21 @@ vr_values::extract_range_from_comparison (value_range_equiv *vr,\n    always overflow.  Set *OVF to true if it is known to always\n    overflow.  */\n \n-bool\n-vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n-\t\t\t\t\t tree op0, tree op1, bool *ovf)\n+static bool\n+check_for_binary_op_overflow (vr_values *store,\n+\t\t\t      enum tree_code subcode, tree type,\n+\t\t\t      tree op0, tree op1, bool *ovf)\n {\n   value_range vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *get_value_range (op0);\n+    vr0 = *store->get_value_range (op0);\n   else if (TREE_CODE (op0) == INTEGER_CST)\n     vr0.set (op0);\n   else\n     vr0.set_varying (TREE_TYPE (op0));\n \n   if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *get_value_range (op1);\n+    vr1 = *store->get_value_range (op1);\n   else if (TREE_CODE (op1) == INTEGER_CST)\n     vr1.set (op1);\n   else\n@@ -1395,7 +1393,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t\t  if (code == IMAGPART_EXPR)\n \t\t    {\n \t\t      bool ovf = false;\n-\t\t      if (check_for_binary_op_overflow (subcode, type,\n+\t\t      if (check_for_binary_op_overflow (this, subcode, type,\n \t\t\t\t\t\t\top0, op1, &ovf))\n \t\t\tvr->set (build_int_cst (type, ovf));\n \t\t      else if (TYPE_PRECISION (type) == 1\n@@ -1636,7 +1634,7 @@ compare_ranges (enum tree_code comp, const value_range_equiv *vr0,\n    assumed signed overflow is undefined.  */\n \n static tree\n-compare_range_with_value (enum tree_code comp, const value_range_equiv *vr,\n+compare_range_with_value (enum tree_code comp, const value_range *vr,\n \t\t\t  tree val, bool *strict_overflow_p)\n {\n   if (vr->varying_p () || vr->undefined_p ())\n@@ -1946,15 +1944,14 @@ vr_values::dump_all_value_ranges (FILE *file)\n \n /* Initialize VRP lattice.  */\n \n-vr_values::vr_values () : vrp_value_range_pool (\"Tree VRP value ranges\")\n+vr_values::vr_values () : vrp_value_range_pool (\"Tree VRP value ranges\"),\n+  simplifier (this)\n {\n   values_propagated = false;\n   num_vr_values = num_ssa_names * 2;\n   vr_value = XCNEWVEC (value_range_equiv *, num_vr_values);\n   vr_phi_edge_counts = XCNEWVEC (int, num_ssa_names);\n   bitmap_obstack_initialize (&vrp_equiv_obstack);\n-  to_remove_edges = vNULL;\n-  to_update_switch_stmts = vNULL;\n }\n \n /* Free VRP lattice.  */\n@@ -1971,12 +1968,6 @@ vr_values::~vr_values ()\n      and not available.  */\n   vr_value = NULL;\n   vr_phi_edge_counts = NULL;\n-\n-  /* If there are entries left in TO_REMOVE_EDGES or TO_UPDATE_SWITCH_STMTS\n-     then an EVRP client did not clean up properly.  Catch it now rather\n-     than seeing something more obscure later.  */\n-  gcc_assert (to_remove_edges.is_empty ()\n-\t      && to_update_switch_stmts.is_empty ());\n }\n \n \n@@ -2094,7 +2085,7 @@ vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n    is varying or undefined.  Uses TEM as storage for the alternate range.  */\n \n const value_range_equiv *\n-vr_values::get_vr_for_comparison (int i, value_range_equiv *tem)\n+simplify_using_ranges::get_vr_for_comparison (int i, value_range_equiv *tem)\n {\n   /* Shallow-copy equiv bitmap.  */\n   const value_range_equiv *vr = get_value_range (ssa_name (i));\n@@ -2117,8 +2108,9 @@ vr_values::get_vr_for_comparison (int i, value_range_equiv *tem)\n    *STRICT_OVERFLOW_P.  */\n \n tree\n-vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n-\t\t\t\t    bool *strict_overflow_p, bool use_equiv_p)\n+simplify_using_ranges::compare_name_with_value\n+\t\t\t\t(enum tree_code comp, tree var, tree val,\n+\t\t\t\t bool *strict_overflow_p, bool use_equiv_p)\n {\n   /* Get the set of equivalences for VAR.  */\n   bitmap e = get_value_range (var)->equiv ();\n@@ -2196,8 +2188,8 @@ vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n \n \n tree\n-vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n-\t\t\t  bool *strict_overflow_p)\n+simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n+\t\t\t\t      bool *strict_overflow_p)\n {\n   /* Compare the ranges of every name equivalent to N1 against the\n      ranges of every name equivalent to N2.  */\n@@ -2310,7 +2302,7 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n    optimizers.  */\n \n tree\n-vr_values::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n+simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n     (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p)\n {\n   const value_range_equiv *vr0, *vr1;\n@@ -2331,11 +2323,12 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n /* Helper function for vrp_evaluate_conditional_warnv. */\n \n tree\n-vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n-\t\t\t\t\t\t    tree op0, tree op1,\n-\t\t\t\t\t\t    bool use_equiv_p,\n-\t\t\t\t\t\t    bool *strict_overflow_p,\n-\t\t\t\t\t\t    bool *only_ranges)\n+simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops\n+\t\t\t\t\t\t(enum tree_code code,\n+\t\t\t\t\t\t tree op0, tree op1,\n+\t\t\t\t\t\t bool use_equiv_p,\n+\t\t\t\t\t\t bool *strict_overflow_p,\n+\t\t\t\t\t\t bool *only_ranges)\n {\n   tree ret;\n   if (only_ranges)\n@@ -2438,8 +2431,8 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n    appropriate.  */\n \n tree\n-vr_values::vrp_evaluate_conditional (tree_code code, tree op0,\n-\t\t\t\t     tree op1, gimple *stmt)\n+simplify_using_ranges::vrp_evaluate_conditional (tree_code code, tree op0,\n+\t\t\t\t\t\t tree op1, gimple *stmt)\n {\n   bool sop;\n   tree ret;\n@@ -2531,7 +2524,7 @@ vr_values::vrp_evaluate_conditional (tree_code code, tree op0,\n    *TAKEN_EDGE_P.  Otherwise, set *TAKEN_EDGE_P to NULL.  */\n \n void\n-vr_values::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n+simplify_using_ranges::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n {\n   tree val;\n \n@@ -2551,7 +2544,7 @@ vr_values::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n \t  fprintf (dump_file, \"\\t\");\n \t  print_generic_expr (dump_file, use);\n \t  fprintf (dump_file, \": \");\n-\t  dump_value_range (dump_file, vr_value[SSA_NAME_VERSION (use)]);\n+\t  dump_value_range (dump_file, get_value_range (use));\n \t}\n \n       fprintf (dump_file, \"\\n\");\n@@ -2624,7 +2617,7 @@ vr_values::vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n    Returns true if the default label is not needed.  */\n \n static bool\n-find_case_label_ranges (gswitch *stmt, const value_range_equiv *vr,\n+find_case_label_ranges (gswitch *stmt, const value_range *vr,\n \t\t\tsize_t *min_idx1, size_t *max_idx1,\n \t\t\tsize_t *min_idx2, size_t *max_idx2)\n {\n@@ -2808,7 +2801,7 @@ vr_values::extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n   else if (is_gimple_assign (stmt) || is_gimple_call (stmt))\n     vrp_visit_assignment_or_call (stmt, output_p, vr);\n   else if (gimple_code (stmt) == GIMPLE_COND)\n-    vrp_visit_cond_stmt (as_a <gcond *> (stmt), taken_edge_p);\n+    simplifier.vrp_visit_cond_stmt (as_a <gcond *> (stmt), taken_edge_p);\n   else if (gimple_code (stmt) == GIMPLE_SWITCH)\n     vrp_visit_switch_stmt (as_a <gswitch *> (stmt), taken_edge_p);\n }\n@@ -3029,8 +3022,9 @@ vr_values::extract_range_from_phi_node (gphi *phi,\n /* Simplify boolean operations if the source is known\n    to be already a boolean.  */\n bool\n-vr_values::simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi,\n-\t\t\t\t\t    gimple *stmt)\n+simplify_using_ranges::simplify_truth_ops_using_ranges\n+\t\t\t\t\t(gimple_stmt_iterator *gsi,\n+\t\t\t\t\t gimple *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree lhs, op0, op1;\n@@ -3106,16 +3100,17 @@ vr_values::simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi,\n    modulo.  */\n \n bool\n-vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n-\t\t\t\t\t     gimple *stmt)\n+simplify_using_ranges::simplify_div_or_mod_using_ranges\n+\t\t\t\t\t(gimple_stmt_iterator *gsi,\n+\t\t\t\t\t gimple *stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n   tree val = NULL;\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n   tree op0min = NULL_TREE, op0max = NULL_TREE;\n   tree op1min = op1;\n-  const value_range_equiv *vr = NULL;\n+  const value_range *vr = NULL;\n \n   if (TREE_CODE (op0) == INTEGER_CST)\n     {\n@@ -3231,8 +3226,9 @@ vr_values::simplify_div_or_mod_using_ranges (gimple_stmt_iterator *gsi,\n    disjoint.   Return true if we do simplify.  */\n \n bool\n-vr_values::simplify_min_or_max_using_ranges (gimple_stmt_iterator *gsi,\n-\t\t\t\t\t     gimple *stmt)\n+simplify_using_ranges::simplify_min_or_max_using_ranges\n+\t\t\t\t(gimple_stmt_iterator *gsi,\n+\t\t\t\t gimple *stmt)\n {\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n@@ -3279,10 +3275,11 @@ vr_values::simplify_min_or_max_using_ranges (gimple_stmt_iterator *gsi,\n    ABS_EXPR into a NEGATE_EXPR.  */\n \n bool\n-vr_values::simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n+simplify_using_ranges::simplify_abs_using_ranges (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t\t  gimple *stmt)\n {\n   tree op = gimple_assign_rhs1 (stmt);\n-  const value_range_equiv *vr = get_value_range (op);\n+  const value_range *vr = get_value_range (op);\n \n   if (vr)\n     {\n@@ -3359,8 +3356,9 @@ vr_set_zero_nonzero_bits (const tree expr_type,\n    operation is redundant.  */\n \n bool\n-vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n-\t\t\t\t\t  gimple *stmt)\n+simplify_using_ranges::simplify_bit_ops_using_ranges\n+\t\t\t\t(gimple_stmt_iterator *gsi,\n+\t\t\t\t gimple *stmt)\n {\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n@@ -3444,7 +3442,7 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n \n static tree\n test_for_singularity (enum tree_code cond_code, tree op0,\n-\t\t      tree op1, const value_range_equiv *vr)\n+\t\t      tree op1, const value_range *vr)\n {\n   tree min = NULL;\n   tree max = NULL;\n@@ -3502,7 +3500,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n    by PRECISION and UNSIGNED_P.  */\n \n static bool\n-range_fits_type_p (const value_range_equiv *vr,\n+range_fits_type_p (const value_range *vr,\n \t\t   unsigned dest_precision, signop dest_sgn)\n {\n   tree src_type;\n@@ -3554,7 +3552,7 @@ range_fits_type_p (const value_range_equiv *vr,\n    conditional as such, and return TRUE.  */\n \n bool\n-vr_values::fold_cond (gcond *cond)\n+simplify_using_ranges::fold_cond (gcond *cond)\n {\n   /* ?? vrp_folder::fold_predicate_in() is a superset of this.  At\n      some point we should merge all variants of this code.  */\n@@ -3579,7 +3577,7 @@ vr_values::fold_cond (gcond *cond)\n    the original conditional.  */\n \n bool\n-vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n+simplify_using_ranges::simplify_cond_using_ranges_1 (gcond *stmt)\n {\n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n@@ -3594,7 +3592,7 @@ vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n       && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n       && is_gimple_min_invariant (op1))\n     {\n-      const value_range_equiv *vr = get_value_range (op0);\n+      const value_range *vr = get_value_range (op0);\n \n       /* If we have range information for OP0, then we might be\n \t able to simplify this conditional. */\n@@ -3667,7 +3665,7 @@ vr_values::simplify_cond_using_ranges_1 (gcond *stmt)\n    subsequent passes.  */\n \n void\n-vr_values::simplify_cond_using_ranges_2 (gcond *stmt)\n+simplify_cond_using_ranges_2 (vr_values *store, gcond *stmt)\n {\n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n@@ -3697,7 +3695,7 @@ vr_values::simplify_cond_using_ranges_2 (gcond *stmt)\n \t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop)\n \t  && desired_pro_or_demotion_p (TREE_TYPE (innerop), TREE_TYPE (op0)))\n \t{\n-\t  const value_range_equiv *vr = get_value_range (innerop);\n+\t  const value_range *vr = store->get_value_range (innerop);\n \n \t  if (range_int_cst_p (vr)\n \t      && range_fits_type_p (vr,\n@@ -3724,10 +3722,10 @@ vr_values::simplify_cond_using_ranges_2 (gcond *stmt)\n    argument.  */\n \n bool\n-vr_values::simplify_switch_using_ranges (gswitch *stmt)\n+simplify_using_ranges::simplify_switch_using_ranges (gswitch *stmt)\n {\n   tree op = gimple_switch_index (stmt);\n-  const value_range_equiv *vr = NULL;\n+  const value_range *vr = NULL;\n   bool take_default;\n   edge e;\n   edge_iterator ei;\n@@ -3905,7 +3903,7 @@ vr_values::simplify_switch_using_ranges (gswitch *stmt)\n }\n \n void\n-vr_values::cleanup_edges_and_switches (void)\n+simplify_using_ranges::cleanup_edges_and_switches (void)\n {\n   int i;\n   edge e;\n@@ -4023,11 +4021,12 @@ simplify_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n /* Simplify a conversion from integral SSA name to float in STMT.  */\n \n bool\n-vr_values::simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n-\t\t\t\t\t\t   gimple *stmt)\n+simplify_using_ranges::simplify_float_conversion_using_ranges\n+\t\t\t\t\t(gimple_stmt_iterator *gsi,\n+\t\t\t\t\t gimple *stmt)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n-  const value_range_equiv *vr = get_value_range (rhs1);\n+  const value_range *vr = get_value_range (rhs1);\n   scalar_float_mode fltmode\n     = SCALAR_FLOAT_TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)));\n   scalar_int_mode mode;\n@@ -4085,8 +4084,9 @@ vr_values::simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n /* Simplify an internal fn call using ranges if possible.  */\n \n bool\n-vr_values::simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi,\n-\t\t\t\t\t\tgimple *stmt)\n+simplify_using_ranges::simplify_internal_call_using_ranges\n+\t\t\t\t\t(gimple_stmt_iterator *gsi,\n+\t\t\t\t\t gimple *stmt)\n {\n   enum tree_code subcode;\n   bool is_ubsan = false;\n@@ -4131,7 +4131,7 @@ vr_values::simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi,\n     return false;\n   else\n     type = TREE_TYPE (TREE_TYPE (gimple_call_lhs (stmt)));\n-  if (!check_for_binary_op_overflow (subcode, type, op0, op1, &ovf)\n+  if (!check_for_binary_op_overflow (store, subcode, type, op0, op1, &ovf)\n       || (is_ubsan && ovf))\n     return false;\n \n@@ -4188,9 +4188,9 @@ vr_values::simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi,\n    two-values when it is true.  Return false otherwise.  */\n \n bool\n-vr_values::two_valued_val_range_p (tree var, tree *a, tree *b)\n+simplify_using_ranges::two_valued_val_range_p (tree var, tree *a, tree *b)\n {\n-  const value_range_equiv *vr = get_value_range (var);\n+  const value_range *vr = get_value_range (var);\n   if (vr->varying_p ()\n       || vr->undefined_p ()\n       || TREE_CODE (vr->min ()) != INTEGER_CST\n@@ -4220,10 +4220,22 @@ vr_values::two_valued_val_range_p (tree var, tree *a, tree *b)\n   return false;\n }\n \n+simplify_using_ranges::simplify_using_ranges (vr_values *store)\n+  : store (store)\n+{\n+  to_remove_edges = vNULL;\n+  to_update_switch_stmts = vNULL;\n+}\n+\n+simplify_using_ranges::~simplify_using_ranges ()\n+{\n+  cleanup_edges_and_switches ();\n+}\n+\n /* Simplify STMT using ranges if possible.  */\n \n bool\n-vr_values::simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n+simplify_using_ranges::simplify (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   if (is_gimple_assign (stmt))"}, {"sha": "62a20218c6d16a0a787b06652e3653d63813321c", "filename": "gcc/vr-values.h", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc36b97af05ef74b0889ba49090c2f52f00e0e77/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=fc36b97af05ef74b0889ba49090c2f52f00e0e77", "patch": "@@ -22,6 +22,65 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"value-range-equiv.h\"\n \n+// Class to simplify a statement using range information.\n+//\n+// The constructor takes a full vr_values, but all it needs is\n+// get_value_range() from it.  This class could be made to work with\n+// any range repository.\n+\n+class simplify_using_ranges\n+{\n+public:\n+  simplify_using_ranges (class vr_values *);\n+  ~simplify_using_ranges ();\n+  bool simplify (gimple_stmt_iterator *);\n+\n+  // ?? These should be cleaned, merged, and made private.\n+  tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n+  void vrp_visit_cond_stmt (gcond *, edge *);\n+  tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n+\t\t\t\t\t\ttree, tree, bool,\n+\t\t\t\t\t\tbool *, bool *);\n+\n+private:\n+  const value_range_equiv *get_value_range (const_tree op);\n+  bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_abs_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_bit_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_min_or_max_using_ranges (gimple_stmt_iterator *, gimple *);\n+  bool simplify_cond_using_ranges_1 (gcond *);\n+  bool fold_cond (gcond *);\n+  bool simplify_switch_using_ranges (gswitch *);\n+  bool simplify_float_conversion_using_ranges (gimple_stmt_iterator *,\n+\t\t\t\t\t       gimple *);\n+  bool simplify_internal_call_using_ranges (gimple_stmt_iterator *, gimple *);\n+\n+  bool two_valued_val_range_p (tree, tree *, tree *);\n+  bool op_with_boolean_value_range_p (tree);\n+  tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n+  tree compare_names (enum tree_code, tree, tree, bool *);\n+  const value_range_equiv *get_vr_for_comparison (int, value_range_equiv *);\n+  tree vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code,\n+\t\t\t\t\t\t\t     tree, tree,\n+\t\t\t\t\t\t\t     bool *);\n+  void cleanup_edges_and_switches (void);\n+\n+  /* Vectors of edges that need removing and switch statements that\n+     need updating.  It is expected that a pass using the simplification\n+     routines will, at the end of the pass, clean up the edges and\n+     switch statements.  The class dtor will try to detect cases\n+     that do not follow that expectation.  */\n+  struct switch_update {\n+    gswitch *stmt;\n+    tree vec;\n+  };\n+\n+  vec<edge> to_remove_edges;\n+  vec<switch_update> to_update_switch_stmts;\n+  class vr_values *store;\n+};\n+\n /* The VR_VALUES class holds the current view of range information\n    for all the SSA_NAMEs in the IL.\n \n@@ -52,7 +111,6 @@ class vr_values\n   tree op_with_constant_singleton_value_range (tree);\n   void adjust_range_with_scev (value_range_equiv *, class loop *,\n \t\t\t       gimple *, tree);\n-  tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n   void dump_all_value_ranges (FILE *);\n \n   void extract_range_for_var_from_comparison_expr (tree, enum tree_code,\n@@ -62,11 +120,6 @@ class vr_values\n   void extract_range_basic (value_range_equiv *, gimple *);\n   void extract_range_from_stmt (gimple *, edge *, tree *, value_range_equiv *);\n \n-  void vrp_visit_cond_stmt (gcond *, edge *);\n-\n-  void simplify_cond_using_ranges_2 (gcond *);\n-  bool simplify_stmt_using_ranges (gimple_stmt_iterator *);\n-\n   /* Indicate that propagation through the lattice is complete.  */\n   void set_lattice_propagation_complete (void) { values_propagated = true; }\n \n@@ -76,24 +129,9 @@ class vr_values\n   void free_value_range (value_range_equiv *vr)\n     { vrp_value_range_pool.remove (vr); }\n \n-  /* */\n-  void cleanup_edges_and_switches (void);\n-\n  private:\n   value_range_equiv *get_lattice_entry (const_tree);\n   bool vrp_stmt_computes_nonzero (gimple *);\n-  bool op_with_boolean_value_range_p (tree);\n-  bool check_for_binary_op_overflow (enum tree_code, tree, tree, tree, bool *);\n-  const value_range_equiv *get_vr_for_comparison (int, value_range_equiv *);\n-  tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n-  tree compare_names (enum tree_code, tree, tree, bool *);\n-  bool two_valued_val_range_p (tree, tree *, tree *);\n-  tree vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code,\n-\t\t\t\t\t\t\t     tree, tree,\n-\t\t\t\t\t\t\t     bool *);\n-  tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n-\t\t\t\t\t\ttree, tree, bool,\n-\t\t\t\t\t\tbool *, bool *);\n   void extract_range_from_assignment (value_range_equiv *, gassign *);\n   void extract_range_from_assert (value_range_equiv *, tree);\n   void extract_range_from_ssa_name (value_range_equiv *, tree);\n@@ -106,17 +144,6 @@ class vr_values\n \t\t\t\t      tree, tree, tree);\n   void vrp_visit_assignment_or_call (gimple*, tree *, value_range_equiv *);\n   void vrp_visit_switch_stmt (gswitch *, edge *);\n-  bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n-  bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n-  bool simplify_abs_using_ranges (gimple_stmt_iterator *, gimple *);\n-  bool simplify_bit_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n-  bool simplify_min_or_max_using_ranges (gimple_stmt_iterator *, gimple *);\n-  bool simplify_cond_using_ranges_1 (gcond *);\n-  bool fold_cond (gcond *);\n-  bool simplify_switch_using_ranges (gswitch *);\n-  bool simplify_float_conversion_using_ranges (gimple_stmt_iterator *,\n-\t\t\t\t\t       gimple *);\n-  bool simplify_internal_call_using_ranges (gimple_stmt_iterator *, gimple *);\n \n   /* Allocation pools for value_range objects.  */\n   object_allocator<value_range_equiv> vrp_value_range_pool;\n@@ -136,20 +163,18 @@ class vr_values\n      number of executable edges we saw the last time we visited the\n      node.  */\n   int *vr_phi_edge_counts;\n-\n-  /* Vectors of edges that need removing and switch statements that\n-     need updating.  It is expected that a pass using the simplification\n-     routines will, at the end of the pass, clean up the edges and\n-     switch statements.  The class dtor will try to detect cases\n-     that do not follow that expectation.  */\n-  struct switch_update {\n-    gswitch *stmt;\n-    tree vec;\n-  };\n-\n-  vec<edge> to_remove_edges;\n-  vec<switch_update> to_update_switch_stmts;\n+  simplify_using_ranges simplifier;\n };\n \n+inline const value_range_equiv *\n+simplify_using_ranges::get_value_range (const_tree op)\n+{\n+  return store->get_value_range (op);\n+}\n+\n extern tree get_output_for_vrp (gimple *);\n+\n+// FIXME: Move this to tree-vrp.c.\n+void simplify_cond_using_ranges_2 (class vr_values *, gcond *);\n+\n #endif /* GCC_VR_VALUES_H */"}]}