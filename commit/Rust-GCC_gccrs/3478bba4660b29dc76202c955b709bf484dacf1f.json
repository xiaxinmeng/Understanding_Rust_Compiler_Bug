{"sha": "3478bba4660b29dc76202c955b709bf484dacf1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ3OGJiYTQ2NjBiMjlkYzc2MjAyYzk1NWI3MDliZjQ4NGRhY2YxZg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-23T22:19:19Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-23T22:19:19Z"}, "message": "re PR libfortran/32972 (performance of pack/unpack)\n\n2007-03-23  Thomas Koenig  <tkoenig@gcc.gnu.org\n\n\tPR libfortran/32972\n\t* Makefile.am:  Add new variable, i_unpack_c, containing\n\tunpack_i1.c, unpack_i2.c, unpack_i4.c, unpack_i8.c,\n\tunpack_i16.c, unpack_r4.c, unpack_r8.c, unpack_r10.c,\n\tunpack_r16.c, unpack_c4.c, unpack_c8.c, unpack_c10.c\n\tand unpack_c16.c\n\tAdd i_unpack_c to gfor_built_src.\n\tAdd rule to generate i_unpack_c from m4/unpack.m4.\n\t* Makefile.in:  Regenerated.\n\t* libgfortran.h: Add prototypes for unpack0_i1, unpack0_i2,\n\tunpack0_i4, unpack0_i8, unpack0_i16, unpack0_r4, unpack0_r8,\n\tunpack0_r10, unpack0_r16, unpack0_c4, unpack0_c8, unpack0_c10,\n\tunpack0_c16, unpack1_i1, unpack1_i2, unpack1_i4, unpack1_i8,\n\tunpack1_i16, unpack1_r4, unpack1_r8, unpack1_r10, unpack1_r16,\n\tunpack1_c4, unpack1_c8, unpack1_c10 and unpack1_c16.\n\t* intrinsics/pack_generic.c (unpack1):  Add calls to specific\n\tunpack1 functions.\n\t(unpack0):  Add calls to specific unpack0 functions.\n\t* m4/unpack.m4:  New file.\n\t* generated/unpack_i1.c:  New file.\n\t* generated/unpack_i2.c:  New file.\n\t* generated/unpack_i4.c:  New file.\n\t* generated/unpack_i8.c:  New file.\n\t* generated/unpack_i16.c:  New file.\n\t* generated/unpack_r4.c:  New file.\n\t* generated/unpack_r8.c:  New file.\n\t* generated/unpack_r10.c:  New file.\n\t* generated/unpack_r16.c:  New file.\n\t* generated/unpack_c4.c:  New file.\n\t* generated/unpack_c8.c:  New file.\n\t* generated/unpack_c10.c:  New file.\n\t* generated/unpack_c16.c:  New file.\n\n2007-03-23  Thomas Koenig  <tkoenig@gcc.gnu.org\n\n\tPR libfortran/32972\n\t* gfortran.dg/intrinsic_unpack_1.f90:  New test case.\n\t* gfortran.dg/intrinsic_unpack_2.f90:  New test case.\n\t* gfortran.dg/intrinsic_unpack_3.f90:  New test case.\n\nFrom-SVN: r133469", "tree": {"sha": "b07d6c628b5ec47255fa6723cf727cb89ace575e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b07d6c628b5ec47255fa6723cf727cb89ace575e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3478bba4660b29dc76202c955b709bf484dacf1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3478bba4660b29dc76202c955b709bf484dacf1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3478bba4660b29dc76202c955b709bf484dacf1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3478bba4660b29dc76202c955b709bf484dacf1f/comments", "author": null, "committer": null, "parents": [{"sha": "2ff8644d33a8b9f3ca7c7c870c011a07da852ab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff8644d33a8b9f3ca7c7c870c011a07da852ab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ff8644d33a8b9f3ca7c7c870c011a07da852ab3"}], "stats": {"total": 5451, "additions": 5432, "deletions": 19}, "files": [{"sha": "50d7ded78c8a3e0e408a569d6337873223f573a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -1,3 +1,10 @@\n+2007-03-23  Thomas Koenig  <tkoenig@gcc.gnu.org\n+\n+\tPR libfortran/32972\n+\t* gfortran.dg/intrinsic_unpack_1.f90:  New test case.\n+\t* gfortran.dg/intrinsic_unpack_2.f90:  New test case.\n+\t* gfortran.dg/intrinsic_unpack_3.f90:  New test case.\n+\n 2008-03-22  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* gcc.target/mips/dse-1.c: Add checks for zeros."}, {"sha": "f73fcc1def9cd05e26d5709d9dc8afc3ff6f994b", "filename": "gcc/testsuite/gfortran.dg/intrinsic_unpack_1.f90", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_1.f90?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do run }\n+! Program to test the UNPACK intrinsic for the types usually present.\n+program intrinsic_unpack\n+   implicit none\n+   integer(kind=1), dimension(3, 3) :: a1, b1\n+   integer(kind=2), dimension(3, 3) :: a2, b2\n+   integer(kind=4), dimension(3, 3) :: a4, b4\n+   integer(kind=8), dimension(3, 3) :: a8, b8\n+   real(kind=4), dimension(3,3) :: ar4, br4\n+   real(kind=8), dimension(3,3) :: ar8, br8\n+   logical, dimension(3, 3) :: mask\n+   character(len=100) line1, line2\n+   integer i\n+\n+   mask = reshape ((/.false.,.true.,.false.,.true.,.false.,.false.,&\n+                    &.false.,.false.,.true./), (/3, 3/));\n+   a1 = reshape ((/1, 0, 0, 0, 1, 0, 0, 0, 1/), (/3, 3/));\n+   b1 = unpack ((/2_1, 3_1, 4_1/), mask, a1)\n+   if (any (b1 .ne. reshape ((/1, 2, 0, 3, 1, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(10I4)') b1\n+   write (line2,'(10I4)') unpack((/2_1, 3_1, 4_1/), mask, a1)\n+   if (line1 .ne. line2) call abort\n+   b1 = -1\n+   b1 = unpack ((/2_1, 3_1, 4_1/), mask, 0_1)\n+   if (any (b1 .ne. reshape ((/0, 2, 0, 3, 0, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+\n+   a2 = reshape ((/1, 0, 0, 0, 1, 0, 0, 0, 1/), (/3, 3/));\n+   b2 = unpack ((/2_2, 3_2, 4_2/), mask, a2)\n+   if (any (b2 .ne. reshape ((/1, 2, 0, 3, 1, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(10I4)') b2\n+   write (line2,'(10I4)') unpack((/2_2, 3_2, 4_2/), mask, a2)\n+   if (line1 .ne. line2) call abort\n+   b2 = -1\n+   b2 = unpack ((/2_2, 3_2, 4_2/), mask, 0_2)\n+   if (any (b2 .ne. reshape ((/0, 2, 0, 3, 0, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+\n+   a4 = reshape ((/1, 0, 0, 0, 1, 0, 0, 0, 1/), (/3, 3/));\n+   b4 = unpack ((/2_4, 3_4, 4_4/), mask, a4)\n+   if (any (b4 .ne. reshape ((/1, 2, 0, 3, 1, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(10I4)') b4\n+   write (line2,'(10I4)') unpack((/2_4, 3_4, 4_4/), mask, a4)\n+   if (line1 .ne. line2) call abort\n+   b4 = -1\n+   b4 = unpack ((/2_4, 3_4, 4_4/), mask, 0_4)\n+   if (any (b4 .ne. reshape ((/0, 2, 0, 3, 0, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+\n+   a8 = reshape ((/1, 0, 0, 0, 1, 0, 0, 0, 1/), (/3, 3/));\n+   b8 = unpack ((/2_8, 3_8, 4_8/), mask, a8)\n+   if (any (b8 .ne. reshape ((/1, 2, 0, 3, 1, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(10I4)') b8\n+   write (line2,'(10I4)') unpack((/2_8, 3_8, 4_8/), mask, a8)\n+   if (line1 .ne. line2) call abort\n+   b8 = -1\n+   b8 = unpack ((/2_8, 3_8, 4_8/), mask, 0_8)\n+   if (any (b8 .ne. reshape ((/0, 2, 0, 3, 0, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+\n+   ar4 = reshape ((/1._4, 0._4, 0._4, 0._4, 1._4, 0._4, 0._4, 0._4, 1._4/), &\n+         (/3, 3/));\n+   br4 = unpack ((/2._4, 3._4, 4._4/), mask, ar4)\n+   if (any (br4 .ne. reshape ((/1._4, 2._4, 0._4, 3._4, 1._4, 0._4, &\n+                               0._4, 0._4, 4._4/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(9F9.5)') br4\n+   write (line2,'(9F9.5)') unpack((/2._4, 3._4, 4._4/), mask, ar4)\n+   if (line1 .ne. line2) call abort\n+   br4 = -1._4\n+   br4 = unpack ((/2._4, 3._4, 4._4/), mask, 0._4)\n+   if (any (br4 .ne. reshape ((/0._4, 2._4, 0._4, 3._4, 0._4, 0._4, &\n+      0._4, 0._4, 4._4/), (/3, 3/)))) &\n+      call abort\n+\n+   ar8 = reshape ((/1._8, 0._8, 0._8, 0._8, 1._8, 0._8, 0._8, 0._8, 1._8/), &\n+         (/3, 3/));\n+   br8 = unpack ((/2._8, 3._8, 4._8/), mask, ar8)\n+   if (any (br8 .ne. reshape ((/1._8, 2._8, 0._8, 3._8, 1._8, 0._8, &\n+                               0._8, 0._8, 4._8/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(9F9.5)') br8\n+   write (line2,'(9F9.5)') unpack((/2._8, 3._8, 4._8/), mask, ar8)\n+   if (line1 .ne. line2) call abort\n+   br8 = -1._8\n+   br8 = unpack ((/2._8, 3._8, 4._8/), mask, 0._8)\n+   if (any (br8 .ne. reshape ((/0._8, 2._8, 0._8, 3._8, 0._8, 0._8, &\n+      0._8, 0._8, 4._8/), (/3, 3/)))) &\n+      call abort\n+\n+end program"}, {"sha": "613f70a1f077464a46edc5b8cc86673a1dae0a2d", "filename": "gcc/testsuite/gfortran.dg/intrinsic_unpack_2.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_2.f90?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_real }\n+! Program to test the UNPACK intrinsic for large real type\n+program intrinsic_unpack\n+   implicit none\n+   integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+\n+   real(kind=k), dimension(3,3) :: ark, brk\n+   logical, dimension(3, 3) :: mask\n+   character(len=100) line1, line2\n+   integer i\n+\n+   mask = reshape ((/.false.,.true.,.false.,.true.,.false.,.false.,&\n+                    &.false.,.false.,.true./), (/3, 3/));\n+\n+   ark = reshape ((/1._k, 0._k, 0._k, 0._k, 1._k, 0._k, 0._k, 0._k, 1._k/), &\n+         (/3, 3/));\n+   brk = unpack ((/2._k, 3._k, 4._k/), mask, ark)\n+   if (any (brk .ne. reshape ((/1._k, 2._k, 0._k, 3._k, 1._k, 0._k, &\n+                               0._k, 0._k, 4._k/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(9F9.5)') brk\n+   write (line2,'(9F9.5)') unpack((/2._k, 3._k, 4._k/), mask, ark)\n+   if (line1 .ne. line2) call abort\n+   brk = -1._k\n+   brk = unpack ((/2._k, 3._k, 4._k/), mask, 0._k)\n+   if (any (brk .ne. reshape ((/0._k, 2._k, 0._k, 3._k, 0._k, 0._k, &\n+      0._k, 0._k, 4._k/), (/3, 3/)))) &\n+      call abort\n+\n+end program"}, {"sha": "4a4443facf5a73e7dd50b62af243c0531e3b5dd4", "filename": "gcc/testsuite/gfortran.dg/intrinsic_unpack_3.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_unpack_3.f90?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_int }\n+! Program to test the UNPACK intrinsic for a long integer type\n+program intrinsic_unpack\n+   implicit none\n+   integer,parameter :: k = selected_int_kind (range (0_8) + 1)\n+   integer(kind=k), dimension(3, 3) :: ak, bk\n+   logical, dimension(3, 3) :: mask\n+   character(len=100) line1, line2\n+   integer i\n+\n+   mask = reshape ((/.false.,.true.,.false.,.true.,.false.,.false.,&\n+                    &.false.,.false.,.true./), (/3, 3/));\n+\n+   ak = reshape ((/1, 0, 0, 0, 1, 0, 0, 0, 1/), (/3, 3/));\n+   bk = unpack ((/2_k, 3_k, 4_k/), mask, ak)\n+   if (any (bk .ne. reshape ((/1, 2, 0, 3, 1, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+   write (line1,'(10I4)') bk\n+   write (line2,'(10I4)') unpack((/2_k, 3_k, 4_k/), mask, ak)\n+   if (line1 .ne. line2) call abort\n+   bk = -1\n+   bk = unpack ((/2_k, 3_k, 4_k/), mask, 0_k)\n+   if (any (bk .ne. reshape ((/0, 2, 0, 3, 0, 0, 0, 0, 4/), (/3, 3/)))) &\n+      call abort\n+\n+end program"}, {"sha": "6ac6dfe89d0f75ff4589700ba9eadbf712137d31", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -1,3 +1,38 @@\n+2007-03-23  Thomas Koenig  <tkoenig@gcc.gnu.org\n+\n+\tPR libfortran/32972\n+\t* Makefile.am:  Add new variable, i_unpack_c, containing\n+\tunpack_i1.c, unpack_i2.c, unpack_i4.c, unpack_i8.c,\n+\tunpack_i16.c, unpack_r4.c, unpack_r8.c, unpack_r10.c,\n+\tunpack_r16.c, unpack_c4.c, unpack_c8.c, unpack_c10.c\n+\tand unpack_c16.c\n+\tAdd i_unpack_c to gfor_built_src.\n+\tAdd rule to generate i_unpack_c from m4/unpack.m4.\n+\t* Makefile.in:  Regenerated.\n+\t* libgfortran.h: Add prototypes for unpack0_i1, unpack0_i2,\n+\tunpack0_i4, unpack0_i8, unpack0_i16, unpack0_r4, unpack0_r8,\n+\tunpack0_r10, unpack0_r16, unpack0_c4, unpack0_c8, unpack0_c10,\n+\tunpack0_c16, unpack1_i1, unpack1_i2, unpack1_i4, unpack1_i8,\n+\tunpack1_i16, unpack1_r4, unpack1_r8, unpack1_r10, unpack1_r16,\n+\tunpack1_c4, unpack1_c8, unpack1_c10 and unpack1_c16.\n+\t* intrinsics/pack_generic.c (unpack1):  Add calls to specific\n+\tunpack1 functions.\n+\t(unpack0):  Add calls to specific unpack0 functions.\n+\t* m4/unpack.m4:  New file.\n+\t* generated/unpack_i1.c:  New file.\n+\t* generated/unpack_i2.c:  New file.\n+\t* generated/unpack_i4.c:  New file.\n+\t* generated/unpack_i8.c:  New file.\n+\t* generated/unpack_i16.c:  New file.\n+\t* generated/unpack_r4.c:  New file.\n+\t* generated/unpack_r8.c:  New file.\n+\t* generated/unpack_r10.c:  New file.\n+\t* generated/unpack_r16.c:  New file.\n+\t* generated/unpack_c4.c:  New file.\n+\t* generated/unpack_c8.c:  New file.\n+\t* generated/unpack_c10.c:  New file.\n+\t* generated/unpack_c16.c:  New file.\n+\n 2008-03-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/35632"}, {"sha": "4e9655a6071feeee28dfa72d410062b8f13cf0d6", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -491,6 +491,21 @@ $(srcdir)/generated/pack_c8.c \\\n $(srcdir)/generated/pack_c10.c \\\n $(srcdir)/generated/pack_c16.c\n \n+i_unpack_c = \\\n+$(srcdir)/generated/unpack_i1.c \\\n+$(srcdir)/generated/unpack_i2.c \\\n+$(srcdir)/generated/unpack_i4.c \\\n+$(srcdir)/generated/unpack_i8.c \\\n+$(srcdir)/generated/unpack_i16.c \\\n+$(srcdir)/generated/unpack_r4.c \\\n+$(srcdir)/generated/unpack_r8.c \\\n+$(srcdir)/generated/unpack_r10.c \\\n+$(srcdir)/generated/unpack_r16.c \\\n+$(srcdir)/generated/unpack_c4.c \\\n+$(srcdir)/generated/unpack_c8.c \\\n+$(srcdir)/generated/unpack_c10.c \\\n+$(srcdir)/generated/unpack_c16.c\n+\n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -499,15 +514,16 @@ m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n-    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4\n+    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n+    m4/unpack.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n     $(i_product_c) $(i_sum_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n-    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) \\\n+    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n     selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     kinds.inc c99_protos.inc fpu-target.h\n \n@@ -826,6 +842,9 @@ $(i_pow_c): m4/pow.m4 $(I_M4_DEPS)\n $(i_pack_c): m4/pack.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 pack.m4 > $@\n \n+$(i_unpack_c): m4/unpack.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 unpack.m4 > $@\n+\n $(gfor_built_specific_src): m4/specific.m4 m4/head.m4\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $@\n "}, {"sha": "fb6056f2d5ce1d5d0209b2ceea06dde1be3f794f", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 154, "deletions": 15, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -370,7 +370,19 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \t$(srcdir)/generated/pack_r8.c $(srcdir)/generated/pack_r10.c \\\n \t$(srcdir)/generated/pack_r16.c $(srcdir)/generated/pack_c4.c \\\n \t$(srcdir)/generated/pack_c8.c $(srcdir)/generated/pack_c10.c \\\n-\t$(srcdir)/generated/pack_c16.c selected_int_kind.inc \\\n+\t$(srcdir)/generated/pack_c16.c $(srcdir)/generated/unpack_i1.c \\\n+\t$(srcdir)/generated/unpack_i2.c \\\n+\t$(srcdir)/generated/unpack_i4.c \\\n+\t$(srcdir)/generated/unpack_i8.c \\\n+\t$(srcdir)/generated/unpack_i16.c \\\n+\t$(srcdir)/generated/unpack_r4.c \\\n+\t$(srcdir)/generated/unpack_r8.c \\\n+\t$(srcdir)/generated/unpack_r10.c \\\n+\t$(srcdir)/generated/unpack_r16.c \\\n+\t$(srcdir)/generated/unpack_c4.c \\\n+\t$(srcdir)/generated/unpack_c8.c \\\n+\t$(srcdir)/generated/unpack_c10.c \\\n+\t$(srcdir)/generated/unpack_c16.c selected_int_kind.inc \\\n \tselected_real_kind.inc kinds.h kinds.inc c99_protos.inc \\\n \tfpu-target.h io/close.c io/file_pos.c io/format.c io/inquire.c \\\n \tio/intrinsics.c io/list_read.c io/lock.c io/open.c io/read.c \\\n@@ -643,7 +655,11 @@ am__objects_29 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \\\n am__objects_30 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \\\n \tpack_i16.lo pack_r4.lo pack_r8.lo pack_r10.lo pack_r16.lo \\\n \tpack_c4.lo pack_c8.lo pack_c10.lo pack_c16.lo\n-am__objects_31 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n+am__objects_31 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \\\n+\tunpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \\\n+\tunpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \\\n+\tunpack_c16.lo\n+am__objects_32 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_5) $(am__objects_6) $(am__objects_7) \\\n \t$(am__objects_8) $(am__objects_9) $(am__objects_10) \\\n \t$(am__objects_11) $(am__objects_12) $(am__objects_13) \\\n@@ -652,11 +668,11 @@ am__objects_31 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_20) $(am__objects_21) $(am__objects_22) \\\n \t$(am__objects_23) $(am__objects_24) $(am__objects_25) \\\n \t$(am__objects_26) $(am__objects_27) $(am__objects_28) \\\n-\t$(am__objects_29) $(am__objects_30)\n-am__objects_32 = close.lo file_pos.lo format.lo inquire.lo \\\n+\t$(am__objects_29) $(am__objects_30) $(am__objects_31)\n+am__objects_33 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n \tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo\n-am__objects_33 = associated.lo abort.lo access.lo args.lo \\\n+am__objects_34 = associated.lo abort.lo access.lo args.lo \\\n \tc99_functions.lo chdir.lo chmod.lo clock.lo cpu_time.lo \\\n \tcshift0.lo ctime.lo date_and_time.lo dtime.lo env.lo \\\n \teoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \\\n@@ -670,8 +686,8 @@ am__objects_33 = associated.lo abort.lo access.lo args.lo \\\n \tsystem_clock.lo time.lo transpose_generic.lo umask.lo \\\n \tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n-am__objects_34 =\n-am__objects_35 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_35 =\n+am__objects_36 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -695,18 +711,18 @@ am__objects_35 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_36 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_37 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_37 = misc_specifics.lo\n-am__objects_38 = $(am__objects_35) $(am__objects_36) $(am__objects_37) \\\n+am__objects_38 = misc_specifics.lo\n+am__objects_39 = $(am__objects_36) $(am__objects_37) $(am__objects_38) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_39 = $(am__objects_1) $(am__objects_31) $(am__objects_32) \\\n-\t$(am__objects_33) $(am__objects_34) $(am__objects_38)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_39)\n+am__objects_40 = $(am__objects_1) $(am__objects_32) $(am__objects_33) \\\n+\t$(am__objects_34) $(am__objects_35) $(am__objects_39)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_40)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n libgfortranbegin_la_LIBADD =\n@@ -1355,6 +1371,21 @@ $(srcdir)/generated/pack_c8.c \\\n $(srcdir)/generated/pack_c10.c \\\n $(srcdir)/generated/pack_c16.c\n \n+i_unpack_c = \\\n+$(srcdir)/generated/unpack_i1.c \\\n+$(srcdir)/generated/unpack_i2.c \\\n+$(srcdir)/generated/unpack_i4.c \\\n+$(srcdir)/generated/unpack_i8.c \\\n+$(srcdir)/generated/unpack_i16.c \\\n+$(srcdir)/generated/unpack_r4.c \\\n+$(srcdir)/generated/unpack_r8.c \\\n+$(srcdir)/generated/unpack_r10.c \\\n+$(srcdir)/generated/unpack_r16.c \\\n+$(srcdir)/generated/unpack_c4.c \\\n+$(srcdir)/generated/unpack_c8.c \\\n+$(srcdir)/generated/unpack_c10.c \\\n+$(srcdir)/generated/unpack_c16.c\n+\n m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -1363,15 +1394,16 @@ m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n-    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4\n+    m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n+    m4/unpack.m4\n \n gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n     $(i_product_c) $(i_sum_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n-    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) \\\n+    $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n     selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     kinds.inc c99_protos.inc fpu-target.h\n \n@@ -2061,7 +2093,20 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unit.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unlink.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_generic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write.Plo@am__quote@\n \n .F90.o:\n@@ -4748,6 +4793,97 @@ pack_c16.lo: $(srcdir)/generated/pack_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o pack_c16.lo `test -f '$(srcdir)/generated/pack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/pack_c16.c\n \n+unpack_i1.lo: $(srcdir)/generated/unpack_i1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_i1.lo -MD -MP -MF \"$(DEPDIR)/unpack_i1.Tpo\" -c -o unpack_i1.lo `test -f '$(srcdir)/generated/unpack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_i1.Tpo\" \"$(DEPDIR)/unpack_i1.Plo\"; else rm -f \"$(DEPDIR)/unpack_i1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_i1.c' object='unpack_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_i1.lo `test -f '$(srcdir)/generated/unpack_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i1.c\n+\n+unpack_i2.lo: $(srcdir)/generated/unpack_i2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_i2.lo -MD -MP -MF \"$(DEPDIR)/unpack_i2.Tpo\" -c -o unpack_i2.lo `test -f '$(srcdir)/generated/unpack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_i2.Tpo\" \"$(DEPDIR)/unpack_i2.Plo\"; else rm -f \"$(DEPDIR)/unpack_i2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_i2.c' object='unpack_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_i2.lo `test -f '$(srcdir)/generated/unpack_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i2.c\n+\n+unpack_i4.lo: $(srcdir)/generated/unpack_i4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_i4.lo -MD -MP -MF \"$(DEPDIR)/unpack_i4.Tpo\" -c -o unpack_i4.lo `test -f '$(srcdir)/generated/unpack_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_i4.Tpo\" \"$(DEPDIR)/unpack_i4.Plo\"; else rm -f \"$(DEPDIR)/unpack_i4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_i4.c' object='unpack_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_i4.lo `test -f '$(srcdir)/generated/unpack_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i4.c\n+\n+unpack_i8.lo: $(srcdir)/generated/unpack_i8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_i8.lo -MD -MP -MF \"$(DEPDIR)/unpack_i8.Tpo\" -c -o unpack_i8.lo `test -f '$(srcdir)/generated/unpack_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_i8.Tpo\" \"$(DEPDIR)/unpack_i8.Plo\"; else rm -f \"$(DEPDIR)/unpack_i8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_i8.c' object='unpack_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_i8.lo `test -f '$(srcdir)/generated/unpack_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i8.c\n+\n+unpack_i16.lo: $(srcdir)/generated/unpack_i16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_i16.lo -MD -MP -MF \"$(DEPDIR)/unpack_i16.Tpo\" -c -o unpack_i16.lo `test -f '$(srcdir)/generated/unpack_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_i16.Tpo\" \"$(DEPDIR)/unpack_i16.Plo\"; else rm -f \"$(DEPDIR)/unpack_i16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_i16.c' object='unpack_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_i16.lo `test -f '$(srcdir)/generated/unpack_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_i16.c\n+\n+unpack_r4.lo: $(srcdir)/generated/unpack_r4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_r4.lo -MD -MP -MF \"$(DEPDIR)/unpack_r4.Tpo\" -c -o unpack_r4.lo `test -f '$(srcdir)/generated/unpack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_r4.Tpo\" \"$(DEPDIR)/unpack_r4.Plo\"; else rm -f \"$(DEPDIR)/unpack_r4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_r4.c' object='unpack_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_r4.lo `test -f '$(srcdir)/generated/unpack_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r4.c\n+\n+unpack_r8.lo: $(srcdir)/generated/unpack_r8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_r8.lo -MD -MP -MF \"$(DEPDIR)/unpack_r8.Tpo\" -c -o unpack_r8.lo `test -f '$(srcdir)/generated/unpack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_r8.Tpo\" \"$(DEPDIR)/unpack_r8.Plo\"; else rm -f \"$(DEPDIR)/unpack_r8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_r8.c' object='unpack_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_r8.lo `test -f '$(srcdir)/generated/unpack_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r8.c\n+\n+unpack_r10.lo: $(srcdir)/generated/unpack_r10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_r10.lo -MD -MP -MF \"$(DEPDIR)/unpack_r10.Tpo\" -c -o unpack_r10.lo `test -f '$(srcdir)/generated/unpack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_r10.Tpo\" \"$(DEPDIR)/unpack_r10.Plo\"; else rm -f \"$(DEPDIR)/unpack_r10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_r10.c' object='unpack_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_r10.lo `test -f '$(srcdir)/generated/unpack_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r10.c\n+\n+unpack_r16.lo: $(srcdir)/generated/unpack_r16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_r16.lo -MD -MP -MF \"$(DEPDIR)/unpack_r16.Tpo\" -c -o unpack_r16.lo `test -f '$(srcdir)/generated/unpack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_r16.Tpo\" \"$(DEPDIR)/unpack_r16.Plo\"; else rm -f \"$(DEPDIR)/unpack_r16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_r16.c' object='unpack_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_r16.lo `test -f '$(srcdir)/generated/unpack_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_r16.c\n+\n+unpack_c4.lo: $(srcdir)/generated/unpack_c4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_c4.lo -MD -MP -MF \"$(DEPDIR)/unpack_c4.Tpo\" -c -o unpack_c4.lo `test -f '$(srcdir)/generated/unpack_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_c4.Tpo\" \"$(DEPDIR)/unpack_c4.Plo\"; else rm -f \"$(DEPDIR)/unpack_c4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_c4.c' object='unpack_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_c4.lo `test -f '$(srcdir)/generated/unpack_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c4.c\n+\n+unpack_c8.lo: $(srcdir)/generated/unpack_c8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_c8.lo -MD -MP -MF \"$(DEPDIR)/unpack_c8.Tpo\" -c -o unpack_c8.lo `test -f '$(srcdir)/generated/unpack_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_c8.Tpo\" \"$(DEPDIR)/unpack_c8.Plo\"; else rm -f \"$(DEPDIR)/unpack_c8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_c8.c' object='unpack_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_c8.lo `test -f '$(srcdir)/generated/unpack_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c8.c\n+\n+unpack_c10.lo: $(srcdir)/generated/unpack_c10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_c10.lo -MD -MP -MF \"$(DEPDIR)/unpack_c10.Tpo\" -c -o unpack_c10.lo `test -f '$(srcdir)/generated/unpack_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_c10.Tpo\" \"$(DEPDIR)/unpack_c10.Plo\"; else rm -f \"$(DEPDIR)/unpack_c10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_c10.c' object='unpack_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_c10.lo `test -f '$(srcdir)/generated/unpack_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c10.c\n+\n+unpack_c16.lo: $(srcdir)/generated/unpack_c16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unpack_c16.lo -MD -MP -MF \"$(DEPDIR)/unpack_c16.Tpo\" -c -o unpack_c16.lo `test -f '$(srcdir)/generated/unpack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/unpack_c16.Tpo\" \"$(DEPDIR)/unpack_c16.Plo\"; else rm -f \"$(DEPDIR)/unpack_c16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/unpack_c16.c' object='unpack_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_c16.lo `test -f '$(srcdir)/generated/unpack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c16.c\n+\n close.lo: io/close.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT close.lo -MD -MP -MF \"$(DEPDIR)/close.Tpo\" -c -o close.lo `test -f 'io/close.c' || echo '$(srcdir)/'`io/close.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/close.Tpo\" \"$(DEPDIR)/close.Plo\"; else rm -f \"$(DEPDIR)/close.Tpo\"; exit 1; fi\n@@ -5702,6 +5838,9 @@ fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n @MAINTAINER_MODE_TRUE@$(i_pack_c): m4/pack.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 pack.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_unpack_c): m4/unpack.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 unpack.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(gfor_built_specific_src): m4/specific.m4 m4/head.m4\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $@\n "}, {"sha": "e6f3ecf265216d6a812fc9d130ac1a922910316f", "filename": "libgfortran/generated/unpack_c10.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c10.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+void\n+unpack0_c10 (gfc_array_c10 *ret, const gfc_array_c10 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_COMPLEX_10 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_10 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_10 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_COMPLEX_10 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_10));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_c10 (gfc_array_c10 *ret, const gfc_array_c10 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_c10 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_10 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_10 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_COMPLEX_10 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_10));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "2d82a10fc84390b0099753d8702bbba05f651475", "filename": "libgfortran/generated/unpack_c16.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c16.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+void\n+unpack0_c16 (gfc_array_c16 *ret, const gfc_array_c16 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_COMPLEX_16 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_16 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_16 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_COMPLEX_16 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_16));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_c16 (gfc_array_c16 *ret, const gfc_array_c16 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_c16 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_16 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_16 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_COMPLEX_16 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_16));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "472ce48c26e18c1c14e1e31e0373b32ae374a691", "filename": "libgfortran/generated/unpack_c4.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c4.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n+void\n+unpack0_c4 (gfc_array_c4 *ret, const gfc_array_c4 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_COMPLEX_4 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_4 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_4 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_COMPLEX_4 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_4));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_c4 (gfc_array_c4 *ret, const gfc_array_c4 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_c4 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_4 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_4 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_COMPLEX_4 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_4));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "62116b78bb2588eb55463823e7842a2ce64f0456", "filename": "libgfortran/generated/unpack_c8.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c8.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n+void\n+unpack0_c8 (gfc_array_c8 *ret, const gfc_array_c8 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_COMPLEX_8 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_8 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_8 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_COMPLEX_8 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_8));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_c8 (gfc_array_c8 *ret, const gfc_array_c8 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_c8 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_COMPLEX_8 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_COMPLEX_8 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_COMPLEX_8 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_COMPLEX_8));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "46a9d4eb6f2005c8b37e3c6b0cd0f983d5fc5c03", "filename": "libgfortran/generated/unpack_i1.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i1.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+void\n+unpack0_i1 (gfc_array_i1 *ret, const gfc_array_i1 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_INTEGER_1 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_1 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_1 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_INTEGER_1 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_1));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_i1 (gfc_array_i1 *ret, const gfc_array_i1 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_i1 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_1 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_1 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_INTEGER_1 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_1));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "0fbd7449ffeb07b2bfc1e4499cd0351446f3bc69", "filename": "libgfortran/generated/unpack_i16.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i16.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+unpack0_i16 (gfc_array_i16 *ret, const gfc_array_i16 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_INTEGER_16 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_16 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_16 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_INTEGER_16 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_i16 (gfc_array_i16 *ret, const gfc_array_i16 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_i16 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_16 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_16 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_INTEGER_16 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "096c7858de1c4fe79e9cd575fa33a031673fc9b0", "filename": "libgfortran/generated/unpack_i2.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i2.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+void\n+unpack0_i2 (gfc_array_i2 *ret, const gfc_array_i2 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_INTEGER_2 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_2 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_2 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_INTEGER_2 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_2));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_i2 (gfc_array_i2 *ret, const gfc_array_i2 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_i2 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_2 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_2 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_INTEGER_2 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_2));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "08f197c376c7cfe1422595d3826a5e2ce62b2e78", "filename": "libgfortran/generated/unpack_i4.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i4.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+unpack0_i4 (gfc_array_i4 *ret, const gfc_array_i4 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_INTEGER_4 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_4 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_4 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_INTEGER_4 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_i4 (gfc_array_i4 *ret, const gfc_array_i4 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_i4 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_4 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_4 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_INTEGER_4 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "0847c1fa0daca1ee4e4d45e49d19515741a13b80", "filename": "libgfortran/generated/unpack_i8.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_i8.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+unpack0_i8 (gfc_array_i8 *ret, const gfc_array_i8 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_INTEGER_8 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_8 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_8 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_INTEGER_8 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_i8 (gfc_array_i8 *ret, const gfc_array_i8 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_i8 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_INTEGER_8 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_INTEGER_8 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_INTEGER_8 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "694d2c542eee2c09fd8c6c01855f76c52a3849f1", "filename": "libgfortran/generated/unpack_r10.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r10.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+void\n+unpack0_r10 (gfc_array_r10 *ret, const gfc_array_r10 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_REAL_10 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_10 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_10 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_REAL_10 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_10));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_r10 (gfc_array_r10 *ret, const gfc_array_r10 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_r10 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_10 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_10 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_REAL_10 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_10));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "65121c1b90ecfaa201bcabd1176664e14b7ee33a", "filename": "libgfortran/generated/unpack_r16.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r16.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+void\n+unpack0_r16 (gfc_array_r16 *ret, const gfc_array_r16 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_REAL_16 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_16 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_16 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_REAL_16 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_16));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_r16 (gfc_array_r16 *ret, const gfc_array_r16 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_r16 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_16 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_16 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_REAL_16 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_16));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "b9983182b6f406902ed49c48dd3314b8ca5a5da2", "filename": "libgfortran/generated/unpack_r4.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r4.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+void\n+unpack0_r4 (gfc_array_r4 *ret, const gfc_array_r4 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_REAL_4 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_4 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_4 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_REAL_4 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_4));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_r4 (gfc_array_r4 *ret, const gfc_array_r4 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_r4 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_4 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_4 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_REAL_4 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_4));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "cccf7596f9bcf5bbd7256f86ce4d9a893ba65961", "filename": "libgfortran/generated/unpack_r8.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fgenerated%2Funpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r8.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,338 @@\n+/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+void\n+unpack0_r8 (gfc_array_r8 *ret, const gfc_array_r8 *vector,\n+\t\t const gfc_array_l1 *mask, const GFC_REAL_8 *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_8 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_8 *vptr;\n+  /* Value for field, this is constant.  */\n+  const GFC_REAL_8 fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_8));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_r8 (gfc_array_r8 *ret, const gfc_array_r8 *vector,\n+\t\t const gfc_array_l1 *mask, const gfc_array_r8 *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  GFC_REAL_8 *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  GFC_REAL_8 *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const GFC_REAL_8 *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof (GFC_REAL_8));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "145dd350568fa59679497d26dda1874c4fcb40aa", "filename": "libgfortran/intrinsics/unpack_generic.c", "status": "modified", "additions": 193, "deletions": 2, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fintrinsics%2Funpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fintrinsics%2Funpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Funpack_generic.c?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -196,8 +196,103 @@ void\n unpack1 (gfc_array_char *ret, const gfc_array_char *vector,\n \t const gfc_array_l1 *mask, const gfc_array_char *field)\n {\n-  unpack_internal (ret, vector, mask, field,\n-\t\t   GFC_DESCRIPTOR_SIZE (vector),\n+  int type;\n+  index_type size;\n+\n+  type = GFC_DESCRIPTOR_TYPE (vector);\n+  size = GFC_DESCRIPTOR_SIZE (vector);\n+\n+  switch(type)\n+    {\n+    case GFC_DTYPE_INTEGER:\n+    case GFC_DTYPE_LOGICAL:\n+      switch(size)\n+\t{\n+\tcase sizeof (GFC_INTEGER_1):\n+\t  unpack1_i1 ((gfc_array_i1 *) ret, (gfc_array_i1 *) vector,\n+\t\t      mask, (gfc_array_i1 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_2):\n+\t  unpack1_i2 ((gfc_array_i2 *) ret, (gfc_array_i2 *) vector,\n+\t\t      mask, (gfc_array_i2 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_4):\n+\t  unpack1_i4 ((gfc_array_i4 *) ret, (gfc_array_i4 *) vector,\n+\t\t      mask, (gfc_array_i4 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_8):\n+\t  unpack1_i8 ((gfc_array_i8 *) ret, (gfc_array_i8 *) vector,\n+\t\t      mask, (gfc_array_i8 *) field);\n+\t  return;\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+\tcase sizeof (GFC_INTEGER_16):\n+\t  unpack1_i16 ((gfc_array_i16 *) ret, (gfc_array_i16 *) vector,\n+\t\t       mask, (gfc_array_i16 *) field);\n+\t  return;\n+#endif\n+\t}\n+    case GFC_DTYPE_REAL:\n+      switch (size)\n+\t{\n+\tcase sizeof (GFC_REAL_4):\n+\t  unpack1_r4 ((gfc_array_r4 *) ret, (gfc_array_r4 *) vector,\n+\t\t      mask, (gfc_array_r4 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_REAL_8):\n+\t  unpack1_r8 ((gfc_array_r8 *) ret, (gfc_array_r8 *) vector,\n+\t\t      mask, (gfc_array_r8 *) field);\n+\t  return;\n+\n+#ifdef HAVE_GFC_REAL_10\n+\tcase sizeof (GFC_REAL_10):\n+\t  unpack1_r10 ((gfc_array_r10 *) ret, (gfc_array_r10 *) vector,\n+\t\t      mask, (gfc_array_r10 *) field);\n+\t  return;\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+\tcase sizeof (GFC_REAL_16):\n+\t  unpack1_r16 ((gfc_array_r16 *) ret, (gfc_array_r16 *) vector,\n+\t\t      mask, (gfc_array_r16 *) field);\n+\t  return;\n+#endif\n+\t}\n+\n+    case GFC_DTYPE_COMPLEX:\n+      switch (size)\n+\t{\n+\tcase sizeof (GFC_COMPLEX_4):\n+\t  unpack1_c4 ((gfc_array_c4 *) ret, (gfc_array_c4 *) vector,\n+\t\t      mask, (gfc_array_c4 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_COMPLEX_8):\n+\t  unpack1_c8 ((gfc_array_c8 *) ret, (gfc_array_c8 *) vector,\n+\t\t      mask, (gfc_array_c8 *) field);\n+\t  return;\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+\tcase sizeof (GFC_COMPLEX_10):\n+\t  unpack1_c10 ((gfc_array_c10 *) ret, (gfc_array_c10 *) vector,\n+\t\t      mask, (gfc_array_c10 *) field);\n+\t  return;\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+\tcase sizeof (GFC_COMPLEX_16):\n+\t  unpack1_c16 ((gfc_array_c16 *) ret, (gfc_array_c16 *) vector,\n+\t\t      mask, (gfc_array_c16 *) field);\n+\t  return;\n+#endif\n+\t}\n+\n+    }\n+  unpack_internal (ret, vector, mask, field, size,\n \t\t   GFC_DESCRIPTOR_SIZE (field));\n }\n \n@@ -227,6 +322,102 @@ unpack0 (gfc_array_char *ret, const gfc_array_char *vector,\n {\n   gfc_array_char tmp;\n \n+  int type;\n+  index_type size;\n+\n+  type = GFC_DESCRIPTOR_TYPE (vector);\n+  size = GFC_DESCRIPTOR_SIZE (vector);\n+\n+  switch(type)\n+    {\n+    case GFC_DTYPE_INTEGER:\n+    case GFC_DTYPE_LOGICAL:\n+      switch(size)\n+\t{\n+\tcase sizeof (GFC_INTEGER_1):\n+\t  unpack0_i1 ((gfc_array_i1 *) ret, (gfc_array_i1 *) vector,\n+\t\t      mask, (GFC_INTEGER_1 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_2):\n+\t  unpack0_i2 ((gfc_array_i2 *) ret, (gfc_array_i2 *) vector,\n+\t\t      mask, (GFC_INTEGER_2 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_4):\n+\t  unpack0_i4 ((gfc_array_i4 *) ret, (gfc_array_i4 *) vector,\n+\t\t      mask, (GFC_INTEGER_4 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_INTEGER_8):\n+\t  unpack0_i8 ((gfc_array_i8 *) ret, (gfc_array_i8 *) vector,\n+\t\t      mask, (GFC_INTEGER_8 *) field);\n+\t  return;\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+\tcase sizeof (GFC_INTEGER_16):\n+\t  unpack0_i16 ((gfc_array_i16 *) ret, (gfc_array_i16 *) vector,\n+\t\t      mask, (GFC_INTEGER_16 *) field);\n+\t  return;\n+#endif\n+\t}\n+\n+    case GFC_DTYPE_REAL:\n+      switch(size)\n+\t{\n+\tcase sizeof (GFC_REAL_4):\n+\t  unpack0_r4 ((gfc_array_r4 *) ret, (gfc_array_r4 *) vector,\n+\t  \t      mask, (GFC_REAL_4 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_REAL_8):\n+\t  unpack0_r8 ((gfc_array_r8 *) ret, (gfc_array_r8*) vector,\n+\t  \t      mask, (GFC_REAL_8  *) field);\n+\t  return;\n+\n+#ifdef HAVE_GFC_REAL_10\n+\tcase sizeof (GFC_REAL_10):\n+\t  unpack0_r10 ((gfc_array_r10 *) ret, (gfc_array_r10 *) vector,\n+\t  \t      mask, (GFC_REAL_10 *) field);\n+\t  return;\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+\tcase sizeof (GFC_REAL_16):\n+\t  unpack0_r16 ((gfc_array_r16 *) ret, (gfc_array_r16 *) vector,\n+\t  \t      mask, (GFC_REAL_16 *) field);\n+\t  return;\n+#endif\n+\t}\n+\n+    case GFC_DTYPE_COMPLEX:\n+      switch(size)\n+\t{\n+\tcase sizeof (GFC_COMPLEX_4):\n+\t  unpack0_c4 ((gfc_array_c4 *) ret, (gfc_array_c4 *) vector,\n+\t  \t      mask, (GFC_COMPLEX_4 *) field);\n+\t  return;\n+\n+\tcase sizeof (GFC_COMPLEX_8):\n+\t  unpack0_c8 ((gfc_array_c8 *) ret, (gfc_array_c8 *) vector,\n+\t  \t      mask, (GFC_COMPLEX_8 *) field);\n+\t  return;\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+\tcase sizeof (GFC_COMPLEX_10):\n+\t  unpack0_c10 ((gfc_array_c10 *) ret, (gfc_array_c10 *) vector,\n+\t  \t      mask, (GFC_COMPLEX_10 *) field);\n+\t  return;\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+\tcase sizeof (GFC_COMPLEX_16):\n+\t  unpack0_c16 ((gfc_array_c16 *) ret, (gfc_array_c16 *) vector,\n+\t  \t      mask, (GFC_COMPLEX_16 *) field);\n+\t  return;\n+#endif\n+\t}\n+    }\n   memset (&tmp, 0, sizeof (tmp));\n   tmp.dtype = 0;\n   tmp.data = field;"}, {"sha": "9a1f643d71d868db3534fa63438cf651f96c93fd", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -774,6 +774,142 @@ extern void pack_c16 (gfc_array_c16 *, const gfc_array_c16 *,\n internal_proto(pack_c16);\n #endif\n \n+/* Internal auxiliary functions for the unpack intrinsic.  */\n+\n+extern void unpack0_i1 (gfc_array_i1 *, const gfc_array_i1 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_INTEGER_1 *);\n+internal_proto(unpack0_i1);\n+\n+extern void unpack0_i2 (gfc_array_i2 *, const gfc_array_i2 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_INTEGER_2 *);\n+internal_proto(unpack0_i2);\n+\n+extern void unpack0_i4 (gfc_array_i4 *, const gfc_array_i4 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_INTEGER_4 *);\n+internal_proto(unpack0_i4);\n+\n+extern void unpack0_i8 (gfc_array_i8 *, const gfc_array_i8 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_INTEGER_8 *);\n+internal_proto(unpack0_i8);\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+\n+extern void unpack0_i16 (gfc_array_i16 *, const gfc_array_i16 *,\n+\t\t\t const gfc_array_l1 *, const GFC_INTEGER_16 *);\n+internal_proto(unpack0_i16);\n+\n+#endif\n+\n+extern void unpack0_r4 (gfc_array_r4 *, const gfc_array_r4 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_REAL_4 *);\n+internal_proto(unpack0_r4);\n+\n+extern void unpack0_r8 (gfc_array_r8 *, const gfc_array_r8 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_REAL_8 *);\n+internal_proto(unpack0_r8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+\n+extern void unpack0_r10 (gfc_array_r10 *, const gfc_array_r10 *,\n+\t\t\t const gfc_array_l1 *, const GFC_REAL_10 *);\n+internal_proto(unpack0_r10);\n+\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+\n+extern void unpack0_r16 (gfc_array_r16 *, const gfc_array_r16 *,\n+\t\t\t const gfc_array_l1 *, const GFC_REAL_16 *);\n+internal_proto(unpack0_r16);\n+\n+#endif\n+\n+extern void unpack0_c4 (gfc_array_c4 *, const gfc_array_c4 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_COMPLEX_4 *);\n+internal_proto(unpack0_c4);\n+\n+extern void unpack0_c8 (gfc_array_c8 *, const gfc_array_c8 *,\n+\t\t\tconst gfc_array_l1 *, const GFC_COMPLEX_8 *);\n+internal_proto(unpack0_c8);\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+\n+extern void unpack0_c10 (gfc_array_c10 *, const gfc_array_c10 *,\n+\t\t\t const gfc_array_l1 *mask, const GFC_COMPLEX_10 *);\n+internal_proto(unpack0_c10);\n+\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+\n+extern void unpack0_c16 (gfc_array_c16 *, const gfc_array_c16 *,\n+\t\t\t const gfc_array_l1 *, const GFC_COMPLEX_16 *);\n+internal_proto(unpack0_c16);\n+\n+#endif\n+\n+extern void unpack1_i1 (gfc_array_i1 *, const gfc_array_i1 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_i1 *);\n+internal_proto(unpack1_i1);\n+\n+extern void unpack1_i2 (gfc_array_i2 *, const gfc_array_i2 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_i2 *);\n+internal_proto(unpack1_i2);\n+\n+extern void unpack1_i4 (gfc_array_i4 *, const gfc_array_i4 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_i4 *);\n+internal_proto(unpack1_i4);\n+\n+extern void unpack1_i8 (gfc_array_i8 *, const gfc_array_i8 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_i8 *);\n+internal_proto(unpack1_i8);\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+extern void unpack1_i16 (gfc_array_i16 *, const gfc_array_i16 *,\n+\t\t\t const gfc_array_l1 *, const gfc_array_i16 *);\n+internal_proto(unpack1_i16);\n+#endif\n+\n+extern void unpack1_r4 (gfc_array_r4 *, const gfc_array_r4 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_r4 *);\n+internal_proto(unpack1_r4);\n+\n+extern void unpack1_r8 (gfc_array_r8 *, const gfc_array_r8 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_r8 *);\n+internal_proto(unpack1_r8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+extern void unpack1_r10 (gfc_array_r10 *, const gfc_array_r10 *,\n+\t\t\t const gfc_array_l1 *, const gfc_array_r10 *);\n+internal_proto(unpack1_r10);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+extern void unpack1_r16 (gfc_array_r16 *, const gfc_array_r16 *,\n+\t\t\t const gfc_array_l1 *, const gfc_array_r16 *);\n+internal_proto(unpack1_r16);\n+#endif\n+\n+extern void unpack1_c4 (gfc_array_c4 *, const gfc_array_c4 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_c4 *);\n+internal_proto(unpack1_c4);\n+\n+extern void unpack1_c8 (gfc_array_c8 *, const gfc_array_c8 *,\n+\t\t\tconst gfc_array_l1 *, const gfc_array_c8 *);\n+internal_proto(unpack1_c8);\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+extern void unpack1_c10 (gfc_array_c10 *, const gfc_array_c10 *,\n+\t\t\t const gfc_array_l1 *, const gfc_array_c10 *);\n+internal_proto(unpack1_c10);\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+extern void unpack1_c16 (gfc_array_c16 *, const gfc_array_c16 *,\n+\t\t\t const gfc_array_l1 *, const gfc_array_c16 *);\n+internal_proto(unpack1_c16);\n+#endif\n+\n /* string_intrinsics.c */\n \n extern int compare_string (GFC_INTEGER_4, const char *,"}, {"sha": "2ad6841a0819541f1915739504a35b53b57823ef", "filename": "libgfortran/m4/unpack.m4", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fm4%2Funpack.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3478bba4660b29dc76202c955b709bf484dacf1f/libgfortran%2Fm4%2Funpack.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Funpack.m4?ref=3478bba4660b29dc76202c955b709bf484dacf1f", "patch": "@@ -0,0 +1,339 @@\n+`/* Specific implementation of the UNPACK intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   unpack_generic.c by Paul Brook <paul@nowt.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>'\n+\n+include(iparm.m4)dnl\n+\n+`#if defined (HAVE_'rtype_name`)\n+\n+void\n+unpack0_'rtype_code` ('rtype` *ret, const 'rtype` *vector,\n+\t\t const gfc_array_l1 *mask, const 'rtype_name` *fptr)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  'rtype_name` *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  'rtype_name` *vptr;\n+  /* Value for field, this is constant.  */\n+  const 'rtype_name` fval = *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof ('rtype_name`));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+\t  /* From vector.  */\n+\t  *rptr = *vptr;\n+\t  vptr += vstride0;\n+        }\n+      else\n+        {\n+\t  /* From field.  */\n+\t  *rptr = fval;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+void\n+unpack1_'rtype_code` ('rtype` *ret, const 'rtype` *vector,\n+\t\t const gfc_array_l1 *mask, const 'rtype` *field)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rs;\n+  'rtype_name` *rptr;\n+  /* v.* indicates the vector array.  */\n+  index_type vstride0;\n+  'rtype_name` *vptr;\n+  /* f.* indicates the field array.  */\n+  index_type fstride[GFC_MAX_DIMENSIONS];\n+  index_type fstride0;\n+  const 'rtype_name` *fptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+\n+  int empty;\n+  int mask_kind;\n+\n+  empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      dim = GFC_DESCRIPTOR_RANK (mask);\n+      rs = 1;\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  ret->dim[n].ubound = mask->dim[n].ubound - mask->dim[n].lbound;\n+\t  extent[n] = ret->dim[n].ubound + 1;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t  rs *= extent[n];\n+\t}\n+      ret->offset = 0;\n+      ret->data = internal_malloc_size (rs * sizeof ('rtype_name`));\n+    }\n+  else\n+    {\n+      dim = GFC_DESCRIPTOR_RANK (ret);\n+      for (n = 0; n < dim; n++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t  empty = empty || extent[n] <= 0;\n+\t  rstride[n] = ret->dim[n].stride;\n+\t  fstride[n] = field->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n+\t}\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+    }\n+\n+  if (empty)\n+    return;\n+\n+  if (fstride[0] == 0)\n+    fstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = 1;\n+\n+  vstride0 = vector->dim[0].stride;\n+  if (vstride0 == 0)\n+    vstride0 = 1;\n+  rstride0 = rstride[0];\n+  fstride0 = fstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+  fptr = field->data;\n+  vptr = vector->data;\n+\n+  while (rptr)\n+    {\n+      if (*mptr)\n+        {\n+          /* From vector.  */\n+\t  *rptr = *vptr;\n+          vptr += vstride0;\n+        }\n+      else\n+        {\n+          /* From field.  */\n+\t  *rptr = *fptr;\n+        }\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      fptr += fstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          fptr -= fstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              fptr += fstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+'"}]}