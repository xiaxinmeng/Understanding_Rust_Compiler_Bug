{"sha": "1eeeda473c577152f6a1a9846b4c0df376622b95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVlZWRhNDczYzU3NzE1MmY2YTFhOTg0NmI0YzBkZjM3NjYyMmI5NQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-12-15T12:22:24Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-12-15T12:22:24Z"}, "message": "gimple-loop-interchange.cc (STMT_COST_RATIO): New macro.\n\n\t* gimple-loop-interchange.cc (STMT_COST_RATIO): New macro.\n\t(loop_cand::m_num_stmts, loop_cand::m_const_init_reduc): New members.\n\t(loop_cand::loop_cand): Initialize above members.\n\t(loop_cand::supported_operations): Delete.\n\t(loop_cand::can_interchange_p): Inline above function.\n\t(loop_cand::classify_simple_reduction): Record number of constant\n\tinitialized simple reductions.\n\t(should_interchange_loops): New parameters.  Check stmt cost of loops\n\tto be interchange.\n\t(tree_loop_interchange::interchange): Prepare stmt cost of outer loop.\n\tUpdate call to should_interchange_loops.\n\t(should_interchange_loop_nest): Update call to\n\tshould_interchange_loops.\n\nFrom-SVN: r255691", "tree": {"sha": "0de6009104de57d1594bee0ca244fda4f96e528c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0de6009104de57d1594bee0ca244fda4f96e528c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eeeda473c577152f6a1a9846b4c0df376622b95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eeeda473c577152f6a1a9846b4c0df376622b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eeeda473c577152f6a1a9846b4c0df376622b95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eeeda473c577152f6a1a9846b4c0df376622b95/comments", "author": null, "committer": null, "parents": [{"sha": "76fc4a85933e84c70c0441d7d87935d805694052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fc4a85933e84c70c0441d7d87935d805694052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76fc4a85933e84c70c0441d7d87935d805694052"}], "stats": {"total": 195, "additions": 114, "deletions": 81}, "files": [{"sha": "5908dd55679a7d364c258be685641f1343fe02f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eeeda473c577152f6a1a9846b4c0df376622b95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eeeda473c577152f6a1a9846b4c0df376622b95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eeeda473c577152f6a1a9846b4c0df376622b95", "patch": "@@ -1,3 +1,19 @@\n+2017-12-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gimple-loop-interchange.cc (STMT_COST_RATIO): New macro.\n+\t(loop_cand::m_num_stmts, loop_cand::m_const_init_reduc): New members.\n+\t(loop_cand::loop_cand): Initialize above members.\n+\t(loop_cand::supported_operations): Delete.\n+\t(loop_cand::can_interchange_p): Inline above function.\n+\t(loop_cand::classify_simple_reduction): Record number of constant\n+\tinitialized simple reductions.\n+\t(should_interchange_loops): New parameters.  Check stmt cost of loops\n+\tto be interchange.\n+\t(tree_loop_interchange::interchange): Prepare stmt cost of outer loop.\n+\tUpdate call to should_interchange_loops.\n+\t(should_interchange_loop_nest): Update call to\n+\tshould_interchange_loops.\n+\n 2017-12-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/66488"}, {"sha": "261a99e516323dcec0a726f7614811ec283869d0", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 98, "deletions": 81, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eeeda473c577152f6a1a9846b4c0df376622b95/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eeeda473c577152f6a1a9846b4c0df376622b95/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=1eeeda473c577152f6a1a9846b4c0df376622b95", "patch": "@@ -90,6 +90,10 @@ along with GCC; see the file COPYING3.  If not see\n    innermost two loops.  */\n #define INNER_STRIDE_RATIO  ((OUTER_STRIDE_RATIO) + 1)\n \n+/* Comparison ratio of stmt cost between inner/outer loops.  Loops won't\n+   be interchanged if outer loop has too many stmts.  */\n+#define STMT_COST_RATIO     (3)\n+\n /* Vector of strides that DR accesses in each level loop of a loop nest.  */\n #define DR_ACCESS_STRIDE(dr) ((vec<tree> *) dr->aux)\n \n@@ -181,7 +185,6 @@ struct loop_cand\n   bool analyze_carried_vars (loop_cand *);\n   bool analyze_lcssa_phis (void);\n   bool can_interchange_p (loop_cand *);\n-  bool supported_operations (basic_block, loop_cand *, int *);\n   void undo_simple_reduction (reduction_p, bitmap);\n \n   /* The loop itself.  */\n@@ -199,13 +202,17 @@ struct loop_cand\n   edge m_exit;\n   /* Basic blocks of this loop.  */\n   basic_block *m_bbs;\n+  /* Number of stmts of this loop.  Inner loops' stmts are not included.  */\n+  int m_num_stmts;\n+  /* Number of constant initialized simple reduction.  */\n+  int m_const_init_reduc;\n };\n \n /* Constructor.  */\n \n loop_cand::loop_cand (struct loop *loop, struct loop *outer)\n-  : m_loop (loop), m_outer (outer),\n-    m_exit (single_exit (loop)), m_bbs (get_loop_body (loop))\n+  : m_loop (loop), m_outer (outer), m_exit (single_exit (loop)),\n+    m_bbs (get_loop_body (loop)), m_num_stmts (0), m_const_init_reduc (0)\n {\n     m_inductions.create (3);\n     m_reductions.create (3);\n@@ -282,75 +289,6 @@ loop_cand::find_reduction_by_stmt (gimple *stmt)\n   return NULL;\n }\n \n-/* Return true if all stmts in BB can be supported by loop interchange,\n-   otherwise return false.  ILOOP is not NULL if this loop_cand is the\n-   outer loop in loop nest.  Add the number of supported statements to\n-   NUM_STMTS.  */\n-\n-bool\n-loop_cand::supported_operations (basic_block bb, loop_cand *iloop,\n-\t\t\t\t int *num_stmts)\n-{\n-  int bb_num_stmts = 0;\n-  gphi_iterator psi;\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (is_gimple_debug (stmt))\n-\tcontinue;\n-\n-      if (gimple_has_side_effects (stmt))\n-\treturn false;\n-\n-      bb_num_stmts++;\n-      if (gcall *call = dyn_cast <gcall *> (stmt))\n-\t{\n-\t  /* In basic block of outer loop, the call should be cheap since\n-\t     it will be moved to inner loop.  */\n-\t  if (iloop != NULL\n-\t      && !gimple_inexpensive_call_p (call))\n-\t    return false;\n-\t  continue;\n-\t}\n-\n-      if (!iloop || !gimple_vuse (stmt))\n-\tcontinue;\n-\n-      /* Support stmt accessing memory in outer loop only if it is for inner\n-\t loop's reduction.  */\n-      if (iloop->find_reduction_by_stmt (stmt))\n-\tcontinue;\n-\n-      tree lhs;\n-      /* Support loop invariant memory reference if it's only used once by\n-\t inner loop.  */\n-      /* ???  How's this checking for invariantness?  */\n-      if (gimple_assign_single_p (stmt)\n-\t  && (lhs = gimple_assign_lhs (stmt)) != NULL_TREE\n-\t  && TREE_CODE (lhs) == SSA_NAME\n-\t  && single_use_in_loop (lhs, iloop->m_loop))\n-\tcontinue;\n-\n-      return false;\n-    }\n-  *num_stmts += bb_num_stmts;\n-\n-  /* Allow PHI nodes in any basic block of inner loop, PHI nodes in outer\n-     loop's header, or PHI nodes in dest bb of inner loop's exit edge.  */\n-  if (!iloop || bb == m_loop->header\n-      || bb == iloop->m_exit->dest)\n-    return true;\n-\n-  /* Don't allow any other PHI nodes.  */\n-  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-    if (!virtual_operand_p (PHI_RESULT (psi.phi ())))\n-      return false;\n-\n-  return true;\n-}\n-\n /* Return true if current loop_cand be interchanged.  ILOOP is not NULL if\n    current loop_cand is outer loop in loop nest.  */\n \n@@ -375,23 +313,72 @@ loop_cand::can_interchange_p (loop_cand *iloop)\n   if (m_lcssa_nodes.length () > allowed_reduction_num)\n     return false;\n \n-  int num_stmts = 0;\n-  /* Check basic blocks other than loop header/exit.  */\n+  /* Check if basic block has any unsupported operation.  Note basic blocks\n+     of inner loops are not checked here.  */\n   for (unsigned i = 0; i < m_loop->num_nodes; i++)\n     {\n       basic_block bb = m_bbs[i];\n+      gphi_iterator psi;\n+      gimple_stmt_iterator gsi;\n \n       /* Skip basic blocks of inner loops.  */\n       if (bb->loop_father != m_loop)\n-\tcontinue;\n+       continue;\n \n-      /* Check if basic block has any unsupported operation.  */\n-      if (!supported_operations (bb, iloop, &num_stmts))\n-\treturn false;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n+\t  if (gimple_has_side_effects (stmt))\n+\t    return false;\n+\n+\t  m_num_stmts++;\n+\t  if (gcall *call = dyn_cast <gcall *> (stmt))\n+\t    {\n+\t      /* In basic block of outer loop, the call should be cheap since\n+\t\t it will be moved to inner loop.  */\n+\t      if (iloop != NULL\n+\t\t  && !gimple_inexpensive_call_p (call))\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\n+\t  if (!iloop || !gimple_vuse (stmt))\n+\t    continue;\n \n+\t  /* Support stmt accessing memory in outer loop only if it is for\n+\t     inner loop's reduction.  */\n+\t  if (iloop->find_reduction_by_stmt (stmt))\n+\t    continue;\n+\n+\t  tree lhs;\n+\t  /* Support loop invariant memory reference if it's only used once by\n+\t     inner loop.  */\n+\t  /* ???  How's this checking for invariantness?  */\n+\t  if (gimple_assign_single_p (stmt)\n+\t      && (lhs = gimple_assign_lhs (stmt)) != NULL_TREE\n+\t      && TREE_CODE (lhs) == SSA_NAME\n+\t      && single_use_in_loop (lhs, iloop->m_loop))\n+\t    continue;\n+\n+\t  return false;\n+\t}\n       /* Check if loop has too many stmts.  */\n-      if (num_stmts > MAX_NUM_STMT)\n+      if (m_num_stmts > MAX_NUM_STMT)\n \treturn false;\n+\n+      /* Allow PHI nodes in any basic block of inner loop, PHI nodes in outer\n+\t loop's header, or PHI nodes in dest bb of inner loop's exit edge.  */\n+      if (!iloop || bb == m_loop->header\n+\t  || bb == iloop->m_exit->dest)\n+\tcontinue;\n+\n+      /* Don't allow any other PHI nodes.  */\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+\tif (!virtual_operand_p (PHI_RESULT (psi.phi ())))\n+\t  return false;\n     }\n \n   return true;\n@@ -440,7 +427,9 @@ loop_cand::classify_simple_reduction (reduction_p re)\n \n       re->init_ref = gimple_assign_rhs1 (producer);\n     }\n-  else if (!CONSTANT_CLASS_P (re->init))\n+  else if (CONSTANT_CLASS_P (re->init))\n+    m_const_init_reduc++;\n+  else\n     return;\n \n   /* Check how reduction variable is used.  */\n@@ -1446,6 +1435,7 @@ dump_access_strides (vec<data_reference_p> datarefs)\n static bool\n should_interchange_loops (unsigned i_idx, unsigned o_idx,\n \t\t\t  vec<data_reference_p> datarefs,\n+\t\t\t  unsigned i_stmt_cost, unsigned o_stmt_cost,\n \t\t\t  bool innermost_loops_p, bool dump_info_p = true)\n {\n   unsigned HOST_WIDE_INT ratio;\n@@ -1541,11 +1531,21 @@ should_interchange_loops (unsigned i_idx, unsigned o_idx,\n \t       num_resolved_not_ok_drs);\n       fprintf (dump_file, \"Variable strides we cannot decide: %d\\n\",\n \t       num_unresolved_drs);\n+      fprintf (dump_file, \"Stmt cost of inner loop: %d\\n\", i_stmt_cost);\n+      fprintf (dump_file, \"Stmt cost of outer loop: %d\\n\", o_stmt_cost);\n     }\n \n   if (num_unresolved_drs != 0 || num_resolved_not_ok_drs != 0)\n     return false;\n \n+  /* Stmts of outer loop will be moved to inner loop.  If there are two many\n+     such stmts, it could make inner loop costly.  Here we compare stmt cost\n+     between outer and inner loops.  */\n+  if (i_stmt_cost && o_stmt_cost\n+      && num_old_inv_drs + o_stmt_cost > num_new_inv_drs\n+      && o_stmt_cost * STMT_COST_RATIO > i_stmt_cost)\n+    return false;\n+\n   /* We use different stride comparison ratio for interchanging innermost\n      two loops or not.  The idea is to be conservative in interchange for\n      the innermost loops.  */\n@@ -1599,8 +1599,25 @@ tree_loop_interchange::interchange (vec<data_reference_p> datarefs,\n \t  || !oloop.can_interchange_p (&iloop))\n \tbreak;\n \n+      /* Outer loop's stmts will be moved to inner loop during interchange.\n+\t If there are many of them, it may make inner loop very costly.  We\n+\t need to check number of outer loop's stmts in profit cost model of\n+\t interchange.  */\n+      int stmt_cost = oloop.m_num_stmts;\n+      /* Count out the exit checking stmt of outer loop.  */\n+      stmt_cost --;\n+      /* Count out IV's increasing stmt, IVOPTs takes care if it.  */\n+      stmt_cost -= oloop.m_inductions.length ();\n+      /* Count in the additional load and cond_expr stmts caused by inner\n+\t loop's constant initialized reduction.  */\n+      stmt_cost += iloop.m_const_init_reduc * 2;\n+      if (stmt_cost < 0)\n+\tstmt_cost = 0;\n+\n       /* Check profitability for loop interchange.  */\n       if (should_interchange_loops (i_idx, o_idx, datarefs,\n+\t\t\t\t    (unsigned) iloop.m_num_stmts,\n+\t\t\t\t    (unsigned) stmt_cost,\n \t\t\t\t    iloop.m_loop->inner == NULL))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1793,7 +1810,7 @@ should_interchange_loop_nest (struct loop *loop_nest, struct loop *innermost,\n   /* Check if any two adjacent loops should be interchanged.  */\n   for (struct loop *loop = innermost;\n        loop != loop_nest; loop = loop_outer (loop), idx--)\n-    if (should_interchange_loops (idx, idx - 1, datarefs,\n+    if (should_interchange_loops (idx, idx - 1, datarefs, 0, 0,\n \t\t\t\t  loop == innermost, false))\n       return true;\n "}]}