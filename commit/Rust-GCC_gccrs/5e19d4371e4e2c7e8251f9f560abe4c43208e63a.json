{"sha": "5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUxOWQ0MzcxZTRlMmM3ZTgyNTFmOWY1NjBhYmU0YzQzMjA4ZTYzYQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-08-01T09:28:18Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-08-01T09:28:18Z"}, "message": "tree.h (POINTER_TYPE_OVERFLOW_UNDEFINED): Delete.\n\n\t* tree.h (POINTER_TYPE_OVERFLOW_UNDEFINED): Delete.\n\t* fold-const.c (fold_comparison, fold_binary_loc): Delete use of\n\tabove macro.\n\t* match.pd: Ditto in address comparison pattern.\n\n\tgcc/testsuite\n\t* gcc.dg/no-strict-overflow-7.c: Revise comment and test string.\n\t* gcc.dg/tree-ssa/pr81388-1.c: Ditto.\n\nFrom-SVN: r250765", "tree": {"sha": "2c36746342cba0e2f34acd02755cf06afc325d81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c36746342cba0e2f34acd02755cf06afc325d81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/comments", "author": null, "committer": null, "parents": [{"sha": "7061cfc027e29b6d276ef5e09835c93899cfd132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7061cfc027e29b6d276ef5e09835c93899cfd132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7061cfc027e29b6d276ef5e09835c93899cfd132"}], "stats": {"total": 57, "additions": 26, "deletions": 31}, "files": [{"sha": "10c10c7089cac5ae6f085c7b147cc74a2f72408e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "patch": "@@ -1,3 +1,10 @@\n+2017-08-01  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree.h (POINTER_TYPE_OVERFLOW_UNDEFINED): Delete.\n+\t* fold-const.c (fold_comparison, fold_binary_loc): Delete use of\n+\tabove macro.\n+\t* match.pd: Ditto in address comparison pattern.\n+\n 2017-08-01  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/81627"}, {"sha": "eeeff1ed166734328a612142fdf6235274f9e858", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "patch": "@@ -8458,14 +8458,9 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t{\n \t  /* We can fold this expression to a constant if the non-constant\n \t     offset parts are equal.  */\n-\t  if ((offset0 == offset1\n-\t       || (offset0 && offset1\n-\t\t   && operand_equal_p (offset0, offset1, 0)))\n-\t      && (equality_code\n-\t\t  || (indirect_base0\n-\t\t      && (DECL_P (base0) || CONSTANT_CLASS_P (base0)))\n-\t\t  || POINTER_TYPE_OVERFLOW_UNDEFINED))\n-\n+\t  if (offset0 == offset1\n+\t      || (offset0 && offset1\n+\t\t  && operand_equal_p (offset0, offset1, 0)))\n \t    {\n \t      if (!equality_code\n \t\t  && bitpos0 != bitpos1\n@@ -8500,11 +8495,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t     because pointer arithmetic is restricted to retain within an\n \t     object and overflow on pointer differences is undefined as of\n \t     6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n-\t  else if (bitpos0 == bitpos1\n-\t\t   && (equality_code\n-\t\t       || (indirect_base0\n-\t\t\t   && (DECL_P (base0) || CONSTANT_CLASS_P (base0)))\n-\t\t       || POINTER_TYPE_OVERFLOW_UNDEFINED))\n+\t  else if (bitpos0 == bitpos1)\n \t    {\n \t      /* By converting to signed sizetype we cover middle-end pointer\n \t         arithmetic which operates on unsigned pointer types of size\n@@ -9590,7 +9581,7 @@ fold_binary_loc (location_t loc,\n \n \t  /* With undefined overflow prefer doing association in a type\n \t     which wraps on overflow, if that is one of the operand types.  */\n-\t  if ((POINTER_TYPE_P (type) && POINTER_TYPE_OVERFLOW_UNDEFINED)\n+\t  if (POINTER_TYPE_P (type)\n \t      || (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type)))\n \t    {\n \t      if (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n@@ -9604,7 +9595,7 @@ fold_binary_loc (location_t loc,\n \n \t  /* With undefined overflow we can only associate constants with one\n \t     variable, and constants whose association doesn't overflow.  */\n-\t  if ((POINTER_TYPE_P (atype) && POINTER_TYPE_OVERFLOW_UNDEFINED)\n+\t  if (POINTER_TYPE_P (atype)\n \t      || (INTEGRAL_TYPE_P (atype) && !TYPE_OVERFLOW_WRAPS (atype)))\n \t    {\n \t      if (var0 && var1)"}, {"sha": "e98db52af84946cf579c6434e06d450713a47162", "filename": "gcc/match.pd", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "patch": "@@ -3223,14 +3223,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t\t    || TREE_CODE (base1) == STRING_CST))\n          equal = (base0 == base1);\n      }\n-     (if (equal == 1\n-\t  && (cmp == EQ_EXPR || cmp == NE_EXPR\n-\t      /* If the offsets are equal we can ignore overflow.  */\n-\t      || off0 == off1\n-\t      || POINTER_TYPE_OVERFLOW_UNDEFINED\n-\t      /* Or if we compare using pointers to decls or strings.  */\n-\t      || (POINTER_TYPE_P (TREE_TYPE (@2))\n-\t\t  && (DECL_P (base0) || TREE_CODE (base0) == STRING_CST))))\n+     (if (equal == 1)\n       (switch\n        (if (cmp == EQ_EXPR)\n \t{ constant_boolean_node (off0 == off1, type); })"}, {"sha": "02df696860c1d50bcabca245a1fe03d0048a7f37", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "patch": "@@ -1,3 +1,8 @@\n+2017-08-01  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/no-strict-overflow-7.c: Revise comment and test string.\n+\t* gcc.dg/tree-ssa/pr81388-1.c: Ditto.\n+\n 2017-08-01  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/81627"}, {"sha": "0e73d486f22f1d6b5d8993c47b1f80861884840e", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-7.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c?ref=5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "patch": "@@ -3,13 +3,13 @@\n \n /* Source: Ian Lance Taylor.  Dual of strict-overflow-6.c.  */\n \n-/* We can only simplify the conditional when using strict overflow\n-   semantics.  */\n+/* We can simplify the conditional because pointer overflow always has\n+   undefined semantics.  */\n \n int\n foo (char* p)\n {\n   return p + 1000 < p;\n }\n \n-/* { dg-final { scan-tree-dump \"\\[+\\]\\[ \\]*1000\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"return 0\" \"optimized\" } } */"}, {"sha": "0beb5109d403ba53a5cf556e80f49208add106e1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr81388-1.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr81388-1.c?ref=5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-strict-overflow -fdump-tree-ivcanon-details\" } */\n+/* { dg-options \"-O2 -fno-strict-overflow -fdump-tree-tailc-details\" } */\n \n void bar();\n void foo(char *dst)\n@@ -11,4 +11,6 @@ void foo(char *dst)\n   } while (dst < end);\n }\n \n-/* { dg-final { scan-tree-dump-times \" zero if \" 1 \"ivcanon\" } } */\n+/* The loop only iterates once because pointer overflow always has undefined\n+   semantics.  As a result, call to bar becomes tail call.  */\n+/* { dg-final { scan-tree-dump-times \"Found tail call \" 1 \"tailc\" } } */"}, {"sha": "d955b58d82a9c1491f85d987fff0e60c31bf8fd7", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e19d4371e4e2c7e8251f9f560abe4c43208e63a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5e19d4371e4e2c7e8251f9f560abe4c43208e63a", "patch": "@@ -859,9 +859,6 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    && !TYPE_OVERFLOW_WRAPS (TYPE)\t\t\t\\\n    && (flag_sanitize & SANITIZE_SI_OVERFLOW))\n \n-/* True if pointer types have undefined overflow.  */\n-#define POINTER_TYPE_OVERFLOW_UNDEFINED (!flag_wrapv)\n-\n /* Nonzero in a VAR_DECL or STRING_CST means assembler code has been written.\n    Nonzero in a FUNCTION_DECL means that the function has been compiled.\n    This is interesting in an inline function, since it might not need"}]}