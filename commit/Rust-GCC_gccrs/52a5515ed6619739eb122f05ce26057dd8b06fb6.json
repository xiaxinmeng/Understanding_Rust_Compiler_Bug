{"sha": "52a5515ed6619739eb122f05ce26057dd8b06fb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJhNTUxNWVkNjYxOTczOWViMTIyZjA1Y2UyNjA1N2RkOGIwNmZiNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-14T11:40:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-26T08:08:46Z"}, "message": "Simplify {gimplify_and_,}update_call_from_tree API\n\nThis removes update_call_from_tree in favor of\ngimplify_and_update_call_from_tree, removing some code duplication\nand simplifying the API use.  Some users of update_call_from_tree\nhave been transitioned to replace_call_with_value and the API\nand its dependences have been moved to gimple-fold.h.\n\nThis shaves off another user of valid_gimple_rhs_p which is now\nonly used from within gimple-fold.c and thus moved and made private.\n\n2021-04-14  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-propagate.h (valid_gimple_rhs_p): Remove.\n\t(update_gimple_call): Likewise.\n\t(update_call_from_tree): Likewise.\n\t* tree-ssa-propagate.c (valid_gimple_rhs_p): Remove.\n\t(valid_gimple_call_p): Likewise.\n\t(move_ssa_defining_stmt_for_defs): Likewise.\n\t(finish_update_gimple_call): Likewise.\n\t(update_gimple_call): Likewise.\n\t(update_call_from_tree): Likewise.\n\t(propagate_tree_value_into_stmt): Use replace_call_with_value.\n\t* gimple-fold.h (update_gimple_call): Declare.\n\t* gimple-fold.c (valid_gimple_rhs_p): Move here from\n\ttree-ssa-propagate.c.\n\t(update_gimple_call): Likewise.\n\t(valid_gimple_call_p): Likewise.\n\t(finish_update_gimple_call): Likewise, and simplify.\n\t(gimplify_and_update_call_from_tree): Implement\n\tupdate_call_from_tree functionality, avoid excessive\n\tpush/pop_gimplify_context.\n\t(gimple_fold_builtin): Use only gimplify_and_update_call_from_tree.\n\t(gimple_fold_call): Likewise.\n\t* gimple-ssa-sprintf.c (try_substitute_return_value): Likewise.\n\t* tree-ssa-ccp.c (ccp_folder::fold_stmt): Likewise.\n\t(pass_fold_builtins::execute): Likewise.\n\t(optimize_stack_restore): Use replace_call_with_value.\n\t* tree-cfg.c (fold_loop_internal_call): Likewise.\n\t* tree-ssa-dce.c (maybe_optimize_arith_overflow): Use\n\tonly gimplify_and_update_call_from_tree.\n\t* tree-ssa-strlen.c (handle_builtin_strlen): Likewise.\n\t(handle_builtin_strchr): Likewise.\n\t* tsan.c: Include gimple-fold.h instead of tree-ssa-propagate.h.\n\n\t* config/rs6000/rs6000-call.c (rs6000_gimple_fold_builtin):\n\tUse replace_call_with_value.", "tree": {"sha": "ce23cf5cca7daae1d47e61007eccfdbfe862fe13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce23cf5cca7daae1d47e61007eccfdbfe862fe13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52a5515ed6619739eb122f05ce26057dd8b06fb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a5515ed6619739eb122f05ce26057dd8b06fb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a5515ed6619739eb122f05ce26057dd8b06fb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a5515ed6619739eb122f05ce26057dd8b06fb6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "297bfacdb448c0d29b8dfac2818350b90902bc75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297bfacdb448c0d29b8dfac2818350b90902bc75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/297bfacdb448c0d29b8dfac2818350b90902bc75"}], "stats": {"total": 559, "additions": 226, "deletions": 333}, "files": [{"sha": "6f6dc47f0aed12540263e455e614a27cb8f18679", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -12369,7 +12369,7 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \t/* Convert result back to the lhs type.  */\n \tres = gimple_build (&stmts, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), res);\n \tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n-\tupdate_call_from_tree (gsi, res);\n+\treplace_call_with_value (gsi, res);\n \treturn true;\n       }\n     /* Vector loads.  */"}, {"sha": "aa33779b7531d2f4f5271353e7f0dfaddc209518", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 211, "deletions": 8, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -335,6 +335,123 @@ maybe_fold_reference (tree expr)\n   return NULL_TREE;\n }\n \n+/* Return true if EXPR is an acceptable right-hand-side for a\n+   GIMPLE assignment.  We validate the entire tree, not just\n+   the root node, thus catching expressions that embed complex\n+   operands that are not permitted in GIMPLE.  This function\n+   is needed because the folding routines in fold-const.c\n+   may return such expressions in some cases, e.g., an array\n+   access with an embedded index addition.  It may make more\n+   sense to have folding routines that are sensitive to the\n+   constraints on GIMPLE operands, rather than abandoning any\n+   any attempt to fold if the usual folding turns out to be too\n+   aggressive.  */\n+\n+bool\n+valid_gimple_rhs_p (tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_declaration:\n+      if (!is_gimple_variable (expr))\n+\treturn false;\n+      break;\n+\n+    case tcc_constant:\n+      /* All constants are ok.  */\n+      break;\n+\n+    case tcc_comparison:\n+      /* GENERIC allows comparisons with non-boolean types, reject\n+\t those for GIMPLE.  Let vector-typed comparisons pass - rules\n+\t for GENERIC and GIMPLE are the same here.  */\n+      if (!(INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+\t    && (TREE_CODE (TREE_TYPE (expr)) == BOOLEAN_TYPE\n+\t\t|| TYPE_PRECISION (TREE_TYPE (expr)) == 1))\n+\t  && ! VECTOR_TYPE_P (TREE_TYPE (expr)))\n+\treturn false;\n+\n+      /* Fallthru.  */\n+    case tcc_binary:\n+      if (!is_gimple_val (TREE_OPERAND (expr, 0))\n+\t  || !is_gimple_val (TREE_OPERAND (expr, 1)))\n+\treturn false;\n+      break;\n+\n+    case tcc_unary:\n+      if (!is_gimple_val (TREE_OPERAND (expr, 0)))\n+\treturn false;\n+      break;\n+\n+    case tcc_expression:\n+      switch (code)\n+\t{\n+\tcase ADDR_EXPR:\n+\t  {\n+\t    tree t;\n+\t    if (is_gimple_min_invariant (expr))\n+\t      return true;\n+\t    t = TREE_OPERAND (expr, 0);\n+\t    while (handled_component_p (t))\n+\t      {\n+\t\t/* ??? More checks needed, see the GIMPLE verifier.  */\n+\t\tif ((TREE_CODE (t) == ARRAY_REF\n+\t\t     || TREE_CODE (t) == ARRAY_RANGE_REF)\n+\t\t    && !is_gimple_val (TREE_OPERAND (t, 1)))\n+\t\t  return false;\n+\t\tt = TREE_OPERAND (t, 0);\n+\t      }\n+\t    if (!is_gimple_id (t))\n+\t      return false;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  if (get_gimple_rhs_class (code) == GIMPLE_TERNARY_RHS)\n+\t    {\n+\t      if ((code == COND_EXPR\n+\t\t   ? !is_gimple_condexpr (TREE_OPERAND (expr, 0))\n+\t\t   : !is_gimple_val (TREE_OPERAND (expr, 0)))\n+\t\t  || !is_gimple_val (TREE_OPERAND (expr, 1))\n+\t\t  || !is_gimple_val (TREE_OPERAND (expr, 2)))\n+\t\treturn false;\n+\t      break;\n+\t    }\n+\t  return false;\n+\t}\n+      break;\n+\n+    case tcc_vl_exp:\n+      return false;\n+\n+    case tcc_exceptional:\n+      if (code == CONSTRUCTOR)\n+\t{\n+\t  unsigned i;\n+\t  tree elt;\n+\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), i, elt)\n+\t    if (!is_gimple_val (elt))\n+\t      return false;\n+\t  return true;\n+\t}\n+      if (code != SSA_NAME)\n+\treturn false;\n+      break;\n+\n+    case tcc_reference:\n+      if (code == BIT_FIELD_REF)\n+\treturn is_gimple_val (TREE_OPERAND (expr, 0));\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n \n /* Attempt to fold an assignment statement pointed-to by SI.  Returns a\n    replacement rhs for the statement or NULL_TREE if no simplification\n@@ -534,6 +651,72 @@ gsi_replace_with_seq_vops (gimple_stmt_iterator *si_p, gimple_seq stmts)\n   gsi_replace_with_seq (si_p, stmts, false);\n }\n \n+/* Helper function for update_gimple_call and\n+   gimplify_and_update_call_from_tree.  A GIMPLE_CALL STMT is being replaced\n+   with GIMPLE_CALL NEW_STMT.  */\n+\n+static void\n+finish_update_gimple_call (gimple_stmt_iterator *si_p, gimple *new_stmt,\n+\t\t\t   gimple *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  gimple_call_set_lhs (new_stmt, lhs);\n+  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+    SSA_NAME_DEF_STMT (lhs) = new_stmt;\n+  gimple_move_vops (new_stmt, stmt);\n+  gimple_set_location (new_stmt, gimple_location (stmt));\n+  if (gimple_block (new_stmt) == NULL_TREE)\n+    gimple_set_block (new_stmt, gimple_block (stmt));\n+  gsi_replace (si_p, new_stmt, false);\n+}\n+\n+/* Update a GIMPLE_CALL statement at iterator *SI_P to call to FN\n+   with number of arguments NARGS, where the arguments in GIMPLE form\n+   follow NARGS argument.  */\n+\n+bool\n+update_gimple_call (gimple_stmt_iterator *si_p, tree fn, int nargs, ...)\n+{\n+  va_list ap;\n+  gcall *new_stmt, *stmt = as_a <gcall *> (gsi_stmt (*si_p));\n+\n+  gcc_assert (is_gimple_call (stmt));\n+  va_start (ap, nargs);\n+  new_stmt = gimple_build_call_valist (fn, nargs, ap);\n+  finish_update_gimple_call (si_p, new_stmt, stmt);\n+  va_end (ap);\n+  return true;\n+}\n+\n+/* Return true if EXPR is a CALL_EXPR suitable for representation\n+   as a single GIMPLE_CALL statement.  If the arguments require\n+   further gimplification, return false.  */\n+\n+static bool\n+valid_gimple_call_p (tree expr)\n+{\n+  unsigned i, nargs;\n+\n+  if (TREE_CODE (expr) != CALL_EXPR)\n+    return false;\n+\n+  nargs = call_expr_nargs (expr);\n+  for (i = 0; i < nargs; i++)\n+    {\n+      tree arg = CALL_EXPR_ARG (expr, i);\n+      if (is_gimple_reg_type (TREE_TYPE (arg)))\n+\t{\n+\t  if (!is_gimple_val (arg))\n+\t    return false;\n+\t}\n+      else\n+\tif (!is_gimple_lvalue (arg))\n+\t  return false;\n+    }\n+\n+  return true;\n+}\n+\n /* Convert EXPR into a GIMPLE value suitable for substitution on the\n    RHS of an assignment.  Insert the necessary statements before\n    iterator *SI_P.  The statement at *SI_P, which must be a GIMPLE_CALL\n@@ -556,17 +739,41 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \n   gcc_assert (is_gimple_call (stmt));\n \n-  push_gimplify_context (gimple_in_ssa_p (cfun));\n+  if (valid_gimple_call_p (expr))\n+    {\n+      /* The call has simplified to another call.  */\n+      tree fn = CALL_EXPR_FN (expr);\n+      unsigned i;\n+      unsigned nargs = call_expr_nargs (expr);\n+      vec<tree> args = vNULL;\n+      gcall *new_stmt;\n+\n+      if (nargs > 0)\n+\t{\n+\t  args.create (nargs);\n+\t  args.safe_grow_cleared (nargs, true);\n+\n+\t  for (i = 0; i < nargs; i++)\n+\t    args[i] = CALL_EXPR_ARG (expr, i);\n+\t}\n+\n+      new_stmt = gimple_build_call_vec (fn, args);\n+      finish_update_gimple_call (si_p, new_stmt, stmt);\n+      args.release ();\n+      return;\n+    }\n \n   lhs = gimple_call_lhs (stmt);\n   if (lhs == NULL_TREE)\n     {\n+      push_gimplify_context (gimple_in_ssa_p (cfun));\n       gimplify_and_add (expr, &stmts);\n+      pop_gimplify_context (NULL);\n+\n       /* We can end up with folding a memcpy of an empty class assignment\n \t which gets optimized away by C++ gimplification.  */\n       if (gimple_seq_empty_p (stmts))\n \t{\n-\t  pop_gimplify_context (NULL);\n \t  if (gimple_in_ssa_p (cfun))\n \t    {\n \t      unlink_stmt_vdef (stmt);\n@@ -585,8 +792,6 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \t\t\t\t       GSI_CONTINUE_LINKING);\n     }\n \n-  pop_gimplify_context (NULL);\n-\n   gsi_replace_with_seq_vops (si_p, stmts);\n }\n \n@@ -4955,8 +5160,7 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \tSTRIP_NOPS (result);\n       else\n \tresult = fold_convert (gimple_call_return_type (stmt), result);\n-      if (!update_call_from_tree (gsi, result))\n-\tgimplify_and_update_call_from_tree (gsi, result);\n+      gimplify_and_update_call_from_tree (gsi, result);\n       return true;\n     }\n \n@@ -5552,8 +5756,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t\tresult = build2_loc (gimple_location (stmt), COMPLEX_EXPR,\n \t\t\t\t     ctype, result, overflow);\n \t    }\n-\t  if (!update_call_from_tree (gsi, result))\n-\t    gimplify_and_update_call_from_tree (gsi, result);\n+\t  gimplify_and_update_call_from_tree (gsi, result);\n \t  changed = true;\n \t}\n     }"}, {"sha": "2401646c48454d1f51a85c48973a278063e5949d", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -28,6 +28,7 @@ extern tree get_symbol_constant_value (tree);\n struct c_strlen_data;\n extern bool get_range_strlen (tree, c_strlen_data *, unsigned eltsize);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n+extern bool update_gimple_call (gimple_stmt_iterator *, tree, int, ...);\n extern bool fold_stmt (gimple_stmt_iterator *);\n extern bool fold_stmt (gimple_stmt_iterator *, tree (*) (tree));\n extern bool fold_stmt_inplace (gimple_stmt_iterator *);"}, {"sha": "fc744669e4bb472a94208ea179476c2cff341537", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -4149,8 +4149,7 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \t  /* Replace the call to the bounded function with a zero size\n \t     (e.g., snprintf(0, 0, \"%i\", 123) with the constant result\n \t     of the function.  */\n-\t  if (!update_call_from_tree (gsi, cst))\n-\t    gimplify_and_update_call_from_tree (gsi, cst);\n+\t  gimplify_and_update_call_from_tree (gsi, cst);\n \t  gimple *callstmt = gsi_stmt (*gsi);\n \t  update_stmt (callstmt);\n \t}"}, {"sha": "316aa832cf6078f9d4a761712cb18608ac9b44df", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -7530,7 +7530,7 @@ fold_loop_internal_call (gimple *g, tree value)\n   gimple *use_stmt;\n   gimple_stmt_iterator gsi = gsi_for_stmt (g);\n \n-  update_call_from_tree (&gsi, value);\n+  replace_call_with_value (&gsi, value);\n   FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n     {\n       FOR_EACH_IMM_USE_ON_STMT (use_p, iter)"}, {"sha": "bf31f03515327ec07dc0351a74c977485d6056e2", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -2332,12 +2332,10 @@ ccp_folder::fold_stmt (gimple_stmt_iterator *gsi)\n \t    && (flags & ECF_LOOPING_CONST_OR_PURE) == 0)\n \t  {\n \t    tree new_rhs = unshare_expr (val);\n-\t    bool res;\n \t    if (!useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t    TREE_TYPE (new_rhs)))\n \t      new_rhs = fold_convert (TREE_TYPE (lhs), new_rhs);\n-\t    res = update_call_from_tree (gsi, new_rhs);\n-\t    gcc_assert (res);\n+\t    gimplify_and_update_call_from_tree (gsi, new_rhs);\n \t    return true;\n \t  }\n \n@@ -2355,9 +2353,8 @@ ccp_folder::fold_stmt (gimple_stmt_iterator *gsi)\n             tree new_rhs = fold_builtin_alloca_with_align (stmt);\n             if (new_rhs)\n \t      {\n-\t\tbool res = update_call_from_tree (gsi, new_rhs);\n+\t\tgimplify_and_update_call_from_tree (gsi, new_rhs);\n \t\ttree var = TREE_OPERAND (TREE_OPERAND (new_rhs, 0),0);\n-\t\tgcc_assert (res);\n \t\tinsert_clobbers_for_var (*gsi, var);\n \t\treturn true;\n \t      }\n@@ -2382,8 +2379,7 @@ ccp_folder::fold_stmt (gimple_stmt_iterator *gsi)\n \t\t    && ((TREE_INT_CST_LOW (ptrval.value) & (align - 1))\n \t\t\t== (TREE_INT_CST_LOW (val.value) & (align - 1))))\n \t\t  {\n-\t\t    bool res = update_call_from_tree (gsi, ptr);\n-\t\t    gcc_assert (res);\n+\t\t    replace_call_with_value (gsi, ptr);\n \t\t    return true;\n \t\t  }\n \t      }\n@@ -2710,7 +2706,7 @@ optimize_stack_restore (gimple_stmt_iterator i)\n \n \t      stack_save_gsi = gsi_for_stmt (stack_save);\n \t      rhs = build_int_cst (TREE_TYPE (gimple_call_arg (call, 0)), 0);\n-\t      update_call_from_tree (&stack_save_gsi, rhs);\n+\t      replace_call_with_value (&stack_save_gsi, rhs);\n \t    }\n \t}\n     }\n@@ -3434,8 +3430,7 @@ pass_fold_builtins::execute (function *fun)\n \t\t  continue;\n \t\t}\n \n-\t      if (!update_call_from_tree (&i, result))\n-\t\tgimplify_and_update_call_from_tree (&i, result);\n+\t      gimplify_and_update_call_from_tree (&i, result);\n \t    }\n \n \t  todoflags |= TODO_update_address_taken;"}, {"sha": "096cfc8721dbd9c0cbe10dc0481dcdfee49eb583", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -1274,8 +1274,7 @@ maybe_optimize_arith_overflow (gimple_stmt_iterator *gsi,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (!update_call_from_tree (gsi, result))\n-    gimplify_and_update_call_from_tree (gsi, result);\n+  gimplify_and_update_call_from_tree (gsi, result);\n }\n \n /* Eliminate unnecessary statements. Any instruction not marked as necessary"}, {"sha": "b3dcd43c00dc6a7676941685773cf2d2f83b0f71", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 299, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -439,302 +439,6 @@ ssa_prop_fini (void)\n }\n \n \n-/* Return true if EXPR is an acceptable right-hand-side for a\n-   GIMPLE assignment.  We validate the entire tree, not just\n-   the root node, thus catching expressions that embed complex\n-   operands that are not permitted in GIMPLE.  This function\n-   is needed because the folding routines in fold-const.c\n-   may return such expressions in some cases, e.g., an array\n-   access with an embedded index addition.  It may make more\n-   sense to have folding routines that are sensitive to the\n-   constraints on GIMPLE operands, rather than abandoning any\n-   any attempt to fold if the usual folding turns out to be too\n-   aggressive.  */\n-\n-bool\n-valid_gimple_rhs_p (tree expr)\n-{\n-  enum tree_code code = TREE_CODE (expr);\n-\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_declaration:\n-      if (!is_gimple_variable (expr))\n-\treturn false;\n-      break;\n-\n-    case tcc_constant:\n-      /* All constants are ok.  */\n-      break;\n-\n-    case tcc_comparison:\n-      /* GENERIC allows comparisons with non-boolean types, reject\n-         those for GIMPLE.  Let vector-typed comparisons pass - rules\n-\t for GENERIC and GIMPLE are the same here.  */\n-      if (!(INTEGRAL_TYPE_P (TREE_TYPE (expr))\n-\t    && (TREE_CODE (TREE_TYPE (expr)) == BOOLEAN_TYPE\n-\t\t|| TYPE_PRECISION (TREE_TYPE (expr)) == 1))\n-\t  && ! VECTOR_TYPE_P (TREE_TYPE (expr)))\n-\treturn false;\n-\n-      /* Fallthru.  */\n-    case tcc_binary:\n-      if (!is_gimple_val (TREE_OPERAND (expr, 0))\n-\t  || !is_gimple_val (TREE_OPERAND (expr, 1)))\n-\treturn false;\n-      break;\n-\n-    case tcc_unary:\n-      if (!is_gimple_val (TREE_OPERAND (expr, 0)))\n-\treturn false;\n-      break;\n-\n-    case tcc_expression:\n-      switch (code)\n-        {\n-        case ADDR_EXPR:\n-          {\n-\t    tree t;\n-\t    if (is_gimple_min_invariant (expr))\n-\t      return true;\n-            t = TREE_OPERAND (expr, 0);\n-            while (handled_component_p (t))\n-              {\n-                /* ??? More checks needed, see the GIMPLE verifier.  */\n-                if ((TREE_CODE (t) == ARRAY_REF\n-                     || TREE_CODE (t) == ARRAY_RANGE_REF)\n-                    && !is_gimple_val (TREE_OPERAND (t, 1)))\n-                  return false;\n-                t = TREE_OPERAND (t, 0);\n-              }\n-            if (!is_gimple_id (t))\n-              return false;\n-          }\n-          break;\n-\n-\tdefault:\n-\t  if (get_gimple_rhs_class (code) == GIMPLE_TERNARY_RHS)\n-\t    {\n-\t      if ((code == COND_EXPR\n-\t\t   ? !is_gimple_condexpr (TREE_OPERAND (expr, 0))\n-\t\t   : !is_gimple_val (TREE_OPERAND (expr, 0)))\n-\t\t  || !is_gimple_val (TREE_OPERAND (expr, 1))\n-\t\t  || !is_gimple_val (TREE_OPERAND (expr, 2)))\n-\t\treturn false;\n-\t      break;\n-\t    }\n-\t  return false;\n-\t}\n-      break;\n-\n-    case tcc_vl_exp:\n-      return false;\n-\n-    case tcc_exceptional:\n-      if (code == CONSTRUCTOR)\n-\t{\n-\t  unsigned i;\n-\t  tree elt;\n-\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (expr), i, elt)\n-\t    if (!is_gimple_val (elt))\n-\t      return false;\n-\t  return true;\n-\t}\n-      if (code != SSA_NAME)\n-        return false;\n-      break;\n-\n-    case tcc_reference:\n-      if (code == BIT_FIELD_REF)\n-\treturn is_gimple_val (TREE_OPERAND (expr, 0));\n-      return false;\n-\n-    default:\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n-\n-/* Return true if EXPR is a CALL_EXPR suitable for representation\n-   as a single GIMPLE_CALL statement.  If the arguments require\n-   further gimplification, return false.  */\n-\n-static bool\n-valid_gimple_call_p (tree expr)\n-{\n-  unsigned i, nargs;\n-\n-  if (TREE_CODE (expr) != CALL_EXPR)\n-    return false;\n-\n-  nargs = call_expr_nargs (expr);\n-  for (i = 0; i < nargs; i++)\n-    {\n-      tree arg = CALL_EXPR_ARG (expr, i);\n-      if (is_gimple_reg_type (TREE_TYPE (arg)))\n-\t{\n-\t  if (!is_gimple_val (arg))\n-\t    return false;\n-\t}\n-      else\n-\tif (!is_gimple_lvalue (arg))\n-\t  return false;\n-    }\n-\n-  return true;\n-}\n-\n-\n-/* Make SSA names defined by OLD_STMT point to NEW_STMT\n-   as their defining statement.  */\n-\n-void\n-move_ssa_defining_stmt_for_defs (gimple *new_stmt, gimple *old_stmt)\n-{\n-  tree var;\n-  ssa_op_iter iter;\n-\n-  if (gimple_in_ssa_p (cfun))\n-    {\n-      /* Make defined SSA_NAMEs point to the new\n-         statement as their definition.  */\n-      FOR_EACH_SSA_TREE_OPERAND (var, old_stmt, iter, SSA_OP_ALL_DEFS)\n-        {\n-          if (TREE_CODE (var) == SSA_NAME)\n-            SSA_NAME_DEF_STMT (var) = new_stmt;\n-        }\n-    }\n-}\n-\n-/* Helper function for update_gimple_call and update_call_from_tree.\n-   A GIMPLE_CALL STMT is being replaced with GIMPLE_CALL NEW_STMT.  */\n-\n-static void\n-finish_update_gimple_call (gimple_stmt_iterator *si_p, gimple *new_stmt,\n-\t\t\t   gimple *stmt)\n-{\n-  gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n-  move_ssa_defining_stmt_for_defs (new_stmt, stmt);\n-  gimple_move_vops (new_stmt, stmt);\n-  gimple_set_location (new_stmt, gimple_location (stmt));\n-  if (gimple_block (new_stmt) == NULL_TREE)\n-    gimple_set_block (new_stmt, gimple_block (stmt));\n-  gsi_replace (si_p, new_stmt, false);\n-}\n-\n-/* Update a GIMPLE_CALL statement at iterator *SI_P to call to FN\n-   with number of arguments NARGS, where the arguments in GIMPLE form\n-   follow NARGS argument.  */\n-\n-bool\n-update_gimple_call (gimple_stmt_iterator *si_p, tree fn, int nargs, ...)\n-{\n-  va_list ap;\n-  gcall *new_stmt, *stmt = as_a <gcall *> (gsi_stmt (*si_p));\n-\n-  gcc_assert (is_gimple_call (stmt));\n-  va_start (ap, nargs);\n-  new_stmt = gimple_build_call_valist (fn, nargs, ap);\n-  finish_update_gimple_call (si_p, new_stmt, stmt);\n-  va_end (ap);\n-  return true;\n-}\n-\n-/* Update a GIMPLE_CALL statement at iterator *SI_P to reflect the\n-   value of EXPR, which is expected to be the result of folding the\n-   call.  This can only be done if EXPR is a CALL_EXPR with valid\n-   GIMPLE operands as arguments, or if it is a suitable RHS expression\n-   for a GIMPLE_ASSIGN.  More complex expressions will require\n-   gimplification, which will introduce additional statements.  In this\n-   event, no update is performed, and the function returns false.\n-   Note that we cannot mutate a GIMPLE_CALL in-place, so we always\n-   replace the statement at *SI_P with an entirely new statement.\n-   The new statement need not be a call, e.g., if the original call\n-   folded to a constant.  */\n-\n-bool\n-update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n-{\n-  gimple *stmt = gsi_stmt (*si_p);\n-\n-  if (valid_gimple_call_p (expr))\n-    {\n-      /* The call has simplified to another call.  */\n-      tree fn = CALL_EXPR_FN (expr);\n-      unsigned i;\n-      unsigned nargs = call_expr_nargs (expr);\n-      vec<tree> args = vNULL;\n-      gcall *new_stmt;\n-\n-      if (nargs > 0)\n-        {\n-          args.create (nargs);\n-\t  args.safe_grow_cleared (nargs, true);\n-\n-          for (i = 0; i < nargs; i++)\n-            args[i] = CALL_EXPR_ARG (expr, i);\n-        }\n-\n-      new_stmt = gimple_build_call_vec (fn, args);\n-      finish_update_gimple_call (si_p, new_stmt, stmt);\n-      args.release ();\n-\n-      return true;\n-    }\n-  else if (valid_gimple_rhs_p (expr))\n-    {\n-      tree lhs = gimple_call_lhs (stmt);\n-      gimple *new_stmt;\n-\n-      /* The call has simplified to an expression\n-         that cannot be represented as a GIMPLE_CALL. */\n-      if (lhs)\n-        {\n-          /* A value is expected.\n-             Introduce a new GIMPLE_ASSIGN statement.  */\n-          STRIP_USELESS_TYPE_CONVERSION (expr);\n-          new_stmt = gimple_build_assign (lhs, expr);\n-          move_ssa_defining_stmt_for_defs (new_stmt, stmt);\n-\t  gimple_move_vops (new_stmt, stmt);\n-        }\n-      else if (!TREE_SIDE_EFFECTS (expr))\n-        {\n-          /* No value is expected, and EXPR has no effect.\n-             Replace it with an empty statement.  */\n-          new_stmt = gimple_build_nop ();\n-\t  if (gimple_in_ssa_p (cfun))\n-\t    {\n-\t      unlink_stmt_vdef (stmt);\n-\t      release_defs (stmt);\n-\t    }\n-        }\n-      else\n-        {\n-          /* No value is expected, but EXPR has an effect,\n-             e.g., it could be a reference to a volatile\n-             variable.  Create an assignment statement\n-             with a dummy (unused) lhs variable.  */\n-          STRIP_USELESS_TYPE_CONVERSION (expr);\n-\t  if (gimple_in_ssa_p (cfun))\n-\t    lhs = make_ssa_name (TREE_TYPE (expr));\n-\t  else\n-\t    lhs = create_tmp_var (TREE_TYPE (expr));\n-          new_stmt = gimple_build_assign (lhs, expr);\n-\t  gimple_move_vops (new_stmt, stmt);\n-          move_ssa_defining_stmt_for_defs (new_stmt, stmt);\n-        }\n-      gimple_set_location (new_stmt, gimple_location (stmt));\n-      gsi_replace (si_p, new_stmt, false);\n-      return true;\n-    }\n-  else\n-    /* The call simplified to an expression that is\n-       not a valid GIMPLE RHS.  */\n-    return false;\n-}\n-\n /* Entry point to the propagation engine.\n \n    The VISIT_STMT virtual function is called for every statement\n@@ -1539,10 +1243,8 @@ propagate_tree_value_into_stmt (gimple_stmt_iterator *gsi, tree val)\n            && gimple_call_lhs (stmt) != NULL_TREE)\n     {\n       tree expr = NULL_TREE;\n-      bool res;\n       propagate_tree_value (&expr, val);\n-      res = update_call_from_tree (gsi, expr);\n-      gcc_assert (res);\n+      replace_call_with_value (gsi, expr);\n     }\n   else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n     propagate_tree_value (gimple_switch_index_ptr (swtch_stmt), val);"}, {"sha": "5257fbb0cf8e5b04eda13494c6399b8d180205a3", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -63,10 +63,7 @@ enum ssa_prop_result {\n };\n \n \n-extern bool valid_gimple_rhs_p (tree);\n extern void move_ssa_defining_stmt_for_defs (gimple *, gimple *);\n-extern bool update_gimple_call (gimple_stmt_iterator *, tree, int, ...);\n-extern bool update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool stmt_makes_single_store (gimple *);\n extern bool may_propagate_copy (tree, tree);\n extern bool may_propagate_copy_into_stmt (gimple *, tree);"}, {"sha": "c7b5e2c6e6b2e2f6b03326d2a3fa11e85ff02140", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -2158,8 +2158,7 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t  if (bound)\n \t    rhs = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (rhs), rhs, bound);\n \n-\t  if (!update_call_from_tree (gsi, rhs))\n-\t    gimplify_and_update_call_from_tree (gsi, rhs);\n+\t  gimplify_and_update_call_from_tree (gsi, rhs);\n \t  stmt = gsi_stmt (*gsi);\n \t  update_stmt (stmt);\n \t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n@@ -2258,8 +2257,7 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      }\n \t    if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (ret)))\n \t      ret = fold_convert_loc (loc, TREE_TYPE (lhs), ret);\n-\t    if (!update_call_from_tree (gsi, ret))\n-\t      gimplify_and_update_call_from_tree (gsi, ret);\n+\t    gimplify_and_update_call_from_tree (gsi, ret);\n \t    stmt = gsi_stmt (*gsi);\n \t    update_stmt (stmt);\n \t    if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n@@ -2337,8 +2335,7 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n \t\t\t\t\t      TREE_TYPE (rhs)))\n \t\trhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n \t    }\n-\t  if (!update_call_from_tree (gsi, rhs))\n-\t    gimplify_and_update_call_from_tree (gsi, rhs);\n+\t  gimplify_and_update_call_from_tree (gsi, rhs);\n \t  stmt = gsi_stmt (*gsi);\n \t  update_stmt (stmt);\n \t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)"}, {"sha": "a1868b661e66575447af43f4e578fd6e3cdc4509", "filename": "gcc/tsan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a5515ed6619739eb122f05ce26057dd8b06fb6/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=52a5515ed6619739eb122f05ce26057dd8b06fb6", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify-me.h\"\n #include \"tree-cfg.h\"\n #include \"tree-iterator.h\"\n-#include \"tree-ssa-propagate.h\"\n+#include \"gimple-fold.h\"\n #include \"tree-ssa-loop-ivopts.h\"\n #include \"tree-eh.h\"\n #include \"tsan.h\""}]}