{"sha": "7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NiZWZmZTJmYjVhMTljZTFhZTIyZTFhMWU1NjU0ZWI5NTFjZTkwMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2004-12-15T17:59:51Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2004-12-15T17:59:51Z"}, "message": "PR middle end/17340\n\n2004-12-15  Vladimir Makarov  <vmakarov@redhat.com>\n            Steven Bosscher  <stevenb@suse.de>\n\tPR middle end/17340\n\n\t* global.c: Update comments in a few places.\n\t(check_earlyclobber): Return true if there are early clobber\n\tclasses.\n        (calculate_local_reg_bb_info): Do not try to mark earlyclobber\n\tregs if there are none.\n\t(bb_info, allocate_bb_info, free_bb_info, modify_reg_pav,\n\tmake_accurate_live_analysis): Rename pavin, pavout to live_pavin,\n\tlive_pavout.\n\t(modify_bb_reg_pav): Remove.\n\t(calculate_reg_pav): Use code from modify_bb_reg_pav.\n\t(temp_bitmap): New variable.\n\t(calculate_reg_pav): Allocate/deallocate temp_bitmap.\n\nCo-Authored-By: Steven Bosscher <stevenb@suse.de>\n\nFrom-SVN: r92206", "tree": {"sha": "7129a59f3c973d005dd723a0771e408df66fde79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7129a59f3c973d005dd723a0771e408df66fde79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dcbca208a35a734fb1098661ae4681f23b197cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbca208a35a734fb1098661ae4681f23b197cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcbca208a35a734fb1098661ae4681f23b197cb9"}], "stats": {"total": 172, "additions": 106, "deletions": 66}, "files": [{"sha": "6b987df1fa4a25baad93aeaae36a3c0c9c89809e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901", "patch": "@@ -1,3 +1,20 @@\n+2004-12-15  Vladimir Makarov  <vmakarov@redhat.com>\n+            Steven Bosscher  <stevenb@suse.de>\n+\tPR middle end/17340\n+\n+\t* global.c: Update comments in a few places.\n+\t(check_earlyclobber): Return true if there are early clobber\n+\tclasses.\n+        (calculate_local_reg_bb_info): Do not try to mark earlyclobber\n+\tregs if there are none.\n+\t(bb_info, allocate_bb_info, free_bb_info, modify_reg_pav,\n+\tmake_accurate_live_analysis): Rename pavin, pavout to live_pavin,\n+\tlive_pavout.\n+\t(modify_bb_reg_pav): Remove.\n+\t(calculate_reg_pav): Use code from modify_bb_reg_pav.\n+\t(temp_bitmap): New variable.\n+\t(calculate_reg_pav): Allocate/deallocate temp_bitmap.\n+\t\n 2004-12-15  Richard Henderson  <rth@redhat.com>\n \n \tPR target/19010"}, {"sha": "86448171ea26e62963261391b9b4c86d45ac1ff2", "filename": "gcc/global.c", "status": "modified", "additions": 89, "deletions": 66, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=7cbeffe2fb5a19ce1ae22e1a1e5654eb951ce901", "patch": "@@ -308,14 +308,13 @@ static void reg_dies (int, enum machine_mode, struct insn_chain *);\n \n static void allocate_bb_info (void);\n static void free_bb_info (void);\n-static void check_earlyclobber (rtx);\n+static bool check_earlyclobber (rtx);\n static bool regclass_intersect (enum reg_class, enum reg_class);\n static void mark_reg_use_for_earlyclobber_1 (rtx *, void *);\n static int mark_reg_use_for_earlyclobber (rtx *, void *);\n static void calculate_local_reg_bb_info (void);\n static void set_up_bb_rts_numbers (void);\n static int rpost_cmp (const void *, const void *);\n-static bool modify_bb_reg_pav (basic_block, basic_block, bool);\n static void calculate_reg_pav (void);\n static void modify_reg_pav (void);\n static void make_accurate_live_analysis (void);\n@@ -2011,9 +2010,10 @@ struct bb_info\n   /* Registers correspondingly killed (clobbered) and defined but not\n      killed afterward in the basic block.  */\n   bitmap killed, avloc;\n-  /* Registers partially available correspondingly at the start and\n-     end of the basic block.  */\n-  bitmap pavin, pavout;\n+  /* Registers partially available and living (in other words whose\n+     values were calclualted and used) correspondingly at the start\n+     and end of the basic block.  */\n+  bitmap live_pavin, live_pavout;\n };\n \n /* Macros for accessing data flow information of basic blocks.  */\n@@ -2022,8 +2022,8 @@ struct bb_info\n #define BB_INFO_BY_INDEX(N) BB_INFO (BASIC_BLOCK(N))\n \n /* The function allocates the info structures of each basic block.  It\n-   also initialized PAVIN and PAVOUT as if all hard registers were\n-   partially available.  */\n+   also initialized LIVE_PAVIN and LIVE_PAVOUT as if all hard\n+   registers were partially available.  */\n \n static void\n allocate_bb_info (void)\n@@ -2043,10 +2043,10 @@ allocate_bb_info (void)\n       bb_info->earlyclobber = BITMAP_XMALLOC ();\n       bb_info->avloc = BITMAP_XMALLOC ();\n       bb_info->killed = BITMAP_XMALLOC ();\n-      bb_info->pavin = BITMAP_XMALLOC ();\n-      bb_info->pavout = BITMAP_XMALLOC ();\n-      bitmap_copy (bb_info->pavin, init);\n-      bitmap_copy (bb_info->pavout, init);\n+      bb_info->live_pavin = BITMAP_XMALLOC ();\n+      bb_info->live_pavout = BITMAP_XMALLOC ();\n+      bitmap_copy (bb_info->live_pavin, init);\n+      bitmap_copy (bb_info->live_pavout, init);\n     }\n   BITMAP_XFREE (init);\n }\n@@ -2062,8 +2062,8 @@ free_bb_info (void)\n   FOR_EACH_BB (bb)\n     {\n       bb_info = BB_INFO (bb);\n-      BITMAP_XFREE (bb_info->pavout);\n-      BITMAP_XFREE (bb_info->pavin);\n+      BITMAP_XFREE (bb_info->live_pavout);\n+      BITMAP_XFREE (bb_info->live_pavin);\n       BITMAP_XFREE (bb_info->killed);\n       BITMAP_XFREE (bb_info->avloc);\n       BITMAP_XFREE (bb_info->earlyclobber);\n@@ -2101,13 +2101,15 @@ mark_reg_change (rtx reg, rtx setter, void *data)\n \n static varray_type earlyclobber_regclass;\n \n-/* The function stores classes of registers which could be early\n-   clobbered in INSN.  */\n+/* This function finds and stores register classes that could be early\n+   clobbered in INSN.  If any earlyclobber classes are found, the function\n+   returns TRUE, in all other cases it returns FALSE.  */\n \n-static void\n+static bool\n check_earlyclobber (rtx insn)\n {\n   int opno;\n+  bool found = false;\n \n   extract_insn (insn);\n \n@@ -2148,6 +2150,7 @@ check_earlyclobber (rtx insn)\n \t    case ',':\n \t      if (amp_p && class != NO_REGS)\n \t\t{\n+\t\t  found = true;\n \t\t  for (i = VARRAY_ACTIVE_SIZE (earlyclobber_regclass) - 1;\n \t\t       i >= 0; i--)\n \t\t    if (VARRAY_INT (earlyclobber_regclass, i) == (int) class)\n@@ -2173,6 +2176,8 @@ check_earlyclobber (rtx insn)\n \t  p += CONSTRAINT_LEN (c, p);\n \t}\n     }\n+\n+  return found;\n }\n \n /* The function returns true if register classes C1 and C2 intersect.  */\n@@ -2193,7 +2198,8 @@ regclass_intersect (enum reg_class c1, enum reg_class c2)\n \n /* The function checks that pseudo-register *X has a class\n    intersecting with the class of pseudo-register could be early\n-   clobbered in the same insn.  */\n+   clobbered in the same insn.\n+   This function is a no-op if earlyclobber_regclass is empty.  */\n \n static int\n mark_reg_use_for_earlyclobber (rtx *x, void *data ATTRIBUTE_UNUSED)\n@@ -2251,8 +2257,8 @@ calculate_local_reg_bb_info (void)\n \tif (INSN_P (insn))\n \t  {\n \t    note_stores (PATTERN (insn), mark_reg_change, bb);\n-\t    check_earlyclobber (insn);\n-\t    note_uses (&PATTERN (insn), mark_reg_use_for_earlyclobber_1, bb);\n+\t    if (check_earlyclobber (insn))\n+\t      note_uses (&PATTERN (insn), mark_reg_use_for_earlyclobber_1, bb);\n \t  }\n     }\n }\n@@ -2283,47 +2289,31 @@ rpost_cmp (const void *bb1, const void *bb2)\n   return BB_INFO (b2)->rts_number - BB_INFO (b1)->rts_number;\n }\n \n-/* The function calculates partial availability of registers.  The\n-   function calculates partial availability at the end of basic block\n-   BB by propagating partial availability at end of predecessor basic\n-   block PRED.  The function returns true if the partial availability\n-   at the end of BB has been changed or if CHANGED_P.  We have the\n-   following equations:\n-\n-     bb.pavin = empty for entry block | union (pavout of predecessors)\n-     bb.pavout = union (bb.pavin - b.killed, bb.avloc)  */\n+/* Temporary bitmap used for live_pavin, live_pavout calculation.  */\n+static bitmap temp_bitmap;\n \n-static bool\n-modify_bb_reg_pav (basic_block bb, basic_block pred, bool changed_p)\n-{\n-  struct bb_info *bb_info;\n-  bitmap bb_pavin, bb_pavout;\n-\n-  bb_info = BB_INFO (bb);\n-  bb_pavin = bb_info->pavin;\n-  bb_pavout = bb_info->pavout;\n-  if (pred->index != ENTRY_BLOCK)\n-    bitmap_ior_into (bb_pavin, BB_INFO (pred)->pavout);\n-  changed_p |= bitmap_ior_and_compl (bb_pavout, bb_info->avloc,\n-\t\t\t\t     bb_pavin, bb_info->killed);\n-  return changed_p;\n-}\n+/* The function calculates partial register availability according to\n+   the following equations:\n \n-/* The function calculates partial register availability.  */\n+     bb.live_pavin\n+       = empty for entry block\n+         | union (live_pavout of predecessors) & global_live_at_start\n+     bb.live_pavout = union (bb.live_pavin - bb.killed, bb.avloc)\n+                      & global_live_at_end  */\n \n static void\n calculate_reg_pav (void)\n {\n   basic_block bb, succ;\n   edge e;\n-  bool changed_p;\n   int i, nel;\n   varray_type bbs, new_bbs, temp;\n   basic_block *bb_array;\n   sbitmap wset;\n \n   VARRAY_BB_INIT (bbs, n_basic_blocks, \"basic blocks\");\n   VARRAY_BB_INIT (new_bbs, n_basic_blocks, \"basic blocks for the next iter.\");\n+  temp_bitmap = BITMAP_XMALLOC ();\n   FOR_EACH_BB (bb)\n     {\n       VARRAY_PUSH_BB (bbs, bb);\n@@ -2338,28 +2328,46 @@ calculate_reg_pav (void)\n       for (i = 0; i < nel; i++)\n \t{\n \t  edge_iterator ei;\n-\n+\t  struct bb_info *bb_info;\n+\t  bitmap bb_live_pavin, bb_live_pavout;\n+\t      \n \t  bb = bb_array [i];\n-\t  changed_p = 0;\n+\t  bb_info = BB_INFO (bb);\n+\t  bb_live_pavin = bb_info->live_pavin;\n+\t  bb_live_pavout = bb_info->live_pavout;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    changed_p = modify_bb_reg_pav (bb, e->src, changed_p);\n-\t  if (changed_p)\n-\t    FOR_EACH_EDGE (e, ei, bb->succs)\n-\t      {\n-\t\tsucc = e->dest;\n-\t\tif (succ->index != EXIT_BLOCK && !TEST_BIT (wset, succ->index))\n-\t\t  {\n-\t\t    SET_BIT (wset, succ->index);\n-\t\t    VARRAY_PUSH_BB (new_bbs, succ);\n-\t\t  }\n-\t      }\n+\t    {\n+\t      basic_block pred = e->src;\n+\n+\t      if (pred->index != ENTRY_BLOCK)\n+\t\tbitmap_ior_into (bb_live_pavin, BB_INFO (pred)->live_pavout);\n+\t    }\n+\t  bitmap_and_into (bb_live_pavin, bb->global_live_at_start);\n+\t  bitmap_ior_and_compl (temp_bitmap, bb_info->avloc,\n+\t\t\t\tbb_live_pavin, bb_info->killed);\n+\t  bitmap_and_into (temp_bitmap, bb->global_live_at_end);\n+\t  if (! bitmap_equal_p (temp_bitmap, bb_live_pavout))\n+\t    {\n+\t      bitmap_copy (bb_live_pavout, temp_bitmap);\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t{\n+\t\t  succ = e->dest;\n+\t\t  if (succ->index != EXIT_BLOCK\n+\t\t      && !TEST_BIT (wset, succ->index))\n+\t\t    {\n+\t\t      SET_BIT (wset, succ->index);\n+\t\t      VARRAY_PUSH_BB (new_bbs, succ);\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n       temp = bbs;\n       bbs = new_bbs;\n       new_bbs = temp;\n       VARRAY_POP_ALL (new_bbs);\n     }\n   sbitmap_free (wset);\n+  BITMAP_XFREE (temp_bitmap);\n }\n \n /* The function modifies partial availability information for two\n@@ -2402,14 +2410,14 @@ modify_reg_pav (void)\n \t insn if the pseudo-register is used first time in given BB\n \t and not lived at the BB start.  To prevent this we don't\n \t change life information for such pseudo-registers.  */\n-      bitmap_ior_into (bb_info->pavin, bb_info->earlyclobber);\n+      bitmap_ior_into (bb_info->live_pavin, bb_info->earlyclobber);\n #ifdef STACK_REGS\n       /* We can not use the same stack register for uninitialized\n \t pseudo-register and another living pseudo-register because if the\n \t uninitialized pseudo-register dies, subsequent pass reg-stack\n \t will be confused (it will believe that the other register\n \t dies).  */\n-      bitmap_ior_into (bb_info->pavin, stack_regs);\n+      bitmap_ior_into (bb_info->live_pavin, stack_regs);\n #endif\n     }\n #ifdef STACK_REGS\n@@ -2419,10 +2427,25 @@ modify_reg_pav (void)\n \n /* The following function makes live information more accurate by\n    modifying global_live_at_start and global_live_at_end of basic\n-   blocks.  After the function call a register lives at a program\n-   point only if it is initialized on a path from CFG entry to the\n-   program point.  The standard GCC life analysis permits registers to\n-   live uninitialized.  */\n+   blocks.\n+\n+   The standard GCC life analysis permits registers to live\n+   uninitialized, for example:\n+\n+       R is never used\n+       .....\n+       Loop:\n+         R is defined\n+       ...\n+       R is used.\n+\n+   With normal life_analysis, R would be live before \"Loop:\".\n+   The result is that R causes many interferences that do not\n+   serve any purpose.\n+\n+   After the function call a register lives at a program point\n+   only if it is initialized on a path from CFG entry to the\n+   program point.  */\n \n static void\n make_accurate_live_analysis (void)\n@@ -2441,8 +2464,8 @@ make_accurate_live_analysis (void)\n     {\n       bb_info = BB_INFO (bb);\n       \n-      bitmap_and_into (bb->global_live_at_start, bb_info->pavin);\n-      bitmap_and_into (bb->global_live_at_end, bb_info->pavout);\n+      bitmap_and_into (bb->global_live_at_start, bb_info->live_pavin);\n+      bitmap_and_into (bb->global_live_at_end, bb_info->live_pavout);\n     }\n   free_bb_info ();\n }"}]}