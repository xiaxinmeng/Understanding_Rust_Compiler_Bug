{"sha": "032713aa55dfe47961798f5ff42e5d660c37f24b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMyNzEzYWE1NWRmZTQ3OTYxNzk4ZjVmZjQyZTVkNjYwYzM3ZjI0Yg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-01-26T22:48:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-26T22:48:32Z"}, "message": "toplev.c: Add -dM command line option to dump RTL after the machine dependent...\n\n        * toplev.c: Add -dM command line option to dump RTL after the\n        machine dependent reorganisation pass, if there is one.\n        Reorganise RTL dump code, so that only one file handle is\n        needed.\n\nFrom-SVN: r17494", "tree": {"sha": "d95151da564ed50fce91a09ea3bbd05337d52f73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d95151da564ed50fce91a09ea3bbd05337d52f73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/032713aa55dfe47961798f5ff42e5d660c37f24b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032713aa55dfe47961798f5ff42e5d660c37f24b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/032713aa55dfe47961798f5ff42e5d660c37f24b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032713aa55dfe47961798f5ff42e5d660c37f24b/comments", "author": null, "committer": null, "parents": [{"sha": "ec2be682fbc995f58fe370243e70bb711f799f8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2be682fbc995f58fe370243e70bb711f799f8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec2be682fbc995f58fe370243e70bb711f799f8f"}], "stats": {"total": 793, "additions": 339, "deletions": 454}, "files": [{"sha": "9dd7f578ccb053894321e840a627a2cad3d4e3cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032713aa55dfe47961798f5ff42e5d660c37f24b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032713aa55dfe47961798f5ff42e5d660c37f24b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=032713aa55dfe47961798f5ff42e5d660c37f24b", "patch": "@@ -1,3 +1,10 @@\n+Fri Jan 23 09:39:36 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* toplev.c: Add -dM command line option to dump RTL after the\n+\tmachine dependent reorganisation pass, if there is one.\n+\tReorganise RTL dump code, so that only one file handle is\n+\tneeded. \n+\n Mon Jan 26 12:09:42 1998  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n \n \t* except.c (check_exception_handler_labels): Disable warning when"}, {"sha": "ef833830261e1b1c7c2fec37200eb0cec4e492c6", "filename": "gcc/invoke.texi", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032713aa55dfe47961798f5ff42e5d660c37f24b/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032713aa55dfe47961798f5ff42e5d660c37f24b/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=032713aa55dfe47961798f5ff42e5d660c37f24b", "patch": "@@ -1924,58 +1924,48 @@ name (e.g.  @file{foo.c.rtl} or @file{foo.c.jump}).  Here are the\n possible letters for use in @var{letters}, and their meanings:\n \n @table @samp\n-@item M\n-Dump all macro definitions, at the end of preprocessing, and write no\n-output.\n-@item N\n-Dump all macro names, at the end of preprocessing.\n-@item D\n-Dump all macro definitions, at the end of preprocessing, in addition to\n-normal output.\n-@item y\n-Dump debugging information during parsing, to standard error.\n-@item r\n-Dump after RTL generation, to @file{@var{file}.rtl}.\n-@item x\n-Just generate RTL for a function instead of compiling it.  Usually used\n-with @samp{r}.\n-@item j\n-Dump after first jump optimization, to @file{@var{file}.jump}.\n-@item s\n-Dump after CSE (including the jump optimization that sometimes\n-follows CSE), to @file{@var{file}.cse}.\n-@item D\n-Dump after purging ADDRESSOF, to @file{@var{file}.addressof}.\n-@item L\n-Dump after loop optimization, to @file{@var{file}.loop}.\n-@item t\n-Dump after the second CSE pass (including the jump optimization that\n-sometimes follows CSE), to @file{@var{file}.cse2}.\n @item b\n Dump after computing branch probabilities, to @file{@var{file}.bp}.\n+@item c\n+Dump after instruction combination, to the file @file{@var{file}.combine}.\n+@item d\n+Dump after delayed branch scheduling, to @file{@var{file}.dbr}.\n+@item D\n+Dump after purging ADDRESSOF, to @file{@var{file}.addressof}.\n @item f\n Dump after flow analysis, to @file{@var{file}.flow}.\n-@item c\n-Dump after instruction combination, to the file\n-@file{@var{file}.combine}.\n-@item S\n-Dump after the first instruction scheduling pass, to\n-@file{@var{file}.sched}.\n-@item l\n-Dump after local register allocation, to\n-@file{@var{file}.lreg}.\n @item g\n-Dump after global register allocation, to\n-@file{@var{file}.greg}.\n-@item R\n-Dump after the second instruction scheduling pass, to\n-@file{@var{file}.sched2}.\n+Dump after global register allocation, to @file{@var{file}.greg}.\n+@item j\n+Dump after first jump optimization, to @file{@var{file}.jump}.\n @item J\n Dump after last jump optimization, to @file{@var{file}.jump2}.\n-@item d\n-Dump after delayed branch scheduling, to @file{@var{file}.dbr}.\n @item k\n Dump after conversion from registers to stack, to @file{@var{file}.stack}.\n+@item l\n+Dump after local register allocation, to @file{@var{file}.lreg}.\n+@item L\n+Dump after loop optimization, to @file{@var{file}.loop}.\n+@item M\n+Dump after performing the machine dependent reorganisation pass, to\n+@file{@var{file}.mach}. \n+@item N\n+Dump after the register move pass, to @file{@var{file}.regmove}.\n+@item r\n+Dump after RTL generation, to @file{@var{file}.rtl}.\n+@item R\n+Dump after the second instruction scheduling pass, to @file{@var{file}.sched2}.\n+@item s\n+Dump after CSE (including the jump optimization that sometimes follows\n+CSE), to @file{@var{file}.cse}. \n+@item S\n+Dump after the first instruction scheduling pass, to @file{@var{file}.sched}.\n+@item t\n+Dump after the second CSE pass (including the jump optimization that\n+sometimes follows CSE), to @file{@var{file}.cse2}. \n+@item x\n+Just generate RTL for a function instead of compiling it.  Usually used\n+with @samp{r}.\n @item a\n Produce all the dumps listed above.\n @item m\n@@ -1984,6 +1974,8 @@ standard error.\n @item p\n Annotate the assembler output with a comment indicating which\n pattern and alternative was used.\n+@item y\n+Dump debugging information during parsing, to standard error.\n @item A\n Annotate the assembler output with miscellaneous debugging information.\n @end table"}, {"sha": "7c9ca603527f9f1612be55c10a4a38b6412e4f9b", "filename": "gcc/toplev.c", "status": "modified", "additions": 297, "deletions": 411, "changes": 708, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032713aa55dfe47961798f5ff42e5d660c37f24b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032713aa55dfe47961798f5ff42e5d660c37f24b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=032713aa55dfe47961798f5ff42e5d660c37f24b", "patch": "@@ -163,6 +163,9 @@ extern void dump_sched_info ();\n extern void dump_local_alloc ();\n extern void regset_release_memory ();\n \n+extern void print_rtl ();\n+extern void print_rtl_with_bb ();\n+\n void rest_of_decl_compilation ();\n void error_with_file_and_line PVPROTO((char *file, int line, char *s, ...));\n void error_with_decl PVPROTO((tree decl, char *s, ...));\n@@ -264,7 +267,12 @@ int sched2_dump = 0;\n int jump2_opt_dump = 0;\n int dbr_sched_dump = 0;\n int flag_print_asm_name = 0;\n+#ifdef STACK_REGS\n int stack_reg_dump = 0;\n+#endif\n+#ifdef MACHINE_DEPENDENT_REORG\n+int mach_dep_reorg_dump = 0;\n+#endif\n \n /* Name for output file of assembly code, specified with -o.  */\n \n@@ -947,23 +955,7 @@ struct { char *string; int *variable; int on_value;} W_options[] =\n \n FILE *asm_out_file;\n FILE *aux_info_file;\n-FILE *rtl_dump_file;\n-FILE *jump_opt_dump_file;\n-FILE *addressof_dump_file;\n-FILE *cse_dump_file;\n-FILE *loop_dump_file;\n-FILE *cse2_dump_file;\n-FILE *branch_prob_dump_file;\n-FILE *flow_dump_file;\n-FILE *combine_dump_file;\n-FILE *regmove_dump_file;\n-FILE *sched_dump_file;\n-FILE *local_reg_dump_file;\n-FILE *global_reg_dump_file;\n-FILE *sched2_dump_file;\n-FILE *jump2_opt_dump_file;\n-FILE *dbr_sched_dump_file;\n-FILE *stack_reg_dump_file;\n+FILE *rtl_dump_file = NULL;\n \n /* Time accumulators, to count the total time spent in various passes.  */\n \n@@ -1122,38 +1114,8 @@ fatal_insn (message, insn)\n     fflush (asm_out_file);\n   if (aux_info_file)\n     fflush (aux_info_file);\n-  if (rtl_dump_file)\n+  if (rtl_dump_file != NULL)\n     fflush (rtl_dump_file);\n-  if (jump_opt_dump_file)\n-    fflush (jump_opt_dump_file);\n-  if (addressof_dump_file)\n-    fflush (addressof_dump_file);\n-  if (cse_dump_file)\n-    fflush (cse_dump_file);\n-  if (loop_dump_file)\n-    fflush (loop_dump_file);\n-  if (cse2_dump_file)\n-    fflush (cse2_dump_file);\n-  if (flow_dump_file)\n-    fflush (flow_dump_file);\n-  if (combine_dump_file)\n-    fflush (combine_dump_file);\n-  if (regmove_dump_file)\n-    fflush (regmove_dump_file);\n-  if (sched_dump_file)\n-    fflush (sched_dump_file);\n-  if (local_reg_dump_file)\n-    fflush (local_reg_dump_file);\n-  if (global_reg_dump_file)\n-    fflush (global_reg_dump_file);\n-  if (sched2_dump_file)\n-    fflush (sched2_dump_file);\n-  if (jump2_opt_dump_file)\n-    fflush (jump2_opt_dump_file);\n-  if (dbr_sched_dump_file)\n-    fflush (dbr_sched_dump_file);\n-  if (stack_reg_dump_file)\n-    fflush (stack_reg_dump_file);\n   fflush (stdout);\n   fflush (stderr);\n   abort ();\n@@ -2183,23 +2145,97 @@ output_lang_identify (asm_out_file)\n }\n \n /* Routine to open a dump file.  */\n+static void\n+open_dump_file (suffix, function_name)\n+     char *suffix;\n+     char *function_name;\n+{\n+  char *dumpname;\n \n-static FILE *\n-open_dump_file (base_name, suffix)\n-     char *base_name;\n+  TIMEVAR\n+    (dump_time,\n+     {\n+       dumpname = (char *) xmalloc (strlen (dump_base_name) + strlen (suffix) + 1);\n+\n+       if (rtl_dump_file != NULL)\n+\t fclose (rtl_dump_file);\n+  \n+       strcpy (dumpname, dump_base_name);\n+       strcat (dumpname, suffix);\n+       \n+       rtl_dump_file = fopen (dumpname, \"a\");\n+       \n+       if (rtl_dump_file == NULL)\n+\t pfatal_with_name (dumpname);\n+       \n+       free (dumpname);\n+\n+       if (function_name)\n+\t fprintf (rtl_dump_file, \"\\n;; Function %s\\n\\n\", function_name);\n+     });\n+  \n+  return;\n+}\n+\n+/* Routine to close a dump file.  */\n+static void\n+close_dump_file (func, insns)\n+     void (*func)(FILE *, rtx);\n+     rtx    insns;\n+{\n+  TIMEVAR\n+    (dump_time,\n+     {\n+       if (func)\n+\t func (rtl_dump_file, insns);\n+       \n+       fflush (rtl_dump_file);\n+       fclose (rtl_dump_file);\n+       \n+       rtl_dump_file = NULL;\n+     });\n+\n+  return;\n+}\n+\n+/* Routine to dump rtl into a file.  */\n+static void\n+dump_rtl (suffix, decl, func, insns)\n      char *suffix;\n+     tree   decl;\n+     void (*func)(FILE *, rtx);\n+     rtx    insns;\n+{\n+  open_dump_file (suffix, decl_printable_name (decl, 2));\n+  close_dump_file (func, insns);\n+}\n+\n+/* Routine to empty a dump file.  */\n+static void\n+clean_dump_file (suffix)\n+     char * suffix;\n {\n-  FILE *f;\n-  char *dumpname = (char *) alloca (strlen (base_name) + strlen (suffix) + 1);\n+  char * dumpname;\n+\n+  dumpname = (char *) xmalloc (strlen (dump_base_name) + strlen (suffix) + 1);\n \n-  strcpy (dumpname, base_name);\n+  strcpy (dumpname, dump_base_name);\n   strcat (dumpname, suffix);\n-  f = fopen (dumpname, \"w\");\n-  if (f == 0)\n-    pfatal_with_name (dumpname);\n-  return f;\n+       \n+  rtl_dump_file = fopen (dumpname, \"w\");\n+\n+  if (rtl_dump_file == NULL)\n+    pfatal_with_name (dumpname);       \n+\n+  free (dumpname);\n+\n+  fclose (rtl_dump_file);\n+  rtl_dump_file = NULL;\n+  \n+  return;\n }\n \n+\n /* Compile an entire file of output from cpp, named NAME.\n    Write a file of assembly output and various debugging dumps.  */\n \n@@ -2291,76 +2327,46 @@ compile_file (name)\n \tpfatal_with_name (aux_info_file_name);\n     }\n \n-  /* If rtl dump desired, open the output file.  */\n+  /* Clear the dump files file.  */\n   if (rtl_dump)\n-    rtl_dump_file = open_dump_file (dump_base_name, \".rtl\");\n-\n-  /* If jump_opt dump desired, open the output file.  */\n+    clean_dump_file (\".rtl\");\n   if (jump_opt_dump)\n-    jump_opt_dump_file = open_dump_file (dump_base_name, \".jump\");\n-\n-  /* If addressof dump desired, open the output file.  */\n+    clean_dump_file (\".jump\");\n   if (addressof_dump)\n-    addressof_dump_file = open_dump_file (dump_base_name, \".addressof\");\n-\n-  /* If cse dump desired, open the output file.  */\n+    clean_dump_file (\".addressof\");\n   if (cse_dump)\n-    cse_dump_file = open_dump_file (dump_base_name, \".cse\");\n-\n-  /* If loop dump desired, open the output file.  */\n+    clean_dump_file (\".cse\");\n   if (loop_dump)\n-    loop_dump_file = open_dump_file (dump_base_name, \".loop\");\n-\n-  /* If cse2 dump desired, open the output file.  */\n+    clean_dump_file (\".loop\");\n   if (cse2_dump)\n-    cse2_dump_file = open_dump_file (dump_base_name, \".cse2\");\n-\n-  /* If branch_prob dump desired, open the output file.  */\n+    clean_dump_file (\".cse2\");\n   if (branch_prob_dump)\n-    branch_prob_dump_file = open_dump_file (dump_base_name, \".bp\");\n-\n-  /* If flow dump desired, open the output file.  */\n+    clean_dump_file (\".bp\");\n   if (flow_dump)\n-    flow_dump_file = open_dump_file (dump_base_name, \".flow\");\n-\n-  /* If combine dump desired, open the output file.  */\n+    clean_dump_file (\".flow\");\n   if (combine_dump)\n-    combine_dump_file = open_dump_file (dump_base_name, \".combine\");\n-\n-  /* If regmove dump desired, open the output file.  */\n+    clean_dump_file (\".combine\");\n   if (regmove_dump)\n-    regmove_dump_file = open_dump_file (dump_base_name, \".regmove\");\n-\n-  /* If scheduling dump desired, open the output file.  */\n+    clean_dump_file (\".regmove\");\n   if (sched_dump)\n-    sched_dump_file = open_dump_file (dump_base_name, \".sched\");\n-\n-  /* If local_reg dump desired, open the output file.  */\n+    clean_dump_file (\".sched\");\n   if (local_reg_dump)\n-    local_reg_dump_file = open_dump_file (dump_base_name, \".lreg\");\n-\n-  /* If global_reg dump desired, open the output file.  */\n+    clean_dump_file (\".lreg\");\n   if (global_reg_dump)\n-    global_reg_dump_file = open_dump_file (dump_base_name, \".greg\");\n-\n-  /* If 2nd scheduling dump desired, open the output file.  */\n+    clean_dump_file (\".greg\");\n   if (sched2_dump)\n-    sched2_dump_file = open_dump_file (dump_base_name, \".sched2\");\n-\n-  /* If jump2_opt dump desired, open the output file.  */\n+    clean_dump_file (\".sched2\");\n   if (jump2_opt_dump)\n-    jump2_opt_dump_file = open_dump_file (dump_base_name, \".jump2\");\n-\n-  /* If dbr_sched dump desired, open the output file.  */\n+    clean_dump_file (\".jump2\");\n   if (dbr_sched_dump)\n-    dbr_sched_dump_file = open_dump_file (dump_base_name, \".dbr\");\n-\n+    clean_dump_file (\".dbr\");\n #ifdef STACK_REGS\n-\n-  /* If stack_reg dump desired, open the output file.  */\n   if (stack_reg_dump)\n-    stack_reg_dump_file = open_dump_file (dump_base_name, \".stack\");\n-\n+    clean_dump_file (\".stack\");\n+#endif\n+#ifdef MACHINE_DEPENDENT_REORG\n+  if (mach_dep_reorg_dump)\n+    clean_dump_file (\".mach\");\n #endif\n \n   /* Open assembler code output file.  */\n@@ -2775,8 +2781,15 @@ compile_file (name)\n   /* Output some stuff at end of file if nec.  */\n \n   end_final (dump_base_name);\n-  end_branch_prob (branch_prob_dump_file);\n-\n+   \n+  if (branch_prob_dump)\n+    open_dump_file (\".bp\", NULL);\n+   \n+  TIMEVAR (dump_time, end_branch_prob (rtl_dump_file));\n+   \n+  if (branch_prob_dump)\n+    close_dump_file (NULL, NULL_RTX);\n+   \n #ifdef ASM_FILE_END\n   ASM_FILE_END (asm_out_file);\n #endif\n@@ -2794,62 +2807,13 @@ compile_file (name)\n \tunlink (aux_info_file_name);\n     }\n \n-  if (rtl_dump)\n-    fclose (rtl_dump_file);\n-\n-  if (jump_opt_dump)\n-    fclose (jump_opt_dump_file);\n-\n-  if (addressof_dump)\n-    fclose (addressof_dump_file);\n-\n-  if (cse_dump)\n-    fclose (cse_dump_file);\n-\n-  if (loop_dump)\n-    fclose (loop_dump_file);\n-\n-  if (cse2_dump)\n-    fclose (cse2_dump_file);\n-\n-  if (branch_prob_dump)\n-    fclose (branch_prob_dump_file);\n-\n-  if (flow_dump)\n-    fclose (flow_dump_file);\n-\n   if (combine_dump)\n     {\n-      dump_combine_total_stats (combine_dump_file);\n-      fclose (combine_dump_file);\n+      open_dump_file (\".combine\", NULL);\n+      TIMEVAR (dump_time, dump_combine_total_stats (rtl_dump_file));\n+      close_dump_file (NULL, NULL_RTX);\n     }\n \n-  if (regmove_dump)\n-    fclose (regmove_dump_file);\n-\n-  if (sched_dump)\n-    fclose (sched_dump_file);\n-\n-  if (local_reg_dump)\n-    fclose (local_reg_dump_file);\n-\n-  if (global_reg_dump)\n-    fclose (global_reg_dump_file);\n-\n-  if (sched2_dump)\n-    fclose (sched2_dump_file);\n-\n-  if (jump2_opt_dump)\n-    fclose (jump2_opt_dump_file);\n-\n-  if (dbr_sched_dump)\n-    fclose (dbr_sched_dump_file);\n-\n-#ifdef STACK_REGS\n-  if (stack_reg_dump)\n-    fclose (stack_reg_dump_file);\n-#endif\n-\n   /* Close non-debugging input and output files.  Take special care to note\n      whether fclose returns an error, since the pages might still be on the\n      buffer chain while the file is open.  */\n@@ -3045,15 +3009,14 @@ rest_of_compilation (decl)\n       /* Dump the rtl code if we are dumping rtl.  */\n \n       if (rtl_dump)\n-\tTIMEVAR (dump_time,\n-\t\t {\n-\t\t   fprintf (rtl_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t    (*decl_printable_name) (decl, 2));\n-\t\t   if (DECL_SAVED_INSNS (decl))\n-\t\t     fprintf (rtl_dump_file, \";; (integrable)\\n\\n\");\n-\t\t   print_rtl (rtl_dump_file, insns);\n-\t\t   fflush (rtl_dump_file);\n-\t\t });\n+\t{\n+\t  open_dump_file (\".rtl\", decl_printable_name (decl, 2));\n+\t  \n+\t  if (DECL_SAVED_INSNS (decl))\n+\t    fprintf (rtl_dump_file, \";; (integrable)\\n\\n\");\n+\t  \n+\t  close_dump_file (print_rtl, insns);\n+\t}\n \n       /* If we can, defer compiling inlines until EOF.\n \t save_for_inline_copying can be extremely expensive.  */\n@@ -3244,159 +3207,124 @@ rest_of_compilation (decl)\n \n   /* Dump rtl code after jump, if we are doing that.  */\n \n-  if (jump_opt_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (jump_opt_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t       print_rtl (jump_opt_dump_file, insns);\n-\t       fflush (jump_opt_dump_file);\n-\t     });\n+    if (jump_opt_dump)\n+      dump_rtl (\".jump\", decl, print_rtl, insns);\n \n   /* Perform common subexpression elimination.\n      Nonzero value from `cse_main' means that jumps were simplified\n      and some code may now be unreachable, so do\n      jump optimization again.  */\n \n-  if (cse_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (cse_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t     });\n-\n   if (optimize > 0)\n     {\n+      if (cse_dump)\n+\topen_dump_file (\".cse\", decl_printable_name (decl, 2));\n+\n       TIMEVAR (cse_time, reg_scan (insns, max_reg_num (), 1));\n \n       if (flag_thread_jumps)\n \t/* Hacks by tiemann & kenner.  */\n \tTIMEVAR (jump_time, thread_jumps (insns, max_reg_num (), 1));\n \n       TIMEVAR (cse_time, tem = cse_main (insns, max_reg_num (),\n-\t\t\t\t\t 0, cse_dump_file));\n+\t\t\t\t\t 0, rtl_dump_file));\n       TIMEVAR (cse_time, delete_dead_from_cse (insns, max_reg_num ()));\n \n       if (tem || optimize > 1)\n \tTIMEVAR (jump_time, jump_optimize (insns, 0, 0, 0));\n-    }\n-\n-  /* Dump rtl code after cse, if we are doing that.  */\n \n-  if (cse_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       print_rtl (cse_dump_file, insns);\n-\t       fflush (cse_dump_file);\n-\t     });\n+      /* Dump rtl code after cse, if we are doing that.  */\n+      \n+      if (cse_dump)\n+\tclose_dump_file (print_rtl, insns);\n+    }\n \n   purge_addressof (insns);\n   reg_scan (insns, max_reg_num (), 1);\n \n   if (addressof_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (addressof_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t       print_rtl (addressof_dump_file, insns);\n-\t       fflush (addressof_dump_file);\n-\t     });\n-\n-  if (loop_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (loop_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t     });\n-\n+    dump_rtl (\".addressof\", decl, print_rtl, insns);\n+  \n   /* Move constant computations out of loops.  */\n \n   if (optimize > 0)\n     {\n-      TIMEVAR (loop_time,\n-\t       {\n-\t\t if (flag_rerun_loop_opt)\n-\t\t   {\n-\t\t      /* We only want to perform unrolling once.  */\n-\n-\t\t      loop_optimize (insns, loop_dump_file, 0);\n-\n-\t\t      /* The regscan pass may not be necessary, but let's\n-\t\t\t be safe until we can prove otherwise.  */\n-\t\t      reg_scan (insns, max_reg_num (), 1);\n-\t\t   }\n-\t\t loop_optimize (insns, loop_dump_file, flag_unroll_loops);\n-\t       });\n-    }\n-\n-  /* Dump rtl code after loop opt, if we are doing that.  */\n-\n-  if (loop_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       print_rtl (loop_dump_file, insns);\n-\t       fflush (loop_dump_file);\n-\t     });\n-\n-  if (cse2_dump)\n-    TIMEVAR (dump_time,\n+      if (loop_dump)\n+\topen_dump_file (\".loop\", decl_printable_name (decl, 2));\n+\t\n+      TIMEVAR\n+\t(loop_time,\n+\t {\n+\t   if (flag_rerun_loop_opt)\n \t     {\n-\t       fprintf (cse2_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t     });\n-\n-  if (optimize > 0 && flag_rerun_cse_after_loop)\n-    {\n-      /* Running another jump optimization pass before the second\n-\t cse pass sometimes simplifies the RTL enough to allow\n-\t the second CSE pass to do a better job.  Jump_optimize can change\n-\t max_reg_num so we must rerun reg_scan afterwards.\n-\t ??? Rework to not call reg_scan so often.  */\n-      TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n-      TIMEVAR (jump_time, jump_optimize (insns, 0, 0, 1));\n-\n-      TIMEVAR (cse2_time, reg_scan (insns, max_reg_num (), 0));\n-      TIMEVAR (cse2_time, tem = cse_main (insns, max_reg_num (),\n-\t\t\t\t\t  1, cse2_dump_file));\n-      if (tem)\n-\tTIMEVAR (jump_time, jump_optimize (insns, 0, 0, 0));\n+\t       /* We only want to perform unrolling once.  */\n+\t       \n+\t       loop_optimize (insns, rtl_dump_file, 0);\n+\t       \n+\t       /* The regscan pass may not be necessary, but let's\n+\t\t  be safe until we can prove otherwise.  */\n+\t       reg_scan (insns, max_reg_num (), 1);\n+\t     }\n+\t   loop_optimize (insns, rtl_dump_file, flag_unroll_loops);\n+\t });\n+      \n+      /* Dump rtl code after loop opt, if we are doing that.  */\n+      \n+      if (loop_dump)\n+\tclose_dump_file (print_rtl, insns);\n     }\n \n-  if (optimize > 0 && flag_thread_jumps)\n+  if (optimize > 0)\n     {\n-      /* This pass of jump threading straightens out code\n-         that was kinked by loop optimization.  */\n-      TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n-      TIMEVAR (jump_time, thread_jumps (insns, max_reg_num (), 0));\n-    }\n-  /* Dump rtl code after cse, if we are doing that.  */\n-\n-  if (cse2_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       print_rtl (cse2_dump_file, insns);\n-\t       fflush (cse2_dump_file);\n-\t     });\n-\n-  if (branch_prob_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (branch_prob_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t     });\n+      if (cse2_dump)\n+\topen_dump_file (\".cse2\", decl_printable_name (decl, 2));\n+      \n+      if (flag_rerun_cse_after_loop)\n+\t{\n+\t  /* Running another jump optimization pass before the second\n+\t     cse pass sometimes simplifies the RTL enough to allow\n+\t     the second CSE pass to do a better job.  Jump_optimize can change\n+\t     max_reg_num so we must rerun reg_scan afterwards.\n+\t     ??? Rework to not call reg_scan so often.  */\n+\t  TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n+\t  TIMEVAR (jump_time, jump_optimize (insns, 0, 0, 1));\n+\t  \n+\t  TIMEVAR (cse2_time, reg_scan (insns, max_reg_num (), 0));\n+\t  TIMEVAR (cse2_time, tem = cse_main (insns, max_reg_num (),\n+\t\t\t\t\t      1, rtl_dump_file));\n+\t  if (tem)\n+\t    TIMEVAR (jump_time, jump_optimize (insns, 0, 0, 0));\n+\t}\n \n+      if (flag_thread_jumps)\n+\t{\n+\t  /* This pass of jump threading straightens out code\n+\t     that was kinked by loop optimization.  */\n+\t  TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n+\t  TIMEVAR (jump_time, thread_jumps (insns, max_reg_num (), 0));\n+\t}\n+      \n+      /* Dump rtl code after cse, if we are doing that.  */\n+      \n+      if (cse2_dump)\n+\tclose_dump_file (print_rtl, insns);\n+    }\n+  \n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    TIMEVAR (branch_prob_time,\n-\t     {\n-\t       branch_prob (insns, branch_prob_dump_file);\n-\t     });\n-\n-  if (branch_prob_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       print_rtl (branch_prob_dump_file, insns);\n-\t       fflush (branch_prob_dump_file);\n-\t     });\n+    {\n+      if (branch_prob_dump)\n+\topen_dump_file (\".bp\", decl_printable_name (decl, 2));\n+    \n+      TIMEVAR\n+\t(branch_prob_time,\n+\t {\n+\t   branch_prob (insns, rtl_dump_file);\n+\t });\n+      \n+      if (branch_prob_dump)\n+\tclose_dump_file (print_rtl, insns);\n+    }\n+  \n   /* We are no longer anticipating cse in this function, at least.  */\n \n   cse_not_expected = 1;\n@@ -3414,19 +3342,15 @@ rest_of_compilation (decl)\n      because doing the flow analysis makes some of the dump.  */\n \n   if (flow_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (flow_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t     });\n-\n+    open_dump_file (\".flow\", decl_printable_name (decl, 2));\n+  \n   if (obey_regdecls)\n     {\n       TIMEVAR (flow_time,\n \t       {\n \t\t regclass (insns, max_reg_num ());\n \t\t stupid_life_analysis (insns, max_reg_num (),\n-\t\t\t\t       flow_dump_file);\n+\t\t\t\t       rtl_dump_file);\n \t       });\n     }\n   else\n@@ -3435,7 +3359,7 @@ rest_of_compilation (decl)\n \t and write some of the results to dump file.  */\n \n       TIMEVAR (flow_time, flow_analysis (insns, max_reg_num (),\n-\t\t\t\t\t flow_dump_file));\n+\t\t\t\t\t rtl_dump_file));\n       if (warn_uninitialized)\n \t{\n \t  uninitialized_vars_warning (DECL_INITIAL (decl));\n@@ -3446,76 +3370,53 @@ rest_of_compilation (decl)\n   /* Dump rtl after flow analysis.  */\n \n   if (flow_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       print_rtl_with_bb (flow_dump_file, insns);\n-\t       fflush (flow_dump_file);\n-\t     });\n-\n+    close_dump_file (print_rtl_with_bb, insns);\n+  \n   /* If -opt, try combining insns through substitution.  */\n \n   if (optimize > 0)\n-    TIMEVAR (combine_time, combine_instructions (insns, max_reg_num ()));\n-\n-  /* Dump rtl code after insn combination.  */\n-\n-  if (combine_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (combine_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t       dump_combine_stats (combine_dump_file);\n-\t       print_rtl_with_bb (combine_dump_file, insns);\n-\t       fflush (combine_dump_file);\n-\t     });\n-\n-  if (regmove_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (regmove_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t     });\n+    {\n+      TIMEVAR (combine_time, combine_instructions (insns, max_reg_num ()));\n+      \n+      /* Dump rtl code after insn combination.  */\n+      \n+      if (combine_dump)\n+\tdump_rtl (\".combine\", decl, print_rtl_with_bb, insns);\n+    }\n \n   /* Register allocation pre-pass, to reduce number of moves\n      necessary for two-address machines.  */\n   if (optimize > 0 && flag_regmove)\n-    TIMEVAR (regmove_time, regmove_optimize (insns, max_reg_num (),\n-\t\t\t\t\t     regmove_dump_file));\n-\n-  if (regmove_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       print_rtl_with_bb (regmove_dump_file, insns);\n-\t       fflush (regmove_dump_file);\n-\t     });\n+    {\n+      if (regmove_dump)\n+\topen_dump_file (\".regmove\", decl_printable_name (decl, 2));\n+      \n+      TIMEVAR (regmove_time, regmove_optimize (insns, max_reg_num (),\n+\t\t\t\t\t       rtl_dump_file));\n+      \n+      if (regmove_dump)\n+\tclose_dump_file (print_rtl_with_bb, insns);\n+    }\n \n   /* Print function header into sched dump now\n      because doing the sched analysis makes some of the dump.  */\n \n-  if (sched_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (sched_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t     });\n-\n   if (optimize > 0 && flag_schedule_insns)\n     {\n+      if (sched_dump)\n+\topen_dump_file (\".sched\", decl_printable_name (decl, 2));\n+      \n       /* Do control and data sched analysis,\n \t and write some of the results to dump file.  */\n \n-      TIMEVAR (sched_time, schedule_insns (sched_dump_file));\n+      TIMEVAR (sched_time, schedule_insns (rtl_dump_file));\n+      \n+      /* Dump rtl after instruction scheduling.  */\n+      \n+      if (sched_dump)\n+\tclose_dump_file (print_rtl_with_bb, insns);\n     }\n \n-  /* Dump rtl after instruction scheduling.  */\n-\n-  if (sched_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       print_rtl_with_bb (sched_dump_file, insns);\n-\t       fflush (sched_dump_file);\n-\t     });\n-\n   /* Unless we did stupid register allocation,\n      allocate pseudo-regs that are used only within 1 basic block.  */\n \n@@ -3529,20 +3430,17 @@ rest_of_compilation (decl)\n   /* Dump rtl code after allocating regs within basic blocks.  */\n \n   if (local_reg_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (local_reg_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t       dump_flow_info (local_reg_dump_file);\n-\t       dump_local_alloc (local_reg_dump_file);\n-\t       print_rtl_with_bb (local_reg_dump_file, insns);\n-\t       fflush (local_reg_dump_file);\n-\t     });\n+    {\n+      open_dump_file (\".lreg\", decl_printable_name (decl, 2));\n+      \n+      TIMEVAR (dump_time, dump_flow_info (rtl_dump_file));\n+      TIMEVAR (dump_time, dump_local_alloc (rtl_dump_file));\n+      \n+      close_dump_file (print_rtl_with_bb, insns);\n+    }\n \n   if (global_reg_dump)\n-    TIMEVAR (dump_time,\n-\t     fprintf (global_reg_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t      (*decl_printable_name) (decl, 2)));\n+    open_dump_file (\".greg\", decl_printable_name (decl, 2));\n \n   /* Save the last label number used so far, so reorg can tell\n      when it's safe to kill spill regs.  */\n@@ -3555,18 +3453,16 @@ rest_of_compilation (decl)\n   TIMEVAR (global_alloc_time,\n \t   {\n \t     if (!obey_regdecls)\n-\t       failure = global_alloc (global_reg_dump_file);\n+\t       failure = global_alloc (rtl_dump_file);\n \t     else\n-\t       failure = reload (insns, 0, global_reg_dump_file);\n+\t       failure = reload (insns, 0, rtl_dump_file);\n \t   });\n \n   if (global_reg_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       dump_global_regs (global_reg_dump_file);\n-\t       print_rtl_with_bb (global_reg_dump_file, insns);\n-\t       fflush (global_reg_dump_file);\n-\t     });\n+    {\n+      TIMEVAR (dump_time, dump_global_regs (rtl_dump_file));\n+      close_dump_file (print_rtl_with_bb, insns);\n+    }\n \n   if (failure)\n     goto exit_rest_of_compilation;\n@@ -3587,25 +3483,17 @@ rest_of_compilation (decl)\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n       if (sched2_dump)\n-\tTIMEVAR (dump_time,\n-\t\t {\n-\t\t   fprintf (sched2_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t    (*decl_printable_name) (decl, 2));\n-\t\t });\n+\topen_dump_file (\".sched2\", decl_printable_name (decl, 2));\n \n       /* Do control and data sched analysis again,\n \t and write some more of the results to dump file.  */\n \n-      TIMEVAR (sched2_time, schedule_insns (sched2_dump_file));\n+      TIMEVAR (sched2_time, schedule_insns (rtl_dump_file));\n \n       /* Dump rtl after post-reorder instruction scheduling.  */\n \n       if (sched2_dump)\n-\tTIMEVAR (dump_time,\n-\t\t {\n-\t\t   print_rtl_with_bb (sched2_dump_file, insns);\n-\t\t   fflush (sched2_dump_file);\n-\t\t });\n+\tclose_dump_file (print_rtl_with_bb, insns);\n     }\n \n #ifdef LEAF_REGISTERS\n@@ -3622,22 +3510,19 @@ rest_of_compilation (decl)\n   if (optimize > 0)\n     {\n       TIMEVAR (jump_time, jump_optimize (insns, 1, 1, 0));\n-    }\n-\n-  /* Dump rtl code after jump, if we are doing that.  */\n+      \n+      /* Dump rtl code after jump, if we are doing that.  */\n \n-  if (jump2_opt_dump)\n-    TIMEVAR (dump_time,\n-\t     {\n-\t       fprintf (jump2_opt_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t(*decl_printable_name) (decl, 2));\n-\t       print_rtl_with_bb (jump2_opt_dump_file, insns);\n-\t       fflush (jump2_opt_dump_file);\n-\t     });\n+      if (jump2_opt_dump)\n+\tdump_rtl (\".jump2\", decl, print_rtl_with_bb, insns);\n+    }\n \n   /* If a machine dependent reorganization is needed, call it.  */\n #ifdef MACHINE_DEPENDENT_REORG\n    MACHINE_DEPENDENT_REORG (insns);\n+\n+   if (mach_dep_reorg_dump)\n+     dump_rtl (\".mach\", decl, print_rtl_with_bb, insns);\n #endif\n \n   /* If a scheduling pass for delayed branches is to be done,\n@@ -3647,16 +3532,9 @@ rest_of_compilation (decl)\n   if (optimize > 0 && flag_delayed_branch)\n     {\n       TIMEVAR (dbr_sched_time, dbr_schedule (insns, dbr_sched_dump_file));\n+      \n       if (dbr_sched_dump)\n-\t{\n-\t  TIMEVAR (dump_time,\n-\t\t {\n-\t\t   fprintf (dbr_sched_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t\t    (*decl_printable_name) (decl, 2));\n-\t\t   print_rtl_with_bb (dbr_sched_dump_file, insns);\n-\t\t   fflush (dbr_sched_dump_file);\n-\t\t });\n-\t}\n+\tdump_rtl (\".dbr\", decl, print_rtl_with_bb, insns);\n     }\n #endif\n \n@@ -3668,16 +3546,9 @@ rest_of_compilation (decl)\n \n #ifdef STACK_REGS\n   TIMEVAR (stack_reg_time, reg_to_stack (insns, stack_reg_dump_file));\n+\n   if (stack_reg_dump)\n-    {\n-      TIMEVAR (dump_time,\n-\t       {\n-\t\t fprintf (stack_reg_dump_file, \"\\n;; Function %s\\n\\n\",\n-\t\t          (*decl_printable_name) (decl, 2));\n-\t\t print_rtl_with_bb (stack_reg_dump_file, insns);\n-\t\t fflush (stack_reg_dump_file);\n-\t       });\n-    }\n+    dump_rtl (\".stack\", decl, print_rtl_with_bb, insns);\n #endif\n \n   /* Now turn the rtl into assembler code.  */\n@@ -3956,14 +3827,21 @@ main (argc, argv, envp)\n  \t\t    cse_dump = 1, cse2_dump = 1;\n  \t\t    sched_dump = 1;\n  \t\t    sched2_dump = 1;\n+#ifdef STACK_REGS\n \t\t    stack_reg_dump = 1;\n+#endif\n+#ifdef MACHINE_DEPENDENT_REORG\n+\t\t    mach_dep_reorg_dump = 1;\n+#endif\n \t\t    break;\n \t\t  case 'b':\n \t\t    branch_prob_dump = 1;\n \t\t    break;\n+#ifdef STACK_REGS\t\t    \n \t\t  case 'k':\n \t\t    stack_reg_dump = 1;\n \t\t    break;\n+#endif\n \t\t  case 'c':\n \t\t    combine_dump = 1;\n \t\t    break;\n@@ -3994,6 +3872,11 @@ main (argc, argv, envp)\n \t\t  case 'm':\n \t\t    flag_print_mem = 1;\n \t\t    break;\n+#ifdef MACHINE_DEPENDENT_REORG\n+\t\t  case 'M':\n+\t\t    mach_dep_reorg_dump = 1;\n+\t\t    break;\n+#endif\n \t\t  case 'p':\n \t\t    flag_print_asm_name = 1;\n \t\t    break;\n@@ -4024,6 +3907,9 @@ main (argc, argv, envp)\n \t\t  case 'A':\n \t\t    flag_debug_asm = 1;\n \t\t    break;\n+\t\t  default:\n+\t\t    warning (\"unrecognised gcc debugging option: %c\", p[-1]);\n+\t\t    break;\n \t\t  }\n \t    }\n \t  else if (str[0] == 'f')"}]}