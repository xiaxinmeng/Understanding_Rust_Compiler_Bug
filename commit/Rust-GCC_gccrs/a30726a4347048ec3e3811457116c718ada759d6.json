{"sha": "a30726a4347048ec3e3811457116c718ada759d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMwNzI2YTQzNDcwNDhlYzNlMzgxMTQ1NzExNmM3MThhZGE3NTlkNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-19T21:49:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-19T21:49:10Z"}, "message": "gimple.c (gtc_visited, [...]): Remove.\n\n\n\t* gimple.c (gtc_visited, gtc_ob, type_pair_hash, type_pair_eq): Remove.\n\t(GIMPLE_TYPE_PAIR_SIZE): New macro.\n\t(type_pair_cache): New static var.\n\t(lookup_type_pair): Use fixed sized custom hash; make inline.\n\t(gtc_visit, gimple_types_compatible_p, gimple_register_type_1): Update\n\tcalls of lookup_type_pair.\n\t(print_gimple_types_stats): Remove cache stats.\n\t(free_gimple_type_tables): Free type_pair_cache instead of gtc_visited\n\tand gtc_ob.\n\nFrom-SVN: r173925", "tree": {"sha": "d4f6b187e8a112ffa4757f72020a92ae15615907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f6b187e8a112ffa4757f72020a92ae15615907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a30726a4347048ec3e3811457116c718ada759d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a30726a4347048ec3e3811457116c718ada759d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a30726a4347048ec3e3811457116c718ada759d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a30726a4347048ec3e3811457116c718ada759d6/comments", "author": null, "committer": null, "parents": [{"sha": "0955cf616c9da0fbd6721dec1e39048559483a45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0955cf616c9da0fbd6721dec1e39048559483a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0955cf616c9da0fbd6721dec1e39048559483a45"}], "stats": {"total": 111, "additions": 43, "deletions": 68}, "files": [{"sha": "09fcbcd62139fcfd7118375e9abcc6fb96d70a5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30726a4347048ec3e3811457116c718ada759d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30726a4347048ec3e3811457116c718ada759d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a30726a4347048ec3e3811457116c718ada759d6", "patch": "@@ -1,3 +1,15 @@\n+2011-05-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gimple.c (gtc_visited, gtc_ob, type_pair_hash, type_pair_eq): Remove.\n+\t(GIMPLE_TYPE_PAIR_SIZE): New macro.\n+\t(type_pair_cache): New static var.\n+\t(lookup_type_pair): Use fixed sized custom hash; make inline.\n+\t(gtc_visit, gimple_types_compatible_p, gimple_register_type_1): Update\n+\tcalls of lookup_type_pair.\n+\t(print_gimple_types_stats): Remove cache stats.\n+\t(free_gimple_type_tables): Free type_pair_cache instead of gtc_visited\n+\tand gtc_ob.\n+\n 2011-05-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (option_override_internal): Enable TARGET_CMOVE"}, {"sha": "e30c7adaa3bf68115e6c6e3b529a0584ad9bd7f0", "filename": "gcc/gimple.c", "status": "modified", "additions": 31, "deletions": 68, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30726a4347048ec3e3811457116c718ada759d6/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30726a4347048ec3e3811457116c718ada759d6/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=a30726a4347048ec3e3811457116c718ada759d6", "patch": "@@ -50,11 +50,6 @@ static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map))\n static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n   htab_t canonical_type_hash_cache;\n \n-/* Global type comparison cache.  This is by TYPE_UID for space efficiency\n-   and thus cannot use and does not need GC.  */\n-static htab_t gtc_visited;\n-static struct obstack gtc_ob;\n-\n /* All the tuples have their operand vector (if present) at the very bottom\n    of the structure.  Therefore, the offset required to find the\n    operands vector the size of the structure minus the size of the 1\n@@ -3237,72 +3232,51 @@ struct type_pair_d\n   signed char same_p[2];\n };\n typedef struct type_pair_d *type_pair_t;\n-\n DEF_VEC_P(type_pair_t);\n DEF_VEC_ALLOC_P(type_pair_t,heap);\n \n-/* Return a hash value for the type pair pointed-to by P.  */\n-\n-static hashval_t\n-type_pair_hash (const void *p)\n-{\n-  const struct type_pair_d *pair = (const struct type_pair_d *) p;\n-  hashval_t val1 = pair->uid1;\n-  hashval_t val2 = pair->uid2;\n-  return iterative_hash_hashval_t (val1, val2);\n-}\n-\n-/* Compare two type pairs pointed-to by P1 and P2.  */\n+#define GIMPLE_TYPE_PAIR_SIZE 16381\n+struct type_pair_d *type_pair_cache;\n \n-static int\n-type_pair_eq (const void *p1, const void *p2)\n-{\n-  const struct type_pair_d *pair1 = (const struct type_pair_d *) p1;\n-  const struct type_pair_d *pair2 = (const struct type_pair_d *) p2;\n-  return (pair1->uid1 == pair2->uid1 && pair1->uid2 == pair2->uid2);\n-}\n \n /* Lookup the pair of types T1 and T2 in *VISITED_P.  Insert a new\n    entry if none existed.  */\n \n-static type_pair_t\n-lookup_type_pair (tree t1, tree t2, htab_t *visited_p, struct obstack *ob_p)\n+static inline type_pair_t\n+lookup_type_pair (tree t1, tree t2)\n {\n-  struct type_pair_d pair;\n-  type_pair_t p;\n-  void **slot;\n+  unsigned int index;\n+  unsigned int uid1, uid2;\n \n-  if (*visited_p == NULL)\n-    {\n-      *visited_p = htab_create (251, type_pair_hash, type_pair_eq, NULL);\n-      gcc_obstack_init (ob_p);\n-    }\n+  if (type_pair_cache == NULL)\n+    type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n \n   if (TYPE_UID (t1) < TYPE_UID (t2))\n     {\n-      pair.uid1 = TYPE_UID (t1);\n-      pair.uid2 = TYPE_UID (t2);\n+      uid1 = TYPE_UID (t1);\n+      uid2 = TYPE_UID (t2);\n     }\n   else\n     {\n-      pair.uid1 = TYPE_UID (t2);\n-      pair.uid2 = TYPE_UID (t1);\n+      uid1 = TYPE_UID (t2);\n+      uid2 = TYPE_UID (t1);\n     }\n-  slot = htab_find_slot (*visited_p, &pair, INSERT);\n+  gcc_checking_assert (uid1 != uid2);\n \n-  if (*slot)\n-    p = *((type_pair_t *) slot);\n-  else\n-    {\n-      p = XOBNEW (ob_p, struct type_pair_d);\n-      p->uid1 = pair.uid1;\n-      p->uid2 = pair.uid2;\n-      p->same_p[0] = -2;\n-      p->same_p[1] = -2;\n-      *slot = (void *) p;\n-    }\n+  /* iterative_hash_hashval_t imply an function calls.\n+     We know that UIDS are in limited range.  */\n+  index = ((((unsigned HOST_WIDE_INT)uid1 << HOST_BITS_PER_WIDE_INT / 2) + uid2)\n+\t   % GIMPLE_TYPE_PAIR_SIZE);\n+  if (type_pair_cache [index].uid1 == uid1\n+      && type_pair_cache [index].uid2 == uid2)\n+    return &type_pair_cache[index];\n \n-  return p;\n+  type_pair_cache [index].uid1 = uid1;\n+  type_pair_cache [index].uid2 = uid2;\n+  type_pair_cache [index].same_p[0] = -2;\n+  type_pair_cache [index].same_p[1] = -2;\n+\n+  return &type_pair_cache[index];\n }\n \n /* Per pointer state for the SCC finding.  The on_sccstack flag\n@@ -3560,7 +3534,7 @@ gtc_visit (tree t1, tree t2,\n     return false;\n \n   /* Allocate a new cache entry for this comparison.  */\n-  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n+  p = lookup_type_pair (t1, t2);\n   if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n@@ -3972,7 +3946,7 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n   /* If we've visited this type pair before (in the case of aggregates\n      with self-referential types), and we made a decision, return it.  */\n-  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n+  p = lookup_type_pair (t1, t2);\n   if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n@@ -4967,16 +4941,6 @@ print_gimple_types_stats (void)\n \t     htab_collisions (canonical_type_hash_cache));\n   else\n     fprintf (stderr, \"GIMPLE canonical type hash table is empty\\n\");\n-  if (gtc_visited)\n-    fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld \"\n-\t     \"elements, %ld searches, %ld collisions (ratio: %f)\\n\",\n-\t     (long) htab_size (gtc_visited),\n-\t     (long) htab_elements (gtc_visited),\n-\t     (long) gtc_visited->searches,\n-\t     (long) gtc_visited->collisions,\n-\t     htab_collisions (gtc_visited));\n-  else\n-    fprintf (stderr, \"GIMPLE type comparison table is empty\\n\");\n }\n \n /* Free the gimple type hashtables used for LTO type merging.  */\n@@ -5008,11 +4972,10 @@ free_gimple_type_tables (void)\n       htab_delete (canonical_type_hash_cache);\n       canonical_type_hash_cache = NULL;\n     }\n-  if (gtc_visited)\n+  if (type_pair_cache)\n     {\n-      htab_delete (gtc_visited);\n-      obstack_free (&gtc_ob, NULL);\n-      gtc_visited = NULL;\n+      free (type_pair_cache);\n+      type_pair_cache = NULL;\n     }\n   gimple_type_leader = NULL;\n }"}]}