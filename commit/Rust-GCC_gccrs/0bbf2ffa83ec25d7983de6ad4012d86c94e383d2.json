{"sha": "0bbf2ffa83ec25d7983de6ad4012d86c94e383d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiZjJmZmE4M2VjMjVkNzk4M2RlNmFkNDAxMmQ4NmM5NGUzODNkMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-06-23T10:03:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-06-23T10:03:41Z"}, "message": "tree-ssa-structalias.c (struct variable_info): Add is_global_var member.\n\n2009-06-23  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (struct variable_info): Add is_global_var\n\tmember.\n\t(var_anything, anything_tree, var_nothing, nothing_tree, var_readonly,\n\treadonly_tree, var_escaped, escaped_tree, var_nonlocal, nonlocal_tree,\n\tvar_callused, callused_tree, var_storedanything, storedanything_tree,\n\tvar_integer, integer_tree): Remove global variables.\n\t(new_var_info): Do not pass new id, append the new var to the\n\tglobal variable vector.\n\t(do_ds_constraint): Use is_global_var member of the variable-info.\n\t(new_scalar_tmp_constraint_exp): Adjust.\n\t(create_function_info_for): Likewise.\n\t(create_variable_info_for): Likewise.\n\t(find_what_var_points_to): Remove dead code.\n\t(init_base_vars): Simplify.\n\t(compute_points_to_sets): Adjust.\n\nFrom-SVN: r148841", "tree": {"sha": "1e1cbe248ae8874ef5e2e79cd36e3696af712a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e1cbe248ae8874ef5e2e79cd36e3696af712a03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "efc81a892c7fa82e5d00cf2258aea4392af4643a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc81a892c7fa82e5d00cf2258aea4392af4643a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc81a892c7fa82e5d00cf2258aea4392af4643a"}], "stats": {"total": 180, "additions": 75, "deletions": 105}, "files": [{"sha": "b45dbac0245da042824a90449806140da4a581a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bbf2ffa83ec25d7983de6ad4012d86c94e383d2", "patch": "@@ -1,3 +1,21 @@\n+2009-06-23  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Add is_global_var\n+\tmember.\n+\t(var_anything, anything_tree, var_nothing, nothing_tree, var_readonly,\n+\treadonly_tree, var_escaped, escaped_tree, var_nonlocal, nonlocal_tree,\n+\tvar_callused, callused_tree, var_storedanything, storedanything_tree,\n+\tvar_integer, integer_tree): Remove global variables.\n+\t(new_var_info): Do not pass new id, append the new var to the\n+\tglobal variable vector.\n+\t(do_ds_constraint): Use is_global_var member of the variable-info.\n+\t(new_scalar_tmp_constraint_exp): Adjust.\n+\t(create_function_info_for): Likewise.\n+\t(create_variable_info_for): Likewise.\n+\t(find_what_var_points_to): Remove dead code.\n+\t(init_base_vars): Simplify.\n+\t(compute_points_to_sets): Adjust.\n+\n 2009-06-22  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* combine.c (try_combine): Dump information about the insns we're"}, {"sha": "692a6240403143e5102f18ed46b1f13b02525ae4", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 57, "deletions": 105, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bbf2ffa83ec25d7983de6ad4012d86c94e383d2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0bbf2ffa83ec25d7983de6ad4012d86c94e383d2", "patch": "@@ -229,6 +229,9 @@ struct variable_info\n   /* True if this field may contain pointers.  */\n   unsigned int may_have_pointers : 1;\n \n+  /* True if this represents a global variable.  */\n+  unsigned int is_global_var : 1;\n+\n   /* A link to the variable for the next field in this structure.  */\n   struct variable_info *next;\n \n@@ -284,39 +287,6 @@ enum { nothing_id = 0, anything_id = 1, readonly_id = 2,\n        escaped_id = 3, nonlocal_id = 4, callused_id = 5,\n        storedanything_id = 6, integer_id = 7 };\n \n-/* Variable that represents the unknown pointer.  */\n-static varinfo_t var_anything;\n-static tree anything_tree;\n-\n-/* Variable that represents the NULL pointer.  */\n-static varinfo_t var_nothing;\n-static tree nothing_tree;\n-\n-/* Variable that represents read only memory.  */\n-static varinfo_t var_readonly;\n-static tree readonly_tree;\n-\n-/* Variable that represents escaped memory.  */\n-static varinfo_t var_escaped;\n-static tree escaped_tree;\n-\n-/* Variable that represents nonlocal memory.  */\n-static varinfo_t var_nonlocal;\n-static tree nonlocal_tree;\n-\n-/* Variable that represents call-used memory.  */\n-static varinfo_t var_callused;\n-static tree callused_tree;\n-\n-/* Variable that represents variables that are stored to anything.  */\n-static varinfo_t var_storedanything;\n-static tree storedanything_tree;\n-\n-/* Variable that represents integers.  This is used for when people do things\n-   like &0->a.b.  */\n-static varinfo_t var_integer;\n-static tree integer_tree;\n-\n /* Lookup a heap var for FROM, and return it if we find one.  */\n \n static tree\n@@ -350,25 +320,34 @@ heapvar_insert (tree from, tree to)\n }\n \n /* Return a new variable info structure consisting for a variable\n-   named NAME, and using constraint graph node NODE.  */\n+   named NAME, and using constraint graph node NODE.  Append it\n+   to the vector of variable info structures.  */\n \n static varinfo_t\n-new_var_info (tree t, unsigned int id, const char *name)\n+new_var_info (tree t, const char *name)\n {\n+  unsigned index = VEC_length (varinfo_t, varmap);\n   varinfo_t ret = (varinfo_t) pool_alloc (variable_info_pool);\n \n-  ret->id = id;\n+  ret->id = index;\n   ret->name = name;\n   ret->decl = t;\n-  ret->is_artificial_var = false;\n+  /* Vars without decl are artificial and do not have sub-variables.  */\n+  ret->is_artificial_var = (t == NULL_TREE);\n+  ret->is_full_var = (t == NULL_TREE);\n   ret->is_heap_var = false;\n   ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n-  ret->is_full_var = false;\n   ret->may_have_pointers = true;\n+  ret->is_global_var = true;\n+  if (t && DECL_P (t))\n+    ret->is_global_var = is_global_var (t);\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n   ret->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n   ret->next = NULL;\n+\n+  VEC_safe_push (varinfo_t, heap, varmap, ret);\n+\n   return ret;\n }\n \n@@ -1702,7 +1681,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t\t}\n \t    }\n \t  /* If v is a global variable then this is an escape point.  */\n-\t  if (is_global_var (v->decl))\n+\t  if (v->is_global_var)\n \t    {\n \t      t = find (escaped_id);\n \t      if (add_graph_edge (graph, t, rhs)\n@@ -2682,15 +2661,13 @@ static struct constraint_expr\n new_scalar_tmp_constraint_exp (const char *name)\n {\n   struct constraint_expr tmp;\n-  unsigned index = VEC_length (varinfo_t, varmap);\n   varinfo_t vi;\n \n-  vi = new_var_info (NULL_TREE, index, name);\n+  vi = new_var_info (NULL_TREE, name);\n   vi->offset = 0;\n   vi->size = -1;\n   vi->fullsize = -1;\n   vi->is_full_var = 1;\n-  VEC_safe_push (varinfo_t, heap, varmap, vi);\n \n   tmp.var = vi->id;\n   tmp.type = SCALAR;\n@@ -4263,20 +4240,18 @@ count_num_arguments (tree decl, bool *is_varargs)\n static unsigned int\n create_function_info_for (tree decl, const char *name)\n {\n-  unsigned int index = VEC_length (varinfo_t, varmap);\n   varinfo_t vi;\n   tree arg;\n   unsigned int i;\n   bool is_varargs = false;\n \n   /* Create the variable info.  */\n \n-  vi = new_var_info (decl, index, name);\n+  vi = new_var_info (decl, name);\n   vi->offset = 0;\n   vi->size = 1;\n   vi->fullsize = count_num_arguments (decl, &is_varargs) + 1;\n   insert_vi_for_tree (vi->decl, vi);\n-  VEC_safe_push (varinfo_t, heap, varmap, vi);\n \n   stats.total_vars++;\n \n@@ -4287,10 +4262,9 @@ create_function_info_for (tree decl, const char *name)\n       vi->fullsize = ~0;\n       vi->size = ~0;\n       vi->is_unknown_size_var = true;\n-      return index;\n+      return vi->id;\n     }\n \n-\n   arg = DECL_ARGUMENTS (decl);\n \n   /* Set up variables for each argument.  */\n@@ -4299,19 +4273,16 @@ create_function_info_for (tree decl, const char *name)\n       varinfo_t argvi;\n       const char *newname;\n       char *tempname;\n-      unsigned int newindex;\n       tree argdecl = decl;\n \n       if (arg)\n \targdecl = arg;\n \n-      newindex = VEC_length (varinfo_t, varmap);\n       asprintf (&tempname, \"%s.arg%d\", name, i-1);\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      argvi = new_var_info (argdecl, newindex, newname);\n-      VEC_safe_push (varinfo_t, heap, varmap, argvi);\n+      argvi = new_var_info (argdecl, newname);\n       argvi->offset = i;\n       argvi->size = 1;\n       argvi->is_full_var = true;\n@@ -4332,21 +4303,18 @@ create_function_info_for (tree decl, const char *name)\n       varinfo_t resultvi;\n       const char *newname;\n       char *tempname;\n-      unsigned int newindex;\n       tree resultdecl = decl;\n \n       vi->fullsize ++;\n \n       if (DECL_RESULT (decl))\n \tresultdecl = DECL_RESULT (decl);\n \n-      newindex = VEC_length (varinfo_t, varmap);\n       asprintf (&tempname, \"%s.result\", name);\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      resultvi = new_var_info (resultdecl, newindex, newname);\n-      VEC_safe_push (varinfo_t, heap, varmap, resultvi);\n+      resultvi = new_var_info (resultdecl, newname);\n       resultvi->offset = i;\n       resultvi->size = 1;\n       resultvi->fullsize = vi->fullsize;\n@@ -4356,7 +4324,8 @@ create_function_info_for (tree decl, const char *name)\n       if (DECL_RESULT (decl))\n \tinsert_vi_for_tree (DECL_RESULT (decl), resultvi);\n     }\n-  return index;\n+\n+  return vi->id;\n }\n \n \n@@ -4386,7 +4355,6 @@ check_for_overlaps (VEC (fieldoff_s,heap) *fieldstack)\n static unsigned int\n create_variable_info_for (tree decl, const char *name)\n {\n-  unsigned int index = VEC_length (varinfo_t, varmap);\n   varinfo_t vi;\n   tree decl_type = TREE_TYPE (decl);\n   tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decl_type);\n@@ -4406,7 +4374,7 @@ create_variable_info_for (tree decl, const char *name)\n   /* If the variable doesn't have subvars, we may end up needing to\n      sort the field list and create fake variables for all the\n      fields.  */\n-  vi = new_var_info (decl, index, name);\n+  vi = new_var_info (decl, name);\n   vi->offset = 0;\n   vi->may_have_pointers = could_have_pointers (decl);\n   if (!declsize\n@@ -4423,7 +4391,6 @@ create_variable_info_for (tree decl, const char *name)\n     }\n \n   insert_vi_for_tree (vi->decl, vi);\n-  VEC_safe_push (varinfo_t, heap, varmap, vi);\n   if (is_global && (!flag_whole_program || !in_ipa_mode)\n       && vi->may_have_pointers)\n     {\n@@ -4441,7 +4408,6 @@ create_variable_info_for (tree decl, const char *name)\n       && VEC_length (fieldoff_s, fieldstack) > 1\n       && VEC_length (fieldoff_s, fieldstack) <= MAX_FIELDS_FOR_FIELD_SENSITIVE)\n     {\n-      unsigned int newindex = VEC_length (varinfo_t, varmap);\n       fieldoff_s *fo = NULL;\n       bool notokay = false;\n       unsigned int i;\n@@ -4481,7 +4447,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  vi->size = ~0;\n \t  vi->is_full_var = true;\n \t  VEC_free (fieldoff_s, heap, fieldstack);\n-\t  return index;\n+\t  return vi->id;\n \t}\n \n       vi->size = fo->size;\n@@ -4495,7 +4461,6 @@ create_variable_info_for (tree decl, const char *name)\n \t  const char *newname = \"NULL\";\n \t  char *tempname;\n \n-\t  newindex = VEC_length (varinfo_t, varmap);\n \t  if (dump_file)\n \t    {\n \t      asprintf (&tempname, \"%s.\" HOST_WIDE_INT_PRINT_DEC\n@@ -4504,13 +4469,12 @@ create_variable_info_for (tree decl, const char *name)\n \t      newname = ggc_strdup (tempname);\n \t      free (tempname);\n \t    }\n-\t  newvi = new_var_info (decl, newindex, newname);\n+\t  newvi = new_var_info (decl, newname);\n \t  newvi->offset = fo->offset;\n \t  newvi->size = fo->size;\n \t  newvi->fullsize = vi->fullsize;\n \t  newvi->may_have_pointers = fo->may_have_pointers;\n \t  insert_into_field_list (vi, newvi);\n-\t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global && (!flag_whole_program || !in_ipa_mode)\n \t      && newvi->may_have_pointers)\n \t    make_copy_constraint (newvi, nonlocal_id);\n@@ -4523,7 +4487,7 @@ create_variable_info_for (tree decl, const char *name)\n \n   VEC_free (fieldoff_s, heap, fieldstack);\n \n-  return index;\n+  return vi->id;\n }\n \n /* Print out the points-to solution for VAR to FILE.  */\n@@ -4770,7 +4734,6 @@ find_what_var_points_to (varinfo_t vi, struct pt_solution *pt)\n   bitmap_iterator bi;\n   bitmap finished_solution;\n   bitmap result;\n-  tree ptr = vi->decl;\n \n   memset (pt, 0, sizeof (struct pt_solution));\n \n@@ -4813,9 +4776,6 @@ find_what_var_points_to (varinfo_t vi, struct pt_solution *pt)\n   finished_solution = BITMAP_GGC_ALLOC ();\n   stats.points_to_sets_created++;\n \n-  if (TREE_CODE (ptr) == SSA_NAME)\n-    ptr = SSA_NAME_VAR (ptr);\n-\n   set_uids_in_ptset (finished_solution, vi->solution, pt);\n   result = shared_bitmap_lookup (finished_solution);\n   if (!result)\n@@ -5066,24 +5026,29 @@ static void\n init_base_vars (void)\n {\n   struct constraint_expr lhs, rhs;\n+  varinfo_t var_anything;\n+  varinfo_t var_nothing;\n+  varinfo_t var_readonly;\n+  varinfo_t var_escaped;\n+  varinfo_t var_nonlocal;\n+  varinfo_t var_callused;\n+  varinfo_t var_storedanything;\n+  varinfo_t var_integer;\n \n   /* Create the NULL variable, used to represent that a variable points\n      to NULL.  */\n-  nothing_tree = create_tmp_var_raw (void_type_node, \"NULL\");\n-  var_nothing = new_var_info (nothing_tree, nothing_id, \"NULL\");\n-  insert_vi_for_tree (nothing_tree, var_nothing);\n+  var_nothing = new_var_info (NULL_TREE, \"NULL\");\n+  gcc_assert (var_nothing->id == nothing_id);\n   var_nothing->is_artificial_var = 1;\n   var_nothing->offset = 0;\n   var_nothing->size = ~0;\n   var_nothing->fullsize = ~0;\n   var_nothing->is_special_var = 1;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_nothing);\n \n   /* Create the ANYTHING variable, used to represent that a variable\n      points to some unknown piece of memory.  */\n-  anything_tree = create_tmp_var_raw (ptr_type_node, \"ANYTHING\");\n-  var_anything = new_var_info (anything_tree, anything_id, \"ANYTHING\");\n-  insert_vi_for_tree (anything_tree, var_anything);\n+  var_anything = new_var_info (NULL_TREE, \"ANYTHING\");\n+  gcc_assert (var_anything->id == anything_id);\n   var_anything->is_artificial_var = 1;\n   var_anything->size = ~0;\n   var_anything->offset = 0;\n@@ -5094,7 +5059,6 @@ init_base_vars (void)\n   /* Anything points to anything.  This makes deref constraints just\n      work in the presence of linked list and other p = *p type loops,\n      by saying that *ANYTHING = ANYTHING. */\n-  VEC_safe_push (varinfo_t, heap, varmap, var_anything);\n   lhs.type = SCALAR;\n   lhs.var = anything_id;\n   lhs.offset = 0;\n@@ -5109,16 +5073,14 @@ init_base_vars (void)\n \n   /* Create the READONLY variable, used to represent that a variable\n      points to readonly memory.  */\n-  readonly_tree = create_tmp_var_raw (ptr_type_node, \"READONLY\");\n-  var_readonly = new_var_info (readonly_tree, readonly_id, \"READONLY\");\n+  var_readonly = new_var_info (NULL_TREE, \"READONLY\");\n+  gcc_assert (var_readonly->id == readonly_id);\n   var_readonly->is_artificial_var = 1;\n   var_readonly->offset = 0;\n   var_readonly->size = ~0;\n   var_readonly->fullsize = ~0;\n   var_readonly->next = NULL;\n   var_readonly->is_special_var = 1;\n-  insert_vi_for_tree (readonly_tree, var_readonly);\n-  VEC_safe_push (varinfo_t, heap, varmap, var_readonly);\n \n   /* readonly memory points to anything, in order to make deref\n      easier.  In reality, it points to anything the particular\n@@ -5134,28 +5096,23 @@ init_base_vars (void)\n \n   /* Create the ESCAPED variable, used to represent the set of escaped\n      memory.  */\n-  escaped_tree = create_tmp_var_raw (ptr_type_node, \"ESCAPED\");\n-  var_escaped = new_var_info (escaped_tree, escaped_id, \"ESCAPED\");\n-  insert_vi_for_tree (escaped_tree, var_escaped);\n+  var_escaped = new_var_info (NULL_TREE, \"ESCAPED\");\n+  gcc_assert (var_escaped->id == escaped_id);\n   var_escaped->is_artificial_var = 1;\n   var_escaped->offset = 0;\n   var_escaped->size = ~0;\n   var_escaped->fullsize = ~0;\n   var_escaped->is_special_var = 0;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_escaped);\n-  gcc_assert (VEC_index (varinfo_t, varmap, 3) == var_escaped);\n \n   /* Create the NONLOCAL variable, used to represent the set of nonlocal\n      memory.  */\n-  nonlocal_tree = create_tmp_var_raw (ptr_type_node, \"NONLOCAL\");\n-  var_nonlocal = new_var_info (nonlocal_tree, nonlocal_id, \"NONLOCAL\");\n-  insert_vi_for_tree (nonlocal_tree, var_nonlocal);\n+  var_nonlocal = new_var_info (NULL_TREE, \"NONLOCAL\");\n+  gcc_assert (var_nonlocal->id == nonlocal_id);\n   var_nonlocal->is_artificial_var = 1;\n   var_nonlocal->offset = 0;\n   var_nonlocal->size = ~0;\n   var_nonlocal->fullsize = ~0;\n   var_nonlocal->is_special_var = 1;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_nonlocal);\n \n   /* ESCAPED = *ESCAPED, because escaped is may-deref'd at calls, etc.  */\n   lhs.type = SCALAR;\n@@ -5203,15 +5160,13 @@ init_base_vars (void)\n \n   /* Create the CALLUSED variable, used to represent the set of call-used\n      memory.  */\n-  callused_tree = create_tmp_var_raw (ptr_type_node, \"CALLUSED\");\n-  var_callused = new_var_info (callused_tree, callused_id, \"CALLUSED\");\n-  insert_vi_for_tree (callused_tree, var_callused);\n+  var_callused = new_var_info (NULL_TREE, \"CALLUSED\");\n+  gcc_assert (var_callused->id == callused_id);\n   var_callused->is_artificial_var = 1;\n   var_callused->offset = 0;\n   var_callused->size = ~0;\n   var_callused->fullsize = ~0;\n   var_callused->is_special_var = 0;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_callused);\n \n   /* CALLUSED = *CALLUSED, because call-used is may-deref'd at calls, etc.  */\n   lhs.type = SCALAR;\n@@ -5234,29 +5189,24 @@ init_base_vars (void)\n \n   /* Create the STOREDANYTHING variable, used to represent the set of\n      variables stored to *ANYTHING.  */\n-  storedanything_tree = create_tmp_var_raw (ptr_type_node, \"STOREDANYTHING\");\n-  var_storedanything = new_var_info (storedanything_tree, storedanything_id,\n-\t\t\t\t     \"STOREDANYTHING\");\n-  insert_vi_for_tree (storedanything_tree, var_storedanything);\n+  var_storedanything = new_var_info (NULL_TREE, \"STOREDANYTHING\");\n+  gcc_assert (var_storedanything->id == storedanything_id);\n   var_storedanything->is_artificial_var = 1;\n   var_storedanything->offset = 0;\n   var_storedanything->size = ~0;\n   var_storedanything->fullsize = ~0;\n   var_storedanything->is_special_var = 0;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_storedanything);\n \n   /* Create the INTEGER variable, used to represent that a variable points\n      to what an INTEGER \"points to\".  */\n-  integer_tree = create_tmp_var_raw (ptr_type_node, \"INTEGER\");\n-  var_integer = new_var_info (integer_tree, integer_id, \"INTEGER\");\n-  insert_vi_for_tree (integer_tree, var_integer);\n+  var_integer = new_var_info (NULL_TREE, \"INTEGER\");\n+  gcc_assert (var_integer->id == integer_id);\n   var_integer->is_artificial_var = 1;\n   var_integer->size = ~0;\n   var_integer->fullsize = ~0;\n   var_integer->offset = 0;\n   var_integer->next = NULL;\n   var_integer->is_special_var = 1;\n-  VEC_safe_push (varinfo_t, heap, varmap, var_integer);\n \n   /* INTEGER = ANYTHING, because we don't know where a dereference of\n      a random integer will point to.  */\n@@ -5446,8 +5396,10 @@ compute_points_to_sets (void)\n \n   /* Compute the points-to sets for ESCAPED and CALLUSED used for\n      call-clobber analysis.  */\n-  find_what_var_points_to (var_escaped, &cfun->gimple_df->escaped);\n-  find_what_var_points_to (var_callused, &cfun->gimple_df->callused);\n+  find_what_var_points_to (get_varinfo (escaped_id),\n+\t\t\t   &cfun->gimple_df->escaped);\n+  find_what_var_points_to (get_varinfo (callused_id),\n+\t\t\t   &cfun->gimple_df->callused);\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies"}]}