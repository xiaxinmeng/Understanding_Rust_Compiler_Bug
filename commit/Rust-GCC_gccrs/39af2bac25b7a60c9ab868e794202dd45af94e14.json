{"sha": "39af2bac25b7a60c9ab868e794202dd45af94e14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlhZjJiYWMyNWI3YTYwYzlhYjg2OGU3OTQyMDJkZDQ1YWY5NGUxNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:56:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:56:07Z"}, "message": "[multiple changes]\n\n2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add an entry in table Canonical_Aspect for\n\tRefined_State.\n\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n\tAspect_Names and Aspect_Delay for Refined_State.\n\t* einfo.adb: Add with and use clauses for Elists.\n\tRemove Refined_State from the list of node usage.\n\tAdd Refined_State_Pragma to the list of node usage.\n\t(Has_Null_Abstract_State): New routine.\n\t(Refined_State): Removed.\n\t(Refined_State_Pragma): New routine.\n\t(Set_Refined_State): Removed.\n\t(Set_Refined_State_Pragma): New routine.\n\t(Write_Field8_Name): Add output for Refined_State_Pragma.\n\t(Write_Field9_Name): Remove the output for Refined_State.\n\t* einfo.ads: Add new synthesized attribute Has_Null_Abstract_State\n\talong with usage in nodes.  Remove attribute Refined_State along\n\twith usage in nodes.  Add new attribute Refined_State_Pragma along\n\twith usage in nodes.\n\t(Has_Null_Abstract_State): New routine.\n\t(Refined_State): Removed.\n\t(Refined_State_Pragma): New routine.\n\t(Set_Refined_State): Removed.\n\t(Set_Refined_State_Pragma): New routine.\n\t* elists.adb (Clone): New routine.\n\t* elists.ads (Clone): New routine.\n\t* par-prag.adb: Add Refined_State to the pragmas that do not\n\trequire special processing by the parser.\n\t* sem_ch3.adb: Add with and use clause for Sem_Prag.\n\t(Analyze_Declarations): Add local variables Body_Id, Context and\n\tSpec_Id. Add processing for delayed aspect/pragma Refined_State.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Update the\n\thandling of aspect Abstract_State.  Add processing for aspect\n\tRefined_State. Remove the bizzare insertion policy for aspect\n\tAbstract_State.\n\t(Check_Aspect_At_Freeze_Point): Add an entry for Refined_State.\n\t* sem_prag.adb: Add an entry to table Sig_Flags\n\tfor pragma Refined_State.\n\t(Add_Item): Update the\n\tcomment on usage. The inserted items need not be unique.\n\t(Analyze_Contract_Cases_In_Decl_Part): Rename variable Restore to\n\tRestore_Scope and update all its occurrences.\n\t(Analyze_Pragma):\n\tUpdate the handling of pragma Abstract_State. Add processing for\n\tpragma Refined_State.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part):\n\tRename variable Restore to Restore_Scope and update all its\n\toccurrences.\n\t(Analyze_Refined_State_In_Decl_Part): New routine.\n\t* sem_prag.ads (Analyze_Refined_State_In_Decl_Part): New routine.\n\t* snames.ads-tmpl: Add new predefined name for Refined_State. Add\n\tnew Pragma_Id for Refined_State.\n\n2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Install_Limited_Withed_Unit): handle properly the\n\tcase of a record declaration in a limited view, when the record\n\tcontains a self-referential component of an anonymous access type.\n\nFrom-SVN: r203371", "tree": {"sha": "6c275556a6003daed0c6e63f15e5ba9a688875ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c275556a6003daed0c6e63f15e5ba9a688875ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39af2bac25b7a60c9ab868e794202dd45af94e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39af2bac25b7a60c9ab868e794202dd45af94e14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39af2bac25b7a60c9ab868e794202dd45af94e14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39af2bac25b7a60c9ab868e794202dd45af94e14/comments", "author": null, "committer": null, "parents": [{"sha": "815839a3844ec00f5f8700eb377fde8842082e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815839a3844ec00f5f8700eb377fde8842082e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815839a3844ec00f5f8700eb377fde8842082e96"}], "stats": {"total": 991, "additions": 866, "deletions": 125}, "files": [{"sha": "5da6a9ea305bd01769a9df4a86ab1d4d25dccd82", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -1,3 +1,63 @@\n+2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add an entry in table Canonical_Aspect for\n+\tRefined_State.\n+\t* aspects.ads: Add entries in tables Aspect_Id, Aspect_Argument,\n+\tAspect_Names and Aspect_Delay for Refined_State.\n+\t* einfo.adb: Add with and use clauses for Elists.\n+\tRemove Refined_State from the list of node usage.\n+\tAdd Refined_State_Pragma to the list of node usage.\n+\t(Has_Null_Abstract_State): New routine.\n+\t(Refined_State): Removed.\n+\t(Refined_State_Pragma): New routine.\n+\t(Set_Refined_State): Removed.\n+\t(Set_Refined_State_Pragma): New routine.\n+\t(Write_Field8_Name): Add output for Refined_State_Pragma.\n+\t(Write_Field9_Name): Remove the output for Refined_State.\n+\t* einfo.ads: Add new synthesized attribute Has_Null_Abstract_State\n+\talong with usage in nodes.  Remove attribute Refined_State along\n+\twith usage in nodes.  Add new attribute Refined_State_Pragma along\n+\twith usage in nodes.\n+\t(Has_Null_Abstract_State): New routine.\n+\t(Refined_State): Removed.\n+\t(Refined_State_Pragma): New routine.\n+\t(Set_Refined_State): Removed.\n+\t(Set_Refined_State_Pragma): New routine.\n+\t* elists.adb (Clone): New routine.\n+\t* elists.ads (Clone): New routine.\n+\t* par-prag.adb: Add Refined_State to the pragmas that do not\n+\trequire special processing by the parser.\n+\t* sem_ch3.adb: Add with and use clause for Sem_Prag.\n+\t(Analyze_Declarations): Add local variables Body_Id, Context and\n+\tSpec_Id. Add processing for delayed aspect/pragma Refined_State.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Update the\n+\thandling of aspect Abstract_State.  Add processing for aspect\n+\tRefined_State. Remove the bizzare insertion policy for aspect\n+\tAbstract_State.\n+\t(Check_Aspect_At_Freeze_Point): Add an entry for Refined_State.\n+\t* sem_prag.adb: Add an entry to table Sig_Flags\n+\tfor pragma Refined_State.\n+\t(Add_Item): Update the\n+\tcomment on usage. The inserted items need not be unique.\n+\t(Analyze_Contract_Cases_In_Decl_Part): Rename variable Restore to\n+\tRestore_Scope and update all its occurrences.\n+\t(Analyze_Pragma):\n+\tUpdate the handling of pragma Abstract_State. Add processing for\n+\tpragma Refined_State.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part):\n+\tRename variable Restore to Restore_Scope and update all its\n+\toccurrences.\n+\t(Analyze_Refined_State_In_Decl_Part): New routine.\n+\t* sem_prag.ads (Analyze_Refined_State_In_Decl_Part): New routine.\n+\t* snames.ads-tmpl: Add new predefined name for Refined_State. Add\n+\tnew Pragma_Id for Refined_State.\n+\n+2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Install_Limited_Withed_Unit): handle properly the\n+\tcase of a record declaration in a limited view, when the record\n+\tcontains a self-referential component of an anonymous access type.\n+\n 2013-10-10  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_ch4.adb (Process_Transient_Object): For any context other"}, {"sha": "2aea7b3ee8b582b0c761225aba307ea2dfafc47e", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -470,6 +470,7 @@ package body Aspects is\n     Aspect_Refined_Global               => Aspect_Refined_Global,\n     Aspect_Refined_Post                 => Aspect_Refined_Post,\n     Aspect_Refined_Pre                  => Aspect_Refined_Pre,\n+    Aspect_Refined_State                => Aspect_Refined_State,\n     Aspect_Remote_Access_Type           => Aspect_Remote_Access_Type,\n     Aspect_Remote_Call_Interface        => Aspect_Remote_Call_Interface,\n     Aspect_Remote_Types                 => Aspect_Remote_Types,"}, {"sha": "15c6e4cec432442413b2cf31c200d0b678783650", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -115,6 +115,7 @@ package Aspects is\n       Aspect_Refined_Global,                -- GNAT\n       Aspect_Refined_Post,                  -- GNAT\n       Aspect_Refined_Pre,                   -- GNAT\n+      Aspect_Refined_State,                 -- GNAT\n       Aspect_Relative_Deadline,\n       Aspect_Scalar_Storage_Order,          -- GNAT\n       Aspect_Simple_Storage_Pool,           -- GNAT\n@@ -327,6 +328,7 @@ package Aspects is\n       Aspect_Refined_Global          => Expression,\n       Aspect_Refined_Post            => Expression,\n       Aspect_Refined_Pre             => Expression,\n+      Aspect_Refined_State           => Expression,\n       Aspect_Relative_Deadline       => Expression,\n       Aspect_Scalar_Storage_Order    => Expression,\n       Aspect_Simple_Storage_Pool     => Name,\n@@ -427,6 +429,7 @@ package Aspects is\n       Aspect_Refined_Global               => Name_Refined_Global,\n       Aspect_Refined_Post                 => Name_Refined_Post,\n       Aspect_Refined_Pre                  => Name_Refined_Pre,\n+      Aspect_Refined_State                => Name_Refined_State,\n       Aspect_Relative_Deadline            => Name_Relative_Deadline,\n       Aspect_Remote_Access_Type           => Name_Remote_Access_Type,\n       Aspect_Remote_Call_Interface        => Name_Remote_Call_Interface,\n@@ -620,6 +623,7 @@ package Aspects is\n       Aspect_Read                         => Always_Delay,\n       Aspect_Refined_Depends              => Always_Delay,\n       Aspect_Refined_Global               => Always_Delay,\n+      Aspect_Refined_State                => Always_Delay,\n       Aspect_Relative_Deadline            => Always_Delay,\n       Aspect_Remote_Access_Type           => Always_Delay,\n       Aspect_Remote_Call_Interface        => Always_Delay,"}, {"sha": "5d4da12efd68f5a52ac612ae66e633d494259a7e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -33,6 +33,7 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram ordering, not used for this unit\n \n with Atree;   use Atree;\n+with Elists;  use Elists;\n with Namet;   use Namet;\n with Nlists;  use Nlists;\n with Output;  use Output;\n@@ -79,12 +80,12 @@ package body Einfo is\n    --    Mechanism                       Uint8 (but returns Mechanism_Type)\n    --    Normalized_First_Bit            Uint8\n    --    Postcondition_Proc              Node8\n+   --    Refined_State_Pragma            Node8\n    --    Return_Applies_To               Node8\n    --    First_Exit_Statement            Node8\n \n    --    Class_Wide_Type                 Node9\n    --    Current_Value                   Node9\n-   --    Refined_State                   Node9\n    --    Renaming_Map                    Uint9\n \n    --    Direct_Primitive_Operations     Elist10\n@@ -2647,11 +2648,11 @@ package body Einfo is\n       return Flag227 (Id);\n    end Referenced_As_Out_Parameter;\n \n-   function Refined_State (Id : E) return E is\n+   function Refined_State_Pragma (Id : E) return N is\n    begin\n-      pragma Assert (Ekind (Id) = E_Abstract_State);\n-      return Node9 (Id);\n-   end Refined_State;\n+      pragma Assert (Ekind (Id) = E_Package_Body);\n+      return Node8 (Id);\n+   end Refined_State_Pragma;\n \n    function Register_Exception_Call (Id : E) return N is\n    begin\n@@ -5307,11 +5308,11 @@ package body Einfo is\n       Set_Flag227 (Id, V);\n    end Set_Referenced_As_Out_Parameter;\n \n-   procedure Set_Refined_State (Id : E; V : E) is\n+   procedure Set_Refined_State_Pragma (Id : E; V : N) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Abstract_State);\n-      Set_Node9 (Id, V);\n-   end Set_Refined_State;\n+      pragma Assert (Ekind (Id) = E_Package_Body);\n+      Set_Node8 (Id, V);\n+   end Set_Refined_State_Pragma;\n \n    procedure Set_Register_Exception_Call (Id : E; V : N) is\n    begin\n@@ -6427,6 +6428,19 @@ package body Einfo is\n       return False;\n    end Has_Interrupt_Handler;\n \n+   -----------------------------\n+   -- Has_Null_Abstract_State --\n+   -----------------------------\n+\n+   function Has_Null_Abstract_State (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Generic_Package, E_Package));\n+\n+      return\n+        Present (Abstract_States (Id))\n+          and then Is_Null_State (Node (First_Elmt (Abstract_States (Id))));\n+   end Has_Null_Abstract_State;\n+\n    --------------------\n    -- Has_Unmodified --\n    --------------------\n@@ -8292,6 +8306,9 @@ package body Einfo is\n          when E_Procedure                                  =>\n             Write_Str (\"Postcondition_Proc\");\n \n+         when E_Package_Body                               =>\n+            Write_Str (\"Refined_State_Pragma\");\n+\n          when E_Return_Statement                           =>\n             Write_Str (\"Return_Applies_To\");\n \n@@ -8313,9 +8330,6 @@ package body Einfo is\n          when Object_Kind                                  =>\n             Write_Str (\"Current_Value\");\n \n-         when E_Abstract_State                             =>\n-            Write_Str (\"Refined_State\");\n-\n          when E_Function                                   |\n               E_Generic_Function                           |\n               E_Generic_Package                            |"}, {"sha": "1b4c381a8a48043fda57012623821aab585db5cc", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -1645,6 +1645,10 @@ package Einfo is\n --       are not considered to be significant since they do not affect\n --       stored bit patterns.\n \n+--    Has_Null_Abstract_State (synth)\n+--       Defined in package entities. True if the package is subject to a null\n+--       Abstract_State aspect/pragma.\n+\n --    Has_Object_Size_Clause (Flag172)\n --       Defined in entities for types and subtypes. Set if an Object_Size\n --       clause has been processed for the type Used to prevent multiple\n@@ -3533,9 +3537,9 @@ package Einfo is\n --       we have a separate warning for variables that are only assigned and\n --       never read, and out parameters are a special case.\n \n---    Refined_State (Node9)\n---       Defined in E_Abstract_State entities. Contains the entity of the\n---       abstract state completion which is usually foung in package bodies.\n+--    Refined_State_Pragma (Node8)\n+--       Defined in [generic] package bodies. Contains the pragma that refines\n+--       all abstract states defined in the corresponding package declaration.\n \n --    Register_Exception_Call (Node20)\n --       Defined in exception entities. When an exception is declared,\n@@ -5092,7 +5096,6 @@ package Einfo is\n    ------------------------------------------\n \n    --  E_Abstract_State\n-   --    Refined_State                       (Node9)\n    --    Is_External_State                   (synth)\n    --    Is_Input_Only_State                 (synth)\n    --    Is_Null_State                       (synth)\n@@ -5636,10 +5639,12 @@ package Einfo is\n    --    Is_Visible_Lib_Unit                 (Flag116)\n    --    Renamed_In_Spec                     (Flag231)  (non-generic case only)\n    --    Static_Elaboration_Desired          (Flag77)   (non-generic case only)\n+   --    Has_Null_Abstract_State             (synth)\n    --    Is_Wrapper_Package                  (synth)    (non-generic case only)\n    --    Scope_Depth                         (synth)\n \n    --  E_Package_Body\n+   --    Refined_State_Pragma                (Node8)\n    --    Handler_Records                     (List10)   (non-generic case only)\n    --    Related_Instance                    (Node15)   (non-generic case only)\n    --    First_Entity                        (Node17)\n@@ -6535,7 +6540,7 @@ package Einfo is\n    function Referenced                          (Id : E) return B;\n    function Referenced_As_LHS                   (Id : E) return B;\n    function Referenced_As_Out_Parameter         (Id : E) return B;\n-   function Refined_State                       (Id : E) return E;\n+   function Refined_State_Pragma                (Id : E) return E;\n    function Register_Exception_Call             (Id : E) return N;\n    function Related_Array_Object                (Id : E) return E;\n    function Related_Expression                  (Id : E) return N;\n@@ -6674,6 +6679,7 @@ package Einfo is\n    function Has_Attach_Handler                  (Id : E) return B;\n    function Has_Entries                         (Id : E) return B;\n    function Has_Foreign_Convention              (Id : E) return B;\n+   function Has_Null_Abstract_State             (Id : E) return B;\n    function Implementation_Base_Type            (Id : E) return E;\n    function Is_Base_Type                        (Id : E) return B;\n    function Is_Boolean_Type                     (Id : E) return B;\n@@ -7152,7 +7158,7 @@ package Einfo is\n    procedure Set_Referenced                      (Id : E; V : B := True);\n    procedure Set_Referenced_As_LHS               (Id : E; V : B := True);\n    procedure Set_Referenced_As_Out_Parameter     (Id : E; V : B := True);\n-   procedure Set_Refined_State                   (Id : E; V : E);\n+   procedure Set_Refined_State_Pragma            (Id : E; V : N);\n    procedure Set_Register_Exception_Call         (Id : E; V : N);\n    procedure Set_Related_Array_Object            (Id : E; V : E);\n    procedure Set_Related_Expression              (Id : E; V : N);\n@@ -7902,7 +7908,7 @@ package Einfo is\n    pragma Inline (Referenced);\n    pragma Inline (Referenced_As_LHS);\n    pragma Inline (Referenced_As_Out_Parameter);\n-   pragma Inline (Refined_State);\n+   pragma Inline (Refined_State_Pragma);\n    pragma Inline (Register_Exception_Call);\n    pragma Inline (Related_Array_Object);\n    pragma Inline (Related_Expression);\n@@ -8318,7 +8324,7 @@ package Einfo is\n    pragma Inline (Set_Referenced);\n    pragma Inline (Set_Referenced_As_LHS);\n    pragma Inline (Set_Referenced_As_Out_Parameter);\n-   pragma Inline (Set_Refined_State);\n+   pragma Inline (Set_Refined_State_Pragma);\n    pragma Inline (Set_Register_Exception_Call);\n    pragma Inline (Set_Related_Array_Object);\n    pragma Inline (Set_Related_Expression);"}, {"sha": "a840d95e333b9cbcdadd350b65d5b1a72ac413d1", "filename": "gcc/ada/elists.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -158,6 +158,34 @@ package body Elists is\n       end loop;\n    end Append_Unique_Elmt;\n \n+   -----------\n+   -- Clone --\n+   ------------\n+\n+   function Clone (List : Elist_Id) return Elist_Id is\n+      Result : Elist_Id;\n+      Elmt   : Elmt_Id;\n+\n+   begin\n+      if List = No_Elist then\n+         return No_Elist;\n+\n+      --  Replicate the contents of the input list while preserving the\n+      --  original order.\n+\n+      else\n+         Result := New_Elmt_List;\n+\n+         Elmt := First_Elmt (List);\n+         while Present (Elmt) loop\n+            Append_Elmt (Node (Elmt), Result);\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         return Result;\n+      end if;\n+   end Clone;\n+\n    --------------\n    -- Contains --\n    --------------"}, {"sha": "d2eb745cc8a96a1cc2844ba35e78301009740c75", "filename": "gcc/ada/elists.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Felists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Felists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.ads?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -153,6 +153,10 @@ package Elists is\n    --  affected, but the space used by the list element may be (but is not\n    --  required to be) freed for reuse in a subsequent Append_Elmt call.\n \n+   function Clone (List : Elist_Id) return Elist_Id;\n+   --  Create a copy of the input list. Internal list nodes are not shared and\n+   --  order of elements is preserved.\n+\n    function Contains (List : Elist_Id; N : Node_Or_Entity_Id) return Boolean;\n    --  Perform a sequential search to determine whether the given list contains\n    --  a node or an entity."}, {"sha": "bf23bc7d609cd5f16b2c5986cb53cec8a36a78c5", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -1254,6 +1254,7 @@ begin\n            Pragma_Refined_Global                 |\n            Pragma_Refined_Post                   |\n            Pragma_Refined_Pre                    |\n+           Pragma_Refined_State                  |\n            Pragma_Relative_Deadline              |\n            Pragma_Remote_Access_Type             |\n            Pragma_Remote_Call_Interface          |"}, {"sha": "ee2ab6300cde01f487a0e262e5092114aa7e3274", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 39, "deletions": 54, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -330,9 +330,8 @@ package body Sem_Ch10 is\n             function Same_Unit (N : Node_Id; P : Entity_Id) return Boolean is\n             begin\n                return Entity (N) = P\n-                 or else\n-                   (Present (Renamed_Object (P))\n-                     and then Entity (N) = Renamed_Object (P));\n+                 or else (Present (Renamed_Object (P))\n+                           and then Entity (N) = Renamed_Object (P));\n             end Same_Unit;\n \n          --  Start of processing for Process_Body_Clauses\n@@ -404,14 +403,12 @@ package body Sem_Ch10 is\n                elsif Nkind (Cont_Item) = N_Pragma\n                  and then\n                    Nam_In (Pragma_Name (Cont_Item), Name_Elaborate,\n-                                                     Name_Elaborate_All)\n+                                                    Name_Elaborate_All)\n                  and then not Used_Type_Or_Elab\n                then\n                   Prag_Unit :=\n                     First (Pragma_Argument_Associations (Cont_Item));\n-                  while Present (Prag_Unit)\n-                    and then not Used_Type_Or_Elab\n-                  loop\n+                  while Present (Prag_Unit) and then not Used_Type_Or_Elab loop\n                      if Entity (Expression (Prag_Unit)) = Nam_Ent then\n                         Used_Type_Or_Elab := True;\n                      end if;\n@@ -478,7 +475,7 @@ package body Sem_Ch10 is\n                --     with Pack;\n                --     with Pack;\n                --     pragma Elaborate (Pack);\n-               --\n+\n                --  In this case, the second with clause is redundant since\n                --  the pragma applies only to the first \"with Pack;\".\n \n@@ -558,10 +555,8 @@ package body Sem_Ch10 is\n                      if (Withed_In_Spec\n                            and then not Used_Type_Or_Elab)\n                              and then\n-                               ((not Used_In_Spec\n-                                   and then not Used_In_Body)\n-                                     or else\n-                                       Used_In_Spec)\n+                               ((not Used_In_Spec and then not Used_In_Body)\n+                                  or else Used_In_Spec)\n                      then\n                         Error_Msg_N -- CODEFIX\n                           (\"redundant with clause in body??\", Clause);\n@@ -1014,9 +1009,8 @@ package body Sem_Ch10 is\n                               N_Package_Renaming_Declaration,\n                               N_Subprogram_Declaration)\n         or else Nkind (Unit_Node) in N_Generic_Declaration\n-        or else\n-          (Nkind (Unit_Node) = N_Subprogram_Body\n-            and then Acts_As_Spec (Unit_Node))\n+        or else (Nkind (Unit_Node) = N_Subprogram_Body\n+                  and then Acts_As_Spec (Unit_Node))\n       then\n          Remove_Unit_From_Visibility (Defining_Entity (Unit_Node));\n \n@@ -1932,10 +1926,9 @@ package body Sem_Ch10 is\n          Nam := Full_View (Nam);\n       end if;\n \n-      if No (Nam)\n-        or else not Is_Protected_Type (Etype (Nam))\n-      then\n+      if No (Nam) or else not Is_Protected_Type (Etype (Nam)) then\n          Error_Msg_N (\"missing specification for Protected body\", N);\n+\n       else\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Set_Has_Completion (Etype (Nam));\n@@ -1970,9 +1963,7 @@ package body Sem_Ch10 is\n                                N_Subprogram_Body)\n       then\n          Decl := First (Declarations (Parent (N)));\n-         while Present (Decl)\n-           and then Decl /= N\n-         loop\n+         while Present (Decl) and then Decl /= N loop\n             if Nkind (Decl) = N_Subprogram_Body_Stub\n               and then (Chars (Defining_Unit_Name (Specification (Decl))) =\n                         Chars (Defining_Unit_Name (Specification (N))))\n@@ -2184,9 +2175,7 @@ package body Sem_Ch10 is\n \n          E := First_Entity (Current_Scope);\n          while Present (E) loop\n-            if not Is_Child_Unit (E)\n-              or else Is_Visible_Lib_Unit (E)\n-            then\n+            if not Is_Child_Unit (E) or else Is_Visible_Lib_Unit (E) then\n                Set_Is_Immediately_Visible (E);\n             end if;\n \n@@ -2312,8 +2301,8 @@ package body Sem_Ch10 is\n          if Is_Package_Or_Generic_Package (Par_Unit) then\n             if not Is_Immediately_Visible (Par_Unit)\n               or else (Present (First_Entity (Par_Unit))\n-                        and then not Is_Immediately_Visible\n-                                      (First_Entity (Par_Unit)))\n+                        and then not\n+                          Is_Immediately_Visible (First_Entity (Par_Unit)))\n             then\n                Set_Is_Immediately_Visible   (Par_Unit);\n                Install_Visible_Declarations (Par_Unit);\n@@ -2923,7 +2912,7 @@ package body Sem_Ch10 is\n                  or else Private_Present (Item)\n                  or else Nkind_In (Lib_Unit, N_Package_Body, N_Subunit)\n                  or else (Nkind (Lib_Unit) = N_Subprogram_Body\n-                            and then not Acts_As_Spec (Parent (Lib_Unit)))\n+                           and then not Acts_As_Spec (Parent (Lib_Unit)))\n                then\n                   null;\n \n@@ -3464,7 +3453,7 @@ package body Sem_Ch10 is\n \n       if Nkind (Lib_Unit) = N_Package_Body\n         or else (Nkind (Lib_Unit) = N_Subprogram_Body\n-                   and then not Acts_As_Spec (N))\n+                  and then not Acts_As_Spec (N))\n       then\n          Install_Context (Library_Unit (N));\n \n@@ -3636,9 +3625,7 @@ package body Sem_Ch10 is\n                      --  Check all the enclosing scopes.\n \n                      E2 := E;\n-                     while E2 /= Standard_Standard\n-                       and then E2 /= WEnt\n-                     loop\n+                     while E2 /= Standard_Standard and then E2 /= WEnt loop\n                         E2 := Scope (E2);\n                      end loop;\n \n@@ -3856,9 +3843,7 @@ package body Sem_Ch10 is\n \n             Check_Private_Limited_Withed_Unit (Item);\n \n-            if not Implicit_With (Item)\n-              and then Is_Child_Spec (Unit (N))\n-            then\n+            if not Implicit_With (Item) and then Is_Child_Spec (Unit (N)) then\n                Check_Renamings (Parent_Spec (Unit (N)), Item);\n             end if;\n \n@@ -3998,7 +3983,7 @@ package body Sem_Ch10 is\n            or else Nkind (Original_Node (Lib_Unit)) in N_Generic_Instantiation\n            or else\n              (Nkind (Lib_Unit) = N_Package_Declaration\n-                and then Present (Generic_Parent (Specification (Lib_Unit))))\n+               and then Present (Generic_Parent (Specification (Lib_Unit))))\n          then\n             null;\n          else\n@@ -4061,9 +4046,7 @@ package body Sem_Ch10 is\n          Set_Use (Generic_Formal_Declarations (Parent (P_Spec)));\n       end if;\n \n-      if Is_Private\n-        or else Private_Present (Parent (Lib_Unit))\n-      then\n+      if Is_Private or else Private_Present (Parent (Lib_Unit)) then\n          Install_Private_Declarations (P_Name);\n          Install_Private_With_Clauses (P_Name);\n          Set_Use (Private_Declarations (P_Spec));\n@@ -4992,7 +4975,18 @@ package body Sem_Ch10 is\n                   --  Replace E in the homonyms list, so that the limited view\n                   --  becomes available.\n \n-                  if E = Non_Limited_View (Lim_Typ) then\n+                  --  If the non-limited view is a record with an anonymous\n+                  --  self-referential component, the analysis of the record\n+                  --  declaration creates an incomplete type with the same name\n+                  --  in order to define an internal access type. The visible\n+                  --  entity is now the incomplete type, and that is the one to\n+                  --  replace in the visibility structure.\n+\n+                  if E = Non_Limited_View (Lim_Typ)\n+                    or else\n+                      (Ekind (E) = E_Incomplete_Type\n+                        and then Full_View (E) = Non_Limited_View (Lim_Typ))\n+                  then\n                      Set_Homonym (Lim_Typ, Homonym (Prev));\n                      Set_Current_Entity (Lim_Typ);\n \n@@ -5004,9 +4998,7 @@ package body Sem_Ch10 is\n                         --  limited_with_clause.\n \n                         exit when No (E);\n-\n                         exit when E = Non_Limited_View (Lim_Typ);\n-\n                         Prev := Homonym (Prev);\n                      end loop;\n \n@@ -5128,7 +5120,7 @@ package body Sem_Ch10 is\n \n       if Sloc (Uname) /= No_Location\n         and then (not Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n-                    or else Current_Sem_Unit = Main_Unit)\n+                   or else Current_Sem_Unit = Main_Unit)\n       then\n          Check_Restricted_Unit\n            (Unit_Name (Get_Source_Unit (Uname)), With_Clause);\n@@ -5224,9 +5216,7 @@ package body Sem_Ch10 is\n \n          begin\n             U2 := Homonym (Uname);\n-            while Present (U2)\n-              and then U2 /= Standard_Standard\n-           loop\n+            while Present (U2) and then U2 /= Standard_Standard loop\n                P2 := Scope (U2);\n                Decl2  := Unit_Declaration_Node (P2);\n \n@@ -5836,9 +5826,7 @@ package body Sem_Ch10 is\n          Ent : Entity_Id;\n \n       begin\n-         if Is_Subprogram (E)\n-           and then Has_Pragma_Inline (E)\n-         then\n+         if Is_Subprogram (E) and then Has_Pragma_Inline (E) then\n             return True;\n \n          elsif Ekind_In (E, E_Generic_Function, E_Generic_Procedure) then\n@@ -6225,9 +6213,8 @@ package body Sem_Ch10 is\n    begin\n       Item := First (Context_Items (Comp_Unit));\n       while Present (Item) loop\n-         if Nkind (Item) = N_With_Clause\n-           and then Private_Present (Item)\n-         then\n+         if Nkind (Item) = N_With_Clause and then Private_Present (Item) then\n+\n             --  If private_with_clause is redundant, remove it from context,\n             --  as a small optimization to subsequent handling of private_with\n             --  clauses in other nested packages.\n@@ -6310,9 +6297,7 @@ package body Sem_Ch10 is\n          Set_Name_Entity_Id (Chars (E), Homonym (E));\n \n       else\n-         while Present (Prev)\n-           and then Homonym (Prev) /= E\n-         loop\n+         while Present (Prev) and then Homonym (Prev) /= E loop\n             Prev := Homonym (Prev);\n          end loop;\n "}, {"sha": "0b812a73f63d0438b8acfb2ec9e9d840dd75a793", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -1883,12 +1883,45 @@ package body Sem_Ch13 is\n \n                --  Abstract_State\n \n-               when Aspect_Abstract_State =>\n-                  Make_Aitem_Pragma\n-                    (Pragma_Argument_Associations => New_List (\n-                       Make_Pragma_Argument_Association (Loc,\n-                         Expression => Relocate_Node (Expr))),\n-                     Pragma_Name                  => Name_Abstract_State);\n+               when Aspect_Abstract_State => Abstract_State : declare\n+                  Decls : List_Id;\n+                  Spec  : Node_Id;\n+\n+               begin\n+                  --  Aspect Abstract_State introduces implicit declarations\n+                  --  for all state abstraction entities it defines. To emulate\n+                  --  this behavior, insert the pragma at the beginning of the\n+                  --  visible declarations of the related package so that it is\n+                  --  analyzed immediately.\n+\n+                  if Nkind_In (N, N_Generic_Package_Declaration,\n+                                  N_Package_Declaration)\n+                  then\n+                     Spec  := Specification (N);\n+                     Decls := Visible_Declarations (Spec);\n+\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => New_List (\n+                          Make_Pragma_Argument_Association (Loc,\n+                            Expression => Relocate_Node (Expr))),\n+                        Pragma_Name                  => Name_Abstract_State);\n+                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+\n+                     if No (Decls) then\n+                        Decls := New_List;\n+                        Set_Visible_Declarations (N, Decls);\n+                     end if;\n+\n+                     Prepend_To (Decls, Aitem);\n+\n+                  else\n+                     Error_Msg_NE\n+                       (\"aspect & must apply to a package declaration\",\n+                        Aspect, Id);\n+                  end if;\n+\n+                  goto Continue;\n+               end Abstract_State;\n \n                --  Depends\n \n@@ -1967,6 +2000,42 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Refined_Pre);\n \n+               --  Refined_State\n+\n+               when Aspect_Refined_State => Refined_State : declare\n+                  Decls : List_Id;\n+\n+               begin\n+                  --  The corresponding pragma for Refined_State is inserted in\n+                  --  the declarations of the related package body. This action\n+                  --  synchronizes both the source and from-aspect versions of\n+                  --  the pragma.\n+\n+                  if Nkind (N) = N_Package_Body then\n+                     Decls := Declarations (N);\n+\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => New_List (\n+                          Make_Pragma_Argument_Association (Loc,\n+                            Expression => Relocate_Node (Expr))),\n+                        Pragma_Name                  => Name_Refined_State);\n+                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+\n+                     if No (Decls) then\n+                        Decls := New_List;\n+                        Set_Declarations (N, Decls);\n+                     end if;\n+\n+                     Prepend_To (Decls, Aitem);\n+\n+                  else\n+                     Error_Msg_NE\n+                       (\"aspect & must apply to a package body\", Aspect, Id);\n+                  end if;\n+\n+                  goto Continue;\n+               end Refined_State;\n+\n                --  Relative_Deadline\n \n                when Aspect_Relative_Deadline =>\n@@ -2411,21 +2480,6 @@ package body Sem_Ch13 is\n                Set_From_Aspect_Specification (Aitem, True);\n             end if;\n \n-            --  Aspect Abstract_State introduces implicit declarations for all\n-            --  state abstraction entities it defines. To emulate this behavior\n-            --  insert the pragma at the start of the visible declarations of\n-            --  the related package.\n-\n-            if Nam = Name_Abstract_State\n-              and then Nkind (N) = N_Package_Declaration\n-            then\n-               if No (Visible_Declarations (Specification (N))) then\n-                  Set_Visible_Declarations (Specification (N), New_List);\n-               end if;\n-\n-               Prepend (Aitem, Visible_Declarations (Specification (N)));\n-               goto Continue;\n-\n             --  In the context of a compilation unit, we directly put the\n             --  pragma in the Pragmas_After list of the N_Compilation_Unit_Aux\n             --  node (no delay is required here) except for aspects on a\n@@ -2434,7 +2488,7 @@ package body Sem_Ch13 is\n             --  copy (see sem_ch12), and for package instantiations, where\n             --  the library unit pragmas are better handled early.\n \n-            elsif Nkind (Parent (N)) = N_Compilation_Unit\n+            if Nkind (Parent (N)) = N_Compilation_Unit\n               and then (Present (Aitem) or else Is_Boolean_Aspect (Aspect))\n             then\n                declare\n@@ -7651,6 +7705,7 @@ package body Sem_Ch13 is\n               Aspect_Refined_Global       |\n               Aspect_Refined_Post         |\n               Aspect_Refined_Pre          |\n+              Aspect_Refined_State        |\n               Aspect_SPARK_Mode           |\n               Aspect_Test_Case            =>\n             raise Program_Error;"}, {"sha": "5e40656e76b037d00337c8a7002b42aae29c87dc", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -64,6 +64,7 @@ with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Smem; use Sem_Smem;\n with Sem_Type; use Sem_Type;\n@@ -2079,8 +2080,11 @@ package body Sem_Ch3 is\n \n       --  Local variables\n \n+      Body_Id     : Entity_Id;\n+      Context     : Node_Id;\n       Freeze_From : Entity_Id := Empty;\n       Next_Decl   : Node_Id;\n+      Spec_Id     : Entity_Id;\n \n    --  Start of processing for Analyze_Declarations\n \n@@ -2190,6 +2194,37 @@ package body Sem_Ch3 is\n          Decl := Next_Decl;\n       end loop;\n \n+      --  Analyze the state refinements within a package body now, after all\n+      --  hidden states have been encountered and freely visible. Refinements\n+      --  must be processed before pragmas Refined_Depends and Refined_Global\n+      --  because the last two may mention constituents.\n+\n+      if Present (L) then\n+         Context := Parent (L);\n+\n+         if Nkind (Context) = N_Package_Body then\n+            Body_Id := Defining_Entity (Context);\n+            Spec_Id := Corresponding_Spec (Context);\n+\n+            --  The analysis of pragma Refined_State detects whether the spec\n+            --  has abstract states available for refinement.\n+\n+            if Present (Refined_State_Pragma (Body_Id)) then\n+               Analyze_Refined_State_In_Decl_Part\n+                 (Refined_State_Pragma (Body_Id));\n+\n+            --  State refinement is required when the package declaration has\n+            --  abstract states. Null states are not considered.\n+\n+            elsif Present (Abstract_States (Spec_Id))\n+              and then not Has_Null_Abstract_State (Spec_Id)\n+            then\n+               Error_Msg_NE\n+                 (\"package & requires state refinement\", Context, Spec_Id);\n+            end if;\n+         end if;\n+      end if;\n+\n       --  Analyze the contracts of a subprogram declaration or a body now due\n       --  to delayed visibility requirements of aspects.\n "}, {"sha": "c0475343e837e6e9dda94e51ad55212b968232f5", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 569, "deletions": 29, "changes": 598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -168,9 +168,9 @@ package body Sem_Prag is\n    -------------------------------------\n \n    procedure Add_Item (Item : Entity_Id; To_List : in out Elist_Id);\n-   --  Subsidiary routine to the analysis of pragmas Depends and Global. Append\n-   --  an input or output item to a list. If the list is empty, a new one is\n-   --  created.\n+   --  Subsidiary routine to the analysis of pragmas Depends, Global and\n+   --  Refined_State. Append an entity to a list. If the list is empty, create\n+   --  a new list.\n \n    function Adjust_External_Name_Case (N : Node_Id) return Node_Id;\n    --  This routine is used for possible casing adjustment of an explicit\n@@ -285,7 +285,7 @@ package body Sem_Prag is\n          To_List := New_Elmt_List;\n       end if;\n \n-      Append_Unique_Elmt (Item, To_List);\n+      Append_Elmt (Item, To_List);\n    end Add_Item;\n \n    -------------------------------\n@@ -404,10 +404,12 @@ package body Sem_Prag is\n       Arg1      : constant Node_Id := First (Pragma_Argument_Associations (N));\n       All_Cases : Node_Id;\n       CCase     : Node_Id;\n-      Restore   : Boolean := False;\n       Subp_Decl : Node_Id;\n       Subp_Id   : Entity_Id;\n \n+      Restore_Scope : Boolean := False;\n+      --  Gets set True if we do a Push_Scope needing a Pop_Scope on exit\n+\n    --  Start of processing for Analyze_Contract_Cases_In_Decl_Part\n \n    begin\n@@ -432,7 +434,7 @@ package body Sem_Prag is\n             --  for subprogram bodies because the formals are already visible.\n \n             if Requires_Profile_Installation (N, Subp_Decl) then\n-               Restore := True;\n+               Restore_Scope := True;\n                Push_Scope (Subp_Id);\n                Install_Formals (Subp_Id);\n             end if;\n@@ -443,7 +445,7 @@ package body Sem_Prag is\n                Next (CCase);\n             end loop;\n \n-            if Restore then\n+            if Restore_Scope then\n                End_Scope;\n             end if;\n          end if;\n@@ -8494,7 +8496,6 @@ package body Sem_Prag is\n                Set_Parent            (Id, State);\n                Set_Ekind             (Id, E_Abstract_State);\n                Set_Etype             (Id, Standard_Void_Type);\n-               Set_Refined_State     (Id, Empty);\n \n                --  Every non-null state must be nameable and resolvable the\n                --  same way a constant is.\n@@ -8523,8 +8524,8 @@ package body Sem_Prag is\n \n             --  Local variables\n \n-            Par   : Node_Id;\n-            State : Node_Id;\n+            Context : constant Node_Id := Parent (Parent (N));\n+            State   : Node_Id;\n \n          --  Start of processing for Abstract_State\n \n@@ -8536,24 +8537,14 @@ package body Sem_Prag is\n             --  Ensure the proper placement of the pragma. Abstract states must\n             --  be associated with a package declaration.\n \n-            if From_Aspect_Specification (N) then\n-               Par := Parent (Corresponding_Aspect (N));\n-            else\n-               Par := Parent (Parent (N));\n-            end if;\n-\n-            if Nkind (Par) = N_Compilation_Unit then\n-               Par := Unit (Par);\n-            end if;\n-\n-            if not Nkind_In (Par, N_Generic_Package_Declaration,\n-                                  N_Package_Declaration)\n+            if not Nkind_In (Context, N_Generic_Package_Declaration,\n+                                      N_Package_Declaration)\n             then\n                Pragma_Misplaced;\n                return;\n             end if;\n \n-            Pack_Id := Defining_Entity (Par);\n+            Pack_Id := Defining_Entity (Context);\n             State   := Expression (Arg1);\n \n             --  Multiple abstract states appear as an aggregate\n@@ -15974,6 +15965,62 @@ package body Sem_Prag is\n          when Pragma_Refined_Pre =>\n             Analyze_Refined_Pre_Post_Condition;\n \n+         -------------------\n+         -- Refined_State --\n+         -------------------\n+\n+         --  pragma Refined_State (REFINEMENT_LIST);\n+\n+         --  REFINEMENT_LIST ::=\n+         --    REFINEMENT_CLAUSE\n+         --    | (REFINEMENT_CLAUSE {, REFINEMENT_CLAUSE})\n+\n+         --  REFINEMENT_CLAUSE ::= state_NAME => CONSTITUENT_LIST\n+\n+         --  CONSTITUENT_LIST ::=\n+         --    null\n+         --    | CONSTITUENT\n+         --    | (CONSTITUENT {, CONSTITUENT})\n+\n+         --  CONSTITUENT ::= object_NAME | state_NAME\n+\n+         when Pragma_Refined_State => Refined_State : declare\n+            Context : constant Node_Id := Parent (N);\n+            Spec_Id : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+\n+            --  Ensure the proper placement of the pragma. Refined states must\n+            --  be associated with a package body.\n+\n+            if Nkind (Context) /= N_Package_Body then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            --  State refinement is allowed only when the corresponding package\n+            --  declaration has a non-null aspect/pragma Abstract_State.\n+\n+            Spec_Id := Corresponding_Spec (Context);\n+\n+            if No (Abstract_States (Spec_Id))\n+              or else Has_Null_Abstract_State (Spec_Id)\n+            then\n+               Error_Pragma\n+                 (\"useless pragma %, package does not define abstract states\");\n+               return;\n+            end if;\n+\n+            --  The pragma must be analyzed at the end of the declarations as\n+            --  it has visibility over the whole declarative region. Save the\n+            --  pragma for later (see Analyze_Refined_Depends_In_Decl_Part).\n+\n+            Set_Refined_State_Pragma (Defining_Entity (Context), N);\n+         end Refined_State;\n+\n          -----------------------\n          -- Relative_Deadline --\n          -----------------------\n@@ -18313,17 +18360,18 @@ package body Sem_Prag is\n      (Prag    : Node_Id;\n       Subp_Id : Entity_Id)\n    is\n-      Arg1    : constant Node_Id :=\n-                  First (Pragma_Argument_Associations (Prag));\n-      Expr    : Node_Id;\n-      Restore : Boolean := False;\n+      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (Prag));\n+      Expr : Node_Id;\n+\n+      Restore_Scope : Boolean := False;\n+      --  Gets set True if we do a Push_Scope needing a Pop_Scope on exit\n \n    begin\n       --  Ensure that the subprogram and its formals are visible when analyzing\n       --  the expression of the pragma.\n \n       if Current_Scope /= Subp_Id then\n-         Restore := True;\n+         Restore_Scope := True;\n          Push_Scope (Subp_Id);\n          Install_Formals (Subp_Id);\n       end if;\n@@ -18465,7 +18513,7 @@ package body Sem_Prag is\n       --  Remove the subprogram from the scope stack now that the pre-analysis\n       --  of the precondition/postcondition is done.\n \n-      if Restore then\n+      if Restore_Scope then\n          End_Scope;\n       end if;\n    end Analyze_Pre_Post_Condition_In_Decl_Part;\n@@ -18494,6 +18542,497 @@ package body Sem_Prag is\n       null;\n    end Analyze_Refined_Global_In_Decl_Part;\n \n+   ----------------------------------------\n+   -- Analyze_Refined_State_In_Decl_Part --\n+   ----------------------------------------\n+\n+   procedure Analyze_Refined_State_In_Decl_Part (N : Node_Id) is\n+      Pack_Body : constant Node_Id   := Parent (N);\n+      Spec_Id   : constant Entity_Id := Corresponding_Spec (Pack_Body);\n+\n+      Abstr_States : Elist_Id := No_Elist;\n+      --  A list of all abstract states defined in the package declaration. The\n+      --  list is used to report unrefined states.\n+\n+      Constituents_Seen : Elist_Id := No_Elist;\n+      --  A list that contains all constituents processed so far. The list is\n+      --  used to detect multiple uses of the same constituent.\n+\n+      Hidden_States : Elist_Id := No_Elist;\n+      --  A list of all hidden states (abstract states and variables) that\n+      --  appear in the package spec and body. The list is used to report\n+      --  unused hidden states.\n+\n+      Refined_States_Seen : Elist_Id := No_Elist;\n+      --  A list that contains all refined states processed so far. The list is\n+      --  used to detect duplicate refinements.\n+\n+      procedure Analyze_Refinement_Clause (Clause : Node_Id);\n+      --  Perform full analysis of a single refinement clause\n+\n+      function Collect_Hidden_States return Elist_Id;\n+      --  Gather the entities of all hidden states that appear in the spec and\n+      --  body of the related package.\n+\n+      procedure Report_Unrefined_States;\n+      --  Emit errors for all abstract states that have not been refined by\n+      --  the pragma.\n+\n+      procedure Report_Unused_Hidden_States;\n+      --  Emit errors for all hidden states of the related package that do not\n+      --  participate in a refinement.\n+\n+      -------------------------------\n+      -- Analyze_Refinement_Clause --\n+      -------------------------------\n+\n+      procedure Analyze_Refinement_Clause (Clause : Node_Id) is\n+         Non_Null_Seen : Boolean := False;\n+         Null_Seen     : Boolean := False;\n+         --  Flags used to detect multiple uses of null in a single clause or a\n+         --  mixture of null and non-null constituents.\n+\n+         procedure Analyze_Constituent (Constit : Node_Id);\n+         --  Perform full analysis of a single constituent\n+\n+         procedure Check_Matching_State\n+           (State    : Node_Id;\n+            State_Id : Entity_Id);\n+         --  Determine whether state State denoted by its name State_Id appears\n+         --  in Abstr_States. Emit an error when attempting to re-refine the\n+         --  state or when the state is not defined in the package declaration.\n+         --  Otherwise remove the state from Abstr_States.\n+\n+         -------------------------\n+         -- Analyze_Constituent --\n+         -------------------------\n+\n+         procedure Analyze_Constituent (Constit : Node_Id) is\n+            procedure Check_Matching_Constituent (Constit_Id : Entity_Id);\n+            --  Determine whether constituent Constit denoted by its entity\n+            --  Constit_Id appears in Hidden_States. Emit an error when the\n+            --  constituent is not a valid hidden state of the related package\n+            --  or when it is used more than once. Otherwise remove the\n+            --  constituent from Hidden_States.\n+\n+            --------------------------------\n+            -- Check_Matching_Constituent --\n+            --------------------------------\n+\n+            procedure Check_Matching_Constituent (Constit_Id : Entity_Id) is\n+               State_Elmt : Elmt_Id;\n+\n+            begin\n+               --  Detect a duplicate use of a constituent\n+\n+               if Contains (Constituents_Seen, Constit_Id) then\n+                  Error_Msg_NE\n+                    (\"duplicate use of constituent &\", Constit, Constit_Id);\n+                  return;\n+               end if;\n+\n+               --  Inspect the hidden states of the related package looking for\n+               --  a match.\n+\n+               State_Elmt := First_Elmt (Hidden_States);\n+               while Present (State_Elmt) loop\n+\n+                  --  A valid hidden state or variable participates in a\n+                  --  refinement. Add the constituent to the list of processed\n+                  --  items to aid with the detection of duplicate constituent\n+                  --  use. Remove the constituent from Hidden_States to signal\n+                  --  that it has already been used.\n+\n+                  if Node (State_Elmt) = Constit_Id then\n+                     Add_Item (Constit_Id, Constituents_Seen);\n+                     Remove_Elmt (Hidden_States, State_Elmt);\n+\n+                     return;\n+                  end if;\n+\n+                  Next_Elmt (State_Elmt);\n+               end loop;\n+\n+               --  If we get here, we are refining a state that is not hidden\n+               --  with respect to the related package.\n+\n+               Error_Msg_Name_1 := Chars (Spec_Id);\n+               Error_Msg_NE\n+                 (\"cannot use & in refinement, constituent is not a hidden \"\n+                  & \"state of package %\", Constit, Constit_Id);\n+            end Check_Matching_Constituent;\n+\n+            --  Local variables\n+\n+            Constit_Id : Entity_Id;\n+\n+         --  Start of processing for Analyze_Constituent\n+\n+         begin\n+            --  Detect multiple uses of null in a single refinement clause or a\n+            --  mixture of null and non-null constituents.\n+\n+            if Nkind (Constit) = N_Null then\n+               if Null_Seen then\n+                  Error_Msg_N\n+                    (\"multiple null constituents not allowed\", Constit);\n+\n+               elsif Non_Null_Seen then\n+                  Error_Msg_N\n+                    (\"cannot mix null and non-null constituents\", Constit);\n+\n+               else\n+                  Null_Seen := True;\n+               end if;\n+\n+            --  Non-null constituents\n+\n+            else\n+               Non_Null_Seen := True;\n+\n+               if Null_Seen then\n+                  Error_Msg_N\n+                    (\"cannot mix null and non-null constituents\", Constit);\n+               end if;\n+\n+               Analyze (Constit);\n+\n+               --  Ensure that the constituent denotes a valid state or a\n+               --  whole variable.\n+\n+               if Is_Entity_Name (Constit) then\n+                  Constit_Id := Entity (Constit);\n+\n+                  if Ekind_In (Constit_Id, E_Abstract_State, E_Variable) then\n+                     Check_Matching_Constituent (Constit_Id);\n+                  else\n+                     Error_Msg_NE\n+                       (\"constituent & must denote a variable or state\",\n+                        Constit, Constit_Id);\n+                  end if;\n+\n+               --  The constituent is illegal\n+\n+               else\n+                  Error_Msg_N (\"malformed constituent\", Constit);\n+               end if;\n+            end if;\n+         end Analyze_Constituent;\n+\n+         --------------------------\n+         -- Check_Matching_State --\n+         --------------------------\n+\n+         procedure Check_Matching_State\n+           (State    : Node_Id;\n+            State_Id : Entity_Id)\n+         is\n+            State_Elmt : Elmt_Id;\n+\n+         begin\n+            --  Detect a duplicate refinement of a state\n+\n+            if Contains (Refined_States_Seen, State_Id) then\n+               Error_Msg_NE\n+                 (\"duplicate refinement of state &\", State, State_Id);\n+               return;\n+            end if;\n+\n+            --  Inspect the abstract states defined in the package declaration\n+            --  looking for a match.\n+\n+            State_Elmt := First_Elmt (Abstr_States);\n+            while Present (State_Elmt) loop\n+\n+               --  A valid abstract state is being refined in the body. Add\n+               --  the state to the list of processed refined states to aid\n+               --  with the detection of duplicate refinements. Remove the\n+               --  state from Abstr_States to signal that it has already been\n+               --  refined.\n+\n+               if Node (State_Elmt) = State_Id then\n+                  Add_Item (State_Id, Refined_States_Seen);\n+                  Remove_Elmt (Abstr_States, State_Elmt);\n+\n+                  return;\n+               end if;\n+\n+               Next_Elmt (State_Elmt);\n+            end loop;\n+\n+            --  If we get here, we are refining a state that is not defined in\n+            --  the package declaration.\n+\n+            Error_Msg_Name_1 := Chars (Spec_Id);\n+            Error_Msg_NE\n+              (\"cannot refine state, & is not defined in package %\",\n+               State, State_Id);\n+         end Check_Matching_State;\n+\n+         --  Local declarations\n+\n+         Constit  : Node_Id;\n+         State    : Node_Id;\n+         State_Id : Entity_Id := Empty;\n+\n+      --  Start of processing for Analyze_Refinement_Clause\n+\n+      begin\n+         --  Analyze the state name of a refinement clause\n+\n+         State := First (Choices (Clause));\n+         while Present (State) loop\n+            if Present (State_Id) then\n+               Error_Msg_N\n+                 (\"refinement clause cannot cover multiple states\", State);\n+\n+            else\n+               Analyze (State);\n+\n+               --  Ensure that the state name denotes a valid abstract state\n+               --  that is defined in the spec of the related package.\n+\n+               if Is_Entity_Name (State) then\n+                  State_Id := Entity (State);\n+\n+                  --  Catch any attempts to re-refine a state or refine a\n+                  --  state that is not defined in the package declaration.\n+\n+                  if Ekind (State_Id) = E_Abstract_State then\n+                     Check_Matching_State (State, State_Id);\n+                  else\n+                     Error_Msg_NE\n+                       (\"& must denote an abstract state\", State, State_Id);\n+                  end if;\n+\n+               --  The state name is illegal\n+\n+               else\n+                  Error_Msg_N\n+                    (\"malformed state name in refinement clause\", State);\n+               end if;\n+            end if;\n+\n+            Next (State);\n+         end loop;\n+\n+         --  Analyze all constituents of the refinement. Multiple constituents\n+         --  appear as an aggregate.\n+\n+         Constit := Expression (Clause);\n+\n+         if Nkind (Constit) = N_Aggregate then\n+            if Present (Component_Associations (Constit)) then\n+               Error_Msg_N\n+                 (\"constituents of refinement clause must appear in \"\n+                  & \"positional form\", Constit);\n+\n+            else pragma Assert (Present (Expressions (Constit)));\n+               Constit := First (Expressions (Constit));\n+               while Present (Constit) loop\n+                  Analyze_Constituent (Constit);\n+\n+                  Next (Constit);\n+               end loop;\n+            end if;\n+\n+         --  Various forms of a single constituent. Note that these may include\n+         --  malformed constituents.\n+\n+         else\n+            Analyze_Constituent (Constit);\n+         end if;\n+      end Analyze_Refinement_Clause;\n+\n+      ---------------------------\n+      -- Collect_Hidden_States --\n+      ---------------------------\n+\n+      function Collect_Hidden_States return Elist_Id is\n+         Result : Elist_Id := No_Elist;\n+\n+         procedure Collect_Hidden_States_In_Decls (Decls : List_Id);\n+         --  Find all hidden states that appear in declarative list Decls and\n+         --  append their entities to Result.\n+\n+         ------------------------------------\n+         -- Collect_Hidden_States_In_Decls --\n+         ------------------------------------\n+\n+         procedure Collect_Hidden_States_In_Decls (Decls : List_Id) is\n+            procedure Collect_Abstract_States (States : Elist_Id);\n+            --  Copy the abstract states defined in list States to list Result\n+\n+            -----------------------------\n+            -- Collect_Abstract_States --\n+            -----------------------------\n+\n+            procedure Collect_Abstract_States (States : Elist_Id) is\n+               State_Elmt : Elmt_Id;\n+\n+            begin\n+               State_Elmt := First_Elmt (States);\n+               while Present (State_Elmt) loop\n+                  Add_Item (Node (State_Elmt), Result);\n+\n+                  Next_Elmt (State_Elmt);\n+               end loop;\n+            end Collect_Abstract_States;\n+\n+            --  Local variables\n+\n+            Decl : Node_Id;\n+\n+         --  Start of processing for Collect_Hidden_States_In_Decls\n+\n+         begin\n+            Decl := First (Decls);\n+            while Present (Decl) loop\n+\n+               --  Objects (non-constants) are valid hidden states\n+\n+               if Nkind (Decl) = N_Object_Declaration\n+                 and then not Constant_Present (Decl)\n+               then\n+                  Add_Item (Defining_Entity (Decl), Result);\n+\n+               --  Gather the abstract states of a package along with all\n+               --  hidden states in its visible declarations.\n+\n+               elsif Nkind (Decl) = N_Package_Declaration then\n+                  Collect_Abstract_States\n+                    (Abstract_States (Defining_Entity (Decl)));\n+\n+                  Collect_Hidden_States_In_Decls\n+                    (Visible_Declarations (Specification (Decl)));\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end Collect_Hidden_States_In_Decls;\n+\n+         --  Local variables\n+\n+         Pack_Spec : constant Node_Id := Parent (Spec_Id);\n+\n+      --  Start of processing for Collect_Hidden_States\n+\n+      begin\n+         --  Process the private declarations of the package spec and the\n+         --  declarations of the body.\n+\n+         Collect_Hidden_States_In_Decls (Private_Declarations (Pack_Spec));\n+         Collect_Hidden_States_In_Decls (Declarations (Pack_Body));\n+\n+         return Result;\n+      end Collect_Hidden_States;\n+\n+      -----------------------------\n+      -- Report_Unrefined_States --\n+      -----------------------------\n+\n+      procedure Report_Unrefined_States is\n+         State_Elmt : Elmt_Id;\n+\n+      begin\n+         if Present (Abstr_States) then\n+            State_Elmt := First_Elmt (Abstr_States);\n+            while Present (State_Elmt) loop\n+               Error_Msg_N\n+                 (\"abstract state & must be refined\", Node (State_Elmt));\n+\n+               Next_Elmt (State_Elmt);\n+            end loop;\n+         end if;\n+      end Report_Unrefined_States;\n+\n+      ---------------------------------\n+      -- Report_Unused_Hidden_States --\n+      ---------------------------------\n+\n+      procedure Report_Unused_Hidden_States is\n+         Posted     : Boolean := False;\n+         State_Elmt : Elmt_Id;\n+         State_Id   : Entity_Id;\n+\n+      begin\n+         if Present (Hidden_States) then\n+            State_Elmt := First_Elmt (Hidden_States);\n+            while Present (State_Elmt) loop\n+               State_Id := Node (State_Elmt);\n+\n+               --  Generate an error message of the form:\n+\n+               --    package ... has unused hidden states\n+               --      abstract state ... defined at ...\n+               --      variable ... defined at ...\n+\n+               if not Posted then\n+                  Posted := True;\n+                  Error_Msg_NE\n+                    (\"package & has unused hidden states\", N, Spec_Id);\n+               end if;\n+\n+               Error_Msg_Sloc := Sloc (State_Id);\n+\n+               if Ekind (State_Id) = E_Abstract_State then\n+                  Error_Msg_NE (\"\\  abstract state & defined #\", N, State_Id);\n+               else\n+                  Error_Msg_NE (\"\\  variable & defined #\", N, State_Id);\n+               end if;\n+\n+               Next_Elmt (State_Elmt);\n+            end loop;\n+         end if;\n+      end Report_Unused_Hidden_States;\n+\n+      --  Local declarations\n+\n+      Clauses : constant Node_Id :=\n+                  Expression (First (Pragma_Argument_Associations (N)));\n+      Clause  : Node_Id;\n+\n+   --  Start of processing for Analyze_Refined_State_In_Decl_Part\n+\n+   begin\n+      Set_Analyzed (N);\n+\n+      --  Initialize the various lists used during analysis\n+\n+      Abstr_States  := Clone (Abstract_States (Spec_Id));\n+      Hidden_States := Collect_Hidden_States;\n+\n+      --  Multiple state refinements appear as an aggregate\n+\n+      if Nkind (Clauses) = N_Aggregate then\n+         if Present (Expressions (Clauses)) then\n+            Error_Msg_N\n+              (\"state refinements must appear as component associations\",\n+               Clauses);\n+\n+         else pragma Assert (Present (Component_Associations (Clauses)));\n+            Clause := First (Component_Associations (Clauses));\n+            while Present (Clause) loop\n+               Analyze_Refinement_Clause (Clause);\n+\n+               Next (Clause);\n+            end loop;\n+         end if;\n+\n+      --  Various forms of a single state refinement. Note that these may\n+      --  include malformed refinements.\n+\n+      else\n+         Analyze_Refinement_Clause (Clauses);\n+      end if;\n+\n+      --  Ensure that all abstract states have been refined and all hidden\n+      --  states of the related package unilized in refinements.\n+\n+      Report_Unrefined_States;\n+      Report_Unused_Hidden_States;\n+   end Analyze_Refined_State_In_Decl_Part;\n+\n    ------------------------------------\n    -- Analyze_Test_Case_In_Decl_Part --\n    ------------------------------------\n@@ -19250,6 +19789,7 @@ package body Sem_Prag is\n       Pragma_Refined_Global                 => -1,\n       Pragma_Refined_Post                   => -1,\n       Pragma_Refined_Pre                    => -1,\n+      Pragma_Refined_State                  => -1,\n       Pragma_Relative_Deadline              => -1,\n       Pragma_Remote_Access_Type             => -1,\n       Pragma_Remote_Call_Interface          => -1,"}, {"sha": "a50757b3ef4c366f59f2f7848900ba456ad1aaa9", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -77,6 +77,9 @@ package Sem_Prag is\n    procedure Analyze_Refined_Global_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Refined_Global\n \n+   procedure Analyze_Refined_State_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis of delayed pragma Refined_State\n+\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id; S : Entity_Id);\n    --  Perform preanalysis of pragma Test_Case that applies to a subprogram\n    --  declaration. Parameter N denotes the pragma, S is the entity of the"}, {"sha": "ceb50f848cde839b5d36d301d0ffb81fc0d0d921", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39af2bac25b7a60c9ab868e794202dd45af94e14/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=39af2bac25b7a60c9ab868e794202dd45af94e14", "patch": "@@ -584,6 +584,10 @@ package Snames is\n    Name_Refined_Global                 : constant Name_Id := N + $; -- GNAT\n    Name_Refined_Post                   : constant Name_Id := N + $; -- GNAT\n    Name_Refined_Pre                    : constant Name_Id := N + $; -- GNAT\n+\n+   --  Kirchev\n+\n+   Name_Refined_State                  : constant Name_Id := N + $; -- GNAT\n    Name_Relative_Deadline              : constant Name_Id := N + $; -- Ada 05\n    Name_Remote_Access_Type             : constant Name_Id := N + $; -- GNAT\n    Name_Remote_Call_Interface          : constant Name_Id := N + $;\n@@ -1871,6 +1875,7 @@ package Snames is\n       Pragma_Refined_Global,\n       Pragma_Refined_Post,\n       Pragma_Refined_Pre,\n+      Pragma_Refined_State,\n       Pragma_Relative_Deadline,\n       Pragma_Remote_Access_Type,\n       Pragma_Remote_Call_Interface,"}]}