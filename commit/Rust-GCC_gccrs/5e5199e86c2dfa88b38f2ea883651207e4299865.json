{"sha": "5e5199e86c2dfa88b38f2ea883651207e4299865", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU1MTk5ZTg2YzJkZmE4OGIzOGYyZWE4ODM2NTEyMDdlNDI5OTg2NQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1998-04-22T08:04:13Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-04-22T08:04:13Z"}, "message": "cplus-dem.c: Add code to enable demangling of names produced with the -fsquangle option.\n\n* cplus-dem.c:  Add code to enable demangling of names produced\n                with the -fsquangle option.\n\nFrom-SVN: r19371", "tree": {"sha": "3399029f64c7b49459f4fa00e33abe287ef173df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3399029f64c7b49459f4fa00e33abe287ef173df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e5199e86c2dfa88b38f2ea883651207e4299865", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5199e86c2dfa88b38f2ea883651207e4299865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e5199e86c2dfa88b38f2ea883651207e4299865", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5199e86c2dfa88b38f2ea883651207e4299865/comments", "author": null, "committer": null, "parents": [{"sha": "ce5b6870d1d9ca2246485b6eb2f4aefd1dfa1e53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce5b6870d1d9ca2246485b6eb2f4aefd1dfa1e53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce5b6870d1d9ca2246485b6eb2f4aefd1dfa1e53"}], "stats": {"total": 676, "additions": 630, "deletions": 46}, "files": [{"sha": "dd3fa3c0a3fc78d4d7042b605f91ec790e208982", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5199e86c2dfa88b38f2ea883651207e4299865/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5199e86c2dfa88b38f2ea883651207e4299865/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e5199e86c2dfa88b38f2ea883651207e4299865", "patch": "@@ -1,3 +1,22 @@\n+Wed Apr 22 10:53:49 EDT 1998 Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* cplus-dem.c (struct work stuff): Add field for B and K mangle codes.\n+\t(cplus_demangle_opname): Call mop_up_squangle.\n+\t(cplus_demangle): Initialize squangle info, then call \n+\tinternal_cplus_demangle. (Most code moved there as well)\n+\t(internal_cplus_demangle): New function, performs most of what use \n+\tto be done in cplus_demangle, but is only called with this file.\n+\t(squangle_mop_up): New function to clean up B and K code data.\n+\t(mop_up): set pointers to NULL after freeing.\n+\t(demangle_signature, demangle_template, demangle_class): Add \n+\tswitch elements to handle K and B codes.\n+\t(demangle_prefix, gnu_special, demangle_qualified): Add\n+\tcode to handle K and B codes.\n+\t(do_type, demangle_fund_type): Handle B and K codes.\n+\t(remember_Ktype): New function to store K info.\n+\t(register_Btype, remember_Btype): New functions for B codes.\n+\t(forget_B_and_K_types): New function to destroy B and K info.\n+\n 1998-04-21  Jim Wilson  <wilson@cygnus.com>\n \n \t* stmt.c (check_seenlabel): When search for line number note for"}, {"sha": "abc85bbe5d1cd0d766cf312a3c3aad2333e8b9ff", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 296, "deletions": 23, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5199e86c2dfa88b38f2ea883651207e4299865/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5199e86c2dfa88b38f2ea883651207e4299865/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=5e5199e86c2dfa88b38f2ea883651207e4299865", "patch": "@@ -101,6 +101,12 @@ struct work_stuff\n {\n   int options;\n   char **typevec;\n+  char **ktypevec;\n+  char **btypevec;\n+  int numk;\n+  int numb;\n+  int ksize;\n+  int bsize;\n   int ntypes;\n   int typevec_size;\n   int constructor;\n@@ -214,6 +220,7 @@ typedef struct string\t\t/* Beware: these aren't required to be */\n     string_prepend(str, \" \");}\n #define APPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_append(str, \" \");}\n+#define LEN_STRING(str)         ( (STRING_EMPTY(str))?0:((str)->p - (str)->b))\n \n #define ARM_VTABLE_STRING \"__vtbl__\"\t/* Lucid/ARM virtual table prefix */\n #define ARM_VTABLE_STRLEN 8\t\t/* strlen (ARM_VTABLE_STRING) */\n@@ -223,11 +230,17 @@ typedef struct string\t\t/* Beware: these aren't required to be */\n static char *\n mop_up PARAMS ((struct work_stuff *, string *, int));\n \n+static char *\n+squangle_mop_up PARAMS ((struct work_stuff *));\n+\n #if 0\n static int\n-demangle_method_args PARAMS ((struct work_stuff *work, const char **, string *));\n+demangle_method_args PARAMS ((struct work_stuff *, const char **, string *));\n #endif\n \n+static char *\n+internal_cplus_demangle PARAMS ((struct work_stuff *, const char *, int));\n+\n static int\n demangle_template_template_parm PARAMS ((struct work_stuff *work, \n \t\t\t\t\t const char **, string *));\n@@ -325,9 +338,21 @@ demangle_function_name PARAMS ((struct work_stuff *, const char **, string *,\n static void\n remember_type PARAMS ((struct work_stuff *, const char *, int));\n \n+static void\n+remember_Btype PARAMS ((struct work_stuff *, const char *, int, int));\n+\n+static int\n+register_Btype PARAMS ((struct work_stuff *));\n+\n+static void\n+remember_Ktype PARAMS ((struct work_stuff *, const char *, int));\n+\n static void\n forget_types PARAMS ((struct work_stuff *));\n \n+static void\n+forget_B_and_K_types PARAMS ((struct work_stuff *));\n+\n static void\n string_prepends PARAMS ((string *, string *));\n \n@@ -511,6 +536,7 @@ cplus_demangle_opname (opname, result, options)\n \t  ret = 1;\n \t}\n     }\n+  squangle_mop_up (work);\n   return ret;\n \n }\n@@ -572,18 +598,45 @@ cplus_demangle (mangled, options)\n      const char *mangled;\n      int options;\n {\n+  char *ret;\n+  struct work_stuff work[1];\n+  memset ((char *) work, 0, sizeof (work));\n+  work -> options = options;\n+  if ((work -> options & DMGL_STYLE_MASK) == 0)\n+    work -> options |= (int) current_demangling_style & DMGL_STYLE_MASK;\n+\n+  ret = internal_cplus_demangle (work, mangled, options);\n+  squangle_mop_up (work);\n+  return (ret);\n+}\n+  \n+\n+/* This function performs most of what cplus_demangle use to do, but \n+   to be able to demangle a name with a B, K or n code, we need to\n+   have a longer term memory of what types have been seen. The original\n+   now intializes and cleans up the squangle code info, while internal\n+   calls go directly to this routine to avoid resetting that info. */\n+\n+static char *\n+internal_cplus_demangle (work, mangled, options)\n+     struct work_stuff *work;\n+     const char *mangled;\n+     int options;\n+{\n+\n   string decl;\n   int success = 0;\n-  struct work_stuff work[1];\n   char *demangled = NULL;\n+  int s1,s2,s3,s4;\n+  s1 = work->constructor;\n+  s2 = work->destructor;\n+  s3 = work->static_type;\n+  s4 = work->const_type;\n+  work->constructor = work->destructor = 0;\n+  work->static_type = work->const_type = 0;\n \n   if ((mangled != NULL) && (*mangled != '\\0'))\n     {\n-      memset ((char *) work, 0, sizeof (work));\n-      work -> options = options;\n-      if ((work->options & DMGL_STYLE_MASK) == 0)\n-\twork->options |= (int)current_demangling_style & DMGL_STYLE_MASK;\n-      \n       string_init (&decl);\n \n       /* First check to see if gnu style demangling is active and if the\n@@ -607,19 +660,43 @@ cplus_demangle (mangled, options)\n \t}\n       if (work->constructor == 2)\n         {\n-          string_prepend(&decl, \"global constructors keyed to \");\n+          string_prepend (&decl, \"global constructors keyed to \");\n           work->constructor = 0;\n         }\n       else if (work->destructor == 2)\n         {\n-          string_prepend(&decl, \"global destructors keyed to \");\n+          string_prepend (&decl, \"global destructors keyed to \");\n           work->destructor = 0;\n         }\n       demangled = mop_up (work, &decl, success);\n     }\n+  work->constructor = s1;\n+  work->destructor = s2;\n+  work->static_type = s3;\n+  work->const_type = s4;\n   return (demangled);\n }\n \n+\n+/* Clear out and squangling related storage */\n+static char *\n+squangle_mop_up (work)\n+     struct work_stuff *work;\n+{\n+  /* clean up the B and K type mangling types. */\n+  forget_B_and_K_types (work);\n+  if (work -> btypevec != NULL)\n+    {\n+      free ((char *) work -> btypevec);\n+    }\n+  if (work -> ktypevec != NULL)\n+    {\n+      free ((char *) work -> ktypevec);\n+    }\n+}\n+\n+/* Clear out any mangled storage */\n+\n static char *\n mop_up (work, declp, success)\n      struct work_stuff *work;\n@@ -634,6 +711,7 @@ mop_up (work, declp, success)\n   if (work -> typevec != NULL)\n     {\n       free ((char *) work -> typevec);\n+      work -> typevec = NULL;\n     }\n   if (work->tmpl_argvec)\n     {\n@@ -644,6 +722,7 @@ mop_up (work, declp, success)\n \t  free ((char*) work->tmpl_argvec[i]);\n       \n       free ((char*) work->tmpl_argvec);\n+      work->tmpl_argvec = NULL;\n     }\n \n   /* If demangling was successful, ensure that the demangled string is null\n@@ -722,6 +801,16 @@ demangle_signature (work, mangled, declp)\n \t    }\n \t  oldmangled = NULL;\n \t  break;\n+\n+        case 'K':\n+\t  oldmangled = *mangled;\n+\t  success = demangle_qualified (work, mangled, declp, 1, 0);\n+\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t    {\n+\t      expect_func = 1;\n+\t    }\n+\t  oldmangled = NULL;\n+\t  break;\n \t  \n \tcase 'S':\n \t  /* Static member function */\n@@ -1061,7 +1150,7 @@ demangle_integral_value (work, mangled, s)\n \t  (*mangled)++;\n \t}\n     }\n-  else if (**mangled == 'Q')\n+  else if (**mangled == 'Q' || **mangled == 'K')\n     success = demangle_qualified (work, mangled, s, 0, 1);\n   else\n     {\n@@ -1119,6 +1208,10 @@ demangle_template_value_parm (work, mangled, s)\n \t  continue;\n \tcase 'E':       /* expression */\n \tcase 'Q':\t/* qualified name */\n+\tcase 'K':\t/* qualified name */\n+\t  done = is_integral = 1;\n+\t  break;\n+\tcase 'B':\t/* squangled name */\n \t  done = is_integral = 1;\n \t  break;\n \tcase 'T':\t/* remembered type */\n@@ -1247,7 +1340,7 @@ demangle_template_value_parm (work, mangled, s)\n \t  char *p = xmalloc (symbol_len + 1), *q;\n \t  strncpy (p, *mangled, symbol_len);\n \t  p [symbol_len] = '\\0';\n-\t  q = cplus_demangle (p, work->options);\n+\t  q = internal_cplus_demangle (work, p, work->options);\n \t  string_appendn (s, \"&\", 1);\n \t  if (q)\n \t    {\n@@ -1604,9 +1697,11 @@ demangle_class (work, mangled, declp)\n      string *declp;\n {\n   int success = 0;\n+  int btype;\n   string class_name;\n \n   string_init (&class_name);\n+  btype = register_Btype (work);\n   if (demangle_class_name (work, mangled, &class_name))\n     {\n       if ((work->constructor & 1) || (work->destructor & 1))\n@@ -1622,6 +1717,8 @@ demangle_class (work, mangled, declp)\n \t      work -> constructor -= 1; \n \t    }\n \t}\n+      remember_Ktype (work, class_name.b, LEN_STRING(&class_name));\n+      remember_Btype (work, class_name.b, LEN_STRING(&class_name), btype);\n       string_prepend (declp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n       string_prepends (declp, &class_name);\n       success = 1;\n@@ -1745,7 +1842,7 @@ demangle_prefix (work, mangled, declp)\n     }\n   else if ((scan == *mangled)\n \t   && (isdigit (scan[2]) || (scan[2] == 'Q') || (scan[2] == 't')\n-\t       || (scan[2] == 'H')))\n+\t       || (scan[2] == 'K') || (scan[2] == 'H')))\n     {\n       /* The ARM says nothing about the mangling of local variables.\n \t But cfront mangles local variables by prepending __<nesting_level>\n@@ -1892,6 +1989,7 @@ gnu_special (work, mangled, declp)\n \t  switch (**mangled)\n \t    {\n \t    case 'Q':\n+\t    case 'K':\n \t      success = demangle_qualified (work, mangled, declp, 0, 1);\n \t      break;\n \t    case 't':\n@@ -1946,6 +2044,7 @@ gnu_special (work, mangled, declp)\n       switch (**mangled)\n \t{\n \tcase 'Q':\n+\tcase 'K':\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n@@ -1974,7 +2073,7 @@ gnu_special (work, mangled, declp)\n   else if (strncmp (*mangled, \"__thunk_\", 8) == 0)\n     {\n       int delta = ((*mangled) += 8, consume_count (mangled));\n-      char *method = cplus_demangle (++*mangled, work->options);\n+      char *method = internal_cplus_demangle (work, ++*mangled, work->options);\n       if (method)\n \t{\n \t  char buf[50];\n@@ -1998,6 +2097,7 @@ gnu_special (work, mangled, declp)\n       switch (**mangled)\n \t{\n \tcase 'Q':\n+\tcase 'K':\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n@@ -2132,15 +2232,28 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n      int isfuncname;\n      int append;\n {\n-  int qualifiers;\n+  int qualifiers = 0;\n   int namelength;\n   int success = 1;\n   const char *p;\n   char num[2];\n   string temp;\n \n   string_init (&temp);\n-  switch ((*mangled)[1])\n+\n+  if ((*mangled)[0] == 'K')\n+    {\n+    /* Squangling qualified name reuse */\n+      int idx;\n+      (*mangled)++;\n+      idx = consume_count_with_underscores (mangled);\n+      if (idx == -1 || idx > work -> numk)\n+        success = 0;\n+      else\n+        string_append (&temp, work -> ktypevec[idx]);\n+    }\n+  else\n+    switch ((*mangled)[1])\n     {\n     case '_':\n       /* GNU mangled name with more than 9 classes.  The count is preceded\n@@ -2198,6 +2311,7 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \n   while (qualifiers-- > 0)\n     {\n+      int remember_K = 1;\n       if (*mangled[0] == '_') \n \t*mangled = *mangled + 1;\n       if (*mangled[0] == 't')\n@@ -2208,6 +2322,19 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n       else if (*mangled[0] == 'X')\n \t{\n \t  success = do_type (work, mangled, &temp);\n+\t  if (!success) break;\n+\t}\n+      if (*mangled[0] == 'K')\n+\t{\n+          int idx;\n+          (*mangled)++;\n+          idx = consume_count_with_underscores (mangled);\n+          if (idx == -1 || idx > work->numk)\n+            success = 0;\n+          else\n+            string_append (&temp, work->ktypevec[idx]);\n+          remember_K = 0;\n+\n \t  if (!success) break;\n \t}\n       else\n@@ -2222,6 +2349,12 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n       \t  string_appendn (&temp, *mangled, namelength);\n       \t  *mangled += namelength;\n \t}\n+\n+      if (remember_K)\n+        {\n+        remember_Ktype (work, temp.b, LEN_STRING (&temp));\n+        }\n+\n       if (qualifiers > 0)\n         {\n           string_append (&temp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n@@ -2331,7 +2464,9 @@ do_type (work, mangled, result)\n   const char *remembered_type;\n   int constp;\n   int volatilep;\n+  string btype;\n \n+  string_init (&btype);\n   string_init (&decl);\n   string_init (result);\n \n@@ -2531,7 +2666,24 @@ do_type (work, mangled, result)\n     {\n       /* A qualified name, such as \"Outer::Inner\".  */\n     case 'Q':\n-      success = demangle_qualified (work, mangled, result, 0, 1);\n+    case 'K':\n+      {\n+        int btype = register_Btype (work);\n+        success = demangle_qualified (work, mangled, result, 0, 1);\n+        remember_Btype (work, result->b, LEN_STRING (result), btype);\n+\n+        break;\n+      }\n+\n+    /* A back reference to a previously seen squangled type */\n+    case 'B':\n+      (*mangled)++;\n+      if (!get_count (mangled, &n) || n >= work -> numb)\n+          success = 0;\n+      else\n+        {\n+          string_append (result, work->btypevec[n]);\n+        }\n       break;\n \n     case 'X':\n@@ -2606,6 +2758,8 @@ demangle_fund_type (work, mangled, result)\n {\n   int done = 0;\n   int success = 1;\n+  string btype;\n+  string_init (&btype);\n \n   /* First pick off any type qualifiers.  There can be more than one.  */\n \n@@ -2731,15 +2885,28 @@ demangle_fund_type (work, mangled, result)\n     case '7':\n     case '8':\n     case '9':\n-      APPEND_BLANK (result);\n-      if (!demangle_class_name (work, mangled, result)) {\n-\t--result->p;\n-\tsuccess = 0;\n+      {\n+        int bindex = register_Btype (work);\n+        string btype;\n+        string_init (&btype);\n+        if (demangle_class_name (work, mangled, &btype)) {\n+          remember_Btype (work, btype.b, LEN_STRING (&btype), bindex);\n+          APPEND_BLANK (result);\n+          string_appends (result, &btype);\n+        }\n+        else \n+          success = 0;\n+        string_delete (&btype);\n+        break;\n       }\n-      break;\n     case 't':\n-      success = demangle_template(work,mangled, result, 0, 1);\n-      break;\n+      {\n+        int bindex= register_Btype (work);\n+        success = demangle_template (work, mangled, &btype, 0, 1);\n+        remember_Btype (work, btype.b, LEN_STRING (&btype), bindex);\n+        string_appends (result, &btype);\n+        break;\n+      }\n     default:\n       success = 0;\n       break;\n@@ -2799,6 +2966,112 @@ remember_type (work, start, len)\n   work -> typevec[work -> ntypes++] = tem;\n }\n \n+\n+/* Remember a K type class qualifier. */\n+static void\n+remember_Ktype (work, start, len)\n+     struct work_stuff *work;\n+     const char *start;\n+     int len;\n+{\n+  char *tem;\n+\n+  if (work -> numk >= work -> ksize)\n+    {\n+      if (work -> ksize == 0)\n+\t{\n+\t  work -> ksize = 5;\n+\t  work -> ktypevec\n+\t    = (char **) xmalloc (sizeof (char *) * work -> ksize);\n+\t}\n+      else\n+\t{\n+\t  work -> ksize *= 2;\n+\t  work -> ktypevec\n+\t    = (char **) xrealloc ((char *)work -> ktypevec,\n+\t\t\t\t  sizeof (char *) * work -> ksize);\n+\t}\n+    }\n+  tem = xmalloc (len + 1);\n+  memcpy (tem, start, len);\n+  tem[len] = '\\0';\n+  work -> ktypevec[work -> numk++] = tem;\n+}\n+\n+/* Register a B code, and get an index for it. B codes are registered\n+   as they are seen, rather than as they are completed, so map<temp<char> >  \n+   registers map<temp<char> > as B0, and temp<char> as B1 */\n+\n+static int\n+register_Btype (work)\n+     struct work_stuff *work;\n+{\n+  int ret;\n+ \n+  if (work -> numb >= work -> bsize)\n+    {\n+      if (work -> bsize == 0)\n+\t{\n+\t  work -> bsize = 5;\n+\t  work -> btypevec\n+\t    = (char **) xmalloc (sizeof (char *) * work -> bsize);\n+\t}\n+      else\n+\t{\n+\t  work -> bsize *= 2;\n+\t  work -> btypevec\n+\t    = (char **) xrealloc ((char *)work -> btypevec,\n+\t\t\t\t  sizeof (char *) * work -> bsize);\n+\t}\n+    }\n+  ret = work -> numb++;\n+  work -> btypevec[ret] = NULL;\n+  return(ret);\n+}\n+\n+/* Store a value into a previously registered B code type. */\n+\n+static void\n+remember_Btype (work, start, len, index)\n+     struct work_stuff *work;\n+     const char *start;\n+     int len, index;\n+{\n+  char *tem;\n+\n+  tem = xmalloc (len + 1);\n+  memcpy (tem, start, len);\n+  tem[len] = '\\0';\n+  work -> btypevec[index] = tem;\n+}\n+\n+/* Lose all the info related to B and K type codes. */\n+static void\n+forget_B_and_K_types (work)\n+     struct work_stuff *work;\n+{\n+  int i;\n+\n+  while (work -> numk > 0)\n+    {\n+      i = --(work -> numk);\n+      if (work -> ktypevec[i] != NULL)\n+\t{\n+\t  free (work -> ktypevec[i]);\n+\t  work -> ktypevec[i] = NULL;\n+\t}\n+    }\n+\n+  while (work -> numb > 0)\n+    {\n+      i = --(work -> numb);\n+      if (work -> btypevec[i] != NULL)\n+\t{\n+\t  free (work -> btypevec[i]);\n+\t  work -> btypevec[i] = NULL;\n+\t}\n+    }\n+}\n /* Forget the remembered types, but not the type vector itself.  */\n \n static void"}, {"sha": "acd96f248eba4d5dc43637be500953d85a3893ef", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5199e86c2dfa88b38f2ea883651207e4299865/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5199e86c2dfa88b38f2ea883651207e4299865/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=5e5199e86c2dfa88b38f2ea883651207e4299865", "patch": "@@ -1,3 +1,22 @@\n+Wed Apr 22 10:53:49 EDT 1998 Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* cplus-dem.c (struct work stuff): Add field for B and K mangle codes.\n+\t(cplus_demangle_opname): Call mop_up_squangle.\n+\t(cplus_demangle): Initialize squangle info, then call \n+\tinternal_cplus_demangle. (Most code moved there as well)\n+\t(internal_cplus_demangle): New function, performs most of what use \n+\tto be done in cplus_demangle, but is only called with this file.\n+\t(squangle_mop_up): New function to clean up B and K code data.\n+\t(mop_up): set pointers to NULL after freeing.\n+\t(demangle_signature, demangle_template, demangle_class): Add \n+\tswitch elements to handle K and B codes.\n+\t(demangle_prefix, gnu_special, demangle_qualified): Add\n+\tcode to handle K and B codes.\n+\t(do_type, demangle_fund_type): Handle B and K codes.\n+\t(remember_Ktype): New function to store K info.\n+\t(register_Btype, remember_Btype): New functions for B codes.\n+\t(forget_B_and_K_types): New function to destroy B and K info.\n+\n Fri Apr 10 01:45:09 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* cplus-dem.c: Sync with gcc."}, {"sha": "abc85bbe5d1cd0d766cf312a3c3aad2333e8b9ff", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 296, "deletions": 23, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5199e86c2dfa88b38f2ea883651207e4299865/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5199e86c2dfa88b38f2ea883651207e4299865/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=5e5199e86c2dfa88b38f2ea883651207e4299865", "patch": "@@ -101,6 +101,12 @@ struct work_stuff\n {\n   int options;\n   char **typevec;\n+  char **ktypevec;\n+  char **btypevec;\n+  int numk;\n+  int numb;\n+  int ksize;\n+  int bsize;\n   int ntypes;\n   int typevec_size;\n   int constructor;\n@@ -214,6 +220,7 @@ typedef struct string\t\t/* Beware: these aren't required to be */\n     string_prepend(str, \" \");}\n #define APPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_append(str, \" \");}\n+#define LEN_STRING(str)         ( (STRING_EMPTY(str))?0:((str)->p - (str)->b))\n \n #define ARM_VTABLE_STRING \"__vtbl__\"\t/* Lucid/ARM virtual table prefix */\n #define ARM_VTABLE_STRLEN 8\t\t/* strlen (ARM_VTABLE_STRING) */\n@@ -223,11 +230,17 @@ typedef struct string\t\t/* Beware: these aren't required to be */\n static char *\n mop_up PARAMS ((struct work_stuff *, string *, int));\n \n+static char *\n+squangle_mop_up PARAMS ((struct work_stuff *));\n+\n #if 0\n static int\n-demangle_method_args PARAMS ((struct work_stuff *work, const char **, string *));\n+demangle_method_args PARAMS ((struct work_stuff *, const char **, string *));\n #endif\n \n+static char *\n+internal_cplus_demangle PARAMS ((struct work_stuff *, const char *, int));\n+\n static int\n demangle_template_template_parm PARAMS ((struct work_stuff *work, \n \t\t\t\t\t const char **, string *));\n@@ -325,9 +338,21 @@ demangle_function_name PARAMS ((struct work_stuff *, const char **, string *,\n static void\n remember_type PARAMS ((struct work_stuff *, const char *, int));\n \n+static void\n+remember_Btype PARAMS ((struct work_stuff *, const char *, int, int));\n+\n+static int\n+register_Btype PARAMS ((struct work_stuff *));\n+\n+static void\n+remember_Ktype PARAMS ((struct work_stuff *, const char *, int));\n+\n static void\n forget_types PARAMS ((struct work_stuff *));\n \n+static void\n+forget_B_and_K_types PARAMS ((struct work_stuff *));\n+\n static void\n string_prepends PARAMS ((string *, string *));\n \n@@ -511,6 +536,7 @@ cplus_demangle_opname (opname, result, options)\n \t  ret = 1;\n \t}\n     }\n+  squangle_mop_up (work);\n   return ret;\n \n }\n@@ -572,18 +598,45 @@ cplus_demangle (mangled, options)\n      const char *mangled;\n      int options;\n {\n+  char *ret;\n+  struct work_stuff work[1];\n+  memset ((char *) work, 0, sizeof (work));\n+  work -> options = options;\n+  if ((work -> options & DMGL_STYLE_MASK) == 0)\n+    work -> options |= (int) current_demangling_style & DMGL_STYLE_MASK;\n+\n+  ret = internal_cplus_demangle (work, mangled, options);\n+  squangle_mop_up (work);\n+  return (ret);\n+}\n+  \n+\n+/* This function performs most of what cplus_demangle use to do, but \n+   to be able to demangle a name with a B, K or n code, we need to\n+   have a longer term memory of what types have been seen. The original\n+   now intializes and cleans up the squangle code info, while internal\n+   calls go directly to this routine to avoid resetting that info. */\n+\n+static char *\n+internal_cplus_demangle (work, mangled, options)\n+     struct work_stuff *work;\n+     const char *mangled;\n+     int options;\n+{\n+\n   string decl;\n   int success = 0;\n-  struct work_stuff work[1];\n   char *demangled = NULL;\n+  int s1,s2,s3,s4;\n+  s1 = work->constructor;\n+  s2 = work->destructor;\n+  s3 = work->static_type;\n+  s4 = work->const_type;\n+  work->constructor = work->destructor = 0;\n+  work->static_type = work->const_type = 0;\n \n   if ((mangled != NULL) && (*mangled != '\\0'))\n     {\n-      memset ((char *) work, 0, sizeof (work));\n-      work -> options = options;\n-      if ((work->options & DMGL_STYLE_MASK) == 0)\n-\twork->options |= (int)current_demangling_style & DMGL_STYLE_MASK;\n-      \n       string_init (&decl);\n \n       /* First check to see if gnu style demangling is active and if the\n@@ -607,19 +660,43 @@ cplus_demangle (mangled, options)\n \t}\n       if (work->constructor == 2)\n         {\n-          string_prepend(&decl, \"global constructors keyed to \");\n+          string_prepend (&decl, \"global constructors keyed to \");\n           work->constructor = 0;\n         }\n       else if (work->destructor == 2)\n         {\n-          string_prepend(&decl, \"global destructors keyed to \");\n+          string_prepend (&decl, \"global destructors keyed to \");\n           work->destructor = 0;\n         }\n       demangled = mop_up (work, &decl, success);\n     }\n+  work->constructor = s1;\n+  work->destructor = s2;\n+  work->static_type = s3;\n+  work->const_type = s4;\n   return (demangled);\n }\n \n+\n+/* Clear out and squangling related storage */\n+static char *\n+squangle_mop_up (work)\n+     struct work_stuff *work;\n+{\n+  /* clean up the B and K type mangling types. */\n+  forget_B_and_K_types (work);\n+  if (work -> btypevec != NULL)\n+    {\n+      free ((char *) work -> btypevec);\n+    }\n+  if (work -> ktypevec != NULL)\n+    {\n+      free ((char *) work -> ktypevec);\n+    }\n+}\n+\n+/* Clear out any mangled storage */\n+\n static char *\n mop_up (work, declp, success)\n      struct work_stuff *work;\n@@ -634,6 +711,7 @@ mop_up (work, declp, success)\n   if (work -> typevec != NULL)\n     {\n       free ((char *) work -> typevec);\n+      work -> typevec = NULL;\n     }\n   if (work->tmpl_argvec)\n     {\n@@ -644,6 +722,7 @@ mop_up (work, declp, success)\n \t  free ((char*) work->tmpl_argvec[i]);\n       \n       free ((char*) work->tmpl_argvec);\n+      work->tmpl_argvec = NULL;\n     }\n \n   /* If demangling was successful, ensure that the demangled string is null\n@@ -722,6 +801,16 @@ demangle_signature (work, mangled, declp)\n \t    }\n \t  oldmangled = NULL;\n \t  break;\n+\n+        case 'K':\n+\t  oldmangled = *mangled;\n+\t  success = demangle_qualified (work, mangled, declp, 1, 0);\n+\t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t    {\n+\t      expect_func = 1;\n+\t    }\n+\t  oldmangled = NULL;\n+\t  break;\n \t  \n \tcase 'S':\n \t  /* Static member function */\n@@ -1061,7 +1150,7 @@ demangle_integral_value (work, mangled, s)\n \t  (*mangled)++;\n \t}\n     }\n-  else if (**mangled == 'Q')\n+  else if (**mangled == 'Q' || **mangled == 'K')\n     success = demangle_qualified (work, mangled, s, 0, 1);\n   else\n     {\n@@ -1119,6 +1208,10 @@ demangle_template_value_parm (work, mangled, s)\n \t  continue;\n \tcase 'E':       /* expression */\n \tcase 'Q':\t/* qualified name */\n+\tcase 'K':\t/* qualified name */\n+\t  done = is_integral = 1;\n+\t  break;\n+\tcase 'B':\t/* squangled name */\n \t  done = is_integral = 1;\n \t  break;\n \tcase 'T':\t/* remembered type */\n@@ -1247,7 +1340,7 @@ demangle_template_value_parm (work, mangled, s)\n \t  char *p = xmalloc (symbol_len + 1), *q;\n \t  strncpy (p, *mangled, symbol_len);\n \t  p [symbol_len] = '\\0';\n-\t  q = cplus_demangle (p, work->options);\n+\t  q = internal_cplus_demangle (work, p, work->options);\n \t  string_appendn (s, \"&\", 1);\n \t  if (q)\n \t    {\n@@ -1604,9 +1697,11 @@ demangle_class (work, mangled, declp)\n      string *declp;\n {\n   int success = 0;\n+  int btype;\n   string class_name;\n \n   string_init (&class_name);\n+  btype = register_Btype (work);\n   if (demangle_class_name (work, mangled, &class_name))\n     {\n       if ((work->constructor & 1) || (work->destructor & 1))\n@@ -1622,6 +1717,8 @@ demangle_class (work, mangled, declp)\n \t      work -> constructor -= 1; \n \t    }\n \t}\n+      remember_Ktype (work, class_name.b, LEN_STRING(&class_name));\n+      remember_Btype (work, class_name.b, LEN_STRING(&class_name), btype);\n       string_prepend (declp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n       string_prepends (declp, &class_name);\n       success = 1;\n@@ -1745,7 +1842,7 @@ demangle_prefix (work, mangled, declp)\n     }\n   else if ((scan == *mangled)\n \t   && (isdigit (scan[2]) || (scan[2] == 'Q') || (scan[2] == 't')\n-\t       || (scan[2] == 'H')))\n+\t       || (scan[2] == 'K') || (scan[2] == 'H')))\n     {\n       /* The ARM says nothing about the mangling of local variables.\n \t But cfront mangles local variables by prepending __<nesting_level>\n@@ -1892,6 +1989,7 @@ gnu_special (work, mangled, declp)\n \t  switch (**mangled)\n \t    {\n \t    case 'Q':\n+\t    case 'K':\n \t      success = demangle_qualified (work, mangled, declp, 0, 1);\n \t      break;\n \t    case 't':\n@@ -1946,6 +2044,7 @@ gnu_special (work, mangled, declp)\n       switch (**mangled)\n \t{\n \tcase 'Q':\n+\tcase 'K':\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n@@ -1974,7 +2073,7 @@ gnu_special (work, mangled, declp)\n   else if (strncmp (*mangled, \"__thunk_\", 8) == 0)\n     {\n       int delta = ((*mangled) += 8, consume_count (mangled));\n-      char *method = cplus_demangle (++*mangled, work->options);\n+      char *method = internal_cplus_demangle (work, ++*mangled, work->options);\n       if (method)\n \t{\n \t  char buf[50];\n@@ -1998,6 +2097,7 @@ gnu_special (work, mangled, declp)\n       switch (**mangled)\n \t{\n \tcase 'Q':\n+\tcase 'K':\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n@@ -2132,15 +2232,28 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n      int isfuncname;\n      int append;\n {\n-  int qualifiers;\n+  int qualifiers = 0;\n   int namelength;\n   int success = 1;\n   const char *p;\n   char num[2];\n   string temp;\n \n   string_init (&temp);\n-  switch ((*mangled)[1])\n+\n+  if ((*mangled)[0] == 'K')\n+    {\n+    /* Squangling qualified name reuse */\n+      int idx;\n+      (*mangled)++;\n+      idx = consume_count_with_underscores (mangled);\n+      if (idx == -1 || idx > work -> numk)\n+        success = 0;\n+      else\n+        string_append (&temp, work -> ktypevec[idx]);\n+    }\n+  else\n+    switch ((*mangled)[1])\n     {\n     case '_':\n       /* GNU mangled name with more than 9 classes.  The count is preceded\n@@ -2198,6 +2311,7 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \n   while (qualifiers-- > 0)\n     {\n+      int remember_K = 1;\n       if (*mangled[0] == '_') \n \t*mangled = *mangled + 1;\n       if (*mangled[0] == 't')\n@@ -2208,6 +2322,19 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n       else if (*mangled[0] == 'X')\n \t{\n \t  success = do_type (work, mangled, &temp);\n+\t  if (!success) break;\n+\t}\n+      if (*mangled[0] == 'K')\n+\t{\n+          int idx;\n+          (*mangled)++;\n+          idx = consume_count_with_underscores (mangled);\n+          if (idx == -1 || idx > work->numk)\n+            success = 0;\n+          else\n+            string_append (&temp, work->ktypevec[idx]);\n+          remember_K = 0;\n+\n \t  if (!success) break;\n \t}\n       else\n@@ -2222,6 +2349,12 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n       \t  string_appendn (&temp, *mangled, namelength);\n       \t  *mangled += namelength;\n \t}\n+\n+      if (remember_K)\n+        {\n+        remember_Ktype (work, temp.b, LEN_STRING (&temp));\n+        }\n+\n       if (qualifiers > 0)\n         {\n           string_append (&temp, (work -> options & DMGL_JAVA) ? \".\" : \"::\");\n@@ -2331,7 +2464,9 @@ do_type (work, mangled, result)\n   const char *remembered_type;\n   int constp;\n   int volatilep;\n+  string btype;\n \n+  string_init (&btype);\n   string_init (&decl);\n   string_init (result);\n \n@@ -2531,7 +2666,24 @@ do_type (work, mangled, result)\n     {\n       /* A qualified name, such as \"Outer::Inner\".  */\n     case 'Q':\n-      success = demangle_qualified (work, mangled, result, 0, 1);\n+    case 'K':\n+      {\n+        int btype = register_Btype (work);\n+        success = demangle_qualified (work, mangled, result, 0, 1);\n+        remember_Btype (work, result->b, LEN_STRING (result), btype);\n+\n+        break;\n+      }\n+\n+    /* A back reference to a previously seen squangled type */\n+    case 'B':\n+      (*mangled)++;\n+      if (!get_count (mangled, &n) || n >= work -> numb)\n+          success = 0;\n+      else\n+        {\n+          string_append (result, work->btypevec[n]);\n+        }\n       break;\n \n     case 'X':\n@@ -2606,6 +2758,8 @@ demangle_fund_type (work, mangled, result)\n {\n   int done = 0;\n   int success = 1;\n+  string btype;\n+  string_init (&btype);\n \n   /* First pick off any type qualifiers.  There can be more than one.  */\n \n@@ -2731,15 +2885,28 @@ demangle_fund_type (work, mangled, result)\n     case '7':\n     case '8':\n     case '9':\n-      APPEND_BLANK (result);\n-      if (!demangle_class_name (work, mangled, result)) {\n-\t--result->p;\n-\tsuccess = 0;\n+      {\n+        int bindex = register_Btype (work);\n+        string btype;\n+        string_init (&btype);\n+        if (demangle_class_name (work, mangled, &btype)) {\n+          remember_Btype (work, btype.b, LEN_STRING (&btype), bindex);\n+          APPEND_BLANK (result);\n+          string_appends (result, &btype);\n+        }\n+        else \n+          success = 0;\n+        string_delete (&btype);\n+        break;\n       }\n-      break;\n     case 't':\n-      success = demangle_template(work,mangled, result, 0, 1);\n-      break;\n+      {\n+        int bindex= register_Btype (work);\n+        success = demangle_template (work, mangled, &btype, 0, 1);\n+        remember_Btype (work, btype.b, LEN_STRING (&btype), bindex);\n+        string_appends (result, &btype);\n+        break;\n+      }\n     default:\n       success = 0;\n       break;\n@@ -2799,6 +2966,112 @@ remember_type (work, start, len)\n   work -> typevec[work -> ntypes++] = tem;\n }\n \n+\n+/* Remember a K type class qualifier. */\n+static void\n+remember_Ktype (work, start, len)\n+     struct work_stuff *work;\n+     const char *start;\n+     int len;\n+{\n+  char *tem;\n+\n+  if (work -> numk >= work -> ksize)\n+    {\n+      if (work -> ksize == 0)\n+\t{\n+\t  work -> ksize = 5;\n+\t  work -> ktypevec\n+\t    = (char **) xmalloc (sizeof (char *) * work -> ksize);\n+\t}\n+      else\n+\t{\n+\t  work -> ksize *= 2;\n+\t  work -> ktypevec\n+\t    = (char **) xrealloc ((char *)work -> ktypevec,\n+\t\t\t\t  sizeof (char *) * work -> ksize);\n+\t}\n+    }\n+  tem = xmalloc (len + 1);\n+  memcpy (tem, start, len);\n+  tem[len] = '\\0';\n+  work -> ktypevec[work -> numk++] = tem;\n+}\n+\n+/* Register a B code, and get an index for it. B codes are registered\n+   as they are seen, rather than as they are completed, so map<temp<char> >  \n+   registers map<temp<char> > as B0, and temp<char> as B1 */\n+\n+static int\n+register_Btype (work)\n+     struct work_stuff *work;\n+{\n+  int ret;\n+ \n+  if (work -> numb >= work -> bsize)\n+    {\n+      if (work -> bsize == 0)\n+\t{\n+\t  work -> bsize = 5;\n+\t  work -> btypevec\n+\t    = (char **) xmalloc (sizeof (char *) * work -> bsize);\n+\t}\n+      else\n+\t{\n+\t  work -> bsize *= 2;\n+\t  work -> btypevec\n+\t    = (char **) xrealloc ((char *)work -> btypevec,\n+\t\t\t\t  sizeof (char *) * work -> bsize);\n+\t}\n+    }\n+  ret = work -> numb++;\n+  work -> btypevec[ret] = NULL;\n+  return(ret);\n+}\n+\n+/* Store a value into a previously registered B code type. */\n+\n+static void\n+remember_Btype (work, start, len, index)\n+     struct work_stuff *work;\n+     const char *start;\n+     int len, index;\n+{\n+  char *tem;\n+\n+  tem = xmalloc (len + 1);\n+  memcpy (tem, start, len);\n+  tem[len] = '\\0';\n+  work -> btypevec[index] = tem;\n+}\n+\n+/* Lose all the info related to B and K type codes. */\n+static void\n+forget_B_and_K_types (work)\n+     struct work_stuff *work;\n+{\n+  int i;\n+\n+  while (work -> numk > 0)\n+    {\n+      i = --(work -> numk);\n+      if (work -> ktypevec[i] != NULL)\n+\t{\n+\t  free (work -> ktypevec[i]);\n+\t  work -> ktypevec[i] = NULL;\n+\t}\n+    }\n+\n+  while (work -> numb > 0)\n+    {\n+      i = --(work -> numb);\n+      if (work -> btypevec[i] != NULL)\n+\t{\n+\t  free (work -> btypevec[i]);\n+\t  work -> btypevec[i] = NULL;\n+\t}\n+    }\n+}\n /* Forget the remembered types, but not the type vector itself.  */\n \n static void"}]}