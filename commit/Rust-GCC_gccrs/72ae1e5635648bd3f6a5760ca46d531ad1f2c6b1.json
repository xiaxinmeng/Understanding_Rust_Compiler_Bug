{"sha": "72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1", "node_id": "C_kwDOANBUbNoAKDcyYWUxZTU2MzU2NDhiZDNmNmE1NzYwY2E0NmQ1MzFhZDFmMmM2YjE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-13T13:41:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-13T14:57:09Z"}, "message": "tree-optimization/28614 - high FRE time for gcc.c-torture/compile/20001226-1.c\n\nI noticed that for gcc.c-torture/compile/20001226-1.c even -O1 has\naround 50% of the compile-time accounted to FRE.  That's because\nwe have blocks with a high incoming edge count and\ncan_track_predicate_on_edge visits all of them even though it could\nstop after the second.  The function is also called repeatedly for\nthe same edge.  The following fixes this and reduces the FRE time\nto 1% on the testcase.\n\n\tPR tree-optimization/28614\n\t* tree-ssa-sccvn.cc (can_track_predicate_on_edge): Avoid\n\twalking all edges in most cases.\n\t(vn_nary_op_insert_pieces_predicated): Avoid repeated\n\tcalls to can_track_predicate_on_edge unless checking is\n\tenabled.\n\t(process_bb): Instead call it once here for each edge\n\twe register possibly multiple predicates on.", "tree": {"sha": "6d02d7c7cac6ba51a7b0dac3846ef5972f8bd810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d02d7c7cac6ba51a7b0dac3846ef5972f8bd810"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6436add49ed9ecf74f1f01b4fe18961df4f3e83d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6436add49ed9ecf74f1f01b4fe18961df4f3e83d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6436add49ed9ecf74f1f01b4fe18961df4f3e83d"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "e5bb278196ad4ff07849111bc356151ffea81404", "filename": "gcc/tree-ssa-sccvn.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1/gcc%2Ftree-ssa-sccvn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1/gcc%2Ftree-ssa-sccvn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.cc?ref=72ae1e5635648bd3f6a5760ca46d531ad1f2c6b1", "patch": "@@ -4527,7 +4527,7 @@ vn_nary_op_insert_pieces (unsigned int length, enum tree_code code,\n static bool\n can_track_predicate_on_edge (edge pred_e)\n {\n-  /* ???  As we are currently recording a basic-block index in\n+  /* ???  As we are currently recording the destination basic-block index in\n      vn_pval.valid_dominated_by_p and using dominance for the\n      validity check we cannot track predicates on all edges.  */\n   if (single_pred_p (pred_e->dest))\n@@ -4537,14 +4537,14 @@ can_track_predicate_on_edge (edge pred_e)\n     return false;\n   /* When there's more than one predecessor we cannot track\n      predicate validity based on the destination block.  The\n-     exception is when all other incoming edges are backedges.  */\n+     exception is when all other incoming edges sources are\n+     dominated by the destination block.  */\n   edge_iterator ei;\n   edge e;\n-  int cnt = 0;\n   FOR_EACH_EDGE (e, ei, pred_e->dest->preds)\n-    if (! dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n-      cnt++;\n-  return cnt == 1;\n+    if (e != pred_e && ! dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n+      return false;\n+  return true;\n }\n \n static vn_nary_op_t\n@@ -4553,8 +4553,8 @@ vn_nary_op_insert_pieces_predicated (unsigned int length, enum tree_code code,\n \t\t\t\t     tree result, unsigned int value_id,\n \t\t\t\t     edge pred_e)\n {\n-  if (!can_track_predicate_on_edge (pred_e))\n-    return NULL;\n+  gcc_assert (can_track_predicate_on_edge (pred_e));\n+\n   if (dump_file && (dump_flags & TDF_DETAILS)\n       /* ???  Fix dumping, but currently we only get comparisons.  */\n       && TREE_CODE_CLASS (code) == tcc_comparison)\n@@ -7933,11 +7933,11 @@ process_bb (rpo_elim &avail, basic_block bb,\n \t\ttree ops[2];\n \t\tops[0] = lhs;\n \t\tops[1] = rhs;\n-\t\tif (do_region\n-\t\t    && bitmap_bit_p (exit_bbs, true_e->dest->index))\n+\t\tif ((do_region && bitmap_bit_p (exit_bbs, true_e->dest->index))\n+\t\t    || !can_track_predicate_on_edge (true_e))\n \t\t  true_e = NULL;\n-\t\tif (do_region\n-\t\t    && bitmap_bit_p (exit_bbs, false_e->dest->index))\n+\t\tif ((do_region && bitmap_bit_p (exit_bbs, false_e->dest->index))\n+\t\t    || !can_track_predicate_on_edge (false_e))\n \t\t  false_e = NULL;\n \t\tif (true_e)\n \t\t  vn_nary_op_insert_pieces_predicated"}]}