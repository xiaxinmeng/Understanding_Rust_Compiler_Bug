{"sha": "8967c38f74e68783fdbff9ad8759178d83eef637", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk2N2MzOGY3NGU2ODc4M2ZkYmZmOWFkODc1OTE3OGQ4M2VlZjYzNw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2006-10-31T18:00:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:00:29Z"}, "message": "g-os_lib.ads, [...] (Locate_Exec_On_Path): Always return an absolute path name.\n\n2006-10-31  Vincent Celier  <celier@adacore.com>\n\n\t* g-os_lib.ads, g-os_lib.adb (Locate_Exec_On_Path): Always return an\n\tabsolute path name.\n\t(Locate_Regular_File): Ditto\n\t(Change_Dir): Remove, no longer used\n\t(Normalize_Pathname): Do not use Change_Dir to get the drive letter\n\ton Windows. Get it calling Get_Current_Dir.\n\t(OpenVMS): Remove imported boolean, no longer needed.\n\t(Normalize_Pathname)[VMS]: Do not resolve directory names.\n\t(Pid_To_Integer): New function to convert a Process_Id to  Integer\n\nFrom-SVN: r118279", "tree": {"sha": "fe4bfdfe91549b1a501849cff44733a5ebf079dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe4bfdfe91549b1a501849cff44733a5ebf079dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8967c38f74e68783fdbff9ad8759178d83eef637", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8967c38f74e68783fdbff9ad8759178d83eef637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8967c38f74e68783fdbff9ad8759178d83eef637", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8967c38f74e68783fdbff9ad8759178d83eef637/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ac36caab6be73f02af1e03f0bc859c45f86e9a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac36caab6be73f02af1e03f0bc859c45f86e9a00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac36caab6be73f02af1e03f0bc859c45f86e9a00"}], "stats": {"total": 399, "additions": 185, "deletions": 214}, "files": [{"sha": "e6d08dd09cd69fdafb5456a34596124aed72de71", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 175, "deletions": 204, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8967c38f74e68783fdbff9ad8759178d83eef637/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8967c38f74e68783fdbff9ad8759178d83eef637/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=8967c38f74e68783fdbff9ad8759178d83eef637", "patch": "@@ -49,14 +49,6 @@ package body GNAT.OS_Lib is\n    procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n    pragma Import (C, Dup2, \"__gnat_dup2\");\n \n-   OpenVMS : Boolean;\n-   --  Note: OpenVMS should be a constant, but it cannot be, because it\n-   --        prevents bootstrapping on some platforms.\n-\n-   pragma Import (Ada, OpenVMS, \"system__openvms\");\n-   --  Needed to avoid doing useless checks when non on a VMS platform (see\n-   --  Normalize_Pathname).\n-\n    On_Windows : constant Boolean := Directory_Separator = '\\';\n    --  An indication that we are on Windows. Used in Normalize_Pathname, to\n    --  deal with drive letters in the beginning of absolute paths.\n@@ -713,9 +705,9 @@ package body GNAT.OS_Lib is\n    -- Create_Output_Text_File --\n    -----------------------------\n \n-   function Create_Output_Text_File (Name  : String) return File_Descriptor is\n+   function Create_Output_Text_File (Name : String) return File_Descriptor is\n       function C_Create_File\n-        (Name  : C_File_Name) return File_Descriptor;\n+        (Name : C_File_Name) return File_Descriptor;\n       pragma Import (C, C_Create_File, \"__gnat_create_output_file\");\n \n       C_Name : String (1 .. Name'Length + 1);\n@@ -914,43 +906,40 @@ package body GNAT.OS_Lib is\n       return Result;\n    end Get_Debuggable_Suffix;\n \n-   ----------------------------------\n-   -- Get_Target_Debuggable_Suffix --\n-   ----------------------------------\n+   ---------------------------\n+   -- Get_Executable_Suffix --\n+   ---------------------------\n \n-   function Get_Target_Debuggable_Suffix return String_Access is\n-      Target_Exec_Ext_Ptr : Address;\n-      pragma Import\n-        (C, Target_Exec_Ext_Ptr, \"__gnat_target_debuggable_extension\");\n+   function Get_Executable_Suffix return String_Access is\n+      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_executable_suffix_ptr\");\n \n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n \n-      function Strlen (Cstring : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n+      Suffix_Ptr    : Address;\n       Suffix_Length : Integer;\n       Result        : String_Access;\n \n    begin\n-      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n+      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n \n       Result := new String (1 .. Suffix_Length);\n \n       if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);\n+         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n       end if;\n \n       return Result;\n-   end Get_Target_Debuggable_Suffix;\n+   end Get_Executable_Suffix;\n \n-   ---------------------------\n-   -- Get_Executable_Suffix --\n-   ---------------------------\n+   -----------------------\n+   -- Get_Object_Suffix --\n+   -----------------------\n \n-   function Get_Executable_Suffix return String_Access is\n+   function Get_Object_Suffix return String_Access is\n       procedure Get_Suffix_Ptr (Length, Ptr : Address);\n-      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_executable_suffix_ptr\");\n+      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_object_suffix_ptr\");\n \n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n@@ -969,16 +958,16 @@ package body GNAT.OS_Lib is\n       end if;\n \n       return Result;\n-   end Get_Executable_Suffix;\n+   end Get_Object_Suffix;\n \n    ----------------------------------\n-   -- Get_Target_Executable_Suffix --\n+   -- Get_Target_Debuggable_Suffix --\n    ----------------------------------\n \n-   function Get_Target_Executable_Suffix return String_Access is\n+   function Get_Target_Debuggable_Suffix return String_Access is\n       Target_Exec_Ext_Ptr : Address;\n       pragma Import\n-        (C, Target_Exec_Ext_Ptr, \"__gnat_target_executable_extension\");\n+        (C, Target_Exec_Ext_Ptr, \"__gnat_target_debuggable_extension\");\n \n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n@@ -999,34 +988,37 @@ package body GNAT.OS_Lib is\n       end if;\n \n       return Result;\n-   end Get_Target_Executable_Suffix;\n+   end Get_Target_Debuggable_Suffix;\n \n-   -----------------------\n-   -- Get_Object_Suffix --\n-   -----------------------\n+   ----------------------------------\n+   -- Get_Target_Executable_Suffix --\n+   ----------------------------------\n \n-   function Get_Object_Suffix return String_Access is\n-      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n-      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_object_suffix_ptr\");\n+   function Get_Target_Executable_Suffix return String_Access is\n+      Target_Exec_Ext_Ptr : Address;\n+      pragma Import\n+        (C, Target_Exec_Ext_Ptr, \"__gnat_target_executable_extension\");\n \n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n \n-      Suffix_Ptr    : Address;\n+      function Strlen (Cstring : Address) return Integer;\n+      pragma Import (C, Strlen, \"strlen\");\n+\n       Suffix_Length : Integer;\n       Result        : String_Access;\n \n    begin\n-      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n+      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n \n       Result := new String (1 .. Suffix_Length);\n \n       if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n+         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);\n       end if;\n \n       return Result;\n-   end Get_Object_Suffix;\n+   end Get_Target_Executable_Suffix;\n \n    ------------------------------\n    -- Get_Target_Object_Suffix --\n@@ -1273,6 +1265,25 @@ package body GNAT.OS_Lib is\n       return Is_Directory (F_Name'Address);\n    end Is_Directory;\n \n+   ----------------------\n+   -- Is_Readable_File --\n+   ----------------------\n+\n+   function Is_Readable_File (Name : C_File_Name) return Boolean is\n+      function Is_Readable_File (Name : Address) return Integer;\n+      pragma Import (C, Is_Readable_File, \"__gnat_is_readable_file\");\n+   begin\n+      return Is_Readable_File (Name) /= 0;\n+   end Is_Readable_File;\n+\n+   function Is_Readable_File (Name : String) return Boolean is\n+      F_Name : String (1 .. Name'Length + 1);\n+   begin\n+      F_Name (1 .. Name'Length) := Name;\n+      F_Name (F_Name'Last)      := ASCII.NUL;\n+      return Is_Readable_File (F_Name'Address);\n+   end Is_Readable_File;\n+\n    ---------------------\n    -- Is_Regular_File --\n    ---------------------\n@@ -1293,23 +1304,23 @@ package body GNAT.OS_Lib is\n    end Is_Regular_File;\n \n    ----------------------\n-   -- Is_Readable_File --\n+   -- Is_Symbolic_Link --\n    ----------------------\n \n-   function Is_Readable_File (Name : C_File_Name) return Boolean is\n-      function Is_Readable_File (Name : Address) return Integer;\n-      pragma Import (C, Is_Readable_File, \"__gnat_is_readable_file\");\n+   function Is_Symbolic_Link (Name : C_File_Name) return Boolean is\n+      function Is_Symbolic_Link (Name : Address) return Integer;\n+      pragma Import (C, Is_Symbolic_Link, \"__gnat_is_symbolic_link\");\n    begin\n-      return Is_Readable_File (Name) /= 0;\n-   end Is_Readable_File;\n+      return Is_Symbolic_Link (Name) /= 0;\n+   end Is_Symbolic_Link;\n \n-   function Is_Readable_File (Name : String) return Boolean is\n+   function Is_Symbolic_Link (Name : String) return Boolean is\n       F_Name : String (1 .. Name'Length + 1);\n    begin\n       F_Name (1 .. Name'Length) := Name;\n       F_Name (F_Name'Last)      := ASCII.NUL;\n-      return Is_Readable_File (F_Name'Address);\n-   end Is_Readable_File;\n+      return Is_Symbolic_Link (F_Name'Address);\n+   end Is_Symbolic_Link;\n \n    ----------------------\n    -- Is_Writable_File --\n@@ -1330,25 +1341,6 @@ package body GNAT.OS_Lib is\n       return Is_Writable_File (F_Name'Address);\n    end Is_Writable_File;\n \n-   ----------------------\n-   -- Is_Symbolic_Link --\n-   ----------------------\n-\n-   function Is_Symbolic_Link (Name : C_File_Name) return Boolean is\n-      function Is_Symbolic_Link (Name : Address) return Integer;\n-      pragma Import (C, Is_Symbolic_Link, \"__gnat_is_symbolic_link\");\n-   begin\n-      return Is_Symbolic_Link (Name) /= 0;\n-   end Is_Symbolic_Link;\n-\n-   function Is_Symbolic_Link (Name : String) return Boolean is\n-      F_Name : String (1 .. Name'Length + 1);\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-      return Is_Symbolic_Link (F_Name'Address);\n-   end Is_Symbolic_Link;\n-\n    -------------------------\n    -- Locate_Exec_On_Path --\n    -------------------------\n@@ -1380,6 +1372,19 @@ package body GNAT.OS_Lib is\n       else\n          Result := To_Path_String_Access (Path_Addr, Path_Len);\n          Free (Path_Addr);\n+\n+         --  Always return an absolute path name\n+\n+         if not Is_Absolute_Path (Result.all) then\n+            declare\n+               Absolute_Path : constant String :=\n+                                 Normalize_Pathname (Result.all);\n+            begin\n+               Free (Result);\n+               Result := new String'(Absolute_Path);\n+            end;\n+         end if;\n+\n          return Result;\n       end if;\n    end Locate_Exec_On_Path;\n@@ -1422,6 +1427,7 @@ package body GNAT.OS_Lib is\n    is\n       C_File_Name : String (1 .. File_Name'Length + 1);\n       C_Path      : String (1 .. Path'Length + 1);\n+      Result      : String_Access;\n \n    begin\n       C_File_Name (1 .. File_Name'Length)   := File_Name;\n@@ -1430,7 +1436,20 @@ package body GNAT.OS_Lib is\n       C_Path    (1 .. Path'Length)          := Path;\n       C_Path    (C_Path'Last)               := ASCII.NUL;\n \n-      return Locate_Regular_File (C_File_Name'Address, C_Path'Address);\n+      Result := Locate_Regular_File (C_File_Name'Address, C_Path'Address);\n+\n+      --  Always return an absolute path name\n+\n+      if Result /= null and then not Is_Absolute_Path (Result.all) then\n+         declare\n+            Absolute_Path : constant String := Normalize_Pathname (Result.all);\n+         begin\n+            Free (Result);\n+            Result := new String'(Absolute_Path);\n+         end;\n+      end if;\n+\n+      return Result;\n    end Locate_Regular_File;\n \n    ------------------------\n@@ -1453,12 +1472,12 @@ package body GNAT.OS_Lib is\n      (Program_Name           : String;\n       Args                   : Argument_List;\n       Output_File_Descriptor : File_Descriptor;\n-      Err_To_Out             : Boolean := True)\n-      return                   Process_Id\n+      Err_To_Out             : Boolean := True) return Process_Id\n    is\n       Saved_Output : File_Descriptor;\n       Saved_Error  : File_Descriptor := Invalid_FD; -- prevent warning\n       Pid          : Process_Id;\n+\n    begin\n       if Output_File_Descriptor = Invalid_FD then\n          return Invalid_Pid;\n@@ -1645,9 +1664,6 @@ package body GNAT.OS_Lib is\n          Length : System.Address);\n       pragma Import (C, Get_Current_Dir, \"__gnat_get_current_dir\");\n \n-      function Change_Dir (Dir_Name : String) return Integer;\n-      pragma Import (C, Change_Dir, \"chdir\");\n-\n       Path_Buffer : String (1 .. Max_Path + Max_Path + 2);\n       End_Path    : Natural := 0;\n       Link_Buffer : String (1 .. Max_Path + 2);\n@@ -1688,69 +1704,17 @@ package body GNAT.OS_Lib is\n       function Strlen (S : System.Address) return Integer;\n       pragma Import (C, Strlen, \"strlen\");\n \n-      function Get_Directory  (Dir : String) return String;\n-      --  If Dir is not empty, return it, adding a directory separator\n-      --  if not already present, otherwise return current working directory\n-      --  with terminating directory separator.\n-\n       function Final_Value (S : String) return String;\n       --  Make final adjustment to the returned string.\n       --  To compensate for non standard path name in Interix,\n       --  if S is \"/x\" or starts with \"/x\", where x is a capital\n       --  letter 'A' to 'Z', add an additional '/' at the beginning\n       --  so that the returned value starts with \"//x\".\n \n-      -------------------\n-      -- Get_Directory --\n-      -------------------\n-\n-      function Get_Directory (Dir : String) return String is\n-      begin\n-         --  Directory given, add directory separator if needed\n-\n-         if Dir'Length > 0 then\n-            if Dir (Dir'Last) = Directory_Separator then\n-               return Directory;\n-            else\n-               declare\n-                  Result : String (1 .. Dir'Length + 1);\n-               begin\n-                  Result (1 .. Dir'Length) := Dir;\n-                  Result (Result'Length) := Directory_Separator;\n-                  return Result;\n-               end;\n-            end if;\n-\n-         --  Directory name not given, get current directory\n-\n-         else\n-            declare\n-               Buffer   : String (1 .. Max_Path + 2);\n-               Path_Len : Natural := Max_Path;\n-\n-            begin\n-               Get_Current_Dir (Buffer'Address, Path_Len'Address);\n-\n-               if Buffer (Path_Len) /= Directory_Separator then\n-                  Path_Len := Path_Len + 1;\n-                  Buffer (Path_Len) := Directory_Separator;\n-               end if;\n-\n-               --  By default, the drive letter on Windows is in upper case\n-\n-               if On_Windows and then Path_Len >= 2 and then\n-                 Buffer (2) = ':'\n-               then\n-                  System.Case_Util.To_Upper (Buffer (1 .. 1));\n-               end if;\n-\n-               return Buffer (1 .. Path_Len);\n-            end;\n-         end if;\n-      end Get_Directory;\n-\n-      Reference_Dir : constant String := Get_Directory (Directory);\n-      --  Current directory name specified\n+      function Get_Directory  (Dir : String) return String;\n+      --  If Dir is not empty, return it, adding a directory separator\n+      --  if not already present, otherwise return current working directory\n+      --  with terminating directory separator.\n \n       -----------------\n       -- Final_Value --\n@@ -1830,6 +1794,58 @@ package body GNAT.OS_Lib is\n          end if;\n       end Final_Value;\n \n+      -------------------\n+      -- Get_Directory --\n+      -------------------\n+\n+      function Get_Directory (Dir : String) return String is\n+      begin\n+         --  Directory given, add directory separator if needed\n+\n+         if Dir'Length > 0 then\n+            if Dir (Dir'Last) = Directory_Separator then\n+               return Directory;\n+            else\n+               declare\n+                  Result : String (1 .. Dir'Length + 1);\n+               begin\n+                  Result (1 .. Dir'Length) := Dir;\n+                  Result (Result'Length) := Directory_Separator;\n+                  return Result;\n+               end;\n+            end if;\n+\n+         --  Directory name not given, get current directory\n+\n+         else\n+            declare\n+               Buffer   : String (1 .. Max_Path + 2);\n+               Path_Len : Natural := Max_Path;\n+\n+            begin\n+               Get_Current_Dir (Buffer'Address, Path_Len'Address);\n+\n+               if Buffer (Path_Len) /= Directory_Separator then\n+                  Path_Len := Path_Len + 1;\n+                  Buffer (Path_Len) := Directory_Separator;\n+               end if;\n+\n+               --  By default, the drive letter on Windows is in upper case\n+\n+               if On_Windows and then Path_Len >= 2 and then\n+                 Buffer (2) = ':'\n+               then\n+                  System.Case_Util.To_Upper (Buffer (1 .. 1));\n+               end if;\n+\n+               return Buffer (1 .. Path_Len);\n+            end;\n+         end if;\n+      end Get_Directory;\n+\n+      Reference_Dir : constant String := Get_Directory (Directory);\n+      --  Current directory name specified\n+\n    --  Start of processing for Normalize_Pathname\n \n    begin\n@@ -1885,90 +1901,36 @@ package body GNAT.OS_Lib is\n          end loop;\n       end if;\n \n-      --  Resolve directory names for VMS and Windows\n+      --  Resolve directory names for Windows (formerly also VMS)\n \n       --  On VMS, if we have a Unix path such as /temp/..., and TEMP is a\n-      --  logical name, we need to resolve this logical name.\n+      --  logical name, we must not try to resolve this logical name, because\n+      --  it may have multiple equivalences and if resolved we will only\n+      --  get the first one.\n \n       --  On Windows, if we have an absolute path starting with a directory\n       --  separator, we need to have the drive letter appended in front.\n \n-      --  For both platforms, Get_Current_Dir will return a suitable\n-      --  directory name (logical names resolved on VMS, path starting with\n-      --  a drive letter on Windows). So we find the directory, change to it,\n-      --  call Get_Current_Dir and change the directory to the returned value.\n-      --  Then, of course, we return to the previous directory.\n+      --  On Windows, Get_Current_Dir will return a suitable directory\n+      --  name (path starting with a drive letter on Windows). So we take this\n+      --  drive letter and prepend it to the current path.\n \n-      if (OpenVMS or On_Windows)\n+      if On_Windows\n         and then Path_Buffer (1) = Directory_Separator\n+        and then Path_Buffer (2) /= Directory_Separator\n       then\n          declare\n             Cur_Dir : String := Get_Directory (\"\");\n-            --  Save the current directory, so that we can change dir back to\n-            --  it. It is not a constant, because the last character (a\n-            --  directory separator) is changed to ASCII.NUL to call the C\n-            --  function chdir.\n-\n-            Path : String := Path_Buffer (1 .. End_Path + 1);\n-            --  Copy of the current path. One character is added that may be\n-            --  set to ASCII.NUL to call chdir.\n-\n-            Pos : Positive := End_Path;\n-            --  Position of the last directory separator\n-\n-            Status : Integer;\n-            --  Value returned by chdir\n+            --  Get the current directory to get the drive letter\n \n          begin\n-            --  Look for the last directory separator\n-\n-            while Path (Pos) /= Directory_Separator loop\n-               Pos := Pos - 1;\n-            end loop;\n-\n-            --  Get the previous character that is not a directory separator\n-\n-            while Pos > 1 and then Path (Pos) = Directory_Separator loop\n-               Pos := Pos - 1;\n-            end loop;\n-\n-            --  If we are at the start of the path, take the full path.\n-            --  It may be a file in the root directory, but it may also be\n-            --  a subdirectory of the root directory.\n-\n-            if Pos = 1 then\n-               Pos := End_Path;\n-            end if;\n-\n-            --  Add the ASCII.NUL to be able to call the C function chdir\n-\n-            Path (Pos + 1) := ASCII.NUL;\n-\n-            Status := Change_Dir (Path (1 .. Pos + 1));\n-\n-            --  If Status is not zero, then we do nothing: this is a file\n-            --  path or it is not a valid directory path.\n-\n-            if Status = 0 then\n-               declare\n-                  New_Dir : constant String := Get_Directory (\"\");\n-                  --  The directory path\n-\n-                  New_Path : String (1 .. New_Dir'Length + End_Path - Pos);\n-                  --  The new complete path, that is built below\n-\n-               begin\n-                  New_Path (1 .. New_Dir'Length) := New_Dir;\n-                  New_Path (New_Dir'Length + 1 .. New_Path'Last) :=\n-                    Path_Buffer (Pos + 1 .. End_Path);\n-                  End_Path := New_Path'Length;\n-                  Path_Buffer (1 .. End_Path) := New_Path;\n-               end;\n-\n-               --  Back to where we were before\n-\n-               Cur_Dir (Cur_Dir'Last) := ASCII.NUL;\n-               Status := Change_Dir (Cur_Dir);\n+            if Cur_Dir'Length > 2\n+              and then Cur_Dir (Cur_Dir'First + 1) = ':'\n+            then\n+               Path_Buffer (3 .. End_Path + 2) := Path_Buffer (1 .. End_Path);\n+               Path_Buffer (1 .. 2) :=\n+                 Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);\n+               End_Path := End_Path + 2;\n             end if;\n          end;\n       end if;\n@@ -2205,6 +2167,15 @@ package body GNAT.OS_Lib is\n       return Open_Read_Write (C_Name (C_Name'First)'Address, Fmode);\n    end Open_Read_Write;\n \n+   --------------------\n+   -- Pid_To_Integer --\n+   --------------------\n+\n+   function Pid_To_Integer (Pid : Process_Id) return Integer is\n+   begin\n+      return Integer (Pid);\n+   end Pid_To_Integer;\n+\n    ----------\n    -- Read --\n    ----------"}, {"sha": "61a9eb7669dccade88810275dd5007a82035fd45", "filename": "gcc/ada/g-os_lib.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8967c38f74e68783fdbff9ad8759178d83eef637/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8967c38f74e68783fdbff9ad8759178d83eef637/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=8967c38f74e68783fdbff9ad8759178d83eef637", "patch": "@@ -198,7 +198,7 @@ package GNAT.OS_Lib is\n    --  for subsequent use in Write calls. File descriptor returned is\n    --  Invalid_FD if file cannot be successfully created.\n \n-   function Create_Output_Text_File (Name  : String) return File_Descriptor;\n+   function Create_Output_Text_File (Name : String) return File_Descriptor;\n    --  Creates new text file with given name suitable to redirect standard\n    --  output, returning file descriptor. File descriptor returned is\n    --  Invalid_FD if file cannot be successfully created.\n@@ -600,8 +600,7 @@ package GNAT.OS_Lib is\n \n    function Locate_Regular_File\n      (File_Name : C_File_Name;\n-      Path      : C_File_Name)\n-      return      String_Access;\n+      Path      : C_File_Name) return String_Access;\n \n    ------------------\n    -- Subprocesses --\n@@ -667,8 +666,7 @@ package GNAT.OS_Lib is\n \n    function Spawn\n      (Program_Name : String;\n-      Args         : Argument_List)\n-      return         Integer;\n+      Args         : Argument_List) return Integer;\n    --  Similar to the above procedure, but returns the actual status returned\n    --  by the operating system, or -1 under VxWorks and any other similar\n    --  operating systems which have no notion of separately spawnable programs.\n@@ -707,16 +705,19 @@ package GNAT.OS_Lib is\n \n    type Process_Id is private;\n    --  A private type used to identify a process activated by the following\n-   --  non-blocking call. The only meaningful operation on this type is a\n+   --  non-blocking calls. The only meaningful operation on this type is a\n    --  comparison for equality.\n \n    Invalid_Pid : constant Process_Id;\n    --  A special value used to indicate errors, as described below\n \n+   function Pid_To_Integer (Pid : Process_Id) return Integer;\n+   --  Convert a process id to an Integer. Useful for writing hash functions\n+   --  for type Process_Id or to compare two Process_Id (e.g. for sorting).\n+\n    function Non_Blocking_Spawn\n      (Program_Name : String;\n-      Args         : Argument_List)\n-      return         Process_Id;\n+      Args         : Argument_List) return Process_Id;\n    --  This is a non blocking call. The Process_Id of the spawned process is\n    --  returned. Parameters are to be used as in Spawn. If Invalid_Pid is\n    --  returned the program could not be spawned.\n@@ -745,8 +746,7 @@ package GNAT.OS_Lib is\n      (Program_Name : String;\n       Args         : Argument_List;\n       Output_File  : String;\n-      Err_To_Out   : Boolean := True)\n-      return         Process_Id;\n+      Err_To_Out   : Boolean := True) return Process_Id;\n    --  Similar to the procedure above, but saves the output of the command to\n    --  a file with the name Output_File.\n    --"}]}