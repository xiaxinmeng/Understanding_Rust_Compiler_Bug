{"sha": "43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlNmI3N2NiYmViYTM2YjFkMTViZjM2OGFlYjJlODZkOGZlYzI2ZQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2006-07-13T21:13:12Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2006-07-13T21:13:12Z"}, "message": "interpret.cc (_Jv_InterpMethod::compile): Add FIXME comment.\n\n2006-07-13  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* interpret.cc (_Jv_InterpMethod::compile): Add FIXME comment.\n\t(_Jv_InterpMethod::run): SAVE_PC before executing any instruction \n\tusing resolve_pool_entry, as it can throw. Likewise for div/rem ops\n\tthat can throw ArithmeticException.\n\nFrom-SVN: r115422", "tree": {"sha": "7e4d0d1103a8313846e31f044ccc494ab60d822d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e4d0d1103a8313846e31f044ccc494ab60d822d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e/comments", "author": null, "committer": null, "parents": [{"sha": "88d03811f89e6e0b1f63bdc7f61d9380645b1adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88d03811f89e6e0b1f63bdc7f61d9380645b1adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88d03811f89e6e0b1f63bdc7f61d9380645b1adf"}], "stats": {"total": 34, "additions": 29, "deletions": 5}, "files": [{"sha": "6452a729d88f6d8bbd3f55fc5ab1cbfaf0ff4371", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e", "patch": "@@ -1,3 +1,10 @@\n+2006-07-13  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* interpret.cc (_Jv_InterpMethod::compile): Add FIXME comment.\n+\t(_Jv_InterpMethod::run): SAVE_PC before executing any instruction \n+\tusing resolve_pool_entry, as it can throw. Likewise for div/rem ops\n+\tthat can throw ArithmeticException.\n+\n 2006-07-12  Gary Benson  <gbenson@redhat.com>\n \n \t* java/io/File.java (renameTo): Fix security checks."}, {"sha": "b9abb01a8735da06af57cf37888ae9585128a75a", "filename": "libjava/interpret.cc", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=43e6b77cbbeba36b1d15bf368aeb2e86d8fec26e", "patch": "@@ -776,6 +776,8 @@ _Jv_InterpMethod::compile (const void * const *insn_targets)\n       exc[i].start_pc.p = &insns[pc_mapping[exc[i].start_pc.i]];\n       exc[i].end_pc.p = &insns[pc_mapping[exc[i].end_pc.i]];\n       exc[i].handler_pc.p = &insns[pc_mapping[exc[i].handler_pc.i]];\n+      // FIXME: resolve_pool_entry can throw - we shouldn't be doing this\n+      // during compilation.\n       jclass handler\n \t= (_Jv_Linker::resolve_pool_entry (defining_class,\n \t\t\t\t\t     exc[i].handler_type.i)).clazz;\n@@ -1139,6 +1141,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_invokevirtual:\t// 0xb6\n       {\n+\tSAVE_PC();\n \tint index = GET2U ();\n \n \t/* _Jv_Linker::resolve_pool_entry returns immediately if the\n@@ -1155,7 +1158,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \tif (rmeth->method->accflags & Modifier::FINAL)\n \t  {\n \t    // We can't rely on NULLCHECK working if the method is final.\n-\t    SAVE_PC();\n \t    if (! sp[0].o)\n \t      throw_null_pointer_exception ();\n \n@@ -1182,13 +1184,13 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n #ifdef DIRECT_THREADED\n     invokevirtual_resolved:\n       {\n+\tSAVE_PC();\n \trmeth = (_Jv_ResolvedMethod *) AVAL ();\n \tsp -= rmeth->stack_item_count;\n \n \tif (rmeth->method->accflags & Modifier::FINAL)\n \t  {\n \t    // We can't rely on NULLCHECK working if the method is final.\n-\t    SAVE_PC();\n \t    if (! sp[0].o)\n \t      throw_null_pointer_exception ();\n \n@@ -1207,8 +1209,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     perform_invoke:\n       {\n-        SAVE_PC();\n-\t\n \t/* here goes the magic again... */\n \tffi_cif *cif = &rmeth->cif;\n \tffi_raw *raw = (ffi_raw*) sp;\n@@ -1358,6 +1358,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n       // For direct threaded we have a separate 'ldc class' operation.\n     insn_ldc_class:\n       {\n+\tSAVE_PC();\n \t// We could rewrite the instruction at this point.\n \tint index = INTVAL ();\n \tjobject k = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n@@ -1826,6 +1827,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_idiv:\n       {\n+\tSAVE_PC();\n \tjint value2 = POPI();\n \tjint value1 = POPI();\n \tjint res = _Jv_divI (value1, value2);\n@@ -1835,6 +1837,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_ldiv:\n       {\n+\tSAVE_PC();\n \tjlong value2 = POPL();\n \tjlong value1 = POPL();\n \tjlong res = _Jv_divJ (value1, value2);\n@@ -1844,6 +1847,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_fdiv:\n       {\n+\tSAVE_PC();\n \tjfloat value2 = POPF();\n \tjfloat value1 = POPF();\n \tjfloat res = value1 / value2;\n@@ -1862,6 +1866,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_irem:\n       {\n+\tSAVE_PC();\n \tjint value2 = POPI();\n \tjint value1 =  POPI();\n \tjint res = _Jv_remI (value1, value2);\n@@ -1871,6 +1876,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_lrem:\n       {\n+\tSAVE_PC();\n \tjlong value2 = POPL();\n \tjlong value1 = POPL();\n \tjlong res = _Jv_remJ (value1, value2);\n@@ -2539,6 +2545,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_getfield:\n       {\n+\tSAVE_PC();\n \tjint fieldref_index = GET2U ();\n \t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n@@ -2653,6 +2660,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_putstatic:\n       {\n+\tSAVE_PC();\n \tjint fieldref_index = GET2U ();\n \t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n@@ -2740,6 +2748,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_putfield:\n       {\n+\tSAVE_PC();\n \tjint fieldref_index = GET2U ();\n \t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n@@ -2863,6 +2872,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_invokespecial:\n       {\n+\tSAVE_PC();\n \tint index = GET2U ();\n \n \trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n@@ -2892,13 +2902,13 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n #ifdef DIRECT_THREADED\n     invokespecial_resolved:\n       {\n+\tSAVE_PC();\n \trmeth = (_Jv_ResolvedMethod *) AVAL ();\n \tsp -= rmeth->stack_item_count;\n \t// We don't use NULLCHECK here because we can't rely on that\n \t// working for <init>.  So instead we do an explicit test.\n \tif (! sp[0].o)\n \t  {\n-\t    SAVE_PC();\n \t    throw_null_pointer_exception ();\n \t  }\n \tfun = (void (*)()) rmeth->method->ncode;\n@@ -2908,6 +2918,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_invokestatic:\n       {\n+\tSAVE_PC();\n \tint index = GET2U ();\n \n \trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n@@ -2929,6 +2940,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n #ifdef DIRECT_THREADED\n     invokestatic_resolved:\n       {\n+\tSAVE_PC();\n \trmeth = (_Jv_ResolvedMethod *) AVAL ();\n \tsp -= rmeth->stack_item_count;\n \tfun = (void (*)()) rmeth->method->ncode;\n@@ -2938,6 +2950,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_invokeinterface:\n       {\n+\tSAVE_PC();\n \tint index = GET2U ();\n \n \trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n@@ -2969,6 +2982,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n #ifdef DIRECT_THREADED\n     invokeinterface_resolved:\n       {\n+\tSAVE_PC();\n \trmeth = (_Jv_ResolvedMethod *) AVAL ();\n \tsp -= rmeth->stack_item_count;\n \tjobject rcv = sp[0].o;\n@@ -2983,6 +2997,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_new:\n       {\n+\tSAVE_PC();\n \tint index = GET2U ();\n \tjclass klass = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t\t  index)).clazz;\n@@ -3021,6 +3036,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_anewarray:\n       {\n+\tSAVE_PC();\n \tint index = GET2U ();\n \tjclass klass = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t\t  index)).clazz;\n@@ -3156,6 +3172,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n     insn_multianewarray:\n       {\n+\tSAVE_PC();\n \tint kind_index = GET2U ();\n \tint dim        = GET1U ();\n "}]}