{"sha": "d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRkMWViYzE5MWU1YzFkMDAyNjZkOWMwMjA3YzVkZGU2OWY1ZTIxNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-10-20T21:46:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-10-20T21:46:55Z"}, "message": "toplev.c (rest_of_compilation): Fix webizer pass ordering.\n\n\n\t* toplev.c (rest_of_compilation): Fix webizer pass ordering.\n\n\t* cgraphunit.c (decide_is_function_needed):  Fix test dealing\n\twith functions implicitly made inline.\n\n\t* cgraphunit.c (cgraph_decide_inlining_incrementally):  New function.\n\t(cgraph_finalize_function): Use it.\n\t(cgraph_mark_inline): Allow incrmental decisions\n\t* invoke.texi (max-inline-slope, min-inline-insns): Kill.\n\t* params.def (PARAM_MAX_INLINE_SLOPE, PARAM_MIN_INLINE_INSNS): Kill.\n\t* tree-inline.c (limits_allow_inlining): Kill.\n\t(expand_call_inline): Always use unit-at-a-time path.\n\n\t* decl.c (start_cleanup_fn):  Set DECL_DECLARED_INLINE_P to deffer\n\tthe expansion.\n\n\t* testsuite/g++.dg/opt/inline4.C: Do not use min-inline-insns\n\tparameter.\n\t* testsuite/gcc.dg/inline-2.c: Likewise.\n\nFrom-SVN: r72721", "tree": {"sha": "e0577f027de65a595f0d08d2ce877c7af9b5a347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0577f027de65a595f0d08d2ce877c7af9b5a347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/comments", "author": null, "committer": null, "parents": [{"sha": "ce01559bb70b9d2af4bb3e91866167440c5a66f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce01559bb70b9d2af4bb3e91866167440c5a66f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce01559bb70b9d2af4bb3e91866167440c5a66f8"}], "stats": {"total": 258, "additions": 103, "deletions": 155}, "files": [{"sha": "2d59559816af17d1f598feedb7a5656554d4ff6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -1,3 +1,18 @@\n+2003-10-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* toplev.c (rest_of_compilation): Fix webizer pass ordering.\n+\n+\t* cgraphunit.c (decide_is_function_needed):  Fix test dealing\n+\twith functions implicitly made inline.\n+\n+\t* cgraphunit.c (cgraph_decide_inlining_incrementally):  New function.\n+\t(cgraph_finalize_function): Use it.\n+\t(cgraph_mark_inline): Allow incrmental decisions\n+\t* invoke.texi (max-inline-slope, min-inline-insns): Kill.\n+\t* params.def (PARAM_MAX_INLINE_SLOPE, PARAM_MIN_INLINE_INSNS): Kill.\n+\t* tree-inline.c (limits_allow_inlining): Kill.\n+\t(expand_call_inline): Always use unit-at-a-time path.\n+\n 2003-10-20  Zack Weinberg  <zack@codesourcery.com>\n \n \t* fixinc/inclhack.def (hpux11_snprintf): New edit."}, {"sha": "c20367d1d00aba3139a959586f1697b7874c184f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -49,6 +49,7 @@ static void cgraph_mark_local_functions (void);\n static void cgraph_optimize_function (struct cgraph_node *);\n static bool cgraph_default_inline_p (struct cgraph_node *n);\n static void cgraph_analyze_function (struct cgraph_node *node);\n+static void cgraph_decide_inlining_incrementally (struct cgraph_node *);\n \n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n@@ -114,7 +115,7 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n \t  /* When declared inline, defer even the uninlinable functions.\n \t     This allows them to be eliminated when unused.  */\n \t  && !DECL_DECLARED_INLINE_P (decl) \n-\t  && (node->local.inlinable || !cgraph_default_inline_p (node))))\n+\t  && (!node->local.inlinable || !cgraph_default_inline_p (node))))\n     return true;\n \n   return false;\n@@ -206,7 +207,10 @@ cgraph_finalize_function (tree decl, bool nested)\n   /* If not unit at a time, then we need to create the call graph\n      now, so that called functions can be queued and emitted now.  */\n   if (!flag_unit_at_a_time)\n-    cgraph_analyze_function (node);\n+    {\n+      cgraph_analyze_function (node);\n+      cgraph_decide_inlining_incrementally (node);\n+    }\n \n   if (decide_is_function_needed (node, decl))\n     cgraph_mark_needed_node (node);\n@@ -852,6 +856,7 @@ cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n   to->global.insns = new_insns;\n \n   if (!called && !what->needed && !what->origin\n+      && flag_unit_at_a_time\n       && !DECL_EXTERNAL (what->decl))\n     {\n       if (!what->global.will_be_output)\n@@ -1221,6 +1226,59 @@ cgraph_decide_inlining (void)\n   free (inlined_callees);\n }\n \n+/* Decide on the inlining.  We do so in the topological order to avoid\n+   expenses on updating datastructures.  */\n+\n+static void\n+cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  struct cgraph_node **inlined =\n+    xmalloc (sizeof (struct cgraph_node *) * cgraph_n_nodes);\n+  struct cgraph_node **inlined_callees =\n+    xmalloc (sizeof (struct cgraph_node *) * cgraph_n_nodes);\n+  int ninlined;\n+  int ninlined_callees;\n+  int y;\n+\n+  ninlined = cgraph_inlined_into (node, inlined);\n+\n+  /* First of all look for always inline functions.  */\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->callee->local.disregard_inline_limits && !e->callee->output\n+\t&& e->callee != node && !e->inline_call)\n+      {\n+\tninlined_callees = cgraph_inlined_callees (e->callee, inlined_callees);\n+\tcgraph_mark_inline (node, e->callee, inlined, ninlined,\n+\t\t\t    inlined_callees, ninlined_callees);\n+\tfor (y = 0; y < ninlined_callees; y++)\n+\t  inlined_callees[y]->output = 0, node->aux = 0;\n+      }\n+\n+  /* Now do the automatic inlining.  */\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->callee->local.inlinable && !e->callee->output\n+\t&& e->callee != node && !e->inline_call\n+        && cgraph_default_inline_p (e->callee)\n+\t&& cgraph_check_inline_limits (node, e->callee, inlined,\n+\t\t\t\t       ninlined))\n+      {\n+\tninlined_callees = cgraph_inlined_callees (e->callee, inlined_callees);\n+\tcgraph_mark_inline (node, e->callee, inlined, ninlined,\n+\t\t\t    inlined_callees, ninlined_callees);\n+\tfor (y = 0; y < ninlined_callees; y++)\n+\t  inlined_callees[y]->output = 0, node->aux = 0;\n+      }\n+\n+  /* Clear the flags set by cgraph_inlined_into.  */\n+  for (y = 0; y < ninlined; y++)\n+    inlined[y]->output = 0, node->aux = 0;\n+\n+  free (inlined);\n+  free (inlined_callees);\n+}\n+\n+\n /* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */\n \n bool"}, {"sha": "835480d3a47c98193a0dfbd858cba3306369e2f1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -16045,7 +16045,7 @@\n \t\t   (unspec:SF [(match_dup 2)\n \t\t\t       (match_operand:SF 1 \"register_operand\" \"\")]\n \t\t    UNSPEC_FPATAN))\n-\t      (clobber (match_dup 1))])]\n+\t      (clobber (match_scratch:SF 3 \"\"))])]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\n    && flag_unsafe_math_optimizations\"\n {"}, {"sha": "9756bbaafa8fb99f7bfca0c4cdae9352792d1f7e", "filename": "gcc/coverage.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n extern void coverage_init (const char *);\n extern void coverage_finish (void);\n+extern void coverage_read_counts_file (void);\n \n /* Complete the coverage information for the current function. Once\n    per function.  */"}, {"sha": "c2cb189b8b240324a52fbda5af57921f6816b08d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -1,3 +1,8 @@\n+2003-10-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl.c (start_cleanup_fn):  Set DECL_DECLARED_INLINE_P to deffer\n+\tthe expansion.\n+\n 2003-10-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Make-lang.in (c++.install-info): Remove."}, {"sha": "0f1170c842e474a7c1bc6268eea8eba4b929794c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -5073,6 +5073,8 @@ start_cleanup_fn (void)\n      it is only called via a function pointer, but we avoid unnecessary\n      emissions this way.  */\n   DECL_INLINE (fndecl) = 1;\n+  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+  DECL_INTERFACE_KNOWN (fndecl) = 1;\n   /* Build the parameter.  */\n   if (flag_use_cxa_atexit)\n     {"}, {"sha": "52bdd6d13621af98d3155f0c09252940254b02a6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -4784,22 +4784,6 @@ larger binaries.  Very high values are not advisable, as too large\n binaries may adversely affect runtime performance.\n The default value is 200.\n \n-@item max-inline-slope\n-After exceeding the maximum number of inlined instructions by repeated\n-inlining, a linear function is used to decrease the allowable size\n-for single functions.  The slope of that function is the negative\n-reciprocal of the number specified here.\n-This parameter is ignored when @option{-funit-at-a-time} is used.\n-The default value is 32.\n-\n-@item min-inline-insns\n-The repeated inlining is throttled more and more by the linear function\n-after exceeding the limit.  To avoid too much throttling, a minimum for\n-this function is specified here to allow repeated inlining for very small\n-functions even when a lot of repeated inlining already has been done.\n-This parameter is ignored when @option{-funit-at-a-time} is used.\n-The default value is 10.\n-\n @item large-function-insns\n The limit specifying really large functions.  For functions greater than this\n limit inlining is constrained by @option{--param large-function-growth}."}, {"sha": "c2b2fad8f17019e769c113a110aa6d56fd75b000", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -719,6 +719,10 @@ extern int flag_unit_at_a_time;\n \n extern int flag_web;\n \n+/* Nonzero means that we defer emitting functions until they are actually\n+   used.  */\n+extern int flag_remove_unreachable_functions;\n+\n /* A string that's used when a random name is required.  NULL means\n    to make it really random.  */\n "}, {"sha": "dafd37104b42bf7e09c84735e210b4f9a29cbe38", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -1061,13 +1061,6 @@ common_handle_option (size_t scode, const char *arg,\n       set_param_value (\"max-inline-insns-single\", value / 2);\n       set_param_value (\"max-inline-insns-auto\", value / 2);\n       set_param_value (\"max-inline-insns-rtl\", value);\n-      if (value / 4 < MIN_INLINE_INSNS)\n-\t{\n-\t  if (value / 4 > 10)\n-\t    set_param_value (\"min-inline-insns\", value / 4);\n-\t  else\n-\t    set_param_value (\"min-inline-insns\", 10);\n-\t}\n       break;\n \n     case OPT_finstrument_functions:"}, {"sha": "b08603b1f29f57428da968d0c813bfe029f31372", "filename": "gcc/params.def", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -84,32 +84,6 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS,\n \t  \"The maximum number of instructions by repeated inlining before gcc starts to throttle inlining\",\n \t  200)\n \n-/* After the repeated inline limit has been exceeded (see\n-   \"max-inline-insns\" parameter), a linear function is used to\n-   decrease the size of single functions eligible for inlining.\n-   The slope of this linear function is given the negative\n-   reciprocal value (-1/x) of this parameter. \n-   The default value is 32.\n-   This linear function is used until it falls below a minimum\n-   value specified by the \"min-inline-insns\" parameter.  */\n-DEFPARAM (PARAM_MAX_INLINE_SLOPE,\n-\t  \"max-inline-slope\",\n-\t  \"The slope of the linear function throttling inlining after the recursive inlining limit has been reached is given by the negative reciprocal value of this parameter\",\n-\t  32)\n-\n-/* When gcc has inlined so many instructions (by repeated\n-   inlining) that the throttling limits the inlining very much,\n-   inlining for very small functions is still desirable to\n-   achieve good runtime performance.  The size of single functions \n-   (measured in gcc instructions) which will still be eligible for \n-   inlining then is given by this parameter.  It defaults to 130.\n-   Only much later (after exceeding 128 times the recursive limit)\n-   inlining is cut down completely.  */\n-DEFPARAM (PARAM_MIN_INLINE_INSNS,\n-\t  \"min-inline-insns\",\n-\t  \"The number of instructions in a single functions still eligible to inlining after a lot recursive inlining\",\n-\t  10)\n-\n /* For languages that (still) use the RTL inliner, we can specify\n    limits for the RTL inliner separately.\n    The parameter here defines the maximum number of RTL instructions"}, {"sha": "20bac3351bd8b665091d95d911bf71ab680a471b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -1,3 +1,9 @@\n+2003-10-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* testsuite/g++.dg/opt/inline4.C: Do not use min-inline-insns\n+\tparameter.\n+\t* testsuite/gcc.dg/inline-2.c: Likewise.\n+\n 2003-10-20  Phil Edwards  <phil@codesourcery.com>\n \n \t* gcc.dg/20021014-1.c:  XFAIL for *-*-windiss targets."}, {"sha": "1db4fe1860bd4fb8e2c94c6b905d701d573eaefa", "filename": "gcc/testsuite/g++.dg/opt/inline4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finline4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finline4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Finline4.C?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -1,4 +1,4 @@\n-// { dg-options \"-O2 -ftemplate-depth-20000 --param min-inline-insns=100 --param max-inline-insns=3\" }\n+// { dg-options \"-O2 -ftemplate-depth-20000\" }\n \n template <int I>\n inline void g() { g<I-1>(); return; }"}, {"sha": "80e7848aca2c2ea592ea762b150c5dedf29aaf59", "filename": "gcc/testsuite/gcc.dg/inline-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftestsuite%2Fgcc.dg%2Finline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftestsuite%2Fgcc.dg%2Finline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finline-2.c?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -11,7 +11,8 @@ static int foo(void)\n \n int bar(void)\n {\n-  return foo() + 1;\n+  /* Call twice to avoid bypassing the limit for functions called once.  */\n+  return foo() + foo() + 1;\n }\n \n /* { dg-final { scan-assembler-not \"jsr\" { target alpha*-*-* } } } */"}, {"sha": "a393c52003e8803aaaf0b7d8d617835e0855c84d", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -3364,9 +3364,6 @@ rest_of_compilation (tree decl)\n \n   rest_of_handle_cfg (decl, insns);\n \n-  if (flag_web)\n-    rest_of_handle_web (decl, insns);\n-\n   if (optimize > 0\n       || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n@@ -3394,6 +3391,9 @@ rest_of_compilation (tree decl)\n \t  || flag_unroll_loops))\n     rest_of_handle_loop2 (decl, insns);\n \n+  if (flag_web)\n+    rest_of_handle_web (decl, insns);\n+\n   if (flag_rerun_cse_after_loop)\n     rest_of_handle_cse2 (decl, insns);\n "}, {"sha": "b827dfc1c29190d5a37e2f007ecd924ba2d3da47", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 98, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d1ebc191e5c1d00266d9c0207c5dde69f5e216/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d4d1ebc191e5c1d00266d9c0207c5dde69f5e216", "patch": "@@ -119,7 +119,6 @@ static tree copy_body (inline_data *);\n static tree expand_call_inline (tree *, int *, void *);\n static void expand_calls_inline (tree *, inline_data *);\n static bool inlinable_function_p (tree);\n-static int limits_allow_inlining (tree, inline_data *);\n static tree remap_decl (tree, inline_data *);\n static tree remap_type (tree, inline_data *);\n #ifndef INLINER_FOR_JAVA\n@@ -1219,97 +1218,6 @@ inlinable_function_p (tree fn)\n   return inlinable;\n }\n \n-/* We can't inline functions that are too big.  Only allow a single\n-   function to be of MAX_INLINE_INSNS_SINGLE size.  Make special\n-   allowance for extern inline functions, though.\n-\n-   Return nonzero if the function FN can be inlined into the inlining\n-   context ID.  */\n-\n-static int\n-limits_allow_inlining (tree fn, inline_data *id)\n-{\n-  int estimated_insns = 0;\n-  size_t i;\n-\n-  /* Don't even bother if the function is not inlinable.  */\n-  if (!inlinable_function_p (fn))\n-    return 0;\n-\n-  /* Investigate the size of the function.  Return at once\n-     if the function body size is too large.  */\n-  if (!(*lang_hooks.tree_inlining.disregard_inline_limits) (fn))\n-    {\n-      int currfn_max_inline_insns;\n-\n-      /* If we haven't already done so, get an estimate of the number of\n-\t instructions that will be produces when expanding this function.  */\n-      if (!DECL_ESTIMATED_INSNS (fn))\n-\tDECL_ESTIMATED_INSNS (fn)\n-\t  = (*lang_hooks.tree_inlining.estimate_num_insns) (fn);\n-      estimated_insns = DECL_ESTIMATED_INSNS (fn);\n-\n-      /* We may be here either because fn is declared inline or because\n-\t we use -finline-functions.  For the second case, we are more\n-\t restrictive.\n-\n-\t FIXME: -finline-functions should imply -funit-at-a-time, it's\n-\t\tabout equally expensive but unit-at-a-time produces\n-\t\tbetter code.  */\n-      currfn_max_inline_insns = DECL_DECLARED_INLINE_P (fn) ?\n-\t\tMAX_INLINE_INSNS_SINGLE : MAX_INLINE_INSNS_AUTO;\n-\n-      /* If the function is too big to be inlined, adieu.  */\n-      if (estimated_insns > currfn_max_inline_insns)\n-\treturn 0;\n-\n-      /* We now know that we don't disregard the inlining limits and that \n-\t we basically should be able to inline this function.\n-\t We always allow inlining functions if we estimate that they are\n-\t smaller than MIN_INLINE_INSNS.  Otherwise, investigate further.  */\n-      if (estimated_insns > MIN_INLINE_INSNS)\n-\t{\n-\t  int sum_insns = (id ? id->inlined_insns : 0) + estimated_insns;\n-\n-\t  /* In the extreme case that we have exceeded the recursive inlining\n-\t     limit by a huge factor (128), we just say no.\n-\n-\t     FIXME:  Should not happen in real life, but people have reported\n-\t\t     that it actually does!?  */\n-\t  if (sum_insns > MAX_INLINE_INSNS * 128)\n-\t    return 0;\n-\n-\t  /* If we did not hit the extreme limit, we use a linear function\n-\t     with slope -1/MAX_INLINE_SLOPE to exceedingly decrease the\n-\t     allowable size.  */\n-\t  else if (sum_insns > MAX_INLINE_INSNS)\n-\t    {\n-\t      if (estimated_insns > currfn_max_inline_insns\n-\t\t\t- (sum_insns - MAX_INLINE_INSNS) / MAX_INLINE_SLOPE)\n-\t        return 0;\n-\t    }\n-\t}\n-    }\n-\n-  /* Don't allow recursive inlining.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (id->fns); ++i)\n-    if (VARRAY_TREE (id->fns, i) == fn)\n-      return 0;\n-\n-  if (DECL_INLINED_FNS (fn))\n-    {\n-      int j;\n-      tree inlined_fns = DECL_INLINED_FNS (fn);\n-\n-      for (j = 0; j < TREE_VEC_LENGTH (inlined_fns); ++j)\n-\tif (TREE_VEC_ELT (inlined_fns, j) == VARRAY_TREE (id->fns, 0))\n-\t  return 0;\n-    }\n-\n-  /* Go ahead, this function can be inlined.  */\n-  return 1;\n-}\n-\n /* If *TP is a CALL_EXPR, replace it with its inline expansion.  */\n \n static tree\n@@ -1396,8 +1304,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n     return NULL_TREE;\n \n   /* Turn forward declarations into real ones.  */\n-  if (flag_unit_at_a_time)\n-    fn = cgraph_node (fn)->decl;\n+  fn = cgraph_node (fn)->decl;\n \n   /* If fn is a declaration of a function in a nested scope that was\n      globally declared inline, we don't set its DECL_INITIAL.\n@@ -1413,9 +1320,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n-  if ((flag_unit_at_a_time\n-       && (!DECL_SAVED_TREE (fn) || !cgraph_inline_p (id->current_decl, fn)))\n-      || (!flag_unit_at_a_time && !limits_allow_inlining (fn, id)))\n+  if (!DECL_SAVED_TREE (fn) || !cgraph_inline_p (id->current_decl, fn))\n     {\n       if (warn_inline && DECL_INLINE (fn) && DECL_DECLARED_INLINE_P (fn)\n \t  && !DECL_IN_SYSTEM_HEADER (fn))\n@@ -1653,7 +1558,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   id->inlined_insns += DECL_ESTIMATED_INSNS (fn) - 1;\n \n   /* Update callgraph if needed.  */\n-  if (id->decl && flag_unit_at_a_time)\n+  if (id->decl)\n     {\n       cgraph_remove_call (id->decl, fn);\n       cgraph_create_edges (id->decl, *inlined_body);"}]}