{"sha": "9e18f575557d94acced039000fa26958e75f69e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUxOGY1NzU1NTdkOTRhY2NlZDAzOTAwMGZhMjY5NThlNzVmNjllNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-05T07:34:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-05T07:34:13Z"}, "message": "lib2funcs.asm (__outline_prologue): New \"function\".\n\n        * lib2funcs.asm (__outline_prologue): New \"function\".\n        (__outline_epilogue): New \"function\".\n        * pa.h (TARGET_SPACE): Define.\n        (target_flags): Add -mspace and -mno-space.  Enable/disable\n        space saving optimizations.\n        (FRAME_POINTER_REQUIRED): Frame pointers are always required\n        when generating out of line prologues and epilogues.\n        * pa.c (compute_frame_size): Handle out of line prologues/epilogues.\n        (hppa_expand_prologue): If optimizing for space, emit an out of\n        line prologue.\n        * pa.c (compute_frame_size): Handle out of line prologues/epilogues.\n        (hppa_expand_prologue): If optimizing for space, emit an out of\n        line prologue.\n        (hppa_expand_epilogue): Similarly.\n        (override_options): Optimizing for space is not compatable with\n        either profiling or PIC code generation.\n        * pa.md (outline_prologue_call): New pattern.\n        (outline_epilogue_call): Likewise.\n\nFrom-SVN: r11438", "tree": {"sha": "fd229de8711cd62458a579be3ecc2a9f5d046fec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd229de8711cd62458a579be3ecc2a9f5d046fec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e18f575557d94acced039000fa26958e75f69e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e18f575557d94acced039000fa26958e75f69e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e18f575557d94acced039000fa26958e75f69e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e18f575557d94acced039000fa26958e75f69e6/comments", "author": null, "committer": null, "parents": [{"sha": "9ad2334b60dab68c60b33bb2c87b9590c6a4002a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad2334b60dab68c60b33bb2c87b9590c6a4002a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ad2334b60dab68c60b33bb2c87b9590c6a4002a"}], "stats": {"total": 442, "additions": 436, "deletions": 6}, "files": [{"sha": "d6f5cbc1d9da6485b37c63a3fb7b7f5e55425d8c", "filename": "gcc/config/pa/lib2funcs.asm", "status": "modified", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Flib2funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Flib2funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flib2funcs.asm?ref=9e18f575557d94acced039000fa26958e75f69e6", "patch": "@@ -24,6 +24,8 @@\n \t.SPACE $TEXT$\n \t.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44\n \t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.SUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,SORT=8\n+\n \t.IMPORT $$dyncall,MILLICODE\n ; gcc_compiled.:\n \t.SPACE $TEXT$\n@@ -61,3 +63,251 @@ L$foo\n \tbe,n 0(%sr0,%rp)\n \t.EXIT\n \t.PROCEND\n+\n+\t.SPACE $TEXT$\n+\t.SUBSPA $MILLICODE$\n+\n+; This is an out-of-line prologue.\n+;\n+; It performs the following operations:\n+;\n+;\t* Saves the return pointer at sp - 20\n+;\n+;\t* Creates a new stack frame (sp'), size of the frame is passed in %r21\n+;\n+;\t* The old stack pointer is saved at sp\n+;\n+;\t* Saves grs (passed in low 16 bits of %r22 into the stack frame\n+;\tat sp' + local_fsize (passed in %r19).\n+;\n+;\t* Saves frs (passed in high 16 bits of %r22) into the stack\n+;\tframe at sp' + local_fsize (passed in %r19).\n+;\n+;\t* Sets up a frame pointer (in %r3).\n+;\n+;\t* Returns to the instruction _immediately_ after the call to\n+;\tthis function.\n+\n+\t.align 32\n+\t.NSUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.EXPORT __outline_prologue,MILLICODE\n+__outline_prologue\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\tcopy %r30,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Save off %r2\n+\tstw %r2,-20(0,%r30)\n+\n+\t; Make our new frame.\n+\tadd %r21,%r30,%r30\n+\n+\t; Save our old stack pointer.\n+\tstw %r20,0(0,%r20)\n+\n+\t; Add in local_fsize to our frame pointer so we do register\n+\t; saves into the right place\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to save.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to save.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr saves.\n+\tcomb,= %r0,%r1,L$0000\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0000\n+\tstws,ma %r18,4(0,%r20)\n+\tnop\n+\tstws,ma %r17,4(0,%r20)\n+\tnop\n+\tstws,ma %r16,4(0,%r20)\n+\tnop\n+\tstws,ma %r15,4(0,%r20)\n+\tnop\n+\tstws,ma %r14,4(0,%r20)\n+\tnop\n+\tstws,ma %r13,4(0,%r20)\n+\tnop\n+\tstws,ma %r12,4(0,%r20)\n+\tnop\n+\tstws,ma %r11,4(0,%r20)\n+\tnop\n+\tstws,ma %r10,4(0,%r20)\n+\tnop\n+\tstws,ma %r9,4(0,%r20)\n+\tnop\n+\tstws,ma %r8,4(0,%r20)\n+\tnop\n+\tstws,ma %r7,4(0,%r20)\n+\tnop\n+\tstws,ma %r6,4(0,%r20)\n+\tnop\n+\tstws,ma %r5,4(0,%r20)\n+\tnop\n+\tstws,ma %r4,4(0,%r20)\n+\tnop\n+\tstws,ma %r3,4(0,%r20)\n+\tnop\n+L$0000\n+\t; All gr saves are done.  Align the temporary frame pointer and\n+\t; do the fr saves.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0001\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0001\n+\tfstws,ma %fr21,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr20,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr19,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr18,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr17,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr16,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr15,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr14,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr13,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr12,8(0,%r20)\n+\tnop\n+L$0001\n+\t; Return, setting up a frame pointer in the delay slot\n+\tbv 0(%r31)\n+\tsub %r30,%r21,%r3\n+\n+\t.EXIT\n+\t.PROCEND\n+\n+; This is an out-of-line epilogue.  It's operation is basically the reverse\n+; of the out-of-line prologue.\n+\n+\t.align 32\n+\t.NSUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.EXPORT __outline_epilogue,MILLICODE\n+__outline_epilogue\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\t; Make a copy of our frame pointer into %r20\n+\tcopy %r3,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Reload %r2\n+\t; First save off %r2\n+\tldw -20(0,%r20),%r2\n+\n+\t; Load our old stack pointer, save it in %r21.\n+\tldw 0(0,%r20),%r21\n+\n+\t; Add in local_fsize (%r19) to the frame pointer to find\n+\t; the saved registers.\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to restore.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to restore.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr restore.\n+\tcomb,= %r0,%r1,L$0002\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0002\n+\tldws,ma 4(0,%r20),%r18\n+\tnop\n+\tldws,ma 4(0,%r20),%r17\n+\tnop\n+\tldws,ma 4(0,%r20),%r16\n+\tnop\n+\tldws,ma 4(0,%r20),%r15\n+\tnop\n+\tldws,ma 4(0,%r20),%r14\n+\tnop\n+\tldws,ma 4(0,%r20),%r13\n+\tnop\n+\tldws,ma 4(0,%r20),%r12\n+\tnop\n+\tldws,ma 4(0,%r20),%r11\n+\tnop\n+\tldws,ma 4(0,%r20),%r10\n+\tnop\n+\tldws,ma 4(0,%r20),%r9\n+\tnop\n+\tldws,ma 4(0,%r20),%r8\n+\tnop\n+\tldws,ma 4(0,%r20),%r7\n+\tnop\n+\tldws,ma 4(0,%r20),%r6\n+\tnop\n+\tldws,ma 4(0,%r20),%r5\n+\tnop\n+\tldws,ma 4(0,%r20),%r4\n+\tnop\n+\tldws,ma 4(0,%r20),%r3\n+\tnop\n+L$0002\n+\t; All gr restore are done.  Align the temporary frame pointer and\n+\t; do the fr restore.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0003\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0003\n+\tfldws,ma 8(0,%r20),%fr21\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr20\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr19\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr18\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr17\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr16\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr15\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr14\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr13\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr12\n+\tnop\n+L$0003\n+\t; Return and deallocate our frame.\n+\tbv 0(%r31)\n+\tcopy %r21,%r30\n+\t.EXIT\n+\t.PROCEND\n+"}, {"sha": "545dab5cce6ebc5b5ffb50b759dbc930f8b8b5ec", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 112, "deletions": 2, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=9e18f575557d94acced039000fa26958e75f69e6", "patch": "@@ -113,6 +113,12 @@ override_options ()\n     {\n       warning (\"PIC code generation is not compatable with profiling\\n\");\n     }\n+\n+  if (TARGET_SPACE && (flag_pic || profile_flag))\n+    {\n+      warning (\"Out of line entry/exit sequences are not compatable\\n\");\n+      warning (\"with PIC or profiling\\n\");\n+    }\n }\n \n \n@@ -2039,8 +2045,24 @@ compute_frame_size (size, fregs_live)\n   for (i = 18; i >= 4; i--)\n     {\n       if (regs_ever_live[i])\n-\tfsize += 4;\n+\t{\n+\t  /* For out of line prologues/epilogues we only need to\n+\t     compute the highest register number to save and\n+\t     allocate space for all the callee saved registers\n+\t     with a lower number.  */\n+\t  if (TARGET_SPACE)\n+\t    {\n+\t      fsize += 4 * (i - 3);\n+\t      break;\n+\t    }\n+\t  fsize += 4;\n+\t}\n     }\n+\n+  /* We always save %r3, make room for it.  */\n+  if (TARGET_SPACE)\n+    fsize += 8;\n+\n   /* If we don't have a frame pointer, the register normally used for that\n      purpose is saved just like other registers, not in the \"frame marker\".  */\n   if (! frame_pointer_needed)\n@@ -2053,9 +2075,19 @@ compute_frame_size (size, fregs_live)\n   for (i = 66; i >= 48; i -= 2)\n     if (regs_ever_live[i] || regs_ever_live[i + 1])\n       {\n-\tfsize += 8;\n \tif (fregs_live)\n \t  *fregs_live = 1;\n+\n+\t/* For out of line prologues/epilogues we only need to\n+\t   compute the highest register number to save and\n+\t   allocate space for all the callee saved registers\n+\t   with a lower number.  */\n+        if (TARGET_SPACE)\n+\t  {\n+\t    fsize += 4 * (i - 46);\n+\t    break;\n+\t  }\n+\tfsize += 8;\n       }\n \n   fsize += current_function_outgoing_args_size;\n@@ -2148,6 +2180,47 @@ hppa_expand_prologue()\n   tmpreg = gen_rtx (REG, SImode, 1);\n   size_rtx = GEN_INT (actual_fsize);\n \n+  /* Handle out of line prologues and epilogues.  */\n+  if (TARGET_SPACE)\n+    {\n+      rtx operands[2];\n+      int saves = 0;\n+\n+      /* Put the local_fisze into %r19.  */\n+      operands[0] = gen_rtx (REG, SImode, 19);\n+      operands[1] = GEN_INT (local_fsize);\n+      emit_move_insn (operands[0], operands[1]);\n+\n+      /* Put the stack size into %r21.  */\n+      operands[0] = gen_rtx (REG, SImode, 21);\n+      operands[1] = size_rtx;\n+      emit_move_insn (operands[0], operands[1]);\n+\n+      /* Put the register save info into %r22.  */\n+      for (i = 18; i >= 3; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    saves = i;\n+            break;\n+\t  }\n+\t  \n+      for (i = 66; i >= 48; i -= 2)\n+\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  {\n+\t    saves |= ((i/2 - 12 ) << 16);\n+\t    break;\n+\t  }\n+\n+      operands[0] = gen_rtx (REG, SImode, 22);\n+      operands[1] = GEN_INT (saves);\n+      emit_move_insn (operands[0], operands[1]);\n+\n+      /* Now call the out-of-line prologue.  */\n+      emit_insn (gen_outline_prologue_call ());\n+      emit_insn (gen_blockage ());\n+      return;     \n+    }\n+\n   /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp-20.  */\n   if (regs_ever_live[2] || profile_flag)\n@@ -2416,6 +2489,43 @@ hppa_expand_epilogue ()\n   int offset,i;\n   int merge_sp_adjust_with_load  = 0;\n \n+  /* Handle out of line prologues and epilogues.  */\n+  if (TARGET_SPACE)\n+    {\n+      int saves = 0;\n+      rtx operands[2];\n+\n+      /* Put the register save info into %r22.  */\n+      for (i = 18; i >= 3; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    saves = i;\n+            break;\n+\t  }\n+\t  \n+      for (i = 66; i >= 48; i -= 2)\n+\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  {\n+\t    saves |= ((i/2 - 12 ) << 16);\n+\t    break;\n+\t  }\n+\n+      emit_insn (gen_blockage ());\n+\n+      /* Put the local_fisze into %r19.  */\n+      operands[0] = gen_rtx (REG, SImode, 19);\n+      operands[1] = GEN_INT (local_fsize);\n+      emit_move_insn (operands[0], operands[1]);\n+\n+      operands[0] = gen_rtx (REG, SImode, 22);\n+      operands[1] = GEN_INT (saves);\n+      emit_move_insn (operands[0], operands[1]);\n+\n+      /* Now call the out-of-line epilogue.  */\n+      emit_insn (gen_outline_epilogue_call ());\n+      return;\n+    }\n+\n   /* We will use this often.  */\n   tmpreg = gen_rtx (REG, SImode, 1);\n "}, {"sha": "606493a4bccbc27b1572b982a4d286783ac019d6", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=9e18f575557d94acced039000fa26958e75f69e6", "patch": "@@ -78,6 +78,10 @@ extern int target_flags;\n /* Allow unconditional jumps in the delay slots of call instructions.  */\n #define TARGET_JUMP_IN_DELAY (target_flags & 8)\n \n+/* Optimize for space.  Currently this only turns on out of line\n+   prologues and epilogues.  */\n+#define TARGET_SPACE (target_flags & 16)\n+\n /* Disable indexed addressing modes.  */\n \n #define TARGET_DISABLE_INDEXING (target_flags & 32)\n@@ -119,9 +123,11 @@ extern int target_flags;\n    {\"disable-fpregs\", 2},\t\\\n    {\"no-disable-fpregs\", -2},\t\\\n    {\"no-space-regs\", 4},\t\\\n-   {\"space-regs\", -4},\\\n+   {\"space-regs\", -4},\t\t\\\n    {\"jump-in-delay\", 8},\t\\\n    {\"no-jump-in-delay\", -8},\t\\\n+   {\"space\", 16},\t\t\\\n+   {\"no-space\", -16},\t\t\\\n    {\"disable-indexing\", 32},\t\\\n    {\"no-disable-indexing\", -32},\\\n    {\"portable-runtime\", 64},\t\\\n@@ -554,9 +560,11 @@ do {\t\t\t\t\t\t\t\t\\\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM 3\n \n-/* Value should be nonzero if functions must have frame pointers. */\n-#define FRAME_POINTER_REQUIRED (current_function_calls_alloca)\n-\n+/* Value should be nonzero if functions must have frame pointers.\n+   All functions have frame pointers when optimizing for space\n+   (for now).\n+#define FRAME_POINTER_REQUIRED \\\n+  (current_function_calls_alloca || TARGET_SPACE)\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue."}, {"sha": "a64d17b91444754893725dbb2cdea4ba654f1ce8", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e18f575557d94acced039000fa26958e75f69e6/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=9e18f575557d94acced039000fa26958e75f69e6", "patch": "@@ -4837,3 +4837,65 @@\n   \"mfsp %%sr0,%4\\;ldsid (0,%2),%3\\;mtsp %3,%%sr0\\;fic 0(%%sr0,%0)\\;fic 0(%%sr0,%1)\\;sync\\;mtsp %4,%%sr0\\;nop\\;nop\\;nop\\;nop\\;nop\\;nop\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"52\")])\n+\n+;; An out-of-line prologue.\n+(define_insn \"outline_prologue_call\"\n+  [(unspec_volatile [(const_int 0)] 0)\n+   (clobber (reg:SI 31))\n+   (clobber (reg:SI 22))\n+   (clobber (reg:SI 21))\n+   (clobber (reg:SI 20))\n+   (clobber (reg:SI 19))\n+   (clobber (reg:SI 1))]\n+  \"\"\n+  \"*\n+{\n+  /* Must import the magic millicode routine.  */\n+  output_asm_insn (\\\".IMPORT __outline_prologue,MILLICODE\\\", NULL);\n+\n+  /* The out-of-line prologue will make sure we return to the right\n+     instruction.  */\n+  if (TARGET_PORTABLE_RUNTIME)\n+    {\n+      output_asm_insn (\\\"ldil L'__outline_prologue,%%r31\\\", NULL);\n+      output_asm_insn (\\\"ble,n R'__outline_prologue(%%sr0,%%r31)\\\", NULL);\n+    }\n+  else\n+    output_asm_insn (\\\"bl,n __outline_prologue,%%r31\\\", NULL);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; An out-of-line epilogue.\n+(define_insn \"outline_epilogue_call\"\n+  [(unspec_volatile [(const_int 1)] 0)\n+   (use (reg:SI 29))\n+   (use (reg:SI 28))\n+   (clobber (reg:SI 31))\n+   (clobber (reg:SI 22))\n+   (clobber (reg:SI 21))\n+   (clobber (reg:SI 20))\n+   (clobber (reg:SI 19))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 1))]\n+  \"\"\n+  \"*\n+{\n+  /* Must import the magic millicode routine.  */\n+  output_asm_insn (\\\".IMPORT __outline_epilogue,MILLICODE\\\", NULL);\n+\n+  /* The out-of-line prologue will make sure we return to the right\n+     instruction.  */\n+  if (TARGET_PORTABLE_RUNTIME)\n+    {\n+      output_asm_insn (\\\"ldil L'__outline_epilogue,%%r31\\\", NULL);\n+      output_asm_insn (\\\"ble,n R'__outline_epilogue(%%sr0,%%r31)\\\", NULL);\n+    }\n+  else\n+    output_asm_insn (\\\"bl,n __outline_epilogue,%%r31\\\", NULL);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+"}]}