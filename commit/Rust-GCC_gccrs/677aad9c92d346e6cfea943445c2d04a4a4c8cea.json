{"sha": "677aad9c92d346e6cfea943445c2d04a4a4c8cea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc3YWFkOWM5MmQzNDZlNmNmZWE5NDM0NDVjMmQwNGE0YTRjOGNlYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-07-09T13:45:56Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-07-09T13:45:56Z"}, "message": "Makefile.am: Add new header.\n\n2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/scoped_allocator: New.\n\t* doc/xml/manual/status_cxx200x.xml: Update.\n\t* testsuite/20_util/scoped_allocator/1.cc: New.\n\t* testsuite/20_util/scoped_allocator/propagation.cc: New.\n\t* testsuite/20_util/scoped_allocator/requirements/typedefs.cc: New.\n\t* testsuite/20_util/scoped_allocator/requirements/\n\texplicit_instantiation.cc: New.\n\nFrom-SVN: r176079", "tree": {"sha": "96b6c4a23f99eba0c685380b33c585071c673b93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96b6c4a23f99eba0c685380b33c585071c673b93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/677aad9c92d346e6cfea943445c2d04a4a4c8cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677aad9c92d346e6cfea943445c2d04a4a4c8cea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/677aad9c92d346e6cfea943445c2d04a4a4c8cea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/677aad9c92d346e6cfea943445c2d04a4a4c8cea/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8485dc9f89c0eff0a548a6ba210e75be6f419c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8485dc9f89c0eff0a548a6ba210e75be6f419c"}], "stats": {"total": 726, "additions": 713, "deletions": 13}, "files": [{"sha": "6424c558aced8fc774ddbea6dee95c4b119e7ee5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -1,3 +1,15 @@\n+2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/std/scoped_allocator: New.\n+\t* doc/xml/manual/status_cxx200x.xml: Update.\n+\t* testsuite/20_util/scoped_allocator/1.cc: New.\n+\t* testsuite/20_util/scoped_allocator/propagation.cc: New.\n+\t* testsuite/20_util/scoped_allocator/requirements/typedefs.cc: New.\n+\t* testsuite/20_util/scoped_allocator/requirements/\n+\texplicit_instantiation.cc: New.\n+\n 2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/bits/stl_vector.h: Use new allocator model in C++0x mode."}, {"sha": "88e238f23556280c9b19c9c00fe06d2bad638cc4", "filename": "libstdc++-v3/doc/xml/manual/status_cxx200x.xml", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx200x.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx200x.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx200x.xml?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -1009,52 +1009,47 @@ particular release.\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n+      <?dbhtml bgcolor=\"#B0B0B0\" ?>\n       <entry>20.12</entry>\n       <entry>Scoped allocator adaptor</entry>\n-      <entry/>\n+      <entry>Partial</entry>\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>20.12.1</entry>\n       <entry>Header <code>&lt;scoped_allocator&gt;</code> synopsis</entry>\n       <entry/>\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>20.12.2</entry>\n       <entry>Scoped allocator adaptor member types</entry>\n-      <entry>N</entry>\n+      <entry>Y</entry>\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>20.12.3</entry>\n       <entry>Scoped allocator adaptor constructors</entry>\n-      <entry>N</entry>\n+      <entry>Y</entry>\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n+      <?dbhtml bgcolor=\"#B0B0B0\" ?>\n       <entry>20.12.4</entry>\n       <entry>Scoped allocator adaptor members</entry>\n-      <entry>N</entry>\n+      <entry>Partial</entry>\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>20.12.5</entry>\n       <entry>Scoped allocator operators</entry>\n-      <entry>N</entry>\n+      <entry>Y</entry>\n       <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>20.13</entry>\n       <entry>Class <code>type_index</code></entry>\n-      <entry>N</entry>\n+      <entry>Y</entry>\n       <entry/>\n     </row>\n     <row>"}, {"sha": "c926a3133aaae7bb0c461a9342669adb13752ee2", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -58,6 +58,7 @@ std_headers = \\\n \t${std_srcdir}/random \\\n \t${std_srcdir}/ratio \\\n \t${std_srcdir}/regex \\\n+\t${std_srcdir}/scoped_allocator \\\n \t${std_srcdir}/set \\\n \t${std_srcdir}/sstream \\\n \t${std_srcdir}/stack \\"}, {"sha": "c26eab0c6a0207fafa39f411df0ddf283dd53700", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -310,6 +310,7 @@ std_headers = \\\n \t${std_srcdir}/random \\\n \t${std_srcdir}/ratio \\\n \t${std_srcdir}/regex \\\n+\t${std_srcdir}/scoped_allocator \\\n \t${std_srcdir}/set \\\n \t${std_srcdir}/sstream \\\n \t${std_srcdir}/stack \\"}, {"sha": "bde996c42b36b8707c32a80cc2a05d23abdcf6d0", "filename": "libstdc++-v3/include/std/scoped_allocator", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fscoped_allocator?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -0,0 +1,373 @@\n+// <scoped_allocator> -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/scoped_allocator\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _SCOPED_ALLOCATOR\n+#define _SCOPED_ALLOCATOR 1\n+\n+#pragma GCC system_header\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <utility>\n+#include <tuple>\n+#include <bits/alloc_traits.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<template<typename> class _Pred, typename... _Allocs>\n+    struct __any_of;\n+\n+  template<template<typename> class _Pred, typename _Alloc, typename... _Allocs>\n+    struct __any_of<_Pred, _Alloc, _Allocs...>\n+    : __or_<_Pred<_Alloc>, __any_of<_Pred, _Allocs...>>\n+    { };\n+\n+  template<template<typename> class _Pred, typename _Alloc>\n+    struct __any_of<_Pred, _Alloc>\n+    : _Pred<_Alloc>\n+    { };\n+\n+  /**\n+   * @addtogroup allocators\n+   * @{\n+   */\n+\n+  template<typename _Alloc>\n+    struct __propagate_on_copy\n+    : allocator_traits<_Alloc>::propagate_on_container_copy_assignment\n+    { };\n+  template<typename _Alloc>\n+    struct __propagate_on_move\n+    : allocator_traits<_Alloc>::propagate_on_container_move_assignment\n+    { };\n+  template<typename _Alloc>\n+    struct __propagate_on_swap\n+    : allocator_traits<_Alloc>::propagate_on_container_swap\n+    { };\n+\n+  \n+  template<typename _Alloc>\n+    inline auto\n+    __do_outermost(_Alloc& __a, _Alloc&) -> decltype(__a.outer_allocator())\n+    { return __a.outer_allocator(); }\n+\n+  template<typename _Alloc>\n+    inline _Alloc&\n+    __do_outermost(_Alloc& __a, ...)\n+    { return __a; }\n+\n+  template<typename _Alloc>\n+    inline auto\n+    __outermost(_Alloc& __a) -> decltype(__do_outermost(__a, __a))\n+    { return __do_outermost(__a, __a); }\n+\n+  template<typename _OuterAlloc, typename... _InnerAllocs>\n+    class scoped_allocator_adaptor;\n+\n+      template<typename...> struct __inner_type_impl;\n+\n+      template<typename _Outer>\n+      struct __inner_type_impl<_Outer>\n+      {\n+\ttypedef scoped_allocator_adaptor<_Outer> __type;\n+\n+        __inner_type_impl() = default;\n+        __inner_type_impl(const __inner_type_impl&) = default;\n+        __inner_type_impl(__inner_type_impl&&) = default;\n+\n+\ttemplate<typename _Alloc>\n+\t  __inner_type_impl(const __inner_type_impl<_Alloc>& __other)\n+\t  { }\n+\n+\ttemplate<typename _Alloc>\n+\t  __inner_type_impl(__inner_type_impl<_Alloc>&& __other)\n+\t  { }\n+\n+\t__type& _M_get(__type* __p) noexcept { return *__p; }\n+\tconst __type& _M_get(const __type* __p) const noexcept { return *__p; }\n+\n+\ttuple<> _M_tie() const noexcept { return tuple<>(); }\n+\n+\tbool operator==(const __inner_type_impl&) const noexcept\n+        { return true; }\n+      };\n+\n+      template<typename _Outer, typename _InnerHead, typename... _InnerTail>\n+      struct __inner_type_impl<_Outer, _InnerHead, _InnerTail...>\n+      {\n+\ttypedef scoped_allocator_adaptor<_InnerHead, _InnerTail...> __type;\n+\n+\t__inner_type_impl() = default;\n+        __inner_type_impl(const __inner_type_impl&) = default;\n+        __inner_type_impl(__inner_type_impl&&) = default;\n+\n+\ttemplate<typename... _Allocs>\n+\t  __inner_type_impl(const __inner_type_impl<_Allocs...>& __other)\n+\t  : _M_inner(__other._M_inner) { }\n+\n+\ttemplate<typename... _Allocs>\n+\t  __inner_type_impl(__inner_type_impl<_Allocs...>&& __other)\n+\t  : _M_inner(std::move(__other._M_inner)) { }\n+\n+\ttemplate<typename... _Args>\n+\t  explicit\n+\t  __inner_type_impl(_Args&&... __args)\n+\t  : _M_inner(std::forward<_Args>(__args)...) { }\n+\n+\t__type& _M_get(void*) noexcept { return _M_inner; }\n+\tconst __type& _M_get(const void*) const noexcept { return _M_inner; }\n+\n+\ttuple<const _InnerHead&, const _InnerTail&...> _M_tie() const noexcept\n+\t{ return _M_inner._M_tie(); }\n+\n+\tbool operator==(const __inner_type_impl& __other) const noexcept\n+\t{ return _M_inner == __other._M_inner; }\n+\n+      private:\n+\ttemplate<typename...> friend class __inner_type_impl;\n+\ttemplate<typename, typename...> friend class scoped_allocator_adaptor;\n+\n+\t__type _M_inner;\n+      };\n+\n+  template<typename _OuterAlloc, typename... _InnerAllocs>\n+    class scoped_allocator_adaptor\n+    : public _OuterAlloc\n+    {\n+      typedef allocator_traits<_OuterAlloc> __traits;\n+\n+      typedef __inner_type_impl<_OuterAlloc, _InnerAllocs...> __inner_type;\n+      __inner_type _M_inner;\n+\n+      template<typename _Outer, typename... _Inner>\n+        friend class scoped_allocator_adaptor;\n+\n+      template<typename...>\n+        friend class __inner_type_impl;\n+\n+      tuple<const _OuterAlloc&, const _InnerAllocs&...>\n+      _M_tie() const noexcept\n+      { return std::tuple_cat(std::tie(outer_allocator()), _M_inner._M_tie()); }\n+\n+      \n+      template<typename _Tp, typename... _Args>\n+        void _M_construct(__uses_alloc0, _Tp* __p, _Args&&... __args)\n+        {\n+          auto& __outer = __outermost(*this);\n+\t  typedef typename std::decay<decltype(__outer)>::type __outer_type;\n+          typedef allocator_traits<__outer_type> __o_traits;\n+          __o_traits::construct(__outer, __p, std::forward<_Args>(__args)...);\n+        }\n+\n+      typedef __uses_alloc1<typename __inner_type::__type> __uses_alloc1_;\n+      typedef __uses_alloc2<typename __inner_type::__type> __uses_alloc2_;\n+\n+      template<typename _Tp, typename... _Args>\n+        void _M_construct(__uses_alloc1_, _Tp* __p, _Args&&... __args)\n+        {\n+          auto& __outer = __outermost(*this);\n+\t  typedef typename std::decay<decltype(__outer)>::type __outer_type;\n+          typedef allocator_traits<__outer_type> __o_traits;\n+          __o_traits::construct(__outer, __p, allocator_arg, inner_allocator(),\n+                                std::forward<_Args>(__args)...);\n+        }\n+\n+      template<typename _Tp, typename... _Args>\n+        void _M_construct(__uses_alloc2_, _Tp* __p, _Args&&... __args)\n+        {\n+\t  auto& __outer = __outermost(*this);\n+\t  typedef typename std::decay<decltype(__outer)>::type __outer_type;\n+          typedef allocator_traits<__outer_type> __o_traits;\n+          __o_traits::construct(__outer, __p, std::forward<_Args>(__args)...,\n+                                inner_allocator());\n+        }\n+\n+      template<typename _Alloc>\n+        static _Alloc\n+        _S_select_on_copy(const _Alloc& __a)\n+        {\n+          typedef allocator_traits<_Alloc> __a_traits;\n+          return __a_traits::select_on_container_copy_construction(__a);\n+        }\n+\n+      template<int... _Indices>\n+        scoped_allocator_adaptor(tuple<const _OuterAlloc&,\n+                                       const _InnerAllocs&...> __refs,\n+                                 _Index_tuple<_Indices...>)\n+        : _OuterAlloc(_S_select_on_copy(std::get<0>(__refs))),\n+          _M_inner(_S_select_on_copy(std::get<_Indices+1>(__refs))...)\n+        { }\n+\n+    public:\n+      typedef _OuterAlloc                       outer_allocator_type;\n+      typedef typename __inner_type::__type     inner_allocator_type;\n+\n+      typedef typename __traits::value_type             value_type;\n+      typedef typename __traits::size_type              size_type;\n+      typedef typename __traits::difference_type        difference_type;\n+      typedef typename __traits::pointer                pointer;\n+      typedef typename __traits::const_pointer          const_pointer;\n+      typedef typename __traits::void_pointer           void_pointer;\n+      typedef typename __traits::const_void_pointer     const_void_pointer;\n+\n+      typedef typename conditional<\n+        __any_of<__propagate_on_copy, _OuterAlloc, _InnerAllocs...>::value,\n+        true_type, false_type>::type propagate_on_container_copy_assignment;\n+      typedef typename conditional<\n+        __any_of<__propagate_on_move, _OuterAlloc, _InnerAllocs...>::value,\n+        true_type, false_type>::type propagate_on_container_move_assignment;\n+      typedef typename conditional<\n+        __any_of<__propagate_on_swap, _OuterAlloc, _InnerAllocs...>::value,\n+        true_type, false_type>::type propagate_on_container_swap;\n+\n+      template <class _Tp>\n+        struct rebind\n+        {\n+          // TODO: use rebind_alloc<Tp> instead of __rebind_alloc<Tp>::__type\n+          typedef scoped_allocator_adaptor<\n+            typename __traits::template __rebind_alloc<_Tp>::__type,\n+            _InnerAllocs...> other;\n+        };\n+\n+      scoped_allocator_adaptor() : _OuterAlloc(), _M_inner() { }\n+\n+      template<typename _Outer2>\n+        scoped_allocator_adaptor(_Outer2&& __outer,\n+                                 const _InnerAllocs&... __inner)\n+        : _OuterAlloc(std::forward<_Outer2>(__outer)),\n+          _M_inner(__inner...)\n+        { }\n+\n+      scoped_allocator_adaptor(const scoped_allocator_adaptor& __other)\n+      : _OuterAlloc(__other.outer_allocator()),\n+\t_M_inner(__other._M_inner)\n+      { }\n+\n+      scoped_allocator_adaptor(scoped_allocator_adaptor&& __other)\n+      : _OuterAlloc(std::move(__other.outer_allocator())),\n+\t_M_inner(std::move(__other._M_inner))\n+      { }\n+\n+      template<typename _Outer2>\n+        scoped_allocator_adaptor(\n+            const scoped_allocator_adaptor<_Outer2, _InnerAllocs...>& __other)\n+        : _OuterAlloc(__other.outer_allocator()),\n+          _M_inner(__other._M_inner)\n+        { }\n+\n+      template<typename _Outer2>\n+        scoped_allocator_adaptor(\n+            scoped_allocator_adaptor<_Outer2, _InnerAllocs...>&& __other)\n+        : _OuterAlloc(std::move(__other.outer_allocator())),\n+          _M_inner(std::move(__other._M_inner))\n+        { }\n+\n+      inner_allocator_type& inner_allocator() noexcept\n+      { return _M_inner._M_get(this); }\n+\n+      const inner_allocator_type& inner_allocator() const noexcept\n+      { return _M_inner._M_get(this); }\n+\n+      outer_allocator_type& outer_allocator() noexcept\n+      { return static_cast<_OuterAlloc&>(*this); }\n+\n+      const outer_allocator_type& outer_allocator() const noexcept\n+      { return static_cast<const _OuterAlloc&>(*this); }\n+\n+      pointer allocate(size_type __n)\n+      { return __traits::allocate(outer_allocator(), __n); }\n+\n+      pointer allocate(size_type __n, const_void_pointer __hint)\n+      { return __traits::allocate(outer_allocator(), __n, __hint); }\n+\n+      void deallocate(pointer __p, size_type __n)\n+      { return __traits::deallocate(outer_allocator(), __p, __n); }\n+\n+      size_type max_size() const\n+      { return __traits::max_size(outer_allocator()); }\n+\n+      template<typename _Tp, typename... _Args>\n+        void construct(_Tp* __p, _Args&&... __args)\n+        {\n+          auto& __inner = inner_allocator();\n+          auto __use_tag\n+            = __use_alloc<_Tp, inner_allocator_type, _Args...>(__inner);\n+          _M_construct(__use_tag, __p, std::forward<_Args>(__args)...);\n+        }\n+\n+      // TODO: construct pairs\n+\n+      template<typename _Tp>\n+        void destroy(_Tp* __p)\n+        {\n+          auto& __outer = __outermost(*this);\n+\t  typedef typename std::decay<decltype(__outer)>::type __outer_type;\n+          allocator_traits<__outer_type>::destroy(__outer, __p);\n+        }\n+\n+      scoped_allocator_adaptor\n+      select_on_container_copy_construction() const\n+      {\n+        typedef typename _Build_index_tuple<sizeof...(_InnerAllocs)>::__type\n+\t    _Indices;\n+        return scoped_allocator_adaptor(_M_tie(), _Indices());\n+      }\n+\n+      template <typename _OutA1, typename _OutA2, typename... _InA>\n+      friend bool\n+      operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n+                 const scoped_allocator_adaptor<_OutA2, _InA...>& __b) noexcept;\n+    };\n+\n+  template <typename _OutA1, typename _OutA2, typename... _InA>\n+    inline bool\n+    operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n+               const scoped_allocator_adaptor<_OutA2, _InA...>& __b) noexcept\n+    {\n+      return __a.outer_allocator() == __b.outer_allocator()\n+          && __a._M_inner == __b._M_inner;\n+    }\n+\n+  template <typename _OutA1, typename _OutA2, typename... _InA>\n+    inline bool\n+    operator!=(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n+               const scoped_allocator_adaptor<_OutA2, _InA...>& __b) noexcept\n+    { return !(__a == __b); }\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n+\n+#endif // _SCOPED_ALLOCATOR"}, {"sha": "823769fb563548b2e596c940d2f54008eae35ed9", "filename": "libstdc++-v3/testsuite/20_util/scoped_allocator/1.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2F1.cc?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -0,0 +1,99 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <scoped_allocator>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::uneq_allocator;\n+\n+struct Element\n+{\n+  typedef uneq_allocator<Element> allocator_type;\n+\n+  allocator_type alloc;\n+\n+  Element(const allocator_type& a = allocator_type()) : alloc(a) { }\n+\n+  Element(std::allocator_arg_t, const allocator_type& a, int i = 0)\n+  : alloc(a) { }\n+\n+  Element(std::allocator_arg_t, const allocator_type& a, const Element&)\n+  : alloc(a) { }\n+\n+  const allocator_type& get_allocator() const { return alloc; }\n+};\n+\n+void test01()\n+{\n+  bool test __attribute((unused)) = false;\n+\n+  typedef std::scoped_allocator_adaptor<Element::allocator_type> alloc1_type;\n+\n+  typedef std::vector<Element, alloc1_type> EltVec;\n+\n+  alloc1_type a1(1);\n+  Element e;\n+  EltVec ev1(1, e, a1);\n+  VERIFY( ev1[0].get_allocator().get_personality() == 1 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute((unused)) = false;\n+\n+  typedef std::vector<Element, Element::allocator_type> EltVec;\n+\n+  typedef std::scoped_allocator_adaptor<EltVec::allocator_type,\n+\t                                Element::allocator_type> alloc_type;\n+\n+  typedef std::vector<EltVec, alloc_type> EltVecVec;\n+\n+  alloc_type a(1, 2);\n+  Element e;\n+  EltVec ev(1, e);\n+  EltVecVec evv(1, ev, a);\n+\n+  VERIFY( evv.get_allocator().get_personality() == 1 );\n+  VERIFY( evv[0].get_allocator().get_personality() == 2 );\n+  VERIFY( evv[0][0].get_allocator().get_personality() == 2 );\n+\n+  alloc_type a2(3, 4);\n+\n+  EltVecVec evv2(evv, a2); // copy with a different allocator\n+\n+  VERIFY( evv2.get_allocator().get_personality() == 3 );\n+  VERIFY( evv2[0].get_allocator().get_personality() == 4 );\n+  VERIFY( evv2[0][0].get_allocator().get_personality() == 4 );\n+\n+  EltVecVec evv3(std::move(evv), a2); // move with a different allocator\n+\n+  VERIFY( evv3.get_allocator().get_personality() == 3 );\n+  VERIFY( evv3[0].get_allocator().get_personality() == 4 );\n+  VERIFY( evv3[0][0].get_allocator().get_personality() == 4 );\n+\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "5679b733715438e65bcf2e8d55dc132d618f2ada", "filename": "libstdc++-v3/testsuite/20_util/scoped_allocator/propagation.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Fpropagation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Fpropagation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Fpropagation.cc?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -0,0 +1,105 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// test that propagate_on_container_xxx is true iff it is true for\n+// any of the outer or inner allocators\n+\n+#include <scoped_allocator>\n+\n+using std::scoped_allocator_adaptor;\n+\n+typedef short test_type;\n+\n+template<typename T>\n+  struct minimal_allocator\n+  {\n+    typedef T value_type;\n+    minimal_allocator();\n+    template <typename U>\n+      minimal_allocator(const minimal_allocator<U>&);\n+    T* allocate(std::size_t);\n+    void deallocate(T*, std::size_t);\n+  };\n+\n+template<typename T, bool copy, bool move, bool swap>\n+  struct test_allocator : minimal_allocator<T>\n+  {\n+    struct propagate_on_container_copy_assignment\n+    { static const bool value = copy; };\n+\n+    struct propagate_on_container_move_assignment\n+    { static const bool value = move; };\n+\n+    struct propagate_on_container_swap\n+    { static const bool value = swap; };\n+  };\n+\n+template<typename A>\n+  constexpr bool prop_on_copy()\n+  {\n+    typedef typename A::propagate_on_container_copy_assignment type;\n+    return type::value;\n+  }\n+\n+template<typename A>\n+  constexpr bool prop_on_move()\n+  {\n+    typedef typename A::propagate_on_container_move_assignment type;\n+    return type::value;\n+  }\n+\n+template<typename A>\n+  constexpr bool prop_on_swap()\n+  {\n+    typedef typename A::propagate_on_container_swap type;\n+    return type::value;\n+  }\n+\n+template<typename A, bool C, bool M, bool S>\n+  constexpr bool test1()\n+  {\n+    static_assert( prop_on_copy<A>() == C, \"copy\" );\n+    static_assert( prop_on_move<A>() == M, \"move\" );\n+    static_assert( prop_on_swap<A>() == S, \"swap\" );\n+    return true;\n+  }\n+\n+template<bool C, bool M, bool S>\n+  constexpr bool test2()\n+  {\n+    typedef minimal_allocator<test_type>       base_alloc;\n+    typedef test_allocator<test_type, C, M, S> test_alloc;\n+    typedef scoped_allocator_adaptor<base_alloc, test_alloc> scoped1;\n+    typedef scoped_allocator_adaptor<test_alloc, base_alloc> scoped2;\n+    typedef scoped_allocator_adaptor<test_alloc, test_alloc> scoped3;\n+    return test1<scoped1, C, M, S>()\n+        && test1<scoped2, C, M, S>()\n+        && test1<scoped3, C, M, S>();\n+  }\n+\n+static_assert( test2<false, false, false>(), \"never propagate\" );\n+static_assert( test2<true, false, false>(), \"propagate on copy\" );\n+static_assert( test2<false, true, false>(), \"propagate on move\" );\n+static_assert( test2<false, false, true>(), \"propagate on swap\" );\n+static_assert( test2<true, true, false>(), \"propagate on copy & move\" );\n+static_assert( test2<true, false, true>(), \"propagate on copy & swap\" );\n+static_assert( test2<false, true, true>(), \"propagate on move & swap\" );\n+static_assert( test2<true, true, true>(), \"always propagate\" );\n+"}, {"sha": "1f85756f74a3d71dee3e1384ed75dd68d3e74f5d", "filename": "libstdc++-v3/testsuite/20_util/scoped_allocator/requirements/explicit_instantiation.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Frequirements%2Fexplicit_instantiation.cc?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing memory with NO OTHER INCLUDES.\n+\n+#include <scoped_allocator>\n+#include <memory>\n+\n+typedef short test_type;\n+\n+template<typename T>\n+  struct minimal_allocator\n+  {\n+    typedef T value_type;\n+    minimal_allocator();\n+    template <typename U>\n+      minimal_allocator(const minimal_allocator<U>&);\n+    T* allocate(unsigned long);\n+    void deallocate(T*, unsigned long);\n+  };\n+\n+namespace std\n+{\n+  template struct scoped_allocator_adaptor<std::allocator<test_type>>;\n+\n+  template struct scoped_allocator_adaptor<minimal_allocator<test_type>>;\n+\n+  template struct scoped_allocator_adaptor<std::allocator<test_type>,\n+                                           minimal_allocator<test_type>>;\n+}"}, {"sha": "762bedf8e5c65f1a3fcac6b9dea82ba40dd4fa91", "filename": "libstdc++-v3/testsuite/20_util/scoped_allocator/requirements/typedefs.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/677aad9c92d346e6cfea943445c2d04a4a4c8cea/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fscoped_allocator%2Frequirements%2Ftypedefs.cc?ref=677aad9c92d346e6cfea943445c2d04a4a4c8cea", "patch": "@@ -0,0 +1,67 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing scoped_allocator with NO OTHER INCLUDES.\n+\n+#include <scoped_allocator>\n+\n+// { dg-do compile }\n+\n+template<typename T>\n+  struct minimal_allocator\n+  {\n+    typedef T value_type;\n+    minimal_allocator();\n+    template <typename U>\n+      minimal_allocator(const minimal_allocator<U>&);\n+    T* allocate(unsigned long);\n+    void deallocate(T*, unsigned long);\n+  };\n+\n+struct S\n+{\n+  typedef minimal_allocator<short> allocator_type;\n+  S(const allocator_type&);\n+};\n+\n+void test01()\n+{\n+  typedef minimal_allocator<S>                      outer_type;\n+  typedef minimal_allocator<S::allocator_type>      inner_type;\n+  typedef std::scoped_allocator_adaptor<outer_type, inner_type> test_type;\n+\n+  // Check for required typedefs\n+  typedef typename test_type::outer_allocator_type  outer_allocator_type;\n+  typedef typename test_type::inner_allocator_type  inner_allocator_type;\n+  typedef typename test_type::value_type            value_type;\n+  typedef typename test_type::size_type             size_type;\n+  typedef typename test_type::difference_type       difference_type;\n+  typedef typename test_type::pointer               pointer;\n+  typedef typename test_type::const_pointer         const_pointer;\n+  typedef typename test_type::void_pointer          void_pointer;\n+  typedef typename test_type::const_void_pointer    const_void_pointer;\n+  typedef typename test_type::propagate_on_container_copy_assignment\n+    propagate_on_container_copy_assignment;\n+  typedef typename test_type::propagate_on_container_move_assignment\n+    propagate_on_container_move_assignment;\n+  typedef typename test_type::propagate_on_container_swap\n+    propagate_on_container_swap;\n+}\n+"}]}