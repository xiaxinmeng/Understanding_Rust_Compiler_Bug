{"sha": "de47f61f5e441f6ce498af603cbe35d86b556262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0N2Y2MWY1ZTQ0MWY2Y2U0OThhZjYwM2NiZTM1ZDg2YjU1NjI2Mg==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2018-01-26T17:15:21Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-01-26T17:15:21Z"}, "message": "[AArch64] Fix gcc.target/aarch64/subs_compare_[12].c\n\nThis patch fixes the testsuite failures gcc.target/aarch64/subs_compare_1.c and subs_compare_2.c\nThe tests check that we combine a sequence like:\n        sub     w2, w0, w1\n        cmp     w0, w1\n\ninto\n        subs    w2, w0, w1\n\nThis is done by a couple of peepholes in aarch64.md.\n\nUnfortunately due to scheduling and other optimisations the SUB and CMP\ncan come in a different order:\n        cmp     w0, w1\n        sub     w0, w0, w1\n\nAnd the existing peepholes cannot catch that and we fail to combine the two.\nThis patch adds a peephole that matches the CMP as the first insn and the SUB as the second\nand outputs a SUBS.  This is almost equivalent to the existing peephole that matches SUB first and CMP second\nexcept that it doesn't have the restriction that the output register of the SUB has to not be one of the input registers.\nRemember \"sub w0, w0, w1 ; cmp w0, w1\" is *not* equivalent to: \"subs  w0, w0, w1\"\nbut \"cmp w0, w1 ; sub w0, w0, w1\" is.\n\nSo this is what this patch does. It adds a peephole for the case above and one for the SUB-immediate variant\n(because the SUB-immediate is represented as PLUS-of-negated-immediate and thus has different RTL structure).\n\nBootstrapped and tested on aarch64-none-linux-gnu.\n\n    * config/aarch64/aarch64.md: Add peepholes for CMP + SUB -> SUBS\n    and CMP + SUB-immediate -> SUBS.\n\nFrom-SVN: r257102", "tree": {"sha": "b12378be652ba3abf1bc63f2065dc9097005490f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b12378be652ba3abf1bc63f2065dc9097005490f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de47f61f5e441f6ce498af603cbe35d86b556262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de47f61f5e441f6ce498af603cbe35d86b556262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de47f61f5e441f6ce498af603cbe35d86b556262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de47f61f5e441f6ce498af603cbe35d86b556262/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "41d733d943d25c83fffe587145271b6669e87984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41d733d943d25c83fffe587145271b6669e87984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41d733d943d25c83fffe587145271b6669e87984"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "dc83c382a51153bad5eeed8e66c8b83efdab0d2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de47f61f5e441f6ce498af603cbe35d86b556262/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de47f61f5e441f6ce498af603cbe35d86b556262/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de47f61f5e441f6ce498af603cbe35d86b556262", "patch": "@@ -1,3 +1,8 @@\n+2018-01-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.md: Add peepholes for CMP + SUB -> SUBS\n+\tand CMP + SUB-immediate -> SUBS.\n+\n 2018-01-26  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/83896"}, {"sha": "49095f8f3d995907903c11b68cae25a919204a76", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de47f61f5e441f6ce498af603cbe35d86b556262/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de47f61f5e441f6ce498af603cbe35d86b556262/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=de47f61f5e441f6ce498af603cbe35d86b556262", "patch": "@@ -2430,6 +2430,26 @@\n   }\n )\n \n+;; Same as the above peephole but with the compare and minus in\n+;; swapped order.  The restriction on overlap between operand 0\n+;; and operands 1 and 2 doesn't apply here.\n+(define_peephole2\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC\n+\t  (match_operand:GPI 1 \"aarch64_reg_or_zero\")\n+\t  (match_operand:GPI 2 \"aarch64_reg_or_zero\")))\n+   (set (match_operand:GPI 0 \"register_operand\")\n+\t(minus:GPI (match_dup 1)\n+\t\t   (match_dup 2)))]\n+  \"\"\n+  [(const_int 0)]\n+  {\n+    emit_insn (gen_sub<mode>3_compare1 (operands[0], operands[1],\n+\t\t\t\t\t operands[2]));\n+    DONE;\n+  }\n+)\n+\n (define_peephole2\n   [(set (match_operand:GPI 0 \"register_operand\")\n \t(plus:GPI (match_operand:GPI 1 \"register_operand\")\n@@ -2448,6 +2468,26 @@\n   }\n )\n \n+;; Same as the above peephole but with the compare and minus in\n+;; swapped order.  The restriction on overlap between operand 0\n+;; and operands 1 doesn't apply here.\n+(define_peephole2\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC\n+\t  (match_operand:GPI 1 \"register_operand\")\n+\t  (match_operand:GPI 3 \"const_int_operand\")))\n+   (set (match_operand:GPI 0 \"register_operand\")\n+\t(plus:GPI (match_dup 1)\n+\t\t  (match_operand:GPI 2 \"aarch64_sub_immediate\")))]\n+  \"INTVAL (operands[3]) == -INTVAL (operands[2])\"\n+  [(const_int 0)]\n+  {\n+    emit_insn (gen_sub<mode>3_compare1_imm (operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3]));\n+    DONE;\n+  }\n+)\n+\n (define_insn \"*sub_<shift>_<mode>\"\n   [(set (match_operand:GPI 0 \"register_operand\" \"=r\")\n \t(minus:GPI (match_operand:GPI 3 \"register_operand\" \"r\")"}]}