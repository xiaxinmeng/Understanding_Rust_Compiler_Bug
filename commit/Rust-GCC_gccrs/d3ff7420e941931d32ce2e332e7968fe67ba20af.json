{"sha": "d3ff7420e941931d32ce2e332e7968fe67ba20af", "node_id": "C_kwDOANBUbNoAKGQzZmY3NDIwZTk0MTkzMWQzMmNlMmUzMzJlNzk2OGZlNjdiYTIwYWY", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2021-12-02T14:34:15Z"}, "committer": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2022-01-10T17:54:33Z"}, "message": "[vect] Re-analyze all modes for epilogues\n\ngcc/ChangeLog:\n\n\t* tree-vectorizer.c (better_epilogue_loop_than_p): Round factors up for\n\tepilogue costing.\n\t* tree-vect-loop.c (vect_analyze_loop): Re-analyze all modes for\n\tepilogues, unless we are guaranteed that we can't have partial vectors.\n\t* genopinit.c: (partial_vectors_supported): Generate new function.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/masked_epilogue.c: New test.", "tree": {"sha": "14dc5d0f7401326cf19569ccfa92dc0841a4ac0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14dc5d0f7401326cf19569ccfa92dc0841a4ac0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3ff7420e941931d32ce2e332e7968fe67ba20af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ff7420e941931d32ce2e332e7968fe67ba20af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ff7420e941931d32ce2e332e7968fe67ba20af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ff7420e941931d32ce2e332e7968fe67ba20af/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "828474fafd2ed33430172fe227f9da7d6fb98723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/828474fafd2ed33430172fe227f9da7d6fb98723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/828474fafd2ed33430172fe227f9da7d6fb98723"}], "stats": {"total": 111, "additions": 72, "deletions": 39}, "files": [{"sha": "fe0791c27d6d08605c414e2f04c98fab503ed278", "filename": "gcc/genopinit.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=d3ff7420e941931d32ce2e332e7968fe67ba20af", "patch": "@@ -320,6 +320,7 @@ main (int argc, const char **argv)\n \t   \"  signed char supports_vec_scatter_store[NUM_MACHINE_MODES];\\n\"\n \t   \"};\\n\"\n \t   \"extern void init_all_optabs (struct target_optabs *);\\n\"\n+\t   \"extern bool partial_vectors_supported_p (void);\\n\"\n \t   \"\\n\"\n \t   \"extern struct target_optabs default_target_optabs;\\n\"\n \t   \"extern struct target_optabs *this_fn_optabs;\\n\"\n@@ -372,6 +373,33 @@ main (int argc, const char **argv)\n     fprintf (s_file, \"  ena[%u] = HAVE_%s;\\n\", i, p->name);\n   fprintf (s_file, \"}\\n\\n\");\n \n+  fprintf (s_file,\n+\t   \"/* Returns TRUE if the target supports any of the partial vector\\n\"\n+\t   \"   optabs: while_ult_optab, len_load_optab or len_store_optab,\\n\"\n+\t   \"   for any mode.  */\\n\"\n+\t   \"bool\\npartial_vectors_supported_p (void)\\n{\\n\");\n+  bool any_match = false;\n+  fprintf (s_file, \"\\treturn\");\n+  bool first = true;\n+  for (i = 0; patterns.iterate (i, &p); ++i)\n+    {\n+#define CMP_NAME(N) !strncmp (p->name, (N), strlen ((N)))\n+      if (CMP_NAME(\"while_ult\") || CMP_NAME (\"len_load\")\n+\t  || CMP_NAME (\"len_store\"))\n+\t{\n+\t  if (first)\n+\t    fprintf (s_file, \" HAVE_%s\", p->name);\n+\t  else\n+\t    fprintf (s_file, \" || HAVE_%s\", p->name);\n+\t  first = false;\n+\t  any_match = true;\n+\t}\n+    }\n+  if (!any_match)\n+    fprintf (s_file, \" false\");\n+  fprintf (s_file, \";\\n}\\n\");\n+\n+\n   /* Perform a binary search on a pre-encoded optab+mode*2.  */\n   /* ??? Perhaps even better to generate a minimal perfect hash.\n      Using gperf directly is awkward since it's so geared to working"}, {"sha": "286a7be236f337fee4c4650f42da72000855c5e6", "filename": "gcc/testsuite/gcc.target/aarch64/masked_epilogue.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmasked_epilogue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmasked_epilogue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmasked_epilogue.c?ref=d3ff7420e941931d32ce2e332e7968fe67ba20af", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-details -march=armv8-a+sve -msve-vector-bits=scalable\" } */\n+\n+void f(unsigned char y[restrict],\n+       unsigned char x[restrict], int n) {\n+  for (int i = 0; i < n; ++i)\n+    y[i] = (y[i] + x[i] + 1) >> 1;\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP EPILOGUE VECTORIZED \\(MODE=VNx} \"vect\" } } */"}, {"sha": "6ed2b5f8724e5ebf27592f67d7f6bdfe1ebcf512", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d3ff7420e941931d32ce2e332e7968fe67ba20af", "patch": "@@ -2936,8 +2936,6 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n   machine_mode autodetected_vector_mode = VOIDmode;\n   opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);\n   unsigned int mode_i = 0;\n-  unsigned int first_loop_i = 0;\n-  unsigned int first_loop_next_i = 0;\n   unsigned HOST_WIDE_INT simdlen = loop->simdlen;\n \n   /* First determine the main loop vectorization mode, either the first\n@@ -2946,7 +2944,6 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n      lowest cost if pick_lowest_cost_p.  */\n   while (1)\n     {\n-      unsigned int loop_vinfo_i = mode_i;\n       bool fatal;\n       opt_loop_vec_info loop_vinfo\n \t= vect_analyze_loop_1 (loop, shared, &loop_form_info,\n@@ -2975,11 +2972,7 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n \t    }\n \t  if (first_loop_vinfo == NULL)\n-\t    {\n-\t      first_loop_vinfo = loop_vinfo;\n-\t      first_loop_i = loop_vinfo_i;\n-\t      first_loop_next_i = mode_i;\n-\t    }\n+\t    first_loop_vinfo = loop_vinfo;\n \t  else\n \t    {\n \t      delete loop_vinfo;\n@@ -3025,32 +3018,37 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n   /* Now analyze first_loop_vinfo for epilogue vectorization.  */\n   poly_uint64 lowest_th = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);\n \n-  /* Handle the case that the original loop can use partial\n-     vectorization, but want to only adopt it for the epilogue.\n-     The retry should be in the same mode as original.  */\n-  if (LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (first_loop_vinfo))\n+  /* For epilogues start the analysis from the first mode.  The motivation\n+     behind starting from the beginning comes from cases where the VECTOR_MODES\n+     array may contain length-agnostic and length-specific modes.  Their\n+     ordering is not guaranteed, so we could end up picking a mode for the main\n+     loop that is after the epilogue's optimal mode.  */\n+  mode_i = 1;\n+  bool supports_partial_vectors = partial_vectors_supported_p ();\n+  poly_uint64 first_vinfo_vf = LOOP_VINFO_VECT_FACTOR (first_loop_vinfo);\n+\n+  while (1)\n     {\n-      gcc_assert (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (first_loop_vinfo)\n-\t\t  && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (first_loop_vinfo));\n+      /* If the target does not support partial vectors we can shorten the\n+\t number of modes to analyze for the epilogue as we know we can't pick a\n+\t mode that has at least as many NUNITS as the main loop's vectorization\n+\t factor, since that would imply the epilogue's vectorization factor\n+\t would be at least as high as the main loop's and we would be\n+\t vectorizing for more scalar iterations than there would be left.  */\n+      if (!supports_partial_vectors\n+\t  && maybe_ge (GET_MODE_NUNITS (vector_modes[mode_i]), first_vinfo_vf))\n+\t{\n+\t  mode_i++;\n+\t  if (mode_i == vector_modes.length ())\n+\t    break;\n+\t  continue;\n+\t}\n+\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Re-trying analysis with same vector mode\"\n-\t\t\t \" %s for epilogue with partial vectors.\\n\",\n-\t\t\t GET_MODE_NAME (first_loop_vinfo->vector_mode));\n-      mode_i = first_loop_i;\n-    }\n-  else\n-    {\n-      mode_i = first_loop_next_i;\n-      if (mode_i == vector_modes.length ())\n-\treturn first_loop_vinfo;\n-    }\n-\n-  /* ???  If first_loop_vinfo was using VOIDmode then we probably\n-     want to instead search for the corresponding mode in vector_modes[].  */\n+\t\t\t \"***** Re-trying epilogue analysis with vector \"\n+\t\t\t \"mode %s\\n\", GET_MODE_NAME (vector_modes[mode_i]));\n \n-  while (1)\n-    {\n       bool fatal;\n       opt_loop_vec_info loop_vinfo\n \t= vect_analyze_loop_1 (loop, shared, &loop_form_info,\n@@ -3102,11 +3100,6 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n       if (mode_i == vector_modes.length ())\n \tbreak;\n \n-      /* Try the next biggest vector size.  */\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Re-trying epilogue analysis with vector \"\n-\t\t\t \"mode %s\\n\", GET_MODE_NAME (vector_modes[mode_i]));\n     }\n \n   if (!first_loop_vinfo->epilogue_vinfos.is_empty ())"}, {"sha": "48eed40cae2d59b42ab520d6ca28fd6af8e5d59f", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ff7420e941931d32ce2e332e7968fe67ba20af/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d3ff7420e941931d32ce2e332e7968fe67ba20af", "patch": "@@ -1887,11 +1887,13 @@ vector_costs::better_epilogue_loop_than_p (const vector_costs *other,\n     {\n       unsigned HOST_WIDE_INT main_vf_max\n \t= estimated_poly_value (main_poly_vf, POLY_VALUE_MAX);\n+      unsigned HOST_WIDE_INT other_vf_max\n+\t= estimated_poly_value (other_vf, POLY_VALUE_MAX);\n+      unsigned HOST_WIDE_INT this_vf_max\n+\t= estimated_poly_value (this_vf, POLY_VALUE_MAX);\n \n-      other_factor = main_vf_max / estimated_poly_value (other_vf,\n-\t\t\t\t\t\t       POLY_VALUE_MAX);\n-      this_factor = main_vf_max / estimated_poly_value (this_vf,\n-\t\t\t\t\t\t       POLY_VALUE_MAX);\n+      other_factor = CEIL (main_vf_max, other_vf_max);\n+      this_factor = CEIL (main_vf_max, this_vf_max);\n \n       /* If the loop is not using partial vectors then it will iterate one\n \t time less than one that does.  It is safe to subtract one here,"}]}