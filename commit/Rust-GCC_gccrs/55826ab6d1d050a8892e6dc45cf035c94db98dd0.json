{"sha": "55826ab6d1d050a8892e6dc45cf035c94db98dd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU4MjZhYjZkMWQwNTBhODg5MmU2ZGM0NWNmMDM1Yzk0ZGI5OGRkMA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-09-24T19:53:36Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-09-24T19:53:36Z"}, "message": "re PR libstdc++/44436 ([C++0x] Implement emplace* in associative containers)\n\n2012-09-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/44436\n\t* include/bits/stl_tree.h\n\t(_Rb_tree<>::_M_insert_): Take _Base_ptr rather than\n\t_Const_Base_ptr.\n\t(_Rb_tree<>::_M_insert_node): New.\n\t(_Rb_tree<>::_M_get_insert_unique_pos): New, search code of\n\t_M_insert_unique method.\n\t(_Rb_tree<>::_M_insert_unique): Use latter.\n\t(_Rb_tree<>::_M_emplace_unique): New, likewise.\n\t(_Rb_tree<>::_M_get_insert_equal_pos): New, search code of\n\t_M_insert_equal method.\n\t(_Rb_tree<>::_M_insert_equal): Use latter.\n\t(_Rb_tree<>::_M_emplace_equal): New, likewise.\n\t(_Rb_tree<>::_M_get_insert_hint_unique_pos): New, search code of\n\t_M_insert_unique_ method.\n\t(_Rb_tree<>::_M_insert_unique_): Use latter.\n\t(_Rb_tree<>::_M_emplace_hint_unique): New, likewise.\n\t(_Rb_tree<>::_M_get_insert_hint_equal_pos): New, search code of\n\t_M_insert_equal_ method.\n\t(_Rb_tree<>::_M_insert_equal_): Use latter.\n\t(_Rb_tree<>::_M_emplace_hint_equal): New, likewise.\n\t(_Rb_tree<>::_M_insert_lower): Remove first _Base_ptr parameter,\n\tuseless as always null.\n\t* include/bits/stl_map.h: Include <tuple> in C++11.\n\t(map<>::operator[](const key_type&)): Use\n\t_Rb_tree<>::_M_emplace_hint_unique in C++11.\n\t(map<>::operator[](key_type&&)): Likewise.\n\t(map<>::emplace): New.\n\t(map<>::emplace_hint): New.\n\t* include/bits/stl_multimap.h (multimap<>::emplace): New.\n\t(multimap<>::emplace_hint): New.\n\t* include/bits/stl_set.h (set<>::emplace): New.\n\t(set<>::emplace_hint): New.\n\t* include/bits/stl_multiset.h (multiset<>::emplace): New.\n\t(multiset<>::emplace_hint): New.\n\t* include/debug/map.h (std::__debug::map<>::emplace): New.\n\t(std::__debug::map<>::emplace_hint): New.\n\t* include/debug/multimap.h (std::__debug::multimap<>::emplace):\n\tNew.\n\t(std::__debug::multimap<>::emplace_hint): New.\n\t* include/debug/set.h (std::__debug::set<>::emplace): New.\n\t(std::__debug::set<>::emplace_hint): New.\n\t* include/debug/multiset.h (std::__debug::multiset<>::emplace):\n\tNew.\n\t(std::__debug::multiset<>::emplace_hint): New.\n\t* include/profile/map.h (std::__profile::map<>::emplace): New.\n\t(std::__profile::map<>::emplace_hint): New.\n\t* include/profile/multimap.h (std::__profile::multimap<>::emplace):\n\tNew.\n\t(std::__profile::multimap<>::emplace_hint): New.\n\t* include/profile/set.h (std::__profile::set<>::emplace): New.\n\t(std::__profile::set<>::emplace_hint): New.\n\t* include/profile/multiset.h (std::__profile::multiset<>::emplace):\n\tNew.\n\t(std::__profile::multiset<>::emplace_hint): New.\n\t* testsuite/util/testsuite_container_traits.h: Signal that emplace\n\tand emplace_hint are available on std::map, std::multimap,\n\tstd::set and std::multiset in C++11.\n\t* testsuite/23_containers/map/operators/2.cc: New.\n\t* testsuite/23_containers/map/modifiers/emplace/1.cc: New.\n\t* testsuite/23_containers/multimap/modifiers/emplace/1.cc: New.\n\t* testsuite/23_containers/set/modifiers/emplace/1.cc: New.\n\t* testsuite/23_containers/multiset/modifiers/emplace/1.cc: New.\n\nFrom-SVN: r191679", "tree": {"sha": "8ceddee0b37d55ec34e134b8a27bf824da90ced6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ceddee0b37d55ec34e134b8a27bf824da90ced6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55826ab6d1d050a8892e6dc45cf035c94db98dd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55826ab6d1d050a8892e6dc45cf035c94db98dd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55826ab6d1d050a8892e6dc45cf035c94db98dd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55826ab6d1d050a8892e6dc45cf035c94db98dd0/comments", "author": null, "committer": null, "parents": [{"sha": "e6fa043b2d9cecafcedc5d1b090db5b636c9a0b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6fa043b2d9cecafcedc5d1b090db5b636c9a0b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6fa043b2d9cecafcedc5d1b090db5b636c9a0b4"}], "stats": {"total": 1393, "additions": 1277, "deletions": 116}, "files": [{"sha": "98d35510d31b3b7d489b9679b65b2bf9b9b8fa3c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -1,3 +1,69 @@\n+2012-09-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/44436\n+\t* include/bits/stl_tree.h\n+\t(_Rb_tree<>::_M_insert_): Take _Base_ptr rather than\n+\t_Const_Base_ptr.\n+\t(_Rb_tree<>::_M_insert_node): New.\n+\t(_Rb_tree<>::_M_get_insert_unique_pos): New, search code of\n+\t_M_insert_unique method.\n+\t(_Rb_tree<>::_M_insert_unique): Use latter.\n+\t(_Rb_tree<>::_M_emplace_unique): New, likewise.\n+\t(_Rb_tree<>::_M_get_insert_equal_pos): New, search code of\n+\t_M_insert_equal method.\n+\t(_Rb_tree<>::_M_insert_equal): Use latter.\n+\t(_Rb_tree<>::_M_emplace_equal): New, likewise.\n+\t(_Rb_tree<>::_M_get_insert_hint_unique_pos): New, search code of\n+\t_M_insert_unique_ method.\n+\t(_Rb_tree<>::_M_insert_unique_): Use latter.\n+\t(_Rb_tree<>::_M_emplace_hint_unique): New, likewise.\n+\t(_Rb_tree<>::_M_get_insert_hint_equal_pos): New, search code of\n+\t_M_insert_equal_ method.\n+\t(_Rb_tree<>::_M_insert_equal_): Use latter.\n+\t(_Rb_tree<>::_M_emplace_hint_equal): New, likewise.\n+\t(_Rb_tree<>::_M_insert_lower): Remove first _Base_ptr parameter,\n+\tuseless as always null.\n+\t* include/bits/stl_map.h: Include <tuple> in C++11.\n+\t(map<>::operator[](const key_type&)): Use\n+\t_Rb_tree<>::_M_emplace_hint_unique in C++11.\n+\t(map<>::operator[](key_type&&)): Likewise.\n+\t(map<>::emplace): New.\n+\t(map<>::emplace_hint): New.\n+\t* include/bits/stl_multimap.h (multimap<>::emplace): New.\n+\t(multimap<>::emplace_hint): New.\n+\t* include/bits/stl_set.h (set<>::emplace): New.\n+\t(set<>::emplace_hint): New.\n+\t* include/bits/stl_multiset.h (multiset<>::emplace): New.\n+\t(multiset<>::emplace_hint): New.\n+\t* include/debug/map.h (std::__debug::map<>::emplace): New.\n+\t(std::__debug::map<>::emplace_hint): New.\n+\t* include/debug/multimap.h (std::__debug::multimap<>::emplace):\n+\tNew.\n+\t(std::__debug::multimap<>::emplace_hint): New.\n+\t* include/debug/set.h (std::__debug::set<>::emplace): New.\n+\t(std::__debug::set<>::emplace_hint): New.\n+\t* include/debug/multiset.h (std::__debug::multiset<>::emplace):\n+\tNew.\n+\t(std::__debug::multiset<>::emplace_hint): New.\n+\t* include/profile/map.h (std::__profile::map<>::emplace): New.\n+\t(std::__profile::map<>::emplace_hint): New.\n+\t* include/profile/multimap.h (std::__profile::multimap<>::emplace):\n+\tNew.\n+\t(std::__profile::multimap<>::emplace_hint): New.\n+\t* include/profile/set.h (std::__profile::set<>::emplace): New.\n+\t(std::__profile::set<>::emplace_hint): New.\n+\t* include/profile/multiset.h (std::__profile::multiset<>::emplace):\n+\tNew.\n+\t(std::__profile::multiset<>::emplace_hint): New.\n+\t* testsuite/util/testsuite_container_traits.h: Signal that emplace\n+\tand emplace_hint are available on std::map, std::multimap,\n+\tstd::set and std::multiset in C++11.\n+\t* testsuite/23_containers/map/operators/2.cc: New.\n+\t* testsuite/23_containers/map/modifiers/emplace/1.cc: New.\n+\t* testsuite/23_containers/multimap/modifiers/emplace/1.cc: New.\n+\t* testsuite/23_containers/set/modifiers/emplace/1.cc: New.\n+\t* testsuite/23_containers/multiset/modifiers/emplace/1.cc: New.\n+\n 2012-09-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* testsuite/performance/23_containers/insert_erase/41975.cc: Use"}, {"sha": "14f44579a4f3f7f2ceb30caeb3539fd139ee1d82", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -61,6 +61,7 @@\n #include <bits/concept_check.h>\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <initializer_list>\n+#include <tuple>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -461,7 +462,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \titerator __i = lower_bound(__k);\n \t// __i->first is greater than or equivalent to __k.\n \tif (__i == end() || key_comp()(__k, (*__i).first))\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+\t  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,\n+\t\t\t\t\t    std::tuple<const key_type&>(__k),\n+\t\t\t\t\t    std::tuple<>());\n+#else\n           __i = insert(__i, value_type(__k, mapped_type()));\n+#endif\n \treturn (*__i).second;\n       }\n \n@@ -475,7 +482,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \titerator __i = lower_bound(__k);\n \t// __i->first is greater than or equivalent to __k.\n \tif (__i == end() || key_comp()(__k, (*__i).first))\n-          __i = insert(__i, std::make_pair(std::move(__k), mapped_type()));\n+\t  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,\n+\t\t\t\t\tstd::forward_as_tuple(std::move(__k)),\n+\t\t\t\t\tstd::tuple<>());\n \treturn (*__i).second;\n       }\n #endif\n@@ -508,6 +517,64 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       }\n \n       // modifiers\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the %map.\n+       *\n+       *  @param __args  Arguments used to generate a new pair instance (see\n+       *\t        std::piecewise_contruct for passing arguments to each\n+       *\t        part of the pair constructor).\n+       *\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted pair, and the second is a bool that\n+       *           is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to build and insert a (key, value) %pair into\n+       *  the %map.\n+       *  A %map relies on unique keys and thus a %pair is only inserted if its\n+       *  first element (the key) is not already present in the %map.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the %map.\n+       *\n+       *  @param  __pos  An iterator that serves as a hint as to where the pair\n+       *                should be inserted.\n+       *  @param  __args  Arguments used to generate a new pair instance (see\n+       *\t         std::piecewise_contruct for passing arguments to each\n+       *\t         part of the pair constructor).\n+       *  @return An iterator that points to the element with key of the\n+       *          std::pair built from @a __args (may or may not be that\n+       *          std::pair).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument emplace()\n+       *  does.\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process. A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  return _M_t._M_emplace_hint_unique(__pos,\n+\t\t\t\t\t     std::forward<_Args>(__args)...);\n+\t}\n+#endif\n+\n       /**\n        *  @brief Attempts to insert a std::pair into the %map.\n "}, {"sha": "a0fb27e219290f66e44637ff5b81de8de0a9fff7", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -108,7 +108,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n-      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)\t\n+      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)\n \n     public:\n       class value_compare\n@@ -433,6 +433,59 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return _M_t.max_size(); }\n \n       // modifiers\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief Build and insert a std::pair into the %multimap.\n+       *\n+       *  @param __args  Arguments used to generate a new pair instance (see\n+       *\t        std::piecewise_contruct for passing arguments to each\n+       *\t        part of the pair constructor).\n+       *\n+       *  @return An iterator that points to the inserted (key,value) pair.\n+       *\n+       *  This function builds and inserts a (key, value) %pair into the\n+       *  %multimap.\n+       *  Contrary to a std::map the %multimap does not rely on unique keys and\n+       *  thus multiple pairs with the same key can be inserted.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{ return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Builds and inserts a std::pair into the %multimap.\n+       *\n+       *  @param  __pos  An iterator that serves as a hint as to where the pair\n+       *                should be inserted.\n+       *  @param  __args  Arguments used to generate a new pair instance (see\n+       *\t         std::piecewise_contruct for passing arguments to each\n+       *\t         part of the pair constructor).\n+       *  @return An iterator that points to the inserted (key,value) pair.\n+       *\n+       *  This function inserts a (key, value) pair into the %multimap.\n+       *  Contrary to a std::map the %multimap does not rely on unique keys and\n+       *  thus multiple pairs with the same key can be inserted.\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process.  A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  For more on @a hinting, see:\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  return _M_t._M_emplace_hint_equal(__pos,\n+\t\t\t\t\t    std::forward<_Args>(__args)...);\n+\t}\n+#endif\n+\n       /**\n        *  @brief Inserts a std::pair into the %multimap.\n        *  @param  __x  Pair to be inserted (see std::make_pair for easy creation"}, {"sha": "2448742356aac8ddee8eb5127c1609e18a3a7a6f", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -1,7 +1,7 @@\n // Multiset implementation -*- C++ -*-\n \n // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-// 2011 Free Software Foundation, Inc.\n+// 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -392,6 +392,54 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief Builds and inserts an element into the %multiset.\n+       *  @param  __args  Arguments used to generate the element instance to be\n+       *                 inserted.\n+       *  @return An iterator that points to the inserted element.\n+       *\n+       *  This function inserts an element into the %multiset.  Contrary\n+       *  to a std::set the %multiset does not rely on unique keys and thus\n+       *  multiple copies of the same element can be inserted.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{ return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Builds and inserts an element into the %multiset.\n+       *  @param  __pos  An iterator that serves as a hint as to where the\n+       *                element should be inserted.\n+       *  @param  __args  Arguments used to generate the element instance to be\n+       *                 inserted.\n+       *  @return An iterator that points to the inserted element.\n+       *\n+       *  This function inserts an element into the %multiset.  Contrary\n+       *  to a std::set the %multiset does not rely on unique keys and thus\n+       *  multiple copies of the same element can be inserted.\n+       *\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process.  A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  return _M_t._M_emplace_hint_equal(__pos,\n+\t\t\t\t\t    std::forward<_Args>(__args)...);\n+\t}\n+#endif\n+\n       /**\n        *  @brief Inserts an element into the %multiset.\n        *  @param  __x  Element to be inserted."}, {"sha": "c3c187086d6f65374fb924e89930139357d0ae5e", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -1,7 +1,7 @@\n // Set implementation -*- C++ -*-\n \n // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-// 2011 Free Software Foundation, Inc.\n+// 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -395,6 +395,55 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      /**\n+       *  @brief Attempts to build and insert an element into the %set.\n+       *  @param __args  Arguments used to generate an element.\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted element, and the second is a bool\n+       *           that is true if the element was actually inserted.\n+       *\n+       *  This function attempts to build and insert an element into the %set.\n+       *  A %set relies on unique keys and thus an element is only inserted if\n+       *  it is not already present in the %set.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief Attempts to insert an element into the %set.\n+       *  @param  __pos  An iterator that serves as a hint as to where the\n+       *                element should be inserted.\n+       *  @param  __args  Arguments used to generate the element to be\n+       *                 inserted.\n+       *  @return An iterator that points to the element with key equivalent to\n+       *          the one generated from @a __args (may or may not be the\n+       *          element itself).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument emplace()\n+       *  does.  Note that the first parameter is only a hint and can\n+       *  potentially improve the performance of the insertion process.  A bad\n+       *  hint would cause no gains in efficiency.\n+       *\n+       *  For more on @a hinting, see:\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  return _M_t._M_emplace_hint_unique(__pos,\n+\t\t\t\t\t     std::forward<_Args>(__args)...);\n+\t}\n+#endif\n+\n       /**\n        *  @brief Attempts to insert an element into the %set.\n        *  @param  __x  Element to be inserted."}, {"sha": "f2adb962c2998814b2fc138ec2f705045b04e0ff", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 354, "deletions": 111, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -570,27 +570,50 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n \n     private:\n+      pair<_Base_ptr, _Base_ptr>\n+      _M_get_insert_unique_pos(const key_type& __k);\n+\n+      pair<_Base_ptr, _Base_ptr>\n+      _M_get_insert_equal_pos(const key_type& __k);\n+\n+      pair<_Base_ptr, _Base_ptr>\n+      _M_get_insert_hint_unique_pos(const_iterator __pos,\n+\t\t\t\t    const key_type& __k);\n+\n+      pair<_Base_ptr, _Base_ptr>\n+      _M_get_insert_hint_equal_pos(const_iterator __pos,\n+\t\t\t\t   const key_type& __k);\n+\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       template<typename _Arg>\n         iterator\n-        _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y, _Arg&& __v);\n+        _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v);\n+\n+      iterator\n+      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);\n \n       template<typename _Arg>\n         iterator\n-        _M_insert_lower(_Base_ptr __x, _Base_ptr __y, _Arg&& __v);\n+        _M_insert_lower(_Base_ptr __y, _Arg&& __v);\n \n       template<typename _Arg>\n         iterator\n         _M_insert_equal_lower(_Arg&& __x);\n+\n+      iterator\n+      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);\n+\n+      iterator\n+      _M_insert_equal_lower_node(_Link_type __z);\n #else\n       iterator\n-      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,\n+      _M_insert_(_Base_ptr __x, _Base_ptr __y,\n \t\t const value_type& __v);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 233. Insertion hints in associative containers.\n       iterator\n-      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n+      _M_insert_lower(_Base_ptr __y, const value_type& __v);\n \n       iterator\n       _M_insert_equal_lower(const value_type& __x);\n@@ -726,6 +749,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Arg>\n         iterator\n         _M_insert_equal_(const_iterator __position, _Arg&& __x);\n+\n+      template<typename... _Args>\n+\tpair<iterator, bool>\n+\t_M_emplace_unique(_Args&&... __args);\n+\n+      template<typename... _Args>\n+\titerator\n+\t_M_emplace_equal(_Args&&... __args);\n+\n+      template<typename... _Args>\n+\titerator\n+\t_M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);\n+\n+      template<typename... _Args>\n+\titerator\n+\t_M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);\n #else\n       pair<iterator, bool>\n       _M_insert_unique(const value_type& __x);\n@@ -967,19 +1006,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, _Arg&& __v)\n+    _M_insert_(_Base_ptr __x, _Base_ptr __p, _Arg&& __v)\n #else\n-    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)\n+    _M_insert_(_Base_ptr __x, _Base_ptr __p, const _Val& __v)\n #endif\n     {\n       bool __insert_left = (__x != 0 || __p == _M_end()\n-\t\t\t    || _M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t    || _M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t\t      _S_key(__p)));\n \n       _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));\n \n-      _Rb_tree_insert_and_rebalance(__insert_left, __z,\n-\t\t\t\t    const_cast<_Base_ptr>(__p),  \n+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,\n \t\t\t\t    this->_M_impl._M_header);\n       ++_M_impl._M_node_count;\n       return iterator(__z);\n@@ -993,18 +1031,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, _Arg&& __v)\n+    _M_insert_lower(_Base_ptr __p, _Arg&& __v)\n #else\n-    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)\n+    _M_insert_lower(_Base_ptr __p, const _Val& __v)\n #endif\n     {\n-      bool __insert_left = (__x != 0 || __p == _M_end()\n+      bool __insert_left = (__p == _M_end()\n \t\t\t    || !_M_impl._M_key_compare(_S_key(__p),\n \t\t\t\t\t\t       _KeyOfValue()(__v)));\n \n       _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));\n \n-      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  \n+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,\n \t\t\t\t    this->_M_impl._M_header);\n       ++_M_impl._M_node_count;\n       return iterator(__z);\n@@ -1031,7 +1069,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?\n \t        _S_left(__x) : _S_right(__x);\n \t}\n-      return _M_insert_lower(__x, __y, _GLIBCXX_FORWARD(_Arg, __v));\n+      return _M_insert_lower(__y, _GLIBCXX_FORWARD(_Arg, __v));\n     }\n \n   template<typename _Key, typename _Val, typename _KoV,\n@@ -1264,64 +1302,81 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    template<typename _Arg>\n-#endif\n     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n-\t\t\t   _Compare, _Alloc>::iterator, bool>\n+\t\t\t   _Compare, _Alloc>::_Base_ptr,\n+\t typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::_Base_ptr>\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    _M_insert_unique(_Arg&& __v)\n-#else\n-    _M_insert_unique(const _Val& __v)\n-#endif\n+    _M_get_insert_unique_pos(const key_type& __k)\n     {\n+      typedef pair<_Base_ptr, _Base_ptr> _Res;\n       _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n       bool __comp = true;\n       while (__x != 0)\n \t{\n \t  __y = __x;\n-\t  __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));\n+\t  __comp = _M_impl._M_key_compare(__k, _S_key(__x));\n \t  __x = __comp ? _S_left(__x) : _S_right(__x);\n \t}\n       iterator __j = iterator(__y);\n       if (__comp)\n \t{\n \t  if (__j == begin())\n-\t    return pair<iterator, bool>\n-\t      (_M_insert_(__x, __y, _GLIBCXX_FORWARD(_Arg, __v)), true);\n+\t    return _Res(__x, __y);\n \t  else\n \t    --__j;\n \t}\n-      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n-\treturn pair<iterator, bool>\n-\t  (_M_insert_(__x, __y, _GLIBCXX_FORWARD(_Arg, __v)), true);\n-      return pair<iterator, bool>(__j, false);\n+      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))\n+\treturn _Res(__x, __y);\n+      return _Res(__j._M_node, 0);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    template<typename _Arg>\n-#endif\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::_Base_ptr,\n+\t typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::_Base_ptr>\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    _M_insert_equal(_Arg&& __v)\n-#else\n-    _M_insert_equal(const _Val& __v)\n-#endif\n+    _M_get_insert_equal_pos(const key_type& __k)\n     {\n+      typedef pair<_Base_ptr, _Base_ptr> _Res;\n       _Link_type __x = _M_begin();\n       _Link_type __y = _M_end();\n       while (__x != 0)\n \t{\n \t  __y = __x;\n-\t  __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n+\t  __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?\n \t        _S_left(__x) : _S_right(__x);\n \t}\n-      return _M_insert_(__x, __y, _GLIBCXX_FORWARD(_Arg, __v));\n+      return _Res(__x, __y);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::iterator, bool>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_unique(_Arg&& __v)\n+#else\n+    _M_insert_unique(const _Val& __v)\n+#endif\n+    {\n+      typedef pair<iterator, bool> _Res;\n+      pair<_Base_ptr, _Base_ptr> __res\n+\t= _M_get_insert_unique_pos(_KeyOfValue()(__v));\n+\n+      if (__res.second)\n+\treturn _Res(_M_insert_(__res.first, __res.second,\n+\t\t\t       _GLIBCXX_FORWARD(_Arg, __v)),\n+\t\t    true);\n+\n+      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1332,67 +1387,73 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    _M_insert_unique_(const_iterator __position, _Arg&& __v)\n+    _M_insert_equal(_Arg&& __v)\n #else\n-    _M_insert_unique_(const_iterator __position, const _Val& __v)\n+    _M_insert_equal(const _Val& __v)\n #endif\n     {\n+      pair<_Base_ptr, _Base_ptr> __res\n+\t= _M_get_insert_equal_pos(_KeyOfValue()(__v));\n+      return _M_insert_(__res.first, __res.second, _GLIBCXX_FORWARD(_Arg, __v));\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::_Base_ptr,\n+         typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::_Base_ptr>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_get_insert_hint_unique_pos(const_iterator __position,\n+\t\t\t\t  const key_type& __k)\n+    {\n+      iterator __pos = __position._M_const_cast();\n+      typedef pair<_Base_ptr, _Base_ptr> _Res;\n+\n       // end()\n-      if (__position._M_node == _M_end())\n+      if (__pos._M_node == _M_end())\n \t{\n \t  if (size() > 0\n-\t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), \n-\t\t\t\t\t_KeyOfValue()(__v)))\n-\t    return _M_insert_(0, _M_rightmost(), _GLIBCXX_FORWARD(_Arg, __v));\n+\t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))\n+\t    return _Res(0, _M_rightmost());\n \t  else\n-\t    return _M_insert_unique(_GLIBCXX_FORWARD(_Arg, __v)).first;\n+\t    return _M_get_insert_unique_pos(__k);\n \t}\n-      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t      _S_key(__position._M_node)))\n+      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))\n \t{\n \t  // First, try before...\n-\t  const_iterator __before = __position;\n-\t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert_(_M_leftmost(), _M_leftmost(),\n-\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n-\t  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), \n-\t\t\t\t\t  _KeyOfValue()(__v)))\n+\t  iterator __before = __pos;\n+\t  if (__pos._M_node == _M_leftmost()) // begin()\n+\t    return _Res(_M_leftmost(), _M_leftmost());\n+\t  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert_(0, __before._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t\treturn _Res(0, __before._M_node);\n \t      else\n-\t\treturn _M_insert_(__position._M_node,\n-\t\t\t\t  __position._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t\treturn _Res(__pos._M_node, __pos._M_node);\n \t    }\n \t  else\n-\t    return _M_insert_unique(_GLIBCXX_FORWARD(_Arg, __v)).first;\n+\t    return _M_get_insert_unique_pos(__k);\n \t}\n-      else if (_M_impl._M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t      _KeyOfValue()(__v)))\n+      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))\n \t{\n \t  // ... then try after.\n-\t  const_iterator __after = __position;\n-\t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert_(0, _M_rightmost(),\n-\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n-\t  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t  _S_key((++__after)._M_node)))\n+\t  iterator __after = __pos;\n+\t  if (__pos._M_node == _M_rightmost())\n+\t    return _Res(0, _M_rightmost());\n+\t  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))\n \t    {\n-\t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert_(0, __position._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t      if (_S_right(__pos._M_node) == 0)\n+\t\treturn _Res(0, __pos._M_node);\n \t      else\n-\t\treturn _M_insert_(__after._M_node, __after._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t\treturn _Res(__after._M_node, __after._M_node);\n \t    }\n \t  else\n-\t    return _M_insert_unique(_GLIBCXX_FORWARD(_Arg, __v)).first;\n+\t    return _M_get_insert_unique_pos(__k);\n \t}\n       else\n \t// Equivalent keys.\n-\treturn __position._M_const_cast();\n+\treturn _Res(__pos._M_node, 0);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1403,66 +1464,248 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-    _M_insert_equal_(const_iterator __position, _Arg&& __v)\n+    _M_insert_unique_(const_iterator __position, _Arg&& __v)\n #else\n-    _M_insert_equal_(const_iterator __position, const _Val& __v)\n+    _M_insert_unique_(const_iterator __position, const _Val& __v)\n #endif\n     {\n+      pair<_Base_ptr, _Base_ptr> __res\n+\t= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));\n+\n+      if (__res.second)\n+\treturn _M_insert_(__res.first, __res.second,\n+\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+      return iterator(static_cast<_Link_type>(__res.first));\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::_Base_ptr,\n+         typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::_Base_ptr>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)\n+    {\n+      iterator __pos = __position._M_const_cast();\n+      typedef pair<_Base_ptr, _Base_ptr> _Res;\n+\n       // end()\n-      if (__position._M_node == _M_end())\n+      if (__pos._M_node == _M_end())\n \t{\n \t  if (size() > 0\n-\t      && !_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t _S_key(_M_rightmost())))\n-\t    return _M_insert_(0, _M_rightmost(),\n-\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n+\t      && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))\n+\t    return _Res(0, _M_rightmost());\n \t  else\n-\t    return _M_insert_equal(_GLIBCXX_FORWARD(_Arg, __v));\n+\t    return _M_get_insert_equal_pos(__k);\n \t}\n-      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t       _KeyOfValue()(__v)))\n+      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))\n \t{\n \t  // First, try before...\n-\t  const_iterator __before = __position;\n-\t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert_(_M_leftmost(), _M_leftmost(),\n-\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n-\t  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t   _S_key((--__before)._M_node)))\n+\t  iterator __before = __pos;\n+\t  if (__pos._M_node == _M_leftmost()) // begin()\n+\t    return _Res(_M_leftmost(), _M_leftmost());\n+\t  else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert_(0, __before._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t\treturn _Res(0, __before._M_node);\n \t      else\n-\t\treturn _M_insert_(__position._M_node,\n-\t\t\t\t  __position._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t\treturn _Res(__pos._M_node, __pos._M_node);\n \t    }\n \t  else\n-\t    return _M_insert_equal(_GLIBCXX_FORWARD(_Arg, __v));\n+\t    return _M_get_insert_equal_pos(__k);\n \t}\n       else\n \t{\n \t  // ... then try after.  \n-\t  const_iterator __after = __position;\n-\t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert_(0, _M_rightmost(),\n-\t\t\t      _GLIBCXX_FORWARD(_Arg, __v));\n-\t  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),\n-\t\t\t\t\t   _KeyOfValue()(__v)))\n+\t  iterator __after = __pos;\n+\t  if (__pos._M_node == _M_rightmost())\n+\t    return _Res(0, _M_rightmost());\n+\t  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))\n \t    {\n-\t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert_(0, __position._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t      if (_S_right(__pos._M_node) == 0)\n+\t\treturn _Res(0, __pos._M_node);\n \t      else\n-\t\treturn _M_insert_(__after._M_node, __after._M_node,\n-\t\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\t\treturn _Res(__after._M_node, __after._M_node);\n \t    }\n \t  else\n-\t    return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));\n+\t    return _Res(0, 0);\n \t}\n     }\n \n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    template<typename _Arg>\n+#endif\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    _M_insert_equal_(const_iterator __position, _Arg&& __v)\n+#else\n+    _M_insert_equal_(const_iterator __position, const _Val& __v)\n+#endif\n+    {\n+      pair<_Base_ptr, _Base_ptr> __res\n+\t= _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));\n+\n+      if (__res.second)\n+\treturn _M_insert_(__res.first, __res.second,\n+\t\t\t  _GLIBCXX_FORWARD(_Arg, __v));\n+\n+      return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));\n+    }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)\n+    {\n+      bool __insert_left = (__x != 0 || __p == _M_end()\n+\t\t\t    || _M_impl._M_key_compare(_S_key(__z),\n+\t\t\t\t\t\t      _S_key(__p)));\n+\n+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,\n+\t\t\t\t    this->_M_impl._M_header);\n+      ++_M_impl._M_node_count;\n+      return iterator(__z);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)\n+    {\n+      bool __insert_left = (__p == _M_end()\n+\t\t\t    || !_M_impl._M_key_compare(_S_key(__p),\n+\t\t\t\t\t\t       _S_key(__z)));\n+\n+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,\n+\t\t\t\t    this->_M_impl._M_header);\n+      ++_M_impl._M_node_count;\n+      return iterator(__z);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_insert_equal_lower_node(_Link_type __z)\n+    {\n+      _Link_type __x = _M_begin();\n+      _Link_type __y = _M_end();\n+      while (__x != 0)\n+\t{\n+\t  __y = __x;\n+\t  __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?\n+\t        _S_left(__x) : _S_right(__x);\n+\t}\n+      return _M_insert_lower_node(__y, __z);\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    template<typename... _Args>\n+      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t     _Compare, _Alloc>::iterator, bool>\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_emplace_unique(_Args&&... __args)\n+      {\n+\t_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);\n+\n+\t__try\n+\t  {\n+\t    typedef pair<iterator, bool> _Res;\n+\t    auto __res = _M_get_insert_unique_pos(_S_key(__z));\n+\t    if (__res.second)\n+\t      return _Res(_M_insert_node(__res.first, __res.second, __z), true);\n+\t\n+\t    _M_destroy_node(__z);\n+\t    return _Res(iterator(static_cast<_Link_type>(__res.first)), false);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_destroy_node(__z);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    template<typename... _Args>\n+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_emplace_equal(_Args&&... __args)\n+      {\n+\t_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);\n+\n+\t__try\n+\t  {\n+\t    auto __res = _M_get_insert_equal_pos(_S_key(__z));\n+\t    return _M_insert_node(__res.first, __res.second, __z);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_destroy_node(__z);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    template<typename... _Args>\n+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)\n+      {\n+\t_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);\n+\n+\t__try\n+\t  {\n+\t    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));\n+\n+\t    if (__res.second)\n+\t      return _M_insert_node(__res.first, __res.second, __z);\n+\n+\t    _M_destroy_node(__z);\n+\t    return iterator(static_cast<_Link_type>(__res.first));\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_destroy_node(__z);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    template<typename... _Args>\n+      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)\n+      {\n+\t_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);\n+\n+\t__try\n+\t  {\n+\t    auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));\n+\n+\t    if (__res.second)\n+\t      return _M_insert_node(__res.first, __res.second, __z);\n+\n+\t    return _M_insert_equal_lower_node(__z);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_destroy_node(__z);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+#endif\n+\n   template<typename _Key, typename _Val, typename _KoV,\n            typename _Cmp, typename _Alloc>\n     template<class _II>"}, {"sha": "254988c2c6401554ad6b3bf197054ee62155da1f", "filename": "libstdc++-v3/include/debug/map.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -203,6 +203,27 @@ namespace __debug\n       using _Base::at;\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{\n+\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  return std::pair<iterator, bool>(iterator(__res.first, this),\n+\t\t\t\t\t   __res.second);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__pos);\n+\t  return iterator(_Base::emplace_hint(__pos.base(),\n+\t\t\t\t\t      std::forward<_Args>(__args)...),\n+\t\t\t  this);\n+\t}\n+#endif\n+\n       std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {"}, {"sha": "e46a7427345af4ee7aa9765f7548738a8c62cc48", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -195,6 +195,25 @@ namespace __debug\n       using _Base::max_size;\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{\n+\t  return iterator(_Base::emplace(std::forward<_Args>(__args)...), this);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__pos);\n+\t  return iterator(_Base::emplace_hint(__pos.base(),\n+\t\t\t\t\t      std::forward<_Args>(__args)...),\n+\t\t\t  this);\n+\t}\n+#endif\n+      \n       iterator\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x), this); }"}, {"sha": "04598464abd0eda27bccb0a918576998852a5572", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -194,6 +194,25 @@ namespace __debug\n       using _Base::max_size;\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{\n+\t  return iterator(_Base::emplace(std::forward<_Args>(__args)...), this);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__pos);\n+\t  return iterator(_Base::emplace_hint(__pos.base(),\n+\t\t\t\t\t      std::forward<_Args>(__args)...),\n+\t\t\t  this);\n+\t}\n+#endif\n+\n       iterator\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x), this); }"}, {"sha": "44cbe941732a1570244d0eac3dbe83489c6048f5", "filename": "libstdc++-v3/include/debug/set.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -194,6 +194,27 @@ namespace __debug\n       using _Base::max_size;\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{\n+\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  return std::pair<iterator, bool>(iterator(__res.first, this),\n+\t\t\t\t\t   __res.second);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert(__pos);\n+\t  return iterator(_Base::emplace_hint(__pos.base(),\n+\t\t\t\t\t      std::forward<_Args>(__args)...),\n+\t\t\t  this);\n+\t}\n+#endif\n+\n       std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {"}, {"sha": "cc01d901cb0f3106d1b0ae3bfc4f3b76a6d1dd04", "filename": "libstdc++-v3/include/profile/map.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmap.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -236,6 +236,29 @@ namespace __profile\n       }\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{\n+\t  __profcxx_map_to_unordered_map_insert(this, size(), 1);\n+\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  return std::pair<iterator, bool>(iterator(__res.first),\n+\t\t\t\t\t   __res.second);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  size_type size_before = size();\n+\t  auto __res = _Base::emplace_hint(__pos.base(),\n+\t\t\t\t\t   std::forward<_Args>(__args)...));\n+\t  __profcxx_map_to_unordered_map_insert(this, size_before,\n+\t\t\t\t\t\tsize() - size_before);\n+\t}\n+#endif\n+\n       std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {\n@@ -282,7 +305,7 @@ namespace __profile\n       {\n         size_type size_before = size();\n \titerator __i = iterator(_Base::insert(__position, __x));\n-        __profcxx_map_to_unordered_map_insert(this, size_before, \n+        __profcxx_map_to_unordered_map_insert(this, size_before,\n \t\t\t\t\t      size() - size_before);\n \treturn __i;\n       }"}, {"sha": "2268161365b79acc63d6d113a8d268ddcc9975cb", "filename": "libstdc++-v3/include/profile/multimap.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultimap.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -180,6 +180,23 @@ namespace __profile\n       using _Base::max_size;\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{\n+\t  return iterator(_Base::emplace(std::forward<_Args>(__args)...));\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  return iterator(_Base::emplace_hint(__pos,\n+\t\t\t\t\t      std::forward<_Args>(__args)...));\n+\t}\n+#endif\n+      \n       iterator\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x)); }"}, {"sha": "f76b4fac6d87bc3ecbed0a6d33c3e87bc5b88ca8", "filename": "libstdc++-v3/include/profile/multiset.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fmultiset.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -180,6 +180,21 @@ namespace __profile\n       using _Base::max_size;\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\titerator\n+\templace(_Args&&... __args)\n+\t{ return iterator(_Base::emplace(std::forward<_Args>(__args)...)); }\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  return iterator(_Base::emplace_hint(__pos,\n+\t\t\t\t\t      std::forward<_Args>(__args)...));\n+\t}\n+#endif\n+\n       iterator\n       insert(const value_type& __x)\n       { return iterator(_Base::insert(__x)); }"}, {"sha": "c0aa180893fd054a283e4be7e3e9b0c83bf1ce08", "filename": "libstdc++-v3/include/profile/set.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fset.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -180,6 +180,25 @@ namespace __profile\n       using _Base::max_size;\n \n       // modifiers:\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+\tstd::pair<iterator, bool>\n+\templace(_Args&&... __args)\n+\t{\n+\t  auto __res = _Base::emplace(std::forward<_Args>(__args)...);\n+\t  return std::pair<iterator, bool>(iterator(__res.first),\n+\t\t\t\t\t   __res.second);\n+\t}\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_hint(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  return iterator(_Base::emplace_hint(__pos,\n+\t\t\t\t\t      std::forward<_Args>(__args)...));\n+\t}\n+#endif\n+\n       std::pair<iterator, bool>\n       insert(const value_type& __x)\n       {"}, {"sha": "bd2560439d406118dbf6df4d8a4fdd24b29d7963", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/emplace/1.cc", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Femplace%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Femplace%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Femplace%2F1.cc?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -0,0 +1,114 @@\n+// { dg-options \"-std=c++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+#include <tuple>\n+#include <vector>\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+    : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+    : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::map<char, std::vector<double>> Map;\n+  Map m;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto ret = m.emplace('a', coord1);\n+  VERIFY( ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  ret = m.emplace('a', coord1);\n+  VERIFY( !ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+  VERIFY( ret.first->second[0] == 0.0 );\n+\n+  auto it = m.emplace_hint(m.begin(), 'b', coord1);\n+  VERIFY( it != m.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  ret = m.emplace('c', std::move(coord1));\n+  VERIFY( ret.second );\n+  VERIFY( ret.first->first == 'c' );\n+  VERIFY( &(ret.first->second[0]) == px );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+  typedef map<char, PathPoint> Map;\n+  Map m;\n+\n+  vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto ret = m.emplace(piecewise_construct,\n+\t\t       make_tuple('a'), make_tuple('a', coord1));\n+  VERIFY( ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  ret = m.emplace(piecewise_construct,\n+\t\t  make_tuple('a'), make_tuple( 'b', coord1));\n+  VERIFY( !ret.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( ret.first->first == 'a' );\n+  VERIFY( ret.first->second.getCoords()[0] == 0.0 );\n+\n+  auto it = m.emplace_hint(m.begin(), piecewise_construct,\n+\t\t\t   make_tuple('b'), make_tuple('c', coord1));\n+  VERIFY( it != m.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second.getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  ret = m.emplace(piecewise_construct,\n+\t\t  make_tuple('c'), make_tuple('d', move(coord1)));\n+  VERIFY( ret.second );\n+  VERIFY( ret.first->first == 'c' );\n+  VERIFY( &(ret.first->second.getCoords()[0]) == px );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "0d8a183d8ea75909b7dc97b943260c673a3f3185", "filename": "libstdc++-v3/testsuite/23_containers/map/operators/2.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F2.cc?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -0,0 +1,87 @@\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This test verifies that the value type of a map need not be default copyable.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+#include <testsuite_counter_type.h>\n+\n+struct Mapped\n+{\n+  Mapped() = default;\n+  explicit Mapped(const Mapped&) = default;\n+};\n+\n+struct DefaultConstructibleType\n+{\n+  int val;\n+\n+  DefaultConstructibleType() : val(123)\n+  {}\n+\n+  DefaultConstructibleType(const DefaultConstructibleType&) = delete;\n+  DefaultConstructibleType(DefaultConstructibleType&&) = delete;\n+\n+  DefaultConstructibleType& operator=(int x)\n+  {\n+    val = x;\n+    return *this;\n+  }\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using __gnu_test::rvalstruct;\n+  using __gnu_test::counter_type;\n+\n+  std::map<int, Mapped> m1;\n+  m1[0] = Mapped();\n+\n+  std::map<int, rvalstruct> m2;\n+  m2[0] = rvalstruct(13);\n+\n+  std::map<int, DefaultConstructibleType> m3;\n+  VERIFY( m3[0].val == 123 );\n+  VERIFY( m3.size() == 1 );\n+  m3[0] = 2;\n+  VERIFY( m3[0].val == 2 );\n+\n+  std::map<counter_type, int> m4;\n+  VERIFY( m4[counter_type(1)] == 0 );\n+  VERIFY( counter_type::specialize_count == 1 );\n+  VERIFY( counter_type::copy_count == 0 );\n+  VERIFY( counter_type::move_count == 1 );\n+  \n+  counter_type k(2);\n+  counter_type::reset();\n+\n+  VERIFY( m4[k] == 0 );\n+  VERIFY( counter_type::copy_count == 1 );\n+  VERIFY( counter_type::move_count == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "71ca8a91d7616983ec4fb175061721331087ab68", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/emplace/1.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Femplace%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Femplace%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Femplace%2F1.cc?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=c++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+#include <vector>\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+  : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+  : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::multimap<char, std::vector<double>> MMap;\n+  MMap mm;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto it = mm.emplace('a', coord1);\n+  VERIFY( mm.size() == 1 );\n+  VERIFY( it->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  it = mm.emplace('a', coord1);\n+  VERIFY( mm.size() == 2 );\n+  VERIFY( it->first == 'a' );\n+  VERIFY( it->second[0] == 3.0 );\n+\n+  it = mm.emplace_hint(mm.begin(), 'b', coord1);\n+  VERIFY( it != mm.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  it = mm.emplace('c', std::move(coord1));\n+  VERIFY( it->first == 'c' );\n+  VERIFY( &(it->second[0]) == px );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+  typedef multimap<char, PathPoint> Map;\n+  Map m;\n+\n+  vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto it = m.emplace(piecewise_construct,\n+\t\t      make_tuple('a'), make_tuple('a', coord1));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( it->first == 'a' );\n+\n+  coord1[0] = 3.0;\n+  it = m.emplace(piecewise_construct,\n+\t\t  make_tuple('a'), make_tuple( 'b', coord1));\n+  VERIFY( m.size() == 2 );\n+  VERIFY( it->first == 'a' );\n+  VERIFY( it->second.getCoords()[0] == 3.0 );\n+\n+  it = m.emplace_hint(m.begin(), piecewise_construct,\n+\t\t      make_tuple('b'), make_tuple('c', coord1));\n+  VERIFY( it != m.end() );\n+  VERIFY( it->first == 'b' );\n+  VERIFY( it->second.getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  it = m.emplace(piecewise_construct,\n+\t\t  make_tuple('c'), make_tuple('d', move(coord1)));\n+  VERIFY( it->first == 'c' );\n+  VERIFY( &(it->second.getCoords()[0]) == px );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "3a1e38ccf612b4a63c37c1b110d385aff7505400", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/emplace/1.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Femplace%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Femplace%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Femplace%2F1.cc?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -0,0 +1,79 @@\n+// { dg-options \"-std=c++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <vector>\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+  : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+  : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+struct PathPointLess\n+{\n+  bool operator() (const PathPoint& __lhs, const PathPoint& __rhs) const\n+  { return __lhs.getType() < __rhs.getType(); }\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::multiset<PathPoint, PathPointLess> Mset;\n+  Mset ms;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto it = ms.emplace('a', coord1);\n+  VERIFY( ms.size() == 1 );\n+  VERIFY( it->getType() == 'a' );\n+\n+  coord1[0] = 3.0;\n+  it = ms.emplace('a', coord1);\n+  VERIFY( ms.size() == 2 );\n+  VERIFY( it->getType() == 'a' );\n+  VERIFY( it->getCoords()[0] == 3.0 );\n+\n+  it = ms.emplace_hint(ms.begin(), 'b', coord1);\n+  VERIFY( it != ms.end() );\n+  VERIFY( it->getType() == 'b' );\n+  VERIFY( it->getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  it = ms.emplace('c', std::move(coord1));\n+  VERIFY( ms.size() == 4 );\n+  VERIFY( it->getType() == 'c' );\n+  VERIFY( &(it->getCoords()[0]) == px );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "34c4c192d3ef08ba41d971f0b1c286b615609516", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/emplace/1.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Femplace%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Femplace%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Femplace%2F1.cc?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -0,0 +1,81 @@\n+// { dg-options \"-std=c++11\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <vector>\n+#include <set>\n+#include <testsuite_hooks.h>\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, const std::vector<double>& c)\n+  : type(t), coords(c) { }\n+  PathPoint(char t, std::vector<double>&& c)\n+  : type(t), coords(std::move(c)) { }\n+  char getType() const { return type; }\n+  const std::vector<double>& getCoords() const { return coords; }\n+private:\n+  char type;\n+  std::vector<double> coords;\n+};\n+\n+struct PathPointLess\n+{\n+  bool operator() (const PathPoint& __lhs, const PathPoint& __rhs) const\n+  { return __lhs.getType() < __rhs.getType(); }\n+};\n+\n+bool test __attribute__((unused)) = true;\n+\n+void test01()\n+{\n+  typedef std::set<PathPoint, PathPointLess> Set;\n+  Set s;\n+\n+  std::vector<double> coord1 = { 0.0, 1.0, 2.0 };\n+\n+  auto ret = s.emplace('a', coord1);\n+  VERIFY( ret.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( ret.first->getType() == 'a' );\n+\n+  coord1[0] = 3.0;\n+  ret = s.emplace('a', coord1);\n+  VERIFY( !ret.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( ret.first->getType() == 'a' );\n+  VERIFY( ret.first->getCoords()[0] == 0.0 );\n+\n+  auto it = s.emplace_hint(s.begin(), 'b', coord1);\n+  VERIFY( it != s.end() );\n+  VERIFY( it->getType() == 'b' );\n+  VERIFY( it->getCoords()[0] == 3.0 );\n+\n+  double *px = &coord1[0];\n+  ret = s.emplace('c', std::move(coord1));\n+  VERIFY( ret.second );\n+  VERIFY( ret.first->getType() == 'c' );\n+  VERIFY( &(ret.first->getCoords()[0]) == px );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "5d8aae04fe04ee92c73cbcfa51ba92b0f8bf79e0", "filename": "libstdc++-v3/testsuite/util/testsuite_container_traits.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55826ab6d1d050a8892e6dc45cf035c94db98dd0/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h?ref=55826ab6d1d050a8892e6dc45cf035c94db98dd0", "patch": "@@ -148,6 +148,9 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      typedef std::true_type\thas_emplace;\n+#endif\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>\n@@ -161,6 +164,9 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      typedef std::true_type\thas_emplace;\n+#endif\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3>\n@@ -173,6 +179,9 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      typedef std::true_type\thas_emplace;\n+#endif\n     };\n \n   template<typename _Tp1, typename _Tp2, typename _Tp3>\n@@ -185,6 +194,9 @@ namespace __gnu_test\n \n       typedef std::true_type\thas_erase;\n       typedef std::true_type\thas_insert;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      typedef std::true_type\thas_emplace;\n+#endif\n     };\n \n   template<typename _Tp1, typename _Tp2>"}]}