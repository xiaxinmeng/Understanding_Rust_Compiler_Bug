{"sha": "f749a55bb4aa154a19b4a029ddf85b7393f52262", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc0OWE1NWJiNGFhMTU0YTE5YjRhMDI5ZGRmODViNzM5M2Y1MjI2Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-04-23T20:26:30Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-04-23T20:26:30Z"}, "message": "locale_facets.h (class time_base, [...]): Move...\n\n2007-04-23  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.h (class time_base,\n\tstruct __timepunct_cache, class __timepunct, class time_get,\n\tclass time_get_byname, class time_put, class time_put_byname,\n\tclass money_base, struct __moneypunct_cache, class moneypunct,\n\tclass moneypunct_byname, class money_get, class money_put,\n\tstruct messages_base, class messages, class messages_byname): Move...\n\t* include/bits/locale_facets_nonio.h: ... here.\n\t* include/bits/locale_facets.tcc\n\t(struct __use_cache<__moneypunct_cache<> >,\n\t__moneypunct_cache<>::_M_cache, money_get<>::_M_extract,\n\tmoney_get<>::__do_get, money_get<>::do_get, money_put<>::_M_insert,\n\tmoney_put<>::__do_put, money_put<>::do_put, time_get<>::do_date_order,\n\ttime_get<>::_M_extract_via_format, time_get<>::_M_extract_num,\n\ttime_get<>::_M_extract_name, time_get<>::do_get_time,\n\ttime_get<>::do_get_date, time_get<>::do_get_weekday,\n\ttime_get<>::do_get_monthname, time_get<>::do_get_year, time_put<>::put,\n\ttime_put<>::do_put): Move...\n\t* include/bits/locale_facets_nonio.tcc: ... here.\n\t* include/Makefile.am: Add.\n\t* include/std/locale: Adjust includes.\n\t* include/std/fstream: Likewise.\n\t* include/std/istream: Likewise.\n\t* include/std/ostream: Likewise.\n\t* include/Makefile.in: Regenerate.\n\nFrom-SVN: r124080", "tree": {"sha": "1f48e5599889c0a9c9b47827315847a28970952e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f48e5599889c0a9c9b47827315847a28970952e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f749a55bb4aa154a19b4a029ddf85b7393f52262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f749a55bb4aa154a19b4a029ddf85b7393f52262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f749a55bb4aa154a19b4a029ddf85b7393f52262", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f749a55bb4aa154a19b4a029ddf85b7393f52262/comments", "author": null, "committer": null, "parents": [{"sha": "e08e57d0c51f46403f3f1aebfa8135c976468aab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08e57d0c51f46403f3f1aebfa8135c976468aab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08e57d0c51f46403f3f1aebfa8135c976468aab"}], "stats": {"total": 6437, "additions": 3283, "deletions": 3154}, "files": [{"sha": "55b90855a5aa6321dcbf9606350d501b1478138c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -1,3 +1,30 @@\n+2007-04-23  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.h (class time_base,\n+\tstruct __timepunct_cache, class __timepunct, class time_get,\n+\tclass time_get_byname, class time_put, class time_put_byname,\n+\tclass money_base, struct __moneypunct_cache, class moneypunct,\n+\tclass moneypunct_byname, class money_get, class money_put,\n+\tstruct messages_base, class messages, class messages_byname): Move...\n+\t* include/bits/locale_facets_nonio.h: ... here.\n+\t* include/bits/locale_facets.tcc\n+\t(struct __use_cache<__moneypunct_cache<> >,\n+\t__moneypunct_cache<>::_M_cache, money_get<>::_M_extract,\n+\tmoney_get<>::__do_get, money_get<>::do_get, money_put<>::_M_insert,\n+\tmoney_put<>::__do_put, money_put<>::do_put, time_get<>::do_date_order,\n+\ttime_get<>::_M_extract_via_format, time_get<>::_M_extract_num,\n+\ttime_get<>::_M_extract_name, time_get<>::do_get_time,\n+\ttime_get<>::do_get_date, time_get<>::do_get_weekday,\n+\ttime_get<>::do_get_monthname, time_get<>::do_get_year, time_put<>::put,\n+\ttime_put<>::do_put): Move...\n+\t* include/bits/locale_facets_nonio.tcc: ... here.\n+\t* include/Makefile.am: Add.\n+\t* include/std/locale: Adjust includes.\n+\t* include/std/fstream: Likewise.\n+\t* include/std/istream: Likewise.\n+\t* include/std/ostream: Likewise.\n+\t* include/Makefile.in: Regenerate.\n+\n 2007-04-23  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* scripts/testsuite_flags.in: Add --build-cc option."}, {"sha": "2ce67ab7eff2fb1eea766faf0302f08006be6598", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -91,6 +91,8 @@ bits_headers = \\\n \t${bits_srcdir}/locale_classes.h \\\n \t${bits_srcdir}/locale_facets.h \\\n \t${bits_srcdir}/locale_facets.tcc \\\n+\t${bits_srcdir}/locale_facets_nonio.h \\\n+\t${bits_srcdir}/locale_facets_nonio.tcc \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/ostream.tcc \\"}, {"sha": "b382004914f4999e0e284e67f04af30524721935", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -325,6 +325,8 @@ bits_headers = \\\n \t${bits_srcdir}/locale_classes.h \\\n \t${bits_srcdir}/locale_facets.h \\\n \t${bits_srcdir}/locale_facets.tcc \\\n+\t${bits_srcdir}/locale_facets_nonio.h \\\n+\t${bits_srcdir}/locale_facets_nonio.tcc \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/ostream.tcc \\"}, {"sha": "e5fa9ad939d99e97f52692b933f4ef66c67c569d", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 5, "deletions": 1867, "changes": 1872, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -43,14 +43,16 @@\n \n #pragma GCC system_header\n \n-#include <ctime>\t// For struct tm\n #include <cwctype>\t// For wctype_t\n #include <cctype>\n #include <bits/ctype_base.h>\t\n #include <iosfwd>\n #include <bits/ios_base.h>  // For ios_base, ios_base::iostate\n #include <streambuf>\n #include <bits/cpp_type_traits.h>\n+#include <ext/type_traits.h>\n+#include <ext/numeric_traits.h>\n+#include <bits/streambuf_iterator.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n@@ -100,7 +102,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   // Inserts \"group separator\" characters into an array of characters.\n   // It's recursive, one iteration per group.  It moves the characters\n   // in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".  Call this\n-  // only with __glen != 0.\n+  // only with __gsize != 0.\n   template<typename _CharT>\n     _CharT*\n     __add_grouping(_CharT* __s, _CharT __sep,\n@@ -1938,6 +1940,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     };\n \n _GLIBCXX_BEGIN_LDBL_NAMESPACE\n+\n   /**\n    *  @brief  Facet for parsing number strings.\n    *\n@@ -2757,1871 +2760,6 @@ _GLIBCXX_END_LDBL_NAMESPACE\n       ~collate_byname() { }\n     };\n \n-\n-  /**\n-   *  @brief  Time format ordering data.\n-   *\n-   *  This class provides an enum representing different orderings of day,\n-   *  month, and year.\n-  */\n-  class time_base\n-  {\n-  public:\n-    enum dateorder { no_order, dmy, mdy, ymd, ydm };\n-  };\n-\n-  template<typename _CharT>\n-    struct __timepunct_cache : public locale::facet\n-    {\n-      // List of all known timezones, with GMT first.\n-      static const _CharT*\t\t_S_timezones[14];\n-\n-      const _CharT*\t\t\t_M_date_format;\n-      const _CharT*\t\t\t_M_date_era_format;\n-      const _CharT*\t\t\t_M_time_format;\n-      const _CharT*\t\t\t_M_time_era_format;\n-      const _CharT*\t\t\t_M_date_time_format;\n-      const _CharT*\t\t\t_M_date_time_era_format;\n-      const _CharT*\t\t\t_M_am;\n-      const _CharT*\t\t\t_M_pm;\n-      const _CharT*\t\t\t_M_am_pm_format;\n-\n-      // Day names, starting with \"C\"'s Sunday.\n-      const _CharT*\t\t\t_M_day1;\n-      const _CharT*\t\t\t_M_day2;\n-      const _CharT*\t\t\t_M_day3;\n-      const _CharT*\t\t\t_M_day4;\n-      const _CharT*\t\t\t_M_day5;\n-      const _CharT*\t\t\t_M_day6;\n-      const _CharT*\t\t\t_M_day7;\n-\n-      // Abbreviated day names, starting with \"C\"'s Sun.\n-      const _CharT*\t\t\t_M_aday1;\n-      const _CharT*\t\t\t_M_aday2;\n-      const _CharT*\t\t\t_M_aday3;\n-      const _CharT*\t\t\t_M_aday4;\n-      const _CharT*\t\t\t_M_aday5;\n-      const _CharT*\t\t\t_M_aday6;\n-      const _CharT*\t\t\t_M_aday7;\n-\n-      // Month names, starting with \"C\"'s January.\n-      const _CharT*\t\t\t_M_month01;\n-      const _CharT*\t\t\t_M_month02;\n-      const _CharT*\t\t\t_M_month03;\n-      const _CharT*\t\t\t_M_month04;\n-      const _CharT*\t\t\t_M_month05;\n-      const _CharT*\t\t\t_M_month06;\n-      const _CharT*\t\t\t_M_month07;\n-      const _CharT*\t\t\t_M_month08;\n-      const _CharT*\t\t\t_M_month09;\n-      const _CharT*\t\t\t_M_month10;\n-      const _CharT*\t\t\t_M_month11;\n-      const _CharT*\t\t\t_M_month12;\n-\n-      // Abbreviated month names, starting with \"C\"'s Jan.\n-      const _CharT*\t\t\t_M_amonth01;\n-      const _CharT*\t\t\t_M_amonth02;\n-      const _CharT*\t\t\t_M_amonth03;\n-      const _CharT*\t\t\t_M_amonth04;\n-      const _CharT*\t\t\t_M_amonth05;\n-      const _CharT*\t\t\t_M_amonth06;\n-      const _CharT*\t\t\t_M_amonth07;\n-      const _CharT*\t\t\t_M_amonth08;\n-      const _CharT*\t\t\t_M_amonth09;\n-      const _CharT*\t\t\t_M_amonth10;\n-      const _CharT*\t\t\t_M_amonth11;\n-      const _CharT*\t\t\t_M_amonth12;\n-\n-      bool\t\t\t\t_M_allocated;\n-\n-      __timepunct_cache(size_t __refs = 0) : facet(__refs),\n-      _M_date_format(NULL), _M_date_era_format(NULL), _M_time_format(NULL),\n-      _M_time_era_format(NULL), _M_date_time_format(NULL),\n-      _M_date_time_era_format(NULL), _M_am(NULL), _M_pm(NULL),\n-      _M_am_pm_format(NULL), _M_day1(NULL), _M_day2(NULL), _M_day3(NULL),\n-      _M_day4(NULL), _M_day5(NULL), _M_day6(NULL), _M_day7(NULL),\n-      _M_aday1(NULL), _M_aday2(NULL), _M_aday3(NULL), _M_aday4(NULL),\n-      _M_aday5(NULL), _M_aday6(NULL), _M_aday7(NULL), _M_month01(NULL),\n-      _M_month02(NULL), _M_month03(NULL), _M_month04(NULL), _M_month05(NULL),\n-      _M_month06(NULL), _M_month07(NULL), _M_month08(NULL), _M_month09(NULL),\n-      _M_month10(NULL), _M_month11(NULL), _M_month12(NULL), _M_amonth01(NULL),\n-      _M_amonth02(NULL), _M_amonth03(NULL), _M_amonth04(NULL),\n-      _M_amonth05(NULL), _M_amonth06(NULL), _M_amonth07(NULL),\n-      _M_amonth08(NULL), _M_amonth09(NULL), _M_amonth10(NULL),\n-      _M_amonth11(NULL), _M_amonth12(NULL), _M_allocated(false)\n-      { }\n-\n-      ~__timepunct_cache();\n-\n-      void\n-      _M_cache(const locale& __loc);\n-\n-    private:\n-      __timepunct_cache&\n-      operator=(const __timepunct_cache&);\n-      \n-      explicit\n-      __timepunct_cache(const __timepunct_cache&);\n-    };\n-\n-  template<typename _CharT>\n-    __timepunct_cache<_CharT>::~__timepunct_cache()\n-    {\n-      if (_M_allocated)\n-\t{\n-\t  // Unused.\n-\t}\n-    }\n-\n-  // Specializations.\n-  template<>\n-    const char*\n-    __timepunct_cache<char>::_S_timezones[14];\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template<>\n-    const wchar_t*\n-    __timepunct_cache<wchar_t>::_S_timezones[14];\n-#endif\n-\n-  // Generic.\n-  template<typename _CharT>\n-    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];\n-\n-  template<typename _CharT>\n-    class __timepunct : public locale::facet\n-    {\n-    public:\n-      // Types:\n-      typedef _CharT\t\t\t__char_type;\n-      typedef basic_string<_CharT>\t__string_type;\n-      typedef __timepunct_cache<_CharT>\t__cache_type;\n-\n-    protected:\n-      __cache_type*\t\t\t_M_data;\n-      __c_locale\t\t\t_M_c_locale_timepunct;\n-      const char*\t\t\t_M_name_timepunct;\n-\n-    public:\n-      /// Numpunct facet id.\n-      static locale::id\t\t\tid;\n-\n-      explicit\n-      __timepunct(size_t __refs = 0);\n-\n-      explicit\n-      __timepunct(__cache_type* __cache, size_t __refs = 0);\n-\n-      /**\n-       *  @brief  Internal constructor. Not for general use.\n-       *\n-       *  This is a constructor for use by the library itself to set up new\n-       *  locales.\n-       *\n-       *  @param cloc  The \"C\" locale.\n-       *  @param s  The name of a locale.\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);\n-\n-      // FIXME: for error checking purposes _M_put should return the return\n-      // value of strftime/wcsftime.\n-      void\n-      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,\n-\t     const tm* __tm) const;\n-\n-      void\n-      _M_date_formats(const _CharT** __date) const\n-      {\n-\t// Always have default first.\n-\t__date[0] = _M_data->_M_date_format;\n-\t__date[1] = _M_data->_M_date_era_format;\n-      }\n-\n-      void\n-      _M_time_formats(const _CharT** __time) const\n-      {\n-\t// Always have default first.\n-\t__time[0] = _M_data->_M_time_format;\n-\t__time[1] = _M_data->_M_time_era_format;\n-      }\n-\n-      void\n-      _M_date_time_formats(const _CharT** __dt) const\n-      {\n-\t// Always have default first.\n-\t__dt[0] = _M_data->_M_date_time_format;\n-\t__dt[1] = _M_data->_M_date_time_era_format;\n-      }\n-\n-      void\n-      _M_am_pm_format(const _CharT* __ampm) const\n-      { __ampm = _M_data->_M_am_pm_format; }\n-\n-      void\n-      _M_am_pm(const _CharT** __ampm) const\n-      {\n-\t__ampm[0] = _M_data->_M_am;\n-\t__ampm[1] = _M_data->_M_pm;\n-      }\n-\n-      void\n-      _M_days(const _CharT** __days) const\n-      {\n-\t__days[0] = _M_data->_M_day1;\n-\t__days[1] = _M_data->_M_day2;\n-\t__days[2] = _M_data->_M_day3;\n-\t__days[3] = _M_data->_M_day4;\n-\t__days[4] = _M_data->_M_day5;\n-\t__days[5] = _M_data->_M_day6;\n-\t__days[6] = _M_data->_M_day7;\n-      }\n-\n-      void\n-      _M_days_abbreviated(const _CharT** __days) const\n-      {\n-\t__days[0] = _M_data->_M_aday1;\n-\t__days[1] = _M_data->_M_aday2;\n-\t__days[2] = _M_data->_M_aday3;\n-\t__days[3] = _M_data->_M_aday4;\n-\t__days[4] = _M_data->_M_aday5;\n-\t__days[5] = _M_data->_M_aday6;\n-\t__days[6] = _M_data->_M_aday7;\n-      }\n-\n-      void\n-      _M_months(const _CharT** __months) const\n-      {\n-\t__months[0] = _M_data->_M_month01;\n-\t__months[1] = _M_data->_M_month02;\n-\t__months[2] = _M_data->_M_month03;\n-\t__months[3] = _M_data->_M_month04;\n-\t__months[4] = _M_data->_M_month05;\n-\t__months[5] = _M_data->_M_month06;\n-\t__months[6] = _M_data->_M_month07;\n-\t__months[7] = _M_data->_M_month08;\n-\t__months[8] = _M_data->_M_month09;\n-\t__months[9] = _M_data->_M_month10;\n-\t__months[10] = _M_data->_M_month11;\n-\t__months[11] = _M_data->_M_month12;\n-      }\n-\n-      void\n-      _M_months_abbreviated(const _CharT** __months) const\n-      {\n-\t__months[0] = _M_data->_M_amonth01;\n-\t__months[1] = _M_data->_M_amonth02;\n-\t__months[2] = _M_data->_M_amonth03;\n-\t__months[3] = _M_data->_M_amonth04;\n-\t__months[4] = _M_data->_M_amonth05;\n-\t__months[5] = _M_data->_M_amonth06;\n-\t__months[6] = _M_data->_M_amonth07;\n-\t__months[7] = _M_data->_M_amonth08;\n-\t__months[8] = _M_data->_M_amonth09;\n-\t__months[9] = _M_data->_M_amonth10;\n-\t__months[10] = _M_data->_M_amonth11;\n-\t__months[11] = _M_data->_M_amonth12;\n-      }\n-\n-    protected:\n-      virtual\n-      ~__timepunct();\n-\n-      // For use at construction time only.\n-      void\n-      _M_initialize_timepunct(__c_locale __cloc = NULL);\n-    };\n-\n-  template<typename _CharT>\n-    locale::id __timepunct<_CharT>::id;\n-\n-  // Specializations.\n-  template<>\n-    void\n-    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);\n-\n-  template<>\n-    void\n-    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template<>\n-    void\n-    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);\n-\n-  template<>\n-    void\n-    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,\n-\t\t\t\t const tm*) const;\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE\n-\n-  // Include host and configuration specific timepunct functions.\n-  #include <bits/time_members.h>\n-\n-_GLIBCXX_BEGIN_NAMESPACE(std)\n-\n-  /**\n-   *  @brief  Facet for parsing dates and times.\n-   *\n-   *  This facet encapsulates the code to parse and return a date or\n-   *  time from a string.  It is used by the istream numeric\n-   *  extraction operators.\n-   *\n-   *  The time_get template uses protected virtual functions to provide the\n-   *  actual results.  The public accessors forward the call to the virtual\n-   *  functions.  These virtual functions are hooks for developers to\n-   *  implement the behavior they require from the time_get facet.\n-  */\n-  template<typename _CharT, typename _InIter>\n-    class time_get : public locale::facet, public time_base\n-    {\n-    public:\n-      // Types:\n-      //@{\n-      /// Public typedefs\n-      typedef _CharT\t\t\tchar_type;\n-      typedef _InIter\t\t\titer_type;\n-      //@}\n-      typedef basic_string<_CharT>\t__string_type;\n-\n-      /// Numpunct facet id.\n-      static locale::id\t\t\tid;\n-\n-      /**\n-       *  @brief  Constructor performs initialization.\n-       *\n-       *  This is the constructor provided by the standard.\n-       *\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      time_get(size_t __refs = 0)\n-      : facet (__refs) { }\n-\n-      /**\n-       *  @brief  Return preferred order of month, day, and year.\n-       *\n-       *  This function returns an enum from timebase::dateorder giving the\n-       *  preferred ordering if the format \"x\" given to time_put::put() only\n-       *  uses month, day, and year.  If the format \"x\" for the associated\n-       *  locale uses other fields, this function returns\n-       *  timebase::dateorder::noorder.\n-       *\n-       *  NOTE: The library always returns noorder at the moment.\n-       *\n-       *  @return  A member of timebase::dateorder.\n-      */\n-      dateorder\n-      date_order()  const\n-      { return this->do_date_order(); }\n-\n-      /**\n-       *  @brief  Parse input time string.\n-       *\n-       *  This function parses a time according to the format \"x\" and puts the\n-       *  results into a user-supplied struct tm.  The result is returned by\n-       *  calling time_get::do_get_time().\n-       *\n-       *  If there is a valid time string according to format \"x\", @a tm will\n-       *  be filled in accordingly and the returned iterator will point to the\n-       *  first character beyond the time string.  If an error occurs before\n-       *  the end, err |= ios_base::failbit.  If parsing reads all the\n-       *  characters, err |= ios_base::eofbit.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond time string.\n-      */\n-      iter_type\n-      get_time(iter_type __beg, iter_type __end, ios_base& __io,\n-\t       ios_base::iostate& __err, tm* __tm)  const\n-      { return this->do_get_time(__beg, __end, __io, __err, __tm); }\n-\n-      /**\n-       *  @brief  Parse input date string.\n-       *\n-       *  This function parses a date according to the format \"X\" and puts the\n-       *  results into a user-supplied struct tm.  The result is returned by\n-       *  calling time_get::do_get_date().\n-       *\n-       *  If there is a valid date string according to format \"X\", @a tm will\n-       *  be filled in accordingly and the returned iterator will point to the\n-       *  first character beyond the date string.  If an error occurs before\n-       *  the end, err |= ios_base::failbit.  If parsing reads all the\n-       *  characters, err |= ios_base::eofbit.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond date string.\n-      */\n-      iter_type\n-      get_date(iter_type __beg, iter_type __end, ios_base& __io,\n-\t       ios_base::iostate& __err, tm* __tm)  const\n-      { return this->do_get_date(__beg, __end, __io, __err, __tm); }\n-\n-      /**\n-       *  @brief  Parse input weekday string.\n-       *\n-       *  This function parses a weekday name and puts the results into a\n-       *  user-supplied struct tm.  The result is returned by calling\n-       *  time_get::do_get_weekday().\n-       *\n-       *  Parsing starts by parsing an abbreviated weekday name.  If a valid\n-       *  abbreviation is followed by a character that would lead to the full\n-       *  weekday name, parsing continues until the full name is found or an\n-       *  error occurs.  Otherwise parsing finishes at the end of the\n-       *  abbreviated name.\n-       *\n-       *  If an error occurs before the end, err |= ios_base::failbit.  If\n-       *  parsing reads all the characters, err |= ios_base::eofbit.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond weekday name.\n-      */\n-      iter_type\n-      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t  ios_base::iostate& __err, tm* __tm) const\n-      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }\n-\n-      /**\n-       *  @brief  Parse input month string.\n-       *\n-       *  This function parses a month name and puts the results into a\n-       *  user-supplied struct tm.  The result is returned by calling\n-       *  time_get::do_get_monthname().\n-       *\n-       *  Parsing starts by parsing an abbreviated month name.  If a valid\n-       *  abbreviation is followed by a character that would lead to the full\n-       *  month name, parsing continues until the full name is found or an\n-       *  error occurs.  Otherwise parsing finishes at the end of the\n-       *  abbreviated name.\n-       *\n-       *  If an error occurs before the end, err |= ios_base::failbit.  If\n-       *  parsing reads all the characters, err |=\n-       *  ios_base::eofbit.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond month name.\n-      */\n-      iter_type\n-      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t    ios_base::iostate& __err, tm* __tm) const\n-      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }\n-\n-      /**\n-       *  @brief  Parse input year string.\n-       *\n-       *  This function reads up to 4 characters to parse a year string and\n-       *  puts the results into a user-supplied struct tm.  The result is\n-       *  returned by calling time_get::do_get_year().\n-       *\n-       *  4 consecutive digits are interpreted as a full year.  If there are\n-       *  exactly 2 consecutive digits, the library interprets this as the\n-       *  number of years since 1900.\n-       *\n-       *  If an error occurs before the end, err |= ios_base::failbit.  If\n-       *  parsing reads all the characters, err |= ios_base::eofbit.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond year.\n-      */\n-      iter_type\n-      get_year(iter_type __beg, iter_type __end, ios_base& __io,\n-\t       ios_base::iostate& __err, tm* __tm) const\n-      { return this->do_get_year(__beg, __end, __io, __err, __tm); }\n-\n-    protected:\n-      /// Destructor.\n-      virtual\n-      ~time_get() { }\n-\n-      /**\n-       *  @brief  Return preferred order of month, day, and year.\n-       *\n-       *  This function returns an enum from timebase::dateorder giving the\n-       *  preferred ordering if the format \"x\" given to time_put::put() only\n-       *  uses month, day, and year.  This function is a hook for derived\n-       *  classes to change the value returned.\n-       *\n-       *  @return  A member of timebase::dateorder.\n-      */\n-      virtual dateorder\n-      do_date_order() const;\n-\n-      /**\n-       *  @brief  Parse input time string.\n-       *\n-       *  This function parses a time according to the format \"x\" and puts the\n-       *  results into a user-supplied struct tm.  This function is a hook for\n-       *  derived classes to change the value returned.  @see get_time() for\n-       *  details.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond time string.\n-      */\n-      virtual iter_type\n-      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t  ios_base::iostate& __err, tm* __tm) const;\n-\n-      /**\n-       *  @brief  Parse input date string.\n-       *\n-       *  This function parses a date according to the format \"X\" and puts the\n-       *  results into a user-supplied struct tm.  This function is a hook for\n-       *  derived classes to change the value returned.  @see get_date() for\n-       *  details.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond date string.\n-      */\n-      virtual iter_type\n-      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t  ios_base::iostate& __err, tm* __tm) const;\n-\n-      /**\n-       *  @brief  Parse input weekday string.\n-       *\n-       *  This function parses a weekday name and puts the results into a\n-       *  user-supplied struct tm.  This function is a hook for derived\n-       *  classes to change the value returned.  @see get_weekday() for\n-       *  details.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond weekday name.\n-      */\n-      virtual iter_type\n-      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,\n-\t\t     ios_base::iostate& __err, tm* __tm) const;\n-\n-      /**\n-       *  @brief  Parse input month string.\n-       *\n-       *  This function parses a month name and puts the results into a\n-       *  user-supplied struct tm.  This function is a hook for derived\n-       *  classes to change the value returned.  @see get_monthname() for\n-       *  details.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond month name.\n-      */\n-      virtual iter_type\n-      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,\n-\t\t       ios_base::iostate& __err, tm* __tm) const;\n-\n-      /**\n-       *  @brief  Parse input year string.\n-       *\n-       *  This function reads up to 4 characters to parse a year string and\n-       *  puts the results into a user-supplied struct tm.  This function is a\n-       *  hook for derived classes to change the value returned.  @see\n-       *  get_year() for details.\n-       *\n-       *  @param  beg  Start of string to parse.\n-       *  @param  end  End of string to parse.\n-       *  @param  io  Source of the locale.\n-       *  @param  err  Error flags to set.\n-       *  @param  tm  Pointer to struct tm to fill in.\n-       *  @return  Iterator to first char beyond year.\n-      */\n-      virtual iter_type\n-      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t  ios_base::iostate& __err, tm* __tm) const;\n-\n-      // Extract numeric component of length __len.\n-      iter_type\n-      _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n-\t\t     int __min, int __max, size_t __len,\n-\t\t     ios_base& __io, ios_base::iostate& __err) const;\n-\n-      // Extract day or month name, or any unique array of string\n-      // literals in a const _CharT* array.\n-      iter_type\n-      _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n-\t\t      const _CharT** __names, size_t __indexlen,\n-\t\t      ios_base& __io, ios_base::iostate& __err) const;\n-\n-      // Extract on a component-by-component basis, via __format argument.\n-      iter_type\n-      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t\t    ios_base::iostate& __err, tm* __tm,\n-\t\t\t    const _CharT* __format) const;\n-    };\n-\n-  template<typename _CharT, typename _InIter>\n-    locale::id time_get<_CharT, _InIter>::id;\n-\n-  /// @brief  class time_get_byname [22.2.5.2].\n-  template<typename _CharT, typename _InIter>\n-    class time_get_byname : public time_get<_CharT, _InIter>\n-    {\n-    public:\n-      // Types:\n-      typedef _CharT\t\t\tchar_type;\n-      typedef _InIter\t\t\titer_type;\n-\n-      explicit\n-      time_get_byname(const char*, size_t __refs = 0)\n-      : time_get<_CharT, _InIter>(__refs) { }\n-\n-    protected:\n-      virtual\n-      ~time_get_byname() { }\n-    };\n-\n-  /**\n-   *  @brief  Facet for outputting dates and times.\n-   *\n-   *  This facet encapsulates the code to format and output dates and times\n-   *  according to formats used by strftime().\n-   *\n-   *  The time_put template uses protected virtual functions to provide the\n-   *  actual results.  The public accessors forward the call to the virtual\n-   *  functions.  These virtual functions are hooks for developers to\n-   *  implement the behavior they require from the time_put facet.\n-  */\n-  template<typename _CharT, typename _OutIter>\n-    class time_put : public locale::facet\n-    {\n-    public:\n-      // Types:\n-      //@{\n-      /// Public typedefs\n-      typedef _CharT\t\t\tchar_type;\n-      typedef _OutIter\t\t\titer_type;\n-      //@}\n-\n-      /// Numpunct facet id.\n-      static locale::id\t\t\tid;\n-\n-      /**\n-       *  @brief  Constructor performs initialization.\n-       *\n-       *  This is the constructor provided by the standard.\n-       *\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      time_put(size_t __refs = 0)\n-      : facet(__refs) { }\n-\n-      /**\n-       *  @brief  Format and output a time or date.\n-       *\n-       *  This function formats the data in struct tm according to the\n-       *  provided format string.  The format string is interpreted as by\n-       *  strftime().\n-       *\n-       *  @param  s  The stream to write to.\n-       *  @param  io  Source of locale.\n-       *  @param  fill  char_type to use for padding.\n-       *  @param  tm  Struct tm with date and time info to format.\n-       *  @param  beg  Start of format string.\n-       *  @param  end  End of format string.\n-       *  @return  Iterator after writing.\n-       */\n-      iter_type\n-      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n-\t  const _CharT* __beg, const _CharT* __end) const;\n-\n-      /**\n-       *  @brief  Format and output a time or date.\n-       *\n-       *  This function formats the data in struct tm according to the\n-       *  provided format char and optional modifier.  The format and modifier\n-       *  are interpreted as by strftime().  It does so by returning\n-       *  time_put::do_put().\n-       *\n-       *  @param  s  The stream to write to.\n-       *  @param  io  Source of locale.\n-       *  @param  fill  char_type to use for padding.\n-       *  @param  tm  Struct tm with date and time info to format.\n-       *  @param  format  Format char.\n-       *  @param  mod  Optional modifier char.\n-       *  @return  Iterator after writing.\n-       */\n-      iter_type\n-      put(iter_type __s, ios_base& __io, char_type __fill,\n-\t  const tm* __tm, char __format, char __mod = 0) const\n-      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }\n-\n-    protected:\n-      /// Destructor.\n-      virtual\n-      ~time_put()\n-      { }\n-\n-      /**\n-       *  @brief  Format and output a time or date.\n-       *\n-       *  This function formats the data in struct tm according to the\n-       *  provided format char and optional modifier.  This function is a hook\n-       *  for derived classes to change the value returned.  @see put() for\n-       *  more details.\n-       *\n-       *  @param  s  The stream to write to.\n-       *  @param  io  Source of locale.\n-       *  @param  fill  char_type to use for padding.\n-       *  @param  tm  Struct tm with date and time info to format.\n-       *  @param  format  Format char.\n-       *  @param  mod  Optional modifier char.\n-       *  @return  Iterator after writing.\n-       */\n-      virtual iter_type\n-      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n-\t     char __format, char __mod) const;\n-    };\n-\n-  template<typename _CharT, typename _OutIter>\n-    locale::id time_put<_CharT, _OutIter>::id;\n-\n-  /// @brief  class time_put_byname [22.2.5.4].\n-  template<typename _CharT, typename _OutIter>\n-    class time_put_byname : public time_put<_CharT, _OutIter>\n-    {\n-    public:\n-      // Types:\n-      typedef _CharT\t\t\tchar_type;\n-      typedef _OutIter\t\t\titer_type;\n-\n-      explicit\n-      time_put_byname(const char*, size_t __refs = 0)\n-      : time_put<_CharT, _OutIter>(__refs)\n-      { };\n-\n-    protected:\n-      virtual\n-      ~time_put_byname() { }\n-    };\n-\n-\n-  /**\n-   *  @brief  Money format ordering data.\n-   *\n-   *  This class contains an ordered array of 4 fields to represent the\n-   *  pattern for formatting a money amount.  Each field may contain one entry\n-   *  from the part enum.  symbol, sign, and value must be present and the\n-   *  remaining field must contain either none or space.  @see\n-   *  moneypunct::pos_format() and moneypunct::neg_format() for details of how\n-   *  these fields are interpreted.\n-  */\n-  class money_base\n-  {\n-  public:\n-    enum part { none, space, symbol, sign, value };\n-    struct pattern { char field[4]; };\n-\n-    static const pattern _S_default_pattern;\n-\n-    enum\n-    {\n-      _S_minus,\n-      _S_zero,\n-      _S_end = 11\n-    };\n-\n-    // String literal of acceptable (narrow) input/output, for\n-    // money_get/money_put. \"-0123456789\"\n-    static const char* _S_atoms;\n-\n-    // Construct and return valid pattern consisting of some combination of:\n-    // space none symbol sign value\n-    static pattern\n-    _S_construct_pattern(char __precedes, char __space, char __posn);\n-  };\n-\n-  template<typename _CharT, bool _Intl>\n-    struct __moneypunct_cache : public locale::facet\n-    {\n-      const char*\t\t\t_M_grouping;\n-      size_t                            _M_grouping_size;\n-      bool\t\t\t\t_M_use_grouping;\n-      _CharT\t\t\t\t_M_decimal_point;\n-      _CharT\t\t\t\t_M_thousands_sep;\n-      const _CharT*\t\t\t_M_curr_symbol;\n-      size_t                            _M_curr_symbol_size;\n-      const _CharT*\t\t\t_M_positive_sign;\n-      size_t                            _M_positive_sign_size;\n-      const _CharT*\t\t\t_M_negative_sign;\n-      size_t                            _M_negative_sign_size;\n-      int\t\t\t\t_M_frac_digits;\n-      money_base::pattern\t\t_M_pos_format;\n-      money_base::pattern\t        _M_neg_format;\n-\n-      // A list of valid numeric literals for input and output: in the standard\n-      // \"C\" locale, this is \"-0123456789\". This array contains the chars after\n-      // having been passed through the current locale's ctype<_CharT>.widen().\n-      _CharT\t\t\t\t_M_atoms[money_base::_S_end];\n-\n-      bool\t\t\t\t_M_allocated;\n-\n-      __moneypunct_cache(size_t __refs = 0) : facet(__refs),\n-      _M_grouping(NULL), _M_grouping_size(0), _M_use_grouping(false),\n-      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),\n-      _M_curr_symbol(NULL), _M_curr_symbol_size(0),\n-      _M_positive_sign(NULL), _M_positive_sign_size(0),\n-      _M_negative_sign(NULL), _M_negative_sign_size(0),\n-      _M_frac_digits(0),\n-      _M_pos_format(money_base::pattern()),\n-      _M_neg_format(money_base::pattern()), _M_allocated(false)\n-      { }\n-\n-      ~__moneypunct_cache();\n-\n-      void\n-      _M_cache(const locale& __loc);\n-\n-    private:\n-      __moneypunct_cache&\n-      operator=(const __moneypunct_cache&);\n-      \n-      explicit\n-      __moneypunct_cache(const __moneypunct_cache&);\n-    };\n-\n-  template<typename _CharT, bool _Intl>\n-    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()\n-    {\n-      if (_M_allocated)\n-\t{\n-\t  delete [] _M_grouping;\n-\t  delete [] _M_curr_symbol;\n-\t  delete [] _M_positive_sign;\n-\t  delete [] _M_negative_sign;\n-\t}\n-    }\n-\n-  /**\n-   *  @brief  Facet for formatting data for money amounts.\n-   *\n-   *  This facet encapsulates the punctuation, grouping and other formatting\n-   *  features of money amount string representations.\n-  */\n-  template<typename _CharT, bool _Intl>\n-    class moneypunct : public locale::facet, public money_base\n-    {\n-    public:\n-      // Types:\n-      //@{\n-      /// Public typedefs\n-      typedef _CharT\t\t\tchar_type;\n-      typedef basic_string<_CharT>\tstring_type;\n-      //@}\n-      typedef __moneypunct_cache<_CharT, _Intl>     __cache_type;\n-\n-    private:\n-      __cache_type*\t\t\t_M_data;\n-\n-    public:\n-      /// This value is provided by the standard, but no reason for its\n-      /// existence.\n-      static const bool\t\t\tintl = _Intl;\n-      /// Numpunct facet id.\n-      static locale::id\t\t\tid;\n-\n-      /**\n-       *  @brief  Constructor performs initialization.\n-       *\n-       *  This is the constructor provided by the standard.\n-       *\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(NULL)\n-      { _M_initialize_moneypunct(); }\n-\n-      /**\n-       *  @brief  Constructor performs initialization.\n-       *\n-       *  This is an internal constructor.\n-       *\n-       *  @param cache  Cache for optimization.\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      moneypunct(__cache_type* __cache, size_t __refs = 0)\n-      : facet(__refs), _M_data(__cache)\n-      { _M_initialize_moneypunct(); }\n-\n-      /**\n-       *  @brief  Internal constructor. Not for general use.\n-       *\n-       *  This is a constructor for use by the library itself to set up new\n-       *  locales.\n-       *\n-       *  @param cloc  The \"C\" locale.\n-       *  @param s  The name of a locale.\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)\n-      : facet(__refs), _M_data(NULL)\n-      { _M_initialize_moneypunct(__cloc, __s); }\n-\n-      /**\n-       *  @brief  Return decimal point character.\n-       *\n-       *  This function returns a char_type to use as a decimal point.  It\n-       *  does so by returning returning\n-       *  moneypunct<char_type>::do_decimal_point().\n-       *\n-       *  @return  @a char_type representing a decimal point.\n-      */\n-      char_type\n-      decimal_point() const\n-      { return this->do_decimal_point(); }\n-\n-      /**\n-       *  @brief  Return thousands separator character.\n-       *\n-       *  This function returns a char_type to use as a thousands\n-       *  separator.  It does so by returning returning\n-       *  moneypunct<char_type>::do_thousands_sep().\n-       *\n-       *  @return  char_type representing a thousands separator.\n-      */\n-      char_type\n-      thousands_sep() const\n-      { return this->do_thousands_sep(); }\n-\n-      /**\n-       *  @brief  Return grouping specification.\n-       *\n-       *  This function returns a string representing groupings for the\n-       *  integer part of an amount.  Groupings indicate where thousands\n-       *  separators should be inserted.\n-       *\n-       *  Each char in the return string is interpret as an integer rather\n-       *  than a character.  These numbers represent the number of digits in a\n-       *  group.  The first char in the string represents the number of digits\n-       *  in the least significant group.  If a char is negative, it indicates\n-       *  an unlimited number of digits for the group.  If more chars from the\n-       *  string are required to group a number, the last char is used\n-       *  repeatedly.\n-       *\n-       *  For example, if the grouping() returns \"\\003\\002\" and is applied to\n-       *  the number 123456789, this corresponds to 12,34,56,789.  Note that\n-       *  if the string was \"32\", this would put more than 50 digits into the\n-       *  least significant group if the character set is ASCII.\n-       *\n-       *  The string is returned by calling\n-       *  moneypunct<char_type>::do_grouping().\n-       *\n-       *  @return  string representing grouping specification.\n-      */\n-      string\n-      grouping() const\n-      { return this->do_grouping(); }\n-\n-      /**\n-       *  @brief  Return currency symbol string.\n-       *\n-       *  This function returns a string_type to use as a currency symbol.  It\n-       *  does so by returning returning\n-       *  moneypunct<char_type>::do_curr_symbol().\n-       *\n-       *  @return  @a string_type representing a currency symbol.\n-      */\n-      string_type\n-      curr_symbol() const\n-      { return this->do_curr_symbol(); }\n-\n-      /**\n-       *  @brief  Return positive sign string.\n-       *\n-       *  This function returns a string_type to use as a sign for positive\n-       *  amounts.  It does so by returning returning\n-       *  moneypunct<char_type>::do_positive_sign().\n-       *\n-       *  If the return value contains more than one character, the first\n-       *  character appears in the position indicated by pos_format() and the\n-       *  remainder appear at the end of the formatted string.\n-       *\n-       *  @return  @a string_type representing a positive sign.\n-      */\n-      string_type\n-      positive_sign() const\n-      { return this->do_positive_sign(); }\n-\n-      /**\n-       *  @brief  Return negative sign string.\n-       *\n-       *  This function returns a string_type to use as a sign for negative\n-       *  amounts.  It does so by returning returning\n-       *  moneypunct<char_type>::do_negative_sign().\n-       *\n-       *  If the return value contains more than one character, the first\n-       *  character appears in the position indicated by neg_format() and the\n-       *  remainder appear at the end of the formatted string.\n-       *\n-       *  @return  @a string_type representing a negative sign.\n-      */\n-      string_type\n-      negative_sign() const\n-      { return this->do_negative_sign(); }\n-\n-      /**\n-       *  @brief  Return number of digits in fraction.\n-       *\n-       *  This function returns the exact number of digits that make up the\n-       *  fractional part of a money amount.  It does so by returning\n-       *  returning moneypunct<char_type>::do_frac_digits().\n-       *\n-       *  The fractional part of a money amount is optional.  But if it is\n-       *  present, there must be frac_digits() digits.\n-       *\n-       *  @return  Number of digits in amount fraction.\n-      */\n-      int\n-      frac_digits() const\n-      { return this->do_frac_digits(); }\n-\n-      //@{\n-      /**\n-       *  @brief  Return pattern for money values.\n-       *\n-       *  This function returns a pattern describing the formatting of a\n-       *  positive or negative valued money amount.  It does so by returning\n-       *  returning moneypunct<char_type>::do_pos_format() or\n-       *  moneypunct<char_type>::do_neg_format().\n-       *\n-       *  The pattern has 4 fields describing the ordering of symbol, sign,\n-       *  value, and none or space.  There must be one of each in the pattern.\n-       *  The none and space enums may not appear in the first field and space\n-       *  may not appear in the final field.\n-       *\n-       *  The parts of a money string must appear in the order indicated by\n-       *  the fields of the pattern.  The symbol field indicates that the\n-       *  value of curr_symbol() may be present.  The sign field indicates\n-       *  that the value of positive_sign() or negative_sign() must be\n-       *  present.  The value field indicates that the absolute value of the\n-       *  money amount is present.  none indicates 0 or more whitespace\n-       *  characters, except at the end, where it permits no whitespace.\n-       *  space indicates that 1 or more whitespace characters must be\n-       *  present.\n-       *\n-       *  For example, for the US locale and pos_format() pattern\n-       *  {symbol,sign,value,none}, curr_symbol() == '$' positive_sign() ==\n-       *  '+', and value 10.01, and options set to force the symbol, the\n-       *  corresponding string is \"$+10.01\".\n-       *\n-       *  @return  Pattern for money values.\n-      */\n-      pattern\n-      pos_format() const\n-      { return this->do_pos_format(); }\n-\n-      pattern\n-      neg_format() const\n-      { return this->do_neg_format(); }\n-      //@}\n-\n-    protected:\n-      /// Destructor.\n-      virtual\n-      ~moneypunct();\n-\n-      /**\n-       *  @brief  Return decimal point character.\n-       *\n-       *  Returns a char_type to use as a decimal point.  This function is a\n-       *  hook for derived classes to change the value returned.\n-       *\n-       *  @return  @a char_type representing a decimal point.\n-      */\n-      virtual char_type\n-      do_decimal_point() const\n-      { return _M_data->_M_decimal_point; }\n-\n-      /**\n-       *  @brief  Return thousands separator character.\n-       *\n-       *  Returns a char_type to use as a thousands separator.  This function\n-       *  is a hook for derived classes to change the value returned.\n-       *\n-       *  @return  @a char_type representing a thousands separator.\n-      */\n-      virtual char_type\n-      do_thousands_sep() const\n-      { return _M_data->_M_thousands_sep; }\n-\n-      /**\n-       *  @brief  Return grouping specification.\n-       *\n-       *  Returns a string representing groupings for the integer part of a\n-       *  number.  This function is a hook for derived classes to change the\n-       *  value returned.  @see grouping() for details.\n-       *\n-       *  @return  String representing grouping specification.\n-      */\n-      virtual string\n-      do_grouping() const\n-      { return _M_data->_M_grouping; }\n-\n-      /**\n-       *  @brief  Return currency symbol string.\n-       *\n-       *  This function returns a string_type to use as a currency symbol.\n-       *  This function is a hook for derived classes to change the value\n-       *  returned.  @see curr_symbol() for details.\n-       *\n-       *  @return  @a string_type representing a currency symbol.\n-      */\n-      virtual string_type\n-      do_curr_symbol()   const\n-      { return _M_data->_M_curr_symbol; }\n-\n-      /**\n-       *  @brief  Return positive sign string.\n-       *\n-       *  This function returns a string_type to use as a sign for positive\n-       *  amounts.  This function is a hook for derived classes to change the\n-       *  value returned.  @see positive_sign() for details.\n-       *\n-       *  @return  @a string_type representing a positive sign.\n-      */\n-      virtual string_type\n-      do_positive_sign() const\n-      { return _M_data->_M_positive_sign; }\n-\n-      /**\n-       *  @brief  Return negative sign string.\n-       *\n-       *  This function returns a string_type to use as a sign for negative\n-       *  amounts.  This function is a hook for derived classes to change the\n-       *  value returned.  @see negative_sign() for details.\n-       *\n-       *  @return  @a string_type representing a negative sign.\n-      */\n-      virtual string_type\n-      do_negative_sign() const\n-      { return _M_data->_M_negative_sign; }\n-\n-      /**\n-       *  @brief  Return number of digits in fraction.\n-       *\n-       *  This function returns the exact number of digits that make up the\n-       *  fractional part of a money amount.  This function is a hook for\n-       *  derived classes to change the value returned.  @see frac_digits()\n-       *  for details.\n-       *\n-       *  @return  Number of digits in amount fraction.\n-      */\n-      virtual int\n-      do_frac_digits() const\n-      { return _M_data->_M_frac_digits; }\n-\n-      /**\n-       *  @brief  Return pattern for money values.\n-       *\n-       *  This function returns a pattern describing the formatting of a\n-       *  positive valued money amount.  This function is a hook for derived\n-       *  classes to change the value returned.  @see pos_format() for\n-       *  details.\n-       *\n-       *  @return  Pattern for money values.\n-      */\n-      virtual pattern\n-      do_pos_format() const\n-      { return _M_data->_M_pos_format; }\n-\n-      /**\n-       *  @brief  Return pattern for money values.\n-       *\n-       *  This function returns a pattern describing the formatting of a\n-       *  negative valued money amount.  This function is a hook for derived\n-       *  classes to change the value returned.  @see neg_format() for\n-       *  details.\n-       *\n-       *  @return  Pattern for money values.\n-      */\n-      virtual pattern\n-      do_neg_format() const\n-      { return _M_data->_M_neg_format; }\n-\n-      // For use at construction time only.\n-       void\n-       _M_initialize_moneypunct(__c_locale __cloc = NULL,\n-\t\t\t\tconst char* __name = NULL);\n-    };\n-\n-  template<typename _CharT, bool _Intl>\n-    locale::id moneypunct<_CharT, _Intl>::id;\n-\n-  template<typename _CharT, bool _Intl>\n-    const bool moneypunct<_CharT, _Intl>::intl;\n-\n-  template<>\n-    moneypunct<char, true>::~moneypunct();\n-\n-  template<>\n-    moneypunct<char, false>::~moneypunct();\n-\n-  template<>\n-    void\n-    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);\n-\n-  template<>\n-    void\n-    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template<>\n-    moneypunct<wchar_t, true>::~moneypunct();\n-\n-  template<>\n-    moneypunct<wchar_t, false>::~moneypunct();\n-\n-  template<>\n-    void\n-    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,\n-\t\t\t\t\t\t\tconst char*);\n-\n-  template<>\n-    void\n-    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,\n-\t\t\t\t\t\t\t const char*);\n-#endif\n-\n-  /// @brief  class moneypunct_byname [22.2.6.4].\n-  template<typename _CharT, bool _Intl>\n-    class moneypunct_byname : public moneypunct<_CharT, _Intl>\n-    {\n-    public:\n-      typedef _CharT\t\t\tchar_type;\n-      typedef basic_string<_CharT>\tstring_type;\n-\n-      static const bool intl = _Intl;\n-\n-      explicit\n-      moneypunct_byname(const char* __s, size_t __refs = 0)\n-      : moneypunct<_CharT, _Intl>(__refs)\n-      {\n-\tif (std::strcmp(__s, \"C\") != 0 && std::strcmp(__s, \"POSIX\") != 0)\n-\t  {\n-\t    __c_locale __tmp;\n-\t    this->_S_create_c_locale(__tmp, __s);\n-\t    this->_M_initialize_moneypunct(__tmp);\n-\t    this->_S_destroy_c_locale(__tmp);\n-\t  }\n-      }\n-\n-    protected:\n-      virtual\n-      ~moneypunct_byname() { }\n-    };\n-\n-  template<typename _CharT, bool _Intl>\n-    const bool moneypunct_byname<_CharT, _Intl>::intl;\n-\n-_GLIBCXX_BEGIN_LDBL_NAMESPACE\n-  /**\n-   *  @brief  Facet for parsing monetary amounts.\n-   *\n-   *  This facet encapsulates the code to parse and return a monetary\n-   *  amount from a string.\n-   *\n-   *  The money_get template uses protected virtual functions to\n-   *  provide the actual results.  The public accessors forward the\n-   *  call to the virtual functions.  These virtual functions are\n-   *  hooks for developers to implement the behavior they require from\n-   *  the money_get facet.\n-  */\n-  template<typename _CharT, typename _InIter>\n-    class money_get : public locale::facet\n-    {\n-    public:\n-      // Types:\n-      //@{\n-      /// Public typedefs\n-      typedef _CharT\t\t\tchar_type;\n-      typedef _InIter\t\t\titer_type;\n-      typedef basic_string<_CharT>\tstring_type;\n-      //@}\n-\n-      /// Numpunct facet id.\n-      static locale::id\t\t\tid;\n-\n-      /**\n-       *  @brief  Constructor performs initialization.\n-       *\n-       *  This is the constructor provided by the standard.\n-       *\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      money_get(size_t __refs = 0) : facet(__refs) { }\n-\n-      /**\n-       *  @brief  Read and parse a monetary value.\n-       *\n-       *  This function reads characters from @a s, interprets them as a\n-       *  monetary value according to moneypunct and ctype facets retrieved\n-       *  from io.getloc(), and returns the result in @a units as an integral\n-       *  value moneypunct::frac_digits() * the actual amount.  For example,\n-       *  the string $10.01 in a US locale would store 1001 in @a units.\n-       *\n-       *  Any characters not part of a valid money amount are not consumed.\n-       *\n-       *  If a money value cannot be parsed from the input stream, sets\n-       *  err=(err|io.failbit).  If the stream is consumed before finishing\n-       *  parsing,  sets err=(err|io.failbit|io.eofbit).  @a units is\n-       *  unchanged if parsing fails.\n-       *\n-       *  This function works by returning the result of do_get().\n-       *\n-       *  @param  s  Start of characters to parse.\n-       *  @param  end  End of characters to parse.\n-       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n-       *  @param  io  Source of facets and io state.\n-       *  @param  err  Error field to set if parsing fails.\n-       *  @param  units  Place to store result of parsing.\n-       *  @return  Iterator referencing first character beyond valid money\n-       *\t   amount.\n-       */\n-      iter_type\n-      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n-\t  ios_base::iostate& __err, long double& __units) const\n-      { return this->do_get(__s, __end, __intl, __io, __err, __units); }\n-\n-      /**\n-       *  @brief  Read and parse a monetary value.\n-       *\n-       *  This function reads characters from @a s, interprets them as a\n-       *  monetary value according to moneypunct and ctype facets retrieved\n-       *  from io.getloc(), and returns the result in @a digits.  For example,\n-       *  the string $10.01 in a US locale would store \"1001\" in @a digits.\n-       *\n-       *  Any characters not part of a valid money amount are not consumed.\n-       *\n-       *  If a money value cannot be parsed from the input stream, sets\n-       *  err=(err|io.failbit).  If the stream is consumed before finishing\n-       *  parsing,  sets err=(err|io.failbit|io.eofbit).\n-       *\n-       *  This function works by returning the result of do_get().\n-       *\n-       *  @param  s  Start of characters to parse.\n-       *  @param  end  End of characters to parse.\n-       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n-       *  @param  io  Source of facets and io state.\n-       *  @param  err  Error field to set if parsing fails.\n-       *  @param  digits  Place to store result of parsing.\n-       *  @return  Iterator referencing first character beyond valid money\n-       *\t   amount.\n-       */\n-      iter_type\n-      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n-\t  ios_base::iostate& __err, string_type& __digits) const\n-      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }\n-\n-    protected:\n-      /// Destructor.\n-      virtual\n-      ~money_get() { }\n-\n-      /**\n-       *  @brief  Read and parse a monetary value.\n-       *\n-       *  This function reads and parses characters representing a monetary\n-       *  value.  This function is a hook for derived classes to change the\n-       *  value returned.  @see get() for details.\n-       */\n-      // XXX GLIBCXX_ABI Deprecated\n-#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n-      virtual iter_type\n-      __do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n-\t       ios_base::iostate& __err, double& __units) const;\n-#else\n-      virtual iter_type\n-      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n-\t     ios_base::iostate& __err, long double& __units) const;\n-#endif\n-\n-      /**\n-       *  @brief  Read and parse a monetary value.\n-       *\n-       *  This function reads and parses characters representing a monetary\n-       *  value.  This function is a hook for derived classes to change the\n-       *  value returned.  @see get() for details.\n-       */\n-      virtual iter_type\n-      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n-\t     ios_base::iostate& __err, string_type& __digits) const;\n-\n-      // XXX GLIBCXX_ABI Deprecated\n-#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n-      virtual iter_type\n-      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n-\t     ios_base::iostate& __err, long double& __units) const;\n-#endif\n-\n-      template<bool _Intl>\n-        iter_type\n-        _M_extract(iter_type __s, iter_type __end, ios_base& __io,\n-\t\t   ios_base::iostate& __err, string& __digits) const;     \n-    };\n-\n-  template<typename _CharT, typename _InIter>\n-    locale::id money_get<_CharT, _InIter>::id;\n-\n-  /**\n-   *  @brief  Facet for outputting monetary amounts.\n-   *\n-   *  This facet encapsulates the code to format and output a monetary\n-   *  amount.\n-   *\n-   *  The money_put template uses protected virtual functions to\n-   *  provide the actual results.  The public accessors forward the\n-   *  call to the virtual functions.  These virtual functions are\n-   *  hooks for developers to implement the behavior they require from\n-   *  the money_put facet.\n-  */\n-  template<typename _CharT, typename _OutIter>\n-    class money_put : public locale::facet\n-    {\n-    public:\n-      //@{\n-      /// Public typedefs\n-      typedef _CharT\t\t\tchar_type;\n-      typedef _OutIter\t\t\titer_type;\n-      typedef basic_string<_CharT>\tstring_type;\n-      //@}\n-\n-      /// Numpunct facet id.\n-      static locale::id\t\t\tid;\n-\n-      /**\n-       *  @brief  Constructor performs initialization.\n-       *\n-       *  This is the constructor provided by the standard.\n-       *\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      money_put(size_t __refs = 0) : facet(__refs) { }\n-\n-      /**\n-       *  @brief  Format and output a monetary value.\n-       *\n-       *  This function formats @a units as a monetary value according to\n-       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n-       *  the resulting characters to @a s.  For example, the value 1001 in a\n-       *  US locale would write \"$10.01\" to @a s.\n-       *\n-       *  This function works by returning the result of do_put().\n-       *\n-       *  @param  s  The stream to write to.\n-       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n-       *  @param  io  Source of facets and io state.\n-       *  @param  fill  char_type to use for padding.\n-       *  @param  units  Place to store result of parsing.\n-       *  @return  Iterator after writing.\n-       */\n-      iter_type\n-      put(iter_type __s, bool __intl, ios_base& __io,\n-\t  char_type __fill, long double __units) const\n-      { return this->do_put(__s, __intl, __io, __fill, __units); }\n-\n-      /**\n-       *  @brief  Format and output a monetary value.\n-       *\n-       *  This function formats @a digits as a monetary value according to\n-       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n-       *  the resulting characters to @a s.  For example, the string \"1001\" in\n-       *  a US locale would write \"$10.01\" to @a s.\n-       *\n-       *  This function works by returning the result of do_put().\n-       *\n-       *  @param  s  The stream to write to.\n-       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n-       *  @param  io  Source of facets and io state.\n-       *  @param  fill  char_type to use for padding.\n-       *  @param  units  Place to store result of parsing.\n-       *  @return  Iterator after writing.\n-       */\n-      iter_type\n-      put(iter_type __s, bool __intl, ios_base& __io,\n-\t  char_type __fill, const string_type& __digits) const\n-      { return this->do_put(__s, __intl, __io, __fill, __digits); }\n-\n-    protected:\n-      /// Destructor.\n-      virtual\n-      ~money_put() { }\n-\n-      /**\n-       *  @brief  Format and output a monetary value.\n-       *\n-       *  This function formats @a units as a monetary value according to\n-       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n-       *  the resulting characters to @a s.  For example, the value 1001 in a\n-       *  US locale would write \"$10.01\" to @a s.\n-       *\n-       *  This function is a hook for derived classes to change the value\n-       *  returned.  @see put().\n-       *\n-       *  @param  s  The stream to write to.\n-       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n-       *  @param  io  Source of facets and io state.\n-       *  @param  fill  char_type to use for padding.\n-       *  @param  units  Place to store result of parsing.\n-       *  @return  Iterator after writing.\n-       */\n-      // XXX GLIBCXX_ABI Deprecated\n-#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n-      virtual iter_type\n-      __do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t       double __units) const;\n-#else\n-      virtual iter_type\n-      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t     long double __units) const;\n-#endif\n-\n-      /**\n-       *  @brief  Format and output a monetary value.\n-       *\n-       *  This function formats @a digits as a monetary value according to\n-       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n-       *  the resulting characters to @a s.  For example, the string \"1001\" in\n-       *  a US locale would write \"$10.01\" to @a s.\n-       *\n-       *  This function is a hook for derived classes to change the value\n-       *  returned.  @see put().\n-       *\n-       *  @param  s  The stream to write to.\n-       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n-       *  @param  io  Source of facets and io state.\n-       *  @param  fill  char_type to use for padding.\n-       *  @param  units  Place to store result of parsing.\n-       *  @return  Iterator after writing.\n-       */\n-      virtual iter_type\n-      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t     const string_type& __digits) const;\n-\n-      // XXX GLIBCXX_ABI Deprecated\n-#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n-      virtual iter_type\n-      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t     long double __units) const;\n-#endif\n-\n-      template<bool _Intl>\n-        iter_type\n-        _M_insert(iter_type __s, ios_base& __io, char_type __fill,\n-\t\t  const string_type& __digits) const;\n-    };\n-\n-  template<typename _CharT, typename _OutIter>\n-    locale::id money_put<_CharT, _OutIter>::id;\n-\n-_GLIBCXX_END_LDBL_NAMESPACE\n-\n-  /**\n-   *  @brief  Messages facet base class providing catalog typedef.\n-   */\n-  struct messages_base\n-  {\n-    typedef int catalog;\n-  };\n-\n-  /**\n-   *  @brief  Facet for handling message catalogs\n-   *\n-   *  This facet encapsulates the code to retrieve messages from\n-   *  message catalogs.  The only thing defined by the standard for this facet\n-   *  is the interface.  All underlying functionality is\n-   *  implementation-defined.\n-   *\n-   *  This library currently implements 3 versions of the message facet.  The\n-   *  first version (gnu) is a wrapper around gettext, provided by libintl.\n-   *  The second version (ieee) is a wrapper around catgets.  The final\n-   *  version (default) does no actual translation.  These implementations are\n-   *  only provided for char and wchar_t instantiations.\n-   *\n-   *  The messages template uses protected virtual functions to\n-   *  provide the actual results.  The public accessors forward the\n-   *  call to the virtual functions.  These virtual functions are\n-   *  hooks for developers to implement the behavior they require from\n-   *  the messages facet.\n-  */\n-  template<typename _CharT>\n-    class messages : public locale::facet, public messages_base\n-    {\n-    public:\n-      // Types:\n-      //@{\n-      /// Public typedefs\n-      typedef _CharT\t\t\tchar_type;\n-      typedef basic_string<_CharT>\tstring_type;\n-      //@}\n-\n-    protected:\n-      // Underlying \"C\" library locale information saved from\n-      // initialization, needed by messages_byname as well.\n-      __c_locale\t\t\t_M_c_locale_messages;\n-      const char*\t\t\t_M_name_messages;\n-\n-    public:\n-      /// Numpunct facet id.\n-      static locale::id\t\t\tid;\n-\n-      /**\n-       *  @brief  Constructor performs initialization.\n-       *\n-       *  This is the constructor provided by the standard.\n-       *\n-       *  @param refs  Passed to the base facet class.\n-      */\n-      explicit\n-      messages(size_t __refs = 0);\n-\n-      // Non-standard.\n-      /**\n-       *  @brief  Internal constructor.  Not for general use.\n-       *\n-       *  This is a constructor for use by the library itself to set up new\n-       *  locales.\n-       *\n-       *  @param  cloc  The \"C\" locale.\n-       *  @param  s  The name of a locale.\n-       *  @param  refs  Refcount to pass to the base class.\n-       */\n-      explicit\n-      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);\n-\n-      /*\n-       *  @brief  Open a message catalog.\n-       *\n-       *  This function opens and returns a handle to a message catalog by\n-       *  returning do_open(s, loc).\n-       *\n-       *  @param  s  The catalog to open.\n-       *  @param  loc  Locale to use for character set conversions.\n-       *  @return  Handle to the catalog or value < 0 if open fails.\n-      */\n-      catalog\n-      open(const basic_string<char>& __s, const locale& __loc) const\n-      { return this->do_open(__s, __loc); }\n-\n-      // Non-standard and unorthodox, yet effective.\n-      /*\n-       *  @brief  Open a message catalog.\n-       *\n-       *  This non-standard function opens and returns a handle to a message\n-       *  catalog by returning do_open(s, loc).  The third argument provides a\n-       *  message catalog root directory for gnu gettext and is ignored\n-       *  otherwise.\n-       *\n-       *  @param  s  The catalog to open.\n-       *  @param  loc  Locale to use for character set conversions.\n-       *  @param  dir  Message catalog root directory.\n-       *  @return  Handle to the catalog or value < 0 if open fails.\n-      */\n-      catalog\n-      open(const basic_string<char>&, const locale&, const char*) const;\n-\n-      /*\n-       *  @brief  Look up a string in a message catalog.\n-       *\n-       *  This function retrieves and returns a message from a catalog by\n-       *  returning do_get(c, set, msgid, s).\n-       *\n-       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).\n-       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).\n-       *\n-       *  @param  c  The catalog to access.\n-       *  @param  set  Implementation-defined.\n-       *  @param  msgid  Implementation-defined.\n-       *  @param  s  Default return value if retrieval fails.\n-       *  @return  Retrieved message or @a s if get fails.\n-      */\n-      string_type\n-      get(catalog __c, int __set, int __msgid, const string_type& __s) const\n-      { return this->do_get(__c, __set, __msgid, __s); }\n-\n-      /*\n-       *  @brief  Close a message catalog.\n-       *\n-       *  Closes catalog @a c by calling do_close(c).\n-       *\n-       *  @param  c  The catalog to close.\n-      */\n-      void\n-      close(catalog __c) const\n-      { return this->do_close(__c); }\n-\n-    protected:\n-      /// Destructor.\n-      virtual\n-      ~messages();\n-\n-      /*\n-       *  @brief  Open a message catalog.\n-       *\n-       *  This function opens and returns a handle to a message catalog in an\n-       *  implementation-defined manner.  This function is a hook for derived\n-       *  classes to change the value returned.\n-       *\n-       *  @param  s  The catalog to open.\n-       *  @param  loc  Locale to use for character set conversions.\n-       *  @return  Handle to the opened catalog, value < 0 if open failed.\n-      */\n-      virtual catalog\n-      do_open(const basic_string<char>&, const locale&) const;\n-\n-      /*\n-       *  @brief  Look up a string in a message catalog.\n-       *\n-       *  This function retrieves and returns a message from a catalog in an\n-       *  implementation-defined manner.  This function is a hook for derived\n-       *  classes to change the value returned.\n-       *\n-       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).\n-       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).\n-       *\n-       *  @param  c  The catalog to access.\n-       *  @param  set  Implementation-defined.\n-       *  @param  msgid  Implementation-defined.\n-       *  @param  s  Default return value if retrieval fails.\n-       *  @return  Retrieved message or @a s if get fails.\n-      */\n-      virtual string_type\n-      do_get(catalog, int, int, const string_type& __dfault) const;\n-\n-      /*\n-       *  @brief  Close a message catalog.\n-       *\n-       *  @param  c  The catalog to close.\n-      */\n-      virtual void\n-      do_close(catalog) const;\n-\n-      // Returns a locale and codeset-converted string, given a char* message.\n-      char*\n-      _M_convert_to_char(const string_type& __msg) const\n-      {\n-\t// XXX\n-\treturn reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));\n-      }\n-\n-      // Returns a locale and codeset-converted string, given a char* message.\n-      string_type\n-      _M_convert_from_char(char*) const\n-      {\n-#if 0\n-\t// Length of message string without terminating null.\n-\tsize_t __len = char_traits<char>::length(__msg) - 1;\n-\n-\t// \"everybody can easily convert the string using\n-\t// mbsrtowcs/wcsrtombs or with iconv()\"\n-\n-\t// Convert char* to _CharT in locale used to open catalog.\n-\t// XXX need additional template parameter on messages class for this..\n-\t// typedef typename codecvt<char, _CharT, _StateT> __codecvt_type;\n-\ttypedef typename codecvt<char, _CharT, mbstate_t> __codecvt_type;\n-\n-\t__codecvt_type::state_type __state;\n-\t// XXX may need to initialize state.\n-\t//initialize_state(__state._M_init());\n-\n-\tchar* __from_next;\n-\t// XXX what size for this string?\n-\t_CharT* __to = static_cast<_CharT*>(__builtin_alloca(__len + 1));\n-\tconst __codecvt_type& __cvt = use_facet<__codecvt_type>(_M_locale_conv);\n-\t__cvt.out(__state, __msg, __msg + __len, __from_next,\n-\t\t  __to, __to + __len + 1, __to_next);\n-\treturn string_type(__to);\n-#endif\n-#if 0\n-\ttypedef ctype<_CharT> __ctype_type;\n-\t// const __ctype_type& __cvt = use_facet<__ctype_type>(_M_locale_msg);\n-\tconst __ctype_type& __cvt = use_facet<__ctype_type>(locale());\n-\t// XXX Again, proper length of converted string an issue here.\n-\t// For now, assume the converted length is not larger.\n-\t_CharT* __dest = static_cast<_CharT*>(__builtin_alloca(__len + 1));\n-\t__cvt.widen(__msg, __msg + __len, __dest);\n-\treturn basic_string<_CharT>(__dest);\n-#endif\n-\treturn string_type();\n-      }\n-     };\n-\n-  template<typename _CharT>\n-    locale::id messages<_CharT>::id;\n-\n-  // Specializations for required instantiations.\n-  template<>\n-    string\n-    messages<char>::do_get(catalog, int, int, const string&) const;\n-\n-#ifdef _GLIBCXX_USE_WCHAR_T\n-  template<>\n-    wstring\n-    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;\n-#endif\n-\n-   /// @brief class messages_byname [22.2.7.2].\n-   template<typename _CharT>\n-    class messages_byname : public messages<_CharT>\n-    {\n-    public:\n-      typedef _CharT\t\t\tchar_type;\n-      typedef basic_string<_CharT>\tstring_type;\n-\n-      explicit\n-      messages_byname(const char* __s, size_t __refs = 0);\n-\n-    protected:\n-      virtual\n-      ~messages_byname()\n-      { }\n-    };\n-\n-_GLIBCXX_END_NAMESPACE\n-\n-  // Include host and configuration specific messages functions.\n-  #include <bits/messages_members.h>\n-\n-_GLIBCXX_BEGIN_NAMESPACE(std)\n-\n   // Subclause convenience interfaces, inlines.\n   // NB: These are inline because, when used in a loop, some compilers\n   // can hoist the body out of the loop; then it's just as fast as the"}, {"sha": "d0b0a96fadce24f13da1d69b7e1a6a27f33d64c3", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 0, "deletions": 1282, "changes": 1282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -39,10 +39,6 @@\n \n #pragma GCC system_header\n \n-#include <ext/type_traits.h>\n-#include <ext/numeric_traits.h>\n-#include <bits/streambuf_iterator.h>\n-\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Facet>\n@@ -154,34 +150,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       }\n     };\n \n-  template<typename _CharT, bool _Intl>\n-    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >\n-    {\n-      const __moneypunct_cache<_CharT, _Intl>*\n-      operator() (const locale& __loc) const\n-      {\n-\tconst size_t __i = moneypunct<_CharT, _Intl>::id._M_id();\n-\tconst locale::facet** __caches = __loc._M_impl->_M_caches;\n-\tif (!__caches[__i])\n-\t  {\n-\t    __moneypunct_cache<_CharT, _Intl>* __tmp = NULL;\n-\t    try\n-\t      {\n-\t\t__tmp = new __moneypunct_cache<_CharT, _Intl>;\n-\t\t__tmp->_M_cache(__loc);\n-\t      }\n-\t    catch(...)\n-\t      {\n-\t\tdelete __tmp;\n-\t\t__throw_exception_again;\n-\t      }\n-\t    __loc._M_impl->_M_install_cache(__tmp, __i);\n-\t  }\n-\treturn static_cast<\n-\t  const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);\n-      }\n-    };\n-\n   template<typename _CharT>\n     void\n     __numpunct_cache<_CharT>::_M_cache(const locale& __loc)\n@@ -217,50 +185,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);\n     }\n \n-  template<typename _CharT, bool _Intl>\n-    void\n-    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)\n-    {\n-      _M_allocated = true;\n-\n-      const moneypunct<_CharT, _Intl>& __mp =\n-\tuse_facet<moneypunct<_CharT, _Intl> >(__loc);\n-\n-      _M_grouping_size = __mp.grouping().size();\n-      char* __grouping = new char[_M_grouping_size];\n-      __mp.grouping().copy(__grouping, _M_grouping_size);\n-      _M_grouping = __grouping;\n-      _M_use_grouping = (_M_grouping_size\n-\t\t\t && static_cast<signed char>(__mp.grouping()[0]) > 0);\n-      \n-      _M_decimal_point = __mp.decimal_point();\n-      _M_thousands_sep = __mp.thousands_sep();\n-      _M_frac_digits = __mp.frac_digits();\n-      \n-      _M_curr_symbol_size = __mp.curr_symbol().size();\n-      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];\n-      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);\n-      _M_curr_symbol = __curr_symbol;\n-      \n-      _M_positive_sign_size = __mp.positive_sign().size();\n-      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];\n-      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);\n-      _M_positive_sign = __positive_sign;\n-\n-      _M_negative_sign_size = __mp.negative_sign().size();\n-      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];\n-      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);\n-      _M_negative_sign = __negative_sign;\n-      \n-      _M_pos_format = __mp.pos_format();\n-      _M_neg_format = __mp.neg_format();\n-\n-      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n-      __ct.widen(money_base::_S_atoms,\n-\t\t money_base::_S_atoms + money_base::_S_end, _M_atoms);\n-    }\n-\n-\n   // Used by both numeric and monetary facets.\n   // Check to make sure that the __grouping_tmp string constructed in\n   // money_get or num_get matches the canonical grouping for a given\n@@ -502,10 +426,6 @@ _GLIBCXX_BEGIN_LDBL_NAMESPACE\n       return __beg;\n     }\n \n-_GLIBCXX_END_LDBL_NAMESPACE\n-\n-_GLIBCXX_BEGIN_LDBL_NAMESPACE\n-\n   template<typename _CharT, typename _InIter>\n     template<typename _ValueT>\n       _InIter\n@@ -1330,1064 +1250,8 @@ _GLIBCXX_BEGIN_LDBL_NAMESPACE\n       return __s;\n     }\n \n-  template<typename _CharT, typename _InIter>\n-    template<bool _Intl>\n-      _InIter\n-      money_get<_CharT, _InIter>::\n-      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t ios_base::iostate& __err, string& __units) const\n-      {\n-\ttypedef char_traits<_CharT>\t\t\t  __traits_type;\n-\ttypedef typename string_type::size_type\t          size_type;\t\n-\ttypedef money_base::part\t\t\t  part;\n-\ttypedef __moneypunct_cache<_CharT, _Intl>         __cache_type;\n-\t\n-\tconst locale& __loc = __io._M_getloc();\n-\tconst ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-\n-\t__use_cache<__cache_type> __uc;\n-\tconst __cache_type* __lc = __uc(__loc);\n-\tconst char_type* __lit = __lc->_M_atoms;\n-\n-\t// Deduced sign.\n-\tbool __negative = false;\n-\t// Sign size.\n-\tsize_type __sign_size = 0;\n-\t// True if sign is mandatory.\n-\tconst bool __mandatory_sign = (__lc->_M_positive_sign_size\n-\t\t\t\t       && __lc->_M_negative_sign_size);\n-\t// String of grouping info from thousands_sep plucked from __units.\n-\tstring __grouping_tmp;\n-\tif (__lc->_M_use_grouping)\n-\t  __grouping_tmp.reserve(32);\n-\t// Last position before the decimal point.\n-\tint __last_pos = 0;\n-\t// Separator positions, then, possibly, fractional digits.\n-\tint __n = 0;\n-\t// If input iterator is in a valid state.\n-\tbool __testvalid = true;\n-\t// Flag marking when a decimal point is found.\n-\tbool __testdecfound = false;\n-\n-\t// The tentative returned string is stored here.\n-\tstring __res;\n-\t__res.reserve(32);\n-\n-\tconst char_type* __lit_zero = __lit + money_base::_S_zero;\n-\tconst money_base::pattern __p = __lc->_M_neg_format;\n-\tfor (int __i = 0; __i < 4 && __testvalid; ++__i)\n-\t  {\n-\t    const part __which = static_cast<part>(__p.field[__i]);\n-\t    switch (__which)\n-\t      {\n-\t      case money_base::symbol:\n-\t\t// According to 22.2.6.1.2, p2, symbol is required\n-\t\t// if (__io.flags() & ios_base::showbase), otherwise\n-\t\t// is optional and consumed only if other characters\n-\t\t// are needed to complete the format.\n-\t\tif (__io.flags() & ios_base::showbase || __sign_size > 1\n-\t\t    || __i == 0\n-\t\t    || (__i == 1 && (__mandatory_sign\n-\t\t\t\t     || (static_cast<part>(__p.field[0])\n-\t\t\t\t\t == money_base::sign)\n-\t\t\t\t     || (static_cast<part>(__p.field[2])\n-\t\t\t\t\t == money_base::space)))\n-\t\t    || (__i == 2 && ((static_cast<part>(__p.field[3])\n-\t\t\t\t      == money_base::value)\n-\t\t\t\t     || (__mandatory_sign\n-\t\t\t\t\t && (static_cast<part>(__p.field[3])\n-\t\t\t\t\t     == money_base::sign)))))\n-\t\t  {\n-\t\t    const size_type __len = __lc->_M_curr_symbol_size;\n-\t\t    size_type __j = 0;\n-\t\t    for (; __beg != __end && __j < __len\n-\t\t\t   && *__beg == __lc->_M_curr_symbol[__j];\n-\t\t\t ++__beg, ++__j);\n-\t\t    if (__j != __len\n-\t\t\t&& (__j || __io.flags() & ios_base::showbase))\n-\t\t      __testvalid = false;\n-\t\t  }\n-\t\tbreak;\n-\t      case money_base::sign:\n-\t\t// Sign might not exist, or be more than one character long.\n-\t\tif (__lc->_M_positive_sign_size && __beg != __end\n-\t\t    && *__beg == __lc->_M_positive_sign[0])\n-\t\t  {\n-\t\t    __sign_size = __lc->_M_positive_sign_size;\n-\t\t    ++__beg;\n-\t\t  }\n-\t\telse if (__lc->_M_negative_sign_size && __beg != __end\n-\t\t\t && *__beg == __lc->_M_negative_sign[0])\n-\t\t  {\n-\t\t    __negative = true;\n-\t\t    __sign_size = __lc->_M_negative_sign_size;\n-\t\t    ++__beg;\n-\t\t  }\n-\t\telse if (__lc->_M_positive_sign_size\n-\t\t\t && !__lc->_M_negative_sign_size)\n-\t\t  // \"... if no sign is detected, the result is given the sign\n-\t\t  // that corresponds to the source of the empty string\"\n-\t\t  __negative = true;\n-\t\telse if (__mandatory_sign)\n-\t\t  __testvalid = false;\n-\t\tbreak;\n-\t      case money_base::value:\n-\t\t// Extract digits, remove and stash away the\n-\t\t// grouping of found thousands separators.\n-\t\tfor (; __beg != __end; ++__beg)\n-\t\t  {\n-\t\t    const char_type __c = *__beg;\n-\t\t    const char_type* __q = __traits_type::find(__lit_zero, \n-\t\t\t\t\t\t\t       10, __c);\n-\t\t    if (__q != 0)\n-\t\t      {\n-\t\t\t__res += money_base::_S_atoms[__q - __lit];\n-\t\t\t++__n;\n-\t\t      }\n-\t\t    else if (__c == __lc->_M_decimal_point \n-\t\t\t     && !__testdecfound)\n-\t\t      {\n-\t\t\t__last_pos = __n;\n-\t\t\t__n = 0;\n-\t\t\t__testdecfound = true;\n-\t\t      }\n-\t\t    else if (__lc->_M_use_grouping\n-\t\t\t     && __c == __lc->_M_thousands_sep\n-\t\t\t     && !__testdecfound)\n-\t\t      {\n-\t\t\tif (__n)\n-\t\t\t  {\n-\t\t\t    // Mark position for later analysis.\n-\t\t\t    __grouping_tmp += static_cast<char>(__n);\n-\t\t\t    __n = 0;\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    __testvalid = false;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t      }\n-\t\t    else\n-\t\t      break;\n-\t\t  }\n-\t\tif (__res.empty())\n-\t\t  __testvalid = false;\n-\t\tbreak;\n-\t      case money_base::space:\n-\t\t// At least one space is required.\n-\t\tif (__beg != __end && __ctype.is(ctype_base::space, *__beg))\n-\t\t  ++__beg;\n-\t\telse\n-\t\t  __testvalid = false;\n-\t      case money_base::none:\n-\t\t// Only if not at the end of the pattern.\n-\t\tif (__i != 3)\n-\t\t  for (; __beg != __end\n-\t\t\t && __ctype.is(ctype_base::space, *__beg); ++__beg);\n-\t\tbreak;\n-\t      }\n-\t  }\n-\n-\t// Need to get the rest of the sign characters, if they exist.\n-\tif (__sign_size > 1 && __testvalid)\n-\t  {\n-\t    const char_type* __sign = __negative ? __lc->_M_negative_sign\n-\t                                         : __lc->_M_positive_sign;\n-\t    size_type __i = 1;\n-\t    for (; __beg != __end && __i < __sign_size\n-\t\t   && *__beg == __sign[__i]; ++__beg, ++__i);\n-\t    \n-\t    if (__i != __sign_size)\n-\t      __testvalid = false;\n-\t  }\n-\n-\tif (__testvalid)\n-\t  {\n-\t    // Strip leading zeros.\n-\t    if (__res.size() > 1)\n-\t      {\n-\t\tconst size_type __first = __res.find_first_not_of('0');\n-\t\tconst bool __only_zeros = __first == string::npos;\n-\t\tif (__first)\n-\t\t  __res.erase(0, __only_zeros ? __res.size() - 1 : __first);\n-\t      }\n-\n-\t    // 22.2.6.1.2, p4\n-\t    if (__negative && __res[0] != '0')\n-\t      __res.insert(__res.begin(), '-');\n-\t    \n-\t    // Test for grouping fidelity.\n-\t    if (__grouping_tmp.size())\n-\t      {\n-\t\t// Add the ending grouping.\n-\t\t__grouping_tmp += static_cast<char>(__testdecfound ? __last_pos\n-\t\t\t\t\t\t                   : __n);\n-\t\tif (!std::__verify_grouping(__lc->_M_grouping,\n-\t\t\t\t\t    __lc->_M_grouping_size,\n-\t\t\t\t\t    __grouping_tmp))\n-\t\t  __err |= ios_base::failbit;\n-\t      }\n-\t    \n-\t    // Iff not enough digits were supplied after the decimal-point.\n-\t    if (__testdecfound && __lc->_M_frac_digits > 0\n-\t\t&& __n != __lc->_M_frac_digits)\n-\t      __testvalid = false;\n-\t  }\n-\t\n-\t// Iff valid sequence is not recognized.\n-\tif (!__testvalid)\n-\t  __err |= ios_base::failbit;\n-\telse\n-\t  __units.swap(__res);\n-\t\n-\t// Iff no more characters are available.\n-\tif (__beg == __end)\n-\t  __err |= ios_base::eofbit;\n-\treturn __beg;\n-      }\n-\n-#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    money_get<_CharT, _InIter>::\n-    __do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n-\t     ios_base::iostate& __err, double& __units) const\n-    {\n-      string __str;\n-      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)\n-                     : _M_extract<false>(__beg, __end, __io, __err, __str);\n-      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());\n-      return __beg;\n-    }\n-#endif\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    money_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n-\t   ios_base::iostate& __err, long double& __units) const\n-    {\n-      string __str;\n-      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)\n-\t             : _M_extract<false>(__beg, __end, __io, __err, __str);\n-      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    money_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n-\t   ios_base::iostate& __err, string_type& __digits) const\n-    {\n-      typedef typename string::size_type                  size_type;\n-\n-      const locale& __loc = __io._M_getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-\n-      string __str;\n-      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)\n-\t             : _M_extract<false>(__beg, __end, __io, __err, __str);\n-      const size_type __len = __str.size();\n-      if (__len)\n-\t{\n-\t  __digits.resize(__len);\n-\t  __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);\n-\t}\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _OutIter>\n-    template<bool _Intl>\n-      _OutIter\n-      money_put<_CharT, _OutIter>::\n-      _M_insert(iter_type __s, ios_base& __io, char_type __fill,\n-\t\tconst string_type& __digits) const\n-      {\n-\ttypedef typename string_type::size_type\t          size_type;\n-\ttypedef money_base::part                          part;\n-\ttypedef __moneypunct_cache<_CharT, _Intl>         __cache_type;\n-      \n-\tconst locale& __loc = __io._M_getloc();\n-\tconst ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-\n-\t__use_cache<__cache_type> __uc;\n-\tconst __cache_type* __lc = __uc(__loc);\n-\tconst char_type* __lit = __lc->_M_atoms;\n-\n-\t// Determine if negative or positive formats are to be used, and\n-\t// discard leading negative_sign if it is present.\n-\tconst char_type* __beg = __digits.data();\n-\n-\tmoney_base::pattern __p;\n-\tconst char_type* __sign;\n-\tsize_type __sign_size;\n-\tif (!(*__beg == __lit[money_base::_S_minus]))\n-\t  {\n-\t    __p = __lc->_M_pos_format;\n-\t    __sign = __lc->_M_positive_sign;\n-\t    __sign_size = __lc->_M_positive_sign_size;\n-\t  }\n-\telse\n-\t  {\n-\t    __p = __lc->_M_neg_format;\n-\t    __sign = __lc->_M_negative_sign;\n-\t    __sign_size = __lc->_M_negative_sign_size;\n-\t    if (__digits.size())\n-\t      ++__beg;\n-\t  }\n-       \n-\t// Look for valid numbers in the ctype facet within input digits.\n-\tsize_type __len = __ctype.scan_not(ctype_base::digit, __beg,\n-\t\t\t\t\t   __beg + __digits.size()) - __beg;\n-\tif (__len)\n-\t  {\n-\t    // Assume valid input, and attempt to format.\n-\t    // Break down input numbers into base components, as follows:\n-\t    //   final_value = grouped units + (decimal point) + (digits)\n-\t    string_type __value;\n-\t    __value.reserve(2 * __len);\n-\n-\t    // Add thousands separators to non-decimal digits, per\n-\t    // grouping rules.\n-\t    long __paddec = __len - __lc->_M_frac_digits;\n-\t    if (__paddec > 0)\n-  \t      {\n-\t\tif (__lc->_M_frac_digits < 0)\n-\t\t  __paddec = __len;\n-  \t\tif (__lc->_M_grouping_size)\n-  \t\t  {\n-\t\t    __value.assign(2 * __paddec, char_type());\n- \t\t    _CharT* __vend = \n-\t\t      std::__add_grouping(&__value[0], __lc->_M_thousands_sep,\n-\t\t\t\t\t  __lc->_M_grouping,\n-\t\t\t\t\t  __lc->_M_grouping_size,\n-\t\t\t\t\t  __beg, __beg + __paddec);\n-\t\t    __value.erase(__vend - &__value[0]);\n-  \t\t  }\n-  \t\telse\n-\t\t  __value.assign(__beg, __paddec);\n-\t      }\n-\n-\t    // Deal with decimal point, decimal digits.\n-\t    if (__lc->_M_frac_digits > 0)\n-\t      {\n-\t\t__value += __lc->_M_decimal_point;\n-\t\tif (__paddec >= 0)\n-\t\t  __value.append(__beg + __paddec, __lc->_M_frac_digits);\n-\t\telse\n-\t\t  {\n-\t\t    // Have to pad zeros in the decimal position.\n-\t\t    __value.append(-__paddec, __lit[money_base::_S_zero]);\n-\t\t    __value.append(__beg, __len);\n-\t\t  }\n-  \t      }\n-  \n-\t    // Calculate length of resulting string.\n-\t    const ios_base::fmtflags __f = __io.flags() \n-\t                                   & ios_base::adjustfield;\n-\t    __len = __value.size() + __sign_size;\n-\t    __len += ((__io.flags() & ios_base::showbase)\n-\t\t      ? __lc->_M_curr_symbol_size : 0);\n-\n-\t    string_type __res;\n-\t    __res.reserve(2 * __len);\n-\t    \n-\t    const size_type __width = static_cast<size_type>(__io.width());  \n-\t    const bool __testipad = (__f == ios_base::internal\n-\t\t\t\t     && __len < __width);\n-\t    // Fit formatted digits into the required pattern.\n-\t    for (int __i = 0; __i < 4; ++__i)\n-\t      {\n-\t\tconst part __which = static_cast<part>(__p.field[__i]);\n-\t\tswitch (__which)\n-\t\t  {\n-\t\t  case money_base::symbol:\n-\t\t    if (__io.flags() & ios_base::showbase)\n-\t\t      __res.append(__lc->_M_curr_symbol,\n-\t\t\t\t   __lc->_M_curr_symbol_size);\n-\t\t    break;\n-\t\t  case money_base::sign:\n-\t\t    // Sign might not exist, or be more than one\n-\t\t    // charater long. In that case, add in the rest\n-\t\t    // below.\n-\t\t    if (__sign_size)\n-\t\t      __res += __sign[0];\n-\t\t    break;\n-\t\t  case money_base::value:\n-\t\t    __res += __value;\n-\t\t    break;\n-\t\t  case money_base::space:\n-\t\t    // At least one space is required, but if internal\n-\t\t    // formatting is required, an arbitrary number of\n-\t\t    // fill spaces will be necessary.\n-\t\t    if (__testipad)\n-\t\t      __res.append(__width - __len, __fill);\n-\t\t    else\n-\t\t      __res += __fill;\n-\t\t    break;\n-\t\t  case money_base::none:\n-\t\t    if (__testipad)\n-\t\t      __res.append(__width - __len, __fill);\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    \n-\t    // Special case of multi-part sign parts.\n-\t    if (__sign_size > 1)\n-\t      __res.append(__sign + 1, __sign_size - 1);\n-\t    \n-\t    // Pad, if still necessary.\n-\t    __len = __res.size();\n-\t    if (__width > __len)\n-\t      {\n-\t\tif (__f == ios_base::left)\n-\t\t  // After.\n-\t\t  __res.append(__width - __len, __fill);\n-\t\telse\n-\t\t  // Before.\n-\t\t  __res.insert(0, __width - __len, __fill);\n-\t\t__len = __width;\n-\t      }\n-\t    \n-\t    // Write resulting, fully-formatted string to output iterator.\n-\t    __s = std::__write(__s, __res.data(), __len);\n-\t  }\n-\t__io.width(0);\n-\treturn __s;    \n-      }\n-\n-#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    money_put<_CharT, _OutIter>::\n-    __do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t     double __units) const\n-    { return this->do_put(__s, __intl, __io, __fill, (long double) __units); }\n-#endif\n-\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    money_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t   long double __units) const\n-    {\n-      const locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-#ifdef _GLIBCXX_USE_C99\n-      // First try a buffer perhaps big enough.\n-      int __cs_size = 64;\n-      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 328. Bad sprintf format modifier in money_put<>::do_put()\n-      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n-\t\t\t\t\t\"%.*Lf\", 0, __units);\n-      // If the buffer was not large enough, try again with the correct size.\n-      if (__len >= __cs_size)\n-\t{\n-\t  __cs_size = __len + 1;\n-\t  __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n-\t  __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n-\t\t\t\t\t\"%.*Lf\", 0, __units);\n-\t}\n-#else\n-      // max_exponent10 + 1 for the integer part, + 2 for sign and '\\0'.\n-      const int __cs_size =\n-\t__gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 3;\n-      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n-      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, 0, \"%.*Lf\", \n-\t\t\t\t\t0, __units);\n-#endif\n-      string_type __digits(__len, char_type());\n-      __ctype.widen(__cs, __cs + __len, &__digits[0]);\n-      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)\n-\t            : _M_insert<false>(__s, __io, __fill, __digits);\n-    }\n-\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    money_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n-\t   const string_type& __digits) const\n-    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)\n-\t            : _M_insert<false>(__s, __io, __fill, __digits); }\n-\n _GLIBCXX_END_LDBL_NAMESPACE\n \n-  // NB: Not especially useful. Without an ios_base object or some\n-  // kind of locale reference, we are left clawing at the air where\n-  // the side of the mountain used to be...\n-  template<typename _CharT, typename _InIter>\n-    time_base::dateorder\n-    time_get<_CharT, _InIter>::do_date_order() const\n-    { return time_base::no_order; }\n-\n-  // Expand a strftime format string and parse it.  E.g., do_get_date() may\n-  // pass %m/%d/%Y => extracted characters.\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t\t  ios_base::iostate& __err, tm* __tm,\n-\t\t\t  const _CharT* __format) const\n-    {\n-      const locale& __loc = __io._M_getloc();\n-      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      const size_t __len = char_traits<_CharT>::length(__format);\n-\n-      ios_base::iostate __tmperr = ios_base::goodbit;\n-      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)\n-\t{\n-\t  if (__ctype.narrow(__format[__i], 0) == '%')\n-\t    {\n-\t      // Verify valid formatting code, attempt to extract.\n-\t      char __c = __ctype.narrow(__format[++__i], 0);\n-\t      int __mem = 0;\n-\t      if (__c == 'E' || __c == 'O')\n-\t\t__c = __ctype.narrow(__format[++__i], 0);\n-\t      switch (__c)\n-\t\t{\n-\t\t  const char* __cs;\n-\t\t  _CharT __wcs[10];\n-\t\tcase 'a':\n-\t\t  // Abbreviated weekday name [tm_wday]\n-\t\t  const char_type*  __days1[7];\n-\t\t  __tp._M_days_abbreviated(__days1);\n-\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,\n-\t\t\t\t\t  7, __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'A':\n-\t\t  // Weekday name [tm_wday].\n-\t\t  const char_type*  __days2[7];\n-\t\t  __tp._M_days(__days2);\n-\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,\n-\t\t\t\t\t  7, __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'h':\n-\t\tcase 'b':\n-\t\t  // Abbreviated month name [tm_mon]\n-\t\t  const char_type*  __months1[12];\n-\t\t  __tp._M_months_abbreviated(__months1);\n-\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_mon, \n-\t\t\t\t\t  __months1, 12, __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'B':\n-\t\t  // Month name [tm_mon].\n-\t\t  const char_type*  __months2[12];\n-\t\t  __tp._M_months(__months2);\n-\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_mon, \n-\t\t\t\t\t  __months2, 12, __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'c':\n-\t\t  // Default time and date representation.\n-\t\t  const char_type*  __dt[2];\n-\t\t  __tp._M_date_time_formats(__dt);\n-\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n-\t\t\t\t\t\t__tm, __dt[0]);\n-\t\t  break;\n-\t\tcase 'd':\n-\t\t  // Day [01, 31]. [tm_mday]\n-\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'e':\n-\t\t  // Day [1, 31], with single digits preceded by\n-\t\t  // space. [tm_mday]\n-\t\t  if (__ctype.is(ctype_base::space, *__beg))\n-\t\t    __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,\n-\t\t\t\t\t   1, __io, __tmperr);\n-\t\t  else\n-\t\t    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,\n-\t\t\t\t\t   2, __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'D':\n-\t\t  // Equivalent to %m/%d/%y.[tm_mon, tm_mday, tm_year]\n-\t\t  __cs = \"%m/%d/%y\";\n-\t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n-\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n-\t\t\t\t\t\t__tm, __wcs);\n-\t\t  break;\n-\t\tcase 'H':\n-\t\t  // Hour [00, 23]. [tm_hour]\n-\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'I':\n-\t\t  // Hour [01, 12]. [tm_hour]\n-\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'm':\n-\t\t  // Month [01, 12]. [tm_mon]\n-\t\t  __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2, \n-\t\t\t\t\t __io, __tmperr);\n-\t\t  if (!__tmperr)\n-\t\t    __tm->tm_mon = __mem - 1;\n-\t\t  break;\n-\t\tcase 'M':\n-\t\t  // Minute [00, 59]. [tm_min]\n-\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'n':\n-\t\t  if (__ctype.narrow(*__beg, 0) == '\\n')\n-\t\t    ++__beg;\n-\t\t  else\n-\t\t    __tmperr |= ios_base::failbit;\n-\t\t  break;\n-\t\tcase 'R':\n-\t\t  // Equivalent to (%H:%M).\n-\t\t  __cs = \"%H:%M\";\n-\t\t  __ctype.widen(__cs, __cs + 6, __wcs);\n-\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n-\t\t\t\t\t\t__tm, __wcs);\n-\t\t  break;\n-\t\tcase 'S':\n-\t\t  // Seconds. [tm_sec]\n-\t\t  // [00, 60] in C99 (one leap-second), [00, 61] in C89.\n-#ifdef _GLIBCXX_USE_C99\n-\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,\n-#else\n-\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 61, 2,\n-#endif\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  break;\n-\t\tcase 't':\n-\t\t  if (__ctype.narrow(*__beg, 0) == '\\t')\n-\t\t    ++__beg;\n-\t\t  else\n-\t\t    __tmperr |= ios_base::failbit;\n-\t\t  break;\n-\t\tcase 'T':\n-\t\t  // Equivalent to (%H:%M:%S).\n-\t\t  __cs = \"%H:%M:%S\";\n-\t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n-\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n-\t\t\t\t\t\t__tm, __wcs);\n-\t\t  break;\n-\t\tcase 'x':\n-\t\t  // Locale's date.\n-\t\t  const char_type*  __dates[2];\n-\t\t  __tp._M_date_formats(__dates);\n-\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n-\t\t\t\t\t\t__tm, __dates[0]);\n-\t\t  break;\n-\t\tcase 'X':\n-\t\t  // Locale's time.\n-\t\t  const char_type*  __times[2];\n-\t\t  __tp._M_time_formats(__times);\n-\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n-\t\t\t\t\t\t__tm, __times[0]);\n-\t\t  break;\n-\t\tcase 'y':\n-\t\tcase 'C': // C99\n-\t\t  // Two digit year. [tm_year]\n-\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  break;\n-\t\tcase 'Y':\n-\t\t  // Year [1900). [tm_year]\n-\t\t  __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  if (!__tmperr)\n-\t\t    __tm->tm_year = __mem - 1900;\n-\t\t  break;\n-\t\tcase 'Z':\n-\t\t  // Timezone info.\n-\t\t  if (__ctype.is(ctype_base::upper, *__beg))\n-\t\t    {\n-\t\t      int __tmp;\n-\t\t      __beg = _M_extract_name(__beg, __end, __tmp,\n-\t\t\t\t       __timepunct_cache<_CharT>::_S_timezones,\n-\t\t\t\t\t      14, __io, __tmperr);\n-\n-\t\t      // GMT requires special effort.\n-\t\t      if (__beg != __end && !__tmperr && __tmp == 0\n-\t\t\t  && (*__beg == __ctype.widen('-')\n-\t\t\t      || *__beg == __ctype.widen('+')))\n-\t\t\t{\n-\t\t\t  __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,\n-\t\t\t\t\t\t __io, __tmperr);\n-\t\t\t  __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,\n-\t\t\t\t\t\t __io, __tmperr);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    __tmperr |= ios_base::failbit;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  // Not recognized.\n-\t\t  __tmperr |= ios_base::failbit;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      // Verify format and input match, extract and discard.\n-\t      if (__format[__i] == *__beg)\n-\t\t++__beg;\n-\t      else\n-\t\t__tmperr |= ios_base::failbit;\n-\t    }\n-\t}\n-\n-      if (__tmperr)\n-\t__err |= ios_base::failbit;\n-  \n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n-\t\t   int __min, int __max, size_t __len,\n-\t\t   ios_base& __io, ios_base::iostate& __err) const\n-    {\n-      const locale& __loc = __io._M_getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-\n-      // As-is works for __len = 1, 2, 4, the values actually used.\n-      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);\n-\n-      ++__min;\n-      size_t __i = 0;\n-      int __value = 0;\n-      for (; __beg != __end && __i < __len; ++__beg, ++__i)\n-\t{\n-\t  const char __c = __ctype.narrow(*__beg, '*');\n-\t  if (__c >= '0' && __c <= '9')\n-\t    {\n-\t      __value = __value * 10 + (__c - '0');\n-\t      const int __valuec = __value * __mult;\n-\t      if (__valuec > __max || __valuec + __mult < __min)\n-\t\tbreak;\n-\t      __mult /= 10;\n-\t    }\n-\t  else\n-\t    break;\n-\t}\n-      if (__i == __len)\n-\t__member = __value;\n-      else\n-\t__err |= ios_base::failbit;\n-\n-      return __beg;\n-    }\n-\n-  // Assumptions:\n-  // All elements in __names are unique.\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n-\t\t    const _CharT** __names, size_t __indexlen,\n-\t\t    ios_base& __io, ios_base::iostate& __err) const\n-    {\n-      typedef char_traits<_CharT>\t\t__traits_type;\n-      const locale& __loc = __io._M_getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-\n-      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)\n-\t\t\t\t\t\t\t  * __indexlen));\n-      size_t __nmatches = 0;\n-      size_t __pos = 0;\n-      bool __testvalid = true;\n-      const char_type* __name;\n-\n-      // Look for initial matches.\n-      // NB: Some of the locale data is in the form of all lowercase\n-      // names, and some is in the form of initially-capitalized\n-      // names. Look for both.\n-      if (__beg != __end)\n-\t{\n-\t  const char_type __c = *__beg;\n-\t  for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)\n-\t    if (__c == __names[__i1][0]\n-\t\t|| __c == __ctype.toupper(__names[__i1][0]))\n-\t      __matches[__nmatches++] = __i1;\n-\t}\n-\n-      while (__nmatches > 1)\n-\t{\n-\t  // Find smallest matching string.\n-\t  size_t __minlen = __traits_type::length(__names[__matches[0]]);\n-\t  for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)\n-\t    __minlen = std::min(__minlen,\n-\t\t\t      __traits_type::length(__names[__matches[__i2]]));\n-\t  ++__beg, ++__pos;\n-\t  if (__pos < __minlen && __beg != __end)\n-\t    for (size_t __i3 = 0; __i3 < __nmatches;)\n-\t      {\n-\t\t__name = __names[__matches[__i3]];\n-\t\tif (!(__name[__pos] == *__beg))\n-\t\t  __matches[__i3] = __matches[--__nmatches];\n-\t\telse\n-\t\t  ++__i3;\n-\t      }\n-\t  else\n-\t    break;\n-\t}\n-\n-      if (__nmatches == 1)\n-\t{\n-\t  // Make sure found name is completely extracted.\n-\t  ++__beg, ++__pos;\n-\t  __name = __names[__matches[0]];\n-\t  const size_t __len = __traits_type::length(__name);\n-\t  while (__pos < __len && __beg != __end && __name[__pos] == *__beg)\n-\t    ++__beg, ++__pos;\n-\n-\t  if (__len == __pos)\n-\t    __member = __matches[0];\n-\t  else\n-\t    __testvalid = false;\n-\t}\n-      else\n-\t__testvalid = false;\n-      if (!__testvalid)\n-\t__err |= ios_base::failbit;\n-\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\tios_base::iostate& __err, tm* __tm) const\n-    {\n-      const locale& __loc = __io._M_getloc();\n-      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const char_type*  __times[2];\n-      __tp._M_time_formats(__times);\n-      __beg = _M_extract_via_format(__beg, __end, __io, __err, \n-\t\t\t\t    __tm, __times[0]);\n-      if (__beg == __end)\n-\t__err |= ios_base::eofbit;\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\tios_base::iostate& __err, tm* __tm) const\n-    {\n-      const locale& __loc = __io._M_getloc();\n-      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const char_type*  __dates[2];\n-      __tp._M_date_formats(__dates);\n-      __beg = _M_extract_via_format(__beg, __end, __io, __err, \n-\t\t\t\t    __tm, __dates[0]);\n-      if (__beg == __end)\n-\t__err |= ios_base::eofbit;\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\t   ios_base::iostate& __err, tm* __tm) const\n-    {\n-      typedef char_traits<_CharT>\t\t__traits_type;\n-      const locale& __loc = __io._M_getloc();\n-      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      const char_type*  __days[7];\n-      __tp._M_days_abbreviated(__days);\n-      int __tmpwday;\n-      ios_base::iostate __tmperr = ios_base::goodbit;\n-      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7,\n-\t\t\t      __io, __tmperr);\n-\n-      // Check to see if non-abbreviated name exists, and extract.\n-      // NB: Assumes both _M_days and _M_days_abbreviated organized in\n-      // exact same order, first to last, such that the resulting\n-      // __days array with the same index points to a day, and that\n-      // day's abbreviated form.\n-      // NB: Also assumes that an abbreviated name is a subset of the name.\n-      if (!__tmperr && __beg != __end)\n-\t{\n-\t  size_t __pos = __traits_type::length(__days[__tmpwday]);\n-\t  __tp._M_days(__days);\n-\t  const char_type* __name = __days[__tmpwday];\n-\t  if (__name[__pos] == *__beg)\n-\t    {\n-\t      // Extract the rest of it.\n-\t      const size_t __len = __traits_type::length(__name);\n-\t      while (__pos < __len && __beg != __end\n-\t\t     && __name[__pos] == *__beg)\n-\t\t++__beg, ++__pos;\n-\t      if (__len != __pos)\n-\t\t__tmperr |= ios_base::failbit;\n-\t    }\n-\t}\n-      if (!__tmperr)\n-\t__tm->tm_wday = __tmpwday;\n-      else\n-\t__err |= ios_base::failbit;\n-\n-      if (__beg == __end)\n-\t__err |= ios_base::eofbit;\n-      return __beg;\n-     }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    do_get_monthname(iter_type __beg, iter_type __end,\n-                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const\n-    {\n-      typedef char_traits<_CharT>\t\t__traits_type;\n-      const locale& __loc = __io._M_getloc();\n-      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      const char_type*  __months[12];\n-      __tp._M_months_abbreviated(__months);\n-      int __tmpmon;\n-      ios_base::iostate __tmperr = ios_base::goodbit;\n-      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12, \n-\t\t\t      __io, __tmperr);\n-\n-      // Check to see if non-abbreviated name exists, and extract.\n-      // NB: Assumes both _M_months and _M_months_abbreviated organized in\n-      // exact same order, first to last, such that the resulting\n-      // __months array with the same index points to a month, and that\n-      // month's abbreviated form.\n-      // NB: Also assumes that an abbreviated name is a subset of the name.\n-      if (!__tmperr && __beg != __end)\n-\t{\n-\t  size_t __pos = __traits_type::length(__months[__tmpmon]);\n-\t  __tp._M_months(__months);\n-\t  const char_type* __name = __months[__tmpmon];\n-\t  if (__name[__pos] == *__beg)\n-\t    {\n-\t      // Extract the rest of it.\n-\t      const size_t __len = __traits_type::length(__name);\n-\t      while (__pos < __len && __beg != __end\n-\t\t     && __name[__pos] == *__beg)\n-\t\t++__beg, ++__pos;\n-\t      if (__len != __pos)\n-\t\t__tmperr |= ios_base::failbit;\n-\t    }\n-\t}\n-      if (!__tmperr)\n-\t__tm->tm_mon = __tmpmon;\n-      else\n-\t__err |= ios_base::failbit;\n-\n-      if (__beg == __end)\n-\t__err |= ios_base::eofbit;\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _InIter>\n-    _InIter\n-    time_get<_CharT, _InIter>::\n-    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n-\t\tios_base::iostate& __err, tm* __tm) const\n-    {\n-      const locale& __loc = __io._M_getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-\n-      size_t __i = 0;\n-      int __value = 0;\n-      for (; __beg != __end && __i < 4; ++__beg, ++__i)\n-\t{\n-\t  const char __c = __ctype.narrow(*__beg, '*');\n-\t  if (__c >= '0' && __c <= '9')\n-\t    __value = __value * 10 + (__c - '0');\n-\t  else\n-\t    break;\n-\t}\n-      if (__i == 2 || __i == 4)\n-\t__tm->tm_year = __i == 2 ? __value : __value - 1900;\n-      else\n-\t__err |= ios_base::failbit;\n-\n-      if (__beg == __end)\n-\t__err |= ios_base::eofbit;\n-      return __beg;\n-    }\n-\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    time_put<_CharT, _OutIter>::\n-    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n-\tconst _CharT* __beg, const _CharT* __end) const\n-    {\n-      const locale& __loc = __io._M_getloc();\n-      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      for (; __beg != __end; ++__beg)\n-\tif (__ctype.narrow(*__beg, 0) != '%')\n-\t  {\n-\t    *__s = *__beg;\n-\t    ++__s;\n-\t  }\n-\telse if (++__beg != __end)\n-\t  {\n-\t    char __format;\n-\t    char __mod = 0;\n-\t    const char __c = __ctype.narrow(*__beg, 0);\n-\t    if (__c != 'E' && __c != 'O')\n-\t      __format = __c;\n-\t    else if (++__beg != __end)\n-\t      {\n-\t\t__mod = __c;\n-\t\t__format = __ctype.narrow(*__beg, 0);\n-\t      }\n-\t    else\n-\t      break;\n-\t    __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);\n-\t  }\n-\telse\n-\t  break;\n-      return __s;\n-    }\n-\n-  template<typename _CharT, typename _OutIter>\n-    _OutIter\n-    time_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,\n-\t   char __format, char __mod) const\n-    {\n-      const locale& __loc = __io._M_getloc();\n-      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);\n-\n-      // NB: This size is arbitrary. Should this be a data member,\n-      // initialized at construction?\n-      const size_t __maxlen = 128;\n-      char_type* __res = \n-       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));\n-\n-      // NB: In IEE 1003.1-200x, and perhaps other locale models, it\n-      // is possible that the format character will be longer than one\n-      // character. Possibilities include 'E' or 'O' followed by a\n-      // format character: if __mod is not the default argument, assume\n-      // it's a valid modifier.\n-      char_type __fmt[4];\n-      __fmt[0] = __ctype.widen('%');\n-      if (!__mod)\n-\t{\n-\t  __fmt[1] = __format;\n-\t  __fmt[2] = char_type();\n-\t}\n-      else\n-\t{\n-\t  __fmt[1] = __mod;\n-\t  __fmt[2] = __format;\n-\t  __fmt[3] = char_type();\n-\t}\n-\n-      __tp._M_put(__res, __maxlen, __fmt, __tm);\n-\n-      // Write resulting, fully-formatted string to output iterator.\n-      return std::__write(__s, __res, char_traits<char_type>::length(__res));\n-    }\n-\n   // Generic version does nothing.\n   template<typename _CharT>\n     int\n@@ -2633,23 +1497,10 @@ _GLIBCXX_END_LDBL_NAMESPACE\n   // which are defined via explicit instantiations elsewhere.\n   // NB: This syntax is a GNU extension.\n #if _GLIBCXX_EXTERN_TEMPLATE\n-  extern template class moneypunct<char, false>;\n-  extern template class moneypunct<char, true>;\n-  extern template class moneypunct_byname<char, false>;\n-  extern template class moneypunct_byname<char, true>;\n-  extern template class _GLIBCXX_LDBL_NAMESPACE money_get<char>;\n-  extern template class _GLIBCXX_LDBL_NAMESPACE money_put<char>;\n   extern template class numpunct<char>;\n   extern template class numpunct_byname<char>;\n   extern template class _GLIBCXX_LDBL_NAMESPACE num_get<char>;\n   extern template class _GLIBCXX_LDBL_NAMESPACE num_put<char>;\n-  extern template class __timepunct<char>;\n-  extern template class time_put<char>;\n-  extern template class time_put_byname<char>;\n-  extern template class time_get<char>;\n-  extern template class time_get_byname<char>;\n-  extern template class messages<char>;\n-  extern template class messages_byname<char>;\n   extern template class ctype_byname<char>;\n   extern template class codecvt_byname<char, char, mbstate_t>;\n   extern template class collate<char>;\n@@ -2675,38 +1526,6 @@ _GLIBCXX_END_LDBL_NAMESPACE\n     const num_get<char>&\n     use_facet<num_get<char> >(const locale&);\n \n-  extern template\n-    const moneypunct<char, true>&\n-    use_facet<moneypunct<char, true> >(const locale&);\n-\n-  extern template\n-    const moneypunct<char, false>&\n-    use_facet<moneypunct<char, false> >(const locale&);\n-\n-  extern template\n-    const money_put<char>&\n-    use_facet<money_put<char> >(const locale&);\n-\n-  extern template\n-    const money_get<char>&\n-    use_facet<money_get<char> >(const locale&);\n-\n-  extern template\n-    const __timepunct<char>&\n-    use_facet<__timepunct<char> >(const locale&);\n-\n-  extern template\n-    const time_put<char>&\n-    use_facet<time_put<char> >(const locale&);\n-\n-  extern template\n-    const time_get<char>&\n-    use_facet<time_get<char> >(const locale&);\n-\n-  extern template\n-    const messages<char>&\n-    use_facet<messages<char> >(const locale&);\n-\n   extern template\n     bool\n     has_facet<ctype<char> >(const locale&);\n@@ -2731,52 +1550,11 @@ _GLIBCXX_END_LDBL_NAMESPACE\n     bool\n     has_facet<num_get<char> >(const locale&);\n \n-  extern template\n-    bool\n-    has_facet<moneypunct<char> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<money_put<char> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<money_get<char> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<__timepunct<char> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<time_put<char> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<time_get<char> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<messages<char> >(const locale&);\n-\n #ifdef _GLIBCXX_USE_WCHAR_T\n-  extern template class moneypunct<wchar_t, false>;\n-  extern template class moneypunct<wchar_t, true>;\n-  extern template class moneypunct_byname<wchar_t, false>;\n-  extern template class moneypunct_byname<wchar_t, true>;\n-  extern template class _GLIBCXX_LDBL_NAMESPACE money_get<wchar_t>;\n-  extern template class _GLIBCXX_LDBL_NAMESPACE money_put<wchar_t>;\n   extern template class numpunct<wchar_t>;\n   extern template class numpunct_byname<wchar_t>;\n   extern template class _GLIBCXX_LDBL_NAMESPACE num_get<wchar_t>;\n   extern template class _GLIBCXX_LDBL_NAMESPACE num_put<wchar_t>;\n-  extern template class __timepunct<wchar_t>;\n-  extern template class time_put<wchar_t>;\n-  extern template class time_put_byname<wchar_t>;\n-  extern template class time_get<wchar_t>;\n-  extern template class time_get_byname<wchar_t>;\n-  extern template class messages<wchar_t>;\n-  extern template class messages_byname<wchar_t>;\n   extern template class ctype_byname<wchar_t>;\n   extern template class codecvt_byname<wchar_t, char, mbstate_t>;\n   extern template class collate<wchar_t>;\n@@ -2802,38 +1580,6 @@ _GLIBCXX_END_LDBL_NAMESPACE\n     const num_get<wchar_t>&\n     use_facet<num_get<wchar_t> >(const locale&);\n \n-  extern template\n-    const moneypunct<wchar_t, true>&\n-    use_facet<moneypunct<wchar_t, true> >(const locale&);\n-\n-  extern template\n-    const moneypunct<wchar_t, false>&\n-    use_facet<moneypunct<wchar_t, false> >(const locale&);\n-\n-  extern template\n-    const money_put<wchar_t>&\n-    use_facet<money_put<wchar_t> >(const locale&);\n-\n-  extern template\n-    const money_get<wchar_t>&\n-    use_facet<money_get<wchar_t> >(const locale&);\n-\n-  extern template\n-    const __timepunct<wchar_t>&\n-    use_facet<__timepunct<wchar_t> >(const locale&);\n-\n-  extern template\n-    const time_put<wchar_t>&\n-    use_facet<time_put<wchar_t> >(const locale&);\n-\n-  extern template\n-    const time_get<wchar_t>&\n-    use_facet<time_get<wchar_t> >(const locale&);\n-\n-  extern template\n-    const messages<wchar_t>&\n-    use_facet<messages<wchar_t> >(const locale&);\n-\n  extern template\n     bool\n     has_facet<ctype<wchar_t> >(const locale&);\n@@ -2857,34 +1603,6 @@ _GLIBCXX_END_LDBL_NAMESPACE\n   extern template\n     bool\n     has_facet<num_get<wchar_t> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<moneypunct<wchar_t> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<money_put<wchar_t> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<money_get<wchar_t> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<__timepunct<wchar_t> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<time_put<wchar_t> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<time_get<wchar_t> >(const locale&);\n-\n-  extern template\n-    bool\n-    has_facet<messages<wchar_t> >(const locale&);\n #endif\n #endif\n "}, {"sha": "1fee4553bc621d965e4bd6e7125d585616ba660b", "filename": "libstdc++-v3/include/bits/locale_facets_nonio.h", "status": "added", "additions": 1909, "deletions": 0, "changes": 1909, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.h?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -0,0 +1,1909 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file locale_facets_nonio.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882: 22.1  Locales\n+//\n+\n+#ifndef _LOCALE_FACETS_NONIO_H\n+#define _LOCALE_FACETS_NONIO_H 1\n+\n+#include <ctime>\t// For struct tm\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  /**\n+   *  @brief  Time format ordering data.\n+   *\n+   *  This class provides an enum representing different orderings of day,\n+   *  month, and year.\n+  */\n+  class time_base\n+  {\n+  public:\n+    enum dateorder { no_order, dmy, mdy, ymd, ydm };\n+  };\n+\n+  template<typename _CharT>\n+    struct __timepunct_cache : public locale::facet\n+    {\n+      // List of all known timezones, with GMT first.\n+      static const _CharT*\t\t_S_timezones[14];\n+\n+      const _CharT*\t\t\t_M_date_format;\n+      const _CharT*\t\t\t_M_date_era_format;\n+      const _CharT*\t\t\t_M_time_format;\n+      const _CharT*\t\t\t_M_time_era_format;\n+      const _CharT*\t\t\t_M_date_time_format;\n+      const _CharT*\t\t\t_M_date_time_era_format;\n+      const _CharT*\t\t\t_M_am;\n+      const _CharT*\t\t\t_M_pm;\n+      const _CharT*\t\t\t_M_am_pm_format;\n+\n+      // Day names, starting with \"C\"'s Sunday.\n+      const _CharT*\t\t\t_M_day1;\n+      const _CharT*\t\t\t_M_day2;\n+      const _CharT*\t\t\t_M_day3;\n+      const _CharT*\t\t\t_M_day4;\n+      const _CharT*\t\t\t_M_day5;\n+      const _CharT*\t\t\t_M_day6;\n+      const _CharT*\t\t\t_M_day7;\n+\n+      // Abbreviated day names, starting with \"C\"'s Sun.\n+      const _CharT*\t\t\t_M_aday1;\n+      const _CharT*\t\t\t_M_aday2;\n+      const _CharT*\t\t\t_M_aday3;\n+      const _CharT*\t\t\t_M_aday4;\n+      const _CharT*\t\t\t_M_aday5;\n+      const _CharT*\t\t\t_M_aday6;\n+      const _CharT*\t\t\t_M_aday7;\n+\n+      // Month names, starting with \"C\"'s January.\n+      const _CharT*\t\t\t_M_month01;\n+      const _CharT*\t\t\t_M_month02;\n+      const _CharT*\t\t\t_M_month03;\n+      const _CharT*\t\t\t_M_month04;\n+      const _CharT*\t\t\t_M_month05;\n+      const _CharT*\t\t\t_M_month06;\n+      const _CharT*\t\t\t_M_month07;\n+      const _CharT*\t\t\t_M_month08;\n+      const _CharT*\t\t\t_M_month09;\n+      const _CharT*\t\t\t_M_month10;\n+      const _CharT*\t\t\t_M_month11;\n+      const _CharT*\t\t\t_M_month12;\n+\n+      // Abbreviated month names, starting with \"C\"'s Jan.\n+      const _CharT*\t\t\t_M_amonth01;\n+      const _CharT*\t\t\t_M_amonth02;\n+      const _CharT*\t\t\t_M_amonth03;\n+      const _CharT*\t\t\t_M_amonth04;\n+      const _CharT*\t\t\t_M_amonth05;\n+      const _CharT*\t\t\t_M_amonth06;\n+      const _CharT*\t\t\t_M_amonth07;\n+      const _CharT*\t\t\t_M_amonth08;\n+      const _CharT*\t\t\t_M_amonth09;\n+      const _CharT*\t\t\t_M_amonth10;\n+      const _CharT*\t\t\t_M_amonth11;\n+      const _CharT*\t\t\t_M_amonth12;\n+\n+      bool\t\t\t\t_M_allocated;\n+\n+      __timepunct_cache(size_t __refs = 0) : facet(__refs),\n+      _M_date_format(NULL), _M_date_era_format(NULL), _M_time_format(NULL),\n+      _M_time_era_format(NULL), _M_date_time_format(NULL),\n+      _M_date_time_era_format(NULL), _M_am(NULL), _M_pm(NULL),\n+      _M_am_pm_format(NULL), _M_day1(NULL), _M_day2(NULL), _M_day3(NULL),\n+      _M_day4(NULL), _M_day5(NULL), _M_day6(NULL), _M_day7(NULL),\n+      _M_aday1(NULL), _M_aday2(NULL), _M_aday3(NULL), _M_aday4(NULL),\n+      _M_aday5(NULL), _M_aday6(NULL), _M_aday7(NULL), _M_month01(NULL),\n+      _M_month02(NULL), _M_month03(NULL), _M_month04(NULL), _M_month05(NULL),\n+      _M_month06(NULL), _M_month07(NULL), _M_month08(NULL), _M_month09(NULL),\n+      _M_month10(NULL), _M_month11(NULL), _M_month12(NULL), _M_amonth01(NULL),\n+      _M_amonth02(NULL), _M_amonth03(NULL), _M_amonth04(NULL),\n+      _M_amonth05(NULL), _M_amonth06(NULL), _M_amonth07(NULL),\n+      _M_amonth08(NULL), _M_amonth09(NULL), _M_amonth10(NULL),\n+      _M_amonth11(NULL), _M_amonth12(NULL), _M_allocated(false)\n+      { }\n+\n+      ~__timepunct_cache();\n+\n+      void\n+      _M_cache(const locale& __loc);\n+\n+    private:\n+      __timepunct_cache&\n+      operator=(const __timepunct_cache&);\n+      \n+      explicit\n+      __timepunct_cache(const __timepunct_cache&);\n+    };\n+\n+  template<typename _CharT>\n+    __timepunct_cache<_CharT>::~__timepunct_cache()\n+    {\n+      if (_M_allocated)\n+\t{\n+\t  // Unused.\n+\t}\n+    }\n+\n+  // Specializations.\n+  template<>\n+    const char*\n+    __timepunct_cache<char>::_S_timezones[14];\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    const wchar_t*\n+    __timepunct_cache<wchar_t>::_S_timezones[14];\n+#endif\n+\n+  // Generic.\n+  template<typename _CharT>\n+    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];\n+\n+  template<typename _CharT>\n+    class __timepunct : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT\t\t\t__char_type;\n+      typedef basic_string<_CharT>\t__string_type;\n+      typedef __timepunct_cache<_CharT>\t__cache_type;\n+\n+    protected:\n+      __cache_type*\t\t\t_M_data;\n+      __c_locale\t\t\t_M_c_locale_timepunct;\n+      const char*\t\t\t_M_name_timepunct;\n+\n+    public:\n+      /// Numpunct facet id.\n+      static locale::id\t\t\tid;\n+\n+      explicit\n+      __timepunct(size_t __refs = 0);\n+\n+      explicit\n+      __timepunct(__cache_type* __cache, size_t __refs = 0);\n+\n+      /**\n+       *  @brief  Internal constructor. Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param cloc  The \"C\" locale.\n+       *  @param s  The name of a locale.\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);\n+\n+      // FIXME: for error checking purposes _M_put should return the return\n+      // value of strftime/wcsftime.\n+      void\n+      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,\n+\t     const tm* __tm) const;\n+\n+      void\n+      _M_date_formats(const _CharT** __date) const\n+      {\n+\t// Always have default first.\n+\t__date[0] = _M_data->_M_date_format;\n+\t__date[1] = _M_data->_M_date_era_format;\n+      }\n+\n+      void\n+      _M_time_formats(const _CharT** __time) const\n+      {\n+\t// Always have default first.\n+\t__time[0] = _M_data->_M_time_format;\n+\t__time[1] = _M_data->_M_time_era_format;\n+      }\n+\n+      void\n+      _M_date_time_formats(const _CharT** __dt) const\n+      {\n+\t// Always have default first.\n+\t__dt[0] = _M_data->_M_date_time_format;\n+\t__dt[1] = _M_data->_M_date_time_era_format;\n+      }\n+\n+      void\n+      _M_am_pm_format(const _CharT* __ampm) const\n+      { __ampm = _M_data->_M_am_pm_format; }\n+\n+      void\n+      _M_am_pm(const _CharT** __ampm) const\n+      {\n+\t__ampm[0] = _M_data->_M_am;\n+\t__ampm[1] = _M_data->_M_pm;\n+      }\n+\n+      void\n+      _M_days(const _CharT** __days) const\n+      {\n+\t__days[0] = _M_data->_M_day1;\n+\t__days[1] = _M_data->_M_day2;\n+\t__days[2] = _M_data->_M_day3;\n+\t__days[3] = _M_data->_M_day4;\n+\t__days[4] = _M_data->_M_day5;\n+\t__days[5] = _M_data->_M_day6;\n+\t__days[6] = _M_data->_M_day7;\n+      }\n+\n+      void\n+      _M_days_abbreviated(const _CharT** __days) const\n+      {\n+\t__days[0] = _M_data->_M_aday1;\n+\t__days[1] = _M_data->_M_aday2;\n+\t__days[2] = _M_data->_M_aday3;\n+\t__days[3] = _M_data->_M_aday4;\n+\t__days[4] = _M_data->_M_aday5;\n+\t__days[5] = _M_data->_M_aday6;\n+\t__days[6] = _M_data->_M_aday7;\n+      }\n+\n+      void\n+      _M_months(const _CharT** __months) const\n+      {\n+\t__months[0] = _M_data->_M_month01;\n+\t__months[1] = _M_data->_M_month02;\n+\t__months[2] = _M_data->_M_month03;\n+\t__months[3] = _M_data->_M_month04;\n+\t__months[4] = _M_data->_M_month05;\n+\t__months[5] = _M_data->_M_month06;\n+\t__months[6] = _M_data->_M_month07;\n+\t__months[7] = _M_data->_M_month08;\n+\t__months[8] = _M_data->_M_month09;\n+\t__months[9] = _M_data->_M_month10;\n+\t__months[10] = _M_data->_M_month11;\n+\t__months[11] = _M_data->_M_month12;\n+      }\n+\n+      void\n+      _M_months_abbreviated(const _CharT** __months) const\n+      {\n+\t__months[0] = _M_data->_M_amonth01;\n+\t__months[1] = _M_data->_M_amonth02;\n+\t__months[2] = _M_data->_M_amonth03;\n+\t__months[3] = _M_data->_M_amonth04;\n+\t__months[4] = _M_data->_M_amonth05;\n+\t__months[5] = _M_data->_M_amonth06;\n+\t__months[6] = _M_data->_M_amonth07;\n+\t__months[7] = _M_data->_M_amonth08;\n+\t__months[8] = _M_data->_M_amonth09;\n+\t__months[9] = _M_data->_M_amonth10;\n+\t__months[10] = _M_data->_M_amonth11;\n+\t__months[11] = _M_data->_M_amonth12;\n+      }\n+\n+    protected:\n+      virtual\n+      ~__timepunct();\n+\n+      // For use at construction time only.\n+      void\n+      _M_initialize_timepunct(__c_locale __cloc = NULL);\n+    };\n+\n+  template<typename _CharT>\n+    locale::id __timepunct<_CharT>::id;\n+\n+  // Specializations.\n+  template<>\n+    void\n+    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);\n+\n+  template<>\n+    void\n+    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    void\n+    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);\n+\n+  template<>\n+    void\n+    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,\n+\t\t\t\t const tm*) const;\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+  // Include host and configuration specific timepunct functions.\n+  #include <bits/time_members.h>\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  /**\n+   *  @brief  Facet for parsing dates and times.\n+   *\n+   *  This facet encapsulates the code to parse and return a date or\n+   *  time from a string.  It is used by the istream numeric\n+   *  extraction operators.\n+   *\n+   *  The time_get template uses protected virtual functions to provide the\n+   *  actual results.  The public accessors forward the call to the virtual\n+   *  functions.  These virtual functions are hooks for developers to\n+   *  implement the behavior they require from the time_get facet.\n+  */\n+  template<typename _CharT, typename _InIter>\n+    class time_get : public locale::facet, public time_base\n+    {\n+    public:\n+      // Types:\n+      //@{\n+      /// Public typedefs\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _InIter\t\t\titer_type;\n+      //@}\n+      typedef basic_string<_CharT>\t__string_type;\n+\n+      /// Numpunct facet id.\n+      static locale::id\t\t\tid;\n+\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      time_get(size_t __refs = 0)\n+      : facet (__refs) { }\n+\n+      /**\n+       *  @brief  Return preferred order of month, day, and year.\n+       *\n+       *  This function returns an enum from timebase::dateorder giving the\n+       *  preferred ordering if the format \"x\" given to time_put::put() only\n+       *  uses month, day, and year.  If the format \"x\" for the associated\n+       *  locale uses other fields, this function returns\n+       *  timebase::dateorder::noorder.\n+       *\n+       *  NOTE: The library always returns noorder at the moment.\n+       *\n+       *  @return  A member of timebase::dateorder.\n+      */\n+      dateorder\n+      date_order()  const\n+      { return this->do_date_order(); }\n+\n+      /**\n+       *  @brief  Parse input time string.\n+       *\n+       *  This function parses a time according to the format \"x\" and puts the\n+       *  results into a user-supplied struct tm.  The result is returned by\n+       *  calling time_get::do_get_time().\n+       *\n+       *  If there is a valid time string according to format \"x\", @a tm will\n+       *  be filled in accordingly and the returned iterator will point to the\n+       *  first character beyond the time string.  If an error occurs before\n+       *  the end, err |= ios_base::failbit.  If parsing reads all the\n+       *  characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond time string.\n+      */\n+      iter_type\n+      get_time(iter_type __beg, iter_type __end, ios_base& __io,\n+\t       ios_base::iostate& __err, tm* __tm)  const\n+      { return this->do_get_time(__beg, __end, __io, __err, __tm); }\n+\n+      /**\n+       *  @brief  Parse input date string.\n+       *\n+       *  This function parses a date according to the format \"X\" and puts the\n+       *  results into a user-supplied struct tm.  The result is returned by\n+       *  calling time_get::do_get_date().\n+       *\n+       *  If there is a valid date string according to format \"X\", @a tm will\n+       *  be filled in accordingly and the returned iterator will point to the\n+       *  first character beyond the date string.  If an error occurs before\n+       *  the end, err |= ios_base::failbit.  If parsing reads all the\n+       *  characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond date string.\n+      */\n+      iter_type\n+      get_date(iter_type __beg, iter_type __end, ios_base& __io,\n+\t       ios_base::iostate& __err, tm* __tm)  const\n+      { return this->do_get_date(__beg, __end, __io, __err, __tm); }\n+\n+      /**\n+       *  @brief  Parse input weekday string.\n+       *\n+       *  This function parses a weekday name and puts the results into a\n+       *  user-supplied struct tm.  The result is returned by calling\n+       *  time_get::do_get_weekday().\n+       *\n+       *  Parsing starts by parsing an abbreviated weekday name.  If a valid\n+       *  abbreviation is followed by a character that would lead to the full\n+       *  weekday name, parsing continues until the full name is found or an\n+       *  error occurs.  Otherwise parsing finishes at the end of the\n+       *  abbreviated name.\n+       *\n+       *  If an error occurs before the end, err |= ios_base::failbit.  If\n+       *  parsing reads all the characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond weekday name.\n+      */\n+      iter_type\n+      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t  ios_base::iostate& __err, tm* __tm) const\n+      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }\n+\n+      /**\n+       *  @brief  Parse input month string.\n+       *\n+       *  This function parses a month name and puts the results into a\n+       *  user-supplied struct tm.  The result is returned by calling\n+       *  time_get::do_get_monthname().\n+       *\n+       *  Parsing starts by parsing an abbreviated month name.  If a valid\n+       *  abbreviation is followed by a character that would lead to the full\n+       *  month name, parsing continues until the full name is found or an\n+       *  error occurs.  Otherwise parsing finishes at the end of the\n+       *  abbreviated name.\n+       *\n+       *  If an error occurs before the end, err |= ios_base::failbit.  If\n+       *  parsing reads all the characters, err |=\n+       *  ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond month name.\n+      */\n+      iter_type\n+      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t    ios_base::iostate& __err, tm* __tm) const\n+      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }\n+\n+      /**\n+       *  @brief  Parse input year string.\n+       *\n+       *  This function reads up to 4 characters to parse a year string and\n+       *  puts the results into a user-supplied struct tm.  The result is\n+       *  returned by calling time_get::do_get_year().\n+       *\n+       *  4 consecutive digits are interpreted as a full year.  If there are\n+       *  exactly 2 consecutive digits, the library interprets this as the\n+       *  number of years since 1900.\n+       *\n+       *  If an error occurs before the end, err |= ios_base::failbit.  If\n+       *  parsing reads all the characters, err |= ios_base::eofbit.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond year.\n+      */\n+      iter_type\n+      get_year(iter_type __beg, iter_type __end, ios_base& __io,\n+\t       ios_base::iostate& __err, tm* __tm) const\n+      { return this->do_get_year(__beg, __end, __io, __err, __tm); }\n+\n+    protected:\n+      /// Destructor.\n+      virtual\n+      ~time_get() { }\n+\n+      /**\n+       *  @brief  Return preferred order of month, day, and year.\n+       *\n+       *  This function returns an enum from timebase::dateorder giving the\n+       *  preferred ordering if the format \"x\" given to time_put::put() only\n+       *  uses month, day, and year.  This function is a hook for derived\n+       *  classes to change the value returned.\n+       *\n+       *  @return  A member of timebase::dateorder.\n+      */\n+      virtual dateorder\n+      do_date_order() const;\n+\n+      /**\n+       *  @brief  Parse input time string.\n+       *\n+       *  This function parses a time according to the format \"x\" and puts the\n+       *  results into a user-supplied struct tm.  This function is a hook for\n+       *  derived classes to change the value returned.  @see get_time() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond time string.\n+      */\n+      virtual iter_type\n+      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t  ios_base::iostate& __err, tm* __tm) const;\n+\n+      /**\n+       *  @brief  Parse input date string.\n+       *\n+       *  This function parses a date according to the format \"X\" and puts the\n+       *  results into a user-supplied struct tm.  This function is a hook for\n+       *  derived classes to change the value returned.  @see get_date() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond date string.\n+      */\n+      virtual iter_type\n+      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t  ios_base::iostate& __err, tm* __tm) const;\n+\n+      /**\n+       *  @brief  Parse input weekday string.\n+       *\n+       *  This function parses a weekday name and puts the results into a\n+       *  user-supplied struct tm.  This function is a hook for derived\n+       *  classes to change the value returned.  @see get_weekday() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond weekday name.\n+      */\n+      virtual iter_type\n+      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,\n+\t\t     ios_base::iostate& __err, tm* __tm) const;\n+\n+      /**\n+       *  @brief  Parse input month string.\n+       *\n+       *  This function parses a month name and puts the results into a\n+       *  user-supplied struct tm.  This function is a hook for derived\n+       *  classes to change the value returned.  @see get_monthname() for\n+       *  details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond month name.\n+      */\n+      virtual iter_type\n+      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,\n+\t\t       ios_base::iostate& __err, tm* __tm) const;\n+\n+      /**\n+       *  @brief  Parse input year string.\n+       *\n+       *  This function reads up to 4 characters to parse a year string and\n+       *  puts the results into a user-supplied struct tm.  This function is a\n+       *  hook for derived classes to change the value returned.  @see\n+       *  get_year() for details.\n+       *\n+       *  @param  beg  Start of string to parse.\n+       *  @param  end  End of string to parse.\n+       *  @param  io  Source of the locale.\n+       *  @param  err  Error flags to set.\n+       *  @param  tm  Pointer to struct tm to fill in.\n+       *  @return  Iterator to first char beyond year.\n+      */\n+      virtual iter_type\n+      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t  ios_base::iostate& __err, tm* __tm) const;\n+\n+      // Extract numeric component of length __len.\n+      iter_type\n+      _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n+\t\t     int __min, int __max, size_t __len,\n+\t\t     ios_base& __io, ios_base::iostate& __err) const;\n+\n+      // Extract day or month name, or any unique array of string\n+      // literals in a const _CharT* array.\n+      iter_type\n+      _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n+\t\t      const _CharT** __names, size_t __indexlen,\n+\t\t      ios_base& __io, ios_base::iostate& __err) const;\n+\n+      // Extract on a component-by-component basis, via __format argument.\n+      iter_type\n+      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t\t    ios_base::iostate& __err, tm* __tm,\n+\t\t\t    const _CharT* __format) const;\n+    };\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id time_get<_CharT, _InIter>::id;\n+\n+  /// @brief  class time_get_byname [22.2.5.2].\n+  template<typename _CharT, typename _InIter>\n+    class time_get_byname : public time_get<_CharT, _InIter>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _InIter\t\t\titer_type;\n+\n+      explicit\n+      time_get_byname(const char*, size_t __refs = 0)\n+      : time_get<_CharT, _InIter>(__refs) { }\n+\n+    protected:\n+      virtual\n+      ~time_get_byname() { }\n+    };\n+\n+  /**\n+   *  @brief  Facet for outputting dates and times.\n+   *\n+   *  This facet encapsulates the code to format and output dates and times\n+   *  according to formats used by strftime().\n+   *\n+   *  The time_put template uses protected virtual functions to provide the\n+   *  actual results.  The public accessors forward the call to the virtual\n+   *  functions.  These virtual functions are hooks for developers to\n+   *  implement the behavior they require from the time_put facet.\n+  */\n+  template<typename _CharT, typename _OutIter>\n+    class time_put : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      //@{\n+      /// Public typedefs\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _OutIter\t\t\titer_type;\n+      //@}\n+\n+      /// Numpunct facet id.\n+      static locale::id\t\t\tid;\n+\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      time_put(size_t __refs = 0)\n+      : facet(__refs) { }\n+\n+      /**\n+       *  @brief  Format and output a time or date.\n+       *\n+       *  This function formats the data in struct tm according to the\n+       *  provided format string.  The format string is interpreted as by\n+       *  strftime().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  io  Source of locale.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  tm  Struct tm with date and time info to format.\n+       *  @param  beg  Start of format string.\n+       *  @param  end  End of format string.\n+       *  @return  Iterator after writing.\n+       */\n+      iter_type\n+      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n+\t  const _CharT* __beg, const _CharT* __end) const;\n+\n+      /**\n+       *  @brief  Format and output a time or date.\n+       *\n+       *  This function formats the data in struct tm according to the\n+       *  provided format char and optional modifier.  The format and modifier\n+       *  are interpreted as by strftime().  It does so by returning\n+       *  time_put::do_put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  io  Source of locale.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  tm  Struct tm with date and time info to format.\n+       *  @param  format  Format char.\n+       *  @param  mod  Optional modifier char.\n+       *  @return  Iterator after writing.\n+       */\n+      iter_type\n+      put(iter_type __s, ios_base& __io, char_type __fill,\n+\t  const tm* __tm, char __format, char __mod = 0) const\n+      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }\n+\n+    protected:\n+      /// Destructor.\n+      virtual\n+      ~time_put()\n+      { }\n+\n+      /**\n+       *  @brief  Format and output a time or date.\n+       *\n+       *  This function formats the data in struct tm according to the\n+       *  provided format char and optional modifier.  This function is a hook\n+       *  for derived classes to change the value returned.  @see put() for\n+       *  more details.\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  io  Source of locale.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  tm  Struct tm with date and time info to format.\n+       *  @param  format  Format char.\n+       *  @param  mod  Optional modifier char.\n+       *  @return  Iterator after writing.\n+       */\n+      virtual iter_type\n+      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n+\t     char __format, char __mod) const;\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    locale::id time_put<_CharT, _OutIter>::id;\n+\n+  /// @brief  class time_put_byname [22.2.5.4].\n+  template<typename _CharT, typename _OutIter>\n+    class time_put_byname : public time_put<_CharT, _OutIter>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _OutIter\t\t\titer_type;\n+\n+      explicit\n+      time_put_byname(const char*, size_t __refs = 0)\n+      : time_put<_CharT, _OutIter>(__refs)\n+      { };\n+\n+    protected:\n+      virtual\n+      ~time_put_byname() { }\n+    };\n+\n+\n+  /**\n+   *  @brief  Money format ordering data.\n+   *\n+   *  This class contains an ordered array of 4 fields to represent the\n+   *  pattern for formatting a money amount.  Each field may contain one entry\n+   *  from the part enum.  symbol, sign, and value must be present and the\n+   *  remaining field must contain either none or space.  @see\n+   *  moneypunct::pos_format() and moneypunct::neg_format() for details of how\n+   *  these fields are interpreted.\n+  */\n+  class money_base\n+  {\n+  public:\n+    enum part { none, space, symbol, sign, value };\n+    struct pattern { char field[4]; };\n+\n+    static const pattern _S_default_pattern;\n+\n+    enum\n+    {\n+      _S_minus,\n+      _S_zero,\n+      _S_end = 11\n+    };\n+\n+    // String literal of acceptable (narrow) input/output, for\n+    // money_get/money_put. \"-0123456789\"\n+    static const char* _S_atoms;\n+\n+    // Construct and return valid pattern consisting of some combination of:\n+    // space none symbol sign value\n+    static pattern\n+    _S_construct_pattern(char __precedes, char __space, char __posn);\n+  };\n+\n+  template<typename _CharT, bool _Intl>\n+    struct __moneypunct_cache : public locale::facet\n+    {\n+      const char*\t\t\t_M_grouping;\n+      size_t                            _M_grouping_size;\n+      bool\t\t\t\t_M_use_grouping;\n+      _CharT\t\t\t\t_M_decimal_point;\n+      _CharT\t\t\t\t_M_thousands_sep;\n+      const _CharT*\t\t\t_M_curr_symbol;\n+      size_t                            _M_curr_symbol_size;\n+      const _CharT*\t\t\t_M_positive_sign;\n+      size_t                            _M_positive_sign_size;\n+      const _CharT*\t\t\t_M_negative_sign;\n+      size_t                            _M_negative_sign_size;\n+      int\t\t\t\t_M_frac_digits;\n+      money_base::pattern\t\t_M_pos_format;\n+      money_base::pattern\t        _M_neg_format;\n+\n+      // A list of valid numeric literals for input and output: in the standard\n+      // \"C\" locale, this is \"-0123456789\". This array contains the chars after\n+      // having been passed through the current locale's ctype<_CharT>.widen().\n+      _CharT\t\t\t\t_M_atoms[money_base::_S_end];\n+\n+      bool\t\t\t\t_M_allocated;\n+\n+      __moneypunct_cache(size_t __refs = 0) : facet(__refs),\n+      _M_grouping(NULL), _M_grouping_size(0), _M_use_grouping(false),\n+      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),\n+      _M_curr_symbol(NULL), _M_curr_symbol_size(0),\n+      _M_positive_sign(NULL), _M_positive_sign_size(0),\n+      _M_negative_sign(NULL), _M_negative_sign_size(0),\n+      _M_frac_digits(0),\n+      _M_pos_format(money_base::pattern()),\n+      _M_neg_format(money_base::pattern()), _M_allocated(false)\n+      { }\n+\n+      ~__moneypunct_cache();\n+\n+      void\n+      _M_cache(const locale& __loc);\n+\n+    private:\n+      __moneypunct_cache&\n+      operator=(const __moneypunct_cache&);\n+      \n+      explicit\n+      __moneypunct_cache(const __moneypunct_cache&);\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()\n+    {\n+      if (_M_allocated)\n+\t{\n+\t  delete [] _M_grouping;\n+\t  delete [] _M_curr_symbol;\n+\t  delete [] _M_positive_sign;\n+\t  delete [] _M_negative_sign;\n+\t}\n+    }\n+\n+  /**\n+   *  @brief  Facet for formatting data for money amounts.\n+   *\n+   *  This facet encapsulates the punctuation, grouping and other formatting\n+   *  features of money amount string representations.\n+  */\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct : public locale::facet, public money_base\n+    {\n+    public:\n+      // Types:\n+      //@{\n+      /// Public typedefs\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+      //@}\n+      typedef __moneypunct_cache<_CharT, _Intl>     __cache_type;\n+\n+    private:\n+      __cache_type*\t\t\t_M_data;\n+\n+    public:\n+      /// This value is provided by the standard, but no reason for its\n+      /// existence.\n+      static const bool\t\t\tintl = _Intl;\n+      /// Numpunct facet id.\n+      static locale::id\t\t\tid;\n+\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(NULL)\n+      { _M_initialize_moneypunct(); }\n+\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is an internal constructor.\n+       *\n+       *  @param cache  Cache for optimization.\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      moneypunct(__cache_type* __cache, size_t __refs = 0)\n+      : facet(__refs), _M_data(__cache)\n+      { _M_initialize_moneypunct(); }\n+\n+      /**\n+       *  @brief  Internal constructor. Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param cloc  The \"C\" locale.\n+       *  @param s  The name of a locale.\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)\n+      : facet(__refs), _M_data(NULL)\n+      { _M_initialize_moneypunct(__cloc, __s); }\n+\n+      /**\n+       *  @brief  Return decimal point character.\n+       *\n+       *  This function returns a char_type to use as a decimal point.  It\n+       *  does so by returning returning\n+       *  moneypunct<char_type>::do_decimal_point().\n+       *\n+       *  @return  @a char_type representing a decimal point.\n+      */\n+      char_type\n+      decimal_point() const\n+      { return this->do_decimal_point(); }\n+\n+      /**\n+       *  @brief  Return thousands separator character.\n+       *\n+       *  This function returns a char_type to use as a thousands\n+       *  separator.  It does so by returning returning\n+       *  moneypunct<char_type>::do_thousands_sep().\n+       *\n+       *  @return  char_type representing a thousands separator.\n+      */\n+      char_type\n+      thousands_sep() const\n+      { return this->do_thousands_sep(); }\n+\n+      /**\n+       *  @brief  Return grouping specification.\n+       *\n+       *  This function returns a string representing groupings for the\n+       *  integer part of an amount.  Groupings indicate where thousands\n+       *  separators should be inserted.\n+       *\n+       *  Each char in the return string is interpret as an integer rather\n+       *  than a character.  These numbers represent the number of digits in a\n+       *  group.  The first char in the string represents the number of digits\n+       *  in the least significant group.  If a char is negative, it indicates\n+       *  an unlimited number of digits for the group.  If more chars from the\n+       *  string are required to group a number, the last char is used\n+       *  repeatedly.\n+       *\n+       *  For example, if the grouping() returns \"\\003\\002\" and is applied to\n+       *  the number 123456789, this corresponds to 12,34,56,789.  Note that\n+       *  if the string was \"32\", this would put more than 50 digits into the\n+       *  least significant group if the character set is ASCII.\n+       *\n+       *  The string is returned by calling\n+       *  moneypunct<char_type>::do_grouping().\n+       *\n+       *  @return  string representing grouping specification.\n+      */\n+      string\n+      grouping() const\n+      { return this->do_grouping(); }\n+\n+      /**\n+       *  @brief  Return currency symbol string.\n+       *\n+       *  This function returns a string_type to use as a currency symbol.  It\n+       *  does so by returning returning\n+       *  moneypunct<char_type>::do_curr_symbol().\n+       *\n+       *  @return  @a string_type representing a currency symbol.\n+      */\n+      string_type\n+      curr_symbol() const\n+      { return this->do_curr_symbol(); }\n+\n+      /**\n+       *  @brief  Return positive sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for positive\n+       *  amounts.  It does so by returning returning\n+       *  moneypunct<char_type>::do_positive_sign().\n+       *\n+       *  If the return value contains more than one character, the first\n+       *  character appears in the position indicated by pos_format() and the\n+       *  remainder appear at the end of the formatted string.\n+       *\n+       *  @return  @a string_type representing a positive sign.\n+      */\n+      string_type\n+      positive_sign() const\n+      { return this->do_positive_sign(); }\n+\n+      /**\n+       *  @brief  Return negative sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for negative\n+       *  amounts.  It does so by returning returning\n+       *  moneypunct<char_type>::do_negative_sign().\n+       *\n+       *  If the return value contains more than one character, the first\n+       *  character appears in the position indicated by neg_format() and the\n+       *  remainder appear at the end of the formatted string.\n+       *\n+       *  @return  @a string_type representing a negative sign.\n+      */\n+      string_type\n+      negative_sign() const\n+      { return this->do_negative_sign(); }\n+\n+      /**\n+       *  @brief  Return number of digits in fraction.\n+       *\n+       *  This function returns the exact number of digits that make up the\n+       *  fractional part of a money amount.  It does so by returning\n+       *  returning moneypunct<char_type>::do_frac_digits().\n+       *\n+       *  The fractional part of a money amount is optional.  But if it is\n+       *  present, there must be frac_digits() digits.\n+       *\n+       *  @return  Number of digits in amount fraction.\n+      */\n+      int\n+      frac_digits() const\n+      { return this->do_frac_digits(); }\n+\n+      //@{\n+      /**\n+       *  @brief  Return pattern for money values.\n+       *\n+       *  This function returns a pattern describing the formatting of a\n+       *  positive or negative valued money amount.  It does so by returning\n+       *  returning moneypunct<char_type>::do_pos_format() or\n+       *  moneypunct<char_type>::do_neg_format().\n+       *\n+       *  The pattern has 4 fields describing the ordering of symbol, sign,\n+       *  value, and none or space.  There must be one of each in the pattern.\n+       *  The none and space enums may not appear in the first field and space\n+       *  may not appear in the final field.\n+       *\n+       *  The parts of a money string must appear in the order indicated by\n+       *  the fields of the pattern.  The symbol field indicates that the\n+       *  value of curr_symbol() may be present.  The sign field indicates\n+       *  that the value of positive_sign() or negative_sign() must be\n+       *  present.  The value field indicates that the absolute value of the\n+       *  money amount is present.  none indicates 0 or more whitespace\n+       *  characters, except at the end, where it permits no whitespace.\n+       *  space indicates that 1 or more whitespace characters must be\n+       *  present.\n+       *\n+       *  For example, for the US locale and pos_format() pattern\n+       *  {symbol,sign,value,none}, curr_symbol() == '$' positive_sign() ==\n+       *  '+', and value 10.01, and options set to force the symbol, the\n+       *  corresponding string is \"$+10.01\".\n+       *\n+       *  @return  Pattern for money values.\n+      */\n+      pattern\n+      pos_format() const\n+      { return this->do_pos_format(); }\n+\n+      pattern\n+      neg_format() const\n+      { return this->do_neg_format(); }\n+      //@}\n+\n+    protected:\n+      /// Destructor.\n+      virtual\n+      ~moneypunct();\n+\n+      /**\n+       *  @brief  Return decimal point character.\n+       *\n+       *  Returns a char_type to use as a decimal point.  This function is a\n+       *  hook for derived classes to change the value returned.\n+       *\n+       *  @return  @a char_type representing a decimal point.\n+      */\n+      virtual char_type\n+      do_decimal_point() const\n+      { return _M_data->_M_decimal_point; }\n+\n+      /**\n+       *  @brief  Return thousands separator character.\n+       *\n+       *  Returns a char_type to use as a thousands separator.  This function\n+       *  is a hook for derived classes to change the value returned.\n+       *\n+       *  @return  @a char_type representing a thousands separator.\n+      */\n+      virtual char_type\n+      do_thousands_sep() const\n+      { return _M_data->_M_thousands_sep; }\n+\n+      /**\n+       *  @brief  Return grouping specification.\n+       *\n+       *  Returns a string representing groupings for the integer part of a\n+       *  number.  This function is a hook for derived classes to change the\n+       *  value returned.  @see grouping() for details.\n+       *\n+       *  @return  String representing grouping specification.\n+      */\n+      virtual string\n+      do_grouping() const\n+      { return _M_data->_M_grouping; }\n+\n+      /**\n+       *  @brief  Return currency symbol string.\n+       *\n+       *  This function returns a string_type to use as a currency symbol.\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.  @see curr_symbol() for details.\n+       *\n+       *  @return  @a string_type representing a currency symbol.\n+      */\n+      virtual string_type\n+      do_curr_symbol()   const\n+      { return _M_data->_M_curr_symbol; }\n+\n+      /**\n+       *  @brief  Return positive sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for positive\n+       *  amounts.  This function is a hook for derived classes to change the\n+       *  value returned.  @see positive_sign() for details.\n+       *\n+       *  @return  @a string_type representing a positive sign.\n+      */\n+      virtual string_type\n+      do_positive_sign() const\n+      { return _M_data->_M_positive_sign; }\n+\n+      /**\n+       *  @brief  Return negative sign string.\n+       *\n+       *  This function returns a string_type to use as a sign for negative\n+       *  amounts.  This function is a hook for derived classes to change the\n+       *  value returned.  @see negative_sign() for details.\n+       *\n+       *  @return  @a string_type representing a negative sign.\n+      */\n+      virtual string_type\n+      do_negative_sign() const\n+      { return _M_data->_M_negative_sign; }\n+\n+      /**\n+       *  @brief  Return number of digits in fraction.\n+       *\n+       *  This function returns the exact number of digits that make up the\n+       *  fractional part of a money amount.  This function is a hook for\n+       *  derived classes to change the value returned.  @see frac_digits()\n+       *  for details.\n+       *\n+       *  @return  Number of digits in amount fraction.\n+      */\n+      virtual int\n+      do_frac_digits() const\n+      { return _M_data->_M_frac_digits; }\n+\n+      /**\n+       *  @brief  Return pattern for money values.\n+       *\n+       *  This function returns a pattern describing the formatting of a\n+       *  positive valued money amount.  This function is a hook for derived\n+       *  classes to change the value returned.  @see pos_format() for\n+       *  details.\n+       *\n+       *  @return  Pattern for money values.\n+      */\n+      virtual pattern\n+      do_pos_format() const\n+      { return _M_data->_M_pos_format; }\n+\n+      /**\n+       *  @brief  Return pattern for money values.\n+       *\n+       *  This function returns a pattern describing the formatting of a\n+       *  negative valued money amount.  This function is a hook for derived\n+       *  classes to change the value returned.  @see neg_format() for\n+       *  details.\n+       *\n+       *  @return  Pattern for money values.\n+      */\n+      virtual pattern\n+      do_neg_format() const\n+      { return _M_data->_M_neg_format; }\n+\n+      // For use at construction time only.\n+       void\n+       _M_initialize_moneypunct(__c_locale __cloc = NULL,\n+\t\t\t\tconst char* __name = NULL);\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    locale::id moneypunct<_CharT, _Intl>::id;\n+\n+  template<typename _CharT, bool _Intl>\n+    const bool moneypunct<_CharT, _Intl>::intl;\n+\n+  template<>\n+    moneypunct<char, true>::~moneypunct();\n+\n+  template<>\n+    moneypunct<char, false>::~moneypunct();\n+\n+  template<>\n+    void\n+    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);\n+\n+  template<>\n+    void\n+    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    moneypunct<wchar_t, true>::~moneypunct();\n+\n+  template<>\n+    moneypunct<wchar_t, false>::~moneypunct();\n+\n+  template<>\n+    void\n+    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,\n+\t\t\t\t\t\t\tconst char*);\n+\n+  template<>\n+    void\n+    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,\n+\t\t\t\t\t\t\t const char*);\n+#endif\n+\n+  /// @brief  class moneypunct_byname [22.2.6.4].\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct_byname : public moneypunct<_CharT, _Intl>\n+    {\n+    public:\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+\n+      static const bool intl = _Intl;\n+\n+      explicit\n+      moneypunct_byname(const char* __s, size_t __refs = 0)\n+      : moneypunct<_CharT, _Intl>(__refs)\n+      {\n+\tif (std::strcmp(__s, \"C\") != 0 && std::strcmp(__s, \"POSIX\") != 0)\n+\t  {\n+\t    __c_locale __tmp;\n+\t    this->_S_create_c_locale(__tmp, __s);\n+\t    this->_M_initialize_moneypunct(__tmp);\n+\t    this->_S_destroy_c_locale(__tmp);\n+\t  }\n+      }\n+\n+    protected:\n+      virtual\n+      ~moneypunct_byname() { }\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    const bool moneypunct_byname<_CharT, _Intl>::intl;\n+\n+_GLIBCXX_BEGIN_LDBL_NAMESPACE\n+\n+  /**\n+   *  @brief  Facet for parsing monetary amounts.\n+   *\n+   *  This facet encapsulates the code to parse and return a monetary\n+   *  amount from a string.\n+   *\n+   *  The money_get template uses protected virtual functions to\n+   *  provide the actual results.  The public accessors forward the\n+   *  call to the virtual functions.  These virtual functions are\n+   *  hooks for developers to implement the behavior they require from\n+   *  the money_get facet.\n+  */\n+  template<typename _CharT, typename _InIter>\n+    class money_get : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      //@{\n+      /// Public typedefs\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _InIter\t\t\titer_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+      //@}\n+\n+      /// Numpunct facet id.\n+      static locale::id\t\t\tid;\n+\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      money_get(size_t __refs = 0) : facet(__refs) { }\n+\n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads characters from @a s, interprets them as a\n+       *  monetary value according to moneypunct and ctype facets retrieved\n+       *  from io.getloc(), and returns the result in @a units as an integral\n+       *  value moneypunct::frac_digits() * the actual amount.  For example,\n+       *  the string $10.01 in a US locale would store 1001 in @a units.\n+       *\n+       *  Any characters not part of a valid money amount are not consumed.\n+       *\n+       *  If a money value cannot be parsed from the input stream, sets\n+       *  err=(err|io.failbit).  If the stream is consumed before finishing\n+       *  parsing,  sets err=(err|io.failbit|io.eofbit).  @a units is\n+       *  unchanged if parsing fails.\n+       *\n+       *  This function works by returning the result of do_get().\n+       *\n+       *  @param  s  Start of characters to parse.\n+       *  @param  end  End of characters to parse.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  err  Error field to set if parsing fails.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator referencing first character beyond valid money\n+       *\t   amount.\n+       */\n+      iter_type\n+      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n+\t  ios_base::iostate& __err, long double& __units) const\n+      { return this->do_get(__s, __end, __intl, __io, __err, __units); }\n+\n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads characters from @a s, interprets them as a\n+       *  monetary value according to moneypunct and ctype facets retrieved\n+       *  from io.getloc(), and returns the result in @a digits.  For example,\n+       *  the string $10.01 in a US locale would store \"1001\" in @a digits.\n+       *\n+       *  Any characters not part of a valid money amount are not consumed.\n+       *\n+       *  If a money value cannot be parsed from the input stream, sets\n+       *  err=(err|io.failbit).  If the stream is consumed before finishing\n+       *  parsing,  sets err=(err|io.failbit|io.eofbit).\n+       *\n+       *  This function works by returning the result of do_get().\n+       *\n+       *  @param  s  Start of characters to parse.\n+       *  @param  end  End of characters to parse.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  err  Error field to set if parsing fails.\n+       *  @param  digits  Place to store result of parsing.\n+       *  @return  Iterator referencing first character beyond valid money\n+       *\t   amount.\n+       */\n+      iter_type\n+      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n+\t  ios_base::iostate& __err, string_type& __digits) const\n+      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }\n+\n+    protected:\n+      /// Destructor.\n+      virtual\n+      ~money_get() { }\n+\n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads and parses characters representing a monetary\n+       *  value.  This function is a hook for derived classes to change the\n+       *  value returned.  @see get() for details.\n+       */\n+      // XXX GLIBCXX_ABI Deprecated\n+#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n+      virtual iter_type\n+      __do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n+\t       ios_base::iostate& __err, double& __units) const;\n+#else\n+      virtual iter_type\n+      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n+\t     ios_base::iostate& __err, long double& __units) const;\n+#endif\n+\n+      /**\n+       *  @brief  Read and parse a monetary value.\n+       *\n+       *  This function reads and parses characters representing a monetary\n+       *  value.  This function is a hook for derived classes to change the\n+       *  value returned.  @see get() for details.\n+       */\n+      virtual iter_type\n+      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n+\t     ios_base::iostate& __err, string_type& __digits) const;\n+\n+      // XXX GLIBCXX_ABI Deprecated\n+#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n+      virtual iter_type\n+      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n+\t     ios_base::iostate& __err, long double& __units) const;\n+#endif\n+\n+      template<bool _Intl>\n+        iter_type\n+        _M_extract(iter_type __s, iter_type __end, ios_base& __io,\n+\t\t   ios_base::iostate& __err, string& __digits) const;     \n+    };\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id money_get<_CharT, _InIter>::id;\n+\n+  /**\n+   *  @brief  Facet for outputting monetary amounts.\n+   *\n+   *  This facet encapsulates the code to format and output a monetary\n+   *  amount.\n+   *\n+   *  The money_put template uses protected virtual functions to\n+   *  provide the actual results.  The public accessors forward the\n+   *  call to the virtual functions.  These virtual functions are\n+   *  hooks for developers to implement the behavior they require from\n+   *  the money_put facet.\n+  */\n+  template<typename _CharT, typename _OutIter>\n+    class money_put : public locale::facet\n+    {\n+    public:\n+      //@{\n+      /// Public typedefs\n+      typedef _CharT\t\t\tchar_type;\n+      typedef _OutIter\t\t\titer_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+      //@}\n+\n+      /// Numpunct facet id.\n+      static locale::id\t\t\tid;\n+\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      money_put(size_t __refs = 0) : facet(__refs) { }\n+\n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a units as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the value 1001 in a\n+       *  US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function works by returning the result of do_put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n+      iter_type\n+      put(iter_type __s, bool __intl, ios_base& __io,\n+\t  char_type __fill, long double __units) const\n+      { return this->do_put(__s, __intl, __io, __fill, __units); }\n+\n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a digits as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the string \"1001\" in\n+       *  a US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function works by returning the result of do_put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n+      iter_type\n+      put(iter_type __s, bool __intl, ios_base& __io,\n+\t  char_type __fill, const string_type& __digits) const\n+      { return this->do_put(__s, __intl, __io, __fill, __digits); }\n+\n+    protected:\n+      /// Destructor.\n+      virtual\n+      ~money_put() { }\n+\n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a units as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the value 1001 in a\n+       *  US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.  @see put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n+      // XXX GLIBCXX_ABI Deprecated\n+#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n+      virtual iter_type\n+      __do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t       double __units) const;\n+#else\n+      virtual iter_type\n+      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     long double __units) const;\n+#endif\n+\n+      /**\n+       *  @brief  Format and output a monetary value.\n+       *\n+       *  This function formats @a digits as a monetary value according to\n+       *  moneypunct and ctype facets retrieved from io.getloc(), and writes\n+       *  the resulting characters to @a s.  For example, the string \"1001\" in\n+       *  a US locale would write \"$10.01\" to @a s.\n+       *\n+       *  This function is a hook for derived classes to change the value\n+       *  returned.  @see put().\n+       *\n+       *  @param  s  The stream to write to.\n+       *  @param  intl  Parameter to use_facet<moneypunct<CharT,intl> >.\n+       *  @param  io  Source of facets and io state.\n+       *  @param  fill  char_type to use for padding.\n+       *  @param  units  Place to store result of parsing.\n+       *  @return  Iterator after writing.\n+       */\n+      virtual iter_type\n+      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     const string_type& __digits) const;\n+\n+      // XXX GLIBCXX_ABI Deprecated\n+#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n+      virtual iter_type\n+      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     long double __units) const;\n+#endif\n+\n+      template<bool _Intl>\n+        iter_type\n+        _M_insert(iter_type __s, ios_base& __io, char_type __fill,\n+\t\t  const string_type& __digits) const;\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    locale::id money_put<_CharT, _OutIter>::id;\n+\n+_GLIBCXX_END_LDBL_NAMESPACE\n+\n+  /**\n+   *  @brief  Messages facet base class providing catalog typedef.\n+   */\n+  struct messages_base\n+  {\n+    typedef int catalog;\n+  };\n+\n+  /**\n+   *  @brief  Facet for handling message catalogs\n+   *\n+   *  This facet encapsulates the code to retrieve messages from\n+   *  message catalogs.  The only thing defined by the standard for this facet\n+   *  is the interface.  All underlying functionality is\n+   *  implementation-defined.\n+   *\n+   *  This library currently implements 3 versions of the message facet.  The\n+   *  first version (gnu) is a wrapper around gettext, provided by libintl.\n+   *  The second version (ieee) is a wrapper around catgets.  The final\n+   *  version (default) does no actual translation.  These implementations are\n+   *  only provided for char and wchar_t instantiations.\n+   *\n+   *  The messages template uses protected virtual functions to\n+   *  provide the actual results.  The public accessors forward the\n+   *  call to the virtual functions.  These virtual functions are\n+   *  hooks for developers to implement the behavior they require from\n+   *  the messages facet.\n+  */\n+  template<typename _CharT>\n+    class messages : public locale::facet, public messages_base\n+    {\n+    public:\n+      // Types:\n+      //@{\n+      /// Public typedefs\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+      //@}\n+\n+    protected:\n+      // Underlying \"C\" library locale information saved from\n+      // initialization, needed by messages_byname as well.\n+      __c_locale\t\t\t_M_c_locale_messages;\n+      const char*\t\t\t_M_name_messages;\n+\n+    public:\n+      /// Numpunct facet id.\n+      static locale::id\t\t\tid;\n+\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  This is the constructor provided by the standard.\n+       *\n+       *  @param refs  Passed to the base facet class.\n+      */\n+      explicit\n+      messages(size_t __refs = 0);\n+\n+      // Non-standard.\n+      /**\n+       *  @brief  Internal constructor.  Not for general use.\n+       *\n+       *  This is a constructor for use by the library itself to set up new\n+       *  locales.\n+       *\n+       *  @param  cloc  The \"C\" locale.\n+       *  @param  s  The name of a locale.\n+       *  @param  refs  Refcount to pass to the base class.\n+       */\n+      explicit\n+      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);\n+\n+      /*\n+       *  @brief  Open a message catalog.\n+       *\n+       *  This function opens and returns a handle to a message catalog by\n+       *  returning do_open(s, loc).\n+       *\n+       *  @param  s  The catalog to open.\n+       *  @param  loc  Locale to use for character set conversions.\n+       *  @return  Handle to the catalog or value < 0 if open fails.\n+      */\n+      catalog\n+      open(const basic_string<char>& __s, const locale& __loc) const\n+      { return this->do_open(__s, __loc); }\n+\n+      // Non-standard and unorthodox, yet effective.\n+      /*\n+       *  @brief  Open a message catalog.\n+       *\n+       *  This non-standard function opens and returns a handle to a message\n+       *  catalog by returning do_open(s, loc).  The third argument provides a\n+       *  message catalog root directory for gnu gettext and is ignored\n+       *  otherwise.\n+       *\n+       *  @param  s  The catalog to open.\n+       *  @param  loc  Locale to use for character set conversions.\n+       *  @param  dir  Message catalog root directory.\n+       *  @return  Handle to the catalog or value < 0 if open fails.\n+      */\n+      catalog\n+      open(const basic_string<char>&, const locale&, const char*) const;\n+\n+      /*\n+       *  @brief  Look up a string in a message catalog.\n+       *\n+       *  This function retrieves and returns a message from a catalog by\n+       *  returning do_get(c, set, msgid, s).\n+       *\n+       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).\n+       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).\n+       *\n+       *  @param  c  The catalog to access.\n+       *  @param  set  Implementation-defined.\n+       *  @param  msgid  Implementation-defined.\n+       *  @param  s  Default return value if retrieval fails.\n+       *  @return  Retrieved message or @a s if get fails.\n+      */\n+      string_type\n+      get(catalog __c, int __set, int __msgid, const string_type& __s) const\n+      { return this->do_get(__c, __set, __msgid, __s); }\n+\n+      /*\n+       *  @brief  Close a message catalog.\n+       *\n+       *  Closes catalog @a c by calling do_close(c).\n+       *\n+       *  @param  c  The catalog to close.\n+      */\n+      void\n+      close(catalog __c) const\n+      { return this->do_close(__c); }\n+\n+    protected:\n+      /// Destructor.\n+      virtual\n+      ~messages();\n+\n+      /*\n+       *  @brief  Open a message catalog.\n+       *\n+       *  This function opens and returns a handle to a message catalog in an\n+       *  implementation-defined manner.  This function is a hook for derived\n+       *  classes to change the value returned.\n+       *\n+       *  @param  s  The catalog to open.\n+       *  @param  loc  Locale to use for character set conversions.\n+       *  @return  Handle to the opened catalog, value < 0 if open failed.\n+      */\n+      virtual catalog\n+      do_open(const basic_string<char>&, const locale&) const;\n+\n+      /*\n+       *  @brief  Look up a string in a message catalog.\n+       *\n+       *  This function retrieves and returns a message from a catalog in an\n+       *  implementation-defined manner.  This function is a hook for derived\n+       *  classes to change the value returned.\n+       *\n+       *  For gnu, @a set and @a msgid are ignored.  Returns gettext(s).\n+       *  For default, returns s. For ieee, returns catgets(c,set,msgid,s).\n+       *\n+       *  @param  c  The catalog to access.\n+       *  @param  set  Implementation-defined.\n+       *  @param  msgid  Implementation-defined.\n+       *  @param  s  Default return value if retrieval fails.\n+       *  @return  Retrieved message or @a s if get fails.\n+      */\n+      virtual string_type\n+      do_get(catalog, int, int, const string_type& __dfault) const;\n+\n+      /*\n+       *  @brief  Close a message catalog.\n+       *\n+       *  @param  c  The catalog to close.\n+      */\n+      virtual void\n+      do_close(catalog) const;\n+\n+      // Returns a locale and codeset-converted string, given a char* message.\n+      char*\n+      _M_convert_to_char(const string_type& __msg) const\n+      {\n+\t// XXX\n+\treturn reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));\n+      }\n+\n+      // Returns a locale and codeset-converted string, given a char* message.\n+      string_type\n+      _M_convert_from_char(char*) const\n+      {\n+#if 0\n+\t// Length of message string without terminating null.\n+\tsize_t __len = char_traits<char>::length(__msg) - 1;\n+\n+\t// \"everybody can easily convert the string using\n+\t// mbsrtowcs/wcsrtombs or with iconv()\"\n+\n+\t// Convert char* to _CharT in locale used to open catalog.\n+\t// XXX need additional template parameter on messages class for this..\n+\t// typedef typename codecvt<char, _CharT, _StateT> __codecvt_type;\n+\ttypedef typename codecvt<char, _CharT, mbstate_t> __codecvt_type;\n+\n+\t__codecvt_type::state_type __state;\n+\t// XXX may need to initialize state.\n+\t//initialize_state(__state._M_init());\n+\n+\tchar* __from_next;\n+\t// XXX what size for this string?\n+\t_CharT* __to = static_cast<_CharT*>(__builtin_alloca(__len + 1));\n+\tconst __codecvt_type& __cvt = use_facet<__codecvt_type>(_M_locale_conv);\n+\t__cvt.out(__state, __msg, __msg + __len, __from_next,\n+\t\t  __to, __to + __len + 1, __to_next);\n+\treturn string_type(__to);\n+#endif\n+#if 0\n+\ttypedef ctype<_CharT> __ctype_type;\n+\t// const __ctype_type& __cvt = use_facet<__ctype_type>(_M_locale_msg);\n+\tconst __ctype_type& __cvt = use_facet<__ctype_type>(locale());\n+\t// XXX Again, proper length of converted string an issue here.\n+\t// For now, assume the converted length is not larger.\n+\t_CharT* __dest = static_cast<_CharT*>(__builtin_alloca(__len + 1));\n+\t__cvt.widen(__msg, __msg + __len, __dest);\n+\treturn basic_string<_CharT>(__dest);\n+#endif\n+\treturn string_type();\n+      }\n+     };\n+\n+  template<typename _CharT>\n+    locale::id messages<_CharT>::id;\n+\n+  // Specializations for required instantiations.\n+  template<>\n+    string\n+    messages<char>::do_get(catalog, int, int, const string&) const;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    wstring\n+    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;\n+#endif\n+\n+   /// @brief class messages_byname [22.2.7.2].\n+   template<typename _CharT>\n+    class messages_byname : public messages<_CharT>\n+    {\n+    public:\n+      typedef _CharT\t\t\tchar_type;\n+      typedef basic_string<_CharT>\tstring_type;\n+\n+      explicit\n+      messages_byname(const char* __s, size_t __refs = 0);\n+\n+    protected:\n+      virtual\n+      ~messages_byname()\n+      { }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+  // Include host and configuration specific messages functions.\n+#include <bits/messages_members.h>\n+\n+#endif"}, {"sha": "190caf37282d766c99546097ff17ede2ffb2368e", "filename": "libstdc++-v3/include/bits/locale_facets_nonio.tcc", "status": "added", "additions": 1328, "deletions": 0, "changes": 1328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.tcc?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -0,0 +1,1328 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file locale_facets_nonio.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _LOCALE_FACETS_NONIO_TCC\n+#define _LOCALE_FACETS_NONIO_TCC 1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  template<typename _CharT, bool _Intl>\n+    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >\n+    {\n+      const __moneypunct_cache<_CharT, _Intl>*\n+      operator() (const locale& __loc) const\n+      {\n+\tconst size_t __i = moneypunct<_CharT, _Intl>::id._M_id();\n+\tconst locale::facet** __caches = __loc._M_impl->_M_caches;\n+\tif (!__caches[__i])\n+\t  {\n+\t    __moneypunct_cache<_CharT, _Intl>* __tmp = NULL;\n+\t    try\n+\t      {\n+\t\t__tmp = new __moneypunct_cache<_CharT, _Intl>;\n+\t\t__tmp->_M_cache(__loc);\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\tdelete __tmp;\n+\t\t__throw_exception_again;\n+\t      }\n+\t    __loc._M_impl->_M_install_cache(__tmp, __i);\n+\t  }\n+\treturn static_cast<\n+\t  const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);\n+      }\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    void\n+    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)\n+    {\n+      _M_allocated = true;\n+\n+      const moneypunct<_CharT, _Intl>& __mp =\n+\tuse_facet<moneypunct<_CharT, _Intl> >(__loc);\n+\n+      _M_grouping_size = __mp.grouping().size();\n+      char* __grouping = new char[_M_grouping_size];\n+      __mp.grouping().copy(__grouping, _M_grouping_size);\n+      _M_grouping = __grouping;\n+      _M_use_grouping = (_M_grouping_size\n+\t\t\t && static_cast<signed char>(__mp.grouping()[0]) > 0);\n+      \n+      _M_decimal_point = __mp.decimal_point();\n+      _M_thousands_sep = __mp.thousands_sep();\n+      _M_frac_digits = __mp.frac_digits();\n+      \n+      _M_curr_symbol_size = __mp.curr_symbol().size();\n+      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];\n+      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);\n+      _M_curr_symbol = __curr_symbol;\n+      \n+      _M_positive_sign_size = __mp.positive_sign().size();\n+      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];\n+      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);\n+      _M_positive_sign = __positive_sign;\n+\n+      _M_negative_sign_size = __mp.negative_sign().size();\n+      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];\n+      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);\n+      _M_negative_sign = __negative_sign;\n+      \n+      _M_pos_format = __mp.pos_format();\n+      _M_neg_format = __mp.neg_format();\n+\n+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n+      __ct.widen(money_base::_S_atoms,\n+\t\t money_base::_S_atoms + money_base::_S_end, _M_atoms);\n+    }\n+\n+_GLIBCXX_BEGIN_LDBL_NAMESPACE\n+\n+  template<typename _CharT, typename _InIter>\n+    template<bool _Intl>\n+      _InIter\n+      money_get<_CharT, _InIter>::\n+      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t ios_base::iostate& __err, string& __units) const\n+      {\n+\ttypedef char_traits<_CharT>\t\t\t  __traits_type;\n+\ttypedef typename string_type::size_type\t          size_type;\t\n+\ttypedef money_base::part\t\t\t  part;\n+\ttypedef __moneypunct_cache<_CharT, _Intl>         __cache_type;\n+\t\n+\tconst locale& __loc = __io._M_getloc();\n+\tconst ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n+\t__use_cache<__cache_type> __uc;\n+\tconst __cache_type* __lc = __uc(__loc);\n+\tconst char_type* __lit = __lc->_M_atoms;\n+\n+\t// Deduced sign.\n+\tbool __negative = false;\n+\t// Sign size.\n+\tsize_type __sign_size = 0;\n+\t// True if sign is mandatory.\n+\tconst bool __mandatory_sign = (__lc->_M_positive_sign_size\n+\t\t\t\t       && __lc->_M_negative_sign_size);\n+\t// String of grouping info from thousands_sep plucked from __units.\n+\tstring __grouping_tmp;\n+\tif (__lc->_M_use_grouping)\n+\t  __grouping_tmp.reserve(32);\n+\t// Last position before the decimal point.\n+\tint __last_pos = 0;\n+\t// Separator positions, then, possibly, fractional digits.\n+\tint __n = 0;\n+\t// If input iterator is in a valid state.\n+\tbool __testvalid = true;\n+\t// Flag marking when a decimal point is found.\n+\tbool __testdecfound = false;\n+\n+\t// The tentative returned string is stored here.\n+\tstring __res;\n+\t__res.reserve(32);\n+\n+\tconst char_type* __lit_zero = __lit + money_base::_S_zero;\n+\tconst money_base::pattern __p = __lc->_M_neg_format;\n+\tfor (int __i = 0; __i < 4 && __testvalid; ++__i)\n+\t  {\n+\t    const part __which = static_cast<part>(__p.field[__i]);\n+\t    switch (__which)\n+\t      {\n+\t      case money_base::symbol:\n+\t\t// According to 22.2.6.1.2, p2, symbol is required\n+\t\t// if (__io.flags() & ios_base::showbase), otherwise\n+\t\t// is optional and consumed only if other characters\n+\t\t// are needed to complete the format.\n+\t\tif (__io.flags() & ios_base::showbase || __sign_size > 1\n+\t\t    || __i == 0\n+\t\t    || (__i == 1 && (__mandatory_sign\n+\t\t\t\t     || (static_cast<part>(__p.field[0])\n+\t\t\t\t\t == money_base::sign)\n+\t\t\t\t     || (static_cast<part>(__p.field[2])\n+\t\t\t\t\t == money_base::space)))\n+\t\t    || (__i == 2 && ((static_cast<part>(__p.field[3])\n+\t\t\t\t      == money_base::value)\n+\t\t\t\t     || (__mandatory_sign\n+\t\t\t\t\t && (static_cast<part>(__p.field[3])\n+\t\t\t\t\t     == money_base::sign)))))\n+\t\t  {\n+\t\t    const size_type __len = __lc->_M_curr_symbol_size;\n+\t\t    size_type __j = 0;\n+\t\t    for (; __beg != __end && __j < __len\n+\t\t\t   && *__beg == __lc->_M_curr_symbol[__j];\n+\t\t\t ++__beg, ++__j);\n+\t\t    if (__j != __len\n+\t\t\t&& (__j || __io.flags() & ios_base::showbase))\n+\t\t      __testvalid = false;\n+\t\t  }\n+\t\tbreak;\n+\t      case money_base::sign:\n+\t\t// Sign might not exist, or be more than one character long.\n+\t\tif (__lc->_M_positive_sign_size && __beg != __end\n+\t\t    && *__beg == __lc->_M_positive_sign[0])\n+\t\t  {\n+\t\t    __sign_size = __lc->_M_positive_sign_size;\n+\t\t    ++__beg;\n+\t\t  }\n+\t\telse if (__lc->_M_negative_sign_size && __beg != __end\n+\t\t\t && *__beg == __lc->_M_negative_sign[0])\n+\t\t  {\n+\t\t    __negative = true;\n+\t\t    __sign_size = __lc->_M_negative_sign_size;\n+\t\t    ++__beg;\n+\t\t  }\n+\t\telse if (__lc->_M_positive_sign_size\n+\t\t\t && !__lc->_M_negative_sign_size)\n+\t\t  // \"... if no sign is detected, the result is given the sign\n+\t\t  // that corresponds to the source of the empty string\"\n+\t\t  __negative = true;\n+\t\telse if (__mandatory_sign)\n+\t\t  __testvalid = false;\n+\t\tbreak;\n+\t      case money_base::value:\n+\t\t// Extract digits, remove and stash away the\n+\t\t// grouping of found thousands separators.\n+\t\tfor (; __beg != __end; ++__beg)\n+\t\t  {\n+\t\t    const char_type __c = *__beg;\n+\t\t    const char_type* __q = __traits_type::find(__lit_zero, \n+\t\t\t\t\t\t\t       10, __c);\n+\t\t    if (__q != 0)\n+\t\t      {\n+\t\t\t__res += money_base::_S_atoms[__q - __lit];\n+\t\t\t++__n;\n+\t\t      }\n+\t\t    else if (__c == __lc->_M_decimal_point \n+\t\t\t     && !__testdecfound)\n+\t\t      {\n+\t\t\t__last_pos = __n;\n+\t\t\t__n = 0;\n+\t\t\t__testdecfound = true;\n+\t\t      }\n+\t\t    else if (__lc->_M_use_grouping\n+\t\t\t     && __c == __lc->_M_thousands_sep\n+\t\t\t     && !__testdecfound)\n+\t\t      {\n+\t\t\tif (__n)\n+\t\t\t  {\n+\t\t\t    // Mark position for later analysis.\n+\t\t\t    __grouping_tmp += static_cast<char>(__n);\n+\t\t\t    __n = 0;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    __testvalid = false;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      }\n+\t\t    else\n+\t\t      break;\n+\t\t  }\n+\t\tif (__res.empty())\n+\t\t  __testvalid = false;\n+\t\tbreak;\n+\t      case money_base::space:\n+\t\t// At least one space is required.\n+\t\tif (__beg != __end && __ctype.is(ctype_base::space, *__beg))\n+\t\t  ++__beg;\n+\t\telse\n+\t\t  __testvalid = false;\n+\t      case money_base::none:\n+\t\t// Only if not at the end of the pattern.\n+\t\tif (__i != 3)\n+\t\t  for (; __beg != __end\n+\t\t\t && __ctype.is(ctype_base::space, *__beg); ++__beg);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\n+\t// Need to get the rest of the sign characters, if they exist.\n+\tif (__sign_size > 1 && __testvalid)\n+\t  {\n+\t    const char_type* __sign = __negative ? __lc->_M_negative_sign\n+\t                                         : __lc->_M_positive_sign;\n+\t    size_type __i = 1;\n+\t    for (; __beg != __end && __i < __sign_size\n+\t\t   && *__beg == __sign[__i]; ++__beg, ++__i);\n+\t    \n+\t    if (__i != __sign_size)\n+\t      __testvalid = false;\n+\t  }\n+\n+\tif (__testvalid)\n+\t  {\n+\t    // Strip leading zeros.\n+\t    if (__res.size() > 1)\n+\t      {\n+\t\tconst size_type __first = __res.find_first_not_of('0');\n+\t\tconst bool __only_zeros = __first == string::npos;\n+\t\tif (__first)\n+\t\t  __res.erase(0, __only_zeros ? __res.size() - 1 : __first);\n+\t      }\n+\n+\t    // 22.2.6.1.2, p4\n+\t    if (__negative && __res[0] != '0')\n+\t      __res.insert(__res.begin(), '-');\n+\t    \n+\t    // Test for grouping fidelity.\n+\t    if (__grouping_tmp.size())\n+\t      {\n+\t\t// Add the ending grouping.\n+\t\t__grouping_tmp += static_cast<char>(__testdecfound ? __last_pos\n+\t\t\t\t\t\t                   : __n);\n+\t\tif (!std::__verify_grouping(__lc->_M_grouping,\n+\t\t\t\t\t    __lc->_M_grouping_size,\n+\t\t\t\t\t    __grouping_tmp))\n+\t\t  __err |= ios_base::failbit;\n+\t      }\n+\t    \n+\t    // Iff not enough digits were supplied after the decimal-point.\n+\t    if (__testdecfound && __lc->_M_frac_digits > 0\n+\t\t&& __n != __lc->_M_frac_digits)\n+\t      __testvalid = false;\n+\t  }\n+\t\n+\t// Iff valid sequence is not recognized.\n+\tif (!__testvalid)\n+\t  __err |= ios_base::failbit;\n+\telse\n+\t  __units.swap(__res);\n+\t\n+\t// Iff no more characters are available.\n+\tif (__beg == __end)\n+\t  __err |= ios_base::eofbit;\n+\treturn __beg;\n+      }\n+\n+#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    money_get<_CharT, _InIter>::\n+    __do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n+\t     ios_base::iostate& __err, double& __units) const\n+    {\n+      string __str;\n+      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)\n+                     : _M_extract<false>(__beg, __end, __io, __err, __str);\n+      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());\n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    money_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n+\t   ios_base::iostate& __err, long double& __units) const\n+    {\n+      string __str;\n+      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)\n+\t             : _M_extract<false>(__beg, __end, __io, __err, __str);\n+      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    money_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n+\t   ios_base::iostate& __err, string_type& __digits) const\n+    {\n+      typedef typename string::size_type                  size_type;\n+\n+      const locale& __loc = __io._M_getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n+      string __str;\n+      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)\n+\t             : _M_extract<false>(__beg, __end, __io, __err, __str);\n+      const size_type __len = __str.size();\n+      if (__len)\n+\t{\n+\t  __digits.resize(__len);\n+\t  __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);\n+\t}\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    template<bool _Intl>\n+      _OutIter\n+      money_put<_CharT, _OutIter>::\n+      _M_insert(iter_type __s, ios_base& __io, char_type __fill,\n+\t\tconst string_type& __digits) const\n+      {\n+\ttypedef typename string_type::size_type\t          size_type;\n+\ttypedef money_base::part                          part;\n+\ttypedef __moneypunct_cache<_CharT, _Intl>         __cache_type;\n+      \n+\tconst locale& __loc = __io._M_getloc();\n+\tconst ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n+\t__use_cache<__cache_type> __uc;\n+\tconst __cache_type* __lc = __uc(__loc);\n+\tconst char_type* __lit = __lc->_M_atoms;\n+\n+\t// Determine if negative or positive formats are to be used, and\n+\t// discard leading negative_sign if it is present.\n+\tconst char_type* __beg = __digits.data();\n+\n+\tmoney_base::pattern __p;\n+\tconst char_type* __sign;\n+\tsize_type __sign_size;\n+\tif (!(*__beg == __lit[money_base::_S_minus]))\n+\t  {\n+\t    __p = __lc->_M_pos_format;\n+\t    __sign = __lc->_M_positive_sign;\n+\t    __sign_size = __lc->_M_positive_sign_size;\n+\t  }\n+\telse\n+\t  {\n+\t    __p = __lc->_M_neg_format;\n+\t    __sign = __lc->_M_negative_sign;\n+\t    __sign_size = __lc->_M_negative_sign_size;\n+\t    if (__digits.size())\n+\t      ++__beg;\n+\t  }\n+       \n+\t// Look for valid numbers in the ctype facet within input digits.\n+\tsize_type __len = __ctype.scan_not(ctype_base::digit, __beg,\n+\t\t\t\t\t   __beg + __digits.size()) - __beg;\n+\tif (__len)\n+\t  {\n+\t    // Assume valid input, and attempt to format.\n+\t    // Break down input numbers into base components, as follows:\n+\t    //   final_value = grouped units + (decimal point) + (digits)\n+\t    string_type __value;\n+\t    __value.reserve(2 * __len);\n+\n+\t    // Add thousands separators to non-decimal digits, per\n+\t    // grouping rules.\n+\t    long __paddec = __len - __lc->_M_frac_digits;\n+\t    if (__paddec > 0)\n+  \t      {\n+\t\tif (__lc->_M_frac_digits < 0)\n+\t\t  __paddec = __len;\n+  \t\tif (__lc->_M_grouping_size)\n+  \t\t  {\n+\t\t    __value.assign(2 * __paddec, char_type());\n+ \t\t    _CharT* __vend = \n+\t\t      std::__add_grouping(&__value[0], __lc->_M_thousands_sep,\n+\t\t\t\t\t  __lc->_M_grouping,\n+\t\t\t\t\t  __lc->_M_grouping_size,\n+\t\t\t\t\t  __beg, __beg + __paddec);\n+\t\t    __value.erase(__vend - &__value[0]);\n+  \t\t  }\n+  \t\telse\n+\t\t  __value.assign(__beg, __paddec);\n+\t      }\n+\n+\t    // Deal with decimal point, decimal digits.\n+\t    if (__lc->_M_frac_digits > 0)\n+\t      {\n+\t\t__value += __lc->_M_decimal_point;\n+\t\tif (__paddec >= 0)\n+\t\t  __value.append(__beg + __paddec, __lc->_M_frac_digits);\n+\t\telse\n+\t\t  {\n+\t\t    // Have to pad zeros in the decimal position.\n+\t\t    __value.append(-__paddec, __lit[money_base::_S_zero]);\n+\t\t    __value.append(__beg, __len);\n+\t\t  }\n+  \t      }\n+  \n+\t    // Calculate length of resulting string.\n+\t    const ios_base::fmtflags __f = __io.flags() \n+\t                                   & ios_base::adjustfield;\n+\t    __len = __value.size() + __sign_size;\n+\t    __len += ((__io.flags() & ios_base::showbase)\n+\t\t      ? __lc->_M_curr_symbol_size : 0);\n+\n+\t    string_type __res;\n+\t    __res.reserve(2 * __len);\n+\t    \n+\t    const size_type __width = static_cast<size_type>(__io.width());  \n+\t    const bool __testipad = (__f == ios_base::internal\n+\t\t\t\t     && __len < __width);\n+\t    // Fit formatted digits into the required pattern.\n+\t    for (int __i = 0; __i < 4; ++__i)\n+\t      {\n+\t\tconst part __which = static_cast<part>(__p.field[__i]);\n+\t\tswitch (__which)\n+\t\t  {\n+\t\t  case money_base::symbol:\n+\t\t    if (__io.flags() & ios_base::showbase)\n+\t\t      __res.append(__lc->_M_curr_symbol,\n+\t\t\t\t   __lc->_M_curr_symbol_size);\n+\t\t    break;\n+\t\t  case money_base::sign:\n+\t\t    // Sign might not exist, or be more than one\n+\t\t    // charater long. In that case, add in the rest\n+\t\t    // below.\n+\t\t    if (__sign_size)\n+\t\t      __res += __sign[0];\n+\t\t    break;\n+\t\t  case money_base::value:\n+\t\t    __res += __value;\n+\t\t    break;\n+\t\t  case money_base::space:\n+\t\t    // At least one space is required, but if internal\n+\t\t    // formatting is required, an arbitrary number of\n+\t\t    // fill spaces will be necessary.\n+\t\t    if (__testipad)\n+\t\t      __res.append(__width - __len, __fill);\n+\t\t    else\n+\t\t      __res += __fill;\n+\t\t    break;\n+\t\t  case money_base::none:\n+\t\t    if (__testipad)\n+\t\t      __res.append(__width - __len, __fill);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    \n+\t    // Special case of multi-part sign parts.\n+\t    if (__sign_size > 1)\n+\t      __res.append(__sign + 1, __sign_size - 1);\n+\t    \n+\t    // Pad, if still necessary.\n+\t    __len = __res.size();\n+\t    if (__width > __len)\n+\t      {\n+\t\tif (__f == ios_base::left)\n+\t\t  // After.\n+\t\t  __res.append(__width - __len, __fill);\n+\t\telse\n+\t\t  // Before.\n+\t\t  __res.insert(0, __width - __len, __fill);\n+\t\t__len = __width;\n+\t      }\n+\t    \n+\t    // Write resulting, fully-formatted string to output iterator.\n+\t    __s = std::__write(__s, __res.data(), __len);\n+\t  }\n+\t__io.width(0);\n+\treturn __s;    \n+      }\n+\n+#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__\n+  template<typename _CharT, typename _OutIter>\n+    _OutIter\n+    money_put<_CharT, _OutIter>::\n+    __do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     double __units) const\n+    { return this->do_put(__s, __intl, __io, __fill, (long double) __units); }\n+#endif\n+\n+  template<typename _CharT, typename _OutIter>\n+    _OutIter\n+    money_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t   long double __units) const\n+    {\n+      const locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+#ifdef _GLIBCXX_USE_C99\n+      // First try a buffer perhaps big enough.\n+      int __cs_size = 64;\n+      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 328. Bad sprintf format modifier in money_put<>::do_put()\n+      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n+\t\t\t\t\t\"%.*Lf\", 0, __units);\n+      // If the buffer was not large enough, try again with the correct size.\n+      if (__len >= __cs_size)\n+\t{\n+\t  __cs_size = __len + 1;\n+\t  __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n+\t  __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,\n+\t\t\t\t\t\"%.*Lf\", 0, __units);\n+\t}\n+#else\n+      // max_exponent10 + 1 for the integer part, + 2 for sign and '\\0'.\n+      const int __cs_size =\n+\t__gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 3;\n+      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n+      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, 0, \"%.*Lf\", \n+\t\t\t\t\t0, __units);\n+#endif\n+      string_type __digits(__len, char_type());\n+      __ctype.widen(__cs, __cs + __len, &__digits[0]);\n+      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)\n+\t            : _M_insert<false>(__s, __io, __fill, __digits);\n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    _OutIter\n+    money_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t   const string_type& __digits) const\n+    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)\n+\t            : _M_insert<false>(__s, __io, __fill, __digits); }\n+\n+_GLIBCXX_END_LDBL_NAMESPACE\n+\n+  // NB: Not especially useful. Without an ios_base object or some\n+  // kind of locale reference, we are left clawing at the air where\n+  // the side of the mountain used to be...\n+  template<typename _CharT, typename _InIter>\n+    time_base::dateorder\n+    time_get<_CharT, _InIter>::do_date_order() const\n+    { return time_base::no_order; }\n+\n+  // Expand a strftime format string and parse it.  E.g., do_get_date() may\n+  // pass %m/%d/%Y => extracted characters.\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t\t  ios_base::iostate& __err, tm* __tm,\n+\t\t\t  const _CharT* __format) const\n+    {\n+      const locale& __loc = __io._M_getloc();\n+      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      const size_t __len = char_traits<_CharT>::length(__format);\n+\n+      ios_base::iostate __tmperr = ios_base::goodbit;\n+      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)\n+\t{\n+\t  if (__ctype.narrow(__format[__i], 0) == '%')\n+\t    {\n+\t      // Verify valid formatting code, attempt to extract.\n+\t      char __c = __ctype.narrow(__format[++__i], 0);\n+\t      int __mem = 0;\n+\t      if (__c == 'E' || __c == 'O')\n+\t\t__c = __ctype.narrow(__format[++__i], 0);\n+\t      switch (__c)\n+\t\t{\n+\t\t  const char* __cs;\n+\t\t  _CharT __wcs[10];\n+\t\tcase 'a':\n+\t\t  // Abbreviated weekday name [tm_wday]\n+\t\t  const char_type*  __days1[7];\n+\t\t  __tp._M_days_abbreviated(__days1);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,\n+\t\t\t\t\t  7, __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'A':\n+\t\t  // Weekday name [tm_wday].\n+\t\t  const char_type*  __days2[7];\n+\t\t  __tp._M_days(__days2);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,\n+\t\t\t\t\t  7, __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'h':\n+\t\tcase 'b':\n+\t\t  // Abbreviated month name [tm_mon]\n+\t\t  const char_type*  __months1[12];\n+\t\t  __tp._M_months_abbreviated(__months1);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_mon, \n+\t\t\t\t\t  __months1, 12, __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'B':\n+\t\t  // Month name [tm_mon].\n+\t\t  const char_type*  __months2[12];\n+\t\t  __tp._M_months(__months2);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_mon, \n+\t\t\t\t\t  __months2, 12, __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'c':\n+\t\t  // Default time and date representation.\n+\t\t  const char_type*  __dt[2];\n+\t\t  __tp._M_date_time_formats(__dt);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n+\t\t\t\t\t\t__tm, __dt[0]);\n+\t\t  break;\n+\t\tcase 'd':\n+\t\t  // Day [01, 31]. [tm_mday]\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,\n+\t\t\t\t\t __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'e':\n+\t\t  // Day [1, 31], with single digits preceded by\n+\t\t  // space. [tm_mday]\n+\t\t  if (__ctype.is(ctype_base::space, *__beg))\n+\t\t    __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,\n+\t\t\t\t\t   1, __io, __tmperr);\n+\t\t  else\n+\t\t    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,\n+\t\t\t\t\t   2, __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'D':\n+\t\t  // Equivalent to %m/%d/%y.[tm_mon, tm_mday, tm_year]\n+\t\t  __cs = \"%m/%d/%y\";\n+\t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n+\t\t\t\t\t\t__tm, __wcs);\n+\t\t  break;\n+\t\tcase 'H':\n+\t\t  // Hour [00, 23]. [tm_hour]\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,\n+\t\t\t\t\t __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'I':\n+\t\t  // Hour [01, 12]. [tm_hour]\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,\n+\t\t\t\t\t __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'm':\n+\t\t  // Month [01, 12]. [tm_mon]\n+\t\t  __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2, \n+\t\t\t\t\t __io, __tmperr);\n+\t\t  if (!__tmperr)\n+\t\t    __tm->tm_mon = __mem - 1;\n+\t\t  break;\n+\t\tcase 'M':\n+\t\t  // Minute [00, 59]. [tm_min]\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,\n+\t\t\t\t\t __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'n':\n+\t\t  if (__ctype.narrow(*__beg, 0) == '\\n')\n+\t\t    ++__beg;\n+\t\t  else\n+\t\t    __tmperr |= ios_base::failbit;\n+\t\t  break;\n+\t\tcase 'R':\n+\t\t  // Equivalent to (%H:%M).\n+\t\t  __cs = \"%H:%M\";\n+\t\t  __ctype.widen(__cs, __cs + 6, __wcs);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n+\t\t\t\t\t\t__tm, __wcs);\n+\t\t  break;\n+\t\tcase 'S':\n+\t\t  // Seconds. [tm_sec]\n+\t\t  // [00, 60] in C99 (one leap-second), [00, 61] in C89.\n+#ifdef _GLIBCXX_USE_C99\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,\n+#else\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 61, 2,\n+#endif\n+\t\t\t\t\t __io, __tmperr);\n+\t\t  break;\n+\t\tcase 't':\n+\t\t  if (__ctype.narrow(*__beg, 0) == '\\t')\n+\t\t    ++__beg;\n+\t\t  else\n+\t\t    __tmperr |= ios_base::failbit;\n+\t\t  break;\n+\t\tcase 'T':\n+\t\t  // Equivalent to (%H:%M:%S).\n+\t\t  __cs = \"%H:%M:%S\";\n+\t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n+\t\t\t\t\t\t__tm, __wcs);\n+\t\t  break;\n+\t\tcase 'x':\n+\t\t  // Locale's date.\n+\t\t  const char_type*  __dates[2];\n+\t\t  __tp._M_date_formats(__dates);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n+\t\t\t\t\t\t__tm, __dates[0]);\n+\t\t  break;\n+\t\tcase 'X':\n+\t\t  // Locale's time.\n+\t\t  const char_type*  __times[2];\n+\t\t  __tp._M_time_formats(__times);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __tmperr, \n+\t\t\t\t\t\t__tm, __times[0]);\n+\t\t  break;\n+\t\tcase 'y':\n+\t\tcase 'C': // C99\n+\t\t  // Two digit year. [tm_year]\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,\n+\t\t\t\t\t __io, __tmperr);\n+\t\t  break;\n+\t\tcase 'Y':\n+\t\t  // Year [1900). [tm_year]\n+\t\t  __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,\n+\t\t\t\t\t __io, __tmperr);\n+\t\t  if (!__tmperr)\n+\t\t    __tm->tm_year = __mem - 1900;\n+\t\t  break;\n+\t\tcase 'Z':\n+\t\t  // Timezone info.\n+\t\t  if (__ctype.is(ctype_base::upper, *__beg))\n+\t\t    {\n+\t\t      int __tmp;\n+\t\t      __beg = _M_extract_name(__beg, __end, __tmp,\n+\t\t\t\t       __timepunct_cache<_CharT>::_S_timezones,\n+\t\t\t\t\t      14, __io, __tmperr);\n+\n+\t\t      // GMT requires special effort.\n+\t\t      if (__beg != __end && !__tmperr && __tmp == 0\n+\t\t\t  && (*__beg == __ctype.widen('-')\n+\t\t\t      || *__beg == __ctype.widen('+')))\n+\t\t\t{\n+\t\t\t  __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,\n+\t\t\t\t\t\t __io, __tmperr);\n+\t\t\t  __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,\n+\t\t\t\t\t\t __io, __tmperr);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    __tmperr |= ios_base::failbit;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  // Not recognized.\n+\t\t  __tmperr |= ios_base::failbit;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      // Verify format and input match, extract and discard.\n+\t      if (__format[__i] == *__beg)\n+\t\t++__beg;\n+\t      else\n+\t\t__tmperr |= ios_base::failbit;\n+\t    }\n+\t}\n+\n+      if (__tmperr)\n+\t__err |= ios_base::failbit;\n+  \n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n+\t\t   int __min, int __max, size_t __len,\n+\t\t   ios_base& __io, ios_base::iostate& __err) const\n+    {\n+      const locale& __loc = __io._M_getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n+      // As-is works for __len = 1, 2, 4, the values actually used.\n+      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);\n+\n+      ++__min;\n+      size_t __i = 0;\n+      int __value = 0;\n+      for (; __beg != __end && __i < __len; ++__beg, ++__i)\n+\t{\n+\t  const char __c = __ctype.narrow(*__beg, '*');\n+\t  if (__c >= '0' && __c <= '9')\n+\t    {\n+\t      __value = __value * 10 + (__c - '0');\n+\t      const int __valuec = __value * __mult;\n+\t      if (__valuec > __max || __valuec + __mult < __min)\n+\t\tbreak;\n+\t      __mult /= 10;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+      if (__i == __len)\n+\t__member = __value;\n+      else\n+\t__err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+  // Assumptions:\n+  // All elements in __names are unique.\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n+\t\t    const _CharT** __names, size_t __indexlen,\n+\t\t    ios_base& __io, ios_base::iostate& __err) const\n+    {\n+      typedef char_traits<_CharT>\t\t__traits_type;\n+      const locale& __loc = __io._M_getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n+      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)\n+\t\t\t\t\t\t\t  * __indexlen));\n+      size_t __nmatches = 0;\n+      size_t __pos = 0;\n+      bool __testvalid = true;\n+      const char_type* __name;\n+\n+      // Look for initial matches.\n+      // NB: Some of the locale data is in the form of all lowercase\n+      // names, and some is in the form of initially-capitalized\n+      // names. Look for both.\n+      if (__beg != __end)\n+\t{\n+\t  const char_type __c = *__beg;\n+\t  for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)\n+\t    if (__c == __names[__i1][0]\n+\t\t|| __c == __ctype.toupper(__names[__i1][0]))\n+\t      __matches[__nmatches++] = __i1;\n+\t}\n+\n+      while (__nmatches > 1)\n+\t{\n+\t  // Find smallest matching string.\n+\t  size_t __minlen = __traits_type::length(__names[__matches[0]]);\n+\t  for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)\n+\t    __minlen = std::min(__minlen,\n+\t\t\t      __traits_type::length(__names[__matches[__i2]]));\n+\t  ++__beg, ++__pos;\n+\t  if (__pos < __minlen && __beg != __end)\n+\t    for (size_t __i3 = 0; __i3 < __nmatches;)\n+\t      {\n+\t\t__name = __names[__matches[__i3]];\n+\t\tif (!(__name[__pos] == *__beg))\n+\t\t  __matches[__i3] = __matches[--__nmatches];\n+\t\telse\n+\t\t  ++__i3;\n+\t      }\n+\t  else\n+\t    break;\n+\t}\n+\n+      if (__nmatches == 1)\n+\t{\n+\t  // Make sure found name is completely extracted.\n+\t  ++__beg, ++__pos;\n+\t  __name = __names[__matches[0]];\n+\t  const size_t __len = __traits_type::length(__name);\n+\t  while (__pos < __len && __beg != __end && __name[__pos] == *__beg)\n+\t    ++__beg, ++__pos;\n+\n+\t  if (__len == __pos)\n+\t    __member = __matches[0];\n+\t  else\n+\t    __testvalid = false;\n+\t}\n+      else\n+\t__testvalid = false;\n+      if (!__testvalid)\n+\t__err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\tios_base::iostate& __err, tm* __tm) const\n+    {\n+      const locale& __loc = __io._M_getloc();\n+      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n+      const char_type*  __times[2];\n+      __tp._M_time_formats(__times);\n+      __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t    __tm, __times[0]);\n+      if (__beg == __end)\n+\t__err |= ios_base::eofbit;\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\tios_base::iostate& __err, tm* __tm) const\n+    {\n+      const locale& __loc = __io._M_getloc();\n+      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n+      const char_type*  __dates[2];\n+      __tp._M_date_formats(__dates);\n+      __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t    __tm, __dates[0]);\n+      if (__beg == __end)\n+\t__err |= ios_base::eofbit;\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t   ios_base::iostate& __err, tm* __tm) const\n+    {\n+      typedef char_traits<_CharT>\t\t__traits_type;\n+      const locale& __loc = __io._M_getloc();\n+      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      const char_type*  __days[7];\n+      __tp._M_days_abbreviated(__days);\n+      int __tmpwday;\n+      ios_base::iostate __tmperr = ios_base::goodbit;\n+      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7,\n+\t\t\t      __io, __tmperr);\n+\n+      // Check to see if non-abbreviated name exists, and extract.\n+      // NB: Assumes both _M_days and _M_days_abbreviated organized in\n+      // exact same order, first to last, such that the resulting\n+      // __days array with the same index points to a day, and that\n+      // day's abbreviated form.\n+      // NB: Also assumes that an abbreviated name is a subset of the name.\n+      if (!__tmperr && __beg != __end)\n+\t{\n+\t  size_t __pos = __traits_type::length(__days[__tmpwday]);\n+\t  __tp._M_days(__days);\n+\t  const char_type* __name = __days[__tmpwday];\n+\t  if (__name[__pos] == *__beg)\n+\t    {\n+\t      // Extract the rest of it.\n+\t      const size_t __len = __traits_type::length(__name);\n+\t      while (__pos < __len && __beg != __end\n+\t\t     && __name[__pos] == *__beg)\n+\t\t++__beg, ++__pos;\n+\t      if (__len != __pos)\n+\t\t__tmperr |= ios_base::failbit;\n+\t    }\n+\t}\n+      if (!__tmperr)\n+\t__tm->tm_wday = __tmpwday;\n+      else\n+\t__err |= ios_base::failbit;\n+\n+      if (__beg == __end)\n+\t__err |= ios_base::eofbit;\n+      return __beg;\n+     }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    do_get_monthname(iter_type __beg, iter_type __end,\n+                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const\n+    {\n+      typedef char_traits<_CharT>\t\t__traits_type;\n+      const locale& __loc = __io._M_getloc();\n+      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      const char_type*  __months[12];\n+      __tp._M_months_abbreviated(__months);\n+      int __tmpmon;\n+      ios_base::iostate __tmperr = ios_base::goodbit;\n+      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12, \n+\t\t\t      __io, __tmperr);\n+\n+      // Check to see if non-abbreviated name exists, and extract.\n+      // NB: Assumes both _M_months and _M_months_abbreviated organized in\n+      // exact same order, first to last, such that the resulting\n+      // __months array with the same index points to a month, and that\n+      // month's abbreviated form.\n+      // NB: Also assumes that an abbreviated name is a subset of the name.\n+      if (!__tmperr && __beg != __end)\n+\t{\n+\t  size_t __pos = __traits_type::length(__months[__tmpmon]);\n+\t  __tp._M_months(__months);\n+\t  const char_type* __name = __months[__tmpmon];\n+\t  if (__name[__pos] == *__beg)\n+\t    {\n+\t      // Extract the rest of it.\n+\t      const size_t __len = __traits_type::length(__name);\n+\t      while (__pos < __len && __beg != __end\n+\t\t     && __name[__pos] == *__beg)\n+\t\t++__beg, ++__pos;\n+\t      if (__len != __pos)\n+\t\t__tmperr |= ios_base::failbit;\n+\t    }\n+\t}\n+      if (!__tmperr)\n+\t__tm->tm_mon = __tmpmon;\n+      else\n+\t__err |= ios_base::failbit;\n+\n+      if (__beg == __end)\n+\t__err |= ios_base::eofbit;\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\tios_base::iostate& __err, tm* __tm) const\n+    {\n+      const locale& __loc = __io._M_getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n+      size_t __i = 0;\n+      int __value = 0;\n+      for (; __beg != __end && __i < 4; ++__beg, ++__i)\n+\t{\n+\t  const char __c = __ctype.narrow(*__beg, '*');\n+\t  if (__c >= '0' && __c <= '9')\n+\t    __value = __value * 10 + (__c - '0');\n+\t  else\n+\t    break;\n+\t}\n+      if (__i == 2 || __i == 4)\n+\t__tm->tm_year = __i == 2 ? __value : __value - 1900;\n+      else\n+\t__err |= ios_base::failbit;\n+\n+      if (__beg == __end)\n+\t__err |= ios_base::eofbit;\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    _OutIter\n+    time_put<_CharT, _OutIter>::\n+    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n+\tconst _CharT* __beg, const _CharT* __end) const\n+    {\n+      const locale& __loc = __io._M_getloc();\n+      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      for (; __beg != __end; ++__beg)\n+\tif (__ctype.narrow(*__beg, 0) != '%')\n+\t  {\n+\t    *__s = *__beg;\n+\t    ++__s;\n+\t  }\n+\telse if (++__beg != __end)\n+\t  {\n+\t    char __format;\n+\t    char __mod = 0;\n+\t    const char __c = __ctype.narrow(*__beg, 0);\n+\t    if (__c != 'E' && __c != 'O')\n+\t      __format = __c;\n+\t    else if (++__beg != __end)\n+\t      {\n+\t\t__mod = __c;\n+\t\t__format = __ctype.narrow(*__beg, 0);\n+\t      }\n+\t    else\n+\t      break;\n+\t    __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);\n+\t  }\n+\telse\n+\t  break;\n+      return __s;\n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    _OutIter\n+    time_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,\n+\t   char __format, char __mod) const\n+    {\n+      const locale& __loc = __io._M_getloc();\n+      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n+      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);\n+\n+      // NB: This size is arbitrary. Should this be a data member,\n+      // initialized at construction?\n+      const size_t __maxlen = 128;\n+      char_type* __res = \n+       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));\n+\n+      // NB: In IEE 1003.1-200x, and perhaps other locale models, it\n+      // is possible that the format character will be longer than one\n+      // character. Possibilities include 'E' or 'O' followed by a\n+      // format character: if __mod is not the default argument, assume\n+      // it's a valid modifier.\n+      char_type __fmt[4];\n+      __fmt[0] = __ctype.widen('%');\n+      if (!__mod)\n+\t{\n+\t  __fmt[1] = __format;\n+\t  __fmt[2] = char_type();\n+\t}\n+      else\n+\t{\n+\t  __fmt[1] = __mod;\n+\t  __fmt[2] = __format;\n+\t  __fmt[3] = char_type();\n+\t}\n+\n+      __tp._M_put(__res, __maxlen, __fmt, __tm);\n+\n+      // Write resulting, fully-formatted string to output iterator.\n+      return std::__write(__s, __res, char_traits<char_type>::length(__res));\n+    }\n+\n+  // Inhibit implicit instantiations for required instantiations,\n+  // which are defined via explicit instantiations elsewhere.\n+  // NB: This syntax is a GNU extension.\n+#if _GLIBCXX_EXTERN_TEMPLATE\n+  extern template class moneypunct<char, false>;\n+  extern template class moneypunct<char, true>;\n+  extern template class moneypunct_byname<char, false>;\n+  extern template class moneypunct_byname<char, true>;\n+  extern template class _GLIBCXX_LDBL_NAMESPACE money_get<char>;\n+  extern template class _GLIBCXX_LDBL_NAMESPACE money_put<char>;\n+  extern template class __timepunct<char>;\n+  extern template class time_put<char>;\n+  extern template class time_put_byname<char>;\n+  extern template class time_get<char>;\n+  extern template class time_get_byname<char>;\n+  extern template class messages<char>;\n+  extern template class messages_byname<char>;\n+\n+  extern template\n+    const moneypunct<char, true>&\n+    use_facet<moneypunct<char, true> >(const locale&);\n+\n+  extern template\n+    const moneypunct<char, false>&\n+    use_facet<moneypunct<char, false> >(const locale&);\n+\n+  extern template\n+    const money_put<char>&\n+    use_facet<money_put<char> >(const locale&);\n+\n+  extern template\n+    const money_get<char>&\n+    use_facet<money_get<char> >(const locale&);\n+\n+  extern template\n+    const __timepunct<char>&\n+    use_facet<__timepunct<char> >(const locale&);\n+\n+  extern template\n+    const time_put<char>&\n+    use_facet<time_put<char> >(const locale&);\n+\n+  extern template\n+    const time_get<char>&\n+    use_facet<time_get<char> >(const locale&);\n+\n+  extern template\n+    const messages<char>&\n+    use_facet<messages<char> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<moneypunct<char> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<money_put<char> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<money_get<char> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<__timepunct<char> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<time_put<char> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<time_get<char> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<messages<char> >(const locale&);\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  extern template class moneypunct<wchar_t, false>;\n+  extern template class moneypunct<wchar_t, true>;\n+  extern template class moneypunct_byname<wchar_t, false>;\n+  extern template class moneypunct_byname<wchar_t, true>;\n+  extern template class _GLIBCXX_LDBL_NAMESPACE money_get<wchar_t>;\n+  extern template class _GLIBCXX_LDBL_NAMESPACE money_put<wchar_t>;\n+  extern template class __timepunct<wchar_t>;\n+  extern template class time_put<wchar_t>;\n+  extern template class time_put_byname<wchar_t>;\n+  extern template class time_get<wchar_t>;\n+  extern template class time_get_byname<wchar_t>;\n+  extern template class messages<wchar_t>;\n+  extern template class messages_byname<wchar_t>;\n+\n+  extern template\n+    const moneypunct<wchar_t, true>&\n+    use_facet<moneypunct<wchar_t, true> >(const locale&);\n+\n+  extern template\n+    const moneypunct<wchar_t, false>&\n+    use_facet<moneypunct<wchar_t, false> >(const locale&);\n+\n+  extern template\n+    const money_put<wchar_t>&\n+    use_facet<money_put<wchar_t> >(const locale&);\n+\n+  extern template\n+    const money_get<wchar_t>&\n+    use_facet<money_get<wchar_t> >(const locale&);\n+\n+  extern template\n+    const __timepunct<wchar_t>&\n+    use_facet<__timepunct<wchar_t> >(const locale&);\n+\n+  extern template\n+    const time_put<wchar_t>&\n+    use_facet<time_put<wchar_t> >(const locale&);\n+\n+  extern template\n+    const time_get<wchar_t>&\n+    use_facet<time_get<wchar_t> >(const locale&);\n+\n+  extern template\n+    const messages<wchar_t>&\n+    use_facet<messages<wchar_t> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<moneypunct<wchar_t> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<money_put<wchar_t> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<money_get<wchar_t> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<__timepunct<wchar_t> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<time_put<wchar_t> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<time_get<wchar_t> >(const locale&);\n+\n+  extern template\n+    bool\n+    has_facet<messages<wchar_t> >(const locale&);\n+#endif\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif"}, {"sha": "170c6d66049aae1d68a4032d4565f083352cc46d", "filename": "libstdc++-v3/include/std/fstream", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -44,7 +44,6 @@\n \n #include <istream>\n #include <ostream>\n-#include <locale>\t// For codecvt\n #include <cstdio>       // For BUFSIZ     \n #include <bits/basic_file.h>  // For __basic_file, __c_lock\n "}, {"sha": "a3e074a7b85d99b3a70f2a06c60c6f8ff74757dc", "filename": "libstdc++-v3/include/std/istream", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -43,7 +43,6 @@\n #pragma GCC system_header\n \n #include <ios>\n-#include <locale>\n #include <ostream>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n@@ -837,6 +836,7 @@ _GLIBCXX_END_NAMESPACE\n \n #ifndef _GLIBCXX_EXPORT_TEMPLATE\n # include <bits/istream.tcc>\n+# include <bits/locale_facets.tcc>\n #endif\n \n #endif\t/* _GLIBCXX_ISTREAM */"}, {"sha": "6bfd78d93e92d395b6a67d9d16198baf1ebb54e8", "filename": "libstdc++-v3/include/std/locale", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -1,6 +1,7 @@\n // Locale support -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+// 2006, 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -43,6 +44,11 @@\n #include <bits/localefwd.h>\n #include <bits/locale_classes.h>\n #include <bits/locale_facets.h>\n-#include <bits/locale_facets.tcc>\n+#include <bits/locale_facets_nonio.h>\n+\n+#ifndef _GLIBCXX_EXPORT_TEMPLATE\n+# include <bits/locale_facets.tcc>\n+# include <bits/locale_facets_nonio.tcc>\n+#endif\n \n #endif /* _GLIBCXX_LOCALE */"}, {"sha": "a4019df84310716b99db03c32e382d5dc34e12d9", "filename": "libstdc++-v3/include/std/ostream", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f749a55bb4aa154a19b4a029ddf85b7393f52262/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream?ref=f749a55bb4aa154a19b4a029ddf85b7393f52262", "patch": "@@ -43,7 +43,6 @@\n #pragma GCC system_header\n \n #include <ios>\n-#include <locale>\n #include <bits/ostream_insert.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n@@ -571,6 +570,7 @@ _GLIBCXX_END_NAMESPACE\n \n #ifndef _GLIBCXX_EXPORT_TEMPLATE\n # include <bits/ostream.tcc>\n+# include <bits/locale_facets.tcc>\n #endif\n \n #endif\t/* _GLIBCXX_OSTREAM */"}]}