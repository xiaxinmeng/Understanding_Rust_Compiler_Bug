{"sha": "d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhNzlmY2MzY2FiYWYwNWU1NTFmOWI1NGIzZWJkM2NhOWZjMGYwOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-06-29T19:29:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-06-29T19:29:02Z"}, "message": "re PR c++/44587 (ICE in instantiate_decl)\n\n\tPR c++/44587\n\t* pt.c (has_value_dependent_address): New.\n\t(value_dependent_expression_p): Check it.\n\t(convert_nontype_argument): Likewise.  Call decay_conversion before\n\tfolding if we want a pointer.\n\t* semantics.c (finish_id_expression): Don't add SCOPE_REF if the\n\tscope is the current instantiation.\n\nFrom-SVN: r161559", "tree": {"sha": "d2fc07b3af76168894748acc9219f892c6988204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2fc07b3af76168894748acc9219f892c6988204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7ecb00a6e253af7db561ce1422041c0ee7596478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecb00a6e253af7db561ce1422041c0ee7596478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ecb00a6e253af7db561ce1422041c0ee7596478"}], "stats": {"total": 113, "additions": 111, "deletions": 2}, "files": [{"sha": "da75d0498b69c59cf62a2e23ec35c152d6c2cb09", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "patch": "@@ -1,3 +1,13 @@\n+2010-06-29  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/44587\n+\t* pt.c (has_value_dependent_address): New.\n+\t(value_dependent_expression_p): Check it.\n+\t(convert_nontype_argument): Likewise.  Call decay_conversion before\n+\tfolding if we want a pointer.\n+\t* semantics.c (finish_id_expression): Don't add SCOPE_REF if the\n+\tscope is the current instantiation.\n+\n 2010-06-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/44682"}, {"sha": "8a447ec157d0a522cde34f803685b864bb4e459c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "patch": "@@ -4880,6 +4880,36 @@ check_valid_ptrmem_cst_expr (tree type, tree expr)\n   return false;\n }\n \n+/* Returns TRUE iff the address of OP is value-dependent.\n+\n+   14.6.2.4 [temp.dep.temp]:\n+   A non-integral non-type template-argument is dependent if its type is\n+   dependent or it has either of the following forms\n+     qualified-id\n+     & qualified-id\n+   and contains a nested-name-specifier which specifies a class-name that\n+   names a dependent type.\n+\n+   We generalize this to just say that the address of a member of a\n+   dependent class is value-dependent; the above doesn't cover the\n+   address of a static data member named with an unqualified-id.  */\n+\n+static bool\n+has_value_dependent_address (tree op)\n+{\n+  /* We could use get_inner_reference here, but there's no need;\n+     this is only relevant for template non-type arguments, which\n+     can only be expressed as &id-expression.  */\n+  if (DECL_P (op))\n+    {\n+      tree ctx = CP_DECL_CONTEXT (op);\n+      if (TYPE_P (ctx) && dependent_type_p (ctx))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n    converted value.  If the conversion is unsuccessful, return\n@@ -4918,14 +4948,23 @@ convert_nontype_argument (tree type, tree expr)\n       return NULL_TREE;\n     }\n \n+  /* Add the ADDR_EXPR now for the benefit of\n+     value_dependent_expression_p.  */\n+  if (TYPE_PTROBV_P (type))\n+    expr = decay_conversion (expr);\n+\n   /* If we are in a template, EXPR may be non-dependent, but still\n      have a syntactic, rather than semantic, form.  For example, EXPR\n      might be a SCOPE_REF, rather than the VAR_DECL to which the\n      SCOPE_REF refers.  Preserving the qualifying scope is necessary\n      so that access checking can be performed when the template is\n      instantiated -- but here we need the resolved form so that we can\n      convert the argument.  */\n-  expr = fold_non_dependent_expr (expr);\n+  if (TYPE_REF_OBJ_P (type)\n+      && has_value_dependent_address (expr))\n+    /* If we want the address and it's value-dependent, don't fold.  */;\n+  else\n+    expr = fold_non_dependent_expr (expr);\n   if (error_operand_p (expr))\n     return error_mark_node;\n   expr_type = TREE_TYPE (expr);\n@@ -17638,6 +17677,13 @@ value_dependent_expression_p (tree expression)\n       return ((value_dependent_expression_p (TREE_OPERAND (expression, 0)))\n \t      || (value_dependent_expression_p (TREE_OPERAND (expression, 2))));\n \n+    case ADDR_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (expression, 0);\n+\treturn (value_dependent_expression_p (op)\n+\t\t|| has_value_dependent_address (op));\n+      }\n+\n     default:\n       /* A constant expression is value-dependent if any subexpression is\n \t value-dependent.  */"}, {"sha": "8baf76ac6ce6d6dd4c8416f0995e536cfdca9a7f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "patch": "@@ -3097,7 +3097,13 @@ finish_id_expression (tree id_expression,\n \t    {\n \t      tree r = convert_from_reference (decl);\n \n-\t      if (processing_template_decl && TYPE_P (scope))\n+\t      /* In a template, return a SCOPE_REF for most qualified-ids\n+\t\t so that we can check access at instantiation time.  But if\n+\t\t we're looking at a member of the current instantiation, we\n+\t\t know we have access and building up the SCOPE_REF confuses\n+\t\t non-type template argument handling.  */\n+\t      if (processing_template_decl && TYPE_P (scope)\n+\t\t  && !currently_open_class (scope))\n \t\tr = build_qualified_name (TREE_TYPE (r),\n \t\t\t\t\t  scope, decl,\n \t\t\t\t\t  template_p);"}, {"sha": "4ecfcabc3ff884b4556f6987ec0e580755eb319d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "patch": "@@ -1,3 +1,9 @@\n+2010-06-29  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/44587\n+\t* g++.dg/template/qualified-id2.C: New.\n+\t* g++.dg/template/qualified-id3.C: New.\n+\n 2010-06-29  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44696"}, {"sha": "e88e85474578b5f1bb417d656e483e2c03f8604f", "filename": "gcc/testsuite/g++.dg/template/qualified-id2.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id2.C?ref=d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/44587\n+// { dg-do run }\n+\n+template <const char *N> struct A { static const char *p; };\n+template <const char *N> const char *A<N>::p = N;\n+template <class T> struct B { static const char c[1]; typedef A<B<T>::c> C; };\n+template <class T> const char B<T>::c[1] = \"\";\n+template <class T> struct D { static const char c[1]; typedef A<c> C; };\n+template <class T> const char D<T>::c[1] = \"\";\n+\n+template <int& I> struct E { static int *ip; };\n+template <int& I> int* E<I>::ip = &I;\n+template <class T> struct F { static int i; typedef E<F<T>::i> C; };\n+template <class T> int F<T>::i;\n+template <class T> struct G { static int i; typedef E<i> C; };\n+template <class T> int G<T>::i;\n+\n+#define AS(X) if (!(X)) return 1;\n+int main()\n+{\n+  AS(B<int>::C::p == B<int>::c);\n+  AS(B<float>::C::p == B<float>::c);\n+  AS(B<float>::C::p != B<int>::c);\n+  AS(D<int>::C::p == D<int>::c);\n+  AS(D<float>::C::p == D<float>::c);\n+  AS(D<float>::C::p != D<int>::c);\n+}"}, {"sha": "d97ef5c592b7a90b63fd22e51f0b786f3ded0e91", "filename": "gcc/testsuite/g++.dg/template/qualified-id3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id3.C?ref=d3a79fcc3cabaf05e551f9b54b3ebd3ca9fc0f09", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/44587\n+\n+template <const int N> struct A { };\n+template <class T> struct B {\n+  static const int c;\n+  typedef A<B<T>::c> C;\t\t// { dg-error \"non-constant\" }\n+};\n+template <class T> const int B<T>::c = sizeof (T);\n+\n+template <const int N> struct D { };\n+template <class T> struct E {\n+  static const int c = sizeof (T);\n+  typedef D<E<T>::c> F;\t\t// OK\n+};"}]}