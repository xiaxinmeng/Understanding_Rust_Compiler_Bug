{"sha": "cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q5YzdiZDI4YjcyZGQ1YzVhOTdmNDBmMmY2OTBkYjIxZjgwYzhlMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-03-30T22:28:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-03-30T22:28:02Z"}, "message": "[multiple changes]\n\n2005-03-31  Jan Hubicka  <jh@suse.cz>\n\n\t2004-11-02  Jan Hubicka  <jh@suse.cz>\n\n\t* cgraph.c (cgraph_varpool_node_name): New function.\n\t(dump_cgraph_varpool_node): New function.\n\t(dump_varpool): New function.\n\t* cgraphunit.c (cgraph_optimize): Dump varpool.\n\n\t2004-10-16  Jan Hubicka  <jh@suse.cz>\n\n\t* cgraph.c (decide_is_variable_needed): New function.\n\t(cgraph_varpool_finalize_decl): Use it.\n\t* cgraphunit.c (cgraph_optimize): Assemble_pending_decls when not doing\n\tunit-at-a-time.\n\t* final.c (output_addr_const): Do not call mark_referenced.\n\t* passes.c (rest_of_decl_compilation): ifdef out DECL_RTL_SET_P hack;\n\talways go via cgraph.\n\t* toplev.c (wrapup_global_declarations): Kill non-unit-at-a-time code.\n\t(check_global_declarations): Ifdef out code clearing DECL_RTL.\n\t* tree-optimize.c (execute_inline): Mark functions called.\n\t* i386.c (output_pic_addr_const): Do not call mark_decl_referenced.\n\n\t2004-10-11  Jan Hubicka  <jh@suse.cz>\n\n\t* cgraph.c (cgraph_varpool_first_unanalyzed_node): New global voriable\n\t(cgraph_varpool_last_needed_node): New static variable.\n\t(enqueue_needed_varpool_node): Break out from ...; add items to the\n\tend of queue; update first pointers.\n\t(cgraph_varpool_mark_needed_node): ... here.\n\t(cgraph_varpool_finalize_decl): Use enqueue_needed_varpool_node.\n\t(cgraph_varpool_assemble_pending_decls): Move to cgraphunit.c\n\t* cgraph.h (cgraph_varpool_node): Add analyzed field.\n\t(cgraph_varpool_first_unanalyzed_node): Declare.\n\t* cgraphunit.c: Include output.h.\n\t(cgraph_varpool_analyze_pending_decls): New function.\n\t(cgraph_varpool_assemble_pending_decls): Move from cgraph.c; bail out\n\tfor errors, analyze pending decls.\n\t(cgraph_finalize_compilation_unit): Only analyze decls.\n\t(cgraph_optimize): Assemble the decls after expanding.\n\nFrom-SVN: r97287", "tree": {"sha": "ddb809af63fbede05531dda040e688b7ae54b743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddb809af63fbede05531dda040e688b7ae54b743"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/comments", "author": null, "committer": null, "parents": [{"sha": "d19e9499fc4f7cf1bbcc48a8c7947d5818827a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19e9499fc4f7cf1bbcc48a8c7947d5818827a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19e9499fc4f7cf1bbcc48a8c7947d5818827a7f"}], "stats": {"total": 438, "additions": 369, "deletions": 69}, "files": [{"sha": "a7394c5dfd8b43384f00830abf98a10cc765dbf9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -1,3 +1,44 @@\n+2005-03-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t2004-11-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_varpool_node_name): New function.\n+\t(dump_cgraph_varpool_node): New function.\n+\t(dump_varpool): New function.\n+\t* cgraphunit.c (cgraph_optimize): Dump varpool.\n+\n+\t2004-10-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (decide_is_variable_needed): New function.\n+\t(cgraph_varpool_finalize_decl): Use it.\n+\t* cgraphunit.c (cgraph_optimize): Assemble_pending_decls when not doing\n+\tunit-at-a-time.\n+\t* final.c (output_addr_const): Do not call mark_referenced.\n+\t* passes.c (rest_of_decl_compilation): ifdef out DECL_RTL_SET_P hack;\n+\talways go via cgraph.\n+\t* toplev.c (wrapup_global_declarations): Kill non-unit-at-a-time code.\n+\t(check_global_declarations): Ifdef out code clearing DECL_RTL.\n+\t* tree-optimize.c (execute_inline): Mark functions called.\n+\t* i386.c (output_pic_addr_const): Do not call mark_decl_referenced.\n+\n+\t2004-10-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_varpool_first_unanalyzed_node): New global voriable\n+\t(cgraph_varpool_last_needed_node): New static variable.\n+\t(enqueue_needed_varpool_node): Break out from ...; add items to the\n+\tend of queue; update first pointers.\n+\t(cgraph_varpool_mark_needed_node): ... here.\n+\t(cgraph_varpool_finalize_decl): Use enqueue_needed_varpool_node.\n+\t(cgraph_varpool_assemble_pending_decls): Move to cgraphunit.c\n+\t* cgraph.h (cgraph_varpool_node): Add analyzed field.\n+\t(cgraph_varpool_first_unanalyzed_node): Declare.\n+\t* cgraphunit.c: Include output.h.\n+\t(cgraph_varpool_analyze_pending_decls): New function.\n+\t(cgraph_varpool_assemble_pending_decls): Move from cgraph.c; bail out\n+\tfor errors, analyze pending decls.\n+\t(cgraph_finalize_compilation_unit): Only analyze decls.\n+\t(cgraph_optimize): Assemble the decls after expanding.\n+\n 2005-03-30  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-alias.c (compute_flow_insensitive_aliasing): Make sure"}, {"sha": "5ed13bce31765cf9e6ff99f418307178be679764", "filename": "gcc/cgraph.c", "status": "modified", "additions": 124, "deletions": 44, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -84,13 +84,15 @@ The varpool data structure:\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"tree-inline.h\"\n #include \"langhooks.h\"\n #include \"hashtab.h\"\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n #include \"debug.h\"\n #include \"target.h\"\n+#include \"basic-block.h\"\n #include \"cgraph.h\"\n #include \"varray.h\"\n #include \"output.h\"\n@@ -118,14 +120,21 @@ int cgraph_max_uid;\n /* Set when whole unit has been analyzed so we can access global info.  */\n bool cgraph_global_info_ready = false;\n \n+/* Set when the cgraph is fully build and the basic flags are computed.  */\n+bool cgraph_function_flags_ready = false;\n+\n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (struct cgraph_varpool_node))) htab_t cgraph_varpool_hash;\n \n /* Queue of cgraph nodes scheduled to be lowered and output.  */\n-struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n+struct cgraph_varpool_node *cgraph_varpool_nodes_queue, *cgraph_varpool_first_unanalyzed_node;\n+\n \n /* The linked list of cgraph varpool nodes.  */\n-static GTY(())  struct cgraph_varpool_node *cgraph_varpool_nodes;\n+static GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes;\n+\n+/* End of the varpool queue.  Needs to be QTYed to work with PCH.  */\n+static GTY(()) struct cgraph_varpool_node *cgraph_varpool_last_needed_node;\n \n static hashval_t hash_node (const void *);\n static int eq_node (const void *, const void *);\n@@ -533,6 +542,13 @@ cgraph_node_name (struct cgraph_node *node)\n   return lang_hooks.decl_printable_name (node->decl, 2);\n }\n \n+/* Return name of the node used in debug output.  */\n+static const char *\n+cgraph_varpool_node_name (struct cgraph_varpool_node *node)\n+{\n+  return lang_hooks.decl_printable_name (node->decl, 2);\n+}\n+\n /* Dump given cgraph node.  */\n void\n dump_cgraph_node (FILE *f, struct cgraph_node *node)\n@@ -598,6 +614,36 @@ dump_cgraph (FILE *f)\n     dump_cgraph_node (f, node);\n }\n \n+/* Dump given cgraph node.  */\n+void\n+dump_cgraph_varpool_node (FILE *f, struct cgraph_varpool_node *node)\n+{\n+  fprintf (f, \"%s:\", cgraph_varpool_node_name (node));\n+  if (DECL_INITIAL (node->decl))\n+    fprintf (f, \" initialized\");\n+  if (node->needed)\n+    fprintf (f, \" needed\");\n+  if (node->analyzed)\n+    fprintf (f, \" analyzed\");\n+  if (node->finalized)\n+    fprintf (f, \" finalized\");\n+  if (node->output)\n+    fprintf (f, \" output\");\n+  fprintf (f, \"\\n\");\n+}\n+\n+/* Dump the callgraph.  */\n+\n+void\n+dump_varpool (FILE *f)\n+{\n+  struct cgraph_varpool_node *node;\n+\n+  fprintf (f, \"variable pool:\\n\\n\");\n+  for (node = cgraph_varpool_nodes; node; node = node->next_needed)\n+    dump_cgraph_varpool_node (f, node);\n+}\n+\n /* Returns a hash code for P.  */\n \n static hashval_t\n@@ -671,20 +717,82 @@ change_decl_assembler_name (tree decl, tree name)\n   SET_DECL_ASSEMBLER_NAME (decl, name);\n }\n \n+/* Helper function for finalization code - add node into lists so it will\n+   be analyzed and compiled.  */\n+void\n+cgraph_varpool_enqueue_needed_node (struct cgraph_varpool_node *node)\n+{\n+  if (cgraph_varpool_last_needed_node)\n+    cgraph_varpool_last_needed_node->next_needed = node;\n+  cgraph_varpool_last_needed_node = node;\n+  node->next_needed = NULL;\n+  if (!cgraph_varpool_nodes_queue)\n+    cgraph_varpool_nodes_queue = node;\n+  if (!cgraph_varpool_first_unanalyzed_node)\n+    cgraph_varpool_first_unanalyzed_node = node;\n+  notice_global_symbol (node->decl);\n+}\n+\n+/* Reset the queue of needed nodes.  */\n+void\n+cgraph_varpool_reset_queue (void)\n+{\n+  cgraph_varpool_last_needed_node = NULL;\n+  cgraph_varpool_nodes_queue = NULL;\n+  cgraph_varpool_first_unanalyzed_node = NULL;\n+}\n+\n /* Notify finalize_compilation_unit that given node is reachable\n    or needed.  */\n void\n cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *node)\n {\n   if (!node->needed && node->finalized)\n-    {\n-      node->next_needed = cgraph_varpool_nodes_queue;\n-      cgraph_varpool_nodes_queue = node;\n-      notice_global_symbol (node->decl);\n-    }\n+    cgraph_varpool_enqueue_needed_node (node);\n   node->needed = 1;\n }\n \n+/* Determine if variable DECL is needed.  That is, visible to something\n+   either outside this translation unit, something magic in the system\n+   configury, or (if not doing unit-at-a-time) to something we haven't\n+   seen yet.  */\n+\n+bool\n+decide_is_variable_needed (struct cgraph_varpool_node *node, tree decl)\n+{\n+  /* If the user told us it is used, then it must be so.  */\n+  if (lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n+    return true;\n+\n+  /* ??? If the assembler name is set by hand, it is possible to assemble\n+     the name later after finalizing the function and the fact is noticed\n+     in assemble_name then.  This is arguably a bug.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl)\n+      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+    return true;\n+\n+  /* If we decided it was needed before, but at the time we didn't have\n+     the definition available, then it's still needed.  */\n+  if (node->needed)\n+    return true;\n+\n+  /* Externally visible functions must be output.  The exception is\n+     COMDAT functions that must be output only when they are needed.  */\n+  if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+    return true;\n+\n+  if (flag_unit_at_a_time)\n+    return false;\n+\n+  /* If not doing unit at a time, then we'll only defer this function\n+     if its marked for inlining.  Otherwise we want to emit it now.  */\n+\n+  /* We want to emit COMDAT variables only when absolutely necessary.  */\n+  if (DECL_COMDAT (decl))\n+    return false;\n+  return true;\n+}\n+\n void\n cgraph_varpool_finalize_decl (tree decl)\n {\n@@ -695,47 +803,19 @@ cgraph_varpool_finalize_decl (tree decl)\n      or local (in C, has internal linkage).  So do nothing more\n      if this function has already run.  */\n   if (node->finalized)\n-    return;\n-  if (node->needed)\n     {\n-      node->next_needed = cgraph_varpool_nodes_queue;\n-      cgraph_varpool_nodes_queue = node;\n-      notice_global_symbol (decl);\n+      if (cgraph_global_info_ready || !flag_unit_at_a_time)\n+\tcgraph_varpool_assemble_pending_decls ();\n+      return;\n     }\n+  if (node->needed)\n+    cgraph_varpool_enqueue_needed_node (node);\n   node->finalized = true;\n \n-  if (/* Externally visible variables must be output.  The exception are\n-\t COMDAT functions that must be output only when they are needed.  */\n-      (TREE_PUBLIC (decl) && !DECL_COMDAT (decl))\n-      /* Function whose name is output to the assembler file must be produced.\n-\t It is possible to assemble the name later after finalizing the function\n-\t and the fact is noticed in assemble_name then.  */\n-      || (DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n-    {\n-      cgraph_varpool_mark_needed_node (node);\n-    }\n-}\n-\n-bool\n-cgraph_varpool_assemble_pending_decls (void)\n-{\n-  bool changed = false;\n-\n-  while (cgraph_varpool_nodes_queue)\n-    {\n-      struct cgraph_varpool_node *node = cgraph_varpool_nodes_queue;\n-      tree decl = node->decl;\n-\n-      cgraph_varpool_nodes_queue = cgraph_varpool_nodes_queue->next_needed;\n-      if (!TREE_ASM_WRITTEN (decl) && !node->alias)\n-\t{\n-\t  assemble_variable (decl, 0, 1, 0);\n-\t  changed = true;\n-\t}\n-      node->next_needed = NULL;\n-    }\n-  return changed;\n+  if (decide_is_variable_needed (node, decl))\n+    cgraph_varpool_mark_needed_node (node);\n+  if (cgraph_global_info_ready || !flag_unit_at_a_time)\n+    cgraph_varpool_assemble_pending_decls ();\n }\n \n /* Return true when the DECL can possibly be inlined.  */"}, {"sha": "e701e5625f13e45019bcc0cbe77cb2eaf519fe66", "filename": "gcc/cgraph.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -151,6 +151,12 @@ struct cgraph_varpool_node GTY(())\n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n   bool needed;\n+  /* Needed variables might become dead by optimization.  This flag\n+     forces the variable to be output even if it appears dead otherwise.  */\n+  bool force_output;\n+  /* Set once the variable has been instantiated and its callee\n+     lists created.  */\n+  bool analyzed;\n   /* Set once it has been finalized so we consider it to be output.  */\n   bool finalized;\n   /* Set when function is scheduled to be assembled.  */\n@@ -165,11 +171,14 @@ extern GTY(()) int cgraph_max_uid;\n extern bool cgraph_global_info_ready;\n extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n \n+extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_first_unanalyzed_node;\n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n void dump_cgraph_node (FILE *, struct cgraph_node *);\n+void dump_varpool (FILE *);\n+void dump_cgraph_varpool_node (FILE *, struct cgraph_varpool_node *);\n void cgraph_remove_edge (struct cgraph_edge *);\n void cgraph_remove_node (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n@@ -190,14 +199,17 @@ struct cgraph_varpool_node *cgraph_varpool_node (tree decl);\n struct cgraph_varpool_node *cgraph_varpool_node_for_asm (tree asmname);\n void cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\n void cgraph_varpool_finalize_decl (tree);\n-bool cgraph_varpool_assemble_pending_decls (void);\n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n \n bool cgraph_function_possibly_inlined_p (tree);\n void cgraph_unnest_node (struct cgraph_node *node);\n+void cgraph_varpool_enqueue_needed_node (struct cgraph_varpool_node *);\n+void cgraph_varpool_reset_queue (void);\n+bool decide_is_variable_needed (struct cgraph_varpool_node *, tree);\n \n /* In cgraphunit.c  */\n bool cgraph_assemble_pending_functions (void);\n+bool cgraph_varpool_assemble_pending_decls (void);\n void cgraph_finalize_function (tree, bool);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_create_edges (struct cgraph_node *, tree);"}, {"sha": "3bb143f97876f788669d450ebb8628a87d7f1cb5", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 117, "deletions": 9, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -189,6 +189,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"function.h\"\n #include \"tree-gimple.h\"\n+#include \"output.h\"\n \n #define INSNS_PER_CALL 10\n \n@@ -281,6 +282,64 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   return false;\n }\n \n+/* Walk the decls we marked as neccesary and see if they reference new variables\n+   or functions and add them into the worklists.  */\n+static bool\n+cgraph_varpool_analyze_pending_decls (void)\n+{\n+  bool changed = false;\n+  timevar_push (TV_CGRAPH);\n+\n+  while (cgraph_varpool_first_unanalyzed_node)\n+    {\n+      tree decl = cgraph_varpool_first_unanalyzed_node->decl;\n+\n+      cgraph_varpool_first_unanalyzed_node->analyzed = true;\n+\n+      cgraph_varpool_first_unanalyzed_node = cgraph_varpool_first_unanalyzed_node->next_needed;\n+\n+      if (DECL_INITIAL (decl))\n+\tcgraph_create_edges (NULL, DECL_INITIAL (decl));\n+      changed = true;\n+    }\n+  timevar_pop (TV_CGRAPH);\n+  return changed;\n+}\n+\n+/* Optimization of function bodies might've rendered some variables as\n+   unnecesary so we want to avoid these from being compiled.\n+\n+   This is done by prunning the queue and keeping only the variables that\n+   really appear needed (ie thery are either externally visible or referenced\n+   by compiled function). Re-doing the reachability analysis on variables\n+   brings back the remaining variables referenced by these.  */\n+static void\n+cgraph_varpool_remove_unreferenced_decls (void)\n+{\n+  struct cgraph_varpool_node *next, *node = cgraph_varpool_nodes_queue;\n+\n+  cgraph_varpool_reset_queue ();\n+\n+  if (errorcount || sorrycount)\n+    return;\n+\n+  while (node)\n+    {\n+      tree decl = node->decl;\n+      next = node->next_needed;\n+      node->needed = 0;\n+\n+      if (node->finalized\n+\t  && ((DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t      || node->force_output\n+\t      || decide_is_variable_needed (node, decl)))\n+\tcgraph_varpool_mark_needed_node (node);\n+\n+      node = next;\n+    }\n+  cgraph_varpool_analyze_pending_decls ();\n+}\n \n \n /* When not doing unit-at-a-time, output all functions enqueued.\n@@ -421,7 +480,7 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n       /* ??? Really, we should mark this decl as *potentially* referenced\n \t by this function and re-examine whether the decl is actually used\n \t after rtl has been generated.  */\n-      if (TREE_STATIC (t))\n+      if (TREE_STATIC (t) || DECL_EXTERNAL (t))\n \t{\n \t  cgraph_varpool_mark_needed_node (cgraph_varpool_node (t));\n \t  if (lang_hooks.callgraph.analyze_expr)\n@@ -639,6 +698,37 @@ verify_cgraph (void)\n     verify_cgraph_node (node);\n }\n \n+\n+/* Output all variables enqueued to be assembled.  */\n+bool\n+cgraph_varpool_assemble_pending_decls (void)\n+{\n+  bool changed = false;\n+\n+  if (errorcount || sorrycount)\n+    return false;\n+ \n+  /* EH might mark decls as needed during expansion.  This should be safe since\n+     we don't create references to new function, but it should not be used\n+     elsewhere.  */\n+  cgraph_varpool_analyze_pending_decls ();\n+\n+  while (cgraph_varpool_nodes_queue)\n+    {\n+      tree decl = cgraph_varpool_nodes_queue->decl;\n+      struct cgraph_varpool_node *node = cgraph_varpool_nodes_queue;\n+\n+      cgraph_varpool_nodes_queue = cgraph_varpool_nodes_queue->next_needed;\n+      if (!TREE_ASM_WRITTEN (decl) && !node->alias && !DECL_EXTERNAL (decl))\n+\t{\n+\t  assemble_variable (decl, 0, 1, 0);\n+\t  changed = true;\n+\t}\n+      node->next_needed = NULL;\n+    }\n+  return changed;\n+}\n+\n /* Analyze the function scheduled to be output.  */\n static void\n cgraph_analyze_function (struct cgraph_node *node)\n@@ -681,6 +771,9 @@ void\n cgraph_finalize_compilation_unit (void)\n {\n   struct cgraph_node *node;\n+  /* Keep track of already processed nodes when called multiple times for\n+     intermodule optmization.  */\n+  static struct cgraph_node *first_analyzed;\n \n   finish_aliases_1 ();\n \n@@ -690,15 +783,18 @@ cgraph_finalize_compilation_unit (void)\n       return;\n     }\n \n-  cgraph_varpool_assemble_pending_decls ();\n   if (!quiet_flag)\n-    fprintf (stderr, \"\\nAnalyzing compilation unit\\n\");\n+    {\n+      fprintf (stderr, \"\\nAnalyzing compilation unit\");\n+      fflush (stderr);\n+    }\n \n   timevar_push (TV_CGRAPH);\n+  cgraph_varpool_analyze_pending_decls ();\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Initial entry points:\");\n-      for (node = cgraph_nodes; node; node = node->next)\n+      for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n \tif (node->needed && DECL_SAVED_TREE (node->decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\");\n@@ -732,15 +828,15 @@ cgraph_finalize_compilation_unit (void)\n \tif (!edge->callee->reachable)\n \t  cgraph_mark_reachable_node (edge->callee);\n \n-      cgraph_varpool_assemble_pending_decls ();\n+      cgraph_varpool_analyze_pending_decls ();\n     }\n \n   /* Collect entry points to the unit.  */\n \n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Unit entry points:\");\n-      for (node = cgraph_nodes; node; node = node->next)\n+      for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n \tif (node->needed && DECL_SAVED_TREE (node->decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n@@ -750,7 +846,7 @@ cgraph_finalize_compilation_unit (void)\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nReclaiming functions:\");\n \n-  for (node = cgraph_nodes; node; node = node->next)\n+  for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n     {\n       tree decl = node->decl;\n \n@@ -768,6 +864,7 @@ cgraph_finalize_compilation_unit (void)\n       fprintf (cgraph_dump_file, \"\\n\\nReclaimed \");\n       dump_cgraph (cgraph_dump_file);\n     }\n+  first_analyzed = cgraph_nodes;\n   ggc_collect ();\n   timevar_pop (TV_CGRAPH);\n }\n@@ -1766,9 +1863,16 @@ cgraph_optimize (void)\n   verify_cgraph ();\n #endif\n   if (!flag_unit_at_a_time)\n-    return;\n+    {\n+      cgraph_varpool_assemble_pending_decls ();\n+      return;\n+    }\n \n   process_pending_assemble_externals ();\n+  \n+  /* Frontend may output common variables after the unit has been finalized.\n+     It is safe to deal with them here as they are always zero initialized.  */\n+  cgraph_varpool_analyze_pending_decls ();\n \n   timevar_push (TV_CGRAPHOPT);\n   if (!quiet_flag)\n@@ -1788,6 +1892,7 @@ cgraph_optimize (void)\n     {\n       fprintf (cgraph_dump_file, \"Optimized \");\n       dump_cgraph (cgraph_dump_file);\n+      dump_varpool (cgraph_dump_file);\n     }\n   timevar_pop (TV_CGRAPHOPT);\n \n@@ -1799,8 +1904,11 @@ cgraph_optimize (void)\n #endif\n   \n   cgraph_mark_functions_to_output ();\n-  \n   cgraph_expand_all_functions ();\n+  cgraph_varpool_remove_unreferenced_decls ();\n+\n+  cgraph_varpool_assemble_pending_decls ();\n+\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"\\nFinal \");"}, {"sha": "fffc5f370474bb0029d57e7562ef86ef07b6366f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -5889,10 +5889,6 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n       break;\n \n     case SYMBOL_REF:\n-     /* Mark the decl as referenced so that cgraph will output the function.  */\n-     if (SYMBOL_REF_DECL (x))\n-       mark_decl_referenced (SYMBOL_REF_DECL (x));\n-\n       assemble_name (file, XSTR (x, 0));\n       if (!TARGET_MACHO && code == 'P' && ! SYMBOL_REF_LOCAL_P (x))\n \tfputs (\"@PLT\", file);"}, {"sha": "d2328387385ff07ffb61d0da98dbbb2d74d196d6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -1,3 +1,8 @@\n+2005-03-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (finish_objects): Mark ctor as needed.\n+\t(cp_finish_file): Output variables only in nonunit-at-a-time.\n+\n 2005-03-29  Richard Henderson  <rth@redhat.com>\n \n \tPR c/20519"}, {"sha": "78ba602155a6fb91770762b264a15cf37ab2c29e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -2110,6 +2110,7 @@ finish_objects (int method_type, int initp, tree body)\n   if (targetm.have_ctors_dtors)\n     {\n       rtx fnsym = XEXP (DECL_RTL (fn), 0);\n+      cgraph_mark_needed_node (cgraph_node (fn));\n       if (method_type == 'I')\n \t(* targetm.asm_out.constructor) (fnsym, initp);\n       else\n@@ -2959,9 +2960,9 @@ cp_finish_file (void)\n       /* Ask the back end to emit functions and variables that are\n \t enqueued.  These emissions may result in marking more entities\n \t as needed.  */\n-      if (cgraph_assemble_pending_functions ())\n+      if (!flag_unit_at_a_time && cgraph_assemble_pending_functions ())\n \treconsider = true;\n-      if (cgraph_varpool_assemble_pending_decls ())\n+      if (!flag_unit_at_a_time && cgraph_varpool_assemble_pending_decls ())\n \treconsider = true;\n \n       retries++;"}, {"sha": "3b11a3e7c9ba50ca984a57c4043a76bdd9f00f1e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -1,3 +1,11 @@\n+2005-03-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Make-lang.in (class.o, decl.o): Depend on cgraph.h.\n+\t* class.c: Include cgraph.h\n+\t(make_local_functoin_alias): Mark aslias as needed.\n+\t* resource.c: Include cgraph.h\n+\t(compile_resource_data): Go via cgraph interface.\n+\n 2005-03-30  Ian Lance Taylor  <ian@airs.com>\n \n \t* parse.y (maybe_yank_clinit): Don't crash if bbody is NULL."}, {"sha": "face9627bbe9f7fd4723d20471bede131702cc75", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -299,13 +299,13 @@ java/check-init.o: java/check-init.c $(CONFIG_H) $(JAVA_TREE_H) $(SYSTEM_H) \\\n   coretypes.h $(TM_H) toplev.h\n java/class.o: java/class.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(JAVA_TREE_H) $(RTL_H) java/jcf.h java/parse.h toplev.h output.h $(GGC_H) \\\n-  $(TARGET_H) function.h gt-java-class.h\n+  $(TARGET_H) function.h gt-java-class.h cgraph.h\n java/constants.o: java/constants.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   toplev.h $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) gt-java-constants.h\n java/decl.o: java/decl.c $(CONFIG_H) $(JAVA_TREE_H) $(RTL_H) java/jcf.h \\\n   toplev.h flags.h $(SYSTEM_H) coretypes.h $(TM_H) function.h expr.h \\\n   libfuncs.h except.h java/java-except.h $(GGC_H) real.h gt-java-decl.h \\\n-  target.h\n+  target.h cgraph.h\n java/except.o: java/except.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h real.h \\\n   $(RTL_H) java/javaop.h java/java-opcodes.h except.h java/java-except.h \\\n   toplev.h $(SYSTEM_H) coretypes.h $(TM_H) function.h "}, {"sha": "1c7c3ab018ce91dcf148c9c1cd498111f92edbd0", "filename": "gcc/java/class.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -45,6 +45,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"except.h\"\n #include \"cgraph.h\"\n #include \"tree-iterator.h\"\n+#include \"cgraph.h\"\n \n /* DOS brain-damage */\n #ifndef O_BINARY\n@@ -910,6 +911,7 @@ build_utf8_ref (tree name)\n   layout_decl (decl, 0);\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, global_bindings_p (), 0);\n+  cgraph_varpool_mark_needed_node (cgraph_varpool_node (decl));\n   utf8_decl_list = decl;\n   make_decl_rtl (decl);\n   ref = build1 (ADDR_EXPR, utf8const_ptr_type, decl);\n@@ -2436,8 +2438,11 @@ emit_register_classes (tree *list_p)\n       named_section_flags (JCR_SECTION_NAME, SECTION_WRITE);\n       assemble_align (POINTER_SIZE);\n       for (t = registered_class; t; t = TREE_CHAIN (t))\n-\tassemble_integer (XEXP (DECL_RTL (t), 0),\n-\t\t\t  POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+\t{\n+\t  mark_decl_referenced (t);\n+\t  assemble_integer (XEXP (DECL_RTL (t), 0),\n+\t\t\t    POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+\t}\n #else\n       /* A target has defined TARGET_USE_JCR_SECTION, but doesn't have a\n \t JCR_SECTION_NAME.  */"}, {"sha": "5f11810c1560f0ffd0c94029956a8dc935b8cd5a", "filename": "gcc/java/resource.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -42,6 +42,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"target.h\"\n #include \"expr.h\"\n #include \"tree-iterator.h\"\n+#include \"cgraph.h\"\n \n /* DOS brain-damage */\n #ifndef O_BINARY\n@@ -93,7 +94,7 @@ compile_resource_data (const char *name, const char *buffer, int length)\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, global_bindings_p (), 0);\n   make_decl_rtl (decl);\n-  assemble_variable (decl, 1, 0, 0);\n+  cgraph_varpool_finalize_decl (decl);\n \n   resources = tree_cons (NULL_TREE, decl, resources);\n }"}, {"sha": "988f4f2c7632f059f0def4dc64afedd883e07c56", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -225,7 +225,7 @@ rest_of_decl_compilation (tree decl,\n \t (see gcc.c-torture/compile/920624-1.c) */\n       if ((at_end\n \t   || !DECL_DEFER_OUTPUT (decl)\n-\t   || (flag_unit_at_a_time && DECL_INITIAL (decl)))\n+\t   || DECL_INITIAL (decl))\n \t  && !DECL_EXTERNAL (decl))\n \t{\n \t  if (flag_unit_at_a_time && !cgraph_global_info_ready"}, {"sha": "411540f55f1cc9e5e145580cb4e81438e57a07bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -1,3 +1,7 @@\n+2005-03-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/varpool-1.c: New testcase.\n+\n 2005-03-30  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c/772"}, {"sha": "48f1cd3593ce86fc06102295b2619fdb88bd2fff", "filename": "gcc/testsuite/gcc.dg/varpool-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftestsuite%2Fgcc.dg%2Fvarpool-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftestsuite%2Fgcc.dg%2Fvarpool-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvarpool-1.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-not \"unnecesary_static_initialized_variable\" } } */\n+\n+static int unnecesary_static_initialized_variable;\n+static int *unnecesary_static_initialized_variable2 =\n+  &unnecesary_static_initialized_variable;\n+static inline\n+simplify_after_inline (int param1, int *param2)\n+{\n+  if (unnecesary_static_initialized_variable != param1)\n+    return unnecesary_static_initialized_variable;\n+  if (unnecesary_static_initialized_variable2 != param2)\n+    return unnecesary_static_initialized_variable;\n+}\n+\n+main ()\n+{\n+  return simplify_after_inline (unnecesary_static_initialized_variable,\n+\t\t\t\tunnecesary_static_initialized_variable2) +\n+    simplify_after_inline (unnecesary_static_initialized_variable,\n+\t\t\t   unnecesary_static_initialized_variable2);\n+}"}, {"sha": "8cfd740629144db9bd2ab43b66f1ad99f5a338b0", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -781,11 +781,11 @@ wrapup_global_declarations (tree *vec, int len)\n \t      bool needed = 1;\n \t      node = cgraph_varpool_node (decl);\n \n-\t      if (flag_unit_at_a_time && node->finalized)\n+\t      if (node->finalized)\n \t\tneeded = 0;\n \t      else if (node->alias)\n \t\tneeded = 0;\n-\t      else if ((flag_unit_at_a_time && !cgraph_global_info_ready)\n+\t      else if (!cgraph_global_info_ready\n \t\t       && (TREE_USED (decl)\n \t\t\t   || TREE_USED (DECL_ASSEMBLER_NAME (decl))))\n \t\t/* needed */;"}, {"sha": "63131af179671cc353b0b64880348692344c93f1", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -660,6 +660,16 @@ tree_rest_of_compilation (tree fndecl)\n \t  timevar_pop (TV_INTEGRATION);\n \t}\n     }\n+  /* We are not going to maintain the cgraph edges up to date.\n+     Kill it so it won't confuse us.  */\n+  while (node->callees)\n+    {\n+      /* In non-unit-at-a-time we must mark all referenced functions as needed.\n+         */\n+      if (node->callees->callee->analyzed && !flag_unit_at_a_time)\n+        cgraph_mark_needed_node (node->callees->callee);\n+      cgraph_remove_edge (node->callees);\n+    }\n \n   /* We are not going to maintain the cgraph edges up to date.\n      Kill it so it won't confuse us.  */"}, {"sha": "9210c413b252410221bb0bf743a89771945e381e", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=cd9c7bd28b72dd5c5a97f40f2f690db21f80c8e2", "patch": "@@ -1883,7 +1883,13 @@ mark_decl_referenced (tree decl)\n         cgraph_mark_needed_node (cgraph_node (decl));\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n-    cgraph_varpool_mark_needed_node (cgraph_varpool_node (decl));\n+    {\n+      struct cgraph_varpool_node *node = cgraph_varpool_node (decl);\n+      cgraph_varpool_mark_needed_node (node);\n+      /* C++ frontend use mark_decl_references to force COMDAT variables\n+         to be output that might appear dead otherwise.  */\n+      node->force_output = true;\n+    }\n   /* else do nothing - we can get various sorts of CST nodes here,\n      which do not need to be marked.  */\n }"}]}