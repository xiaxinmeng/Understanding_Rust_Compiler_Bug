{"sha": "96e82e0a8ae6309f957f263e15ea502f615e0f0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZlODJlMGE4YWU2MzA5Zjk1N2YyNjNlMTVlYTUwMmY2MTVlMGYwYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-03-13T12:20:26Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-03-13T12:20:26Z"}, "message": "cfgrtl.c (last_loop_beg_note, [...]): Removed.\n\n\t* cfgrtl.c (last_loop_beg_note, back_edge_of_syntactic_loop_p):\n\tRemoved.\n\t(force_nonfallthru_and_redirect): Do not use last_loop_beg_note.\n\t(rtl_split_edge): Do not use back_edge_of_syntactic_loop_p.\n\t(commit_one_edge_insertion): Do not look for loop notes.\n\nFrom-SVN: r111997", "tree": {"sha": "f27b417488af1ac2b0b7ac1f9c8c870c83dea457", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f27b417488af1ac2b0b7ac1f9c8c870c83dea457"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96e82e0a8ae6309f957f263e15ea502f615e0f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e82e0a8ae6309f957f263e15ea502f615e0f0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e82e0a8ae6309f957f263e15ea502f615e0f0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e82e0a8ae6309f957f263e15ea502f615e0f0a/comments", "author": null, "committer": null, "parents": [{"sha": "50af63845bc1ce97cd8dd9a2a7236a29ac93a366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50af63845bc1ce97cd8dd9a2a7236a29ac93a366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50af63845bc1ce97cd8dd9a2a7236a29ac93a366"}], "stats": {"total": 107, "additions": 11, "deletions": 96}, "files": [{"sha": "5b60dade9d536564468340e24a4abb20176aba38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e82e0a8ae6309f957f263e15ea502f615e0f0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e82e0a8ae6309f957f263e15ea502f615e0f0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96e82e0a8ae6309f957f263e15ea502f615e0f0a", "patch": "@@ -1,3 +1,11 @@\n+2006-03-13  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* cfgrtl.c (last_loop_beg_note, back_edge_of_syntactic_loop_p):\n+\tRemoved.\n+\t(force_nonfallthru_and_redirect): Do not use last_loop_beg_note.\n+\t(rtl_split_edge): Do not use back_edge_of_syntactic_loop_p.\n+\t(commit_one_edge_insertion): Do not look for loop notes.\n+\n 2006-03-13  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* jump.c (follow_jumps): Do not check for loop notes.  Move check for"}, {"sha": "b4875d2b3352e371f109c89ab773607dd0a5ccae", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 96, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e82e0a8ae6309f957f263e15ea502f615e0f0a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e82e0a8ae6309f957f263e15ea502f615e0f0a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=96e82e0a8ae6309f957f263e15ea502f615e0f0a", "patch": "@@ -64,8 +64,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n static int can_delete_note_p (rtx);\n static int can_delete_label_p (rtx);\n static void commit_one_edge_insertion (edge, int);\n-static rtx last_loop_beg_note (rtx);\n-static bool back_edge_of_syntactic_loop_p (basic_block, basic_block);\n static basic_block rtl_split_edge (edge);\n static bool rtl_move_block_after (basic_block, basic_block);\n static int rtl_verify_flow_info (void);\n@@ -861,28 +859,6 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   return e;\n }\n \n-/* Return last loop_beg note appearing after INSN, before start of next\n-   basic block.  Return INSN if there are no such notes.\n-\n-   When emitting jump to redirect a fallthru edge, it should always appear\n-   after the LOOP_BEG notes, as loop optimizer expect loop to either start by\n-   fallthru edge or jump following the LOOP_BEG note jumping to the loop exit\n-   test.  */\n-\n-static rtx\n-last_loop_beg_note (rtx insn)\n-{\n-  rtx last = insn;\n-\n-  for (insn = NEXT_INSN (insn); insn && NOTE_P (insn)\n-       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK;\n-       insn = NEXT_INSN (insn))\n-    if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-      last = insn;\n-\n-  return last;\n-}\n-\n /* Redirect edge representing branch of (un)conditional jump or tablejump,\n    NULL on failure  */\n static edge\n@@ -1100,9 +1076,6 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t forward from the last instruction of the old block.  */\n       if (!tablejump_p (BB_END (e->src), NULL, &note))\n \tnote = BB_END (e->src);\n-\n-      /* Position the new block correctly relative to loop notes.  */\n-      note = last_loop_beg_note (note);\n       note = NEXT_INSN (note);\n \n       jump_block = create_basic_block (note, NULL, e->src);\n@@ -1254,40 +1227,6 @@ rtl_tidy_fallthru_edge (edge e)\n   e->flags |= EDGE_FALLTHRU;\n }\n \f\n-/* Helper function for split_edge.  Return true in case edge BB2 to BB1\n-   is back edge of syntactic loop.  */\n-\n-static bool\n-back_edge_of_syntactic_loop_p (basic_block bb1, basic_block bb2)\n-{\n-  rtx insn;\n-  int count = 0;\n-  basic_block bb;\n-\n-  if (bb1 == bb2)\n-    return true;\n-\n-  /* ??? Could we guarantee that bb indices are monotone, so that we could\n-     just compare them?  */\n-  for (bb = bb1; bb && bb != bb2; bb = bb->next_bb)\n-    continue;\n-\n-  if (!bb)\n-    return false;\n-\n-  for (insn = BB_END (bb1); insn != BB_HEAD (bb2) && count >= 0;\n-       insn = NEXT_INSN (insn))\n-    if (NOTE_P (insn))\n-      {\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t  count++;\n-\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t  count--;\n-      }\n-\n-  return count >= 0;\n-}\n-\n /* Should move basic block BB after basic block AFTER.  NIY.  */\n \n static bool\n@@ -1328,32 +1267,8 @@ rtl_split_edge (edge edge_in)\n \tforce_nonfallthru (e);\n     }\n \n-  /* Create the basic block note.\n-\n-     Where we place the note can have a noticeable impact on the generated\n-     code.  Consider this cfg:\n-\n-\t\t        E\n-\t\t\t|\n-\t\t\t0\n-\t\t       / \\\n-\t\t   +->1-->2--->E\n-                   |  |\n-\t\t   +--+\n-\n-      If we need to insert an insn on the edge from block 0 to block 1,\n-      we want to ensure the instructions we insert are outside of any\n-      loop notes that physically sit between block 0 and block 1.  Otherwise\n-      we confuse the loop optimizer into thinking the loop is a phony.  */\n-\n-  if (edge_in->dest != EXIT_BLOCK_PTR\n-      && PREV_INSN (BB_HEAD (edge_in->dest))\n-      && NOTE_P (PREV_INSN (BB_HEAD (edge_in->dest)))\n-      && (NOTE_LINE_NUMBER (PREV_INSN (BB_HEAD (edge_in->dest)))\n-\t  == NOTE_INSN_LOOP_BEG)\n-      && !back_edge_of_syntactic_loop_p (edge_in->dest, edge_in->src))\n-    before = PREV_INSN (BB_HEAD (edge_in->dest));\n-  else if (edge_in->dest != EXIT_BLOCK_PTR)\n+  /* Create the basic block note.  */\n+  if (edge_in->dest != EXIT_BLOCK_PTR)\n     before = BB_HEAD (edge_in->dest);\n   else\n     before = NULL_RTX;\n@@ -1363,10 +1278,6 @@ rtl_split_edge (edge edge_in)\n   if (edge_in->flags & EDGE_FALLTHRU && edge_in->dest == EXIT_BLOCK_PTR)\n     {\n       before = NEXT_INSN (BB_END (edge_in->src));\n-      if (before\n-\t  && NOTE_P (before)\n-\t  && NOTE_LINE_NUMBER (before) == NOTE_INSN_LOOP_END)\n-\tbefore = NEXT_INSN (before);\n       bb = create_basic_block (before, NULL, edge_in->src);\n       BB_COPY_PARTITION (bb, edge_in->src);\n     }\n@@ -1596,11 +1507,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t     We know this block has a single successor, so we can just emit\n \t     the queued insns before the jump.  */\n \t  if (JUMP_P (BB_END (bb)))\n-\t    for (before = BB_END (bb);\n-\t\t NOTE_P (PREV_INSN (before))\n-\t\t && NOTE_LINE_NUMBER (PREV_INSN (before)) ==\n-\t\t NOTE_INSN_LOOP_BEG; before = PREV_INSN (before))\n-\t      ;\n+\t    before = BB_END (bb);\n \t  else\n \t    {\n \t      /* We'd better be fallthru, or we've lost track of"}]}