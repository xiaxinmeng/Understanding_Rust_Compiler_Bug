{"sha": "81c4f554f38bbe074af8c31fad93d53b7085f5f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFjNGY1NTRmMzhiYmUwNzRhZjhjMzFmYWQ5M2Q1M2I3MDg1ZjVmMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-04-25T13:59:36Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-04-25T13:59:36Z"}, "message": "re PR tree-optimization/21173 (miscompiled pointer subtraction broke Linux kernel)\n\n\n2005-04-25  Steven Bosscher  <stevenb@suse.de>\n\n\tFix PR tree-optimization/21173\n\n\t* tree-ssa-pre.c (create_expression_by_pieces): Simplify code.\n\tUnshare expression we pass to force_gimple_operand.\n\nFrom-SVN: r98712", "tree": {"sha": "0d4b1e68fac33821ccf8b9b55bda4a1747caaab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d4b1e68fac33821ccf8b9b55bda4a1747caaab4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81c4f554f38bbe074af8c31fad93d53b7085f5f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c4f554f38bbe074af8c31fad93d53b7085f5f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81c4f554f38bbe074af8c31fad93d53b7085f5f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81c4f554f38bbe074af8c31fad93d53b7085f5f2/comments", "author": null, "committer": null, "parents": [{"sha": "4c33cb26d4c5da87d48e6db6ba6832aaabf358fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c33cb26d4c5da87d48e6db6ba6832aaabf358fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c33cb26d4c5da87d48e6db6ba6832aaabf358fb"}], "stats": {"total": 147, "additions": 61, "deletions": 86}, "files": [{"sha": "cc32e36b84d751966cb6abddec5d050b793d9565", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c4f554f38bbe074af8c31fad93d53b7085f5f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c4f554f38bbe074af8c31fad93d53b7085f5f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81c4f554f38bbe074af8c31fad93d53b7085f5f2", "patch": "@@ -1,3 +1,10 @@\n+2005-04-25  Steven Bosscher  <stevenb@suse.de>\n+\n+\tFix PR tree-optimization/21173\n+\n+\t* tree-ssa-pre.c (create_expression_by_pieces): Simplify code.\n+\tUnshare expression we pass to force_gimple_operand.\n+\n 2005-04-25  J\"orn Rennecke <joern.rennecke@st.com>\n \t    Stephen Clarke <stevec@superh.com>\n \t    Roger Sayle <roger@eyesopen.com>"}, {"sha": "c2043cc6345c8ee6ea655e6d58b071fe1871118c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 54, "deletions": 86, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81c4f554f38bbe074af8c31fad93d53b7085f5f2/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81c4f554f38bbe074af8c31fad93d53b7085f5f2/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=81c4f554f38bbe074af8c31fad93d53b7085f5f2", "patch": "@@ -1319,126 +1319,94 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n static tree\n create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n {\n-  tree name = NULL_TREE;\n-  tree newexpr = NULL_TREE;\n+  tree temp, name;\n+  tree folded, forced_stmts, newexpr;\n   tree v;\n-  \n+  tree_stmt_iterator tsi;\n+\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n     case tcc_binary:\n     case tcc_comparison:\n       {\n-\ttree_stmt_iterator tsi;\n-\ttree forced_stmts;\n-\ttree genop1, genop2;\n-\ttree temp;\n-\ttree folded;\n \ttree op1 = TREE_OPERAND (expr, 0);\n \ttree op2 = TREE_OPERAND (expr, 1);\n-\tgenop1 = find_or_generate_expression (block, op1, stmts);\n-\tgenop2 = find_or_generate_expression (block, op2, stmts);\n-\ttemp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n-\tadd_referenced_tmp_var (temp);\n-\t\n+\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n+\ttree genop2 = find_or_generate_expression (block, op2, stmts);\n \tfolded = fold (build (TREE_CODE (expr), TREE_TYPE (expr), \n \t\t\t      genop1, genop2));\n-\tnewexpr = force_gimple_operand (folded, &forced_stmts, false, NULL);\n-\tif (forced_stmts)\n-\t  {\n-\t    tsi = tsi_start (forced_stmts);\n-\t    for (; !tsi_end_p (tsi); tsi_next (&tsi))\n-\t      {\n-\t\ttree stmt = tsi_stmt (tsi);\n-\t\ttree forcedname = TREE_OPERAND (stmt, 0);\n-\t\ttree forcedexpr = TREE_OPERAND (stmt, 1);\n-\t\ttree val = vn_lookup_or_add (forcedexpr, NULL);\n-\t\tvn_add (forcedname, val, NULL);\t\t\n-\t\tbitmap_value_replace_in_set (NEW_SETS (block), forcedname); \n-\t\tbitmap_value_replace_in_set (AVAIL_OUT (block), forcedname);\n-\t      }\n-\n-\t    tsi = tsi_last (stmts);\n-\t    tsi_link_after (&tsi, forced_stmts, TSI_CONTINUE_LINKING);\n-\t  }\n-\tnewexpr = build (MODIFY_EXPR, TREE_TYPE (expr),\n-\t\t\t temp, newexpr);\n-\tNECESSARY (newexpr) = 0;\n-\tname = make_ssa_name (temp, newexpr);\n-\tTREE_OPERAND (newexpr, 0) = name;\n-\ttsi = tsi_last (stmts);\n-\ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n-\tVEC_safe_push (tree, heap, inserted_exprs, newexpr);\n-\tpre_stats.insertions++;\n \tbreak;\n       }\n+\n     case tcc_unary:\n       {\n-\ttree_stmt_iterator tsi;\n-\ttree forced_stmts = NULL;\n-\ttree genop1;\n-\ttree temp;\n-\ttree folded;\n \ttree op1 = TREE_OPERAND (expr, 0);\n-\tgenop1 = find_or_generate_expression (block, op1, stmts);\n-\ttemp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n-\tadd_referenced_tmp_var (temp);\n+\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n \tfolded = fold (build (TREE_CODE (expr), TREE_TYPE (expr), \n \t\t\t      genop1));\n-\t/* If the generated operand  is already GIMPLE min_invariant\n-\t   just use it instead of calling force_gimple_operand on it,\n-\t   since that may make it not invariant by copying it into an\n-\t   assignment.  */\n-\tif (!is_gimple_min_invariant (genop1))\n-\t  newexpr = force_gimple_operand (folded, &forced_stmts, false, NULL);\n-\telse\n-\t  newexpr = genop1;\n-\tif (forced_stmts)\n-\t  {\n-\t    tsi = tsi_start (forced_stmts);\n-\t    for (; !tsi_end_p (tsi); tsi_next (&tsi))\n-\t      {\n-\t\ttree stmt = tsi_stmt (tsi);\n-\t\ttree forcedname = TREE_OPERAND (stmt, 0);\n-\t\ttree forcedexpr = TREE_OPERAND (stmt, 1);\n-\t\ttree val = vn_lookup_or_add (forcedexpr, NULL);\n-\t\tvn_add (forcedname, val, NULL);\t\t\n-\t\tbitmap_value_replace_in_set (NEW_SETS (block), forcedname); \n-\t\tbitmap_value_replace_in_set (AVAIL_OUT (block), forcedname);\n-\t      }\n-\t    tsi = tsi_last (stmts);\n-\t    tsi_link_after (&tsi, forced_stmts, TSI_CONTINUE_LINKING);\n-\t  }\n-\tnewexpr = build (MODIFY_EXPR, TREE_TYPE (expr),\n-\t\t\t temp, newexpr);\n-\tname = make_ssa_name (temp, newexpr);\n-\tTREE_OPERAND (newexpr, 0) = name;\n-\tNECESSARY (newexpr) = 0;\n-\ttsi = tsi_last (stmts);\n-\ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n-\tVEC_safe_push (tree, heap, inserted_exprs, newexpr);\n-\tpre_stats.insertions++;\n-\n \tbreak;\n       }\n+\n     default:\n       gcc_unreachable ();\n-      \n     }\n-  v = get_value_handle (expr);\n-  vn_add (name, v, NULL);\n \n-  /* The value may already exist in either NEW_SETS, or AVAIL_OUT, because\n+  /* Force the generated expression to be a sequence of GIMPLE\n+     statements.\n+     We have to call unshare_expr because force_gimple_operand may\n+     modify the tree we pass to it.  */\n+  newexpr = force_gimple_operand (unshare_expr (folded), &forced_stmts, \n+                                  false, NULL);\n+\n+  /* If we have any intermediate expressions to the value sets, add them\n+     to the value sets and chain them on in the instruction stream.  */\n+  if (forced_stmts)\n+    {\n+      tsi = tsi_start (forced_stmts);\n+      for (; !tsi_end_p (tsi); tsi_next (&tsi))\n+\t{\n+\t  tree stmt = tsi_stmt (tsi);\n+\t  tree forcedname = TREE_OPERAND (stmt, 0);\n+\t  tree forcedexpr = TREE_OPERAND (stmt, 1);\n+\t  tree val = vn_lookup_or_add (forcedexpr, NULL);\n+\t  vn_add (forcedname, val, NULL);\n+\t  bitmap_value_replace_in_set (NEW_SETS (block), forcedname);\n+\t  bitmap_value_replace_in_set (AVAIL_OUT (block), forcedname);\n+\t}\n+      tsi = tsi_last (stmts);\n+      tsi_link_after (&tsi, forced_stmts, TSI_CONTINUE_LINKING);\n+    }\n+\n+  /* Build and insert the assignment of the end result to the temporary\n+     that we will return.  */\n+  temp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n+  add_referenced_tmp_var (temp);\n+  newexpr = build (MODIFY_EXPR, TREE_TYPE (expr), temp, newexpr);\n+  name = make_ssa_name (temp, newexpr);\n+  TREE_OPERAND (newexpr, 0) = name;\n+  NECESSARY (newexpr) = 0;\n+  tsi = tsi_last (stmts);\n+  tsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n+  VEC_safe_push (tree, heap, inserted_exprs, newexpr);\n+\n+  /* Add a value handle to the temprorary.\n+     The value may already exist in either NEW_SETS, or AVAIL_OUT, because\n      we are creating the expression by pieces, and this particular piece of\n      the expression may have been represented.  There is no harm in replacing\n      here.  */\n+  v = get_value_handle (expr);\n+  vn_add (name, v, NULL);\n   bitmap_value_replace_in_set (NEW_SETS (block), name); \n   bitmap_value_replace_in_set (AVAIL_OUT (block), name);\n+\n+  pre_stats.insertions++;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\t\t\t\t    \n       fprintf (dump_file, \"Inserted \");\n       print_generic_expr (dump_file, newexpr, 0);\n       fprintf (dump_file, \" in predecessor %d\\n\", block->index);\n     }\n+\n   return name;\n }\n "}]}