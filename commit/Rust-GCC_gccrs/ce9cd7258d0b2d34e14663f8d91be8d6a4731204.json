{"sha": "ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "node_id": "C_kwDOANBUbNoAKGNlOWNkNzI1OGQwYjJkMzRlMTQ2NjNmOGQ5MWJlOGQ2YTQ3MzEyMDQ", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2023-03-02T20:56:53Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2023-03-02T20:56:53Z"}, "message": "amdgcn: Enable SIMD vectorization of math functions\n\nCalls to vectorized versions of routines in the math library will now\nbe inserted when vectorizing code containing supported math functions.\n\n2023-03-02  Kwok Cheung Yeung  <kcy@codesourcery.com>\n\t    Paul-Antoine Arras  <pa@codesourcery.com>\n\n\tgcc/\n\t* builtins.cc (mathfn_built_in_explicit): New.\n\t* config/gcn/gcn.cc: Include case-cfn-macros.h.\n\t(mathfn_built_in_explicit): Add prototype.\n\t(gcn_vectorize_builtin_vectorized_function): New.\n\t(gcn_libc_has_function): New.\n\t(TARGET_LIBC_HAS_FUNCTION): Define.\n\t(TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION): Define.\n\n\tgcc/testsuite/\n\t* gcc.target/gcn/simd-math-1.c: New testcase.\n\t* gcc.target/gcn/simd-math-2.c: New testcase.\n\n\tlibgomp/\n\t* testsuite/libgomp.c/simd-math-1.c: New testcase.", "tree": {"sha": "2e06521f898b5c5412865a24b35688b207e14e34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e06521f898b5c5412865a24b35688b207e14e34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5425159d176a7a92afc932cbb22d8822667099c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5425159d176a7a92afc932cbb22d8822667099c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5425159d176a7a92afc932cbb22d8822667099c4"}], "stats": {"total": 549, "additions": 549, "deletions": 0}, "files": [{"sha": "305c65c29be58c838e6cdb4918aedb6096d2c38a", "filename": "gcc/builtins.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "patch": "@@ -2089,6 +2089,14 @@ mathfn_built_in (tree type, combined_fn fn)\n   return mathfn_built_in_1 (type, fn, /*implicit=*/ 1);\n }\n \n+/* Like mathfn_built_in_1, but always use the explicit array.  */\n+\n+tree\n+mathfn_built_in_explicit (tree type, combined_fn fn)\n+{\n+  return mathfn_built_in_1 (type, fn, /*implicit=*/ 0);\n+}\n+\n /* Like mathfn_built_in_1, but take a built_in_function and\n    always use the implicit array.  */\n "}, {"sha": "6f0a90a49040e66329fcbf944ad7910f7a895e8d", "filename": "gcc/config/gcn/gcn.cc", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.cc?ref=ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "patch": "@@ -53,6 +53,7 @@\n #include \"dwarf2.h\"\n #include \"gimple.h\"\n #include \"cgraph.h\"\n+#include \"case-cfn-macros.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -5240,6 +5241,110 @@ gcn_simd_clone_usable (struct cgraph_node *ARG_UNUSED (node))\n   return 0;\n }\n \n+tree mathfn_built_in_explicit (tree, combined_fn);\n+\n+/* Implement TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION.\n+   Return the function declaration of the vectorized version of the builtin\n+   in the math library if available.  */\n+\n+tree\n+gcn_vectorize_builtin_vectorized_function (unsigned int fn, tree type_out,\n+\t\t\t\t\t   tree type_in)\n+{\n+  if (TREE_CODE (type_out) != VECTOR_TYPE\n+      || TREE_CODE (type_in) != VECTOR_TYPE)\n+    return NULL_TREE;\n+\n+  machine_mode out_mode = TYPE_MODE (TREE_TYPE (type_out));\n+  int out_n = TYPE_VECTOR_SUBPARTS (type_out);\n+  machine_mode in_mode = TYPE_MODE (TREE_TYPE (type_in));\n+  int in_n = TYPE_VECTOR_SUBPARTS (type_in);\n+  combined_fn cfn = combined_fn (fn);\n+\n+  /* Keep this consistent with the list of vectorized math routines.  */\n+  int implicit_p;\n+  switch (fn)\n+    {\n+    CASE_CFN_ACOS:\n+    CASE_CFN_ACOSH:\n+    CASE_CFN_ASIN:\n+    CASE_CFN_ASINH:\n+    CASE_CFN_ATAN:\n+    CASE_CFN_ATAN2:\n+    CASE_CFN_ATANH:\n+    CASE_CFN_COPYSIGN:\n+    CASE_CFN_COS:\n+    CASE_CFN_COSH:\n+    CASE_CFN_ERF:\n+    CASE_CFN_EXP:\n+    CASE_CFN_EXP2:\n+    CASE_CFN_FINITE:\n+    CASE_CFN_FMOD:\n+    CASE_CFN_GAMMA:\n+    CASE_CFN_HYPOT:\n+    CASE_CFN_ISNAN:\n+    CASE_CFN_LGAMMA:\n+    CASE_CFN_LOG:\n+    CASE_CFN_LOG10:\n+    CASE_CFN_LOG2:\n+    CASE_CFN_POW:\n+    CASE_CFN_REMAINDER:\n+    CASE_CFN_RINT:\n+    CASE_CFN_SIN:\n+    CASE_CFN_SINH:\n+    CASE_CFN_SQRT:\n+    CASE_CFN_TAN:\n+    CASE_CFN_TANH:\n+    CASE_CFN_TGAMMA:\n+      implicit_p = 1;\n+      break;\n+\n+    CASE_CFN_SCALB:\n+    CASE_CFN_SIGNIFICAND:\n+      implicit_p = 0;\n+      break;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  tree out_t_node = (out_mode == DFmode) ? double_type_node : float_type_node;\n+  tree fndecl = implicit_p ? mathfn_built_in (out_t_node, cfn)\n+\t\t\t   : mathfn_built_in_explicit (out_t_node, cfn);\n+\n+  const char *bname = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+  char name[20];\n+  sprintf (name, out_mode == DFmode ? \"v%ddf_%s\" : \"v%dsf_%s\",\n+\t   out_n, bname + 10);\n+\n+  unsigned arity = 0;\n+  for (tree args = DECL_ARGUMENTS (fndecl); args; args = TREE_CHAIN (args))\n+    arity++;\n+\n+  tree fntype = (arity == 1)\n+\t\t? build_function_type_list (type_out, type_in, NULL)\n+\t\t: build_function_type_list (type_out, type_in, type_in, NULL);\n+\n+  /* Build a function declaration for the vectorized function.  */\n+  tree new_fndecl = build_decl (BUILTINS_LOCATION,\n+\t\t\t\tFUNCTION_DECL, get_identifier (name), fntype);\n+  TREE_PUBLIC (new_fndecl) = 1;\n+  DECL_EXTERNAL (new_fndecl) = 1;\n+  DECL_IS_NOVOPS (new_fndecl) = 1;\n+  TREE_READONLY (new_fndecl) = 1;\n+\n+  return new_fndecl;\n+}\n+\n+/* Implement TARGET_LIBC_HAS_FUNCTION.  */\n+\n+bool\n+gcn_libc_has_function (enum function_class fn_class,\n+\t\t       tree type)\n+{\n+  return bsd_libc_has_function (fn_class, type);\n+}\n+\n /* }}}  */\n /* {{{ md_reorg pass.  */\n \n@@ -7290,6 +7395,8 @@ gcn_dwarf_register_span (rtx rtl)\n   gcn_ira_change_pseudo_allocno_class\n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P gcn_legitimate_constant_p\n+#undef  TARGET_LIBC_HAS_FUNCTION\n+#define TARGET_LIBC_HAS_FUNCTION gcn_libc_has_function\n #undef  TARGET_LRA_P\n #define TARGET_LRA_P hook_bool_void_true\n #undef  TARGET_MACHINE_DEPENDENT_REORG\n@@ -7337,6 +7444,9 @@ gcn_dwarf_register_span (rtx rtl)\n #define TARGET_TRULY_NOOP_TRUNCATION gcn_truly_noop_truncation\n #undef  TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST gcn_vectorization_cost\n+#undef  TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION \\\n+  gcn_vectorize_builtin_vectorized_function\n #undef  TARGET_VECTORIZE_GET_MASK_MODE\n #define TARGET_VECTORIZE_GET_MASK_MODE gcn_vectorize_get_mask_mode\n #undef  TARGET_VECTORIZE_PREFERRED_SIMD_MODE"}, {"sha": "6868ccb2c543c64e30a0b2cd91bbd382c9e1f56b", "filename": "gcc/testsuite/gcc.target/gcn/simd-math-1.c", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fsimd-math-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fsimd-math-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fsimd-math-1.c?ref=ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "patch": "@@ -0,0 +1,206 @@\n+/* Check that calls to the vectorized math functions are actually emitted.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-math-errno -mstack-size=3000000 -fdump-tree-vect\" } */\n+\n+\n+#undef PRINT_RESULT\n+#define VERBOSE 0\n+#define EARLY_EXIT 1\n+\n+#include <math.h>\n+#include <stdlib.h>\n+\n+#ifdef PRINT_RESULT\n+  #include <stdio.h>\n+  #define PRINTF printf\n+#else\n+  static void null_printf (const char *f, ...) { }\n+\n+  #define PRINTF null_printf\n+#endif\n+\n+#define N 512\n+#define EPSILON_float 1e-5\n+#define EPSILON_double 1e-10\n+\n+static int failed = 0;\n+\n+int deviation_float (float x, float y)\n+{\n+  union {\n+    float f;\n+    unsigned u;\n+  } u, v;\n+\n+  u.f = x;\n+  v.f = y;\n+\n+  unsigned mask = 0x80000000U; \n+  int i;\n+\n+  for (i = 32; i > 0; i--)\n+    if ((u.u ^ v.u) & mask)\n+      break;\n+    else\n+      mask >>= 1;\n+\n+  return i;\n+}\n+\n+int deviation_double (double x, double y)\n+{\n+  union {\n+    double d;\n+    unsigned long long u;\n+  } u, v;\n+\n+  u.d = x;\n+  v.d = y;\n+\n+  unsigned long long mask = 0x8000000000000000ULL;\n+  int i;\n+\n+  for (i = 64; i > 0; i--)\n+    if ((u.u ^ v.u) & mask)\n+      break;\n+    else\n+      mask >>= 1;\n+\n+  return i;\n+}\n+\n+#define TEST_FUN(TFLOAT, LOW, HIGH, FUN) \\\n+__attribute__((optimize(\"no-tree-vectorize\"))) \\\n+__attribute__((optimize(\"no-unsafe-math-optimizations\"))) \\\n+void check_##FUN (TFLOAT res[N], TFLOAT a[N]) \\\n+{ \\\n+  int failed = 0; \\\n+  for (int i = 0; i < N; i++) { \\\n+    TFLOAT expected = FUN (a[i]); \\\n+    TFLOAT diff = __builtin_fabs (expected - res[i]); \\\n+    int deviation = deviation_##TFLOAT (expected, res[i]); \\\n+    int fail = isnan (res[i]) != isnan (expected) \\\n+               || isinf (res[i]) != isinf (expected) \\\n+               || (diff > EPSILON_##TFLOAT && deviation > 10); \\\n+    failed |= fail; \\\n+    if (VERBOSE || fail) \\\n+      PRINTF (#FUN \"(%f) = %f, expected = %f, diff = %f, deviation = %d %s\\n\", \\\n+              a[i], res[i], expected, diff, deviation, fail ? \"(!)\" : \"\"); \\\n+    if (EARLY_EXIT && fail) \\\n+      exit (1); \\\n+  } \\\n+} \\\n+void test_##FUN (void) \\\n+{ \\\n+  TFLOAT res[N], a[N]; \\\n+  for (int i = 0; i < N; i++) \\\n+    a[i] = LOW + ((HIGH - LOW) / N) * i; \\\n+  for (int i = 0; i < N; i++) \\\n+    res[i] = FUN (a[i]); \\\n+  check_##FUN (res, a); \\\n+}\\\n+test_##FUN ();\n+\n+#define TEST_FUN2(TFLOAT, LOW1, HIGH1, LOW2, HIGH2, FUN) \\\n+__attribute__((optimize(\"no-tree-vectorize\"))) \\\n+__attribute__((optimize(\"no-unsafe-math-optimizations\"))) \\\n+void check_##FUN (TFLOAT res[N], TFLOAT a[N], TFLOAT b[N]) \\\n+{ \\\n+  int failed = 0; \\\n+  for (int i = 0; i < N; i++) { \\\n+    TFLOAT expected = FUN (a[i], b[i]); \\\n+    TFLOAT diff = __builtin_fabs (expected - res[i]); \\\n+    int deviation = deviation_##TFLOAT (expected, res[i]); \\\n+    int fail = isnan (res[i]) != isnan (expected) \\\n+               || isinf (res[i]) != isinf (expected) \\\n+               || (diff > EPSILON_##TFLOAT && deviation > 10); \\\n+    failed |= fail; \\\n+    if (VERBOSE || fail) \\\n+      PRINTF (#FUN \"(%f,%f) = %f, expected = %f, diff = %f, deviation = %d %s\\n\", \\\n+              a[i], b[i], res[i], expected, diff, deviation, fail ? \"(!)\" : \"\"); \\\n+    if (EARLY_EXIT && fail) \\\n+      exit (1); \\\n+  } \\\n+} \\\n+void test_##FUN (void) \\\n+{ \\\n+  TFLOAT res[N], a[N], b[N]; \\\n+  for (int i = 0; i < N; i++) { \\\n+    a[i] = LOW1 + ((HIGH1 - LOW1) / N) * i; \\\n+    b[i] = LOW2 + ((HIGH2 - LOW2) / N) * i; \\\n+  } \\\n+  for (int i = 0; i < N; i++) \\\n+    res[i] = FUN (a[i], b[i]); \\\n+  check_##FUN (res, a, b); \\\n+}\\\n+test_##FUN ();\n+\n+int main (void)\n+{\n+  TEST_FUN (float, -1.1, 1.1, acosf); /* { dg-final { scan-tree-dump \"v64sf_acosf\" \"vect\" } }*/\n+  TEST_FUN (float, -10, 10, acoshf); /* { dg-final { scan-tree-dump \"v64sf_acoshf\" \"vect\" } }*/\n+  TEST_FUN (float, -1.1, 1.1, asinf); /* { dg-final { scan-tree-dump \"v64sf_asinf\" \"vect\" } }*/\n+  TEST_FUN (float, -10, 10, asinhf); /* { dg-final { scan-tree-dump \"v64sf_asinhf\" \"vect\" } }*/\n+  TEST_FUN (float, -1.1, 1.1, atanf); /* { dg-final { scan-tree-dump \"v64sf_atanf\" \"vect\" } }*/\n+  TEST_FUN2 (float, -2.0, 2.0, 2.0, -2.0, atan2f); /* { dg-final { scan-tree-dump \"v64sf_atan2f\" \"vect\" } }*/\n+  TEST_FUN (float, -2.0, 2.0, atanhf); /* { dg-final { scan-tree-dump \"v64sf_atanhf\" \"vect\" } }*/\n+  TEST_FUN2 (float, -10.0, 10.0, 5.0, -15.0, copysignf); /* { dg-final { scan-tree-dump \"v64sf_copysignf\" \"vect\" } }*/\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, cosf); /* { dg-final { scan-tree-dump \"v64sf_cosf\" \"vect\" } }*/\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, coshf); /* { dg-final { scan-tree-dump \"v64sf_coshf\" \"vect\" } }*/\n+  TEST_FUN (float, -10.0, 10.0, erff);  /* { dg-final { scan-tree-dump \"v64sf_erff\" \"vect\" } }*/\n+  TEST_FUN (float, -10.0, 10.0, expf); /* { dg-final { scan-tree-dump \"v64sf_expf\" \"vect\" } }*/\n+  TEST_FUN (float, -10.0, 10.0, exp2f); /* { dg-final { scan-tree-dump \"v64sf_exp2f\" \"vect\" } }*/\n+  TEST_FUN2 (float, -10.0, 10.0, 100.0, -25.0, fmodf); /* { dg-final { scan-tree-dump \"v64sf_fmodf\" \"vect\" } }*/\n+  TEST_FUN (float, -10.0, 10.0, gammaf); /* { dg-final { scan-tree-dump \"v64sf_gammaf\" \"vect\" { xfail *-*-*} } }*/\n+  TEST_FUN2 (float, -10.0, 10.0, 15.0, -5.0,hypotf); /* { dg-final { scan-tree-dump \"v64sf_hypotf\" \"vect\" } }*/\n+  TEST_FUN (float, -10.0, 10.0, lgammaf); /* { dg-final { scan-tree-dump \"v64sf_lgammaf\" \"vect\" { xfail *-*-*} } }*/\n+  TEST_FUN (float, -1.0, 50.0, logf); /* { dg-final { scan-tree-dump \"v64sf_logf\" \"vect\" } }*/\n+  TEST_FUN (float, -1.0, 500.0, log10f); /* { dg-final { scan-tree-dump \"v64sf_log10f\" \"vect\" } }*/\n+  TEST_FUN (float, -1.0, 64.0, log2f); /* { dg-final { scan-tree-dump \"v64sf_log2f\" \"vect\" } }*/\n+  TEST_FUN2 (float, -100.0, 100.0, 100.0, -100.0, powf); /* { dg-final { scan-tree-dump \"v64sf_powf\" \"vect\" } }*/\n+  TEST_FUN2 (float, -50.0, 100.0, -2.0, 40.0, remainderf); /* { dg-final { scan-tree-dump \"v64sf_remainderf\" \"vect\" } }*/\n+  TEST_FUN (float, -50.0, 50.0, rintf);  /* { dg-final { scan-tree-dump \"v64sf_rintf\" \"vect\" } }*/\n+  TEST_FUN2 (float, -50.0, 50.0, -10.0, 32.0, __builtin_scalbf); /* { dg-final { scan-tree-dump \"v64sf_scalbf\" \"vect\" } }*/\n+  TEST_FUN (float, -10.0, 10.0, __builtin_significandf); /* { dg-final { scan-tree-dump \"v64sf_significandf\" \"vect\" } }*/\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, sinf); /* { dg-final { scan-tree-dump \"v64sf_sinf\" \"vect\" } }*/\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, sinhf); /* { dg-final { scan-tree-dump \"v64sf_sinhf\" \"vect\" } }*/\n+  TEST_FUN (float, -0.1, 10000.0, sqrtf); /* { dg-final { scan-tree-dump \"v64sf_sqrtf\" \"vect\" } }*/\n+  TEST_FUN (float, -5.0, 5.0, tanf); /* { dg-final { scan-tree-dump \"v64sf_tanf\" \"vect\" } }*/\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, tanhf); /* { dg-final { scan-tree-dump \"v64sf_tanhf\" \"vect\" } }*/\n+  TEST_FUN (float, -10.0, 10.0, tgammaf); /* { dg-final { scan-tree-dump \"v64sf_tgammaf\" \"vect\" } }*/\n+\n+  TEST_FUN (double, -1.1, 1.1, acos); /* { dg-final { scan-tree-dump \"v64df_acos\" \"vect\" } }*/\n+  TEST_FUN (double, -10, 10, acosh); /* { dg-final { scan-tree-dump \"v64df_acosh\" \"vect\" } }*/\n+  TEST_FUN (double, -1.1, 1.1, asin); /* { dg-final { scan-tree-dump \"v64df_asin\" \"vect\" } }*/\n+  TEST_FUN (double, -10, 10, asinh); /* { dg-final { scan-tree-dump \"v64df_asinh\" \"vect\" } }*/\n+  TEST_FUN (double, -1.1, 1.1, atan); /* { dg-final { scan-tree-dump \"v64df_atan\" \"vect\" } }*/\n+  TEST_FUN2 (double, -2.0, 2.0, 2.0, -2.0, atan2); /* { dg-final { scan-tree-dump \"v64df_atan2\" \"vect\" } }*/\n+  TEST_FUN (double, -2.0, 2.0, atanh); /* { dg-final { scan-tree-dump \"v64df_atanh\" \"vect\" } }*/\n+  TEST_FUN2 (double, -10.0, 10.0, 5.0, -15.0, copysign); /* { dg-final { scan-tree-dump \"v64df_copysign\" \"vect\" } }*/\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, cos); /* { dg-final { scan-tree-dump \"v64df_cos\" \"vect\" } }*/\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, cosh); /* { dg-final { scan-tree-dump \"v64df_cosh\" \"vect\" } }*/\n+  TEST_FUN (double, -10.0, 10.0, erf); /* { dg-final { scan-tree-dump \"v64df_erf\" \"vect\" } }*/\n+  TEST_FUN (double, -10.0, 10.0, exp); /* { dg-final { scan-tree-dump \"v64df_exp\" \"vect\" } }*/\n+  TEST_FUN (double, -10.0, 10.0, exp2); /* { dg-final { scan-tree-dump \"v64df_exp2\" \"vect\" } }*/\n+  TEST_FUN2 (double, -10.0, 10.0, 100.0, -25.0, fmod); /* { dg-final { scan-tree-dump \"v64df_fmod\" \"vect\" } }*/\n+  TEST_FUN (double, -10.0, 10.0, gamma); /* { dg-final { scan-tree-dump \"v64df_gamma\" \"vect\" { xfail *-*-*} } }*/\n+  TEST_FUN2 (double, -10.0, 10.0, 15.0, -5.0, hypot); /* { dg-final { scan-tree-dump \"v64df_hypot\" \"vect\" } }*/\n+  TEST_FUN (double, -10.0, 10.0, lgamma); /* { dg-final { scan-tree-dump \"v64df_lgamma\" \"vect\" { xfail *-*-*} } }*/\n+  TEST_FUN (double, -1.0, 50.0, log); /* { dg-final { scan-tree-dump \"v64df_log\" \"vect\" } }*/\n+  TEST_FUN (double, -1.0, 500.0, log10); /* { dg-final { scan-tree-dump \"v64df_log10\" \"vect\" } }*/\n+  TEST_FUN (double, -1.0, 64.0, log2); /* { dg-final { scan-tree-dump \"v64df_log2\" \"vect\" { xfail *-*-*} } }*/\n+  TEST_FUN2 (double, -100.0, 100.0, 100.0, -100.0, pow); /* { dg-final { scan-tree-dump \"v64df_pow\" \"vect\" } }*/\n+  TEST_FUN2 (double, -50.0, 100.0, -2.0, 40.0, remainder); /* { dg-final { scan-tree-dump \"v64df_remainder\" \"vect\" } }*/\n+  TEST_FUN (double, -50.0, 50.0, rint); /* { dg-final { scan-tree-dump \"v64df_rint\" \"vect\" } }*/\n+  TEST_FUN2 (double, -50.0, 50.0, -10.0, 32.0, __builtin_scalb); /* { dg-final { scan-tree-dump \"v64df_scalb\" \"vect\" } }*/\n+  TEST_FUN (double, -10.0, 10.0, __builtin_significand); /* { dg-final { scan-tree-dump \"v64df_significand\" \"vect\" } }*/\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, sin); /* { dg-final { scan-tree-dump \"v64df_sin\" \"vect\" } }*/\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, sinh); /* { dg-final { scan-tree-dump \"v64df_sinh\" \"vect\" } }*/\n+  TEST_FUN (double, -0.1, 10000.0, sqrt); /* { dg-final { scan-tree-dump \"v64df_sqrt\" \"vect\" } }*/\n+  TEST_FUN (double, -5.0, 5.0, tan); /* { dg-final { scan-tree-dump \"v64df_tan\" \"vect\" } }*/\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, tanh); /* { dg-final { scan-tree-dump \"v64df_tanh\" \"vect\" } }*/\n+  TEST_FUN (double, -10.0, 10.0, tgamma); /* { dg-final { scan-tree-dump \"v64df_tgamma\" \"vect\" } }*/\n+\n+  return failed;\n+}"}, {"sha": "375a2ad92631b37f1e2d1abe2a411a318f4fe59b", "filename": "gcc/testsuite/gcc.target/gcn/simd-math-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fsimd-math-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fsimd-math-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fgcn%2Fsimd-math-2.c?ref=ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "patch": "@@ -0,0 +1,8 @@\n+/* Check that the SIMD versions of math routines give the same (or\n+   sufficiently close) results as their scalar equivalents.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-math-errno\" } */\n+/* { dg-set-target-env-var \"GCN_STACK_SIZE\" \"3000000\" } */\n+\n+#include \"simd-math-1.c\""}, {"sha": "947bf606e3602cbcd5153b01e30defe33897b5f2", "filename": "libgomp/testsuite/libgomp.c/simd-math-1.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-math-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9cd7258d0b2d34e14663f8d91be8d6a4731204/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-math-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsimd-math-1.c?ref=ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "patch": "@@ -0,0 +1,217 @@\n+/* Check that the SIMD versions of math routines give the same (or\n+   sufficiently close) results as their scalar equivalents.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-math-errno\" } */\n+/* { dg-additional-options -foffload-options=amdgcn-amdhsa=-mstack-size=3000000 { target offload_target_amdgcn } } */\n+/* { dg-additional-options -foffload-options=-lm } */\n+\n+#undef PRINT_RESULT\n+#define VERBOSE 0\n+#define EARLY_EXIT 1\n+\n+#include <math.h>\n+#include <stdlib.h>\n+\n+#ifdef PRINT_RESULT\n+  #include <stdio.h>\n+  #define PRINTF printf\n+#else\n+  static void null_printf (const char *f, ...) { }\n+\n+  #define PRINTF null_printf\n+#endif\n+\n+#define N 512\n+#define EPSILON_float 1e-5\n+#define EPSILON_double 1e-10\n+\n+static int xfail = 0;\n+static int failed = 0;\n+\n+int deviation_float (float x, float y)\n+{\n+  union {\n+    float f;\n+    unsigned u;\n+  } u, v;\n+\n+  u.f = x;\n+  v.f = y;\n+\n+  unsigned mask = 0x80000000U;\n+  int i;\n+\n+  for (i = 32; i > 0; i--)\n+    if ((u.u ^ v.u) & mask)\n+      break;\n+    else\n+      mask >>= 1;\n+\n+  return i;\n+}\n+\n+int deviation_double (double x, double y)\n+{\n+  union {\n+    double d;\n+    unsigned long long u;\n+  } u, v;\n+\n+  u.d = x;\n+  v.d = y;\n+\n+  unsigned long long mask = 0x8000000000000000ULL;\n+  int i;\n+\n+  for (i = 64; i > 0; i--)\n+    if ((u.u ^ v.u) & mask)\n+      break;\n+    else\n+      mask >>= 1;\n+\n+  return i;\n+}\n+\n+#define TEST_FUN_XFAIL(TFLOAT, LOW, HIGH, FUN) \\\n+  xfail = 1; \\\n+  TEST_FUN (TFLOAT, LOW, HIGH, FUN); \\\n+  xfail = 0;\n+\n+#define TEST_FUN(TFLOAT, LOW, HIGH, FUN) \\\n+__attribute__((optimize(\"no-tree-vectorize\"))) \\\n+__attribute__((optimize(\"no-unsafe-math-optimizations\"))) \\\n+void check_##FUN (TFLOAT res[N], TFLOAT a[N]) \\\n+{ \\\n+  for (int i = 0; i < N; i++) { \\\n+    TFLOAT expected = FUN (a[i]); \\\n+    TFLOAT diff = __builtin_fabs (expected - res[i]); \\\n+    int deviation = deviation_##TFLOAT (expected, res[i]); \\\n+    int fail = isnan (res[i]) != isnan (expected) \\\n+\t       || isinf (res[i]) != isinf (expected) \\\n+\t       || (diff > EPSILON_##TFLOAT && deviation > 10); \\\n+    if (VERBOSE || fail) \\\n+      PRINTF (#FUN \"(%f) = %f, expected = %f, diff = %f, deviation = %d %s\\n\", \\\n+\t      a[i], res[i], expected, diff, deviation, fail ? \"(!)\" : \"\"); \\\n+    failed |= (fail && !xfail); \\\n+    if (EARLY_EXIT && failed) \\\n+      exit (1); \\\n+  } \\\n+} \\\n+void test_##FUN (void) \\\n+{ \\\n+  TFLOAT res[N], a[N]; \\\n+  for (int i = 0; i < N; i++) \\\n+    a[i] = LOW + ((HIGH - LOW) / N) * i; \\\n+  _Pragma (\"omp target parallel for simd map(to:a) map(from:res)\") \\\n+    for (int i = 0; i < N; i++) \\\n+      res[i] = FUN (a[i]); \\\n+  check_##FUN (res, a); \\\n+}\\\n+test_##FUN ();\n+\n+#define TEST_FUN2(TFLOAT, LOW1, HIGH1, LOW2, HIGH2, FUN) \\\n+__attribute__((optimize(\"no-tree-vectorize\"))) \\\n+__attribute__((optimize(\"no-unsafe-math-optimizations\"))) \\\n+void check_##FUN (TFLOAT res[N], TFLOAT a[N], TFLOAT b[N]) \\\n+{ \\\n+  int failed = 0; \\\n+  for (int i = 0; i < N; i++) { \\\n+    TFLOAT expected = FUN (a[i], b[i]); \\\n+    TFLOAT diff = __builtin_fabs (expected - res[i]); \\\n+    int deviation = deviation_##TFLOAT (expected, res[i]); \\\n+    int fail = isnan (res[i]) != isnan (expected) \\\n+\t       || isinf (res[i]) != isinf (expected) \\\n+\t       || (diff > EPSILON_##TFLOAT && deviation > 10); \\\n+    failed |= fail; \\\n+    if (VERBOSE || fail) \\\n+      PRINTF (#FUN \"(%f,%f) = %f, expected = %f, diff = %f, deviation = %d %s\\n\", \\\n+\t      a[i], b[i], res[i], expected, diff, deviation, fail ? \"(!)\" : \"\"); \\\n+    if (EARLY_EXIT && fail) \\\n+      exit (1); \\\n+  } \\\n+} \\\n+void test_##FUN (void) \\\n+{ \\\n+  TFLOAT res[N], a[N], b[N]; \\\n+  for (int i = 0; i < N; i++) { \\\n+    a[i] = LOW1 + ((HIGH1 - LOW1) / N) * i; \\\n+    b[i] = LOW2 + ((HIGH2 - LOW2) / N) * i; \\\n+  } \\\n+  _Pragma (\"omp target parallel for simd map(to:a) map(from:res)\") \\\n+    for (int i = 0; i < N; i++) \\\n+      res[i] = FUN (a[i], b[i]); \\\n+  check_##FUN (res, a, b); \\\n+}\\\n+test_##FUN ();\n+\n+int main (void)\n+{\n+  TEST_FUN (float, -1.1, 1.1, acosf);\n+  TEST_FUN (float, -10, 10, acoshf);\n+  TEST_FUN (float, -1.1, 1.1, asinf);\n+  TEST_FUN (float, -10, 10, asinhf);\n+  TEST_FUN (float, -1.1, 1.1, atanf);\n+  TEST_FUN2 (float, -2.0, 2.0, 2.0, -2.0, atan2f);\n+  TEST_FUN (float, -2.0, 2.0, atanhf);\n+  TEST_FUN2 (float, -10.0, 10.0, 5.0, -15.0, copysignf);\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, cosf);\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, coshf);\n+  TEST_FUN (float, -10.0, 10.0, erff);\n+  TEST_FUN (float, -10.0, 10.0, expf);\n+  TEST_FUN (float, -10.0, 10.0, exp2f);\n+  TEST_FUN2 (float, -10.0, 10.0, 100.0, -25.0, fmodf);\n+  TEST_FUN (float, -10.0, 10.0, gammaf);\n+  TEST_FUN2 (float, -10.0, 10.0, 15.0, -5.0,hypotf);\n+  TEST_FUN (float, -10.0, 10.0, lgammaf);\n+  TEST_FUN (float, -1.0, 50.0, logf);\n+  TEST_FUN (float, -1.0, 500.0, log10f);\n+  TEST_FUN (float, -1.0, 64.0, log2f);\n+  TEST_FUN2 (float, -100.0, 100.0, 100.0, -100.0, powf);\n+  TEST_FUN2 (float, -50.0, 100.0, -2.0, 40.0, remainderf);\n+  TEST_FUN (float, -50.0, 50.0, rintf);\n+  TEST_FUN2 (float, -50.0, 50.0, -10.0, 32.0, __builtin_scalbf);\n+  TEST_FUN (float, -10.0, 10.0, __builtin_significandf);\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, sinf);\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, sinhf);\n+  TEST_FUN (float, -0.1, 10000.0, sqrtf);\n+  TEST_FUN (float, -5.0, 5.0, tanf);\n+  TEST_FUN (float, -3.14159265359, 3.14159265359, tanhf);\n+  /* Newlib's version of tgammaf is known to have poor accuracy.  */\n+  TEST_FUN_XFAIL (float, -10.0, 10.0, tgammaf);\n+\n+  TEST_FUN (double, -1.1, 1.1, acos);\n+  TEST_FUN (double, -10, 10, acosh);\n+  TEST_FUN (double, -1.1, 1.1, asin);\n+  TEST_FUN (double, -10, 10, asinh);\n+  TEST_FUN (double, -1.1, 1.1, atan);\n+  TEST_FUN2 (double, -2.0, 2.0, 2.0, -2.0, atan2);\n+  TEST_FUN (double, -2.0, 2.0, atanh);\n+  TEST_FUN2 (double, -10.0, 10.0, 5.0, -15.0, copysign);\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, cos);\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, cosh);\n+  TEST_FUN (double, -10.0, 10.0, erf);\n+  TEST_FUN (double, -10.0, 10.0, exp);\n+  TEST_FUN (double, -10.0, 10.0, exp2);\n+  TEST_FUN2 (double, -10.0, 10.0, 100.0, -25.0, fmod);\n+  TEST_FUN (double, -10.0, 10.0, gamma);\n+  TEST_FUN2 (double, -10.0, 10.0, 15.0, -5.0, hypot);\n+  TEST_FUN (double, -10.0, 10.0, lgamma);\n+  TEST_FUN (double, -1.0, 50.0, log);\n+  TEST_FUN (double, -1.0, 500.0, log10);\n+  TEST_FUN (double, -1.0, 64.0, log2);\n+  TEST_FUN2 (double, -100.0, 100.0, 100.0, -100.0, pow);\n+  TEST_FUN2 (double, -50.0, 100.0, -2.0, 40.0, remainder);\n+  TEST_FUN (double, -50.0, 50.0, rint);\n+  TEST_FUN2 (double, -50.0, 50.0, -10.0, 32.0, __builtin_scalb);\n+  TEST_FUN (double, -10.0, 10.0, __builtin_significand);\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, sin);\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, sinh);\n+  TEST_FUN (double, -0.1, 10000.0, sqrt);\n+  TEST_FUN (double, -5.0, 5.0, tan);\n+  TEST_FUN (double, -3.14159265359, 3.14159265359, tanh);\n+  /* Newlib's version of tgamma is known to have poor accuracy.  */\n+  TEST_FUN_XFAIL (double, -10.0, 10.0, tgamma);\n+\n+  return failed;\n+}"}]}