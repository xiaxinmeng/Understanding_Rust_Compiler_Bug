{"sha": "a211395bbba9f4df621d741c43b56d851f123607", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxMTM5NWJiYmE5ZjRkZjYyMWQ3NDFjNDNiNTZkODUxZjEyMzYwNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-04-17T21:42:19Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-04-17T21:42:19Z"}, "message": "reload1.c (move2add_last_cc0): New.\n\n\t* reload1.c (move2add_last_cc0): New.\n\t(reload_cse_move2add): Detect implicit sets.\n\t(move2add_note_store): Notice a store into cc0.\n\nFrom-SVN: r65754", "tree": {"sha": "ce5d2c9f1c930ffefdcebdac3891d91c22af277c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce5d2c9f1c930ffefdcebdac3891d91c22af277c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a211395bbba9f4df621d741c43b56d851f123607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a211395bbba9f4df621d741c43b56d851f123607", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a211395bbba9f4df621d741c43b56d851f123607", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a211395bbba9f4df621d741c43b56d851f123607/comments", "author": null, "committer": null, "parents": [{"sha": "220a35cc8e39aa6e6a846fefee1a7bf460a339cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220a35cc8e39aa6e6a846fefee1a7bf460a339cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220a35cc8e39aa6e6a846fefee1a7bf460a339cc"}], "stats": {"total": 40, "additions": 40, "deletions": 0}, "files": [{"sha": "df58352d177b71ae4b4e49d24e4246ede44da54b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a211395bbba9f4df621d741c43b56d851f123607/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a211395bbba9f4df621d741c43b56d851f123607/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a211395bbba9f4df621d741c43b56d851f123607", "patch": "@@ -1,3 +1,9 @@\n+2003-04-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* reload1.c (move2add_last_cc0): New.\n+\t(reload_cse_move2add): Detect implicit sets.\n+\t(move2add_note_store): Notice a store into cc0.\n+\n 2003-04-17  Roger Sayle  <roger@eyesopen.com>\n \n \tPR c/10375"}, {"sha": "83456130534fd139132a927eb899798e679e4d28", "filename": "gcc/reload1.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a211395bbba9f4df621d741c43b56d851f123607/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a211395bbba9f4df621d741c43b56d851f123607/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a211395bbba9f4df621d741c43b56d851f123607", "patch": "@@ -9094,6 +9094,9 @@ static int move2add_last_label_luid;\n        && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (OUTMODE), \\\n \t\t\t\t GET_MODE_BITSIZE (INMODE))))\n \n+/* The source of the last set to cc0 we've seen.  */\n+static rtx move2add_last_cc0;\n+\n static void\n reload_cse_move2add (first)\n      rtx first;\n@@ -9106,6 +9109,7 @@ reload_cse_move2add (first)\n \n   move2add_last_label_luid = 0;\n   move2add_luid = 2;\n+  move2add_last_cc0 = NULL_RTX;\n   for (insn = first; insn; insn = NEXT_INSN (insn), move2add_luid++)\n     {\n       rtx pat, note;\n@@ -9288,6 +9292,29 @@ reload_cse_move2add (first)\n \t    }\n \t}\n       note_stores (PATTERN (insn), move2add_note_store, NULL);\n+\n+      /* If INSN is a conditional branch, we try to extract an\n+\t implicit set out of it.  */\n+      if (any_condjump_p (insn) && onlyjump_p (insn))\n+\t{\n+\t  rtx cnd = get_condition (insn, NULL);\n+\n+#ifdef HAVE_cc0\n+\t  if (cnd != NULL_RTX && move2add_last_cc0 != NULL_RTX)\n+\t    cnd = simplify_replace_rtx (cnd, cc0_rtx, move2add_last_cc0);\n+#endif\n+\t  if (cnd != NULL_RTX\n+\t      && GET_CODE (cnd) == NE\n+\t      && GET_CODE (XEXP (cnd, 0)) == REG\n+\t      && SCALAR_INT_MODE_P (GET_MODE (XEXP (cnd, 0)))\n+\t      && GET_CODE (XEXP (cnd, 1)) == CONST_INT)\n+\t    {\n+\t      rtx implicit_set =\n+\t\tgen_rtx_SET (VOIDmode, SET_DEST (cnd), SET_SRC (cnd));\n+\t      move2add_note_store (SET_DEST (implicit_set), implicit_set, 0);\n+\t    }\n+\t}\n+\n       /* If this is a CALL_INSN, all call used registers are stored with\n \t unknown values.  */\n       if (GET_CODE (insn) == CALL_INSN)\n@@ -9334,6 +9361,13 @@ move2add_note_store (dst, set, data)\n \treg_set_luid[REGNO (XEXP (dst, 0))] = 0;\n       return;\n     }\n+  /* Note a store into cc0 so that we can later find an implicit\n+     set.  */\n+  if (CC0_P (dst))\n+    {\n+      move2add_last_cc0 = SET_SRC (set);\n+      return;\n+    }\n   if (GET_CODE (dst) != REG)\n     return;\n "}]}