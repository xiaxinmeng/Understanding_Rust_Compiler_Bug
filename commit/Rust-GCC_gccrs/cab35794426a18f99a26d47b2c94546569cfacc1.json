{"sha": "cab35794426a18f99a26d47b2c94546569cfacc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FiMzU3OTQ0MjZhMThmOTlhMjZkNDdiMmM5NDU0NjU2OWNmYWNjMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-10-18T08:46:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-10-18T08:46:00Z"}, "message": "re PR middle-end/50716 (Segmentation fault caused by misaligned vector access)\n\n2011-10-18  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/50716\n\t* expr.c (get_object_or_type_alignment): New function.\n\t(expand_assignment): Use it.\n\t(expand_expr_real_1): Likewise.\n\nFrom-SVN: r180125", "tree": {"sha": "1a8080e2ebcb325ca311d4643aef5acb4e9cbca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a8080e2ebcb325ca311d4643aef5acb4e9cbca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cab35794426a18f99a26d47b2c94546569cfacc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab35794426a18f99a26d47b2c94546569cfacc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cab35794426a18f99a26d47b2c94546569cfacc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cab35794426a18f99a26d47b2c94546569cfacc1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d17687f6f0ec28df90cb851a15cf0945d7b7ba57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17687f6f0ec28df90cb851a15cf0945d7b7ba57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17687f6f0ec28df90cb851a15cf0945d7b7ba57"}], "stats": {"total": 46, "additions": 37, "deletions": 9}, "files": [{"sha": "19f851d2dd43b406ebe2a7e22b489dd0aef9b149", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab35794426a18f99a26d47b2c94546569cfacc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab35794426a18f99a26d47b2c94546569cfacc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cab35794426a18f99a26d47b2c94546569cfacc1", "patch": "@@ -1,3 +1,10 @@\n+2011-10-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/50716\n+\t* expr.c (get_object_or_type_alignment): New function.\n+\t(expand_assignment): Use it.\n+\t(expand_expr_real_1): Likewise.\n+\n 2011-10-18  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR bootstrap/50760"}, {"sha": "c1117a8231c19fc2fa077808fecc2e3245d1ffc0", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cab35794426a18f99a26d47b2c94546569cfacc1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cab35794426a18f99a26d47b2c94546569cfacc1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cab35794426a18f99a26d47b2c94546569cfacc1", "patch": "@@ -4544,6 +4544,27 @@ get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n     }\n }\n \n+/* Return the alignment of the object EXP, also considering its type\n+   when we do not know of explicit misalignment.\n+   ???  Note that, in the general case, the type of an expression is not kept\n+   consistent with misalignment information by the front-end, for\n+   example when taking the address of a member of a packed structure.\n+   However, in most of the cases, expressions have the alignment of\n+   their type, so we optimistically fall back to the alignment of the\n+   type when we cannot compute a misalignment.  */\n+\n+static unsigned int\n+get_object_or_type_alignment (tree exp)\n+{\n+  unsigned HOST_WIDE_INT misalign;\n+  unsigned int align = get_object_alignment_1 (exp, &misalign);\n+  if (misalign != 0)\n+    align = (misalign & -misalign);\n+  else\n+    align = MAX (TYPE_ALIGN (TREE_TYPE (exp)), align);\n+  return align;\n+}\n+\n /* Expand an assignment that stores the value of FROM into TO.  If NONTEMPORAL\n    is true, try generating a nontemporal store.  */\n \n@@ -4553,7 +4574,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   rtx to_rtx = 0;\n   rtx result;\n   enum machine_mode mode;\n-  int align;\n+  unsigned int align;\n   enum insn_code icode;\n \n   /* Don't crash if the lhs of the assignment was erroneous.  */\n@@ -4571,8 +4592,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n   if ((TREE_CODE (to) == MEM_REF\n        || TREE_CODE (to) == TARGET_MEM_REF)\n       && mode != BLKmode\n-      && ((align = MAX (TYPE_ALIGN (TREE_TYPE (to)), get_object_alignment (to)))\n-\t  < (signed) GET_MODE_ALIGNMENT (mode))\n+      && ((align = get_object_or_type_alignment (to))\n+\t  < GET_MODE_ALIGNMENT (mode))\n       && ((icode = optab_handler (movmisalign_optab, mode))\n \t  != CODE_FOR_nothing))\n     {\n@@ -9241,17 +9262,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \taddr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n \tstruct mem_address addr;\n \tenum insn_code icode;\n-\tint align;\n+\tunsigned int align;\n \n \tget_address_description (exp, &addr);\n \top0 = addr_for_mem_ref (&addr, as, true);\n \top0 = memory_address_addr_space (mode, op0, as);\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, exp, 0);\n \tset_mem_addr_space (temp, as);\n-\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)), get_object_alignment (exp));\n+\talign = get_object_or_type_alignment (exp);\n \tif (mode != BLKmode\n-\t    && (unsigned) align < GET_MODE_ALIGNMENT (mode)\n+\t    && align < GET_MODE_ALIGNMENT (mode)\n \t    /* If the target does not have special handling for unaligned\n \t       loads of mode then it can use regular moves for them.  */\n \t    && ((icode = optab_handler (movmisalign_optab, mode))\n@@ -9278,7 +9299,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttree base = TREE_OPERAND (exp, 0);\n \tgimple def_stmt;\n \tenum insn_code icode;\n-\tint align;\n+\tunsigned align;\n \t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n \t   might end up in a register.  */\n \tif (TREE_CODE (base) == ADDR_EXPR)\n@@ -9329,7 +9350,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t   gimple_assign_rhs1 (def_stmt), mask);\n \t    TREE_OPERAND (exp, 0) = base;\n \t  }\n-\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)), get_object_alignment (exp));\n+\talign = get_object_or_type_alignment (exp);\n \top0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address_addr_space (address_mode, op0, as);\n \tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n@@ -9345,7 +9366,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tif (TREE_THIS_VOLATILE (exp))\n \t  MEM_VOLATILE_P (temp) = 1;\n \tif (mode != BLKmode\n-\t    && (unsigned) align < GET_MODE_ALIGNMENT (mode)\n+\t    && align < GET_MODE_ALIGNMENT (mode)\n \t    /* If the target does not have special handling for unaligned\n \t       loads of mode then it can use regular moves for them.  */\n \t    && ((icode = optab_handler (movmisalign_optab, mode))"}]}