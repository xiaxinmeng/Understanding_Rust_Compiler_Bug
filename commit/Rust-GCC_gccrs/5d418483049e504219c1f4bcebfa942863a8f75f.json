{"sha": "5d418483049e504219c1f4bcebfa942863a8f75f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ0MTg0ODMwNDllNTA0MjE5YzFmNGJjZWJmYTk0Mjg2M2E4Zjc1Zg==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2013-06-13T08:21:01Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2013-06-13T08:21:01Z"}, "message": "tree-ssa-forwprop.c (simplify_bitwise_binary, [...]): Generalize to complex and vector.\n\n2013-06-13  Marc Glisse  <marc.glisse@inria.fr>\n\ngcc/\n\t* tree-ssa-forwprop.c (simplify_bitwise_binary, associate_plusminus):\n\tGeneralize to complex and vector.\n\t* tree.c (build_all_ones_cst): New function.\n\t* tree.h (build_all_ones_cst): Declare it.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/forwprop-27.c: New testcase.\n\nFrom-SVN: r200059", "tree": {"sha": "8f1f22ea52826b0983e2fe29263ca85cfbb146ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f1f22ea52826b0983e2fe29263ca85cfbb146ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d418483049e504219c1f4bcebfa942863a8f75f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d418483049e504219c1f4bcebfa942863a8f75f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d418483049e504219c1f4bcebfa942863a8f75f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d418483049e504219c1f4bcebfa942863a8f75f/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "491f54a74b896005f70bdba66df495d91822b325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/491f54a74b896005f70bdba66df495d91822b325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/491f54a74b896005f70bdba66df495d91822b325"}], "stats": {"total": 127, "additions": 97, "deletions": 30}, "files": [{"sha": "19e1b4cd8cb574ed3de70b00b20fea8d243b995e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d418483049e504219c1f4bcebfa942863a8f75f", "patch": "@@ -1,3 +1,10 @@\n+2013-06-13  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* tree-ssa-forwprop.c (simplify_bitwise_binary, associate_plusminus):\n+\tGeneralize to complex and vector.\n+\t* tree.c (build_all_ones_cst): New function.\n+\t* tree.h (build_all_ones_cst): Declare it.\n+\n 2013-06-13  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.h (LONG_DOUBLE_LARGE_FIRST): Define."}, {"sha": "e3dd654decaed7435b7432a035fc106c3a7a8e16", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d418483049e504219c1f4bcebfa942863a8f75f", "patch": "@@ -1,3 +1,7 @@\n+2013-06-13  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* gcc.dg/tree-ssa/forwprop-27.c: New testcase.\n+\n 2013-06-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \t    Pat Haugen <pthaugen@us.ibm.com>\n \t    Peter Bergner <bergner@vnet.ibm.com>"}, {"sha": "9e1b0763b44ad5044c3a3125cc87372e7e2742c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-27.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-27.c?ref=5d418483049e504219c1f4bcebfa942863a8f75f", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-forwprop1\" } */\n+\n+typedef int V __attribute__((vector_size(2*sizeof(int))));\n+typedef __complex__ int C;\n+\n+void f (V *v1, V *v2){\n+  V w1 = *v1;\n+  V x1 = ~w1;\n+  *v1 = x1 + 1;\n+  V w2 = *v2;\n+  V x2 = ~w2;\n+  *v2 = x2 + w2;\n+}\n+\n+void g (V *v1, V *v2){\n+  V c1 = { 5, -10 };\n+  V c2 = { 32, 13 };\n+  *v1 = (*v1|c1)&c2;\n+  *v2 = (*v2^c1)^c2;\n+}\n+\n+void h (C *v1, C *v2){\n+  C w = *v2;\n+  C x = *v1 - w;\n+  *v1 = x + w;\n+}\n+\n+void i (V *v1, V *v2){\n+  V c1 = { 5, -10 };\n+  V c2 = { 32, 13 };\n+  *v1 = (*v1-c1)+c2;\n+  *v2 = (c1-*v2)+c2;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"\\\\\\+\" \"forwprop1\"} } */\n+/* { dg-final { scan-tree-dump \"{ 0, 4 }\" \"forwprop1\"} } */\n+/* { dg-final { scan-tree-dump \"{ 37, -5 }\" \"forwprop1\"} } */\n+/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */\n+"}, {"sha": "c6a7eafbad51bcd65f39856e66d4e1a6a14c7de5", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=5d418483049e504219c1f4bcebfa942863a8f75f", "patch": "@@ -1978,8 +1978,8 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n   /* (a | CST1) & CST2  ->  (a & CST2) | (CST1 & CST2).  */\n   if (code == BIT_AND_EXPR\n       && def1_code == BIT_IOR_EXPR\n-      && TREE_CODE (arg2) == INTEGER_CST\n-      && TREE_CODE (def1_arg2) == INTEGER_CST)\n+      && CONSTANT_CLASS_P (arg2)\n+      && CONSTANT_CLASS_P (def1_arg2))\n     {\n       tree cst = fold_build2 (BIT_AND_EXPR, TREE_TYPE (arg2),\n \t\t\t      arg2, def1_arg2);\n@@ -2009,8 +2009,8 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n        || code == BIT_IOR_EXPR\n        || code == BIT_XOR_EXPR)\n       && def1_code == code \n-      && TREE_CODE (arg2) == INTEGER_CST\n-      && TREE_CODE (def1_arg2) == INTEGER_CST)\n+      && CONSTANT_CLASS_P (arg2)\n+      && CONSTANT_CLASS_P (def1_arg2))\n     {\n       tree cst = fold_build2 (code, TREE_TYPE (arg2),\n \t\t\t      arg2, def1_arg2);\n@@ -2022,7 +2022,6 @@ simplify_bitwise_binary (gimple_stmt_iterator *gsi)\n \n   /* Canonicalize X ^ ~0 to ~X.  */\n   if (code == BIT_XOR_EXPR\n-      && TREE_CODE (arg2) == INTEGER_CST\n       && integer_all_onesp (arg2))\n     {\n       gimple_assign_set_rhs_with_ops (gsi, BIT_NOT_EXPR, arg1, NULL_TREE);\n@@ -2433,7 +2432,7 @@ associate_plusminus (gimple_stmt_iterator *gsi)\n \t(A +- B) - A       ->  +- B\n \t(A +- B) -+ B      ->  A\n \t(CST +- A) +- CST  ->  CST +- A\n-\t(A + CST) +- CST   ->  A + CST\n+\t(A +- CST) +- CST  ->  A +- CST\n \t~A + A             ->  -1\n \t~A + 1             ->  -A \n \tA - (A +- B)       ->  -+ B\n@@ -2479,8 +2478,8 @@ associate_plusminus (gimple_stmt_iterator *gsi)\n \t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n \t\t  gimple_set_modified (stmt, true);\n \t\t}\n-\t      else if (TREE_CODE (rhs2) == INTEGER_CST\n-\t\t       && TREE_CODE (def_rhs1) == INTEGER_CST)\n+\t      else if (CONSTANT_CLASS_P (rhs2)\n+\t\t       && CONSTANT_CLASS_P (def_rhs1))\n \t\t{\n \t\t  /* (CST +- A) +- CST -> CST +- A.  */\n \t\t  tree cst = fold_binary (code, TREE_TYPE (rhs1),\n@@ -2496,16 +2495,17 @@ associate_plusminus (gimple_stmt_iterator *gsi)\n \t\t      gimple_set_modified (stmt, true);\n \t\t    }\n \t\t}\n-\t      else if (TREE_CODE (rhs2) == INTEGER_CST\n-\t\t       && TREE_CODE (def_rhs2) == INTEGER_CST\n-\t\t       && def_code == PLUS_EXPR)\n+\t      else if (CONSTANT_CLASS_P (rhs2)\n+\t\t       && CONSTANT_CLASS_P (def_rhs2))\n \t\t{\n-\t\t  /* (A + CST) +- CST -> A + CST.  */\n-\t\t  tree cst = fold_binary (code, TREE_TYPE (rhs1),\n+\t\t  /* (A +- CST) +- CST -> A +- CST.  */\n+\t\t  enum tree_code mix = (code == def_code)\n+\t\t\t\t       ? PLUS_EXPR : MINUS_EXPR;\n+\t\t  tree cst = fold_binary (mix, TREE_TYPE (rhs1),\n \t\t\t\t\t  def_rhs2, rhs2);\n \t\t  if (cst && !TREE_OVERFLOW (cst))\n \t\t    {\n-\t\t      code = PLUS_EXPR;\n+\t\t      code = def_code;\n \t\t      gimple_assign_set_rhs_code (stmt, code);\n \t\t      rhs1 = def_rhs1;\n \t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n@@ -2515,23 +2515,24 @@ associate_plusminus (gimple_stmt_iterator *gsi)\n \t\t    }\n \t\t}\n \t    }\n-\t  else if (def_code == BIT_NOT_EXPR\n-\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (rhs1)))\n+\t  else if (def_code == BIT_NOT_EXPR && code == PLUS_EXPR)\n \t    {\n \t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n-\t      if (code == PLUS_EXPR\n-\t\t  && operand_equal_p (def_rhs1, rhs2, 0))\n+\t      if (operand_equal_p (def_rhs1, rhs2, 0))\n \t\t{\n \t\t  /* ~A + A -> -1.  */\n-\t\t  code = INTEGER_CST;\n-\t\t  rhs1 = build_int_cst_type (TREE_TYPE (rhs2), -1);\n+\t\t  rhs1 = build_all_ones_cst (TREE_TYPE (rhs2));\n \t\t  rhs2 = NULL_TREE;\n+\t\t  code = TREE_CODE (rhs1);\n \t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n \t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n \t\t  gimple_set_modified (stmt, true);\n \t\t}\n-\t      else if (code == PLUS_EXPR\n-\t\t       && integer_onep (rhs1))\n+\t      else if ((TREE_CODE (TREE_TYPE (rhs2)) != COMPLEX_TYPE\n+\t\t\t&& integer_onep (rhs2))\n+\t\t       || (TREE_CODE (rhs2) == COMPLEX_CST\n+\t\t\t   && integer_onep (TREE_REALPART (rhs2))\n+\t\t\t   && integer_onep (TREE_IMAGPART (rhs2))))\n \t\t{\n \t\t  /* ~A + 1 -> -A.  */\n \t\t  code = NEGATE_EXPR;\n@@ -2580,8 +2581,8 @@ associate_plusminus (gimple_stmt_iterator *gsi)\n \t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n \t\t  gimple_set_modified (stmt, true);\n \t\t}\n-\t      else if (TREE_CODE (rhs1) == INTEGER_CST\n-\t\t       && TREE_CODE (def_rhs1) == INTEGER_CST)\n+\t      else if (CONSTANT_CLASS_P (rhs1)\n+\t\t       && CONSTANT_CLASS_P (def_rhs1))\n \t\t{\n \t\t  /* CST +- (CST +- A) -> CST +- A.  */\n \t\t  tree cst = fold_binary (code, TREE_TYPE (rhs2),\n@@ -2597,8 +2598,8 @@ associate_plusminus (gimple_stmt_iterator *gsi)\n \t\t      gimple_set_modified (stmt, true);\n \t\t    }\n \t\t}\n-\t      else if (TREE_CODE (rhs1) == INTEGER_CST\n-\t\t       && TREE_CODE (def_rhs2) == INTEGER_CST)\n+\t      else if (CONSTANT_CLASS_P (rhs1)\n+\t\t       && CONSTANT_CLASS_P (def_rhs2))\n \t\t{\n \t\t  /* CST +- (A +- CST) -> CST +- A.  */\n \t\t  tree cst = fold_binary (def_code == code\n@@ -2615,17 +2616,16 @@ associate_plusminus (gimple_stmt_iterator *gsi)\n \t\t    }\n \t\t}\n \t    }\n-\t  else if (def_code == BIT_NOT_EXPR\n-\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (rhs2)))\n+\t  else if (def_code == BIT_NOT_EXPR)\n \t    {\n \t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n \t      if (code == PLUS_EXPR\n \t\t  && operand_equal_p (def_rhs1, rhs1, 0))\n \t\t{\n \t\t  /* A + ~A -> -1.  */\n-\t\t  code = INTEGER_CST;\n-\t\t  rhs1 = build_int_cst_type (TREE_TYPE (rhs1), -1);\n+\t\t  rhs1 = build_all_ones_cst (TREE_TYPE (rhs1));\n \t\t  rhs2 = NULL_TREE;\n+\t\t  code = TREE_CODE (rhs1);\n \t\t  gimple_assign_set_rhs_with_ops (gsi, code, rhs1, NULL_TREE);\n \t\t  gcc_assert (gsi_stmt (*gsi) == stmt);\n \t\t  gimple_set_modified (stmt, true);"}, {"sha": "2c93c0e7c219651b5afec747d172cce492811a1f", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5d418483049e504219c1f4bcebfa942863a8f75f", "patch": "@@ -1643,6 +1643,21 @@ build_one_cst (tree type)\n     }\n }\n \n+/* Return an integer of type TYPE containing all 1's in as much precision as\n+   it contains, or a complex or vector whose subparts are such integers.  */\n+\n+tree\n+build_all_ones_cst (tree type)\n+{\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      tree scalar = build_all_ones_cst (TREE_TYPE (type));\n+      return build_complex (type, scalar, scalar);\n+    }\n+  else\n+    return build_minus_one_cst (type);\n+}\n+\n /* Return a constant of arithmetic type TYPE which is the\n    opposite of the multiplicative identity of the set TYPE.  */\n "}, {"sha": "860d002d3a5789174bb5713cd80dd3f041c01ae6", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d418483049e504219c1f4bcebfa942863a8f75f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5d418483049e504219c1f4bcebfa942863a8f75f", "patch": "@@ -4768,6 +4768,7 @@ extern tree build_real_from_int_cst (tree, const_tree);\n extern tree build_complex (tree, tree, tree);\n extern tree build_one_cst (tree);\n extern tree build_minus_one_cst (tree);\n+extern tree build_all_ones_cst (tree);\n extern tree build_zero_cst (tree);\n extern tree build_string (int, const char *);\n extern tree build_tree_list_stat (tree, tree MEM_STAT_DECL);"}]}