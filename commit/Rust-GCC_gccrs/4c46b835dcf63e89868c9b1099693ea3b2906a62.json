{"sha": "4c46b835dcf63e89868c9b1099693ea3b2906a62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM0NmI4MzVkY2Y2M2U4OTg2OGM5YjEwOTk2OTNlYTNiMjkwNmE2Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-08-16T09:00:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-08-16T09:00:19Z"}, "message": "[multiple changes]\n\n2004-08-16  Pascal Obry  <obry@gnat.com>\n\n\t* adaint.c (__gnat_prj_add_obj_files): Set to 0 only on Win32 for GCC\n\tbackend prior to GCC 3.4. With GCC 3.4 we are using the GCC's shared\n\toption and not mdll anymore. Update comment.\n\n2004-08-16  Pascal Obry  <obry@gnat.com>\n\n\t* bld.adb (Put_Include_Project): Properly handle directory separators\n\ton Windows.\n\n2004-08-16  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch4.adb (Try_Object_Operation): Restructure code. Optimize by\n\tdecreasing the number of allocated junk nodes while searching for the\n\tappropriate subprogram.\n\nFrom-SVN: r86049", "tree": {"sha": "168a8f766937c47892e57a5c6fb8b61b4f50921f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/168a8f766937c47892e57a5c6fb8b61b4f50921f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c46b835dcf63e89868c9b1099693ea3b2906a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c46b835dcf63e89868c9b1099693ea3b2906a62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c46b835dcf63e89868c9b1099693ea3b2906a62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c46b835dcf63e89868c9b1099693ea3b2906a62/comments", "author": null, "committer": null, "parents": [{"sha": "16e9be4c0903c1963fb91ed740185b22317473ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e9be4c0903c1963fb91ed740185b22317473ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e9be4c0903c1963fb91ed740185b22317473ac"}], "stats": {"total": 771, "additions": 428, "deletions": 343}, "files": [{"sha": "ef1854ce001c66c97730e6109a34296ebad08db8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4c46b835dcf63e89868c9b1099693ea3b2906a62", "patch": "@@ -1,3 +1,20 @@\n+2004-08-16  Pascal Obry  <obry@gnat.com>\n+\n+\t* adaint.c (__gnat_prj_add_obj_files): Set to 0 only on Win32 for GCC\n+\tbackend prior to GCC 3.4. With GCC 3.4 we are using the GCC's shared\n+\toption and not mdll anymore. Update comment.\n+\n+2004-08-16  Pascal Obry  <obry@gnat.com>\n+\n+\t* bld.adb (Put_Include_Project): Properly handle directory separators\n+\ton Windows.\n+\n+2004-08-16  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch4.adb (Try_Object_Operation): Restructure code. Optimize by\n+\tdecreasing the number of allocated junk nodes while searching for the\n+\tappropriate subprogram.\n+\n 2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cuintp.c (UI_To_gnu): Use build_int_cst.."}, {"sha": "a07f008c58abb86ed6f8ab7f3507c07357c5f997", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=4c46b835dcf63e89868c9b1099693ea3b2906a62", "patch": "@@ -2469,8 +2469,11 @@ int __gnat_argument_needs_quote = 0;\n \n /* This option is used to enable/disable object files handling from the\n    binder file by the GNAT Project module. For example, this is disabled on\n-   Windows as it is already done by the mdll module. */\n-#if defined (_WIN32)\n+   Windows (prior to GCC 3.4) as it is already done by the mdll module.\n+   Stating with GCC 3.4 the shared libraries are not based on mdll\n+   anymore as it uses the GCC's -shared option  */\n+#if defined (_WIN32) \\\n+    && ((__GNUC__ < 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ < 4)))\n int __gnat_prj_add_obj_files = 0;\n #else\n int __gnat_prj_add_obj_files = 1;"}, {"sha": "b6bf9b5ed630e488f2becd2c9ed0d2fd17132069", "filename": "gcc/ada/bld.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2Fbld.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2Fbld.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbld.adb?ref=4c46b835dcf63e89868c9b1099693ea3b2906a62", "patch": "@@ -2388,7 +2388,8 @@ package body Bld is\n             --  directory.\n \n             if Last >= Included_Directory_Path'First\n-              and then Included_Directory_Path (Last) = Directory_Separator\n+              and then (Included_Directory_Path (Last) = Directory_Separator\n+                          or else Included_Directory_Path (Last) = '/')\n             then\n                Last := Last - 1;\n             end if;"}, {"sha": "ba7e46aa67380126687d524fd254e15cdc750c67", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 404, "deletions": 340, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c46b835dcf63e89868c9b1099693ea3b2906a62/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=4c46b835dcf63e89868c9b1099693ea3b2906a62", "patch": "@@ -244,6 +244,10 @@ package body Sem_Ch4 is\n    procedure Ambiguous_Operands (N : Node_Id) is\n       procedure List_Operand_Interps (Opnd : Node_Id);\n \n+      --------------------------\n+      -- List_Operand_Interps --\n+      --------------------------\n+\n       procedure List_Operand_Interps (Opnd : Node_Id) is\n          Nam   : Node_Id;\n          Err   : Node_Id := N;\n@@ -252,10 +256,8 @@ package body Sem_Ch4 is\n          if Is_Overloaded (Opnd) then\n             if Nkind (Opnd) in N_Op then\n                Nam := Opnd;\n-\n             elsif Nkind (Opnd) = N_Function_Call then\n                Nam := Name (Opnd);\n-\n             else\n                return;\n             end if;\n@@ -276,6 +278,8 @@ package body Sem_Ch4 is\n          List_Interps (Nam, Err);\n       end List_Operand_Interps;\n \n+   --  Start of processing for Ambiguous_Operands\n+\n    begin\n       if Nkind (N) = N_In\n         or else Nkind (N) = N_Not_In\n@@ -373,6 +377,8 @@ package body Sem_Ch4 is\n \n          Set_Etype  (E, Type_Id);\n \n+      --  Case where no qualified expression is present\n+\n       else\n          declare\n             Def_Id : Entity_Id;\n@@ -586,12 +592,12 @@ package body Sem_Ch4 is\n    -- Analyze_Call --\n    ------------------\n \n-   --  Function, procedure, and entry calls are checked here. The Name\n-   --  in the call may be overloaded. The actuals have been analyzed\n-   --  and may themselves be overloaded. On exit from this procedure, the node\n-   --  N may have zero, one or more interpretations. In the first case an error\n-   --  message is produced. In the last case, the node is flagged as overloaded\n-   --  and the interpretations are collected in All_Interp.\n+   --  Function, procedure, and entry calls are checked here. The Name in\n+   --  the call may be overloaded. The actuals have been analyzed and may\n+   --  themselves be overloaded. On exit from this procedure, the node N\n+   --  may have zero, one or more interpretations. In the first case an\n+   --  error message is produced. In the last case, the node is flagged\n+   --  as overloaded and the interpretations are collected in All_Interp.\n \n    --  If the name is an Access_To_Subprogram, it cannot be overloaded, but\n    --  the type-checking is similar to that of other calls.\n@@ -675,12 +681,10 @@ package body Sem_Ch4 is\n \n             if Nkind (Prefix (Nam)) = N_Selected_Component then\n                Nam_Ent := Entity (Selector_Name (Prefix (Nam)));\n-\n             else\n                Error_Msg_N (\"name in call is not a callable entity\", Nam);\n                Set_Etype (N, Any_Type);\n                return;\n-\n             end if;\n \n          elsif not Is_Entity_Name (Nam) then\n@@ -887,7 +891,6 @@ package body Sem_Ch4 is\n       Analyze_Expression (R);\n \n       if Present (Op_Id) then\n-\n          if Ekind (Op_Id) = E_Operator then\n             Find_Comparison_Types (L, R, Op_Id, N);\n          else\n@@ -900,9 +903,7 @@ package body Sem_Ch4 is\n \n       else\n          Op_Id := Get_Name_Entity_Id (Chars (N));\n-\n          while Present (Op_Id) loop\n-\n             if Ekind (Op_Id) = E_Operator then\n                Find_Comparison_Types (L, R, Op_Id, N);\n             else\n@@ -982,11 +983,10 @@ package body Sem_Ch4 is\n                Add_One_Interp (N, Op_Id, Etype (Op_Id));\n \n             else\n-               --  Type and its operations must be visible.\n+               --  Type and its operations must be visible\n \n                Set_Entity (N, Empty);\n                Analyze_Concatenation (N);\n-\n             end if;\n \n          else\n@@ -995,7 +995,6 @@ package body Sem_Ch4 is\n \n       else\n          Op_Id  := Get_Name_Entity_Id (Name_Op_Concat);\n-\n          while Present (Op_Id) loop\n             if Ekind (Op_Id) = E_Operator then\n                Find_Concatenation_Types (L, R, Op_Id, N);\n@@ -1018,7 +1017,6 @@ package body Sem_Ch4 is\n       Condition : constant Node_Id := First (Expressions (N));\n       Then_Expr : constant Node_Id := Next (Condition);\n       Else_Expr : constant Node_Id := Next (Then_Expr);\n-\n    begin\n       Analyze_Expression (Condition);\n       Analyze_Expression (Then_Expr);\n@@ -1031,10 +1029,10 @@ package body Sem_Ch4 is\n    -------------------------\n \n    procedure Analyze_Equality_Op (N : Node_Id) is\n-      Loc    : constant Source_Ptr := Sloc (N);\n-      L      : constant Node_Id := Left_Opnd (N);\n-      R      : constant Node_Id := Right_Opnd (N);\n-      Op_Id  : Entity_Id;\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      L     : constant Node_Id := Left_Opnd (N);\n+      R     : constant Node_Id := Right_Opnd (N);\n+      Op_Id : Entity_Id;\n \n    begin\n       Set_Etype (N, Any_Type);\n@@ -1055,7 +1053,6 @@ package body Sem_Ch4 is\n       --  of the user-defined function.\n \n       if Present (Entity (N)) then\n-\n          Op_Id := Entity (N);\n \n          if Ekind (Op_Id) = E_Operator then\n@@ -1065,7 +1062,6 @@ package body Sem_Ch4 is\n          end if;\n \n          if Is_Overloaded (L) then\n-\n             if Ekind (Op_Id) = E_Operator then\n                Set_Etype (L, Intersect_Types (L, R));\n             else\n@@ -1075,9 +1071,7 @@ package body Sem_Ch4 is\n \n       else\n          Op_Id := Get_Name_Entity_Id (Chars (N));\n-\n          while Present (Op_Id) loop\n-\n             if Ekind (Op_Id) = E_Operator then\n                Find_Equality_Types (L, R, Op_Id, N);\n             else\n@@ -1141,11 +1135,15 @@ package body Sem_Ch4 is\n       New_N : Node_Id;\n \n       function Is_Function_Type return Boolean;\n-      --  Check whether node may be interpreted as an implicit function call.\n+      --  Check whether node may be interpreted as an implicit function call\n+\n+      ----------------------\n+      -- Is_Function_Type --\n+      ----------------------\n \n       function Is_Function_Type return Boolean is\n-         I     : Interp_Index;\n-         It    : Interp;\n+         I  : Interp_Index;\n+         It : Interp;\n \n       begin\n          if not Is_Overloaded (N) then\n@@ -1169,6 +1167,8 @@ package body Sem_Ch4 is\n          end if;\n       end Is_Function_Type;\n \n+   --  Start of processing for Analyze_Explicit_Deference\n+\n    begin\n       Analyze (P);\n       Set_Etype (N, Any_Type);\n@@ -1266,7 +1266,6 @@ package body Sem_Ch4 is\n \n          if Is_Overloaded (P) then\n             Get_First_Interp (P, I, It);\n-\n             while Present (It.Nam) loop\n                T := It.Typ;\n \n@@ -1288,7 +1287,6 @@ package body Sem_Ch4 is\n       --  (RM E.2.2(16)).\n \n       Validate_Remote_Access_To_Class_Wide_Type (N);\n-\n    end Analyze_Explicit_Dereference;\n \n    ------------------------\n@@ -1342,8 +1340,8 @@ package body Sem_Ch4 is\n          Change_Node (N, N_Function_Call);\n          Set_Name (N, P);\n          Set_Parameter_Associations (N, Exprs);\n-         Actual := First (Parameter_Associations (N));\n \n+         Actual := First (Parameter_Associations (N));\n          while Present (Actual) loop\n             Analyze (Actual);\n             Check_Parameterless_Call (Actual);\n@@ -1476,7 +1474,6 @@ package body Sem_Ch4 is\n                Error_Msg_N (\"too many subscripts in array reference\", Exp);\n             end if;\n          end if;\n-\n       end Process_Indexed_Component;\n \n       ----------------------------------------\n@@ -1486,7 +1483,6 @@ package body Sem_Ch4 is\n       procedure Process_Indexed_Component_Or_Slice is\n       begin\n          Exp := First (Exprs);\n-\n          while Present (Exp) loop\n             Analyze_Expression (Exp);\n             Next (Exp);\n@@ -1534,8 +1530,8 @@ package body Sem_Ch4 is\n \n       begin\n          Set_Etype (N, Any_Type);\n-         Get_First_Interp (P, I, It);\n \n+         Get_First_Interp (P, I, It);\n          while Present (It.Nam) loop\n             Typ := It.Typ;\n \n@@ -1550,9 +1546,7 @@ package body Sem_Ch4 is\n \n                Index := First_Index (Typ);\n                Found := True;\n-\n                Exp := First (Exprs);\n-\n                while Present (Index) and then Present (Exp) loop\n                   if Has_Compatible_Type (Exp, Etype (Index)) then\n                      null;\n@@ -1584,9 +1578,7 @@ package body Sem_Ch4 is\n          End_Interp_List;\n       end Process_Overloaded_Indexed_Component;\n \n-   ------------------------------------\n-   -- Analyze_Indexed_Component_Form --\n-   ------------------------------------\n+   --  Start of processing for Analyze_Indexed_Component_Form\n \n    begin\n       --  Get name of array, function or type\n@@ -1613,7 +1605,7 @@ package body Sem_Ch4 is\n \n          if Ekind (U_N) in  Type_Kind then\n \n-            --  Reformat node as a type conversion.\n+            --  Reformat node as a type conversion\n \n             E := Remove_Head (Exprs);\n \n@@ -1648,7 +1640,7 @@ package body Sem_Ch4 is\n \n          elsif Is_Generic_Subprogram (U_N) then\n \n-            --  A common beginner's (or C++ templates fan) error.\n+            --  A common beginner's (or C++ templates fan) error\n \n             Error_Msg_N (\"generic subprogram cannot be called\", N);\n             Set_Etype (N, Any_Type);\n@@ -1744,6 +1736,10 @@ package body Sem_Ch4 is\n       --  if there is more than one interpretation of the operands that is\n       --  compatible with a membership test, the operation is ambiguous.\n \n+      --------------------\n+      -- Try_One_Interp --\n+      --------------------\n+\n       procedure Try_One_Interp (T1 : Entity_Id) is\n       begin\n          if Has_Compatible_Type (R, T1) then\n@@ -1836,7 +1832,6 @@ package body Sem_Ch4 is\n \n       else\n          Op_Id := Get_Name_Entity_Id (Chars (N));\n-\n          while Present (Op_Id) loop\n             if Ekind (Op_Id) = E_Operator then\n                Find_Negation_Types (R, Op_Id, N);\n@@ -1970,7 +1965,7 @@ package body Sem_Ch4 is\n       then\n          return;\n \n-      --  Ditto for function calls in a procedure context.\n+      --  Ditto for function calls in a procedure context\n \n       elsif Nkind (N) = N_Procedure_Call_Statement\n          and then Is_Overloaded (Name (N))\n@@ -2010,9 +2005,7 @@ package body Sem_Ch4 is\n \n                begin\n                   Get_First_Interp (Name (N), I, It);\n-\n                   while Present (It.Nam) loop\n-\n                      if Ekind (It.Nam) /= E_Operator\n                         and then Hides_Op (It.Nam, Nam)\n                         and then\n@@ -2050,9 +2043,7 @@ package body Sem_Ch4 is\n \n          Actual := First_Actual (N);\n          Formal := First_Formal (Nam);\n-\n          while Present (Actual) and then Present (Formal) loop\n-\n             if Nkind (Parent (Actual)) /= N_Parameter_Association\n               or else Chars (Selector_Name (Parent (Actual))) = Chars (Formal)\n             then\n@@ -2072,7 +2063,6 @@ package body Sem_Ch4 is\n                   end if;\n \n                   if Report and not Is_Indexed then\n-\n                      Wrong_Type (Actual, Etype (Formal));\n \n                      if Nkind (Actual) = N_Op_Eq\n@@ -2132,7 +2122,7 @@ package body Sem_Ch4 is\n             end if;\n          end loop;\n \n-         --  On exit, all actuals match.\n+         --  On exit, all actuals match\n \n          Indicate_Name_And_Type;\n       end if;\n@@ -2148,14 +2138,13 @@ package body Sem_Ch4 is\n       Act2    : constant Node_Id := Next_Actual (Act1);\n \n    begin\n+      --  Binary operator case\n+\n       if Present (Act2) then\n \n-         --  Maybe binary operators\n+         --  If more than two operands, then not binary operator after all\n \n          if Present (Next_Actual (Act2)) then\n-\n-            --  Too many actuals for an operator\n-\n             return;\n \n          elsif     Op_Name = Name_Op_Add\n@@ -2195,9 +2184,9 @@ package body Sem_Ch4 is\n             null;\n          end if;\n \n-      else\n-         --  Unary operators\n+      --  Unary operator case\n \n+      else\n          if Op_Name = Name_Op_Subtract or else\n             Op_Name = Name_Op_Add      or else\n             Op_Name = Name_Op_Abs\n@@ -2230,24 +2219,20 @@ package body Sem_Ch4 is\n       T     : Entity_Id;\n \n    begin\n-      Get_First_Interp (Nam, I, It);\n-\n-      Set_Etype (Sel,  Any_Type);\n+      Set_Etype (Sel, Any_Type);\n \n+      Get_First_Interp (Nam, I, It);\n       while Present (It.Typ) loop\n          if Is_Access_Type (It.Typ) then\n             T := Designated_Type (It.Typ);\n             Error_Msg_NW (Warn_On_Dereference, \"?implicit dereference\", N);\n-\n          else\n             T := It.Typ;\n          end if;\n \n          if Is_Record_Type (T) then\n             Comp := First_Entity (T);\n-\n             while Present (Comp) loop\n-\n                if Chars (Comp) = Chars (Sel)\n                  and then Is_Visible_Component (Comp)\n                then\n@@ -2268,7 +2253,6 @@ package body Sem_Ch4 is\n \n          elsif Is_Concurrent_Type (T) then\n             Comp := First_Entity (T);\n-\n             while Present (Comp)\n               and then Comp /= First_Private_Entity (T)\n             loop\n@@ -2308,7 +2292,6 @@ package body Sem_Ch4 is\n          Set_Entity (Sel, Any_Id);\n          Set_Etype  (Sel, Any_Type);\n       end if;\n-\n    end Analyze_Overloaded_Selected_Component;\n \n    ----------------------------------\n@@ -2327,8 +2310,8 @@ package body Sem_Ch4 is\n       if T = Any_Type then\n          return;\n       end if;\n-      Check_Fully_Declared (T, N);\n \n+      Check_Fully_Declared (T, N);\n       Analyze_Expression (Expression (N));\n       Set_Etype  (N, T);\n    end Analyze_Qualified_Expression;\n@@ -2387,7 +2370,6 @@ package body Sem_Ch4 is\n             Check_Common_Type (T, Etype (H));\n          else\n             Get_First_Interp (H, I2, It2);\n-\n             while Present (It2.Typ) loop\n                Check_Common_Type (T, It2.Typ);\n                Get_Next_Interp (I2, It2);\n@@ -2425,7 +2407,6 @@ package body Sem_Ch4 is\n             Check_High_Bound (Etype (L));\n          else\n             Get_First_Interp (L, I1, It1);\n-\n             while Present (It1.Typ) loop\n                Check_High_Bound (It1.Typ);\n                Get_Next_Interp (I1, It1);\n@@ -2442,7 +2423,7 @@ package body Sem_Ch4 is\n       if Ada_Version = Ada_83\n         and then\n           (Nkind (Parent (N)) = N_Loop_Parameter_Specification\n-            or else Nkind (Parent (N)) = N_Constrained_Array_Definition)\n+             or else Nkind (Parent (N)) = N_Constrained_Array_Definition)\n       then\n          Check_Universal_Expression (L);\n          Check_Universal_Expression (H);\n@@ -2456,7 +2437,6 @@ package body Sem_Ch4 is\n    procedure Analyze_Reference (N : Node_Id) is\n       P        : constant Node_Id := Prefix (N);\n       Acc_Type : Entity_Id;\n-\n    begin\n       Analyze (P);\n       Acc_Type := Create_Itype (E_Allocator_Type, N);\n@@ -2580,7 +2560,6 @@ package body Sem_Ch4 is\n          --  Find component with given name\n \n          while Present (Comp) loop\n-\n             if Chars (Comp) = Chars (Sel)\n               and then Is_Visible_Component (Comp)\n             then\n@@ -2688,6 +2667,11 @@ package body Sem_Ch4 is\n            and then Try_Object_Operation (N)\n          then\n             return;\n+\n+            --  If the transformation fails, it will be necessary\n+            --  to redo the analysis with all errors enabled, to indicate\n+            --  candidate interpretations and reasons for each failure ???\n+\n          end if;\n \n       elsif Is_Private_Type (Prefix_Type) then\n@@ -2702,7 +2686,6 @@ package body Sem_Ch4 is\n          end if;\n \n          while Present (Comp) loop\n-\n             if Chars (Comp) = Chars (Sel) then\n                if Ekind (Comp) = E_Discriminant then\n                   Set_Entity_With_Style_Check (Sel, Comp);\n@@ -2793,7 +2776,7 @@ package body Sem_Ch4 is\n          Error_Msg_NE (\"invalid prefix in selected component&\", N, Sel);\n       end if;\n \n-      --  If N still has no type, the component is not defined in the prefix.\n+      --  If N still has no type, the component is not defined in the prefix\n \n       if Etype (N) = Any_Type then\n \n@@ -2828,17 +2811,16 @@ package body Sem_Ch4 is\n            and then Is_Generic_Actual_Type (Prefix_Type)\n            and then Present (Full_View (Prefix_Type))\n          then\n-            --  Similarly, if this the actual for a formal derived type,\n-            --  the component inherited from the generic parent may not\n-            --  be visible in the actual, but the selected component is\n-            --  legal.\n+            --  Similarly, if this the actual for a formal derived type, the\n+            --  component inherited from the generic parent may not be visible\n+            --  in the actual, but the selected component is legal.\n \n             declare\n                Comp : Entity_Id;\n+\n             begin\n                Comp :=\n                  First_Component (Generic_Parent_Type (Parent (Prefix_Type)));\n-\n                while Present (Comp) loop\n                   if Chars (Comp) = Chars (Sel) then\n                      Set_Entity_With_Style_Check (Sel, Comp);\n@@ -2864,9 +2846,7 @@ package body Sem_Ch4 is\n                --  compilation error anyway.\n \n                Comp := First_Component (Base_Type (Prefix_Type));\n-\n                while Present (Comp) loop\n-\n                   if Chars (Comp) = Chars (Sel)\n                     and then Is_Visible_Component (Comp)\n                   then\n@@ -2968,15 +2948,19 @@ package body Sem_Ch4 is\n       --  If the prefix is overloaded, select those interpretations that\n       --  yield a one-dimensional array type.\n \n+      ------------------------------\n+      -- Analyze_Overloaded_Slice --\n+      ------------------------------\n+\n       procedure Analyze_Overloaded_Slice is\n          I   : Interp_Index;\n          It  : Interp;\n          Typ : Entity_Id;\n \n       begin\n          Set_Etype (N, Any_Type);\n-         Get_First_Interp (P, I, It);\n \n+         Get_First_Interp (P, I, It);\n          while Present (It.Nam) loop\n             Typ := It.Typ;\n \n@@ -3003,7 +2987,6 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Slice\n \n    begin\n-\n       Analyze (P);\n       Analyze (D);\n \n@@ -3108,7 +3091,6 @@ package body Sem_Ch4 is\n          Error_Msg_N (\"argument of conversion cannot be access\", N);\n          Error_Msg_N (\"\\use qualified expression instead\", N);\n       end if;\n-\n    end Analyze_Type_Conversion;\n \n    ----------------------\n@@ -3134,9 +3116,7 @@ package body Sem_Ch4 is\n \n       else\n          Op_Id := Get_Name_Entity_Id (Chars (N));\n-\n          while Present (Op_Id) loop\n-\n             if Ekind (Op_Id) = E_Operator then\n                if No (Next_Entity (First_Entity (Op_Id))) then\n                   Find_Unary_Types (R, Op_Id,  N);\n@@ -3267,6 +3247,10 @@ package body Sem_Ch4 is\n       function Specific_Type (T1, T2 : Entity_Id) return Entity_Id;\n       --  Get specific type (i.e. non-universal type if there is one)\n \n+      -------------------\n+      -- Specific_Type --\n+      -------------------\n+\n       function Specific_Type (T1, T2 : Entity_Id) return Entity_Id is\n       begin\n          if T1 = Universal_Integer or else T1 = Universal_Real then\n@@ -3367,7 +3351,6 @@ package body Sem_Ch4 is\n          end if;\n \n       elsif Op_Name = Name_Op_Expon then\n-\n          if Is_Numeric_Type (T1)\n            and then not Is_Fixed_Point_Type (T1)\n            and then (Base_Type (T2) = Base_Type (Standard_Integer)\n@@ -3414,24 +3397,23 @@ package body Sem_Ch4 is\n       --  possible misspellings, these misspellings will be suggested as\n       --  possible correction.\n \n-      if not (Is_Private_Type (Prefix) or Is_Record_Type (Prefix)) then\n+      if not (Is_Private_Type (Prefix) or else Is_Record_Type (Prefix)) then\n+\n          --  Concurrent types should be handled as well ???\n+\n          return;\n       end if;\n \n       Get_Name_String (Chars (Sel));\n \n       declare\n-         S  : constant String (1 .. Name_Len) :=\n-                Name_Buffer (1 .. Name_Len);\n+         S  : constant String (1 .. Name_Len) := Name_Buffer (1 .. Name_Len);\n \n       begin\n          Comp  := First_Entity (Prefix);\n-\n          while Nr_Of_Suggestions <= Max_Suggestions\n             and then Present (Comp)\n          loop\n-\n             if Is_Visible_Component (Comp) then\n                Get_Name_String (Chars (Comp));\n \n@@ -3469,7 +3451,6 @@ package body Sem_Ch4 is\n    function Defined_In_Scope (T : Entity_Id; S : Entity_Id) return Boolean\n    is\n       S1 : constant Entity_Id := Scope (Base_Type (T));\n-\n    begin\n       return S1 = S\n         or else (S1 = System_Aux_Id and then S = Scope (S1));\n@@ -3545,7 +3526,6 @@ package body Sem_Ch4 is\n \n       if Nkind (N) = N_Function_Call then\n          Get_First_Interp (Nam, X, It);\n-\n          while Present (It.Nam) loop\n             if Ekind (It.Nam) = E_Function\n               or else Ekind (It.Nam) = E_Operator\n@@ -3560,8 +3540,8 @@ package body Sem_Ch4 is\n          --  more precise message. Ditto if this appears as the prefix\n          --  of a selected component, which may be a lexical error.\n \n-         Error_Msg_N (\n-         \"\\context requires function call, found procedure name\", Nam);\n+         Error_Msg_N\n+           (\"\\context requires function call, found procedure name\", Nam);\n \n          if Nkind (Parent (N)) = N_Selected_Component\n            and then N = Prefix (Parent (N))\n@@ -3589,19 +3569,24 @@ package body Sem_Ch4 is\n       Op_Id : Entity_Id;\n       N     : Node_Id)\n    is\n-      Index1, Index2 : Interp_Index;\n-      It1, It2 : Interp;\n+      Index1 : Interp_Index;\n+      Index2 : Interp_Index;\n+      It1    : Interp;\n+      It2    : Interp;\n \n       procedure Check_Right_Argument (T : Entity_Id);\n       --  Check right operand of operator\n \n+      --------------------------\n+      -- Check_Right_Argument --\n+      --------------------------\n+\n       procedure Check_Right_Argument (T : Entity_Id) is\n       begin\n          if not Is_Overloaded (R) then\n             Check_Arithmetic_Pair (T, Etype (R), Op_Id,  N);\n          else\n             Get_First_Interp (R, Index2, It2);\n-\n             while Present (It2.Typ) loop\n                Check_Arithmetic_Pair (T, It2.Typ, Op_Id, N);\n                Get_Next_Interp (Index2, It2);\n@@ -3642,6 +3627,10 @@ package body Sem_Ch4 is\n       --  Special case for logical operations one of whose operands is an\n       --  integer literal. If both are literal the result is any modular type.\n \n+      ----------------------------\n+      -- Check_Numeric_Argument --\n+      ----------------------------\n+\n       procedure Check_Numeric_Argument (T : Entity_Id) is\n       begin\n          if T = Universal_Integer then\n@@ -3656,7 +3645,6 @@ package body Sem_Ch4 is\n \n    begin\n       if not Is_Overloaded (L) then\n-\n          if Etype (L) = Universal_Integer\n            or else Etype (L) = Any_Modular\n          then\n@@ -3665,10 +3653,8 @@ package body Sem_Ch4 is\n \n             else\n                Get_First_Interp (R, Index, It);\n-\n                while Present (It.Typ) loop\n                   Check_Numeric_Argument (It.Typ);\n-\n                   Get_Next_Interp (Index, It);\n                end loop;\n             end if;\n@@ -3681,7 +3667,6 @@ package body Sem_Ch4 is\n \n       else\n          Get_First_Interp (L, Index, It);\n-\n          while Present (It.Typ) loop\n             if Valid_Boolean_Arg (It.Typ)\n               and then Has_Compatible_Type (R, It.Typ)\n@@ -3716,6 +3701,10 @@ package body Sem_Ch4 is\n       --  if there is more than one interpretation of the operands that is\n       --  compatible with comparison, the operation is ambiguous.\n \n+      --------------------\n+      -- Try_One_Interp --\n+      --------------------\n+\n       procedure Try_One_Interp (T1 : Entity_Id) is\n       begin\n \n@@ -3796,7 +3785,6 @@ package body Sem_Ch4 is\n \n       else\n          Get_First_Interp (L, Index, It);\n-\n          while Present (It.Typ) loop\n             Try_One_Interp (It.Typ);\n             Get_Next_Interp (Index, It);\n@@ -3815,7 +3803,7 @@ package body Sem_Ch4 is\n       T1    : Entity_Id)\n    is\n       Index : Interp_Index;\n-      It   : Interp;\n+      It    : Interp;\n \n    begin\n       if T1 = Universal_Integer\n@@ -3826,7 +3814,6 @@ package body Sem_Ch4 is\n               (N, Op_Id, Standard_Boolean, Base_Type (Etype (R)));\n          else\n             Get_First_Interp (R, Index, It);\n-\n             while Present (It.Typ) loop\n                if Covers (It.Typ, T1) then\n                   Add_One_Interp\n@@ -3891,9 +3878,12 @@ package body Sem_Ch4 is\n       --  is ambiguous and an error can be emitted now, after trying to\n       --  disambiguate, i.e. applying preference rules.\n \n+      --------------------\n+      -- Try_One_Interp --\n+      --------------------\n+\n       procedure Try_One_Interp (T1 : Entity_Id) is\n       begin\n-\n          --  If the operator is an expanded name, then the type of the operand\n          --  must be defined in the corresponding scope. If the type is\n          --  universal, the context will impose the correct type. An anonymous\n@@ -3993,10 +3983,9 @@ package body Sem_Ch4 is\n \n       if not Is_Overloaded (L) then\n          Try_One_Interp (Etype (L));\n-      else\n \n+      else\n          Get_First_Interp (L, Index, It);\n-\n          while Present (It.Typ) loop\n             Try_One_Interp (It.Typ);\n             Get_Next_Interp (Index, It);\n@@ -4018,17 +4007,14 @@ package body Sem_Ch4 is\n \n    begin\n       if not Is_Overloaded (R) then\n-\n          if Etype (R) = Universal_Integer then\n             Add_One_Interp (N, Op_Id, Any_Modular);\n-\n          elsif Valid_Boolean_Arg (Etype (R)) then\n             Add_One_Interp (N, Op_Id, Etype (R));\n          end if;\n \n       else\n          Get_First_Interp (R, Index, It);\n-\n          while Present (It.Typ) loop\n             if Valid_Boolean_Arg (It.Typ) then\n                Add_One_Interp (N, Op_Id, It.Typ);\n@@ -4059,7 +4045,6 @@ package body Sem_Ch4 is\n \n       else\n          Get_First_Interp (R, Index, It);\n-\n          while Present (It.Typ) loop\n             if Is_Numeric_Type (It.Typ) then\n                Add_One_Interp (N, Op_Id, Base_Type (It.Typ));\n@@ -4184,14 +4169,13 @@ package body Sem_Ch4 is\n             then\n                return;\n \n-            --  We explicitly check for the case of concatenation of\n-            --  component with component to avoid reporting spurious\n-            --  matching array types that might happen to be lurking\n-            --  in distant packages (such as run-time packages). This\n-            --  also prevents inconsistencies in the messages for certain\n-            --  ACVC B tests, which can vary depending on types declared\n-            --  in run-time interfaces. A further improvement, when\n-            --  aggregates are present, is to look for a well-typed operand.\n+            --  We explicitly check for the case of concatenation of component\n+            --  with component to avoid reporting spurious matching array types\n+            --  that might happen to be lurking in distant packages (such as\n+            --  run-time packages). This also prevents inconsistencies in the\n+            --  messages for certain ACVC B tests, which can vary depending on\n+            --  types declared in run-time interfaces. Another improvement when\n+            --  aggregates are present is to look for a well-typed operand.\n \n             elsif Present (Candidate_Type)\n               and then (Nkind (N) /= N_Op_Concat\n@@ -4432,6 +4416,7 @@ package body Sem_Ch4 is\n             return;\n \n          elsif Nkind (N) in N_Op then\n+\n             --  Remove interpretations that treat literals as addresses.\n             --  This is never appropriate.\n \n@@ -4645,156 +4630,245 @@ package body Sem_Ch4 is\n       else\n          return False;\n       end if;\n-\n    end Try_Indexed_Call;\n \n    --------------------------\n    -- Try_Object_Operation --\n    --------------------------\n \n    function Try_Object_Operation (N : Node_Id) return Boolean is\n-      Obj       : constant Node_Id := Prefix (N);\n-      Obj_Type  : Entity_Id;\n-      Actual    : Node_Id;\n-\n-      Last_Node : Node_Id;\n-      --  Used to free all the nodes generated while trying the alternatives.\n-      --  To me removed later, too low level ???\n-\n-      use Atree_Private_Part;\n-\n-      function Try_Replacement\n-        (New_Prefix : Entity_Id;\n-         New_Subprg : Node_Id;\n-         New_Formal : Node_Id;\n-         Nam_Ent    : Entity_Id) return Boolean;\n-      --  Replace the node with the Object.Operation notation by the\n-      --  equivalent node with the Package.Operation (Object, ...) notation\n-      --\n-      --  Nam_Ent is the entity that provides the formals against which\n-      --  the actuals are checked. If the actuals are compatible with\n-      --  Ent_Nam, this function returns true.\n-      --  Document other parameters, also what is Ent_Nam???\n-\n-      function Try_Primitive_Operations\n-        (New_Prefix : Entity_Id;\n-         New_Subprg : Node_Id;\n-         Obj        : Node_Id;\n-         Obj_Type   : Entity_Id) return Boolean;\n-      --  Traverse list of primitive subprograms to look for the subprogram\n-      --  Parameters should be documented ???\n-      --  subprogram.\n+      Loc      : constant Source_Ptr := Sloc (N);\n+      Obj      : constant Node_Id := Prefix (N);\n+      Obj_Type : Entity_Id := Etype (Obj);\n+      Subprog  : constant Node_Id := Selector_Name (N);\n+\n+      Call_Node       : Node_Id;\n+      Call_Node_Case  : Node_Id := Empty;\n+      First_Actual    : Node_Id;\n+      Node_To_Replace : Node_Id;\n+\n+      procedure Analyze_Actuals;\n+      --  If the parent of N is a subprogram call, then analyze the actual\n+      --  parameters of the parent of N.\n+\n+      procedure Complete_Object_Operation\n+        (Call_Node       : Node_Id;\n+         Node_To_Replace : Node_Id;\n+         Subprog         : Node_Id);\n+      --  Set Subprog as the name of Call_Node, replace Node_To_Replace with\n+      --  Call_Node and reanalyze Node_To_Replace.\n+\n+      procedure Transform_Object_Operation\n+        (Call_Node       : out Node_Id;\n+         First_Actual    : Node_Id;\n+         Node_To_Replace : out Node_Id;\n+         Subprog         : Node_Id);\n+      --  Transform Object.Operation (...) to Operation (Object, ...)\n+      --  Call_Node is the resulting subprogram call node, First_Actual is\n+      --  either the object Obj or an explicit dereference of Obj in certain\n+      --  cases, Node_To_Replace is either N or the parent of N, and Subprog\n+      --  is the subprogram we are trying to match.\n \n       function Try_Class_Wide_Operation\n-        (New_Subprg : Node_Id;\n-         Obj        : Node_Id;\n-         Obj_Type   : Entity_Id) return Boolean;\n-      --  Traverse all the ancestor types to look for a class-wide subprogram\n-      --  Parameters should be documented ???\n+        (Call_Node       : Node_Id;\n+         Node_To_Replace : Node_Id) return Boolean;\n+      --  Traverse all the ancestor types looking for a class-wide subprogram\n+      --  that matches Subprog.\n \n-      ------------------------------\n-      -- Try_Primitive_Operations --\n-      ------------------------------\n+      function Try_Primitive_Operation\n+        (Call_Node       : Node_Id;\n+         Node_To_Replace : Node_Id) return Boolean;\n+      --  Traverse the list of primitive subprograms looking for a subprogram\n+      --  than matches Subprog.\n+\n+      ---------------------\n+      -- Analyze_Actuals --\n+      ---------------------\n+\n+      procedure Analyze_Actuals is\n+         Actual : Node_Id;\n+\n+      begin\n+         if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n+               or else\n+             Nkind (Parent (N)) = N_Function_Call)\n+\n+            --  Avoid recursive calls\n \n-      function Try_Primitive_Operations\n-        (New_Prefix : Entity_Id;\n-         New_Subprg : Node_Id;\n-         Obj        : Node_Id;\n-         Obj_Type   : Entity_Id) return Boolean\n+           and then N /= First (Parameter_Associations (Parent (N)))\n+         then\n+            Actual := First (Parameter_Associations (Parent (N)));\n+            while Present (Actual) loop\n+               Analyze (Actual);\n+               Check_Parameterless_Call (Actual);\n+               Next (Actual);\n+\n+            end loop;\n+         end if;\n+      end Analyze_Actuals;\n+\n+      -------------------------------\n+      -- Complete_Object_Operation --\n+      -------------------------------\n+\n+      procedure Complete_Object_Operation\n+        (Call_Node       : Node_Id;\n+         Node_To_Replace : Node_Id;\n+         Subprog         : Node_Id)\n+      is\n+      begin\n+         Set_Name (Call_Node, New_Copy_Tree (Subprog));\n+         Set_Analyzed (Call_Node, False);\n+         Replace (Node_To_Replace, Call_Node);\n+         Analyze (Node_To_Replace);\n+\n+      end Complete_Object_Operation;\n+\n+      --------------------------------\n+      -- Transform_Object_Operation --\n+      --------------------------------\n+\n+      procedure Transform_Object_Operation\n+        (Call_Node       : out Node_Id;\n+         First_Actual    : Node_Id;\n+         Node_To_Replace : out Node_Id;\n+         Subprog         : Node_Id)\n       is\n-         Deref   : Node_Id;\n-         Elmt    : Elmt_Id;\n-         Prim_Op : Entity_Id;\n+         Actuals     : List_Id;\n+         Parent_Node : constant Node_Id := Parent (N);\n \n       begin\n-         --  Look for the subprogram in the list of primitive operations.\n-         --  This case is simple because all the primitive operations are\n-         --  implicitly inherited and thus we have a candidate as soon as\n-         --  we find a primitive subprogram with the same name. The latter\n-         --  analysis after the node replacement will resolve it.\n+         Actuals := New_List (New_Copy_Tree (First_Actual));\n \n-         Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n-         while Present (Elmt) loop\n-            Prim_Op := Node (Elmt);\n+         if (Nkind (Parent_Node) = N_Function_Call\n+               or else\n+             Nkind (Parent_Node) = N_Procedure_Call_Statement)\n \n-            if Chars (Prim_Op) = Chars (New_Subprg) then\n-               if Try_Replacement (New_Prefix => New_Prefix,\n-                                   New_Subprg => New_Subprg,\n-                                   New_Formal => Obj,\n-                                   Nam_Ent    => Prim_Op)\n-               then\n-                  return True;\n+            --  Avoid recursive calls\n \n-               --  Try the implicit dereference in case of access type\n+           and then N /= First (Parameter_Associations (Parent_Node))\n+         then\n+            Node_To_Replace := Parent_Node;\n \n-               elsif Is_Access_Type (Etype (Obj)) then\n-                  Deref := Make_Explicit_Dereference (Sloc (Obj), Obj);\n-                  Set_Etype (Deref, Obj_Type);\n+            Append_List_To (Actuals,\n+              New_Copy_List (Parameter_Associations (Parent_Node)));\n+\n+            if Nkind (Parent_Node) = N_Procedure_Call_Statement then\n+               Call_Node :=\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Copy_Tree (Subprog),\n+                   Parameter_Associations => Actuals);\n+\n+            else\n+               pragma Assert (Nkind (Parent_Node) = N_Function_Call);\n+\n+               Call_Node :=\n+                 Make_Function_Call (Loc,\n+                   Name => New_Copy_Tree (Subprog),\n+                   Parameter_Associations => Actuals);\n \n-                  if Try_Replacement (New_Prefix => New_Prefix,\n-                                      New_Subprg => New_Subprg,\n-                                      New_Formal => Deref,\n-                                      Nam_Ent    => Prim_Op)\n-                  then\n-                     return True;\n-                  end if;\n-               end if;\n             end if;\n \n-            Next_Elmt (Elmt);\n-         end loop;\n+         --  Parameterless call\n \n-         return False;\n-      end Try_Primitive_Operations;\n+         else\n+            Node_To_Replace := N;\n+\n+            Call_Node :=\n+               Make_Function_Call (Loc,\n+                 Name => New_Copy_Tree (Subprog),\n+                 Parameter_Associations => Actuals);\n+\n+         end if;\n+      end Transform_Object_Operation;\n \n       ------------------------------\n       -- Try_Class_Wide_Operation --\n       ------------------------------\n \n       function Try_Class_Wide_Operation\n-        (New_Subprg : Node_Id;\n-         Obj        : Node_Id;\n-         Obj_Type   : Entity_Id) return Boolean\n+        (Call_Node       : Node_Id;\n+         Node_To_Replace : Node_Id) return Boolean\n       is\n-         Deref : Node_Id;\n-         Hom   : Entity_Id;\n-         Typ   : Entity_Id;\n+         Anc_Type : Entity_Id;\n+         Dummy    : Node_Id;\n+         Hom      : Entity_Id;\n+         Hom_Ref  : Node_Id;\n+         Success  : Boolean;\n \n       begin\n-         --  Loop through ancestor types\n+         --  Loop through ancestor types, traverse their homonym chains and\n+         --  gather all interpretations of the subprogram.\n \n-         Typ := Obj_Type;\n+         Anc_Type := Obj_Type;\n          loop\n-            --  For each parent subtype we traverse all the homonym chain\n-            --  looking for a candidate class-wide subprogram\n-\n-            Hom := Current_Entity (New_Subprg);\n+            Hom := Current_Entity (Subprog);\n             while Present (Hom) loop\n                if (Ekind (Hom) = E_Procedure\n-                     or else Ekind (Hom) = E_Function)\n-                   and then Present (First_Entity (Hom))\n-                   and then Etype (First_Entity (Hom)) = Class_Wide_Type (Typ)\n+                     or else\n+                   Ekind (Hom) = E_Function)\n+                 and then Present (First_Formal (Hom))\n+                 and then Etype (First_Formal (Hom)) =\n+                            Class_Wide_Type (Anc_Type)\n                then\n-                  if Try_Replacement\n-                    (New_Prefix => Scope (Hom),\n-                     New_Subprg => Make_Identifier (Sloc (N), Chars (Hom)),\n-                     New_Formal => Obj,\n-                     Nam_Ent    => Hom)\n+                  Hom_Ref := New_Reference_To (Hom, Loc);\n+\n+                  --  When both the type of the object and the type of the\n+                  --  first formal of the primitive operation are tagged\n+                  --  access types, we use a node with the object as first\n+                  --  actual.\n+\n+                  if Is_Access_Type (Etype (Obj))\n+                    and then Ekind (Etype (First_Formal (Hom))) =\n+                               E_Anonymous_Access_Type\n                   then\n-                     return True;\n+                     --  Allocate the node only once\n \n-                  --  Try the implicit dereference in case of access type\n+                     if not Present (Call_Node_Case) then\n+                        Transform_Object_Operation (\n+                          Call_Node       => Call_Node_Case,\n+                          First_Actual    => Obj,\n+                          Node_To_Replace => Dummy,\n+                          Subprog         => Subprog);\n \n-                  elsif Is_Access_Type (Etype (Obj)) then\n-                     Deref := Make_Explicit_Dereference (Sloc (Obj), Obj);\n-                     Set_Etype (Deref, Obj_Type);\n+                        Set_Etype (Call_Node_Case, Any_Type);\n+                        Set_Parent (Call_Node_Case, Parent (Node_To_Replace));\n+                     end if;\n+\n+                     Set_Name (Call_Node_Case, Hom_Ref);\n+\n+                     Analyze_One_Call (\n+                       N       => Call_Node_Case,\n+                       Nam     => Hom,\n+                       Report  => False,\n+                       Success => Success);\n+\n+                     if Success then\n+                        Complete_Object_Operation (\n+                          Call_Node       => Call_Node_Case,\n+                          Node_To_Replace => Node_To_Replace,\n+                          Subprog         => Hom_Ref);\n+\n+                        return True;\n+                     end if;\n+\n+                  --  ??? comment required\n+\n+                  else\n+                     Set_Name (Call_Node, Hom_Ref);\n+\n+                     Analyze_One_Call (\n+                       N       => Call_Node,\n+                       Nam     => Hom,\n+                       Report  => False,\n+                       Success => Success);\n+\n+                     if Success then\n+                        Complete_Object_Operation (\n+                          Call_Node       => Call_Node,\n+                          Node_To_Replace => Node_To_Replace,\n+                          Subprog         => Hom_Ref);\n \n-                     if Try_Replacement\n-                       (New_Prefix => Scope (Hom),\n-                        New_Subprg => Make_Identifier (Sloc (N), Chars (Hom)),\n-                        New_Formal => Deref,\n-                        Nam_Ent    => Hom)\n-                     then\n                         return True;\n                      end if;\n                   end if;\n@@ -4805,120 +4879,108 @@ package body Sem_Ch4 is\n \n             --  Climb to ancestor type if there is one\n \n-            exit when Etype (Typ) = Typ;\n-            Typ := Etype (Typ);\n+            exit when Etype (Anc_Type) = Anc_Type;\n+            Anc_Type := Etype (Anc_Type);\n          end loop;\n \n          return False;\n       end Try_Class_Wide_Operation;\n \n-      ---------------------\n-      -- Try_Replacement --\n-      ---------------------\n+      -----------------------------\n+      -- Try_Primitive_Operation --\n+      -----------------------------\n \n-      function Try_Replacement\n-        (New_Prefix : Entity_Id;\n-         New_Subprg : Node_Id;\n-         New_Formal : Node_Id;\n-         Nam_Ent    : Entity_Id) return Boolean\n+      function Try_Primitive_Operation\n+        (Call_Node       : Node_Id;\n+         Node_To_Replace : Node_Id) return Boolean\n       is\n-         Loc             : constant Source_Ptr := Sloc (N);\n-         Call_Node       : Node_Id;\n-         New_Name        : Node_Id;\n-         New_Actuals     : List_Id;\n-         Node_To_Replace : Node_Id;\n-         Success         : Boolean;\n+         Dummy          : Node_Id;\n+         Elmt           : Elmt_Id;\n+         Prim_Op        : Entity_Id;\n+         Prim_Op_Ref    : Node_Id;\n+         Success        : Boolean;\n \n       begin\n-         --  Step 1. Build the replacement node: a subprogram call node\n-         --  with the object as its first actual parameter\n+         --  Look for the subprogram in the list of primitive operations.\n \n-         New_Name := Make_Selected_Component (Loc,\n-                       Prefix        => New_Reference_To (New_Prefix, Loc),\n-                       Selector_Name => New_Copy_Tree (New_Subprg));\n+         Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n+         while Present (Elmt) loop\n+            Prim_Op := Node (Elmt);\n \n-         New_Actuals := New_List (New_Copy_Tree (New_Formal));\n+            if Chars (Prim_Op) = Chars (Subprog)\n+              and then Present (First_Formal (Prim_Op))\n+            then\n+               Prim_Op_Ref := New_Reference_To (Prim_Op, Loc);\n \n-         if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n-               or else Nkind (Parent (N)) = N_Function_Call)\n+               --  When both the type of the object and the type of the first\n+               --  formal of the primitive operation are tagged access types,\n+               --  we use a node with the object as first actual.\n \n-            --  Protect against recursive call; It occurs in \"..:= F (O.P)\"\n+               if Is_Access_Type (Etype (Obj))\n+                 and then Ekind (Etype (First_Formal (Prim_Op))) =\n+                            E_Anonymous_Access_Type\n+               then\n+                  --  Allocate the node only once\n \n-            and then N /= First (Parameter_Associations (Parent (N)))\n+                  if not Present (Call_Node_Case) then\n+                     Transform_Object_Operation (\n+                       Call_Node       => Call_Node_Case,\n+                       First_Actual    => Obj,\n+                       Node_To_Replace => Dummy,\n+                       Subprog         => Subprog);\n \n-         then\n-            Node_To_Replace := Parent (N);\n+                     Set_Etype (Call_Node_Case, Any_Type);\n+                     Set_Parent (Call_Node_Case, Parent (Node_To_Replace));\n+                  end if;\n \n-            Append_List_To\n-              (New_Actuals,\n-               New_Copy_List (Parameter_Associations (Node_To_Replace)));\n+                  Set_Name (Call_Node_Case, Prim_Op_Ref);\n \n-            if Nkind (Node_To_Replace) = N_Procedure_Call_Statement then\n-               Call_Node :=\n-                 Make_Procedure_Call_Statement (Loc, New_Name, New_Actuals);\n+                  Analyze_One_Call (\n+                    N       => Call_Node_Case,\n+                    Nam     => Prim_Op,\n+                    Report  => False,\n+                    Success => Success);\n \n-            else pragma Assert (Nkind (Node_To_Replace) = N_Function_Call);\n-               Call_Node :=\n-                 Make_Function_Call (Loc, New_Name, New_Actuals);\n-            end if;\n+                  if Success then\n+                     Complete_Object_Operation (\n+                       Call_Node       => Call_Node_Case,\n+                       Node_To_Replace => Node_To_Replace,\n+                       Subprog         => Prim_Op_Ref);\n \n-         --  Case of a function without parameters\n+                     return True;\n+                  end if;\n \n-         else\n-            Node_To_Replace := N;\n+               --  Comment required ???\n \n-            Call_Node :=\n-              Make_Function_Call (Loc, New_Name, New_Actuals);\n-         end if;\n+               else\n+                  Set_Name (Call_Node, Prim_Op_Ref);\n \n-         --  Step 2. Analyze the candidate replacement node. If it was\n-         --  successfully analyzed then replace the original node and\n-         --  carry out the full analysis to verify that there is no\n-         --  conflict with overloaded subprograms.\n-\n-         --  To properly analyze the candidate we must initialize the type\n-         --  of the result node of the call to the error type; it will be\n-         --  reset if the type is successfully resolved.\n-\n-         Set_Etype (Call_Node, Any_Type);\n-\n-         Analyze_One_Call\n-           (N       => Call_Node,\n-            Nam     => Nam_Ent,\n-            Report  => False,  -- do not post errors\n-            Success => Success);\n-\n-         if Success then\n-            --  Previous analysis transformed the node with the name\n-            --  and we have to reset it to properly re-analyze it.\n-\n-            New_Name :=\n-              Make_Selected_Component (Loc,\n-                Prefix        => New_Reference_To (New_Prefix, Loc),\n-                Selector_Name => New_Copy_Tree (New_Subprg));\n-            Set_Name (Call_Node, New_Name);\n-\n-            Set_Analyzed (Call_Node, False);\n-            Set_Parent (Call_Node, Parent (Node_To_Replace));\n-            Replace (Node_To_Replace, Call_Node);\n-            Analyze (Node_To_Replace);\n-            return True;\n+                  Analyze_One_Call (\n+                    N       => Call_Node,\n+                    Nam     => Prim_Op,\n+                    Report  => False,\n+                    Success => Success);\n \n-         --  Free all the nodes used for this test and return\n+                  if Success then\n+                     Complete_Object_Operation (\n+                       Call_Node       => Call_Node,\n+                       Node_To_Replace => Node_To_Replace,\n+                       Subprog         => Prim_Op_Ref);\n \n-         else\n-            Nodes.Set_Last (Last_Node);\n-            return False;\n-         end if;\n-      end Try_Replacement;\n+                     return True;\n+                  end if;\n+               end if;\n+            end if;\n \n-   --  Start of processing for Try_Object_Operation\n+            Next_Elmt (Elmt);\n+         end loop;\n \n-   begin\n-      --  Find the type of the object\n+         return False;\n+      end Try_Primitive_Operation;\n \n-      Obj_Type := Etype (Obj);\n+   --  Start of processing for Try_Object_Operation\n \n+   begin\n       if Is_Access_Type (Obj_Type) then\n          Obj_Type := Designated_Type (Obj_Type);\n       end if;\n@@ -4931,36 +4993,38 @@ package body Sem_Ch4 is\n          Obj_Type := Etype (Class_Wide_Type (Obj_Type));\n       end if;\n \n-      --  Analyze the actuals\n-\n-      if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n-            or else Nkind (Parent (N)) = N_Function_Call)\n-\n-         --  Protects against recursive call in case of \"..:= F (O.Proc)\"\n+      Analyze_Actuals;\n \n-         and then N /= First (Parameter_Associations (Parent (N)))\n-      then\n-         Actual := First (Parameter_Associations (Parent (N)));\n+      --  If the object is of an Access type, explicit dereference is\n+      --  required.\n \n-         while Present (Actual) loop\n-            Analyze (Actual);\n-            Check_Parameterless_Call (Actual);\n-            Next_Actual (Actual);\n-         end loop;\n+      if Is_Access_Type (Etype (Obj)) then\n+         First_Actual :=\n+           Make_Explicit_Dereference (Sloc (Obj), Obj);\n+         Set_Etype (First_Actual, Obj_Type);\n+      else\n+         First_Actual := Obj;\n       end if;\n \n-      Last_Node := Last_Node_Id;\n-\n-      return Try_Primitive_Operations\n-               (New_Prefix => Scope (Obj_Type),\n-                New_Subprg => Selector_Name (N),\n-                Obj        => Obj,\n-                Obj_Type   => Obj_Type)\n-           or else\n-             Try_Class_Wide_Operation\n-               (New_Subprg => Selector_Name (N),\n-                Obj        => Obj,\n-                Obj_Type   => Obj_Type);\n+      --  Build a subprogram call node\n+\n+      Transform_Object_Operation (\n+        Call_Node       => Call_Node,\n+        First_Actual    => First_Actual,\n+        Node_To_Replace => Node_To_Replace,\n+        Subprog         => Subprog);\n+\n+      Set_Etype (Call_Node, Any_Type);\n+      Set_Parent (Call_Node, Parent (Node_To_Replace));\n+\n+      return\n+         Try_Primitive_Operation\n+           (Call_Node       => Call_Node,\n+            Node_To_Replace => Node_To_Replace)\n+        or else\n+         Try_Class_Wide_Operation\n+           (Call_Node       => Call_Node,\n+            Node_To_Replace => Node_To_Replace);\n    end Try_Object_Operation;\n \n end Sem_Ch4;"}]}