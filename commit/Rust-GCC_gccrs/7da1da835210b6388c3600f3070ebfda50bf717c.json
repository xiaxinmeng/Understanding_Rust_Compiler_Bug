{"sha": "7da1da835210b6388c3600f3070ebfda50bf717c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RhMWRhODM1MjEwYjYzODhjMzYwMGYzMDcwZWJmZGE1MGJmNzE3Yw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-09-29T11:24:28Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-29T11:24:28Z"}, "message": "InetAddress.java, URL.java: Reformated.\n\n2003-09-29  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/InetAddress.java,\n\tjava/net/URL.java: Reformated.\n\nFrom-SVN: r71897", "tree": {"sha": "c2172fe5bb8cac7ef7950fa8ced22afc54adac3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2172fe5bb8cac7ef7950fa8ced22afc54adac3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7da1da835210b6388c3600f3070ebfda50bf717c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da1da835210b6388c3600f3070ebfda50bf717c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da1da835210b6388c3600f3070ebfda50bf717c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da1da835210b6388c3600f3070ebfda50bf717c/comments", "author": null, "committer": null, "parents": [{"sha": "6cd6aed7900dd521cb45a208a4ca48bacedf23e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd6aed7900dd521cb45a208a4ca48bacedf23e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cd6aed7900dd521cb45a208a4ca48bacedf23e4"}], "stats": {"total": 115, "additions": 64, "deletions": 51}, "files": [{"sha": "15268d28a005532dc0285bdb83f3194bad03803f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da1da835210b6388c3600f3070ebfda50bf717c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da1da835210b6388c3600f3070ebfda50bf717c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7da1da835210b6388c3600f3070ebfda50bf717c", "patch": "@@ -1,3 +1,8 @@\n+2003-09-29  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/InetAddress.java,\n+\tjava/net/URL.java: Reformated.\n+\n 2003-09-29  Bryce McKinlay  <bryce@mckinlay.net.nz>\n \n \t* boehm.cc (_Jv_BuildGCDescr): Put first word of object in most "}, {"sha": "253e837836b7feddbb8e428fecd6d637dcaae4b2", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da1da835210b6388c3600f3070ebfda50bf717c/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da1da835210b6388c3600f3070ebfda50bf717c/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=7da1da835210b6388c3600f3070ebfda50bf717c", "patch": "@@ -138,7 +138,7 @@ public class InetAddress implements Serializable\n    *\n    * @since 1.1\n    */\n-  public boolean isMulticastAddress ()\n+  public boolean isMulticastAddress()\n   {\n     int len = addr.length;\n     \n@@ -156,7 +156,7 @@ public boolean isMulticastAddress ()\n    * \n    * @since 1.4\n    */\n-  public boolean isAnyLocalAddress ()\n+  public boolean isAnyLocalAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -168,7 +168,7 @@ public boolean isAnyLocalAddress ()\n    * \n    * @since 1.4\n    */\n-  public boolean isLoopbackAddress ()\n+  public boolean isLoopbackAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -181,7 +181,7 @@ public boolean isLoopbackAddress ()\n    * \n    * @since 1.4\n    */\n-  public boolean isLinkLocalAddress ()\n+  public boolean isLinkLocalAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -195,7 +195,7 @@ public boolean isLinkLocalAddress ()\n    * \n    * @since 1.4\n    */\n-  public boolean isSiteLocalAddress ()\n+  public boolean isSiteLocalAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -226,7 +226,7 @@ public boolean isSiteLocalAddress ()\n    * \n    * @since 1.4\n    */\n-  public boolean isMCGlobal ()\n+  public boolean isMCGlobal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -240,7 +240,7 @@ public boolean isMCGlobal ()\n    * \n    * @since 1.4\n    */\n-  public boolean isMCNodeLocal ()\n+  public boolean isMCNodeLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -254,12 +254,12 @@ public boolean isMCNodeLocal ()\n    * \n    * @since 1.4\n    */\n-  public boolean isMCLinkLocal ()\n+  public boolean isMCLinkLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n     \n-    if (!isMulticastAddress ())\n+    if (!isMulticastAddress())\n       return false;\n \n     return (addr [0] == 0xE0\n@@ -272,7 +272,7 @@ public boolean isMCLinkLocal ()\n    *\n    * @since 1.4\n    */\n-  public boolean isMCSiteLocal ()\n+  public boolean isMCSiteLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -287,7 +287,7 @@ public boolean isMCSiteLocal ()\n    * \n    * @since 1.4\n    */\n-  public boolean isMCOrgLocal ()\n+  public boolean isMCOrgLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n@@ -299,7 +299,7 @@ public boolean isMCOrgLocal ()\n   /**\n    * Returns the hostname represented by this InetAddress\n    */\n-  public String getHostName ()\n+  public String getHostName()\n   {\n     if (hostName == null)\n       lookup (null, this, false);\n@@ -312,9 +312,9 @@ public String getHostName ()\n    * \n    * @since 1.4\n    */\n-  public String getCanonicalHostName ()\n+  public String getCanonicalHostName()\n   {\n-    SecurityManager sm = System.getSecurityManager ();\n+    SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       {\n         try\n@@ -323,23 +323,23 @@ public String getCanonicalHostName ()\n \t  }\n \tcatch (SecurityException e)\n \t  {\n-\t    return getHostAddress ();\n+\t    return getHostAddress();\n \t  }\n       }\n \n     // Try to find the FDQN now\n-    InetAddress address = new InetAddress (getAddress (), null);\n-    return address.getHostName ();\n+    InetAddress address = new InetAddress (getAddress(), null);\n+    return address.getHostName();\n   }\n \n   /**\n    * Returns the IP address of this InetAddress as array of bytes\n    */\n-  public byte[] getAddress ()\n+  public byte[] getAddress()\n   {\n     // An experiment shows that JDK1.2 returns a different byte array each\n     // time.  This makes sense, in terms of security.\n-    return (byte[]) addr.clone ();\n+    return (byte[]) addr.clone();\n   }\n \n   /* Helper function due to a CNI limitation.  */\n@@ -351,7 +351,7 @@ private static InetAddress[] allocArray (int count)\n   /* Helper function due to a CNI limitation.  */\n   private static SecurityException checkConnect (String hostname)\n   {\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     \n     if (s == null)\n       return null;\n@@ -372,56 +372,63 @@ private static SecurityException checkConnect (String hostname)\n    *\n    * @since 1.0.2\n    */\n-  public String getHostAddress ()\n+  public String getHostAddress()\n   {\n-    StringBuffer sbuf = new StringBuffer (40);\n+    StringBuffer sb = new StringBuffer (40);\n     int len = addr.length;\n     int i = 0;\n+    \n     if (len == 16)\n       { // An IPv6 address.\n-\tfor (;  ;  i += 2)\n+\tfor ( ; ; i += 2)\n \t  {\n \t    if (i >= 16)\n-\t      return sbuf.toString ();\n+\t      return sb.toString();\n+\t    \n \t    int x = ((addr [i] & 0xFF) << 8) | (addr [i + 1] & 0xFF);\n-\t    boolean empty = sbuf.length () == 0;\n+\t    boolean empty = sb.length() == 0;\n+\t    \n \t    if (empty)\n \t      {\n \t\tif (i == 10 && x == 0xFFFF)\n \t\t  { // IPv4-mapped IPv6 address.\n-\t\t    sbuf.append (\":FFFF:\");\n+\t\t    sb.append (\":FFFF:\");\n \t\t    break;  // Continue as IPv4 address;\n \t\t  }\n \t\telse if (i == 12)\n \t\t  { // IPv4-compatible IPv6 address.\n-\t\t    sbuf.append (':');\n+\t\t    sb.append (':');\n \t\t    break;  // Continue as IPv4 address.\n \t\t  }\n \t\telse if (i > 0)\n-\t\t  sbuf.append (\"::\");\n+\t\t  sb.append (\"::\");\n \t      }\n \t    else\n-\t      sbuf.append (':');\n+\t      sb.append (':');\n+\t    \n \t    if (x != 0 || i >= 14)\n-\t      sbuf.append (Integer.toHexString (x).toUpperCase ());\n+\t      sb.append (Integer.toHexString (x).toUpperCase());\n \t  }\n       }\n-    for ( ;  ; )\n+    \n+    for ( ; ; )\n       {\n-\tsbuf.append (addr[i] & 0xFF);\n+        sb.append (addr [i] & 0xff);\n \ti++;\n+\t\n \tif (i == len)\n \t  break;\n-\tsbuf.append ('.');\n+\t\n+\tsb.append ('.');\n       }\n     \n-    return sbuf.toString();\n+    return sb.toString();\n   }\n \n   /**\n    * Returns a hashcode of the InetAddress\n    */\n-  public int hashCode ()\n+  public int hashCode()\n   {\n     // There hashing algorithm is not specified, but a simple experiment\n     // shows that it is equal to the address, as a 32-bit big-endian integer.\n@@ -466,10 +473,10 @@ public boolean equals (Object obj)\n   /**\n    * Returns then <code>InetAddress</code> as string\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     String result;\n-    String address = getHostAddress ();\n+    String address = getHostAddress();\n     \n     if (hostName != null)\n       result = hostName + \"/\" + address;\n@@ -542,13 +549,13 @@ private static native InetAddress[] lookup (String hostname,\n   public static InetAddress getByName (String hostname)\n     throws UnknownHostException\n   {\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkConnect (hostname, -1);\n    \n     // Default to current host if necessary\n     if (hostname == null)\n-      return getLocalHost ();\n+      return getLocalHost();\n \n     // Assume that the host string is an IP address\n     byte[] address = aton (hostname);\n@@ -590,7 +597,7 @@ else if (address.length == 16)\n   public static InetAddress[] getAllByName (String hostname)\n     throws UnknownHostException\n   {\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkConnect (hostname, -1);\n \n@@ -607,17 +614,17 @@ public static InetAddress[] getAllByName (String hostname)\n     return lookup (hostname, null, true);\n   }\n \n-  private static native String getLocalHostname ();\n+  private static native String getLocalHostname();\n \n   /**\n-   * Returns the local host\n+   * Returns the local host address.\n    *\n    * @exception UnknownHostException If no IP address for the host could\n    * be found\n    */\n-  public static InetAddress getLocalHost () throws UnknownHostException\n+  public static InetAddress getLocalHost() throws UnknownHostException\n   {\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     \n     // Experimentation shows that JDK1.2 does cache the result.\n     // However, if there is a security manager, and the cached result\n@@ -636,7 +643,7 @@ private static synchronized void getLocalHost (SecurityManager s)\n     if (s == null && localhost != null)\n       return;\n     \n-    String hostname = getLocalHostname ();\n+    String hostname = getLocalHostname();\n     \n     if (s != null)\n       {\n@@ -677,15 +684,15 @@ private static synchronized void getLocalHost (SecurityManager s)\n   /**\n    * Needed for serialization\n    */\n-  private void readResolve () throws ObjectStreamException\n+  private void readResolve() throws ObjectStreamException\n   {\n     // FIXME: implement this\n   }\n \t  \n   private void readObject (ObjectInputStream ois)\n     throws IOException, ClassNotFoundException\n   {\n-    ois.defaultReadObject ();\n+    ois.defaultReadObject();\n     addr = new byte [4];\n     addr [3] = (byte) address;\n     \n@@ -710,6 +717,6 @@ private void writeObject (ObjectOutputStream oos) throws IOException\n     for (; i < len; i++)\n       address = address << 8 | (((int) addr [i]) & 0xFF);\n     \n-    oos.defaultWriteObject ();\n+    oos.defaultWriteObject();\n   }\n }"}, {"sha": "6585c52fbb04288c07f45801be7ed907a0b89da6", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da1da835210b6388c3600f3070ebfda50bf717c/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da1da835210b6388c3600f3070ebfda50bf717c/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=7da1da835210b6388c3600f3070ebfda50bf717c", "patch": "@@ -183,7 +183,8 @@ public final class URL implements Serializable\n \n   static\n     {\n-      String s = System.getProperty(\"gnu.java.net.nocache_protocol_handlers\");\n+      String s = System.getProperty (\"gnu.java.net.nocache_protocol_handlers\");\n+      \n       if (s == null)\n         cache_handlers = true;\n       else\n@@ -761,7 +762,7 @@ public String toString()\n     // First, see if a protocol handler is in our cache.\n     if (cache_handlers)\n       {\n-        if ((ph = (URLStreamHandler) ph_cache.get(protocol)) != null)\n+        if ((ph = (URLStreamHandler) ph_cache.get (protocol)) != null)\n           return ph;\n       }\n \n@@ -831,7 +832,7 @@ else if (protocol.equals (\"file\"))\n     if (ph != null\n         && cache_handlers)\n       if (ph instanceof URLStreamHandler)\n-\tph_cache.put(protocol, ph);\n+\tph_cache.put (protocol, ph);\n       else\n \tph = null;\n "}]}