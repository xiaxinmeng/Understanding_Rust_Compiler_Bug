{"sha": "52243905a209f98799e8b8e4416520d11c17a04a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIyNDM5MDVhMjA5Zjk4Nzk5ZThiOGU0NDE2NTIwZDExYzE3YTA0YQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-10-15T19:15:48Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-10-15T19:15:48Z"}, "message": "re PR c++/17805 (too liberal operator lookup)\n\n/cp\n2012-10-15  Alexandre Oliva  <aoliva@redhat.com>\n\t    Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/17805\n\t* call.c (build_new_op): Filter out operator functions that don't\n\tsatisfy enum-conversion match requirements.\n\n/testsuite\n2012-10-15  Alexandre Oliva  <aoliva@redhat.com>\n\t    Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/17805\n\t* g++.dg/overload/operator6.C: New.\n\nCo-Authored-By: Paolo Carlini <paolo.carlini@oracle.com>\n\nFrom-SVN: r192471", "tree": {"sha": "3cdd6d195d2a5d6ef57c4f63655d1981322d1c32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cdd6d195d2a5d6ef57c4f63655d1981322d1c32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52243905a209f98799e8b8e4416520d11c17a04a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52243905a209f98799e8b8e4416520d11c17a04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52243905a209f98799e8b8e4416520d11c17a04a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52243905a209f98799e8b8e4416520d11c17a04a/comments", "author": null, "committer": null, "parents": [{"sha": "c9e3b2097b6cd7bd26fad8d5cf3ddd7335776a84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e3b2097b6cd7bd26fad8d5cf3ddd7335776a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e3b2097b6cd7bd26fad8d5cf3ddd7335776a84"}], "stats": {"total": 90, "additions": 87, "deletions": 3}, "files": [{"sha": "67ceed97723e8f3741856e260f4a2ada6fd7f98f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=52243905a209f98799e8b8e4416520d11c17a04a", "patch": "@@ -1,3 +1,10 @@\n+2012-10-15  Alexandre Oliva  <aoliva@redhat.com>\n+\t    Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/17805\n+\t* call.c (build_new_op): Filter out operator functions that don't\n+\tsatisfy enum-conversion match requirements.\n+\n 2012-10-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50080 (again)"}, {"sha": "e21049b8e648a803d8421244835206a7d85eaf3e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=52243905a209f98799e8b8e4416520d11c17a04a", "patch": "@@ -5043,6 +5043,11 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t\t  NULL_TREE, arglist, NULL_TREE,\n \t\t  NULL_TREE, false, NULL_TREE, NULL_TREE,\n \t\t  flags, &candidates, complain);\n+\n+  args[0] = arg1;\n+  args[1] = arg2;\n+  args[2] = NULL_TREE;\n+\n   /* Add class-member operators to the candidate set.  */\n   if (CLASS_TYPE_P (TREE_TYPE (arg1)))\n     {\n@@ -5062,10 +5067,49 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t\t\tBASELINK_ACCESS_BINFO (fns),\n \t\t\tflags, &candidates, complain);\n     }\n+  /* Per 13.3.1.2/3, 2nd bullet, if no operand has a class type, then\n+     only non-member functions that have type T1 or reference to\n+     cv-qualified-opt T1 for the first argument, if the first argument\n+     has an enumeration type, or T2 or reference to cv-qualified-opt\n+     T2 for the second argument, if the the second argument has an\n+     enumeration type.  Filter out those that don't match.  */\n+  else if (! arg2 || ! CLASS_TYPE_P (TREE_TYPE (arg2)))\n+    {\n+      struct z_candidate **candp, **next;\n \n-  args[0] = arg1;\n-  args[1] = arg2;\n-  args[2] = NULL_TREE;\n+      for (candp = &candidates; *candp; candp = next)\n+\t{\n+\t  tree parmlist, parmtype;\n+\t  int i, nargs = (arg2 ? 2 : 1);\n+\n+\t  cand = *candp;\n+\t  next = &cand->next;\n+\n+\t  parmlist = TYPE_ARG_TYPES (TREE_TYPE (cand->fn));\n+\n+\t  for (i = 0; i < nargs; ++i)\n+\t    {\n+\t      parmtype = TREE_VALUE (parmlist);\n+\n+\t      if (TREE_CODE (parmtype) == REFERENCE_TYPE)\n+\t\tparmtype = TREE_TYPE (parmtype);\n+\t      if (TREE_CODE (TREE_TYPE (args[i])) == ENUMERAL_TYPE\n+\t\t  && (same_type_ignoring_top_level_qualifiers_p\n+\t\t      (TREE_TYPE (args[i]), parmtype)))\n+\t\tbreak;\n+\n+\t      parmlist = TREE_CHAIN (parmlist);\n+\t    }\n+\n+\t  /* No argument has an appropriate type, so remove this\n+\t     candidate function from the list.  */\n+\t  if (i == nargs)\n+\t    {\n+\t      *candp = cand->next;\n+\t      next = candp;\n+\t    }\n+\t}\n+    }\n \n   add_builtin_candidates (&candidates, code, code2, fnname, args,\n \t\t\t  flags, complain);"}, {"sha": "1b23a7b1dd33b834a4faec9b3e834213bf476e81", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52243905a209f98799e8b8e4416520d11c17a04a", "patch": "@@ -1,3 +1,9 @@\n+2012-10-15  Alexandre Oliva  <aoliva@redhat.com>\n+\t    Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/17805\n+\t* g++.dg/overload/operator6.C: New.\n+\n 2012-10-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50080 (again)"}, {"sha": "5002602b698bef340e1eb075fe0403373ea4b7b3", "filename": "gcc/testsuite/g++.dg/overload/operator6.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Foperator6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243905a209f98799e8b8e4416520d11c17a04a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Foperator6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Foperator6.C?ref=52243905a209f98799e8b8e4416520d11c17a04a", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/17805\n+\n+// Per 13.3.1.2/3 bullet 2, an operator function is not a candidate\n+// for overload resolution if neither argument is of class type and\n+// neither enumerator-typed argument gets an exact match, with or\n+// without reference binding, for the corresponding parameter.\n+\n+struct A\n+{\n+  A(int);\n+  A(const char*);\n+};\n+\n+bool operator==(const A&, const A&);\n+const A& operator*(const A&);\n+\n+enum E { e };\n+\n+bool b1 = (e == \"\");     // { dg-error \"no match\" }\n+\n+bool b2 = (A(1) == \"\");\n+\n+bool b3 = (e == A(1));\n+\n+const A& a1 = *e;        // { dg-error \"no match\" }\n+\n+const A& a2 = *A(1);"}]}