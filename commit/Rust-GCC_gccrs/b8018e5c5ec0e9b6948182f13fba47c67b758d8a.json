{"sha": "b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "node_id": "C_kwDOANBUbNoAKGI4MDE4ZTVjNWVjMGU5YjY5NDgxODJmMTNmYmE0N2M2N2I3NThkOGE", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-25T16:49:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-25T23:12:14Z"}, "message": "libstdc++: Make std::pointer_traits SFINAE-friendly [PR96416]\n\nThis implements the resolution I'm proposing for LWG 3545, to avoid hard\nerrors when using std::to_address for types that make pointer_traits\nill-formed.\n\nConsistent with std::iterator_traits, instantiating std::pointer_traits\nfor a non-pointer type will be well-formed, but give an empty type with\nno member types. This avoids the problematic cases for std::to_address.\nAdditionally, the pointer_to member is now only declared when the\nelement type is not cv void (and for C++20, when the function body would\nbe well-formed). The rebind member was already SFINAE-friendly in our\nimplementation.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/96416\n\t* include/bits/ptr_traits.h (pointer_traits): Reimplement to be\n\tSFINAE-friendly (LWG 3545).\n\t* testsuite/20_util/pointer_traits/lwg3545.cc: New test.\n\t* testsuite/20_util/to_address/1_neg.cc: Adjust dg-error line.\n\t* testsuite/20_util/to_address/lwg3545.cc: New test.", "tree": {"sha": "cd93663f7bd2a993e5a5a0feef2b6947e6e8e4a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd93663f7bd2a993e5a5a0feef2b6947e6e8e4a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b0acc4b800b589a39d637d7312da5cf969a5765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0acc4b800b589a39d637d7312da5cf969a5765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b0acc4b800b589a39d637d7312da5cf969a5765"}], "stats": {"total": 295, "additions": 248, "deletions": 47}, "files": [{"sha": "4987fa9942f2e849be41f816b3fd0d212cdcd59e", "filename": "libstdc++-v3/include/bits/ptr_traits.h", "status": "modified", "additions": 115, "deletions": 46, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h?ref=b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "patch": "@@ -35,6 +35,7 @@\n #include <bits/move.h>\n \n #if __cplusplus > 201703L\n+#include <concepts>\n #define __cpp_lib_constexpr_memory 201811L\n namespace __gnu_debug { struct _Safe_iterator_base; }\n #endif\n@@ -45,106 +46,174 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   class __undefined;\n \n-  // Given Template<T, ...> return T, otherwise invalid.\n+  // For a specialization `SomeTemplate<T, Types...>` the member `type` is T,\n+  // otherwise `type` is `__undefined`.\n   template<typename _Tp>\n     struct __get_first_arg\n     { using type = __undefined; };\n \n-  template<template<typename, typename...> class _Template, typename _Tp,\n+  template<template<typename, typename...> class _SomeTemplate, typename _Tp,\n            typename... _Types>\n-    struct __get_first_arg<_Template<_Tp, _Types...>>\n+    struct __get_first_arg<_SomeTemplate<_Tp, _Types...>>\n     { using type = _Tp; };\n \n-  template<typename _Tp>\n-    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;\n-\n-  // Given Template<T, ...> and U return Template<U, ...>, otherwise invalid.\n+  // For a specialization `SomeTemplate<T, Args...>` and a type `U` the member\n+  // `type` is `SomeTemplate<U, Args...>`, otherwise there is no member `type`.\n   template<typename _Tp, typename _Up>\n     struct __replace_first_arg\n     { };\n \n-  template<template<typename, typename...> class _Template, typename _Up,\n+  template<template<typename, typename...> class _SomeTemplate, typename _Up,\n            typename _Tp, typename... _Types>\n-    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>\n-    { using type = _Template<_Up, _Types...>; };\n+    struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>\n+    { using type = _SomeTemplate<_Up, _Types...>; };\n \n-  template<typename _Tp, typename _Up>\n-    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;\n+#if __cpp_concepts\n+  // When concepts are supported detection of _Ptr::element_type is done\n+  // by a requires-clause, so __ptr_traits_elem_t only needs to do this:\n+  template<typename _Ptr>\n+    using __ptr_traits_elem_t = typename __get_first_arg<_Ptr>::type;\n+#else\n+  // Detect the element type of a pointer-like type.\n+  template<typename _Ptr, typename = void>\n+    struct __ptr_traits_elem : __get_first_arg<_Ptr>\n+    { };\n \n-  template<typename _Tp>\n-    using __make_not_void\n-      = __conditional_t<is_void<_Tp>::value, __undefined, _Tp>;\n+  // Use _Ptr::element_type if is a valid type.\n+  template<typename _Ptr>\n+    struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>>\n+    { using type = typename _Ptr::element_type; };\n \n-  /**\n-   * @brief  Uniform interface to all pointer-like types\n-   * @ingroup pointer_abstractions\n-  */\n   template<typename _Ptr>\n-    struct pointer_traits\n+    using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;\n+#endif\n+\n+  // Define pointer_traits<P>::pointer_to.\n+  template<typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>\n+    struct __ptr_traits_ptr_to\n+    {\n+      using pointer = _Ptr;\n+      using element_type = _Elt;\n+\n+      /**\n+       *  @brief  Obtain a pointer to an object\n+       *  @param  __r  A reference to an object of type `element_type`\n+       *  @return `pointer::pointer_to(__e)`\n+       *  @pre `pointer::pointer_to(__e)` is a valid expression.\n+      */\n+      static pointer\n+      pointer_to(element_type& __e)\n+#if __cpp_lib_concepts\n+      requires requires {\n+\t{ pointer::pointer_to(__e) } -> convertible_to<pointer>;\n+      }\n+#endif\n+      { return pointer::pointer_to(__e); }\n+    };\n+\n+  // Do not define pointer_traits<P>::pointer_to if element type is void.\n+  template<typename _Ptr, typename _Elt>\n+    struct __ptr_traits_ptr_to<_Ptr, _Elt, true>\n+    { };\n+\n+  // Partial specialization defining pointer_traits<T*>::pointer_to(T&).\n+  template<typename _Tp>\n+    struct __ptr_traits_ptr_to<_Tp*, _Tp, false>\n+    {\n+      using pointer = _Tp*;\n+      using element_type = _Tp;\n+\n+      /**\n+       *  @brief  Obtain a pointer to an object\n+       *  @param  __r  A reference to an object of type `element_type`\n+       *  @return `addressof(__r)`\n+      */\n+      static _GLIBCXX20_CONSTEXPR pointer\n+      pointer_to(element_type& __r) noexcept\n+      { return std::addressof(__r); }\n+    };\n+\n+  template<typename _Ptr, typename _Elt>\n+    struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>\n     {\n     private:\n-      template<typename _Tp>\n-\tusing __element_type = typename _Tp::element_type;\n+      template<typename _Tp, typename = void>\n+\tstruct __difference { using type = ptrdiff_t; };\n \n       template<typename _Tp>\n-\tusing __difference_type = typename _Tp::difference_type;\n+#if __cpp_concepts\n+\trequires requires { typename _Tp::difference_type; }\n+\tstruct __difference<_Tp>\n+#else\n+\tstruct __difference<_Tp, __void_t<typename _Tp::difference_type>>\n+#endif\n+\t{ using type = typename _Tp::difference_type; };\n \n       template<typename _Tp, typename _Up, typename = void>\n \tstruct __rebind : __replace_first_arg<_Tp, _Up> { };\n \n       template<typename _Tp, typename _Up>\n+#if __cpp_concepts\n+\trequires requires { typename _Tp::template rebind<_Up>; }\n+\tstruct __rebind<_Tp, _Up>\n+#else\n \tstruct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>\n+#endif\n \t{ using type = typename _Tp::template rebind<_Up>; };\n \n     public:\n       /// The pointer type.\n       using pointer = _Ptr;\n \n       /// The type pointed to.\n-      using element_type\n-\t= __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;\n+      using element_type = _Elt;\n \n       /// The type used to represent the difference between two pointers.\n-      using difference_type\n-\t= __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;\n+      using difference_type = typename __difference<_Ptr>::type;\n \n       /// A pointer to a different type.\n       template<typename _Up>\n         using rebind = typename __rebind<_Ptr, _Up>::type;\n+    };\n \n-      static _Ptr\n-      pointer_to(__make_not_void<element_type>& __e)\n-      { return _Ptr::pointer_to(__e); }\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 3545. std::pointer_traits should be SFINAE-friendly\n+  template<typename _Ptr>\n+    struct __ptr_traits_impl<_Ptr, __undefined>\n+    { };\n \n-      static_assert(!is_same<element_type, __undefined>::value,\n-\t  \"pointer type defines element_type or is like SomePointer<T, Args>\");\n-    };\n+  /**\n+   * @brief  Uniform interface to all pointer-like types\n+   * @ingroup pointer_abstractions\n+   * @since C++11\n+  */\n+  template<typename _Ptr>\n+    struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>>\n+    { };\n+\n+#if __cpp_concepts\n+  template<typename _Ptr> requires requires { typename _Ptr::element_type; }\n+    struct pointer_traits<_Ptr>\n+    : __ptr_traits_impl<_Ptr, typename _Ptr::element_type>\n+    { };\n+#endif\n \n   /**\n    * @brief  Partial specialization for built-in pointers.\n    * @ingroup pointer_abstractions\n+   * @since C++11\n   */\n   template<typename _Tp>\n-    struct pointer_traits<_Tp*>\n+    struct pointer_traits<_Tp*> : __ptr_traits_ptr_to<_Tp*, _Tp>\n     {\n       /// The pointer type\n       typedef _Tp* pointer;\n       /// The type pointed to\n       typedef _Tp  element_type;\n       /// Type used to represent the difference between two pointers\n       typedef ptrdiff_t difference_type;\n-\n-      template<typename _Up>\n-        using rebind = _Up*;\n-\n-      /**\n-       *  @brief  Obtain a pointer to an object\n-       *  @param  __r  A reference to an object of type @c element_type\n-       *  @return @c addressof(__r)\n-      */\n-      static _GLIBCXX20_CONSTEXPR pointer\n-      pointer_to(__make_not_void<element_type>& __r) noexcept\n-      { return std::addressof(__r); }\n+      /// A pointer to a different type.\n+      template<typename _Up> using rebind = _Up*;\n     };\n \n   /// Convenience alias for rebinding pointers."}, {"sha": "8325cb66d08539aa41dfb6e154b232c7c455adec", "filename": "libstdc++-v3/testsuite/20_util/pointer_traits/lwg3545.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Flwg3545.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Flwg3545.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Flwg3545.cc?ref=b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "patch": "@@ -0,0 +1,120 @@\n+// { dg-do compile { target c++11 } }\n+\n+// LWG 3545. std::pointer_traits should be SFINAE-friendly\n+\n+#include <memory>\n+\n+using std::is_same;\n+\n+template<typename> using void_t = void;\n+\n+template<template<typename> class Probe, typename T, typename = void>\n+  struct has_member\n+  : std::false_type { };\n+\n+template<template<typename> class Probe, typename T>\n+  struct has_member<Probe, T, void_t<Probe<T>>>\n+  : std::true_type { };\n+\n+template<typename T>\n+  using element_type = typename T::element_type;\n+template<typename T>\n+  using pointer = typename T::pointer;\n+template<typename T>\n+  using difference_type = typename T::difference_type;\n+template<typename T>\n+  using rebind = typename T::template rebind<short>;\n+template<typename T>\n+  using pointer_to = decltype(T::pointer_to(std::declval<element_type<T>&>()));\n+\n+using invalid = std::pointer_traits<int>;\n+invalid i; // invalid instantiation is not ill-formed\n+\n+static_assert( !has_member<element_type, invalid>::value, \"\" );\n+static_assert( !has_member<pointer, invalid>::value, \"\" );\n+static_assert( !has_member<difference_type, invalid>::value, \"\" );\n+static_assert( !has_member<rebind, invalid>::value, \"\" );\n+static_assert( !has_member<pointer_to, invalid>::value, \"\" );\n+\n+struct I\n+{\n+  // These members should not be used by pointer_traits<P>::pointer.\n+  using pointer = int;\n+  using difference_type = int;\n+  template<typename> using rebind = int;\n+};\n+\n+using invalid2 = std::pointer_traits<I>;\n+\n+static_assert( !has_member<element_type, invalid2>::value, \"\" );\n+static_assert( !has_member<pointer, invalid2>::value, \"\" );\n+static_assert( !has_member<difference_type, invalid2>::value, \"\" );\n+static_assert( !has_member<rebind, invalid2>::value, \"\" );\n+static_assert( !has_member<pointer_to, invalid2>::value, \"\" );\n+\n+struct P\n+{\n+  using element_type = long;\n+  struct pointer { }; // should not be used by pointer_traits<P>::pointer\n+\n+  P pointer_to(long&) const; // not static, should not be used.\n+};\n+using Ptraits = std::pointer_traits<P>;\n+Ptraits p;\n+\n+static_assert( is_same<element_type<Ptraits>, long>::value, \"\" );\n+static_assert( is_same<pointer<Ptraits>, P>::value, \"\" );\n+static_assert( is_same<difference_type<Ptraits>, std::ptrdiff_t>::value, \"\" );\n+static_assert( !has_member<rebind, Ptraits>::value, \"\" );\n+#if __cplusplus >= 202002L\n+// pointer_traits<P>::pointer_to(long&) is constrained in C++20 and later.\n+static_assert( !has_member<pointer_to, Ptraits>::value, \"\" );\n+#else\n+static_assert( is_same<pointer_to<Ptraits>, P>::value, \"\" );\n+#endif\n+\n+struct V { using element_type = const void; };\n+using Vtraits = std::pointer_traits<V>;\n+Vtraits v;\n+\n+static_assert( is_same<element_type<Vtraits>, const void>::value, \"\" );\n+static_assert( is_same<pointer<Vtraits>, V>::value, \"\" );\n+static_assert( is_same<difference_type<Vtraits>, std::ptrdiff_t>::value, \"\" );\n+static_assert( !has_member<rebind, Vtraits>::value, \"\" );\n+static_assert( !has_member<pointer_to, Vtraits>::value, \"\" );\n+\n+template<typename T>\n+struct clever_ptr\n+{\n+  static T obj;\n+\n+  static clever_ptr pointer_to(T&) { return {}; }\n+  constexpr T* operator->() const { return &obj; }\n+};\n+\n+using Ctraits = std::pointer_traits<clever_ptr<char>>;\n+\n+static_assert( is_same<element_type<Ctraits>, char>::value, \"\" );\n+static_assert( is_same<pointer<Ctraits>, clever_ptr<char>>::value, \"\" );\n+static_assert( is_same<difference_type<Ctraits>, std::ptrdiff_t>::value, \"\" );\n+static_assert( is_same<rebind<Ctraits>, clever_ptr<short>>::value, \"\" );\n+static_assert( is_same<pointer_to<Ctraits>, clever_ptr<char>>::value, \"\" );\n+\n+#if __cplusplus >= 202002L\n+static_assert( std::to_address(clever_ptr<char>{}) == &clever_ptr<char>::obj, \"\" );\n+\n+int the_int;\n+\n+template<>\n+struct std::pointer_traits<clever_ptr<int>>\n+{\n+  using element_type = int;\n+  using difference_type = std::ptrdiff_t;\n+  using pointer = clever_ptr<int>;\n+\n+  static constexpr int* to_address(pointer p) { return &the_int; }\n+};\n+\n+// Should use pointer_traits<clever_ptr<int>>::to_address\n+static_assert( std::to_address(clever_ptr<int>{}) == &the_int, \"\" );\n+#endif"}, {"sha": "65aff7a8a5e229ae9f36aa4fddec3eb3f7764794", "filename": "libstdc++-v3/testsuite/20_util/to_address/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_address%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_address%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_address%2F1_neg.cc?ref=b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "patch": "@@ -17,7 +17,7 @@\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do compile { target c++2a } }\n-// { dg-error \"not a function pointer\" \"\" { target *-*-* } 158 }\n+// { dg-error \"not a function pointer\" \"\" { target *-*-* } 0 }\n \n #include <memory>\n "}, {"sha": "4dc5fdcdde0c43446d43461da0b25adc80daf51d", "filename": "libstdc++-v3/testsuite/20_util/to_address/lwg3545.cc", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_address%2Flwg3545.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8018e5c5ec0e9b6948182f13fba47c67b758d8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_address%2Flwg3545.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_address%2Flwg3545.cc?ref=b8018e5c5ec0e9b6948182f13fba47c67b758d8a", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"-std=gnu++20\" }\n+\n+#include <memory>\n+\n+template<typename T, bool> struct nttp_ptr\n+{\n+  T* operator->() const { return nullptr; }\n+};\n+\n+// This gives an error in C++20, which the LWG 3545 resolution should fix:\n+auto x = std::to_address( nttp_ptr<int, true>() );"}]}