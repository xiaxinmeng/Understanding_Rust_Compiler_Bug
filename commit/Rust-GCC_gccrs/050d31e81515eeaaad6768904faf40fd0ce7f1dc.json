{"sha": "050d31e81515eeaaad6768904faf40fd0ce7f1dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwZDMxZTgxNTE1ZWVhYWFkNjc2ODkwNGZhZjQwZmQwY2U3ZjFkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:36:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:36:06Z"}, "message": "eval_fat.adb: (Eps_Model,Eps_Denorm): Remove, no longer used.\n\n\t* eval_fat.adb: (Eps_Model,Eps_Denorm): Remove, no longer used.\n\t(Succ): Re-implement using Scaling, Exponent and Ceiling attributes.\n\t(Pred): Implement in terms of Succ.\n\n\t* trans.c (convert_with_check): Reimplement conversion of float to\n\tinteger.\n\nFrom-SVN: r92834", "tree": {"sha": "d2fe6394d342c3b74749dc0e0c67f5ebc45351d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2fe6394d342c3b74749dc0e0c67f5ebc45351d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/050d31e81515eeaaad6768904faf40fd0ce7f1dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050d31e81515eeaaad6768904faf40fd0ce7f1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/050d31e81515eeaaad6768904faf40fd0ce7f1dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050d31e81515eeaaad6768904faf40fd0ce7f1dc/comments", "author": null, "committer": null, "parents": [{"sha": "c5e12904bcca3866f419bb91365dbdfb052b8782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e12904bcca3866f419bb91365dbdfb052b8782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e12904bcca3866f419bb91365dbdfb052b8782"}], "stats": {"total": 194, "additions": 87, "deletions": 107}, "files": [{"sha": "9221e919cdcdb2dd7bee08a926e597ffb86021dc", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 33, "deletions": 90, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050d31e81515eeaaad6768904faf40fd0ce7f1dc/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050d31e81515eeaaad6768904faf40fd0ce7f1dc/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=050d31e81515eeaaad6768904faf40fd0ce7f1dc", "patch": "@@ -38,14 +38,14 @@ package body Eval_Fat is\n    --  case of anyone ever having to adjust this code for another value,\n    --  and for documentation purposes.\n \n+   --  Another assumption is that the range of the floating-point type\n+   --  is symmetric around zero.\n+\n    type Radix_Power_Table is array (Int range 1 .. 4) of Int;\n \n    Radix_Powers : constant Radix_Power_Table :=\n                     (Radix ** 1, Radix ** 2, Radix ** 3, Radix ** 4);\n \n-   function Float_Radix return T renames Ureal_2;\n-   --  Radix expressed in real form\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -74,12 +74,6 @@ package body Eval_Fat is\n    --  even, a floor operation or a ceiling operation depending on the setting\n    --  of Mode (see corresponding descriptions in Urealp).\n \n-   function Eps_Model (RT : R) return T;\n-   --  Return the smallest model number of R.\n-\n-   function Eps_Denorm (RT : R) return T;\n-   --  Return the smallest denormal of type R.\n-\n    function Machine_Emin (RT : R) return Int;\n    --  Return value of the Machine_Emin attribute\n \n@@ -91,10 +85,8 @@ package body Eval_Fat is\n    begin\n       if Towards = X then\n          return X;\n-\n       elsif Towards > X then\n          return Succ (RT, X);\n-\n       else\n          return Pred (RT, X);\n       end if;\n@@ -106,14 +98,11 @@ package body Eval_Fat is\n \n    function Ceiling (RT : R; X : T) return T is\n       XT : constant T := Truncation (RT, X);\n-\n    begin\n       if UR_Is_Negative (X) then\n          return XT;\n-\n       elsif X = XT then\n          return X;\n-\n       else\n          return XT + Ureal_1;\n       end if;\n@@ -382,10 +371,10 @@ package body Eval_Fat is\n       Calculate_Fraction_And_Exponent : begin\n          Uintp_Mark := Mark;\n \n-         --  Determine correct rounding based on the remainder\n-         --  which is in N and the divisor D. The rounding is\n-         --  performed on the absolute value of X, so Ceiling\n-         --  and Floor need to check for the sign of X explicitly.\n+         --  Determine correct rounding based on the remainder which is in\n+         --  N and the divisor D. The rounding is performed on the absolute\n+         --  value of X, so Ceiling and Floor need to check for the sign of\n+         --  X explicitly.\n \n          case Mode is\n             when Round_Even =>\n@@ -440,25 +429,6 @@ package body Eval_Fat is\n       end Calculate_Fraction_And_Exponent;\n    end Decompose_Int;\n \n-   ----------------\n-   -- Eps_Denorm --\n-   ----------------\n-\n-   function Eps_Denorm (RT : R) return T is\n-   begin\n-      return Float_Radix ** UI_From_Int\n-                                  (Machine_Emin (RT) - Machine_Mantissa (RT));\n-   end Eps_Denorm;\n-\n-   ---------------\n-   -- Eps_Model --\n-   ---------------\n-\n-   function Eps_Model (RT : R) return T is\n-   begin\n-      return Float_Radix ** UI_From_Int (Machine_Emin (RT));\n-   end Eps_Model;\n-\n    --------------\n    -- Exponent --\n    --------------\n@@ -735,37 +705,8 @@ package body Eval_Fat is\n    ----------\n \n    function Pred (RT : R; X : T) return T is\n-      Result_F : UI;\n-      Result_X : UI;\n-\n    begin\n-      if abs X < Eps_Model (RT) then\n-         if Denorm_On_Target then\n-            return X - Eps_Denorm (RT);\n-\n-         elsif X > Ureal_0 then\n-\n-            --  Target does not support denorms, so predecessor is 0.0\n-\n-            return Ureal_0;\n-\n-         else\n-            --  Target does not support denorms, and X is 0.0\n-            --  or at least bigger than -Eps_Model (RT)\n-\n-            return -Eps_Model (RT);\n-         end if;\n-\n-      else\n-         Decompose_Int (RT, X, Result_F,  Result_X, Ceiling);\n-         return UR_From_Components\n-           (Num      => Result_F - 1,\n-            Den      => Machine_Mantissa (RT) - Result_X,\n-            Rbase    => Radix,\n-            Negative => False);\n-         --  Result_F may be false, but this is OK as UR_From_Components\n-         --  handles that situation.\n-      end if;\n+      return -Succ (RT, -X);\n    end Pred;\n \n    ---------------\n@@ -892,35 +833,38 @@ package body Eval_Fat is\n    ----------\n \n    function Succ (RT : R; X : T) return T is\n-      Result_F : UI;\n-      Result_X : UI;\n+      Emin     : constant UI := UI_From_Int (Machine_Emin (RT));\n+      Mantissa : constant UI := UI_From_Int (Machine_Mantissa (RT));\n+      Exp      : UI := UI_Max (Emin, Exponent (RT, X));\n+      Frac     : T;\n+      New_Frac : T;\n \n    begin\n-      if abs X < Eps_Model (RT) then\n-         if Denorm_On_Target then\n-            return X + Eps_Denorm (RT);\n+      if UR_Is_Zero (X) then\n+         Exp := Emin;\n+      end if;\n \n-         elsif X < Ureal_0 then\n-            --  Target does not support denorms, so successor is 0.0\n-            return Ureal_0;\n+      --  Set exponent such that the radix point will be directly\n+      --  following the mantissa after scaling\n \n-         else\n-            --  Target does not support denorms, and X is 0.0\n-            --  or at least smaller than Eps_Model (RT)\n+      if Denorm_On_Target or Exp /= Emin then\n+         Exp := Exp - Mantissa;\n+      else\n+         Exp := Exp - 1;\n+      end if;\n \n-            return Eps_Model (RT);\n-         end if;\n+      Frac := Scaling (RT, X, -Exp);\n+      New_Frac := Ceiling (RT, Frac);\n \n-      else\n-         Decompose_Int (RT, X, Result_F, Result_X, Floor);\n-         return UR_From_Components\n-           (Num      => Result_F + 1,\n-            Den      => Machine_Mantissa (RT) - Result_X,\n-            Rbase    => Radix,\n-            Negative => False);\n-         --  Result_F may be false, but this is OK as UR_From_Components\n-         --  handles that situation.\n+      if New_Frac = Frac then\n+         if New_Frac = Scaling (RT, -Ureal_1, Mantissa - 1) then\n+            New_Frac := New_Frac + Scaling (RT, Ureal_1, Uint_Minus_1);\n+         else\n+            New_Frac := New_Frac + Ureal_1;\n+         end if;\n       end if;\n+\n+      return Scaling (RT, New_Frac, Exp);\n    end Succ;\n \n    ----------------\n@@ -929,7 +873,6 @@ package body Eval_Fat is\n \n    function Truncation (RT : R; X : T) return T is\n       pragma Warnings (Off, RT);\n-\n    begin\n       return UR_From_Uint (UR_Trunc (X));\n    end Truncation;"}, {"sha": "94aa9dc892656c2b68b8300d3ef3b879c709804a", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050d31e81515eeaaad6768904faf40fd0ce7f1dc/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050d31e81515eeaaad6768904faf40fd0ce7f1dc/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=050d31e81515eeaaad6768904faf40fd0ce7f1dc", "patch": "@@ -165,9 +165,6 @@ static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference_1 (tree, bool);\n static void annotate_with_node (tree, Node_Id);\n \n-/* Constants for +0.5 and -0.5 for float-to-integer rounding.  */\n-static REAL_VALUE_TYPE dconstp5;\n-static REAL_VALUE_TYPE dconstmp5;\n \f\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n@@ -288,9 +285,6 @@ gnat_init_stmt_group ()\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n \n   gcc_assert (Exception_Mechanism != Front_End_ZCX);\n-\n-  REAL_ARITHMETIC (dconstp5, RDIV_EXPR, dconst1, dconst2);\n-  REAL_ARITHMETIC (dconstmp5, RDIV_EXPR, dconstm1, dconst2);\n }\n \f\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Identifier,\n@@ -5195,17 +5189,60 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   if (INTEGRAL_TYPE_P (gnu_ada_base_type) && FLOAT_TYPE_P (gnu_in_basetype)\n       && !truncatep)\n     {\n-      tree gnu_point_5 = build_real (gnu_in_basetype, dconstp5);\n-      tree gnu_minus_point_5 = build_real (gnu_in_basetype, dconstmp5);\n-      tree gnu_zero = convert (gnu_in_basetype, integer_zero_node);\n-      tree gnu_saved_result = save_expr (gnu_result);\n-      tree gnu_comp = build2 (GE_EXPR, integer_type_node,\n-\t\t\t      gnu_saved_result, gnu_zero);\n-      tree gnu_adjust = build3 (COND_EXPR, gnu_in_basetype, gnu_comp,\n-\t\t\t\tgnu_point_5, gnu_minus_point_5);\n-\n-      gnu_result\n-\t= build2 (PLUS_EXPR, gnu_in_basetype, gnu_saved_result, gnu_adjust);\n+      REAL_VALUE_TYPE half_minus_pred_half, pred_half;\n+      tree gnu_conv, gnu_zero, gnu_comp, gnu_saved_result, calc_type;\n+      tree gnu_pred_half, gnu_add_pred_half, gnu_subtract_pred_half;\n+      const struct real_format *fmt;\n+\n+      /* The following calculations depend on proper rounding to even\n+         of each arithmetic operation. In order to prevent excess\n+         precision from spoiling this property, use the widest hardware\n+         floating-point type.\n+\n+         FIXME: For maximum efficiency, this should only be done for machines\n+         and types where intermediates may have extra precision.  */\n+\n+      calc_type = longest_float_type_node;\n+      /* FIXME: Should not have padding in the first place */\n+      if (TREE_CODE (calc_type) == RECORD_TYPE\n+              && TYPE_IS_PADDING_P (calc_type))\n+        calc_type = TREE_TYPE (TYPE_FIELDS (calc_type));\n+\n+      /* Compute the exact value calc_type'Pred (0.5) at compile time. */\n+      fmt = REAL_MODE_FORMAT (TYPE_MODE (calc_type));\n+      real_2expN (&half_minus_pred_half, -(fmt->p) - 1);\n+      REAL_ARITHMETIC (pred_half, MINUS_EXPR, dconsthalf,\n+                       half_minus_pred_half);\n+      gnu_pred_half = build_real (calc_type, pred_half);\n+\n+      /* If the input is strictly negative, subtract this value\n+         and otherwise add it from the input. For 0.5, the result\n+         is exactly between 1.0 and the machine number preceding 1.0\n+         (for calc_type). Since the last bit of 1.0 is even, this 0.5\n+         will round to 1.0, while all other number with an absolute\n+         value less than 0.5 round to 0.0. For larger numbers exactly\n+         halfway between integers, rounding will always be correct as\n+         the true mathematical result will be closer to the higher\n+         integer compared to the lower one. So, this constant works\n+         for all floating-point numbers.\n+\n+         The reason to use the same constant with subtract/add instead\n+         of a positive and negative constant is to allow the comparison\n+         to be scheduled in parallel with retrieval of the constant and\n+         conversion of the input to the calc_type (if necessary).\n+      */\n+\n+      gnu_zero = convert (gnu_in_basetype, integer_zero_node);\n+      gnu_saved_result = save_expr (gnu_result);\n+      gnu_conv = convert (calc_type, gnu_saved_result);\n+      gnu_comp = build2 (GE_EXPR, integer_type_node,\n+\t                gnu_saved_result, gnu_zero);\n+      gnu_add_pred_half\n+        = build2 (PLUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n+      gnu_subtract_pred_half\n+        = build2 (MINUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n+      gnu_result = build3 (COND_EXPR, calc_type, gnu_comp,\n+\t\t\t   gnu_add_pred_half, gnu_subtract_pred_half);\n     }\n \n   if (TREE_CODE (gnu_ada_base_type) == INTEGER_TYPE"}]}