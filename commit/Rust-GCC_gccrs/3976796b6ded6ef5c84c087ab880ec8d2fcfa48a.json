{"sha": "3976796b6ded6ef5c84c087ab880ec8d2fcfa48a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk3Njc5NmI2ZGVkNmVmNWM4NGMwODdhYjg4MGVjOGQyZmNmYTQ4YQ==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2014-07-10T22:26:50Z"}, "committer": {"name": "Edward Smith-Rowland", "email": "emsr@gcc.gnu.org", "date": "2014-07-10T22:26:50Z"}, "message": "re PR preprocessor/61389 (libcpp diagnostics shouldn't talk about ISO C99 for C++ input files)\n\n2014-07-10  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\t    Jonathan Wakely  <jwakely@redhat.com>\n\n\tPR CPP/61389\n\t* macro.c (_cpp_arguments_ok, parse_params, create_iso_definition):\n\tWarning messages mention C++11 in c++ mode and C99 in c mode.\n\t* lex.c (lex_identifier_intern, lex_identifier): Ditto\n\n\nCo-Authored-By: Jonathan Wakely <jwakely@redhat.com>\n\nFrom-SVN: r212441", "tree": {"sha": "85c3bdc9927029974392deb0bbf99aa974e8fcbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85c3bdc9927029974392deb0bbf99aa974e8fcbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a25b76d802c2df2b082b874f242d089d1a2bb42a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25b76d802c2df2b082b874f242d089d1a2bb42a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25b76d802c2df2b082b874f242d089d1a2bb42a"}], "stats": {"total": 111, "additions": 84, "deletions": 27}, "files": [{"sha": "c62478d6044fe08d6f0af9738e305c6e9eeb3347", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=3976796b6ded6ef5c84c087ab880ec8d2fcfa48a", "patch": "@@ -1,3 +1,11 @@\n+2014-07-10  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\t    Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR CPP/61389\n+\t* macro.c (_cpp_arguments_ok, parse_params, create_iso_definition):\n+\tWarning messages mention C++11 in c++ mode and C99 in c mode.\n+\t* lex.c (lex_identifier_intern, lex_identifier): Ditto\n+\n 2014-07-09  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tPR c++/58155 - -Wliteral-suffix warns about tokens which are skipped"}, {"sha": "7e2db64db09318190460bccf78a1e934c797cc18", "filename": "libcpp/lex.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=3976796b6ded6ef5c84c087ab880ec8d2fcfa48a", "patch": "@@ -1175,9 +1175,16 @@ lex_identifier_intern (cpp_reader *pfile, const uchar *base)\n \t replacement list of a variadic macro.  */\n       if (result == pfile->spec_nodes.n__VA_ARGS__\n \t  && !pfile->state.va_args_ok)\n-\tcpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t   \"__VA_ARGS__ can only appear in the expansion\"\n-\t\t   \" of a C99 variadic macro\");\n+\t{\n+\t  if (CPP_OPTION (pfile, cplusplus))\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"__VA_ARGS__ can only appear in the expansion\"\n+\t\t       \" of a C++11 variadic macro\");\n+\t  else\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"__VA_ARGS__ can only appear in the expansion\"\n+\t\t       \" of a C99 variadic macro\");\n+\t}\n \n       /* For -Wc++-compat, warn about use of C++ named operators.  */\n       if (result->flags & NODE_WARN_OPERATOR)\n@@ -1255,9 +1262,16 @@ lex_identifier (cpp_reader *pfile, const uchar *base, bool starts_ucn,\n \t replacement list of a variadic macro.  */\n       if (result == pfile->spec_nodes.n__VA_ARGS__\n \t  && !pfile->state.va_args_ok)\n-\tcpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t   \"__VA_ARGS__ can only appear in the expansion\"\n-\t\t   \" of a C99 variadic macro\");\n+\t{\n+\t  if (CPP_OPTION (pfile, cplusplus))\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"__VA_ARGS__ can only appear in the expansion\"\n+\t\t       \" of a C++11 variadic macro\");\n+\t  else\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"__VA_ARGS__ can only appear in the expansion\"\n+\t\t       \" of a C99 variadic macro\");\n+\t}\n \n       /* For -Wc++-compat, warn about use of C++ named operators.  */\n       if (result->flags & NODE_WARN_OPERATOR)"}, {"sha": "ab4817e8af60c599d1e5d64b056dcc15c7358f98", "filename": "libcpp/macro.c", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3976796b6ded6ef5c84c087ab880ec8d2fcfa48a/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=3976796b6ded6ef5c84c087ab880ec8d2fcfa48a", "patch": "@@ -713,19 +713,27 @@ _cpp_arguments_ok (cpp_reader *pfile, cpp_macro *macro, const cpp_hashnode *node\n \n   if (argc < macro->paramc)\n     {\n-      /* As an extension, a rest argument is allowed to not appear in\n+      /* As an extension, variadic arguments are allowed to not appear in\n \t the invocation at all.\n \t e.g. #define debug(format, args...) something\n \t debug(\"string\");\n \n-\t This is exactly the same as if there had been an empty rest\n-\t argument - debug(\"string\", ).  */\n+\t This is exactly the same as if an empty variadic list had been\n+\t supplied - debug(\"string\", ).  */\n \n       if (argc + 1 == macro->paramc && macro->variadic)\n \t{\n \t  if (CPP_PEDANTIC (pfile) && ! macro->syshdr)\n-\t    cpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t       \"ISO C99 requires rest arguments to be used\");\n+\t    {\n+\t      if (CPP_OPTION (pfile, cplusplus))\n+\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t\t   \"ISO C++11 requires at least one argument \"\n+\t\t\t   \"for the \\\"...\\\" in a variadic macro\");\n+\t      else\n+\t\tcpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t\t   \"ISO C99 requires at least one argument \"\n+\t\t\t   \"for the \\\"...\\\" in a variadic macro\");\n+\t    }\n \t  return true;\n \t}\n \n@@ -1748,12 +1756,20 @@ replace_args (cpp_reader *pfile, cpp_hashnode *node, cpp_macro *macro,\n \t       && ! CPP_OPTION (pfile, c99)\n \t       && ! cpp_in_system_header (pfile))\n \t{\n-\t  cpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t     \"invoking macro %s argument %d: \"\n-\t\t     \"empty macro arguments are undefined\"\n-\t\t     \" in ISO C90 and ISO C++98\",\n-\t\t     NODE_NAME (node),\n-\t\t     src->val.macro_arg.arg_no);\n+\t  if (CPP_OPTION (pfile, cplusplus))\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"invoking macro %s argument %d: \"\n+\t\t       \"empty macro arguments are undefined\"\n+\t\t       \" in ISO C++98\",\n+\t\t       NODE_NAME (node),\n+\t\t       src->val.macro_arg.arg_no);\n+\t  else\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"invoking macro %s argument %d: \"\n+\t\t       \"empty macro arguments are undefined\"\n+\t\t       \" in ISO C90\",\n+\t\t       NODE_NAME (node),\n+\t\t       src->val.macro_arg.arg_no);\n \t}\n \n       /* Avoid paste on RHS (even case count == 0).  */\n@@ -2798,14 +2814,27 @@ parse_params (cpp_reader *pfile, cpp_macro *macro)\n \t      if (! CPP_OPTION (pfile, c99)\n \t\t  && CPP_OPTION (pfile, cpp_pedantic)\n \t\t  && CPP_OPTION (pfile, warn_variadic_macros))\n-\t\tcpp_pedwarning\n-                  (pfile, CPP_W_VARIADIC_MACROS,\n-\t\t   \"anonymous variadic macros were introduced in C99\");\n+\t\t{\n+\t\t  if (CPP_OPTION (pfile, cplusplus))\n+\t\t    cpp_pedwarning\n+\t\t\t(pfile, CPP_W_VARIADIC_MACROS,\n+\t\t\t\"anonymous variadic macros were introduced in C++11\");\n+\t\t  else\n+\t\t    cpp_pedwarning\n+\t\t\t(pfile, CPP_W_VARIADIC_MACROS,\n+\t\t\t\"anonymous variadic macros were introduced in C99\");\n+\t\t}\n \t    }\n \t  else if (CPP_OPTION (pfile, cpp_pedantic)\n \t\t   && CPP_OPTION (pfile, warn_variadic_macros))\n-\t    cpp_pedwarning (pfile, CPP_W_VARIADIC_MACROS,\n+\t    {\n+\t      if (CPP_OPTION (pfile, cplusplus))\n+\t\tcpp_pedwarning (pfile, CPP_W_VARIADIC_MACROS,\n+\t\t            \"ISO C++ does not permit named variadic macros\");\n+\t      else\n+\t\tcpp_pedwarning (pfile, CPP_W_VARIADIC_MACROS,\n \t\t            \"ISO C does not permit named variadic macros\");\n+\t    }\n \n \t  /* We're at the end, and just expect a closing parenthesis.  */\n \t  token = _cpp_lex_token (pfile);\n@@ -2894,11 +2923,17 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n   else if (ctoken->type != CPP_EOF && !(ctoken->flags & PREV_WHITE))\n     {\n       /* While ISO C99 requires whitespace before replacement text\n-\t in a macro definition, ISO C90 with TC1 allows there characters\n-\t from the basic source character set.  */\n+\t in a macro definition, ISO C90 with TC1 allows characters\n+\t from the basic source character set there.  */\n       if (CPP_OPTION (pfile, c99))\n-\tcpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t   \"ISO C99 requires whitespace after the macro name\");\n+\t{\n+\t  if (CPP_OPTION (pfile, cplusplus))\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"ISO C++11 requires whitespace after the macro name\");\n+\t  else\n+\t    cpp_error (pfile, CPP_DL_PEDWARN,\n+\t\t       \"ISO C99 requires whitespace after the macro name\");\n+\t}\n       else\n \t{\n \t  int warntype = CPP_DL_WARNING;\n@@ -3134,8 +3169,8 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n       && ustrcmp (NODE_NAME (node), (const uchar *) \"__STDC_FORMAT_MACROS\")\n       /* __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS are mentioned\n \t in the C standard, as something that one must use in C++.\n-\t However DR#593 indicates that these aren't actually mentioned\n-\t in the C++ standard.  We special-case them anyway.  */\n+\t However DR#593 and C++11 indicate that they play no role in C++.\n+\t We special-case them anyway.  */\n       && ustrcmp (NODE_NAME (node), (const uchar *) \"__STDC_LIMIT_MACROS\")\n       && ustrcmp (NODE_NAME (node), (const uchar *) \"__STDC_CONSTANT_MACROS\"))\n     node->flags |= NODE_WARN;"}]}