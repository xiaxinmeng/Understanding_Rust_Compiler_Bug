{"sha": "9c69933102c60c283b53a7ad73192be51a29f507", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM2OTkzMzEwMmM2MGMyODNiNTNhN2FkNzMxOTJiZTUxYTI5ZjUwNw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-01-12T20:26:10Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-01-12T20:26:10Z"}, "message": "re PR libfortran/36755 (Avoid fork/exec in chmod intrinsic)\n\n2012-01-12  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36755\n        * intrinsic.texi (CHMOD): Extend a bit and remove statement\n        that /bin/chmod is called.\n\n2012-01-12  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/36755\n        * intrinsics/chmod.c (chmod_func): Replace call to /bin/chmod\n\nFrom-SVN: r183137", "tree": {"sha": "b6e0d3e2fffc3e6afe56a8ece666aab8f9c1513a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6e0d3e2fffc3e6afe56a8ece666aab8f9c1513a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c69933102c60c283b53a7ad73192be51a29f507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c69933102c60c283b53a7ad73192be51a29f507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c69933102c60c283b53a7ad73192be51a29f507", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c69933102c60c283b53a7ad73192be51a29f507/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "105b876e5556ffbb0fe367eda217cb4e74125c1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105b876e5556ffbb0fe367eda217cb4e74125c1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105b876e5556ffbb0fe367eda217cb4e74125c1f"}], "stats": {"total": 450, "additions": 409, "deletions": 41}, "files": [{"sha": "000516173da0fa004cfd482477388b36318c17dd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c69933102c60c283b53a7ad73192be51a29f507/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c69933102c60c283b53a7ad73192be51a29f507/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9c69933102c60c283b53a7ad73192be51a29f507", "patch": "@@ -1,3 +1,9 @@\n+2012-01-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36755\n+\t* intrinsic.texi (CHMOD): Extend a bit and remove statement\n+\tthat /bin/chmod is called.\n+\n 2012-01-10  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* gfortran.texi (Fortran 2003 Status): Fix grammar."}, {"sha": "294818e43d0a1c62d4d5250ec56605cb1b29202b", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c69933102c60c283b53a7ad73192be51a29f507/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c69933102c60c283b53a7ad73192be51a29f507/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=9c69933102c60c283b53a7ad73192be51a29f507", "patch": "@@ -1,5 +1,5 @@\n @ignore\n-Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2012\n Free Software Foundation, Inc.\n This is part of the GNU Fortran manual.   \n For copying conditions, see the file gfortran.texi.\n@@ -2665,8 +2665,7 @@ END PROGRAM\n \n @table @asis\n @item @emph{Description}:\n-@code{CHMOD} changes the permissions of a file. This function invokes\n-@code{/bin/chmod} and might therefore not work on all platforms.\n+@code{CHMOD} changes the permissions of a file.\n \n This intrinsic is provided in both subroutine and function forms; however,\n only one form can be used in any given program unit.\n@@ -2692,8 +2691,9 @@ file name. Trailing blanks are ignored unless the character\n @code{achar(0)} are used as the file name.\n \n @item @var{MODE} @tab Scalar @code{CHARACTER} of default kind giving the\n-file permission. @var{MODE} uses the same syntax as the @var{MODE}\n-argument of @code{/bin/chmod}.\n+file permission. @var{MODE} uses the same syntax as the @code{chmod} utility\n+as defined by the POSIX standard. The argument shall either be a string of\n+a nonnegative octal number or a symbolic mode.\n \n @item @var{STATUS} @tab (optional) scalar @code{INTEGER}, which is\n @code{0} on success and nonzero otherwise."}, {"sha": "6e30d8274e51d1808c245df3d838989b36088dee", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c69933102c60c283b53a7ad73192be51a29f507/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c69933102c60c283b53a7ad73192be51a29f507/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=9c69933102c60c283b53a7ad73192be51a29f507", "patch": "@@ -1,3 +1,8 @@\n+2012-01-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/36755\n+\t* intrinsics/chmod.c (chmod_func): Replace call to /bin/chmod\n+\n 2012-01-12  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* configure.ac: Remove check for fdopen."}, {"sha": "6c685f42250fd3b3dcf41973a362be03af387c9a", "filename": "libgfortran/intrinsics/chmod.c", "status": "modified", "additions": 393, "deletions": 36, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c69933102c60c283b53a7ad73192be51a29f507/libgfortran%2Fintrinsics%2Fchmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c69933102c60c283b53a7ad73192be51a29f507/libgfortran%2Fintrinsics%2Fchmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchmod.c?ref=9c69933102c60c283b53a7ad73192be51a29f507", "patch": "@@ -1,8 +1,8 @@\n /* Implementation of the CHMOD intrinsic.\n-   Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2009, 2012 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -25,20 +25,39 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"libgfortran.h\"\n \n-#include <errno.h>\n-#include <string.h>\n+#if defined(HAVE_SYS_STAT_H)\n \n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#ifdef  HAVE_SYS_WAIT_H\n-#include <sys/wait.h>\n-#endif\n+#include <stdbool.h>\n+#include <string.h>\t/* For memcpy. */\n+#include <sys/stat.h>\t/* For stat, chmod and umask.  */\n+\n+\n+/* INTEGER FUNCTION CHMOD (NAME, MODE)\n+   CHARACTER(len=*), INTENT(IN) :: NAME, MODE\n+\n+   Sets the file permission \"chmod\" using a mode string.\n \n-/* INTEGER FUNCTION ACCESS(NAME, MODE)\n-   CHARACTER(len=*), INTENT(IN) :: NAME, MODE  */\n+   The mode string allows for the same arguments as POSIX's chmod utility.\n+   a) string containing an octal number.\n+   b) Comma separated list of clauses of the form:\n+      [<who-list>]<op>[<perm-list>|<permcopy>][<op>[<perm-list>|<permcopy>],...]\n+      <who> - 'u', 'g', 'o', 'a'\n+      <op>  - '+', '-', '='\n+      <perm> - 'r', 'w', 'x', 'X', 's', t'\n+   If <op> is not followed by a perm-list or permcopy, '-' and '+' do not\n+   change the mode while '=' clears all file mode bits. 'u' stands for the\n+   user permissions, 'g' for the group and 'o' for the permissions for others.\n+   'a' is equivalent to 'ugo'. '+' sets the given permission in addition to\n+   the ones of the file, '-' unsets the given permissions of the file, while\n+   '=' sets the file to that mode. 'r' sets the read, 'w' the write, and\n+   'x' the execute mode. 'X' sets the execute bit if the file is a directory\n+   or if the user, group or other executable bit is set. 't' sets the sticky\n+   bit, 's' (un)sets the and/or S_ISUID/S_ISGID bit.\n \n-#if defined(HAVE_FORK) && defined(HAVE_EXECL) && defined(HAVE_WAIT)\n+   Note that if <who> is omitted, the permissions are filtered by the umask.\n+\n+   A return value of 0 indicates success, -1 an error of chmod() while 1\n+   indicates a mode parsing error.  */\n \n extern int chmod_func (char *, char *, gfc_charlen_type, gfc_charlen_type);\n export_proto(chmod_func);\n@@ -47,41 +66,379 @@ int\n chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t    gfc_charlen_type mode_len)\n {\n-  char * file, * m;\n-  pid_t pid;\n-  int status;\n+  char * file;\n+  int i;\n+  bool ugo[3];\n+  bool rwxXstugo[9];\n+  int set_mode, part;\n+  bool is_dir, honor_umask, continue_clause = false;\n+  mode_t mode_mask, file_mode, new_mode;\n+  struct stat stat_buf;\n \n-  /* Trim trailing spaces.  */\n+  /* Trim trailing spaces of the file name.  */\n   while (name_len > 0 && name[name_len - 1] == ' ')\n     name_len--;\n-  while (mode_len > 0 && mode[mode_len - 1] == ' ')\n-    mode_len--;\n \n-  /* Make a null terminated copy of the strings.  */\n+  /* Make a null terminated copy of the file name.  */\n   file = gfc_alloca (name_len + 1);\n   memcpy (file, name, name_len);\n   file[name_len] = '\\0';\n \n-  m = gfc_alloca (mode_len + 1);\n-  memcpy (m, mode, mode_len);\n-  m[mode_len]= '\\0';\n+  if (mode_len == 0)\n+    return 1;\n \n-  /* Execute /bin/chmod.  */\n-  if ((pid = fork()) < 0)\n-    return errno;\n-  if (pid == 0)\n+  if (mode[0] >= '0' && mode[0] <= '9')\n     {\n-      /* Child process.  */\n-      execl (\"/bin/chmod\", \"chmod\", m, file, (char *) NULL);\n-      return errno;\n+      if (sscanf (mode, \"%o\", &file_mode) != 1)\n+\treturn 1;\n+      return chmod (file, file_mode);\n     }\n-  else\n-    wait (&status);\n \n-  if (WIFEXITED(status))\n-    return WEXITSTATUS(status);\n-  else\n-    return -1;\n+  /* Read the current file mode. */\n+  if (stat (file, &stat_buf))\n+    return 1;\n+\n+  file_mode = stat_buf.st_mode & ~S_IFMT;\n+  is_dir = stat_buf.st_mode & S_IFDIR;\n+\n+  /* Obtain the umask without distroying the setting.  */\n+  mode_mask = 0;\n+  mode_mask = umask (mode_mask);\n+  (void) umask (mode_mask);\n+\n+  for (i = 0; i < mode_len; i++)\n+    {\n+      if (!continue_clause)\n+\t{\n+\t  ugo[0] = false;\n+\t  ugo[1] = false;\n+\t  ugo[2] = false;\n+\t  honor_umask = true;\n+\t}\n+      continue_clause = false; \n+      rwxXstugo[0] = false;\n+      rwxXstugo[1] = false;\n+      rwxXstugo[2] = false;\n+      rwxXstugo[3] = false;\n+      rwxXstugo[4] = false;\n+      rwxXstugo[5] = false;\n+      rwxXstugo[6] = false;\n+      rwxXstugo[7] = false;\n+      rwxXstugo[8] = false;\n+      rwxXstugo[9] = false;\n+      part = 0;\n+      set_mode = -1;\n+      for (; i < mode_len; i++)\n+\t{\n+\t  switch (mode[i])\n+\t    {\n+\t    /* User setting: a[ll]/u[ser]/g[roup]/o[ther].  */\n+\t    case 'a':\n+\t      if (part > 1)\n+\t\treturn 1;\n+\t      ugo[0] = true;\n+\t      ugo[1] = true;\n+\t      ugo[2] = true;\n+\t      part = 1;\n+\t      honor_umask = false;\n+\t      break;\n+\t    case 'u':\n+\t      if (part == 2)\n+\t\t{\n+\t\t  rwxXstugo[6] = true; \n+\t\t  part = 4;\n+\t\t  break; \n+\t\t}\n+\t      if (part > 1)\n+\t\treturn 1;\n+\t      ugo[0] = true;\n+\t      part = 1;\n+\t      honor_umask = false;\n+\t      break;\n+\t    case 'g':\n+\t      if (part == 2)\n+\t\t{\n+\t\t  rwxXstugo[7] = true; \n+\t\t  part = 4;\n+\t\t  break; \n+\t\t}\n+\t      if (part > 1)\n+\t\treturn 1;\n+       \t      ugo[1] = true;\n+\t      part = 1;\n+\t      honor_umask = false;\n+\t      break;\n+\t    case 'o':\n+\t      if (part == 2)\n+\t\t{\n+\t\t  rwxXstugo[8] = true; \n+\t\t  part = 4;\n+\t\t  break; \n+\t\t}\n+\t      if (part > 1)\n+\t\treturn 1;\n+\t      ugo[2] = true;\n+\t      part = 1;\n+\t      honor_umask = false;\n+\t      break;\n+\n+\t    /* Mode setting: =+-.  */\n+\t    case '=':\n+\t      if (part > 2)\n+\t\t{\n+\t\t  continue_clause = true;\n+\t\t  i--;\n+\t\t  part = 2;\n+\t\t  goto clause_done;\n+\t\t}\n+\t      set_mode = 1;\n+\t      part = 2;\n+\t      break;\n+\n+\t    case '-':\n+\t      if (part > 2)\n+\t\t{\n+\t\t  continue_clause = true;\n+\t\t  i--;\n+\t\t  part = 2;\n+\t\t  goto clause_done;\n+\t\t}\n+\t      set_mode = 2;\n+\t      part = 2;\n+\t      break;\n+\n+\t    case '+':\n+\t      if (part > 2)\n+\t\t{\n+\t\t  continue_clause = true;\n+\t\t  i--;\n+\t\t  part = 2;\n+\t\t  goto clause_done;\n+\t\t}\n+\t      set_mode = 3;\n+\t      part = 2;\n+\t      break;\n+\n+\t    /* Permissions: rwxXst - for ugo see above.  */\n+\t    case 'r':\n+\t      if (part != 2 && part != 3)\n+\t\treturn 1;\n+\t      rwxXstugo[0] = true;\n+\t      part = 3;\n+\t      break;\n+\n+\t    case 'w':\n+\t      if (part != 2 && part != 3)\n+\t\treturn 1;\n+\t      rwxXstugo[1] = true;\n+\t      part = 3;\n+\t      break;\n+\n+\t    case 'x':\n+\t      if (part != 2 && part != 3)\n+\t\treturn 1;\n+\t      rwxXstugo[2] = true;\n+\t      part = 3;\n+\t      break;\n+\n+\t    case 'X':\n+\t      if (part != 2 && part != 3)\n+\t\treturn 1;\n+\t      rwxXstugo[3] = true;\n+\t      part = 3;\n+\t      break;\n+\n+\t    case 's':\n+\t      if (part != 2 && part != 3)\n+\t\treturn 1;\n+\t      rwxXstugo[4] = true;\n+\t      part = 3;\n+\t      break;\n+\n+\t    case 't':\n+\t      if (part != 2 && part != 3)\n+\t\treturn 1;\n+\t      rwxXstugo[5] = true;\n+\t      part = 3;\n+\t      break;\n+\n+\t    /* Tailing blanks are valid in Fortran.  */\n+\t    case ' ':\n+\t      for (i++; i < mode_len; i++)\n+\t\tif (mode[i] != ' ')\n+\t\t  break;\n+\t      if (i != mode_len)\n+\t\treturn 1;\n+\t      goto clause_done;\n+\n+\t    case ',':\n+\t      goto clause_done;\n+\n+\t    default:\n+\t      return 1;\n+\t    }\n+\t}\n+\n+clause_done:\n+      if (part < 2)\n+\treturn 1;\n+\n+      new_mode = 0;\n+\n+      /* Read. */\n+      if (rwxXstugo[0])\n+\t{\n+\t  if (ugo[0] || honor_umask)\n+\t    new_mode |= S_IRUSR;\n+\t  if (ugo[1] || honor_umask)\n+\t    new_mode |= S_IRGRP;\n+\t  if (ugo[2] || honor_umask)\n+\t    new_mode |= S_IROTH;\n+\t}\n+\n+      /* Write.  */\n+      if (rwxXstugo[1])\n+\t{\n+\t  if (ugo[0] || honor_umask)\n+\t    new_mode |= S_IWUSR;\n+\t  if (ugo[1] || honor_umask)\n+\t    new_mode |= S_IWGRP;\n+\t  if (ugo[2] || honor_umask)\n+\t    new_mode |= S_IWOTH;\n+\t}\n+\n+      /* Execute. */\n+      if (rwxXstugo[2])\n+\t{\n+\t  if (ugo[0] || honor_umask)\n+\t    new_mode |= S_IXUSR;\n+\t  if (ugo[1] || honor_umask)\n+\t    new_mode |= S_IXGRP;\n+\t  if (ugo[2] || honor_umask)\n+\t    new_mode |= S_IXOTH;\n+\t}\n+\n+      /* 'X' execute.  */\n+      if (rwxXstugo[3]\n+\t  && (is_dir || (file_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n+\tnew_mode |= (S_IXUSR | S_IXGRP | S_IXOTH);\n+\n+      /* 's'.  */\n+      if (rwxXstugo[4])\n+\t{\n+\t  if (ugo[0] || honor_umask)\n+\t    new_mode |= S_ISUID;\n+\t  if (ugo[1] || honor_umask)\n+\t    new_mode |= S_ISGID;\n+\t}\n+\n+      /* As original 'u'.  */\n+      if (rwxXstugo[6])\n+\t{\n+\t  if (ugo[1] || honor_umask)\n+\t    {\n+\t      if (file_mode & S_IRUSR)\n+\t\tnew_mode |= S_IRGRP;\n+\t      if (file_mode & S_IWUSR)\n+\t\tnew_mode |= S_IWGRP;\n+\t      if (file_mode & S_IXUSR)\n+\t\tnew_mode |= S_IXGRP;\n+\t    }\n+\t  if (ugo[2] || honor_umask)\n+\t    {\n+\t      if (file_mode & S_IRUSR)\n+\t\tnew_mode |= S_IROTH;\n+\t      if (file_mode & S_IWUSR)\n+\t\tnew_mode |= S_IWOTH;\n+\t      if (file_mode & S_IXUSR)\n+\t\tnew_mode |= S_IXOTH;\n+\t    }\n+\t}\n+\n+      /* As original 'g'.  */\n+      if (rwxXstugo[7])\n+\t{\n+\t  if (ugo[0] || honor_umask)\n+\t    {\n+\t      if (file_mode & S_IRGRP)\n+\t\tnew_mode |= S_IRUSR;\n+\t      if (file_mode & S_IWGRP)\n+\t\tnew_mode |= S_IWUSR;\n+\t      if (file_mode & S_IXGRP)\n+\t\tnew_mode |= S_IXUSR;\n+\t    }\n+\t  if (ugo[2] || honor_umask)\n+\t    {\n+\t      if (file_mode & S_IRGRP)\n+\t\tnew_mode |= S_IROTH;\n+\t      if (file_mode & S_IWGRP)\n+\t\tnew_mode |= S_IWOTH;\n+\t      if (file_mode & S_IXGRP)\n+\t\tnew_mode |= S_IXOTH;\n+\t    }\n+\t}\n+\n+      /* As original 'o'.  */\n+      if (rwxXstugo[8])\n+\t{\n+\t  if (ugo[0] || honor_umask)\n+\t    {\n+\t      if (file_mode & S_IROTH)\n+\t\tnew_mode |= S_IRUSR;\n+\t      if (file_mode & S_IWOTH)\n+\t\tnew_mode |= S_IWUSR;\n+\t      if (file_mode & S_IXOTH)\n+\t\tnew_mode |= S_IXUSR;\n+\t    }\n+\t  if (ugo[1] || honor_umask)\n+\t    {\n+\t      if (file_mode & S_IROTH)\n+\t\tnew_mode |= S_IRGRP;\n+\t      if (file_mode & S_IWOTH)\n+\t\tnew_mode |= S_IWGRP;\n+\t      if (file_mode & S_IXOTH)\n+\t\tnew_mode |= S_IXGRP;\n+\t    }\n+\t}\n+\n+    if (honor_umask)\n+      new_mode &= ~mode_mask;\n+\n+    if (set_mode == 1)\n+      {\n+\t/* Set '='.  */\n+\tif ((ugo[0] || honor_umask) && !rwxXstugo[6])\n+\t  file_mode = (file_mode & ~(S_ISUID | S_IRUSR | S_IWUSR | S_IXUSR))\n+\t\t      | (new_mode & (S_ISUID | S_IRUSR | S_IWUSR | S_IXUSR));\n+\tif ((ugo[1] || honor_umask) && !rwxXstugo[7])\n+\t  file_mode = (file_mode & ~(S_ISGID | S_IRGRP | S_IWGRP | S_IXGRP))\n+\t\t      | (new_mode & (S_ISGID | S_IRGRP | S_IWGRP | S_IXGRP));\n+\tif ((ugo[2] || honor_umask) && !rwxXstugo[8])\n+\t  file_mode = (file_mode & ~(S_IROTH | S_IWOTH | S_IXOTH))\n+\t\t      | (new_mode & (S_IROTH | S_IWOTH | S_IXOTH));\n+\tif (is_dir && rwxXstugo[5])\n+\t  file_mode |= S_ISVTX;\n+\telse if (!is_dir)\n+\t  file_mode &= ~S_ISVTX;\n+      }\n+    else if (set_mode == 2)\n+      {\n+\t/* Clear '-'.  */\n+\tfile_mode &= ~new_mode;\n+\tif (rwxXstugo[5] || !is_dir)\n+\t  file_mode &= ~S_ISVTX;\n+      }\n+    else if (set_mode == 3)\n+      {\n+\tfile_mode |= new_mode;\n+\tif (rwxXstugo[5] && is_dir)\n+\t  file_mode |= S_ISVTX;\n+\telse if (!is_dir)\n+\t  file_mode &= ~S_ISVTX;\n+      }\n+  }\n+\n+  return chmod (file, file_mode);\n }\n \n "}]}