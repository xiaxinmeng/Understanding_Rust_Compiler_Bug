{"sha": "9e0aebcaeec9fd14355424916ecde132097ee0e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUwYWViY2FlZWM5ZmQxNDM1NTQyNDkxNmVjZGUxMzIwOTdlZTBlOQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2008-04-03T05:17:11Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2008-04-03T05:17:11Z"}, "message": "* expmed.c (extract_force_align_mem_bit_field): Remove.\n\nFrom-SVN: r133858", "tree": {"sha": "96c5b377655df074fc6b667a178b9ca3286ecc9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96c5b377655df074fc6b667a178b9ca3286ecc9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e0aebcaeec9fd14355424916ecde132097ee0e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0aebcaeec9fd14355424916ecde132097ee0e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0aebcaeec9fd14355424916ecde132097ee0e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0aebcaeec9fd14355424916ecde132097ee0e9/comments", "author": null, "committer": null, "parents": [{"sha": "55187c8a16273a21be18e982bc2389e534e48975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55187c8a16273a21be18e982bc2389e534e48975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55187c8a16273a21be18e982bc2389e534e48975"}], "stats": {"total": 150, "additions": 4, "deletions": 146}, "files": [{"sha": "e9d13b07981bb6f6f4880efdeb796db5937c3572", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0aebcaeec9fd14355424916ecde132097ee0e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0aebcaeec9fd14355424916ecde132097ee0e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e0aebcaeec9fd14355424916ecde132097ee0e9", "patch": "@@ -1,3 +1,7 @@\n+2008-04-03  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* expmed.c (extract_force_align_mem_bit_field): Remove.\n+\n 2008-04-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/35800"}, {"sha": "d5d2d528ca0a4d489231c91217442392cb825583", "filename": "gcc/expmed.c", "status": "modified", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e0aebcaeec9fd14355424916ecde132097ee0e9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e0aebcaeec9fd14355424916ecde132097ee0e9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9e0aebcaeec9fd14355424916ecde132097ee0e9", "patch": "@@ -1835,152 +1835,6 @@ lshift_value (enum machine_mode mode, rtx value, int bitpos, int bitsize)\n   return immed_double_const (low, high, mode);\n }\n \f\n-/* Extract a bit field from a memory by forcing the alignment of the\n-   memory.  This efficient only if the field spans at least 4 boundaries.\n-\n-   OP0 is the MEM.\n-   BITSIZE is the field width; BITPOS is the position of the first bit.\n-   UNSIGNEDP is true if the result should be zero-extended.  */\n-\n-static rtx\n-extract_force_align_mem_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n-\t\t\t\t   unsigned HOST_WIDE_INT bitpos,\n-\t\t\t\t   int unsignedp)\n-{\n-  enum machine_mode mode, dmode;\n-  unsigned int m_bitsize, m_size;\n-  unsigned int sign_shift_up, sign_shift_dn;\n-  rtx base, a1, a2, v1, v2, comb, shift, result, start;\n-\n-  /* Choose a mode that will fit BITSIZE.  */\n-  mode = smallest_mode_for_size (bitsize, MODE_INT);\n-  m_size = GET_MODE_SIZE (mode);\n-  m_bitsize = GET_MODE_BITSIZE (mode);\n-\n-  /* Choose a mode twice as wide.  Fail if no such mode exists.  */\n-  dmode = mode_for_size (m_bitsize * 2, MODE_INT, false);\n-  if (dmode == BLKmode)\n-    return NULL;\n-\n-  do_pending_stack_adjust ();\n-  start = get_last_insn ();\n-\n-  /* At the end, we'll need an additional shift to deal with sign/zero\n-     extension.  By default this will be a left+right shift of the\n-     appropriate size.  But we may be able to eliminate one of them.  */\n-  sign_shift_up = sign_shift_dn = m_bitsize - bitsize;\n-\n-  if (STRICT_ALIGNMENT)\n-    {\n-      base = plus_constant (XEXP (op0, 0), bitpos / BITS_PER_UNIT);\n-      bitpos %= BITS_PER_UNIT;\n-\n-      /* We load two values to be concatenate.  There's an edge condition\n-\t that bears notice -- an aligned value at the end of a page can\n-\t only load one value lest we segfault.  So the two values we load\n-\t are at \"base & -size\" and \"(base + size - 1) & -size\".  If base\n-\t is unaligned, the addresses will be aligned and sequential; if\n-\t base is aligned, the addresses will both be equal to base.  */\n-\n-      a1 = expand_simple_binop (Pmode, AND, force_operand (base, NULL),\n-\t\t\t\tGEN_INT (-(HOST_WIDE_INT)m_size),\n-\t\t\t\tNULL, true, OPTAB_LIB_WIDEN);\n-      mark_reg_pointer (a1, m_bitsize);\n-      v1 = gen_rtx_MEM (mode, a1);\n-      set_mem_align (v1, m_bitsize);\n-      v1 = force_reg (mode, validize_mem (v1));\n-\n-      a2 = plus_constant (base, GET_MODE_SIZE (mode) - 1);\n-      a2 = expand_simple_binop (Pmode, AND, force_operand (a2, NULL),\n-\t\t\t\tGEN_INT (-(HOST_WIDE_INT)m_size),\n-\t\t\t\tNULL, true, OPTAB_LIB_WIDEN);\n-      v2 = gen_rtx_MEM (mode, a2);\n-      set_mem_align (v2, m_bitsize);\n-      v2 = force_reg (mode, validize_mem (v2));\n-\n-      /* Combine these two values into a double-word value.  */\n-      if (m_bitsize == BITS_PER_WORD)\n-\t{\n-\t  comb = gen_reg_rtx (dmode);\n-\t  emit_insn (gen_rtx_CLOBBER (VOIDmode, comb));\n-\t  emit_move_insn (gen_rtx_SUBREG (mode, comb, 0), v1);\n-\t  emit_move_insn (gen_rtx_SUBREG (mode, comb, m_size), v2);\n-\t}\n-      else\n-\t{\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    comb = v1, v1 = v2, v2 = comb;\n-\t  v1 = convert_modes (dmode, mode, v1, true);\n-\t  if (v1 == NULL)\n-\t    goto fail;\n-\t  v2 = convert_modes (dmode, mode, v2, true);\n-\t  v2 = expand_simple_binop (dmode, ASHIFT, v2, GEN_INT (m_bitsize),\n-\t\t\t\t    NULL, true, OPTAB_LIB_WIDEN);\n-\t  if (v2 == NULL)\n-\t    goto fail;\n-\t  comb = expand_simple_binop (dmode, IOR, v1, v2, NULL,\n-\t\t\t\t      true, OPTAB_LIB_WIDEN);\n-\t  if (comb == NULL)\n-\t    goto fail;\n-\t}\n-\n-      shift = expand_simple_binop (Pmode, AND, base, GEN_INT (m_size - 1),\n-\t\t\t\t   NULL, true, OPTAB_LIB_WIDEN);\n-      shift = expand_mult (Pmode, shift, GEN_INT (BITS_PER_UNIT), NULL, 1);\n-\n-      if (bitpos != 0)\n-\t{\n-\t  if (sign_shift_up <= bitpos)\n-\t    bitpos -= sign_shift_up, sign_shift_up = 0;\n-\t  shift = expand_simple_binop (Pmode, PLUS, shift, GEN_INT (bitpos),\n-\t\t\t\t       NULL, true, OPTAB_LIB_WIDEN);\n-\t}\n-    }\n-  else\n-    {\n-      unsigned HOST_WIDE_INT offset = bitpos / BITS_PER_UNIT;\n-      bitpos %= BITS_PER_UNIT;\n-\n-      /* When strict alignment is not required, we can just load directly\n-\t from memory without masking.  If the remaining BITPOS offset is\n-\t small enough, we may be able to do all operations in MODE as \n-\t opposed to DMODE.  */\n-      if (bitpos + bitsize <= m_bitsize)\n-\tdmode = mode;\n-      comb = adjust_address (op0, dmode, offset);\n-\n-      if (sign_shift_up <= bitpos)\n-\tbitpos -= sign_shift_up, sign_shift_up = 0;\n-      shift = GEN_INT (bitpos);\n-    }\n-\n-  /* Shift down the double-word such that the requested value is at bit 0.  */\n-  if (shift != const0_rtx)\n-    comb = expand_simple_binop (dmode, unsignedp ? LSHIFTRT : ASHIFTRT,\n-\t\t\t\tcomb, shift, NULL, unsignedp, OPTAB_LIB_WIDEN);\n-  if (comb == NULL)\n-    goto fail;\n-\n-  /* If the field exactly matches MODE, then all we need to do is return the\n-     lowpart.  Otherwise, shift to get the sign bits set properly.  */\n-  result = force_reg (mode, gen_lowpart (mode, comb));\n-\n-  if (sign_shift_up)\n-    result = expand_simple_binop (mode, ASHIFT, result,\n-\t\t\t\t  GEN_INT (sign_shift_up),\n-\t\t\t\t  NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-  if (sign_shift_dn)\n-    result = expand_simple_binop (mode, unsignedp ? LSHIFTRT : ASHIFTRT,\n-\t\t\t\t  result, GEN_INT (sign_shift_dn),\n-\t\t\t\t  NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\n-  return result;\n-\n- fail:\n-  delete_insns_since (start);\n-  return NULL;\n-}\n-\n /* Extract a bit field that is split across two words\n    and return an RTX for the result.\n "}]}