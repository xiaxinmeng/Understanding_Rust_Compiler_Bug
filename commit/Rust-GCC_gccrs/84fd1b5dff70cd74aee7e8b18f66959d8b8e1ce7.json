{"sha": "84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRmZDFiNWRmZjcwY2Q3NGFlZTdlOGIxOGY2Njk1OWQ4YjhlMWNlNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-20T01:12:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-20T20:59:17Z"}, "message": "c++: designated init with anonymous union [PR100489]\n\nMy patch for PR98463 added an assert that tripped on this testcase, because\nwe ended up with a U CONSTRUCTOR with an initializer for a, which is not a\nmember of U.  We need to wrap the a initializer in another CONSTRUCTOR for\nthe anonymous union.\n\nThere was already support for this in process_init_constructor_record, but\nnot in process_init_constructor_union.  But since this is about brace\nelision, it really belongs under reshape_init rather than digest_init, so\nthis patch moves the handling to reshape_init_class, which also handles\nunions.\n\n\tPR c++/100489\n\ngcc/cp/ChangeLog:\n\n\t* decl.c (reshape_init_class): Handle designator for\n\tmember of anonymous aggregate here.\n\t* typeck2.c (process_init_constructor_record): Not here.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/desig18.C: New test.", "tree": {"sha": "3584ac15bb2a3eea9a0c8787fc9b66e5bbc4f396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3584ac15bb2a3eea9a0c8787fc9b66e5bbc4f396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64ba45c76e831914764b70207d69a06f800b43a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ba45c76e831914764b70207d69a06f800b43a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64ba45c76e831914764b70207d69a06f800b43a4"}], "stats": {"total": 76, "additions": 46, "deletions": 30}, "files": [{"sha": "6107b553cb490271ba5ac5a1d6bc7d8ef584b75d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "patch": "@@ -6418,10 +6418,9 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n \t      /* We already reshaped this.  */\n \t      if (field != d->cur->index)\n \t\t{\n-\t\t  tree id = DECL_NAME (d->cur->index);\n-\t\t  gcc_assert (id);\n-\t\t  gcc_checking_assert (d->cur->index\n-\t\t\t\t       == get_class_binding (type, id));\n+\t\t  if (tree id = DECL_NAME (d->cur->index))\n+\t\t    gcc_checking_assert (d->cur->index\n+\t\t\t\t\t == get_class_binding (type, id));\n \t\t  field = d->cur->index;\n \t\t}\n \t    }\n@@ -6442,6 +6441,32 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n \t\t       d->cur->index);\n \t      return error_mark_node;\n \t    }\n+\n+\t  /* If the element is an anonymous union object and the initializer\n+\t     list is a designated-initializer-list, the anonymous union object\n+\t     is initialized by the designated-initializer-list { D }, where D\n+\t     is the designated-initializer-clause naming a member of the\n+\t     anonymous union object.  */\n+\t  tree ictx = DECL_CONTEXT (field);\n+\t  if (!same_type_ignoring_top_level_qualifiers_p (ictx, type))\n+\t    {\n+\t      gcc_assert (ANON_AGGR_TYPE_P (ictx));\n+\t      /* Find the anon aggr that is a direct member of TYPE.  */\n+\t      while (true)\n+\t\t{\n+\t\t  tree cctx = TYPE_CONTEXT (ictx);\n+\t\t  if (same_type_ignoring_top_level_qualifiers_p (cctx, type))\n+\t\t    break;\n+\t\t  ictx = cctx;\n+\t\t}\n+\t      /* And then the TYPE member with that anon aggr type.  */\n+\t      tree aafield = TYPE_FIELDS (type);\n+\t      for (; aafield; aafield = TREE_CHAIN (aafield))\n+\t\tif (TREE_TYPE (aafield) == ictx)\n+\t\t  break;\n+\t      gcc_assert (aafield);\n+\t      field = aafield;\n+\t    }\n \t}\n \n       /* If we processed all the member of the class, we are done.  */"}, {"sha": "5a7219dec65bf871c01573c2cfadf3826db3369d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "patch": "@@ -1517,19 +1517,6 @@ process_init_constructor_record (tree type, tree init, int nested, int flags,\n \t\t\t  || identifier_p (ce->index));\n \t      if (ce->index == field || ce->index == DECL_NAME (field))\n \t\tnext = ce->value;\n-\t      else if (ANON_AGGR_TYPE_P (fldtype)\n-\t\t       && search_anon_aggr (fldtype,\n-\t\t\t\t\t    TREE_CODE (ce->index) == FIELD_DECL\n-\t\t\t\t\t    ? DECL_NAME (ce->index)\n-\t\t\t\t\t    : ce->index))\n-\t\t/* If the element is an anonymous union object and the\n-\t\t   initializer list is a designated-initializer-list, the\n-\t\t   anonymous union object is initialized by the\n-\t\t   designated-initializer-list { D }, where D is the\n-\t\t   designated-initializer-clause naming a member of the\n-\t\t   anonymous union object.  */\n-\t\tnext = build_constructor_single (init_list_type_node,\n-\t\t\t\t\t\t ce->index, ce->value);\n \t      else\n \t\t{\n \t\t  ce = NULL;\n@@ -1675,19 +1662,6 @@ process_init_constructor_record (tree type, tree init, int nested, int flags,\n \n \t\t  if (ce->index == field || ce->index == DECL_NAME (field))\n \t\t    break;\n-\t\t  if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-\t\t    {\n-\t\t      tree t\n-\t\t\t= search_anon_aggr (TREE_TYPE (field),\n-\t\t\t\t\t    TREE_CODE (ce->index) == FIELD_DECL\n-\t\t\t\t\t    ? DECL_NAME (ce->index)\n-\t\t\t\t\t    : ce->index);\n-\t\t      if (t)\n-\t\t\t{\n-\t\t\t  field = t;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n \t\t}\n \t    }\n \t  if (field)"}, {"sha": "4851579b7c78f239fca714f81ca83623c3c4f335", "filename": "gcc/testsuite/g++.dg/cpp2a/desig18.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fdesig18.C?ref=84fd1b5dff70cd74aee7e8b18f66959d8b8e1ce7", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/100489\n+// { dg-options \"\" }\n+\n+union U\n+{\n+  union\n+  {\n+    unsigned char a;\n+  };\n+\n+  unsigned char b[1];\n+};\n+\n+void f(unsigned char a)\n+{\n+  union U u = { .a = a };\n+}"}]}