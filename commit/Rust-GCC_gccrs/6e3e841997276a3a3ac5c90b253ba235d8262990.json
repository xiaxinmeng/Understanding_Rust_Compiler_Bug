{"sha": "6e3e841997276a3a3ac5c90b253ba235d8262990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUzZTg0MTk5NzI3NmEzYTNhYzVjOTBiMjUzYmEyMzVkODI2Mjk5MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-09-29T18:51:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-09-29T18:51:00Z"}, "message": "c-ada-spec.c (to_ada_name): Add index parameter.\n\n\t* c-ada-spec.c (to_ada_name): Add index parameter.\n\t(pp_ada_tree_identifier): Likewise.\n\t(dump_ada_macros): Adjust call to to_ada_name.\n\t(struct overloaded_name_hash): New type.\n\t(struct overloaded_name_hasher): Likewise.\n\t(overloaded_names): New hash table.\n\t(compute_overloading_index): New function.\n\t(dump_ada_decl_name): Call it and pass the result to\n\tpp_ada_tree_identifier.\n\t(dump_ada_double_name): Adjust calls to pp_ada_tree_identifier.\n\t(dump_ada_function_declaration): Likewise.\n\t(dump_generic_ada_node): Likewise.\n\t(print_constructor): Likewise.\n\t(print_destructor): Likewise.\n\t(dump_ada_specs): Delete overloaded_names table.\n\nFrom-SVN: r253306", "tree": {"sha": "7b23cfe5ea2302a3fac8b2802b46baceb552beb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b23cfe5ea2302a3fac8b2802b46baceb552beb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e3e841997276a3a3ac5c90b253ba235d8262990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3e841997276a3a3ac5c90b253ba235d8262990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e3e841997276a3a3ac5c90b253ba235d8262990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3e841997276a3a3ac5c90b253ba235d8262990/comments", "author": null, "committer": null, "parents": [{"sha": "e9d297a15d68121ba5bdd5a76ea71c1916180622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d297a15d68121ba5bdd5a76ea71c1916180622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d297a15d68121ba5bdd5a76ea71c1916180622"}], "stats": {"total": 172, "additions": 148, "deletions": 24}, "files": [{"sha": "e2b73c8907ca9b34d08e7b0a6af47037efa25d75", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6e3e841997276a3a3ac5c90b253ba235d8262990", "patch": "@@ -1,3 +1,21 @@\n+2017-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c (to_ada_name): Add index parameter.\n+\t(pp_ada_tree_identifier): Likewise.\n+\t(dump_ada_macros): Adjust call to to_ada_name.\n+\t(struct overloaded_name_hash): New type.\n+\t(struct overloaded_name_hasher): Likewise.\n+\t(overloaded_names): New hash table.\n+\t(compute_overloading_index): New function.\n+\t(dump_ada_decl_name): Call it and pass the result to\n+\tpp_ada_tree_identifier.\n+\t(dump_ada_double_name): Adjust calls to pp_ada_tree_identifier.\n+\t(dump_ada_function_declaration): Likewise.\n+\t(dump_generic_ada_node): Likewise.\n+\t(print_constructor): Likewise.\n+\t(print_destructor): Likewise.\n+\t(dump_ada_specs): Delete overloaded_names table.\n+\n 2017-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (max_ada_macros): Move around."}, {"sha": "834360f347e69f35090c181917a00dfbe0d9ad7a", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 102, "deletions": 24, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=6e3e841997276a3a3ac5c90b253ba235d8262990", "patch": "@@ -36,7 +36,7 @@ static int  dump_generic_ada_node (pretty_printer *, tree, tree, int, bool,\n \t\t\t\t   bool);\n static int  dump_ada_declaration (pretty_printer *, tree, tree, int);\n static void dump_ada_struct_decl (pretty_printer *, tree, tree, int, bool);\n-static char *to_ada_name (const char *, bool *);\n+static char *to_ada_name (const char *, unsigned int, bool *);\n \n #define INDENT(SPACE) \\\n   do { int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)\n@@ -577,7 +577,7 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \t  prev_line = sloc.line;\n \n \t  pp_string (pp, \"   \");\n-\t  ada_name = to_ada_name ((const char *) NODE_NAME (node), NULL);\n+\t  ada_name = to_ada_name ((const char *) NODE_NAME (node), 0, NULL);\n \t  pp_string (pp, ada_name);\n \t  free (ada_name);\n \t  pp_string (pp, \" : \");\n@@ -1078,18 +1078,20 @@ has_nontrivial_methods (tree type)\n   return false;\n }\n \n-/* Generate a legal Ada name from a C/C++ NAME and return a malloc'ed string. \n-   SPACE_FOUND, if not NULL, is used to indicate whether a space was found\n-   in NAME.  */\n+#define INDEX_LENGTH 8\n+\n+/* Generate a legal Ada name from a C/C++ NAME and return a malloc'ed string.\n+   INDEX, if non-zero, is used to disambiguate overloaded names.  SPACE_FOUND,\n+   if not NULL, is used to indicate whether a space was found in NAME.  */\n \n static char *\n-to_ada_name (const char *name, bool *space_found)\n+to_ada_name (const char *name, unsigned int index, bool *space_found)\n {\n   const char **names;\n   const int len = strlen (name);\n   int j, len2 = 0;\n   bool found = false;\n-  char *s = XNEWVEC (char, len * 2 + 5);\n+  char *s = XNEWVEC (char, len * 2 + 5 + (index ? INDEX_LENGTH : 0));\n   char c;\n \n   if (space_found)\n@@ -1287,7 +1289,10 @@ to_ada_name (const char *name, bool *space_found)\n   if (s[len2 - 1] == '_')\n     s[len2++] = 'u';\n \n-  s[len2] = '\\0';\n+  if (index)\n+    snprintf (&s[len2], INDEX_LENGTH, \"_u_%d\", index + 1);\n+  else\n+    s[len2] = '\\0';\n \n   return s;\n }\n@@ -1305,16 +1310,17 @@ separate_class_package (tree decl)\n static bool package_prefix = true;\n \n /* Dump in BUFFER the name of an identifier NODE of type TYPE, following Ada\n-   syntax.  LIMITED_ACCESS indicates whether NODE can be accessed via a limited\n+   syntax.  INDEX, if non-zero, is used to disambiguate overloaded names.\n+   LIMITED_ACCESS indicates whether NODE can be accessed via a limited\n    'with' clause rather than a regular 'with' clause.  */\n \n static void\n pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,\n-\t\t\tbool limited_access)\n+\t\t\tunsigned int index, bool limited_access)\n {\n   const char *name = IDENTIFIER_POINTER (node);\n   bool space_found = false;\n-  char *s = to_ada_name (name, &space_found);\n+  char *s = to_ada_name (name, index, &space_found);\n   tree decl = get_underlying_decl (type);\n \n   /* If the entity comes from another file, generate a package prefix.  */\n@@ -1426,6 +1432,71 @@ pp_asm_name (pretty_printer *buffer, tree t)\n   pp_string (buffer, ada_name);\n }\n \n+/* Hash table of overloaded names associating identifier nodes with DECL_UIDs.\n+   It is needed in Ada 2005 because we can have at most one import directive\n+   per subprogram name in a given scope, so we have to mangle the subprogram\n+   names on the Ada side to import overloaded subprograms from C++.  */\n+\n+struct overloaded_name_hash {\n+  hashval_t hash;\n+  tree name;\n+  tree context;\n+  vec<unsigned int> homonyms;\n+};\n+\n+struct overloaded_name_hasher : delete_ptr_hash<overloaded_name_hash>\n+{\n+  static inline hashval_t hash (overloaded_name_hash *t)\n+    { return t->hash; }\n+  static inline bool equal (overloaded_name_hash *a, overloaded_name_hash *b)\n+    { return a->name == b->name && a->context == b->context; }\n+};\n+\n+static hash_table<overloaded_name_hasher> *overloaded_names;\n+\n+/* Compute the overloading index of function DECL in its context.  */\n+\n+static unsigned int\n+compute_overloading_index (tree decl)\n+{\n+  const hashval_t hashcode\n+    = iterative_hash_hashval_t (htab_hash_pointer (DECL_NAME (decl)),\n+\t\t\t        htab_hash_pointer (DECL_CONTEXT (decl)));\n+  struct overloaded_name_hash in, *h, **slot;\n+  unsigned int index, *iter;\n+\n+  if (!overloaded_names)\n+    overloaded_names = new hash_table<overloaded_name_hasher> (512);\n+\n+  /* Look up the list of homonyms in the table.  */\n+  in.hash = hashcode;\n+  in.name = DECL_NAME (decl);\n+  in.context = DECL_CONTEXT (decl);\n+  slot = overloaded_names->find_slot_with_hash (&in, hashcode, INSERT);\n+  if (*slot)\n+    h = *slot;\n+  else\n+    {\n+      h = new overloaded_name_hash;\n+      h->hash = hashcode;\n+      h->name = DECL_NAME (decl);\n+      h->context = DECL_CONTEXT (decl);\n+      h->homonyms.create (0);\n+      *slot = h;\n+    }\n+\n+  /* Look up the function in the list of homonyms.  */\n+  FOR_EACH_VEC_ELT (h->homonyms, index, iter)\n+    if (*iter == DECL_UID (decl))\n+      break;\n+\n+  /* If it is not present, push it onto the list.  */\n+  if (!iter)\n+    h->homonyms.safe_push (DECL_UID (decl));\n+\n+  return index;\n+}\n+\n /* Dump in BUFFER the name of a DECL node if set, following Ada syntax.\n    LIMITED_ACCESS indicates whether NODE can be accessed via a limited\n    'with' clause rather than a regular 'with' clause.  */\n@@ -1434,7 +1505,13 @@ static void\n dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n {\n   if (DECL_NAME (decl))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (decl), decl, limited_access);\n+    {\n+      const unsigned int index\n+\t= (TREE_CODE (decl) == FUNCTION_DECL && cpp_check)\n+\t  ? compute_overloading_index (decl) : 0;\n+      pp_ada_tree_identifier (buffer, DECL_NAME (decl), decl, index,\n+\t\t\t      limited_access);\n+    }\n   else\n     {\n       tree type_name = TYPE_NAME (TREE_TYPE (decl));\n@@ -1448,7 +1525,7 @@ dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n \t    pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (decl)));\n \t}\n       else if (TREE_CODE (type_name) == IDENTIFIER_NODE)\n-\tpp_ada_tree_identifier (buffer, type_name, decl, limited_access);\n+\tpp_ada_tree_identifier (buffer, type_name, decl, 0, limited_access);\n     }\n }\n \n@@ -1458,7 +1535,7 @@ static void\n dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n {\n   if (DECL_NAME (t1))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (t1), t1, false);\n+    pp_ada_tree_identifier (buffer, DECL_NAME (t1), t1, 0, false);\n   else\n     {\n       pp_string (buffer, \"anon\");\n@@ -1468,7 +1545,7 @@ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n   pp_underscore (buffer);\n \n   if (DECL_NAME (t2))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, false);\n+    pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, 0, false);\n   else\n     {\n       pp_string (buffer, \"anon\");\n@@ -1622,7 +1699,7 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n \t  if (DECL_NAME (arg))\n \t    {\n \t      check_name (buffer, arg);\n-\t      pp_ada_tree_identifier (buffer, DECL_NAME (arg), NULL_TREE,\n+\t      pp_ada_tree_identifier (buffer, DECL_NAME (arg), NULL_TREE, 0,\n \t\t\t\t      false);\n \t      pp_string (buffer, \" : \");\n \t    }\n@@ -1958,7 +2035,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       return 0;\n \n     case IDENTIFIER_NODE:\n-      pp_ada_tree_identifier (buffer, node, type, limited_access);\n+      pp_ada_tree_identifier (buffer, node, type, 0, limited_access);\n       break;\n \n     case TREE_LIST:\n@@ -2016,7 +2093,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t    }\n \n \t\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node,\n-\t\t\t\t\t  false);\n+\t\t\t\t\t  0, false);\n \t\t}\n \t      pp_string (buffer, \");\");\n \t      spc -= INDENT_INCR;\n@@ -2039,7 +2116,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t  newline_and_indent (buffer, spc);\n \n \t\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node,\n-\t\t\t\t\t  false);\n+\t\t\t\t\t  0, false);\n \t\t  pp_string (buffer, \" : constant \");\n \n \t\t  dump_generic_ada_node\n@@ -2069,7 +2146,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \tif (tclass == tcc_declaration)\n \t  {\n \t    if (DECL_NAME (node))\n-\t      pp_ada_tree_identifier (buffer, DECL_NAME (node), NULL_TREE,\n+\t      pp_ada_tree_identifier (buffer, DECL_NAME (node), NULL_TREE, 0,\n \t\t\t\t      limited_access);\n \t    else\n \t      pp_string (buffer, \"<unnamed type decl>\");\n@@ -2079,7 +2156,7 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t    if (TYPE_NAME (node))\n \t      {\n \t\tif (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n-\t\t  pp_ada_tree_identifier (buffer, TYPE_NAME (node), node,\n+\t\t  pp_ada_tree_identifier (buffer, TYPE_NAME (node), node, 0,\n \t\t\t\t\t  limited_access);\n \t\telse if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n \t\t\t && DECL_NAME (TYPE_NAME (node)))\n@@ -2598,7 +2675,7 @@ print_constructor (pretty_printer *buffer, tree t, tree type)\n   tree decl_name = DECL_NAME (TYPE_NAME (type));\n \n   pp_string (buffer, \"New_\");\n-  pp_ada_tree_identifier (buffer, decl_name, t, false);\n+  pp_ada_tree_identifier (buffer, decl_name, t, 0, false);\n }\n \n /* Dump in BUFFER destructor spec corresponding to T.  */\n@@ -2609,7 +2686,7 @@ print_destructor (pretty_printer *buffer, tree t, tree type)\n   tree decl_name = DECL_NAME (TYPE_NAME (type));\n \n   pp_string (buffer, \"Delete_\");\n-  pp_ada_tree_identifier (buffer, decl_name, t, false);\n+  pp_ada_tree_identifier (buffer, decl_name, t, 0, false);\n }\n \n /* Return the name of type T.  */\n@@ -3375,6 +3452,7 @@ dump_ada_specs (void (*collect_all_refs)(const char *),\n   for (int i = 0; i < source_refs_used; i++)\n     dump_ads (source_refs[i], collect_all_refs, check);\n \n-  /* Free files table.  */\n+  /* Free various tables.  */\n   free (source_refs);\n+  delete overloaded_names;\n }"}, {"sha": "0cf96a9e8ef8dfcc0ab21f5ba3b4a5114ce28036", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e3e841997276a3a3ac5c90b253ba235d8262990", "patch": "@@ -1,3 +1,7 @@\n+2017-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* g++.dg/other/dump-ada-spec-10.C: New test.\n+\n 2017-09-29  Jeff Law  <law@redhat.com>\n \n \t* testsuite/gcc.dg/tree-ssa/ssa-dse-26.c: New test."}, {"sha": "0e641ae3b60f8492a60c5785be37fa93ada6889b", "filename": "gcc/testsuite/g++.dg/other/dump-ada-spec-10.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3e841997276a3a3ac5c90b253ba235d8262990/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fdump-ada-spec-10.C?ref=6e3e841997276a3a3ac5c90b253ba235d8262990", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-ada-spec\" } */\n+\n+extern int convert_to_int (float f);\n+extern int convert_to_int (double d);\n+extern int convert_to_int (long double ld);\n+\n+class S1\n+{\n+  S1 ();\n+  int convert_to_int (float f);\n+  int convert_to_int (double d);\n+  int convert_to_int (long double ld);\n+};\n+\n+class S2\n+{\n+  S2 ();\n+  virtual int convert_to_int (float f);\n+  virtual int convert_to_int (double d);\n+  virtual int convert_to_int (long double ld);\n+};\n+\n+/* { dg-final { cleanup-ada-spec } } */"}]}