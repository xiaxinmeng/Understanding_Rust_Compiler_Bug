{"sha": "2588e44e0019aac9b55c974efd69885eea663f54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4OGU0NGUwMDE5YWFjOWI1NWM5NzRlZmQ2OTg4NWVlYTY2M2Y1NA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-10-08T21:12:33Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-10-08T21:12:33Z"}, "message": "c-common.c (FMT_FLAG_ARG_CONVERT, [...]): Define.\n\n\t* c-common.c (FMT_FLAG_ARG_CONVERT, FMT_FLAG_SCANF_A_KLUDGE,\n\tFMT_FLAG_FANCY_PERCENT_OK): Define.\n\t(format_char_info): Add flag \"4\" to comment.\n\t(format_flag_spec, format_flag_pair): New structures.\n\t(format_kind_info): Add additional fields to control format\n\tchecking.\n\t(printf_flag_specs, printf_flag_pairs, scanf_flag_specs,\n\tscanf_flag_pairs, strftime_flag_specs, strftime_flag_pairs): New\n\tarrays.\n\t(time_char_table): Use \"4\" flag to handle %Ey.\n\t(format_types): Add entries for new fields.\n\t(get_flag_spec): New function.\n\t(check_format_info): Increase size of flag_chars[] to 256.\n\tControl format checking using the new fields of a format_kind_info\n\tand the new tables; remove all conditionals on printf_format_type,\n\tscanf_format_type or strftime_format_type.  Handle all details of\n\tbad combinations of flags (including width, precision and strftime\n\tmodifiers) through data rather than ad hoc code.  Handle all\n\tdetails of standard versions in which flags appeared through\n\tdata.  Use the \"4\" flag.\n\ntestsuite:\n\t* gcc.dg/c90-printf-1.c, gcc.dg/c90-scanf-1.c,\n\tgcc.dg/c99-printf-1.c, gcc.dg/c99-scanf-1.c,\n\tgcc.dg/c99-strftime-1.c, gcc.dg/format-ext-3.c: Adjust error\n\tregexps and details of expected handling of some bad formats.\n\t* gcc.dg/format-xopen-1.c: Add test for $ format with assignment\n\tsuppression.\n\nFrom-SVN: r36790", "tree": {"sha": "6f49f847180526c3c7d7a8d59f55017486fd803d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f49f847180526c3c7d7a8d59f55017486fd803d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2588e44e0019aac9b55c974efd69885eea663f54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2588e44e0019aac9b55c974efd69885eea663f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2588e44e0019aac9b55c974efd69885eea663f54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2588e44e0019aac9b55c974efd69885eea663f54/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd9a5168344bc1d3621e263412e587d79969091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd9a5168344bc1d3621e263412e587d79969091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd9a5168344bc1d3621e263412e587d79969091"}], "stats": {"total": 1008, "additions": 651, "deletions": 357}, "files": [{"sha": "6f1718fbe5adebe984552ba22ba3a8124e28e669", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -1,3 +1,26 @@\n+2000-10-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (FMT_FLAG_ARG_CONVERT, FMT_FLAG_SCANF_A_KLUDGE,\n+\tFMT_FLAG_FANCY_PERCENT_OK): Define.\n+\t(format_char_info): Add flag \"4\" to comment.\n+\t(format_flag_spec, format_flag_pair): New structures.\n+\t(format_kind_info): Add additional fields to control format\n+\tchecking.\n+\t(printf_flag_specs, printf_flag_pairs, scanf_flag_specs,\n+\tscanf_flag_pairs, strftime_flag_specs, strftime_flag_pairs): New\n+\tarrays.\n+\t(time_char_table): Use \"4\" flag to handle %Ey.\n+\t(format_types): Add entries for new fields.\n+\t(get_flag_spec): New function.\n+\t(check_format_info): Increase size of flag_chars[] to 256.\n+\tControl format checking using the new fields of a format_kind_info\n+\tand the new tables; remove all conditionals on printf_format_type,\n+\tscanf_format_type or strftime_format_type.  Handle all details of\n+\tbad combinations of flags (including width, precision and strftime\n+\tmodifiers) through data rather than ad hoc code.  Handle all\n+\tdetails of standard versions in which flags appeared through\n+\tdata.  Use the \"4\" flag.\n+\n 2000-10-07  Will Cohen  <wcohen@redhat.com>, Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.md: Remove the memory alternative and correct"}, {"sha": "6ad83f78d77d05dafe9864b4ba6231a212cf2266", "filename": "gcc/c-common.c", "status": "modified", "additions": 519, "deletions": 260, "changes": 779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -1246,6 +1246,26 @@ enum format_std_version\n };\n \n \n+/* Flags that may apply to a particular kind of format checked by GCC.  */\n+enum\n+{\n+  /* This format converts arguments of types determined by the\n+     format string.  */\n+  FMT_FLAG_ARG_CONVERT = 1,\n+  /* The scanf allocation 'a' kludge applies to this format kind.  */\n+  FMT_FLAG_SCANF_A_KLUDGE = 2,\n+  /* A % during parsing a specifier is allowed to be a modified % rather\n+     that indicating the format is broken and we are out-of-sync.  */\n+  FMT_FLAG_FANCY_PERCENT_OK = 4\n+  /* Not included here: details of whether width or precision may occur\n+     (controlled by width_char and precision_char); details of whether\n+     '*' can be used for these (width_type and precision_type); details\n+     of whether length modifiers can occur (length_char_specs); details\n+     of when $ operand numbers are allowed (always, for the formats\n+     supported, if arguments are converted).  */\n+};\n+\n+\n /* Structure describing a length modifier supported in format checking, and\n    possibly a doubled version such as \"hh\".  */\n typedef struct\n@@ -1302,15 +1322,58 @@ typedef struct\n   /* List of additional flags describing these conversion specifiers.\n      \"c\" for generic character pointers being allowed, \"2\" for strftime\n      two digit year formats, \"3\" for strftime formats giving two digit\n-     years in some locales, \"o\" if use of strftime \"O\"\n-     is a GNU extension beyond C99, \"W\" if the argument is a pointer\n-     which is dereferenced and written into, \"i\" for printf integer\n-     formats where the '0' flag is ignored with precision, and \"[\"\n-     for the starting character of a scanf scanset.  */\n+     years in some locales, \"4\" for \"2\" which becomes \"3\" with an \"E\" modifier,\n+     \"o\" if use of strftime \"O\" is a GNU extension beyond C99,\n+     \"W\" if the argument is a pointer which is dereferenced and written into,\n+     \"i\" for printf integer formats where the '0' flag is ignored with\n+     precision, and \"[\" for the starting character of a scanf scanset.  */\n   const char *flags2;\n } format_char_info;\n \n \n+/* Structure describing a flag accepted by some kind of format.  */\n+typedef struct\n+{\n+  /* The flag character in question (0 for end of array).  */\n+  int flag_char;\n+  /* Zero if this entry describes the flag character in general, or a\n+     non-zero character that may be found in flags2 if it describes the\n+     flag when used with certain formats only.  If the latter, only\n+     the first such entry found that applies to the current conversion\n+     specifier is used; the values of `name' and `long_name' it supplies\n+     will be used, if non-NULL and the standard version is higher than\n+     the unpredicated one, for any pedantic warning.  For example, 'o'\n+     for strftime formats (meaning 'O' is an extension over C99).  */\n+  int predicate;\n+  /* The name to use for this flag in diagnostic messages.  For example,\n+     N_(\"`0' flag\"), N_(\"field width\").  */\n+  const char *name;\n+  /* Long name for this flag in diagnostic messages; currently only used for\n+     \"ISO C does not support ...\".  For example, N_(\"the `I' printf flag\").  */\n+  const char *long_name;\n+  /* The standard version in which it appeared.  */\n+  enum format_std_version std;\n+} format_flag_spec;\n+\n+\n+/* Structure describing a combination of flags that is bad for some kind\n+   of format.  */\n+typedef struct\n+{\n+  /* The first flag character in question (0 for end of array).  */\n+  int flag_char1;\n+  /* The second flag character.  */\n+  int flag_char2;\n+  /* Non-zero if the message should say that the first flag is ignored with\n+     the second, zero if the combination should simply be objected to.  */\n+  int ignored;\n+  /* Zero if this entry applies whenever this flag combination occurs,\n+     a non-zero character from flags2 if it only applies in some\n+     circumstances (e.g. 'i' for printf formats ignoring 0 with precision).  */\n+  int predicate;\n+} format_flag_pair;\n+\n+\n /* Structure describing a particular kind of format processed by GCC.  */\n typedef struct\n {\n@@ -1320,6 +1383,34 @@ typedef struct\n   const format_length_info *length_char_specs;\n   /* Details of the conversion specification characters accepted.  */\n   const format_char_info *conversion_specs;\n+  /* String listing the flag characters that are accepted.  */\n+  const char *flag_chars;\n+  /* String listing modifier characters (strftime) accepted.  May be NULL.  */\n+  const char *modifier_chars;\n+  /* Details of the flag characters, including pseudo-flags.  */\n+  const format_flag_spec *flag_specs;\n+  /* Details of bad combinations of flags.  */\n+  const format_flag_pair *bad_flag_pairs;\n+  /* Flags applicable to this kind of format.  */\n+  int flags;\n+  /* Flag character to treat a width as, or 0 if width not used.  */\n+  int width_char;\n+  /* Flag character to treat a precision as, or 0 if precision not used.  */\n+  int precision_char;\n+  /* If a flag character has the effect of suppressing the conversion of\n+     an argument ('*' in scanf), that flag character, otherwise 0.  */\n+  int suppression_char;\n+  /* Flag character to treat a length modifier as (ignored if length\n+     modifiers not used).  Need not be placed in flag_chars for conversion\n+     specifiers, but is used to check for bad combinations such as length\n+     modifier with assignment suppression in scanf.  */\n+  int length_code_char;\n+  /* Pointer to type of argument expected if '*' is used for a width,\n+     or NULL if '*' not used for widths.  */\n+  tree *width_type;\n+  /* Pointer to type of argument expected if '*' is used for a precision,\n+     or NULL if '*' not used for precisions.  */\n+  tree *precision_type;\n } format_kind_info;\n \n \n@@ -1383,6 +1474,70 @@ static const format_length_info scanf_length_specs[] =\n };\n \n \n+static const format_flag_spec printf_flag_specs[] =\n+{\n+  { ' ',  0, N_(\"` ' flag\"),        N_(\"the ` ' printf flag\"),              STD_C89 },\n+  { '+',  0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n+  { '#',  0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n+  { '0',  0, N_(\"`0' flag\"),        N_(\"the `0' printf flag\"),              STD_C89 },\n+  { '-',  0, N_(\"`-' flag\"),        N_(\"the `-' printf flag\"),              STD_C89 },\n+  { '\\'', 0, N_(\"`'' flag\"),        N_(\"the `'' printf flag\"),              STD_EXT },\n+  { 'I',  0, N_(\"`I' flag\"),        N_(\"the `I' printf flag\"),              STD_EXT },\n+  { 'w',  0, N_(\"field width\"),     N_(\"field width in printf format\"),     STD_C89 },\n+  { 'p',  0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n+  { 'L',  0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n+  { 0, 0, NULL, NULL, 0 }\n+};\n+\n+\n+static const format_flag_pair printf_flag_pairs[] =\n+{\n+  { ' ', '+', 1, 0   },\n+  { '0', '-', 1, 0   },\n+  { '0', 'p', 1, 'i' },\n+  { 0, 0, 0, 0 }\n+};\n+\n+\n+static const format_flag_spec scanf_flag_specs[] =\n+{\n+  { '*', 0, N_(\"assignment suppression\"), N_(\"assignment suppression\"),          STD_C89 },\n+  { 'a', 0, N_(\"`a' flag\"),               N_(\"the `a' scanf flag\"),              STD_EXT },\n+  { 'w', 0, N_(\"field width\"),            N_(\"field width in scanf format\"),     STD_C89 },\n+  { 'L', 0, N_(\"length modifier\"),        N_(\"length modifier in scanf format\"), STD_C89 },\n+  { 0, 0, NULL, NULL, 0 }\n+};\n+\n+\n+static const format_flag_pair scanf_flag_pairs[] =\n+{\n+  { '*', 'L', 0, 0 },\n+  { 0, 0, 0, 0 }\n+};\n+\n+\n+static const format_flag_spec strftime_flag_specs[] =\n+{\n+  { '_', 0,   N_(\"`_' flag\"),     N_(\"the `_' strftime flag\"),          STD_EXT },\n+  { '-', 0,   N_(\"`-' flag\"),     N_(\"the `-' strftime flag\"),          STD_EXT },\n+  { '0', 0,   N_(\"`0' flag\"),     N_(\"the `0' strftime flag\"),          STD_EXT },\n+  { '^', 0,   N_(\"`^' flag\"),     N_(\"the `^' strftime flag\"),          STD_EXT },\n+  { '#', 0,   N_(\"`#' flag\"),     N_(\"the `#' strftime flag\"),          STD_EXT },\n+  { 'w', 0,   N_(\"field width\"),  N_(\"field width in strftime format\"), STD_EXT },\n+  { 'E', 0,   N_(\"`E' modifier\"), N_(\"the `E' strftime modifier\"),      STD_C99 },\n+  { 'O', 0,   N_(\"`O' modifier\"), N_(\"the `O' strftime modifier\"),      STD_C99 },\n+  { 'O', 'o', NULL,               N_(\"the `O' modifier\"),               STD_EXT },\n+  { 0, 0, NULL, NULL, 0 }\n+};\n+\n+\n+static const format_flag_pair strftime_flag_pairs[] =\n+{\n+  { 'E', 'O', 0, 0 },\n+  { 0, 0, 0, 0 }\n+};\n+\n+\n #define T_I\t&integer_type_node\n #define T89_I\t{ STD_C89, NULL, T_I }\n #define T99_I\t{ STD_C99, NULL, T_I }\n@@ -1490,7 +1645,7 @@ static format_char_info time_char_table[] =\n   { \"j\",\t\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"o\"  },\n   { \"p\",\t\t0, STD_C89, NOLENGTHS, \"#\",      \"\"   },\n   { \"X\",\t\t0, STD_C89, NOLENGTHS, \"E\",      \"\"   },\n-  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"2\"  },\n+  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"4\"  },\n   { \"Y\",\t\t0, STD_C89, NOLENGTHS, \"-_0EOw\", \"o\"  },\n   { \"%\",\t\t0, STD_C89, NOLENGTHS, \"\",       \"\"   },\n   /* C99 conversion specifiers.  */\n@@ -1512,9 +1667,21 @@ static format_char_info time_char_table[] =\n /* This must be in the same order as enum format_type.  */\n static const format_kind_info format_types[] =\n {\n-  { \"printf\",   printf_length_specs, print_char_table },\n-  { \"scanf\",    scanf_length_specs,  scan_char_table  },\n-  { \"strftime\", NULL,                time_char_table  }\n+  { \"printf\",   printf_length_specs, print_char_table, \" +#0-'I\", NULL, \n+    printf_flag_specs, printf_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT, 'w', 'p', 0, 'L',\n+    &integer_type_node, &integer_type_node\n+  },\n+  { \"scanf\",    scanf_length_specs,  scan_char_table,  \"*\", NULL, \n+    scanf_flag_specs, scanf_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE, 'w', 0, '*', 'L',\n+    NULL, NULL\n+  },\n+  { \"strftime\", NULL,                time_char_table,  \"_-0^#\", \"EO\",\n+    strftime_flag_specs, strftime_flag_pairs,\n+    FMT_FLAG_FANCY_PERCENT_OK, 'w', 0, 0, 0,\n+    NULL, NULL\n+  }\n };\n \n \n@@ -1549,6 +1716,9 @@ static int maybe_read_dollar_number\t\tPARAMS ((int *, const char **, int,\n \t\t\t\t\t\t\t tree, tree *));\n static void finish_dollar_format_checking\tPARAMS ((int *));\n \n+static const format_flag_spec *get_flag_spec\tPARAMS ((const format_flag_spec *,\n+\t\t\t\t\t\t\t int, const char *));\n+\n static void check_format_types\tPARAMS ((int *, format_wanted_type *));\n static int is_valid_printf_arglist PARAMS ((tree));\n static rtx c_expand_builtin (tree, rtx, enum machine_mode, enum expand_modifier);\n@@ -1928,6 +2098,41 @@ finish_dollar_format_checking (status)\n }\n \n \n+/* Retrieve the specification for a format flag.  SPEC contains the\n+   specifications for format flags for the applicable kind of format.\n+   FLAG is the flag in question.  If PREDICATES is NULL, the basic\n+   spec for that flag must be retrieved and this function aborts if\n+   it cannot be found.  If PREDICATES is not NULL, it is a string listing\n+   possible predicates for the spec entry; if an entry predicated on any\n+   of these is found, it is returned, otherwise NULL is returned.  */\n+\n+static const format_flag_spec *\n+get_flag_spec (spec, flag, predicates)\n+     const format_flag_spec *spec;\n+     int flag;\n+     const char *predicates;\n+{\n+  int i;\n+  for (i = 0; spec[i].flag_char != 0; i++)\n+    {\n+      if (spec[i].flag_char != flag)\n+\tcontinue;\n+      if (predicates != NULL)\n+\t{\n+\t  if (spec[i].predicate != 0\n+\t      && index (predicates, spec[i].predicate) != 0)\n+\t    return &spec[i];\n+\t}\n+      else if (spec[i].predicate == 0)\n+\treturn &spec[i];\n+    }\n+  if (predicates == NULL)\n+    abort ();\n+  else\n+    return NULL;\n+}\n+\n+\n /* Check the argument list of a call to printf, scanf, etc.\n    INFO points to the function_format_info structure.\n    PARAMS is the list of argument values.  */\n@@ -1940,7 +2145,7 @@ check_format_info (status, info, params)\n {\n   int i;\n   int arg_num;\n-  int suppressed, wide, precise;\n+  int suppressed;\n   const char *length_chars = NULL;\n   enum format_lengths length_chars_val = FMT_LEN_none;\n   enum format_std_version length_chars_std = STD_C89;\n@@ -1961,9 +2166,11 @@ check_format_info (status, info, params)\n   tree first_fillin_param;\n   const char *format_chars;\n   const format_kind_info *fki = NULL;\n+  const format_flag_spec *flag_specs = NULL;\n+  const format_flag_pair *bad_flag_pairs = NULL;\n   const format_length_info *fli = NULL;\n   const format_char_info *fci = NULL;\n-  char flag_chars[8];\n+  char flag_chars[256];\n   /* -1 if no conversions taking an operand have been found; 0 if one has\n      and it didn't use $; 1 if $ formats are in use.  */\n   int has_operand_number = -1;\n@@ -2073,6 +2280,8 @@ check_format_info (status, info, params)\n   first_fillin_param = params;\n   init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n   fki = &format_types[info->format_type];\n+  flag_specs = fki->flag_specs;\n+  bad_flag_pairs = fki->bad_flag_pairs;\n   while (1)\n     {\n       int aflag;\n@@ -2102,127 +2311,57 @@ check_format_info (status, info, params)\n \t  continue;\n \t}\n       flag_chars[0] = 0;\n-      suppressed = wide = precise = FALSE;\n+      suppressed = FALSE;\n       main_arg_num = 0;\n       main_arg_params = 0;\n-      if (info->format_type == scanf_format_type)\n+\n+      if ((fki->flags & FMT_FLAG_ARG_CONVERT) && has_operand_number != 0)\n \t{\n-\t  int non_zero_width_char = FALSE;\n-\t  suppressed = *format_chars == '*';\n-\t  if (suppressed)\n-\t    ++format_chars;\n-\t  else if (has_operand_number != 0)\n+\t  /* Possibly read a $ operand number at the start of the format.\n+\t     If one was previously used, one is required here.  If one\n+\t     is not used here, we can't immediately conclude this is a\n+\t     format without them, since it could be printf %m or scanf %*.  */\n+\t  int opnum;\n+\t  opnum = maybe_read_dollar_number (status, &format_chars, 0,\n+\t\t\t\t\t    first_fillin_param,\n+\t\t\t\t\t    &main_arg_params);\n+\t  if (opnum == -1)\n+\t    return;\n+\t  else if (opnum > 0)\n \t    {\n-\t      int opnum;\n-\t      opnum = maybe_read_dollar_number (status, &format_chars,\n-\t\t\t\t\t\thas_operand_number == 1,\n-\t\t\t\t\t\tfirst_fillin_param,\n-\t\t\t\t\t\t&main_arg_params);\n-\t      if (opnum == -1)\n-\t\treturn;\n-\t      else if (opnum > 0)\n-\t\t{\n-\t\t  has_operand_number = 1;\n-\t\t  main_arg_num = opnum + info->first_arg_num - 1;\n-\t\t}\n-\t      else\n-\t\thas_operand_number = 0;\n-\t    }\n-\t  while (ISDIGIT (*format_chars))\n-\t    {\n-\t      wide = TRUE;\n-\t      if (*format_chars != '0')\n-\t\tnon_zero_width_char = TRUE;\n-\t      ++format_chars;\n+\t      has_operand_number = 1;\n+\t      main_arg_num = opnum + info->first_arg_num - 1;\n \t    }\n-\t  if (wide && !non_zero_width_char)\n-\t    status_warning (status, \"zero width in scanf format\");\n \t}\n-      else if (info->format_type == strftime_format_type)\n-        {\n-\t  while (*format_chars != 0 && index (\"_-0^#\", *format_chars) != 0)\n-\t    {\n-\t      if (pedantic)\n-\t\tstatus_warning (status, \"ISO C does not support the strftime `%c' flag\",\n-\t\t\t *format_chars);\n-\t      if (index (flag_chars, *format_chars) != 0)\n-\t\t{\n-\t\t  status_warning (status, \"repeated `%c' flag in format\",\n-\t\t\t   *format_chars);\n-\t\t  ++format_chars;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = *format_chars++;\n-\t\t  flag_chars[i] = 0;\n-\t\t}\n-\t    }\n-\t  while (ISDIGIT ((unsigned char) *format_chars))\n+\n+      /* Read any format flags, but do not yet validate them beyond removing\n+\t duplicates, since in general validation depends on the rest of\n+\t the format.  */\n+      while (*format_chars != 0 && index (fki->flag_chars, *format_chars) != 0)\n+\t{\n+\t  if (index (flag_chars, *format_chars) != 0)\n \t    {\n-\t      wide = TRUE;\n-              ++format_chars;\n+\t      const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t\t *format_chars, NULL);\n+\t      status_warning (status, \"repeated %s in format\", _(s->name));\n \t    }\n-\t  if (wide && pedantic)\n-\t    status_warning (status, \"ISO C does not support strftime format width\");\n-\t  if (*format_chars == 'E' || *format_chars == 'O')\n+\t  else\n \t    {\n \t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = *format_chars++;\n+\t      flag_chars[i++] = *format_chars;\n \t      flag_chars[i] = 0;\n-\t      if (*format_chars == 'E' || *format_chars == 'O')\n-\t        {\n-\t\t  status_warning (status, \"multiple E/O modifiers in format\");\n-\t\t  while (*format_chars == 'E' || *format_chars == 'O')\n-\t\t    ++format_chars;\n-\t\t}\n \t    }\n+\t  ++format_chars;\n \t}\n-      else if (info->format_type == printf_format_type)\n-\t{\n-\t  if (has_operand_number != 0)\n-\t    {\n-\t      int opnum;\n-\t      opnum = maybe_read_dollar_number (status, &format_chars,\n-\t\t\t\t\t\t0, first_fillin_param,\n-\t\t\t\t\t\t&main_arg_params);\n-\t      if (opnum == -1)\n-\t\treturn;\n-\t      else if (opnum > 0)\n-\t\t{\n-\t\t  has_operand_number = 1;\n-\t\t  main_arg_num = opnum + info->first_arg_num - 1;\n-\t\t}\n-\t    }\n \n-\t  while (*format_chars != 0 && index (\" +#0-'I\", *format_chars) != 0)\n-\t    {\n-\t      if (index (flag_chars, *format_chars) != 0)\n-\t\tstatus_warning (status, \"repeated `%c' flag in format\", *format_chars++);\n-\t      else\n-\t\t{\n-\t\t  i = strlen (flag_chars);\n-\t\t  flag_chars[i++] = *format_chars++;\n-\t\t  flag_chars[i] = 0;\n-\t\t}\n-\t    }\n-\t  /* \"If the space and + flags both appear,\n-\t     the space flag will be ignored.\"  */\n-\t  if (index (flag_chars, ' ') != 0\n-\t      && index (flag_chars, '+') != 0)\n-\t    status_warning (status, \"use of both ` ' and `+' flags in format\");\n-\t  /* \"If the 0 and - flags both appear,\n-\t     the 0 flag will be ignored.\"  */\n-\t  if (index (flag_chars, '0') != 0\n-\t      && index (flag_chars, '-') != 0)\n-\t    status_warning (status, \"use of both `0' and `-' flags in format\");\n-\t  if (index (flag_chars, '\\'') && pedantic)\n-\t    status_warning (status, \"ISO C does not support the `'' format flag\");\n-\t  if (index (flag_chars, 'I') && pedantic)\n-\t    status_warning (status, \"ISO C does not support the `I' format flag\");\n-\t  if (*format_chars == '*')\n+      /* Read any format width, possibly * or *m$.  */\n+      if (fki->width_char != 0)\n+\t{\n+\t  if (fki->width_type != NULL && *format_chars == '*')\n \t    {\n-\t      wide = TRUE;\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = fki->width_char;\n+\t      flag_chars[i] = 0;\n \t      /* \"...a field width...may be indicated by an asterisk.\n \t\t In this case, an int argument supplies the field width...\"  */\n \t      ++format_chars;\n@@ -2256,7 +2395,7 @@ check_format_info (status, info, params)\n \t\t      params = TREE_CHAIN (params);\n \t\t      ++arg_num;\n \t\t    }\n-\t\t  width_wanted_type.wanted_type = integer_type_node;\n+\t\t  width_wanted_type.wanted_type = *fki->width_type;\n \t\t  width_wanted_type.wanted_type_name = NULL;\n \t\t  width_wanted_type.pointer_count = 0;\n \t\t  width_wanted_type.char_lenient_flag = 0;\n@@ -2274,78 +2413,100 @@ check_format_info (status, info, params)\n \t    }\n \t  else\n \t    {\n+\t      /* Possibly read a numeric width.  If the width is zero,\n+\t\t we complain; for scanf this is bad according to the\n+\t\t standard, and for printf and strftime it cannot occur\n+\t\t because 0 is a flag.  */\n+\t      int non_zero_width_char = FALSE;\n+\t      int found_width = FALSE;\n \t      while (ISDIGIT (*format_chars))\n \t\t{\n-\t\t  wide = TRUE;\n+\t\t  found_width = TRUE;\n+\t\t  if (*format_chars != '0')\n+\t\t    non_zero_width_char = TRUE;\n \t\t  ++format_chars;\n \t\t}\n+\t      if (found_width && !non_zero_width_char)\n+\t\tstatus_warning (status, \"zero width in scanf format\");\n+\t      if (found_width)\n+\t\t{\n+\t\t  i = strlen (flag_chars);\n+\t\t  flag_chars[i++] = fki->width_char;\n+\t\t  flag_chars[i] = 0;\n+\t\t}\n \t    }\n-\t  if (*format_chars == '.')\n+\t}\n+\n+      /* Read any format precision, possibly * or *m$.  */\n+      if (fki->precision_char != 0 && *format_chars == '.')\n+\t{\n+\t  ++format_chars;\n+\t  i = strlen (flag_chars);\n+\t  flag_chars[i++] = fki->precision_char;\n+\t  flag_chars[i] = 0;\n+\t  if (fki->precision_type != NULL && *format_chars == '*')\n \t    {\n-\t      precise = TRUE;\n-\t      ++format_chars;\n \t      /* \"...a...precision...may be indicated by an asterisk.\n \t\t In this case, an int argument supplies the...precision.\"  */\n-\t      if (*format_chars == '*')\n+\t      ++format_chars;\n+\t      if (has_operand_number != 0)\n \t\t{\n-\t\t  ++format_chars;\n-\t\t  if (has_operand_number != 0)\n-\t\t    {\n-\t\t      int opnum;\n-\t\t      opnum = maybe_read_dollar_number (status, &format_chars,\n-\t\t\t\t\t\t\thas_operand_number == 1,\n-\t\t\t\t\t\t\tfirst_fillin_param,\n-\t\t\t\t\t\t\t&params);\n-\t\t      if (opnum == -1)\n-\t\t\treturn;\n-\t\t      else if (opnum > 0)\n-\t\t\t{\n-\t\t\t  has_operand_number = 1;\n-\t\t\t  arg_num = opnum + info->first_arg_num - 1;\n-\t\t\t}\n-\t\t      else\n-\t\t\thas_operand_number = 0;\n-\t\t    }\n-\t\t  if (info->first_arg_num != 0)\n+\t\t  int opnum;\n+\t\t  opnum = maybe_read_dollar_number (status, &format_chars,\n+\t\t\t\t\t\t    has_operand_number == 1,\n+\t\t\t\t\t\t    first_fillin_param,\n+\t\t\t\t\t\t    &params);\n+\t\t  if (opnum == -1)\n+\t\t    return;\n+\t\t  else if (opnum > 0)\n \t\t    {\n-\t\t      if (params == 0)\n-\t\t        {\n-\t\t\t  status_warning (status, \"too few arguments for format\");\n-\t\t\t  return;\n-\t\t\t}\n-\t\t      cur_param = TREE_VALUE (params);\n-\t\t      if (has_operand_number <= 0)\n-\t\t\t{\n-\t\t\t  params = TREE_CHAIN (params);\n-\t\t\t  ++arg_num;\n-\t\t\t}\n-\t\t      precision_wanted_type.wanted_type = integer_type_node;\n-\t\t      precision_wanted_type.wanted_type_name = NULL;\n-\t\t      precision_wanted_type.pointer_count = 0;\n-\t\t      precision_wanted_type.char_lenient_flag = 0;\n-\t\t      precision_wanted_type.writing_in_flag = 0;\n-\t\t      precision_wanted_type.name = _(\"field precision\");\n-\t\t      precision_wanted_type.param = cur_param;\n-\t\t      precision_wanted_type.arg_num = arg_num;\n-\t\t      precision_wanted_type.next = NULL;\n-\t\t      if (last_wanted_type != 0)\n-\t\t\tlast_wanted_type->next = &precision_wanted_type;\n-\t\t      if (first_wanted_type == 0)\n-\t\t\tfirst_wanted_type = &precision_wanted_type;\n-\t\t      last_wanted_type = &precision_wanted_type;\n+\t\t      has_operand_number = 1;\n+\t\t      arg_num = opnum + info->first_arg_num - 1;\n \t\t    }\n+\t\t  else\n+\t\t    has_operand_number = 0;\n \t\t}\n-\t      else\n+\t      if (info->first_arg_num != 0)\n \t\t{\n-\t\t  while (ISDIGIT (*format_chars))\n-\t\t    ++format_chars;\n+\t\t  if (params == 0)\n+\t\t    {\n+\t\t      status_warning (status, \"too few arguments for format\");\n+\t\t      return;\n+\t\t    }\n+\t\t  cur_param = TREE_VALUE (params);\n+\t\t  if (has_operand_number <= 0)\n+\t\t    {\n+\t\t      params = TREE_CHAIN (params);\n+\t\t      ++arg_num;\n+\t\t    }\n+\t\t  precision_wanted_type.wanted_type = *fki->precision_type;\n+\t\t  precision_wanted_type.wanted_type_name = NULL;\n+\t\t  precision_wanted_type.pointer_count = 0;\n+\t\t  precision_wanted_type.char_lenient_flag = 0;\n+\t\t  precision_wanted_type.writing_in_flag = 0;\n+\t\t  precision_wanted_type.name = _(\"field precision\");\n+\t\t  precision_wanted_type.param = cur_param;\n+\t\t  precision_wanted_type.arg_num = arg_num;\n+\t\t  precision_wanted_type.next = NULL;\n+\t\t  if (last_wanted_type != 0)\n+\t\t    last_wanted_type->next = &precision_wanted_type;\n+\t\t  if (first_wanted_type == 0)\n+\t\t    first_wanted_type = &precision_wanted_type;\n+\t\t  last_wanted_type = &precision_wanted_type;\n \t\t}\n \t    }\n+\t  else\n+\t    {\n+\t      while (ISDIGIT (*format_chars))\n+\t\t++format_chars;\n+\t    }\n \t}\n \n-      aflag = 0;\n-\n+      /* Read any length modifier, if this kind of format has them.  */\n       fli = fki->length_char_specs;\n+      length_chars = NULL;\n+      length_chars_val = FMT_LEN_none;\n+      length_chars_std = STD_C89;\n       if (fli)\n \t{\n \t  while (fli->name != 0 && fli->name[0] != *format_chars)\n@@ -2366,12 +2527,9 @@ check_format_info (status, info, params)\n \t\t  length_chars_val = fli->index;\n \t\t  length_chars_std = fli->std;\n \t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      length_chars = NULL;\n-\t      length_chars_val = FMT_LEN_none;\n-\t      length_chars_std = STD_C89;\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = fki->length_code_char;\n+\t      flag_chars[i] = 0;\n \t    }\n \t  if (pedantic)\n \t    {\n@@ -2384,23 +2542,50 @@ check_format_info (status, info, params)\n \t\tstatus_warning (status, \"ISO C89 does not support the `%s' %s length modifier\",\n \t\t\t length_chars, fki->name);\n \t    }\n-\t  if (*format_chars == 'a' && info->format_type == scanf_format_type\n-\t      && !flag_isoc99)\n+\t}\n+\n+      /* Read any modifier (strftime E/O).  */\n+      if (fki->modifier_chars != NULL)\n+\t{\n+\t  while (*format_chars != 0\n+\t\t && index (fki->modifier_chars, *format_chars) != 0)\n+\t    {\n+\t      if (index (flag_chars, *format_chars) != 0)\n+\t\t{\n+\t\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t\t     *format_chars, NULL);\n+\t\t  status_warning (status, \"repeated %s in format\", _(s->name));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  i = strlen (flag_chars);\n+\t\t  flag_chars[i++] = *format_chars;\n+\t\t  flag_chars[i] = 0;\n+\t\t}\n+\t      ++format_chars;\n+\t    }\n+\t}\n+\n+      /* Handle the scanf allocation kludge.  */\n+      if (fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n+\t{\n+\t  if (*format_chars == 'a' && !flag_isoc99)\n \t    {\n \t      if (format_chars[1] == 's' || format_chars[1] == 'S'\n \t\t  || format_chars[1] == '[')\n \t\t{\n \t\t  /* `a' is used as a flag.  */\n-\t\t  aflag = 1;\n+\t\t  i = strlen (flag_chars);\n+\t\t  flag_chars[i++] = 'a';\n+\t\t  flag_chars[i] = 0;\n \t\t  format_chars++;\n \t\t}\n \t    }\n-\t  if (suppressed && length_chars_val != FMT_LEN_none)\n-\t    status_warning (status, \"use of `*' and `%s' together in format\", length_chars);\n \t}\n+\n       format_char = *format_chars;\n       if (format_char == 0\n-\t  || (info->format_type != strftime_format_type && format_char == '%'))\n+\t  || (!(fki->flags & FMT_FLAG_FANCY_PERCENT_OK) && format_char == '%'))\n \t{\n \t  status_warning (status, \"conversion lacks type at end of format\");\n \t  continue;\n@@ -2429,35 +2614,117 @@ check_format_info (status, info, params)\n \t\t   || (fci->std == STD_C94 && !flag_isoc94))\n \t    status_warning (status, \"ISO C89 does not support the `%%%c' %s format\",\n \t\t     format_char, fki->name);\n-\t  if (index (flag_chars, 'O') != 0)\n-\t    {\n-\t      if (index (fci->flags2, 'o') != 0)\n-\t\tstatus_warning (status, \"ISO C does not support `%%O%c'\", format_char);\n-\t      else if (!flag_isoc99 && index (fci->flag_chars, 'O') != 0)\n-\t\tstatus_warning (status, \"ISO C89 does not support `%%O%c'\", format_char);\n-\t    }\n-\t  if (!flag_isoc99 && index (flag_chars, 'E'))\n-\t    status_warning (status, \"ISO C89 does not support `%%E%c'\", format_char);\n \t}\n-      if (wide && index (fci->flag_chars, 'w') == 0)\n-\tstatus_warning (status, \"width used with `%c' format\", format_char);\n-      if (index (fci->flags2, '3') != 0\n-\t  || (format_char == 'y' && index (flag_chars, 'E')))\n-\tstatus_warning (status, \"`%%%c' yields only last 2 digits of year in some locales\",\n-\t\t format_char);\n-      else if (index (fci->flags2, '2') != 0)\n-\tstatus_warning (status, \"`%%%c' yields only last 2 digits of year\", format_char);\n-      if (precise && index (fci->flag_chars, 'p') == 0)\n-\tstatus_warning (status, \"precision used with `%c' format\", format_char);\n-      if (aflag && index (fci->flag_chars, 'a') == 0)\n+\n+      /* Validate the individual flags used, removing any that are invalid.  */\n+      {\n+\tint d = 0;\n+\tfor (i = 0; flag_chars[i] != 0; i++)\n+\t  {\n+\t    const format_flag_spec *s = get_flag_spec (flag_specs,\n+\t\t\t\t\t\t       flag_chars[i], NULL);\n+\t    flag_chars[i - d] = flag_chars[i];\n+\t    if (flag_chars[i] == fki->length_code_char)\n+\t      continue;\n+\t    if (index (fci->flag_chars, flag_chars[i]) == 0)\n+\t      {\n+\t\tstatus_warning (status, \"%s used with `%%%c' %s format\",\n+\t\t\t\t_(s->name), format_char, fki->name);\n+\t\td++;\n+\t\tcontinue;\n+\t      }\n+\t    if (pedantic)\n+\t      {\n+\t\tconst format_flag_spec *t;\n+\t\tif (s->std == STD_EXT)\n+\t\t  status_warning (status, \"ISO C does not support %s\",\n+\t\t\t\t  _(s->long_name));\n+\t\telse if ((s->std == STD_C99 && !flag_isoc99)\n+\t\t\t || (s->std == STD_C94 && !flag_isoc94))\n+\t\t  status_warning (status, \"ISO C89 does not support %s\",\n+\t\t\t\t  _(s->long_name));\n+\t\tt = get_flag_spec (flag_specs, flag_chars[i], fci->flags2);\n+\t\tif (t != NULL && t->std > s->std)\n+\t\t  {\n+\t\t    const char *long_name = (t->long_name != NULL\n+\t\t\t\t\t     ? t->long_name\n+\t\t\t\t\t     : s->long_name);\n+\t\t    if (t->std == STD_EXT)\n+\t\t      status_warning (status, \"ISO C does not support %s with the `%%%c' %s format\",\n+\t\t\t\t      _(long_name), format_char, fki->name);\n+\t\t    else if ((t->std == STD_C99 && !flag_isoc99)\n+\t\t\t     || (t->std == STD_C94 && !flag_isoc94))\n+\t\t      status_warning (status, \"ISO C89 does not support %s with the `%%%c' %s format\",\n+\t\t\t\t      _(long_name), format_char, fki->name);\n+\t\t  }\n+\t      }\n+\t  }\n+\tflag_chars[i - d] = 0;\n+      }\n+\n+      aflag = 0;\n+      if ((fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n+\t  && index (flag_chars, 'a') != 0)\n+\taflag = 1;\n+\n+      if (fki->suppression_char\n+\t  && index (flag_chars, fki->suppression_char) != 0)\n+\tsuppressed = 1;\n+\n+      /* Validate the pairs of flags used.  */\n+      for (i = 0; bad_flag_pairs[i].flag_char1 != 0; i++)\n \t{\n-\t  status_warning (status, \"`a' flag used with `%c' format\", format_char);\n-\t  /* To simplify the following code.  */\n-\t  aflag = 0;\n+\t  const format_flag_spec *s, *t;\n+\t  if (index (flag_chars, bad_flag_pairs[i].flag_char1) == 0)\n+\t    continue;\n+\t  if (index (flag_chars, bad_flag_pairs[i].flag_char2) == 0)\n+\t    continue;\n+\t  if (bad_flag_pairs[i].predicate != 0\n+\t      && index (fci->flags2, bad_flag_pairs[i].predicate) == 0)\n+\t    continue;\n+\t  s = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char1, NULL);\n+\t  t = get_flag_spec (flag_specs, bad_flag_pairs[i].flag_char2, NULL);\n+\t  if (bad_flag_pairs[i].ignored)\n+\t    {\n+\t      if (bad_flag_pairs[i].predicate != 0)\n+\t\tstatus_warning (status, \"%s ignored with %s and `%%%c' %s format\",\n+\t\t\t\t_(s->name), _(t->name), format_char,\n+\t\t\t\tfki->name);\n+\t      else\n+\t\tstatus_warning (status, \"%s ignored with %s in %s format\",\n+\t\t\t\t_(s->name), _(t->name), fki->name);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (bad_flag_pairs[i].predicate != 0)\n+\t\tstatus_warning (status, \"use of %s and %s together with `%%%c' %s format\",\n+\t\t\t\t_(s->name), _(t->name), format_char,\n+\t\t\t\tfki->name);\n+\t      else\n+\t\tstatus_warning (status, \"use of %s and %s together in %s format\",\n+\t\t\t\t_(s->name), _(t->name), fki->name);\n+\t    }\n \t}\n-      /* The a flag is a GNU extension.  */\n-      else if (pedantic && aflag)\n-\tstatus_warning (status, \"ISO C does not support the `a' flag\");\n+\n+      /* Give Y2K warnings.  */\n+      {\n+\tint y2k_level = 0;\n+\tif (index (fci->flags2, '4') != 0)\n+\t  if (index (flag_chars, 'E') != 0)\n+\t    y2k_level = 3;\n+\t  else\n+\t    y2k_level = 2;\n+\telse if (index (fci->flags2, '3') != 0)\n+\t  y2k_level = 3;\n+\telse if (index (fci->flags2, '2') != 0)\n+\t  y2k_level = 2;\n+\tif (y2k_level == 3)\n+\t  status_warning (status, \"`%%%c' yields only last 2 digits of year in some locales\",\n+\t\t\t  format_char);\n+\telse if (y2k_level == 2)\n+\t  status_warning (status, \"`%%%c' yields only last 2 digits of year\", format_char);\n+      }\n+\n       if (index (fci->flags2, '[') != 0)\n \t{\n \t  /* Skip over scan set, in case it happens to have '%' in it.  */\n@@ -2473,66 +2740,58 @@ check_format_info (status, info, params)\n \t    /* The end of the format string was reached.  */\n \t    status_warning (status, \"no closing `]' for `%%[' format\");\n \t}\n-      if (suppressed)\n-\t{\n-\t  if (index (fci->flag_chars, '*') == 0)\n-\t    status_warning (status, \"suppression of `%c' conversion in format\", format_char);\n-\t  continue;\n-\t}\n-      for (i = 0; flag_chars[i] != 0; ++i)\n-\t{\n-\t  if (index (fci->flag_chars, flag_chars[i]) == 0)\n-\t    status_warning (status, \"flag `%c' used with type `%c'\",\n-\t\t     flag_chars[i], format_char);\n-\t}\n-      if (info->format_type == strftime_format_type)\n-\tcontinue;\n-      if (precise && index (flag_chars, '0') != 0\n-\t  && (index (fci->flags2, 'i') != 0))\n-\tstatus_warning (status, \"`0' flag ignored with precision specifier and `%c' format\",\n-\t\t format_char);\n-      wanted_type = (fci->types[length_chars_val].type\n-\t\t     ? *fci->types[length_chars_val].type : 0);\n-      wanted_type_name = fci->types[length_chars_val].name;\n-      wanted_type_std = fci->types[length_chars_val].std;\n-      if (wanted_type == 0)\n+\n+      if (fki->flags & FMT_FLAG_ARG_CONVERT)\n \t{\n-\t  status_warning (status, \"use of `%s' length modifier with `%c' type character\",\n-\t\t   length_chars, format_char);\n-\t  /* Heuristic: skip one argument when an invalid length/type\n-\t     combination is encountered.  */\n-\t  arg_num++;\n-\t  if (params == 0)\n+\t  wanted_type = (fci->types[length_chars_val].type\n+\t\t\t ? *fci->types[length_chars_val].type : 0);\n+\t  wanted_type_name = fci->types[length_chars_val].name;\n+\t  wanted_type_std = fci->types[length_chars_val].std;\n+\t  if (wanted_type == 0)\n+\t    {\n+\t      status_warning (status, \"use of `%s' length modifier with `%c' type character\",\n+\t\t\t      length_chars, format_char);\n+\t      /* Heuristic: skip one argument when an invalid length/type\n+\t\t combination is encountered.  */\n+\t      arg_num++;\n+\t      if (params == 0)\n+\t\t{\n+\t\t  status_warning (status, \"too few arguments for format\");\n+\t\t  return;\n+\t\t}\n+\t      params = TREE_CHAIN (params);\n+\t      continue;\n+\t    }\n+\t  else if (pedantic\n+\t\t   /* Warn if non-standard, provided it is more non-standard\n+\t\t      than the length and type characters that may already\n+\t\t      have been warned for.  */\n+\t\t   && wanted_type_std > length_chars_std\n+\t\t   && wanted_type_std > fci->std)\n \t    {\n-\t      status_warning (status, \"too few arguments for format\");\n-\t      return;\n+\t      if (wanted_type_std == STD_EXT)\n+\t\tstatus_warning (status, \"ISO C does not support the `%%%s%c' %s format\",\n+\t\t\t\tlength_chars, format_char, fki->name);\n+\t      else if ((wanted_type_std == STD_C99 && !flag_isoc99)\n+\t\t       || (wanted_type_std == STD_C94 && !flag_isoc94))\n+\t\tstatus_warning (status, \"ISO C89 does not support the `%%%s%c' %s format\",\n+\t\t\t\tlength_chars, format_char, fki->name);\n \t    }\n-\t  params = TREE_CHAIN (params);\n-\t  continue;\n-\t}\n-      else if (pedantic\n-\t       /* Warn if non-standard, provided it is more non-standard\n-\t\t  than the length and type characters that may already\n-\t\t  have been warned for.  */\n-\t       && wanted_type_std > length_chars_std\n-\t       && wanted_type_std > fci->std)\n-\t{\n-\t  if (wanted_type_std == STD_EXT)\n-\t    status_warning (status, \"ISO C does not support the `%%%s%c' %s format\",\n-\t\t     length_chars, format_char, fki->name);\n-\t  else if ((wanted_type_std == STD_C99 && !flag_isoc99)\n-\t\t   || (wanted_type_std == STD_C94 && !flag_isoc94))\n-\t    status_warning (status, \"ISO C89 does not support the `%%%s%c' %s format\",\n-\t\t     length_chars, format_char, fki->name);\n \t}\n \n       /* Finally. . .check type of argument against desired type!  */\n       if (info->first_arg_num == 0)\n \tcontinue;\n-      if (fci->pointer_count == 0 && wanted_type == void_type_node)\n+      if ((fci->pointer_count == 0 && wanted_type == void_type_node)\n+\t  || suppressed)\n \t{\n \t  if (main_arg_num != 0)\n-\t    status_warning (status, \"operand number specified for format taking no argument\");\n+\t    {\n+\t      if (suppressed)\n+\t\tstatus_warning (status, \"operand number specified with suppressed assignment\");\n+\t      else\n+\t\tstatus_warning (status, \"operand number specified for format taking no argument\");\n+\t    }\n \t}\n       else\n \t{"}, {"sha": "990a4df578819a09e6034876b33951e0bb6c806c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -1,3 +1,12 @@\n+2000-10-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/c90-printf-1.c, gcc.dg/c90-scanf-1.c,\n+\tgcc.dg/c99-printf-1.c, gcc.dg/c99-scanf-1.c,\n+\tgcc.dg/c99-strftime-1.c, gcc.dg/format-ext-3.c: Adjust error\n+\tregexps and details of expected handling of some bad formats.\n+\t* gcc.dg/format-xopen-1.c: Add test for $ format with assignment\n+\tsuppression.\n+\n 2000-10-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* g++.old-deja/g++.eh/cond1.C, g++.old-deja/g++.other/bitfld3.C,"}, {"sha": "ef9e498e5bce0a42d2ce1df9a50397cb049e825a", "filename": "gcc/testsuite/gcc.dg/c90-printf-1.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-printf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-printf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-printf-1.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -140,8 +140,8 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   /* Uses of the space flag (valid on signed conversions only, and ignored\n      with +).\n   */\n-  printf (\"% +d\", i); /* { dg-warning \"use of both\" \"use of space and + flags\" } */\n-  printf (\"%+ d\", i); /* { dg-warning \"use of both\" \"use of space and + flags\" } */\n+  printf (\"% +d\", i); /* { dg-warning \"use of both|ignored\" \"use of space and + flags\" } */\n+  printf (\"%+ d\", i); /* { dg-warning \"use of both|ignored\" \"use of space and + flags\" } */\n   printf (\"% d% i% f% e% E% g% G\\n\", i, i, d, d, d, d, d);\n   printf (\"% o\", u); /* { dg-warning \"flag\" \"bad use of space flag\" } */\n   printf (\"% u\", u); /* { dg-warning \"flag\" \"bad use of space flag\" } */\n@@ -176,17 +176,17 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   printf (\"%08.5X\", u); /* { dg-warning \"ignored\" \"0 flag ignored with precision\" } */\n   printf (\"%08.5f%08.5e%08.5E%08.5g%08.5G\", d, d, d, d, d);\n   /* 0 flag ignored with - flag.  */\n-  printf (\"%-08d\", i); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08i\", i); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08o\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08u\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08x\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08X\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08e\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08E\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08f\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08g\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08G\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08d\", i); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08i\", i); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08o\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08u\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08x\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08X\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08e\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08E\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08f\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08g\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08G\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n   /* Various tests of bad argument types.  */\n   printf (\"%d\", l); /* { dg-warning \"format\" \"bad argument types\" } */\n   printf (\"%*.*d\", l, i2, i); /* { dg-warning \"field\" \"bad * argument types\" } */"}, {"sha": "f1da57aff88f1f53a8d288e15c4f775f5ccd4d89", "filename": "gcc/testsuite/gcc.dg/c90-scanf-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-1.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -44,7 +44,7 @@ foo (int *ip, unsigned int *uip, short int *hp, unsigned short int *uhp,\n   /* Valid, invalid and silly assignment-suppression constructions.  */\n   scanf (\"%*d%*i%*o%*u%*x%*X%*e%*E%*f%*g%*G%*s%*[abc]%*c%*p\");\n   scanf (\"%*2d%*8s%*3c\");\n-  scanf (\"%*n\"); /* { dg-warning \"suppress\" \"suppression of %n\" } */\n+  scanf (\"%*n\", n); /* { dg-warning \"suppress\" \"suppression of %n\" } */\n   scanf (\"%*hd\"); /* { dg-warning \"together\" \"suppression with length\" } */\n   /* Valid, invalid and silly width constructions.  */\n   scanf (\"%2d%3i%4o%5u%6x%7X%8e%9E%10f%11g%12G%13s%14[abc]%15c%16p\","}, {"sha": "304be531657466e2424e9563efdf80a996c3cc08", "filename": "gcc/testsuite/gcc.dg/c99-printf-1.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-printf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-printf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-printf-1.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -155,8 +155,8 @@ foo (int i, unsigned int u, double d, char *s, void *p, int *n,\n   /* Uses of the space flag (valid on signed conversions only, and ignored\n      with +).\n   */\n-  printf (\"% +d\", i); /* { dg-warning \"use of both\" \"use of space and + flags\" } */\n-  printf (\"%+ d\", i); /* { dg-warning \"use of both\" \"use of space and + flags\" } */\n+  printf (\"% +d\", i); /* { dg-warning \"use of both|ignored\" \"use of space and + flags\" } */\n+  printf (\"%+ d\", i); /* { dg-warning \"use of both|ignored\" \"use of space and + flags\" } */\n   printf (\"% d% i% f% F% e% E% g% G% a% A\\n\", i, i, d, d, d, d, d, d, d, d);\n   printf (\"% o\", u); /* { dg-warning \"flag\" \"bad use of space flag\" } */\n   printf (\"% u\", u); /* { dg-warning \"flag\" \"bad use of space flag\" } */\n@@ -193,20 +193,20 @@ foo (int i, unsigned int u, double d, char *s, void *p, int *n,\n   printf (\"%08.5f%08.5F%08.5e%08.5E%08.5g%08.5G%08.5a%08.5A\",\n \t  d, d, d, d, d, d, d, d);\n   /* 0 flag ignored with - flag.  */\n-  printf (\"%-08d\", i); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08i\", i); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08o\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08u\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08x\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08X\", u); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08e\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08E\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08f\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08F\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08g\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08G\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08a\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n-  printf (\"%-08A\", d); /* { dg-warning \"flags\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08d\", i); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08i\", i); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08o\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08u\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08x\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08X\", u); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08e\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08E\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08f\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08F\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08g\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08G\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08a\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n+  printf (\"%-08A\", d); /* { dg-warning \"flags|ignored\" \"0 flag ignored with - flag\" } */\n   /* Various tests of bad argument types.  Mostly covered in c90-printf-1.c;\n      here just test for pointer target sign with %hhn.  (Probably allowed\n      by the standard, but a bad idea, so GCC should diagnose if what"}, {"sha": "447d51eaed80d622e933e65dcb0ae9213c05fc0f", "filename": "gcc/testsuite/gcc.dg/c99-scanf-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-1.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -47,7 +47,7 @@ foo (int *ip, unsigned int *uip, short int *hp, unsigned short int *uhp,\n   */\n   scanf (\"%*d%*i%*o%*u%*x%*X%*a%*A%*e%*E%*f%*F%*g%*G%*s%*[abc]%*c%*p\");\n   scanf (\"%*2d%*8s%*3c\");\n-  scanf (\"%*n\"); /* { dg-warning \"suppress\" \"suppression of %n\" } */\n+  scanf (\"%*n\", n); /* { dg-warning \"suppress\" \"suppression of %n\" } */\n   scanf (\"%*hd\"); /* { dg-warning \"together\" \"suppression with length\" } */\n   scanf (\"%2d%3i%4o%5u%6x%7X%8a%9A%10e%11E%12f%13F%14g%15G%16s%3[abc]%4c%5p\",\n \t ip, ip, uip, uip, uip, uip, fp, fp, fp, fp, fp, fp, fp, fp,"}, {"sha": "187fc7ceb492866415f66518e0bb1c25097fb2f0", "filename": "gcc/testsuite/gcc.dg/c99-strftime-1.c", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-strftime-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-strftime-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-strftime-1.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -31,69 +31,71 @@ foo (char *s, size_t m, const struct tm *tp)\n   */\n   strftime (s, m, \"%Ey\", tp); /* { dg-warning \"some locales\" \"2-digit year\" } */\n   /* Bad uses of %E and %O.  */\n-  strftime (s, m, \"%EEY\", tp); /* { dg-warning \"multiple\" \"multiple %E/%O\" } */\n-  strftime (s, m, \"%EOY\", tp); /* { dg-warning \"multiple\" \"multiple %E/%O\" } */\n-  strftime (s, m, \"%OEV\", tp); /* { dg-warning \"multiple\" \"multiple %E/%O\" } */\n-  strftime (s, m, \"%OOV\", tp); /* { dg-warning \"multiple\" \"multiple %E/%O\" } */\n-  strftime (s, m, \"%Ea\", tp); /* { dg-warning \"flag\" \"bad %Ea\" } */\n-  strftime (s, m, \"%EA\", tp); /* { dg-warning \"flag\" \"bad %EA\" } */\n-  strftime (s, m, \"%Eb\", tp); /* { dg-warning \"flag\" \"bad %Eb\" } */\n-  strftime (s, m, \"%EB\", tp); /* { dg-warning \"flag\" \"bad %EB\" } */\n-  strftime (s, m, \"%Ed\", tp); /* { dg-warning \"flag\" \"bad %Ed\" } */\n-  strftime (s, m, \"%ED\", tp); /* { dg-warning \"flag\" \"bad %ED\" } */\n-  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 43 } */\n-  strftime (s, m, \"%Ee\", tp); /* { dg-warning \"flag\" \"bad %Ee\" } */\n-  strftime (s, m, \"%EF\", tp); /* { dg-warning \"flag\" \"bad %EF\" } */\n-  strftime (s, m, \"%Eg\", tp); /* { dg-warning \"flag\" \"bad %Eg\" } */\n-  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 47 } */\n-  strftime (s, m, \"%EG\", tp); /* { dg-warning \"flag\" \"bad %EG\" } */\n-  strftime (s, m, \"%Eh\", tp); /* { dg-warning \"flag\" \"bad %Eh\" } */\n-  strftime (s, m, \"%EH\", tp); /* { dg-warning \"flag\" \"bad %EH\" } */\n-  strftime (s, m, \"%EI\", tp); /* { dg-warning \"flag\" \"bad %EI\" } */\n-  strftime (s, m, \"%Ej\", tp); /* { dg-warning \"flag\" \"bad %Ej\" } */\n-  strftime (s, m, \"%Em\", tp); /* { dg-warning \"flag\" \"bad %Em\" } */\n-  strftime (s, m, \"%EM\", tp); /* { dg-warning \"flag\" \"bad %EM\" } */\n-  strftime (s, m, \"%En\", tp); /* { dg-warning \"flag\" \"bad %En\" } */\n-  strftime (s, m, \"%Ep\", tp); /* { dg-warning \"flag\" \"bad %Ep\" } */\n-  strftime (s, m, \"%Er\", tp); /* { dg-warning \"flag\" \"bad %Er\" } */\n-  strftime (s, m, \"%ER\", tp); /* { dg-warning \"flag\" \"bad %ER\" } */\n-  strftime (s, m, \"%ES\", tp); /* { dg-warning \"flag\" \"bad %ES\" } */\n-  strftime (s, m, \"%Et\", tp); /* { dg-warning \"flag\" \"bad %Et\" } */\n-  strftime (s, m, \"%ET\", tp); /* { dg-warning \"flag\" \"bad %ET\" } */\n-  strftime (s, m, \"%Eu\", tp); /* { dg-warning \"flag\" \"bad %Eu\" } */\n-  strftime (s, m, \"%EU\", tp); /* { dg-warning \"flag\" \"bad %EU\" } */\n-  strftime (s, m, \"%EV\", tp); /* { dg-warning \"flag\" \"bad %EV\" } */\n-  strftime (s, m, \"%Ew\", tp); /* { dg-warning \"flag\" \"bad %Ew\" } */\n-  strftime (s, m, \"%EW\", tp); /* { dg-warning \"flag\" \"bad %EW\" } */\n-  strftime (s, m, \"%Ez\", tp); /* { dg-warning \"flag\" \"bad %Ez\" } */\n-  strftime (s, m, \"%EZ\", tp); /* { dg-warning \"flag\" \"bad %EZ\" } */\n-  strftime (s, m, \"%E%\", tp); /* { dg-warning \"flag\" \"bad %E%\" } */\n-  strftime (s, m, \"%Oa\", tp); /* { dg-warning \"flag\" \"bad %Oa\" } */\n-  strftime (s, m, \"%OA\", tp); /* { dg-warning \"flag\" \"bad %OA\" } */\n-  strftime (s, m, \"%Ob\", tp); /* { dg-warning \"flag\" \"bad %Ob\" } */\n-  strftime (s, m, \"%OB\", tp); /* { dg-warning \"flag\" \"bad %OB\" } */\n-  strftime (s, m, \"%Oc\", tp); /* { dg-warning \"flag\" \"bad %Oc\" } */\n-  /* { dg-warning \"in some locales\" \"2-digit year\" { target *-*-* } 75 } */\n-  strftime (s, m, \"%OC\", tp); /* { dg-warning \"flag|C\" \"bad %OC\" } */\n-  strftime (s, m, \"%OD\", tp); /* { dg-warning \"flag\" \"bad %OD\" } */\n-  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 78 } */\n-  strftime (s, m, \"%OF\", tp); /* { dg-warning \"flag\" \"bad %OF\" } */\n-  strftime (s, m, \"%Og\", tp); /* { dg-warning \"flag|C\" \"bad %Og\" } */\n-  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 81 } */\n-  strftime (s, m, \"%OG\", tp); /* { dg-warning \"flag|C\" \"bad %OG\" } */\n-  strftime (s, m, \"%Oh\", tp); /* { dg-warning \"flag\" \"bad %Oh\" } */\n-  strftime (s, m, \"%Oj\", tp); /* { dg-warning \"flag|C\" \"bad %Oj\" } */\n-  strftime (s, m, \"%On\", tp); /* { dg-warning \"flag\" \"bad %On\" } */\n-  strftime (s, m, \"%Op\", tp); /* { dg-warning \"flag\" \"bad %Op\" } */\n-  strftime (s, m, \"%Or\", tp); /* { dg-warning \"flag\" \"bad %Or\" } */\n-  strftime (s, m, \"%OR\", tp); /* { dg-warning \"flag\" \"bad %OR\" } */\n-  strftime (s, m, \"%Ot\", tp); /* { dg-warning \"flag\" \"bad %Ot\" } */\n-  strftime (s, m, \"%OT\", tp); /* { dg-warning \"flag\" \"bad %OT\" } */\n-  strftime (s, m, \"%Ox\", tp); /* { dg-warning \"flag\" \"bad %Ox\" } */\n-  /* { dg-warning \"in some locales\" \"2-digit year\" { target *-*-* } 92 } */\n-  strftime (s, m, \"%OX\", tp); /* { dg-warning \"flag\" \"bad %OX\" } */\n-  strftime (s, m, \"%OY\", tp); /* { dg-warning \"flag|C\" \"bad %OY\" } */\n-  strftime (s, m, \"%Oz\", tp); /* { dg-warning \"flag|C\" \"bad %Oz\" } */\n-  strftime (s, m, \"%OZ\", tp); /* { dg-warning \"flag\" \"bad %OZ\" } */\n-  strftime (s, m, \"%O%\", tp); /* { dg-warning \"flag\" \"bad %O%\" } */\n+  strftime (s, m, \"%EEY\", tp); /* { dg-warning \"multiple|repeated\" \"multiple %E/%O\" } */\n+  strftime (s, m, \"%EOy\", tp); /* { dg-warning \"multiple|together\" \"multiple %E/%O\" } */\n+  strftime (s, m, \"%OEy\", tp); /* { dg-warning \"multiple|together\" \"multiple %E/%O\" } */\n+  strftime (s, m, \"%OOV\", tp); /* { dg-warning \"multiple|repeated\" \"multiple %E/%O\" } */\n+  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 35 } */\n+  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 36 } */\n+  strftime (s, m, \"%Ea\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ea\" } */\n+  strftime (s, m, \"%EA\", tp); /* { dg-warning \"flag|modifier\" \"bad %EA\" } */\n+  strftime (s, m, \"%Eb\", tp); /* { dg-warning \"flag|modifier\" \"bad %Eb\" } */\n+  strftime (s, m, \"%EB\", tp); /* { dg-warning \"flag|modifier\" \"bad %EB\" } */\n+  strftime (s, m, \"%Ed\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ed\" } */\n+  strftime (s, m, \"%ED\", tp); /* { dg-warning \"flag|modifier\" \"bad %ED\" } */\n+  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 45 } */\n+  strftime (s, m, \"%Ee\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ee\" } */\n+  strftime (s, m, \"%EF\", tp); /* { dg-warning \"flag|modifier\" \"bad %EF\" } */\n+  strftime (s, m, \"%Eg\", tp); /* { dg-warning \"flag|modifier\" \"bad %Eg\" } */\n+  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 49 } */\n+  strftime (s, m, \"%EG\", tp); /* { dg-warning \"flag|modifier\" \"bad %EG\" } */\n+  strftime (s, m, \"%Eh\", tp); /* { dg-warning \"flag|modifier\" \"bad %Eh\" } */\n+  strftime (s, m, \"%EH\", tp); /* { dg-warning \"flag|modifier\" \"bad %EH\" } */\n+  strftime (s, m, \"%EI\", tp); /* { dg-warning \"flag|modifier\" \"bad %EI\" } */\n+  strftime (s, m, \"%Ej\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ej\" } */\n+  strftime (s, m, \"%Em\", tp); /* { dg-warning \"flag|modifier\" \"bad %Em\" } */\n+  strftime (s, m, \"%EM\", tp); /* { dg-warning \"flag|modifier\" \"bad %EM\" } */\n+  strftime (s, m, \"%En\", tp); /* { dg-warning \"flag|modifier\" \"bad %En\" } */\n+  strftime (s, m, \"%Ep\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ep\" } */\n+  strftime (s, m, \"%Er\", tp); /* { dg-warning \"flag|modifier\" \"bad %Er\" } */\n+  strftime (s, m, \"%ER\", tp); /* { dg-warning \"flag|modifier\" \"bad %ER\" } */\n+  strftime (s, m, \"%ES\", tp); /* { dg-warning \"flag|modifier\" \"bad %ES\" } */\n+  strftime (s, m, \"%Et\", tp); /* { dg-warning \"flag|modifier\" \"bad %Et\" } */\n+  strftime (s, m, \"%ET\", tp); /* { dg-warning \"flag|modifier\" \"bad %ET\" } */\n+  strftime (s, m, \"%Eu\", tp); /* { dg-warning \"flag|modifier\" \"bad %Eu\" } */\n+  strftime (s, m, \"%EU\", tp); /* { dg-warning \"flag|modifier\" \"bad %EU\" } */\n+  strftime (s, m, \"%EV\", tp); /* { dg-warning \"flag|modifier\" \"bad %EV\" } */\n+  strftime (s, m, \"%Ew\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ew\" } */\n+  strftime (s, m, \"%EW\", tp); /* { dg-warning \"flag|modifier\" \"bad %EW\" } */\n+  strftime (s, m, \"%Ez\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ez\" } */\n+  strftime (s, m, \"%EZ\", tp); /* { dg-warning \"flag|modifier\" \"bad %EZ\" } */\n+  strftime (s, m, \"%E%\", tp); /* { dg-warning \"flag|modifier\" \"bad %E%\" } */\n+  strftime (s, m, \"%Oa\", tp); /* { dg-warning \"flag|modifier\" \"bad %Oa\" } */\n+  strftime (s, m, \"%OA\", tp); /* { dg-warning \"flag|modifier\" \"bad %OA\" } */\n+  strftime (s, m, \"%Ob\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ob\" } */\n+  strftime (s, m, \"%OB\", tp); /* { dg-warning \"flag|modifier\" \"bad %OB\" } */\n+  strftime (s, m, \"%Oc\", tp); /* { dg-warning \"flag|modifier\" \"bad %Oc\" } */\n+  /* { dg-warning \"in some locales\" \"2-digit year\" { target *-*-* } 77 } */\n+  strftime (s, m, \"%OC\", tp); /* { dg-warning \"flag|modifier|C\" \"bad %OC\" } */\n+  strftime (s, m, \"%OD\", tp); /* { dg-warning \"flag|modifier\" \"bad %OD\" } */\n+  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 80 } */\n+  strftime (s, m, \"%OF\", tp); /* { dg-warning \"flag|modifier\" \"bad %OF\" } */\n+  strftime (s, m, \"%Og\", tp); /* { dg-warning \"flag|modifier|C\" \"bad %Og\" } */\n+  /* { dg-warning \"only last 2\" \"2-digit year\" { target *-*-* } 83 } */\n+  strftime (s, m, \"%OG\", tp); /* { dg-warning \"flag|modifier|C\" \"bad %OG\" } */\n+  strftime (s, m, \"%Oh\", tp); /* { dg-warning \"flag|modifier\" \"bad %Oh\" } */\n+  strftime (s, m, \"%Oj\", tp); /* { dg-warning \"flag|modifier|C\" \"bad %Oj\" } */\n+  strftime (s, m, \"%On\", tp); /* { dg-warning \"flag|modifier\" \"bad %On\" } */\n+  strftime (s, m, \"%Op\", tp); /* { dg-warning \"flag|modifier\" \"bad %Op\" } */\n+  strftime (s, m, \"%Or\", tp); /* { dg-warning \"flag|modifier\" \"bad %Or\" } */\n+  strftime (s, m, \"%OR\", tp); /* { dg-warning \"flag|modifier\" \"bad %OR\" } */\n+  strftime (s, m, \"%Ot\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ot\" } */\n+  strftime (s, m, \"%OT\", tp); /* { dg-warning \"flag|modifier\" \"bad %OT\" } */\n+  strftime (s, m, \"%Ox\", tp); /* { dg-warning \"flag|modifier\" \"bad %Ox\" } */\n+  /* { dg-warning \"in some locales\" \"2-digit year\" { target *-*-* } 94 } */\n+  strftime (s, m, \"%OX\", tp); /* { dg-warning \"flag|modifier\" \"bad %OX\" } */\n+  strftime (s, m, \"%OY\", tp); /* { dg-warning \"flag|modifier|C\" \"bad %OY\" } */\n+  strftime (s, m, \"%Oz\", tp); /* { dg-warning \"flag|modifier|C\" \"bad %Oz\" } */\n+  strftime (s, m, \"%OZ\", tp); /* { dg-warning \"flag|modifier\" \"bad %OZ\" } */\n+  strftime (s, m, \"%O%\", tp); /* { dg-warning \"flag|modifier\" \"bad %O%\" } */\n }"}, {"sha": "26d13249a992f1d64009bb58da777f84d8ed5882", "filename": "gcc/testsuite/gcc.dg/format-ext-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-ext-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-ext-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-ext-3.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -210,5 +210,5 @@ foo (char *s, size_t m, const struct tm *tp)\n      covered in c99-strftime-1.c, except for the extension %P.\n   */\n   strftime (s, m, \"%OC%Og%OG%Oj%OY%Oz%Ok%Ol%Os\", tp); /* { dg-warning \"only last 2\" \"2-digit year\" } */\n-  strftime (s, m, \"%OP\", tp); /* { dg-warning \"flag\" \"bad %OP\" } */\n+  strftime (s, m, \"%OP\", tp); /* { dg-warning \"flag|modifier\" \"bad %OP\" } */\n }"}, {"sha": "0eb8d70eaa740542b3a380499d2607c2d5a061ba", "filename": "gcc/testsuite/gcc.dg/format-xopen-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-xopen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2588e44e0019aac9b55c974efd69885eea663f54/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-xopen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-xopen-1.c?ref=2588e44e0019aac9b55c974efd69885eea663f54", "patch": "@@ -119,4 +119,5 @@ foo (int i, unsigned int u, wint_t lc, wchar_t *ls, int *ip, double d,\n   printf (\"%3$d%1$d\", i, i, i); /* { dg-warning \"before used\" \"unused $ operand\" } */\n   printf (\"%2$d%1$d\", i, i, i); /* { dg-warning \"unused\" \"unused $ operand\" } */\n   vprintf (\"%3$d%1$d\", va); /* { dg-warning \"before used\" \"unused $ operand\" } */\n+  scanf (\"%1$*d%1$d\", ip); /* { dg-warning \"operand\" \"operand number with suppression\" } */\n }"}]}