{"sha": "bd5b625228d545d5ecb35df24f9f094edc95e3fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ1YjYyNTIyOGQ1NDVkNWVjYjM1ZGYyNGY5ZjA5NGVkYzk1ZTNmYQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-06-15T14:35:34Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-16T16:52:05Z"}, "message": "rs6000: Initial create of rs6000-gen-builtins.c\n\n2021-04-02  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c: New.", "tree": {"sha": "7c42f0f30bec933d5e3d8c75cfd7039f4ee1fb0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c42f0f30bec933d5e3d8c75cfd7039f4ee1fb0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd5b625228d545d5ecb35df24f9f094edc95e3fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5b625228d545d5ecb35df24f9f094edc95e3fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd5b625228d545d5ecb35df24f9f094edc95e3fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5b625228d545d5ecb35df24f9f094edc95e3fa/comments", "author": null, "committer": null, "parents": [{"sha": "27d16cb56972279fb1ca4e5c5a79d4c5b0b86610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27d16cb56972279fb1ca4e5c5a79d4c5b0b86610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27d16cb56972279fb1ca4e5c5a79d4c5b0b86610"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "6ab7d7bb189cf900dc897214a0bf52fc70f95bf3", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5b625228d545d5ecb35df24f9f094edc95e3fa/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5b625228d545d5ecb35df24f9f094edc95e3fa/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=bd5b625228d545d5ecb35df24f9f094edc95e3fa", "patch": "@@ -0,0 +1,165 @@\n+/* Generate built-in function initialization and recognition for Power.\n+   Copyright (C) 2020-21 Free Software Foundation, Inc.\n+   Contributed by Bill Schmidt, IBM <wschmidt@linux.ibm.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This program generates built-in function initialization and\n+   recognition code for Power targets, based on text files that\n+   describe the built-in functions and vector overloads:\n+\n+     rs6000-builtin-new.def     Table of built-in functions\n+     rs6000-overload.def        Table of overload functions\n+\n+   Both files group similar functions together in \"stanzas,\" as\n+   described below.\n+\n+   Each stanza in the built-in function file starts with a line\n+   identifying the circumstances in which the group of functions is\n+   permitted, with the gating predicate in square brackets.  For\n+   example, this could be\n+\n+     [altivec]\n+\n+   or it could be\n+\n+     [power9]\n+\n+   The bracketed gating predicate is the only information allowed on\n+   the stanza header line, other than whitespace.\n+\n+   Following the stanza header are two lines for each function: the\n+   prototype line and the attributes line.  The prototype line has\n+   this format, where the square brackets indicate optional\n+   information and angle brackets indicate required information:\n+\n+     [kind] <return-type> <bif-name> (<argument-list>);\n+\n+   Here [kind] can be one of \"const\", \"pure\", or \"fpmath\";\n+   <return-type> is a legal type for a built-in function result;\n+   <bif-name> is the name by which the function can be called;\n+   and <argument-list> is a comma-separated list of legal types\n+   for built-in function arguments.  The argument list may be\n+   empty, but the parentheses and semicolon are required.\n+\n+   The attributes line looks like this:\n+\n+     <bif-id> <bif-pattern> {<attribute-list>}\n+\n+   Here <bif-id> is a unique internal identifier for the built-in\n+   function that will be used as part of an enumeration of all\n+   built-in functions; <bif-pattern> is the define_expand or\n+   define_insn that will be invoked when the call is expanded;\n+   and <attribute-list> is a comma-separated list of special\n+   conditions that apply to the built-in function.  The attribute\n+   list may be empty, but the braces are required.\n+\n+   Attributes are strings, such as these:\n+\n+     init     Process as a vec_init function\n+     set      Process as a vec_set function\n+     extract  Process as a vec_extract function\n+     nosoft   Not valid with -msoft-float\n+     ldvec    Needs special handling for vec_ld semantics\n+     stvec    Needs special handling for vec_st semantics\n+     reve     Needs special handling for element reversal\n+     pred     Needs special handling for comparison predicates\n+     htm      Needs special handling for transactional memory\n+     htmspr   HTM function using an SPR\n+     htmcr    HTM function using a CR\n+     mma      Needs special handling for MMA instructions\n+     quad     MMA instruction using a register quad as an input operand\n+     pair     MMA instruction using a register pair as an input operand\n+     no32bit  Not valid for TARGET_32BIT\n+     32bit    Requires different handling for TARGET_32BIT\n+     cpu      This is a \"cpu_is\" or \"cpu_supports\" builtin\n+     ldstmask Altivec mask for load or store\n+     lxvrse   Needs special handling for load-rightmost, sign-extended\n+     lxvrze   Needs special handling for load-rightmost, zero-extended\n+     endian   Needs special handling for endianness\n+\n+   An example stanza might look like this:\n+\n+[altivec]\n+  const vsc __builtin_altivec_abs_v16qi (vsc);\n+    ABS_V16QI absv16qi2 {}\n+  const vss __builtin_altivec_abs_v8hi (vss);\n+    ABS_V8HI absv8hi2 {}\n+\n+   Here \"vsc\" and \"vss\" are shorthand for \"vector signed char\" and\n+   \"vector signed short\" to shorten line lengths and improve readability.\n+   Note the use of indentation, which is recommended but not required.\n+\n+   The overload file has more complex stanza headers.  Here the stanza\n+   represents all functions with the same overloaded function name:\n+\n+     [<overload-id>, <abi-name>, <builtin-name>[[, <ifdef>]] ]\n+\n+   Here the single square brackets are part of the syntax, <overload-id>\n+   is a unique internal identifier for the overload that will be used as\n+   part of an enumeration of all overloaded functions; <abi-name> is the\n+   name that will appear as a #define in rs6000-vecdefines.h;\n+   <builtin-name> is the name that is overloaded in the back end; and\n+   <ifdef> is an optional token used to guard the #define with an #ifdef\n+   in rs6000-vecdefines.h.\n+\n+   Each function entry again has two lines.  The first line is again a\n+   prototype line (this time without [kind]):\n+\n+     <return-type> <internal-name> (<argument-list>);\n+\n+   The second line contains the <bif-id> that this particular instance of\n+   the overloaded function maps to.  It must match a token that appears in\n+   rs6000-builtin-new.def.  Optionally, a second token may appear.  If only\n+   one token is on the line, it is also used to build the unique identifier\n+   for the overloaded function.  If a second token is present, the second\n+   token is used instead for this purpose.  This is necessary in cases\n+   where a built-in function accepts more than one type signature.  It is\n+   common to have a built-in function that, for example, specifies a\n+   \"vector signed char\" argument, but accepts \"vector unsigned char\" and\n+   \"vector bool char\" as well because only the mode matters.  Note that\n+   the overload resolution mechanism has always handled these cases by\n+   performing fold_convert on vector arguments to hide type mismatches,\n+   and it will continue to do so.\n+\n+   As a concrete example, __builtin_altivec_mtvscr uses an opaque argument\n+   type for the source operand.  Its built-in function id is MTVSCR.  The\n+   overloaded function __builtin_vec_mtvscr takes a variety of specific\n+   types, but not all vector types.  Each of these maps to the same\n+   __builtin_altivec_mtvscr built-in function, but the overload ID must\n+   be unique, so we must specify the second token as shown here.\n+\n+    [VEC_MTVSCR, vec_mtvscr, __builtin_vec_mtvscr]\n+      void __builtin_vec_mtvscr (vbc);\n+\tMTVSCR  MTVSCR_VBC\n+      void __builtin_vec_mtvscr (vsc);\n+\tMTVSCR  MTVSCR_VSC\n+      ...\n+\n+  Blank lines may be used as desired in these files between the lines as\n+  defined above; that is, you can introduce as many extra newlines as you\n+  like after a required newline, but nowhere else.  Lines beginning with\n+  a semicolon are also treated as blank lines.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include <stdint.h>\n+#include <ctype.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <unistd.h>"}]}