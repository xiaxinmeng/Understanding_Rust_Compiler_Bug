{"sha": "9cb5fdd06256b2de8d63197810cd421f60d82a0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNiNWZkZDA2MjU2YjJkZThkNjMxOTc4MTBjZDQyMWY2MGQ4MmEwZQ==", "commit": {"author": {"name": "Josh Conner", "email": "jconner@apple.com", "date": "2005-09-13T23:27:25Z"}, "committer": {"name": "Josh Conner", "email": "jconner@gcc.gnu.org", "date": "2005-09-13T23:27:25Z"}, "message": "gcc-dg.exp: Load scanipa.exp.\n\n        * lib/gcc-dg.exp: Load scanipa.exp.\n        (cleanup-dump): New procedure.\n        (cleanup-rtl-dump, cleanup-tree-dump, cleanup-ipa-dump): Use it.\n        * lib/scandump.exp: New file.\n        * lib/scantree.exp: Use it.\n        * lib/scanipa.exp: New file.\n\nFrom-SVN: r104244", "tree": {"sha": "ef8a8c20c8f8dd4288b995e58255052d6528c030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef8a8c20c8f8dd4288b995e58255052d6528c030"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cb5fdd06256b2de8d63197810cd421f60d82a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cb5fdd06256b2de8d63197810cd421f60d82a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cb5fdd06256b2de8d63197810cd421f60d82a0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cb5fdd06256b2de8d63197810cd421f60d82a0e/comments", "author": null, "committer": null, "parents": [{"sha": "18943792101a72cbd5b1134cfe801eb9704586ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18943792101a72cbd5b1134cfe801eb9704586ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18943792101a72cbd5b1134cfe801eb9704586ab"}], "stats": {"total": 602, "additions": 423, "deletions": 179}, "files": [{"sha": "337d4fd2a506847be239b9598c50d768a9e75e19", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9cb5fdd06256b2de8d63197810cd421f60d82a0e", "patch": "@@ -1,3 +1,12 @@\n+2005-09-13  Josh Conner  <jconner@apple.com>\n+\n+\t* lib/gcc-dg.exp: Load scanipa.exp.\n+\t(cleanup-dump): New procedure.\n+\t(cleanup-rtl-dump, cleanup-tree-dump, cleanup-ipa-dump): Use it.\n+\t* lib/scandump.exp: New file.\n+\t* lib/scantree.exp: Use it.\n+\t* lib/scanipa.exp: New file.\n+\n 2005-09-13  Erik Edelmann  <erik.edelmann@iki.fi>\n \n \tPR fortran/17740"}, {"sha": "68c4aacf8e88bfdaa0ed1d16b6b0021f64e4a64c", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=9cb5fdd06256b2de8d63197810cd421f60d82a0e", "patch": "@@ -20,6 +20,7 @@ load_lib target-supports.exp\n load_lib target-supports-dg.exp\n load_lib scanasm.exp\n load_lib scantree.exp\n+load_lib scanipa.exp\n load_lib prune.exp\n load_lib libgloss.exp\n load_lib target-libpath.exp\n@@ -343,52 +344,35 @@ proc cleanup-repo-files { } {\n #\n # SUFFIX is the filename suffix pattern.\n proc cleanup-rtl-dump { suffix } {\n-    # This assumes that we are two frames down from dg-test or some other proc\n-    # that stores the filename of the testcase in a local variable \"name\".\n-    # A cleaner solution would require a new DejaGnu release.\n-    upvar 2 name testcase\n-    remove-build-file \"[file tail $testcase].??.$suffix\"\n-\n-    # Clean up dump files for additional source files.\n-    if [info exists additional_sources] {\n-\tforeach srcfile $additional_sources {\n-\t    remove-build-file \"[file tail $srcfile].??.$suffix\"\n-\t}\n-    }\n+  cleanup-dump \"\\[0-9\\]\\[0-9\\].$suffix\"\n }\n \n # Remove a specific tree dump file for the current test.\n #\n-# SUFFIX is the file suffix pattern.\n+# SUFFIX is the tree dump file suffix pattern.\n proc cleanup-tree-dump { suffix } {\n-    # This assumes that we are two frames down from dg-test or some other proc\n-    # that stores the filename of the testcase in a local variable \"name\".\n-    # A cleaner solution would require a new DejaGnu release.\n-    upvar 2 name testcase\n-    remove-build-file \"[file tail $testcase].t??.$suffix\"\n-\n-    # Clean up dump files for additional source files.\n-    if [info exists additional_sources] {\n-\tforeach srcfile $additional_sources {\n-\t    remove-build-file \"[file tail $srcfile].t??.$suffix\"\n-\t}\n-    }\n+  cleanup-dump \"t\\[0-9\\]\\[0-9\\].$suffix\"\n }\n \n # Remove a specific ipa dump file for the current test.\n #\n-# SUFFIX is the file suffix pattern.\n+# SUFFIX is the ipa dump file suffix pattern.\n proc cleanup-ipa-dump { suffix } {\n-    # This assumes that we are two frames down from dg-test or some other proc\n-    # that stores the filename of the testcase in a local variable \"name\".\n-    # A cleaner solution would require a new DejaGnu release.\n-    upvar 2 name testcase\n-    remove-build-file \"[file tail $testcase].i??.$suffix\"\n+  cleanup-dump \"i\\[0-9\\]\\[0-9\\].$suffix\"\n+}\n+\n+# Remove all dump files with the provided suffix.\n+proc cleanup-dump { suffix } {\n+    # This assumes that we are three frames down from dg-test or some other\n+    # proc that stores the filename of the testcase in a local variable\n+    # \"name\".  A cleaner solution would require a new DejaGnu release.\n+    upvar 3 name testcase\n+    remove-build-file \"[file tail $testcase].$suffix\"\n \n     # Clean up dump files for additional source files.\n     if [info exists additional_sources] {\n \tforeach srcfile $additional_sources {\n-\t    remove-build-file \"[file tail $srcfile].i??.$suffix\"\n+\t    remove-build-file \"[file tail $srcfile].$suffix\"\n \t}\n     }\n }"}, {"sha": "c968a8c1f9811aa8b75fe24008eba7fc01132d0f", "filename": "gcc/testsuite/lib/scandump.exp", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fscandump.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fscandump.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscandump.exp?ref=9cb5fdd06256b2de8d63197810cd421f60d82a0e", "patch": "@@ -0,0 +1,217 @@\n+#   Copyright (C) 2000, 2002, 2003, 2005 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# Various utilities for scanning dump output, used by gcc-dg.exp and\n+# g++-dg.exp.\n+#\n+# This is largely borrowed from scanasm.exp.\n+\n+# Utility for scanning compiler result, invoked via dg-final.\n+# Call pass if pattern is present, otherwise fail.\n+#\n+# Argument 0 is the type of dump we are searching (rtl, tree, ipa)\n+# Argument 1 is the regexp to match.\n+# Argument 2 is the suffix for the dump file\n+# Argument 3 handles expected failures and the like\n+proc scan-dump { args } {\n+\n+    if { [llength $args] >= 4 } {\n+        switch [dg-process-target [lindex $args 3]] {\n+            \"S\" { }\n+            \"N\" { return }\n+            \"F\" { setup_xfail \"*-*-*\" }\n+            \"P\" { }\n+        }\n+    }\n+\n+    # This assumes that we are three frames down from dg-test, and that\n+    # it still stores the filename of the testcase in a local variable \"name\".\n+    # A cleaner solution would require a new DejaGnu release.\n+    upvar 3 name testcase\n+\n+    set src [file tail [lindex $testcase 0]]\n+    set output_file \"[glob $src.[lindex $args 2]]\"\n+\n+    set fd [open $output_file r]\n+    set text [read $fd]\n+    close $fd\n+\n+    if [regexp -- [lindex $args 1] $text] {\n+\tpass \"$testcase scan-[lindex $args 0]-dump [lindex $args 1]\"\n+    } else {\n+\tfail \"$testcase scan-[lindex $args 0]-dump [lindex $args 1]\"\n+    }\n+}\n+\n+# Call pass if pattern is present given number of times, otherwise fail.\n+# Argument 0 is the type of dump we are searching (rtl, tree, ipa)\n+# Argument 1 is the regexp to match.\n+# Argument 2 is number of times the regexp must be found\n+# Argument 3 is the suffix for the dump file\n+# Argument 4 handles expected failures and the like\n+proc scan-dump-times { args } {\n+\n+    if { [llength $args] >= 5 } {\n+\tswitch [dg-process-target [lindex $args 4]] {\n+\t    \"S\" { }\n+\t    \"N\" { return }\n+\t    \"F\" { setup_xfail \"*-*-*\" }\n+\t    \"P\" { }\n+\t}\n+    }\n+\n+    # This assumes that we are three frames down from dg-test, and that\n+    # it still stores the filename of the testcase in a local variable \"name\".\n+    # A cleaner solution would require a new DejaGnu release.\n+    upvar 3 name testcase\n+\n+    set src [file tail [lindex $testcase 0]]\n+    set output_file \"[glob $src.[lindex $args 3]]\"\n+\n+    set fd [open $output_file r]\n+    set text [read $fd]\n+    close $fd\n+\n+    if { [llength [regexp -inline -all -- [lindex $args 1] $text]] == [lindex $args 2]} {\n+        pass \"$testcase scan-[lindex $args 0]-dump-times [lindex $args 1] [lindex $args 2]\"\n+    } else {\n+        fail \"$testcase scan-[lindex $args 0]-dump-times [lindex $args 1] [lindex $args 2]\"\n+    }\n+}\n+\n+# Call pass if pattern is not present, otherwise fail.\n+#\n+# Argument 0 is the type of dump we are searching (rtl, tree, ipa)\n+# Argument 1 is the regexp to match.\n+# Argument 2 is the suffix for the dump file\n+# Argument 3 handles expected failures and the like\n+proc scan-dump-not { args } {\n+\n+    if { [llength $args] >= 4 } {\n+\tswitch [dg-process-target [lindex $args 3]] {\n+\t    \"S\" { }\n+\t    \"N\" { return }\n+\t    \"F\" { setup_xfail \"*-*-*\" }\n+\t    \"P\" { }\n+\t}\n+    }\n+\n+    # This assumes that we are three frames down from dg-test, and that\n+    # it still stores the filename of the testcase in a local variable \"name\".\n+    # A cleaner solution would require a new DejaGnu release.\n+    upvar 3 name testcase\n+    set src [file tail [lindex $testcase 0]]\n+    set output_file \"[glob $src.[lindex $args 2]]\"\n+\n+    set fd [open $output_file r]\n+    set text [read $fd]\n+    close $fd\n+\n+    if ![regexp -- [lindex $args 1] $text] {\n+\tpass \"$testcase scan-[lindex $args 0]-dump-not [lindex $args 1]\"\n+    } else {\n+\tfail \"$testcase scan-[lindex $args 0]-dump-not [lindex $args 1]\"\n+    }\n+}\n+\n+# Utility for scanning demangled compiler result, invoked via dg-final.\n+# Call pass if pattern is present, otherwise fail.\n+#\n+# Argument 0 is the type of dump we are searching (rtl, tree, ipa)\n+# Argument 1 is the regexp to match.\n+# Argument 2 is the suffix for the dump file\n+# Argument 3 handles expected failures and the like\n+proc scan-dump-dem { args } {\n+    global cxxfilt\n+    global base_dir\n+\n+    if { [llength $args] >= 4 } {\n+\tswitch [dg-process-target [lindex $args 3]] {\n+\t    \"S\" { }\n+\t    \"N\" { return }\n+\t    \"F\" { setup_xfail \"*-*-*\" }\n+\t    \"P\" { }\n+\t}\n+    }\n+\n+    # Find c++filt like we find g++ in g++.exp.\n+    if ![info exists cxxfilt]  {\n+\tset cxxfilt [findfile $base_dir/../../binutils/cxxfilt \\\n+\t\t     $base_dir/../../binutils/cxxfilt \\\n+\t             [findfile $base_dir/../c++filt $base_dir/../c++filt \\\n+\t\t      [findfile $base_dir/c++filt $base_dir/c++filt \\\n+\t\t       [transform c++filt]]]]\n+\tverbose -log \"c++filt is $cxxfilt\"\n+    }\n+\n+    upvar 3 name testcase\n+    set src [file tail [lindex $testcase 0]]\n+    set output_file \"[glob $src.[lindex $args 2]]\"\n+\n+    set fd [open \"| $cxxfilt < $output_file\" r]\n+    set text [read $fd]\n+    close $fd\n+\n+    if [regexp -- [lindex $args 1] $text] {\n+\tpass \"$testcase scan-[lindex $args 0]-dump-dem [lindex $args 1]\"\n+    } else {\n+\tfail \"$testcase scan-[lindex $args 0]-dump-dem [lindex $args 1]\"\n+    }\n+}\n+\n+# Call pass if demangled pattern is not present, otherwise fail.\n+#\n+# Argument 0 is the type of dump we are searching (rtl, tree, ipa)\n+# Argument 1 is the regexp to match.\n+# Argument 2 is the suffix for the dump file\n+# Argument 3 handles expected failures and the like\n+proc scan-dump-dem-not { args } {\n+    global cxxfilt\n+    global base_dir\n+\n+    if { [llength $args] >= 4 } {\n+\tswitch [dg-process-target [lindex $args 3]] {\n+\t    \"S\" { }\n+\t    \"N\" { return }\n+\t    \"F\" { setup_xfail \"*-*-*\" }\n+\t    \"P\" { }\n+\t}\n+    }\n+\n+    # Find c++filt like we find g++ in g++.exp.\n+    if ![info exists cxxfilt]  {\n+\tset cxxfilt [findfile $base_dir/../../binutils/cxxfilt \\\n+\t\t     $base_dir/../../binutils/cxxfilt \\\n+\t\t     [findfile $base_dir/../c++filt $base_dir/../c++filt \\\n+\t\t      [findfile $base_dir/c++filt $base_dir/c++filt \\\n+\t\t       [transform c++filt]]]]\n+\tverbose -log \"c++filt is $cxxfilt\"\n+    }\n+\n+    upvar 3 name testcase\n+    set src [file tail [lindex $testcase 0]]\n+    set output_file \"[glob $src.[lindex $args 2]]\"\n+\n+    set fd [open \"| $cxxfilt < $output_file\" r]\n+    set text [read $fd]\n+    close $fd\n+\n+    if ![regexp -- [lindex $args 1] $text] {\n+\tpass \"$testcase scan-[lindex $args 0]-dump-dem-not [lindex $args 1]\"\n+    } else {\n+\tfail \"$testcase scan-[lindex $args 0]-dump-dem-not [lindex $args 1]\"\n+    }\n+}"}, {"sha": "97688a9c78f88eadc1b7e4817d53f7f7e1803b9f", "filename": "gcc/testsuite/lib/scanipa.exp", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fscanipa.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fscanipa.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscanipa.exp?ref=9cb5fdd06256b2de8d63197810cd421f60d82a0e", "patch": "@@ -0,0 +1,141 @@\n+#   Copyright (C) 2000, 2002, 2003, 2005 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# Various utilities for scanning ipa dump output, used by gcc-dg.exp and\n+# g++-dg.exp.\n+\n+load_lib scandump.exp\n+\n+# Utility for scanning compiler result, invoked via dg-final.\n+# Call pass if pattern is present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-ipa-dump { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-ipa-dump: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-ipa-dump: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscan-dump \"ipa\" [lindex $args 0] \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\" [lindex $args 2]\n+    } else {\n+\tscan-dump \"ipa\" [lindex $args 0] \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n+    }\n+}\n+\n+# Call pass if pattern is present given number of times, otherwise fail.\n+# Argument 0 is the regexp to match\n+# Argument 1 is number of times the regexp must be found\n+# Argument 2 is the name of the dumped ipa pass\n+# Argument 3 handles expected failures and the like\n+proc scan-ipa-dump-times { args } {\n+\n+    if { [llength $args] < 3 } {\n+\terror \"scan-ipa-dump: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 4 } {\n+\terror \"scan-ipa-dump: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 4 } {\n+\tscan-dump-times \"ipa\" [lindex $args 0] [lindex $args 1] \\\n+\t\t\t\"i\\[0-9\\]\\[0-9\\].[lindex $args 2]\" [lindex $args 3]\n+    } else {\n+\tscan-dump-times \"ipa\" [lindex $args 0] [lindex $args 1] \\\n+\t\t\t\"i\\[0-9\\]\\[0-9\\].[lindex $args 2]\"\n+    }\n+}\n+\n+# Call pass if pattern is not present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-ipa-dump-not { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-ipa-dump-not: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-ipa-dump-not: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscan-dump-not \"ipa\" [lindex $args 0] \\\n+\t\t      \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\" [lindex $args 2]\n+    } else {\n+\tscan-dump-not \"ipa\" [lindex $args 0] \\\n+\t\t      \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n+    }\n+}\n+\n+# Utility for scanning demangled compiler result, invoked via dg-final.\n+# Call pass if pattern is present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-ipa-dump-dem { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-ipa-dump-dem: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-ipa-dump-dem: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscan-dump-dem \"ipa\" [lindex $args 0] \\\n+\t\t      \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\" [lindex $args 2]\n+    } else {\n+\tscan-dump-dem \"ipa\" [lindex $args 0] \\\n+\t\t      \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n+    }\n+}\n+\n+# Call pass if demangled pattern is not present, otherwise fail.\n+#\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped ipa pass\n+# Argument 2 handles expected failures and the like\n+proc scan-ipa-dump-dem-not { args } {\n+\n+    if { [llength $args] < 2 } {\n+\terror \"scan-ipa-dump-dem-not: too few arguments\"\n+\treturn\n+    }\n+    if { [llength $args] > 3 } {\n+\terror \"scan-ipa-dump-dem-not: too many arguments\"\n+\treturn\n+    }\n+    if { [llength $args] >= 3 } {\n+\tscan-dump-dem-not \"ipa\" [lindex $args 0] \\\n+\t\t\t  \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\" \\\n+\t\t\t  [lindex $args 2]\n+    } else {\n+\tscan-dump-dem-not \"ipa\" [lindex $args 0] \\\n+\t\t\t  \"i\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n+    }\n+}"}, {"sha": "d0f57969b9712f0094daeccda75a9d597798f119", "filename": "gcc/testsuite/lib/scantree.exp", "status": "modified", "additions": 40, "deletions": 147, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fscantree.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb5fdd06256b2de8d63197810cd421f60d82a0e/gcc%2Ftestsuite%2Flib%2Fscantree.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscantree.exp?ref=9cb5fdd06256b2de8d63197810cd421f60d82a0e", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n+#   Copyright (C) 2000, 2002, 2003, 2005 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -16,233 +16,126 @@\n \n # Various utilities for scanning tree dump output, used by gcc-dg.exp and\n # g++-dg.exp.\n-#\n-# This is largely borrowed from scanasm.exp.\n+\n+load_lib scandump.exp\n \n # Utility for scanning compiler result, invoked via dg-final.\n # Call pass if pattern is present, otherwise fail.\n #\n-# Argument 0 is the regexp to match.\n-# Argument 1 is the suffix for the tree dump file\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped tree pass\n # Argument 2 handles expected failures and the like\n proc scan-tree-dump { args } {\n+\n     if { [llength $args] < 2 } {\n \terror \"scan-tree-dump: too few arguments\"\n-        return\n+\treturn\n     }\n     if { [llength $args] > 3 } {\n \terror \"scan-tree-dump: too many arguments\"\n \treturn\n     }\n     if { [llength $args] >= 3 } {\n-\tswitch [dg-process-target [lindex $args 2]] {\n-\t    \"S\" { }\n-\t    \"N\" { return }\n-\t    \"F\" { setup_xfail \"*-*-*\" }\n-\t    \"P\" { }\n-\t}\n-    }\n-\n-    # This assumes that we are two frames down from dg-test, and that\n-    # it still stores the filename of the testcase in a local variable \"name\".\n-    # A cleaner solution would require a new dejagnu release.\n-    upvar 2 name testcase\n-\n-    # This must match the rule in gcc-dg.exp.\n-    set src [file tail [lindex $testcase 0]]\n-    set output_file \"[glob $src.t??.[lindex $args 1]]\"\n-\n-    set fd [open $output_file r]\n-    set text [read $fd]\n-    close $fd\n-\n-    if [regexp -- [lindex $args 0] $text] {\n-\tpass \"$testcase scan-tree-dump [lindex $args 0]\"\n+\tscan-dump \"tree\" [lindex $args 0] \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\" [lindex $args 2]\n     } else {\n-\tfail \"$testcase scan-tree-dump [lindex $args 0]\"\n+\tscan-dump \"tree\" [lindex $args 0] \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n     }\n }\n \n # Call pass if pattern is present given number of times, otherwise fail.\n-# Argument 0 is the regexp to match.\n+# Argument 0 is the regexp to match\n # Argument 1 is number of times the regexp must be found\n-# Argument 2 is the suffix for the tree dump file\n+# Argument 2 is the name of the dumped tree pass\n # Argument 3 handles expected failures and the like\n proc scan-tree-dump-times { args } {\n+\n     if { [llength $args] < 3 } {\n \terror \"scan-tree-dump: too few arguments\"\n-        return\n+\treturn\n     }\n     if { [llength $args] > 4 } {\n \terror \"scan-tree-dump: too many arguments\"\n \treturn\n     }\n     if { [llength $args] >= 4 } {\n-\tswitch [dg-process-target [lindex $args 3]] {\n-\t    \"S\" { }\n-\t    \"N\" { return }\n-\t    \"F\" { setup_xfail \"*-*-*\" }\n-\t    \"P\" { }\n-\t}\n-    }\n-\n-    # This assumes that we are two frames down from dg-test, and that\n-    # it still stores the filename of the testcase in a local variable \"name\".\n-    # A cleaner solution would require a new dejagnu release.\n-    upvar 2 name testcase\n-\n-    # This must match the rule in gcc-dg.exp.\n-    set src [file tail [lindex $testcase 0]]\n-    set output_file \"[glob $src.t??.[lindex $args 2]]\"\n-\n-    set fd [open $output_file r]\n-    set text [read $fd]\n-    close $fd\n-\n-    if { [llength [regexp -inline -all -- [lindex $args 0] $text]] == [lindex $args 1]} {\n-\tpass \"$testcase scan-tree-dump-times [lindex $args 0] [lindex $args 1]\"\n+\tscan-dump-times \"tree\" [lindex $args 0] [lindex $args 1] \\\n+\t\t\t\"t\\[0-9\\]\\[0-9\\].[lindex $args 2]\" [lindex $args 3]\n     } else {\n-\tfail \"$testcase scan-tree-dump-times [lindex $args 0] [lindex $args 1]\"\n+\tscan-dump-times \"tree\" [lindex $args 0] [lindex $args 1] \\\n+\t\t\t\"t\\[0-9\\]\\[0-9\\].[lindex $args 2]\"\n     }\n }\n \n # Call pass if pattern is not present, otherwise fail.\n #\n-# Argument 0 is the regexp to match.\n-# Argument 1 is the suffix for the tree dump file\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped tree pass\n # Argument 2 handles expected failures and the like\n proc scan-tree-dump-not { args } {\n+\n     if { [llength $args] < 2 } {\n \terror \"scan-tree-dump-not: too few arguments\"\n-        return\n+\treturn\n     }\n     if { [llength $args] > 3 } {\n \terror \"scan-tree-dump-not: too many arguments\"\n \treturn\n     }\n     if { [llength $args] >= 3 } {\n-\tswitch [dg-process-target [lindex $args 2]] {\n-\t    \"S\" { }\n-\t    \"N\" { return }\n-\t    \"F\" { setup_xfail \"*-*-*\" }\n-\t    \"P\" { }\n-\t}\n-    }\n-\n-    upvar 2 name testcase\n-    set src [file tail [lindex $testcase 0]]\n-    set output_file \"[glob $src.t??.[lindex $args 1]]\"\n-\n-    set fd [open $output_file r]\n-    set text [read $fd]\n-    close $fd\n-\n-    if ![regexp -- [lindex $args 0] $text] {\n-\tpass \"$testcase scan-tree-dump-not [lindex $args 0]\"\n+\tscan-dump-not \"tree\" [lindex $args 0] \\\n+\t\t      \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\" [lindex $args 2]\n     } else {\n-\tfail \"$testcase scan-tree-dump-not [lindex $args 0]\"\n+\tscan-dump-not \"tree\" [lindex $args 0] \\\n+\t\t      \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n     }\n }\n \n # Utility for scanning demangled compiler result, invoked via dg-final.\n # Call pass if pattern is present, otherwise fail.\n #\n-# Argument 0 is the regexp to match.\n-# Argument 1 is the suffix for the tree dump file\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped tree pass\n # Argument 2 handles expected failures and the like\n proc scan-tree-dump-dem { args } {\n-    global cxxfilt\n-    global base_dir\n \n     if { [llength $args] < 2 } {\n \terror \"scan-tree-dump-dem: too few arguments\"\n-        return\n+\treturn\n     }\n     if { [llength $args] > 3 } {\n \terror \"scan-tree-dump-dem: too many arguments\"\n \treturn\n     }\n     if { [llength $args] >= 3 } {\n-\tswitch [dg-process-target [lindex $args 2]] {\n-\t    \"S\" { }\n-\t    \"N\" { return }\n-\t    \"F\" { setup_xfail \"*-*-*\" }\n-\t    \"P\" { }\n-\t}\n-    }\n-\n-    # Find c++filt like we find g++ in g++.exp.\n-    if ![info exists cxxfilt]  {\n-\tset cxxfilt [findfile $base_dir/../../binutils/cxxfilt \\\n-\t\t     $base_dir/../../binutils/cxxfilt \\\n-\t             [findfile $base_dir/../c++filt $base_dir/../c++filt \\\n-\t\t      [findfile $base_dir/c++filt $base_dir/c++filt \\\n-\t\t       [transform c++filt]]]]\n-\tverbose -log \"c++filt is $cxxfilt\"\n-    }\n-\n-    upvar 2 name testcase\n-    set src [file tail [lindex $testcase 0]]\n-    set output_file \"[glob $src.t??.[lindex $args 1]]\"\n-\n-    set fd [open \"| $cxxfilt < $output_file\" r]\n-    set text [read $fd]\n-    close $fd\n-\n-    if [regexp -- [lindex $args 0] $text] {\n-\tpass \"$testcase scan-tree-dump-dem [lindex $args 0]\"\n+\tscan-dump-dem \"tree\" [lindex $args 0] \\\n+\t\t      \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\" [lindex $args 2]\n     } else {\n-\tfail \"$testcase scan-tree-dump-dem [lindex $args 0]\"\n+\tscan-dump-dem \"tree\" [lindex $args 0] \\\n+\t\t      \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n     }\n }\n \n # Call pass if demangled pattern is not present, otherwise fail.\n #\n-# Argument 0 is the regexp to match.\n-# Argument 1 is the suffix for the tree dump file\n+# Argument 0 is the regexp to match\n+# Argument 1 is the name of the dumped tree pass\n # Argument 2 handles expected failures and the like\n proc scan-tree-dump-dem-not { args } {\n-    global cxxfilt\n-    global base_dir\n \n     if { [llength $args] < 2 } {\n \terror \"scan-tree-dump-dem-not: too few arguments\"\n-        return\n+\treturn\n     }\n     if { [llength $args] > 3 } {\n \terror \"scan-tree-dump-dem-not: too many arguments\"\n \treturn\n     }\n     if { [llength $args] >= 3 } {\n-\tswitch [dg-process-target [lindex $args 2]] {\n-\t    \"S\" { }\n-\t    \"N\" { return }\n-\t    \"F\" { setup_xfail \"*-*-*\" }\n-\t    \"P\" { }\n-\t}\n-    }\n-\n-    # Find c++filt like we find g++ in g++.exp.\n-    if ![info exists cxxfilt]  {\n-\tset cxxfilt [findfile $base_dir/../../binutils/cxxfilt \\\n-\t\t     $base_dir/../../binutils/cxxfilt \\\n-\t\t     [findfile $base_dir/../c++filt $base_dir/../c++filt \\\n-\t\t      [findfile $base_dir/c++filt $base_dir/c++filt \\\n-\t\t       [transform c++filt]]]]\n-\tverbose -log \"c++filt is $cxxfilt\"\n-    }\n-\n-    upvar 2 name testcase\n-    set src [file tail [lindex $testcase 0]]\n-    set output_file \"[glob $src.t??.[lindex $args 1]]\"\n-\n-    set fd [open \"| $cxxfilt < $output_file\" r]\n-    set text [read $fd]\n-    close $fd\n-\n-    if ![regexp -- [lindex $args 0] $text] {\n-\tpass \"$testcase scan-tree-dump-dem-not [lindex $args 0]\"\n+\tscan-dump-dem-not \"tree\" [lindex $args 0] \\\n+\t\t\t  \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\" \\\n+\t\t\t  [lindex $args 2]\n     } else {\n-\tfail \"$testcase scan-tree-dump-dem-not [lindex $args 0]\"\n+\tscan-dump-dem-not \"tree\" [lindex $args 0] \\\n+\t\t\t  \"t\\[0-9\\]\\[0-9\\].[lindex $args 1]\"\n     }\n }"}]}