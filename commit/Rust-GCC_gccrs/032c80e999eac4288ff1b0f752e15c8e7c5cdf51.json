{"sha": "032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMyYzgwZTk5OWVhYzQyODhmZjFiMGY3NTJlMTVjOGU3YzVjZGY1MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-05-02T09:39:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-05-02T09:39:09Z"}, "message": "Support <, <=, > and >= for offset_int and widest_int\n\noffset_int and widest_int are supposed to be at least one bit wider\nthan all the values they need to represent, with the extra bits\nbeing signs.  Thus offset_int is effectively int128_t and widest_int\nis effectively intNNN_t, for target-dependent NNN.\n\nBecause the types are signed, there's not really any need to specify\na sign for operations like comparison.  I think things would be clearer\nif we supported <, <=, > and >= for them (but not for wide_int, which\ndoesn't have a sign).\n\nTested on x86_64-linux-gnu and aarch64-linux-gnu.\n\ngcc/\n\t* wide-int.h: Update offset_int and widest_int documentation.\n\t(WI_SIGNED_BINARY_PREDICATE_RESULT): New macro.\n\t(wi::binary_traits): Allow ordered comparisons between offset_int and\n\toffset_int, between widest_int and widest_int, and between either\n\tof these types and basic C types.\n\t(operator <, <=, >, >=): Define for the same combinations.\n\t* tree.h (tree_int_cst_lt): Use comparison operators instead\n\tof wi:: comparisons.\n\t(tree_int_cst_le): Likewise.\n\t* gimple-fold.c (fold_array_ctor_reference): Likewise.\n\t(fold_nonarray_ctor_reference): Likewise.\n\t* gimple-ssa-strength-reduction.c (record_increment): Likewise.\n\t* tree-affine.c (aff_comb_cannot_overlap_p): Likewise.\n\t* tree-parloops.c (try_transform_to_exit_first_loop_alt): Likewise.\n\t* tree-sra.c (completely_scalarize): Likewise.\n\t* tree-ssa-alias.c (stmt_kills_ref_p): Likewise.\n\t* tree-ssa-reassoc.c (extract_bit_test_mask): Likewise.\n\t* tree-vrp.c (extract_range_from_binary_expr_1): Likewise.\n\t(check_for_binary_op_overflow): Likewise.\n\t(search_for_addr_array): Likewise.\n\t* ubsan.c (ubsan_expand_objsize_ifn): Likewise.\n\nFrom-SVN: r235719", "tree": {"sha": "246e0c0732538d6aaa57d527e1ad81e531ce8ace", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/246e0c0732538d6aaa57d527e1ad81e531ce8ace"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd1e4d417a91f4e802e745c8ff6cc6d88a2e96c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd1e4d417a91f4e802e745c8ff6cc6d88a2e96c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd1e4d417a91f4e802e745c8ff6cc6d88a2e96c1"}], "stats": {"total": 143, "additions": 97, "deletions": 46}, "files": [{"sha": "acc6b798eeecbe76ce786650d68e29f8e3c93986", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -1,3 +1,27 @@\n+2016-05-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* wide-int.h: Update offset_int and widest_int documentation.\n+\t(WI_SIGNED_BINARY_PREDICATE_RESULT): New macro.\n+\t(wi::binary_traits): Allow ordered comparisons between offset_int and\n+\toffset_int, between widest_int and widest_int, and between either\n+\tof these types and basic C types.\n+\t(operator <, <=, >, >=): Define for the same combinations.\n+\t* tree.h (tree_int_cst_lt): Use comparison operators instead\n+\tof wi:: comparisons.\n+\t(tree_int_cst_le): Likewise.\n+\t* gimple-fold.c (fold_array_ctor_reference): Likewise.\n+\t(fold_nonarray_ctor_reference): Likewise.\n+\t* gimple-ssa-strength-reduction.c (record_increment): Likewise.\n+\t* tree-affine.c (aff_comb_cannot_overlap_p): Likewise.\n+\t* tree-parloops.c (try_transform_to_exit_first_loop_alt): Likewise.\n+\t* tree-sra.c (completely_scalarize): Likewise.\n+\t* tree-ssa-alias.c (stmt_kills_ref_p): Likewise.\n+\t* tree-ssa-reassoc.c (extract_bit_test_mask): Likewise.\n+\t* tree-vrp.c (extract_range_from_binary_expr_1): Likewise.\n+\t(check_for_binary_op_overflow): Likewise.\n+\t(search_for_addr_array): Likewise.\n+\t* ubsan.c (ubsan_expand_objsize_ifn): Likewise.\n+\n 2016-05-02  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.c (arc_preferred_simd_mode): Remove enum keyword."}, {"sha": "6ed72dc5883f4c7bd37d6bcc1977a96761588b69", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -5380,7 +5380,7 @@ fold_array_ctor_reference (tree type, tree ctor,\n      be larger than size of array element.  */\n   if (!TYPE_SIZE_UNIT (type)\n       || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST\n-      || wi::lts_p (elt_size, wi::to_offset (TYPE_SIZE_UNIT (type)))\n+      || elt_size < wi::to_offset (TYPE_SIZE_UNIT (type))\n       || elt_size == 0)\n     return NULL_TREE;\n \n@@ -5457,7 +5457,7 @@ fold_nonarray_ctor_reference (tree type, tree ctor,\n \t     fields.  */\n \t  if (wi::cmps (access_end, bitoffset_end) > 0)\n \t    return NULL_TREE;\n-\t  if (wi::lts_p (offset, bitoffset))\n+\t  if (offset < bitoffset)\n \t    return NULL_TREE;\n \t  return fold_ctor_reference (type, cval,\n \t\t\t\t      inner_offset.to_uhwi (), size,"}, {"sha": "b2351511fe08742bbf64fbd3920560323b565443", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -2506,8 +2506,7 @@ record_increment (slsr_cand_t c, widest_int increment, bool is_phi_adjust)\n       if (c->kind == CAND_ADD\n \t  && !is_phi_adjust\n \t  && c->index == increment\n-\t  && (wi::gts_p (increment, 1)\n-\t      || wi::lts_p (increment, -1))\n+\t  && (increment > 1 || increment < -1)\n \t  && (gimple_assign_rhs_code (c->cand_stmt) == PLUS_EXPR\n \t      || gimple_assign_rhs_code (c->cand_stmt) == POINTER_PLUS_EXPR))\n \t{"}, {"sha": "32f2301337439de2ffb0f56176e09adf6c0dd538", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -929,7 +929,7 @@ aff_comb_cannot_overlap_p (aff_tree *diff, const widest_int &size1,\n   else\n     {\n       /* We succeed if the second object starts after the first one ends.  */\n-      return wi::les_p (size1, diff->offset);\n+      return size1 <= diff->offset;\n     }\n }\n "}, {"sha": "25a29bdcb28e59fb0abe418883fbe3148190dfef", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -1868,7 +1868,7 @@ try_transform_to_exit_first_loop_alt (struct loop *loop,\n \n   /* Check if nit + 1 overflows.  */\n   widest_int type_max = wi::to_widest (TYPE_MAXVAL (nit_type));\n-  if (!wi::lts_p (nit_max, type_max))\n+  if (nit_max >= type_max)\n     return false;\n \n   gimple *def = SSA_NAME_DEF_STMT (nit);"}, {"sha": "936d3a6bfcf2601aa829bae6b2c6329b9c397c5a", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -1055,7 +1055,7 @@ completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)\n \t\tidx = wi::sext (idx, TYPE_PRECISION (domain));\n \t\tmax = wi::sext (max, TYPE_PRECISION (domain));\n \t      }\n-\t    for (int el_off = offset; wi::les_p (idx, max); ++idx)\n+\t    for (int el_off = offset; idx <= max; ++idx)\n \t      {\n \t\ttree nref = build4 (ARRAY_REF, elemtype,\n \t\t\t\t    ref,"}, {"sha": "4ffefaf3f4fa4a762c0c103ec0e643ea1dedb3fe", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -2440,10 +2440,10 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t\t  rbase = TREE_OPERAND (rbase, 0);\n \t\t}\n \t      if (base == rbase\n-\t\t  && wi::les_p (offset, roffset)\n-\t\t  && wi::les_p (roffset + ref->max_size,\n-\t\t\t\toffset + wi::lshift (wi::to_offset (len),\n-\t\t\t\t\t\t     LOG2_BITS_PER_UNIT)))\n+\t\t  && offset <= roffset\n+\t\t  && (roffset + ref->max_size\n+\t\t      <= offset + wi::lshift (wi::to_offset (len),\n+\t\t\t\t\t      LOG2_BITS_PER_UNIT)))\n \t\treturn true;\n \t      break;\n \t    }"}, {"sha": "740897756bd59a59c115e64d0fb9a2153510622c", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -2464,7 +2464,7 @@ extract_bit_test_mask (tree exp, int prec, tree totallow, tree low, tree high,\n \t\treturn NULL_TREE;\n \t      bias = wi::to_widest (tbias);\n \t      bias -= wi::to_widest (totallow);\n-\t      if (wi::ges_p (bias, 0) && wi::lts_p (bias, prec - max))\n+\t      if (bias >= 0 && bias < prec - max)\n \t\t{\n \t\t  *mask = wi::lshift (*mask, bias);\n \t\t  return ret;"}, {"sha": "4cd1ab30b30f58b723b67f61a83b982ba242c451", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -2749,17 +2749,17 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  /* Sort the 4 products so that min is in prod0 and max is in\n \t     prod3.  */\n \t  /* min0min1 > max0max1 */\n-\t  if (wi::gts_p (prod0, prod3))\n+\t  if (prod0 > prod3)\n \t    std::swap (prod0, prod3);\n \n \t  /* min0max1 > max0min1 */\n-\t  if (wi::gts_p (prod1, prod2))\n+\t  if (prod1 > prod2)\n \t    std::swap (prod1, prod2);\n \n-\t  if (wi::gts_p (prod0, prod1))\n+\t  if (prod0 > prod1)\n \t    std::swap (prod0, prod1);\n \n-\t  if (wi::gts_p (prod2, prod3))\n+\t  if (prod2 > prod3)\n \t    std::swap (prod2, prod3);\n \n \t  /* diff = max - min.  */\n@@ -3775,7 +3775,7 @@ check_for_binary_op_overflow (enum tree_code subcode, tree type,\n       /* If all values in [wmin, wmax] are smaller than\n \t [wtmin, wtmax] or all are larger than [wtmin, wtmax],\n \t the arithmetic operation will always overflow.  */\n-      if (wi::lts_p (wmax, wtmin) || wi::gts_p (wmin, wtmax))\n+      if (wmax < wtmin || wmin > wtmax)\n \treturn true;\n       return false;\n     }\n@@ -6587,7 +6587,7 @@ search_for_addr_array (tree t, location_t location)\n \n       idx = mem_ref_offset (t);\n       idx = wi::sdiv_trunc (idx, wi::to_offset (el_sz));\n-      if (wi::lts_p (idx, 0))\n+      if (idx < 0)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -6599,8 +6599,8 @@ search_for_addr_array (tree t, location_t location)\n \t\t      \"array subscript is below array bounds\");\n \t  TREE_NO_WARNING (t) = 1;\n \t}\n-      else if (wi::gts_p (idx, (wi::to_offset (up_bound)\n-\t\t\t\t- wi::to_offset (low_bound) + 1)))\n+      else if (idx > (wi::to_offset (up_bound)\n+\t\t      - wi::to_offset (low_bound) + 1))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {"}, {"sha": "aa76f50bab58315c50b2fa78397b8d01df27ad7b", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -5318,7 +5318,7 @@ wi::max_value (const_tree type)\n inline bool\n tree_int_cst_lt (const_tree t1, const_tree t2)\n {\n-  return wi::lts_p (wi::to_widest (t1), wi::to_widest (t2));\n+  return wi::to_widest (t1) < wi::to_widest (t2);\n }\n \n /* Return true if INTEGER_CST T1 is less than or equal to INTEGER_CST T2,\n@@ -5327,7 +5327,7 @@ tree_int_cst_lt (const_tree t1, const_tree t2)\n inline bool\n tree_int_cst_le (const_tree t1, const_tree t2)\n {\n-  return wi::les_p (wi::to_widest (t1), wi::to_widest (t2));\n+  return wi::to_widest (t1) <= wi::to_widest (t2);\n }\n \n /* Returns -1 if T1 < T2, 0 if T1 == T2, and 1 if T1 > T2.  T1 and T2"}, {"sha": "802341e999539cea7ed8a03ea873d5b6a1e88c24", "filename": "gcc/ubsan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -911,8 +911,8 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n     /* Yes, __builtin_object_size couldn't determine the\n        object size.  */;\n   else if (TREE_CODE (offset) == INTEGER_CST\n-\t   && wi::ges_p (wi::to_widest (offset), -OBJSZ_MAX_OFFSET)\n-\t   && wi::les_p (wi::to_widest (offset), -1))\n+\t   && wi::to_widest (offset) >= -OBJSZ_MAX_OFFSET\n+\t   && wi::to_widest (offset) <= -1)\n     /* The offset is in range [-16K, -1].  */;\n   else\n     {\n@@ -928,8 +928,8 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n       /* If the offset is small enough, we don't need the second\n \t run-time check.  */\n       if (TREE_CODE (offset) == INTEGER_CST\n-\t  && wi::ges_p (wi::to_widest (offset), 0)\n-\t  && wi::les_p (wi::to_widest (offset), OBJSZ_MAX_OFFSET))\n+\t  && wi::to_widest (offset) >= 0\n+\t  && wi::to_widest (offset) <= OBJSZ_MAX_OFFSET)\n \t*gsi = gsi_after_labels (then_bb);\n       else\n \t{"}, {"sha": "b1dfcff6ad17f2121e6752c3437cffaedb2239aa", "filename": "gcc/wide-int.h", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032c80e999eac4288ff1b0f752e15c8e7c5cdf51/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=032c80e999eac4288ff1b0f752e15c8e7c5cdf51", "patch": "@@ -53,32 +53,36 @@ along with GCC; see the file COPYING3.  If not see\n      multiply, division, shifts, comparisons, and operations that need\n      overflow detected), the signedness must be specified separately.\n \n-     2) offset_int.  This is a fixed size representation that is\n-     guaranteed to be large enough to compute any bit or byte sized\n-     address calculation on the target.  Currently the value is 64 + 4\n-     bits rounded up to the next number even multiple of\n-     HOST_BITS_PER_WIDE_INT (but this can be changed when the first\n-     port needs more than 64 bits for the size of a pointer).\n-\n-     This flavor can be used for all address math on the target.  In\n-     this representation, the values are sign or zero extended based\n-     on their input types to the internal precision.  All math is done\n-     in this precision and then the values are truncated to fit in the\n-     result type.  Unlike most gimple or rtl intermediate code, it is\n-     not useful to perform the address arithmetic at the same\n-     precision in which the operands are represented because there has\n-     been no effort by the front ends to convert most addressing\n-     arithmetic to canonical types.\n+     2) offset_int.  This is a fixed-precision integer that can hold\n+     any address offset, measured in either bits or bytes, with at\n+     least one extra sign bit.  At the moment the maximum address\n+     size GCC supports is 64 bits.  With 8-bit bytes and an extra\n+     sign bit, offset_int therefore needs to have at least 68 bits\n+     of precision.  We round this up to 128 bits for efficiency.\n+     Values of type T are converted to this precision by sign- or\n+     zero-extending them based on the signedness of T.\n+\n+     The extra sign bit means that offset_int is effectively a signed\n+     128-bit integer, i.e. it behaves like int128_t.\n+\n+     Since the values are logically signed, there is no need to\n+     distinguish between signed and unsigned operations.  Sign-sensitive\n+     comparison operators <, <=, > and >= are therefore supported.\n+\n+     [ Note that, even though offset_int is effectively int128_t,\n+       it can still be useful to use unsigned comparisons like\n+       wi::leu_p (a, b) as a more efficient short-hand for\n+       \"a >= 0 && a <= b\". ]\n \n      3) widest_int.  This representation is an approximation of\n      infinite precision math.  However, it is not really infinite\n      precision math as in the GMP library.  It is really finite\n      precision math where the precision is 4 times the size of the\n      largest integer that the target port can represent.\n \n-     widest_int is supposed to be wider than any number that it needs to\n-     store, meaning that there is always at least one leading sign bit.\n-     All widest_int values are therefore signed.\n+     Like offset_int, widest_int is wider than all the values that\n+     it needs to represent, so the integers are logically signed.\n+     Sign-sensitive comparison operators <, <=, > and >= are supported.\n \n      There are several places in the GCC where this should/must be used:\n \n@@ -255,6 +259,12 @@ along with GCC; see the file COPYING3.  If not see\n #define WI_BINARY_RESULT(T1, T2) \\\n   typename wi::binary_traits <T1, T2>::result_type\n \n+/* The type of result produced by a signed binary predicate on types T1 and T2.\n+   This is bool if signed comparisons make sense for T1 and T2 and leads to\n+   substitution failure otherwise.  */\n+#define WI_SIGNED_BINARY_PREDICATE_RESULT(T1, T2) \\\n+  typename wi::binary_traits <T1, T2>::signed_predicate_result\n+\n /* The type of result produced by a unary operation on type T.  */\n #define WI_UNARY_RESULT(T) \\\n   typename wi::unary_traits <T>::result_type\n@@ -316,7 +326,7 @@ namespace wi\n     VAR_PRECISION,\n \n     /* The integer has a constant precision (known at GCC compile time)\n-       but no defined signedness.  */\n+       and is signed.  */\n     CONST_PRECISION\n   };\n \n@@ -379,6 +389,7 @@ namespace wi\n        so as not to confuse gengtype.  */\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T2>::precision> > result_type;\n+    typedef bool signed_predicate_result;\n   };\n \n   template <typename T1, typename T2>\n@@ -394,6 +405,7 @@ namespace wi\n        so as not to confuse gengtype.  */\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T1>::precision> > result_type;\n+    typedef bool signed_predicate_result;\n   };\n \n   template <typename T1, typename T2>\n@@ -404,6 +416,7 @@ namespace wi\n     STATIC_ASSERT (int_traits <T1>::precision == int_traits <T2>::precision);\n     typedef generic_wide_int < fixed_wide_int_storage\n \t\t\t       <int_traits <T1>::precision> > result_type;\n+    typedef bool signed_predicate_result;\n   };\n \n   template <typename T1, typename T2>\n@@ -3050,6 +3063,21 @@ wi::min_precision (const T &x, signop sgn)\n     return get_precision (x) - clz (x);\n }\n \n+#define SIGNED_BINARY_PREDICATE(OP, F)\t\t\t\\\n+  template <typename T1, typename T2>\t\t\t\\\n+    inline WI_SIGNED_BINARY_PREDICATE_RESULT (T1, T2)\t\\\n+    OP (const T1 &x, const T2 &y)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      return wi::F (x, y);\t\t\t\t\\\n+    }\n+\n+SIGNED_BINARY_PREDICATE (operator <, lts_p)\n+SIGNED_BINARY_PREDICATE (operator <=, les_p)\n+SIGNED_BINARY_PREDICATE (operator >, gts_p)\n+SIGNED_BINARY_PREDICATE (operator >=, ges_p)\n+\n+#undef SIGNED_BINARY_PREDICATE\n+\n template<typename T>\n void\n gt_ggc_mx (generic_wide_int <T> *)"}]}