{"sha": "dce6c58db87ebf7f4477bd3126228e73e4eeee97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNlNmM1OGRiODdlYmY3ZjQ0NzdiZDMxMjYyMjhlNzNlNGVlZWU5Nw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-12-03T22:41:25Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-12-03T22:43:32Z"}, "message": "Add support for detecting mismatched allocation/deallocation calls.\n\nPR c++/90629 - Support for -Wmismatched-new-delete\nPR middle-end/94527 - Add an __attribute__ that marks a function as freeing an object\n\ngcc/ChangeLog:\n\n\tPR c++/90629\n\tPR middle-end/94527\n\t* builtins.c (access_ref::access_ref): Initialize new member.\n\t(compute_objsize): Use access_ref::deref.  Handle simple pointer\n\tassignment.\n\t(expand_builtin): Remove handling of the free built-in.\n\t(call_dealloc_argno): Same.\n\t(find_assignment_location): New function.\n\t(fndecl_alloc_p): Same.\n\t(gimple_call_alloc_p): Same.\n\t(call_dealloc_p): Same.\n\t(matching_alloc_calls_p): Same.\n\t(warn_dealloc_offset): Same.\n\t(maybe_emit_free_warning): Same.\n\t* builtins.h (struct access_ref): Declare new member.\n\t(maybe_emit_free_warning): Make extern.  Make use of access_ref.\n\tHandle -Wmismatched-new-delete.\n\t* calls.c (initialize_argument_information): Call\n\tmaybe_emit_free_warning.\n\t* doc/extend.texi (attribute malloc): Update.\n\t* doc/invoke.texi (-Wfree-nonheap-object): Expand documentation.\n\t(-Wmismatched-new-delete): Document new option.\n\t(-Wmismatched-dealloc): Document new option.\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/90629\n\tPR middle-end/94527\n\t* c-attribs.c (handle_dealloc_attribute): New function.\n\t(handle_malloc_attribute): Handle argument forms of attribute.\n\t* c.opt (-Wmismatched-dealloc): New option.\n\t(-Wmismatched-new-delete): New option.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/90629\n\tPR middle-end/94527\n\t* g++.dg/asan/asan_test.cc: Fix a bug.\n\t* g++.dg/warn/delete-array-1.C: Add expected warning.\n\t* g++.old-deja/g++.other/delete2.C: Add expected warning.\n\t* g++.dg/warn/Wfree-nonheap-object-2.C: New test.\n\t* g++.dg/warn/Wfree-nonheap-object.C: New test.\n\t* g++.dg/warn/Wmismatched-new-delete.C: New test.\n\t* g++.dg/warn/Wmismatched-dealloc-2.C: New test.\n\t* g++.dg/warn/Wmismatched-dealloc.C: New test.\n\t* gcc.dg/Wmismatched-dealloc.c: New test.\n\t* gcc.dg/analyzer/malloc-1.c: Prune out expected warning.\n\t* gcc.dg/attr-malloc.c: New test.\n\t* gcc.dg/free-1.c: Adjust text of expected warning.\n\t* gcc.dg/free-2.c: Same.\n\t* gcc.dg/torture/pr71816.c: Prune out expected warning.\n\t* gcc.dg/tree-ssa/pr19831-2.c: Add an expected warning.\n\t* gcc.dg/Wfree-nonheap-object-2.c: New test.\n\t* gcc.dg/Wfree-nonheap-object-3.c: New test.\n\t* gcc.dg/Wfree-nonheap-object.c: New test.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/ext/vstring/modifiers/clear/56166.cc: Suppress a false\n\tpositive warning.", "tree": {"sha": "f89f18c53c2f16c2d39a1951c21f99cdd4773c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f89f18c53c2f16c2d39a1951c21f99cdd4773c99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dce6c58db87ebf7f4477bd3126228e73e4eeee97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dce6c58db87ebf7f4477bd3126228e73e4eeee97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dce6c58db87ebf7f4477bd3126228e73e4eeee97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dce6c58db87ebf7f4477bd3126228e73e4eeee97/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f7a6957a674caf95c4aefa618be51092022e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f7a6957a674caf95c4aefa618be51092022e87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f7a6957a674caf95c4aefa618be51092022e87"}], "stats": {"total": 2599, "additions": 2530, "deletions": 69}, "files": [{"sha": "bd12659712f72b5606bc2ade5e3be1bff14ebe9c", "filename": "gcc/builtins.c", "status": "modified", "additions": 400, "deletions": 23, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -73,6 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gomp-constants.h\"\n #include \"omp-general.h\"\n #include \"tree-dfa.h\"\n+#include \"gimple-iterator.h\"\n #include \"gimple-ssa.h\"\n #include \"tree-ssa-live.h\"\n #include \"tree-outof-ssa.h\"\n@@ -182,7 +183,6 @@ static rtx expand_builtin_memory_chk (tree, rtx, machine_mode,\n \t\t\t\t      enum built_in_function);\n static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n-static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n static bool compute_objsize_r (tree, int, access_ref *, ssa_name_limit_t &,\n@@ -201,8 +201,8 @@ static void expand_builtin_sync_synchronize (void);\n \n access_ref::access_ref (tree bound /* = NULL_TREE */,\n \t\t\tbool minaccess /* = false */)\n-: ref (), eval ([](tree x){ return x; }), trail1special (true), base0 (true),\n-  parmarray ()\n+: ref (), eval ([](tree x){ return x; }), deref (), trail1special (true),\n+  base0 (true), parmarray ()\n {\n   /* Set to valid.  */\n   offrng[0] = offrng[1] = 0;\n@@ -5313,7 +5313,10 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \n   const bool addr = TREE_CODE (ptr) == ADDR_EXPR;\n   if (addr)\n-    ptr = TREE_OPERAND (ptr, 0);\n+    {\n+      --pref->deref;\n+      ptr = TREE_OPERAND (ptr, 0);\n+    }\n \n   if (DECL_P (ptr))\n     {\n@@ -5421,6 +5424,8 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \n   if (code == ARRAY_REF || code == MEM_REF)\n     {\n+      ++pref->deref;\n+\n       tree ref = TREE_OPERAND (ptr, 0);\n       tree reftype = TREE_TYPE (ref);\n       if (!addr && code == ARRAY_REF\n@@ -5544,6 +5549,10 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n       if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n \treturn false;\n \n+      /* Clear DEREF since the offset is being applied to the target\n+\t of the dereference.  */\n+      pref->deref = 0;\n+\n       offset_int orng[2];\n       tree off = pref->eval (TREE_OPERAND (ptr, 1));\n       if (get_offset_range (off, NULL, orng, rvals))\n@@ -10630,11 +10639,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       maybe_emit_sprintf_chk_warning (exp, fcode);\n       break;\n \n-    case BUILT_IN_FREE:\n-      if (warn_free_nonheap_object)\n-\tmaybe_emit_free_warning (exp);\n-      break;\n-\n     case BUILT_IN_THREAD_POINTER:\n       return expand_builtin_thread_pointer (exp, target);\n \n@@ -12944,30 +12948,403 @@ maybe_emit_sprintf_chk_warning (tree exp, enum built_in_function fcode)\n \t\taccess_write_only);\n }\n \n-/* Emit warning if a free is called with address of a variable.  */\n+/* Return true if STMT is a call to an allocation function.  Unless\n+   ALL_ALLOC is set, consider only functions that return dynmamically\n+   allocated objects.  Otherwise return true even for all forms of\n+   alloca (including VLA).  */\n \n-static void\n+static bool\n+fndecl_alloc_p (tree fndecl, bool all_alloc)\n+{\n+  if (!fndecl)\n+    return false;\n+\n+  /* A call to operator new isn't recognized as one to a built-in.  */\n+  if (DECL_IS_OPERATOR_NEW_P (fndecl))\n+    return true;\n+\n+  if (fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n+    {\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tcase BUILT_IN_ALLOCA:\n+\tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n+\t  return all_alloc;\n+\tcase BUILT_IN_CALLOC:\n+\tcase BUILT_IN_MALLOC:\n+\tcase BUILT_IN_REALLOC:\n+\tcase BUILT_IN_STRDUP:\n+\tcase BUILT_IN_STRNDUP:\n+\t  return true;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  /* A function is considered an allocation function if it's declared\n+     with attribute malloc with an argument naming its associated\n+     deallocation function.  */\n+  tree attrs = DECL_ATTRIBUTES (fndecl);\n+  if (!attrs)\n+    return false;\n+\n+  for (tree allocs = attrs;\n+       (allocs = lookup_attribute (\"malloc\", allocs));\n+       allocs = TREE_CHAIN (allocs))\n+    {\n+      tree args = TREE_VALUE (allocs);\n+      if (!args)\n+\tcontinue;\n+\n+      if (TREE_VALUE (args))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if STMT is a call to an allocation function.  A wrapper\n+   around fndecl_alloc_p.  */\n+\n+static bool\n+gimple_call_alloc_p (gimple *stmt, bool all_alloc = false)\n+{\n+  return fndecl_alloc_p (gimple_call_fndecl (stmt), all_alloc);\n+}\n+\n+/* Return the zero-based number corresponding to the argument being\n+   deallocated if STMT is a call to a deallocation function or UINT_MAX\n+   if it isn't.  */\n+\n+static unsigned\n+call_dealloc_argno (tree exp)\n+{\n+  tree fndecl = get_callee_fndecl (exp);\n+  if (!fndecl)\n+    return UINT_MAX;\n+\n+  /* A call to operator delete isn't recognized as one to a built-in.  */\n+  if (DECL_IS_OPERATOR_DELETE_P (fndecl))\n+    return 0;\n+\n+  /* TODO: Handle user-defined functions with attribute malloc?  Handle\n+     known non-built-ins like fopen?  */\n+  if (fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n+    {\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tcase BUILT_IN_FREE:\n+\tcase BUILT_IN_REALLOC:\n+\t  return 0;\n+\tdefault:\n+\t  break;\n+\t}\n+      return UINT_MAX;\n+    }\n+\n+  tree attrs = DECL_ATTRIBUTES (fndecl);\n+  if (!attrs)\n+    return UINT_MAX;\n+\n+  for (tree atfree = attrs;\n+       (atfree = lookup_attribute (\"*dealloc\", atfree));\n+       atfree = TREE_CHAIN (atfree))\n+    {\n+      tree alloc = TREE_VALUE (atfree);\n+      if (!alloc)\n+\tcontinue;\n+\n+      tree pos = TREE_CHAIN (alloc);\n+      if (!pos)\n+\treturn 0;\n+\n+      pos = TREE_VALUE (pos);\n+      return TREE_INT_CST_LOW (pos) - 1;\n+    }\n+\n+  return UINT_MAX;\n+}\n+\n+/* Return true if STMT is a call to a deallocation function.  */\n+\n+static inline bool\n+call_dealloc_p (tree exp)\n+{\n+  return call_dealloc_argno (exp) != UINT_MAX;\n+}\n+\n+/* ALLOC_DECL and DEALLOC_DECL are pair of allocation and deallocation\n+   functions.  Return true if the latter is suitable to deallocate objects\n+   allocated by calls to the former.  */\n+\n+static bool\n+matching_alloc_calls_p (tree alloc_decl, tree dealloc_decl)\n+{\n+  if (DECL_IS_OPERATOR_NEW_P (alloc_decl))\n+    {\n+      if (DECL_IS_OPERATOR_DELETE_P (dealloc_decl))\n+\t{\n+\t  /* Return true iff both functions are of the same array or\n+\t     singleton form and false otherwise.  */\n+\t  tree alloc_id = DECL_NAME (alloc_decl);\n+\t  tree dealloc_id = DECL_NAME (dealloc_decl);\n+\t  const char *alloc_fname = IDENTIFIER_POINTER (alloc_id);\n+\t  const char *dealloc_fname = IDENTIFIER_POINTER (dealloc_id);\n+\t  return !strchr (alloc_fname, '[') == !strchr (dealloc_fname, '[');\n+\t}\n+\n+      /* Return false for deallocation functions that are known not\n+\t to match.  */\n+      if (fndecl_built_in_p (dealloc_decl, BUILT_IN_FREE)\n+\t  || fndecl_built_in_p (dealloc_decl, BUILT_IN_REALLOC))\n+\treturn false;\n+      /* Otherwise proceed below to check the deallocation function's\n+\t \"*dealloc\" attributes to look for one that mentions this operator\n+\t new.  */\n+    }\n+  else if (fndecl_built_in_p (alloc_decl, BUILT_IN_NORMAL))\n+    {\n+      switch (DECL_FUNCTION_CODE (alloc_decl))\n+\t{\n+\tcase BUILT_IN_ALLOCA:\n+\tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n+\t  return false;\n+\n+\tcase BUILT_IN_CALLOC:\n+\tcase BUILT_IN_MALLOC:\n+\tcase BUILT_IN_REALLOC:\n+\tcase BUILT_IN_STRDUP:\n+\tcase BUILT_IN_STRNDUP:\n+\t  if (DECL_IS_OPERATOR_DELETE_P (dealloc_decl))\n+\t    return false;\n+\n+\t  if (fndecl_built_in_p (dealloc_decl, BUILT_IN_FREE)\n+\t      || fndecl_built_in_p (dealloc_decl, BUILT_IN_REALLOC))\n+\t    return true;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  /* If DEALLOC_DECL has internal \"*dealloc\" attribute scan the list of\n+     its associated allocation functions for ALLOC_DECL.  If it's found\n+     they are a matching pair, otherwise they're not.  */\n+  tree attrs = DECL_ATTRIBUTES (dealloc_decl);\n+  if (!attrs)\n+    return false;\n+\n+  for (tree funs = attrs;\n+       (funs = lookup_attribute (\"*dealloc\", funs));\n+       funs = TREE_CHAIN (funs))\n+    {\n+      tree args = TREE_VALUE (funs);\n+      if (!args)\n+\tcontinue;\n+\n+      tree fname = TREE_VALUE (args);\n+      if (!fname)\n+\tcontinue;\n+\n+      if (fname == DECL_NAME (alloc_decl))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if DEALLOC_DECL is a function suitable to deallocate\n+   objectes allocated by the ALLOC call.  */\n+\n+static bool\n+matching_alloc_calls_p (gimple *alloc, tree dealloc_decl)\n+{\n+  tree alloc_decl = gimple_call_fndecl (alloc);\n+  if (!alloc_decl)\n+    return true;\n+\n+  return matching_alloc_calls_p (alloc_decl, dealloc_decl);\n+}\n+\n+/* Diagnose a call to FNDECL to deallocate a pointer referenced by\n+   AREF that includes a nonzero offset.  Such a pointer cannot refer\n+   to the beginning of an allocated object.  A negative offset may\n+   refer to it only if the target pointer is unknown.  */\n+\n+static bool\n+warn_dealloc_offset (location_t loc, tree exp, tree fndecl,\n+\t\t     const access_ref &aref)\n+{\n+  char offstr[80];\n+  offstr[0] = '\\0';\n+  if (wi::fits_shwi_p (aref.offrng[0]))\n+    {\n+      if (aref.offrng[0] == aref.offrng[1]\n+\t  || !wi::fits_shwi_p (aref.offrng[1]))\n+\tsprintf (offstr, \" %lli\",\n+\t\t (long long)aref.offrng[0].to_shwi ());\n+      else\n+\tsprintf (offstr, \" [%lli, %lli]\",\n+\t\t (long long)aref.offrng[0].to_shwi (),\n+\t\t (long long)aref.offrng[1].to_shwi ());\n+    }\n+\n+  if (!warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t   \"%K%qD called on pointer %qE with nonzero offset%s\",\n+\t\t   exp, fndecl, aref.ref, offstr))\n+    return false;\n+\n+  if (DECL_P (aref.ref))\n+    inform (DECL_SOURCE_LOCATION (aref.ref), \"declared here\");\n+  else if (TREE_CODE (aref.ref) == SSA_NAME)\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (aref.ref);\n+      if (is_gimple_call (def_stmt))\n+\t{\n+\t  tree alloc_decl = gimple_call_fndecl (def_stmt);\n+\t  inform (gimple_location (def_stmt),\n+\t\t  \"returned from a call to %qD\", alloc_decl);\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Issue a warning if a deallocation function such as free, realloc,\n+   or C++ operator delete is called with an argument not returned by\n+   a matching allocation function such as malloc or the corresponding\n+   form of C++ operatorn new.  */\n+\n+void\n maybe_emit_free_warning (tree exp)\n {\n-  if (call_expr_nargs (exp) != 1)\n+  tree fndecl = get_callee_fndecl (exp);\n+  if (!fndecl)\n     return;\n \n-  tree arg = CALL_EXPR_ARG (exp, 0);\n+  unsigned argno = call_dealloc_argno (exp);\n+  if ((unsigned) call_expr_nargs (exp) <= argno)\n+    return;\n \n-  STRIP_NOPS (arg);\n-  if (TREE_CODE (arg) != ADDR_EXPR)\n+  tree ptr = CALL_EXPR_ARG (exp, argno);\n+  if (integer_zerop (ptr))\n     return;\n \n-  arg = get_base_address (TREE_OPERAND (arg, 0));\n-  if (arg == NULL || INDIRECT_REF_P (arg) || TREE_CODE (arg) == MEM_REF)\n+  access_ref aref;\n+  if (!compute_objsize (ptr, 0, &aref))\n     return;\n \n-  if (SSA_VAR_P (arg))\n-    warning_at (tree_nonartificial_location (exp), OPT_Wfree_nonheap_object,\n-\t\t\"%Kattempt to free a non-heap object %qD\", exp, arg);\n-  else\n-    warning_at (tree_nonartificial_location (exp), OPT_Wfree_nonheap_object,\n-\t\t\"%Kattempt to free a non-heap object\", exp);\n+  tree ref = aref.ref;\n+  if (integer_zerop (ref))\n+    return;\n+\n+  tree dealloc_decl = get_callee_fndecl (exp);\n+  location_t loc = tree_nonartificial_location (exp);\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  if (DECL_P (ref) || EXPR_P (ref))\n+    {\n+      /* Diagnose freeing a declared object.  */\n+      if (aref.ref_declared ()\n+\t  && warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t\t \"%K%qD called on unallocated object %qD\",\n+\t\t\t exp, dealloc_decl, ref))\n+\t{\n+\t  inform (DECL_SOURCE_LOCATION (ref),\n+\t\t  \"declared here\");\n+\t  return;\n+\t}\n+\n+      /* Diagnose freeing a pointer that includes a positive offset.\n+\t Such a pointer cannot refer to the beginning of an allocated\n+\t object.  A negative offset may refer to it.  */\n+      if (!aref.deref\n+\t  && aref.sizrng[0] != aref.sizrng[1]\n+\t  && aref.offrng[0] > 0 && aref.offrng[1] > 0\n+\t  && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+\treturn;\n+    }\n+  else if (CONSTANT_CLASS_P (ref))\n+    {\n+      if (warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t      \"%K%qD called on a pointer to an unallocated \"\n+\t\t      \"object %qE\", exp, dealloc_decl, ref))\n+\t{\n+\t  if (TREE_CODE (ptr) == SSA_NAME)\n+\t    {\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (ptr);\n+\t      if (is_gimple_assign (def_stmt))\n+\t\t{\n+\t\t  location_t loc = gimple_location (def_stmt);\n+\t\t  inform (loc, \"assigned here\");\n+\t\t}\n+\t    }\n+\t  return;\n+\t}\n+    }\n+  else if (TREE_CODE (ref) == SSA_NAME)\n+    {\n+      /* Also warn if the pointer argument refers to the result\n+\t of an allocation call like alloca or VLA.  */\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (ref);\n+      if (is_gimple_call (def_stmt))\n+\t{\n+\t  bool warned = false;\n+\t  if (gimple_call_alloc_p (def_stmt))\n+\t    {\n+\t      if (matching_alloc_calls_p (def_stmt, dealloc_decl))\n+\t\t{\n+\t\t  if (!aref.deref\n+\t\t      && aref.offrng[0] > 0 && aref.offrng[1] > 0\n+\t\t      && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+\t\t    return;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree alloc_decl = gimple_call_fndecl (def_stmt);\n+\t\t  int opt = (DECL_IS_OPERATOR_NEW_P (alloc_decl)\n+\t\t\t     || DECL_IS_OPERATOR_DELETE_P (dealloc_decl)\n+\t\t\t     ? OPT_Wmismatched_new_delete\n+\t\t\t     : OPT_Wmismatched_dealloc);\n+\t\t  warned = warning_at (loc, opt,\n+\t\t\t\t       \"%K%qD called on pointer returned \"\n+\t\t\t\t       \"from a mismatched allocation \"\n+\t\t\t\t       \"function\", exp, dealloc_decl);\n+\t\t}\n+\t    }\n+\t  else if (gimple_call_builtin_p (def_stmt, BUILT_IN_ALLOCA)\n+\t    \t   || gimple_call_builtin_p (def_stmt,\n+\t    \t\t\t\t     BUILT_IN_ALLOCA_WITH_ALIGN))\n+\t    warned = warning_at (loc, OPT_Wfree_nonheap_object,\n+\t\t\t\t \"%K%qD called on pointer to \"\n+\t\t\t\t \"an unallocated object\",\n+\t\t\t\t exp, dealloc_decl);\n+\t  else if (!aref.deref\n+\t\t   && aref.offrng[0] > 0 && aref.offrng[1] > 0\n+\t\t   && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+\t    return;\n+\n+\t  if (warned)\n+\t    {\n+\t      tree fndecl = gimple_call_fndecl (def_stmt);\n+\t      inform (gimple_location (def_stmt),\n+\t\t      \"returned from a call to %qD\", fndecl);\n+\t      return;\n+\t    }\n+\t}\n+      else if (gimple_nop_p (def_stmt))\n+\t{\n+\t  ref = SSA_NAME_VAR (ref);\n+\t  /* Diagnose freeing a pointer that includes a positive offset.  */\n+\t  if (TREE_CODE (ref) == PARM_DECL\n+\t      && !aref.deref\n+\t      && aref.sizrng[0] != aref.sizrng[1]\n+\t      && aref.offrng[0] > 0 && aref.offrng[1] > 0\n+\t      && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+\t    return;\n+\t}\n+    }\n }\n \n /* Fold a call to __builtin_object_size with arguments PTR and OST,"}, {"sha": "642923281c1de5d4576e2afaa4b163a436e57d34", "filename": "gcc/builtins.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -220,6 +220,12 @@ struct access_ref\n      argument to the minimum.  */\n   offset_int size_remaining (offset_int * = NULL) const;\n \n+  /* Return true if *THIS is an access to a declared object.  */\n+  bool ref_declared () const\n+  {\n+    return DECL_P (ref) && base0 && deref < 1;\n+  }\n+\n   /* Set the size range to the maximum.  */\n   void set_max_size_range ()\n   {\n@@ -261,6 +267,9 @@ struct access_ref\n \n   /* Used to fold integer expressions when called from front ends.  */\n   tree (*eval)(tree);\n+  /* Positive when REF is dereferenced, negative when its address is\n+     taken.  */\n+  int deref;\n   /* Set if trailing one-element arrays should be treated as flexible\n      array members.  */\n   bool trail1special;\n@@ -350,5 +359,6 @@ extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n \t\t\t     range_query * = NULL);\n extern bool check_access (tree, tree, tree, tree, tree,\n \t\t\t  access_mode, const access_data * = NULL);\n+extern void maybe_emit_free_warning (tree);\n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "f7dad7a91d702bd9081283997acc47f794ea80fb", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 171, "deletions": 9, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -113,6 +113,7 @@ static tree handle_no_instrument_function_attribute (tree *, tree,\n static tree handle_no_profile_instrument_function_attribute (tree *, tree,\n \t\t\t\t\t\t\t     tree, int, bool *);\n static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_dealloc_attribute (tree *, tree, tree, int, bool *);\n static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n static tree handle_no_limit_stack_attribute (tree *, tree, tree, int,\n \t\t\t\t\t     bool *);\n@@ -364,7 +365,7 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"no_profile_instrument_function\",  0, 0, true, false, false, false,\n \t\t\t      handle_no_profile_instrument_function_attribute,\n \t\t\t      NULL },\n-  { \"malloc\",                 0, 0, true,  false, false, false,\n+  { \"malloc\",                 0, 2, true,  false, false, false,\n \t\t\t      handle_malloc_attribute, attr_alloc_exclusions },\n   { \"returns_twice\",          0, 0, true,  false, false, false,\n \t\t\t      handle_returns_twice_attribute,\n@@ -524,6 +525,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_objc_root_class_attribute, NULL },\n   { \"objc_nullability\",\t      1, 1, true, false, false, false,\n \t\t\t      handle_objc_nullability_attribute, NULL },\n+  { \"*dealloc\",                1, 2, true, false, false, false,\n+\t\t\t      handle_dealloc_attribute, NULL },\n   { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -3127,20 +3130,179 @@ handle_no_profile_instrument_function_attribute (tree *node, tree name, tree,\n   return NULL_TREE;\n }\n \n-/* Handle a \"malloc\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n+/* Handle the \"malloc\" attribute.  */\n \n static tree\n-handle_malloc_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+handle_malloc_attribute (tree *node, tree name, tree args,\n \t\t\t int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n-  if (TREE_CODE (*node) == FUNCTION_DECL\n-      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (*node))))\n-    DECL_IS_MALLOC (*node) = 1;\n-  else\n+  tree fndecl = *node;\n+\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored; valid only \"\n+\t       \"for functions\",\n+\t       name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  tree rettype = TREE_TYPE (TREE_TYPE (*node));\n+  if (!POINTER_TYPE_P (rettype))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored on functions \"\n+\t       \"returning %qT; valid only for pointer return types\",\n+\t       name, rettype);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (!args)\n+    {\n+      /* Only the form of the attribute with no arguments declares\n+\t a function malloc-like.  */\n+      DECL_IS_MALLOC (*node) = 1;\n+      return NULL_TREE;\n+    }\n+\n+  tree dealloc = TREE_VALUE (args);\n+  if (error_operand_p (dealloc))\n+    {\n+      /* If the argument is in error it will have already been diagnosed.\n+\t Avoid issuing redundant errors here.  */\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* In C++ the argument may be wrapped in a cast to disambiguate one\n+     of a number of overloads (such as operator delete).  Strip it.  */\n+  STRIP_NOPS (dealloc);\n+  if (TREE_CODE (dealloc) == ADDR_EXPR)\n+    dealloc = TREE_OPERAND (dealloc, 0);\n+\n+  if (TREE_CODE (dealloc) != FUNCTION_DECL)\n+    {\n+      if (TREE_CODE (dealloc) == OVERLOAD)\n+\t{\n+\t  /* Handle specially the common case of specifying one of a number\n+\t     of overloads, such as operator delete.  */\n+\t  error (\"%qE attribute argument 1 is ambiguous\", name);\n+\t  inform (input_location,\n+\t\t  \"use a cast to the expected type to disambiguate\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      error (\"%qE attribute argument 1 does not name a function\", name);\n+      if (DECL_P (dealloc))\n+\tinform (DECL_SOURCE_LOCATION (dealloc),\n+\t\t\"argument references a symbol declared here\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* Mentioning the deallocation function qualifies as its use.  */\n+  TREE_USED (dealloc) = 1;\n+\n+  tree fntype = TREE_TYPE (dealloc);\n+  tree argpos = TREE_CHAIN (args) ? TREE_VALUE (TREE_CHAIN (args)) : NULL_TREE;\n+  if (!argpos)\n+    {\n+      tree argtypes = TYPE_ARG_TYPES (fntype);\n+      if (!argtypes)\n+\t{\n+\t  /* Reject functions without a prototype.  */\n+\t  error (\"%qE attribute argument 1 must take a pointer \"\n+\t\t \"type as its first argument\", name);\n+\t  inform (DECL_SOURCE_LOCATION (dealloc),\n+\t\t  \"refernced symbol declared here\" );\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      tree argtype = TREE_VALUE (argtypes);\n+      if (TREE_CODE (argtype) != POINTER_TYPE)\n+\t{\n+\t  /* Reject functions that don't take a pointer as their first\n+\t     argument.  */\n+\t  error (\"%qE attribute argument 1 must take a pointer type \"\n+\t\t \"as its first argument; have %qT\", name, argtype);\n+\t  inform (DECL_SOURCE_LOCATION (dealloc),\n+\t\t  \"referenced symbol declared here\" );\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      *no_add_attrs = false;\n+      tree attr_free = build_tree_list (NULL_TREE, DECL_NAME (fndecl));\n+      attr_free = build_tree_list (get_identifier (\"*dealloc\"), attr_free);\n+      decl_attributes (&dealloc, attr_free, 0);\n+      return NULL_TREE;\n+    }\n+\n+  /* Validate the positional argument.  */\n+  argpos = positional_argument (fntype, name, argpos, POINTER_TYPE);\n+  if (!argpos)\n     {\n-      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* It's valid to declare the same function with multiple instances\n+     of attribute malloc, each naming the same or different deallocator\n+     functions, and each referencing either the same or a different\n+     positional argument.  */\n+  *no_add_attrs = false;\n+  tree attr_free = tree_cons (NULL_TREE, argpos, NULL_TREE);\n+  attr_free = tree_cons (NULL_TREE, DECL_NAME (fndecl), attr_free);\n+  attr_free = build_tree_list (get_identifier (\"*dealloc\"), attr_free);\n+  decl_attributes (&dealloc, attr_free, 0);\n+  return NULL_TREE;\n+}\n+\n+/* Handle the internal \"*dealloc\" attribute added for functions declared\n+   with the one- and two-argument forms of attribute malloc.  Add it\n+   to *NODE unless it's already there with the same arguments.  */\n+\n+static tree\n+handle_dealloc_attribute (tree *node, tree name, tree args, int,\n+\t\t\t  bool *no_add_attrs)\n+{\n+  tree fndecl = *node;\n+\n+  tree attrs = DECL_ATTRIBUTES (fndecl);\n+  if (!attrs)\n+    return NULL_TREE;\n+\n+  tree arg_fname = TREE_VALUE (args);\n+  args = TREE_CHAIN (args);\n+  tree arg_pos = args ? TREE_VALUE (args) : NULL_TREE;\n+\n+  gcc_checking_assert (TREE_CODE (arg_fname) == IDENTIFIER_NODE);\n+\n+  const char* const namestr = IDENTIFIER_POINTER (name);\n+  for (tree at = attrs; (at = lookup_attribute (namestr, at));\n+       at = TREE_CHAIN (at))\n+    {\n+      tree alloc = TREE_VALUE (at);\n+      if (!alloc)\n+\tcontinue;\n+\n+      tree pos = TREE_CHAIN (alloc);\n+      alloc = TREE_VALUE (alloc);\n+      pos = pos ? TREE_VALUE (pos) : NULL_TREE;\n+      gcc_checking_assert (TREE_CODE (alloc) == IDENTIFIER_NODE);\n+\n+      if (alloc == arg_fname\n+\t  && ((!pos && !arg_pos)\n+\t      || (pos && arg_pos && tree_int_cst_equal (pos, arg_pos))))\n+\t{\n+\t  /* The function already has the attribute either without any\n+\t     arguments or with the same arguments as the attribute that's\n+\t     being added.  Return without adding another copy.  */\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n     }\n \n   return NULL_TREE;"}, {"sha": "79478285070e3e836cb987fec8869dba84a7a143", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -793,6 +793,16 @@ Wmisleading-indentation\n C C++ Common Var(warn_misleading_indentation) Warning LangEnabledBy(C C++,Wall)\n Warn when the indentation of the code does not reflect the block structure.\n \n+Wmismatched-dealloc\n+C ObjC C++ ObjC++ Var(warn_mismatched_alloc) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n+Warn for deallocation calls with arguments returned from mismatched allocation\n+functions.\n+\n+Wmismatched-new-delete\n+C++ ObjC++ Var(warn_mismatched_new_delete) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n+Warn for mismatches between calls to operator new or delete and the corrsponding\n+call to the allocation or deallocation function.\n+\n Wmismatched-tags\n C++ ObjC++ Var(warn_mismatched_tags) Warning\n Warn when a class is redeclared or referenced using a mismatched class-key."}, {"sha": "4114bf5e5b2337e23c26074dc60ca4faa3156257", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -2623,6 +2623,10 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n   /* Check attribute access arguments.  */\n   maybe_warn_rdwr_sizes (&rdwr_idx, fndecl, fntype, exp);\n+\n+  /* Check calls to operator new for mismatched forms and attempts\n+     to deallocate unallocated objects.  */\n+  maybe_emit_free_warning (exp);\n }\n \n /* Update ARGS_SIZE to contain the total size for the argument block."}, {"sha": "435761572cd35c81a351f4471222c48f7aff201a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -3233,20 +3233,63 @@ this reason the attribute is not allowed on types to annotate indirect\n calls.\n \n @item malloc\n+@item malloc (@var{deallocator})\n+@item malloc (@var{deallocator}, @var{ptr-index})\n @cindex @code{malloc} function attribute\n @cindex functions that behave like malloc\n-This tells the compiler that a function is @code{malloc}-like, i.e.,\n-that the pointer @var{P} returned by the function cannot alias any\n+Attribute @code{malloc} indicates that a function is @code{malloc}-like,\n+i.e., that the pointer @var{P} returned by the function cannot alias any\n other pointer valid when the function returns, and moreover no\n pointers to valid objects occur in any storage addressed by @var{P}.\n \n-Using this attribute can improve optimization.  Compiler predicts\n-that a function with the attribute returns non-null in most cases.\n-Functions like\n-@code{malloc} and @code{calloc} have this property because they return\n-a pointer to uninitialized or zeroed-out storage.  However, functions\n-like @code{realloc} do not have this property, as they can return a\n-pointer to storage containing pointers.\n+Independently, the form of the attribute with one or two arguments\n+associates @code{deallocator} as a suitable deallocation function for\n+pointers returned from the @code{malloc}-like function.  @var{ptr-index}\n+denotes the positional argument to which when the pointer is passed in\n+calls to @code{deallocator} has the effect of deallocating it.\n+\n+Using the attribute with no arguments is designed to improve optimization.\n+The compiler predicts that a function with the attribute returns non-null\n+in most cases.  Functions like @code{malloc} and @code{calloc} have this\n+property because they return a pointer to uninitialized or zeroed-out\n+storage.  However, functions like @code{realloc} do not have this property,\n+as they may return pointers to storage containing pointers to existing\n+objects.\n+\n+Associating a function with a @var{deallocator} helps detect calls to\n+mismatched allocation and deallocation functions and diagnose them\n+under the control of options such as @option{-Wmismatched-dealloc}.\n+To indicate that an allocation function both satisifies the nonaliasing\n+property and has a deallocator associated with it, both the plain form\n+of the attribute and the one with the @var{deallocator} argument must\n+be used.\n+\n+For example, besides stating that the functions return pointers that do\n+not alias any others, the following declarations make the @code{fclose}\n+and @code{frepen} functions suitable deallocators for pointers returned\n+from all the functions that return them, and the @code{pclose} function\n+as the only other suitable deallocator besides @code{freopen} for pointers\n+returned from @code{popen}.  The deallocator functions must declared\n+before they can be referenced in the attribute.\n+\n+@smallexample\n+int   fclose (FILE*);\n+FILE* freopen (const char*, const char*, FILE*);\n+int   pclose (FILE*);\n+\n+__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+  FILE* fdopen (int);\n+__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+  FILE* fopen (const char*, const char*);\n+__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+  FILE* fmemopen(void *, size_t, const char *);\n+__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+  FILE* freopen (const char*, const char*, FILE*);\n+__attribute__ ((malloc, malloc (pclose), malloc (freopen, 3)))\n+  FILE* popen (const char*, const char*);\n+__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+  FILE* tmpfile (void);\n+@end smallexample\n \n @item no_icf\n @cindex @code{no_icf} function attribute"}, {"sha": "615eae9a1c5d1256ca758431b159e88bed0b9a77", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 88, "deletions": 3, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -242,7 +242,8 @@ in the following sections.\n -Wno-deprecated-enum-enum-conversion -Wno-deprecated-enum-float-conversion @gol\n -Weffc++  -Wno-exceptions -Wextra-semi  -Wno-inaccessible-base @gol\n -Wno-inherited-variadic-ctor  -Wno-init-list-lifetime @gol\n--Wno-invalid-offsetof  -Wno-literal-suffix  -Wmismatched-tags @gol\n+-Wno-invalid-offsetof  -Wno-literal-suffix @gol\n+-Wno-mismatched-new-delete -Wmismatched-tags @gol\n -Wmultiple-inheritance  -Wnamespaces  -Wnarrowing @gol\n -Wnoexcept  -Wnoexcept-type  -Wnon-virtual-dtor @gol\n -Wpessimizing-move  -Wno-placement-new  -Wplacement-new=@var{n} @gol\n@@ -3859,6 +3860,40 @@ The warning is inactive inside a system header file, such as the STL, so\n one can still use the STL.  One may also instantiate or specialize\n templates.\n \n+@item -Wno-mismatched-new-delete @r{(C++ and Objective-C++ only)}\n+@opindex Wmismatched-new-delete\n+@opindex Wno-mismatched-new-delete\n+Warn for mismatches between calls to @code{operator new} or @code{operator\n+delete} and the corresponding call to the allocation or deallocation function.\n+This includes invocations of C++ @code{operator delete} with pointers\n+returned from either mismatched forms of @code{operator new}, or from other\n+functions that allocate objects for which the @code{operator delete} isn't\n+a suitable deallocator, as well as calls to other deallocation functions\n+with pointers returned from @code{operator new} for which the deallocation\n+function isn't suitable.\n+\n+For example, the @code{delete} expression in the function below is diagnosed\n+because it doesn't match the array form of the @code{new} expression\n+the pointer argument was returned from.  Similarly, the call to @code{free}\n+is also diagnosed.\n+\n+@smallexample\n+void f ()\n+@{\n+  int *a = new int[n];\n+  delete a;   // warning: mismatch in array forms of expressions\n+\n+  char *p = new char[n];\n+  free (p);   // warning: mismatch between new and free\n+@}\n+@end smallexample\n+\n+The related option @option{-Wmismatched-dealloc} diagnoses mismatches\n+involving allocation and deallocation functions other than @code{operator\n+new} and @code{operator delete}.\n+\n+@option{-Wmismatched-new-delete} is enabled by default.\n+\n @item -Wmismatched-tags @r{(C++ and Objective-C++ only)}\n @opindex Wmismatched-tags\n @opindex Wno-mismatched-tags\n@@ -6287,6 +6322,41 @@ Ignoring the warning can result in poorly optimized code.\n disable the warning, but this is not recommended and should be done only\n when non-existent profile data is justified.\n \n+@item -Wno-mismatched-dealloc\n+@opindex Wmismatched-dealloc\n+@opindex Wno-mismatched-dealloc\n+\n+Warn for calls to deallocation functions with pointer arguments returned\n+from from allocations functions for which the former isn't a suitable\n+deallocator.  A pair of functions can be associated as matching allocators\n+and deallocators by use of attribute @code{malloc}.  Unless disabled by\n+the @option{-fno-builtin} option the standard functions @code{calloc},\n+@code{malloc}, @code{realloc}, and @code{free}, as well as the corresponding\n+forms of C++ @code{operator new} and @code{operator delete} are implicitly\n+associated as matching allocators and deallocators.  In the following\n+example @code{mydealloc} is the deallocator for pointers returned from\n+@code{myalloc}.\n+\n+@smallexample\n+void mydealloc (void*);\n+\n+__attribute__ ((malloc (mydealloc, 1))) void*\n+myalloc (size_t);\n+\n+void f (void)\n+@{\n+  void *p = myalloc (32);\n+  // @dots{}use p@dots{}\n+  free (p);   // warning: not a matching deallocator for myalloc\n+  mydealloc (p);   // ok\n+@}\n+@end smallexample\n+\n+In C++, the related option @option{-Wmismatched-new-delete} diagnoses\n+mismatches involving either @code{operator new} or @code{operator delete}.\n+\n+Option @option{-Wmismatched-dealloc} is enabled by default.\n+\n @item -Wmultistatement-macros\n @opindex Wmultistatement-macros\n @opindex Wno-multistatement-macros\n@@ -7778,8 +7848,23 @@ to @option{-Wframe-larger-than=}@samp{SIZE_MAX} or larger.\n @item -Wno-free-nonheap-object\n @opindex Wno-free-nonheap-object\n @opindex Wfree-nonheap-object\n-Do not warn when attempting to free an object that was not allocated\n-on the heap.\n+Warn when attempting to deallocate an object that was either not allocated\n+on the heap, or by using a pointer that was not returned from a prior call\n+to the corresponding allocation function.  For example, because the call\n+to @code{stpcpy} returns a pointer to the terminating nul character and\n+not to the begginning of the object, the call to @code{free} below is\n+diagnosed.\n+\n+@smallexample\n+void f (char *p)\n+@{\n+  p = stpcpy (p, \"abc\");\n+  // ...\n+  free (p);   // warning\n+@}\n+@end smallexample\n+\n+@option{-Wfree-nonheap-object} is enabled by default.\n \n @item -Wstack-usage=@var{byte-size}\n @opindex Wstack-usage"}, {"sha": "dbf1a6ac0a529a7deba26ce94f11db2575004b73", "filename": "gcc/testsuite/g++.dg/asan/asan_test.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -829,7 +829,7 @@ NOINLINE static int LargeFunction(bool do_bad_access) {\n   x[18]++;\n   x[19]++;\n \n-  delete x;\n+  delete[] x;\n   return res;\n }\n "}, {"sha": "9d4d2a393ea6dd675819704c6b37eafb61908e5d", "filename": "gcc/testsuite/g++.dg/warn/Wfree-nonheap-object-2.C", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-2.C?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,274 @@\n+/* PR ????? - No warning on attempts to access free object\n+   Verify that freeing unallocated objects referenced either directly\n+   or through pointers is diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wfree-nonheap-object\" }  */\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+typedef __SIZE_TYPE__   size_t;\n+\n+extern \"C\"\n+{\n+  void free (void*);\n+  extern void* malloc (size_t);\n+  extern void* realloc (void *p, size_t);\n+}\n+\n+void sink (void*, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+\n+extern char ecarr[];\n+extern void* eparr[];\n+\n+extern char *eptr;\n+\n+void* source (void);\n+\n+void nowarn_free (void *p, void **pp, size_t n, intptr_t iptr)\n+{\n+  free (p);\n+\n+  p = 0;\n+  free (p);\n+\n+  p = malloc (n);\n+  sink (p);\n+  free (p);\n+\n+  p = malloc (n);\n+  sink (p);\n+\n+  p = realloc (p, n * 2);\n+  sink (p);\n+  free (p);\n+\n+  free ((void*)iptr);\n+\n+  p = source ();\n+  free (p);\n+\n+  p = source ();\n+  p = (char*)p - 1;\n+  free (p);\n+\n+  free (*pp);\n+}\n+\n+void warn_free_extern_arr (void)\n+{\n+  free (ecarr);               // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_extern_arr_offset (int i)\n+{\n+  char *p = ecarr + i;\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_cstint (void)\n+{\n+  void *p = (void*)1;\n+  sink (p);\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_func (void)\n+{\n+  void *p = (void*)warn_free_func;\n+  sink (p);\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_string (int i)\n+{\n+  {\n+    char *p = (char*)\"123\";\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char *p = (char*)\"234\" + 1;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char *p = (char*)\"345\" + i;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+\n+  if (i >= 0)\n+    {\n+      char *p = (char*)\"456\" + i;\n+      sink (p);\n+      free (p);               // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    }\n+}\n+\n+void warn_free_local_arr (int i)\n+{\n+  {\n+    char a[4];\n+    sink (a);\n+    free (a);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char b[5];\n+    sink (b);\n+\n+    char *p = b + 1;\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char c[6];\n+    sink (c);\n+\n+    char *p = c + i;\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+}\n+\n+\n+void warn_free_vla (int n, int i)\n+{\n+  {\n+    int vla[n], *p = vla;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+\n+  {\n+    int vla[n + 1], *p = vla + 1;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    int vla[n + 2], *p = vla + i;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+}\n+\n+\n+void nowarn_free_extern_ptrarr (void)\n+{\n+  free (*eparr);\n+}\n+\n+void nowarn_free_extern_ptrarr_offset (int i)\n+{\n+  void *p = eparr[i];\n+  free (p);\n+}\n+\n+\n+void warn_free_extern_ptrarr (void)\n+{\n+  free (eparr);               // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_extern_ptrarr_offset (int i)\n+{\n+  void *p = &eparr[i];\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void nowarn_free_local_ptrarr (int i)\n+{\n+  void* a[4];\n+  sink (a);\n+  free (a[0]);\n+  free (a[1]);\n+  free (a[i]);\n+}\n+\n+\n+void nowarn_free_extern_ptr (void)\n+{\n+  free (eptr);\n+}\n+\n+void nowarn_free_extern_ptr_offset (int i)\n+{\n+  char *p = eptr + i;\n+  free (p);\n+}\n+\n+void warn_free_extern_ptr_pos_offset (int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  char *q = eptr + i;\n+  free (q);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void nowarn_free_parm_offset (char *p, int i)\n+{\n+  char *q = p + i;\n+  free (q);\n+}\n+\n+void nowarn_free_parm_neg_offset (char *p, int i)\n+{\n+  if (i >= 0)\n+    i = -1;\n+\n+  char *q = p + i;\n+  free (q);\n+}\n+\n+void warn_free_parm_pos_offset (char *p, int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  char *q = p + i;\n+  free (q);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+struct Members\n+{\n+  char a[4], *p, *q;\n+};\n+\n+extern struct Members em;\n+\n+void nowarn_free_member_ptr (struct Members *pm, int i)\n+{\n+  char *p = em.p;\n+  free (p);\n+  p = em.q + i;\n+  free (p);\n+\n+  free (pm->q);\n+  p = pm->p;\n+  free (pm);\n+  free (p);\n+}\n+\n+void nowarn_free_struct_cast (intptr_t *p)\n+{\n+  struct Members *q = (struct Members*)*p;\n+  if (q->p == 0)\n+    free (q);                 // { dg-bogus \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_member_array (void)\n+{\n+  char *p = em.a;\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_member_array_off (int i)\n+{\n+  char *p = em.a + i;\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}"}, {"sha": "82b081ad48f7ca0c03594672470f2c001bf0bb35", "filename": "gcc/testsuite/g++.dg/warn/Wfree-nonheap-object.C", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object.C?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,124 @@\n+/* PR ????? - No warning on attempts to access free object\n+   Verify that attempts to deallocate objects by pointers with nonzero\n+   offsets is diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wfree-nonheap-object\" }  */\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+typedef __SIZE_TYPE__   size_t;\n+\n+void sink (void*, ...);\n+\n+extern char ecarr[];\n+extern void* eparr[];\n+\n+extern char *eptr;\n+\n+char* source (void);\n+\n+void nowarn_op_delete (void *p, void ***ppp, size_t n, intptr_t iptr)\n+{\n+  operator delete (p);\n+\n+  p = 0;\n+  operator delete (p);\n+\n+  p = operator new (n);\n+  sink (p);\n+  operator delete (p);\n+\n+  p = operator new (n);\n+  sink (p);\n+\n+  operator delete ((void*)iptr);\n+\n+  p = source ();\n+  operator delete (p);\n+\n+  p = source ();\n+  p = (char*)p - 1;\n+  operator delete (p);\n+\n+  operator delete (**ppp);\n+  operator delete (*ppp);\n+  operator delete (ppp);\n+}\n+\n+void warn_op_delete_cstaddr (void *p)\n+{\n+  operator delete (p);\n+  p = (void*)~0;\n+  operator delete (p);        // { dg-warning \"called on a pointer to an unallocated object\" } */\n+}\n+\n+void warn_op_delete_funcaddr ()\n+{\n+  void *p = (void*)&warn_op_delete_funcaddr;\n+  operator delete (p);        // { dg-warning \"called on unallocated object 'void warn_op_delete_funcaddr()\" } */\n+}\n+\n+void warn_op_delete_string (void *p)\n+{\n+  operator delete (p);\n+  p = (void*)\"\";\n+  operator delete (p);        // { dg-warning \"called on a pointer to an unallocated object\" } */\n+}\n+\n+void warn_op_delete_ptr_to_self (void *p)\n+{\n+  operator delete (p);\n+  p = &p;\n+  operator delete (p);        // { dg-warning \"called on unallocated object 'p'\" } */\n+}\n+\n+void nowarn_op_new_delete (size_t n)\n+{\n+  void *p = operator new (n);\n+  sink (p);\n+  operator delete (p);\n+}\n+\n+void nowarn_op_new_delete_ptr_plus (size_t n)\n+{\n+  void *p0_1 = operator new (n);\n+  void *p1 = (char*)p0_1 + 1;\n+  sink (p0_1, p1);\n+  void *p0_2 = (char*)p1 - 1;\n+  sink (p0_1, p1, p0_2);\n+  operator delete (p0_2);\n+}\n+\n+void warn_op_new_delete_cstoff (size_t n)\n+{\n+  void *p = operator new (n);\n+  void *q = (char*)p + 1;\n+  sink (p, q);\n+  operator delete (q);        // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\\\\\)' called on pointer '\\[^'\\]+' with nonzero offset 1\" }\n+}\n+\n+void warn_op_new_delete_ptr_plus (size_t n)\n+{\n+  char *p = (char*)operator new (n);\n+  sink (++p);\n+  operator delete (p);        // { dg-warning \"called on pointer '\\[^']+' with nonzero offset 1\" }\n+}\n+\n+void warn_op_delete_funcret_plus (size_t n)\n+{\n+  char *p = source ();\n+  sink (++p);\n+  operator delete (p);        // { dg-warning \"called on pointer '\\[^']+' with nonzero offset 1\" }\n+}\n+\n+void warn_op_delete_eptr_plus (int i)\n+{\n+  extern char *ecp;\n+\n+  if (i < 1)\n+    i = 1;\n+\n+  char *p = ecp + i;\n+  sink (p);\n+\n+  operator delete (p);        // { dg-warning \"called on pointer '\\[^']+' with nonzero offset \\\\\\[1, \\\\d+]\" }\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/g++.dg/warn/Wfree-nonheap-object.s", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object.s?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97"}, {"sha": "7ecc99a325cce34a38bef239915fa3461dca0ed2", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-dealloc-2.C", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-2.C?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,185 @@\n+/* PR middle-end/94527 - Add an attribute that marks a function as freeing\n+   an object\n+   The detection doesn't require optimization.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__)))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\" {\n+  void free (void *);\n+  void* realloc (void *, size_t);\n+}\n+\n+void sink (void *);\n+\n+void                   mydealloc (int, void*);\n+void* A (mydealloc, 2) myalloc (void*);\n+\n+\n+void my_delete (const char*, void*);\n+void my_array_delete (const char*, void*);\n+\n+typedef void OpDelete1 (void*);\n+typedef void OpDelete2 (void*, size_t);\n+\n+A ((OpDelete1*)operator delete, 1)\n+#if __cplusplus >= 201402L\n+A ((OpDelete2*)operator delete, 1)\n+#endif\n+A (my_delete, 2)\n+int* my_new (size_t);\n+\n+A ((OpDelete1*)operator delete[], 1)\n+#if __cplusplus >= 201402L\n+A ((OpDelete2*)operator delete[], 1)\n+#endif\n+A (my_array_delete, 2)\n+int* my_array_new (size_t);\n+\n+\n+void test_my_new ()\n+{\n+  {\n+    void *p = my_new (1);\n+    operator delete (p);\n+  }\n+  {\n+    void *p = my_new (1);\n+    sink (p);\n+    operator delete (p);\n+  }\n+  {\n+    int *p = my_new (1);\n+    sink (p);\n+    delete p;\n+  }\n+\n+  {\n+    void *p = my_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    operator delete[] (p);\n+    // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n+  }\n+  {\n+    void *p = my_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    operator delete[] (p);\n+    // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n+  }\n+  {\n+    int *p = my_new (1);\n+    sink (p);\n+    delete[] p;\n+    // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    void *p = my_new (1);\n+    my_delete (\"1\", p);\n+  }\n+  {\n+    void *p = my_new (1);\n+    sink (p);\n+    my_delete (\"2\", p);\n+  }\n+\n+  {\n+    void *p = my_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    my_array_delete (\"3\", p);\n+    // { dg-warning \"'void my_array_delete\\\\\\(const char\\\\\\*, void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    void *p = my_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    free (p);\n+    // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    void *p = my_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    p = realloc (p, 123);\n+    // { dg-warning \"'void\\\\\\* realloc\\\\\\(void\\\\\\*, size_t\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+}\n+\n+\n+void test_my_array_new ()\n+{\n+  {\n+    void *p = my_array_new (1);\n+    operator delete[] (p);\n+  }\n+  {\n+    void *p = my_array_new (1);\n+    sink (p);\n+    operator delete[] (p);\n+  }\n+  {\n+    int *p = my_array_new (1);\n+    sink (p);\n+    delete[] p;\n+  }\n+\n+  {\n+    void *p = my_array_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    operator delete (p);\n+    // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n+  }\n+  {\n+    void *p = my_array_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    operator delete (p);\n+    // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n+  }\n+  {\n+    int *p = my_array_new (1);\n+    sink (p);\n+    delete p;\n+    // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\[^\\)\\]*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    void *p = my_array_new (1);\n+    my_array_delete (\"1\", p);\n+  }\n+  {\n+    void *p = my_array_new (1);\n+    sink (p);\n+    my_array_delete (\"2\", p);\n+  }\n+  {\n+    void *p = my_array_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    my_delete (\"3\", p);\n+    // { dg-warning \"'void my_delete\\\\\\(const char\\\\\\*, void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    void *p = my_array_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    free (p);\n+    // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    void *p = my_array_new (1);\n+    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    p = realloc (p, 123);\n+    // { dg-warning \"'void\\\\\\* realloc\\\\\\(void\\\\\\*, size_t\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+}"}, {"sha": "682db6f02cb2e44e2d209e7a998d0fd3c4aaae52", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-dealloc.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc.C?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,27 @@\n+/* PR middle-end/94527 - Add an attribute that marks a function as freeing\n+   an object\n+   { dg-do compile { target c++11 } }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__)))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void                   mydealloc (int, void*);\n+void* A (mydealloc, 2) myalloc (void*);\n+\n+\n+void* A (operator delete, 1)\n+  bad_new (size_t);                     // { dg-error \"attribute argument 1 is ambiguous\" }\n+void* A (operator delete[], 1)\n+  bad_array_new (size_t);               // { dg-error \"attribute argument 1 is ambiguous\" }\n+\n+void my_delete (const char*, void*);\n+void my_array_delete (const char*, void*);\n+\n+typedef void OpDelete (void*);\n+\n+int* A ((OpDelete*)operator delete, 1) A (my_delete, 2)\n+  my_new (size_t);\n+int* A ((OpDelete*)operator delete[], 1) A (my_array_delete, 2)\n+  my_array_new (size_t);"}, {"sha": "ed1090be5c54be917b6a557a92d509c8ea0f4528", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-new-delete.C", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete.C?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,212 @@\n+/* PR c++/90629 - Support for -Wmismatched-new-delete\n+   The detection doesn't require optimization.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\" {\n+  void free (void *);\n+  void* malloc (size_t);\n+  void* realloc (void *, size_t);\n+  char* strdup (const char *);\n+  char* strndup (const char *, size_t);\n+}\n+\n+void sink (void *);\n+\n+void nowarn_op_new_delete (int n)\n+{\n+  void *p = operator new (n);\n+  sink (p);\n+  operator delete (p);\n+}\n+\n+void nowarn_new_delete (int n)\n+{\n+  {\n+    char *p = new char;\n+    sink (p);\n+    delete p;\n+  }\n+\n+  {\n+    char *p = new char[n];\n+    sink (p);\n+    delete[] p;\n+  }\n+}\n+\n+/* Verify a warning for calls to free() with a pointer returned from\n+   a call to operator new() or the new expressopm.  */\n+\n+void warn_new_free (int n)\n+{\n+  {\n+    void *p = operator new (n);\n+    // { dg-message \"returned from a call to 'void\\\\\\* operator new\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    free (p);\n+    // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+  {\n+    char *p = new char[n];\n+    // { dg-message \"returned from a call to 'void\\\\\\* operator new \\\\\\[\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    free (p);\n+    // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+}\n+\n+\n+/* Verify a warning for calls to realloc() with a pointer returned from\n+   a call to operator new() or the new expressopm.  */\n+\n+void warn_new_realloc (int n)\n+{\n+  {\n+    void *p = operator new (n);\n+    // { dg-message \"returned from a call to 'void\\\\\\* operator new\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    p = realloc (p, n * 2);\n+    // { dg-warning \"'void\\\\\\* realloc\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+    sink (p);\n+  }\n+  {\n+    void *p = new char[n];\n+    // { dg-message \"returned from a call to 'void\\\\\\* operator new \\\\\\[\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    p = realloc (p, n * 2);\n+    // { dg-warning \"'void\\\\\\* realloc\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+    sink (p);\n+  }\n+}\n+\n+\n+/* Verify a warning for a call to operator_delete() with a pointer returned\n+   from a call to malloc().  */\n+\n+void warn_malloc_op_delete (int n)\n+{\n+  char *p = (char *)malloc (n);\n+  // { dg-message \"returned from a call to 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+  sink (p);\n+  operator delete (p);\n+  // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+}\n+\n+\n+/* Verify a warning for an invocation of either form of the delete\n+   expression with a pointer returned from a call to malloc().  */\n+\n+void warn_malloc_delete (int n)\n+{\n+  {\n+    char *p = (char *)malloc (n);\n+    // { dg-message \"returned from a call to 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    /* C++98 calls operator delete (void*) but later versions call\n+       operator delete (void*, size_t).  The difference doesn't matter\n+       here so verify just that some operator delete is called.  */\n+    delete p;\n+    // { dg-warning \"'void operator delete\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    char *p = (char *)malloc (n);\n+    // { dg-message \"returned from a call to 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (p);\n+    delete[] p;\n+    // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+}\n+\n+\n+/* Verify a warning for an invocation of either form of the delete\n+   expression with a pointer returned from a call to realloc().  */\n+\n+void warn_realloc_delete (void *p1, void *p2, int n)\n+{\n+  {\n+    char *q = (char *)realloc (p1, n);\n+    // { dg-message \"returned from a call to 'void\\\\\\* realloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (q);\n+    /* C++98 calls operator delete (void*) but later versions call\n+       operator delete (void*, size_t).  The difference doesn't matter\n+       here so verify just that some operator delete is called.  */\n+    delete q;\n+    // { dg-warning \"'void operator delete\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    char *q = (char *)realloc (p2, n);\n+    // { dg-message \"returned from a call to 'void\\\\\\* realloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (q);\n+    delete[] q;\n+    // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+}\n+\n+\n+/* Verify a warning for an invocation of either form of the delete\n+   expression with a pointer returned from a call to strdup().  */\n+\n+void warn_strdup_delete (const char *s1, const char *s2)\n+{\n+  {\n+    char *q = strdup (s1);\n+    // { dg-message \"returned from a call to 'char\\\\\\* strdup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (q);\n+    /* C++98 calls operator delete (void*) but later versions call\n+       operator delete (void*, size_t).  The difference doesn't matter\n+       here so verify just that some operator delete is called.  */\n+    delete q;\n+    // { dg-warning \"'void operator delete\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    char *q = strdup (s2);\n+    // { dg-message \"returned from a call to 'char\\\\\\* strdup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (q);\n+    delete[] q;\n+    // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+}\n+\n+\n+\n+/* Verify a warning for an invocation of either form of the delete\n+   expression with a pointer returned from a call to strndup().  */\n+\n+void warn_strdup_delete (const char *s1, const char *s2, size_t n)\n+{\n+  {\n+    char *q = strndup (s1, n);\n+    // { dg-message \"returned from a call to 'char\\\\\\* strndup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (q);\n+    /* C++98 calls operator delete (void*) but later versions call\n+       operator delete (void*, size_t).  The difference doesn't matter\n+       here so verify just that some operator delete is called.  */\n+    delete q;\n+    // { dg-warning \"'void operator delete\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+\n+  {\n+    char *q = strndup (s2, n);\n+    // { dg-message \"returned from a call to 'char\\\\\\* strndup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    sink (q);\n+    delete[] q;\n+    // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n+  }\n+}\n+\n+\n+struct Base { virtual ~Base (); };\n+struct Derived: Base { };\n+\n+void warn_new_free_base_derived ()\n+{\n+  Base *p = new Derived ();\n+  sink (p);\n+  free (p);                   // { dg-warning \"\\\\\\[-Wmismatched-new-delete\" }\n+}"}, {"sha": "95fa7d445d4cc98fb43d207ba8f099b93037bb96", "filename": "gcc/testsuite/g++.dg/warn/delete-array-1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fdelete-array-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fdelete-array-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fdelete-array-1.C?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -5,7 +5,7 @@ struct S { int a [1]; } s;\n \n void foo (S *p)\n {\n-  delete a;    // { dg-warning \"deleting array\" }\n-  delete s.a;  // { dg-warning \"deleting array\" }\n-  delete p->a; // { dg-warning \"deleting array\" }\n+  delete a;    // { dg-warning \"deleting array|-Wfree-nonheap-object\" }\n+  delete s.a;  // { dg-warning \"deleting array|-Wfree-nonheap-object\" }\n+  delete p->a; // { dg-warning \"deleting array|-Wfree-nonheap-object\" }\n }"}, {"sha": "76ae3558a1db9d8d2c03149ee9a10282b37e6b82", "filename": "gcc/testsuite/g++.old-deja/g++.other/delete2.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdelete2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdelete2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdelete2.C?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -9,5 +9,7 @@ void bar(foo a) {\n   delete[] a; // should be accepted\n   char b[1];\n   delete b; // { dg-warning \"deleting array\" } expecting pointer type\n+  // { dg-warning \"-Wfree-nonheap-object\" \"\" { target *-*-* } .-1 }\n   delete[] b; // { dg-warning \"deleting array\" } expecting pointer type\n+  // { dg-warning \"-Wfree-nonheap-object\" \"\" { target *-*-* } .-1 }\n }"}, {"sha": "2b00d77e8b83e7b1a75727231eff6edc5a87e1bf", "filename": "gcc/testsuite/gcc.dg/Wfree-nonheap-object-2.c", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-2.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,279 @@\n+/* PR ????? - No warning on attempts to access free object\n+   Verify that attempting to reallocate unallocated objects referenced\n+   either directly or through pointers is diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wfree-nonheap-object\" }  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void free (void*);\n+extern void* alloca (size_t);\n+extern void* realloc (void*, size_t);\n+\n+void sink (void*, ...);\n+\n+extern void* eparr[];\n+extern char *eptr;\n+\n+extern size_t n;\n+\n+\n+void nowarn_realloc (void *p, size_t n)\n+{\n+  char *q = realloc (p, n);\n+  sink (q);\n+\n+  q = realloc (0, n);\n+  sink (q);\n+\n+  q = realloc (q, n * 2);\n+  sink (q);\n+}\n+\n+/* Verify that calling realloc on a pointer to an unknown object minus\n+   some nonzero offset isn't diagnosed, but a pointer plus a positive\n+   offset is (a positive offset cannot point at the beginning).  */\n+\n+void test_realloc_offset (char *p1, char *p2, char *p3, size_t n, int i)\n+{\n+  char *q;\n+  q = realloc (p1 - 1, n);\n+  sink (q);\n+\n+  q = realloc (p2 + 1, n);    // { dg-warning \"'realloc' called on pointer 'p2' with nonzero offset 1\" }\n+  sink (q);\n+\n+  q = realloc (p3 + i, n);\n+  sink (q);\n+}\n+\n+void warn_realloc_extern_arr (void)\n+{\n+  extern char ecarr[];        // { gg-message \"declared here\" }\n+  char *p = ecarr;\n+  char *q = realloc (p, n);   // { dg-warning \"'realloc' called on unallocated object 'ecarr'\" }\n+  sink (q);\n+}\n+\n+void warn_realloc_extern_arr_offset (int i)\n+{\n+  extern char ecarr[];\n+  char *p = ecarr + i;\n+  char *q = realloc (p, n);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  sink (q);\n+}\n+\n+\n+void warn_realloc_string (int i)\n+{\n+  char *p, *q;\n+  {\n+    p = \"123\";\n+    sink (p);\n+    q = realloc (p, n);       // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+  {\n+    p = \"234\" + 1;\n+    sink (p);\n+    q = realloc (p, n);       // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+  {\n+    p = \"123\" + i;\n+    sink (p);\n+    q = realloc (p, n);       // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+}\n+\n+\n+void warn_realloc_alloca (int n, int i)\n+{\n+  char *p, *q;\n+  {\n+    p = alloca (n);\n+    sink (p);\n+    q = realloc (p, n);       // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+  {\n+    p = (char*)alloca (n + 1);\n+    sink (p);\n+    q = realloc (p, n);       // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+  {\n+    p = (char*)alloca (n + 2) + i;\n+    sink (p);\n+    q = realloc (p, n);       // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+}\n+\n+\n+void warn_realloc_local_arr (int i)\n+{\n+  char *q;\n+  {\n+    char a[4];\n+    sink (a);\n+    q = realloc (a, n);       // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+\n+  {\n+    char b[5];\n+    sink (b);\n+    q = realloc (b + 1, n);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+\n+  {\n+    char c[6];\n+    sink (c);\n+    q = realloc (&c[2], n);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+\n+  {\n+    char d[7];\n+    sink (d);\n+    q = realloc (&d[i], n);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+}\n+\n+void warn_realloc_vla (int n1, int n2, int i)\n+{\n+  char *q;\n+  {\n+    char vla[n1];\n+    sink (vla);\n+    q = realloc (vla, n2);    // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+\n+  {\n+    char vlb[n1 + 1];\n+    sink (vlb);\n+    q = realloc (vlb + 1, n2);// { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+\n+  {\n+    char vlc[n1 + 2];\n+    sink (vlc);\n+    q = realloc (&vlc[2], n2);// { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+\n+  {\n+    char vld[7];\n+    sink (vld);\n+    q = realloc (&vld[i], n2);// { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    sink (q);\n+  }\n+}\n+\n+void nowarn_realloc_extern_ptrarr (void)\n+{\n+  char *q = realloc (*eparr, n);\n+  sink (q);\n+}\n+\n+void nowarn_realloc_extern_ptrarr_offset (int i)\n+{\n+  char *p = eparr[i];\n+  char *q = realloc (p, n);\n+  sink (q);\n+}\n+\n+\n+void warn_realloc_extern_ptrarr (void)\n+{\n+  char *q = realloc (eparr, n);  // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  sink (q);\n+}\n+\n+void warn_realloc_extern_ptrarr_offset (int i)\n+{\n+  void *p = eparr + i;\n+  void *q = realloc (p, n);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  sink (q);\n+}\n+\n+\n+void nowarn_realloc_extern_ptr (void)\n+{\n+  char *q = realloc (eptr, n);\n+  sink (q);\n+}\n+\n+void nowarn_realloc_extern_ptr_offset (int i)\n+{\n+  char *p = eptr + i;\n+  char *q = realloc (p, n);\n+  sink (q);\n+}\n+\n+\n+void warn_realloc_extern_ptr_pos_offset (int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  char *p = eptr + i;\n+  char *q = realloc (p, n);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  sink (q);\n+}\n+\n+\n+void nowarn_realloc_parm_offset (char *p, int i)\n+{\n+  char *q = p + i;\n+  q = realloc (q, n);\n+  sink (q);\n+}\n+\n+void nowarn_realloc_parm_neg_offset (char *p, int i)\n+{\n+  if (i >= 0)\n+    i = -1;\n+\n+  char *q = p + i;\n+  q = realloc (q, n);\n+  sink (q);\n+}\n+\n+void warn_realloc_parm_pos_offset (char *p, int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  char *q = p + i;\n+  q = realloc (q, n);         // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  sink (q);\n+}\n+\n+void nowarn_realloc_deref_parm_pos_offset (void **p, int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  // The offset is from p, not *p.\n+  void *q = *(p + i);\n+  q = realloc (q, n);\n+  sink (q);\n+}\n+\n+void warn_realloc_deref_parm_pos_offset (void **p, int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  // Unlike in the function above the offset is from *p.\n+  void *q = *p + i;\n+  q = realloc (q, n);         // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  sink (q);\n+}"}, {"sha": "a472b93fb87d69558ef14b7a71411e5ecb401991", "filename": "gcc/testsuite/gcc.dg/Wfree-nonheap-object-3.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-3.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,57 @@\n+/* PR ????? - No warning on attempts to access free object\n+   Verify that freeing unallocated objects referenced indirectly through\n+   pointers obtained from function calls is diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wfree-nonheap-object\" }  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void free (void*);\n+extern char* memchr (const void*, int, size_t);\n+extern char* strchr (const char*, int);\n+\n+void sink (void*, ...);\n+\n+extern char ecarr[];\n+extern void* eparr[];\n+\n+extern char *eptr;\n+\n+\n+void warn_free_memchr_ecarr (int x, size_t n)\n+{\n+  char *p = memchr (ecarr, x, n);\n+  sink (p);\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_memchr_ecarr_offset (int i, int j, int x, size_t n)\n+{\n+  char *p = memchr (ecarr + i, x, n);\n+  char *q = p + j;\n+  sink (p, q);\n+  free (q);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_memchr_local_arr (int x, size_t n)\n+{\n+  char a[8];\n+  sink (a);\n+\n+  char *p = memchr (a, x, n);\n+  sink (p);\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_memchr_local_arr_offset (int i, int j, int x, size_t n)\n+{\n+  char a[8];\n+  sink (a);\n+\n+  char *p = memchr (a + i, x, n);\n+  char *q = p + j;\n+  sink (p, q);\n+  free (q);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+"}, {"sha": "bb222ccf6abc9362b5e04f40c15873150dac680f", "filename": "gcc/testsuite/gcc.dg/Wfree-nonheap-object.c", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,273 @@\n+/* PR ????? - No warning on attempts to access free object\n+   Verify that freeing unallocated objects referenced either directly\n+   or through pointers is diagnosed.  In most cases this doesn't require\n+   optimization.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wfree-nonheap-object\" }  */\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+typedef __SIZE_TYPE__   size_t;\n+\n+extern void free (void*);\n+extern void* malloc (size_t);\n+extern void* realloc (void *p, size_t);\n+\n+void sink (void*, ...);\n+\n+extern char ecarr[];\n+extern void* eparr[];\n+\n+extern char *eptr;\n+\n+void* source (void);\n+\n+void nowarn_free (void *p, void **pp, size_t n, intptr_t iptr)\n+{\n+  free (p);\n+\n+  p = 0;\n+  free (p);\n+\n+  p = malloc (n);\n+  sink (p);\n+  free (p);\n+\n+  p = malloc (n);\n+  sink (p);\n+\n+  p = realloc (p, n * 2);\n+  sink (p);\n+  free (p);\n+\n+  free ((void*)iptr);\n+\n+  p = source ();\n+  free (p);\n+\n+  p = source ();\n+  p = (char*)p - 1;\n+  free (p);\n+\n+  free (*pp);\n+}\n+\n+void warn_free_extern_arr (void)\n+{\n+  free (ecarr);               // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_extern_arr_offset (int i)\n+{\n+  char *p = ecarr + i;\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_cstint (void)\n+{\n+  void *p = (void*)1;\n+  sink (p);\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_func (void)\n+{\n+  void *p = warn_free_func;\n+  sink (p);\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_string (int i)\n+{\n+  {\n+    char *p = \"123\";\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char *p = \"234\" + 1;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char *p = \"345\" + i;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+\n+  if (i >= 0)\n+    {\n+      char *p = \"456\" + i;\n+      sink (p);\n+      free (p);               // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+    }\n+}\n+\n+void warn_free_local_arr (int i)\n+{\n+  {\n+    char a[4];\n+    sink (a);\n+    free (a);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char b[5];\n+    sink (b);\n+\n+    char *p = b + 1;\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    char c[6];\n+    sink (c);\n+\n+    char *p = c + i;\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+}\n+\n+\n+void warn_free_vla (int n, int i)\n+{\n+  {\n+    int vla[n], *p = vla;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+\n+  {\n+    int vla[n + 1], *p = vla + 1;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+  {\n+    int vla[n + 2], *p = vla + i;\n+    sink (p);\n+    free (p);                 // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+}\n+\n+\n+void nowarn_free_extern_ptrarr (void)\n+{\n+  free (*eparr);\n+}\n+\n+void nowarn_free_extern_ptrarr_offset (int i)\n+{\n+  char *p = eparr[i];\n+  free (p);\n+}\n+\n+\n+void warn_free_extern_ptrarr (void)\n+{\n+  free (eparr);               // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_extern_ptrarr_offset (int i)\n+{\n+  void *p = &eparr[i];\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void nowarn_free_local_ptrarr (int i)\n+{\n+  void* a[4];\n+  sink (a);\n+  free (a[0]);\n+  free (a[1]);\n+  free (a[i]);\n+}\n+\n+\n+void nowarn_free_extern_ptr (void)\n+{\n+  free (eptr);\n+}\n+\n+void nowarn_free_extern_ptr_offset (int i)\n+{\n+  char *p = eptr + i;\n+  free (p);\n+}\n+\n+void nowarn_free_parm_offset (char *p, int i)\n+{\n+  char *q = p + i;\n+  free (q);\n+}\n+\n+void nowarn_free_parm_neg_offset (char *p, int i)\n+{\n+  if (i >= 0)\n+    i = -1;\n+\n+  char *q = p + i;\n+  free (q);\n+}\n+\n+struct Members\n+{\n+  char a[4], *p, *q;\n+};\n+\n+extern struct Members em;\n+\n+void nowarn_free_member_ptr (struct Members *pm, int i)\n+{\n+  char *p = em.p;\n+  free (p);\n+  p = em.q + i;\n+  free (p);\n+\n+  free (pm->q);\n+  p = pm->p;\n+  free (pm);\n+  free (p);\n+}\n+\n+void nowarn_free_struct_cast (intptr_t *p)\n+{\n+  struct Members *q = (struct Members*)*p;\n+  if (q->p == 0)\n+    free (q);                 // { dg-bogus \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+void warn_free_member_array (void)\n+{\n+  char *p = em.a;\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_member_array_off (int i)\n+{\n+  char *p = em.a + i;\n+  free (p);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+\n+// Range information requires optimization.\n+#pragma GCC optimize \"1\"\n+\n+void warn_free_extern_ptr_pos_offset (int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  char *q = eptr + i;\n+  free (q);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+void warn_free_parm_pos_offset (char *p, int i)\n+{\n+  if (i <= 0)\n+    i = 1;\n+\n+  char *q = p + i;\n+  free (q);                   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}"}, {"sha": "7c5d6acf4d686efc2de99b17ca55affe9fe022cc", "filename": "gcc/testsuite/gcc.dg/Wmismatched-dealloc.c", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,252 @@\n+/* PR middle-end/94527 - Add an attribute that marks a function as freeing\n+   an object\n+   Verify that attribute malloc with one or two arguments has the expected\n+   effect on diagnostics.\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__)))\n+\n+typedef struct FILE   FILE;\n+typedef __SIZE_TYPE__ size_t;\n+\n+void  free (void*);\n+void* malloc (size_t);\n+void* realloc (void*, size_t);\n+\n+int   fclose (FILE*);\n+FILE* freopen (const char*, const char*, FILE*);\n+int   pclose (FILE*);\n+\n+A (fclose) A (freopen, 3)\n+  FILE* fdopen (int);\n+A (fclose) A (freopen, 3)\n+  FILE* fopen (const char*, const char*);\n+A (fclose) A (freopen, 3)\n+  FILE* fmemopen(void *, size_t, const char *);\n+A (fclose) A (freopen, 3)\n+  FILE* freopen (const char*, const char*, FILE*);\n+A (pclose) A (freopen, 3)\n+  FILE* popen (const char*, const char*);\n+A (fclose) A (freopen, 3)\n+  FILE* tmpfile (void);\n+\n+void sink (FILE*);\n+\n+\n+            void  release (void*);\n+A (release) FILE* acquire (void);\n+\n+void nowarn_fdopen (void)\n+{\n+  {\n+    FILE *q = fdopen (0);\n+    if (!q)\n+      return;\n+\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);\n+    if (!q)\n+      return;\n+\n+    q = freopen (\"1\", \"r\", q);\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);\n+    if (!q)\n+      return;\n+\n+    sink (q);\n+  }\n+}\n+\n+\n+void warn_fdopen (void)\n+{\n+  {\n+    FILE *q = fdopen (0);     // { dg-message \"returned from a call to 'fdopen'\" \"note\" }\n+    sink (q);\n+    release (q);              // { dg-warning \"'release' called on pointer returned from a mismatched allocation function\" }\n+  }\n+  {\n+    FILE *q = fdopen (0);     // { dg-message \"returned from a call to 'fdopen'\" \"note\" }\n+    sink (q);\n+    free (q);                 // { dg-warning \"'free' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);     // { dg-message \"returned from a call to 'fdopen'\" \"note\" }\n+    sink (q);\n+    q = realloc (q, 7);       // { dg-warning \"'realloc' called on pointer returned from a mismatched allocation function\" }\n+    sink (q);\n+  }\n+}\n+\n+\n+void nowarn_fopen (void)\n+{\n+  {\n+    FILE *q = fopen (\"1\", \"r\");\n+    sink (q);\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fopen (\"2\", \"r\");\n+    sink (q);\n+    q = freopen (\"3\", \"r\", q);\n+    sink (q);\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fopen (\"4\", \"r\");\n+    sink (q);\n+  }\n+}\n+\n+\n+void warn_fopen (void)\n+{\n+  {\n+    FILE *q = fopen (\"1\", \"r\");\n+    sink (q);\n+    release (q);              // { dg-warning \"'release' called on pointer returned from a mismatched allocation function\" }\n+  }\n+  {\n+    FILE *q = fdopen (0);\n+    sink (q);\n+    free (q);                 // { dg-warning \"'free' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);\n+    sink (q);\n+    q = realloc (q, 7);       // { dg-warning \"'realloc' called on pointer returned from a mismatched allocation function\" }\n+    sink (q);\n+  }\n+}\n+\n+\n+void test_popen (void)\n+{\n+  {\n+    FILE *p = popen (\"1\", \"r\");\n+    sink (p);\n+    pclose (p);\n+  }\n+\n+  {\n+    FILE *p;\n+    p = popen (\"2\", \"r\");     // { dg-message \"returned from a call to 'popen'\" \"note\" }\n+    sink (p);\n+    fclose (p);               // { dg-warning \"'fclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    /* freopen() can close a stream open by popen() but pclose() can't\n+       close the stream returned from freopen().  */\n+    FILE *p = popen (\"2\", \"r\");\n+    sink (p);\n+    p = freopen (\"3\", \"r\", p);  // { dg-message \"returned from a call to 'freopen'\" \"note\" }\n+    sink (p);\n+    pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void test_tmpfile (void)\n+{\n+  {\n+    FILE *p = tmpfile ();\n+    sink (p);\n+    fclose (p);\n+  }\n+\n+  {\n+    FILE *p = tmpfile ();\n+    sink (p);\n+    p = freopen (\"1\", \"r\", p);\n+    sink (p);\n+    fclose (p);\n+  }\n+\n+  {\n+    FILE *p = tmpfile ();     // { dg-message \"returned from a call to 'tmpfile'\" \"note\" }\n+    sink (p);\n+    pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void warn_malloc (void)\n+{\n+  {\n+    FILE *p = malloc (100);   // { dg-message \"returned from a call to 'malloc'\" \"note\" }\n+    sink (p);\n+    fclose (p);               // { dg-warning \"'fclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *p = malloc (100);   // { dg-message \"returned from a call to 'malloc'\" \"note\" }\n+    sink (p);\n+    p = freopen (\"1\", \"r\", p);// { dg-warning \"'freopen' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *p = malloc (100);   // { dg-message \"returned from a call to 'malloc'\" \"note\" }\n+    sink (p);\n+    pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void test_acquire (void)\n+{\n+  {\n+    FILE *p = acquire ();\n+    release (p);\n+  }\n+\n+  {\n+    FILE *p = acquire ();\n+    sink (p);\n+    release (p);\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    sink (p);\n+    fclose (p);               // { dg-warning \"'fclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    sink (p);\n+    pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    sink (p);\n+    p = freopen (\"1\", \"r\", p);  // { dg-warning \"'freopen' called on pointer returned from a mismatched allocation function\" }\n+    sink (p);\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    sink (p);\n+    free (p);               // { dg-warning \"'free' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    sink (p);\n+    p = realloc (p, 123);     // { dg-warning \"'realloc' called on pointer returned from a mismatched allocation function\" }\n+    sink (p);\n+  }\n+}"}, {"sha": "26d828848a25989e2dafa8ece988a7c240043f61", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -609,3 +609,5 @@ int test_49 (int i)\n   *p = 1; /* { dg-warning \"dereference of NULL 'p' \\\\\\[CWE-476\\\\\\]\" } */\n   return x;\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" } */"}, {"sha": "14f1980ed7f6f539a42432910434e9d8ffb490f9", "filename": "gcc/testsuite/gcc.dg/attr-malloc.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-malloc.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -0,0 +1,75 @@\n+/* PR middle-end/94527 - Add an attribute that marks a function as freeing\n+   an object\n+   Verify that attribute malloc with one or two arguments is accepted where\n+   intended and rejected where it's invalid.\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__)))\n+\n+A (0) void* alloc_zero (int);           // { dg-error \"'malloc' attribute argument 1 does not name a function\" }\n+\n+A (\"\") void* alloc_string (int);        // { dg-error \"'malloc' attribute argument 1 does not name a function\" }\n+\n+int var;\n+A (var) void* alloc_var (int);          // { dg-error \"'malloc' attribute argument 1 does not name a function\" }\n+\n+typedef struct Type { int i; } Type;\n+A (Type) void* alloc_type (int);        // { dg-error \"expected expression|identifier\" }\n+\n+A (unknown) void* alloc_unknown (int);  // { dg-error \"'unknown' undeclared\" }\n+\n+void fv_ ();                            // { dg-message \"declared here\" }\n+A (fv_) void* alloc_fv_ (int);          // { dg-error \"'malloc' attribute argument 1 must take a pointer type as its first argument\" }\n+\n+void fvi (int);                         // { dg-message \"declared here\" }\n+A (fvi) void* alloc_fvi (int);          // { dg-error \"'malloc' attribute argument 1 must take a pointer type as its first argument; have 'int'\" }\n+\n+void fvv (void);                        // { dg-message \"declared here\" }\n+A (fvv) void* alloc_fvv (int);          // { dg-error \"'malloc' attribute argument 1 must take a pointer type as its first argument; have 'void'\" }\n+\n+void fvi_ (int, ...);                   // { dg-message \"declared here\" }\n+A (fvi_) void* alloc_fvi_ (int);        // { dg-error \"'malloc' attribute argument 1 must take a pointer type as its first argument; have 'int'\" }\n+\n+void fvi_vp (Type, void*);              // { dg-message \"declared here\" }\n+A (fvi_vp) void* alloc_fvi_vp (int);    // { dg-error \"'malloc' attribute argument 1 must take a pointer type as its first argument; have 'Type'\" }\n+\n+\n+void fpv (void*);\n+A (fpv) void* alloc_fpv (int);\n+\n+void fpv_i (void*, int);\n+A (fpv_i) void* alloc_fpv_i (int);\n+\n+void fpv_pv (void*, void*);\n+A (fpv_i) void* alloc_fpv_pv (int);\n+\n+\n+void gpc (char*);\n+void hpi (int*);\n+A (fpv) A (gpc) A (hpi) Type* alloc_fpv_gpv (int);\n+\n+\n+/* Verify that the attribute can be applied to <stdio.h> functions.  */\n+typedef struct FILE FILE;\n+typedef __SIZE_TYPE__ size_t;\n+\n+int   fclose (FILE*);\n+FILE* fdopen (int);\n+FILE* fopen (const char*, const char*);\n+FILE* freopen (const char*, const char*, FILE*);\n+int   pclose (FILE*);\n+FILE* popen (const char*, const char*);\n+FILE* tmpfile (void);\n+\n+A (fclose) A (freopen, 3) A (pclose)\n+  FILE* fdopen (int);\n+A (fclose) A (freopen, 3) A (pclose)\n+  FILE* fopen (const char*, const char*);\n+A (fclose) A (freopen, 3) A (pclose)\n+  FILE* fmemopen(void *, size_t, const char *);\n+A (fclose) A (freopen, 3) A (pclose)\n+  FILE* freopen (const char*, const char*, FILE*);\n+A (fclose) A (freopen, 3) A (pclose)\n+  FILE* popen (const char*, const char*);\n+A (fclose) A (freopen, 3) A (pclose)\n+  FILE* tmpfile (void);"}, {"sha": "ad49d787fbeea18aa59c81ebce8f5a9b87100b61", "filename": "gcc/testsuite/gcc.dg/free-1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ffree-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ffree-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffree-1.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -13,14 +13,14 @@ void foo (void)\n   static char buf4[10], e;\n   char *q = buf;\n   free (p);\n-  free (q);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (buf2);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (&c);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (buf3);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (&d);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (buf4);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (&e);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n+  free (q);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (buf2);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (&c);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (buf3);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (&d);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (buf4);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (&e);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n   free (&r->a);\n-  free (\"abcd\");      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (L\"abcd\");     /* { dg-warning \"attempt to free a non-heap object\" } */\n+  free (\"abcd\");      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (L\"abcd\");     /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n }"}, {"sha": "edbcdc74a2018d294784fa11daabb4260f3c62b4", "filename": "gcc/testsuite/gcc.dg/free-2.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ffree-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ffree-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffree-2.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -13,14 +13,14 @@ void foo (void)\n   static char buf4[10], e;\n   char *q = buf;\n   free (p);\n-  free (q);\t      /* At -O0 no warning is reported here.  */\n-  free (buf2);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (&c);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (buf3);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (&d);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (buf4);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (&e);\t      /* { dg-warning \"attempt to free a non-heap object\" } */\n+  free (q);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (buf2);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (&c);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (buf3);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (&d);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (buf4);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (&e);\t      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n   free (&r->a);\n-  free (\"abcd\");      /* { dg-warning \"attempt to free a non-heap object\" } */\n-  free (L\"abcd\");     /* { dg-warning \"attempt to free a non-heap object\" } */\n+  free (\"abcd\");      /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n+  free (L\"abcd\");     /* { dg-warning \"\\\\\\[-Wfree-nonheap-object\" } */\n }"}, {"sha": "cc143fa6c7deb911b5b5c46bd5ab8163b992526a", "filename": "gcc/testsuite/gcc.dg/torture/pr71816.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71816.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71816.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71816.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -20,3 +20,7 @@ struct ext2_icount_el *insert_icount_el() {\n     ext2fs_resize_mem(&insert_icount_el_icount_1);\n     return 0;\n }\n+\n+/* Passing the address of a declared object to realloc triggers\n+   -Wfree-nonheap-object unless -flto is used.\n+   { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" } */"}, {"sha": "df4120da5828b2d4a25edd26f2f92bf685660fbd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19831-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19831-2.c?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -5,7 +5,7 @@ void test1(void)\n {\n   int *p = __builtin_malloc (sizeof (int) * 4);\n   *p++ = 4;\n-  __builtin_free (p);\n+  __builtin_free (p);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n }\n \n /* Undefined.  We can't do anything here.  */"}, {"sha": "b5ce78ddc7e886f9d17b2fcf843499b55ef0f410", "filename": "libstdc++-v3/testsuite/ext/vstring/modifiers/clear/56166.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce6c58db87ebf7f4477bd3126228e73e4eeee97/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Fmodifiers%2Fclear%2F56166.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce6c58db87ebf7f4477bd3126228e73e4eeee97/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Fmodifiers%2Fclear%2F56166.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Fmodifiers%2Fclear%2F56166.cc?ref=dce6c58db87ebf7f4477bd3126228e73e4eeee97", "patch": "@@ -56,12 +56,12 @@ template<typename T>\n           throw std::bad_alloc();\n         }\n       }\n-      return (T*)new char[n * sizeof(T)];\n+      return (T*)operator new (n * sizeof(T));\n     }\n \n     void deallocate(T* p, size_type)\n     {\n-      delete[] (char*)p;\n+      operator delete (p);\n     }\n   };\n \n@@ -94,3 +94,7 @@ int main()\n     }\n   }\n }\n+\n+// The __versa_string destructor triggers a bogus -Wfree-nonheap-object\n+// due to pr54202.\n+// { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" }"}]}