{"sha": "76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZiZDI5ZjYzYzg3M2E1ZTUwNjY1ZDNiZTA5ZjNkNmU5NmRkMmNmNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-12-18T10:50:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-12-18T10:50:47Z"}, "message": "re PR rtl-optimization/55717 (ICE in form_sum, at reload.c:5400)\n\n\tPR debug/55717\n\t* rtlhooks-def.h (RTL_HOOKS_GEN_LOWPART_NO_EMIT): Define to\n\tgen_lowpart_if_possible.\n\t(gen_lowpart_no_emit_general): Remove prototype.\n\t* rtlhooks.c (gen_lowpart_no_emit_general): Removed.\n\t* simplify-rtx.c (simplify_unary_operation_1, \n\tsimplify_binary_operation_1): Continue simplifying if\n\trtl_hooks.gen_lowpart_no_emit returns NULL_RTX.\n\t* dwarf2out.c (mem_loc_descriptor) <case TRUNCATE>: Handle\n\ttruncation like lowpart SUBREG.\n\n\t* testsuite/g++.dg/opt/pr55717.C: New test.\n\nFrom-SVN: r194575", "tree": {"sha": "aa9c6427dcc97a3b76b02ae4b8e5bfd7aa409495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa9c6427dcc97a3b76b02ae4b8e5bfd7aa409495"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07146f23bcb7633110474cbf8476df1186352408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07146f23bcb7633110474cbf8476df1186352408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07146f23bcb7633110474cbf8476df1186352408"}], "stats": {"total": 236, "additions": 195, "deletions": 41}, "files": [{"sha": "104fc9e6d76dfcb854a363cd23e5b82c5115ca31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "patch": "@@ -1,3 +1,16 @@\n+2012-12-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/55717\n+\t* rtlhooks-def.h (RTL_HOOKS_GEN_LOWPART_NO_EMIT): Define to\n+\tgen_lowpart_if_possible.\n+\t(gen_lowpart_no_emit_general): Remove prototype.\n+\t* rtlhooks.c (gen_lowpart_no_emit_general): Removed.\n+\t* simplify-rtx.c (simplify_unary_operation_1, \n+\tsimplify_binary_operation_1): Continue simplifying if\n+\trtl_hooks.gen_lowpart_no_emit returns NULL_RTX.\n+\t* dwarf2out.c (mem_loc_descriptor) <case TRUNCATE>: Handle\n+\ttruncation like lowpart SUBREG.\n+\n 2012-12-17  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/contrib.texi (Contributors): Update Kaveh Ghazi's entry;"}, {"sha": "a284eed6977fabb225ee2c12ae6413888666af81", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "patch": "@@ -11840,6 +11840,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n   dw_loc_descr_ref mem_loc_result = NULL;\n   enum dwarf_location_atom op;\n   dw_loc_descr_ref op0, op1;\n+  rtx inner = NULL_RTX;\n \n   if (mode == VOIDmode)\n     mode = GET_MODE (rtl);\n@@ -11869,35 +11870,39 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t contains the given subreg.  */\n       if (!subreg_lowpart_p (rtl))\n \tbreak;\n+      inner = SUBREG_REG (rtl);\n+    case TRUNCATE:\n+      if (inner == NULL_RTX)\n+        inner = XEXP (rtl, 0);\n       if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE_CLASS (GET_MODE (SUBREG_REG (rtl))) == MODE_INT\n+\t  && GET_MODE_CLASS (GET_MODE (inner)) == MODE_INT\n \t  && (GET_MODE_SIZE (mode) <= DWARF2_ADDR_SIZE\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t      || (mode == Pmode && mem_mode != VOIDmode)\n #endif\n \t     )\n-\t  && GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl))) <= DWARF2_ADDR_SIZE)\n+\t  && GET_MODE_SIZE (GET_MODE (inner)) <= DWARF2_ADDR_SIZE)\n \t{\n-\t  mem_loc_result = mem_loc_descriptor (SUBREG_REG (rtl),\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (rtl)),\n+\t  mem_loc_result = mem_loc_descriptor (inner,\n+\t\t\t\t\t       GET_MODE (inner),\n \t\t\t\t\t       mem_mode, initialized);\n \t  break;\n \t}\n       if (dwarf_strict)\n \tbreak;\n-      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl))))\n+      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (inner)))\n \tbreak;\n-      if (GET_MODE_SIZE (mode) != GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl)))\n+      if (GET_MODE_SIZE (mode) != GET_MODE_SIZE (GET_MODE (inner))\n \t  && (GET_MODE_CLASS (mode) != MODE_INT\n-\t      || GET_MODE_CLASS (GET_MODE (SUBREG_REG (rtl))) != MODE_INT))\n+\t      || GET_MODE_CLASS (GET_MODE (inner)) != MODE_INT))\n \tbreak;\n       else\n \t{\n \t  dw_die_ref type_die;\n \t  dw_loc_descr_ref cvt;\n \n-\t  mem_loc_result = mem_loc_descriptor (SUBREG_REG (rtl),\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (rtl)),\n+\t  mem_loc_result = mem_loc_descriptor (inner,\n+\t\t\t\t\t       GET_MODE (inner),\n \t\t\t\t\t       mem_mode, initialized);\n \t  if (mem_loc_result == NULL)\n \t    break;\n@@ -11909,7 +11914,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t      break;\n \t    }\n \t  if (GET_MODE_SIZE (mode)\n-\t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (rtl))))\n+\t      != GET_MODE_SIZE (GET_MODE (inner)))\n \t    cvt = new_loc_descr (DW_OP_GNU_convert, 0, 0);\n \t  else\n \t    cvt = new_loc_descr (DW_OP_GNU_reinterpret, 0, 0);\n@@ -12666,7 +12671,6 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case COMPARE:\n-    case TRUNCATE:\n       /* In theory, we could implement the above.  */\n       /* DWARF cannot represent the unsigned compare operations\n \t natively.  */"}, {"sha": "ab442e690b2f195049426ee67ccae3209af666db", "filename": "gcc/rtlhooks-def.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Frtlhooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Frtlhooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks-def.h?ref=76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "patch": "@@ -1,5 +1,5 @@\n /* Default macros to initialize an rtl_hooks data structure.\n-   Copyright 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright 2004, 2005, 2007, 2008, 2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n \n #define RTL_HOOKS_GEN_LOWPART gen_lowpart_general\n-#define RTL_HOOKS_GEN_LOWPART_NO_EMIT gen_lowpart_no_emit_general\n+#define RTL_HOOKS_GEN_LOWPART_NO_EMIT gen_lowpart_if_possible\n #define RTL_HOOKS_REG_NONZERO_REG_BITS reg_nonzero_bits_general\n #define RTL_HOOKS_REG_NUM_SIGN_BIT_COPIES reg_num_sign_bit_copies_general\n #define RTL_HOOKS_REG_TRUNCATED_TO_MODE reg_truncated_to_mode_general\n@@ -38,7 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n }\n \n extern rtx gen_lowpart_general (enum machine_mode, rtx);\n-extern rtx gen_lowpart_no_emit_general (enum machine_mode, rtx);\n extern rtx reg_nonzero_bits_general (const_rtx, enum machine_mode, const_rtx,\n \t\t\t\t     enum machine_mode,\n \t\t\t\t     unsigned HOST_WIDE_INT,"}, {"sha": "ef6552dfd5609d83adc9c98fa2a8cddbad4d381d", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "patch": "@@ -1,5 +1,6 @@\n /* Generic hooks for the RTL middle-end.\n-   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2008, 2009, 2011, 2012\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -79,18 +80,6 @@ gen_lowpart_general (enum machine_mode mode, rtx x)\n     }\n }\n \n-/* Similar to gen_lowpart, but cannot emit any instruction via\n-   copy_to_reg or force_reg.  Mainly used in simplify-rtx.c.  */\n-rtx\n-gen_lowpart_no_emit_general (enum machine_mode mode, rtx x)\n-{\n-  rtx result = gen_lowpart_if_possible (mode, x);\n-  if (result)\n-    return result;\n-  else\n-    return x;\n-}\n-\n rtx\n reg_num_sign_bit_copies_general (const_rtx x ATTRIBUTE_UNUSED,\n \t\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,"}, {"sha": "ea99c64bff848f493891ace69eb8ef424925f6a9", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "patch": "@@ -873,7 +873,9 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t\t\t      simplify_gen_unary (NOT, inner_mode, const1_rtx,\n \t\t\t\t\t\t  inner_mode),\n \t\t\t      XEXP (SUBREG_REG (op), 1));\n-\t  return rtl_hooks.gen_lowpart_no_emit (mode, x);\n+\t  temp = rtl_hooks.gen_lowpart_no_emit (mode, x);\n+\t  if (temp)\n+\t    return temp;\n \t}\n \n       /* Apply De Morgan's laws to reduce number of patterns for machines\n@@ -1029,7 +1031,11 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n       if (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n \t{\n \t  if (TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (op)))\n-\t    return rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t    {\n+\t      temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t      if (temp)\n+\t\treturn temp;\n+\t    }\n \t  /* We can't handle truncation to a partial integer mode here\n \t     because we don't know the real bitsize of the partial\n \t     integer mode.  */\n@@ -1048,7 +1054,11 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n       if (GET_MODE_NUNITS (mode) == 1\n \t  && (TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (op))\n \t      || truncated_to_mode (mode, op)))\n-\treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t{\n+\t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n \n       /* A truncate of a comparison can be replaced with a subreg if\n          STORE_FLAG_VALUE permits.  This is like the previous test,\n@@ -1057,15 +1067,23 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n       if (HWI_COMPUTABLE_MODE_P (mode)\n \t  && COMPARISON_P (op)\n \t  && (STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0)\n-\treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t{\n+\t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n \n       /* A truncate of a memory is just loading the low part of the memory\n \t if we are not changing the meaning of the address. */\n       if (GET_CODE (op) == MEM\n \t  && !VECTOR_MODE_P (mode)\n \t  && !MEM_VOLATILE_P (op)\n \t  && !mode_dependent_address_p (XEXP (op, 0), MEM_ADDR_SPACE (op)))\n-\treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t{\n+\t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n \n       break;\n \n@@ -1298,7 +1316,11 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t  && SUBREG_PROMOTED_VAR_P (op)\n \t  && ! SUBREG_PROMOTED_UNSIGNED_P (op)\n \t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n-\treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t{\n+\t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n \n       /* (sign_extend:M (sign_extend:N <X>)) is (sign_extend:M <X>).\n \t (sign_extend:M (zero_extend:N <X>)) is (zero_extend:M <X>).  */\n@@ -1330,9 +1352,10 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t    {\n \t      rtx inner =\n \t\trtl_hooks.gen_lowpart_no_emit (tmode, XEXP (XEXP (op, 0), 0));\n-\t      return simplify_gen_unary (GET_CODE (op) == ASHIFTRT\n-\t\t\t\t\t ? SIGN_EXTEND : ZERO_EXTEND,\n-\t\t\t\t\t mode, inner, tmode);\n+\t      if (inner)\n+\t\treturn simplify_gen_unary (GET_CODE (op) == ASHIFTRT\n+\t\t\t\t\t   ? SIGN_EXTEND : ZERO_EXTEND,\n+\t\t\t\t\t   mode, inner, tmode);\n \t    }\n \t}\n \n@@ -1360,7 +1383,11 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t  && SUBREG_PROMOTED_VAR_P (op)\n \t  && SUBREG_PROMOTED_UNSIGNED_P (op) > 0\n \t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n-\treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t{\n+\t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n \n       /* Extending a widening multiplication should be canonicalized to\n \t a wider widening multiplication.  */\n@@ -1425,7 +1452,8 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \t    {\n \t      rtx inner =\n \t\trtl_hooks.gen_lowpart_no_emit (tmode, XEXP (XEXP (op, 0), 0));\n-\t      return simplify_gen_unary (ZERO_EXTEND, mode, inner, tmode);\n+\t      if (inner)\n+\t\treturn simplify_gen_unary (ZERO_EXTEND, mode, inner, tmode);\n \t    }\n \t}\n \n@@ -3095,7 +3123,11 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t}\n       /* x/1 is x.  */\n       if (trueop1 == CONST1_RTX (mode))\n-\treturn rtl_hooks.gen_lowpart_no_emit (mode, op0);\n+\t{\n+\t  tem = rtl_hooks.gen_lowpart_no_emit (mode, op0);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n       /* Convert divide by power of two into shift.  */\n       if (CONST_INT_P (trueop1)\n \t  && (val = exact_log2 (UINTVAL (trueop1))) > 0)\n@@ -3154,12 +3186,17 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t    }\n \t  /* x/1 is x.  */\n \t  if (trueop1 == CONST1_RTX (mode))\n-\t    return rtl_hooks.gen_lowpart_no_emit (mode, op0);\n+\t    {\n+\t      tem = rtl_hooks.gen_lowpart_no_emit (mode, op0);\n+\t      if (tem)\n+\t\treturn tem;\n+\t    }\n \t  /* x/-1 is -x.  */\n \t  if (trueop1 == constm1_rtx)\n \t    {\n \t      rtx x = rtl_hooks.gen_lowpart_no_emit (mode, op0);\n-\t      return simplify_gen_unary (NEG, mode, x, mode);\n+\t      if (x)\n+\t\treturn simplify_gen_unary (NEG, mode, x, mode);\n \t    }\n \t}\n       break;"}, {"sha": "2360147fba7d4d290e57419c0d31c58e29c66659", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "patch": "@@ -1,3 +1,8 @@\n+2012-12-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/55717\n+\t* testsuite/g++.dg/opt/pr55717.C: New test.\n+\n 2012-12-17  Andrew Stubbs  <ams@codesourcery.com>\n \t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n "}, {"sha": "7b3af589ee683c129f7715d5d985616bbb5814d1", "filename": "gcc/testsuite/g++.dg/opt/pr55717.C", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr55717.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bd29f63c873a5e50665d3be09f3d6e96dd2cf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr55717.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr55717.C?ref=76bd29f63c873a5e50665d3be09f3d6e96dd2cf7", "patch": "@@ -0,0 +1,107 @@\n+// PR debug/55717\n+// { dg-do compile }\n+// { dg-options \"-O -g\" }\n+\n+struct DebugOnly {};\n+template <class T>\n+struct StripConst { typedef T result; };\n+class TempAllocPolicy {};\n+template <class T>\n+class HashTableEntry\n+{\n+  unsigned keyHash;\n+  template <class, class, class>\n+  friend class HashTable;\n+  T t;\n+  void setLive (unsigned hn) { keyHash = hn; }\n+};\n+template <class T, class HashPolicy, class>\n+struct HashTable\n+{\n+  typedef typename HashPolicy::KeyType Key;\n+  typedef typename HashPolicy::Lookup Lookup;\n+  typedef HashTableEntry <T> Entry;\n+  struct Range\n+  {\n+    Range () {}\n+    Entry *cur, end;\n+    bool empty () { return false; }\n+    T front () { return T (); }\n+  };\n+  struct Enum : public Range\n+  {\n+    HashTable table;\n+    bool removed;\n+    template <class Map>\n+    Enum (Map map) : Range (map.all ()), table (map.impl), removed () {}\n+    void rekeyFront (Lookup l, Key)\n+    {\n+      T t = this->cur->t;\n+      table.putNewInfallible (l, t);\n+    }\n+    void rekeyFront (Key k)\n+    {\n+      rekeyFront (k, k);\n+    }\n+  };\n+  unsigned entryCount;\n+  unsigned sCollisionBit;\n+  unsigned prepareHash (Lookup l)\n+  {\n+    unsigned keyHash (HashPolicy::hash (l));\n+    return keyHash & sCollisionBit;\n+  }\n+  static Entry *entryp;\n+  Entry *findFreeEntry (unsigned) { return entryp; }\n+  void putNewInfallible (Lookup l, T)\n+  {\n+    unsigned keyHash = prepareHash (l);\n+    Entry *entry = findFreeEntry (keyHash);\n+    entry->setLive (keyHash);\n+    entryCount++;\n+  }\n+};\n+template <class Key>\n+struct HashMapEntry { Key key; };\n+template <class Key, class Value, class HashPolicy = DebugOnly, class AllocPolicy = TempAllocPolicy>\n+struct HashMap\n+{\n+  typedef HashMapEntry <Key> Entry;\n+  struct MapHashPolicy : HashPolicy\n+  {\n+    typedef Key KeyType;\n+  };\n+  typedef HashTable <Entry, MapHashPolicy, AllocPolicy> Impl;\n+  Impl impl;\n+  typedef typename Impl::Range Range;\n+  Range all () { return Range (); }\n+  typedef typename Impl::Enum Enum;\n+};\n+class FreeOp;\n+struct AllocationSiteKey;\n+typedef HashMap <AllocationSiteKey, DebugOnly, AllocationSiteKey, TempAllocPolicy> AllocationSiteTable;\n+struct TypeCompartment\n+{\n+  AllocationSiteTable *allocationSiteTable;\n+  void sweep (FreeOp *);\n+};\n+struct JSScript { unsigned *code; };\n+bool IsScriptMarked (JSScript **);\n+struct AllocationSiteKey\n+{\n+  JSScript *script;\n+  unsigned offset : 24;\n+  int kind;\n+  typedef AllocationSiteKey Lookup;\n+  static unsigned hash (AllocationSiteKey key) { return (long (key.script->code + key.offset)) ^ key.kind; }\n+};\n+void\n+TypeCompartment::sweep (FreeOp *)\n+{\n+  for (AllocationSiteTable::Enum e (*allocationSiteTable); !e.empty ();)\n+    {\n+      AllocationSiteKey key = e.front ().key;\n+      IsScriptMarked (&key.script);\n+      e.rekeyFront (key);\n+    }\n+}"}]}