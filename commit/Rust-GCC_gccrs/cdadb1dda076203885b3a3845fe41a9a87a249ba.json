{"sha": "cdadb1dda076203885b3a3845fe41a9a87a249ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RhZGIxZGRhMDc2MjAzODg1YjNhMzg0NWZlNDFhOWE4N2EyNDliYQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-17T15:47:29Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-17T15:47:29Z"}, "message": "reload.c: PROTO -> PARAMS.\n\n        * reload.c: PROTO -> PARAMS.\n        * reload.h: Likewise.\n        * reload1.c: Likewise.\n        * reorg.c: Likewise.\n        * resource.h: Likewise.\n        * rtl.c: Likewise.\n        * rtl.h: Likewise.\n        * rtlanal.c: Likewise.\n        * sbitmap.h: Likewise.\n        * sdbout.c: Likewise.\n        * stack.h: Likewise.\n        * stmt.c: Likewise.\n        * system.h: Likewise.\n\nFrom-SVN: r31461", "tree": {"sha": "02d760faa2edcf054521c763f17de45357e930fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02d760faa2edcf054521c763f17de45357e930fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdadb1dda076203885b3a3845fe41a9a87a249ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdadb1dda076203885b3a3845fe41a9a87a249ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdadb1dda076203885b3a3845fe41a9a87a249ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdadb1dda076203885b3a3845fe41a9a87a249ba/comments", "author": null, "committer": null, "parents": [{"sha": "283a159fe38e477d93b189d43888f1e42043c0af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283a159fe38e477d93b189d43888f1e42043c0af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/283a159fe38e477d93b189d43888f1e42043c0af"}], "stats": {"total": 1286, "additions": 651, "deletions": 635}, "files": [{"sha": "35869ba7363a94b06e03a47f4001f97e65a8ecaf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -1,3 +1,19 @@\n+2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* reload.c: PROTO -> PARAMS.\n+\t* reload.h: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reorg.c: Likewise.\n+\t* resource.h: Likewise.\n+\t* rtl.c: Likewise.\n+\t* rtl.h: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* sbitmap.h: Likewise.\n+\t* sdbout.c: Likewise.\n+\t* stack.h: Likewise.\n+\t* stmt.c: Likewise.\n+\t* system.h: Likewise.\n+\n 2000-01-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* machmode.h: PROTO -> PARAMS."}, {"sha": "ffad39973e76241ef71677e170b33791fa755eb3", "filename": "gcc/reload.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -237,42 +237,42 @@ static int output_reloadnum;\n       : (type)))\n \n #ifdef HAVE_SECONDARY_RELOADS\n-static int push_secondary_reload PROTO((int, rtx, int, int, enum reg_class,\n+static int push_secondary_reload PARAMS ((int, rtx, int, int, enum reg_class,\n \t\t\t\t\tenum machine_mode, enum reload_type,\n \t\t\t\t\tenum insn_code *));\n #endif\n-static enum reg_class find_valid_class PROTO((enum machine_mode, int));\n-static int push_reload\t\tPROTO((rtx, rtx, rtx *, rtx *, enum reg_class,\n+static enum reg_class find_valid_class PARAMS ((enum machine_mode, int));\n+static int push_reload\t\tPARAMS ((rtx, rtx, rtx *, rtx *, enum reg_class,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int, int, enum reload_type));\n-static void push_replacement\tPROTO((rtx *, int, enum machine_mode));\n-static void combine_reloads\tPROTO((void));\n-static int find_reusable_reload\tPROTO((rtx *, rtx, enum reg_class,\n+static void push_replacement\tPARAMS ((rtx *, int, enum machine_mode));\n+static void combine_reloads\tPARAMS ((void));\n+static int find_reusable_reload\tPARAMS ((rtx *, rtx, enum reg_class,\n \t\t\t\t       enum reload_type, int, int));\n-static rtx find_dummy_reload\tPROTO((rtx, rtx, rtx *, rtx *,\n+static rtx find_dummy_reload\tPARAMS ((rtx, rtx, rtx *, rtx *,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       enum reg_class, int, int));\n-static int hard_reg_set_here_p\tPROTO((int, int, rtx));\n-static struct decomposition decompose PROTO((rtx));\n-static int immune_p\t\tPROTO((rtx, rtx, struct decomposition));\n-static int alternative_allows_memconst PROTO((const char *, int));\n-static rtx find_reloads_toplev\tPROTO((rtx, int, enum reload_type, int, int, rtx));\n-static rtx make_memloc\t\tPROTO((rtx, int));\n-static int find_reloads_address\tPROTO((enum machine_mode, rtx *, rtx, rtx *,\n+static int hard_reg_set_here_p\tPARAMS ((int, int, rtx));\n+static struct decomposition decompose PARAMS ((rtx));\n+static int immune_p\t\tPARAMS ((rtx, rtx, struct decomposition));\n+static int alternative_allows_memconst PARAMS ((const char *, int));\n+static rtx find_reloads_toplev\tPARAMS ((rtx, int, enum reload_type, int, int, rtx));\n+static rtx make_memloc\t\tPARAMS ((rtx, int));\n+static int find_reloads_address\tPARAMS ((enum machine_mode, rtx *, rtx, rtx *,\n \t\t\t\t       int, enum reload_type, int, rtx));\n-static rtx subst_reg_equivs\tPROTO((rtx, rtx));\n-static rtx subst_indexed_address PROTO((rtx));\n-static int find_reloads_address_1 PROTO((enum machine_mode, rtx, int, rtx *,\n+static rtx subst_reg_equivs\tPARAMS ((rtx, rtx));\n+static rtx subst_indexed_address PARAMS ((rtx));\n+static int find_reloads_address_1 PARAMS ((enum machine_mode, rtx, int, rtx *,\n \t\t\t\t\t int, enum reload_type,int, rtx));\n-static void find_reloads_address_part PROTO((rtx, rtx *, enum reg_class,\n+static void find_reloads_address_part PARAMS ((rtx, rtx *, enum reg_class,\n \t\t\t\t\t     enum machine_mode, int,\n \t\t\t\t\t     enum reload_type, int));\n-static rtx find_reloads_subreg_address PROTO((rtx, int, int, enum reload_type,\n+static rtx find_reloads_subreg_address PARAMS ((rtx, int, int, enum reload_type,\n \t\t\t\t\t      int, rtx));\n-static int find_inc_amount\tPROTO((rtx, rtx));\n-static int loc_mentioned_in_p\tPROTO((rtx *, rtx));\n-extern void debug_reload_to_stream PROTO((FILE *));\n-extern void debug_reload PROTO((void));\n+static int find_inc_amount\tPARAMS ((rtx, rtx));\n+static int loc_mentioned_in_p\tPARAMS ((rtx *, rtx));\n+extern void debug_reload_to_stream PARAMS ((FILE *));\n+extern void debug_reload PARAMS ((void));\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n "}, {"sha": "dcf51190abed285999e3e61663e125f9442203a9", "filename": "gcc/reload.h", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -43,7 +43,7 @@ Boston, MA 02111-1307, USA.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n #endif\n #endif\n-extern int memory_move_secondary_cost PROTO ((enum machine_mode, enum reg_class, int));\n+extern int memory_move_secondary_cost PARAMS ((enum machine_mode, enum reg_class, int));\n \n /* Maximum number of reloads we can need.  */\n #define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))\n@@ -254,131 +254,131 @@ struct insn_chain\n extern struct insn_chain *reload_insn_chain;\n \n /* Allocate a new insn_chain structure.  */\n-extern struct insn_chain *new_insn_chain\tPROTO((void));\n+extern struct insn_chain *new_insn_chain\tPARAMS ((void));\n \n-extern void compute_use_by_pseudos\t\tPROTO((HARD_REG_SET *, regset));\n+extern void compute_use_by_pseudos\t\tPARAMS ((HARD_REG_SET *, regset));\n #endif\n \n /* Functions from reload.c:  */\n \n /* Return a memory location that will be used to copy X in mode MODE.  \n    If we haven't already made a location for this mode in this insn,\n    call find_reloads_address on the location being returned.  */\n-extern rtx get_secondary_mem PROTO((rtx, enum machine_mode,\n+extern rtx get_secondary_mem PARAMS ((rtx, enum machine_mode,\n \t\t\t\t    int, enum reload_type));\n \n /* Clear any secondary memory locations we've made.  */\n-extern void clear_secondary_mem PROTO((void));\n+extern void clear_secondary_mem PARAMS ((void));\n \n /* Transfer all replacements that used to be in reload FROM to be in\n    reload TO.  */\n-extern void transfer_replacements PROTO((int, int));\n+extern void transfer_replacements PARAMS ((int, int));\n \n /* IN_RTX is the value loaded by a reload that we now decided to inherit,\n    or a subpart of it.  If we have any replacements registered for IN_RTX,\n    chancel the reloads that were supposed to load them.\n    Return non-zero if we chanceled any reloads.  */\n-extern int remove_address_replacements PROTO((rtx in_rtx));\n+extern int remove_address_replacements PARAMS ((rtx in_rtx));\n \n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n    if they are the same hard reg, and has special hacks for\n    autoincrement and autodecrement.  */\n-extern int operands_match_p PROTO((rtx, rtx));\n+extern int operands_match_p PARAMS ((rtx, rtx));\n \n /* Return 1 if altering OP will not modify the value of CLOBBER. */\n-extern int safe_from_earlyclobber PROTO((rtx, rtx));\n+extern int safe_from_earlyclobber PARAMS ((rtx, rtx));\n \n /* Search the body of INSN for values that need reloading and record them\n    with push_reload.  REPLACE nonzero means record also where the values occur\n    so that subst_reloads can be used.  */\n-extern int find_reloads PROTO((rtx, int, int, int, short *));\n+extern int find_reloads PARAMS ((rtx, int, int, int, short *));\n \n /* Compute the sum of X and Y, making canonicalizations assumed in an\n    address, namely: sum constant integers, surround the sum of two\n    constants with a CONST, put the constant as the second operand, and\n    group the constant on the outermost sum.  */\n-extern rtx form_sum PROTO((rtx, rtx));\n+extern rtx form_sum PARAMS ((rtx, rtx));\n \n /* Substitute into the current INSN the registers into which we have reloaded\n    the things that need reloading.  */\n-extern void subst_reloads PROTO((void));\n+extern void subst_reloads PARAMS ((void));\n \n /* Make a copy of any replacements being done into X and move those copies\n    to locations in Y, a copy of X.  We only look at the highest level of\n    the RTL.  */\n-extern void copy_replacements PROTO((rtx, rtx));\n+extern void copy_replacements PARAMS ((rtx, rtx));\n \n /* Change any replacements being done to *X to be done to *Y */\n-extern void move_replacements PROTO((rtx *x, rtx *y));\n+extern void move_replacements PARAMS ((rtx *x, rtx *y));\n \n /* If LOC was scheduled to be replaced by something, return the replacement.\n    Otherwise, return *LOC.  */\n-extern rtx find_replacement PROTO((rtx *));\n+extern rtx find_replacement PARAMS ((rtx *));\n \n /* Return nonzero if register in range [REGNO, ENDREGNO)\n    appears either explicitly or implicitly in X\n    other than being stored into.  */\n-extern int refers_to_regno_for_reload_p PROTO((int, int, rtx, rtx *));\n+extern int refers_to_regno_for_reload_p PARAMS ((int, int, rtx, rtx *));\n \n /* Nonzero if modifying X will affect IN.  */\n-extern int reg_overlap_mentioned_for_reload_p PROTO((rtx, rtx));\n+extern int reg_overlap_mentioned_for_reload_p PARAMS ((rtx, rtx));\n \n /* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n    registers.  */\n-extern int refers_to_mem_for_reload_p PROTO((rtx));\n+extern int refers_to_mem_for_reload_p PARAMS ((rtx));\n \n /* Check the insns before INSN to see if there is a suitable register\n    containing the same value as GOAL.  */\n-extern rtx find_equiv_reg PROTO((rtx, rtx, enum reg_class, int, short *,\n+extern rtx find_equiv_reg PARAMS ((rtx, rtx, enum reg_class, int, short *,\n \t\t\t\t int, enum machine_mode));\n \n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n-extern int regno_clobbered_p PROTO((int, rtx));\n+extern int regno_clobbered_p PARAMS ((int, rtx));\n \n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n-int earlyclobber_operand_p PROTO((rtx));\n+int earlyclobber_operand_p PARAMS ((rtx));\n \n /* Functions in reload1.c:  */\n \n-extern int reloads_conflict\t\tPROTO ((int, int));\n+extern int reloads_conflict\t\tPARAMS ((int, int));\n \n-int count_occurrences            PROTO((rtx, rtx));\n+int count_occurrences            PARAMS ((rtx, rtx));\n \n /* Initialize the reload pass once per compilation.  */\n-extern void init_reload PROTO((void));\n+extern void init_reload PARAMS ((void));\n \n /* The reload pass itself.  */\n-extern int reload PROTO((rtx, int, FILE *));\n+extern int reload PARAMS ((rtx, int, FILE *));\n \n /* Mark the slots in regs_ever_live for the hard regs\n    used by pseudo-reg number REGNO.  */\n-extern void mark_home_live PROTO((int));\n+extern void mark_home_live PARAMS ((int));\n \n /* Scan X and replace any eliminable registers (such as fp) with a\n    replacement (such as sp), plus an offset.  */\n-extern rtx eliminate_regs PROTO((rtx, enum machine_mode, rtx));\n+extern rtx eliminate_regs PARAMS ((rtx, enum machine_mode, rtx));\n \n /* Emit code to perform a reload from IN (which may be a reload register) to\n    OUT (which may also be a reload register).  IN or OUT is from operand\n    OPNUM with reload type TYPE.  */\n-extern rtx gen_reload PROTO((rtx, rtx, int, enum reload_type));\n+extern rtx gen_reload PARAMS ((rtx, rtx, int, enum reload_type));\n \n /* Deallocate the reload register used by reload number R.  */\n-extern void deallocate_reload_reg PROTO((int r));\n+extern void deallocate_reload_reg PARAMS ((int r));\n \n /* Functions in caller-save.c:  */\n \n /* Initialize for caller-save.  */\n-extern void init_caller_save PROTO((void));\n+extern void init_caller_save PARAMS ((void));\n \n /* Initialize save areas by showing that we haven't allocated any yet.  */\n-extern void init_save_areas PROTO((void));\n+extern void init_save_areas PARAMS ((void));\n \n /* Allocate save areas for any hard registers that might need saving.  */\n-extern void setup_save_areas PROTO((void));\n+extern void setup_save_areas PARAMS ((void));\n \n /* Find the places where hard regs are live across calls and save them.  */\n-extern void save_call_clobbered_regs PROTO((void));\n+extern void save_call_clobbered_regs PARAMS ((void));\n \n /* Replace (subreg (reg)) with the appropriate (reg) for any operands.  */\n-extern void cleanup_subreg_operands PROTO ((rtx));\n+extern void cleanup_subreg_operands PARAMS ((rtx));"}, {"sha": "4745773dd8d811ad7384bd35ac0cb1aa02a6619e", "filename": "gcc/reload1.c", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -366,92 +366,92 @@ static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n static int num_labels;\n \f\n-static void maybe_fix_stack_asms\tPROTO((void));\n-static void copy_reloads\t\tPROTO((struct insn_chain *));\n-static void calculate_needs_all_insns\tPROTO((int));\n-static int find_reg\t\t\tPROTO((struct insn_chain *, int,\n+static void maybe_fix_stack_asms\tPARAMS ((void));\n+static void copy_reloads\t\tPARAMS ((struct insn_chain *));\n+static void calculate_needs_all_insns\tPARAMS ((int));\n+static int find_reg\t\t\tPARAMS ((struct insn_chain *, int,\n \t\t\t\t\t       FILE *));\n-static void find_reload_regs\t\tPROTO((struct insn_chain *, FILE *));\n-static void select_reload_regs\t\tPROTO((FILE *));\n-static void delete_caller_save_insns\tPROTO((void));\n-\n-static void spill_failure\t\tPROTO((rtx, enum reg_class));\n-static void count_spilled_pseudo\tPROTO((int, int, int));\n-static void delete_dead_insn\t\tPROTO((rtx));\n-static void alter_reg  \t\t\tPROTO((int, int));\n-static void set_label_offsets\t\tPROTO((rtx, rtx, int));\n-static void check_eliminable_occurrences\tPROTO((rtx));\n-static void elimination_effects\t\tPROTO((rtx, enum machine_mode));\n-static int eliminate_regs_in_insn\tPROTO((rtx, int));\n-static void update_eliminable_offsets\tPROTO((void));\n-static void mark_not_eliminable\t\tPROTO((rtx, rtx, void *));\n-static void set_initial_elim_offsets\tPROTO((void));\n-static void verify_initial_elim_offsets\tPROTO((void));\n-static void set_initial_label_offsets\tPROTO((void));\n-static void set_offsets_for_label\tPROTO((rtx));\n-static void init_elim_table\t\tPROTO((void));\n-static void update_eliminables\t\tPROTO((HARD_REG_SET *));\n-static void spill_hard_reg\t\tPROTO((int, FILE *, int));\n-static int finish_spills\t\tPROTO((int, FILE *));\n-static void ior_hard_reg_set\t\tPROTO((HARD_REG_SET *, HARD_REG_SET *));\n-static void scan_paradoxical_subregs\tPROTO((rtx));\n-static void count_pseudo\t\tPROTO((int));\n-static void order_regs_for_reload\tPROTO((struct insn_chain *));\n-static void reload_as_needed\t\tPROTO((int));\n-static void forget_old_reloads_1\tPROTO((rtx, rtx, void *));\n-static int reload_reg_class_lower\tPROTO((const PTR, const PTR));\n-static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n+static void find_reload_regs\t\tPARAMS ((struct insn_chain *, FILE *));\n+static void select_reload_regs\t\tPARAMS ((FILE *));\n+static void delete_caller_save_insns\tPARAMS ((void));\n+\n+static void spill_failure\t\tPARAMS ((rtx, enum reg_class));\n+static void count_spilled_pseudo\tPARAMS ((int, int, int));\n+static void delete_dead_insn\t\tPARAMS ((rtx));\n+static void alter_reg  \t\t\tPARAMS ((int, int));\n+static void set_label_offsets\t\tPARAMS ((rtx, rtx, int));\n+static void check_eliminable_occurrences\tPARAMS ((rtx));\n+static void elimination_effects\t\tPARAMS ((rtx, enum machine_mode));\n+static int eliminate_regs_in_insn\tPARAMS ((rtx, int));\n+static void update_eliminable_offsets\tPARAMS ((void));\n+static void mark_not_eliminable\t\tPARAMS ((rtx, rtx, void *));\n+static void set_initial_elim_offsets\tPARAMS ((void));\n+static void verify_initial_elim_offsets\tPARAMS ((void));\n+static void set_initial_label_offsets\tPARAMS ((void));\n+static void set_offsets_for_label\tPARAMS ((rtx));\n+static void init_elim_table\t\tPARAMS ((void));\n+static void update_eliminables\t\tPARAMS ((HARD_REG_SET *));\n+static void spill_hard_reg\t\tPARAMS ((int, FILE *, int));\n+static int finish_spills\t\tPARAMS ((int, FILE *));\n+static void ior_hard_reg_set\t\tPARAMS ((HARD_REG_SET *, HARD_REG_SET *));\n+static void scan_paradoxical_subregs\tPARAMS ((rtx));\n+static void count_pseudo\t\tPARAMS ((int));\n+static void order_regs_for_reload\tPARAMS ((struct insn_chain *));\n+static void reload_as_needed\t\tPARAMS ((int));\n+static void forget_old_reloads_1\tPARAMS ((rtx, rtx, void *));\n+static int reload_reg_class_lower\tPARAMS ((const PTR, const PTR));\n+static void mark_reload_reg_in_use\tPARAMS ((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n-static void clear_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n+static void clear_reload_reg_in_use\tPARAMS ((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n-static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n-static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type,\n+static int reload_reg_free_p\t\tPARAMS ((int, int, enum reload_type));\n+static int reload_reg_free_for_value_p\tPARAMS ((int, int, enum reload_type,\n \t\t\t\t\t       rtx, rtx, int, int));\n-static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n-static int allocate_reload_reg\t\tPROTO((struct insn_chain *, int, int));\n-static void failed_reload\t\tPROTO((rtx, int));\n-static int set_reload_reg\t\tPROTO((int, int));\n-static void choose_reload_regs_init\tPROTO((struct insn_chain *, rtx *));\n-static void choose_reload_regs\t\tPROTO((struct insn_chain *));\n-static void merge_assigned_reloads\tPROTO((rtx));\n-static void emit_input_reload_insns\tPROTO((struct insn_chain *,\n+static int reload_reg_reaches_end_p\tPARAMS ((int, int, enum reload_type));\n+static int allocate_reload_reg\t\tPARAMS ((struct insn_chain *, int, int));\n+static void failed_reload\t\tPARAMS ((rtx, int));\n+static int set_reload_reg\t\tPARAMS ((int, int));\n+static void choose_reload_regs_init\tPARAMS ((struct insn_chain *, rtx *));\n+static void choose_reload_regs\t\tPARAMS ((struct insn_chain *));\n+static void merge_assigned_reloads\tPARAMS ((rtx));\n+static void emit_input_reload_insns\tPARAMS ((struct insn_chain *,\n \t\t\t\t\t       struct reload *, rtx, int));\n-static void emit_output_reload_insns\tPROTO((struct insn_chain *,\n+static void emit_output_reload_insns\tPARAMS ((struct insn_chain *,\n \t\t\t\t\t       struct reload *, int));\n-static void do_input_reload\t\tPROTO((struct insn_chain *,\n+static void do_input_reload\t\tPARAMS ((struct insn_chain *,\n \t\t\t\t\t       struct reload *, int));\n-static void do_output_reload\t\tPROTO((struct insn_chain *,\n+static void do_output_reload\t\tPARAMS ((struct insn_chain *,\n \t\t\t\t\t       struct reload *, int));\n-static void emit_reload_insns\t\tPROTO((struct insn_chain *));\n-static void delete_output_reload\tPROTO((rtx, int, int));\n-static void delete_address_reloads\tPROTO((rtx, rtx));\n-static void delete_address_reloads_1\tPROTO((rtx, rtx, rtx));\n-static rtx inc_for_reload\t\tPROTO((rtx, rtx, rtx, int));\n-static int constraint_accepts_reg_p\tPROTO((const char *, rtx));\n-static void reload_cse_regs_1\t\tPROTO((rtx));\n-static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n-static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx));\n-static void reload_cse_invalidate_mem\tPROTO((rtx));\n-static void reload_cse_invalidate_rtx\tPROTO((rtx, rtx, void *));\n-static int reload_cse_regno_equal_p\tPROTO((int, rtx, enum machine_mode));\n-static int reload_cse_noop_set_p\tPROTO((rtx, rtx));\n-static int reload_cse_simplify_set\tPROTO((rtx, rtx));\n-static int reload_cse_simplify_operands\tPROTO((rtx));\n-static void reload_cse_check_clobber\tPROTO((rtx, rtx, void *));\n-static void reload_cse_record_set\tPROTO((rtx, rtx));\n-static void reload_combine PROTO((void));\n-static void reload_combine_note_use PROTO((rtx *, rtx));\n-static void reload_combine_note_store PROTO((rtx, rtx, void *));\n-static void reload_cse_move2add PROTO((rtx));\n-static void move2add_note_store PROTO((rtx, rtx, void *));\n+static void emit_reload_insns\t\tPARAMS ((struct insn_chain *));\n+static void delete_output_reload\tPARAMS ((rtx, int, int));\n+static void delete_address_reloads\tPARAMS ((rtx, rtx));\n+static void delete_address_reloads_1\tPARAMS ((rtx, rtx, rtx));\n+static rtx inc_for_reload\t\tPARAMS ((rtx, rtx, rtx, int));\n+static int constraint_accepts_reg_p\tPARAMS ((const char *, rtx));\n+static void reload_cse_regs_1\t\tPARAMS ((rtx));\n+static void reload_cse_invalidate_regno\tPARAMS ((int, enum machine_mode, int));\n+static int reload_cse_mem_conflict_p\tPARAMS ((rtx, rtx));\n+static void reload_cse_invalidate_mem\tPARAMS ((rtx));\n+static void reload_cse_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n+static int reload_cse_regno_equal_p\tPARAMS ((int, rtx, enum machine_mode));\n+static int reload_cse_noop_set_p\tPARAMS ((rtx, rtx));\n+static int reload_cse_simplify_set\tPARAMS ((rtx, rtx));\n+static int reload_cse_simplify_operands\tPARAMS ((rtx));\n+static void reload_cse_check_clobber\tPARAMS ((rtx, rtx, void *));\n+static void reload_cse_record_set\tPARAMS ((rtx, rtx));\n+static void reload_combine PARAMS ((void));\n+static void reload_combine_note_use PARAMS ((rtx *, rtx));\n+static void reload_combine_note_store PARAMS ((rtx, rtx, void *));\n+static void reload_cse_move2add PARAMS ((rtx));\n+static void move2add_note_store PARAMS ((rtx, rtx, void *));\n #ifdef AUTO_INC_DEC\n-static void add_auto_inc_notes PROTO((rtx, rtx));\n+static void add_auto_inc_notes PARAMS ((rtx, rtx));\n #endif\n-static rtx gen_mode_int\t\t\tPROTO((enum machine_mode,\n+static rtx gen_mode_int\t\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t       HOST_WIDE_INT));\n-static void failed_reload\t\tPROTO((rtx, int));\n-static int set_reload_reg\t\tPROTO((int, int));\n-extern void dump_needs\t\t\tPROTO((struct insn_chain *, FILE *));\n+static void failed_reload\t\tPARAMS ((rtx, int));\n+static int set_reload_reg\t\tPARAMS ((int, int));\n+extern void dump_needs\t\t\tPARAMS ((struct insn_chain *, FILE *));\n \f\n /* Initialize the reload pass once per compilation.  */\n "}, {"sha": "6648455d3f1199edfe52c16a40609d39d249eaa6", "filename": "gcc/reorg.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -177,53 +177,53 @@ static int *uid_to_ruid;\n /* Highest valid index in `uid_to_ruid'.  */\n static int max_uid;\n \n-static int stop_search_p\t\tPROTO((rtx, int));\n-static int resource_conflicts_p\t\tPROTO((struct resources *,\n+static int stop_search_p\t\tPARAMS ((rtx, int));\n+static int resource_conflicts_p\t\tPARAMS ((struct resources *,\n \t\t\t\t\t       struct resources *));\n-static int insn_references_resource_p\tPROTO((rtx, struct resources *, int));\n-static int insn_sets_resource_p\t\tPROTO((rtx, struct resources *, int));\n-static rtx find_end_label\t\tPROTO((void));\n-static rtx emit_delay_sequence\t\tPROTO((rtx, rtx, int));\n-static rtx add_to_delay_list\t\tPROTO((rtx, rtx));\n-static rtx delete_from_delay_slot\tPROTO((rtx));\n-static void delete_scheduled_jump\tPROTO((rtx));\n-static void note_delay_statistics\tPROTO((int, int));\n+static int insn_references_resource_p\tPARAMS ((rtx, struct resources *, int));\n+static int insn_sets_resource_p\t\tPARAMS ((rtx, struct resources *, int));\n+static rtx find_end_label\t\tPARAMS ((void));\n+static rtx emit_delay_sequence\t\tPARAMS ((rtx, rtx, int));\n+static rtx add_to_delay_list\t\tPARAMS ((rtx, rtx));\n+static rtx delete_from_delay_slot\tPARAMS ((rtx));\n+static void delete_scheduled_jump\tPARAMS ((rtx));\n+static void note_delay_statistics\tPARAMS ((int, int));\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n-static rtx optimize_skip\t\tPROTO((rtx));\n+static rtx optimize_skip\t\tPARAMS ((rtx));\n #endif\n-static int get_jump_flags\t\tPROTO((rtx, rtx));\n-static int rare_destination\t\tPROTO((rtx));\n-static int mostly_true_jump\t\tPROTO((rtx, rtx));\n-static rtx get_branch_condition\t\tPROTO((rtx, rtx));\n-static int condition_dominates_p\tPROTO((rtx, rtx));\n-static int redirect_with_delay_slots_safe_p PROTO ((rtx, rtx, rtx));\n-static int redirect_with_delay_list_safe_p PROTO ((rtx, rtx, rtx));\n-static int check_annul_list_true_false\tPROTO ((int, rtx));\n-static rtx steal_delay_list_from_target PROTO((rtx, rtx, rtx, rtx,\n+static int get_jump_flags\t\tPARAMS ((rtx, rtx));\n+static int rare_destination\t\tPARAMS ((rtx));\n+static int mostly_true_jump\t\tPARAMS ((rtx, rtx));\n+static rtx get_branch_condition\t\tPARAMS ((rtx, rtx));\n+static int condition_dominates_p\tPARAMS ((rtx, rtx));\n+static int redirect_with_delay_slots_safe_p PARAMS ((rtx, rtx, rtx));\n+static int redirect_with_delay_list_safe_p PARAMS ((rtx, rtx, rtx));\n+static int check_annul_list_true_false\tPARAMS ((int, rtx));\n+static rtx steal_delay_list_from_target PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t\t       struct resources *,\n \t\t\t\t\t       struct resources *,\n \t\t\t\t\t       struct resources *,\n \t\t\t\t\t       int, int *, int *, rtx *));\n-static rtx steal_delay_list_from_fallthrough PROTO((rtx, rtx, rtx, rtx,\n+static rtx steal_delay_list_from_fallthrough PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    int, int *, int *));\n-static void try_merge_delay_insns\tPROTO((rtx, rtx));\n-static rtx redundant_insn\t\tPROTO((rtx, rtx, rtx));\n-static int own_thread_p\t\t\tPROTO((rtx, rtx, int));\n-static void update_block\t\tPROTO((rtx, rtx));\n-static int reorg_redirect_jump\t\tPROTO((rtx, rtx));\n-static void update_reg_dead_notes\tPROTO((rtx, rtx));\n-static void fix_reg_dead_note\t\tPROTO((rtx, rtx));\n-static void update_reg_unused_notes\tPROTO((rtx, rtx));\n-static void fill_simple_delay_slots\tPROTO((int));\n-static rtx fill_slots_from_thread\tPROTO((rtx, rtx, rtx, rtx, int, int,\n+static void try_merge_delay_insns\tPARAMS ((rtx, rtx));\n+static rtx redundant_insn\t\tPARAMS ((rtx, rtx, rtx));\n+static int own_thread_p\t\t\tPARAMS ((rtx, rtx, int));\n+static void update_block\t\tPARAMS ((rtx, rtx));\n+static int reorg_redirect_jump\t\tPARAMS ((rtx, rtx));\n+static void update_reg_dead_notes\tPARAMS ((rtx, rtx));\n+static void fix_reg_dead_note\t\tPARAMS ((rtx, rtx));\n+static void update_reg_unused_notes\tPARAMS ((rtx, rtx));\n+static void fill_simple_delay_slots\tPARAMS ((int));\n+static rtx fill_slots_from_thread\tPARAMS ((rtx, rtx, rtx, rtx, int, int,\n \t\t\t\t\t       int, int, int *, rtx));\n-static void fill_eager_delay_slots\tPROTO((void));\n-static void relax_delay_slots\t\tPROTO((rtx));\n+static void fill_eager_delay_slots\tPARAMS ((void));\n+static void relax_delay_slots\t\tPARAMS ((rtx));\n #ifdef HAVE_return\n-static void make_return_insns\t\tPROTO((rtx));\n+static void make_return_insns\t\tPARAMS ((rtx));\n #endif\n \f\n /* Return TRUE if this insn should stop the search for insn to fill delay"}, {"sha": "5c11e4c061b13d1371ae2f0274b03b6948b40b8f", "filename": "gcc/resource.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -33,15 +33,15 @@ struct resources\n   HARD_REG_SET regs;\t/* Which registers are set or needed.  */\n };\n \n-extern void mark_target_live_regs \tPROTO((rtx, rtx, struct resources *));\n-extern void mark_set_resources\t\tPROTO((rtx, struct resources *, int,\n+extern void mark_target_live_regs \tPARAMS ((rtx, rtx, struct resources *));\n+extern void mark_set_resources\t\tPARAMS ((rtx, struct resources *, int,\n \t\t\t\t\t       int));\n-extern void mark_referenced_resources\tPROTO((rtx, struct resources *, int));\n-extern void clear_hashed_info_for_insn\tPROTO((rtx));\n-extern void incr_ticks_for_insn\t\tPROTO((rtx));\n-extern void mark_end_of_function_resources PROTO ((rtx, int));\n-extern void init_resource_info\t\tPROTO((rtx));\n-extern void free_resource_info\t\tPROTO((void));\n-extern rtx find_free_register\t\tPROTO((rtx, rtx, const char *, int,\n+extern void mark_referenced_resources\tPARAMS ((rtx, struct resources *, int));\n+extern void clear_hashed_info_for_insn\tPARAMS ((rtx));\n+extern void incr_ticks_for_insn\t\tPARAMS ((rtx));\n+extern void mark_end_of_function_resources PARAMS ((rtx, int));\n+extern void init_resource_info\t\tPARAMS ((rtx));\n+extern void free_resource_info\t\tPARAMS ((void));\n+extern rtx find_free_register\t\tPARAMS ((rtx, rtx, const char *, int,\n \t\t\t\t\t       HARD_REG_SET *));\n-extern int reg_dead_p\t\t\tPROTO((rtx, rtx));\n+extern int reg_dead_p\t\t\tPARAMS ((rtx, rtx));"}, {"sha": "f14d789ab95d712861008fc70a11cb2ad12a8ae0", "filename": "gcc/rtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -257,11 +257,11 @@ const char * const reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"\n \t\t\t  \"REG_FRAME_RELATED_EXPR\", \"REG_EH_REGION\",\n \t\t\t  \"REG_EH_RETHROW\", \"REG_SAVE_NOTE\" };\n \n-static void fatal_with_file_and_line PVPROTO((FILE *, const char *, ...))\n+static void fatal_with_file_and_line PARAMS ((FILE *, const char *, ...))\n   ATTRIBUTE_NORETURN;\n-static void fatal_expected_char PROTO((FILE *, int, int)) ATTRIBUTE_NORETURN;\n-static void read_name\t\tPROTO((char *, FILE *));\n-static const char *trim_filename PROTO((const char *));\n+static void fatal_expected_char PARAMS ((FILE *, int, int)) ATTRIBUTE_NORETURN;\n+static void read_name\t\tPARAMS ((char *, FILE *));\n+static const char *trim_filename PARAMS ((const char *));\n \f\n /* Allocate an rtx vector of N elements.\n    Store the length, and initialize all elements to zero.  */\n@@ -697,7 +697,7 @@ int read_rtx_lineno = 1;\n const char *read_rtx_filename = \"<unknown>\";\n \n static void\n-fatal_with_file_and_line VPROTO((FILE *infile, const char *msg, ...))\n+fatal_with_file_and_line VPARAMS ((FILE *infile, const char *msg, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   FILE *infile;"}, {"sha": "1067e202c7ffa83ef66407b19421745ddf2e40a0", "filename": "gcc/rtl.h", "status": "modified", "additions": 379, "deletions": 379, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -274,22 +274,22 @@ typedef struct rtvec_def{\n \t\t\t\t  __PRETTY_FUNCTION__);\t\t\t\\\n      &_rtvec->elem[_i]; }))\n \n-extern void rtl_check_failed_bounds PROTO((rtx, int,\n+extern void rtl_check_failed_bounds PARAMS ((rtx, int,\n \t\t\t\t\t   const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_type1 PROTO((rtx, int, int,\n+extern void rtl_check_failed_type1 PARAMS ((rtx, int, int,\n \t\t\t\t\t  const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_type2 PROTO((rtx, int, int, int,\n+extern void rtl_check_failed_type2 PARAMS ((rtx, int, int, int,\n \t\t\t\t\t  const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_code1 PROTO((rtx, enum rtx_code,\n+extern void rtl_check_failed_code1 PARAMS ((rtx, enum rtx_code,\n \t\t\t\t\t  const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n-extern void rtl_check_failed_code2 PROTO((rtx, enum rtx_code, enum rtx_code,\n+extern void rtl_check_failed_code2 PARAMS ((rtx, enum rtx_code, enum rtx_code,\n \t\t\t\t\t  const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n-extern void rtvec_check_failed_bounds PROTO((rtvec, int,\n+extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n \t\t\t\t\t     const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n \n@@ -944,207 +944,207 @@ extern int rtx_equal_function_value_matters;\n #define exact_log2(N) exact_log2_wide ((unsigned HOST_WIDE_INT) (N))\n #define floor_log2(N) floor_log2_wide ((unsigned HOST_WIDE_INT) (N))\n #endif\n-extern int exact_log2_wide\t\tPROTO((unsigned HOST_WIDE_INT));\n-extern int floor_log2_wide\t\tPROTO((unsigned HOST_WIDE_INT));\n+extern int exact_log2_wide\t\tPARAMS ((unsigned HOST_WIDE_INT));\n+extern int floor_log2_wide\t\tPARAMS ((unsigned HOST_WIDE_INT));\n \n /* In expmed.c */\n-extern int ceil_log2\t\t\tPROTO((unsigned HOST_WIDE_INT));\n+extern int ceil_log2\t\t\tPARAMS ((unsigned HOST_WIDE_INT));\n \n #define plus_constant(X,C) plus_constant_wide (X, (HOST_WIDE_INT) (C))\n \n #define plus_constant_for_output(X,C)  \\\n   plus_constant_for_output_wide (X, (HOST_WIDE_INT) (C))\n \n /* In explow.c */\n-extern HOST_WIDE_INT trunc_int_for_mode\tPROTO((HOST_WIDE_INT,\n+extern HOST_WIDE_INT trunc_int_for_mode\tPARAMS ((HOST_WIDE_INT,\n \t\t\t\t\t       enum machine_mode));\n-extern rtx plus_constant_wide\t\t PROTO((rtx, HOST_WIDE_INT));\n-extern rtx plus_constant_for_output_wide PROTO((rtx, HOST_WIDE_INT));\n-extern void optimize_save_area_alloca\tPROTO((rtx));\n+extern rtx plus_constant_wide\t\t PARAMS ((rtx, HOST_WIDE_INT));\n+extern rtx plus_constant_for_output_wide PARAMS ((rtx, HOST_WIDE_INT));\n+extern void optimize_save_area_alloca\tPARAMS ((rtx));\n \n-extern rtx gen_rtx\t\t\tPVPROTO((enum rtx_code,\n+extern rtx gen_rtx\t\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, ...));\n-extern rtvec gen_rtvec\t\t\tPVPROTO((int, ...));\n-\n-extern char *oballoc\t\t\tPROTO((int));\n-extern char *permalloc\t\t\tPROTO((int));\n-extern rtx rtx_alloc\t\t\tPROTO((RTX_CODE));\n-extern rtvec rtvec_alloc\t\tPROTO((int));\n-extern rtx copy_insn_1\t\t\tPROTO((rtx));\n-extern rtx copy_insn\t\t\tPROTO((rtx));\n-extern rtx copy_rtx\t\t\tPROTO((rtx));\n-extern rtx copy_rtx_if_shared\t\tPROTO((rtx));\n-extern rtx copy_most_rtx\t\tPROTO((rtx, rtx));\n-extern rtx shallow_copy_rtx\t\tPROTO((rtx));\n-extern int rtx_equal_p                  PROTO((rtx, rtx));\n-extern rtvec gen_rtvec_v\t\tPROTO((int, rtx *));\n-extern rtx gen_reg_rtx\t\t\tPROTO((enum machine_mode));\n-extern rtx gen_label_rtx\t\tPROTO((void));\n-extern rtx gen_lowpart_common\t\tPROTO((enum machine_mode, rtx));\n-extern rtx gen_lowpart\t\t\tPROTO((enum machine_mode, rtx));\n-extern rtx gen_lowpart_if_possible\tPROTO((enum machine_mode, rtx));\n-extern rtx gen_highpart\t\t\tPROTO((enum machine_mode, rtx));\n-extern rtx gen_realpart\t\t\tPROTO((enum machine_mode, rtx));\n-extern rtx gen_imagpart\t\t\tPROTO((enum machine_mode, rtx));\n-extern rtx operand_subword\t\tPROTO((rtx, int, int, enum machine_mode));\n-extern rtx operand_subword_force\tPROTO((rtx, int, enum machine_mode));\n-extern int subreg_lowpart_p\t\tPROTO((rtx));\n-extern rtx make_safe_from\t\tPROTO((rtx, rtx));\n-extern rtx convert_memory_address\tPROTO((enum machine_mode, rtx));\n-extern rtx memory_address\t\tPROTO((enum machine_mode, rtx));\n-extern rtx get_insns\t\t\tPROTO((void));\n-extern const char *get_insn_name\tPROTO((int));\n-extern rtx get_last_insn\t\tPROTO((void));\n-extern rtx get_last_insn_anywhere\tPROTO((void));\n-extern void start_sequence\t\tPROTO((void));\n-extern void push_to_sequence\t\tPROTO((rtx));\n-extern void end_sequence\t\tPROTO((void));\n-extern rtx gen_sequence\t\t\tPROTO((void));\n-extern rtx immed_double_const\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode));\n-extern rtx force_const_mem\t\tPROTO((enum machine_mode, rtx));\n-extern rtx force_reg\t\t\tPROTO((enum machine_mode, rtx));\n-extern rtx get_pool_constant\t\tPROTO((rtx));\n-extern enum machine_mode get_pool_mode\tPROTO((rtx));\n-extern rtx get_pool_constant_for_function\tPROTO((struct function *, rtx));\n-extern enum machine_mode get_pool_mode_for_function\tPROTO((struct function *, rtx));\n-extern int get_pool_offset\t\tPROTO((rtx));\n-extern rtx simplify_subtraction\t\tPROTO((rtx));\n-extern rtx assign_stack_local\t\tPROTO((enum machine_mode,\n+extern rtvec gen_rtvec\t\t\tPARAMS ((int, ...));\n+\n+extern char *oballoc\t\t\tPARAMS ((int));\n+extern char *permalloc\t\t\tPARAMS ((int));\n+extern rtx rtx_alloc\t\t\tPARAMS ((RTX_CODE));\n+extern rtvec rtvec_alloc\t\tPARAMS ((int));\n+extern rtx copy_insn_1\t\t\tPARAMS ((rtx));\n+extern rtx copy_insn\t\t\tPARAMS ((rtx));\n+extern rtx copy_rtx\t\t\tPARAMS ((rtx));\n+extern rtx copy_rtx_if_shared\t\tPARAMS ((rtx));\n+extern rtx copy_most_rtx\t\tPARAMS ((rtx, rtx));\n+extern rtx shallow_copy_rtx\t\tPARAMS ((rtx));\n+extern int rtx_equal_p                  PARAMS ((rtx, rtx));\n+extern rtvec gen_rtvec_v\t\tPARAMS ((int, rtx *));\n+extern rtx gen_reg_rtx\t\t\tPARAMS ((enum machine_mode));\n+extern rtx gen_label_rtx\t\tPARAMS ((void));\n+extern rtx gen_lowpart_common\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx gen_lowpart\t\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx gen_lowpart_if_possible\tPARAMS ((enum machine_mode, rtx));\n+extern rtx gen_highpart\t\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx gen_realpart\t\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx gen_imagpart\t\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx operand_subword\t\tPARAMS ((rtx, int, int, enum machine_mode));\n+extern rtx operand_subword_force\tPARAMS ((rtx, int, enum machine_mode));\n+extern int subreg_lowpart_p\t\tPARAMS ((rtx));\n+extern rtx make_safe_from\t\tPARAMS ((rtx, rtx));\n+extern rtx convert_memory_address\tPARAMS ((enum machine_mode, rtx));\n+extern rtx memory_address\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx get_insns\t\t\tPARAMS ((void));\n+extern const char *get_insn_name\tPARAMS ((int));\n+extern rtx get_last_insn\t\tPARAMS ((void));\n+extern rtx get_last_insn_anywhere\tPARAMS ((void));\n+extern void start_sequence\t\tPARAMS ((void));\n+extern void push_to_sequence\t\tPARAMS ((rtx));\n+extern void end_sequence\t\tPARAMS ((void));\n+extern rtx gen_sequence\t\t\tPARAMS ((void));\n+extern rtx immed_double_const\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode));\n+extern rtx force_const_mem\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx force_reg\t\t\tPARAMS ((enum machine_mode, rtx));\n+extern rtx get_pool_constant\t\tPARAMS ((rtx));\n+extern enum machine_mode get_pool_mode\tPARAMS ((rtx));\n+extern rtx get_pool_constant_for_function\tPARAMS ((struct function *, rtx));\n+extern enum machine_mode get_pool_mode_for_function\tPARAMS ((struct function *, rtx));\n+extern int get_pool_offset\t\tPARAMS ((rtx));\n+extern rtx simplify_subtraction\t\tPARAMS ((rtx));\n+extern rtx assign_stack_local\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t       HOST_WIDE_INT, int));\n-extern rtx assign_stack_temp\t\tPROTO((enum machine_mode,\n+extern rtx assign_stack_temp\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t       HOST_WIDE_INT, int));\n-extern rtx assign_temp\t\t\tPROTO((union tree_node *,\n+extern rtx assign_temp\t\t\tPARAMS ((union tree_node *,\n \t\t\t\t\t       int, int, int));\n-extern rtx protect_from_queue\t\tPROTO((rtx, int));\n-extern void emit_queue\t\t\tPROTO((void));\n-extern rtx emit_move_insn\t\tPROTO((rtx, rtx));\n-extern rtx emit_insn_before\t\tPROTO((rtx, rtx));\n-extern rtx emit_jump_insn_before\tPROTO((rtx, rtx));\n-extern rtx emit_call_insn_before\tPROTO((rtx, rtx));\n-extern rtx emit_barrier_before\t\tPROTO((rtx));\n-extern rtx emit_label_before\t\tPROTO((rtx, rtx));\n-extern rtx emit_note_before\t\tPROTO((int, rtx));\n-extern rtx emit_insn_after\t\tPROTO((rtx, rtx));\n-extern rtx emit_jump_insn_after\t\tPROTO((rtx, rtx));\n-extern rtx emit_barrier_after\t\tPROTO((rtx));\n-extern rtx emit_label_after\t\tPROTO((rtx, rtx));\n-extern rtx emit_note_after\t\tPROTO((int, rtx));\n-extern rtx emit_line_note_after\t\tPROTO((char *, int, rtx));\n-extern rtx emit_insn\t\t\tPROTO((rtx));\n-extern rtx emit_insns\t\t\tPROTO((rtx));\n-extern rtx emit_insns_before\t\tPROTO((rtx, rtx));\n-extern rtx emit_insns_after\t\tPROTO((rtx, rtx));\n-extern rtx emit_jump_insn\t\tPROTO((rtx));\n-extern rtx emit_call_insn\t\tPROTO((rtx));\n-extern rtx emit_label\t\t\tPROTO((rtx));\n-extern rtx emit_barrier\t\t\tPROTO((void));\n-extern rtx emit_line_note\t\tPROTO((char *, int));\n-extern rtx emit_note\t\t\tPROTO((char *, int));\n-extern rtx emit_line_note_force\t\tPROTO((char *, int));\n-extern rtx make_insn_raw\t\tPROTO((rtx));\n-extern rtx previous_insn\t\tPROTO((rtx));\n-extern rtx next_insn\t\t\tPROTO((rtx));\n-extern rtx prev_nonnote_insn\t\tPROTO((rtx));\n-extern rtx next_nonnote_insn\t\tPROTO((rtx));\n-extern rtx prev_real_insn\t\tPROTO((rtx));\n-extern rtx next_real_insn\t\tPROTO((rtx));\n-extern rtx prev_active_insn\t\tPROTO((rtx));\n-extern rtx next_active_insn\t\tPROTO((rtx));\n-extern rtx prev_label\t\t\tPROTO((rtx));\n-extern rtx next_label\t\t\tPROTO((rtx));\n-extern rtx next_cc0_user\t\tPROTO((rtx));\n-extern rtx prev_cc0_setter\t\tPROTO((rtx));\n-extern rtx next_nondeleted_insn\t\tPROTO((rtx));\n-extern enum rtx_code reverse_condition\tPROTO((enum rtx_code));\n-extern enum rtx_code swap_condition\tPROTO((enum rtx_code));\n-extern enum rtx_code unsigned_condition\tPROTO((enum rtx_code));\n-extern enum rtx_code signed_condition\tPROTO((enum rtx_code));\n-extern rtx find_equiv_reg\t\tPROTO((rtx, rtx, enum reg_class, int, short *, int, enum machine_mode));\n-extern rtx squeeze_notes\t\tPROTO((rtx, rtx));\n-extern rtx delete_insn\t\t\tPROTO((rtx));\n-extern void delete_jump\t\t\tPROTO((rtx));\n-extern void delete_barrier\t\tPROTO((rtx));\n-extern rtx get_label_before\t\tPROTO((rtx));\n-extern rtx get_label_after\t\tPROTO((rtx));\n-extern rtx follow_jumps\t\t\tPROTO((rtx));\n-extern rtx adj_offsettable_operand\tPROTO((rtx, int));\n-extern rtx try_split\t\t\tPROTO((rtx, rtx, int));\n-extern rtx split_insns\t\t\tPROTO((rtx, rtx));\n-extern rtx simplify_unary_operation\tPROTO((enum rtx_code, enum machine_mode, rtx, enum machine_mode));\n-extern rtx simplify_binary_operation\tPROTO((enum rtx_code, enum machine_mode, rtx, rtx));\n-extern rtx simplify_ternary_operation\tPROTO((enum rtx_code, enum machine_mode, enum machine_mode, rtx, rtx, rtx));\n-extern rtx simplify_relational_operation PROTO((enum rtx_code, enum machine_mode, rtx, rtx));\n-extern rtx simplify_gen_binary\t\tPROTO((enum rtx_code, enum machine_mode,\n+extern rtx protect_from_queue\t\tPARAMS ((rtx, int));\n+extern void emit_queue\t\t\tPARAMS ((void));\n+extern rtx emit_move_insn\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_insn_before\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_jump_insn_before\tPARAMS ((rtx, rtx));\n+extern rtx emit_call_insn_before\tPARAMS ((rtx, rtx));\n+extern rtx emit_barrier_before\t\tPARAMS ((rtx));\n+extern rtx emit_label_before\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_note_before\t\tPARAMS ((int, rtx));\n+extern rtx emit_insn_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_jump_insn_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_barrier_after\t\tPARAMS ((rtx));\n+extern rtx emit_label_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_note_after\t\tPARAMS ((int, rtx));\n+extern rtx emit_line_note_after\t\tPARAMS ((char *, int, rtx));\n+extern rtx emit_insn\t\t\tPARAMS ((rtx));\n+extern rtx emit_insns\t\t\tPARAMS ((rtx));\n+extern rtx emit_insns_before\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_insns_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_jump_insn\t\tPARAMS ((rtx));\n+extern rtx emit_call_insn\t\tPARAMS ((rtx));\n+extern rtx emit_label\t\t\tPARAMS ((rtx));\n+extern rtx emit_barrier\t\t\tPARAMS ((void));\n+extern rtx emit_line_note\t\tPARAMS ((char *, int));\n+extern rtx emit_note\t\t\tPARAMS ((char *, int));\n+extern rtx emit_line_note_force\t\tPARAMS ((char *, int));\n+extern rtx make_insn_raw\t\tPARAMS ((rtx));\n+extern rtx previous_insn\t\tPARAMS ((rtx));\n+extern rtx next_insn\t\t\tPARAMS ((rtx));\n+extern rtx prev_nonnote_insn\t\tPARAMS ((rtx));\n+extern rtx next_nonnote_insn\t\tPARAMS ((rtx));\n+extern rtx prev_real_insn\t\tPARAMS ((rtx));\n+extern rtx next_real_insn\t\tPARAMS ((rtx));\n+extern rtx prev_active_insn\t\tPARAMS ((rtx));\n+extern rtx next_active_insn\t\tPARAMS ((rtx));\n+extern rtx prev_label\t\t\tPARAMS ((rtx));\n+extern rtx next_label\t\t\tPARAMS ((rtx));\n+extern rtx next_cc0_user\t\tPARAMS ((rtx));\n+extern rtx prev_cc0_setter\t\tPARAMS ((rtx));\n+extern rtx next_nondeleted_insn\t\tPARAMS ((rtx));\n+extern enum rtx_code reverse_condition\tPARAMS ((enum rtx_code));\n+extern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\n+extern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\n+extern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));\n+extern rtx find_equiv_reg\t\tPARAMS ((rtx, rtx, enum reg_class, int, short *, int, enum machine_mode));\n+extern rtx squeeze_notes\t\tPARAMS ((rtx, rtx));\n+extern rtx delete_insn\t\t\tPARAMS ((rtx));\n+extern void delete_jump\t\t\tPARAMS ((rtx));\n+extern void delete_barrier\t\tPARAMS ((rtx));\n+extern rtx get_label_before\t\tPARAMS ((rtx));\n+extern rtx get_label_after\t\tPARAMS ((rtx));\n+extern rtx follow_jumps\t\t\tPARAMS ((rtx));\n+extern rtx adj_offsettable_operand\tPARAMS ((rtx, int));\n+extern rtx try_split\t\t\tPARAMS ((rtx, rtx, int));\n+extern rtx split_insns\t\t\tPARAMS ((rtx, rtx));\n+extern rtx simplify_unary_operation\tPARAMS ((enum rtx_code, enum machine_mode, rtx, enum machine_mode));\n+extern rtx simplify_binary_operation\tPARAMS ((enum rtx_code, enum machine_mode, rtx, rtx));\n+extern rtx simplify_ternary_operation\tPARAMS ((enum rtx_code, enum machine_mode, enum machine_mode, rtx, rtx, rtx));\n+extern rtx simplify_relational_operation PARAMS ((enum rtx_code, enum machine_mode, rtx, rtx));\n+extern rtx simplify_gen_binary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t\t       rtx, rtx));\n-extern rtx simplify_rtx\t\t\tPROTO((rtx));\n-extern rtx gen_move_insn\t\tPROTO((rtx, rtx));\n-extern rtx gen_jump\t\t\tPROTO((rtx));\n-extern rtx gen_beq\t\t\tPROTO((rtx));\n-extern rtx gen_bge\t\t\tPROTO((rtx));\n-extern rtx gen_ble\t\t\tPROTO((rtx));\n-extern rtx gen_mem_addressof\t\tPROTO((rtx, union tree_node *));\n-extern rtx eliminate_constant_term\tPROTO((rtx, rtx *));\n-extern rtx expand_complex_abs\t\tPROTO((enum machine_mode, rtx, rtx, int));\n-extern enum machine_mode choose_hard_reg_mode PROTO((int, int));\n-extern void set_unique_reg_note         PROTO((rtx, enum reg_note, rtx));\n+extern rtx simplify_rtx\t\t\tPARAMS ((rtx));\n+extern rtx gen_move_insn\t\tPARAMS ((rtx, rtx));\n+extern rtx gen_jump\t\t\tPARAMS ((rtx));\n+extern rtx gen_beq\t\t\tPARAMS ((rtx));\n+extern rtx gen_bge\t\t\tPARAMS ((rtx));\n+extern rtx gen_ble\t\t\tPARAMS ((rtx));\n+extern rtx gen_mem_addressof\t\tPARAMS ((rtx, union tree_node *));\n+extern rtx eliminate_constant_term\tPARAMS ((rtx, rtx *));\n+extern rtx expand_complex_abs\t\tPARAMS ((enum machine_mode, rtx, rtx, int));\n+extern enum machine_mode choose_hard_reg_mode PARAMS ((int, int));\n+extern void set_unique_reg_note         PARAMS ((rtx, enum reg_note, rtx));\n \n /* Functions in rtlanal.c */\n \n-extern int rtx_unstable_p\t\tPROTO((rtx));\n-extern int rtx_varies_p\t\t\tPROTO((rtx));\n-extern int rtx_addr_varies_p\t\tPROTO((rtx));\n-extern HOST_WIDE_INT get_integer_term\tPROTO((rtx));\n-extern rtx get_related_value\t\tPROTO((rtx));\n-extern int reg_mentioned_p\t\tPROTO((rtx, rtx));\n-extern int reg_referenced_p\t\tPROTO((rtx, rtx));\n-extern int reg_used_between_p\t\tPROTO((rtx, rtx, rtx));\n-extern int reg_referenced_between_p\tPROTO((rtx, rtx, rtx));\n-extern int reg_set_between_p\t\tPROTO((rtx, rtx, rtx));\n-extern int regs_set_between_p\t\tPROTO((rtx, rtx, rtx));\n-extern int modified_between_p\t\tPROTO((rtx, rtx, rtx));\n-extern int no_labels_between_p\t\tPROTO((rtx, rtx));\n-extern int no_jumps_between_p\t\tPROTO((rtx, rtx));\n-extern int modified_in_p\t\tPROTO((rtx, rtx));\n-extern int reg_set_p\t\t\tPROTO((rtx, rtx));\n-extern rtx single_set\t\t\tPROTO((rtx));\n-extern int multiple_sets\t\tPROTO((rtx));\n-extern rtx find_last_value\t\tPROTO((rtx, rtx *, rtx, int));\n-extern int refers_to_regno_p\t\tPROTO((int, int, rtx, rtx *));\n-extern int reg_overlap_mentioned_p\tPROTO((rtx, rtx));\n-extern void note_stores\t\t\tPROTO((rtx, void (*)(rtx, rtx, void *), void *));\n-extern rtx reg_set_last\t\t\tPROTO((rtx, rtx));\n-extern int dead_or_set_p\t\tPROTO((rtx, rtx));\n-extern int dead_or_set_regno_p\t\tPROTO((rtx, int));\n-extern rtx find_reg_note\t\tPROTO((rtx, enum reg_note, rtx));\n-extern rtx find_regno_note\t\tPROTO((rtx, enum reg_note, int));\n-extern int find_reg_fusage\t\tPROTO((rtx, enum rtx_code, rtx));\n-extern int find_regno_fusage\t\tPROTO((rtx, enum rtx_code, int));\n-extern void remove_note\t\t\tPROTO((rtx, rtx));\n-extern int side_effects_p\t\tPROTO((rtx));\n-extern int volatile_refs_p\t\tPROTO((rtx));\n-extern int volatile_insn_p\t\tPROTO((rtx));\n-extern int may_trap_p\t\t\tPROTO((rtx));\n-extern int inequality_comparisons_p\tPROTO ((rtx));\n-extern rtx replace_rtx\t\t\tPROTO((rtx, rtx, rtx));\n-extern rtx replace_regs\t\t\tPROTO((rtx, rtx *, int, int));\n-extern int computed_jump_p\t\tPROTO((rtx));\n-typedef int (*rtx_function)             PROTO((rtx *, void *));\n-extern int for_each_rtx                 PROTO((rtx *, rtx_function, void *));\n-extern rtx regno_use_in\t\t\tPROTO((int, rtx));\n-extern int auto_inc_p\t\t\tPROTO((rtx));\n-extern void remove_node_from_expr_list\tPROTO((rtx, rtx *));\n-extern int insns_safe_to_move_p         PROTO((rtx, rtx, rtx *));\n+extern int rtx_unstable_p\t\tPARAMS ((rtx));\n+extern int rtx_varies_p\t\t\tPARAMS ((rtx));\n+extern int rtx_addr_varies_p\t\tPARAMS ((rtx));\n+extern HOST_WIDE_INT get_integer_term\tPARAMS ((rtx));\n+extern rtx get_related_value\t\tPARAMS ((rtx));\n+extern int reg_mentioned_p\t\tPARAMS ((rtx, rtx));\n+extern int reg_referenced_p\t\tPARAMS ((rtx, rtx));\n+extern int reg_used_between_p\t\tPARAMS ((rtx, rtx, rtx));\n+extern int reg_referenced_between_p\tPARAMS ((rtx, rtx, rtx));\n+extern int reg_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n+extern int regs_set_between_p\t\tPARAMS ((rtx, rtx, rtx));\n+extern int modified_between_p\t\tPARAMS ((rtx, rtx, rtx));\n+extern int no_labels_between_p\t\tPARAMS ((rtx, rtx));\n+extern int no_jumps_between_p\t\tPARAMS ((rtx, rtx));\n+extern int modified_in_p\t\tPARAMS ((rtx, rtx));\n+extern int reg_set_p\t\t\tPARAMS ((rtx, rtx));\n+extern rtx single_set\t\t\tPARAMS ((rtx));\n+extern int multiple_sets\t\tPARAMS ((rtx));\n+extern rtx find_last_value\t\tPARAMS ((rtx, rtx *, rtx, int));\n+extern int refers_to_regno_p\t\tPARAMS ((int, int, rtx, rtx *));\n+extern int reg_overlap_mentioned_p\tPARAMS ((rtx, rtx));\n+extern void note_stores\t\t\tPARAMS ((rtx, void (*)(rtx, rtx, void *), void *));\n+extern rtx reg_set_last\t\t\tPARAMS ((rtx, rtx));\n+extern int dead_or_set_p\t\tPARAMS ((rtx, rtx));\n+extern int dead_or_set_regno_p\t\tPARAMS ((rtx, int));\n+extern rtx find_reg_note\t\tPARAMS ((rtx, enum reg_note, rtx));\n+extern rtx find_regno_note\t\tPARAMS ((rtx, enum reg_note, int));\n+extern int find_reg_fusage\t\tPARAMS ((rtx, enum rtx_code, rtx));\n+extern int find_regno_fusage\t\tPARAMS ((rtx, enum rtx_code, int));\n+extern void remove_note\t\t\tPARAMS ((rtx, rtx));\n+extern int side_effects_p\t\tPARAMS ((rtx));\n+extern int volatile_refs_p\t\tPARAMS ((rtx));\n+extern int volatile_insn_p\t\tPARAMS ((rtx));\n+extern int may_trap_p\t\t\tPARAMS ((rtx));\n+extern int inequality_comparisons_p\tPARAMS ((rtx));\n+extern rtx replace_rtx\t\t\tPARAMS ((rtx, rtx, rtx));\n+extern rtx replace_regs\t\t\tPARAMS ((rtx, rtx *, int, int));\n+extern int computed_jump_p\t\tPARAMS ((rtx));\n+typedef int (*rtx_function)             PARAMS ((rtx *, void *));\n+extern int for_each_rtx                 PARAMS ((rtx *, rtx_function, void *));\n+extern rtx regno_use_in\t\t\tPARAMS ((int, rtx));\n+extern int auto_inc_p\t\t\tPARAMS ((rtx));\n+extern void remove_node_from_expr_list\tPARAMS ((rtx, rtx *));\n+extern int insns_safe_to_move_p         PARAMS ((rtx, rtx, rtx *));\n \n /* flow.c */\n \n-extern rtx find_use_as_address\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n-void init_EXPR_INSN_LIST_cache\t\tPROTO((void));\n-void free_EXPR_LIST_list \t\tPROTO((rtx *));\n-void free_INSN_LIST_list \t\tPROTO((rtx *));\n-void free_EXPR_LIST_node \t\tPROTO((rtx));\n-void free_INSN_LIST_node \t\tPROTO((rtx));\n-rtx alloc_INSN_LIST\t\t\tPROTO((rtx, rtx));\n-rtx alloc_EXPR_LIST\t\t\tPROTO((int, rtx, rtx));\n+extern rtx find_use_as_address\t\tPARAMS ((rtx, rtx, HOST_WIDE_INT));\n+void init_EXPR_INSN_LIST_cache\t\tPARAMS ((void));\n+void free_EXPR_LIST_list \t\tPARAMS ((rtx *));\n+void free_INSN_LIST_list \t\tPARAMS ((rtx *));\n+void free_EXPR_LIST_node \t\tPARAMS ((rtx));\n+void free_INSN_LIST_node \t\tPARAMS ((rtx));\n+rtx alloc_INSN_LIST\t\t\tPARAMS ((rtx, rtx));\n+rtx alloc_EXPR_LIST\t\t\tPARAMS ((int, rtx, rtx));\n \n /* regclass.c */\n \n@@ -1155,20 +1155,20 @@ rtx alloc_EXPR_LIST\t\t\tPROTO((int, rtx, rtx));\n extern int max_parallel;\n \n /* Free up register info memory.  */\n-extern void free_reg_info\t\tPROTO((void));\n+extern void free_reg_info\t\tPARAMS ((void));\n \n /* recog.c */\n-extern int asm_noperands\t\tPROTO((rtx));\n-extern char *decode_asm_operands\tPROTO((rtx, rtx *, rtx **,\n+extern int asm_noperands\t\tPARAMS ((rtx));\n+extern char *decode_asm_operands\tPARAMS ((rtx, rtx *, rtx **,\n \t\t\t\t\t       const char **,\n \t\t\t\t\t       enum machine_mode *));\n \n-extern enum reg_class reg_preferred_class PROTO((int));\n-extern enum reg_class reg_alternate_class PROTO((int));\n+extern enum reg_class reg_preferred_class PARAMS ((int));\n+extern enum reg_class reg_alternate_class PARAMS ((int));\n \n-extern rtx get_first_nonparm_insn\tPROTO((void));\n+extern rtx get_first_nonparm_insn\tPARAMS ((void));\n \n-extern void split_all_insns\t\tPROTO((int));\n+extern void split_all_insns\t\tPARAMS ((int));\n \n #define MAX_SAVED_CONST_INT 64\n extern rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n@@ -1268,11 +1268,11 @@ extern rtx return_address_pointer_rtx;\n    add to this list, modify special_rtx in gengenrtl.c as well.  You\n    should also modify gen_rtx to use the special function.  */\n \n-extern rtx gen_rtx_CONST_DOUBLE PROTO((enum machine_mode, rtx,\n+extern rtx gen_rtx_CONST_DOUBLE PARAMS ((enum machine_mode, rtx,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\n-extern rtx gen_rtx_CONST_INT PROTO((enum machine_mode, HOST_WIDE_INT));\n-extern rtx gen_rtx_REG PROTO((enum machine_mode, int));\n-extern rtx gen_rtx_MEM PROTO((enum machine_mode, rtx));\n+extern rtx gen_rtx_CONST_INT PARAMS ((enum machine_mode, HOST_WIDE_INT));\n+extern rtx gen_rtx_REG PARAMS ((enum machine_mode, int));\n+extern rtx gen_rtx_MEM PARAMS ((enum machine_mode, rtx));\n \n /* We need the cast here to ensure that we get the same result both with\n    and without prototypes.  */\n@@ -1330,12 +1330,12 @@ extern rtx gen_rtx_MEM PROTO((enum machine_mode, rtx));\n \n #define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n \n-extern rtx find_next_ref\t\tPROTO((rtx, rtx));\n-extern rtx *find_single_use\t\tPROTO((rtx, rtx, rtx *));\n+extern rtx find_next_ref\t\tPARAMS ((rtx, rtx));\n+extern rtx *find_single_use\t\tPARAMS ((rtx, rtx, rtx *));\n \n-extern rtx output_constant_def\t\tPROTO((union tree_node *));\n-extern rtx immed_real_const\t\tPROTO((union tree_node *));\n-extern union tree_node *make_tree\tPROTO((union tree_node *, rtx));\n+extern rtx output_constant_def\t\tPARAMS ((union tree_node *));\n+extern rtx immed_real_const\t\tPARAMS ((union tree_node *));\n+extern union tree_node *make_tree\tPARAMS ((union tree_node *, rtx));\n \n /* Define a default value for STORE_FLAG_VALUE.  */\n \n@@ -1373,48 +1373,48 @@ extern int no_new_pseudos;\n    REAL_ARITHMETIC.  The function returns an int because the caller may not\n    know what `enum tree_code' means.  */\n \n-extern int rtx_to_tree_code\tPROTO((enum rtx_code));\n+extern int rtx_to_tree_code\tPARAMS ((enum rtx_code));\n \n /* In tree.c */\n-extern void obfree\t\t\tPROTO ((char *));\n+extern void obfree\t\t\tPARAMS ((char *));\n struct obstack;\n-extern void gcc_obstack_init\t\tPROTO ((struct obstack *));\n-extern void pop_obstacks\t\tPROTO ((void));\n-extern void push_obstacks\t\tPROTO ((struct obstack *,\n+extern void gcc_obstack_init\t\tPARAMS ((struct obstack *));\n+extern void pop_obstacks\t\tPARAMS ((void));\n+extern void push_obstacks\t\tPARAMS ((struct obstack *,\n \t\t\t\t\t\tstruct obstack *));\n /* In cse.c */\n struct cse_basic_block_data;\n-extern int rtx_cost\t\t\tPROTO ((rtx, enum rtx_code));\n-extern void delete_trivially_dead_insns\tPROTO ((rtx, int));\n+extern int rtx_cost\t\t\tPARAMS ((rtx, enum rtx_code));\n+extern void delete_trivially_dead_insns\tPARAMS ((rtx, int));\n #ifdef BUFSIZ\n-extern int cse_main\t\t\tPROTO ((rtx, int, int, FILE *));\n+extern int cse_main\t\t\tPARAMS ((rtx, int, int, FILE *));\n #endif\n-extern void cse_end_of_basic_block\tPROTO ((rtx,\n+extern void cse_end_of_basic_block\tPARAMS ((rtx,\n \t\t\t\t\t\tstruct cse_basic_block_data *,\n \t\t\t\t\t\tint, int, int));\n \n /* In jump.c */\n-extern int comparison_dominates_p\tPROTO ((enum rtx_code, enum rtx_code));\n-extern int condjump_p\t\t\tPROTO ((rtx));\n-extern rtx condjump_label\t\tPROTO ((rtx));\n-extern int simplejump_p\t\t\tPROTO ((rtx));\n-extern int returnjump_p\t\t\tPROTO ((rtx));\n-extern int onlyjump_p\t\t\tPROTO ((rtx));\n-extern int sets_cc0_p\t\t\tPROTO ((rtx));\n-extern int invert_jump\t\t\tPROTO ((rtx, rtx));\n-extern int rtx_renumbered_equal_p\tPROTO ((rtx, rtx));\n-extern int true_regnum\t\t\tPROTO ((rtx));\n-extern int redirect_jump\t\tPROTO ((rtx, rtx));\n-extern void jump_optimize\t\tPROTO ((rtx, int, int, int));\n-extern void rebuild_jump_labels\t\tPROTO ((rtx));\n-extern void thread_jumps\t\tPROTO ((rtx, int, int));\n-extern int redirect_exp\t\t\tPROTO ((rtx *, rtx, rtx, rtx));\n-extern int rtx_equal_for_thread_p\tPROTO ((rtx, rtx, rtx));\n-extern int invert_exp\t\t\tPROTO ((rtx, rtx));\n-extern int can_reverse_comparison_p\tPROTO ((rtx, rtx));\n-extern void delete_for_peephole\t\tPROTO ((rtx, rtx));\n-extern int condjump_in_parallel_p\tPROTO ((rtx));\n-extern void never_reached_warning\tPROTO ((rtx));\n+extern int comparison_dominates_p\tPARAMS ((enum rtx_code, enum rtx_code));\n+extern int condjump_p\t\t\tPARAMS ((rtx));\n+extern rtx condjump_label\t\tPARAMS ((rtx));\n+extern int simplejump_p\t\t\tPARAMS ((rtx));\n+extern int returnjump_p\t\t\tPARAMS ((rtx));\n+extern int onlyjump_p\t\t\tPARAMS ((rtx));\n+extern int sets_cc0_p\t\t\tPARAMS ((rtx));\n+extern int invert_jump\t\t\tPARAMS ((rtx, rtx));\n+extern int rtx_renumbered_equal_p\tPARAMS ((rtx, rtx));\n+extern int true_regnum\t\t\tPARAMS ((rtx));\n+extern int redirect_jump\t\tPARAMS ((rtx, rtx));\n+extern void jump_optimize\t\tPARAMS ((rtx, int, int, int));\n+extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n+extern void thread_jumps\t\tPARAMS ((rtx, int, int));\n+extern int redirect_exp\t\t\tPARAMS ((rtx *, rtx, rtx, rtx));\n+extern int rtx_equal_for_thread_p\tPARAMS ((rtx, rtx, rtx));\n+extern int invert_exp\t\t\tPARAMS ((rtx, rtx));\n+extern int can_reverse_comparison_p\tPARAMS ((rtx, rtx));\n+extern void delete_for_peephole\t\tPARAMS ((rtx, rtx));\n+extern int condjump_in_parallel_p\tPARAMS ((rtx));\n+extern void never_reached_warning\tPARAMS ((rtx));\n \n /* Flags for jump_optimize() */\n #define JUMP_CROSS_JUMP\t\t\t1\n@@ -1423,250 +1423,250 @@ extern void never_reached_warning\tPROTO ((rtx));\n #define JUMP_AFTER_REGSCAN\t\t1\n \n /* In emit-rtl.c. */\n-extern int max_reg_num\t\t\t\tPROTO ((void));\n-extern int max_label_num\t\t\tPROTO ((void));\n-extern int get_first_label_num\t\t\tPROTO ((void));\n-extern void delete_insns_since\t\t\tPROTO ((rtx));\n-extern void mark_reg_pointer\t\t\tPROTO ((rtx, int));\n-extern void mark_user_reg\t\t\tPROTO ((rtx));\n-extern void reset_used_flags\t\t\tPROTO ((rtx));\n-extern void reorder_insns\t\t\tPROTO ((rtx, rtx, rtx));\n-extern int get_max_uid\t\t\t\tPROTO ((void));\n-extern int in_sequence_p\t\t\tPROTO ((void));\n-extern void force_next_line_note\t\tPROTO ((void));\n-extern void clear_emit_caches\t\t\tPROTO ((void));\n-extern void init_emit\t\t\t\tPROTO ((void));\n-extern void init_emit_once\t\t\tPROTO ((int));\n-extern void push_topmost_sequence\t\tPROTO ((void));\n-extern void pop_topmost_sequence\t\tPROTO ((void));\n-extern int subreg_realpart_p\t\t\tPROTO ((rtx));\n-extern void reverse_comparison\t\t\tPROTO ((rtx));\n-extern void set_new_first_and_last_insn\t\tPROTO ((rtx, rtx));\n-extern void set_new_first_and_last_label_num\tPROTO ((int, int));\n-extern void set_new_last_label_num\t\tPROTO ((int));\n-extern void unshare_all_rtl\t\t\tPROTO ((rtx));\n-extern void set_last_insn\t\t\tPROTO ((rtx));\n-extern void link_cc0_insns\t\t\tPROTO ((rtx));\n-extern void add_insn\t\t\t\tPROTO ((rtx));\n-extern void add_insn_before\t\t\tPROTO ((rtx, rtx));\n-extern void add_insn_after\t\t\tPROTO ((rtx, rtx));\n-extern void remove_insn\t\t\t\tPROTO ((rtx));\n-extern void reorder_insns_with_line_notes\tPROTO ((rtx, rtx, rtx));\n-extern void emit_insn_after_with_line_notes\tPROTO ((rtx, rtx, rtx));\n-extern enum rtx_code classify_insn\t\tPROTO ((rtx));\n-extern rtx emit\t\t\t\t\tPROTO ((rtx));\n+extern int max_reg_num\t\t\t\tPARAMS ((void));\n+extern int max_label_num\t\t\tPARAMS ((void));\n+extern int get_first_label_num\t\t\tPARAMS ((void));\n+extern void delete_insns_since\t\t\tPARAMS ((rtx));\n+extern void mark_reg_pointer\t\t\tPARAMS ((rtx, int));\n+extern void mark_user_reg\t\t\tPARAMS ((rtx));\n+extern void reset_used_flags\t\t\tPARAMS ((rtx));\n+extern void reorder_insns\t\t\tPARAMS ((rtx, rtx, rtx));\n+extern int get_max_uid\t\t\t\tPARAMS ((void));\n+extern int in_sequence_p\t\t\tPARAMS ((void));\n+extern void force_next_line_note\t\tPARAMS ((void));\n+extern void clear_emit_caches\t\t\tPARAMS ((void));\n+extern void init_emit\t\t\t\tPARAMS ((void));\n+extern void init_emit_once\t\t\tPARAMS ((int));\n+extern void push_topmost_sequence\t\tPARAMS ((void));\n+extern void pop_topmost_sequence\t\tPARAMS ((void));\n+extern int subreg_realpart_p\t\t\tPARAMS ((rtx));\n+extern void reverse_comparison\t\t\tPARAMS ((rtx));\n+extern void set_new_first_and_last_insn\t\tPARAMS ((rtx, rtx));\n+extern void set_new_first_and_last_label_num\tPARAMS ((int, int));\n+extern void set_new_last_label_num\t\tPARAMS ((int));\n+extern void unshare_all_rtl\t\t\tPARAMS ((rtx));\n+extern void set_last_insn\t\t\tPARAMS ((rtx));\n+extern void link_cc0_insns\t\t\tPARAMS ((rtx));\n+extern void add_insn\t\t\t\tPARAMS ((rtx));\n+extern void add_insn_before\t\t\tPARAMS ((rtx, rtx));\n+extern void add_insn_after\t\t\tPARAMS ((rtx, rtx));\n+extern void remove_insn\t\t\t\tPARAMS ((rtx));\n+extern void reorder_insns_with_line_notes\tPARAMS ((rtx, rtx, rtx));\n+extern void emit_insn_after_with_line_notes\tPARAMS ((rtx, rtx, rtx));\n+extern enum rtx_code classify_insn\t\tPARAMS ((rtx));\n+extern rtx emit\t\t\t\t\tPARAMS ((rtx));\n /* Query and clear/ restore no_line_numbers.  This is used by the\n    switch / case handling in stmt.c to give proper line numbers in\n    warnings about unreachable code.  */\n-int force_line_numbers PROTO((void));\n-void restore_line_number_status PROTO((int old_value));\n-extern void renumber_insns                      PROTO ((FILE *));\n-extern void remove_unncessary_notes             PROTO ((void));\n+int force_line_numbers PARAMS ((void));\n+void restore_line_number_status PARAMS ((int old_value));\n+extern void renumber_insns                      PARAMS ((FILE *));\n+extern void remove_unncessary_notes             PARAMS ((void));\n \n /* In insn-emit.c */\n-extern void add_clobbers\t\tPROTO ((rtx, int));\n+extern void add_clobbers\t\tPARAMS ((rtx, int));\n \n /* In combine.c */\n-extern void combine_instructions\tPROTO ((rtx, int));\n-extern int extended_count\t\tPROTO ((rtx, enum machine_mode, int));\n-extern rtx remove_death\t\t\tPROTO ((int, rtx));\n+extern void combine_instructions\tPARAMS ((rtx, int));\n+extern int extended_count\t\tPARAMS ((rtx, enum machine_mode, int));\n+extern rtx remove_death\t\t\tPARAMS ((int, rtx));\n #ifdef BUFSIZ\n-extern void dump_combine_stats\t\tPROTO ((FILE *));\n-extern void dump_combine_total_stats\tPROTO ((FILE *));\n+extern void dump_combine_stats\t\tPARAMS ((FILE *));\n+extern void dump_combine_total_stats\tPARAMS ((FILE *));\n #endif\n \n /* In sched.c. */\n #ifdef BUFSIZ\n-extern void schedule_insns\t\tPROTO ((FILE *));\n+extern void schedule_insns\t\tPARAMS ((FILE *));\n #endif\n-extern void fix_sched_param\t\tPROTO ((const char *, const char *));\n+extern void fix_sched_param\t\tPARAMS ((const char *, const char *));\n \n /* In print-rtl.c */\n-extern void debug_rtx\t\t\tPROTO ((rtx));\n-extern void debug_rtx_list\t\tPROTO ((rtx, int));\n-extern rtx debug_rtx_find\t\tPROTO ((rtx, int));\n+extern void debug_rtx\t\t\tPARAMS ((rtx));\n+extern void debug_rtx_list\t\tPARAMS ((rtx, int));\n+extern rtx debug_rtx_find\t\tPARAMS ((rtx, int));\n #ifdef BUFSIZ\n-extern void print_rtl\t\t\tPROTO ((FILE *, rtx));\n-extern int print_rtl_single\t\tPROTO ((FILE *, rtx));\n-extern void print_inline_rtx\t\tPROTO ((FILE *, rtx, int));\n+extern void print_rtl\t\t\tPARAMS ((FILE *, rtx));\n+extern int print_rtl_single\t\tPARAMS ((FILE *, rtx));\n+extern void print_inline_rtx\t\tPARAMS ((FILE *, rtx, int));\n #endif\n \n /* In loop.c */\n-extern void init_loop\t\t\tPROTO ((void));\n-extern rtx libcall_other_reg\t\tPROTO ((rtx, rtx));\n+extern void init_loop\t\t\tPARAMS ((void));\n+extern rtx libcall_other_reg\t\tPARAMS ((rtx, rtx));\n #ifdef BUFSIZ\n-extern void loop_optimize\t\tPROTO ((rtx, FILE *, int, int));\n+extern void loop_optimize\t\tPARAMS ((rtx, FILE *, int, int));\n #endif\n-extern void record_excess_regs\t\tPROTO ((rtx, rtx, rtx *));\n+extern void record_excess_regs\t\tPARAMS ((rtx, rtx, rtx *));\n \n /* In function.c */\n-extern void reposition_prologue_and_epilogue_notes\tPROTO ((rtx));\n-extern void thread_prologue_and_epilogue_insns\t\tPROTO ((rtx));\n-extern int prologue_epilogue_contains\t\t\tPROTO ((rtx));\n-extern void use_variable\t\t\t\tPROTO ((rtx));\n-extern HOST_WIDE_INT get_frame_size\t\t\tPROTO ((void));\n-extern void preserve_rtl_expr_result\t\t\tPROTO ((rtx));\n-extern void mark_temp_addr_taken\t\t\tPROTO ((rtx));\n-extern void update_temp_slot_address\t\t\tPROTO ((rtx, rtx));\n-extern void use_variable_after\t\t\t\tPROTO ((rtx, rtx));\n-extern void purge_addressof\t\t\t\tPROTO ((rtx));\n+extern void reposition_prologue_and_epilogue_notes\tPARAMS ((rtx));\n+extern void thread_prologue_and_epilogue_insns\t\tPARAMS ((rtx));\n+extern int prologue_epilogue_contains\t\t\tPARAMS ((rtx));\n+extern void use_variable\t\t\t\tPARAMS ((rtx));\n+extern HOST_WIDE_INT get_frame_size\t\t\tPARAMS ((void));\n+extern void preserve_rtl_expr_result\t\t\tPARAMS ((rtx));\n+extern void mark_temp_addr_taken\t\t\tPARAMS ((rtx));\n+extern void update_temp_slot_address\t\t\tPARAMS ((rtx, rtx));\n+extern void use_variable_after\t\t\t\tPARAMS ((rtx, rtx));\n+extern void purge_addressof\t\t\t\tPARAMS ((rtx));\n \n /* In reload.c */\n-extern int operands_match_p\t\tPROTO ((rtx, rtx));\n-extern int safe_from_earlyclobber\tPROTO ((rtx, rtx));\n+extern int operands_match_p\t\tPARAMS ((rtx, rtx));\n+extern int safe_from_earlyclobber\tPARAMS ((rtx, rtx));\n \n /* In stmt.c */\n-extern void set_file_and_line_for_stmt\tPROTO ((char *, int));\n-extern void expand_null_return\t\tPROTO((void));\n-extern void emit_jump\t\t\tPROTO ((rtx));\n-extern int preserve_subexpressions_p\tPROTO ((void));\n+extern void set_file_and_line_for_stmt\tPARAMS ((char *, int));\n+extern void expand_null_return\t\tPARAMS ((void));\n+extern void emit_jump\t\t\tPARAMS ((rtx));\n+extern int preserve_subexpressions_p\tPARAMS ((void));\n \n /* In expr.c */\n-extern void init_expr_once\t\tPROTO ((void));\n-extern void move_by_pieces\t\tPROTO ((rtx, rtx, int, int));\n+extern void init_expr_once\t\tPARAMS ((void));\n+extern void move_by_pieces\t\tPARAMS ((rtx, rtx, int, int));\n \n \n /* In stupid.c */\n #ifdef BUFSIZ\n-extern void stupid_life_analysis\tPROTO ((rtx, int, FILE *));\n+extern void stupid_life_analysis\tPARAMS ((rtx, int, FILE *));\n #endif\n \n /* In flow.c */\n-extern void allocate_bb_life_data\tPROTO ((void));\n-extern void allocate_reg_life_data\tPROTO ((void));\n-extern void recompute_reg_usage\t\tPROTO ((rtx, int));\n+extern void allocate_bb_life_data\tPARAMS ((void));\n+extern void allocate_reg_life_data\tPARAMS ((void));\n+extern void recompute_reg_usage\t\tPARAMS ((rtx, int));\n #ifdef BUFSIZ\n-extern void print_rtl_with_bb\t\tPROTO ((FILE *, rtx));\n-extern void dump_flow_info\t\tPROTO ((FILE *));\n+extern void print_rtl_with_bb\t\tPARAMS ((FILE *, rtx));\n+extern void dump_flow_info\t\tPARAMS ((FILE *));\n #endif\n \n /* In expmed.c */\n-extern void init_expmed\t\t\tPROTO ((void));\n-extern void expand_inc\t\t\tPROTO ((rtx, rtx));\n-extern void expand_dec\t\t\tPROTO ((rtx, rtx));\n-extern rtx expand_mult_highpart\t\tPROTO ((enum machine_mode, rtx,\n+extern void init_expmed\t\t\tPARAMS ((void));\n+extern void expand_inc\t\t\tPARAMS ((rtx, rtx));\n+extern void expand_dec\t\t\tPARAMS ((rtx, rtx));\n+extern rtx expand_mult_highpart\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\tunsigned HOST_WIDE_INT, rtx,\n \t\t\t\t\t\tint, int));\n \n /* In gcse.c */\n #ifdef BUFSIZ\n-extern int gcse_main\t\t\tPROTO ((rtx, FILE *));\n+extern int gcse_main\t\t\tPARAMS ((rtx, FILE *));\n #endif\n \n /* In global.c */\n-extern void mark_elimination\t\tPROTO ((int, int));\n+extern void mark_elimination\t\tPARAMS ((int, int));\n #ifdef BUFSIZ\n-extern int global_alloc\t\t\tPROTO ((FILE *));\n-extern void dump_global_regs\t\tPROTO ((FILE *));\n+extern int global_alloc\t\t\tPARAMS ((FILE *));\n+extern void dump_global_regs\t\tPARAMS ((FILE *));\n #endif\n #ifdef HARD_CONST\n-extern void retry_global_alloc\t\tPROTO ((int, HARD_REG_SET));\n+extern void retry_global_alloc\t\tPARAMS ((int, HARD_REG_SET));\n #endif\n \n /* In regclass.c */\n-extern int reg_classes_intersect_p\tPROTO ((enum reg_class, enum reg_class));\n-extern int reg_class_subset_p\t\tPROTO ((enum reg_class, enum reg_class));\n-extern void globalize_reg\t\tPROTO ((int));\n-extern void init_regs\t\t\tPROTO ((void));\n-extern void init_reg_sets\t\tPROTO ((void));\n-extern void regset_release_memory\tPROTO ((void));\n-extern void regclass_init\t\tPROTO ((void));\n-extern void regclass\t\t\tPROTO ((rtx, int, FILE *));\n-extern void reg_scan\t\t\tPROTO ((rtx, int, int));\n-extern void reg_scan_update\t\tPROTO ((rtx, rtx, int));\n-extern void fix_register\t\tPROTO ((const char *, int, int));\n-\n-extern void delete_null_pointer_checks\tPROTO ((rtx));\n+extern int reg_classes_intersect_p\tPARAMS ((enum reg_class, enum reg_class));\n+extern int reg_class_subset_p\t\tPARAMS ((enum reg_class, enum reg_class));\n+extern void globalize_reg\t\tPARAMS ((int));\n+extern void init_regs\t\t\tPARAMS ((void));\n+extern void init_reg_sets\t\tPARAMS ((void));\n+extern void regset_release_memory\tPARAMS ((void));\n+extern void regclass_init\t\tPARAMS ((void));\n+extern void regclass\t\t\tPARAMS ((rtx, int, FILE *));\n+extern void reg_scan\t\t\tPARAMS ((rtx, int, int));\n+extern void reg_scan_update\t\tPARAMS ((rtx, rtx, int));\n+extern void fix_register\t\tPARAMS ((const char *, int, int));\n+\n+extern void delete_null_pointer_checks\tPARAMS ((rtx));\n \n /* In regmove.c */\n #ifdef BUFSIZ\n-extern void regmove_optimize\t\tPROTO ((rtx, int, FILE *));\n+extern void regmove_optimize\t\tPARAMS ((rtx, int, FILE *));\n #endif\n \n /* In reorg.c */\n #ifdef BUFSIZ\n-extern void dbr_schedule\t\tPROTO ((rtx, FILE *));\n+extern void dbr_schedule\t\tPARAMS ((rtx, FILE *));\n #endif\n \n /* In optabs.c */\n-extern void init_optabs\t\t\tPROTO ((void));\n+extern void init_optabs\t\t\tPARAMS ((void));\n \n /* In local-alloc.c */\n #ifdef BUFSIZ\n-extern void dump_local_alloc\t\tPROTO ((FILE *));\n+extern void dump_local_alloc\t\tPARAMS ((FILE *));\n #endif\n-extern int local_alloc\t\t\tPROTO ((void));\n-extern int function_invariant_p\t\tPROTO ((rtx));\n+extern int local_alloc\t\t\tPARAMS ((void));\n+extern int function_invariant_p\t\tPARAMS ((rtx));\n \n /* In reload1.c */\n-extern void reload_cse_regs\t\tPROTO ((rtx));\n-extern void init_reload\t\t\tPROTO ((void));\n-extern void mark_home_live\t\tPROTO ((int));\n+extern void reload_cse_regs\t\tPARAMS ((rtx));\n+extern void init_reload\t\t\tPARAMS ((void));\n+extern void mark_home_live\t\tPARAMS ((int));\n #ifdef BUFSIZ\n-extern int reload\t\t\tPROTO ((rtx, int, FILE *));\n+extern int reload\t\t\tPARAMS ((rtx, int, FILE *));\n #endif\n \n /* In caller-save.c */\n-extern void init_caller_save\t\tPROTO ((void));\n+extern void init_caller_save\t\tPARAMS ((void));\n \n /* In profile.c */\n-extern void init_branch_prob\t\tPROTO ((const char *));\n+extern void init_branch_prob\t\tPARAMS ((const char *));\n #ifdef BUFSIZ\n-extern void branch_prob\t\t\tPROTO ((rtx, FILE *));\n-extern void end_branch_prob\t\tPROTO ((FILE *));\n+extern void branch_prob\t\t\tPARAMS ((rtx, FILE *));\n+extern void end_branch_prob\t\tPARAMS ((FILE *));\n #endif\n-extern void output_func_start_profiler\tPROTO ((void));\n+extern void output_func_start_profiler\tPARAMS ((void));\n \n /* In reg-stack.c */\n #ifdef BUFSIZ\n-extern void reg_to_stack\t\tPROTO ((rtx, FILE *));\n+extern void reg_to_stack\t\tPARAMS ((rtx, FILE *));\n #endif\n \n /* In fold-const.c */\n-extern int add_double\t\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern int add_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int neg_double\t\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern int neg_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int mul_double\t\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern int mul_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern void lshift_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void lshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n \t\t\t\t\tHOST_WIDE_INT *, int));\n-extern void rshift_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void rshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT, int,\n \t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *, int));\n-extern void lrotate_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void lrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n \t\t\t\t\tHOST_WIDE_INT *));\n-extern void rrotate_double\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,\n+extern void rrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n \t\t\t\t\tHOST_WIDE_INT *));\n \n /* In calls.c */\n-extern void emit_library_call\t\tPVPROTO ((rtx, int, enum machine_mode,\n+extern void emit_library_call\t\tPARAMS ((rtx, int, enum machine_mode,\n \t\t\t\t\t\t  int, ...));\n-extern rtx emit_library_call_value\tPVPROTO((rtx, rtx, int,\n+extern rtx emit_library_call_value\tPARAMS ((rtx, rtx, int,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t int, ...));\n \n /* In unroll.c */\n-extern int set_dominates_use\t\tPROTO ((int, int, int, rtx, rtx));\n+extern int set_dominates_use\t\tPARAMS ((int, int, int, rtx, rtx));\n \n /* In varasm.c */\n-extern void bss_section\t\t\tPROTO ((void));\n-extern int in_data_section\t\tPROTO ((void));\n-extern int supports_one_only\t\tPROTO ((void));\n-extern void init_varasm_once\t\tPROTO ((void));\n+extern void bss_section\t\t\tPARAMS ((void));\n+extern int in_data_section\t\tPARAMS ((void));\n+extern int supports_one_only\t\tPARAMS ((void));\n+extern void init_varasm_once\t\tPARAMS ((void));\n \n /* In rtl.c */\n-extern void init_rtl\t\t\tPROTO ((void));\n-extern void rtx_free\t\t\tPROTO ((rtx));\n+extern void init_rtl\t\t\tPARAMS ((void));\n+extern void rtx_free\t\t\tPARAMS ((rtx));\n \n #ifdef BUFSIZ\n-extern int read_skip_spaces\t\tPROTO ((FILE *));\n-extern rtx read_rtx\t\t\tPROTO ((FILE *));\n+extern int read_skip_spaces\t\tPARAMS ((FILE *));\n+extern rtx read_rtx\t\t\tPARAMS ((FILE *));\n #endif\n \n extern const char *read_rtx_filename;\n@@ -1678,7 +1678,7 @@ extern int read_rtx_lineno;\n    special abort includes one or both.  toplev.h gets too few files,\n    system.h gets too many.  */\n \n-extern void fancy_abort PROTO((const char *, int, const char *))\n+extern void fancy_abort PARAMS ((const char *, int, const char *))\n     ATTRIBUTE_NORETURN;\n #if (GCC_VERSION >= 2007)\n #define abort() fancy_abort (__FILE__, __LINE__, __PRETTY_FUNCTION__)\n@@ -1687,22 +1687,22 @@ extern void fancy_abort PROTO((const char *, int, const char *))\n #endif\n \n /* In alias.c */\n-extern int true_dependence\t\tPROTO ((rtx, enum machine_mode, rtx,\n+extern int true_dependence\t\tPARAMS ((rtx, enum machine_mode, rtx,\n \t\t\t\t\t\tint (*)(rtx)));\n-extern int read_dependence\t\tPROTO ((rtx, rtx));\n-extern int anti_dependence\t\tPROTO ((rtx, rtx));\n-extern int output_dependence\t\tPROTO ((rtx, rtx));\n-extern void mark_constant_function\tPROTO ((void));\n-extern void init_alias_once\t\tPROTO ((void));\n-extern void init_alias_analysis\t\tPROTO ((void));\n-extern void end_alias_analysis\t\tPROTO ((void));\n-\n-extern void record_base_value\t\tPROTO ((int, rtx, int));\n-extern void record_alias_subset         PROTO ((int, int));\n-extern rtx addr_side_effect_eval\tPROTO ((rtx, int, int));\n+extern int read_dependence\t\tPARAMS ((rtx, rtx));\n+extern int anti_dependence\t\tPARAMS ((rtx, rtx));\n+extern int output_dependence\t\tPARAMS ((rtx, rtx));\n+extern void mark_constant_function\tPARAMS ((void));\n+extern void init_alias_once\t\tPARAMS ((void));\n+extern void init_alias_analysis\t\tPARAMS ((void));\n+extern void end_alias_analysis\t\tPARAMS ((void));\n+\n+extern void record_base_value\t\tPARAMS ((int, rtx, int));\n+extern void record_alias_subset         PARAMS ((int, int));\n+extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n \n #ifdef STACK_REGS\n-extern int stack_regs_mentioned\t\tPROTO((rtx insn));\n+extern int stack_regs_mentioned\t\tPARAMS ((rtx insn));\n #endif\n \n /* In toplev.c */"}, {"sha": "9485865c510a6ca05ec92cd2505e01d767d82344", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -23,13 +23,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n \n-static int rtx_addr_can_trap_p\tPROTO((rtx));\n-static void reg_set_p_1\t\tPROTO((rtx, rtx, void *));\n-static void reg_set_last_1\tPROTO((rtx, rtx, void *));\n+static int rtx_addr_can_trap_p\tPARAMS ((rtx));\n+static void reg_set_p_1\t\tPARAMS ((rtx, rtx, void *));\n+static void reg_set_last_1\tPARAMS ((rtx, rtx, void *));\n \n \n /* Forward declarations */\n-static int jmp_uses_reg_or_mem\t\tPROTO((rtx));\n+static int jmp_uses_reg_or_mem\t\tPARAMS ((rtx));\n \n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n@@ -1081,7 +1081,7 @@ reg_set_last (x, insn)\n void\n note_stores (x, fun, data)\n      register rtx x;\n-     void (*fun) PROTO ((rtx, rtx, void *));\n+     void (*fun) PARAMS ((rtx, rtx, void *));\n      void *data;\n {\n   if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER))"}, {"sha": "a77759917dd53165408e8cac0d073642f519459a", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -92,45 +92,45 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define sbitmap_free(map)\t\tfree(map)\n #define sbitmap_vector_free(vec)\tfree(vec)\n \n-extern void dump_sbitmap PROTO ((FILE *, sbitmap));\n-extern void dump_sbitmap_vector PROTO ((FILE *, const char *, const char *,\n+extern void dump_sbitmap PARAMS ((FILE *, sbitmap));\n+extern void dump_sbitmap_vector PARAMS ((FILE *, const char *, const char *,\n \t\t\t\t\tsbitmap *, int));\n \n-extern sbitmap sbitmap_alloc PROTO ((int));\n-extern sbitmap *sbitmap_vector_alloc PROTO ((int, int));\n+extern sbitmap sbitmap_alloc PARAMS ((int));\n+extern sbitmap *sbitmap_vector_alloc PARAMS ((int, int));\n \n-extern void sbitmap_copy PROTO ((sbitmap, sbitmap));\n-extern void sbitmap_zero PROTO ((sbitmap));\n-extern void sbitmap_ones PROTO ((sbitmap));\n-extern void sbitmap_vector_zero PROTO ((sbitmap *, int));\n-extern void sbitmap_vector_ones PROTO ((sbitmap *, int));\n+extern void sbitmap_copy PARAMS ((sbitmap, sbitmap));\n+extern void sbitmap_zero PARAMS ((sbitmap));\n+extern void sbitmap_ones PARAMS ((sbitmap));\n+extern void sbitmap_vector_zero PARAMS ((sbitmap *, int));\n+extern void sbitmap_vector_ones PARAMS ((sbitmap *, int));\n \n-extern int sbitmap_union_of_diff PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_difference PROTO ((sbitmap, sbitmap, sbitmap));\n-extern void sbitmap_not PROTO ((sbitmap, sbitmap));\n-extern int sbitmap_a_or_b_and_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n-extern int sbitmap_a_and_b_or_c PROTO ((sbitmap, sbitmap, sbitmap, sbitmap));\n-extern int sbitmap_a_and_b PROTO ((sbitmap, sbitmap, sbitmap));\n-extern int sbitmap_a_or_b PROTO ((sbitmap, sbitmap, sbitmap));\n-extern int sbitmap_a_subset_b_p PROTO ((sbitmap, sbitmap));\n+extern int sbitmap_union_of_diff PARAMS ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern void sbitmap_difference PARAMS ((sbitmap, sbitmap, sbitmap));\n+extern void sbitmap_not PARAMS ((sbitmap, sbitmap));\n+extern int sbitmap_a_or_b_and_c PARAMS ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_and_b_or_c PARAMS ((sbitmap, sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_and_b PARAMS ((sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_or_b PARAMS ((sbitmap, sbitmap, sbitmap));\n+extern int sbitmap_a_subset_b_p PARAMS ((sbitmap, sbitmap));\n \n struct int_list;\n-extern void sbitmap_intersect_of_predsucc PROTO ((sbitmap, sbitmap *,\n+extern void sbitmap_intersect_of_predsucc PARAMS ((sbitmap, sbitmap *,\n \t\t\t\t\t\t  int, struct int_list **));\n #define sbitmap_intersect_of_predecessors  sbitmap_intersect_of_predsucc\n #define sbitmap_intersect_of_successors    sbitmap_intersect_of_predsucc\n \n-extern void sbitmap_union_of_predsucc PROTO ((sbitmap, sbitmap *, int,\n+extern void sbitmap_union_of_predsucc PARAMS ((sbitmap, sbitmap *, int,\n \t\t\t\t\t      struct int_list **));\n #define sbitmap_union_of_predecessors  sbitmap_union_of_predsucc\n #define sbitmap_union_of_successors    sbitmap_union_of_predsucc\n \n /* Intersection and Union of preds/succs using the new flow graph \n    structure instead of the pred/succ arrays.  */\n \n-extern void sbitmap_intersection_of_succs    PROTO ((sbitmap, sbitmap *, int));\n-extern void sbitmap_intersection_of_preds    PROTO ((sbitmap, sbitmap *, int));\n-extern void sbitmap_union_of_succs\t     PROTO ((sbitmap, sbitmap *, int));\n-extern void sbitmap_union_of_preds\t     PROTO ((sbitmap, sbitmap *, int));\n+extern void sbitmap_intersection_of_succs    PARAMS ((sbitmap, sbitmap *, int));\n+extern void sbitmap_intersection_of_preds    PARAMS ((sbitmap, sbitmap *, int));\n+extern void sbitmap_union_of_succs\t     PARAMS ((sbitmap, sbitmap *, int));\n+extern void sbitmap_union_of_preds\t     PARAMS ((sbitmap, sbitmap *, int));\n \n #endif /* _SBITMAP_H */"}, {"sha": "bdf74a265b97b03841fb51b39474b498bcedb950", "filename": "gcc/sdbout.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -105,22 +105,22 @@ extern tree current_function_decl;\n \n #include \"sdbout.h\"\n \n-static char *gen_fake_label\t\tPROTO((void));\n-static int plain_type\t\t\tPROTO((tree));\n-static int template_name_p\t\tPROTO((tree));\n-static void sdbout_record_type_name\tPROTO((tree));\n-static int plain_type_1\t\t\tPROTO((tree, int));\n-static void sdbout_block\t\tPROTO((tree));\n-static void sdbout_syms\t\t\tPROTO((tree));\n+static char *gen_fake_label\t\tPARAMS ((void));\n+static int plain_type\t\t\tPARAMS ((tree));\n+static int template_name_p\t\tPARAMS ((tree));\n+static void sdbout_record_type_name\tPARAMS ((tree));\n+static int plain_type_1\t\t\tPARAMS ((tree, int));\n+static void sdbout_block\t\tPARAMS ((tree));\n+static void sdbout_syms\t\t\tPARAMS ((tree));\n #ifdef SDB_ALLOW_FORWARD_REFERENCES\n-static void sdbout_queue_anonymous_type\tPROTO((tree));\n-static void sdbout_dequeue_anonymous_types PROTO((void));\n+static void sdbout_queue_anonymous_type\tPARAMS ((tree));\n+static void sdbout_dequeue_anonymous_types PARAMS ((void));\n #endif\n-static void sdbout_type\t\t\tPROTO((tree));\n-static void sdbout_field_types\t\tPROTO((tree));\n-static void sdbout_one_type\t\tPROTO((tree));\n-static void sdbout_parms\t\tPROTO((tree));\n-static void sdbout_reg_parms\t\tPROTO((tree));\n+static void sdbout_type\t\t\tPARAMS ((tree));\n+static void sdbout_field_types\t\tPARAMS ((tree));\n+static void sdbout_one_type\t\tPARAMS ((tree));\n+static void sdbout_parms\t\tPARAMS ((tree));\n+static void sdbout_reg_parms\t\tPARAMS ((tree));\n \f\n /* Define the default sizes for various types.  */\n "}, {"sha": "0cb215f665eb7b81996cdb39cf54c859386e1673", "filename": "gcc/stack.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack.h?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -38,5 +38,5 @@ struct stack_level\n   int limit;\n };\n \n-struct stack_level *push_stack_level PROTO((struct obstack *, char *, int));\n-struct stack_level *pop_stack_level PROTO((struct stack_level *));\n+struct stack_level *push_stack_level PARAMS ((struct obstack *, char *, int));\n+struct stack_level *pop_stack_level PARAMS ((struct stack_level *));"}, {"sha": "3cb79b19cbdab9a50a6ca4cef2fc2b36f9fb210f", "filename": "gcc/stmt.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -400,36 +400,36 @@ static int using_eh_for_cleanups_p = 0;\n static char *digit_strings[10];\n \n \n-static int n_occurrences\t\tPROTO((int, const char *));\n-static void expand_goto_internal\tPROTO((tree, rtx, rtx));\n-static int expand_fixup\t\t\tPROTO((tree, rtx, rtx));\n-static rtx expand_nl_handler_label\tPROTO((rtx, rtx));\n-static void expand_nl_goto_receiver\tPROTO((void));\n-static void expand_nl_goto_receivers\tPROTO((struct nesting *));\n-static void fixup_gotos\t\t\tPROTO((struct nesting *, rtx, tree,\n+static int n_occurrences\t\tPARAMS ((int, const char *));\n+static void expand_goto_internal\tPARAMS ((tree, rtx, rtx));\n+static int expand_fixup\t\t\tPARAMS ((tree, rtx, rtx));\n+static rtx expand_nl_handler_label\tPARAMS ((rtx, rtx));\n+static void expand_nl_goto_receiver\tPARAMS ((void));\n+static void expand_nl_goto_receivers\tPARAMS ((struct nesting *));\n+static void fixup_gotos\t\t\tPARAMS ((struct nesting *, rtx, tree,\n \t\t\t\t\t       rtx, int));\n-static void expand_null_return_1\tPROTO((rtx, int));\n-static void expand_value_return\t\tPROTO((rtx));\n-static int tail_recursion_args\t\tPROTO((tree, tree));\n-static void expand_cleanups\t\tPROTO((tree, tree, int, int));\n-static void check_seenlabel\t\tPROTO((void));\n-static void do_jump_if_equal\t\tPROTO((rtx, rtx, rtx, int));\n-static int estimate_case_costs\t\tPROTO((case_node_ptr));\n-static void group_case_nodes\t\tPROTO((case_node_ptr));\n-static void balance_case_nodes\t\tPROTO((case_node_ptr *,\n+static void expand_null_return_1\tPARAMS ((rtx, int));\n+static void expand_value_return\t\tPARAMS ((rtx));\n+static int tail_recursion_args\t\tPARAMS ((tree, tree));\n+static void expand_cleanups\t\tPARAMS ((tree, tree, int, int));\n+static void check_seenlabel\t\tPARAMS ((void));\n+static void do_jump_if_equal\t\tPARAMS ((rtx, rtx, rtx, int));\n+static int estimate_case_costs\t\tPARAMS ((case_node_ptr));\n+static void group_case_nodes\t\tPARAMS ((case_node_ptr));\n+static void balance_case_nodes\t\tPARAMS ((case_node_ptr *,\n \t\t\t\t\t       case_node_ptr));\n-static int node_has_low_bound\t\tPROTO((case_node_ptr, tree));\n-static int node_has_high_bound\t\tPROTO((case_node_ptr, tree));\n-static int node_is_bounded\t\tPROTO((case_node_ptr, tree));\n-static void emit_jump_if_reachable\tPROTO((rtx));\n-static void emit_case_nodes\t\tPROTO((rtx, case_node_ptr, rtx, tree));\n-static int add_case_node\t\tPROTO((tree, tree, tree, tree *));\n-static struct case_node *case_tree2list\tPROTO((case_node *, case_node *));\n-static void mark_cond_nesting           PROTO((struct nesting *));\n-static void mark_loop_nesting           PROTO((struct nesting *));\n-static void mark_block_nesting          PROTO((struct nesting *));\n-static void mark_case_nesting           PROTO((struct nesting *));\n-static void mark_goto_fixup             PROTO((struct goto_fixup *));\n+static int node_has_low_bound\t\tPARAMS ((case_node_ptr, tree));\n+static int node_has_high_bound\t\tPARAMS ((case_node_ptr, tree));\n+static int node_is_bounded\t\tPARAMS ((case_node_ptr, tree));\n+static void emit_jump_if_reachable\tPARAMS ((rtx));\n+static void emit_case_nodes\t\tPARAMS ((rtx, case_node_ptr, rtx, tree));\n+static int add_case_node\t\tPARAMS ((tree, tree, tree, tree *));\n+static struct case_node *case_tree2list\tPARAMS ((case_node *, case_node *));\n+static void mark_cond_nesting           PARAMS ((struct nesting *));\n+static void mark_loop_nesting           PARAMS ((struct nesting *));\n+static void mark_block_nesting          PARAMS ((struct nesting *));\n+static void mark_case_nesting           PARAMS ((struct nesting *));\n+static void mark_goto_fixup             PARAMS ((struct goto_fixup *));\n \n \f\n void\n@@ -4547,7 +4547,7 @@ check_seenlabel ()\n int\n pushcase (value, converter, label, duplicate)\n      register tree value;\n-     tree (*converter) PROTO((tree, tree));\n+     tree (*converter) PARAMS ((tree, tree));\n      register tree label;\n      tree *duplicate;\n {\n@@ -4611,7 +4611,7 @@ pushcase (value, converter, label, duplicate)\n int\n pushcase_range (value1, value2, converter, label, duplicate)\n      register tree value1, value2;\n-     tree (*converter) PROTO((tree, tree));\n+     tree (*converter) PARAMS ((tree, tree));\n      register tree label;\n      tree *duplicate;\n {"}, {"sha": "99b0d08703079deabd8477767a46d07785888b0e", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdadb1dda076203885b3a3845fe41a9a87a249ba/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=cdadb1dda076203885b3a3845fe41a9a87a249ba", "patch": "@@ -58,7 +58,7 @@ Boston, MA 02111-1307, USA.  */\n # undef fputs\n # define fputs(String, Stream) fputs_unlocked (String, Stream)\n # ifdef NEED_DECLARATION_FPUTS_UNLOCKED\n-extern int fputs_unlocked PROTO ((const char *, FILE *));\n+extern int fputs_unlocked PARAMS ((const char *, FILE *));\n # endif\n #endif\n "}]}