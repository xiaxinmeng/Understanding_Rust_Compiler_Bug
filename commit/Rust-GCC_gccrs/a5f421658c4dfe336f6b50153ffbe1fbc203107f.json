{"sha": "a5f421658c4dfe336f6b50153ffbe1fbc203107f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVmNDIxNjU4YzRkZmUzMzZmNmI1MDE1M2ZmYmUxZmJjMjAzMTA3Zg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-09-23T16:44:39Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-09-23T16:44:39Z"}, "message": "Add Jim's patches to improve reload behaviour.\n\nFrom-SVN: r22561", "tree": {"sha": "811ac8b66e4882c61dd2b5fea781e6c17069d42d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/811ac8b66e4882c61dd2b5fea781e6c17069d42d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5f421658c4dfe336f6b50153ffbe1fbc203107f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f421658c4dfe336f6b50153ffbe1fbc203107f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5f421658c4dfe336f6b50153ffbe1fbc203107f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f421658c4dfe336f6b50153ffbe1fbc203107f/comments", "author": null, "committer": null, "parents": [{"sha": "f916eeb6db92d698c87706411143f50ddfe9b126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f916eeb6db92d698c87706411143f50ddfe9b126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f916eeb6db92d698c87706411143f50ddfe9b126"}], "stats": {"total": 76, "additions": 67, "deletions": 9}, "files": [{"sha": "2e46e4d0e93c3b326eb9ca17ee8730865493244b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5f421658c4dfe336f6b50153ffbe1fbc203107f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5f421658c4dfe336f6b50153ffbe1fbc203107f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5f421658c4dfe336f6b50153ffbe1fbc203107f", "patch": "@@ -1,5 +1,13 @@\n Wed Sep 23 16:22:01 1998  Nick Clifton  <nickc@cygnus.com>\n \n+\t* config/arm/thumb.h: The following patches were made by Jim Wilson:\n+\t(enum reg_class): Add NONARG_LO_REGS support.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS, REGNO_REG_CLASS,\n+\tPREFERRED_RELOAD_CLASS, SECONDARY_RELOAD_CLASS): Likewise.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Disable REG+REG addresses before reload\n+\tcompletes.  Re-enable HImode REG+OFFSET addresses.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Define.\n+\n \t* expmed.c (extract_bit_field): Add comment from Jim Wilson. \n \n Wed Sep 23 13:26:02 1998  Richard Henderson  <rth@cygnus.com>"}, {"sha": "0f6c60c6390ca428abc8e8cd8f49445372287c3d", "filename": "gcc/config/arm/thumb.h", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5f421658c4dfe336f6b50153ffbe1fbc203107f/gcc%2Fconfig%2Farm%2Fthumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5f421658c4dfe336f6b50153ffbe1fbc203107f/gcc%2Fconfig%2Farm%2Fthumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.h?ref=a5f421658c4dfe336f6b50153ffbe1fbc203107f", "patch": "@@ -472,9 +472,15 @@ extern char * structure_size_string;\n \n #define MODES_TIEABLE_P(MODE1,MODE2) 1\n \n+/* The NOARG_LO_REGS class is the set of LO_REGS that are not used for passing\n+   arguments to functions.  These are the registers that are available for\n+   spilling during reload.  The code in reload1.c:init_reload() will detect this\n+   class and place it into 'reload_address_base_reg_class'.  */\n+\n enum reg_class\n {\n   NO_REGS,\n+  NONARG_LO_REGS,\n   LO_REGS,\n   STACK_REG,\n   BASE_REGS,\n@@ -490,6 +496,7 @@ enum reg_class\n #define REG_CLASS_NAMES \\\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n+  \"NONARG_LO_REGS\",\t\\\n   \"LO_REGS\",\t\t\\\n   \"STACK_REG\",\t\t\\\n   \"BASE_REGS\",\t\t\\\n@@ -500,6 +507,7 @@ enum reg_class\n #define REG_CLASS_CONTENTS\t\\\n {\t\t\t\t\\\n   0x00000,\t\t\t\\\n+  0x000f0,\t\t\t\\\n   0x000ff,\t\t\t\\\n   0x02000,\t\t\t\\\n   0x020ff,\t\t\t\\\n@@ -509,7 +517,8 @@ enum reg_class\n \n #define REGNO_REG_CLASS(REGNO)\t\t\t\\\n  ((REGNO) == STACK_POINTER_REGNUM ? STACK_REG\t\\\n-  : (REGNO) < 8 ? LO_REGS\t\t\t\\\n+  : (REGNO) < 8 ? ((REGNO) < 4 ? LO_REGS\t\\\n+\t\t   : NONARG_LO_REGS)\t\t\\\n   : HI_REGS)\n \n #define BASE_REG_CLASS BASE_REGS\n@@ -555,8 +564,15 @@ enum reg_class\n    abort.  Alternatively, this could be fixed by modifying BASE_REG_CLASS\n    to be LO_REGS instead of BASE_REGS.  It is not clear what affect this\n    change would have.  */\n+/* ??? This looks even more suspiciously wrong.  PREFERRED_RELOAD_CLASS\n+   must always return a strict subset of the input class.  Just blindly\n+   returning LO_REGS is safe only if the input class is a superset of LO_REGS,\n+   but there is no check for this.  Added another exception for NONARG_LO_REGS\n+   because it is not a superset of LO_REGS.  */\n+/* ??? We now use NONARG_LO_REGS for caller_save_spill_class, so the\n+   comments about BASE_REGS are now obsolete.  */\n #define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n-  ((CLASS) == BASE_REGS ? (CLASS)\t\\\n+  ((CLASS) == BASE_REGS || (CLASS) == NONARG_LO_REGS ? (CLASS)\t\\\n    : LO_REGS)\n /*\n   ((CONSTANT_P ((X)) && GET_CODE ((X)) != CONST_INT\t\t\\\n@@ -565,9 +581,10 @@ enum reg_class\n       && (unsigned HOST_WIDE_INT) INTVAL ((X)) > 255) ? NO_REGS\t\\\n    : LO_REGS) */\n \n-/* Must leave BASE_REGS reloads alone, see comment above.  */\n+/* Must leave BASE_REGS and NONARG_LO_REGS reloads alone, see comment\n+   above.  */\n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,X)\t\t\t\t\\\n-   ((CLASS) != LO_REGS && (CLASS) != BASE_REGS\t\t\t\t\\\n+   ((CLASS) != LO_REGS && (CLASS) != BASE_REGS && (CLASS) != NONARG_LO_REGS \\\n    ? ((true_regnum (X) == -1 ? LO_REGS\t\t\t\t\t\\\n        : (true_regnum (X) + HARD_REGNO_NREGS (0, MODE) > 8) ? LO_REGS\t\\\n        : NO_REGS)) \t\t\t\t\t\t\t\\\n@@ -885,6 +902,16 @@ int thumb_shiftable_const ();\n   else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       /* REG+REG address can be any two index registers.  */\t\t\\\n+      /* ??? REG+REG addresses have been completely disabled before\t\\\n+\t reload completes, because we do not have enough available\t\\\n+\t reload registers.  We only have 3 guaranteed reload registers\t\\\n+\t (NONARG_LO_REGS - the frame pointer), but we need at least 4\t\\\n+\t to support REG+REG addresses.  We have left them enabled after\t\\\n+\t reload completes, in the hope that reload_cse_regs and related\t\\\n+\t routines will be able to create them after the fact.  It is\t\\\n+\t probably possible to support REG+REG addresses with additional\t\\\n+\t reload work, but I do not not have enough time to attempt such\t\\\n+\t a change at this time.  */\t\t\t\t\t\\\n       /* ??? Normally checking the mode here is wrong, since it isn't\t\\\n \t impossible to use REG+REG with DFmode.  However, the movdf\t\\\n \t pattern requires offsettable addresses, and REG+REG is not\t\\\n@@ -898,24 +925,21 @@ int thumb_shiftable_const ();\n \t will be replaced with STACK, and SP relative addressing only   \\\n \t permits SP+OFFSET.  */\t\t\t\t\t\t\\\n       if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t  /* ??? See comment above.  */\t\t\t\t\t\\\n+\t  && reload_completed\t\t\t\t\t\t\\\n \t  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n \t  && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n \t  && XEXP (X, 0) != frame_pointer_rtx\t\t\t\t\\\n \t  && XEXP (X, 1) != frame_pointer_rtx\t\t\t\t\\\n-\t  /* CYGNUS LOCAL nickc */ \\\n \t  && XEXP (X, 0) != virtual_stack_vars_rtx\t\t\t\\\n \t  && XEXP (X, 1) != virtual_stack_vars_rtx\t\t\t\\\n-\t  /* END CYGNUS LOCAL */ \\\n \t  && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n \t  && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\t\t\t\\\n \tgoto WIN;\t\t\t\t\t\t\t\\\n       /* REG+const has 5-7 bit offset for non-SP registers.  */\t\t\\\n       else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n \t       && (REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\\\n \t\t   || XEXP (X, 0) == arg_pointer_rtx)\t\t\t\\\n-\t       /* CYGNUS LOCAL nickc */ \\\n-\t       && GET_MODE_SIZE (MODE) != 2\t\t\t\t\\\n-\t       /* END CYGNUS LOCAL */ \\\n \t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n \t       && LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n \tgoto WIN;\t\t\t\t\t\t\t\\\n@@ -933,6 +957,32 @@ int thumb_shiftable_const ();\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+/* ??? If an HImode FP+large_offset address is converted to an HImode\n+   SP+large_offset address, then reload won't know how to fix it.  It sees\n+   only that SP isn't valid for HImode, and so reloads the SP into an index\n+   register, but the resulting address is still invalid because the offset\n+   is too big.  We fix it here instead by reloading the entire address.  */\n+/* We could probably achieve better results by defining PROMOTE_MODE to help\n+   cope with the variances between the Thumb's signed and unsigned byte and\n+   halfword load instructions.  */\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+      && XEXP (X, 0) == stack_pointer_rtx\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+      && ! LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx orig_X = X;\t\t\t\t\t\t\t\\\n+      X = copy_rtx (X);\t\t\t\t\t\t\t\\\n+      push_reload (orig_X, NULL_RTX, &X, NULL_PTR,\t\t\t\\\n+\t\t   reload_address_base_reg_class,\t\t\t\\\n+\t\t   Pmode, VOIDmode, 0, 0, OPNUM, TYPE);\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+  \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)"}]}