{"sha": "656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "node_id": "C_kwDOANBUbNoAKDY1NmIyMzM4YzhmMjQ4ZDkyMDViNmU5ZDVlNGQ5Y2M0MzIyOGRkNWU", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-10-18T12:14:26Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-10-18T12:14:26Z"}, "message": "ipa-cp: Better representation of aggregate values in call contexts\n\nThis patch extends the previous one by using the same data structure\nto represent aggregate values in classes ipa_auto_call_arg_values and\nipa_call_arg_values.\n\nThis usually simplifies handling and makes allocations of memory much\ncheaper because only a single vectore is needed, as opposed to vectors\nwith each element pointing at other vecs.  The only functions which\nunfortunately are a bit more complec are estimate_local_effects in\nipa-cp.cc and ipa_call_context::equal_to but I hope not too much - the\nlatter could probably be shorteneed at the expense of readability.\n\nThe patch removes types ipa_agg_value ipa_agg_value_set which is no\nlonger used with it.  This means that we could replace the \"_argagg_\"\npart of the types introduced by the previous patches with more\nreasonable \"_agg_\" - possibly as a follow-up patch.\n\ngcc/ChangeLog:\n\n2022-08-26  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_agg_value): Remove type.\n\t(ipa_agg_value_set): Likewise.\n\t(ipa_copy_agg_values): Remove function.\n\t(ipa_release_agg_values): Likewise.\n\t(ipa_auto_call_arg_values) Add a forward declaration.\n\t(ipa_call_arg_values): Likewise.\n\t(class ipa_argagg_value_list): New constructors, added member function\n\tvalue_for_index_p.\n\t(class ipa_auto_call_arg_values): Removed the destructor and member\n\tfunction safe_aggval_at.  Use ipa_argagg_values for m_known_aggs.\n\t(class ipa_call_arg_values): Removed member function safe_aggval_at.\n\tUse ipa_argagg_values for m_known_aggs.\n\t(ipa_get_indirect_edge_target): Removed declaration.\n\t(ipa_find_agg_cst_for_param): Likewise.\n\t(ipa_find_agg_cst_from_init): New declaration.\n\t(ipa_agg_value_from_jfunc): Likewise.\n\t(ipa_agg_value_set_from_jfunc): Removed declaration.\n\t(ipa_push_agg_values_from_jfunc): New declaration.\n\t* ipa-cp.cc (ipa_agg_value_from_node): Renamed to\n\tipa_agg_value_from_jfunc, made public.\n\t(ipa_agg_value_set_from_jfunc): Removed.\n\t(ipa_push_agg_values_from_jfunc): New function.\n\t(ipa_get_indirect_edge_target_1): Removed known_aggs parameter, use\n\tavs for this purpose too.\n\t(ipa_get_indirect_edge_target): Removed the overload working on\n\tipa_auto_call_arg_values, use ipa_argagg_value_list in the remaining\n\tone.\n\t(devirtualization_time_bonus): Use ipa_argagg_value_list and\n\tipa_get_indirect_edge_target_1 instead of\n\tipa_get_indirect_edge_target.\n\t(context_independent_aggregate_values): Removed function.\n\t(gather_context_independent_values): Work on ipa_argagg_value_list.\n\t(estimate_local_effects): Likewise, define some iterator variables\n\tonly in the construct where necessary.\n\t(ipcp_discover_new_direct_edges): Adjust the call to\n\tipa_get_indirect_edge_target_1.\n\t(push_agg_values_for_index_from_edge): Adjust the call\n\tipa_agg_value_from_node which has been renamed to\n\tipa_agg_value_from_jfunc.\n\t* ipa-fnsummary.cc (evaluate_conditions_for_known_args): Work on\n\tipa_argagg_value_list.\n\t(evaluate_properties_for_edge): Replace manual filling in aggregate\n\tvalues with call to ipa_push_agg_values_from_jfunc.\n\t(estimate_calls_size_and_time): Work on ipa_argagg_value_list.\n\t(ipa_cached_call_context::duplicate_from): Likewise.\n\t(ipa_cached_call_context::release): Likewise.\n\t(ipa_call_context::equal_to): Likewise.\n\t* ipa-prop.cc (ipa_find_agg_cst_from_init): Make public.\n\t(ipa_find_agg_cst_for_param): Removed function.\n\t(ipa_find_agg_cst_from_jfunc_items): New function.\n\t(try_make_edge_direct_simple_call): Replace calls to\n\tipa_agg_value_set_from_jfunc and ipa_find_agg_cst_for_param with\n\tipa_find_agg_cst_from_init and ipa_find_agg_cst_from_jfunc_items.\n\t(try_make_edge_direct_virtual_call): Replace calls to\n\tipa_agg_value_set_from_jfunc and ipa_find_agg_cst_for_param with\n\tsimple query of constant jump function and a call to\n\tipa_find_agg_cst_from_jfunc_items.\n\t(ipa_auto_call_arg_values::~ipa_auto_call_arg_values): Removed.", "tree": {"sha": "09d8d400677fa1521a05d9081e4dd59b2755d5eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09d8d400677fa1521a05d9081e4dd59b2755d5eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0403e95689af7d562c7d04f706e9e25115747ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0403e95689af7d562c7d04f706e9e25115747ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0403e95689af7d562c7d04f706e9e25115747ff"}], "stats": {"total": 621, "additions": 218, "deletions": 403}, "files": [{"sha": "d2bcd5e5e691ced8dba4b496b9d044eb2777d2b2", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 91, "deletions": 143, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "patch": "@@ -1975,10 +1975,9 @@ ipa_value_range_from_jfunc (ipa_node_params *info, cgraph_edge *cs,\n    NODE and INFO describes the caller node or the one it is inlined to, and\n    its related info.  */\n \n-static tree\n-ipa_agg_value_from_node (class ipa_node_params *info,\n-\t\t\t struct cgraph_node *node,\n-\t\t\t const ipa_agg_jf_item *item)\n+tree\n+ipa_agg_value_from_jfunc (ipa_node_params *info, cgraph_node *node,\n+\t\t\t  const ipa_agg_jf_item *item)\n {\n   tree value = NULL_TREE;\n   int src_idx;\n@@ -2061,37 +2060,38 @@ ipa_agg_value_from_node (class ipa_node_params *info,\n \t\t\t\t  item->type);\n }\n \n-/* Determine whether AGG_JFUNC evaluates to a set of known constant value for\n-   an aggregate and if so, return it.  Otherwise return an empty set.  NODE\n-   and INFO describes the caller node or the one it is inlined to, and its\n-   related info.  */\n+/* Process all items in AGG_JFUNC relative to caller (or the node the original\n+  caller is inlined to) NODE which described by INFO and push the results to\n+  RES as describing values passed in parameter DST_INDEX.  */\n \n-struct ipa_agg_value_set\n-ipa_agg_value_set_from_jfunc (class ipa_node_params *info, cgraph_node *node,\n-\t\t\t      struct ipa_agg_jump_function *agg_jfunc)\n+void\n+ipa_push_agg_values_from_jfunc (ipa_node_params *info, cgraph_node *node,\n+\t\t\t\tipa_agg_jump_function *agg_jfunc,\n+\t\t\t\tunsigned dst_index,\n+\t\t\t\tvec<ipa_argagg_value> *res)\n {\n-  struct ipa_agg_value_set agg;\n-  struct ipa_agg_jf_item *item;\n-  int i;\n-\n-  agg.items = vNULL;\n-  agg.by_ref = agg_jfunc->by_ref;\n+  unsigned prev_unit_offset = 0;\n+  bool first = true;\n \n-  FOR_EACH_VEC_SAFE_ELT (agg_jfunc->items, i, item)\n+  for (const ipa_agg_jf_item &item : agg_jfunc->items)\n     {\n-      tree value = ipa_agg_value_from_node (info, node, item);\n+      tree value = ipa_agg_value_from_jfunc (info, node, &item);\n+      if (!value)\n+\tcontinue;\n \n-      if (value)\n-\t{\n-\t  struct ipa_agg_value value_item;\n+      ipa_argagg_value iav;\n+      iav.value = value;\n+      iav.unit_offset = item.offset / BITS_PER_UNIT;\n+      iav.index = dst_index;\n+      iav.by_ref = agg_jfunc->by_ref;\n \n-\t  value_item.offset = item->offset;\n-\t  value_item.value = value;\n+      gcc_assert (first\n+\t\t  || iav.unit_offset > prev_unit_offset);\n+      prev_unit_offset = iav.unit_offset;\n+      first = false;\n \n-\t  agg.items.safe_push (value_item);\n-\t}\n+      res->safe_push (iav);\n     }\n-  return agg;\n }\n \n /* If checking is enabled, verify that no lattice is in the TOP state, i.e. not\n@@ -3240,8 +3240,7 @@ static tree\n ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t\t\t\tconst vec<tree> &known_csts,\n \t\t\t\tconst vec<ipa_polymorphic_call_context> &known_contexts,\n-\t\t\t\tconst vec<ipa_agg_value_set> &known_aggs,\n-\t\t\t\tconst ipa_argagg_value_list *avs,\n+\t\t\t\tconst ipa_argagg_value_list &avs,\n \t\t\t\tbool *speculative)\n {\n   int param_index = ie->indirect_info->param_index;\n@@ -3261,31 +3260,16 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n       if (ie->indirect_info->agg_contents)\n \t{\n \t  t = NULL;\n-\t  if (avs && ie->indirect_info->guaranteed_unmodified)\n-\t    t = avs->get_value (param_index,\n-\t\t\t\tie->indirect_info->offset / BITS_PER_UNIT,\n-\t\t\t\tie->indirect_info->by_ref);\n-\t  if (!t)\n-\t    {\n-\t      const ipa_agg_value_set *agg;\n-\t      if (known_aggs.length () > (unsigned int) param_index)\n-\t\tagg = &known_aggs[param_index];\n-\t      else\n-\t\tagg = NULL;\n-\t      bool from_global_constant;\n-\t      t = ipa_find_agg_cst_for_param (agg,\n-\t\t\t\t\t      (unsigned) param_index\n-\t\t\t\t\t\t < known_csts.length ()\n-\t\t\t\t\t      ? known_csts[param_index]\n-\t\t\t\t\t      : NULL,\n-\t\t\t\t\t      ie->indirect_info->offset,\n-\t\t\t\t\t      ie->indirect_info->by_ref,\n-\t\t\t\t\t      &from_global_constant);\n-\t      if (t\n-\t\t  && !from_global_constant\n-\t\t  && !ie->indirect_info->guaranteed_unmodified)\n-\t\tt = NULL_TREE;\n-\t    }\n+\t  if ((unsigned) param_index < known_csts.length ()\n+\t      && known_csts[param_index])\n+\t    t = ipa_find_agg_cst_from_init (known_csts[param_index],\n+\t\t\t\t\t    ie->indirect_info->offset,\n+\t\t\t\t\t    ie->indirect_info->by_ref);\n+\n+\t  if (!t && ie->indirect_info->guaranteed_unmodified)\n+\t    t = avs.get_value (param_index,\n+\t\t\t       ie->indirect_info->offset / BITS_PER_UNIT,\n+\t\t\t       ie->indirect_info->by_ref);\n \t}\n       else if ((unsigned) param_index < known_csts.length ())\n \tt = known_csts[param_index];\n@@ -3302,28 +3286,22 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n     return NULL_TREE;\n \n   gcc_assert (!ie->indirect_info->agg_contents);\n+  gcc_assert (!ie->indirect_info->by_ref);\n   anc_offset = ie->indirect_info->offset;\n \n   t = NULL;\n \n-  /* Try to work out value of virtual table pointer value in replacements.  */\n-  if (!t && avs && !ie->indirect_info->by_ref)\n-    t = avs->get_value (param_index,\n-\t\t\tie->indirect_info->offset / BITS_PER_UNIT,\n-\t\t\ttrue);\n+  if ((unsigned) param_index < known_csts.length ()\n+      && known_csts[param_index])\n+    t = ipa_find_agg_cst_from_init (known_csts[param_index],\n+\t\t\t\t    ie->indirect_info->offset, true);\n \n-  /* Try to work out value of virtual table pointer value in known\n-     aggregate values.  */\n-  if (!t && known_aggs.length () > (unsigned int) param_index\n-      && !ie->indirect_info->by_ref)\n-    {\n-      const ipa_agg_value_set *agg = &known_aggs[param_index];\n-      t = ipa_find_agg_cst_for_param (agg,\n-\t\t\t\t      (unsigned) param_index\n-\t\t\t\t\t < known_csts.length ()\n-\t\t\t\t      ? known_csts[param_index] : NULL,\n-\t\t\t\t      ie->indirect_info->offset, true);\n-    }\n+  /* Try to work out value of virtual table pointer value in replacements.  */\n+  /* or known aggregate values.  */\n+  if (!t)\n+    t = avs.get_value (param_index,\n+\t\t       ie->indirect_info->offset / BITS_PER_UNIT,\n+\t\t       true);\n \n   /* If we found the virtual table pointer, lookup the target.  */\n   if (t)\n@@ -3442,23 +3420,10 @@ ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \t\t\t      ipa_call_arg_values *avals,\n \t\t\t      bool *speculative)\n {\n+  ipa_argagg_value_list avl (avals);\n   return ipa_get_indirect_edge_target_1 (ie, avals->m_known_vals,\n \t\t\t\t\t avals->m_known_contexts,\n-\t\t\t\t\t avals->m_known_aggs,\n-\t\t\t\t\t NULL, speculative);\n-}\n-\n-/* The same functionality as above overloaded for ipa_auto_call_arg_values.  */\n-\n-tree\n-ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t      ipa_auto_call_arg_values *avals,\n-\t\t\t      bool *speculative)\n-{\n-  return ipa_get_indirect_edge_target_1 (ie, avals->m_known_vals,\n-\t\t\t\t\t avals->m_known_contexts,\n-\t\t\t\t\t avals->m_known_aggs,\n-\t\t\t\t\t NULL, speculative);\n+\t\t\t\t\t avl, speculative);\n }\n \n /* Calculate devirtualization time bonus for NODE, assuming we know information\n@@ -3479,7 +3444,10 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       tree target;\n       bool speculative;\n \n-      target = ipa_get_indirect_edge_target (ie, avals, &speculative);\n+      ipa_argagg_value_list avl (avals);\n+      target = ipa_get_indirect_edge_target_1 (ie, avals->m_known_vals,\n+\t\t\t\t\t       avals->m_known_contexts,\n+\t\t\t\t\t       avl, &speculative);\n       if (!target)\n \tcontinue;\n \n@@ -3615,32 +3583,6 @@ good_cloning_opportunity_p (struct cgraph_node *node, sreal time_benefit,\n     }\n }\n \n-/* Return all context independent values from aggregate lattices in PLATS in a\n-   vector.  Return NULL if there are none.  */\n-\n-static vec<ipa_agg_value>\n-context_independent_aggregate_values (class ipcp_param_lattices *plats)\n-{\n-  vec<ipa_agg_value> res = vNULL;\n-\n-  if (plats->aggs_bottom\n-      || plats->aggs_contain_variable\n-      || plats->aggs_count == 0)\n-    return vNULL;\n-\n-  for (struct ipcp_agg_lattice *aglat = plats->aggs;\n-       aglat;\n-       aglat = aglat->next)\n-    if (aglat->is_single_const ())\n-      {\n-\tstruct ipa_agg_value item;\n-\titem.offset = aglat->offset;\n-\titem.value = aglat->values->value;\n-\tres.safe_push (item);\n-      }\n-  return res;\n-}\n-\n /* Grow vectors in AVALS and fill them with information about values of\n    parameters that are known to be independent of the context.  Only calculate\n    m_known_aggs if CALCULATE_AGGS is true.  INFO describes the function.  If\n@@ -3660,8 +3602,6 @@ gather_context_independent_values (class ipa_node_params *info,\n \n   avals->m_known_vals.safe_grow_cleared (count, true);\n   avals->m_known_contexts.safe_grow_cleared (count, true);\n-  if (calculate_aggs)\n-    avals->m_known_aggs.safe_grow_cleared (count, true);\n \n   if (removable_params_cost)\n     *removable_params_cost = 0;\n@@ -3696,16 +3636,7 @@ gather_context_independent_values (class ipa_node_params *info,\n \tavals->m_known_contexts[i] = ctxlat->values->value;\n \n       if (calculate_aggs)\n-\t{\n-\t  vec<ipa_agg_value> agg_items;\n-\t  struct ipa_agg_value_set *agg;\n-\n-\t  agg_items = context_independent_aggregate_values (plats);\n-\t  agg = &avals->m_known_aggs[i];\n-\t  agg->items = agg_items;\n-\t  agg->by_ref = plats->aggs_by_ref;\n-\t  ret |= !agg_items.is_empty ();\n-\t}\n+\tret |= push_agg_values_from_plats (plats, i, 0, &avals->m_known_aggs);\n     }\n \n   return ret;\n@@ -3776,7 +3707,7 @@ static void\n estimate_local_effects (struct cgraph_node *node)\n {\n   ipa_node_params *info = ipa_node_params_sum->get (node);\n-  int i, count = ipa_get_param_count (info);\n+  int count = ipa_get_param_count (info);\n   bool always_const;\n   int removable_params_cost;\n \n@@ -3842,7 +3773,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n     }\n \n-  for (i = 0; i < count; i++)\n+  for (int i = 0; i < count; i++)\n     {\n       class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n@@ -3876,7 +3807,7 @@ estimate_local_effects (struct cgraph_node *node)\n       avals.m_known_vals[i] = NULL_TREE;\n     }\n \n-  for (i = 0; i < count; i++)\n+  for (int i = 0; i < count; i++)\n     {\n       class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \n@@ -3911,30 +3842,49 @@ estimate_local_effects (struct cgraph_node *node)\n       avals.m_known_contexts[i] = ipa_polymorphic_call_context ();\n     }\n \n-  for (i = 0; i < count; i++)\n+  unsigned all_ctx_len = avals.m_known_aggs.length ();\n+  auto_vec<ipa_argagg_value, 32> all_ctx;\n+  all_ctx.reserve_exact (all_ctx_len);\n+  all_ctx.splice (avals.m_known_aggs);\n+  avals.m_known_aggs.safe_grow_cleared (all_ctx_len + 1);\n+\n+  unsigned j = 0;\n+  for (int index = 0; index < count; index++)\n     {\n-      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, index);\n \n       if (plats->aggs_bottom || !plats->aggs)\n \tcontinue;\n \n-      ipa_agg_value_set *agg = &avals.m_known_aggs[i];\n       for (ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n \t{\n \t  ipcp_value<tree> *val;\n \t  if (aglat->bottom || !aglat->values\n-\t      /* If the following is true, the one value is in known_aggs.  */\n+\t      /* If the following is true, the one value is already part of all\n+\t\t context estimations.  */\n \t      || (!plats->aggs_contain_variable\n \t\t  && aglat->is_single_const ()))\n \t    continue;\n \n-\t  for (val = aglat->values; val; val = val->next)\n+\t  unsigned unit_offset = aglat->offset / BITS_PER_UNIT;\n+\t  while (j < all_ctx_len\n+\t\t && (all_ctx[j].index < index\n+\t\t     || (all_ctx[j].index == index\n+\t\t\t && all_ctx[j].unit_offset < unit_offset)))\n \t    {\n-\t      struct ipa_agg_value item;\n+\t      avals.m_known_aggs[j] = all_ctx[j];\n+\t      j++;\n+\t    }\n+\n+\t  for (unsigned k = j; k < all_ctx_len; k++)\n+\t    avals.m_known_aggs[k+1] = all_ctx[k];\n \n-\t      item.offset = aglat->offset;\n-\t      item.value = val->value;\n-\t      agg->items.safe_push (item);\n+\t  for (val = aglat->values; val; val = val->next)\n+\t    {\n+\t      avals.m_known_aggs[j].value = val->value;\n+\t      avals.m_known_aggs[j].unit_offset = unit_offset;\n+\t      avals.m_known_aggs[j].index = index;\n+\t      avals.m_known_aggs[j].by_ref = plats->aggs_by_ref;\n \n \t      perform_estimation_of_a_value (node, &avals,\n \t\t\t\t\t     removable_params_cost, 0, val);\n@@ -3944,16 +3894,14 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t  fprintf (dump_file, \" - estimates for value \");\n \t\t  print_ipcp_constant_value (dump_file, val->value);\n \t\t  fprintf (dump_file, \" for \");\n-\t\t  ipa_dump_param (dump_file, info, i);\n+\t\t  ipa_dump_param (dump_file, info, index);\n \t\t  fprintf (dump_file, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC\n \t\t\t   \"]: time_benefit: %g, size: %i\\n\",\n \t\t\t   plats->aggs_by_ref ? \"ref \" : \"\",\n \t\t\t   aglat->offset,\n \t\t\t   val->local_time_benefit.to_double (),\n \t\t\t   val->local_size_cost);\n \t\t}\n-\n-\t      agg->items.pop ();\n \t    }\n \t}\n     }\n@@ -4350,7 +4298,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n       next_ie = ie->next_callee;\n       ipa_argagg_value_list avs (aggvals);\n       target = ipa_get_indirect_edge_target_1 (ie, known_csts, known_contexts,\n-\t\t\t\t\t       vNULL, &avs, &speculative);\n+\t\t\t\t\t       avs, &speculative);\n       if (target)\n \t{\n \t  bool agg_contents = ie->indirect_info->agg_contents;\n@@ -5779,8 +5727,8 @@ push_agg_values_for_index_from_edge (struct cgraph_edge *cs, int index,\n \t\t\t\t\t agg_jf.value.pass_through.operand,\n \t\t\t\t\t agg_jf.type);\n       else\n-\tvalue = ipa_agg_value_from_node (caller_info, cs->caller,\n-\t\t\t\t\t &agg_jf);\n+\tvalue = ipa_agg_value_from_jfunc (caller_info, cs->caller,\n+\t\t\t\t\t  &agg_jf);\n       if (value)\n \t{\n \t  struct ipa_argagg_value iav;"}, {"sha": "fd3d7d6c5e863e28a8a54755be385c1cd852e4d6", "filename": "gcc/ipa-fnsummary.cc", "status": "modified", "additions": 58, "deletions": 47, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-fnsummary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-fnsummary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.cc?ref=656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "patch": "@@ -386,30 +386,21 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       int j;\n       struct expr_eval_op *op;\n \n-      /* We allow call stmt to have fewer arguments than the callee function\n-         (especially for K&R style programs).  So bound check here (we assume\n-         m_known_aggs vector is either empty or has the same length as\n-         m_known_vals).  */\n-      gcc_checking_assert (!avals->m_known_aggs.length ()\n-\t\t\t   || !avals->m_known_vals.length ()\n-\t\t\t   || (avals->m_known_vals.length ()\n-\t\t\t       == avals->m_known_aggs.length ()));\n-\n       if (c->agg_contents)\n \t{\n \t  if (c->code == ipa_predicate::changed\n \t      && !c->by_ref\n \t      && (avals->safe_sval_at(c->operand_num) == error_mark_node))\n \t    continue;\n \n-\t  if (ipa_agg_value_set *agg = avals->safe_aggval_at (c->operand_num))\n+\t  if (tree sval = avals->safe_sval_at (c->operand_num))\n+\t    val = ipa_find_agg_cst_from_init (sval, c->offset, c->by_ref);\n+\t  if (!val)\n \t    {\n-\t      tree sval = avals->safe_sval_at (c->operand_num);\n-\t      val = ipa_find_agg_cst_for_param (agg, sval, c->offset,\n-\t\t\t\t\t\tc->by_ref);\n+\t      ipa_argagg_value_list avs (avals);\n+\t      val = avs.get_value (c->operand_num, c->offset / BITS_PER_UNIT,\n+\t\t\t\t   c->by_ref);\n \t    }\n-\t  else\n-\t    val = NULL_TREE;\n \t}\n       else\n \t{\n@@ -674,17 +665,9 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \n \t\t/* Determine known aggregate values.  */\n \t\tif (fre_will_run_p (caller))\n-\t\t  {\n-\t\t    ipa_agg_value_set agg\n-\t\t\t= ipa_agg_value_set_from_jfunc (caller_parms_info,\n-\t\t\t\t\t\t\tcaller, &jf->agg);\n-\t\t    if (agg.items.length ())\n-\t\t      {\n-\t\t\tif (!avals->m_known_aggs.length ())\n-\t\t\t  avals->m_known_aggs.safe_grow_cleared (count, true);\n-\t\t\tavals->m_known_aggs[i] = agg;\n-\t\t      }\n-\t\t  }\n+\t\t  ipa_push_agg_values_from_jfunc (caller_parms_info,\n+\t\t\t\t\t\t  caller, &jf->agg, i,\n+\t\t\t\t\t\t  &avals->m_known_aggs);\n \t      }\n \n \t    /* For calls used in polymorphic calls we further determine\n@@ -3446,8 +3429,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t{\n \t  if (ipa_is_param_used_by_indirect_call (params_summary, i)\n \t      && (avals->safe_sval_at (i)\n-\t\t  || (avals->m_known_aggs.length () > i\n-\t\t      && avals->m_known_aggs[i].items.length ())))\n+\t\t  || (ipa_argagg_value_list (avals).value_for_index_p (i))))\n \t    use_table = false;\n \t  else if (ipa_is_param_used_by_polymorphic_call (params_summary, i)\n \t\t   && (avals->m_known_contexts.length () > i\n@@ -3583,14 +3565,12 @@ ipa_cached_call_context::duplicate_from (const ipa_call_context &ctx)\n   m_avals.m_known_aggs = vNULL;\n   if (ctx.m_avals.m_known_aggs.exists ())\n     {\n-      unsigned int n = MIN (ctx.m_avals.m_known_aggs.length (), nargs);\n-\n-      for (unsigned int i = 0; i < n; i++)\n+      const ipa_argagg_value_list avl (&ctx.m_avals);\n+      for (unsigned int i = 0; i < nargs; i++)\n \tif (ipa_is_param_used_by_indirect_call (params_summary, i)\n-\t    && !ctx.m_avals.m_known_aggs[i].is_empty ())\n+\t    && avl.value_for_index_p (i))\n \t  {\n-\t    m_avals.m_known_aggs\n-\t      = ipa_copy_agg_values (ctx.m_avals.m_known_aggs);\n+\t    m_avals.m_known_aggs = ctx.m_avals.m_known_aggs.copy ();\n \t    break;\n \t  }\n     }\n@@ -3607,7 +3587,7 @@ ipa_cached_call_context::release ()\n   /* See if context is initialized at first place.  */\n   if (!m_node)\n     return;\n-  ipa_release_agg_values (m_avals.m_known_aggs, true);\n+  m_avals.m_known_aggs.release ();\n   m_avals.m_known_vals.release ();\n   m_avals.m_known_contexts.release ();\n   m_inline_param_summary.release ();\n@@ -3708,28 +3688,59 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n     }\n   if (m_avals.m_known_aggs.exists () || ctx.m_avals.m_known_aggs.exists ())\n     {\n-      for (unsigned int i = 0; i < nargs; i++)\n+      unsigned i = 0, j = 0;\n+      while (i < m_avals.m_known_aggs.length ()\n+\t     || j < ctx.m_avals.m_known_aggs.length ())\n \t{\n-\t  if (!ipa_is_param_used_by_indirect_call (params_summary, i))\n-\t    continue;\n-\t  if (i >= m_avals.m_known_aggs.length ()\n-\t      || m_avals.m_known_aggs[i].is_empty ())\n+\t  if (i >= m_avals.m_known_aggs.length ())\n \t    {\n-\t      if (i < ctx.m_avals.m_known_aggs.length ()\n-\t\t  && !ctx.m_avals.m_known_aggs[i].is_empty ())\n+\t      int idx2 = ctx.m_avals.m_known_aggs[j].index;\n+\t      if (ipa_is_param_used_by_indirect_call (params_summary, idx2))\n \t\treturn false;\n+\t      j++;\n \t      continue;\n \t    }\n-\t  if (i >= ctx.m_avals.m_known_aggs.length ()\n-\t      || ctx.m_avals.m_known_aggs[i].is_empty ())\n+\t  if (j >= ctx.m_avals.m_known_aggs.length ())\n \t    {\n-\t      if (i < m_avals.m_known_aggs.length ()\n-\t\t  && !m_avals.m_known_aggs[i].is_empty ())\n+\t      int idx1 = m_avals.m_known_aggs[i].index;\n+\t      if (ipa_is_param_used_by_indirect_call (params_summary, idx1))\n \t\treturn false;\n+\t      i++;\n \t      continue;\n \t    }\n-\t  if (!m_avals.m_known_aggs[i].equal_to (ctx.m_avals.m_known_aggs[i]))\n+\n+\t  int idx1 = m_avals.m_known_aggs[i].index;\n+\t  int idx2 = ctx.m_avals.m_known_aggs[j].index;\n+\t  if (idx1 < idx2)\n+\t    {\n+\t      if (ipa_is_param_used_by_indirect_call (params_summary, idx1))\n+\t\treturn false;\n+\t      i++;\n+\t      continue;\n+\t    }\n+\t  if (idx1 > idx2)\n+\t    {\n+\t      if (ipa_is_param_used_by_indirect_call (params_summary, idx2))\n+\t\treturn false;\n+\t      j++;\n+\t      continue;\n+\t    }\n+\t  if (!ipa_is_param_used_by_indirect_call (params_summary, idx1))\n+\t    {\n+\t      i++;\n+\t      j++;\n+\t      continue;\n+\t    }\n+\n+\t  if ((m_avals.m_known_aggs[i].unit_offset\n+\t       != ctx.m_avals.m_known_aggs[j].unit_offset)\n+\t      || (m_avals.m_known_aggs[i].by_ref\n+\t       != ctx.m_avals.m_known_aggs[j].by_ref)\n+\t      || !operand_equal_p (m_avals.m_known_aggs[i].value,\n+\t\t\t\t   ctx.m_avals.m_known_aggs[j].value))\n \t    return false;\n+\t  i++;\n+\t  j++;\n \t}\n     }\n   return true;"}, {"sha": "e6cf25591b3286f2d027458daa3cda9e956fc851", "filename": "gcc/ipa-prop.cc", "status": "modified", "additions": 32, "deletions": 78, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-prop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-prop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.cc?ref=656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "patch": "@@ -3612,7 +3612,7 @@ find_constructor_constant_at_offset (tree constructor, HOST_WIDE_INT req_offset)\n    invariant from a static constructor and if so, return it.  Otherwise return\n    NULL. */\n \n-static tree\n+tree\n ipa_find_agg_cst_from_init (tree scalar, HOST_WIDE_INT offset, bool by_ref)\n {\n   if (by_ref)\n@@ -3632,47 +3632,24 @@ ipa_find_agg_cst_from_init (tree scalar, HOST_WIDE_INT offset, bool by_ref)\n   return find_constructor_constant_at_offset (DECL_INITIAL (scalar), offset);\n }\n \n-/* Retrieve value from AGG, a set of known offset/value for an aggregate or\n-   static initializer of SCALAR (which can be NULL) for the given OFFSET or\n-   return NULL if there is none.  BY_REF specifies whether the value has to be\n-   passed by reference or by value.  If FROM_GLOBAL_CONSTANT is non-NULL, then\n-   the boolean it points to is set to true if the value comes from an\n-   initializer of a constant.  */\n+/* Retrieve value from AGG_JFUNC for the given OFFSET or return NULL if there\n+   is none.  BY_REF specifies whether the value has to be passed by reference\n+   or by value.  */\n \n-tree\n-ipa_find_agg_cst_for_param (const ipa_agg_value_set *agg, tree scalar,\n-\t\t\t    HOST_WIDE_INT offset, bool by_ref,\n-\t\t\t    bool *from_global_constant)\n+static tree\n+ipa_find_agg_cst_from_jfunc_items (struct ipa_agg_jump_function *agg_jfunc,\n+\t\t\t\t   ipa_node_params *src_info,\n+\t\t\t\t   cgraph_node *src_node,\n+\t\t\t\t   HOST_WIDE_INT offset, bool by_ref)\n {\n-  struct ipa_agg_value *item;\n-  int i;\n-\n-  if (scalar)\n-    {\n-      tree res = ipa_find_agg_cst_from_init (scalar, offset, by_ref);\n-      if (res)\n-\t{\n-\t  if (from_global_constant)\n-\t    *from_global_constant = true;\n-\t  return res;\n-\t}\n-    }\n+  if (by_ref != agg_jfunc->by_ref)\n+    return NULL_TREE;\n \n-  if (!agg\n-      || by_ref != agg->by_ref)\n-    return NULL;\n+  for (const ipa_agg_jf_item &item : agg_jfunc->items)\n+    if (item.offset == offset)\n+      return ipa_agg_value_from_jfunc (src_info, src_node, &item);\n \n-  FOR_EACH_VEC_ELT (agg->items, i, item)\n-    if (item->offset == offset)\n-      {\n-\t/* Currently we do not have clobber values, return NULL for them once\n-\t   we do.  */\n-\tgcc_checking_assert (is_gimple_ip_invariant (item->value));\n-\tif (from_global_constant)\n-\t  *from_global_constant = false;\n-\treturn item->value;\n-      }\n-  return NULL;\n+  return NULL_TREE;\n }\n \n /* Remove a reference to SYMBOL from the list of references of a node given by\n@@ -3769,24 +3746,19 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n \t\t\t\t  class ipa_node_params *new_root_info)\n {\n   struct cgraph_edge *cs;\n-  tree target;\n+  tree target = NULL_TREE;\n   bool agg_contents = ie->indirect_info->agg_contents;\n   tree scalar = ipa_value_from_jfunc (new_root_info, jfunc, target_type);\n   if (agg_contents)\n     {\n-      bool from_global_constant;\n-      ipa_agg_value_set agg = ipa_agg_value_set_from_jfunc (new_root_info,\n-\t\t\t\t\t\t\t    new_root,\n-\t\t\t\t\t\t\t    &jfunc->agg);\n-      target = ipa_find_agg_cst_for_param (&agg, scalar,\n-\t\t\t\t\t   ie->indirect_info->offset,\n-\t\t\t\t\t   ie->indirect_info->by_ref,\n-\t\t\t\t\t   &from_global_constant);\n-      agg.release ();\n-      if (target\n-\t  && !from_global_constant\n-\t  && !ie->indirect_info->guaranteed_unmodified)\n-\treturn NULL;\n+      if (scalar)\n+\ttarget = ipa_find_agg_cst_from_init (scalar, ie->indirect_info->offset,\n+\t\t\t\t\t     ie->indirect_info->by_ref);\n+      if (!target && ie->indirect_info->guaranteed_unmodified)\n+\ttarget = ipa_find_agg_cst_from_jfunc_items (&jfunc->agg, new_root_info,\n+\t\t\t\t\t\t    new_root,\n+\t\t\t\t\t\t    ie->indirect_info->offset,\n+\t\t\t\t\t\t    ie->indirect_info->by_ref);\n     }\n   else\n     target = scalar;\n@@ -3861,15 +3833,14 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n     {\n       tree vtable;\n       unsigned HOST_WIDE_INT offset;\n-      tree scalar = (jfunc->type == IPA_JF_CONST) ? ipa_get_jf_constant (jfunc)\n-\t: NULL;\n-      ipa_agg_value_set agg = ipa_agg_value_set_from_jfunc (new_root_info,\n-\t\t\t\t\t\t\t    new_root,\n-\t\t\t\t\t\t\t    &jfunc->agg);\n-      tree t = ipa_find_agg_cst_for_param (&agg, scalar,\n-\t\t\t\t\t   ie->indirect_info->offset,\n-\t\t\t\t\t   true);\n-      agg.release ();\n+      tree t = NULL_TREE;\n+      if (jfunc->type == IPA_JF_CONST)\n+\tt = ipa_find_agg_cst_from_init (ipa_get_jf_constant (jfunc),\n+\t\t\t\t\tie->indirect_info->offset, true);\n+      if (!t)\n+\tt = ipa_find_agg_cst_from_jfunc_items (&jfunc->agg, new_root_info,\n+\t\t\t\t\t       new_root,\n+\t\t\t\t\t       ie->indirect_info->offset, true);\n       if (t && vtable_pointer_value_to_vtable (t, &vtable, &offset))\n \t{\n \t  bool can_refer;\n@@ -6064,21 +6035,4 @@ ipcp_transform_function (struct cgraph_node *node)\n }\n \n \n-/* Return true if OTHER describes same agg value.  */\n-bool\n-ipa_agg_value::equal_to (const ipa_agg_value &other)\n-{\n-  return offset == other.offset\n-\t && operand_equal_p (value, other.value, 0);\n-}\n-\n-/* Destructor also removing individual aggregate values.  */\n-\n-ipa_auto_call_arg_values::~ipa_auto_call_arg_values ()\n-{\n-  ipa_release_agg_values (m_known_aggs, false);\n-}\n-\n-\n-\n #include \"gt-ipa-prop.h\""}, {"sha": "0ba6ded476404508863cd8bb4c986200b8f43448", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 37, "deletions": 135, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "patch": "@@ -190,6 +190,8 @@ struct GTY(()) ipa_agg_jump_function\n };\n \n class ipcp_transformation;\n+class ipa_auto_call_arg_values;\n+class ipa_call_arg_values;\n \n /* Element of a vector describing aggregate values for a number of arguments in\n    a particular context, be it a call or the aggregate constants that a node is\n@@ -224,6 +226,8 @@ class ipa_argagg_value_list\n   ipa_argagg_value_list (const vec<ipa_argagg_value> *values)\n     : m_elts (*values)\n   {}\n+  ipa_argagg_value_list (const ipa_auto_call_arg_values *aavals);\n+  ipa_argagg_value_list (const ipa_call_arg_values *gavals);\n   ipa_argagg_value_list (const ipcp_transformation *tinfo);\n \n   /* Return the aggregate constant stored for INDEX at UNIT_OFFSET, if it is\n@@ -243,12 +247,22 @@ class ipa_argagg_value_list\n \n   const ipa_argagg_value *get_elt (int index, unsigned unit_offset) const;\n \n+\n   /* Return the first item describing a constant stored for parameter with\n      INDEX, regardless of offset or reference, or NULL if there is no such\n      constant.  */\n \n   const ipa_argagg_value *get_elt_for_index (int index) const;\n \n+  /* Return true if there is an aggregate constant referring to a value passed\n+     in or by parameter with INDEX (at any offset, whether by reference or\n+     not).  */\n+\n+  bool value_for_index_p (int index) const\n+  {\n+    return !!get_elt_for_index (index);\n+  }\n+\n   /* Return true if all elements present in OTHER are also present in this\n      list.  */\n \n@@ -275,105 +289,6 @@ class ipa_argagg_value_list\n   array_slice<const ipa_argagg_value> m_elts;\n };\n \n-/* An element in an aggregate part describing a known value at a given offset.\n-   All unlisted positions are assumed to be unknown and all listed values must\n-   fulfill is_gimple_ip_invariant.  */\n-\n-struct ipa_agg_value\n-{\n-  /* The offset at which the known value is located within the aggregate.  */\n-  HOST_WIDE_INT offset;\n-\n-  /* The known constant.  */\n-  tree value;\n-\n-  /* Return true if OTHER describes same agg value.  */\n-  bool equal_to (const ipa_agg_value &other);\n-};\n-\n-/* Structure describing a set of known offset/value for aggregate.  */\n-\n-struct ipa_agg_value_set\n-{\n-  /* Description of the individual item.  */\n-  vec<ipa_agg_value> items;\n-  /* True if the data was passed by reference (as opposed to by value).  */\n-  bool by_ref;\n-\n-  /* Return true if OTHER describes same agg values.  */\n-  bool equal_to (const ipa_agg_value_set &other)\n-  {\n-    if (by_ref != other.by_ref)\n-      return false;\n-    if (items.length () != other.items.length ())\n-      return false;\n-    for (unsigned int i = 0; i < items.length (); i++)\n-      if (!items[i].equal_to (other.items[i]))\n-\treturn false;\n-    return true;\n-  }\n-\n-  /* Return true if there is any value for aggregate.  */\n-  bool is_empty () const\n-  {\n-    return items.is_empty ();\n-  }\n-\n-  ipa_agg_value_set copy () const\n-  {\n-    ipa_agg_value_set new_copy;\n-\n-    new_copy.items = items.copy ();\n-    new_copy.by_ref = by_ref;\n-\n-    return new_copy;\n-  }\n-\n-  void release ()\n-  {\n-    items.release ();\n-  }\n-};\n-\n-/* Return copy of a vec<ipa_agg_value_set>.  */\n-\n-static inline vec<ipa_agg_value_set>\n-ipa_copy_agg_values (const vec<ipa_agg_value_set> &aggs)\n-{\n-  vec<ipa_agg_value_set> aggs_copy = vNULL;\n-\n-  if (!aggs.is_empty ())\n-    {\n-      ipa_agg_value_set *agg;\n-      int i;\n-\n-      aggs_copy.reserve_exact (aggs.length ());\n-\n-      FOR_EACH_VEC_ELT (aggs, i, agg)\n-\taggs_copy.quick_push (agg->copy ());\n-    }\n-\n-  return aggs_copy;\n-}\n-\n-/* For vec<ipa_agg_value_set>, DO NOT call release(), use below function\n-   instead.  Because ipa_agg_value_set contains a field of vector type, we\n-   should release this child vector in each element before reclaiming the\n-   whole vector.  */\n-\n-static inline void\n-ipa_release_agg_values (vec<ipa_agg_value_set> &aggs,\n-\t\t\tbool release_vector = true)\n-{\n-  ipa_agg_value_set *agg;\n-  int i;\n-\n-  FOR_EACH_VEC_ELT (aggs, i, agg)\n-    agg->release ();\n-  if (release_vector)\n-    aggs.release ();\n-}\n-\n /* Information about zero/non-zero bits.  */\n class GTY(()) ipa_bits\n {\n@@ -551,44 +466,38 @@ ipa_get_jf_ancestor_keep_null (struct ipa_jump_func *jfunc)\n class ipa_auto_call_arg_values\n {\n public:\n-  ~ipa_auto_call_arg_values ();\n-\n   /* If m_known_vals (vector of known \"scalar\" values) is sufficiantly long,\n      return its element at INDEX, otherwise return NULL.  */\n   tree safe_sval_at (int index)\n   {\n-    /* TODO: Assert non-negative index here and test.  */\n     if ((unsigned) index < m_known_vals.length ())\n       return m_known_vals[index];\n     return NULL;\n   }\n \n-  /* If m_known_aggs is sufficiantly long, return the pointer rto its element\n-     at INDEX, otherwise return NULL.  */\n-  ipa_agg_value_set *safe_aggval_at (int index)\n-  {\n-    /* TODO: Assert non-negative index here and test.  */\n-    if ((unsigned) index < m_known_aggs.length ())\n-      return &m_known_aggs[index];\n-    return NULL;\n-  }\n-\n   /* Vector describing known values of parameters.  */\n   auto_vec<tree, 32> m_known_vals;\n \n   /* Vector describing known polymorphic call contexts.  */\n   auto_vec<ipa_polymorphic_call_context, 32> m_known_contexts;\n \n   /* Vector describing known aggregate values.  */\n-  auto_vec<ipa_agg_value_set, 32> m_known_aggs;\n+  auto_vec<ipa_argagg_value, 32> m_known_aggs;\n \n   /* Vector describing known value ranges of arguments.  */\n   auto_vec<value_range, 32> m_known_value_ranges;\n };\n \n+inline\n+ipa_argagg_value_list\n+::ipa_argagg_value_list (const ipa_auto_call_arg_values *aavals)\n+  : m_elts (aavals->m_known_aggs)\n+{}\n+\n /* Class bundling the various potentially known properties about actual\n    arguments of a particular call.  This variant does not deallocate the\n-   bundled data in any way.  */\n+   bundled data in any way as the vectors can either be pointing to vectors in\n+   ipa_auto_call_arg_values or be allocated independently.  */\n \n class ipa_call_arg_values\n {\n@@ -613,35 +522,29 @@ class ipa_call_arg_values\n      return its element at INDEX, otherwise return NULL.  */\n   tree safe_sval_at (int index)\n   {\n-    /* TODO: Assert non-negative index here and test.  */\n     if ((unsigned) index < m_known_vals.length ())\n       return m_known_vals[index];\n     return NULL;\n   }\n \n-  /* If m_known_aggs is sufficiantly long, return the pointer rto its element\n-     at INDEX, otherwise return NULL.  */\n-  ipa_agg_value_set *safe_aggval_at (int index)\n-  {\n-    /* TODO: Assert non-negative index here and test.  */\n-    if ((unsigned) index < m_known_aggs.length ())\n-      return &m_known_aggs[index];\n-    return NULL;\n-  }\n-\n   /* Vector describing known values of parameters.  */\n   vec<tree> m_known_vals = vNULL;\n \n   /* Vector describing known polymorphic call contexts.  */\n   vec<ipa_polymorphic_call_context> m_known_contexts = vNULL;\n \n   /* Vector describing known aggregate values.  */\n-  vec<ipa_agg_value_set> m_known_aggs = vNULL;\n+  vec<ipa_argagg_value> m_known_aggs = vNULL;\n \n   /* Vector describing known value ranges of arguments.  */\n   vec<value_range> m_known_value_ranges = vNULL;\n };\n \n+inline\n+ipa_argagg_value_list\n+::ipa_argagg_value_list (const ipa_call_arg_values *gavals)\n+  : m_elts (gavals->m_known_aggs)\n+{}\n \n /* Summary describing a single formal parameter.  */\n \n@@ -1190,9 +1093,6 @@ bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \t\t\t\t   ipa_call_arg_values *avals,\n \t\t\t\t   bool *speculative);\n-tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t\t   ipa_auto_call_arg_values *avals,\n-\t\t\t\t   bool *speculative);\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n \t\t\t\t\t\t    bool speculative = false);\n tree ipa_impossible_devirt_target (struct cgraph_edge *, tree);\n@@ -1204,9 +1104,8 @@ ipa_bits *ipa_get_ipa_bits_for_value (const widest_int &value,\n void ipa_analyze_node (struct cgraph_node *);\n \n /* Aggregate jump function related functions.  */\n-tree ipa_find_agg_cst_for_param (const ipa_agg_value_set *agg, tree scalar,\n-\t\t\t\t HOST_WIDE_INT offset, bool by_ref,\n-\t\t\t\t bool *from_global_constant = NULL);\n+tree ipa_find_agg_cst_from_init (tree scalar, HOST_WIDE_INT offset,\n+\t\t\t\t bool by_ref);\n bool ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n \t\t\t     vec<ipa_param_descriptor, va_gc> *descriptors,\n \t\t\t     gimple *stmt, tree op, int *index_p,\n@@ -1243,16 +1142,19 @@ void ipcp_read_transformation_summaries (void);\n int ipa_get_param_decl_index (class ipa_node_params *, tree);\n tree ipa_value_from_jfunc (class ipa_node_params *info,\n \t\t\t   struct ipa_jump_func *jfunc, tree type);\n+tree ipa_agg_value_from_jfunc (ipa_node_params *info, cgraph_node *node,\n+\t\t\t       const ipa_agg_jf_item *item);\n unsigned int ipcp_transform_function (struct cgraph_node *node);\n ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,\n \t\t\t\t\t\t     cgraph_edge *,\n \t\t\t\t\t\t     int,\n \t\t\t\t\t\t     ipa_jump_func *);\n value_range ipa_value_range_from_jfunc (ipa_node_params *, cgraph_edge *,\n \t\t\t\t\tipa_jump_func *, tree);\n-ipa_agg_value_set ipa_agg_value_set_from_jfunc (ipa_node_params *,\n-\t\t\t\t\t\tcgraph_node *,\n-\t\t\t\t\t\tipa_agg_jump_function *);\n+void ipa_push_agg_values_from_jfunc (ipa_node_params *info, cgraph_node *node,\n+\t\t\t\t     ipa_agg_jump_function *agg_jfunc,\n+\t\t\t\t     unsigned dst_index,\n+\t\t\t\t     vec<ipa_argagg_value> *res);\n void ipa_dump_param (FILE *, class ipa_node_params *info, int i);\n void ipa_release_body_info (struct ipa_func_body_info *);\n tree ipa_get_callee_param_type (struct cgraph_edge *e, int i);"}]}