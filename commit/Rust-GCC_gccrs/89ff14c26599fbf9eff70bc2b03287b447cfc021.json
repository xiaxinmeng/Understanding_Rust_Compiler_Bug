{"sha": "89ff14c26599fbf9eff70bc2b03287b447cfc021", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmZjE0YzI2NTk5ZmJmOWVmZjcwYmMyYjAzMjg3YjQ0N2NmYzAyMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-11-29T15:58:05Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-11-29T15:58:05Z"}, "message": "haifa-sched.c (recompute_todo_spec): Simplify and correct the code checking for a clobber of a condition register...\n\n\t* haifa-sched.c (recompute_todo_spec): Simplify and correct the\n\tcode checking for a clobber of a condition register when deciding\n\twhether to predicate.\n\nFrom-SVN: r181806", "tree": {"sha": "9ed8ffdc66f0c8e75d56bfa860fedc60e86bb452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ed8ffdc66f0c8e75d56bfa860fedc60e86bb452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89ff14c26599fbf9eff70bc2b03287b447cfc021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ff14c26599fbf9eff70bc2b03287b447cfc021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ff14c26599fbf9eff70bc2b03287b447cfc021", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ff14c26599fbf9eff70bc2b03287b447cfc021/comments", "author": null, "committer": null, "parents": [{"sha": "4d5ae4eadc00c0fc843735d39c56a58f0107c972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5ae4eadc00c0fc843735d39c56a58f0107c972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d5ae4eadc00c0fc843735d39c56a58f0107c972"}], "stats": {"total": 45, "additions": 19, "deletions": 26}, "files": [{"sha": "9a6765d4dec33ffd1ef8e62ed48b4bc158ebf6a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ff14c26599fbf9eff70bc2b03287b447cfc021/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ff14c26599fbf9eff70bc2b03287b447cfc021/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89ff14c26599fbf9eff70bc2b03287b447cfc021", "patch": "@@ -1,3 +1,9 @@\n+2011-11-29  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* haifa-sched.c (recompute_todo_spec): Simplify and correct the\n+\tcode checking for a clobber of a condition register when deciding\n+\twhether to predicate.\n+\n 2011-11-29   Diego Novillo  <dnovillo@google.com>\n \n \t* gimple.c (gimple_call_set_cannot_inline): Move from gimple.h."}, {"sha": "4db23139b10105cd4d51a2416d5aef100b93800f", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ff14c26599fbf9eff70bc2b03287b447cfc021/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ff14c26599fbf9eff70bc2b03287b447cfc021/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=89ff14c26599fbf9eff70bc2b03287b447cfc021", "patch": "@@ -1178,33 +1178,20 @@ recompute_todo_spec (rtx next)\n       regno = REGNO (XEXP (cond, 0));\n \n       /* Find the last scheduled insn that modifies the condition register.\n-\t If we have a true dependency on it, it sets it to the correct value,\n-\t otherwise it must be a later insn scheduled in-between that clobbers\n-\t the condition.  */\n-      FOR_EACH_VEC_ELT_REVERSE (rtx, scheduled_insns, i, prev)\n-\t{\n-\t  sd_iterator_def sd_it;\n-\t  dep_t dep;\n-\t  HARD_REG_SET t;\n-\t  bool found;\n-\n-\t  find_all_hard_reg_sets (prev, &t);\n-\t  if (!TEST_HARD_REG_BIT (t, regno))\n-\t    continue;\n+\t We can stop looking once we find the insn we depend on through the\n+\t REG_DEP_CONTROL; if the condition register isn't modified after it,\n+\t we know that it still has the right value.  */\n+      if (QUEUE_INDEX (pro) == QUEUE_SCHEDULED)\n+\tFOR_EACH_VEC_ELT_REVERSE (rtx, scheduled_insns, i, prev)\n+\t  {\n+\t    HARD_REG_SET t;\n \n-\t  found = false;\n-\t  FOR_EACH_DEP (next, SD_LIST_RES_BACK, sd_it, dep)\n-\t    {\n-\t      if (DEP_PRO (dep) == prev && DEP_TYPE (dep) == REG_DEP_TRUE)\n-\t\t{\n-\t\t  found = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (!found)\n-\t    return HARD_DEP;\n-\t  break;\n-\t}\n+\t    find_all_hard_reg_sets (prev, &t);\n+\t    if (TEST_HARD_REG_BIT (t, regno))\n+\t      return HARD_DEP;\n+\t    if (prev == pro)\n+\t      break;\n+\t  }\n       if (ORIG_PAT (next) == NULL_RTX)\n \t{\n \t  ORIG_PAT (next) = PATTERN (next);"}]}