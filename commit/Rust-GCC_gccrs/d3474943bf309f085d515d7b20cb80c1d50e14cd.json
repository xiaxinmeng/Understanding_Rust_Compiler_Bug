{"sha": "d3474943bf309f085d515d7b20cb80c1d50e14cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM0NzQ5NDNiZjMwOWYwODVkNTE1ZDdiMjBjYjgwYzFkNTBlMTRjZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-04-21T01:18:16Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-04-21T01:18:16Z"}, "message": "Fix for PR java.io/204:\n\n\t* java/io/PipedInputStream.java, java/io/PipedReader.java,\n\tjava/io/PipedOutputStream.java, java/io/PipedWriter.java: Imported\n\tfrom Classpath.\n\nFrom-SVN: r33300", "tree": {"sha": "dec5c6d7c3d3c314853e857fd39856ceb50ec5db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dec5c6d7c3d3c314853e857fd39856ceb50ec5db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3474943bf309f085d515d7b20cb80c1d50e14cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3474943bf309f085d515d7b20cb80c1d50e14cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3474943bf309f085d515d7b20cb80c1d50e14cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3474943bf309f085d515d7b20cb80c1d50e14cd/comments", "author": null, "committer": null, "parents": [{"sha": "21caf59006e2c7dd06bf9840a7fc3cea321282f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21caf59006e2c7dd06bf9840a7fc3cea321282f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21caf59006e2c7dd06bf9840a7fc3cea321282f7"}], "stats": {"total": 1999, "additions": 1431, "deletions": 568}, "files": [{"sha": "d5e16880ad694d4af803036a9ec59beb4995dff7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d3474943bf309f085d515d7b20cb80c1d50e14cd", "patch": "@@ -1,5 +1,10 @@\n 2000-04-20  Tom Tromey  <tromey@cygnus.com>\n \n+\tFix for PR java.io/204:\n+\t* java/io/PipedInputStream.java, java/io/PipedReader.java,\n+\tjava/io/PipedOutputStream.java, java/io/PipedWriter.java: Imported\n+\tfrom Classpath.\n+\n \tFix for PR libgcj/212:\n \t* gcj/javaprims.h (_Jv_word, _Jv_word2): Removed definitions.\n \t* include/jvm.h (_Jv_word, _Jv_word2): Define."}, {"sha": "d1081a2ce3d9bd15a152513ade59a850c558e991", "filename": "libjava/java/io/PipedInputStream.java", "status": "modified", "additions": 520, "deletions": 212, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedInputStream.java?ref=d3474943bf309f085d515d7b20cb80c1d50e14cd", "patch": "@@ -1,242 +1,550 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* PipedInputStream.java -- Input stream that reads from an output stream\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.io;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 29, 1998.  \n+  * This class is an input stream that reads its bytes from an output stream\n+  * to which it is connected. \n+  * <p>\n+  * Data is read and written to an internal buffer.  It is highly recommended\n+  * that the <code>PipedInputStream</code> and connected <code>PipedOutputStream</code>\n+  * be part of different threads.  If they are not, there is a possibility\n+  * that the read and write operations could deadlock their thread.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class PipedInputStream extends InputStream\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Class Variables\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n+\n+/**\n+  * The size of the internal buffer used for input/output.  Note that this\n+  * can be overriden by setting the system property \n+  * <code>gnu.java.io.PipedInputStream.pipe_size</code> to the desired size shown \n+  * in bytes.  This is not a standard part of the class library.  Note that \n+  * since this variable is <code>final</code>, it cannot be changed to refect \n+  * the size specified in the property.\n+  * <p>\n+  * The value for this variable is 2048.\n+  */\n+protected static final int PIPE_SIZE = 2048;\n+\n+/**\n+  * This is the real pipe size.  It defaults to PIPE_SIZE, unless overridden\n+  * by use of the system property <code>gnu.java.io.PipedInputStream.pipe_size</code>.\n+  */\n+private static int pipe_size;\n+\n+/**\n+  * This variable indicates whether or not the <code>read()</code> method will attempt\n+  * return a short count if this will possibly keep the stream from blocking.  \n+  * The default for this is <code>false</code> because that is what what the JDK seems\n+  * to imply in its javadocs.  We set this to <code>false</code> if the system \n+  * property <code>gnu.java.io.try_not_to_block</code> is set.\n+  */\n+private static boolean try_not_to_block = false;\n+\n+static\n+{\n+  pipe_size = Integer.getInteger(\"gnu.java.io.PipedInputStream.pipe_size\",\n+                                 PIPE_SIZE).intValue();\n+\n+  String block_prop = System.getProperty(\"gnu.java.io.try_not_to_block\");\n+  if (block_prop != null)\n+    try_not_to_block = true;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n  */\n- \n-public class PipedInputStream extends InputStream\n+\n+/**\n+  * This is the internal circular buffer used for storing bytes written\n+  * to the pipe and from which bytes are read by this stream\n+  */\n+protected byte[] buffer = new byte[pipe_size];\n+\n+/**\n+  * The index into buffer where the bytes written byte the connected\n+  * <code>PipedOutputStream</code> will be written.  If this variables is less\n+  * than 0, then the buffer is empty.  If this variable is equal to \n+  * <code>out</code>, then the buffer is full\n+  */\n+protected int in = -1;\n+\n+/**\n+  * This index into the buffer where bytes will be read from.\n+  */\n+protected int out = 0;\n+\n+/**\n+  * This variable is <code>true</code> if this object has ever been connected\n+  * to a <code>PipedOutputStream</code>, and <code>false</code> otherwise.  It is used\n+  * to detect an attempt to connect an already connected stream or to\n+  * otherwise use the stream before it is connected.\n+  */\n+private boolean ever_connected = false;\n+\n+/**\n+  * This variable is set to <code>true</code> if the <code>close()</code> method is\n+  * called.  This value is checked prevents a caller from re-opening the\n+  * stream.\n+  */\n+private boolean closed = false;\n+\n+/**\n+  * This variable is the PipedOutputStream to which this stream is connected.\n+  */\n+PipedOutputStream src;\n+\n+/**\n+  * Used by <code>read()</code> to call an overloaded method\n+  */\n+private byte[] read_buf = new byte[1];\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This constructor creates a new <code>PipedInputStream</code> that is not \n+  * connected to a <code>PipedOutputStream</code>.  It must be connected before\n+  * bytes can be read from this stream.\n+  */\n+public\n+PipedInputStream()\n {\n-  /* The size of the pipe's circular input buffer. */\n-  protected static final int PIPE_SIZE = 1024;\n+  return;\n+}\n \n-  /* The circular buffer into which incoming data is placed. */\n-  protected byte[] buffer;\n+/*************************************************************************/\n \n-  /* The index in the buffer at which the next byte of data will be stored. */\n-  protected int in = -1;\n+/**\n+  * This constructor creates a new <code>PipedInputStream</code> and connects\n+  * it to the passed in <code>PipedOutputStream</code>. The stream is then read\n+  * for reading.\n+  *\n+  * @param src The <code>PipedOutputStream</code> to connect this stream to\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public\n+PipedInputStream(PipedOutputStream src) throws IOException\n+{\n+  connect(src);\n+}\n \n-  /* The index in the buffer at which the next byte of data will be read. */\n-  protected int out = 0;\n+/*************************************************************************/\n \n-  /* The output stream this is connected to; used to check for errors. */\n-  private PipedOutputStream po = null;\n+/*\n+ * Instance Variables\n+ */\n \n-  /* Flag to indicate that the output stream was closed. */\n-  private boolean outClosed = false;\n+/**\n+  * This method connects this stream to the passed in <code>PipedOutputStream</code>.\n+  * This stream is then ready for reading.  If this stream is already\n+  * connected or has been previously closed, then an exception is thrown\n+  *\n+  * @param src The <code>PipedOutputStream</code> to connect this stream to\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+connect(PipedOutputStream src) throws IOException\n+{\n+  if (src == this.src)\n+    return;\n \n-  public PipedInputStream(PipedOutputStream src) throws IOException\n-  {\n-    buffer = new byte[PIPE_SIZE];\n-    connect(src);\n-  }\n+  if (ever_connected)\n+    throw new IOException(\"Already connected\");\n \n-  public PipedInputStream()\n-  {\n-    buffer = new byte[PIPE_SIZE];\n-  }\n+  if (closed)\n+    throw new IOException(\"Stream is closed and cannot be reopened\");\n \n-  public synchronized int available() throws IOException\n-  {\n-    if (in < 0)\n-      return 0;\n+  src.connect(this);\n \n-    if (in > out)\n-      return in - out;\n+  ever_connected = true;\n+}\n \n-    // Buffer has wrapped around.\n-    return buffer.length - out + in;\n-  }\n+/*************************************************************************/\n \n-  public void close() throws IOException\n-  {\n-    buffer = null;\n-    po = null;\n+/**\n+  * This methods closes the stream so that no more data can be read\n+  * from it.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+close() throws IOException\n+{\n+  closed = true;\n+  notifyAll();\n+}\n \n-    // Mark as empty for available method.\n-    in = -1;\n-  }\n+/*************************************************************************/\n \n-  public void connect(PipedOutputStream src) throws IOException\n-  {\n-    if (buffer == null)\n-      throw new IOException(\"pipe closed\");\n+/**\n+  * This method returns the number of bytes that can be read from this stream\n+  * before blocking could occur.  This is the number of bytes that are\n+  * currently unread in the internal circular buffer.  Note that once this\n+  * many additional bytes are read, the stream may block on a subsequent\n+  * read, but it not guaranteed to block.\n+  *\n+  * @return The number of bytes that can be read before blocking might occur\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized int\n+available() throws IOException\n+{\n+  if (in == -1)\n+    return(0);\n+  else if (in > out)\n+    return(in - out);\n+  else\n+    return(in + (pipe_size - out));\n+}\n \n-    if (po != null)\n-      if (po == src)\n-\treturn;\n-      else\n-        throw new IOException(\"pipe already connected\");\n+/*************************************************************************/\n+\n+/**\n+  * Reads the next byte from the stream.  The byte read is returned as\n+  * and int in the range of 0-255.  If a byte cannot be read because of an\n+  * end of stream condition, -1 is returned.  If the stream is already\n+  * closed, an IOException will be thrown.\n+  *  <code>\n+  * This method will block if no bytes are available to be read.\n+  *\n+  * @return The byte read or -1 if end of stream.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized int\n+read() throws IOException\n+{\n+  // Method operates by calling the multibyte overloaded read method\n+  // Note that read_buf is an internal instance variable.  I allocate it\n+  // there to avoid constant reallocation overhead for applications that\n+  // call this method in a loop at the cost of some unneeded overhead\n+  // if this method is never called.\n+ \n+  int bytes_read = read(read_buf, 0, read_buf.length);\n+\n+  if (bytes_read == -1)\n+    return(-1);\n+  else\n+    return((read_buf[0] & 0xFF));\n+}\n+\n+/*************************************************************************/\n \n-    po = src;\n-    try\n+/**\n+  * This method reads bytes from the stream into a caller supplied buffer.\n+  * It starts storing bytes at position <code>offset</code> into the buffer and\n+  * reads a maximum of <cod>>len</code> bytes.  Note that this method can actually\n+  * read fewer than <code>len</code> bytes.  The actual number of bytes read is\n+  * returned.  A -1 is returned to indicated that no bytes can be read\n+  * because the end of the stream was reached.  If the stream is already\n+  * closed, a -1 will again be returned to indicate the end of the stream.\n+  * <p>\n+  * This method will block if no bytes are available to be read.\n+  *\n+  * @param buf The buffer into which bytes will be stored\n+  * @param offset The index into the buffer at which to start writing.\n+  * @param len The maximum number of bytes to read.\n+  */\n+public synchronized int\n+read(byte[] buf, int offset, int len) throws IOException\n+{\n+  if (!ever_connected)\n+    throw new IOException(\"Not connected\"); \n+\n+  int bytes_read = 0;\n+  for (;;)\n     {\n-      src.connect(this);\n-    }\n-    catch (IOException ex)\n+      // If there are bytes, take them\n+      if (in != -1)\n+        {\n+          int desired_bytes = len - bytes_read;\n+\n+          // We are in a \"wrap\" condition\n+          if (out > in)\n+            {\n+              if (desired_bytes > (pipe_size - out))\n+                {\n+                  if (in == 0)\n+                    desired_bytes = (pipe_size - out) - 1;\n+                  else\n+                    desired_bytes = pipe_size - out;\n+\n+                  System.arraycopy(buffer, out, buf, offset + bytes_read,\n+                                   desired_bytes);\n+\n+                  bytes_read += desired_bytes;\n+                  out += desired_bytes;\n+                  desired_bytes = len - bytes_read;\n+\n+                  if (out == pipe_size)\n+                    out = 0;\n+\n+                  notifyAll();\n+                }\n+              else\n+                {\n+                  if ((out + desired_bytes) == in)\n+                    --desired_bytes;\n+\n+                  if (((out + desired_bytes) == pipe_size) && (in == 0)) \n+                    desired_bytes = (pipe_size - out) - 1;\n+\n+                  System.arraycopy(buffer, out, buf, offset + bytes_read,\n+                                   desired_bytes); \n+\n+                  bytes_read += desired_bytes;\n+                  out += desired_bytes;\n+                  desired_bytes = len - bytes_read;\n+\n+                  if (out == pipe_size)\n+                    out = 0;\n+\n+                  notifyAll();\n+                }\n+            }\n+ \n+          // We are in a \"no wrap\" or condition (can also be fall through\n+          // from above\n+          if (in > out)\n+            {\n+              if (desired_bytes >= ((in - out) - 1))\n+                desired_bytes = (in - out) - 1;\n+\n+              System.arraycopy(buffer, out, buf, offset + bytes_read, \n+                               desired_bytes);\n+\n+              bytes_read += desired_bytes;\n+              out += desired_bytes;\n+              desired_bytes = len - bytes_read;\n+\n+              if (out == pipe_size)\n+                out = 0;\n+\n+              notifyAll();\n+            }\n+        }\n+\n+      // If we are done, return\n+      if (bytes_read == len)\n+        return(bytes_read);\n+\n+      // Return a short count if necessary\n+      if (bytes_read < len)\n+        if (try_not_to_block)\n+           return(bytes_read);\n+\n+      // Handle the case where the end of stream was encountered.\n+      if (closed)\n+        {\n+          // We never let in == out so there might be one last byte\n+          // available that we have not copied yet.\n+          if (in != -1)\n+            {\n+              buf[offset + bytes_read] = buffer[out];\n+              in = -1;\n+              ++out;\n+              ++bytes_read;\n+            }\n+\n+          if (bytes_read != 0)\n+            return(bytes_read);\n+          else\n+            return(-1);\n+        }\n+\n+      // Wait for a byte to be read\n+      try\n+        {\n+          wait();\n+        }\n+      catch(InterruptedException e) { ; }\n+    } \n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method receives a byte of input from the source PipedOutputStream.\n+  * If there is no data ready to be written, or if the internal circular\n+  * buffer is full, this method blocks.\n+  *\n+  * *****What is this method really supposed to do *********\n+  */\n+protected synchronized void\n+receive(int byte_received) throws IOException\n+{\n+  int orig_in = in;\n+\n+  for (;;)\n     {\n-      po = null;\n-      throw ex;\n+      // Wait for something to happen\n+      try\n+        {\n+          wait();\n+        }\n+      catch(InterruptedException e) { ; }\n+\n+      // See if we woke up because the stream was closed on us\n+      if (closed)\n+        throw new IOException(\"Stream closed before receiving byte\");\n+\n+      // See if a byte of data was received\n+      if (in != orig_in)\n+        return;\n     }\n-  }\n-\n-  public synchronized int read() throws IOException\n-  {\n-    // TBD: Spec says to throw IOException if thread writing to output stream\n-    // died.  What does this really mean?  Theoretically, multiple threads\n-    // could be writing to this object.  Do you track the first, last, or\n-    // all of them?\n-    if (po == null)\n-      if (buffer == null)\n-        throw new IOException(\"pipe closed\");\n-      else\n-        throw new IOException(\"pipe unconnected\");\n+}\n \n-    // Block until there's something to read or output stream was closed.\n-    while (in < 0)\n-      try\n-\t{\n-\t  if (outClosed)\n-\t    return -1;\n-\t  wait();\n-\t}\n-      catch (InterruptedException ex)\n-       {\n-\t throw new InterruptedIOException();\n-       }\n-\n-    // Let other threads know there's room to write now.\n-    notifyAll();\n-\n-    int retval = buffer[out++] & 0xFF;\n-\n-    // Wrap back around if at end of the array.\n-    if (out >= buffer.length)\n-      out = 0;\n-\n-    // When the last byte available is read, mark the buffer as empty.\n-    if (out == in)\n-      {\n-        in = -1;\n-\tout = 0;\n-      }\n-      \n-    return retval;\n-  }\n-\n-  public synchronized int read(byte[] b, int off, int len) throws IOException\n-  {\n-    if (off < 0 || len < 0 || off + len > b.length)\n-      throw new ArrayIndexOutOfBoundsException();\n-\n-    // TBD: Spec says to throw IOException if thread writing to output stream\n-    // died.  What does this really mean?  Theoretically, multiple threads\n-    // could be writing to this object.  Do you track the first, last, or\n-    // all of them?\n-    if (po == null)\n-      if (buffer == null)\n-        throw new IOException(\"pipe closed\");\n-      else\n-        throw new IOException(\"pipe unconnected\");\n+/*************************************************************************/\n \n-    // Block until there's something to read or output stream was closed.\n-    while (in < 0)\n-      try\n-\t{\n-\t  if (outClosed)\n-\t    return -1;\n-\t  wait();\n-\t}\n-      catch (InterruptedException ex)\n-       {\n-\t throw new InterruptedIOException();\n-       }\n-\n-    // Let other threads know there's room to write now.\n-    notifyAll();\n-\n-    int numRead;\n-    len = Math.min(len, available());\n-    if (in <= out && len >= (numRead = buffer.length - out))\n-      {\n-\t// Buffer has wrapped around; need to copy in 2 steps.\n-\t// Copy to the end of the buffer first; second copy may be of zero\n-\t// bytes but that is ok.  Doing it that way saves having to check\n-\t// later if 'out' has grown to buffer.length.\n-        System.arraycopy(buffer, out, b, off, numRead);\n-\tlen -= numRead;\n-\toff += numRead;\n-\tout = 0;\n-      }\n-    else\n-      numRead = 0;\n-\n-    System.arraycopy(buffer, out, b, off, len);\n-    numRead += len;\n-    out += len;\n-\n-    // When the last byte available is read, mark the buffer as empty.\n-    if (out == in)\n-      {\n-        in = -1;\n-\tout = 0;\n-      }\n-\n-    return numRead;\n-  }\n-\n-  protected synchronized void receive(int b) throws IOException\n-  {\n-    if (buffer == null)\n-      throw new IOException(\"pipe closed\");\n-\n-    // TBD: Spec says to throw IOException if thread reading from input stream\n-    // died.  What does this really mean?  Theoretically, multiple threads\n-    // could be reading to this object (why else would 'read' be synchronized?).\n-    // Do you track the first, last, or all of them?\n-\n-    if (b < 0)\n-      {\n-        outClosed = true;\n-\tnotifyAll();\t// In case someone was blocked in a read.\n-\treturn;\n-      }\n-\n-    // Block until there's room in the pipe.\n-    while (in == out)\n-      try\n-\t{\n-\t  wait();\n-\t}\n-      catch (InterruptedException ex)\n-       {\n-\t throw new InterruptedIOException();\n-       }\n-\n-    // Check if buffer is empty.\n-    if (in < 0)\n-      in = 0;\n-\n-    buffer[in++] = (byte) b;\n-\n-    // Wrap back around if at end of the array.\n-    if (in >= buffer.length)\n-      in = 0;\n-\n-    // Let other threads know there's something to read when this returns.\n-    notifyAll();\n-  }\n+/**\n+  * This method is used by the connected <code>PipedOutputStream</code> to\n+  * write bytes into the buffer.  It uses this method instead of directly\n+  * writing the bytes in order to obtain ownership of the object's monitor\n+  * for the purposes of calling <code>notify</code>.\n+  *\n+  * @param buf The array containing bytes to write to this stream\n+  * @param offset The offset into the array to start writing from\n+  * @param len The number of bytes to write.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+synchronized void\n+write(byte[] buf, int offset, int len) throws IOException\n+{\n+  if (len <= 0)\n+    return;\n+\n+  int total_written = 0;\n+  while (total_written < len)\n+    {\n+      // If we are not at the end of the buffer with out = 0\n+      if (!((in == (buffer.length - 1)) && (out == 0)))\n+        {\n+          // This is the \"no wrap\" situation\n+          if ((in - 1) >= out)\n+            {\n+              int bytes_written = 0;\n+              if ((buffer.length - in) > (len - total_written))\n+                bytes_written = (len - total_written);\n+              else if (out == 0)\n+                bytes_written = (buffer.length - in) - 1;\n+              else \n+                bytes_written = (buffer.length - in);\n+\n+              if (bytes_written > 0) \n+                System.arraycopy(buf, offset + total_written, buffer, in, \n+                                 bytes_written);\n+              total_written += bytes_written;\n+              in += bytes_written;\n+\n+              if (in == buffer.length)\n+                in = 0;\n+\n+              notifyAll();\n+            }\n+          // This is the \"wrap\" situtation\n+          if ((out > in) && (total_written != len))\n+            {\n+              int bytes_written = 0;\n+\n+              // Do special processing if we are at the beginning\n+              if (in == -1)\n+                {\n+                  in = 0;\n+\n+                  if (buffer.length > len)\n+                    bytes_written = len;\n+                  else\n+                    bytes_written = buffer.length - 1;\n+                }\n+              else if (((out - in) - 1) < (len - total_written))\n+                {\n+                  bytes_written = (out - in) - 1;\n+                }\n+              else\n+                {\n+                  bytes_written = len - total_written;\n+                }\n+\n+              // If the buffer is full, wait for it to empty out\n+              if ((out - 1) == in)\n+                {\n+                  try\n+                    {         \n+                      wait(); \n+                    }\n+                  catch (InterruptedException e) \n+                    { \n+                      continue; \n+                    }\n+                }\n+\n+              System.arraycopy(buf, offset + total_written, buffer, in,\n+                               bytes_written);\n+              total_written += bytes_written;\n+              in += bytes_written;\n+\n+              if (in == buffer.length)\n+                in = 0;\n+\n+              notifyAll();\n+            }\n+        }\n+      // Wait for some reads to occur before we write anything.\n+      else\n+        {\n+          try\n+            {\n+              wait();\n+            }\n+          catch (InterruptedException e) { ; }\n+        }\n+    }\n }\n+\n+} // class PipedInputStream\n+"}, {"sha": "6d1061230bea2ebbbce2efbc607a8e4d6f07eaa8", "filename": "libjava/java/io/PipedOutputStream.java", "status": "modified", "additions": 196, "deletions": 84, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedOutputStream.java?ref=d3474943bf309f085d515d7b20cb80c1d50e14cd", "patch": "@@ -1,97 +1,209 @@\n-// PipedOutputStream.java - Write bytes to a pipe.\n+/* PipedOutputStream.java -- Write portion of piped streams.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.io;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 24, 1998 \n+  * This class writes its bytes to a <code>PipedInputStream</code> to \n+  * which it is connected.\n+  * <p>\n+  * It is highly recommended that a <code>PipedOutputStream</code> and its\n+  * connected <code>PipedInputStream</code> be in different threads.  If \n+  * they are in the same thread, read and write operations could deadlock\n+  * the thread.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class PipedOutputStream extends OutputStream\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n  */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Believed complete and correct.\n+/**\n+  * This is the <code>PipedInputStream</code> to which this object\n+  * is connected.\n+  */\n+private PipedInputStream snk;\n+\n+/**\n+  * This flag indicates whether or not this stream has ever been\n+  * connected to an input stream\n+  */\n+private boolean ever_connected;\n+\n+/**\n+  * This flag indicates whether the <code>close</code> method has ever\n+  * been called for this stream.\n+  */\n+private boolean closed;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new <code>PipedOutputStream</code> instance.\n+  * This constructor creates an unconnected object.  It must be connected\n+  * to a <code>PipedInputStream</code> object using the <code>connect</code>\n+  * method prior to writing any data or an exception will be thrown.\n+  */\n+public\n+PipedOutputStream()\n+{\n+  ; // Do Nothing\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new <code>PipedOutputStream</code> instance\n+  * to write to the specified <code>PipedInputStream</code>.  This stream\n+  * is then ready for writing.\n+  *\n+  * @param snk The <code>PipedInputStream</code> to connect this stream to.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public\n+PipedOutputStream(PipedInputStream snk) throws IOException\n+{\n+  connect(snk);\n+} \n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n  */\n \n-public class PipedOutputStream extends OutputStream\n+/**\n+  * This method connects this object to the specified \n+  * <code>PipedInputStream</code> object.  This stream will then be ready \n+  * for writing.  If this stream is already connected or has been \n+  * previously closed, then an exception is thrown.\n+  *\n+  * @param snk The <code>PipedInputStream</code> to connect this stream to\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+connect(PipedInputStream snk) throws IOException\n {\n-  public void close () throws IOException\n-  {\n-    closed = true;\n-\n-    // Notify PipedInputStream that there is no more data to be had.\n-    destination.receive(-1);\n-  }\n-\n-  public void connect (PipedInputStream dest) throws IOException\n-  {\n-    if (closed)\n-      throw new IOException(\"pipe closed\");\n-\n-    if (destination != null)\n-      if (destination == dest)\n-\treturn;\n-      else\n-        throw new IOException(\"pipe already connected\");\n-\n-    destination = dest;\n-    try\n-    {\n-      dest.connect(this);\n-    }\n-    catch (IOException ex)\n-    {\n-      destination = null;\n-      throw ex;\n-    }\n-  }\n-\n-  public synchronized void flush () throws IOException\n-  {\n-    // There doesn't seem to be anything to do here.\n-\n-    // TBD: Should this maybe do a notifyAll as a way for the user\n-    // to wake up the input stream to check for bytes to read?  Shouldn't\n-    // be necessary but if there aren't any bytes, other threads will just\n-    // go blocak again anyway so it wouldn't hurt.\n-  }\n-\n-  public PipedOutputStream ()\n-  {\n-    closed = false;\n-  }\n-\n-  public PipedOutputStream (PipedInputStream dest) throws IOException\n-  {\n-    closed = false;\n-    connect (dest);\n-  }\n-\n-  public void write (int oneByte) throws IOException\n-  {\n-    if (closed)\n-      throw new IOException ();\n-    destination.receive(oneByte);\n-  }\n-\n-  public void write (byte[] buffer, int offset, int count) throws IOException\n-  {\n-    if (closed)\n-      throw new IOException ();\n-    if (offset < 0 || count < 0 || offset + count > buffer.length)\n-      throw new ArrayIndexOutOfBoundsException ();\n-    for (int i = 0; i < count; ++i)\n-      destination.receive (buffer[offset + i]);\n-  }\n-\n-  // Instance variables.\n-  private PipedInputStream destination;\n-  private boolean closed;\n+  if (snk == this.snk)\n+    return;\n+\n+  if (ever_connected)\n+    throw new IOException(\"Already connected\");\n+\n+  if (closed)\n+    throw new IOException(\"Stream is closed and cannot be reopened\");\n+\n+  this.snk = snk;\n+  ever_connected = true;\n+  snk.src = this;\n+\n+  snk.connect(this);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method closes this stream so that no more data can be written\n+  * to it. Any further attempts to write to this stream may throw an\n+  * exception\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+close() throws IOException\n+{\n+  closed = true;\n+  snk.close();\n+  notifyAll();\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes a single byte of date to the stream.  Note that\n+  * this method will block if the <code>PipedInputStream</code> to which\n+  * this object is connected has a full buffer.\n+  *\n+  * @param b The byte of data to be written, passed as an <code>int</code>.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public synchronized void\n+write(int b) throws IOException\n+{\n+  byte[] buf = new byte[1];\n+  buf[0] = (byte)(b & 0xFF);\n+\n+  snk.write(buf, 0, buf.length);\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes <code>len</code> bytes of data from the byte array\n+  * <code>buf</code> starting at index <code>offset</code> in the array\n+  * to the stream.  Note that this method will block if the  \n+  * <code>PipedInputStream</code> to which this object is connected has\n+  * a buffer that cannot hold all of the bytes to be written.\n+  *\n+  * @param buf The array containing bytes to write to thes stream.\n+  * @param offset The index into the array to start writing bytes from.\n+  * @param len The number of bytes to write.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+write(byte[] buf, int offset, int len) throws IOException\n+{\n+  snk.write(buf, 0, len);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method flushes any unwritten bytes to the output and notifies\n+  * any waiting readers that the pipe is ready to be read.\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public void\n+flush() throws IOException\n+{\n+  return;\n+}\n+\n+} // class PipedOutputStream\n+"}, {"sha": "72e516a2c102c1d5ee094e285484e59fe3b97151", "filename": "libjava/java/io/PipedReader.java", "status": "modified", "additions": 506, "deletions": 197, "changes": 703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedReader.java?ref=d3474943bf309f085d515d7b20cb80c1d50e14cd", "patch": "@@ -1,210 +1,519 @@\n-// PipedReader.java - Piped character stream.\n+/* PipedReader.java -- Input stream that reads from an output stream\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.io;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 25, 1998 \n+  * This class is an input stream that reads its chars from an output stream\n+  * to which it is connected. \n+  * <p>\n+  * Data is read and written to an internal buffer.  It is highly recommended\n+  * that the <code>PipedReader</code> and connected <code>PipedWriter</code>\n+  * be part of different threads.  If they are not, there is a possibility\n+  * that the read and write operations could deadlock their thread.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class PipedReader extends Reader\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Class Variables\n  */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Complete to 1.1.\n+/**\n+  * The size of the internal buffer used for input/output.  Note that this\n+  * can be overriden by setting the system property \n+  * <code>gnu.java.io.PipedReader.pipe_size</code> to the desired size shown \n+  * in chars.  This is not a standard part of the class library.  Note that \n+  * since this variable is <code>final</code>, it cannot be changed to refect \n+  * the size specified in the property.\n+  * <p>\n+  * The value for this variable is 2048.\n+  */\n+private static final int PIPE_SIZE = 2048;\n+\n+/**\n+  * This is the real pipe size.  It defaults to PIPE_SIZE, unless overridden\n+  * by use of the system property <code>gnu.java.io.PipedReader.pipe_size</code>.\n+  */\n+private static int pipe_size;\n+\n+/**\n+  * This variable indicates whether or not the <code>read()</code> method will attempt\n+  * return a short count if this will possibly keep the stream from blocking.  \n+  * The default for this is <code>false</code> because that is what what the JDK seems\n+  * to imply in its javadocs.  We set this to <code>false</code> if the system \n+  * property <code>gnu.java.io.try_not_to_block</code> is set.\n+  */\n+private static boolean try_not_to_block = false;\n+\n+static\n+{\n+  pipe_size =  Integer.getInteger(\"gnu.java.io.PipedReader.pipe_size\",\n+                                  PIPE_SIZE).intValue();\n+\n+  String block_prop = System.getProperty(\"gnu.java.io.try_not_to_block\");\n+  if (block_prop != null)\n+    try_not_to_block = true;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n  */\n \n-public class PipedReader extends Reader\n+/**\n+  * This is the internal circular buffer used for storing chars written\n+  * to the pipe and from which chars are read by this stream\n+  */\n+private char[] buffer = new char[pipe_size];\n+\n+/**\n+  * The index into buffer where the chars written char the connected\n+  * <code>PipedWriter</code> will be written.  If this variables is less\n+  * than 0, then the buffer is empty.  If this variable is equal to \n+  * <code>out</code>, then the buffer is full\n+  */\n+private int in = -1;\n+\n+/**\n+  * This index into the buffer where chars will be read from.\n+  */\n+private int out = 0;\n+\n+/**\n+  * This variable is <code>true</code> if this object has ever been connected\n+  * to a <code>PipedWriter</code>, and <code>false</code> otherwise.  It is used\n+  * to detect an attempt to connect an already connected stream or to\n+  * otherwise use the stream before it is connected.\n+  */\n+private boolean ever_connected = false;\n+\n+/**\n+  * This variable is set to <code>true</code> if the <code>close()</code> method is\n+  * called.  This value is checked prevents a caller from re-opening the\n+  * stream.\n+  */\n+private boolean closed = false;\n+\n+/**\n+  * This variable is the PipedWriter to which this stream is connected.\n+  */\n+PipedWriter src;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * This constructor creates a new <code>PipedReader</code> that is not \n+  * connected to a <code>PipedWriter</code>.  It must be connected before\n+  * chars can be read from this stream.\n+  */\n+public\n+PipedReader()\n+{\n+  return;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This constructor creates a new <code>PipedReader</code> and connects\n+  * it to the passed in <code>PipedWriter</code>. The stream is then read\n+  * for reading.\n+  *\n+  * @param src The <code>PipedWriter</code> to connect this stream to\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public\n+PipedReader(PipedWriter src) throws IOException\n+{\n+  connect(src);\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * This method connects this stream to the passed in <code>PipedWriter</code>.\n+  * This stream is then ready for reading.  If this stream is already\n+  * connected or has been previously closed, then an exception is thrown\n+  *\n+  * @param src The <code>PipedWriter</code> to connect this stream to\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+connect(PipedWriter src) throws IOException\n+{\n+  if (src == this.src)\n+    return;\n+\n+  if (ever_connected)\n+    throw new IOException(\"Already connected\");\n+\n+  if (closed)\n+    throw new IOException(\"Stream is closed and cannot be reopened\");\n+\n+  synchronized (lock) {\n+\n+  src.connect(this);\n+\n+  ever_connected = true;\n+\n+  } // synchronized\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This methods closes the stream so that no more data can be read\n+  * from it.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+close() throws IOException\n+{\n+  synchronized (lock) {\n+\n+  closed = true;\n+  notifyAll();\n+\n+  } // synchronized\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method determines whether or not this stream is ready to be read.\n+  * If this metho returns <code>false</code> an attempt to read may (but is\n+  * not guaranteed to) block.\n+  *\n+  * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public boolean\n+ready() throws IOException\n {\n-  public void close () throws IOException\n-  {\n-    closed = true;\n-  }\n-\n-  public void connect (PipedWriter src) throws IOException\n-  {\n-    if (closed)\n-      throw new IOException (\"already closed\");\n-    if (writer != null)\n-      {\n-\tif (writer == src)\n-\t  return;\n-\tthrow new IOException (\"already connected\");\n-      }\n-    try\n-      {\n-\twriter = src;\n-\twriter.connect(this);\n-      }\n-    catch (IOException e)\n-      {\n-\twriter = null;\n-\tthrow e;\n-      }\n-  }\n-\n-  public PipedReader ()\n-  {\n-    super ();\n-    writer = null;\n-    closed = false;\n-    in = -1;\n-    out = 0;\n-    pipeBuffer = new char[1024];\n-  }\n-\n-  public PipedReader (PipedWriter src) throws IOException\n-  {\n-    super ();\n-    closed = false;\n-    in = -1;\n-    out = 0;\n-    pipeBuffer = new char[1024];\n-    connect (src);\n-  }\n-\n-  public int read (char buf[], int offset, int count) throws IOException\n-  {\n-    if (closed)\n-      throw new IOException (\"closed\");\n-    if (count < 0)\n-      throw new ArrayIndexOutOfBoundsException ();\n-    int toCopy = count;\n-    synchronized (lock)\n-      {\n-\twhile (toCopy > 0)\n-\t  {\n-\t    // Wait for data in the pipe.  If the writer is closed and\n-\t    // no data has been copied into the output buffer, return\n-\t    // the magic EOF number.\n-\t    while (in == -1)\n-\t      {\n-\t\tif (writer.isClosed())\n-\t\t  {\n-\t\t    if (toCopy < count)\n-\t\t      return count - toCopy;\n-\t\t    return -1;\n-\t\t  }\n-\n-\t\t// Note that JCL doesn't say this is the right thing\n-\t\t// to do.  Still, it feels right, and we must deal\n-\t\t// with an interrupt somehow.\n-\t\ttry\n-\t\t  {\n-\t\t    lock.wait();\n-\t\t  }\n-\t\tcatch (InterruptedException e)\n-\t\t  {\n-\t\t    InterruptedIOException io\n-\t\t      = new InterruptedIOException (e.getMessage());\n-\t\t    io.bytesTransferred = count - toCopy;\n-\t\t    throw io;\n-\t\t  }\n-\t      }\n-\t    // Now copy some data from pipe into user buffer.\n-\t    int len;\n-\t    if (in < out)\n-\t      len = pipeBuffer.length - out;\n-\t    else\n-\t      len = in - out;\n-\t    len = len > toCopy ? toCopy : len;\n-\t    System.arraycopy(pipeBuffer, out, buf, offset, len);\n-\t    out += len;\n-\t    if (out == pipeBuffer.length)\n-\t      out = 0;\n-\t    toCopy -= len;\n-\t    offset += len;\n-\t    // If we've read all the data, then reset so that we know\n-\t    // there is nothing left to be read.\n-\t    if (in == out)\n-\t      in = -1;\n-\t    // Tell anybody waiting for space in the buffer.\n-\t    lock.notifyAll();\n-\t  }\n-      }\n-    return count;\n-  }\n-\n-  void receive (char buf[], int offset, int count) throws IOException\n-  {\n-    if (count < 0)\n-      throw new ArrayIndexOutOfBoundsException ();\n-    int original = count;\n-    synchronized (lock)\n-      {\n-\twhile (count > 0)\n-\t  {\n-\t    // Wait until there is some space in the buffer.\n-\t    while (in == out)\n-\t      {\n-\t\ttry\n-\t\t  {\n-\t\t    lock.wait();\n-\t\t  }\n-\t\tcatch (InterruptedException e)\n-\t\t  {\n-\t\t    // Turn interrupts into IO interrupts.\n-\t\t    InterruptedIOException io\n-\t\t      = new InterruptedIOException (e.getMessage());\n-\t\t    io.bytesTransferred = original - count;\n-\t\t    throw io;\n-\t\t  }\n-\t      }\n-\n-\t    // Compute destination in the pipe.\n-\t    int base, len;\n-\t    if (in == -1)\n-\t      {\n-\t\tbase = 0;\n-\t\tlen = pipeBuffer.length;\n-\t      }\n-\t    else if (in < out)\n-\t      {\n-\t\tbase = in;\n-\t\tlen = out - in;\n-\t      }\n-\t    else\n-\t      {\n-\t\tbase = in;\n-\t\tlen = pipeBuffer.length - in;\n-\t      }\n-\t    int copyLen = len > count ? count : len;\n-\t    // Copy data and update local state.\n-\t    System.arraycopy(buf, offset, pipeBuffer, base, copyLen);\n-\t    in = base + copyLen;\n-\t    if (in == pipeBuffer.length)\n-\t      in = 0;\n-\t    count -= copyLen;\n-\t    offset += copyLen;\n-\t    // Tell anybody waiting for data.\n-\t    lock.notifyAll();\n-\t  }\n-      }\n-  }\n-\n-\n-  boolean isClosed ()\n-  {\n-    return closed;\n-  }\n-\n-  // The associated writer.\n-  private PipedWriter writer;\n-  // True if this reader has been closed.\n-  boolean closed;\n-\n-  // Index of next character to overwrite when receive() is called.\n-  // If -1, then that means the buffer is empty.\n-  private int in;\n-  // Index of next character to return from read().\n-  private int out;\n-\n-  // The pipe buffer itself.\n-  private char[] pipeBuffer;\n+  if (in == -1)\n+    return(false);\n+\n+  if (out == (in - 1))\n+    return(false);\n+\n+  if ((out == pipe_size) && (in == 0))\n+    return(false);\n+\n+  return(true);\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method reads a single char from the pipe and returns it as an\n+  * <code>int</code>.\n+  * <p>\n+  * This method will block if no chars are available to be read.\n+  *\n+  * @return An char read from the pipe, or -1 if the end of stream is \n+  * reached.\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public int\n+read() throws IOException\n+{\n+  char[] buf = new char[1];\n+\n+  return(read(buf, 0, buf.length));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method reads chars from the stream into a caller supplied buffer.\n+  * It starts storing chars at position <code>offset</code> into the buffer and\n+  * reads a maximum of <cod>>len</code> chars.  Note that this method can actually\n+  * read fewer than <code>len</code> chars.  The actual number of chars read is\n+  * returned.  A -1 is returned to indicated that no chars can be read\n+  * because the end of the stream was reached.  If the stream is already\n+  * closed, a -1 will again be returned to indicate the end of the stream.\n+  * <p>\n+  * This method will block if no chars are available to be read.\n+  *\n+  * @param buf The buffer into which chars will be stored\n+  * @param offset The index into the buffer at which to start writing.\n+  * @param len The maximum number of chars to read.\n+  */\n+public int\n+read(char[] buf, int offset, int len) throws IOException\n+{\n+  if (!ever_connected)\n+    throw new IOException(\"Not connected\"); \n+\n+  synchronized (lock) {\n+\n+  int chars_read = 0;\n+  for (;;)\n+    {\n+      // If there are chars, take them\n+      if (in != -1)\n+        {\n+          int desired_chars = len - chars_read;\n+\n+          // We are in a \"wrap\" condition\n+          if (out > in)\n+            {\n+              if (desired_chars > (pipe_size - out))\n+                {\n+                  if (in == 0)\n+                    desired_chars = (pipe_size - out) - 1;\n+                  else\n+                    desired_chars = pipe_size - out;\n+\n+                  System.arraycopy(buffer, out, buf, offset + chars_read,\n+                                   desired_chars);\n+\n+                  chars_read += desired_chars;\n+                  out += desired_chars;\n+                  desired_chars = len - chars_read;\n+\n+                  if (out == pipe_size)\n+                    out = 0;\n+\n+                  notifyAll();\n+                }\n+              else\n+                {\n+                  if ((out + desired_chars) == in)\n+                    --desired_chars;\n+\n+                  if (((out + desired_chars) == pipe_size) && (in == 0)) \n+                    desired_chars = (pipe_size - out) - 1;\n+\n+                  System.arraycopy(buffer, out, buf, offset + chars_read,\n+                                   desired_chars); \n+\n+                  chars_read += desired_chars;\n+                  out += desired_chars;\n+                  desired_chars = len - chars_read;\n+\n+                  if (out == pipe_size)\n+                    out = 0;\n+\n+                  notifyAll();\n+                }\n+            }\n+ \n+          // We are in a \"no wrap\" or condition (can also be fall through\n+          // from above\n+          if (in > out)\n+            {\n+              if (desired_chars >= ((in - out) - 1))\n+                desired_chars = (in - out) - 1;\n+\n+              System.arraycopy(buffer, out, buf, offset + chars_read, \n+                               desired_chars);\n+\n+              chars_read += desired_chars;\n+              out += desired_chars;\n+              desired_chars = len - chars_read;\n+\n+              if (out == pipe_size)\n+                out = 0;\n+\n+              notifyAll();\n+            }\n+        }\n+\n+      // If we are done, return\n+      if (chars_read == len)\n+        return(chars_read);\n+\n+      // Return a short count if necessary\n+      if (chars_read < len)\n+        if (try_not_to_block)\n+           return(chars_read);\n+\n+      // Handle the case where the end of stream was encountered.\n+      if (closed)\n+        {\n+          // We never let in == out so there might be one last char\n+          // available that we have not copied yet.\n+          if (in != -1)\n+            {\n+              buf[offset + chars_read] = buffer[out];\n+              in = -1;\n+              ++out;\n+              ++chars_read;\n+            }\n+\n+          if (chars_read != 0)\n+            return(chars_read);\n+          else\n+            return(-1);\n+        }\n+\n+      // Wait for a char to be read\n+      try\n+        {\n+          wait();\n+        }\n+      catch(InterruptedException e) { ; }\n+    } \n+\n+  } // synchronized\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method is used by the connected <code>PipedWriter</code> to\n+  * write chars into the buffer.  It uses this method instead of directly\n+  * writing the chars in order to obtain ownership of the object's monitor\n+  * for the purposes of calling <code>notify</code>.\n+  *\n+  * @param buf The array containing chars to write to this stream\n+  * @param offset The offset into the array to start writing from\n+  * @param len The number of chars to write.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+void\n+write(char[] buf, int offset, int len) throws IOException\n+{\n+  if (len <= 0)\n+    return;\n+\n+  synchronized (lock) {\n+\n+  int total_written = 0;\n+  while (total_written < len)\n+    {\n+      // If we are not at the end of the buffer with out = 0\n+      if (!((in == (buffer.length - 1)) && (out == 0)))\n+        {\n+          // This is the \"no wrap\" situation\n+          if ((in - 1) >= out)\n+            {\n+              int chars_written = 0;\n+              if ((buffer.length - in) > (len - total_written))\n+                chars_written = (len - total_written);\n+              else if (out == 0)\n+                chars_written = (buffer.length - in) - 1;\n+              else \n+                chars_written = (buffer.length - in);\n+\n+              if (chars_written > 0) \n+                System.arraycopy(buf, offset + total_written, buffer, in, \n+                                 chars_written);\n+              total_written += chars_written;\n+              in += chars_written;\n+\n+              if (in == buffer.length)\n+                in = 0;\n+\n+              notifyAll();\n+            }\n+          // This is the \"wrap\" situtation\n+          if ((out > in) && (total_written != len))\n+            {\n+              int chars_written = 0;\n+\n+              // Do special processing if we are at the beginning\n+              if (in == -1)\n+                {\n+                  in = 0;\n+\n+                  if (buffer.length > len)\n+                    chars_written = len;\n+                  else\n+                    chars_written = buffer.length - 1;\n+                }\n+              else if (((out - in) - 1) < (len - total_written))\n+                {\n+                  chars_written = (out - in) - 1;\n+                }\n+              else\n+                {\n+                  chars_written = len - total_written;\n+                }\n+\n+              // If the buffer is full, wait for it to empty out\n+              if ((out - 1) == in)\n+                {\n+                  try\n+                    {         \n+                      wait(); \n+                    }\n+                  catch (InterruptedException e) \n+                    { \n+                      continue; \n+                    }\n+                }\n+\n+              System.arraycopy(buf, offset + total_written, buffer, in,\n+                               chars_written);\n+              total_written += chars_written;\n+              in += chars_written;\n+\n+              if (in == buffer.length)\n+                in = 0;\n+\n+              notifyAll();\n+            }\n+        }\n+      // Wait for some reads to occur before we write anything.\n+      else\n+        {\n+          try\n+            {\n+              wait();\n+            }\n+          catch (InterruptedException e) { ; }\n+        }\n+    }\n+  } // synchronized\n+}\n+\n+} // class PipedReader\n+"}, {"sha": "cc36acdf0d5cffb01a55ee149fa486198d6f3606", "filename": "libjava/java/io/PipedWriter.java", "status": "modified", "additions": 204, "deletions": 75, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3474943bf309f085d515d7b20cb80c1d50e14cd/libjava%2Fjava%2Fio%2FPipedWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedWriter.java?ref=d3474943bf309f085d515d7b20cb80c1d50e14cd", "patch": "@@ -1,88 +1,217 @@\n-// PipedWriter.java - Piped character stream.\n+/* PipedWriter.java -- Write portion of piped streams.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.io;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 25, 1998 \n+  * This class writes its chars to a <code>PipedReader</code> to \n+  * which it is connected.\n+  * <p>\n+  * It is highly recommended that a <code>PipedWriter</code> and its\n+  * connected <code>PipedReader</code> be in different threads.  If \n+  * they are in the same thread, read and write operations could deadlock\n+  * the thread.\n+  *\n+  * @version 0.0\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+public class PipedWriter extends Writer\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n  */\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Complete to 1.1.\n+/**\n+  * This is the <code>PipedReader</code> to which this object\n+  * is connected.\n+  */\n+private PipedReader snk;\n+\n+/**\n+  * This flag indicates whether or not this stream has ever been\n+  * connected to an input stream\n+  */\n+private boolean ever_connected;\n+\n+/**\n+  * This flag indicates whether the <code>close</code> method has ever\n+  * been called for this stream.\n+  */\n+private boolean closed;\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new <code>PipedWriter</code> instance.\n+  * This constructor creates an unconnected object.  It must be connected\n+  * to a <code>PipedReader</code> object using the <code>connect</code>\n+  * method prior to writing any data or an exception will be thrown.\n+  */\n+public\n+PipedWriter()\n+{\n+  ; // Do Nothing\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method initializes a new <code>PipedWriter</code> instance\n+  * to write to the specified <code>PipedReader</code>.  This stream\n+  * is then ready for writing.\n+  *\n+  * @param snk The <code>PipedReader</code> to connect this stream to.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public\n+PipedWriter(PipedReader snk) throws IOException\n+{\n+  connect(snk);\n+} \n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n  */\n \n-public class PipedWriter extends Writer\n+/**\n+  * This method connects this object to the specified \n+  * <code>PipedReader</code> object.  This stream will then be ready \n+  * for writing.  If this stream is already connected or has been \n+  * previously closed, then an exception is thrown.\n+  *\n+  * @param snk The <code>PipedReader</code> to connect this stream to\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+connect(PipedReader snk) throws IOException\n+{\n+  if (snk == this.snk)\n+    return;\n+\n+  if (ever_connected)\n+    throw new IOException(\"Already connected\");\n+\n+  if (closed)\n+    throw new IOException(\"Stream is closed and cannot be reopened\");\n+\n+  synchronized (lock) {\n+\n+  this.snk = snk;\n+  ever_connected = true;\n+  snk.src = this;\n+\n+  snk.connect(this);\n+\n+  } // synchronized\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method closes this stream so that no more data can be written\n+  * to it. Any further attempts to write to this stream may throw an\n+  * exception\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+close() throws IOException\n {\n-  public void close () throws IOException\n-  {\n-    closed = true;\n-  }\n-\n-  public void connect (PipedReader sink) throws IOException\n-  {\n-    if (closed)\n-      throw new IOException (\"already closed\");\n-    if (reader != null)\n-      {\n-\tif (reader == sink)\n-\t  return;\n-\tthrow new IOException (\"already connected\");\n-      }\n-    try\n-      {\n-\treader = sink;\n-\treader.connect(this);\n-      }\n-    catch (IOException e)\n-      {\n-\treader = null;\n-\tthrow e;\n-      }\n-  }\n-\n-  public void flush () throws IOException\n-  {\n-    // We'll throw an exception if we're closed, but there's nothing\n-    // else to do here.\n-    if (closed)\n-      throw new IOException (\"closed\");\n-  }\n-\n-  public PipedWriter ()\n-  {\n-    super ();\n-    closed = false;\n-  }\n-\n-  public PipedWriter (PipedReader sink) throws IOException\n-  {\n-    super ();\n-    closed = false;\n-    connect (sink);\n-  }\n-\n-  public void write (char buffer[], int offset, int count) throws IOException\n-  {\n-    if (closed)\n-      throw new IOException (\"closed\");\n-    reader.receive(buffer, offset, count);\n-  }\n-\n-  boolean isClosed ()\n-  {\n-    return closed;\n-  }\n-\n-  // The associated reader.\n-  private PipedReader reader;\n-  private boolean closed;\n+  synchronized (lock) {\n+\n+  closed = true;\n+  snk.close();\n+  notifyAll();\n+\n+  } // synchronized\n }\n+\n+/*************************************************************************/\n+\n+/**\n+  * This methods writes a single byte of data to the pipe.  This call may\n+  * block if the pipe is full.\n+  *\n+  * @param c The <code>char</code> to write, passed as an <code>int</code>.\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public void\n+write(int c) throws IOException\n+{\n+  char[] buf = new char[1];\n+  buf[0] = (char)c;\n+\n+  write(buf, 0, buf.length);\n+} \n+\n+/*************************************************************************/\n+\n+/**\n+  * This method writes <code>len</code> chars of data from the char array\n+  * <code>buf</code> starting at index <code>offset</code> in the array\n+  * to the stream.  Note that this method will block if the  \n+  * <code>PipedReader</code> to which this object is connected has\n+  * a buffer that cannot hold all of the chars to be written.\n+  *\n+  * @param buf The array containing chars to write to thes stream.\n+  * @param offset The index into the array to start writing chars from.\n+  * @param len The number of chars to write.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+write(char[] buf, int offset, int len) throws IOException\n+{\n+  snk.write(buf, 0, len);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method flushes any unwritten chars to the underlying output\n+  * sink.  This method does nothing in this class because this class does\n+  * not buffer any chars.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+flush() throws IOException\n+{\n+  ; // Do Nothing\n+}\n+\n+} // class PipedWriter\n+"}]}