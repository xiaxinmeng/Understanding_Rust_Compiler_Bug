{"sha": "9997d19d6d7b8391b67cbdb36f2805b6f1390268", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk5N2QxOWQ2ZDdiODM5MWI2N2NiZGIzNmYyODA1YjZmMTM5MDI2OA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-02T18:41:52Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-02T18:41:52Z"}, "message": "(arm_condition_code): Move to start of file.\n\n(const_pool_offset): Correct typo.\n(fp_const_from_val): New function.\n(all instruction generators): mark position where conditionalization\nshould be with '%?'.\n(output_move_double): Use new '%m' output type to simplify load/store\nmultiple generation.\n(shift_instr): Delete.\n(shift_op): New function.\n(output_arithmetic): Delete.\n(output_arithmetic_with_shift): Delete.\n(output_arithmetic_with_immediate_multiply): Delete.\n(output_shifted_move): Delete.\n(output_shift_compare): Delete.\n(arm_print_operand): New function.\n\nFrom-SVN: r7423", "tree": {"sha": "2b63ef31b6aae7cf360aba2269ae2621c68a5373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b63ef31b6aae7cf360aba2269ae2621c68a5373"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9997d19d6d7b8391b67cbdb36f2805b6f1390268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9997d19d6d7b8391b67cbdb36f2805b6f1390268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9997d19d6d7b8391b67cbdb36f2805b6f1390268", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9997d19d6d7b8391b67cbdb36f2805b6f1390268/comments", "author": null, "committer": null, "parents": [{"sha": "945388edd6e6261c6b91b8192e4d9d3f60a6e0e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/945388edd6e6261c6b91b8192e4d9d3f60a6e0e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/945388edd6e6261c6b91b8192e4d9d3f60a6e0e6"}], "stats": {"total": 477, "additions": 265, "deletions": 212}, "files": [{"sha": "e4a2a15e10428c8579259fa4645fbdde3fd145ea", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 265, "deletions": 212, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9997d19d6d7b8391b67cbdb36f2805b6f1390268/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9997d19d6d7b8391b67cbdb36f2805b6f1390268/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9997d19d6d7b8391b67cbdb36f2805b6f1390268", "patch": "@@ -96,6 +96,15 @@ int arm_ccfsm_state;\n int arm_current_cc;\n rtx arm_target_insn;\n int arm_target_label;\n+\n+/* The condition codes of the ARM, and the inverse function.  */\n+char *arm_condition_codes[] =\n+{\n+  \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n+  \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\"\n+};\n+\n+#define ARM_INVERSE_CONDITION_CODE(X)  ((X) ^ 1)\n \f\n /* Return 1 if it is possible to return using a single instruction */\n \n@@ -680,7 +689,7 @@ store_multiple_operation (op, mode)\n \n int\n const_pool_offset (symbol)\n-     rtx (symbol);\n+     rtx symbol;\n {\n   return get_pool_offset (symbol) - get_pool_size () - get_prologue_size ();\n }\n@@ -852,6 +861,22 @@ fp_immediate_constant (x)\n   abort ();\n }\n \n+/* As for fp_immediate_constant, but value is passed directly, not in rtx.  */\n+static char *\n+fp_const_from_val (r)\n+     REAL_VALUE_TYPE *r;\n+{\n+  int i;\n+\n+  if (! fpa_consts_inited)\n+    init_fpa_table ();\n+\n+  for (i = 0; i < 8; i++)\n+    if (REAL_VALUES_EQUAL (*r, values_fpa[i]))\n+      return strings_fpa[i];\n+\n+  abort ();\n+}\n \n /* Output the operands of a LDM/STM instruction to STREAM.\n    MASK is the ARM register set mask of which only bits 0-15 are important.\n@@ -891,10 +916,10 @@ output_call (operands)\n   if (REGNO (operands[0]) == 14)\n     {\n       operands[0] = gen_rtx (REG, SImode, 12);\n-      output_asm_insn (\"mov\\t%0, lr\", operands);\n+      output_asm_insn (\"mov%?\\t%0, lr\", operands);\n     }\n-  output_asm_insn (\"mov\\tlr, pc\", operands);\n-  output_asm_insn (\"mov\\tpc, %0\", operands);\n+  output_asm_insn (\"mov%?\\tlr, pc\", operands);\n+  output_asm_insn (\"mov%?\\tpc, %0\", operands);\n   return \"\";\n }\n \n@@ -940,10 +965,10 @@ output_call_mem (operands)\n   /* Handle calls using lr by using ip (which may be clobbered in subr anyway).\n    */\n   if (eliminate_lr2ip (&operands[0]))\n-    output_asm_insn (\"mov\\tip, lr\", operands);\n+    output_asm_insn (\"mov%?\\tip, lr\", operands);\n \n-  output_asm_insn (\"mov\\tlr, pc\", operands);\n-  output_asm_insn (\"ldr\\tpc, %0\", operands);\n+  output_asm_insn (\"mov%?\\tlr, pc\", operands);\n+  output_asm_insn (\"ldr%?\\tpc, %0\", operands);\n   return \"\";\n }\n \n@@ -966,8 +991,8 @@ output_mov_long_double_fpu_from_arm (operands)\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n   ops[2] = gen_rtx (REG, SImode, 2 + arm_reg0);\n   \n-  output_asm_insn (\"stmfd\\tsp!, {%0, %1, %2}\", ops);\n-  output_asm_insn (\"ldfe\\t%0, [sp], #12\", operands);\n+  output_asm_insn (\"stm%?fd\\tsp!, {%0, %1, %2}\", ops);\n+  output_asm_insn (\"ldf%?e\\t%0, [sp], #12\", operands);\n   return \"\";\n }\n \n@@ -989,8 +1014,8 @@ output_mov_long_double_arm_from_fpu (operands)\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n   ops[2] = gen_rtx (REG, SImode, 2 + arm_reg0);\n \n-  output_asm_insn (\"stfe\\t%1, [sp, #-12]!\", operands);\n-  output_asm_insn (\"ldmfd\\tsp!, {%0, %1, %2}\", ops);\n+  output_asm_insn (\"stf%?e\\t%1, [sp, #-12]!\", operands);\n+  output_asm_insn (\"ldm%?fd\\tsp!, {%0, %1, %2}\", ops);\n   return \"\";\n }\n \n@@ -1013,7 +1038,7 @@ output_mov_long_double_arm_from_arm (operands)\n \t{\n \t  ops[0] = gen_rtx (REG, SImode, dest_start + i);\n \t  ops[1] = gen_rtx (REG, SImode, src_start + i);\n-\t  output_asm_insn (\"mov\\t%0, %1\", ops);\n+\t  output_asm_insn (\"mov%?\\t%0, %1\", ops);\n \t}\n     }\n   else\n@@ -1022,7 +1047,7 @@ output_mov_long_double_arm_from_arm (operands)\n \t{\n \t  ops[0] = gen_rtx (REG, SImode, dest_start + i);\n \t  ops[1] = gen_rtx (REG, SImode, src_start + i);\n-\t  output_asm_insn (\"mov\\t%0, %1\", ops);\n+\t  output_asm_insn (\"mov%?\\t%0, %1\", ops);\n \t}\n     }\n \n@@ -1045,8 +1070,8 @@ output_mov_double_fpu_from_arm (operands)\n     abort();\n   ops[0] = gen_rtx (REG, SImode, arm_reg0);\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n-  output_asm_insn (\"stmfd\\tsp!, {%0, %1}\", ops);\n-  output_asm_insn (\"ldfd\\t%0, [sp], #8\", operands);\n+  output_asm_insn (\"stm%?fd\\tsp!, {%0, %1}\", ops);\n+  output_asm_insn (\"ldf%?d\\t%0, [sp], #8\", operands);\n   return \"\";\n }\n \n@@ -1066,8 +1091,8 @@ output_mov_double_arm_from_fpu (operands)\n \n   ops[0] = gen_rtx (REG, SImode, arm_reg0);\n   ops[1] = gen_rtx (REG, SImode, 1 + arm_reg0);\n-  output_asm_insn (\"stfd\\t%1, [sp, #-8]!\", operands);\n-  output_asm_insn (\"ldmfd\\tsp!, {%0, %1}\", ops);\n+  output_asm_insn (\"stf%?d\\t%1, [sp, #-8]!\", operands);\n+  output_asm_insn (\"ldm%?fd\\tsp!, {%0, %1}\", ops);\n   return \"\";\n }\n \n@@ -1099,13 +1124,13 @@ output_move_double (operands)\n \t  /* Ensure the second source is not overwritten */\n \t  if (reg0 == 1 + reg1)\n \t    {\n-\t      output_asm_insn(\"mov\\t%0, %1\", otherops);\n-\t      output_asm_insn(\"mov\\t%0, %1\", operands);\n+\t      output_asm_insn(\"mov%?\\t%0, %1\", otherops);\n+\t      output_asm_insn(\"mov%?\\t%0, %1\", operands);\n \t    }\n \t  else\n \t    {\n-\t      output_asm_insn(\"mov\\t%0, %1\", operands);\n-\t      output_asm_insn(\"mov\\t%0, %1\", otherops);\n+\t      output_asm_insn(\"mov%?\\t%0, %1\", operands);\n+\t      output_asm_insn(\"mov%?\\t%0, %1\", otherops);\n \t    }\n \t}\n       else if (code1 == CONST_DOUBLE)\n@@ -1124,9 +1149,9 @@ output_move_double (operands)\n \t  /* Note: output_mov_immediate may clobber operands[1], so we\n \t     put this out first */\n \t  if (INTVAL (operands[1]) < 0)\n-\t    output_asm_insn (\"mvn\\t%0, %1\", otherops);\n+\t    output_asm_insn (\"mvn%?\\t%0, %1\", otherops);\n \t  else\n-\t    output_asm_insn (\"mov\\t%0, %1\", otherops);\n+\t    output_asm_insn (\"mov%?\\t%0, %1\", otherops);\n \t  output_mov_immediate (operands, FALSE, \"\");\n \t}\n       else if (code1 == MEM)\n@@ -1136,40 +1161,35 @@ output_move_double (operands)\n \t    case REG:\n \t      /* Handle the simple case where address is [r, #0] more\n \t\t efficient.  */\n-\t      operands[1] = XEXP (operands[1], 0);\n-\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      output_asm_insn (\"ldm%?ia\\t%m1, %M0\", operands);\n \t      break;\n   \t    case PRE_INC:\n-\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      output_asm_insn (\"add\\t%1, %1, #8\", operands);\n-\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      output_asm_insn (\"add%?\\t%m1, %m1, #8\", operands);\n+\t      output_asm_insn (\"ldm%?ia\\t%m1, %M0\", operands);\n \t      break;\n \t    case PRE_DEC:\n-\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n-\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n+\t      output_asm_insn (\"sub%?\\t%m1, %m1, #8\", operands);\n+\t      output_asm_insn (\"ldm%?ia\\t%m1, %M0\", operands);\n \t      break;\n \t    case POST_INC:\n-\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      output_asm_insn (\"ldmia\\t%1!, %M0\", operands);\n+\t      output_asm_insn (\"ldm%?ia\\t%m1!, %M0\", operands);\n \t      break;\n \t    case POST_DEC:\n-\t      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\t      output_asm_insn (\"ldmia\\t%1, %M0\", operands);\n-\t      output_asm_insn (\"sub\\t%1, %1, #8\", operands);\n+\t      output_asm_insn (\"ldm%?ia\\t%m1, %M0\", operands);\n+\t      output_asm_insn (\"sub%?\\t%m1, %m1, #8\", operands);\n \t      break;\n \t    default:\n \t      otherops[1] = adj_offsettable_operand (operands[1], 4);\n \t      /* Take care of overlapping base/data reg.  */\n \t      if (reg_mentioned_p (operands[0], operands[1]))\n \t\t{\n-\t\t  output_asm_insn (\"ldr\\t%0, %1\", otherops);\n-\t\t  output_asm_insn (\"ldr\\t%0, %1\", operands);\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", otherops);\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", operands);\n \t\t}\n \t      else\n \t\t{\n-\t\t  output_asm_insn (\"ldr\\t%0, %1\", operands);\n-\t\t  output_asm_insn (\"ldr\\t%0, %1\", otherops);\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", operands);\n+\t\t  output_asm_insn (\"ldr%?\\t%0, %1\", otherops);\n \t\t}\n \t    }\n \t}\n@@ -1182,39 +1202,34 @@ output_move_double (operands)\n       switch (GET_CODE (XEXP (operands[0], 0)))\n         {\n \tcase REG:\n-\t  operands[0] = XEXP (operands[0], 0);\n-\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  output_asm_insn (\"stm%?ia\\t%m0, %M1\", operands);\n \t  break;\n         case PRE_INC:\n-\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  output_asm_insn (\"add\\t%0, %0, #8\", operands);\n-\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  output_asm_insn (\"add%?\\t%m0, %m0, #8\", operands);\n+\t  output_asm_insn (\"stm%?ia\\t%m0, %M1\", operands);\n \t  break;\n         case PRE_DEC:\n-\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n-\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n+\t  output_asm_insn (\"sub%?\\t%m0, %m0, #8\", operands);\n+\t  output_asm_insn (\"stm%?ia\\t%m0, %M1\", operands);\n \t  break;\n         case POST_INC:\n-\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  output_asm_insn (\"stmia\\t%0!, %M1\", operands);\n+\t  output_asm_insn (\"stm%?ia\\t%m0!, %M1\", operands);\n \t  break;\n         case POST_DEC:\n-\t  operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\t  output_asm_insn (\"stmia\\t%0, %M1\", operands);\n-\t  output_asm_insn (\"sub\\t%0, %0, #8\", operands);\n+\t  output_asm_insn (\"stm%?ia\\t%m0, %M1\", operands);\n+\t  output_asm_insn (\"sub%?\\t%m0, %m0, #8\", operands);\n \t  break;\n         default:\n \t  otherops[0] = adj_offsettable_operand (operands[0], 4);\n \t  otherops[1] = gen_rtx (REG, SImode, 1 + REGNO (operands[1]));\n-\t  output_asm_insn (\"str\\t%1, %0\", operands);\n-\t  output_asm_insn (\"str\\t%1, %0\", otherops);\n+\t  output_asm_insn (\"str%?\\t%1, %0\", operands);\n+\t  output_asm_insn (\"str%?\\t%1, %0\", otherops);\n \t}\n     }\n   else abort();  /* Constraints should prevent this */\n \n-  return(\"\");\n-} /* output_move_double */\n+  return \"\";\n+}\n \n \n /* Output an arbitrary MOV reg, #n.\n@@ -1231,15 +1246,15 @@ output_mov_immediate (operands)\n   /* Try to use one MOV */\n   if (const_ok_for_arm (n))\n     {\n-      output_asm_insn (\"mov\\t%0, %1\", operands);\n+      output_asm_insn (\"mov%?\\t%0, %1\", operands);\n       return \"\";\n     }\n \n   /* Try to use one MVN */\n   if (const_ok_for_arm (~n))\n     {\n       operands[1] = GEN_INT (~n);\n-      output_asm_insn (\"mvn\\t%0, %1\", operands);\n+      output_asm_insn (\"mvn%?\\t%0, %1\", operands);\n       return \"\";\n     }\n \n@@ -1250,9 +1265,11 @@ output_mov_immediate (operands)\n       n_ones++;\n \n   if (n_ones > 16)  /* Shorter to use MVN with BIC in this case. */\n-    output_multi_immediate(operands, \"mvn\\t%0, %1\", \"bic\\t%0, %0, %1\", 1, ~n);\n+    output_multi_immediate(operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1,\n+\t\t\t   ~n);\n   else\n-    output_multi_immediate(operands, \"mov\\t%0, %1\", \"orr\\t%0, %0, %1\", 1, n);\n+    output_multi_immediate(operands, \"mov%?\\t%0, %1\", \"orr%?\\t%0, %0, %1\", 1,\n+\t\t\t   n);\n \n   return \"\";\n }\n@@ -1271,16 +1288,17 @@ output_add_immediate (operands)\n     {\n       if (n < 0)\n \toutput_multi_immediate (operands,\n-\t\t\t\t\"sub\\t%0, %1, %2\", \"sub\\t%0, %0, %2\", 2, -n);\n+\t\t\t\t\"sub%?\\t%0, %1, %2\", \"sub%?\\t%0, %0, %2\", 2,\n+\t\t\t\t-n);\n       else\n \toutput_multi_immediate (operands,\n-\t\t\t\t\"add\\t%0, %1, %2\", \"add\\t%0, %0, %2\", 2, n);\n+\t\t\t\t\"add%?\\t%0, %1, %2\", \"add%?\\t%0, %0, %2\", 2,\n+\t\t\t\tn);\n     }\n \n   return \"\";\n }\n \n-\n /* Output a multiple immediate operation.\n    OPERANDS is the vector of operands referred to in the output patterns.\n    INSTR1 is the output pattern to use for the first constant.\n@@ -1322,7 +1340,7 @@ output_multi_immediate (operands, instr1, instr2, immed_op, n)\n \t}\n     }\n   return \"\";\n-} /* output_multi_immediate */\n+}\n \n \n /* Return the appropriate ARM instruction for the operation code.\n@@ -1335,7 +1353,7 @@ arithmetic_instr (op, shift_first_arg)\n      rtx op;\n      int shift_first_arg;\n {\n-  switch (GET_CODE(op))\n+  switch (GET_CODE (op))\n     {\n     case PLUS:\n       return \"add\";\n@@ -1361,18 +1379,26 @@ arithmetic_instr (op, shift_first_arg)\n /* Ensure valid constant shifts and return the appropriate shift mnemonic\n    for the operation code.  The returned result should not be overwritten.\n    OP is the rtx code of the shift.\n-   SHIFT_PTR points to the shift size operand.  */\n+   On exit, *AMOUNTP will be -1 if the shift is by a register, or a constant\n+   shift. */\n \n-char *\n-shift_instr (op, shift_ptr)\n-     enum rtx_code op;\n-     rtx *shift_ptr;\n+static char *\n+shift_op (op, amountp)\n+     rtx op;\n+     HOST_WIDE_INT *amountp;\n {\n   int min_shift = 0;\n   int max_shift = 31;\n   char *mnem;\n \n-  switch (op)\n+  if (GET_CODE (XEXP (op, 1)) == REG || GET_CODE (XEXP (op, 1)) == SUBREG)\n+    *amountp = -1;\n+  else if (GET_CODE (XEXP (op, 1)) == CONST_INT)\n+    *amountp = INTVAL (XEXP (op, 1));\n+  else\n+    abort ();\n+\n+  switch (GET_CODE (op))\n     {\n     case ASHIFT:\n       mnem = \"asl\";\n@@ -1388,25 +1414,27 @@ shift_instr (op, shift_ptr)\n       max_shift = 32;\n       break;\n \n+    case ROTATERT:\n+      mnem = \"ror\";\n+      max_shift = 31;\n+      break;\n+\n     case MULT:\n-      *shift_ptr = GEN_INT (int_log2 (INTVAL (*shift_ptr)));\n+      if (*amountp != -1)\n+\t*amountp = int_log2 (*amountp);\n+      else\n+\tabort ();\n       return \"asl\";\n \n     default:\n       abort ();\n     }\n \n-  if (GET_CODE (*shift_ptr) == CONST_INT)\n-    {\n-      int shift = INTVAL (*shift_ptr);\n-\n-      if (shift < min_shift)\n-\t*shift_ptr = gen_rtx (CONST_INT, VOIDmode, 0);\n-      else if (shift > max_shift)\n-\t*shift_ptr = gen_rtx (CONST_INT, VOIDmode, max_shift);\n-    }\n-  return (mnem);\n-} /* shift_instr */\n+  if (*amountp != -1\n+      && (*amountp < min_shift || *amountp > max_shift))\n+    abort ();\n+  return mnem;\n+}\n \n \n /* Obtain the shift from the POWER of two. */\n@@ -1427,119 +1455,6 @@ int_log2 (power)\n   return shift;\n }\n \n-\n-/* Output an arithmetic instruction which may set the condition code.\n-   OPERANDS[0] is the destination register.\n-   OPERANDS[1] is the arithmetic operator expression.\n-   OPERANDS[2] is the left hand argument.\n-   OPERANDS[3] is the right hand argument.\n-   CONST_FIRST_ARG is TRUE if the first argument of the operator was constant.\n-   SET_COND is TRUE when the condition code should be set.  */\n-\n-char *\n-output_arithmetic (operands, const_first_arg, set_cond)\n-     rtx *operands;\n-     int const_first_arg;\n-     int set_cond;\n-{\n-  char mnemonic[80];\n-  char *instr = arithmetic_instr (operands[1], const_first_arg);\n-\n-  sprintf (mnemonic, \"%s%s\\t%%0, %%2, %%3\", instr, set_cond ? \"s\" : \"\");\n-  output_asm_insn (mnemonic, operands);\n-  return \"\";\n-}\n-\n-\n-/* Output an arithmetic instruction with a shift.\n-   OPERANDS[0] is the destination register.\n-   OPERANDS[1] is the arithmetic operator expression.\n-   OPERANDS[2] is the unshifted register.\n-   OPERANDS[3] is the shift operator expression.\n-   OPERANDS[4] is the shifted register.\n-   OPERANDS[5] is the shift constant or register.\n-   SHIFT_FIRST_ARG is TRUE if the first argument of the operator was shifted.\n-   SET_COND is TRUE when the condition code should be set.  */\n-\n-char *\n-output_arithmetic_with_shift (operands, shift_first_arg, set_cond)\n-     rtx *operands;\n-     int shift_first_arg;\n-     int set_cond;\n-{\n-  char mnemonic[80];\n-  char *instr = arithmetic_instr (operands[1], shift_first_arg);\n-  char *condbit = set_cond ? \"s\" : \"\";\n-  char *shift = shift_instr (GET_CODE (operands[3]), &operands[5]);\n-\n-  sprintf (mnemonic, \"%s%s\\t%%0, %%2, %%4, %s %%5\", instr, condbit, shift);\n-  output_asm_insn (mnemonic, operands);\n-  return \"\";\n-}\n-\n-/* Output an arithmetic instruction with a power of two multiplication.\n-   OPERANDS[0] is the destination register.\n-   OPERANDS[1] is the arithmetic operator expression.\n-   OPERANDS[2] is the unmultiplied register.\n-   OPERANDS[3] is the multiplied register.\n-   OPERANDS[4] is the constant multiple (power of two).\n-   SHIFT_FIRST_ARG is TRUE if the first arg of the operator was multiplied.  */\n-\n-char *\n-output_arithmetic_with_immediate_multiply (operands, shift_first_arg)\n-     rtx *operands;\n-     int shift_first_arg;\n-{\n-  char mnemonic[80];\n-  char *instr = arithmetic_instr (operands[1], shift_first_arg);\n-  HOST_WIDE_INT shift = int_log2 (INTVAL (operands[4]));\n-\n-  sprintf (mnemonic, \"%s\\t%%0, %%2, %%3, asl#%d\", instr, (int) shift);\n-  output_asm_insn (mnemonic, operands);\n-  return \"\";\n-}\n-\n-\n-/* Output a move with a shift.\n-   OP is the shift rtx code.\n-   OPERANDS[0] = destination register.\n-   OPERANDS[1] = source register.\n-   OPERANDS[2] = shift constant or register.  */\n-\n-char *\n-output_shifted_move (op, operands)\n-     enum rtx_code op;\n-     rtx *operands;\n-{\n-  char mnemonic[80];\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0)\n-    sprintf (mnemonic, \"mov\\t%%0, %%1\");\n-  else\n-    sprintf (mnemonic, \"mov\\t%%0, %%1, %s %%2\",\n-\t     shift_instr (op, &operands[2]));\n-\n-  output_asm_insn (mnemonic, operands);\n-  return \"\";\n-}\n-\n-char *\n-output_shift_compare (operands, neg)\n-     rtx *operands;\n-     int neg;\n-{\n-  char buf[80];\n-\n-  if (neg)\n-    sprintf (buf, \"cmn\\t%%1, %%3, %s %%4\", shift_instr (GET_CODE (operands[2]),\n-\t\t\t\t\t\t\t&operands[4]));\n-  else\n-    sprintf (buf, \"cmp\\t%%1, %%3, %s %%4\", shift_instr (GET_CODE (operands[2]),\n-\t\t\t\t\t\t\t&operands[4]));\n-  output_asm_insn (buf, operands);\n-  return \"\";\n-}\n-\n /* Output a .ascii pseudo-op, keeping track of lengths.  This is because\n    /bin/as is horribly restrictive.  */\n \n@@ -1760,9 +1675,9 @@ output_return_instruction (operand, really_return)\n         live_regs++;\n \n       if (frame_pointer_needed)\n-        strcpy (instr, \"ldm%d0ea\\tfp, {\");\n+        strcpy (instr, \"ldm%?%d0ea\\tfp, {\");\n       else\n-        strcpy (instr, \"ldm%d0fd\\tsp!, {\");\n+        strcpy (instr, \"ldm%?%d0fd\\tsp!, {\");\n \n       for (reg = 0; reg <= 10; reg++)\n         if (regs_ever_live[reg] && ! call_used_regs[reg])\n@@ -1787,7 +1702,7 @@ output_return_instruction (operand, really_return)\n     }\n   else if (really_return)\n     {\n-      strcpy (instr, TARGET_6 ? \"mov%d0\\tpc, lr\" : \"mov%d0s\\tpc, lr\");\n+      strcpy (instr, TARGET_6 ? \"mov%?%d0\\tpc, lr\" : \"mov%?%d0s\\tpc, lr\");\n       output_asm_insn (instr, &operand);\n     }\n \n@@ -2052,6 +1967,153 @@ output_func_epilogue (f, frame_size)\n   current_function_anonymous_args = 0;\n }\n \f\n+/* If CODE is 'd', then the X is a condition operand and the instruction\n+   should only be executed if the condition is true.\n+   if CODE is 'D', then the X is a condition operand and the instruciton\n+   should only be executed if the condition is false: however, if the mode\n+   of the comparison is CCFPEmode, then always execute the instruction -- we\n+   do this because in these circumstances !GE does not necessarily imply LT;\n+   in these cases the instruction pattern will take care to make sure that\n+   an instruction containing %d will follow, thereby undoing the effects of\n+   doing this instrucion unconditionally.\n+   If CODE is 'N' then X is a floating point operand that must be negated\n+   before output.\n+   If CODE is 'B' then output a bitwise inverted value of X (a const int).\n+   If X is a REG and CODE is `M', output a ldm/stm style multi-reg.  */\n+\n+void\n+arm_print_operand (stream, x, code)\n+     FILE *stream;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+    case '@':\n+      fputc (ARM_COMMENT_CHAR, stream);\n+      return;\n+\n+    case '|':\n+      fputs (ARM_REG_PREFIX, stream);\n+      return;\n+\n+    case '?':\n+      if (arm_ccfsm_state == 3 || arm_ccfsm_state == 4)\n+\tfputs (arm_condition_codes[arm_current_cc], stream);\n+      return;\n+\n+    case 'N':\n+      {\n+\tREAL_VALUE_TYPE r;\n+\tREAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\tr = REAL_VALUE_NEGATE (r);\n+\tfprintf (stream, \"%s\", fp_const_from_val (&r));\n+      }\n+      return;\n+\n+    case 'B':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (stream,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t \"%d\",\n+#else\n+\t\t \"%ld\",\n+#endif\n+\t\t ARM_SIGN_EXTEND (~ INTVAL (x)));\n+      else\n+\t{\n+\t  putc ('~', stream);\n+\t  output_addr_const (stream, x);\n+\t}\n+      return;\n+\n+    case 'i':\n+      fprintf (stream, \"%s\", arithmetic_instr (x, 1));\n+      return;\n+\n+    case 'I':\n+      fprintf (stream, \"%s\", arithmetic_instr (x, 0));\n+      return;\n+\n+    case 'S':\n+      {\n+\tHOST_WIDE_INT val;\n+\n+\tfprintf (stream, \"%s \", shift_op (x, &val));\n+\tif (val == -1)\n+\t  arm_print_operand (stream, XEXP (x, 1), 0);\n+\telse\n+\t  fprintf (stream,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t   \"#%d\",\n+#else\n+\t\t   \"#%ld\",\n+#endif\n+\t\t   val);\n+      }\n+      return;\n+\n+    case 'R':\n+      if (REGNO (x) > 15)\n+\tabort ();\n+      fputs (reg_names[REGNO (x) + 1], stream);\n+      return;\n+\n+    case 'm':\n+      if (GET_CODE (XEXP (x, 0)) == REG)\n+\tfputs (reg_names[REGNO (XEXP (x, 0))], stream);\n+      else\n+\tfputs (reg_names[REGNO (XEXP (XEXP (x, 0), 0))], stream);\n+      return;\n+\n+    case 'M':\n+      fprintf (stream, \"{%s-%s}\", reg_names[REGNO (x)],\n+\t       reg_names[REGNO (x) - 1\n+\t\t\t + ((GET_MODE_SIZE (GET_MODE (x))\n+\t\t\t     + GET_MODE_SIZE (SImode) - 1)\n+\t\t\t    / GET_MODE_SIZE (SImode))]);\n+      return;\n+\n+    case 'd':\n+      if (x)\n+        fputs (arm_condition_codes[get_arm_condition_code (x)],\n+\t       stream);\n+      return;\n+\n+    case 'D':\n+      if (x && (flag_fast_math\n+\t\t|| GET_CODE (x) == EQ || GET_CODE (x) == NE\n+\t\t|| (GET_MODE (XEXP (x, 0)) != CCFPEmode\n+\t\t    && (GET_MODE_CLASS (GET_MODE (XEXP (x, 0)))\n+\t\t\t!= MODE_FLOAT))))\n+        fputs (arm_condition_codes[ARM_INVERSE_CONDITION_CODE\n+\t\t\t\t   (get_arm_condition_code (x))],\n+\t       stream);\n+      return;\n+\n+    default:\n+      if (x == 0)\n+\tabort ();\n+\n+      if (GET_CODE (x) == REG)\n+\tfputs (reg_names[REGNO (x)], stream);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  output_memory_reference_mode = GET_MODE (x);\n+\t  output_address (XEXP (x, 0));\n+\t}\n+      else if (GET_CODE (x) == CONST_DOUBLE)\n+\tfprintf (stream, \"#%s\", fp_immediate_constant (x));\n+      else if (GET_CODE (x) == NEG)\n+\tabort (); /* This should never happen now. */\n+      else\n+\t{\n+\t  fputc ('#', stream);\n+\t  output_addr_const (stream, x);\n+\t}\n+    }\n+}\n+\n /* Increase the `arm_text_location' by AMOUNT if we're in the text\n    segment.  */\n \n@@ -2143,7 +2205,7 @@ output_load_symbol (insn, operands)\n     abort ();\n \n   /* When generating the instructions, we never mask out the bits that we\n-     think will be always zero, then if a mistake has occureed somewhere, the\n+     think will be always zero, then if a mistake has occured somewhere, the\n      assembler will spot it and generate an error.  */\n \n   /* If the symbol is word aligned then we might be able to reduce the\n@@ -2166,12 +2228,12 @@ output_load_symbol (insn, operands)\n     {\n       if (inst == 8)\n \t{\n-\t  strcpy (buffer, \"sub\\t%0, pc, #(8 + . -%a1)\");\n+\t  strcpy (buffer, \"sub%?\\t%0, pc, #(8 + . -%a1)\");\n \t  if ((never_mask | mask) != 0xffffffff)\n \t    sprintf (buffer + strlen (buffer), \" & 0x%x\", mask | never_mask);\n \t}\n       else\n-\tsprintf (buffer, \"sub\\t%%0, %%0, #(%d + . -%%a1) & 0x%x\",\n+\tsprintf (buffer, \"sub%%?\\t%%0, %%0, #(%d + . -%%a1) & 0x%x\",\n \t\t inst, mask | never_mask);\n \n       output_asm_insn (buffer, operands);\n@@ -2235,15 +2297,6 @@ output_lcomm_directive (stream, name, size, rounded)\n    time.  But then, I want to reduce the code size to somewhere near what\n    /bin/cc produces.  */\n \n-/* The condition codes of the ARM, and the inverse function.  */\n-char *arm_condition_codes[] =\n-{\n-  \"eq\", \"ne\", \"cs\", \"cc\", \"mi\", \"pl\", \"vs\", \"vc\",\n-  \"hi\", \"ls\", \"ge\", \"lt\", \"gt\", \"le\", \"al\", \"nv\"\n-};\n-\n-#define ARM_INVERSE_CONDITION_CODE(X)  ((X) ^ 1)\n-\n /* Returns the index of the ARM condition code string in\n    `arm_condition_codes'.  COMPARISON should be an rtx like\n    `(eq (...) (...))'.  */"}]}