{"sha": "8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY4MmIxYTUwOGU1YmE5YmQyZTFiMmI0ZDI5OGJmN2QwN2EzN2Y4MA==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2019-10-07T15:58:19Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2019-10-07T15:58:19Z"}, "message": "MSP430: Don't generate 430X insns when handling data in the lower memory region\n\ngcc/ChangeLog:\n\n2019-10-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* config.in: Regenerate.\n\t* config/msp430/constraints.md: Fix docstring for \"Ys\" constraint.\n\tAdd new \"Yx\" constraint.\n\t* config/msp430/driver-msp430.c (msp430_propagate_region_opt): New spec\n\tfunction.\n\t* config/msp430/msp430-protos.h (msp430_op_not_in_high_mem): New\n\tprototype.\n\t* config/msp430/msp430.c (msp430_option_override): Allow the lower\n\tcode/data region to be selected in the small memory model.\n\t(msp430_section_attr): Don't warn if the \"section\" and \"lower\"\n\tattributes are used together.\n\t(msp430_handle_generic_attribute): Likewise.\n\t(msp430_var_in_low_mem): New function.\n\t(TARGET_ENCODE_SECTION_INFO): Define.\n\t(msp430_encode_section_info): New function.\n\t(gen_prefix): Return early in the small memory model.\n\tRequire TARGET_USE_LOWER_REGION_PREFIX to be set before adding the\n\t\".lower\" prefix if -m{code,data}-region=lower have been passed.\n\t(msp430_output_aligned_decl_common): Emit common symbols when\n\t-mdata-region=lower is passed unless TARGET_USE_LOWER_REGION_PREFIX is\n\tset. \n\t(TARGET_ASM_FILE_END): Define.\n\t(msp430_file_end): New function.\n\t(msp430_do_not_relax_short_jumps): Allow relaxation when\n\tfunction will be in the lower region.\n\t(msp430_op_not_in_high_mem): New function.\n\t(msp430_print_operand): Check \"msp430_op_not_in_high_mem\" for\n\tthe 'X' operand selector. \n\tClarify comment for 'x' operand selector.\n\t* config/msp430/msp430.h (LINK_SPEC): Propagate\n\t-m{code,data}-region to the linker via spec function\n\tmsp430_propagate_region_opt.\n\t(msp430_propagate_region_opt): New prototype.\n\t(EXTRA_SPEC_FUNCTIONS): Add msp430_propagate_region_opt.\n\t(SYMBOL_FLAG_LOW_MEM): Define.\n\t* config/msp430/msp430.md (addsipsi3): Add missing \"%X\" operand\n\tselector.\n\t(zero_extendqihi2): Fix operand number used by \"%X\" selector.\n\t(zero_extendqisi2): Likewise.\n\t(zero_extendhisi2): Likewise.\n\t(movqi): Use \"Yx\" constraint in place of \"%X\" operand selector.\n\t(movhi): Likewise.\n\t(addqi3): Likewise.\n\t(addhi3): Likewise.\n\t(addsi3): Likewise.\n\t(addhi3_cy): Likewise.\n\t(addchi4_cy): Likewise.\n\t(subqi3): Likewise.\n\t(subhi3): Likewise.\n\t(subsi3): Likewise.\n\t(bic<mode>3): Likewise.\n\t(and<mode>3): Likewise.\n\t(ior<mode>3): Likewise.\n\t(xor<mode>3): Likewise.\n\t(slli_1): Add missing \"%X\" operand selector.\n\t(slll_1): Likewise.\n\t(slll_2): Likewise.\n\t(srai_1): Likewise.\n\t(sral_1): Likewise.\n\t(sral_2): Likewise.\n\t(srli_1): Likewise.\n\t(srll_1): Likewise.\n\t(cbranchqi4_real): Use \"Yx\" constraint in place of \"%X\" operand\n\tselector.\n\t(cbranchhi4_real): Likewise.\n\t(cbranchqi4_reversed): Likewise.\n\t(cbranchhi4_reversed): Likewise.\n\t(*bitbranch<mode>4): Likewise.\n\t(*bitbranch<mode>4_z): Remove unnecessary \"%x\" operand selector.\n\t* config/msp430/msp430.opt (mcode-region=): Set default to\n\tMSP430_REGION_LOWER. Improve docstring.\n\t(mdata-region=): Likewise.\n\t(muse-lower-region-prefix): New option.\n\t* config/msp430/t-msp430 (MULTILIB_OPTIONS): Add\n\tmdata-region=none multilib. \n\t(MULTILIB_MATCHES): Set mdata-region={upper,either} to match\n\tmdata-region=none multilib. \n\tMULTILIB_EXCEPTIONS: Remove.\n\tMULTILIB_REQUIRED: Define.\n\t* configure: Regenerate.\n\t* configure.ac: Define HAVE_AS_GNU_ATTRIBUTE and\n\tHAVE_AS_MSPABI_ATTRIBUTE if GAS version >= 2.33.50.\n\t* doc/extend.texi: Clarify comment for {upper,lower,either}\n\tfunction attributes.\n\tAdd separate description for \"lower\" variable attribute.\n\ngcc/testsuite/ChangeLog:\n\n2019-10-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* gcc.target/msp430/430x-insns.c: New test.\n\t* gcc.target/msp430/data-attributes-2.c: Remove dg-warning\n\tdirectives for conflicts between the \"section\" and \"lower\" attributes.\n\t* gcc.target/msp430/msp430.exp\n\t(check_effective_target_msp430_region_not_lower): New.\n\t(check_effective_target_msp430_region_lower): New.\n\t* gcc.target/msp430/object-attributes-430.c: New test.\n\t* gcc.target/msp430/object-attributes-default.c: New test.\n\t* gcc.target/msp430/object-attributes-mlarge-any-region.c: New test.\n\t* gcc.target/msp430/object-attributes-mlarge.c: New test.\n\nFrom-SVN: r276665", "tree": {"sha": "0ca5ebb630b7aaee342feadcf29e07af6e22fd9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ca5ebb630b7aaee342feadcf29e07af6e22fd9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b06099d407225a28f12ed600ae561aa8317dfc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b06099d407225a28f12ed600ae561aa8317dfc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b06099d407225a28f12ed600ae561aa8317dfc9"}], "stats": {"total": 2387, "additions": 2256, "deletions": 131}, "files": [{"sha": "74afcaa120c97cdad14263c2f69ed157d9869a0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -1,3 +1,91 @@\n+2019-10-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* config.in: Regenerate.\n+\t* config/msp430/constraints.md: Fix docstring for \"Ys\" constraint.\n+\tAdd new \"Yx\" constraint.\n+\t* config/msp430/driver-msp430.c (msp430_propagate_region_opt): New spec\n+\tfunction.\n+\t* config/msp430/msp430-protos.h (msp430_op_not_in_high_mem): New\n+\tprototype.\n+\t* config/msp430/msp430.c (msp430_option_override): Allow the lower\n+\tcode/data region to be selected in the small memory model.\n+\t(msp430_section_attr): Don't warn if the \"section\" and \"lower\"\n+\tattributes are used together.\n+\t(msp430_handle_generic_attribute): Likewise.\n+\t(msp430_var_in_low_mem): New function.\n+\t(TARGET_ENCODE_SECTION_INFO): Define.\n+\t(msp430_encode_section_info): New function.\n+\t(gen_prefix): Return early in the small memory model.\n+\tRequire TARGET_USE_LOWER_REGION_PREFIX to be set before adding the\n+\t\".lower\" prefix if -m{code,data}-region=lower have been passed.\n+\t(msp430_output_aligned_decl_common): Emit common symbols when\n+\t-mdata-region=lower is passed unless TARGET_USE_LOWER_REGION_PREFIX is\n+\tset. \n+\t(TARGET_ASM_FILE_END): Define.\n+\t(msp430_file_end): New function.\n+\t(msp430_do_not_relax_short_jumps): Allow relaxation when\n+\tfunction will be in the lower region.\n+\t(msp430_op_not_in_high_mem): New function.\n+\t(msp430_print_operand): Check \"msp430_op_not_in_high_mem\" for\n+\tthe 'X' operand selector. \n+\tClarify comment for 'x' operand selector.\n+\t* config/msp430/msp430.h (LINK_SPEC): Propagate\n+\t-m{code,data}-region to the linker via spec function\n+\tmsp430_propagate_region_opt.\n+\t(msp430_propagate_region_opt): New prototype.\n+\t(EXTRA_SPEC_FUNCTIONS): Add msp430_propagate_region_opt.\n+\t(SYMBOL_FLAG_LOW_MEM): Define.\n+\t* config/msp430/msp430.md (addsipsi3): Add missing \"%X\" operand\n+\tselector.\n+\t(zero_extendqihi2): Fix operand number used by \"%X\" selector.\n+\t(zero_extendqisi2): Likewise.\n+\t(zero_extendhisi2): Likewise.\n+\t(movqi): Use \"Yx\" constraint in place of \"%X\" operand selector.\n+\t(movhi): Likewise.\n+\t(addqi3): Likewise.\n+\t(addhi3): Likewise.\n+\t(addsi3): Likewise.\n+\t(addhi3_cy): Likewise.\n+\t(addchi4_cy): Likewise.\n+\t(subqi3): Likewise.\n+\t(subhi3): Likewise.\n+\t(subsi3): Likewise.\n+\t(bic<mode>3): Likewise.\n+\t(and<mode>3): Likewise.\n+\t(ior<mode>3): Likewise.\n+\t(xor<mode>3): Likewise.\n+\t(slli_1): Add missing \"%X\" operand selector.\n+\t(slll_1): Likewise.\n+\t(slll_2): Likewise.\n+\t(srai_1): Likewise.\n+\t(sral_1): Likewise.\n+\t(sral_2): Likewise.\n+\t(srli_1): Likewise.\n+\t(srll_1): Likewise.\n+\t(cbranchqi4_real): Use \"Yx\" constraint in place of \"%X\" operand\n+\tselector.\n+\t(cbranchhi4_real): Likewise.\n+\t(cbranchqi4_reversed): Likewise.\n+\t(cbranchhi4_reversed): Likewise.\n+\t(*bitbranch<mode>4): Likewise.\n+\t(*bitbranch<mode>4_z): Remove unnecessary \"%x\" operand selector.\n+\t* config/msp430/msp430.opt (mcode-region=): Set default to\n+\tMSP430_REGION_LOWER. Improve docstring.\n+\t(mdata-region=): Likewise.\n+\t(muse-lower-region-prefix): New option.\n+\t* config/msp430/t-msp430 (MULTILIB_OPTIONS): Add\n+\tmdata-region=none multilib. \n+\t(MULTILIB_MATCHES): Set mdata-region={upper,either} to match\n+\tmdata-region=none multilib. \n+\tMULTILIB_EXCEPTIONS: Remove.\n+\tMULTILIB_REQUIRED: Define.\n+\t* configure: Regenerate.\n+\t* configure.ac: Define HAVE_AS_GNU_ATTRIBUTE and\n+\tHAVE_AS_MSPABI_ATTRIBUTE if GAS version >= 2.33.50.\n+\t* doc/extend.texi: Clarify comment for {upper,lower,either}\n+\tfunction attributes.\n+\tAdd separate description for \"lower\" variable attribute.\n+\n 2019-10-07  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/77918"}, {"sha": "9b54a4715db310334239476a00ede1d92b4eb4b8", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -553,6 +553,12 @@\n #endif\n \n \n+/* Define if your assembler supports .mspabi_attribute. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_MSPABI_ATTRIBUTE\n+#endif\n+\n+\n /* Define if the assembler understands -mnan=. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_NAN"}, {"sha": "4422b2b6454560deba17edbed3edc0dffb94bd7d", "filename": "gcc/config/msp430/constraints.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fconstraints.md?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -69,9 +69,11 @@\n \n \n ;; These are memory references that are safe to use without the X suffix,\n-;; because we know/assume they need not index across the 64k boundary.\n+;; because we know/assume they need not index across the 64K boundary.\n+;; Note that for a PSImode memory operand, we always need to use the X suffix,\n+;; regardless of what this constraint decides.\n (define_constraint \"Ys\"\n-  \"Memory reference, stack only.\"\n+  \"Memory reference, indexed or indirect register addressing modes.\"\n   (and (match_code \"mem\")\n        (ior\n \t(and (match_code \"plus\" \"0\")\n@@ -93,3 +95,7 @@\n \t\t  (match_test (\"REGNO (XEXP (XEXP (op, 0), 0)) != SP_REGNO\")))\n \t     ))))\n \n+(define_constraint \"Yx\"\n+  \"Memory reference, in lower memory below address 0x10000.\"\n+  (and (match_code \"mem\")\n+       (match_test \"msp430_op_not_in_high_mem (op)\")))"}, {"sha": "c37b169ff8b27510a17003d19370ff22a5e61f38", "filename": "gcc/config/msp430/driver-msp430.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fdriver-msp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fdriver-msp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fdriver-msp430.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -149,3 +149,16 @@ msp430_select_hwmult_lib (int argc ATTRIBUTE_UNUSED,\n \n   return \"-lmul_none\";\n }\n+\n+/* Spec function.  Propagate -m{code,data}-region= to the linker, unless the\n+   lower region has been specified without -muse-lower-region-prefix also being\n+   used.  */\n+const char *\n+msp430_propagate_region_opt (int argc, const char **argv)\n+{\n+  if (strcmp (argv[0], \"lower\") != 0)\n+    return argv[0];\n+  else if ((argc == 2) && (strcmp (argv[1], \"-muse-lower-region-prefix\") == 0))\n+    return argv[0]; /* argv[0] == \"lower\".  */\n+  return \"none\";\n+}"}, {"sha": "1c1757fc7ab75de414fa1c7b39d9efd8f6d2953a", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -47,5 +47,6 @@ void\tmsp430_split_movsi (rtx *);\n void    msp430_start_function (FILE *, const char *, tree);\n rtx\tmsp430_subreg (machine_mode, rtx, machine_mode, int);\n bool    msp430_use_f5_series_hwmult (void);\n+bool msp430_op_not_in_high_mem (rtx op);\n \n #endif /* GCC_MSP430_PROTOS_H */"}, {"sha": "354b4ddb4194ca5fde586865362907df2f341865", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 185, "deletions": 29, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -35,6 +35,7 @@\n #include \"tm_p.h\"\n #include \"regs.h\"\n #include \"emit-rtl.h\"\n+#include \"varasm.h\"\n #include \"diagnostic-core.h\"\n #include \"fold-const.h\"\n #include \"stor-layout.h\"\n@@ -263,20 +264,13 @@ msp430_option_override (void)\n   else if (!TARGET_LARGE && msp430_code_region == MSP430_REGION_UPPER)\n     error (\"%<-mcode-region=upper%> requires the large memory model \"\n \t   \"(%<-mlarge%>)\");\n-  else if (!TARGET_LARGE && msp430_code_region == MSP430_REGION_LOWER)\n-    error (\"%<-mcode-region=lower%> requires the large memory model \"\n-\t   \"(%<-mlarge%>)\");\n \n   if (!TARGET_LARGE && msp430_data_region == MSP430_REGION_EITHER)\n     error (\"%<-mdata-region=either%> requires the large memory model \"\n \t   \"(%<-mlarge%>)\");\n   else if (!TARGET_LARGE && msp430_data_region == MSP430_REGION_UPPER)\n     error (\"%<-mdata-region=upper%> requires the large memory model \"\n \t   \"(%<-mlarge%>)\");\n-  else if (!TARGET_LARGE && msp430_data_region == MSP430_REGION_LOWER)\n-    error (\"%<-mdata-region=lower%> requires the large memory model \"\n-\t   \"(%<-mlarge%>)\");\n-\n \n   if (flag_exceptions || flag_non_call_exceptions\n       || flag_unwind_tables || flag_asynchronous_unwind_tables)\n@@ -1386,7 +1380,7 @@ msp430_section_attr (tree * node,\n   if (has_attr (ATTR_NOINIT, *node))\n     message = G_(\"ignoring attribute %qE because it conflicts with \"\n \t\t \"attribute %<noinit%>\");\n-  else if (has_attr (\"section\", *node))\n+  else if (has_attr (\"section\", *node) && !TREE_NAME_EQ (name, \"lower\"))\n     message = G_(\"ignoring attribute %qE because it conflicts with \"\n \t\t \"attribute %<section%>\");\n   /* It does not make sense to use upper/lower/either attributes without\n@@ -1564,12 +1558,14 @@ msp430_handle_generic_attribute (tree *node,\n {\n   const char *message = NULL;\n \n+  /* The front end has set up an exclusion between the \"noinit\" and \"section\"\n+     attributes.  */\n   if (!(TREE_NAME_EQ (name, ATTR_NOINIT) || TREE_NAME_EQ (name, \"section\")))\n     return NULL_TREE;\n \n-  /* The front end has set up an exclusion between the \"noinit\" and \"section\"\n-     attributes.  */\n-  if (has_attr (ATTR_LOWER, *node))\n+  /* We allow the \"lower\" attribute to be used on variables with the \"section\"\n+     attribute.  */\n+  if (has_attr (ATTR_LOWER, *node) && !TREE_NAME_EQ (name, \"section\"))\n     message = G_(\"ignoring attribute %qE because it conflicts with \"\n \t\t \"attribute %<lower%>\");\n   else if (has_attr (ATTR_UPPER, *node))\n@@ -1591,6 +1587,55 @@ msp430_handle_generic_attribute (tree *node,\n   return NULL_TREE;\n }\n \n+/* Given a non-automatic VAR_DECL which can possibly have a section, return\n+   true if the variable will definitely be placed in the lower memory\n+   region (below address 0x10000).  */\n+static bool\n+msp430_var_in_low_mem (tree decl)\n+{\n+  gcc_assert (VAR_P (decl));\n+\n+  /* \"noinit\" variables are always placed in the lower memory region.  */\n+  if (has_attr (ATTR_UPPER, decl)\n+      || has_attr (ATTR_EITHER, decl)\n+      || has_attr (ATTR_PERSIST, decl)\n+      /* Unless the variable is marked with the lower or noinit attribute, we\n+\t cannot assume that it is in the lower region if it is marked with the\n+\t section attribute or -mdata-region={upper,either,none} have been\n+\t passed.\n+\t The noinit and section attributes conflict.  */\n+      || (!has_attr (ATTR_LOWER, decl) && !has_attr (ATTR_NOINIT, decl)\n+\t  && (has_attr (\"section\", decl)\n+\t      || msp430_data_region == MSP430_REGION_UPPER\n+\t      || msp430_data_region == MSP430_REGION_EITHER\n+\t      || msp430_data_region == MSP430_REGION_ANY)))\n+    return false;\n+  return true;\n+}\n+\n+#undef TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO msp430_encode_section_info\n+\n+/* Encode whether a SYMBOL_REF is definitely in the lower memory region.  */\n+static void\n+msp430_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  rtx symbol;\n+  default_encode_section_info (decl, rtl, first);\n+\n+  /* Careful not to prod global register variables.  */\n+  if (!MEM_P (rtl))\n+    return;\n+  symbol = XEXP (rtl, 0);\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return;\n+\n+  if (VAR_P (decl)\n+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n+      && msp430_var_in_low_mem (decl))\n+    SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOW_MEM;\n+}\n+\n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE\tmsp430_start_function\n \n@@ -1744,15 +1789,17 @@ gen_prefix (tree decl)\n   if (has_section_name (\".lowtext\", decl))\n     return NULL;\n \n-  /* If the object has __attribute__((lower)) then use the \".lower.\" prefix.  */\n+  /* Memory regions require the large memory model.  */\n+  if (!TARGET_LARGE)\n+    return NULL;\n+\n+  /* Note that we always apply the lower prefix when the attribute has been\n+     used.  But we only apply the lower prefix when the lower region has been\n+     specified by a command line option if -muse-lower-region-prefix has also\n+     been passed.  */\n   if (has_attr (ATTR_LOWER, decl))\n     return lower_prefix;\n \n-  /* If we are compiling for the MSP430 then we do not support the upper\n-     region.  */\n-  if (! msp430x)\n-    return NULL;\n-\n   if (has_attr (ATTR_UPPER, decl))\n     return upper_prefix;\n \n@@ -1761,7 +1808,8 @@ gen_prefix (tree decl)\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      if (msp430_code_region == MSP430_REGION_LOWER)\n+      if ((msp430_code_region == MSP430_REGION_LOWER)\n+\t  && TARGET_USE_LOWER_REGION_PREFIX)\n \treturn lower_prefix;\n \n       if (msp430_code_region == MSP430_REGION_UPPER)\n@@ -1772,7 +1820,8 @@ gen_prefix (tree decl)\n     }\n   else\n     {\n-      if (msp430_data_region == MSP430_REGION_LOWER)\n+      if ((msp430_data_region == MSP430_REGION_LOWER)\n+\t  && TARGET_USE_LOWER_REGION_PREFIX)\n \treturn lower_prefix;\n \n       if (msp430_data_region == MSP430_REGION_UPPER)\n@@ -1966,7 +2015,6 @@ msp430_unique_section (tree decl, int reloc)\n /* Emit a declaration of a common symbol.\n    If a data region is in use then put the symbol into the\n    equivalent .bss section instead.  */\n-\n void\n msp430_output_aligned_decl_common (FILE *\t\t  stream,\n \t\t\t\t   const tree\t\t  decl,\n@@ -1976,7 +2024,9 @@ msp430_output_aligned_decl_common (FILE *\t\t  stream,\n {\n   /* Only emit a common symbol if the variable does not have a specific section\n      assigned.  */\n-  if (msp430_data_region == MSP430_REGION_ANY\n+  if ((msp430_data_region == MSP430_REGION_ANY\n+       || ((msp430_data_region == MSP430_REGION_LOWER)\n+\t   && !TARGET_USE_LOWER_REGION_PREFIX))\n       && !(decl != NULL_TREE && DECL_SECTION_NAME (decl))\n       && !has_attr (ATTR_EITHER, decl)\n       && !has_attr (ATTR_LOWER, decl)\n@@ -2021,6 +2071,78 @@ msp430_output_aligned_decl_common (FILE *\t\t  stream,\n     }\n }\n \n+#undef TARGET_ASM_FILE_END\n+#define TARGET_ASM_FILE_END msp430_file_end\n+\n+/* Emit MSPABI and GNU object attributes.\n+   Tags and values for MSPABI attributes are:\n+   OFBA_MSPABI_Tag_ISA\t\t4\n+     MSP430\t1\n+     MSP430X\t2\n+   OFBA_MSPABI_Tag_Code_Model\t6\n+     Small \t1\n+     Large\t2\n+   OFBA_MSPABI_Tag_Data_Model\t8\n+     Small \t1\n+     Large\t2\n+     Restricted\t3 (Unused by GNU)\n+   OFBA_MSPABI_Tag_enum_size\t10 (Unused by GNU)\n+   Note that Code_Model and Data_Model are always equal for GNU.\n+   We define a new .gnu_attribute to keep track of the data region used.\n+   Tag_GNU_MSP430_Data_Region\t4\n+     LOWER\t1\n+     ANY\t2\n+   See binutils-gdb/include/elf/msp430.h for the full details.  */\n+static void\n+msp430_file_end (void)\n+{\n+#ifdef HAVE_AS_GNU_ATTRIBUTE\n+  /* Enum for tag names.  */\n+  enum\n+    {\n+      OFBA_MSPABI_Tag_ISA = 4,\n+      OFBA_MSPABI_Tag_Code_Model = 6,\n+      OFBA_MSPABI_Tag_Data_Model = 8,\n+      Tag_GNU_MSP430_Data_Region = 4\n+    };\n+  /* Enum for tag values.  */\n+  enum\n+    {\n+      OFBA_MSPABI_Val_ISA_MSP430 = 1,\n+      OFBA_MSPABI_Val_ISA_MSP430X = 2,\n+      OFBA_MSPABI_Val_Model_Small = 1,\n+      OFBA_MSPABI_Val_Model_Large = 2,\n+      Tag_GNU_MSP430_Data_Region_Lower = 1,\n+      Tag_GNU_MSP430_Data_Region_Any = 2\n+    };\n+  /* .mspabi_attribute is a GNU assembler directive only.  The assembler will\n+     construct a .MSP430.attributes section based on the options it is invoked\n+     with.  The values it reads from these directives are used for validating\n+     those options.  */\n+  const char *msp_attr = \".mspabi_attribute\";\n+  const char *gnu_attr = \".gnu_attribute\";\n+\n+  /* Emit .mspabi_attribute directive for OFBA_MSPABI_Tag_ISA.  */\n+  fprintf (asm_out_file, \"\\t%s %d, %d\\n\", msp_attr, OFBA_MSPABI_Tag_ISA,\n+\t   msp430x ? OFBA_MSPABI_Val_ISA_MSP430X : OFBA_MSPABI_Val_ISA_MSP430);\n+  /* Emit .mspabi_attribute directive for OFBA_MSPABI_Tag_Code_Model.  */\n+  fprintf (asm_out_file, \"\\t%s %d, %d\\n\", msp_attr, OFBA_MSPABI_Tag_Code_Model,\n+\t   TARGET_LARGE ? OFBA_MSPABI_Val_Model_Large\n+\t   : OFBA_MSPABI_Val_Model_Small);\n+  /* Emit .mspabi_attribute directive for OFBA_MSPABI_Tag_Data_Model.  */\n+  fprintf (asm_out_file, \"\\t%s %d, %d\\n\", msp_attr, OFBA_MSPABI_Tag_Data_Model,\n+\t   TARGET_LARGE ? OFBA_MSPABI_Val_Model_Large\n+\t   : OFBA_MSPABI_Val_Model_Small);\n+#ifdef HAVE_AS_MSPABI_ATTRIBUTE\n+  /* Emit .gnu_attribute directive for Tag_GNU_MSP430_Data_Region.  */\n+  fprintf (asm_out_file, \"\\t%s %d, %d\\n\", gnu_attr, Tag_GNU_MSP430_Data_Region,\n+\t   msp430_data_region == MSP430_REGION_LOWER\n+\t   ? Tag_GNU_MSP430_Data_Region_Lower\n+\t   : Tag_GNU_MSP430_Data_Region_Any);\n+#endif\n+#endif\n+}\n+\n bool\n msp430_do_not_relax_short_jumps (void)\n {\n@@ -2031,9 +2153,7 @@ msp430_do_not_relax_short_jumps (void)\n      end up in a low section.  */\n   return\n     msp430_code_region == MSP430_REGION_EITHER\n-    || msp430_code_region == MSP430_REGION_LOWER\n-    || has_attr (ATTR_EITHER, current_function_decl)\n-    || has_attr (ATTR_LOWER, current_function_decl);\n+    || has_attr (ATTR_EITHER, current_function_decl);\n }\n \n enum msp430_builtin\n@@ -3074,6 +3194,36 @@ msp430_print_operand_addr (FILE * file, machine_mode /*mode*/, rtx addr)\n   msp430_print_operand_raw (file, addr);\n }\n \n+/* Determine whether an RTX is definitely not a MEM referencing an address in\n+   the upper memory region.  Returns true if we've decided the address will be\n+   in the lower memory region, or the RTX is not a MEM.  Returns false\n+   otherwise.  */\n+bool\n+msp430_op_not_in_high_mem (rtx op)\n+{\n+  rtx op0;\n+\n+  if (!TARGET_LARGE || !MEM_P (op))\n+    return true;\n+\n+  op0 = XEXP (op, 0);\n+\n+  if (SYMBOL_REF_P (op0) && (SYMBOL_REF_FLAGS (op0) & SYMBOL_FLAG_LOW_MEM))\n+    /* msp430_encode_section_info decided this mem will be in lower\n+       memory.  */\n+    return true;\n+\n+  /* Catch (mem (const (plus ((symbol_ref) (const_int))))) e.g. &addr+2.  */\n+  if ((GET_CODE (op0) == CONST)\n+      && (GET_CODE (XEXP (op0, 0)) == PLUS)\n+      && (SYMBOL_REF_P (XEXP (XEXP (op0, 0), 0)))\n+      && (SYMBOL_REF_FLAGS (XEXP (XEXP (op0, 0), 0)) & SYMBOL_FLAG_LOW_MEM))\n+    return true;\n+\n+  /* Return false when undecided.  */\n+  return false;\n+}\n+\n #undef  TARGET_PRINT_OPERAND\n #define TARGET_PRINT_OPERAND\t\tmsp430_print_operand\n \n@@ -3245,15 +3395,21 @@ msp430_print_operand (FILE * file, rtx op, int letter)\n \n     case 'X':\n       /* This is used to turn, for example, an ADD opcode into an ADDX\n-\t opcode when we're using 20-bit addresses.  */\n-      if (TARGET_LARGE || GET_MODE (op) == PSImode)\n+\t opcode when we're using 20-bit addresses.\n+\t This can be used for insns which have only one operand which might be\n+\t a mem.\n+\t If an insn has two different operands which could be memory operands,\n+\t then the \"Yx\" constraint must be used to determine if the X suffix is\n+\t required by checking both operands.  */\n+      if (GET_MODE (op) == PSImode\n+\t  || !msp430_op_not_in_high_mem (op))\n \tfprintf (file, \"X\");\n-      /* We don't care which operand we use, but we want 'X' in the MD\n-\t file, so we do it this way.  */\n       return;\n \n     case 'x':\n-      /* Similarly, but only for PSImodes.  BIC, for example, needs this.  */\n+      /* Similarly, but only for PSImodes.  BIC, and other insn patterns using\n+\t the QHI mode iterator (which includes, QI, HI, and PSImode) use\n+\t this.  */\n       if (GET_MODE (op) == PSImode)\n \tfprintf (file, \"X\");\n       return;"}, {"sha": "f885de2bb2face2a266072c5fc6e5cf14ee27da2", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -71,7 +71,10 @@ extern bool msp430x;\n    is enabled  (the GDB testsuite relies upon unused entities not being\n    deleted).  */\n #define LINK_SPEC \"%{mrelax:--relax} %{mlarge:%{!r:%{!g:--gc-sections}}} \" \\\n-  \"%{mcode-region=*:--code-region=%*} %{mdata-region=*:--data-region=%*}\"\n+  \"%{mcode-region=*:--code-region=%:\" \\\n+    \"msp430_propagate_region_opt(%* %{muse-lower-region-prefix})} \" \\\n+  \"%{mdata-region=*:--data-region=%:\" \\\n+    \"msp430_propagate_region_opt(%* %{muse-lower-region-prefix})} \" \\\n \n #define DRIVER_SELF_SPECS \\\n   \" %{!mlarge:%{mcode-region=*:%{mdata-region=*:%e-mcode-region and \"\t\\\n@@ -90,12 +93,16 @@ extern const char * msp430_select_hwmult_lib (int, const char **);\n extern const char * msp430_select_cpu (int, const char **);\n extern const char * msp430_set_driver_var (int, const char **);\n extern const char * msp430_check_path_for_devices (int, const char **);\n+extern const char *msp430_propagate_region_opt (int, const char **);\n \n+/* There must be a trailing comma after the last item, see gcc.c\n+   \"static_spec_functions\".  */\n # define EXTRA_SPEC_FUNCTIONS\t\t\t\t\\\n   { \"msp430_hwmult_lib\", msp430_select_hwmult_lib },\t\\\n   { \"msp430_select_cpu\", msp430_select_cpu },\t\t\\\n   { \"msp430_set_driver_var\", msp430_set_driver_var },\t\t\\\n-  { \"msp430_check_path_for_devices\", msp430_check_path_for_devices },\n+  { \"msp430_check_path_for_devices\", msp430_check_path_for_devices }, \\\n+  { \"msp430_propagate_region_opt\", msp430_propagate_region_opt },\n \n /* Specify the libraries to include on the linker command line.\n \n@@ -482,3 +489,5 @@ typedef struct\n \n #define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n   msp430_output_aligned_decl_common ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n+\n+#define SYMBOL_FLAG_LOW_MEM (SYMBOL_FLAG_MACH_DEP << 0)"}, {"sha": "c72f7aade30bd7b5617d088c0149c9f9a6a55a4d", "filename": "gcc/config/msp430/msp430.md", "status": "modified", "additions": 92, "deletions": 84, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.md?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -190,22 +190,22 @@\n )\n \n (define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n-\t(match_operand:QI 1 \"msp_general_operand\" \"riYs,rmi\"))]\n+  [(set (match_operand:QI 0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n+\t(match_operand:QI 1 \"msp_general_operand\" \"riYsYx,rmi\"))]\n   \"\"\n   \"@\n   MOV.B\\t%1, %0\n-  MOV%X0.B\\t%1, %0\"\n+  MOVX.B\\t%1, %0\"\n )\n \n (define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"msp_nonimmediate_operand\" \"=r,rYs,rm\")\n-\t(match_operand:HI 1 \"msp_general_operand\" \"N,riYs,rmi\"))]\n+  [(set (match_operand:HI 0 \"msp_nonimmediate_operand\" \"=r,rYsYx,rm\")\n+\t(match_operand:HI 1 \"msp_general_operand\" \"N,riYsYx,rmi\"))]\n   \"\"\n   \"@\n   MOV.B\\t%1, %0\n   MOV.W\\t%1, %0\n-  MOV%X0.W\\t%1, %0\"\n+  MOVX.W\\t%1, %0\"\n )\n \n (define_expand \"movsi\"\n@@ -241,7 +241,7 @@\n   \"msp430_split_movsi (operands);\"\n )\n \n-;; Some MOVX.A cases can be done with MOVA, this is only a few of them.\n+;; FIXME: Some MOVX.A cases can be done with MOVA, this is only a few of them.\n (define_insn \"movpsi\"\n   [(set (match_operand:PSI 0 \"msp_nonimmediate_operand\" \"=r,r,r,Ya,rm\")\n \t(match_operand:PSI 1 \"msp_general_operand\" \"N,O,riYa,r,rmi\"))]\n@@ -289,23 +289,23 @@\n )\n \n (define_insn \"addqi3\"\n-  [(set (match_operand:QI          0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n+  [(set (match_operand:QI          0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n \t(plus:QI (match_operand:QI 1 \"msp_nonimmediate_operand\" \"%0,0\")\n-\t\t (match_operand:QI 2 \"msp_general_operand\"      \"riYs,rmi\")))]\n+\t\t (match_operand:QI 2 \"msp_general_operand\"      \"riYsYx,rmi\")))]\n   \"\"\n   \"@\n    ADD.B\\t%2, %0\n-   ADD%X0.B\\t%2, %0\"\n+   ADDX.B\\t%2, %0\"\n )\n \n (define_insn \"addhi3\"\n-  [(set (match_operand:HI           0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n+  [(set (match_operand:HI           0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n \t(plus:HI (match_operand:HI  1 \"msp_nonimmediate_operand\" \"%0,0\")\n-\t\t  (match_operand:HI 2 \"msp_general_operand\"      \"riYs,rmi\")))]\n+\t\t  (match_operand:HI 2 \"msp_general_operand\"      \"riYsYx,rmi\")))]\n   \"\"\n   \"@\n    ADD.W\\t%2, %0\n-   ADD%X0.W\\t%2, %0\"\n+   ADDX.W\\t%2, %0\"\n )\n \n ; This pattern is needed in order to avoid reload problems.\n@@ -317,17 +317,17 @@\n \t(plus:SI (match_operand:SI    1 \"register_operand\" \"0\")\n \t\t (match_operand       2 \"general_operand\" \"rmi\")))]\n   \"\"\n-  \"ADD.W\\t%L2, %L0 { ADDC.W\\t%H2, %H0 { PUSH.W\\t%H0 { PUSH.W\\t%L0 { POPM.A\\t#1, %0\"\n+  \"ADD%X2.W\\t%L2, %L0 { ADDC%X2.W\\t%H2, %H0 { PUSH.W\\t%H0 { PUSH.W\\t%L0 { POPM.A\\t#1, %0\"\n )\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,rm\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&rYsYx,rm\")\n \t(plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"r,mi\")))]\n+\t\t (match_operand:SI 2 \"general_operand\" \"rYsYxi,mi\")))]\n   \"\"\n   \"@\n    ADD\\t%L2, %L0 { ADDC\\t%H2, %H0\n-   ADD%X0\\t%L2, %L0 { ADDC%X0\\t%H2, %H0\"\n+   ADDX\\t%L2, %L0 { ADDCX\\t%H2, %H0\"\n )\n \n ; Version of addhi that exposes the carry operations, for SImode adds.\n@@ -358,9 +358,9 @@\n ; that are not single_set() very well.\n \n (define_insn \"addhi3_cy\"\n-  [(set (match_operand:HI          0 \"msp_nonimmediate_operand\" \"=r,rm\")\n+  [(set (match_operand:HI          0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n \t(plus:HI (match_operand:HI 1 \"msp_nonimmediate_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"msp_nonimmediate_operand\" \"r,rm\")))\n+\t\t (match_operand:HI 2 \"msp_nonimmediate_operand\" \"rYsYxi,rm\")))\n    (set (reg:BI CARRY)\n \t(truncate:BI (lshiftrt:SI (plus:SI (zero_extend:SI (match_dup 1))\n \t\t\t\t\t   (zero_extend:SI (match_dup 2)))\n@@ -369,7 +369,7 @@\n   \"\"\n   \"@\n    ADD\\t%2, %1 ; cy\n-   ADD%X0\\t%2, %1 ; cy\"\n+   ADDX\\t%2, %1 ; cy\"\n   )\n \n (define_insn \"addhi3_cy_i\"\n@@ -389,15 +389,15 @@\n \n ; Version of addhi that adds the carry, for SImode adds.\n (define_insn \"addchi4_cy\"\n-  [(set (match_operand:HI                   0 \"msp_nonimmediate_operand\" \"=r,rm\")\n+  [(set (match_operand:HI                   0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n \t(plus:HI (plus:HI (match_operand:HI 1 \"msp_nonimmediate_operand\" \"%0,0\")\n-\t\t\t  (match_operand:HI 2 \"msp_general_operand\"      \"ri,rmi\"))\n+\t\t\t  (match_operand:HI 2 \"msp_general_operand\"      \"riYsYx,rmi\"))\n \t\t (zero_extend:HI (reg:BI CARRY))))\n    ]\n   \"\"\n   \"@\n    ADDC\\t%2, %1\n-   ADDC%X0\\t%2, %1\"\n+   ADDCX\\t%2, %1\"\n   )\n \n ; Split an SImode add into two HImode adds, keeping track of the carry\n@@ -458,36 +458,38 @@\n \n ;; Alternatives 2 and 3 are to handle cases generated by reload.\n (define_insn \"subqi3\"\n-  [(set (match_operand:QI           0 \"nonimmediate_operand\" \"=rYs,  rm,  &?r, ?&r\")\n+  [(set (match_operand:QI           0 \"nonimmediate_operand\" \"=rYsYx,  rm,  &?r, ?&r\")\n \t(minus:QI (match_operand:QI 1 \"general_operand\"       \"0,    0,    !r,  !i\")\n-\t\t  (match_operand:QI 2 \"general_operand\"      \" riYs, rmi, rmi,   r\")))]\n+\t\t  (match_operand:QI 2 \"general_operand\"      \" riYsYx, rmi, rmi,   r\")))]\n   \"\"\n   \"@\n   SUB.B\\t%2, %0\n-  SUB%X0.B\\t%2, %0\n-  MOV%X0.B\\t%1, %0 { SUB%X0.B\\t%2, %0\n+  SUBX.B\\t%2, %0\n+  MOV%X2.B\\t%1, %0 { SUB%X2.B\\t%2, %0\n   MOV%X0.B\\t%1, %0 { SUB%X0.B\\t%2, %0\"\n )\n \n ;; Alternatives 2 and 3 are to handle cases generated by reload.\n (define_insn \"subhi3\"\n-  [(set (match_operand:HI           0 \"nonimmediate_operand\" \"=rYs,  rm,  &?r, ?&r\")\n+  [(set (match_operand:HI           0 \"nonimmediate_operand\" \"=rYsYx,  rm,  &?r, ?&r\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\"       \"0,    0,    !r,  !i\")\n-\t\t  (match_operand:HI 2 \"general_operand\"      \" riYs, rmi, rmi,   r\")))]\n+\t\t  (match_operand:HI 2 \"general_operand\"      \" riYsYx, rmi, rmi,   r\")))]\n   \"\"\n   \"@\n   SUB.W\\t%2, %0\n-  SUB%X0.W\\t%2, %0\n-  MOV%X0.W\\t%1, %0 { SUB%X0.W\\t%2, %0\n+  SUBX.W\\t%2, %0\n+  MOV%X2.W\\t%1, %0 { SUB%X2.W\\t%2, %0\n   MOV%X0.W\\t%1, %0 { SUB%X0.W\\t%2, %0\"\n )\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI           0 \"nonimmediate_operand\" \"=&rm\")\n-\t(minus:SI (match_operand:SI 1 \"nonimmediate_operand\"   \"0\")\n-\t\t  (match_operand:SI 2 \"general_operand\"        \"rmi\")))]\n+  [(set (match_operand:SI           0 \"nonimmediate_operand\" \"=&rYsYx,m\")\n+\t(minus:SI (match_operand:SI 1 \"nonimmediate_operand\"   \"0,0\")\n+\t\t  (match_operand:SI 2 \"general_operand\"        \"riYsYx,mi\")))]\n   \"\"\n-  \"SUB%X0\\t%L2, %L0 { SUBC%X0\\t%H2, %H0\"\n+  \"@\n+  SUB\\t%L2, %L0 { SUBC\\t%H2, %H0\n+  SUBX\\t%L2, %L0 { SUBCX\\t%H2, %H0\"\n )\n \n (define_insn \"*bic<mode>_cg\"\n@@ -501,44 +503,44 @@\n )\n \n (define_insn \"bic<mode>3\"\n-  [(set (match_operand:QHI                   0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n-\t(and:QHI (not:QHI (match_operand:QHI 1 \"msp_general_operand\"       \"rYs,rmn\"))\n+  [(set (match_operand:QHI                   0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n+\t(and:QHI (not:QHI (match_operand:QHI 1 \"msp_general_operand\"       \"rYsYx,rmn\"))\n \t\t (match_operand:QHI          2 \"msp_nonimmediate_operand\"  \"0,0\")))]\n   \"\"\n   \"@\n    BIC%x0%b0\\t%1, %0\n-   BIC%X0%b0\\t%1, %0\"\n+   BICX%b0\\t%1, %0\"\n )\n \n (define_insn \"and<mode>3\"\n-  [(set (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"=r,rYs,rm\")\n+  [(set (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"=r,rYsYx,rm\")\n \t(and:QHI (match_operand:QHI 1 \"msp_nonimmediate_operand\" \"%0,0,0\")\n-\t\t (match_operand:QHI 2 \"msp_general_operand\" \"N,riYs,rmi\")))]\n+\t\t (match_operand:QHI 2 \"msp_general_operand\" \"N,riYsYx,rmi\")))]\n   \"\"\n   \"@\n    AND%x0.B\\t%2, %0\n    AND%x0%b0\\t%2, %0\n-   AND%X0%b0\\t%2, %0\"\n+   ANDX%b0\\t%2, %0\"\n )\n \n (define_insn \"ior<mode>3\"\n-  [(set (match_operand:QHI          0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n+  [(set (match_operand:QHI          0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n \t(ior:QHI (match_operand:QHI 1 \"msp_nonimmediate_operand\" \"%0,0\")\n-\t\t (match_operand:QHI 2 \"msp_general_operand\" \"riYs,rmi\")))]\n+\t\t (match_operand:QHI 2 \"msp_general_operand\" \"riYsYx,rmi\")))]\n   \"\"\n   \"@\n    BIS%x0%b0\\t%2, %0\n-   BIS%X0%b0\\t%2, %0\"\n+   BISX%b0\\t%2, %0\"\n )\n \n (define_insn \"xor<mode>3\"\n-  [(set (match_operand:QHI          0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n+  [(set (match_operand:QHI          0 \"msp_nonimmediate_operand\" \"=rYsYx,rm\")\n \t(xor:QHI (match_operand:QHI 1 \"msp_nonimmediate_operand\" \"%0,0\")\n-\t\t (match_operand:QHI 2 \"msp_general_operand\" \"riYs,rmi\")))]\n+\t\t (match_operand:QHI 2 \"msp_general_operand\" \"riYsYx,rmi\")))]\n   \"\"\n   \"@\n    XOR%x0%b0\\t%2, %0\n-   XOR%X0%b0\\t%2, %0\"\n+   XORX%b0\\t%2, %0\"\n )\n \n ;; Macro : XOR #~0, %0\n@@ -567,7 +569,7 @@\n   \"@\n    AND\\t#0xff, %0\n    MOV.B\\t%1, %0\n-   MOV%X0.B\\t%1, %0\n+   MOV%X1.B\\t%1, %0\n    AND%X0\\t#0xff, %0\"\n )\n \n@@ -621,15 +623,15 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n   \"\"\n-  \"MOV.B\\t%1,%L0 { CLR\\t%H0\"\n+  \"MOV%X1.B\\t%1,%L0 { CLR\\t%H0\"\n )\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,r\")))]\n   \"\"\n   \"@\n-  MOV.W\\t#0,%H0\n+  MOV%X0.W\\t#0,%H0\n   MOV.W\\t%1,%L0 { MOV.W\\t#0,%H0\"\n )\n \n@@ -782,7 +784,7 @@\n \t(ashift:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n \t\t   (const_int 1)))]\n   \"\"\n-  \"RLA.W\\t%0\" ;; Note - this is a macro for ADD\n+  \"RLA%X0.W\\t%0\" ;; Note - this is a macro for ADD\n )\n \n (define_insn \"430x_shift_left\"\n@@ -802,15 +804,15 @@\n \t(ashift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n \t\t   (const_int 1)))]\n   \"\"\n-  \"RLA.W\\t%L0 { RLC.W\\t%H0\"\n+  \"RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0\"\n )\n \n (define_insn \"slll_2\"\n   [(set (match_operand:SI            0 \"nonimmediate_operand\" \"=rm\")\n \t(ashift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n \t\t   (const_int 2)))]\n   \"\"\n-  \"RLA.W\\t%L0 { RLC.W\\t%H0 { RLA.W\\t%L0 { RLC.W\\t%H0\"\n+  \"RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0 { RLA%X0.W\\t%L0 { RLC%X0.W\\t%H0\"\n )\n \n (define_expand \"ashlsi3\"\n@@ -867,7 +869,7 @@\n \t(ashiftrt:HI (match_operand:HI 1 \"msp_general_operand\"      \"0\")\n \t\t     (const_int 1)))]\n   \"\"\n-  \"RRA.W\\t%0\"\n+  \"RRA%X0.W\\t%0\"\n )\n \n (define_insn \"430x_arithmetic_shift_right\"\n@@ -903,15 +905,15 @@\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n \t\t     (const_int 1)))]\n   \"\"\n-  \"RRA.W\\t%H0 { RRC.W\\t%L0\"\n+  \"RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0\"\n )\n \n (define_insn \"sral_2\"\n   [(set (match_operand:SI              0 \"nonimmediate_operand\" \"=rm\")\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n \t\t     (const_int 2)))]\n   \"\"\n-  \"RRA.W\\t%H0 { RRC.W\\t%L0 { RRA.W\\t%H0 { RRC.W\\t%L0\"\n+  \"RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0 { RRA%X0.W\\t%H0 { RRC%X0.W\\t%L0\"\n )\n \n (define_expand \"ashrsi3\"\n@@ -968,7 +970,7 @@\n \t(lshiftrt:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n \t\t     (const_int 1)))]\n   \"\"\n-  \"CLRC { RRC.W\\t%0\"\n+  \"CLRC { RRC%X0.W\\t%0\"\n )\n \n (define_insn \"430x_logical_shift_right\"\n@@ -994,7 +996,7 @@\n \t(lshiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n \t\t     (const_int 1)))]\n   \"\"\n-  \"CLRC { RRC.W\\t%H0 { RRC.W\\t%L0\"\n+  \"CLRC { RRC%X0.W\\t%H0 { RRC%X0.W\\t%L0\"\n )\n \n (define_insn \"srll_2x\"\n@@ -1188,23 +1190,23 @@\n (define_insn \"cbranchqi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator                    0 \"msp430_cmp_operator\"\n-\t\t\t      [(match_operand:QI 1 \"nonimmediate_operand\" \"rYs,rm\")\n-\t\t\t       (match_operand:QI 2 \"general_operand\"      \"rYsi,rmi\")])\n+\t\t\t      [(match_operand:QI 1 \"nonimmediate_operand\" \"rYsYx,rm\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\"      \"rYsYxi,rmi\")])\n               (label_ref (match_operand          3 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n    CMP.B\\t%2, %1 { J%0\\t%l3\n-   CMP%X0.B\\t%2, %1 { J%0\\t%l3\"\n+   CMPX.B\\t%2, %1 { J%0\\t%l3\"\n   )\n \n (define_insn \"cbranchhi4_real\"\n   [(set (pc) (if_then_else\n \t      (match_operator                    0 \"msp430_cmp_operator\"\n-\t\t\t      [(match_operand:HI 1 \"nonimmediate_operand\" \"rYs,rm\")\n-\t\t\t       (match_operand:HI 2 \"general_operand\"      \"rYsi,rmi\")])\n+\t\t\t      [(match_operand:HI 1 \"nonimmediate_operand\" \"rYsYx,rm\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\"      \"rYsYxi,rmi\")])\n               (label_ref (match_operand          3 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n@@ -1222,12 +1224,12 @@\n       {\n         return which_alternative == 0 ?\n             \\\"CMP.W\\t%2, %1 { J%r0 1f { BRA #%l3 { 1:\\\" :\n-         \\\"CMP%X0.W\\t%2, %1 { J%r0 1f { BRA #%l3 { 1:\\\";\n+\t    \\\"CMPX.W\\t%2, %1 { J%r0 1f { BRA #%l3 { 1:\\\";\n       }\n \n     return which_alternative == 0 ?\n          \\\"CMP.W\\t%2, %1 { J%0\\t%l3\\\" :\n-      \\\"CMP%X0.W\\t%2, %1 { J%0\\t%l3\\\";\n+\t \\\"CMPX.W\\t%2, %1 { J%0\\t%l3\\\";\n   \"\n   [(set (attr \"length\")\n \t(if_then_else\n@@ -1257,37 +1259,37 @@\n (define_insn \"cbranchqi4_reversed\"\n   [(set (pc) (if_then_else\n \t      (match_operator                    0 \"msp430_reversible_cmp_operator\"\n-\t\t\t      [(match_operand:QI 1 \"general_operand\" \"rYsi,rmi\")\n-\t\t\t       (match_operand:QI 2 \"general_operand\" \"rYs,rm\")])\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"rYsYxi,rmi\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\" \"rYsYx,rm\")])\n               (label_ref (match_operand          3 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n    CMP.B\\t%1, %2 { J%R0\\t%l3\n-   CMP%X0.B\\t%1, %2 { J%R0\\t%l3\"\n+   CMPX.B\\t%1, %2 { J%R0\\t%l3\"\n   )\n \n (define_insn \"cbranchhi4_reversed\"\n   [(set (pc) (if_then_else\n \t      (match_operator                    0 \"msp430_reversible_cmp_operator\"\n-\t\t\t      [(match_operand:HI 1 \"general_operand\" \"rYsi,rmi\")\n-\t\t\t       (match_operand:HI 2 \"general_operand\" \"rYs,rm\")])\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"rYsYxi,rmi\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\" \"rYsYx,rm\")])\n               (label_ref (match_operand          3 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n   \"@\n    CMP.W\\t%1, %2 { J%R0\\t%l3\n-   CMP%X0.W\\t%1, %2 { J%R0\\t%l3\"\n+   CMPX.W\\t%1, %2 { J%R0\\t%l3\"\n   )\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n-\t      (ne (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYs,rm\")\n-\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rYsi,rmi\"))\n+\t      (ne (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYsYx,rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n               (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n@@ -1296,46 +1298,52 @@\n   \"\"\n   \"@\n    BIT%x0%b0\\t%1, %0 { JNE\\t%l2\n-   BIT%X0%b0\\t%1, %0 { JNE\\t%l2\"\n+   BITX%b0\\t%1, %0 { JNE\\t%l2\"\n   )\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n-\t      (eq (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n-\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rmi\"))\n+\t      (eq (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYsYx,rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n               (label_ref (match_operand 2 \"\" \"\"))\n \t      (pc)))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n-  \"BIT%x0%b0\\t%1, %0 { JEQ\\t%l2\"\n+  \"@\n+   BIT%x0%b0\\t%1, %0 { JEQ\\t%l2\n+   BITX%b0\\t%1, %0 { JEQ\\t%l2\"\n   )\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n-\t      (eq (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n-\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rmi\"))\n+\t      (eq (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYsYx,rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n               (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n-  \"BIT%X0%b0\\t%1, %0 { JNE\\t%l2\"\n+  \"@\n+  BIT%x0%b0\\t%1, %0 { JNE\\t%l2\n+  BITX%b0\\t%1, %0 { JNE\\t%l2\"\n   )\n \n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n-\t      (ne (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n-\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rmi\"))\n+\t      (ne (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYsYx,rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rYsYxi,rmi\"))\n \t\t  (const_int 0))\n               (pc)\n \t      (label_ref (match_operand 2 \"\" \"\"))))\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n-  \"BIT%X0%b0\\t%1, %0 { JEQ\\t%l2\"\n+  \"@\n+  BIT%x0%b0\\t%1, %0 { JEQ\\t%l2\n+  BITX%b0\\t%1, %0 { JEQ\\t%l2\"\n   )\n \n ;;------------------------------------------------------------\n@@ -1368,7 +1376,7 @@\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n-  \"BIT%x0%X0%b0\\t%p1, %0 { JEQ\\t%l2\"\n+  \"BIT%X0%b0\\t%p1, %0 { JEQ\\t%l2\"\n   )\n \n (define_insn \"*bitbranch<mode>4_z\""}, {"sha": "2db2906ca11052fbe27cc6870809bc7c0ea6618d", "filename": "gcc/config/msp430/msp430.opt", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -67,12 +67,16 @@ EnumValue\n Enum(msp430_hwmult_types) String(f5series) Value(MSP430_HWMULT_F5SERIES)\n \n mcode-region=\n-Target Joined RejectNegative Report ToLower Var(msp430_code_region) Enum(msp430_regions) Init(MSP430_REGION_ANY)\n-Specify whether functions should be placed into low or high memory.\n+Target Joined RejectNegative Report ToLower Var(msp430_code_region) Enum(msp430_regions) Init(MSP430_REGION_LOWER)\n+Specify whether functions should be placed into the lower or upper memory regions, or if they should be shuffled between the regions (either) for best fit (default: lower).\n \n mdata-region=\n-Target Joined RejectNegative Report ToLower Var(msp430_data_region) Enum(msp430_regions) Init(MSP430_REGION_ANY)\n-Specify whether variables should be placed into low or high memory.\n+Target Joined RejectNegative Report ToLower Var(msp430_data_region) Enum(msp430_regions) Init(MSP430_REGION_LOWER)\n+Specify whether variables should be placed into the lower or upper memory regions, or if they should be shuffled between the regions (either) for best fit (default: lower).\n+\n+muse-lower-region-prefix\n+Target Mask(USE_LOWER_REGION_PREFIX) Report\n+Add the .lower prefix to section names when compiling with -m{code,data}-region=lower (disabled by default).\n \n Enum\n Name(msp430_regions) Type(enum msp430_regions)"}, {"sha": "f8ba7751123d26ce85d5c95e92f047437a7d3d7d", "filename": "gcc/config/msp430/t-msp430", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Ft-msp430", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfig%2Fmsp430%2Ft-msp430", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Ft-msp430?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -28,17 +28,22 @@ msp430-devices.o: $(srcdir)/config/msp430/msp430-devices.c \\\n \n # Enable multilibs:\n \n-MULTILIB_OPTIONS    = mcpu=msp430 mlarge \n-MULTILIB_DIRNAMES   = 430          large\n+MULTILIB_OPTIONS    = mcpu=msp430 mlarge  mdata-region=none\n+MULTILIB_DIRNAMES   = 430\t   large  full-memory-range\n \n # Match -mcpu=430\n MULTILIB_MATCHES    = mcpu?msp430=mcpu?430\n+# These options are equivalent in terms of the multilib required for them\n+MULTILIB_MATCHES   += mdata-region?none=mdata-region?upper\n+MULTILIB_MATCHES   += mdata-region?none=mdata-region?either\n \n # The correct multilib for a given mmcu is selected without the need for\n # hard-coded data here, because DRIVER_SELF_SPECS will place the correct\n # -mcpu option for a given mcu onto the command line.\n \n-MULTILIB_EXCEPTIONS = mcpu=msp430/mlarge\n+MULTILIB_REQUIRED = mcpu=msp430\n+MULTILIB_REQUIRED += mlarge\n+MULTILIB_REQUIRED += mlarge/mdata-region=none\n \n \n MULTILIB_EXTRA_OPTS ="}, {"sha": "dc9f5fefaa80077befa8b80df1e83d1f043e8518", "filename": "gcc/configure", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -27772,6 +27772,80 @@ fi\n        && test x$with_nan != x; then\n       as_fn_error $? \"Requesting --with-nan= requires assembler support for -mnan=\" \"$LINENO\" 5\n     fi\n+    ;;\n+    msp430-*-*)\n+    # Earlier GAS versions generically support .gnu_attribute, but the\n+    # msp430 assembler will not do anything with it.\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .gnu_attribute support\" >&5\n+$as_echo_n \"checking assembler for .gnu_attribute support... \" >&6; }\n+if ${gcc_cv_as_msp430_gnu_attribute+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_msp430_gnu_attribute=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 33 \\) \\* 1000 + 50`\n+  then gcc_cv_as_msp430_gnu_attribute=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    $as_echo '.gnu_attribute 4,1' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_msp430_gnu_attribute=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_msp430_gnu_attribute\" >&5\n+$as_echo \"$gcc_cv_as_msp430_gnu_attribute\" >&6; }\n+if test $gcc_cv_as_msp430_gnu_attribute = yes; then\n+\n+$as_echo \"#define HAVE_AS_GNU_ATTRIBUTE 1\" >>confdefs.h\n+\n+fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .mspabi_attribute support\" >&5\n+$as_echo_n \"checking assembler for .mspabi_attribute support... \" >&6; }\n+if ${gcc_cv_as_msp430_mspabi_attribute+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_msp430_mspabi_attribute=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 33 \\) \\* 1000 + 50`\n+  then gcc_cv_as_msp430_mspabi_attribute=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    $as_echo '.mspabi_attribute 4,1' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_msp430_mspabi_attribute=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_msp430_mspabi_attribute\" >&5\n+$as_echo \"$gcc_cv_as_msp430_mspabi_attribute\" >&6; }\n+if test $gcc_cv_as_msp430_mspabi_attribute = yes; then\n+\n+$as_echo \"#define HAVE_AS_MSPABI_ATTRIBUTE 1\" >>confdefs.h\n+\n+fi\n+\n     ;;\n     riscv*-*-*)\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .attribute support\" >&5"}, {"sha": "54a67159b989fae37a34d961bbcd3280eb3d5a4f", "filename": "gcc/configure.ac", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -4949,6 +4949,20 @@ pointers into PC-relative form.])\n \t[Requesting --with-nan= requires assembler support for -mnan=])\n     fi\n     ;;\n+    msp430-*-*)\n+    # Earlier GAS versions generically support .gnu_attribute, but the\n+    # msp430 assembler will not do anything with it.\n+    gcc_GAS_CHECK_FEATURE([.gnu_attribute support],\n+      gcc_cv_as_msp430_gnu_attribute, [2,33,50],,\n+      [.gnu_attribute 4,1],,\n+      [AC_DEFINE(HAVE_AS_GNU_ATTRIBUTE, 1,\n+\t  [Define if your assembler supports .gnu_attribute.])])\n+    gcc_GAS_CHECK_FEATURE([.mspabi_attribute support],\n+      gcc_cv_as_msp430_mspabi_attribute, [2,33,50],,\n+      [.mspabi_attribute 4,1],,\n+      [AC_DEFINE(HAVE_AS_MSPABI_ATTRIBUTE, 1,\n+\t  [Define if your assembler supports .mspabi_attribute.])])\n+    ;;\n     riscv*-*-*)\n     gcc_GAS_CHECK_FEATURE([.attribute support],\n       gcc_cv_as_riscv_attribute, [2,32,0],,"}, {"sha": "7e37c5cc2e6256936770e3d945076ee3cefa254f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -5206,7 +5206,7 @@ On the MSP430 target these attributes can be used to specify whether\n the function or variable should be placed into low memory, high\n memory, or the placement should be left to the linker to decide.  The\n attributes are only significant if compiling for the MSP430X\n-architecture.\n+architecture in the large memory model.\n \n The attributes work in conjunction with a linker script that has been\n augmented to specify where to place sections with a @code{.lower} and\n@@ -7537,15 +7537,30 @@ value will be retained across resets.  The linker script being used to\n create the application should ensure that persistent data is correctly\n placed.\n \n-@item lower\n-@itemx upper\n+@item upper\n @itemx either\n-@cindex @code{lower} variable attribute, MSP430 \n @cindex @code{upper} variable attribute, MSP430 \n @cindex @code{either} variable attribute, MSP430 \n These attributes are the same as the MSP430 function attributes of the\n same name (@pxref{MSP430 Function Attributes}).  \n-These attributes can be applied to both functions and variables.\n+\n+@item lower\n+@cindex @code{lower} variable attribute, MSP430\n+This option behaves mostly the same as the MSP430 function attribute of the\n+same name (@pxref{MSP430 Function Attributes}), but it has some additional\n+functionality.\n+\n+If @option{-mdata-region=}@{@code{upper,either,none}@} has been passed, or\n+the @code{section} attribute is applied to a variable, the compiler will\n+generate 430X instructions to handle it.  This is because the compiler has\n+to assume that the variable could get placed in the upper memory region\n+(above address 0xFFFF).  Marking the variable with the @code{lower} attribute\n+informs the compiler that the variable will be placed in lower memory so it\n+is safe to use 430 instructions to handle it.\n+\n+In the case of the @code{section} attribute, the section name given\n+will be used, and the @code{.lower} prefix will not be added.\n+\n @end table\n \n @node Nvidia PTX Variable Attributes"}, {"sha": "b55e272864abb8d0dd562ac4dafdc9d7335e5689", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -1,3 +1,16 @@\n+2019-10-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* gcc.target/msp430/430x-insns.c: New test.\n+\t* gcc.target/msp430/data-attributes-2.c: Remove dg-warning\n+\tdirectives for conflicts between the \"section\" and \"lower\" attributes.\n+\t* gcc.target/msp430/msp430.exp\n+\t(check_effective_target_msp430_region_not_lower): New.\n+\t(check_effective_target_msp430_region_lower): New.\n+\t* gcc.target/msp430/object-attributes-430.c: New test.\n+\t* gcc.target/msp430/object-attributes-default.c: New test.\n+\t* gcc.target/msp430/object-attributes-mlarge-any-region.c: New test.\n+\t* gcc.target/msp430/object-attributes-mlarge.c: New test.\n+\n 2019-10-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.target/i386/pr71801.c (uuidcache_init): Fix up size of d array."}, {"sha": "a67f778371a94955d3ef32b71c8f80dce27e3b79", "filename": "gcc/testsuite/gcc.target/msp430/430x-insns.c", "status": "added", "additions": 1646, "deletions": 0, "changes": 1646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2F430x-insns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2F430x-insns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2F430x-insns.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -0,0 +1,1646 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" \"-mcpu=430\" \"-msmall\" } { \"\" } } */\n+/* { dg-options \"-O1 -mlarge\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/* The purpose of this test is to check that all insn patters in msp430.md\n+   which use the \"Yx\" constraint work as expected.\n+   So when both of the operands are in lower memory, a 430 instruction is\n+   generated, and when at least one of the operands might be in upper memory,\n+   a 430X instruction is generated.\n+   We do not need to extensively test the situation where one of the operands\n+   in an insn is not a mem (i.e. it is a register or immediate).  A single test\n+   will verify that the constraint correctly assumes that a reg\n+   or immediate does not itself require a 430X instruction.  */\n+\n+typedef char qi;\n+typedef int hi;\n+/* For insns which use the QHI mode iterator (therefore accepting QI, HI and \n+   PSI modes), we also check the PSImode version.  All insns should be 430x\n+   in that case.  */\n+typedef __int20 psi;\n+typedef long si;\n+\n+#define ATTR_EITHER __attribute__((either))\n+#define ATTR_LOWER __attribute__((lower))\n+\n+/* Use these to generate 430X insns.  */\n+qi ATTR_EITHER eqi1, eqi2, eqi3, eqi4, eqi5, eqi6;\n+hi ATTR_EITHER ehi1, ehi2, ehi3, ehi4, ehi5, ehi6;\n+psi ATTR_EITHER epsi1, epsi2, epsi3, epsi4, epsi5, epsi6;\n+si ATTR_EITHER esi1, esi2, esi3, esi4, esi5, esi6;\n+\n+/* Use these to generate 430 insns.  */\n+qi ATTR_LOWER lqi1, lqi2, lqi3, lqi4, lqi5, lqi6;\n+hi ATTR_LOWER lhi1, lhi2, lhi3, lhi4, lhi5, lhi6;\n+psi ATTR_LOWER lpsi1, lpsi2, lpsi3, lpsi4, lpsi5, lpsi6;\n+si ATTR_LOWER lsi1, lsi2, lsi3, lsi4, lsi5, lsi6;\n+\n+/* The default data region is \"lower\", so these behave the same as the above\n+   \"l*\" variables unless -mdata-region={upper,either,none} is passed.  */\n+qi qi1, qi2, qi3, qi4, qi5, qi6;\n+hi hi1, hi2, hi3, hi4, hi5, hi6;\n+psi psi1, psi2, psi3, psi4, psi5, psi6;\n+si si1, si2, si3, si4, si5, si6;\n+\n+qi use_qi(qi a);\n+hi use_hi(hi a);\n+psi use_psi(psi a);\n+si use_si(si a);\n+\n+#define USE_MODE(MODE) use_ ## MODE\n+#define USE_MODE_N(MODE,N) use_ ## N ## MODE\n+\n+#define E_VAR(MODE,N) e ## MODE ## N\n+#define L_VAR(MODE,N) l ## MODE ## N\n+#define VAR(MODE,N) MODE ## N\n+\n+#define REG_VAR(MODE,N) MODE ## r ## N\n+\n+/* Verify that a register operand does not influence whether a 430X instruction\n+   is used or not.  */\n+/*\n+** register_operand:  { target msp430_region_lower }\n+** ...\n+**\tMOV.B\t&lqi1, R12\n+** ...\n+**\tMOV.B\t&qi1, R12\n+** ...\n+**\tMOVX.B\t&eqi1, R12\n+** ...\n+*/\n+/*\n+** register_operand:  { target msp430_region_not_lower }\n+** ...\n+**\tMOV.B\t&lqi1, R12\n+** ...\n+**\tMOVX.B\t&qi1, R12\n+** ...\n+**\tMOVX.B\t&eqi1, R12\n+** ...\n+*/\n+\n+void\n+register_operand (void)\n+{\n+  use_qi (lqi1);\n+  use_qi (qi1);\n+  use_qi (eqi1);\n+}\n+\n+/* Verify that an immediate operand does not influence whether a 430X instruction\n+   is used or not.  */\n+/*\n+** immediate_operand: { target msp430_region_lower }\n+** ...\n+**\tMOV.B\t#1, &lqi1\n+**\tMOV.B\t#2, &qi1\n+**\tMOVX.B\t#3, &eqi1\n+** ...\n+*/\n+/*\n+** immediate_operand: { target msp430_region_not_lower }\n+** ...\n+**\tMOV.B\t#1, &lqi1\n+**\tMOVX.B\t#2, &qi1\n+**\tMOVX.B\t#3, &eqi1\n+** ...\n+*/\n+void\n+immediate_operand (void)\n+{\n+  lqi1 = 1;\n+  qi1 = 2;\n+  eqi1 = 3;\n+}\n+\n+/* Verify that variables marked with the noinit, persistent, section and lower\n+   attributes have the appropriate format instructions generated to handle\n+   them.  */\n+int __attribute__((persistent)) pp = 10;\n+int __attribute__((noinit)) nn;\n+int __attribute__((section(\".data.foo\"))) s;\n+int __attribute__((section(\".data.foo\"),lower)) sl1;\n+int __attribute__((lower,section(\".data.foo\"))) sl2;\n+\n+/*\n+** attrs:\n+** ...\n+**\tMOVX.W\t#1, &pp\n+**\tMOV.W\t#2, &nn\n+**\tMOVX.W\t#3, &s\n+**\tMOV.W\t#4, &sl1\n+**\tMOV.W\t#5, &sl2\n+** ...\n+*/\n+void\n+attrs (void)\n+{\n+  pp = 1;\n+  nn = 2;\n+  s = 3;\n+  sl1 = 4;\n+  sl2 = 5;\n+}\n+\n+#define MOV_INSNS(MODE) \\\n+  E_VAR(MODE, 1) = E_VAR(MODE, 2); \\\n+  E_VAR(MODE, 3) = L_VAR(MODE, 1); \\\n+  E_VAR(MODE, 4) = VAR(MODE, 1); \\\n+  L_VAR(MODE, 4) = E_VAR(MODE, 5); \\\n+  VAR(MODE, 5) = E_VAR(MODE, 6); \\\n+  L_VAR(MODE, 2) = L_VAR(MODE, 3); \\\n+  L_VAR(MODE, 5) = VAR(MODE, 2); \\\n+  VAR(MODE, 3) = VAR(MODE, 4); \\\n+  VAR(MODE, 6) = L_VAR(MODE, 6);\n+\n+\n+/*\n+** movqi: { target msp430_region_lower }\n+** ...\n+**\tMOVX.B\t&eqi2, &eqi1\n+**\tMOVX.B\t&lqi1, &eqi3\n+**\tMOVX.B\t&qi1, &eqi4\n+**\tMOVX.B\t&eqi5, &lqi4\n+**\tMOVX.B\t&eqi6, &qi5\n+**\tMOV.B\t&lqi3, &lqi2\n+**\tMOV.B\t&qi2, &lqi5\n+**\tMOV.B\t&qi4, &qi3\n+**\tMOV.B\t&lqi6, &qi6\n+** ...\n+*/\n+/*\n+** movqi: { target msp430_region_not_lower }\n+** ...\n+**\tMOVX.B\t&eqi2, &eqi1\n+**\tMOVX.B\t&lqi1, &eqi3\n+**\tMOVX.B\t&qi1, &eqi4\n+**\tMOVX.B\t&eqi5, &lqi4\n+**\tMOVX.B\t&eqi6, &qi5\n+**\tMOV.B\t&lqi3, &lqi2\n+**\tMOVX.B\t&qi2, &lqi5\n+**\tMOVX.B\t&qi4, &qi3\n+**\tMOVX.B\t&lqi6, &qi6\n+** ...\n+*/\n+void\n+movqi (void)\n+{\n+  MOV_INSNS (qi)\n+}\n+\n+/*\n+** movhi: { target msp430_region_lower }\n+** ...\n+**\tMOVX.W\t&ehi2, &ehi1\n+**\tMOVX.W\t&lhi1, &ehi3\n+**\tMOVX.W\t&hi1, &ehi4\n+**\tMOVX.W\t&ehi5, &lhi4\n+**\tMOVX.W\t&ehi6, &hi5\n+**\tMOV.W\t&lhi3, &lhi2\n+**\tMOV.W\t&hi2, &lhi5\n+**\tMOV.W\t&hi4, &hi3\n+**\tMOV.W\t&lhi6, &hi6\n+** ...\n+*/\n+/*\n+** movhi: { target msp430_region_not_lower }\n+** ...\n+**\tMOVX.W\t&ehi2, &ehi1\n+**\tMOVX.W\t&lhi1, &ehi3\n+**\tMOVX.W\t&hi1, &ehi4\n+**\tMOVX.W\t&ehi5, &lhi4\n+**\tMOVX.W\t&ehi6, &hi5\n+**\tMOV.W\t&lhi3, &lhi2\n+**\tMOVX.W\t&hi2, &lhi5\n+**\tMOVX.W\t&hi4, &hi3\n+**\tMOVX.W\t&lhi6, &hi6\n+** ...\n+*/\n+void\n+movhi (void)\n+{\n+  MOV_INSNS (hi)\n+}\n+\n+/* There is no specific movsi3 pattern defined for msp430, but we check\n+   this is synthesized correctly anyway.  */\n+/*\n+** movsi: { target msp430_region_lower }\n+** ...\n+**\tMOVX.W\t&esi2, &esi1\n+**\tMOVX.W\t&esi2\\+2, &esi1\\+2\n+**\tMOVX.W\t&lsi1, &esi3\n+**\tMOVX.W\t&lsi1\\+2, &esi3\\+2\n+**\tMOVX.W\t&si1, &esi4\n+**\tMOVX.W\t&si1\\+2, &esi4\\+2\n+**\tMOVX.W\t&esi5, &lsi4\n+**\tMOVX.W\t&esi5\\+2, &lsi4\\+2\n+**\tMOVX.W\t&esi6, &si5\n+**\tMOVX.W\t&esi6\\+2, &si5\\+2\n+**\tMOV.W\t&lsi3, &lsi2\n+**\tMOV.W\t&lsi3\\+2, &lsi2\\+2\n+**\tMOV.W\t&si2, &lsi5\n+**\tMOV.W\t&si2\\+2, &lsi5\\+2\n+**\tMOV.W\t&si4, &si3\n+**\tMOV.W\t&si4\\+2, &si3\\+2\n+**\tMOV.W\t&lsi6, &si6\n+**\tMOV.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+/*\n+** movsi: { target msp430_region_not_lower }\n+** ...\n+**\tMOVX.W\t&esi2, &esi1\n+**\tMOVX.W\t&esi2\\+2, &esi1\\+2\n+**\tMOVX.W\t&lsi1, &esi3\n+**\tMOVX.W\t&lsi1\\+2, &esi3\\+2\n+**\tMOVX.W\t&si1, &esi4\n+**\tMOVX.W\t&si1\\+2, &esi4\\+2\n+**\tMOVX.W\t&esi5, &lsi4\n+**\tMOVX.W\t&esi5\\+2, &lsi4\\+2\n+**\tMOVX.W\t&esi6, &si5\n+**\tMOVX.W\t&esi6\\+2, &si5\\+2\n+**\tMOV.W\t&lsi3, &lsi2\n+**\tMOV.W\t&lsi3\\+2, &lsi2\\+2\n+**\tMOVX.W\t&si2, &lsi5\n+**\tMOVX.W\t&si2\\+2, &lsi5\\+2\n+**\tMOVX.W\t&si4, &si3\n+**\tMOVX.W\t&si4\\+2, &si3\\+2\n+**\tMOVX.W\t&lsi6, &si6\n+**\tMOVX.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+void\n+movsi (void)\n+{\n+  MOV_INSNS (si)\n+}\n+\n+#define ADD_INSNS(MODE) \\\n+  E_VAR(MODE,1) += E_VAR(MODE,2); \\\n+  E_VAR(MODE,3) += L_VAR(MODE,1); \\\n+  E_VAR(MODE,4) += VAR(MODE,1); \\\n+  L_VAR(MODE,2) += E_VAR(MODE,5); \\\n+  VAR(MODE,3) += E_VAR(MODE,6); \\\n+  L_VAR(MODE,3) += L_VAR(MODE,4); \\\n+  L_VAR(MODE,5) += VAR(MODE,2); \\\n+  VAR(MODE,4) += L_VAR(MODE,6); \\\n+  VAR(MODE,5) += VAR(MODE,6);\n+\n+/*\n+** addqi3: { target msp430_region_lower }\n+** ...\n+**\tADDX.B\t&eqi2, &eqi1\n+**\tADDX.B\t&lqi1, &eqi3\n+**\tADDX.B\t&qi1, &eqi4\n+**\tADDX.B\t&eqi5, &lqi2\n+**\tADDX.B\t&eqi6, &qi3\n+**\tADD.B\t&lqi4, &lqi3\n+**\tADD.B\t&qi2, &lqi5\n+**\tADD.B\t&lqi6, &qi4\n+**\tADD.B\t&qi6, &qi5\n+** ...\n+*/\n+/*\n+** addqi3: { target msp430_region_not_lower }\n+** ...\n+**\tADDX.B\t&eqi2, &eqi1\n+**\tADDX.B\t&lqi1, &eqi3\n+**\tADDX.B\t&qi1, &eqi4\n+**\tADDX.B\t&eqi5, &lqi2\n+**\tADDX.B\t&eqi6, &qi3\n+**\tADD.B\t&lqi4, &lqi3\n+**\tADDX.B\t&qi2, &lqi5\n+**\tADDX.B\t&lqi6, &qi4\n+**\tADDX.B\t&qi6, &qi5\n+** ...\n+*/\n+void\n+addqi3 (void)\n+{\n+  ADD_INSNS(qi)\n+}\n+\n+/*\n+** addhi3: { target msp430_region_lower }\n+** ...\n+**\tADDX.W\t&ehi2, &ehi1\n+**\tADDX.W\t&lhi1, &ehi3\n+**\tADDX.W\t&hi1, &ehi4\n+**\tADDX.W\t&ehi5, &lhi2\n+**\tADDX.W\t&ehi6, &hi3\n+**\tADD.W\t&lhi4, &lhi3\n+**\tADD.W\t&hi2, &lhi5\n+**\tADD.W\t&lhi6, &hi4\n+**\tADD.W\t&hi6, &hi5\n+** ...\n+*/\n+/*\n+** addhi3: { target msp430_region_not_lower }\n+** ...\n+**\tADDX.W\t&ehi2, &ehi1\n+**\tADDX.W\t&lhi1, &ehi3\n+**\tADDX.W\t&hi1, &ehi4\n+**\tADDX.W\t&ehi5, &lhi2\n+**\tADDX.W\t&ehi6, &hi3\n+**\tADD.W\t&lhi4, &lhi3\n+**\tADDX.W\t&hi2, &lhi5\n+**\tADDX.W\t&lhi6, &hi4\n+**\tADDX.W\t&hi6, &hi5\n+** ...\n+*/\n+void\n+addhi3 (void)\n+{\n+  ADD_INSNS(hi)\n+}\n+\n+/*\n+** addsi3: { target msp430_region_lower }\n+** ...\n+**\tADDX\t&esi2, &esi1 { ADDCX\t&esi2\\+2, &esi1\\+2\n+**\tADDX\t&lsi1, &esi3 { ADDCX\t&lsi1\\+2, &esi3\\+2\n+**\tADDX\t&si1, &esi4 { ADDCX\t&si1\\+2, &esi4\\+2\n+**\tADDX\t&esi5, &lsi2 { ADDCX\t&esi5\\+2, &lsi2\\+2\n+**\tADDX\t&esi6, &si3 { ADDCX\t&esi6\\+2, &si3\\+2\n+**\tADD\t&lsi4, &lsi3 { ADDC\t&lsi4\\+2, &lsi3\\+2\n+**\tADD\t&si2, &lsi5 { ADDC\t&si2\\+2, &lsi5\\+2\n+**\tADD\t&lsi6, &si4 { ADDC\t&lsi6\\+2, &si4\\+2\n+**\tADD\t&si6, &si5 { ADDC\t&si6\\+2, &si5\\+2\n+** ...\n+*/\n+/*\n+** addsi3: { target msp430_region_not_lower }\n+** ...\n+**\tADDX\t&esi2, &esi1 { ADDCX\t&esi2\\+2, &esi1\\+2\n+**\tADDX\t&lsi1, &esi3 { ADDCX\t&lsi1\\+2, &esi3\\+2\n+**\tADDX\t&si1, &esi4 { ADDCX\t&si1\\+2, &esi4\\+2\n+**\tADDX\t&esi5, &lsi2 { ADDCX\t&esi5\\+2, &lsi2\\+2\n+**\tADDX\t&esi6, &si3 { ADDCX\t&esi6\\+2, &si3\\+2\n+**\tADD\t&lsi4, &lsi3 { ADDC\t&lsi4\\+2, &lsi3\\+2\n+**\tADDX\t&si2, &lsi5 { ADDCX\t&si2\\+2, &lsi5\\+2\n+**\tADDX\t&lsi6, &si4 { ADDCX\t&lsi6\\+2, &si4\\+2\n+**\tADDX\t&si6, &si5 { ADDCX\t&si6\\+2, &si5\\+2\n+** ...\n+*/\n+void\n+addsi3 (void)\n+{\n+  ADD_INSNS(si)\n+}\n+\n+#define SUB_INSNS(MODE) \\\n+  E_VAR(MODE,1) -= E_VAR(MODE,2); \\\n+  E_VAR(MODE,3) -= L_VAR(MODE,1); \\\n+  E_VAR(MODE,4) -= VAR(MODE,1); \\\n+  L_VAR(MODE,2) -= E_VAR(MODE,5); \\\n+  VAR(MODE,3) -= E_VAR(MODE,6); \\\n+  L_VAR(MODE,3) -= L_VAR(MODE,4); \\\n+  L_VAR(MODE,5) -= VAR(MODE,2); \\\n+  VAR(MODE,4) -= L_VAR(MODE,6); \\\n+  VAR(MODE,5) -= VAR(MODE,6);\n+\n+/*\n+** subqi3: { target msp430_region_lower }\n+** ...\n+**\tSUBX.B\t&eqi2, &eqi1\n+**\tSUBX.B\t&lqi1, &eqi3\n+**\tSUBX.B\t&qi1, &eqi4\n+**\tSUBX.B\t&eqi5, &lqi2\n+**\tSUBX.B\t&eqi6, &qi3\n+**\tSUB.B\t&lqi4, &lqi3\n+**\tSUB.B\t&qi2, &lqi5\n+**\tSUB.B\t&lqi6, &qi4\n+**\tSUB.B\t&qi6, &qi5\n+** ...\n+*/\n+/*\n+** subqi3: { target msp430_region_not_lower }\n+** ...\n+**\tSUBX.B\t&eqi2, &eqi1\n+**\tSUBX.B\t&lqi1, &eqi3\n+**\tSUBX.B\t&qi1, &eqi4\n+**\tSUBX.B\t&eqi5, &lqi2\n+**\tSUBX.B\t&eqi6, &qi3\n+**\tSUB.B\t&lqi4, &lqi3\n+**\tSUBX.B\t&qi2, &lqi5\n+**\tSUBX.B\t&lqi6, &qi4\n+**\tSUBX.B\t&qi6, &qi5\n+** ...\n+*/\n+void\n+subqi3 (void)\n+{\n+  SUB_INSNS(qi)\n+}\n+\n+/*\n+** subhi3: { target msp430_region_lower }\n+** ...\n+**\tSUBX.W\t&ehi2, &ehi1\n+**\tSUBX.W\t&lhi1, &ehi3\n+**\tSUBX.W\t&hi1, &ehi4\n+**\tSUBX.W\t&ehi5, &lhi2\n+**\tSUBX.W\t&ehi6, &hi3\n+**\tSUB.W\t&lhi4, &lhi3\n+**\tSUB.W\t&hi2, &lhi5\n+**\tSUB.W\t&lhi6, &hi4\n+**\tSUB.W\t&hi6, &hi5\n+** ...\n+*/\n+/*\n+** subhi3: { target msp430_region_not_lower }\n+** ...\n+**\tSUBX.W\t&ehi2, &ehi1\n+**\tSUBX.W\t&lhi1, &ehi3\n+**\tSUBX.W\t&hi1, &ehi4\n+**\tSUBX.W\t&ehi5, &lhi2\n+**\tSUBX.W\t&ehi6, &hi3\n+**\tSUB.W\t&lhi4, &lhi3\n+**\tSUBX.W\t&hi2, &lhi5\n+**\tSUBX.W\t&lhi6, &hi4\n+**\tSUBX.W\t&hi6, &hi5\n+** ...\n+*/\n+void\n+subhi3 (void)\n+{\n+  SUB_INSNS(hi)\n+}\n+\n+/*\n+** subsi3: { target msp430_region_lower }\n+** ...\n+**\tSUBX\t&esi2, &esi1 { SUBCX\t&esi2\\+2, &esi1\\+2\n+**\tSUBX\t&lsi1, &esi3 { SUBCX\t&lsi1\\+2, &esi3\\+2\n+**\tSUBX\t&si1, &esi4 { SUBCX\t&si1\\+2, &esi4\\+2\n+**\tSUBX\t&esi5, &lsi2 { SUBCX\t&esi5\\+2, &lsi2\\+2\n+**\tSUBX\t&esi6, &si3 { SUBCX\t&esi6\\+2, &si3\\+2\n+**\tSUB\t&lsi4, &lsi3 { SUBC\t&lsi4\\+2, &lsi3\\+2\n+**\tSUB\t&si2, &lsi5 { SUBC\t&si2\\+2, &lsi5\\+2\n+**\tSUB\t&lsi6, &si4 { SUBC\t&lsi6\\+2, &si4\\+2\n+**\tSUB\t&si6, &si5 { SUBC\t&si6\\+2, &si5\\+2\n+** ...\n+*/\n+/*\n+** subsi3: { target msp430_region_not_lower }\n+** ...\n+**\tSUBX\t&esi2, &esi1 { SUBCX\t&esi2\\+2, &esi1\\+2\n+**\tSUBX\t&lsi1, &esi3 { SUBCX\t&lsi1\\+2, &esi3\\+2\n+**\tSUBX\t&si1, &esi4 { SUBCX\t&si1\\+2, &esi4\\+2\n+**\tSUBX\t&esi5, &lsi2 { SUBCX\t&esi5\\+2, &lsi2\\+2\n+**\tSUBX\t&esi6, &si3 { SUBCX\t&esi6\\+2, &si3\\+2\n+**\tSUB\t&lsi4, &lsi3 { SUBC\t&lsi4\\+2, &lsi3\\+2\n+**\tSUBX\t&si2, &lsi5 { SUBCX\t&si2\\+2, &lsi5\\+2\n+**\tSUBX\t&lsi6, &si4 { SUBCX\t&lsi6\\+2, &si4\\+2\n+**\tSUBX\t&si6, &si5 { SUBCX\t&si6\\+2, &si5\\+2\n+** ...\n+*/\n+void\n+subsi3 (void)\n+{\n+  SUB_INSNS(si)\n+}\n+\n+#define BIC_INSN(MODE) \\\n+  E_VAR(MODE,1) &= (E_VAR(MODE,2) ^ E_VAR(MODE,1)); \\\n+  E_VAR(MODE,3) &= (L_VAR(MODE,1) ^ E_VAR(MODE,3)); \\\n+  E_VAR(MODE,4) &= (VAR(MODE,1) ^ E_VAR(MODE,4)); \\\n+  L_VAR(MODE,2) &= (E_VAR(MODE,5) ^ L_VAR(MODE,2)); \\\n+  VAR(MODE,2) &= (E_VAR(MODE,6) ^ VAR(MODE,2)); \\\n+  L_VAR(MODE,3) &= (L_VAR(MODE,4) ^ L_VAR(MODE,3)); \\\n+  L_VAR(MODE,5) &= (VAR(MODE,3) ^ L_VAR(MODE,5)); \\\n+  VAR(MODE,4) &= (L_VAR(MODE,6) ^ VAR(MODE,4)); \\\n+  VAR(MODE,5) &= (VAR(MODE,6) ^ VAR(MODE,5)); \\\n+\n+/*\n+** bicqi3: { target msp430_region_lower }\n+** ...\n+**\tBICX.B\t&eqi2, &eqi1\n+**\tBICX.B\t&lqi1, &eqi3\n+**\tBICX.B\t&qi1, &eqi4\n+**\tBICX.B\t&eqi5, &lqi2\n+**\tBICX.B\t&eqi6, &qi2\n+**\tBIC.B\t&lqi4, &lqi3\n+**\tBIC.B\t&qi3, &lqi5\n+**\tBIC.B\t&lqi6, &qi4\n+**\tBIC.B\t&qi6, &qi5\n+** ...\n+*/\n+/*\n+** bicqi3: { target msp430_region_not_lower }\n+** ...\n+**\tBICX.B\t&eqi2, &eqi1\n+**\tBICX.B\t&lqi1, &eqi3\n+**\tBICX.B\t&qi1, &eqi4\n+**\tBICX.B\t&eqi5, &lqi2\n+**\tBICX.B\t&eqi6, &qi2\n+**\tBIC.B\t&lqi4, &lqi3\n+**\tBICX.B\t&qi3, &lqi5\n+**\tBICX.B\t&lqi6, &qi4\n+**\tBICX.B\t&qi6, &qi5\n+** ...\n+*/\n+void\n+bicqi3 (void)\n+{\n+  BIC_INSN(qi)\n+}\n+\n+/*\n+** bichi3: { target msp430_region_lower }\n+** ...\n+**\tBICX.W\t&ehi2, &ehi1\n+**\tBICX.W\t&lhi1, &ehi3\n+**\tBICX.W\t&hi1, &ehi4\n+**\tBICX.W\t&ehi5, &lhi2\n+**\tBICX.W\t&ehi6, &hi2\n+**\tBIC.W\t&lhi4, &lhi3\n+**\tBIC.W\t&hi3, &lhi5\n+**\tBIC.W\t&lhi6, &hi4\n+**\tBIC.W\t&hi6, &hi5\n+** ...\n+*/\n+/*\n+** bichi3: { target msp430_region_not_lower }\n+** ...\n+**\tBICX.W\t&ehi2, &ehi1\n+**\tBICX.W\t&lhi1, &ehi3\n+**\tBICX.W\t&hi1, &ehi4\n+**\tBICX.W\t&ehi5, &lhi2\n+**\tBICX.W\t&ehi6, &hi2\n+**\tBIC.W\t&lhi4, &lhi3\n+**\tBICX.W\t&hi3, &lhi5\n+**\tBICX.W\t&lhi6, &hi4\n+**\tBICX.W\t&hi6, &hi5\n+** ...\n+*/\n+void\n+bichi3 (void)\n+{\n+  BIC_INSN(hi)\n+}\n+\n+/*\n+** bicpsi3:\n+** ...\n+**\tBICX.A\t&epsi2, &epsi1\n+**\tBICX.A\t&lpsi1, &epsi3\n+**\tBICX.A\t&psi1, &epsi4\n+**\tBICX.A\t&epsi5, &lpsi2\n+**\tBICX.A\t&epsi6, &psi2\n+**\tBICX.A\t&lpsi4, &lpsi3\n+**\tBICX.A\t&psi3, &lpsi5\n+**\tBICX.A\t&lpsi6, &psi4\n+**\tBICX.A\t&psi6, &psi5\n+** ...\n+*/\n+void\n+bicpsi3 (void)\n+{\n+  BIC_INSN(psi)\n+}\n+\n+/* There is no specific bicsi3 pattern defined for msp430, but we check\n+   this is synthesized correctly anyway.  */\n+/*\n+** bicsi3: { target msp430_region_lower }\n+** ...\n+**\tBICX.W\t&esi2, &esi1\n+**\tBICX.W\t&esi2\\+2, &esi1\\+2\n+**\tBICX.W\t&lsi1, &esi3\n+**\tBICX.W\t&lsi1\\+2, &esi3\\+2\n+**\tBICX.W\t&si1, &esi4\n+**\tBICX.W\t&si1\\+2, &esi4\\+2\n+**\tBICX.W\t&esi5, &lsi2\n+**\tBICX.W\t&esi5\\+2, &lsi2\\+2\n+**\tBICX.W\t&esi6, &si2\n+**\tBICX.W\t&esi6\\+2, &si2\\+2\n+**\tBIC.W\t&lsi4, &lsi3\n+**\tBIC.W\t&lsi4\\+2, &lsi3\\+2\n+**\tBIC.W\t&si3, &lsi5\n+**\tBIC.W\t&si3\\+2, &lsi5\\+2\n+**\tBIC.W\t&lsi6, &si4\n+**\tBIC.W\t&lsi6\\+2, &si4\\+2\n+**\tBIC.W\t&si6, &si5\n+**\tBIC.W\t&si6\\+2, &si5\\+2\n+** ...\n+*/\n+/*\n+** bicsi3: { target msp430_region_not_lower }\n+** ...\n+**\tBICX.W\t&esi2, &esi1\n+**\tBICX.W\t&esi2\\+2, &esi1\\+2\n+**\tBICX.W\t&lsi1, &esi3\n+**\tBICX.W\t&lsi1\\+2, &esi3\\+2\n+**\tBICX.W\t&si1, &esi4\n+**\tBICX.W\t&si1\\+2, &esi4\\+2\n+**\tBICX.W\t&esi5, &lsi2\n+**\tBICX.W\t&esi5\\+2, &lsi2\\+2\n+**\tBICX.W\t&esi6, &si2\n+**\tBICX.W\t&esi6\\+2, &si2\\+2\n+**\tBIC.W\t&lsi4, &lsi3\n+**\tBIC.W\t&lsi4\\+2, &lsi3\\+2\n+**\tBICX.W\t&si3, &lsi5\n+**\tBICX.W\t&si3\\+2, &lsi5\\+2\n+**\tBICX.W\t&lsi6, &si4\n+**\tBICX.W\t&lsi6\\+2, &si4\\+2\n+**\tBICX.W\t&si6, &si5\n+**\tBICX.W\t&si6\\+2, &si5\\+2\n+** ...\n+*/\n+void\n+bicsi3 (void)\n+{\n+  BIC_INSN(si)\n+}\n+\n+#define BIC_CG_INSN(MODE) \\\n+  E_VAR(MODE,1) &= (1 ^ E_VAR(MODE,1)); \\\n+  E_VAR(MODE,2) &= (2 ^ E_VAR(MODE,2)); \\\n+  L_VAR(MODE,1) &= (4 ^ L_VAR(MODE,1)); \\\n+  VAR(MODE,1) &= (8 ^ VAR(MODE,1)); \\\n+\n+/*\n+** bic_cg_qi3: { target msp430_region_lower }\n+** ...\n+**\tBICX.B\t#1, &eqi1\n+**\tBICX.B\t#2, &eqi2\n+**\tBIC.B\t#4, &lqi1\n+**\tBIC.B\t#8, &qi1\n+** ...\n+*/\n+/*\n+** bic_cg_qi3: { target msp430_region_not_lower }\n+** ...\n+**\tBICX.B\t#1, &eqi1\n+**\tBICX.B\t#2, &eqi2\n+**\tBIC.B\t#4, &lqi1\n+**\tBICX.B\t#8, &qi1\n+** ...\n+*/\n+void\n+bic_cg_qi3 (void)\n+{\n+  BIC_CG_INSN(qi)\n+}\n+\n+/*\n+** bic_cg_hi3: { target msp430_region_lower }\n+** ...\n+**\tBICX.W\t#1, &ehi1\n+**\tBICX.W\t#2, &ehi2\n+**\tBIC.W\t#4, &lhi1\n+**\tBIC.W\t#8, &hi1\n+** ...\n+*/\n+/*\n+** bic_cg_hi3: { target msp430_region_not_lower }\n+** ...\n+**\tBICX.W\t#1, &ehi1\n+**\tBICX.W\t#2, &ehi2\n+**\tBIC.W\t#4, &lhi1\n+**\tBICX.W\t#8, &hi1\n+** ...\n+*/\n+void\n+bic_cg_hi3 (void)\n+{\n+  BIC_CG_INSN(hi)\n+}\n+\n+/*\n+** bic_cg_psi3:\n+** ...\n+**\tBICX.A\t#1, &epsi1\n+**\tBICX.A\t#2, &epsi2\n+**\tBICX.A\t#4, &lpsi1\n+**\tBICX.A\t#8, &psi1\n+** ...\n+*/\n+void\n+bic_cg_psi3 (void)\n+{\n+  BIC_CG_INSN(psi)\n+}\n+\n+/* There is no specific bic_cg_si3 pattern defined for msp430, but we check\n+   this is synthesized correctly anyway.  */\n+/*\n+** bic_cg_si3: { target msp430_region_lower }\n+** ...\n+**\tBICX.W\t#1, &esi1\n+**\tBICX.W\t#2, &esi2\n+**\tBIC.W\t#4, &lsi1\n+**\tBIC.W\t#8, &si1\n+** ...\n+*/\n+/*\n+** bic_cg_si3: { target msp430_region_not_lower }\n+** ...\n+**\tBICX.W\t#1, &esi1\n+**\tBICX.W\t#2, &esi2\n+**\tBIC.W\t#4, &lsi1\n+**\tBICX.W\t#8, &si1\n+** ...\n+*/\n+void\n+bic_cg_si3 (void)\n+{\n+  BIC_CG_INSN(si)\n+}\n+\n+#define AND_INSN(MODE) \\\n+  E_VAR(MODE,1) &= E_VAR(MODE,2); \\\n+  E_VAR(MODE,3) &= L_VAR(MODE,1); \\\n+  E_VAR(MODE,4) &= VAR(MODE,1); \\\n+  L_VAR(MODE,2) &= E_VAR(MODE,5); \\\n+  VAR(MODE,2) &= E_VAR(MODE,6); \\\n+  L_VAR(MODE,3) &= L_VAR(MODE,4); \\\n+  L_VAR(MODE,5) &= VAR(MODE,3); \\\n+  VAR(MODE,4) &= VAR(MODE,5); \\\n+  VAR(MODE,6) &= L_VAR(MODE,6);\n+\n+/*\n+** andqi3: { target msp430_region_lower }\n+** ...\n+**\tANDX.B\t&eqi2, &eqi1\n+**\tANDX.B\t&lqi1, &eqi3\n+**\tANDX.B\t&qi1, &eqi4\n+**\tANDX.B\t&eqi5, &lqi2\n+**\tANDX.B\t&eqi6, &qi2\n+**\tAND.B\t&lqi4, &lqi3\n+**\tAND.B\t&qi3, &lqi5\n+**\tAND.B\t&qi5, &qi4\n+**\tAND.B\t&lqi6, &qi6\n+** ...\n+*/\n+/*\n+** andqi3: { target msp430_region_not_lower }\n+** ...\n+**\tANDX.B\t&eqi2, &eqi1\n+**\tANDX.B\t&lqi1, &eqi3\n+**\tANDX.B\t&qi1, &eqi4\n+**\tANDX.B\t&eqi5, &lqi2\n+**\tANDX.B\t&eqi6, &qi2\n+**\tAND.B\t&lqi4, &lqi3\n+**\tANDX.B\t&qi3, &lqi5\n+**\tANDX.B\t&qi5, &qi4\n+**\tANDX.B\t&lqi6, &qi6\n+** ...\n+*/\n+void\n+andqi3 (void)\n+{\n+  AND_INSN(qi)\n+}\n+\n+/*\n+** andhi3: { target msp430_region_lower }\n+** ...\n+**\tANDX.W\t&ehi2, &ehi1\n+**\tANDX.W\t&lhi1, &ehi3\n+**\tANDX.W\t&hi1, &ehi4\n+**\tANDX.W\t&ehi5, &lhi2\n+**\tANDX.W\t&ehi6, &hi2\n+**\tAND.W\t&lhi4, &lhi3\n+**\tAND.W\t&hi3, &lhi5\n+**\tAND.W\t&hi5, &hi4\n+**\tAND.W\t&lhi6, &hi6\n+** ...\n+*/\n+/*\n+** andhi3: { target msp430_region_not_lower }\n+** ...\n+**\tANDX.W\t&ehi2, &ehi1\n+**\tANDX.W\t&lhi1, &ehi3\n+**\tANDX.W\t&hi1, &ehi4\n+**\tANDX.W\t&ehi5, &lhi2\n+**\tANDX.W\t&ehi6, &hi2\n+**\tAND.W\t&lhi4, &lhi3\n+**\tANDX.W\t&hi3, &lhi5\n+**\tANDX.W\t&hi5, &hi4\n+**\tANDX.W\t&lhi6, &hi6\n+** ...\n+*/\n+void\n+andhi3 (void)\n+{\n+  AND_INSN(hi)\n+}\n+\n+/*\n+** andpsi3:\n+** ...\n+**\tANDX.A\t&epsi2, &epsi1\n+**\tANDX.A\t&lpsi1, &epsi3\n+**\tANDX.A\t&psi1, &epsi4\n+**\tANDX.A\t&epsi5, &lpsi2\n+**\tANDX.A\t&epsi6, &psi2\n+**\tANDX.A\t&lpsi4, &lpsi3\n+**\tANDX.A\t&psi3, &lpsi5\n+**\tANDX.A\t&psi5, &psi4\n+**\tANDX.A\t&lpsi6, &psi6\n+** ...\n+*/\n+void\n+andpsi3 (void)\n+{\n+  AND_INSN(psi)\n+}\n+\n+/* There is no specific andsi3 pattern defined for msp430, but we check\n+   this is synthesized correctly anyway.  */\n+/*\n+** andsi3: { target msp430_region_lower }\n+** ...\n+**\tANDX.W\t&esi2, &esi1\n+**\tANDX.W\t&esi2\\+2, &esi1\\+2\n+**\tANDX.W\t&lsi1, &esi3\n+**\tANDX.W\t&lsi1\\+2, &esi3\\+2\n+**\tANDX.W\t&si1, &esi4\n+**\tANDX.W\t&si1\\+2, &esi4\\+2\n+**\tANDX.W\t&esi5, &lsi2\n+**\tANDX.W\t&esi5\\+2, &lsi2\\+2\n+**\tANDX.W\t&esi6, &si2\n+**\tANDX.W\t&esi6\\+2, &si2\\+2\n+**\tAND.W\t&lsi4, &lsi3\n+**\tAND.W\t&lsi4\\+2, &lsi3\\+2\n+**\tAND.W\t&si3, &lsi5\n+**\tAND.W\t&si3\\+2, &lsi5\\+2\n+**\tAND.W\t&si5, &si4\n+**\tAND.W\t&si5\\+2, &si4\\+2\n+**\tAND.W\t&lsi6, &si6\n+**\tAND.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+/*\n+** andsi3: { target msp430_region_not_lower }\n+** ...\n+**\tANDX.W\t&esi2, &esi1\n+**\tANDX.W\t&esi2\\+2, &esi1\\+2\n+**\tANDX.W\t&lsi1, &esi3\n+**\tANDX.W\t&lsi1\\+2, &esi3\\+2\n+**\tANDX.W\t&si1, &esi4\n+**\tANDX.W\t&si1\\+2, &esi4\\+2\n+**\tANDX.W\t&esi5, &lsi2\n+**\tANDX.W\t&esi5\\+2, &lsi2\\+2\n+**\tANDX.W\t&esi6, &si2\n+**\tANDX.W\t&esi6\\+2, &si2\\+2\n+**\tAND.W\t&lsi4, &lsi3\n+**\tAND.W\t&lsi4\\+2, &lsi3\\+2\n+**\tANDX.W\t&si3, &lsi5\n+**\tANDX.W\t&si3\\+2, &lsi5\\+2\n+**\tANDX.W\t&si5, &si4\n+**\tANDX.W\t&si5\\+2, &si4\\+2\n+**\tANDX.W\t&lsi6, &si6\n+**\tANDX.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+void\n+andsi3 (void)\n+{\n+  AND_INSN(si)\n+}\n+\n+#define IOR_INSN(MODE) \\\n+  E_VAR(MODE,1) |= E_VAR(MODE,2); \\\n+  E_VAR(MODE,3) |= L_VAR(MODE,1); \\\n+  E_VAR(MODE,4) |= VAR(MODE,1); \\\n+  L_VAR(MODE,2) |= E_VAR(MODE,5); \\\n+  VAR(MODE,2) |= E_VAR(MODE,6); \\\n+  L_VAR(MODE,3) |= L_VAR(MODE,4); \\\n+  L_VAR(MODE,5) |= VAR(MODE,3); \\\n+  VAR(MODE,4) |= VAR(MODE,5); \\\n+  VAR(MODE,6) |= L_VAR(MODE,6);\n+\n+/*\n+** iorqi3: { target msp430_region_lower }\n+** ...\n+**\tBISX.B\t&eqi2, &eqi1\n+**\tBISX.B\t&lqi1, &eqi3\n+**\tBISX.B\t&qi1, &eqi4\n+**\tBISX.B\t&eqi5, &lqi2\n+**\tBISX.B\t&eqi6, &qi2\n+**\tBIS.B\t&lqi4, &lqi3\n+**\tBIS.B\t&qi3, &lqi5\n+**\tBIS.B\t&qi5, &qi4\n+**\tBIS.B\t&lqi6, &qi6\n+** ...\n+*/\n+/*\n+** iorqi3: { target msp430_region_not_lower }\n+** ...\n+**\tBISX.B\t&eqi2, &eqi1\n+**\tBISX.B\t&lqi1, &eqi3\n+**\tBISX.B\t&qi1, &eqi4\n+**\tBISX.B\t&eqi5, &lqi2\n+**\tBISX.B\t&eqi6, &qi2\n+**\tBIS.B\t&lqi4, &lqi3\n+**\tBISX.B\t&qi3, &lqi5\n+**\tBISX.B\t&qi5, &qi4\n+**\tBISX.B\t&lqi6, &qi6\n+** ...\n+*/\n+void\n+iorqi3 (void)\n+{\n+  IOR_INSN(qi)\n+}\n+\n+/*\n+** iorhi3: { target msp430_region_lower }\n+** ...\n+**\tBISX.W\t&ehi2, &ehi1\n+**\tBISX.W\t&lhi1, &ehi3\n+**\tBISX.W\t&hi1, &ehi4\n+**\tBISX.W\t&ehi5, &lhi2\n+**\tBISX.W\t&ehi6, &hi2\n+**\tBIS.W\t&lhi4, &lhi3\n+**\tBIS.W\t&hi3, &lhi5\n+**\tBIS.W\t&hi5, &hi4\n+**\tBIS.W\t&lhi6, &hi6\n+** ...\n+*/\n+/*\n+** iorhi3: { target msp430_region_not_lower }\n+** ...\n+**\tBISX.W\t&ehi2, &ehi1\n+**\tBISX.W\t&lhi1, &ehi3\n+**\tBISX.W\t&hi1, &ehi4\n+**\tBISX.W\t&ehi5, &lhi2\n+**\tBISX.W\t&ehi6, &hi2\n+**\tBIS.W\t&lhi4, &lhi3\n+**\tBISX.W\t&hi3, &lhi5\n+**\tBISX.W\t&hi5, &hi4\n+**\tBISX.W\t&lhi6, &hi6\n+** ...\n+*/\n+void\n+iorhi3 (void)\n+{\n+  IOR_INSN(hi)\n+}\n+\n+/*\n+** iorpsi3:\n+** ...\n+**\tBISX.A\t&epsi2, &epsi1\n+**\tBISX.A\t&lpsi1, &epsi3\n+**\tBISX.A\t&psi1, &epsi4\n+**\tBISX.A\t&epsi5, &lpsi2\n+**\tBISX.A\t&epsi6, &psi2\n+**\tBISX.A\t&lpsi4, &lpsi3\n+**\tBISX.A\t&psi3, &lpsi5\n+**\tBISX.A\t&psi5, &psi4\n+**\tBISX.A\t&lpsi6, &psi6\n+** ...\n+*/\n+void\n+iorpsi3 (void)\n+{\n+  IOR_INSN(psi)\n+}\n+\n+/* There is no specific iorsi3 pattern defined for msp430, but we check\n+   this is synthesized correctly anyway.  */\n+/*\n+** iorsi3: { target msp430_region_lower }\n+** ...\n+**\tBISX.W\t&esi2, &esi1\n+**\tBISX.W\t&esi2\\+2, &esi1\\+2\n+**\tBISX.W\t&lsi1, &esi3\n+**\tBISX.W\t&lsi1\\+2, &esi3\\+2\n+**\tBISX.W\t&si1, &esi4\n+**\tBISX.W\t&si1\\+2, &esi4\\+2\n+**\tBISX.W\t&esi5, &lsi2\n+**\tBISX.W\t&esi5\\+2, &lsi2\\+2\n+**\tBISX.W\t&esi6, &si2\n+**\tBISX.W\t&esi6\\+2, &si2\\+2\n+**\tBIS.W\t&lsi4, &lsi3\n+**\tBIS.W\t&lsi4\\+2, &lsi3\\+2\n+**\tBIS.W\t&si3, &lsi5\n+**\tBIS.W\t&si3\\+2, &lsi5\\+2\n+**\tBIS.W\t&si5, &si4\n+**\tBIS.W\t&si5\\+2, &si4\\+2\n+**\tBIS.W\t&lsi6, &si6\n+**\tBIS.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+/*\n+** iorsi3: { target msp430_region_not_lower }\n+** ...\n+**\tBISX.W\t&esi2, &esi1\n+**\tBISX.W\t&esi2\\+2, &esi1\\+2\n+**\tBISX.W\t&lsi1, &esi3\n+**\tBISX.W\t&lsi1\\+2, &esi3\\+2\n+**\tBISX.W\t&si1, &esi4\n+**\tBISX.W\t&si1\\+2, &esi4\\+2\n+**\tBISX.W\t&esi5, &lsi2\n+**\tBISX.W\t&esi5\\+2, &lsi2\\+2\n+**\tBISX.W\t&esi6, &si2\n+**\tBISX.W\t&esi6\\+2, &si2\\+2\n+**\tBIS.W\t&lsi4, &lsi3\n+**\tBIS.W\t&lsi4\\+2, &lsi3\\+2\n+**\tBISX.W\t&si3, &lsi5\n+**\tBISX.W\t&si3\\+2, &lsi5\\+2\n+**\tBISX.W\t&si5, &si4\n+**\tBISX.W\t&si5\\+2, &si4\\+2\n+**\tBISX.W\t&lsi6, &si6\n+**\tBISX.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+void\n+iorsi3 (void)\n+{\n+  IOR_INSN(si)\n+}\n+\n+#define XOR_INSN(MODE) \\\n+  E_VAR(MODE,1) ^= E_VAR(MODE,2); \\\n+  E_VAR(MODE,3) ^= L_VAR(MODE,1); \\\n+  E_VAR(MODE,4) ^= VAR(MODE,1); \\\n+  L_VAR(MODE,2) ^= E_VAR(MODE,5); \\\n+  VAR(MODE,2) ^= E_VAR(MODE,6); \\\n+  L_VAR(MODE,3) ^= L_VAR(MODE,4); \\\n+  L_VAR(MODE,5) ^= VAR(MODE,3); \\\n+  VAR(MODE,4) ^= VAR(MODE,5); \\\n+  VAR(MODE,6) ^= L_VAR(MODE,6);\n+\n+/*\n+** xorqi3: { target msp430_region_lower }\n+** ...\n+**\tXORX.B\t&eqi2, &eqi1\n+**\tXORX.B\t&lqi1, &eqi3\n+**\tXORX.B\t&qi1, &eqi4\n+**\tXORX.B\t&eqi5, &lqi2\n+**\tXORX.B\t&eqi6, &qi2\n+**\tXOR.B\t&lqi4, &lqi3\n+**\tXOR.B\t&qi3, &lqi5\n+**\tXOR.B\t&qi5, &qi4\n+**\tXOR.B\t&lqi6, &qi6\n+** ...\n+*/\n+/*\n+** xorqi3: { target msp430_region_not_lower }\n+** ...\n+**\tXORX.B\t&eqi2, &eqi1\n+**\tXORX.B\t&lqi1, &eqi3\n+**\tXORX.B\t&qi1, &eqi4\n+**\tXORX.B\t&eqi5, &lqi2\n+**\tXORX.B\t&eqi6, &qi2\n+**\tXOR.B\t&lqi4, &lqi3\n+**\tXORX.B\t&qi3, &lqi5\n+**\tXORX.B\t&qi5, &qi4\n+**\tXORX.B\t&lqi6, &qi6\n+** ...\n+*/\n+void\n+xorqi3 (void)\n+{\n+  XOR_INSN(qi)\n+}\n+\n+/*\n+** xorhi3: { target msp430_region_lower }\n+** ...\n+**\tXORX.W\t&ehi2, &ehi1\n+**\tXORX.W\t&lhi1, &ehi3\n+**\tXORX.W\t&hi1, &ehi4\n+**\tXORX.W\t&ehi5, &lhi2\n+**\tXORX.W\t&ehi6, &hi2\n+**\tXOR.W\t&lhi4, &lhi3\n+**\tXOR.W\t&hi3, &lhi5\n+**\tXOR.W\t&hi5, &hi4\n+**\tXOR.W\t&lhi6, &hi6\n+** ...\n+*/\n+/*\n+** xorhi3: { target msp430_region_not_lower }\n+** ...\n+**\tXORX.W\t&ehi2, &ehi1\n+**\tXORX.W\t&lhi1, &ehi3\n+**\tXORX.W\t&hi1, &ehi4\n+**\tXORX.W\t&ehi5, &lhi2\n+**\tXORX.W\t&ehi6, &hi2\n+**\tXOR.W\t&lhi4, &lhi3\n+**\tXORX.W\t&hi3, &lhi5\n+**\tXORX.W\t&hi5, &hi4\n+**\tXORX.W\t&lhi6, &hi6\n+** ...\n+*/\n+void\n+xorhi3 (void)\n+{\n+  XOR_INSN(hi)\n+}\n+\n+/*\n+** xorpsi3:\n+** ...\n+**\tXORX.A\t&epsi2, &epsi1\n+**\tXORX.A\t&lpsi1, &epsi3\n+**\tXORX.A\t&psi1, &epsi4\n+**\tXORX.A\t&epsi5, &lpsi2\n+**\tXORX.A\t&epsi6, &psi2\n+**\tXORX.A\t&lpsi4, &lpsi3\n+**\tXORX.A\t&psi3, &lpsi5\n+**\tXORX.A\t&psi5, &psi4\n+**\tXORX.A\t&lpsi6, &psi6\n+** ...\n+*/\n+void\n+xorpsi3 (void)\n+{\n+  XOR_INSN(psi)\n+}\n+\n+/* There is no specific xorsi3 pattern defined for msp430, but we check\n+   this is synthesized correctly anyway.  */\n+/*\n+** xorsi3: { target msp430_region_lower }\n+** ...\n+**\tXORX.W\t&esi2, &esi1\n+**\tXORX.W\t&esi2\\+2, &esi1\\+2\n+**\tXORX.W\t&lsi1, &esi3\n+**\tXORX.W\t&lsi1\\+2, &esi3\\+2\n+**\tXORX.W\t&si1, &esi4\n+**\tXORX.W\t&si1\\+2, &esi4\\+2\n+**\tXORX.W\t&esi5, &lsi2\n+**\tXORX.W\t&esi5\\+2, &lsi2\\+2\n+**\tXORX.W\t&esi6, &si2\n+**\tXORX.W\t&esi6\\+2, &si2\\+2\n+**\tXOR.W\t&lsi4, &lsi3\n+**\tXOR.W\t&lsi4\\+2, &lsi3\\+2\n+**\tXOR.W\t&si3, &lsi5\n+**\tXOR.W\t&si3\\+2, &lsi5\\+2\n+**\tXOR.W\t&si5, &si4\n+**\tXOR.W\t&si5\\+2, &si4\\+2\n+**\tXOR.W\t&lsi6, &si6\n+**\tXOR.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+/*\n+** xorsi3: { target msp430_region_not_lower }\n+** ...\n+**\tXORX.W\t&esi2, &esi1\n+**\tXORX.W\t&esi2\\+2, &esi1\\+2\n+**\tXORX.W\t&lsi1, &esi3\n+**\tXORX.W\t&lsi1\\+2, &esi3\\+2\n+**\tXORX.W\t&si1, &esi4\n+**\tXORX.W\t&si1\\+2, &esi4\\+2\n+**\tXORX.W\t&esi5, &lsi2\n+**\tXORX.W\t&esi5\\+2, &lsi2\\+2\n+**\tXORX.W\t&esi6, &si2\n+**\tXORX.W\t&esi6\\+2, &si2\\+2\n+**\tXOR.W\t&lsi4, &lsi3\n+**\tXOR.W\t&lsi4\\+2, &lsi3\\+2\n+**\tXORX.W\t&si3, &lsi5\n+**\tXORX.W\t&si3\\+2, &lsi5\\+2\n+**\tXORX.W\t&si5, &si4\n+**\tXORX.W\t&si5\\+2, &si4\\+2\n+**\tXORX.W\t&lsi6, &si6\n+**\tXORX.W\t&lsi6\\+2, &si6\\+2\n+** ...\n+*/\n+void\n+xorsi3 (void)\n+{\n+  XOR_INSN(si)\n+}\n+\n+#define DO1 \\\n+{ \\\n+  qi z; \\\n+  z += use_qi(z); \\\n+  use_qi(z); \\\n+}\n+\n+#define DO2 \\\n+{ \\\n+  hi z; \\\n+  z += use_hi(z); \\\n+  use_hi(z); \\\n+}\n+\n+#define DO3 \\\n+{ \\\n+  si z; \\\n+  z += use_si(z); \\\n+  use_si(z); \\\n+}\n+\n+#define CBRANCH_INSN(MODE) \\\n+  if (E_VAR(MODE,1) == E_VAR(MODE,2)) \\\n+    DO1 \\\n+  else if (E_VAR(MODE,3) == L_VAR(MODE,1)) \\\n+    DO2 \\\n+  else if (E_VAR(MODE,4) == VAR(MODE,1)) \\\n+    DO1 \\\n+  else if (L_VAR(MODE,2) == E_VAR(MODE,5)) \\\n+    DO2 \\\n+  else if (VAR(MODE,2) == E_VAR(MODE,6)) \\\n+    DO1 \\\n+  else if (L_VAR(MODE,3) == L_VAR(MODE,4)) \\\n+    DO2 \\\n+  else if (L_VAR(MODE,5) == VAR(MODE,3)) \\\n+    DO2 \\\n+  else if (VAR(MODE,4) == VAR(MODE,5)) \\\n+    DO1 \\\n+  else if (VAR(MODE,6) == L_VAR(MODE,6)) \\\n+    DO2\n+\n+/*\n+** cbranchqi4_real: { target msp430_region_lower }\n+** ...\n+**\tCMPX.B\t&eqi2, &eqi1 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&lqi1, &eqi3 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&qi1, &eqi4 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&eqi5, &lqi2 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&eqi6, &qi2 { JEQ\t.L[0-9]+\n+**\tCMP.B\t&lqi4, &lqi3 { JEQ\t.L[0-9]+\n+**\tCMP.B\t&qi3, &lqi5 { JEQ\t.L[0-9]+\n+**\tCMP.B\t&qi5, &qi4 { JEQ\t.L[0-9]+\n+**\tCMP.B\t&lqi6, &qi6 { JNE\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** cbranchqi4_real: { target msp430_region_not_lower }\n+** ...\n+**\tCMPX.B\t&eqi2, &eqi1 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&lqi1, &eqi3 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&qi1, &eqi4 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&eqi5, &lqi2 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&eqi6, &qi2 { JEQ\t.L[0-9]+\n+**\tCMP.B\t&lqi4, &lqi3 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&qi3, &lqi5 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&qi5, &qi4 { JEQ\t.L[0-9]+\n+**\tCMPX.B\t&lqi6, &qi6 { JNE\t.L[0-9]+\n+** ...\n+*/\n+void\n+cbranchqi4_real (void)\n+{\n+  CBRANCH_INSN(qi)\n+}\n+\n+/*\n+** cbranchhi4_real: { target msp430_region_lower }\n+** ...\n+**\tCMPX.W\t&ehi2, &ehi1 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lhi1, &ehi3 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&hi1, &ehi4 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&ehi5, &lhi2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&ehi6, &hi2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lhi4, &lhi3 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&hi3, &lhi5 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&hi5, &hi4 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lhi6, &hi6 { JNE\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** cbranchhi4_real: { target msp430_region_not_lower }\n+** ...\n+**\tCMPX.W\t&ehi2, &ehi1 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lhi1, &ehi3 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&hi1, &ehi4 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&ehi5, &lhi2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&ehi6, &hi2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lhi4, &lhi3 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&hi3, &lhi5 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&hi5, &hi4 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lhi6, &hi6 { JNE\t.L[0-9]+\n+** ...\n+*/\n+void\n+cbranchhi4_real (void)\n+{\n+  CBRANCH_INSN(hi)\n+}\n+\n+/* There is no specific cbranchsi4_real pattern defined for msp430, but we\n+   check this is synthesized correctly anyway.  */\n+/*\n+** cbranchsi4_real: { target msp430_region_lower }\n+** ...\n+**\tCMPX.W\t&esi2, &esi1 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lsi1, &esi3 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si1, &esi4 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi5, &lsi2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi6, &si2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lsi4, &lsi3 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&si3, &lsi5 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&si5, &si4 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lsi6, &si6 { JNE\t.L[0-9]+\n+**\tCMP.W\t&lsi6\\+2, &si6\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&esi2\\+2, &esi1\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&lsi1\\+2, &esi3\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&si1\\+2, &esi4\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&esi5\\+2, &lsi2\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&esi6\\+2, &si2\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMP.W\t&lsi4\\+2, &lsi3\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMP.W\t&si3\\+2, &lsi5\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMP.W\t&si5\\+2, &si4\\+2 { JNE\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** cbranchsi4_real: { target msp430_region_not_lower }\n+** ...\n+**\tCMPX.W\t&esi2, &esi1 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lsi1, &esi3 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si1, &esi4 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi5, &lsi2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi6, &si2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lsi4, &lsi3 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si3, &lsi5 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si5, &si4 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lsi6, &si6 { JNE\t.L[0-9]+\n+**\tCMPX.W\t&lsi6\\+2, &si6\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&esi2\\+2, &esi1\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&lsi1\\+2, &esi3\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&si1\\+2, &esi4\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&esi5\\+2, &lsi2\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&esi6\\+2, &si2\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMP.W\t&lsi4\\+2, &lsi3\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&si3\\+2, &lsi5\\+2 { JNE\t.L[0-9]+\n+** ...\n+**\tCMPX.W\t&si5\\+2, &si4\\+2 { JNE\t.L[0-9]+\n+** ...\n+*/\n+void\n+cbranchsi4_real (void)\n+{\n+  CBRANCH_INSN(si)\n+}\n+\n+#define CBRANCH_REVERSE_INSN(MODE) \\\n+  if (E_VAR(MODE,1) > E_VAR(MODE,2)) \\\n+    DO1 \\\n+  else if (E_VAR(MODE,3) > L_VAR(MODE,1)) \\\n+    DO2 \\\n+  else if (E_VAR(MODE,4) > VAR(MODE,1)) \\\n+    DO1 \\\n+  else if (L_VAR(MODE,2) > E_VAR(MODE,5)) \\\n+    DO2 \\\n+  else if (VAR(MODE,2) > E_VAR(MODE,6)) \\\n+    DO1 \\\n+  else if (L_VAR(MODE,3) > L_VAR(MODE,4)) \\\n+    DO2 \\\n+  else if (L_VAR(MODE,5) > VAR(MODE,3)) \\\n+    DO2 \\\n+  else if (VAR(MODE,4) > VAR(MODE,5)) \\\n+    DO1 \\\n+  else if (VAR(MODE,6) > L_VAR(MODE,6)) \\\n+    DO2\n+\n+/*\n+** cbranchqi4_reversed: { target msp430_region_lower }\n+** ...\n+**\tCMPX.B\t&eqi1, &eqi2 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&eqi3, &lqi1 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&eqi4, &qi1 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&lqi2, &eqi5 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&qi2, &eqi6 { JLO\t.L[0-9]+\n+**\tCMP.B\t&lqi3, &lqi4 { JLO\t.L[0-9]+\n+**\tCMP.B\t&lqi5, &qi3 { JLO\t.L[0-9]+\n+**\tCMP.B\t&qi4, &qi5 { JLO\t.L[0-9]+\n+**\tCMP.B\t&qi6, &lqi6 { JHS\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** cbranchqi4_reversed: { target msp430_region_not_lower }\n+** ...\n+**\tCMPX.B\t&eqi1, &eqi2 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&eqi3, &lqi1 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&eqi4, &qi1 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&lqi2, &eqi5 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&qi2, &eqi6 { JLO\t.L[0-9]+\n+**\tCMP.B\t&lqi3, &lqi4 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&lqi5, &qi3 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&qi4, &qi5 { JLO\t.L[0-9]+\n+**\tCMPX.B\t&qi6, &lqi6 { JHS\t.L[0-9]+\n+** ...\n+*/\n+void\n+cbranchqi4_reversed (void)\n+{\n+  CBRANCH_REVERSE_INSN(qi)\n+}\n+\n+/*\n+** cbranchhi4_reversed: { target msp430_region_lower }\n+** ...\n+**\tCMPX.W\t&ehi1, &ehi2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&ehi3, &lhi1 { JL\t.L[0-9]+\n+**\tCMPX.W\t&ehi4, &hi1 { JL\t.L[0-9]+\n+**\tCMPX.W\t&lhi2, &ehi5 { JL\t.L[0-9]+\n+**\tCMPX.W\t&hi2, &ehi6 { JL\t.L[0-9]+\n+**\tCMP.W\t&lhi3, &lhi4 { JL\t.L[0-9]+\n+**\tCMP.W\t&lhi5, &hi3 { JL\t.L[0-9]+\n+**\tCMP.W\t&hi4, &hi5 { JL\t.L[0-9]+\n+**\tCMP.W\t&hi6, &lhi6 { JGE\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** cbranchhi4_reversed: { target msp430_region_not_lower }\n+** ...\n+**\tCMPX.W\t&ehi1, &ehi2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&ehi3, &lhi1 { JL\t.L[0-9]+\n+**\tCMPX.W\t&ehi4, &hi1 { JL\t.L[0-9]+\n+**\tCMPX.W\t&lhi2, &ehi5 { JL\t.L[0-9]+\n+**\tCMPX.W\t&hi2, &ehi6 { JL\t.L[0-9]+\n+**\tCMP.W\t&lhi3, &lhi4 { JL\t.L[0-9]+\n+**\tCMPX.W\t&lhi5, &hi3 { JL\t.L[0-9]+\n+**\tCMPX.W\t&hi4, &hi5 { JL\t.L[0-9]+\n+**\tCMPX.W\t&hi6, &lhi6 { JGE\t.L[0-9]+\n+** ...\n+*/\n+void\n+cbranchhi4_reversed (void)\n+{\n+  CBRANCH_REVERSE_INSN(hi)\n+}\n+\n+/* There is no specific cbranchsi4_reversed pattern defined for msp430, but\n+   we check this is synthesized correctly anyway.\n+   This output assembly for this one is quite long and convoluted so we only\n+   check part of it.  */\n+/*\n+** cbranchsi4_reversed: { target msp430_region_lower }\n+** ...\n+**\tCMPX.W\t&esi1\\+2, &esi2\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&esi2\\+2, &esi1\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi3\\+2, &lsi1\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&lsi1\\+2, &esi3\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi4\\+2, &si1\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&si1\\+2, &esi4\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lsi2\\+2, &esi5\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&esi5\\+2, &lsi2\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si2\\+2, &esi6\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&esi6\\+2, &si2\\+2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lsi3\\+2, &lsi4\\+2 { JL\t.L[0-9]+\n+**\tCMP.W\t&lsi4\\+2, &lsi3\\+2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lsi5\\+2, &si3\\+2 { JL\t.L[0-9]+\n+**\tCMP.W\t&si3\\+2, &lsi5\\+2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&si4\\+2, &si5\\+2 { JL\t.L[0-9]+\n+**\tCMP.W\t&si5\\+2, &si4\\+2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&si6\\+2, &lsi6\\+2 { JL\t.L[0-9]+\n+**\tCMP.W\t&lsi6\\+2, &si6\\+2 { JNE\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** cbranchsi4_reversed: { target msp430_region_not_lower }\n+** ...\n+**\tCMPX.W\t&esi1\\+2, &esi2\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&esi2\\+2, &esi1\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi3\\+2, &lsi1\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&lsi1\\+2, &esi3\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&esi4\\+2, &si1\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&si1\\+2, &esi4\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lsi2\\+2, &esi5\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&esi5\\+2, &lsi2\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si2\\+2, &esi6\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&esi6\\+2, &si2\\+2 { JEQ\t.L[0-9]+\n+**\tCMP.W\t&lsi3\\+2, &lsi4\\+2 { JL\t.L[0-9]+\n+**\tCMP.W\t&lsi4\\+2, &lsi3\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&lsi5\\+2, &si3\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&si3\\+2, &lsi5\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si4\\+2, &si5\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&si5\\+2, &si4\\+2 { JEQ\t.L[0-9]+\n+**\tCMPX.W\t&si6\\+2, &lsi6\\+2 { JL\t.L[0-9]+\n+**\tCMPX.W\t&lsi6\\+2, &si6\\+2 { JNE\t.L[0-9]+\n+** ...\n+*/\n+void\n+cbranchsi4_reversed (void)\n+{\n+  CBRANCH_REVERSE_INSN(si)\n+}\n+\n+#define BITBRANCH_NE_INSN(MODE) \\\n+  if (E_VAR(MODE,1) & E_VAR(MODE,2)) \\\n+    DO1 \\\n+  else if (E_VAR(MODE,3) & L_VAR(MODE,1)) \\\n+    DO2 \\\n+  else if (E_VAR(MODE,4) & VAR(MODE,1)) \\\n+    DO1 \\\n+  else if (L_VAR(MODE,2) & E_VAR(MODE,5)) \\\n+    DO2 \\\n+  else if (VAR(MODE,2) & E_VAR(MODE,6)) \\\n+    DO1 \\\n+  else if (L_VAR(MODE,3) & L_VAR(MODE,4)) \\\n+    DO2 \\\n+  else if (L_VAR(MODE,5) & VAR(MODE,3)) \\\n+    DO2 \\\n+  else if (VAR(MODE,4) & VAR(MODE,5)) \\\n+    DO1 \\\n+  else if (VAR(MODE,6) & L_VAR(MODE,6)) \\\n+    DO2\n+/*\n+** bitbranchqi4: { target msp430_region_lower }\n+** ...\n+**\tBITX.B\t&eqi2, &eqi1 { JNE\t.L[0-9]+\n+**\tBITX.B\t&lqi1, &eqi3 { JNE\t.L[0-9]+\n+**\tBITX.B\t&qi1, &eqi4 { JNE\t.L[0-9]+\n+**\tBITX.B\t&eqi5, &lqi2 { JNE\t.L[0-9]+\n+**\tBITX.B\t&eqi6, &qi2 { JNE\t.L[0-9]+\n+**\tBIT.B\t&lqi4, &lqi3 { JNE\t.L[0-9]+\n+**\tBIT.B\t&qi3, &lqi5 { JNE\t.L[0-9]+\n+**\tBIT.B\t&qi5, &qi4 { JNE\t.L[0-9]+\n+**\tBIT.B\t&lqi6, &qi6 { JEQ\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** bitbranchqi4: { target msp430_region_not_lower }\n+** ...\n+**\tBITX.B\t&eqi2, &eqi1 { JNE\t.L[0-9]+\n+**\tBITX.B\t&lqi1, &eqi3 { JNE\t.L[0-9]+\n+**\tBITX.B\t&qi1, &eqi4 { JNE\t.L[0-9]+\n+**\tBITX.B\t&eqi5, &lqi2 { JNE\t.L[0-9]+\n+**\tBITX.B\t&eqi6, &qi2 { JNE\t.L[0-9]+\n+**\tBIT.B\t&lqi4, &lqi3 { JNE\t.L[0-9]+\n+**\tBITX.B\t&qi3, &lqi5 { JNE\t.L[0-9]+\n+**\tBITX.B\t&qi5, &qi4 { JNE\t.L[0-9]+\n+**\tBITX.B\t&lqi6, &qi6 { JEQ\t.L[0-9]+\n+** ...\n+*/\n+void\n+bitbranchqi4 (void)\n+{\n+  BITBRANCH_NE_INSN(qi)\n+}\n+\n+/*\n+** bitbranchhi4: { target msp430_region_lower }\n+** ...\n+**\tBITX.W\t&ehi2, &ehi1 { JNE\t.L[0-9]+\n+**\tBITX.W\t&lhi1, &ehi3 { JNE\t.L[0-9]+\n+**\tBITX.W\t&hi1, &ehi4 { JNE\t.L[0-9]+\n+**\tBITX.W\t&ehi5, &lhi2 { JNE\t.L[0-9]+\n+**\tBITX.W\t&ehi6, &hi2 { JNE\t.L[0-9]+\n+**\tBIT.W\t&lhi4, &lhi3 { JNE\t.L[0-9]+\n+**\tBIT.W\t&hi3, &lhi5 { JNE\t.L[0-9]+\n+**\tBIT.W\t&hi5, &hi4 { JNE\t.L[0-9]+\n+**\tBIT.W\t&lhi6, &hi6 { JEQ\t.L[0-9]+\n+** ...\n+*/\n+/*\n+** bitbranchhi4: { target msp430_region_not_lower }\n+** ...\n+**\tBITX.W\t&ehi2, &ehi1 { JNE\t.L[0-9]+\n+**\tBITX.W\t&lhi1, &ehi3 { JNE\t.L[0-9]+\n+**\tBITX.W\t&hi1, &ehi4 { JNE\t.L[0-9]+\n+**\tBITX.W\t&ehi5, &lhi2 { JNE\t.L[0-9]+\n+**\tBITX.W\t&ehi6, &hi2 { JNE\t.L[0-9]+\n+**\tBIT.W\t&lhi4, &lhi3 { JNE\t.L[0-9]+\n+**\tBITX.W\t&hi3, &lhi5 { JNE\t.L[0-9]+\n+**\tBITX.W\t&hi5, &hi4 { JNE\t.L[0-9]+\n+**\tBITX.W\t&lhi6, &hi6 { JEQ\t.L[0-9]+\n+** ...\n+*/\n+void\n+bitbranchhi4 (void)\n+{\n+  BITBRANCH_NE_INSN(hi)\n+}\n+\n+/*\n+** bitbranchpsi4:\n+** ...\n+**\tBITX.A\t&epsi2, &epsi1 { JNE\t.L[0-9]+\n+**\tBITX.A\t&lpsi1, &epsi3 { JNE\t.L[0-9]+\n+**\tBITX.A\t&psi1, &epsi4 { JNE\t.L[0-9]+\n+**\tBITX.A\t&epsi5, &lpsi2 { JNE\t.L[0-9]+\n+**\tBITX.A\t&epsi6, &psi2 { JNE\t.L[0-9]+\n+**\tBITX.A\t&lpsi4, &lpsi3 { JNE\t.L[0-9]+\n+**\tBITX.A\t&psi3, &lpsi5 { JNE\t.L[0-9]+\n+**\tBITX.A\t&psi5, &psi4 { JNE\t.L[0-9]+\n+**\tBITX.A\t&lpsi6, &psi6 { JEQ\t.L[0-9]+\n+** ...\n+*/\n+void\n+bitbranchpsi4 (void)\n+{\n+  BITBRANCH_NE_INSN(psi)\n+}\n+\n+\n+/* \"bitbranch\" using SImode operands is omitted since the resulting assembly\n+   uses many temporary registers to perform the bitwise and comparison\n+   operations.  */"}, {"sha": "6113e99f052a3b59a7fed7d7962d2d67ef206c8b", "filename": "gcc/testsuite/gcc.target/msp430/data-attributes-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes-2.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -27,7 +27,7 @@ int __attribute__((lower,upper)) lu = 20; /* { dg-warning \"ignoring attribute 'u\n int __attribute__((lower,either)) le = 20; /* { dg-warning \"ignoring attribute 'either' because it conflicts with attribute 'lower'\" } */\n int __attribute__((lower,persistent)) lp = 20; /* { dg-warning \"ignoring attribute 'persistent' because it conflicts with attribute 'lower'\" } */\n int __attribute__((lower,noinit)) ln; /* { dg-warning \"ignoring attribute 'noinit' because it conflicts with attribute 'lower'\" } */\n-int __attribute__((lower,section(\".data.foo\"))) ls = 30; /* { dg-warning \"ignoring attribute 'section' because it conflicts with attribute 'lower'\" } */\n+int __attribute__((lower,section(\".data.foo\"))) ls = 30;\n \n int __attribute__((upper)) u = 20;\n int __attribute__((upper,lower)) ul = 20; /* { dg-warning \"ignoring attribute 'lower' because it conflicts with attribute 'upper'\" } */\n@@ -46,6 +46,6 @@ int __attribute__((either,section(\".data.foo\"))) es = 30; /* { dg-warning \"ignor\n int __attribute__((section(\".data.foo\"))) s = 20;\n int __attribute__((section(\".data.foo\"),noinit)) sn; /* { dg-warning \"ignoring attribute 'noinit' because it conflicts with attribute 'section'\" } */\n int __attribute__((section(\".data.foo\"),persistent)) sp = 20; /* { dg-warning \"ignoring attribute 'persistent' because it conflicts with attribute 'section'\" } */\n-int __attribute__((section(\".data.foo\"),lower)) sl = 2; /* { dg-warning \"ignoring attribute 'lower' because it conflicts with attribute 'section'\" } */\n+int __attribute__((section(\".data.foo\"),lower)) sl = 2;\n int __attribute__((section(\".data.foo\"),upper)) su = 20; /* { dg-warning \"ignoring attribute 'upper' because it conflicts with attribute 'section'\" } */\n int __attribute__((section(\".data.foo\"),either)) se = 2; /* { dg-warning \"ignoring attribute 'either' because it conflicts with attribute 'section'\" } */"}, {"sha": "bcc56861abc4f0bfb580af22a3f37b2a972c9591", "filename": "gcc/testsuite/gcc.target/msp430/msp430.exp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmsp430.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmsp430.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fmsp430.exp?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -36,6 +36,14 @@ proc check_effective_target_msp430_mlarge_selected { } {\n     return [check-flags [list \"\" { *-*-* } { \"-mlarge\" } { \"\" } ]]\n }\n \n+proc check_effective_target_msp430_region_not_lower { } {\n+    return [check-flags [list \"\" { *-*-* } { \"-mdata-region=none\" \"-mdata-region=upper\" \"-mdata-region=either\" } { \"\" } ]]\n+}\n+\n+proc check_effective_target_msp430_region_lower { } {\n+    return [check-flags [list \"\" { *-*-* } { \"*\" } { \"-mdata-region=none\" \"-mdata-region=upper\" \"-mdata-region=either\" } ]]\n+}\n+\n proc check_effective_target_msp430_hwmul_not_none { } {\n     return [check-flags [list \"\" { *-*-* } \\\n     { \"-mhwmult=16bit\" \"-mhwmult=32bit\" \"-mhwmult=f5series\" } { \"\" } ]]"}, {"sha": "4296be22edb6819f0c0f42f68180262ba6759d12", "filename": "gcc/testsuite/gcc.target/msp430/object-attributes-430.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-430.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430x\" \"-mlarge\" } { \"\" } } */\n+/* { dg-options \"-mcpu=msp430\" } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 4, 1\" } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 6, 1\" } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 8, 1\" } } */\n+/* { dg-final { scan-assembler \".gnu_attribute 4, 1\" } } */\n+\n+int\n+main (void)\n+{\n+  while (1);\n+  return 0;\n+}"}, {"sha": "39c1f3eab44ca3ba159c08031099591886857a70", "filename": "gcc/testsuite/gcc.target/msp430/object-attributes-default.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-default.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-default.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-default.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 4, 1\" { target msp430_430_selected } } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 4, 2\" { target msp430_430x_selected } } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 6, 1\" { target { ! msp430_mlarge_selected } } } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 8, 1\" { target { ! msp430_mlarge_selected } } } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 6, 2\" { target msp430_mlarge_selected } } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 8, 2\" { target msp430_mlarge_selected } } } */\n+/* { dg-final { scan-assembler \".gnu_attribute 4, 1\" { target { ! msp430_region_not_lower } } } } */\n+/* { dg-final { scan-assembler \".gnu_attribute 4, 2\" { target msp430_region_not_lower } } } */\n+\n+int\n+main (void)\n+{\n+  while (1);\n+  return 0;\n+}"}, {"sha": "2aa8bfb3663577e57f9c56afe612d1ca51d52d28", "filename": "gcc/testsuite/gcc.target/msp430/object-attributes-mlarge-any-region.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-mlarge-any-region.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-mlarge-any-region.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-mlarge-any-region.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" \"-mdata-region=lower\" } { \"\" } } */\n+/* { dg-options \"-mlarge -mdata-region=none\" } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 4, 2\" } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 6, 2\" } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 8, 2\" } } */\n+/* { dg-final { scan-assembler \".gnu_attribute 4, 2\" } } */\n+\n+int\n+main (void)\n+{\n+  while (1);\n+  return 0;\n+}"}, {"sha": "06738ea795acf34c2b13c1a1e822f6f413dab73e", "filename": "gcc/testsuite/gcc.target/msp430/object-attributes-mlarge.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-mlarge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-mlarge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fobject-attributes-mlarge.c?ref=8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" } { \"\" } } */\n+/* { dg-options \"-mlarge\" } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 4, 2\" } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 6, 2\" } } */\n+/* { dg-final { scan-assembler \".mspabi_attribute 8, 2\" } } */\n+/* { dg-final { scan-assembler \".gnu_attribute 4, 1\" { target msp430_region_lower } } } */\n+/* { dg-final { scan-assembler \".gnu_attribute 4, 2\" { target { ! msp430_region_lower } } } } */\n+\n+int\n+main (void)\n+{\n+  while (1);\n+  return 0;\n+}"}]}