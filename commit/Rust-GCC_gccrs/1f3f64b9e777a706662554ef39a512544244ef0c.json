{"sha": "1f3f64b9e777a706662554ef39a512544244ef0c", "node_id": "C_kwDOANBUbNoAKDFmM2Y2NGI5ZTc3N2E3MDY2NjI1NTRlZjM5YTUxMjU0NDI0NGVmMGM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-28T17:03:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-13T10:01:22Z"}, "message": "[Ada] Extend No_Dependence restriction to code generation\n\nThis reports violations for 4 units from gigi.\n\ngcc/ada/\n\n\t* gcc-interface/trans.cc (gigi): Report a violation of No_Dependence\n\ton System.Stack_Checking if Stack_Check_Probes_On_Target is not set\n\tand -fstack-check is specified.\n\t(build_binary_op_trapv): Report violatiosn of No_Dependence on both\n\tSystem.Arith_64 and System.Arith_128.\n\t(add_decl_expr): If an initialized variable, report a violation of\n\tNo_Dependence on System.Memory_Copy for large aggregate types.\n\t(gnat_to_gnu) <N_Op_Eq>: Report a violation\n\tof No_Dependence on System.Memory_Compare for large aggregate types.\n\t<N_Assignment_Statement>! Report a violation of No_Dependence on\n\tSystem.Memory_Set, System.Memory_Move or else System.Memory_Copy for\n\tlarge aggregate types.\n\t* gcc-interface/utils2.cc (maybe_wrap_malloc): Report a violation of\n\tNo_Dependence on System.Memory.\n\t(maybe_wrap_free): Add GNAT_NODE parameter and report a violation of\n\tNo_Dependence on System.Memory.\n\t(build_call_alloc_dealloc): Adjust call to maybe_wrap_free.", "tree": {"sha": "55685db14669e4cb9ed2988d75cfa55782ab0a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55685db14669e4cb9ed2988d75cfa55782ab0a2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f3f64b9e777a706662554ef39a512544244ef0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3f64b9e777a706662554ef39a512544244ef0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3f64b9e777a706662554ef39a512544244ef0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3f64b9e777a706662554ef39a512544244ef0c/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "351659f8dc80f1faaefae9fec2eab30c24ff282d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351659f8dc80f1faaefae9fec2eab30c24ff282d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/351659f8dc80f1faaefae9fec2eab30c24ff282d"}], "stats": {"total": 85, "additions": 64, "deletions": 21}, "files": [{"sha": "9d7fd2b2377feb31b673633db0c65f290e4b23fe", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3f64b9e777a706662554ef39a512544244ef0c/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3f64b9e777a706662554ef39a512544244ef0c/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=1f3f64b9e777a706662554ef39a512544244ef0c", "patch": "@@ -364,7 +364,12 @@ gigi (Node_Id gnat_root,\n \n   /* Enable GNAT stack checking method if needed */\n   if (!Stack_Check_Probes_On_Target)\n-    set_stack_check_libfunc (\"__gnat_stack_check\");\n+    {\n+      set_stack_check_libfunc (\"__gnat_stack_check\");\n+      if (flag_stack_check != NO_STACK_CHECK)\n+\tCheck_Restriction_No_Dependence_On_System (Name_Stack_Checking,\n+\t\t\t\t\t\t   gnat_root);\n+    }\n \n   /* Retrieve alignment settings.  */\n   double_float_alignment = get_target_double_float_alignment ();\n@@ -6933,9 +6938,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      = convert (TREE_TYPE (gnu_rhs), TYPE_SIZE (gnu_type));\n \t  }\n \n+\t/* If this is a comparison between (potentially) large aggregates, then\n+\t   declare the dependence on the memcmp routine.  */\n+\telse if ((kind == N_Op_Eq || kind == N_Op_Ne)\n+\t\t && AGGREGATE_TYPE_P (TREE_TYPE (gnu_lhs))\n+\t\t && (!TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_lhs)))\n+\t\t     || compare_tree_int (TYPE_SIZE (TREE_TYPE (gnu_lhs)),\n+\t\t\t\t\t  2 * BITS_PER_WORD) > 0))\n+\t  Check_Restriction_No_Dependence_On_System (Name_Memory_Compare,\n+\t\t\t\t\t\t     gnat_node);\n+\n \t/* Pending generic support for efficient vector logical operations in\n-\t   GCC, convert vectors to their representative array type view and\n-\t   fallthrough.  */\n+\t   GCC, convert vectors to their representative array type view.  */\n \tgnu_lhs = maybe_vector_array (gnu_lhs);\n \tgnu_rhs = maybe_vector_array (gnu_rhs);\n \n@@ -7254,6 +7268,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t  value = int_const_binop (BIT_AND_EXPR, value, mask);\n \t\t}\n \t      gnu_result = build_call_expr (t, 3, dest, value, size);\n+\t      Check_Restriction_No_Dependence_On_System (Name_Memory_Set,\n+\t\t\t\t\t\t\t gnat_node);\n \t    }\n \n \t  /* Otherwise build a regular assignment.  */\n@@ -7278,7 +7294,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      tree from_ptr = build_fold_addr_expr (from);\n \t      tree t = builtin_decl_explicit (BUILT_IN_MEMMOVE);\n \t      gnu_result = build_call_expr (t, 3, to_ptr, from_ptr, size);\n+\t      Check_Restriction_No_Dependence_On_System (Name_Memory_Move,\n+\t\t\t\t\t\t\t gnat_node);\n \t   }\n+\n+\t  /* If this is an assignment between (potentially) large aggregates,\n+\t     then declare the dependence on the memcpy routine.  */\n+\t  else if (AGGREGATE_TYPE_P (TREE_TYPE (gnu_lhs))\n+\t\t   && (!TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_lhs)))\n+\t\t       || compare_tree_int (TYPE_SIZE (TREE_TYPE (gnu_lhs)),\n+\t\t\t\t\t    2 * BITS_PER_WORD) > 0))\n+\t    Check_Restriction_No_Dependence_On_System (Name_Memory_Copy,\n+\t\t\t\t\t\t       gnat_node);\n \t}\n       break;\n \n@@ -8437,27 +8464,37 @@ add_decl_expr (tree gnu_decl, Node_Id gnat_node)\n       && !TYPE_FAT_POINTER_P (type))\n     MARK_VISITED (TYPE_ADA_SIZE (type));\n \n-  /* If this is a variable and an initializer is attached to it, it must be\n-     valid for the context.  Similar to init_const in create_var_decl.  */\n-  if (TREE_CODE (gnu_decl) == VAR_DECL\n-      && (gnu_init = DECL_INITIAL (gnu_decl))\n-      && (!gnat_types_compatible_p (type, TREE_TYPE (gnu_init))\n+  if (TREE_CODE (gnu_decl) == VAR_DECL && (gnu_init = DECL_INITIAL (gnu_decl)))\n+    {\n+      /* If this is a variable and an initializer is attached to it, it must be\n+\t valid for the context.  Similar to init_const in create_var_decl.  */\n+      if (!gnat_types_compatible_p (type, TREE_TYPE (gnu_init))\n \t  || (TREE_STATIC (gnu_decl)\n \t      && !initializer_constant_valid_p (gnu_init,\n-\t\t\t\t\t\tTREE_TYPE (gnu_init)))))\n-    {\n-      DECL_INITIAL (gnu_decl) = NULL_TREE;\n-      if (TREE_READONLY (gnu_decl))\n+\t\t\t\t\t\tTREE_TYPE (gnu_init))))\n \t{\n-\t  TREE_READONLY (gnu_decl) = 0;\n-\t  DECL_READONLY_ONCE_ELAB (gnu_decl) = 1;\n-\t}\n+\t  DECL_INITIAL (gnu_decl) = NULL_TREE;\n+\t  if (TREE_READONLY (gnu_decl))\n+\t    {\n+\t      TREE_READONLY (gnu_decl) = 0;\n+\t      DECL_READONLY_ONCE_ELAB (gnu_decl) = 1;\n+\t    }\n+\n+\t  /* Remove any padding so the assignment is done properly.  */\n+\t  gnu_decl = maybe_padded_object (gnu_decl);\n \n-      /* Remove any padding so the assignment is done properly.  */\n-      gnu_decl = maybe_padded_object (gnu_decl);\n+\t  gnu_stmt\n+\t    = build_binary_op (INIT_EXPR, NULL_TREE, gnu_decl, gnu_init);\n+\t  add_stmt_with_node (gnu_stmt, gnat_node);\n+\t}\n \n-      gnu_stmt = build_binary_op (INIT_EXPR, NULL_TREE, gnu_decl, gnu_init);\n-      add_stmt_with_node (gnu_stmt, gnat_node);\n+      /* If this is the initialization of a (potentially) large aggregate, then\n+\t declare the dependence on the memcpy routine.  */\n+      if (AGGREGATE_TYPE_P (type)\n+\t  && (!TREE_CONSTANT (TYPE_SIZE (type))\n+\t      || compare_tree_int (TYPE_SIZE (type), 2 * BITS_PER_WORD) > 0))\n+\tCheck_Restriction_No_Dependence_On_System (Name_Memory_Copy,\n+\t\t\t\t\t\t   gnat_node);\n     }\n }\n \n@@ -9359,6 +9396,7 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n       if (code == MULT_EXPR && precision == 64 && BITS_PER_WORD < 64)\n \t{\n \t  tree int64 = gnat_type_for_size (64, 0);\n+\t  Check_Restriction_No_Dependence_On_System (Name_Arith_64, gnat_node);\n \t  return convert (gnu_type, build_call_n_expr (mulv64_decl, 2,\n \t\t\t\t\t\t       convert (int64, lhs),\n \t\t\t\t\t\t       convert (int64, rhs)));\n@@ -9368,6 +9406,7 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n       else if (code == MULT_EXPR && precision == 128 && BITS_PER_WORD < 128)\n \t{\n \t  tree int128 = gnat_type_for_size (128, 0);\n+\t  Check_Restriction_No_Dependence_On_System (Name_Arith_128, gnat_node);\n \t  return convert (gnu_type, build_call_n_expr (mulv128_decl, 2,\n \t\t\t\t\t\t       convert (int128, lhs),\n \t\t\t\t\t\t       convert (int128, rhs)));"}, {"sha": "4c66a930d1d79002997e76d2e513f19b4ff4d48c", "filename": "gcc/ada/gcc-interface/utils2.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3f64b9e777a706662554ef39a512544244ef0c/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3f64b9e777a706662554ef39a512544244ef0c/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.cc?ref=1f3f64b9e777a706662554ef39a512544244ef0c", "patch": "@@ -2259,6 +2259,8 @@ maybe_wrap_malloc (tree data_size, tree data_type, Node_Id gnat_node)\n \n   tree malloc_ptr = build_call_n_expr (malloc_decl, 1, size_to_malloc);\n \n+  Check_Restriction_No_Dependence_On_System (Name_Memory, gnat_node);\n+\n   if (aligning_type)\n     {\n       /* Latch malloc's return value and get a pointer to the aligning field\n@@ -2305,7 +2307,7 @@ maybe_wrap_malloc (tree data_size, tree data_type, Node_Id gnat_node)\n    designated by DATA_PTR using the __gnat_free entry point.  */\n \n static inline tree\n-maybe_wrap_free (tree data_ptr, tree data_type)\n+maybe_wrap_free (tree data_ptr, tree data_type, Node_Id gnat_node)\n {\n   /* In the regular alignment case, we pass the data pointer straight to free.\n      In the superaligned case, we need to retrieve the initial allocator\n@@ -2317,6 +2319,8 @@ maybe_wrap_free (tree data_ptr, tree data_type)\n \n   tree free_ptr;\n \n+  Check_Restriction_No_Dependence_On_System (Name_Memory, gnat_node);\n+\n   if (data_align > system_allocator_alignment)\n     {\n       /* DATA_FRONT_PTR (void *)\n@@ -2363,7 +2367,7 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, tree gnu_type,\n   /* Otherwise, object to \"free\" or \"malloc\" with possible special processing\n      for alignments stricter than what the default allocator honors.  */\n   else if (gnu_obj)\n-    return maybe_wrap_free (gnu_obj, gnu_type);\n+    return maybe_wrap_free (gnu_obj, gnu_type, gnat_node);\n   else\n     {\n       /* Assert that we no longer can be called with this special pool.  */"}]}