{"sha": "aa576f2a860c8287cac6bbe6d37f5f37448bf06a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1NzZmMmE4NjBjODI4N2NhYzZiYmU2ZDM3ZjVmMzc0NDhiZjA2YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-04-20T13:44:08Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-04-20T13:44:08Z"}, "message": "c++: Template argument hashing [pr94454]\n\nOne of the problems hit by pr94454 was that the argument hasher was\nnot skipping nodes that template_args_equal would.  Fixed by replacing\nthe STRIP_NOPS invocation by a bespoke loop.  We also confuse the\ncanonical type machinery by treating tpl-tpl-parms as types.  They're\nnot; bound-tpl-tpl-parms are.  We can get away with them being\ntype-like.  Unfortunately we give the original level==orig_level case\na canonical type, but the reduced cases of level<orig_level get\nstructural equality.  That breaks the hasher because we'll use\nTYPE_HASH (CANONICAL_TYPE ()) when we can. There's a note in\ntsubst[TEMPLATE_TEMPLATE_PARM] about why the reduced ones cannot have\na canonical type. (I didn't feel like questioning that assertion at\nthis point.)\n\n\t* pt.c (iterative_hash_template_arg): Strip nodes as\n\ttemplate_args_equal does.\n\t[ARGUMENT_PACK_SELECT, TREE_VEC, CONSTRUCTOR]: Refactor.\n\t[node_class:TEMPLATE_TEMPLATE_PARM]: Hash by level & index.\n\t[node_class:default]: Refactor.", "tree": {"sha": "ce77b77ef21f537759c4abbb0c9461a4ee45b726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce77b77ef21f537759c4abbb0c9461a4ee45b726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa576f2a860c8287cac6bbe6d37f5f37448bf06a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa576f2a860c8287cac6bbe6d37f5f37448bf06a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa576f2a860c8287cac6bbe6d37f5f37448bf06a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa576f2a860c8287cac6bbe6d37f5f37448bf06a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48c82310947355665d628d4d1c8e736df9987574", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c82310947355665d628d4d1c8e736df9987574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c82310947355665d628d4d1c8e736df9987574"}], "stats": {"total": 84, "additions": 55, "deletions": 29}, "files": [{"sha": "5191db9580ed18d2a63202903472c08727553429", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa576f2a860c8287cac6bbe6d37f5f37448bf06a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa576f2a860c8287cac6bbe6d37f5f37448bf06a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa576f2a860c8287cac6bbe6d37f5f37448bf06a", "patch": "@@ -1,3 +1,12 @@\n+2020-04-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/94454 Template Argument Hashing\n+\t* pt.c (iterative_hash_template_arg): Strip nodes as\n+\ttemplate_args_equal does.\n+\t[ARGUMENT_PACK_SELECT, TREE_VEC, CONSTRUCTOR]: Refactor.\n+\t[node_class:TEMPLATE_TEMPLATE_PARM]: Hash by level & index.\n+\t[node_class:default]: Refactor.\n+\n 2020-04-18  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/94632"}, {"sha": "4814b768c2caaaa81b3bf19fa884cc1d26e826e8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 46, "deletions": 29, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa576f2a860c8287cac6bbe6d37f5f37448bf06a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa576f2a860c8287cac6bbe6d37f5f37448bf06a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=aa576f2a860c8287cac6bbe6d37f5f37448bf06a", "patch": "@@ -195,6 +195,7 @@ static void set_current_access_from_decl (tree);\n static enum template_base_result get_template_base (tree, tree, tree, tree,\n \t\t\t\t\t\t    bool , tree *);\n static tree try_class_unification (tree, tree, tree, tree, bool);\n+static bool class_nttp_const_wrapper_p (tree t);\n static int coerce_template_template_parms (tree, tree, tsubst_flags_t,\n \t\t\t\t\t   tree, tree);\n static bool template_template_parm_bindings_ok_p (tree, tree);\n@@ -1737,44 +1738,42 @@ spec_hasher::hash (spec_entry *e)\n }\n \n /* Recursively calculate a hash value for a template argument ARG, for use\n-   in the hash tables of template specializations.  */\n+   in the hash tables of template specializations.   We must be\n+   careful to (at least) skip the same entities template_args_equal\n+   does.  */\n \n hashval_t\n iterative_hash_template_arg (tree arg, hashval_t val)\n {\n-  unsigned HOST_WIDE_INT i;\n-  enum tree_code code;\n-  char tclass;\n-\n   if (arg == NULL_TREE)\n     return iterative_hash_object (arg, val);\n \n   if (!TYPE_P (arg))\n-    STRIP_NOPS (arg);\n-\n-  if (TREE_CODE (arg) == ARGUMENT_PACK_SELECT)\n-    gcc_unreachable ();\n+    /* Strip nop-like things, but not the same as STRIP_NOPS.  */\n+    while (CONVERT_EXPR_P (arg)\n+\t   || TREE_CODE (arg) == NON_LVALUE_EXPR\n+\t   || class_nttp_const_wrapper_p (arg))\n+      arg = TREE_OPERAND (arg, 0);\n \n-  code = TREE_CODE (arg);\n-  tclass = TREE_CODE_CLASS (code);\n+  enum tree_code code = TREE_CODE (arg);\n \n   val = iterative_hash_object (code, val);\n \n   switch (code)\n     {\n+    case ARGUMENT_PACK_SELECT:\n+      gcc_unreachable ();\n+\n     case ERROR_MARK:\n       return val;\n \n     case IDENTIFIER_NODE:\n       return iterative_hash_object (IDENTIFIER_HASH_VALUE (arg), val);\n \n     case TREE_VEC:\n-      {\n-\tint i, len = TREE_VEC_LENGTH (arg);\n-\tfor (i = 0; i < len; ++i)\n-\t  val = iterative_hash_template_arg (TREE_VEC_ELT (arg, i), val);\n-\treturn val;\n-      }\n+      for (int i = 0, len = TREE_VEC_LENGTH (arg); i < len; ++i)\n+\tval = iterative_hash_template_arg (TREE_VEC_ELT (arg, i), val);\n+      return val;\n \n     case TYPE_PACK_EXPANSION:\n     case EXPR_PACK_EXPANSION:\n@@ -1798,6 +1797,7 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n     case CONSTRUCTOR:\n       {\n \ttree field, value;\n+\tunsigned i;\n \titerative_hash_template_arg (TREE_TYPE (arg), val);\n \tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (arg), i, field, value)\n \t  {\n@@ -1884,6 +1884,7 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n       break;\n     }\n \n+  char tclass = TREE_CODE_CLASS (code);\n   switch (tclass)\n     {\n     case tcc_type:\n@@ -1899,12 +1900,30 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n \t  tree ti = TYPE_ALIAS_TEMPLATE_INFO (ats);\n \t  return hash_tmpl_and_args (TI_TEMPLATE (ti), TI_ARGS (ti));\n \t}\n-      if (TYPE_CANONICAL (arg))\n-\treturn iterative_hash_object (TYPE_HASH (TYPE_CANONICAL (arg)),\n-\t\t\t\t      val);\n-      else if (TREE_CODE (arg) == DECLTYPE_TYPE)\n-\treturn iterative_hash_template_arg (DECLTYPE_TYPE_EXPR (arg), val);\n-      /* Otherwise just compare the types during lookup.  */\n+\n+      switch (TREE_CODE (arg))\n+\t{\n+\tcase TEMPLATE_TEMPLATE_PARM:\n+\t  {\n+\t    tree tpi = TEMPLATE_TYPE_PARM_INDEX (arg);\n+\n+\t    /* Do not recurse with TPI directly, as that is unbounded\n+\t       recursion.  */\n+\t    val = iterative_hash_object (TEMPLATE_PARM_LEVEL (tpi), val);\n+\t    val = iterative_hash_object (TEMPLATE_PARM_IDX (tpi), val);\n+\t  }\n+\t  break;\n+\n+\tcase  DECLTYPE_TYPE:\n+\t  val = iterative_hash_template_arg (DECLTYPE_TYPE_EXPR (arg), val);\n+\t  break;\n+\n+\tdefault:\n+\t  if (tree canonical = TYPE_CANONICAL (arg))\n+\t    val = iterative_hash_object (TYPE_HASH (canonical), val);\n+\t  break;\n+\t}\n+\n       return val;\n \n     case tcc_declaration:\n@@ -1913,13 +1932,11 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n \n     default:\n       gcc_assert (IS_EXPR_CODE_CLASS (tclass));\n-      {\n-\tunsigned n = cp_tree_operand_length (arg);\n-\tfor (i = 0; i < n; ++i)\n-\t  val = iterative_hash_template_arg (TREE_OPERAND (arg, i), val);\n-\treturn val;\n-      }\n+      for (int i = 0, n = cp_tree_operand_length (arg); i < n; ++i)\n+\tval = iterative_hash_template_arg (TREE_OPERAND (arg, i), val);\n+      return val;\n     }\n+\n   gcc_unreachable ();\n   return 0;\n }"}]}