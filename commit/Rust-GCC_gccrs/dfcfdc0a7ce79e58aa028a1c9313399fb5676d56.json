{"sha": "dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZjZmRjMGE3Y2U3OWU1OGFhMDI4YTFjOTMxMzM5OWZiNTY3NmQ1Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T09:56:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T09:56:17Z"}, "message": "[multiple changes]\n\n2009-07-23  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): For an initialized object\n\tof a class-wide interface type that is a return object of a\n\tbuild-in-place function, bypass the interface-related expansions into\n\trenamings with displacement conversions, etc.\n\t* exp_ch5.adb (Expand_N_Extended_Return_Statement): Add an assertion\n\tfor the case where a renaming occurs in a build-in-place context, to\n\tassert that the bypassing of the build-in-place treatment only occurs\n\tin the case of a renaming that is an expansion of a return expression\n\tthat is itself a build-in-place function call.\n\n2009-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Primitive_Operation): A primitive operation is a\n\tvalid candidate interpretation in a prefixed view if it is hidden, but\n\toverrides an inherited operation declared in the visible part.\n\n2009-07-23  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Don't promote integer\n\tdivision operands to 64-bit at all in any circumstances.\n\nFrom-SVN: r149990", "tree": {"sha": "735031bde32a343c5b6d452bf2bef5353bb7517e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/735031bde32a343c5b6d452bf2bef5353bb7517e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/comments", "author": null, "committer": null, "parents": [{"sha": "832338d8f52b3eb165e1527bdb6b0e014ef4c731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832338d8f52b3eb165e1527bdb6b0e014ef4c731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/832338d8f52b3eb165e1527bdb6b0e014ef4c731"}], "stats": {"total": 207, "additions": 144, "deletions": 63}, "files": [{"sha": "2e160cde5516413fe39f720a008eb99c3a778fe3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "patch": "@@ -1,3 +1,26 @@\n+2009-07-23  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): For an initialized object\n+\tof a class-wide interface type that is a return object of a\n+\tbuild-in-place function, bypass the interface-related expansions into\n+\trenamings with displacement conversions, etc.\n+\t* exp_ch5.adb (Expand_N_Extended_Return_Statement): Add an assertion\n+\tfor the case where a renaming occurs in a build-in-place context, to\n+\tassert that the bypassing of the build-in-place treatment only occurs\n+\tin the case of a renaming that is an expansion of a return expression\n+\tthat is itself a build-in-place function call.\n+\n+2009-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Primitive_Operation): A primitive operation is a\n+\tvalid candidate interpretation in a prefixed view if it is hidden, but\n+\toverrides an inherited operation declared in the visible part.\n+\n+2009-07-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Don't promote integer\n+\tdivision operands to 64-bit at all in any circumstances.\n+\n 2009-07-23  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch4.adb (Analyze_N_Op_Rem): Assume operands are valid when"}, {"sha": "e8b46e55e6095161046700f11da3cb8f564a21fa", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "patch": "@@ -4524,7 +4524,18 @@ package body Exp_Ch3 is\n          then\n             pragma Assert (Is_Class_Wide_Type (Typ));\n \n-            if Tagged_Type_Expansion then\n+            --  If the object is a return object of an inherently limited type,\n+            --  which implies build-in-place treatment, bypass the special\n+            --  treatment of class-wide interface initialization below. In this\n+            --  case, the expansion of the return statement will take care of\n+            --  creating the object (via allocator) and initializing it.\n+\n+            if Is_Return_Object (Def_Id)\n+              and then Is_Inherently_Limited_Type (Typ)\n+            then\n+               null;\n+\n+            elsif Tagged_Type_Expansion then\n                declare\n                   Iface    : constant Entity_Id := Root_Type (Typ);\n                   Expr_N   : Node_Id := Expr;"}, {"sha": "258ce3a82669faf6663e6a1dc634b7f090ee865e", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 76, "deletions": 55, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "patch": "@@ -7952,10 +7952,15 @@ package body Exp_Ch4 is\n       --  sure that things are in range of the target type in any case. This\n       --  avoids some unnecessary intermediate overflows.\n \n-      --  We also do a similar transformation in the case where the target\n-      --  type is a 64-bit signed integer, in this case we do the inner\n-      --  computation in Long_Long_Integer. We also use Long_Long_Integer\n-      --  as the inner type in the fixed-point or floating-point target case.\n+      --  We might consider a similar transformation in the case where the\n+      --  target is a real type or a 64-bit integer type, and the operand\n+      --  is an arithmetic operation using a 32-bit integer type. However,\n+      --  we do not bother with this case, because it could cause significant\n+      --  ineffiencies on 32-bit machines. On a 64-bit machine it would be\n+      --  much cheaper, but we don't want different behavior on 32-bit and\n+      --  64-bit machines. Note that the exclusion of the 64-bit case also\n+      --  handles the configurable run-time cases where 64-bit arithmetic\n+      --  may simply be unavailable.\n \n       --  Note: this circuit is partially redundant with respect to the circuit\n       --  in Checks.Apply_Arithmetic_Overflow_Check, but we catch more cases in\n@@ -7964,69 +7969,85 @@ package body Exp_Ch4 is\n       --  place, since it would be trick to remove them here!\n \n       declare\n-         Inner_Type        : Entity_Id          := Empty;\n-         Root_Target_Type  : constant Entity_Id := Root_Type (Target_Type);\n          Root_Operand_Type : constant Entity_Id := Root_Type (Operand_Type);\n \n       begin\n-         if (Root_Target_Type = Base_Type (Standard_Long_Long_Integer)\n-              or else Is_Real_Type (Root_Target_Type))\n-           and then Is_Signed_Integer_Type (Operand_Type)\n-         then\n-            Inner_Type := Standard_Long_Long_Integer;\n+         --  Enable transformation if all conditions are met\n \n-         elsif Root_Operand_Type = Base_Type (Standard_Short_Integer)\n-                 or else\n-               Root_Operand_Type = Base_Type (Standard_Short_Short_Integer)\n+         if\n+           --  We only do this transformation for source constructs. We assume\n+           --  that the expander knows what it is doing when it generates code.\n+\n+           Comes_From_Source (N)\n+\n+           --  If the operand type is Short_Integer or Short_Short_Integer,\n+           --  then we will promote to Integer, which is available on all\n+           --  targets, and is sufficient to ensure no intermediate overflow.\n+           --  Furthermore it is likely to be as efficient or more efficient\n+           --  than using the smaller type for the computation so we do this\n+           --  unconditionally.\n+\n+           and then\n+             (Root_Operand_Type = Base_Type (Standard_Short_Integer)\n+               or else\n+              Root_Operand_Type = Base_Type (Standard_Short_Short_Integer))\n+\n+           --  Test for interesting operation, which includes addition,\n+           --  division, exponentiation, multiplication, subtraction, and\n+           --  unary negation.\n+\n+           and then Nkind_In (Operand, N_Op_Add,\n+                                       N_Op_Divide,\n+                                       N_Op_Expon,\n+                                       N_Op_Minus,\n+                                       N_Op_Multiply,\n+                                       N_Op_Subtract)\n          then\n-            Inner_Type := Standard_Integer;\n-         end if;\n+            --  All conditions met, go ahead with transformation\n \n-         --  Do rewrite if enabled\n-\n-         if Present (Inner_Type) then\n-\n-            --  Test for interesting binary operation, which includes addition,\n-            --  exponentiation, multiplication, and subtraction. We do not\n-            --  include division in the 64-bit case. It is a very marginal\n-            --  situation to get overflow from division in any case (largest\n-            --  negative number divided by minus one), and doing the promotion\n-            --  may result in less efficient code. Worse still we may end up\n-            --  promoting to 64-bit divide on a target that does not support\n-            --  this operation, causing a fatal error.\n-\n-            if Nkind_In (Operand, N_Op_Add,\n-                                  N_Op_Expon,\n-                                  N_Op_Multiply,\n-                                  N_Op_Subtract)\n-              or else (Nkind (Operand) = N_Op_Divide\n-                        and then Inner_Type /= Standard_Long_Long_Integer)\n-            then\n-               Rewrite (Left_Opnd (Operand),\n-                 Make_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Reference_To (Inner_Type, Loc),\n-                   Expression   => Relocate_Node (Left_Opnd (Operand))));\n+            declare\n+               Opnd : Node_Id;\n+               L, R : Node_Id;\n \n-               Rewrite (Right_Opnd (Operand),\n+            begin\n+               R :=\n                  Make_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Reference_To (Inner_Type, Loc),\n-                   Expression   => Relocate_Node (Right_Opnd (Operand))));\n+                   Subtype_Mark => New_Reference_To (Standard_Integer, Loc),\n+                   Expression   => Relocate_Node (Right_Opnd (Operand)));\n \n-               Set_Analyzed (Operand, False);\n-               Analyze_And_Resolve (Operand, Inner_Type);\n+               if Nkind (Operand) = N_Op_Minus then\n+                  Opnd := Make_Op_Minus (Loc, Right_Opnd => R);\n \n-               --  Similar processing for unary operation. The only interesting\n-               --  case is negation, nothing else can produce an overflow.\n+               else\n+                  L :=\n+                    Make_Type_Conversion (Loc,\n+                      Subtype_Mark => New_Reference_To (Standard_Integer, Loc),\n+                      Expression   => Relocate_Node (Left_Opnd (Operand)));\n+\n+                  case Nkind (Operand) is\n+                     when N_Op_Add =>\n+                        Opnd := Make_Op_Add (Loc, L, R);\n+                     when N_Op_Divide =>\n+                        Opnd := Make_Op_Divide (Loc, L, R);\n+                     when N_Op_Expon =>\n+                        Opnd := Make_Op_Expon (Loc, L, R);\n+                     when N_Op_Multiply =>\n+                        Opnd := Make_Op_Multiply (Loc, L, R);\n+                     when N_Op_Subtract =>\n+                        Opnd := Make_Op_Subtract (Loc, L, R);\n+                     when others =>\n+                        raise Program_Error;\n+                  end case;\n \n-            elsif Nkind (Operand) = N_Op_Minus then\n-               Rewrite (Right_Opnd (Operand),\n-                 Make_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Reference_To (Inner_Type, Loc),\n-                   Expression   => Relocate_Node (Right_Opnd (Operand))));\n+                  Rewrite (N,\n+                    Make_Type_Conversion (Loc,\n+                      Subtype_Mark => Relocate_Node (Subtype_Mark (N)),\n+                      Expression   => Opnd));\n \n-               Set_Analyzed (Operand, False);\n-               Analyze_And_Resolve (Operand, Inner_Type);\n-            end if;\n+                     Analyze_And_Resolve (N, Target_Type);\n+                     return;\n+               end if;\n+            end;\n          end if;\n       end;\n "}, {"sha": "39700bda9e0ff61be9650f2f696df9d138a8a17d", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "patch": "@@ -2689,6 +2689,11 @@ package body Exp_Ch5 is\n            and then\n              Nkind (Return_Object_Decl) = N_Object_Renaming_Declaration\n          then\n+            pragma Assert (Nkind (Original_Node (Return_Object_Decl)) =\n+                            N_Object_Declaration\n+              and then Is_Build_In_Place_Function_Call\n+                         (Expression (Original_Node (Return_Object_Decl))));\n+\n             Set_By_Ref (Return_Stm);  -- Return build-in-place results by ref\n \n          elsif Is_Build_In_Place then"}, {"sha": "826380e4c279b42e270d59a8d6a0796d92b173a8", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfcfdc0a7ce79e58aa028a1c9313399fb5676d56/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=dfcfdc0a7ce79e58aa028a1c9313399fb5676d56", "patch": "@@ -6574,6 +6574,12 @@ package body Sem_Ch4 is\n          --  subprogram because that list starts with the subprogram formals.\n          --  We retrieve the candidate operations from the generic declaration.\n \n+         function Is_Private_Overriding (Op : Entity_Id) return Boolean;\n+         --  An operation that overrides an inherited operation in the private\n+         --  part of its package may be hidden, but if the inherited operation\n+         --  is visible a direct call to it will dispatch to the private one,\n+         --  which is therefore a valid candidate.\n+\n          function Valid_First_Argument_Of (Op : Entity_Id) return Boolean;\n          --  Verify that the prefix, dereferenced if need be, is a valid\n          --  controlling argument in a call to Op. The remaining actuals\n@@ -6664,6 +6670,20 @@ package body Sem_Ch4 is\n             end if;\n          end Collect_Generic_Type_Ops;\n \n+         ---------------------------\n+         -- Is_Private_Overriding --\n+         ---------------------------\n+\n+         function Is_Private_Overriding (Op : Entity_Id) return Boolean is\n+            Visible_Op : constant Entity_Id := Homonym (Op);\n+\n+         begin\n+            return Present (Visible_Op)\n+              and then not Comes_From_Source (Visible_Op)\n+              and then Alias (Visible_Op) = Op\n+              and then not Is_Hidden (Visible_Op);\n+         end Is_Private_Overriding;\n+\n          -----------------------------\n          -- Valid_First_Argument_Of --\n          -----------------------------\n@@ -6744,15 +6764,16 @@ package body Sem_Ch4 is\n                if (Present (Interface_Alias (Prim_Op))\n                     and then Is_Ancestor (Find_Dispatching_Type\n                                             (Alias (Prim_Op)), Corr_Type))\n-                 or else\n \n-                  --  Do not consider hidden primitives unless the type is\n-                  --  in an open scope or we are within an instance, where\n-                  --  visibility is known to be correct.\n+                 --  Do not consider hidden primitives unless the type is in an\n+                 --  open scope or we are within an instance, where visibility\n+                 --  is known to be correct, or else if this is an overriding\n+                 --  operation in the private part for an inherited operation.\n \n-                  (Is_Hidden (Prim_Op)\n-                     and then not Is_Immediately_Visible (Obj_Type)\n-                     and then not In_Instance)\n+                 or else (Is_Hidden (Prim_Op)\n+                           and then not Is_Immediately_Visible (Obj_Type)\n+                           and then not In_Instance\n+                           and then not Is_Private_Overriding (Prim_Op))\n                then\n                   goto Continue;\n                end if;"}]}