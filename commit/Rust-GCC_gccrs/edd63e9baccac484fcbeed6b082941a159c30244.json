{"sha": "edd63e9baccac484fcbeed6b082941a159c30244", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRkNjNlOWJhY2NhYzQ4NGZjYmVlZDZiMDgyOTQxYTE1OWMzMDI0NA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-06-16T08:35:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:35:26Z"}, "message": "einfo.ads, einfo.adb (Is_Local_Anonymous_Access): New flag on anonymous access types...\n\n2005-06-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* einfo.ads, einfo.adb (Is_Local_Anonymous_Access): New flag on\n\tanonymous access types, to indicate that the accessibility level of\n\tthe type is determined by that of the enclosing declaration.\n\t(Has_Persistent_BSS): New flag\n\t(Set_Is_Primitive_Wrapper): Upgrade the barrier to allow the usage\n\tof this attribute with functions.\n\t(Is_Primitive_Wrapper): Remove the barrier.\n\t(Has_Specified_Stream_Input, Has_Specified_Stream_Output,\n\tHas_Specified_Stream_Read, Has_Specified_Stream_Write):\n\tNew subprograms.\n\t(Set_Has_Specified_Stream_Input, Set_Has_Specified_Stream_Output,\n\tSet_Has_Specified_Stream_Read, Set_Has_Specified_Stream_Write):\n\tNew subprograms.\n\t(Is_Pure_Unit_Access_Type): New flag\n\t(Abstract_Interfaces): Complete the assertion to cover all usages.\n\t(Set_Is_Interface): Complete the assertion to cover all usages.\n\t(Is_Primitive_Wrapper): New attribute.\n\t(Is_Obsolescent): Now applies to all entities (though it is only set\n\tfor subprograms currently)\n\tNew flag:  Has_Constrained_Partial_View, to implemente Ada 2005 AI-363,\n\twhich solves various problems concerning access subtypes.\n\t(Has_Persistent_BSS): New flag\n\t(Is_Primitive_Wrapper, Set_Primitive_Wrapper): Code cleanup.\n\tRemove these subprograms because this attribute is currently\n\tnot used.\n\tNew entity flags:\n\tHas_Specified_Stream_Input (Flag190)\n\tHas_Specified_Stream_Output (Flag191)\n\tHas_Specified_Stream_Read (Flag192)\n\tHas_Specified_Stream_Write (Flag193)\n\tPresent in all type and subtype entities. Set for a given view if the\n\tcorresponding stream-oriented attribute has been defined by an\n\tattribute definition clause. When such a clause occurs, a TSS is set\n\ton the underlying full view; the flags are used to track visibility of\n\tthe attribute definition clause for partial or incomplete views.\n\t(Is_Pure_Unit_Access_Type): New flag\n\tClarify use of Is_Internal.\n\t(Is_Primitive_Wrapper): New attribute present in primitive subprograms\n\tinternally generated to wrap the invocation of tasks and protected\n\ttypes that implement interfaces.\n\t(Implementation_Base_Type): Documentation correction\n\t(Is_Obsolescent): Now applies to all entities (though it is only set\n\tfor subprograms currently)\n\tNew flag:  Has_Constrained_Partial_View, to implement Ada 2005 AI-363,\n\twhich solves various problems concerning access subtypes.\n\n\t* exp_ch9.adb (Type_Conformant_Parameters): Introduce mode conformance\n\tfor examined parameters. Identify unequal parameter list lengths as\n\tnon-conformant parameters.\n\t(Overriding_Possible): Do not check for \"All\" qualifier in declaration\n\tof controlling access parameter, following prescription of AI-404.\n\t(Build_Entry_Wrapper_Spec, Build_Entry_Wrapper_Body): New subprograms\n\tthat build the procedure body that wraps an entry invocation\n\t(Build_Corresponding_Record, Build_Protected_Sub_Specification,\n\tExpand_N_Protected_Body, Expand_N_Protected_Type_Declaration,\n\tExpand_N_Task_Body, Expand_N_Task_Type_Declaration): Modified to\n\tgive support to abstract interface types\n\n\t* freeze.adb (Freeze_Entity): Issue error message if\n\tIs_Pure_Unit_Access_Type set, unless we are in Ada 2005 mode and the\n\ttype has no storage pool (Ada 2005) AI-366.\n\tAlso modified to give support to abstract interface types\n\t(Freeze_Subprogram): Issue an error for a dispatching subprogram with an\n\tInline_Always pragma.\n\n\t* par-ch9.adb (P_Task_Items): Reserved words \"not\" or \"overriding\" may\n\tnow begin an entry declaration.\n\t(P_Entry_Or_Subprogram_With_Indicator): New procedure in\n\tP_Protected_Operation_Declaration_Opt. Parse an entry declaration or\n\ta subprogram declaration preceded by an overriding indicator.\n\t(P_Protected_Operation_Declaration_Opt): Add case for parsing entry\n\tdeclarations or subprogram declarations preceded by reserved words\n\t\"not\" or \"overriding\".\n\t(P_Entry_Declaration): Update comment. Parse and check overriding\n\tindicator, set semantic flags of entry declarations.\n\t(P_Task): New error message in case of private applied\n\tto a task type declaration.\n\t(P_Protected): New error message in case of private applied\n\tto a task type declaration.\n\n\t* sem_ch7.adb (Preserve_Full_Attributes): Modified to handle the case\n\tin which the full view of a type implementing an interface is a\n\tconcurrent type.\n\t(Has_Overriding_Pragma): Remove obsolete implementation of AI-218.\n\tDeclare_Inherited_Private_Subprograms): If an explicit operation\n\toverrides an operation that is inherited in the private part, mark the\n\texplicit one as overriding, to enable overriding indicator checks.\n\t(Preserve_Full_Attributes): Propagate Is_Unchecked_Union attribute from\n\tfull view to partial view, to simplify handling in back-end.\n\n\t* sprint.adb: Print interface lists where needed: derived types,\n\tprotected types, task types.\n\toutput \"is null\" for null procedures. Part of implementation of\n\n\t* sem_cat.adb (Validate_Access_Type_Declaration): Implement AI-366\n\trelaxation of rules for access types in pure, shared passive partitions.\n\n\t* exp_strm.adb (Build_Mutable_Record_Read_Procedure): Reorganize to\n\tfirst read discriminants into temporary objects, performing checks on\n\tthe read values, then possibly performing discriminant checks on the\n\tactual (if it is constrained), and only finally reading the components\n\tinto a constrained temporary object.\n\t(Build_Elementary_Input_Call): Adjust the specific circuitry for the\n\tcase of reading discriminants of a mutable record type to recognize\n\tthe new form of the code generated by\n\tBuild_Mutable_Record_Read_Procedure.\n\n\t* exp_tss.ads, exp_tss.adb (Make_Init_Proc_Name): Reimplement in terms\n\tof a simple call to Make_TSS_Name.\n\t(Make_TSS_Name_Local): Add the TSS name as the last thing in the name\n\tbuffer, in order for Is_TSS to work correctly on local TSS names.\n\n\t* sem_attr.ads, sem_attr.adb (Resolve_Attribute, case 'Access): Use flag\n\tIs_Local_Anonymous_Access to check legaliy of attributes in the\n\tcontext of  access components and stand-alone access objects.\n\t(Stream_Attribute_Available): In Ada 95 mode, a stream attribute is\n\ttreated as available for a limited private type if there is an\n\tattribute_definition_clause that applies to its full view, but not in\n\tother cases where the attribute is available for the full view\n\t(specifically, the sole fact that the full view is non-limited does not\n\tmake the attribute available for the partial view).\n\t(Build_Access_Subprogram_Type): Diagnose attempt to apply 'access to a\n\tnon-overloaded intrinsic subprogram.\n\t(Check_Stream_Attribute): Reject an attribute reference for an\n\tunavailable stream attribute even if the prefix is not a limited type\n\t(case of a 'Input attribute reference for an abstract, non-classwide\n\ttype)\n\t(Stream_Attribute_Available): New function to determine whether a stream\n\tattribute is available at a place.\n\t(Check_Attribute): Use Stream_Attribute_Available instead of just\n\ttesting for TSS presence on the implementation base type.\n\t(Analyze_Attribute): Modified to give support to task interfaces.\n\t(Analyze_Access_Attribute): Add error check for use of an Access (or\n\tUnrestricted_Access) attribute with a subprogram marked as\n\tInline_Always.\n\t(Analyze_Attribute, case Attribute_Address): Add error check for use of\n\tan Address attribute with a subprogram marked as Inline_Always.\n\tUpdate Eval_Attribute to handle new value of Width from AI-395\n\n\t* sem_ch13.adb (Analyze_Stream_TSS_Definition): New subprogram.\n\t(Analyze_Attribute_Definition_Clause, cases Input, Output, Read, Write):\n\tFactor common code across the stream-oriented attribute circcuits into\n\ta new subprogram, Analyze_Stream_TSS_Definition. The new uniform\n\tprocessing is functionally identical to the previous duplicated one,\n\texcept that an expression that denotes an abstract subprogram will now\n\tbe rejected, as mandated by AI-195 item 5.\n\n\t* sem_util.ads, sem_util.adb (Type_Access_Level): Use flag\n\tIs_Local_Anonymous_Access to apply accessibility checks to access\n\tcomponents and stand-alone access objects.\n\t(Has_Discriminant_Dependent_Constraint): Moved to spec for use\n\telsewhere.\n\t(Is_Potentially_Persistent_Type): New function\n\t(Is_Dependent_Component_Of_Mutable_Object): If the enclosing object is\n\ta heap-object whose type has a constrained partial view, the object is\n\tunconstrained and the component may depend on a discriminant, making its\n\trenaming illegal.\n\n\t* sinfo.ads, sinfo.adb\n\t(Must_Not_Override): Flag applicable to N_Entry_Declaration.\n\t(Must_Override): Flag applicable to N_Entry_Declaration.\n\tIndicate that interface_list can appear in single task and single\n\tprotected declarations.\n\tReplace Is_Overriding and Not_Overriding with Must_Override and\n\tMust_Not_Override, to better express intent of AI.\n\tIs_Overriding, Not_Overriding: Ada2005 flags that indicate the presence\n\tof an overriding indicator in a subprogram or instance.\n\tAda 2005 (AI-248) Null_Present can appear in a procedure specification.\n\tAdd the overriding indicator [[not] overriding] construct to the\n\tfollowing grammar productions:\n\t ENTRY_DECLARATION\n\t GENERIC_INSTANTIATION\n\t SUBPROGRAM_SPECIFICATION\n\n\t* par-ch10.adb (P_Compilation_Unit): Subprogram declaration or body\n\tcan start with an overriding indicator.\n\n\t* par-ch6.adb (P_Subprogram): Recognize overriding indicator, and set\n\tflags accordingly on subrogram specifications or instances.\n\n\t* sem_ch8.adb:\n\t(Analyze_Subprogram_Renaming): For a renaming_as_body, verify that the\n\toverriding_indicator, if present, is consistent with status of spec.\n\tImprove error message for null-excluding checks on controlling access\n\tparameters.\n\t(Check_In_Previous_With_Clause): Protect the frontend against\n\tpreviously reported critical errors in the context clauses.\n\tSave and restore Ada_Version_Explicit, for implementation of AI-362\n\t(Analyze_Subprogram_Renaming): If the new entity is a dispatching\n\toperation verify that controlling formals of the renamed entity that\n\tare access parameters are explicitly non-null.\n\t(Find_Expanded_Name): Improve error message when prefix is an illegal\n\treference to a private child unit.\n\n\t* exp_imgv.adb, s-imgwch.ads, s-imgwch.adb, s-valwch.adb,\n\ts-valwch.ads, s-widwch.adb, s-widwch.ads, s-wwdcha.adb, s-wwdwch.adb:\n\tRewrite to correspond to new wide character names in AI-395\n\n        * par-ch12.adb (P_Formal_Subprogram_Declaration): Recognize null\n        default procedures.\n\nFrom-SVN: r101029", "tree": {"sha": "91e1755b20c022b6125eab58f540040f0dac13ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91e1755b20c022b6125eab58f540040f0dac13ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edd63e9baccac484fcbeed6b082941a159c30244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd63e9baccac484fcbeed6b082941a159c30244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edd63e9baccac484fcbeed6b082941a159c30244", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edd63e9baccac484fcbeed6b082941a159c30244/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4881d364f4a56a41ec47624f6c1076424c00179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4881d364f4a56a41ec47624f6c1076424c00179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4881d364f4a56a41ec47624f6c1076424c00179"}], "stats": {"total": 3739, "additions": 2469, "deletions": 1270}, "files": [{"sha": "4bd76bf29a002b8a2a82a39285ebc2e45377b51f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 130, "deletions": 29, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -211,7 +211,7 @@ package body Einfo is\n \n    --    Obsolescent_Warning             Node24\n    --    Task_Body_Procedure             Node24\n-   --    Abstract_Interfaces             Node24\n+   --    Abstract_Interfaces             Elist24\n \n    --    Abstract_Interface_Alias        Node25\n \n@@ -433,15 +433,16 @@ package body Einfo is\n    --    Has_Stream_Size_Clause         Flag184\n    --    Is_Ada_2005                    Flag185\n    --    Is_Interface                   Flag186\n+   --    Has_Constrained_Partial_View   Flag187\n+   --    Has_Persistent_BSS             Flag188\n+   --    Is_Pure_Unit_Access_Type       Flag189\n+   --    Has_Specified_Stream_Input     Flag190\n+\n+   --    Has_Specified_Stream_Output    Flag191\n+   --    Has_Specified_Stream_Read      Flag192\n+   --    Has_Specified_Stream_Write     Flag193\n+   --    Is_Local_Anonymous_Access      Flag194\n \n-   --    (unused)                       Flag187\n-   --    (unused)                       Flag188\n-   --    (unused)                       Flag189\n-   --    (unused)                       Flag190\n-   --    (unused)                       Flag191\n-   --    (unused)                       Flag192\n-   --    (unused)                       Flag193\n-   --    (unused)                       Flag194\n    --    (unused)                       Flag195\n    --    (unused)                       Flag196\n    --    (unused)                       Flag197\n@@ -500,10 +501,12 @@ package body Einfo is\n \n    function Abstract_Interfaces (Id : E) return L is\n    begin\n-      pragma Assert (Ekind (Id) = E_Record_Type\n-                       or else Ekind (Id) = E_Record_Subtype\n-                       or else Ekind (Id) = E_Record_Type_With_Private\n-                       or else Ekind (Id) = E_Record_Subtype_With_Private);\n+      pragma Assert\n+        (Ekind (Id) = E_Record_Type\n+          or else Ekind (Id) = E_Record_Subtype\n+          or else Ekind (Id) = E_Record_Type_With_Private\n+          or else Ekind (Id) = E_Record_Subtype_With_Private\n+          or else Ekind (Id) = E_Class_Wide_Type);\n       return Elist24 (Id);\n    end Abstract_Interfaces;\n \n@@ -817,7 +820,7 @@ package body Einfo is\n \n    function DT_Entry_Count (Id : E) return U is\n    begin\n-      pragma Assert (Ekind (Id) = E_Component  and then Is_Tag (Id));\n+      pragma Assert (Ekind (Id) = E_Component and then Is_Tag (Id));\n       return Uint15 (Id);\n    end DT_Entry_Count;\n \n@@ -1104,6 +1107,12 @@ package body Einfo is\n       return Flag68 (Implementation_Base_Type (Id));\n    end Has_Component_Size_Clause;\n \n+   function Has_Constrained_Partial_View (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag187 (Id);\n+   end Has_Constrained_Partial_View;\n+\n    function Has_Controlled_Component (Id : E) return B is\n    begin\n       return Flag43 (Base_Type (Id));\n@@ -1212,6 +1221,11 @@ package body Einfo is\n       return Flag154 (Id);\n    end Has_Per_Object_Constraint;\n \n+   function Has_Persistent_BSS (Id : E) return B is\n+   begin\n+      return Flag188 (Id);\n+   end Has_Persistent_BSS;\n+\n    function Has_Pragma_Controlled (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -1289,6 +1303,30 @@ package body Einfo is\n       return Flag100 (Implementation_Base_Type (Id));\n    end Has_Specified_Layout;\n \n+   function Has_Specified_Stream_Input (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag190 (Id);\n+   end Has_Specified_Stream_Input;\n+\n+   function Has_Specified_Stream_Output (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag191 (Id);\n+   end Has_Specified_Stream_Output;\n+\n+   function Has_Specified_Stream_Read (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag192 (Id);\n+   end Has_Specified_Stream_Read;\n+\n+   function Has_Specified_Stream_Write (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag193 (Id);\n+   end Has_Specified_Stream_Write;\n+\n    function Has_Storage_Size_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n@@ -1374,6 +1412,12 @@ package body Einfo is\n       return Flag19 (Id);\n    end Is_Abstract;\n \n+   function Is_Local_Anonymous_Access (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Access_Type (Id));\n+      return Flag194 (Id);\n+   end Is_Local_Anonymous_Access;\n+\n    function Is_Access_Constant (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -1579,11 +1623,6 @@ package body Einfo is\n \n    function Is_Interface (Id : E) return B is\n    begin\n-      pragma Assert (Ekind (Id) = E_Record_Type\n-                       or else Ekind (Id) = E_Record_Subtype\n-                       or else Ekind (Id) = E_Record_Type_With_Private\n-                       or else Ekind (Id) = E_Record_Subtype_With_Private\n-                       or else Ekind (Id) = E_Class_Wide_Type);\n       return Flag186 (Id);\n    end Is_Interface;\n \n@@ -1654,7 +1693,6 @@ package body Einfo is\n \n    function Is_Obsolescent (Id : E) return B is\n    begin\n-      pragma Assert (Is_Subprogram (Id));\n       return Flag153 (Id);\n    end Is_Obsolescent;\n \n@@ -1718,6 +1756,12 @@ package body Einfo is\n       return Flag44 (Id);\n    end Is_Pure;\n \n+   function Is_Pure_Unit_Access_Type (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Access_Type (Id));\n+      return Flag189 (Id);\n+   end Is_Pure_Unit_Access_Type;\n+\n    function Is_Remote_Call_Interface (Id : E) return B is\n    begin\n       return Flag62 (Id);\n@@ -2479,10 +2523,12 @@ package body Einfo is\n \n    procedure Set_Abstract_Interfaces (Id : E; V : L) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Record_Type\n-                       or else Ekind (Id) = E_Record_Subtype\n-                       or else Ekind (Id) = E_Record_Type_With_Private\n-                       or else Ekind (Id) = E_Record_Subtype_With_Private);\n+      pragma Assert\n+        (Ekind (Id) = E_Record_Type\n+          or else Ekind (Id) = E_Record_Subtype\n+          or else Ekind (Id) = E_Record_Type_With_Private\n+          or else Ekind (Id) = E_Record_Subtype_With_Private\n+          or else Ekind (Id) = E_Class_Wide_Type);\n       Set_Elist24 (Id, V);\n    end Set_Abstract_Interfaces;\n \n@@ -3094,6 +3140,12 @@ package body Einfo is\n       Set_Flag68 (Id, V);\n    end Set_Has_Component_Size_Clause;\n \n+   procedure Set_Has_Constrained_Partial_View (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag187 (Id, V);\n+   end Set_Has_Constrained_Partial_View;\n+\n    procedure Set_Has_Contiguous_Rep (Id : E; V : B := True) is\n    begin\n       Set_Flag181 (Id, V);\n@@ -3204,6 +3256,11 @@ package body Einfo is\n       Set_Flag154 (Id, V);\n    end Set_Has_Per_Object_Constraint;\n \n+   procedure Set_Has_Persistent_BSS (Id : E; V : B := True) is\n+   begin\n+      Set_Flag188 (Id, V);\n+   end Set_Has_Persistent_BSS;\n+\n    procedure Set_Has_Pragma_Controlled (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -3282,6 +3339,30 @@ package body Einfo is\n       Set_Flag100 (Id, V);\n    end Set_Has_Specified_Layout;\n \n+   procedure Set_Has_Specified_Stream_Input (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag190 (Id, V);\n+   end Set_Has_Specified_Stream_Input;\n+\n+   procedure Set_Has_Specified_Stream_Output (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag191 (Id, V);\n+   end Set_Has_Specified_Stream_Output;\n+\n+   procedure Set_Has_Specified_Stream_Read (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag192 (Id, V);\n+   end Set_Has_Specified_Stream_Read;\n+\n+   procedure Set_Has_Specified_Stream_Write (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag193 (Id, V);\n+   end Set_Has_Specified_Stream_Write;\n+\n    procedure Set_Has_Storage_Size_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n@@ -3372,6 +3453,12 @@ package body Einfo is\n       Set_Flag19 (Id, V);\n    end Set_Is_Abstract;\n \n+   procedure Set_Is_Local_Anonymous_Access (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Access_Type (Id));\n+      Set_Flag194 (Id, V);\n+   end Set_Is_Local_Anonymous_Access;\n+\n    procedure Set_Is_Access_Constant (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -3593,10 +3680,12 @@ package body Einfo is\n \n    procedure Set_Is_Interface (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Record_Type\n-                       or else Ekind (Id) = E_Record_Subtype\n-                       or else Ekind (Id) = E_Record_Type_With_Private\n-                       or else Ekind (Id) = E_Record_Subtype_With_Private);\n+      pragma Assert\n+        (Ekind (Id) = E_Record_Type\n+          or else Ekind (Id) = E_Record_Subtype\n+          or else Ekind (Id) = E_Record_Type_With_Private\n+          or else Ekind (Id) = E_Record_Subtype_With_Private\n+          or else Ekind (Id) = E_Class_Wide_Type);\n       Set_Flag186 (Id, V);\n    end Set_Is_Interface;\n \n@@ -3668,7 +3757,6 @@ package body Einfo is\n \n    procedure Set_Is_Obsolescent (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Subprogram (Id));\n       Set_Flag153 (Id, V);\n    end Set_Is_Obsolescent;\n \n@@ -3733,6 +3821,12 @@ package body Einfo is\n       Set_Flag44 (Id, V);\n    end Set_Is_Pure;\n \n+   procedure Set_Is_Pure_Unit_Access_Type (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Access_Type (Id));\n+      Set_Flag189 (Id, V);\n+   end Set_Is_Pure_Unit_Access_Type;\n+\n    procedure Set_Is_Remote_Call_Interface (Id : E; V : B := True) is\n    begin\n       Set_Flag62 (Id, V);\n@@ -6353,6 +6447,7 @@ package body Einfo is\n       W (\"Has_Non_Standard_Rep\",          Flag75  (Id));\n       W (\"Has_Object_Size_Clause\",        Flag172 (Id));\n       W (\"Has_Per_Object_Constraint\",     Flag154 (Id));\n+      W (\"Has_Persistent_BSS\",            Flag188 (Id));\n       W (\"Has_Pragma_Controlled\",         Flag27  (Id));\n       W (\"Has_Pragma_Elaborate_Body\",     Flag150 (Id));\n       W (\"Has_Pragma_Inline\",             Flag157 (Id));\n@@ -6367,6 +6462,10 @@ package body Einfo is\n       W (\"Has_Size_Clause\",               Flag29  (Id));\n       W (\"Has_Small_Clause\",              Flag67  (Id));\n       W (\"Has_Specified_Layout\",          Flag100 (Id));\n+      W (\"Has_Specified_Stream_Input\",    Flag190 (Id));\n+      W (\"Has_Specified_Stream_Output\",   Flag191 (Id));\n+      W (\"Has_Specified_Stream_Read\",     Flag192 (Id));\n+      W (\"Has_Specified_Stream_Write\",    Flag193 (Id));\n       W (\"Has_Storage_Size_Clause\",       Flag23  (Id));\n       W (\"Has_Stream_Size_Clause\",        Flag184 (Id));\n       W (\"Has_Subprogram_Descriptor\",     Flag93  (Id));\n@@ -6380,6 +6479,7 @@ package body Einfo is\n       W (\"In_Use\",                        Flag8   (Id));\n       W (\"Is_AST_Entry\",                  Flag132 (Id));\n       W (\"Is_Abstract\",                   Flag19  (Id));\n+      W (\"Is_Local_Anonymous_Access\",     Flag194 (Id));\n       W (\"Is_Access_Constant\",            Flag69  (Id));\n       W (\"Is_Ada_2005\",                   Flag185 (Id));\n       W (\"Is_Aliased\",                    Flag15  (Id));\n@@ -6442,6 +6542,7 @@ package body Einfo is\n       W (\"Is_Private_Descendant\",         Flag53  (Id));\n       W (\"Is_Public\",                     Flag10  (Id));\n       W (\"Is_Pure\",                       Flag44  (Id));\n+      W (\"Is_Pure_Unit_Access_Type\",      Flag189 (Id));\n       W (\"Is_Remote_Call_Interface\",      Flag62  (Id));\n       W (\"Is_Remote_Types\",               Flag61  (Id));\n       W (\"Is_Renaming_Of_Object\",         Flag112 (Id));"}, {"sha": "f6f87b4fdfc99b9a99a3e16bd6cd635e07f247cf", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 89, "deletions": 12, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -115,7 +115,7 @@ package Einfo is\n --     There can only be a single statement, contained on a single line,\n --     not counting any pragma Assert statements.\n \n---     This single statement must either by a function call with simple,\n+--     This single statement must either be a function call with simple,\n --     single token arguments, or it must be a membership test of the form\n --     a in b, where a and b are single tokens.\n \n@@ -1281,6 +1281,12 @@ package Einfo is\n --       present for the given type. Note that this flag can be False even\n --       if Component_Size is non-zero (happens in the case of derived types).\n \n+--    Has_Constrained_Partial_View (Flag187)\n+--       Present in private type and their completions, when the private\n+--       type has no discriminants and the full view has discriminants with\n+--       defaults. In Ada 2005 heap-allocated objects of such types are not\n+--       constrained, and can change their discriminants with full assignment.\n+\n --    Has_Contiguous_Rep (Flag181)\n --       Present in enumeration types. True if the type as a representation\n --       clause whose entries are successive integers.\n@@ -1428,6 +1434,13 @@ package Einfo is\n --       5. N_Range_Constraint - when the range expression uses the\n --          discriminant of the enclosing type.\n \n+--    Has_Persistent_BSS (Flag188)\n+--       Present in all entities. Set True for entities to which a valid\n+--       pragma Persistent_BSS applies. Note that although the pragma is\n+--       only meaningful for objects, we set it for all entities in a unit\n+--       to which the pragma applies, as well as the unit entity itself, for\n+--       convenience in propagating the flag to contained entities.\n+\n --    Has_Pragma_Controlled (Flag27) [implementation base type only]\n --       Present in access type entities. It is set if a pragma Controlled\n --       applies to the access type.\n@@ -1523,6 +1536,16 @@ package Einfo is\n --       representation clause, and thus is not inherited by a derived type.\n --       This flag is always False for non-record types.\n \n+--    Has_Specified_Stream_Input (Flag190)\n+--    Has_Specified_Stream_Output (Flag191)\n+--    Has_Specified_Stream_Read (Flag192)\n+--    Has_Specified_Stream_Write (Flag193)\n+--       Present in all type and subtype entities. Set for a given view if the\n+--       corresponding stream-oriented attribute has been defined by an\n+--       attribute definition clause. When such a clause occurs, a TSS is set\n+--       on the underlying full view; the flags are used to track visibility of\n+--       the attribute definition clause for partial or incomplete views.\n+\n --    Has_Storage_Size_Clause (Flag23) [implementation base type only]\n --       Present in task types and access types. It is set if a Storage_Size\n --       clause is present for the type. Used to prevent multiple clauses for\n@@ -1608,10 +1631,10 @@ package Einfo is\n --    Implementation_Base_Type (synthesized)\n --       Applies to all types. Similar to Base_Type, but never returns a\n --       private type when applied to a non-private type. Instead in this\n---       case, it always returns the Representation_Type of the base type\n---       in this case, so that we still have a concrete type. Note: it is\n---       allowed to apply Implementation_Base_Type to other than a type,\n---       in which case it simply returns the entity unchanged.\n+--       case, it always returns the Underlying_Type of the base type, so that\n+--       we still have a concrete type. Note: it is allowed to apply\n+--       Implementation_Base_Type to other than a type, in which case it\n+--       simply returns the entity unchanged.\n \n --    In_Package_Body (Flag48)\n --       Set on the entity that denotes the package (the defining occurrence\n@@ -1662,6 +1685,14 @@ package Einfo is\n --       Present in all types, and also for functions and procedures. Set\n --       for abstract types and abstract subprograms.\n \n+--    Is_Local_Anonymous_Access (Flag194)\n+--       Present in access types. Set for an anonymous access type to indicate\n+--       that the type is created for a record component with an access\n+--       definition, an array component, or a stand-alone object. Such\n+--       anonymous types have an accessibility level equal to that of the\n+--       declaration in which they appear, unlike the anonymous access types\n+--       that are created for access parameters and access discriminants.\n+\n --    Is_Access_Constant (Flag69)\n --       Present in access types and subtypes. Indicates that the keyword\n --       constant was present in the access type definition.\n@@ -1981,8 +2012,10 @@ package Einfo is\n \n --    Is_Internal (Flag17)\n --       Present in all entities. Set to indicate an entity created during\n---       semantic processing (e.g. an implicit type). Need more documentation\n---       on this one! ???\n+--       semantic processing (e.g. an implicit type, or a temporary). The\n+--       only current use of this flag is to indicate that temporaries\n+--       generated for the result of an inlined function call need not be\n+--       initialized, even when scalars are initialized or normalized.\n \n --    Is_Interrupt_Handler (Flag89)\n --       Present in procedures. Set if a pragma Interrupt_Handler applies\n@@ -2124,8 +2157,8 @@ package Einfo is\n --       including generic formal parameters.\n \n --    Is_Obsolescent (Flag153)\n---       Present in subprogram entities. Set if a valid pragma Obsolescent\n---       applies to the subprogram.\n+--       Present in all entities. Set only for subprograms when a valid pragma\n+--       Obsolescent applies to the subprogram.\n \n --    Is_Optional_Parameter (Flag134)\n --       Present in parameter entities. Set if the parameter is specified as\n@@ -2252,6 +2285,11 @@ package Einfo is\n --       resulting from assignment to out parameters, or to objects designated\n --       by access parameters).\n \n+--    Is_Pure_Unit_Access_Type (Flag189)\n+--       Present in access type and subtype entities. Set if the type or\n+--       subtype appears in a pure unit. Used to give an error message at\n+--       freeze time if the access type has a storage pool.\n+\n --    Is_Real_Type (synthesized)\n --       Applies to all entities, true for real types and subtypes\n \n@@ -3933,7 +3971,7 @@ package Einfo is\n    --  For each enumeration value defined in Entity_Kind we list all the\n    --  attributes defined in Einfo which can legally be applied to an entity\n    --  of that kind. The implementation of the attribute functions (and for\n-   --  non-synthesized attributes, or the corresponding set procedures) are\n+   --  non-synthetized attributes, of the corresponding set procedures) are\n    --  in the Einfo body.\n \n    --  The following attributes apply to all entities\n@@ -3958,6 +3996,7 @@ package Einfo is\n    --    Has_Fully_Qualified_Name      (Flag173)\n    --    Has_Gigi_Rep_Item             (Flag82)\n    --    Has_Homonym                   (Flag56)\n+   --    Has_Persistent_BSS            (Flag188)\n    --    Has_Pragma_Elaborate_Body     (Flag150)\n    --    Has_Pragma_Inline             (Flag157)\n    --    Has_Pragma_Unreferenced       (Flag180)\n@@ -3987,6 +4026,7 @@ package Einfo is\n    --    Is_Known_Valid                (Flag170)\n    --    Is_Limited_Composite          (Flag106)\n    --    Is_Limited_Record             (Flag25)\n+   --    Is_Obsolescent                (Flag153)\n    --    Is_Package_Body_Entity        (Flag160)\n    --    Is_Packed_Array_Type          (Flag138)\n    --    Is_Potentially_Use_Visible    (Flag9)\n@@ -4037,12 +4077,17 @@ package Einfo is\n    --    Has_Alignment_Clause          (Flag46)\n    --    Has_Atomic_Components         (Flag86)   (base type only)\n    --    Has_Complex_Representation    (Flag140)  (base type only)\n+   --    Has_Constrained_Partial_View  (Flag187)\n    --    Has_Discriminants             (Flag5)\n    --    Has_Non_Standard_Rep          (Flag75)   (base type only)\n    --    Has_Object_Size_Clause        (Flag172)\n    --    Has_Primitive_Operations      (Flag120)  (base type only)\n    --    Has_Size_Clause               (Flag29)\n    --    Has_Specified_Layout          (Flag100)  (base type only)\n+   --    Has_Specified_Stream_Input    (Flag190)\n+   --    Has_Specified_Stream_Output   (Flag191)\n+   --    Has_Specified_Stream_Read     (Flag192)\n+   --    Has_Specified_Stream_Write    (Flag193)\n    --    Has_Task                      (Flag30)   (base type only)\n    --    Has_Unchecked_Union           (Flag123)  (base type only)\n    --    Has_Volatile_Components       (Flag87)   (base type only)\n@@ -4110,7 +4155,9 @@ package Einfo is\n    --    Associated_Final_Chain        (Node23)\n    --    Has_Pragma_Controlled         (Flag27)   (base type only)\n    --    Has_Storage_Size_Clause       (Flag23)   (base type only)\n+   --    Is_Local_Anonymous_Access     (Flag194)\n    --    Is_Access_Constant            (Flag69)\n+   --    Is_Pure_Unit_Access_Type      (Flag189)\n    --    No_Pool_Assigned              (Flag131)  (base type only)\n    --    No_Strict_Aliasing            (Flag136)  (base type only)\n    --    (plus type attributes)\n@@ -4376,7 +4423,6 @@ package Einfo is\n    --    Is_Instantiated               (Flag126)  (generic case only)\n    --    Is_Intrinsic_Subprogram       (Flag64)\n    --    Is_Machine_Code_Subprogram    (Flag137)  (non-generic case only)\n-   --    Is_Obsolescent                (Flag153)\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n@@ -4624,7 +4670,6 @@ package Einfo is\n    --    Is_Intrinsic_Subprogram       (Flag64)\n    --    Is_Machine_Code_Subprogram    (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc             (Flag178)\n-   --    Is_Obsolescent                (Flag153)\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n@@ -5142,6 +5187,7 @@ package Einfo is\n    function Has_Completion_In_Body             (Id : E) return B;\n    function Has_Complex_Representation         (Id : E) return B;\n    function Has_Component_Size_Clause          (Id : E) return B;\n+   function Has_Constrained_Partial_View       (Id : E) return B;\n    function Has_Contiguous_Rep                 (Id : E) return B;\n    function Has_Controlled_Component           (Id : E) return B;\n    function Has_Controlling_Result             (Id : E) return B;\n@@ -5163,6 +5209,7 @@ package Einfo is\n    function Has_Non_Standard_Rep               (Id : E) return B;\n    function Has_Object_Size_Clause             (Id : E) return B;\n    function Has_Per_Object_Constraint          (Id : E) return B;\n+   function Has_Persistent_BSS                 (Id : E) return B;\n    function Has_Pragma_Controlled              (Id : E) return B;\n    function Has_Pragma_Elaborate_Body          (Id : E) return B;\n    function Has_Pragma_Inline                  (Id : E) return B;\n@@ -5176,6 +5223,10 @@ package Einfo is\n    function Has_Size_Clause                    (Id : E) return B;\n    function Has_Small_Clause                   (Id : E) return B;\n    function Has_Specified_Layout               (Id : E) return B;\n+   function Has_Specified_Stream_Input         (Id : E) return B;\n+   function Has_Specified_Stream_Output        (Id : E) return B;\n+   function Has_Specified_Stream_Read          (Id : E) return B;\n+   function Has_Specified_Stream_Write         (Id : E) return B;\n    function Has_Storage_Size_Clause            (Id : E) return B;\n    function Has_Stream_Size_Clause             (Id : E) return B;\n    function Has_Subprogram_Descriptor          (Id : E) return B;\n@@ -5193,6 +5244,7 @@ package Einfo is\n    function Interface_Name                     (Id : E) return N;\n    function Is_AST_Entry                       (Id : E) return B;\n    function Is_Abstract                        (Id : E) return B;\n+   function Is_Local_Anonymous_Access          (Id : E) return B;\n    function Is_Access_Constant                 (Id : E) return B;\n    function Is_Ada_2005                        (Id : E) return B;\n    function Is_Aliased                         (Id : E) return B;\n@@ -5249,6 +5301,7 @@ package Einfo is\n    function Is_Private_Descendant              (Id : E) return B;\n    function Is_Public                          (Id : E) return B;\n    function Is_Pure                            (Id : E) return B;\n+   function Is_Pure_Unit_Access_Type           (Id : E) return B;\n    function Is_Remote_Call_Interface           (Id : E) return B;\n    function Is_Remote_Types                    (Id : E) return B;\n    function Is_Renaming_Of_Object              (Id : E) return B;\n@@ -5621,6 +5674,7 @@ package Einfo is\n    procedure Set_Has_Completion_In_Body        (Id : E; V : B := True);\n    procedure Set_Has_Complex_Representation    (Id : E; V : B := True);\n    procedure Set_Has_Component_Size_Clause     (Id : E; V : B := True);\n+   procedure Set_Has_Constrained_Partial_View  (Id : E; V : B := True);\n    procedure Set_Has_Contiguous_Rep            (Id : E; V : B := True);\n    procedure Set_Has_Controlled_Component      (Id : E; V : B := True);\n    procedure Set_Has_Controlling_Result        (Id : E; V : B := True);\n@@ -5641,6 +5695,7 @@ package Einfo is\n    procedure Set_Has_Non_Standard_Rep          (Id : E; V : B := True);\n    procedure Set_Has_Object_Size_Clause        (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint     (Id : E; V : B := True);\n+   procedure Set_Has_Persistent_BSS            (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Controlled         (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Elaborate_Body     (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Inline             (Id : E; V : B := True);\n@@ -5655,6 +5710,10 @@ package Einfo is\n    procedure Set_Has_Size_Clause               (Id : E; V : B := True);\n    procedure Set_Has_Small_Clause              (Id : E; V : B := True);\n    procedure Set_Has_Specified_Layout          (Id : E; V : B := True);\n+   procedure Set_Has_Specified_Stream_Input    (Id : E; V : B := True);\n+   procedure Set_Has_Specified_Stream_Output   (Id : E; V : B := True);\n+   procedure Set_Has_Specified_Stream_Read     (Id : E; V : B := True);\n+   procedure Set_Has_Specified_Stream_Write    (Id : E; V : B := True);\n    procedure Set_Has_Storage_Size_Clause       (Id : E; V : B := True);\n    procedure Set_Has_Stream_Size_Clause        (Id : E; V : B := True);\n    procedure Set_Has_Subprogram_Descriptor     (Id : E; V : B := True);\n@@ -5672,6 +5731,7 @@ package Einfo is\n    procedure Set_Interface_Name                (Id : E; V : N);\n    procedure Set_Is_AST_Entry                  (Id : E; V : B := True);\n    procedure Set_Is_Abstract                   (Id : E; V : B := True);\n+   procedure Set_Is_Local_Anonymous_Access     (Id : E; V : B := True);\n    procedure Set_Is_Access_Constant            (Id : E; V : B := True);\n    procedure Set_Is_Ada_2005                   (Id : E; V : B := True);\n    procedure Set_Is_Aliased                    (Id : E; V : B := True);\n@@ -5734,6 +5794,7 @@ package Einfo is\n    procedure Set_Is_Private_Descendant         (Id : E; V : B := True);\n    procedure Set_Is_Public                     (Id : E; V : B := True);\n    procedure Set_Is_Pure                       (Id : E; V : B := True);\n+   procedure Set_Is_Pure_Unit_Access_Type      (Id : E; V : B := True);\n    procedure Set_Is_Remote_Call_Interface      (Id : E; V : B := True);\n    procedure Set_Is_Remote_Types               (Id : E; V : B := True);\n    procedure Set_Is_Renaming_Of_Object         (Id : E; V : B := True);\n@@ -6155,6 +6216,7 @@ package Einfo is\n    pragma Inline (Has_Completion_In_Body);\n    pragma Inline (Has_Complex_Representation);\n    pragma Inline (Has_Component_Size_Clause);\n+   pragma Inline (Has_Constrained_Partial_View);\n    pragma Inline (Has_Contiguous_Rep);\n    pragma Inline (Has_Controlled_Component);\n    pragma Inline (Has_Controlling_Result);\n@@ -6175,6 +6237,7 @@ package Einfo is\n    pragma Inline (Has_Non_Standard_Rep);\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Per_Object_Constraint);\n+   pragma Inline (Has_Persistent_BSS);\n    pragma Inline (Has_Pragma_Controlled);\n    pragma Inline (Has_Pragma_Elaborate_Body);\n    pragma Inline (Has_Pragma_Inline);\n@@ -6189,6 +6252,10 @@ package Einfo is\n    pragma Inline (Has_Size_Clause);\n    pragma Inline (Has_Small_Clause);\n    pragma Inline (Has_Specified_Layout);\n+   pragma Inline (Has_Specified_Stream_Input);\n+   pragma Inline (Has_Specified_Stream_Output);\n+   pragma Inline (Has_Specified_Stream_Read);\n+   pragma Inline (Has_Specified_Stream_Write);\n    pragma Inline (Has_Storage_Size_Clause);\n    pragma Inline (Has_Stream_Size_Clause);\n    pragma Inline (Has_Subprogram_Descriptor);\n@@ -6206,6 +6273,7 @@ package Einfo is\n    pragma Inline (Interface_Name);\n    pragma Inline (Is_AST_Entry);\n    pragma Inline (Is_Abstract);\n+   pragma Inline (Is_Local_Anonymous_Access);\n    pragma Inline (Is_Access_Constant);\n    pragma Inline (Is_Ada_2005);\n    pragma Inline (Is_Access_Type);\n@@ -6296,6 +6364,7 @@ package Einfo is\n    pragma Inline (Is_Protected_Type);\n    pragma Inline (Is_Public);\n    pragma Inline (Is_Pure);\n+   pragma Inline (Is_Pure_Unit_Access_Type);\n    pragma Inline (Is_Real_Type);\n    pragma Inline (Is_Record_Type);\n    pragma Inline (Is_Remote_Call_Interface);\n@@ -6506,6 +6575,7 @@ package Einfo is\n    pragma Inline (Set_Has_Completion_In_Body);\n    pragma Inline (Set_Has_Complex_Representation);\n    pragma Inline (Set_Has_Component_Size_Clause);\n+   pragma Inline (Set_Has_Constrained_Partial_View);\n    pragma Inline (Set_Has_Contiguous_Rep);\n    pragma Inline (Set_Has_Controlled_Component);\n    pragma Inline (Set_Has_Controlling_Result);\n@@ -6526,6 +6596,7 @@ package Einfo is\n    pragma Inline (Set_Has_Non_Standard_Rep);\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n+   pragma Inline (Set_Has_Persistent_BSS);\n    pragma Inline (Set_Has_Pragma_Controlled);\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);\n    pragma Inline (Set_Has_Pragma_Inline);\n@@ -6540,6 +6611,10 @@ package Einfo is\n    pragma Inline (Set_Has_Size_Clause);\n    pragma Inline (Set_Has_Small_Clause);\n    pragma Inline (Set_Has_Specified_Layout);\n+   pragma Inline (Set_Has_Specified_Stream_Input);\n+   pragma Inline (Set_Has_Specified_Stream_Output);\n+   pragma Inline (Set_Has_Specified_Stream_Read);\n+   pragma Inline (Set_Has_Specified_Stream_Write);\n    pragma Inline (Set_Has_Storage_Size_Clause);\n    pragma Inline (Set_Has_Subprogram_Descriptor);\n    pragma Inline (Set_Has_Task);\n@@ -6556,6 +6631,7 @@ package Einfo is\n    pragma Inline (Set_Interface_Name);\n    pragma Inline (Set_Is_AST_Entry);\n    pragma Inline (Set_Is_Abstract);\n+   pragma Inline (Set_Is_Local_Anonymous_Access);\n    pragma Inline (Set_Is_Access_Constant);\n    pragma Inline (Set_Is_Ada_2005);\n    pragma Inline (Set_Is_Aliased);\n@@ -6618,6 +6694,7 @@ package Einfo is\n    pragma Inline (Set_Is_Private_Descendant);\n    pragma Inline (Set_Is_Public);\n    pragma Inline (Set_Is_Pure);\n+   pragma Inline (Set_Is_Pure_Unit_Access_Type);\n    pragma Inline (Set_Is_Remote_Call_Interface);\n    pragma Inline (Set_Is_Remote_Types);\n    pragma Inline (Set_Is_Renaming_Of_Object);"}, {"sha": "c60415f855405f059a43ed11ce5d27f56c31a72d", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 691, "deletions": 19, "changes": 710, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,7 +46,7 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n-with Sem_Ch6;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch11; use Sem_Ch11;\n with Sem_Elab; use Sem_Elab;\n@@ -131,6 +131,30 @@ package body Exp_Ch9 is\n    --  of the range of each entry family. A single array with that size is\n    --  allocated for each concurrent object of the type.\n \n+   function Build_Wrapper_Body\n+     (Loc      : Source_Ptr;\n+      Proc_Nam : Entity_Id;\n+      Obj_Typ  : Entity_Id;\n+      Formals  : List_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Build the body that wraps a primitive operation\n+   --  associated with a protected or task type. This is required to implement\n+   --  dispatching calls through interfaces. Proc_Nam is the entry name to be\n+   --  wrapped, Obj_Typ is the type of the newly added formal parameter to\n+   --  handle object notation, Formals are the original entry formals that will\n+   --  be explicitly replicated.\n+\n+   function Build_Wrapper_Spec\n+     (Loc      : Source_Ptr;\n+      Proc_Nam : Entity_Id;\n+      Obj_Typ  : Entity_Id;\n+      Formals  : List_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Build the specification of a primitive operation\n+   --  associated with a protected or task type. This is required implement\n+   --  dispatching calls through interfaces. Proc_Nam is the entry name to be\n+   --  wrapped, Obj_Typ is the type of the newly added formal parameter to\n+   --  handle object notation, Formals are the original entry formals that will\n+   --  be explicitly replicated.\n+\n    function Build_Find_Body_Index (Typ : Entity_Id) return Node_Id;\n    --  Build the function that translates the entry index in the call\n    --  (which depends on the size of entry families) into an index into the\n@@ -850,7 +874,7 @@ package body Exp_Ch9 is\n       Cdecls   : List_Id;\n \n    begin\n-      Set_Corresponding_Record_Type (Ctyp, Rec_Ent);\n+      Set_Corresponding_Record_Type     (Ctyp, Rec_Ent);\n       Set_Ekind                         (Rec_Ent, E_Record_Type);\n       Set_Has_Delayed_Freeze            (Rec_Ent, Has_Delayed_Freeze (Ctyp));\n       Set_Is_Concurrent_Record_Type     (Rec_Ent, True);\n@@ -895,9 +919,11 @@ package body Exp_Ch9 is\n       end if;\n \n       --  Now we can construct the record type declaration. Note that this\n-      --  record is limited, reflecting the underlying limitedness of the\n-      --  task or protected object that it represents, and ensuring for\n-      --  example that it is properly passed by reference.\n+      --  record is \"limited tagged\". It is \"limited\" to reflect the underlying\n+      --  limitedness of the task or protected object that it represents, and\n+      --  ensuring for example that it is properly passed by reference. It is\n+      --  \"tagged\" to give support to dispatching calls through interfaces (Ada\n+      --  2005: AI-345)\n \n       return\n         Make_Full_Type_Declaration (Loc,\n@@ -908,6 +934,7 @@ package body Exp_Ch9 is\n               Component_List =>\n                 Make_Component_List (Loc,\n                   Component_Items => Cdecls),\n+              Tagged_Present  => Ada_Version >= Ada_05,\n               Limited_Present => True));\n    end Build_Corresponding_Record;\n \n@@ -971,6 +998,394 @@ package body Exp_Ch9 is\n       return Ecount;\n    end Build_Entry_Count_Expression;\n \n+   ------------------------------\n+   -- Build_Wrapper_Body --\n+   ------------------------------\n+\n+   function Build_Wrapper_Body\n+     (Loc      : Source_Ptr;\n+      Proc_Nam : Entity_Id;\n+      Obj_Typ  : Entity_Id;\n+      Formals  : List_Id) return Node_Id\n+   is\n+      Actuals      : List_Id := No_List;\n+      Body_Spec    : Node_Id;\n+      Conv_Id      : Node_Id;\n+      First_Formal : Node_Id;\n+      Formal       : Node_Id;\n+\n+   begin\n+      Body_Spec := Build_Wrapper_Spec (Loc, Proc_Nam, Obj_Typ, Formals);\n+\n+      --  If we did not generate the specification do have nothing else to do\n+\n+      if Body_Spec = Empty then\n+         return Empty;\n+      end if;\n+\n+      --  Map formals to actuals. Use the list built for the wrapper spec,\n+      --  skipping the object notation parameter.\n+\n+      First_Formal := First (Parameter_Specifications (Body_Spec));\n+\n+      Formal := First_Formal;\n+      Next (Formal);\n+\n+      if Present (Formal) then\n+         Actuals := New_List;\n+\n+         while Present (Formal) loop\n+            Append_To (Actuals,\n+              Make_Identifier (Loc, Chars =>\n+                Chars (Defining_Identifier (Formal))));\n+\n+            Next (Formal);\n+         end loop;\n+      end if;\n+\n+      --  An access-to-variable first parameter will require an explicit\n+      --  dereference in the unchecked conversion. This case occurs when\n+      --  a protected entry wrapper must override an interface-level\n+      --  procedure with interface access as first parameter.\n+\n+      --     SubprgName (O.all).Proc_Nam (Formal_1 .. Formal_N)\n+\n+      if Nkind (Parameter_Type (First_Formal)) = N_Access_Definition then\n+         Conv_Id :=\n+           Make_Explicit_Dereference (Loc,\n+             Prefix =>\n+               Make_Identifier (Loc, Chars => Name_uO));\n+      else\n+         Conv_Id :=\n+           Make_Identifier (Loc, Chars => Name_uO);\n+      end if;\n+\n+      if Ekind (Proc_Nam) = E_Function then\n+         return\n+           Make_Subprogram_Body (Loc,\n+             Specification => Body_Spec,\n+             Declarations  => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements =>\n+                   New_List (\n+                     Make_Return_Statement (Loc,\n+                        Make_Function_Call (Loc,\n+                          Name =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix =>\n+                                Unchecked_Convert_To (\n+                                  Corresponding_Concurrent_Type (Obj_Typ),\n+                                  Conv_Id),\n+                              Selector_Name =>\n+                                New_Reference_To (Proc_Nam, Loc)),\n+                          Parameter_Associations => Actuals)))));\n+      else\n+         return\n+           Make_Subprogram_Body (Loc,\n+             Specification => Body_Spec,\n+             Declarations  => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements =>\n+                   New_List (\n+                     Make_Procedure_Call_Statement (Loc,\n+                       Name =>\n+                         Make_Selected_Component (Loc,\n+                           Prefix =>\n+                             Unchecked_Convert_To (\n+                               Corresponding_Concurrent_Type (Obj_Typ),\n+                               Conv_Id),\n+                           Selector_Name =>\n+                             New_Reference_To (Proc_Nam, Loc)),\n+                       Parameter_Associations => Actuals))));\n+      end if;\n+   end Build_Wrapper_Body;\n+\n+   ------------------------\n+   -- Build_Wrapper_Spec --\n+   ------------------------\n+\n+   function Build_Wrapper_Spec\n+     (Loc      : Source_Ptr;\n+      Proc_Nam : Entity_Id;\n+      Obj_Typ  : Entity_Id;\n+      Formals  : List_Id) return Node_Id\n+   is\n+      New_Name_Id : constant Entity_Id :=\n+                      Make_Defining_Identifier (Loc, Chars (Proc_Nam));\n+\n+      First_Param        : Node_Id := Empty;\n+      Iface              : Entity_Id;\n+      Iface_Elmt         : Elmt_Id := No_Elmt;\n+      New_Formals        : List_Id;\n+      Obj_Param          : Node_Id;\n+      Obj_Param_Typ      : Node_Id;\n+      Iface_Prim_Op      : Entity_Id;\n+      Iface_Prim_Op_Elmt : Elmt_Id;\n+\n+      function Overriding_Possible\n+        (Iface_Prim_Op : Entity_Id;\n+         Proc_Nam      : Entity_Id) return Boolean;\n+      --  Determine whether a primitive operation can be overriden by the\n+      --  wrapper. Iface_Prim_Op is the candidate primitive operation of an\n+      --  abstract interface type, Proc_Nam is the generated entry wrapper.\n+\n+      function Replicate_Entry_Formals\n+        (Loc     : Source_Ptr;\n+         Formals : List_Id) return List_Id;\n+      --  An explicit parameter replication is required due to the\n+      --  Is_Entry_Formal flag being set for all the formals. The explicit\n+      --  replication removes the flag that would otherwise cause a different\n+      --  path of analysis.\n+\n+      -------------------------\n+      -- Overriding_Possible --\n+      -------------------------\n+\n+      function Overriding_Possible\n+        (Iface_Prim_Op : Entity_Id;\n+         Proc_Nam      : Entity_Id) return Boolean\n+      is\n+         Prim_Op_Spec  : constant Node_Id := Parent (Iface_Prim_Op);\n+         Proc_Spec     : constant Node_Id := Parent (Proc_Nam);\n+\n+         Is_Access_To_Variable : Boolean;\n+         Is_Out_Present        : Boolean;\n+\n+         function Type_Conformant_Parameters\n+           (Prim_Op_Param_Specs : List_Id;\n+            Proc_Param_Specs    : List_Id) return Boolean;\n+         --  Determine whether the parameters of the generated entry wrapper\n+         --  and those of a primitive operation are type conformant. During\n+         --  this check, the first parameter of the primitive operation is\n+         --  always skipped.\n+\n+         --------------------------------\n+         -- Type_Conformant_Parameters --\n+         --------------------------------\n+\n+         function Type_Conformant_Parameters\n+           (Prim_Op_Param_Specs : List_Id;\n+            Proc_Param_Specs    : List_Id) return Boolean\n+         is\n+            Prim_Op_Param : Node_Id;\n+            Proc_Param    : Node_Id;\n+\n+         begin\n+            --  Skip the first parameter of the primitive operation\n+\n+            Prim_Op_Param := Next (First (Prim_Op_Param_Specs));\n+            Proc_Param    := First (Proc_Param_Specs);\n+            while Present (Prim_Op_Param)\n+              and then Present (Proc_Param)\n+            loop\n+               --  The two parameters must be mode conformant and have\n+               --  the exact same types.\n+\n+               if Out_Present (Prim_Op_Param) /= Out_Present (Proc_Param)\n+                 or else In_Present (Prim_Op_Param) /= In_Present (Proc_Param)\n+                 or else Etype (Parameter_Type (Prim_Op_Param)) /=\n+                         Etype (Parameter_Type (Proc_Param))\n+               then\n+                  return False;\n+               end if;\n+\n+               Next (Prim_Op_Param);\n+               Next (Proc_Param);\n+            end loop;\n+\n+            --  One of the lists is longer than the other\n+\n+            if Present (Prim_Op_Param) or else Present (Proc_Param) then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end Type_Conformant_Parameters;\n+\n+      --  Start of processing for Overriding_Possible\n+\n+      begin\n+         if Chars (Iface_Prim_Op) /= Chars (Proc_Nam) then\n+            return False;\n+         end if;\n+\n+         --  Special check for protected procedures: If an inherited subprogram\n+         --  is implemented by a protected procedure or an entry, then the\n+         --  first parameter of the inherited subprogram shall be of mode OUT\n+         --  or IN OUT, or an access-to-variable parameter.\n+\n+         if Ekind (Iface_Prim_Op) = E_Procedure then\n+\n+            Is_Out_Present :=\n+              Present (Parameter_Specifications (Prim_Op_Spec))\n+                and then\n+              Out_Present (First (Parameter_Specifications (Prim_Op_Spec)));\n+\n+            Is_Access_To_Variable :=\n+              Present (Parameter_Specifications (Prim_Op_Spec))\n+                and then\n+              Nkind (Parameter_Type\n+                     (First\n+                      (Parameter_Specifications (Prim_Op_Spec))))\n+                        = N_Access_Definition;\n+\n+            if not Is_Out_Present\n+              and then not Is_Access_To_Variable\n+            then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return Type_Conformant_Parameters (\n+           Parameter_Specifications (Prim_Op_Spec),\n+           Parameter_Specifications (Proc_Spec));\n+\n+      end Overriding_Possible;\n+\n+      -----------------------------\n+      -- Replicate_Entry_Formals --\n+      -----------------------------\n+\n+      function Replicate_Entry_Formals\n+        (Loc     : Source_Ptr;\n+         Formals : List_Id) return List_Id\n+      is\n+         New_Formals : constant List_Id := New_List;\n+         Formal      : Node_Id;\n+\n+      begin\n+         Formal := First (Formals);\n+\n+         if Present (Formal) then\n+            while Present (Formal) loop\n+\n+               --  Create an explicit copy of the entry parameter\n+\n+               Append_To (New_Formals,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc,\n+                       Chars => Chars (Defining_Identifier (Formal))),\n+                   In_Present  => In_Present  (Formal),\n+                   Out_Present => Out_Present (Formal),\n+                   Parameter_Type => New_Reference_To (Etype (\n+                                       Parameter_Type (Formal)), Loc)));\n+\n+               Next (Formal);\n+            end loop;\n+         end if;\n+\n+         return New_Formals;\n+      end Replicate_Entry_Formals;\n+\n+   --  Start of processing for Build_Wrapper_Spec\n+\n+   begin\n+      --  The mode is determined by the first parameter of the interface-level\n+      --  procedure that the current entry is trying to override.\n+\n+      pragma Assert (Present (Abstract_Interfaces\n+                     (Corresponding_Record_Type (Scope (Proc_Nam)))));\n+\n+      Iface_Elmt :=\n+        First_Elmt (Abstract_Interfaces\n+                    (Corresponding_Record_Type (Scope (Proc_Nam))));\n+\n+      --  We must examine all the protected operations of the implemented\n+      --  interfaces in order to discover a possible overriding candidate.\n+\n+      Examine_Interfaces : while Present (Iface_Elmt) loop\n+         Iface := Node (Iface_Elmt);\n+\n+         if Present (Primitive_Operations (Iface)) then\n+            Iface_Prim_Op_Elmt := First_Elmt (Primitive_Operations (Iface));\n+\n+            while Present (Iface_Prim_Op_Elmt) loop\n+               Iface_Prim_Op := Node (Iface_Prim_Op_Elmt);\n+\n+               --  The current primitive operation can be overriden by the\n+               --  generated entry wrapper.\n+\n+               if Overriding_Possible (Iface_Prim_Op, Proc_Nam) then\n+                  First_Param :=\n+                    First (Parameter_Specifications (Parent (Iface_Prim_Op)));\n+\n+                  exit Examine_Interfaces;\n+               end if;\n+\n+               Next_Elmt (Iface_Prim_Op_Elmt);\n+            end loop;\n+         end if;\n+\n+         Next_Elmt (Iface_Elmt);\n+      end loop Examine_Interfaces;\n+\n+      --  Return if no interface primitive can be overriden\n+\n+      if not Present (First_Param) then\n+         return Empty;\n+      end if;\n+\n+      New_Formals := Replicate_Entry_Formals (Loc, Formals);\n+\n+      --  ??? Certain source packages contain protected or task types that do\n+      --  not implement any interfaces and are compiled with the -gnat05\n+      --  switch.  In this case, a default first parameter is created.\n+\n+      if Present (First_Param) then\n+         if Nkind (Parameter_Type (First_Param)) = N_Access_Definition then\n+            Obj_Param_Typ :=\n+              Make_Access_Definition (Loc,\n+                Subtype_Mark =>\n+                  New_Reference_To (Obj_Typ, Loc));\n+         else\n+            Obj_Param_Typ := New_Reference_To (Obj_Typ, Loc);\n+         end if;\n+\n+         Obj_Param :=\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uO),\n+             In_Present  => In_Present  (First_Param),\n+             Out_Present => Out_Present (First_Param),\n+             Parameter_Type => Obj_Param_Typ);\n+\n+      else\n+         Obj_Param :=\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Name_uO),\n+             In_Present  => True,\n+             Out_Present => True,\n+               Parameter_Type => New_Reference_To (Obj_Typ, Loc));\n+      end if;\n+\n+      Prepend_To (New_Formals, Obj_Param);\n+\n+      --  Minimum decoration needed to catch the entity in\n+      --  Sem_Ch6.Override_Dispatching_Operation\n+\n+      if Ekind (Proc_Nam) = E_Procedure\n+        or else Ekind (Proc_Nam) = E_Entry\n+      then\n+         Set_Ekind (New_Name_Id, E_Procedure);\n+         return\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name => New_Name_Id,\n+             Parameter_Specifications => New_Formals);\n+\n+      else pragma Assert (Ekind (Proc_Nam) = E_Function);\n+         Set_Ekind (New_Name_Id, E_Function);\n+         return\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name => New_Name_Id,\n+             Parameter_Specifications => New_Formals,\n+             Subtype_Mark => New_Copy (Subtype_Mark (Parent (Proc_Nam))));\n+      end if;\n+   end Build_Wrapper_Spec;\n+\n    ---------------------------\n    -- Build_Find_Body_Index --\n    ---------------------------\n@@ -1513,7 +1928,14 @@ package body Exp_Ch9 is\n       if Unprotected then\n          Append_Char := 'N';\n       else\n-         Append_Char := 'P';\n+         --  Ada 2005 (AI-345): The protected version no longer uses 'P'\n+         --  as suffix in order to make it a primitive operation\n+\n+         if Ada_Version >= Ada_05 then\n+            Append_Char := ' ';\n+         else\n+            Append_Char := 'P';\n+         end if;\n       end if;\n \n       New_Id :=\n@@ -4836,6 +5258,7 @@ package body Exp_Ch9 is\n    --  the state of the protected object.\n \n    procedure Expand_N_Protected_Body (N : Node_Id) is\n+      Loc          : constant Source_Ptr := Sloc (N);\n       Pid          : constant Entity_Id  := Corresponding_Spec (N);\n       Has_Entries  : Boolean := False;\n       Op_Decl      : Node_Id;\n@@ -4985,8 +5408,70 @@ package body Exp_Ch9 is\n       then\n          New_Op_Body := Build_Find_Body_Index (Pid);\n          Insert_After (Current_Node, New_Op_Body);\n+         Current_Node := New_Op_Body;\n          Analyze (New_Op_Body);\n       end if;\n+\n+      --  Ada 2005 (AI-345): Construct the primitive entry wrapper bodies\n+      --  after the protected body. At this point the entry specs have been\n+      --  created, frozen and included in the dispatch table for the\n+      --  protected type.\n+\n+      pragma Assert (Present (Corresponding_Record_Type (Pid)));\n+\n+      if Ada_Version >= Ada_05\n+        and then Present (Protected_Definition (Parent (Pid)))\n+        and then Present (Abstract_Interfaces\n+                          (Corresponding_Record_Type (Pid)))\n+      then\n+         declare\n+            Vis_Decl  : Node_Id :=\n+                          First (Visible_Declarations\n+                                 (Protected_Definition (Parent (Pid))));\n+            Wrap_Body : Node_Id;\n+\n+         begin\n+            --  Examine the visible declarations of the protected type,\n+            --  looking for an entry declaration. We do not consider\n+            --  entry families since they can not have dispatching\n+            --  operations, thus they do not need entry wrappers.\n+\n+            while Present (Vis_Decl) loop\n+               if Nkind (Vis_Decl) = N_Entry_Declaration then\n+                  Wrap_Body :=\n+                    Build_Wrapper_Body (Loc,\n+                      Proc_Nam => Defining_Identifier (Vis_Decl),\n+                      Obj_Typ  => Corresponding_Record_Type (Pid),\n+                      Formals  => Parameter_Specifications (Vis_Decl));\n+\n+                  if Wrap_Body /= Empty then\n+                     Insert_After (Current_Node, Wrap_Body);\n+                     Current_Node := Wrap_Body;\n+\n+                     Analyze (Wrap_Body);\n+                  end if;\n+\n+               elsif Nkind (Vis_Decl) = N_Subprogram_Declaration then\n+                  Wrap_Body :=\n+                    Build_Wrapper_Body (Loc,\n+                      Proc_Nam => Defining_Unit_Name\n+                                        (Specification (Vis_Decl)),\n+                      Obj_Typ  => Corresponding_Record_Type (Pid),\n+                      Formals  => Parameter_Specifications\n+                                        (Specification (Vis_Decl)));\n+\n+                  if Wrap_Body /= Empty then\n+                     Insert_After (Current_Node, Wrap_Body);\n+                     Current_Node := Wrap_Body;\n+\n+                     Analyze (Wrap_Body);\n+                  end if;\n+               end if;\n+\n+               Next (Vis_Decl);\n+            end loop;\n+         end;\n+      end if;\n    end Expand_N_Protected_Body;\n \n    -----------------------------------------\n@@ -5136,6 +5621,11 @@ package body Exp_Ch9 is\n                       (Component_List (Type_Definition (Rec_Decl)));\n       end if;\n \n+      --  Ada 2005 (AI-345): Propagate the attribute that contains the list\n+      --  of implemented interfaces.\n+\n+      Set_Interface_List (Type_Definition (Rec_Decl), Interface_List (N));\n+\n       Qualify_Entity_Names (N);\n \n       --  If the type has discriminants, their occurrences in the declaration\n@@ -5353,6 +5843,70 @@ package body Exp_Ch9 is\n \n       Analyze (Rec_Decl, Suppress => All_Checks);\n \n+      --  Ada 2005 (AI-345): Construct the primitive entry wrappers before\n+      --  the corresponding record is frozen\n+\n+      if Ada_Version >= Ada_05\n+        and then Present (Visible_Declarations (Pdef))\n+        and then Present (Corresponding_Record_Type\n+                          (Defining_Identifier (Parent (Pdef))))\n+        and then Present (Abstract_Interfaces\n+                          (Corresponding_Record_Type\n+                           (Defining_Identifier (Parent (Pdef)))))\n+      then\n+         declare\n+            Current_Node : Node_Id := Rec_Decl;\n+            Vis_Decl     : Node_Id;\n+            Wrap_Spec    : Node_Id;\n+            New_N        : Node_Id;\n+\n+         begin\n+            --  Examine the visible declarations of the protected type, looking\n+            --  for declarations of entries, and subprograms. We do not\n+            --  consider entry families since they can not have dispatching\n+            --  operations, thus they do not need entry wrappers.\n+\n+            Vis_Decl := First (Visible_Declarations (Pdef));\n+\n+            while Present (Vis_Decl) loop\n+\n+               Wrap_Spec := Empty;\n+\n+               if Nkind (Vis_Decl) = N_Entry_Declaration\n+                 and then not Present (Discrete_Subtype_Definition (Vis_Decl))\n+               then\n+                  Wrap_Spec :=\n+                    Build_Wrapper_Spec (Loc,\n+                      Proc_Nam => Defining_Identifier (Vis_Decl),\n+                      Obj_Typ  => Defining_Identifier (Rec_Decl),\n+                      Formals  => Parameter_Specifications (Vis_Decl));\n+\n+               elsif Nkind (Vis_Decl) = N_Subprogram_Declaration then\n+                  Wrap_Spec :=\n+                    Build_Wrapper_Spec (Loc,\n+                      Proc_Nam => Defining_Unit_Name\n+                                    (Specification (Vis_Decl)),\n+                      Obj_Typ  => Defining_Identifier (Rec_Decl),\n+                      Formals  => Parameter_Specifications\n+                                    (Specification (Vis_Decl)));\n+\n+               end if;\n+\n+               if Wrap_Spec /= Empty then\n+                  New_N := Make_Subprogram_Declaration (Loc,\n+                             Specification => Wrap_Spec);\n+\n+                  Insert_After (Current_Node, New_N);\n+                  Current_Node := New_N;\n+\n+                  Analyze (New_N);\n+               end if;\n+\n+               Next (Vis_Decl);\n+            end loop;\n+         end;\n+      end if;\n+\n       --  Collect pointers to entry bodies and their barriers, to be placed\n       --  in the Entry_Bodies_Array for the type. For each entry/family we\n       --  add an expression to the aggregate which is the initial value of\n@@ -7038,6 +7592,62 @@ package body Exp_Ch9 is\n                Make_Identifier (Loc, New_External_Name (Chars (Ttyp), 'E')),\n              Expression => New_Reference_To (Standard_True, Loc)));\n       end if;\n+\n+      --  Ada 2005 (AI-345): Construct the primitive entry wrapper bodies\n+      --  after the task body. At this point the entry specs have been\n+      --  created, frozen and included in the dispatch table for the task\n+      --  type.\n+\n+      pragma Assert (Present (Corresponding_Record_Type (Ttyp)));\n+\n+      if Ada_Version >= Ada_05\n+        and then Present (Task_Definition (Parent (Ttyp)))\n+        and then Present (Abstract_Interfaces\n+                          (Corresponding_Record_Type (Ttyp)))\n+      then\n+         declare\n+            Current_Node : Node_Id;\n+            Vis_Decl     : Node_Id :=\n+              First (Visible_Declarations (Task_Definition (Parent (Ttyp))));\n+            Wrap_Body    : Node_Id;\n+\n+         begin\n+            if Nkind (Parent (N)) = N_Subunit then\n+               Current_Node := Corresponding_Stub (Parent (N));\n+            else\n+               Current_Node := N;\n+            end if;\n+\n+            --  Examine the visible declarations of the task type,\n+            --  looking for an entry declaration. We do not consider\n+            --  entry families since they can not have dispatching\n+            --  operations, thus they do not need entry wrappers.\n+\n+            while Present (Vis_Decl) loop\n+               if Nkind (Vis_Decl) = N_Entry_Declaration\n+                 and then Ekind (Defining_Identifier (Vis_Decl)) = E_Entry\n+               then\n+\n+                  --  Create the specification of the wrapper\n+\n+                  Wrap_Body :=\n+                    Build_Wrapper_Body (Loc,\n+                      Proc_Nam => Defining_Identifier (Vis_Decl),\n+                      Obj_Typ  => Corresponding_Record_Type (Ttyp),\n+                      Formals  => Parameter_Specifications (Vis_Decl));\n+\n+                  if Wrap_Body /= Empty then\n+                     Insert_After (Current_Node, Wrap_Body);\n+                     Current_Node := Wrap_Body;\n+\n+                     Analyze (Wrap_Body);\n+                  end if;\n+               end if;\n+\n+               Next (Vis_Decl);\n+            end loop;\n+         end;\n+      end if;\n    end Expand_N_Task_Body;\n \n    ------------------------------------\n@@ -7160,6 +7770,12 @@ package body Exp_Ch9 is\n       --  Here we will do the expansion\n \n       Rec_Decl := Build_Corresponding_Record (N, Tasktyp, Loc);\n+\n+      --  Ada 2005 (AI-345): Propagate the attribute that contains the list\n+      --  of implemented interfaces.\n+\n+      Set_Interface_List (Type_Definition (Rec_Decl), Interface_List (N));\n+\n       Rec_Ent  := Defining_Identifier (Rec_Decl);\n       Cdecls   := Component_Items (Component_List\n                                      (Type_Definition (Rec_Decl)));\n@@ -7412,20 +8028,76 @@ package body Exp_Ch9 is\n       Set_Needs_Debug_Info\n         (Defining_Entity (Proc_Spec), Comes_From_Source (Original_Node (N)));\n \n-      --  Now we can freeze the corresponding record. This needs manually\n-      --  freezing, since it is really part of the task type, and the task\n-      --  type is frozen at this stage. We of course need the initialization\n-      --  procedure for this corresponding record type and we won't get it\n-      --  in time if we don't freeze now.\n+      --  Ada 2005 (AI-345): Construct the primitive entry wrapper specs\n+      --  before the corresponding record has been frozen.\n \n-      declare\n-         L : constant List_Id := Freeze_Entity (Rec_Ent, Loc);\n+      if Ada_Version >= Ada_05\n+        and then Present (Taskdef)\n+        and then Present (Corresponding_Record_Type\n+                          (Defining_Identifier (Parent (Taskdef))))\n+        and then Present (Abstract_Interfaces\n+                          (Corresponding_Record_Type\n+                           (Defining_Identifier (Parent (Taskdef)))))\n+      then\n+         declare\n+            Current_Node : Node_Id := Rec_Decl;\n+            Vis_Decl     : Node_Id := First (Visible_Declarations (Taskdef));\n+            Wrap_Spec    : Node_Id;\n+            New_N        : Node_Id;\n \n-      begin\n-         if Is_Non_Empty_List (L) then\n-            Insert_List_After (Body_Decl, L);\n-         end if;\n-      end;\n+         begin\n+            --  Examine the visible declarations of the task type,\n+            --  looking for an entry declaration. We do not consider\n+            --  entry families since they can not have dispatching\n+            --  operations, thus they do not need entry wrappers.\n+\n+            while Present (Vis_Decl) loop\n+               if Nkind (Vis_Decl) = N_Entry_Declaration\n+                 and then Ekind (Defining_Identifier (Vis_Decl)) = E_Entry\n+               then\n+                  Wrap_Spec :=\n+                    Build_Wrapper_Spec (Loc,\n+                      Proc_Nam => Defining_Identifier (Vis_Decl),\n+                      Obj_Typ  => Etype (Rec_Ent),\n+                      Formals  => Parameter_Specifications (Vis_Decl));\n+\n+                  if Wrap_Spec /= Empty then\n+                     New_N :=\n+                       Make_Subprogram_Declaration (Loc,\n+                         Specification => Wrap_Spec);\n+\n+                     Insert_After (Current_Node, New_N);\n+                     Current_Node := New_N;\n+\n+                     Analyze (New_N);\n+                  end if;\n+               end if;\n+\n+               Next (Vis_Decl);\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Ada 2005 (AI-345): We must defer freezing to allow further\n+      --  declaration of primitive subprograms covering task interfaces\n+\n+      if Ada_Version <= Ada_95 then\n+\n+         --  Now we can freeze the corresponding record. This needs manually\n+         --  freezing, since it is really part of the task type, and the task\n+         --  type is frozen at this stage. We of course need the initialization\n+         --  procedure for this corresponding record type and we won't get it\n+         --  in time if we don't freeze now.\n+\n+         declare\n+            L : constant List_Id := Freeze_Entity (Rec_Ent, Loc);\n+\n+         begin\n+            if Is_Non_Empty_List (L) then\n+               Insert_List_After (Body_Decl, L);\n+            end if;\n+         end;\n+      end if;\n \n       --  Complete the expansion of access types to the current task\n       --  type, if any were declared."}, {"sha": "f4a58add325087b2c6248e5c9650a9444007d467", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 6, "deletions": 51, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -32,7 +32,6 @@ with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n-with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem_Res;  use Sem_Res;\n with Sinfo;    use Sinfo;\n@@ -192,12 +191,10 @@ package body Exp_Imgv is\n    --    For types whose root type is Wide_Character\n    --      xx = Wide_Character\n    --      tv = Wide_Character (Expr)\n-   --      pm = Wide_Character_Encoding_Method\n \n    --    For types whose root type is Wide_Wide_Character\n    --      xx = Wide_Wide_haracter\n    --      tv = Wide_Wide_Character (Expr)\n-   --      pm = Wide_Character_Encoding_Method\n \n    --    For floating-point types\n    --      xx = Floating_Point\n@@ -391,15 +388,6 @@ package body Exp_Imgv is\n              Prefix         => New_Reference_To (Ptyp, Loc),\n              Attribute_Name => Name_Aft));\n \n-      --  For wide [wide] character, append encoding method\n-\n-      elsif Rtyp = Standard_Wide_Character\n-        or else Rtyp = Standard_Wide_Wide_Character\n-      then\n-         Append_To (Arglist,\n-           Make_Integer_Literal (Loc,\n-             Intval => Int (Wide_Character_Encoding_Method)));\n-\n       --  For decimal, append Scale and also set to do literal conversion\n \n       elsif Is_Decimal_Fixed_Point_Type (Rtyp) then\n@@ -434,6 +422,12 @@ package body Exp_Imgv is\n    --    For types whose root type is Character\n    --      xx = Character\n \n+   --    For types whose root type is Wide_Character\n+   --      xx = Wide_Character\n+\n+   --    For types whose root type is Wide_Wide_Character\n+   --      xx = Wide_Wide_Character\n+\n    --    For types whose root type is Boolean\n    --      xx = Boolean\n \n@@ -452,14 +446,6 @@ package body Exp_Imgv is\n    --    For floating-point types and ordinary fixed-point types\n    --      xx = Real\n \n-   --  For types derived from Wide_Character, typ'Value (X) expands into\n-\n-   --    Value_Wide_Character (X, Wide_Character_Encoding_Method)\n-\n-   --  For types derived from Wide_Wide_Character, typ'Value (X) expands into\n-\n-   --    Value_Wide_Wide_Character (X, Wide_Character_Encoding_Method)\n-\n    --  For decimal types with size <= Integer'Size, typ'Value (X)\n    --  expands into\n \n@@ -504,15 +490,9 @@ package body Exp_Imgv is\n \n       elsif Rtyp = Standard_Wide_Character then\n          Vid := RE_Value_Wide_Character;\n-         Append_To (Args,\n-           Make_Integer_Literal (Loc,\n-             Intval => Int (Wide_Character_Encoding_Method)));\n \n       elsif Rtyp = Standard_Wide_Wide_Character then\n          Vid := RE_Value_Wide_Wide_Character;\n-         Append_To (Args,\n-           Make_Integer_Literal (Loc,\n-             Intval => Int (Wide_Character_Encoding_Method)));\n \n       elsif     Rtyp = Base_Type (Standard_Short_Short_Integer)\n         or else Rtyp = Base_Type (Standard_Short_Integer)\n@@ -686,42 +666,36 @@ package body Exp_Imgv is\n    --    Result_Type (Width_Wide_Character (\n    --      Wide_Character (typ'First),\n    --      Wide_Character (typ'Last),\n-   --      Wide_Character_Encoding_Method);\n \n    --  and typ'Wide_Width expands into:\n \n    --    Result_Type (Wide_Width_Wide_Character (\n    --      Wide_Character (typ'First),\n    --      Wide_Character (typ'Last));\n-   --      Wide_Character_Encoding_Method);\n \n    --  and typ'Wide_Wide_Width expands into\n \n    --    Result_Type (Wide_Wide_Width_Wide_Character (\n    --      Wide_Character (typ'First),\n    --      Wide_Character (typ'Last));\n-   --      Wide_Character_Encoding_Method);\n \n    --  For types derived from Wide_Wide_Character, typ'Width expands into\n \n    --    Result_Type (Width_Wide_Wide_Character (\n    --      Wide_Wide_Character (typ'First),\n    --      Wide_Wide_Character (typ'Last),\n-   --      Wide_Character_Encoding_Method);\n \n    --  and typ'Wide_Width expands into:\n \n    --    Result_Type (Wide_Width_Wide_Wide_Character (\n    --      Wide_Wide_Character (typ'First),\n    --      Wide_Wide_Character (typ'Last));\n-   --      Wide_Character_Encoding_Method);\n \n    --  and typ'Wide_Wide_Width expands into\n \n    --    Result_Type (Wide_Wide_Width_Wide_Wide_Char (\n    --      Wide_Wide_Character (typ'First),\n    --      Wide_Wide_Character (typ'Last));\n-   --      Wide_Character_Encoding_Method);\n \n    --  For real types, typ'Width and typ'Wide_[Wide_]Width expand into\n \n@@ -914,14 +888,6 @@ package body Exp_Imgv is\n                    Prefix => New_Reference_To (Ptyp, Loc),\n                    Attribute_Name => Name_Last))));\n \n-         --  For enumeration'Wide_[Wide_]Width, add encoding method parameter\n-\n-         if Attr /= Normal then\n-            Append_To (Arglist,\n-              Make_Integer_Literal (Loc,\n-                Intval => Int (Wide_Character_Encoding_Method)));\n-         end if;\n-\n          Rewrite (N,\n            Convert_To (Typ,\n              Make_Function_Call (Loc,\n@@ -945,17 +911,6 @@ package body Exp_Imgv is\n             Prefix => New_Reference_To (Ptyp, Loc),\n             Attribute_Name => Name_Last)));\n \n-      --  For Wide_[Wide_]Character'Width, add encoding method parameter\n-\n-      if (Rtyp = Standard_Wide_Character\n-           or else\n-          Rtyp = Standard_Wide_Wide_Character)\n-        and then Attr /= Normal then\n-         Append_To (Arglist,\n-           Make_Integer_Literal (Loc,\n-             Intval => Int (Wide_Character_Encoding_Method)));\n-      end if;\n-\n       Rewrite (N,\n         Convert_To (Typ,\n           Make_Function_Call (Loc,"}, {"sha": "905fe7e42a41476b6ea6410307425973c49541df", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 90, "deletions": 48, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -592,12 +592,12 @@ package body Exp_Strm is\n \n       --  Call the function, and do an unchecked conversion of the result\n       --  to the actual type of the prefix. If the target is a discriminant,\n-      --  set target type to force a constraint check (13.13.2 (35)).\n+      --  and we are in the body of the default implementation of a 'Read\n+      --  attribute, set target type to force a constraint check (13.13.2(35)).\n \n-      if Nkind (Targ) = N_Selected_Component\n-        and then Present (Entity (Selector_Name (Targ)))\n-        and then Ekind (Entity (Selector_Name (Targ)))\n-          = E_Discriminant\n+      if Nkind (Targ) = N_Identifier\n+        and then Is_Internal_Name (Chars (Targ))\n+        and then Is_TSS (Scope (Entity (Targ)), TSS_Stream_Read)\n       then\n          Res :=\n            Unchecked_Convert_To (Base_Type (P_Type),\n@@ -786,23 +786,41 @@ package body Exp_Strm is\n       Decl : out Node_Id;\n       Pnam : out Entity_Id)\n    is\n-      Stms : List_Id;\n+      Out_Formal : Node_Id;\n+      --  Expression denoting the out formal parameter\n+\n+      Dcls : constant List_Id := New_List;\n+      --  Declarations for the 'Read body\n+\n+      Stms : List_Id := New_List;\n       --  Statements for the 'Read body\n \n+      Disc : Entity_Id;\n+      --  Entity of the discriminant being processed\n+\n+      Tmp_For_Disc : Entity_Id;\n+      --  Temporary object used to read the value of Disc\n+\n+      Tmps_For_Discs : constant List_Id := New_List;\n+      --  List of object declarations for temporaries holding the read values\n+      --  for the discriminants.\n+\n+      Cstr : constant List_Id := New_List;\n+      --  List of constraints to be applied on temporary record\n+\n+      Discriminant_Checks : constant List_Id := New_List;\n+      --  List of discriminant checks to be performed if the actual object\n+      --  is constrained.\n+\n       Tmp : constant Entity_Id := Make_Defining_Identifier (Loc, Name_V);\n-      --  Temporary, must hide formal (assignments to components of the\n+      --  Temporary record must hide formal (assignments to components of the\n       --  record are always generated with V as the identifier for the record).\n \n-      Cstr : List_Id;\n-      --  List of constraints to be applied on temporary\n-\n-      Disc     : Entity_Id;\n-      Disc_Ref : Node_Id;\n-      Block    : Node_Id;\n+      Constrained_Stms : List_Id := New_List;\n+      --  Statements within the block where we have the constrained temporary\n \n    begin\n-      Stms := New_List;\n-      Cstr := New_List;\n+\n       Disc := First_Discriminant (Typ);\n \n       --  A mutable type cannot be a tagged type, so we generate a new name\n@@ -812,33 +830,50 @@ package body Exp_Strm is\n         Make_Defining_Identifier (Loc,\n           Chars => Make_TSS_Name_Local (Typ, TSS_Stream_Read));\n \n+      Out_Formal :=\n+        Make_Selected_Component (Loc,\n+          Prefix => New_Occurrence_Of (Pnam, Loc),\n+          Selector_Name => Make_Identifier (Loc, Name_V));\n+\n       --  Generate Reads for the discriminants of the type. The discriminants\n       --  need to be read before the rest of the components, so that\n-      --  variants are initialized correctly.\n+      --  variants are initialized correctly. The discriminants must be read\n+      --  into temporary variables so an incomplete Read (interrupted by an\n+      --  exception, for example) does not alter the passed object.\n \n       while Present (Disc) loop\n-         Disc_Ref :=\n-           Make_Selected_Component (Loc,\n-             Prefix        => Make_Selected_Component (Loc,\n-                                Prefix => New_Occurrence_Of (Pnam, Loc),\n-                                Selector_Name =>\n-                                  Make_Identifier (Loc, Name_V)),\n-             Selector_Name => New_Occurrence_Of (Disc, Loc));\n+         Tmp_For_Disc := Make_Defining_Identifier (Loc,\n+                           New_External_Name (Chars (Disc), \"D\"));\n \n-         Set_Assignment_OK (Disc_Ref);\n+         Append_To (Tmps_For_Discs,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Tmp_For_Disc,\n+             Object_Definition   => New_Occurrence_Of (Etype (Disc), Loc)));\n+         Set_No_Initialization (Last (Tmps_For_Discs));\n \n          Append_To (Stms,\n            Make_Attribute_Reference (Loc,\n              Prefix => New_Occurrence_Of (Etype (Disc), Loc),\n-               Attribute_Name => Name_Read,\n-               Expressions => New_List (\n-                 Make_Identifier (Loc, Name_S),\n-                 Disc_Ref)));\n+             Attribute_Name => Name_Read,\n+             Expressions => New_List (\n+               Make_Identifier (Loc, Name_S),\n+               New_Occurrence_Of (Tmp_For_Disc, Loc))));\n \n          Append_To (Cstr,\n            Make_Discriminant_Association (Loc,\n              Selector_Names => New_List (New_Occurrence_Of (Disc, Loc)),\n-             Expression     => New_Copy_Tree (Disc_Ref)));\n+             Expression     => New_Occurrence_Of (Tmp_For_Disc, Loc)));\n+\n+         Append_To (Discriminant_Checks,\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Tmp_For_Disc, Loc),\n+                 Right_Opnd =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix => New_Copy_Tree (Out_Formal),\n+                     Selector_Name => New_Occurrence_Of (Disc, Loc))),\n+             Reason => CE_Discriminant_Check_Failed));\n          Next_Discriminant (Disc);\n       end loop;\n \n@@ -854,27 +889,33 @@ package body Exp_Strm is\n       --  prior to being initialized. To this effect, we wrap the component\n       --  assignments in a block where V is a constrained temporary.\n \n-      Block :=\n+      Append_To (Dcls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Tmp,\n+          Object_Definition   =>\n+            Make_Subtype_Indication (Loc,\n+              Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+              Constraint =>\n+                Make_Index_Or_Discriminant_Constraint (Loc,\n+                  Constraints => Cstr))));\n+\n+      Constrained_Stms := Statements (Handled_Statement_Sequence (Decl));\n+      Append_To (Stms,\n         Make_Block_Statement (Loc,\n-          Declarations => New_List (\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Tmp,\n-             Object_Definition   =>\n-               Make_Subtype_Indication (Loc,\n-                 Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n-                 Constraint =>\n-                   Make_Index_Or_Discriminant_Constraint (Loc,\n-                     Constraints => Cstr)))),\n-          Handled_Statement_Sequence =>\n-            Handled_Statement_Sequence (Decl));\n-\n-      Append_To (Stms, Block);\n-\n-      Append_To (Statements (Handled_Statement_Sequence (Block)),\n+          Declarations => Dcls,\n+          Handled_Statement_Sequence => Parent (Constrained_Stms)));\n+\n+      Append_To (Constrained_Stms,\n+        Make_Implicit_If_Statement (Pnam,\n+          Condition =>\n+            Make_Attribute_Reference (Loc,\n+              Prefix => New_Copy_Tree (Out_Formal),\n+              Attribute_Name => Name_Constrained),\n+          Then_Statements => Discriminant_Checks));\n+\n+      Append_To (Constrained_Stms,\n         Make_Assignment_Statement (Loc,\n-          Name => Make_Selected_Component (Loc,\n-                    Prefix => New_Occurrence_Of (Pnam, Loc),\n-                    Selector_Name => Make_Identifier (Loc, Name_V)),\n+          Name => Out_Formal,\n           Expression => Make_Identifier (Loc, Name_V)));\n \n       if Is_Unchecked_Union (Typ) then\n@@ -890,6 +931,7 @@ package body Exp_Strm is\n                Reason => PE_Unchecked_Union_Restriction));\n       end if;\n \n+      Set_Declarations (Decl, Tmps_For_Discs);\n       Set_Handled_Statement_Sequence (Decl,\n         Make_Handled_Sequence_Of_Statements (Loc,\n           Statements => Stms));"}, {"sha": "78bc1825a75bf7c5f797023b77086d3fd146097a", "filename": "gcc/ada/exp_tss.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_tss.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_tss.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -235,11 +235,7 @@ package body Exp_Tss is\n \n    function Make_Init_Proc_Name (Typ : Entity_Id) return Name_Id is\n    begin\n-      Get_Name_String (Chars (Typ));\n-      Name_Len := Name_Len + 2;\n-      Name_Buffer (Name_Len - 1) := TSS_Init_Proc (1);\n-      Name_Buffer (Name_Len)     := TSS_Init_Proc (2);\n-      return Name_Find;\n+      return Make_TSS_Name (Typ, TSS_Init_Proc);\n    end Make_Init_Proc_Name;\n \n    -------------------------\n@@ -252,10 +248,10 @@ package body Exp_Tss is\n    is\n    begin\n       Get_Name_String (Chars (Typ));\n-      Add_Char_To_Name_Buffer (Nam (1));\n-      Add_Char_To_Name_Buffer (Nam (2));\n       Add_Char_To_Name_Buffer ('_');\n       Add_Nat_To_Name_Buffer (Increment_Serial_Number);\n+      Add_Char_To_Name_Buffer (Nam (1));\n+      Add_Char_To_Name_Buffer (Nam (2));\n       return Name_Find;\n    end Make_TSS_Name_Local;\n "}, {"sha": "8be57a419f9a08770cc3e14ad938bdeaa57d7114", "filename": "gcc/ada/exp_tss.ads", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_tss.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fexp_tss.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -64,9 +64,13 @@ package Exp_Tss is\n    -- TSS Naming --\n    ----------------\n \n-   --  A TSS is identified by its Chars name. The name has the form typXY,\n-   --  where typ is the type name, and XY are two characters that identify\n-   --  the particular TSS routine, using the following codes:\n+   --  A TSS is identified by its Chars name. The name has the form typXY or\n+   --  typ_<serial>XY, where typ is the type name, and XY are two characters\n+   --  that identify the particular TSS routine. A unique serial number is\n+   --  included for the case where several local instances of the same TSS\n+   --  must be generated (see discussion under Make_TSS_Name_Local).\n+\n+   --  The following codes are used to denote TSSs:\n \n    --  Note: When making additions to this list, update the list in snames.adb\n \n@@ -126,10 +130,11 @@ package Exp_Tss is\n    function Make_TSS_Name_Local\n      (Typ : Entity_Id;\n       Nam : TSS_Name_Type) return Name_Id;\n-   --  Similar to the above call, but a string of the form _nnn is appended\n-   --  to the name, where nnn is a unique serial number. This is used when\n-   --  multiple instances of the same TSS routine may be generated in the\n-   --  same scope (see also discussion above of current limitations).\n+   --  Similar to the above call, but a string of the form _nnn is inserted\n+   --  before the TSS code suffix, where nnn is a unique serial number. This\n+   --  is used when multiple instances of the same TSS routine may be\n+   --  generated in the same scope (see also discussion above of current\n+   --  limitations).\n \n    function Make_Init_Proc_Name (Typ : Entity_Id) return Name_Id;\n    --  Version for init procs, same as Make_TSS_Name (Typ, TSS_Init_Proc)"}, {"sha": "cb4c53281354921438d0dea4e009316dcdf4fdca", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 150, "deletions": 105, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1380,17 +1380,17 @@ package body Freeze is\n       Atype  : Entity_Id;\n \n       procedure Check_Current_Instance (Comp_Decl : Node_Id);\n-      --  Check that an Access or Unchecked_Access attribute with\n-      --  a prefix which is the current instance type can only be\n-      --  applied when the type is limited.\n+      --  Check that an Access or Unchecked_Access attribute with a prefix\n+      --  which is the current instance type can only be applied when the type\n+      --  is limited.\n \n       function After_Last_Declaration return Boolean;\n       --  If Loc is a freeze_entity that appears after the last declaration\n       --  in the scope, inhibit error messages on late completion.\n \n       procedure Freeze_Record_Type (Rec : Entity_Id);\n-      --  Freeze each component, handle some representation clauses, and\n-      --  freeze primitive operations if this is a tagged type.\n+      --  Freeze each component, handle some representation clauses, and freeze\n+      --  primitive operations if this is a tagged type.\n \n       ----------------------------\n       -- After_Last_Declaration --\n@@ -3010,26 +3010,40 @@ package body Freeze is\n          elsif Is_Integer_Type (E) then\n             Adjust_Esize_For_Alignment (E);\n \n-         elsif Is_Access_Type (E)\n-           and then No (Associated_Storage_Pool (E))\n-         then\n-            Check_Restriction (No_Standard_Storage_Pools, E);\n+         elsif Is_Access_Type (E) then\n+\n+            --  Check restriction for standard storage pool\n+\n+            if No (Associated_Storage_Pool (E)) then\n+               Check_Restriction (No_Standard_Storage_Pools, E);\n+            end if;\n+\n+            --  Deal with error message for pure access type. This is not an\n+            --  error in Ada 2005 if there is no pool (see AI-366).\n+\n+            if Is_Pure_Unit_Access_Type (E)\n+              and then (Ada_Version < Ada_05\n+                        or else not No_Pool_Assigned (E))\n+            then\n+               Error_Msg_N (\"named access type not allowed in pure unit\", E);\n+            end if;\n          end if;\n \n+         --  Case of composite types\n+\n          if Is_Composite_Type (E) then\n \n-            --  AI-117 requires that all new primitives of a tagged type\n-            --  must inherit the convention of the full view of the type.\n-            --  Inherited and overriding operations are defined to inherit\n-            --  the convention of their parent or overridden subprogram\n-            --  (also specified in AI-117), and that will have occurred\n-            --  earlier (in Derive_Subprogram and New_Overloaded_Entity).\n-            --  Here we set the convention of primitives that are still\n-            --  convention Ada, which will ensure that any new primitives\n-            --  inherit the type's convention. Class-wide types can have\n-            --  a foreign convention inherited from their specific type,\n-            --  but are excluded from this since they don't have any\n-            --  associated primitives.\n+            --  AI-117 requires that all new primitives of a tagged type must\n+            --  inherit the convention of the full view of the type. Inherited\n+            --  and overriding operations are defined to inherit the convention\n+            --  of their parent or overridden subprogram (also specified in\n+            --  AI-117), and that will have occurred earlier (in\n+            --  Derive_Subprogram and New_Overloaded_Entity). Here we set the\n+            --  convention of primitives that are still convention Ada, which\n+            --  will ensure that any new primitives inherit the type's\n+            --  convention. Class-wide types can have a foreign convention\n+            --  inherited from their specific type, but are excluded from this\n+            --  since they don't have any associated primitives.\n \n             if Is_Tagged_Type (E)\n               and then not Is_Class_Wide_Type (E)\n@@ -3057,19 +3071,41 @@ package body Freeze is\n            and then not Is_Class_Wide_Type (E)\n          then\n             declare\n-               Prim_List : constant Elist_Id := Primitive_Operations (E);\n+               Prim_List : Elist_Id;\n                Prim      : Elmt_Id;\n                Ent       : Entity_Id;\n \n             begin\n+               --  Ada 2005 (AI-345): In case of concurrent type generate\n+               --  reference to the wrapper that allow us to dispatch calls\n+               --  through their implemented abstract interface types.\n+\n+               --  The check for Present here is to protect against previously\n+               --  reported critical errors.\n+\n+               if Is_Concurrent_Type (E)\n+                 and then Present (Corresponding_Record_Type (E))\n+               then\n+                  pragma Assert (not Is_Empty_Elmt_List\n+                                       (Abstract_Interfaces\n+                                        (Corresponding_Record_Type (E))));\n+\n+                  Prim_List := Primitive_Operations\n+                                (Corresponding_Record_Type (E));\n+               else\n+                  Prim_List := Primitive_Operations (E);\n+               end if;\n+\n+               --  Loop to generate references for primitive operations\n+\n                Prim := First_Elmt (Prim_List);\n                while Present (Prim) loop\n                   Ent := Node (Prim);\n \n-                  --  If the operation is derived, get the original for\n-                  --  cross-reference purposes (it is the original for\n-                  --  which we want the xref, and for which the comes\n-                  --  from source test needs to be performed).\n+                  --  If the operation is derived, get the original for cross-\n+                  --  reference purposes (it is the original for which we want\n+                  --  the xref, and for which the comes from source test needs\n+                  --  to be performed).\n \n                   while Present (Alias (Ent)) loop\n                      Ent := Alias (Ent);\n@@ -3337,10 +3373,10 @@ package body Freeze is\n    --  Start of processing for Freeze_Expression\n \n    begin\n-      --  Immediate return if freezing is inhibited. This flag is set by\n-      --  the analyzer to stop freezing on generated expressions that would\n-      --  cause freezing if they were in the source program, but which are\n-      --  not supposed to freeze, since they are created.\n+      --  Immediate return if freezing is inhibited. This flag is set by the\n+      --  analyzer to stop freezing on generated expressions that would cause\n+      --  freezing if they were in the source program, but which are not\n+      --  supposed to freeze, since they are created.\n \n       if Must_Not_Freeze (N) then\n          return;\n@@ -3468,12 +3504,12 @@ package body Freeze is\n \n          case Nkind (Parent_P) is\n \n-            --  A special test for the exception of (RM 13.14(8)) for the\n-            --  case of per-object expressions (RM 3.8(18)) occurring in a\n-            --  component definition or a discrete subtype definition. Note\n-            --  that we test for a component declaration which includes both\n-            --  cases we are interested in, and furthermore the tree does not\n-            --  have explicit nodes for either of these two constructs.\n+            --  A special test for the exception of (RM 13.14(8)) for the case\n+            --  of per-object expressions (RM 3.8(18)) occurring in component\n+            --  definition or a discrete subtype definition. Note that we test\n+            --  for a component declaration which includes both cases we are\n+            --  interested in, and furthermore the tree does not have explicit\n+            --  nodes for either of these two constructs.\n \n             when N_Component_Declaration =>\n \n@@ -3504,9 +3540,9 @@ package body Freeze is\n                   end if;\n                end if;\n \n-            --  If we have an enumeration literal that appears as the\n-            --  choice in the aggregate of an enumeration representation\n-            --  clause, then freezing does not occur (RM 13.14(10)).\n+            --  If we have an enumeration literal that appears as the choice in\n+            --  the aggregate of an enumeration representation clause, then\n+            --  freezing does not occur (RM 13.14(10)).\n \n             when N_Enumeration_Representation_Clause =>\n \n@@ -3545,11 +3581,11 @@ package body Freeze is\n \n             when N_Handled_Sequence_Of_Statements =>\n \n-               --  An exception occurs when the sequence of statements is\n-               --  for an expander generated body that did not do the usual\n-               --  freeze all operation. In this case we usually want to\n-               --  freeze outside this body, not inside it, and we skip\n-               --  past the subprogram body that we are inside.\n+               --  An exception occurs when the sequence of statements is for\n+               --  an expander generated body that did not do the usual freeze\n+               --  all operation. In this case we usually want to freeze\n+               --  outside this body, not inside it, and we skip past the\n+               --  subprogram body that we are inside.\n \n                if In_Exp_Body (Parent_P) then\n \n@@ -3631,11 +3667,11 @@ package body Freeze is\n \n             --  Note: The N_Loop_Statement is a special case. A type that\n             --  appears in the source can never be frozen in a loop (this\n-            --  occurs only because of a loop expanded by the expander),\n-            --  so we keep on going. Otherwise we terminate the search.\n-            --  Same is true of any entity which comes from source. (if they\n-            --  have a predefined type, that type does not appear to come\n-            --  from source, but the entity should not be frozen here).\n+            --  occurs only because of a loop expanded by the expander), so we\n+            --  keep on going. Otherwise we terminate the search. Same is true\n+            --  of any entity which comes from source. (if they have a\n+            --  predefined type, that type does not appear to come from source,\n+            --  but the entity should not be frozen here).\n \n             when N_Loop_Statement =>\n                exit when not Comes_From_Source (Etype (N))\n@@ -3653,17 +3689,17 @@ package body Freeze is\n          P := Parent_P;\n       end loop;\n \n-      --  If the expression appears in a record or an initialization\n-      --  procedure, the freeze nodes are collected and attached to\n-      --  the current scope, to be inserted and analyzed on exit from\n-      --  the scope, to insure that generated entities appear in the\n-      --  correct scope. If the expression is a default for a discriminant\n-      --  specification, the scope is still void. The expression can also\n-      --  appear in the discriminant part of a private or concurrent type.\n+      --  If the expression appears in a record or an initialization procedure,\n+      --  the freeze nodes are collected and attached to the current scope, to\n+      --  be inserted and analyzed on exit from the scope, to insure that\n+      --  generated entities appear in the correct scope. If the expression is\n+      --  a default for a discriminant specification, the scope is still void.\n+      --  The expression can also appear in the discriminant part of a private\n+      --  or concurrent type.\n \n       --  If the expression appears in a constrained subcomponent of an\n-      --  enclosing record declaration, the freeze nodes must be attached\n-      --  to the outer record type so they can eventually be placed in the\n+      --  enclosing record declaration, the freeze nodes must be attached to\n+      --  the outer record type so they can eventually be placed in the\n       --  enclosing declaration list.\n \n       --  The other case requiring this special handling is if we are in\n@@ -3760,15 +3796,15 @@ package body Freeze is\n    -- Freeze_Fixed_Point_Type --\n    -----------------------------\n \n-   --  Certain fixed-point types and subtypes, including implicit base\n-   --  types and declared first subtypes, have not yet set up a range.\n-   --  This is because the range cannot be set until the Small and Size\n-   --  values are known, and these are not known till the type is frozen.\n+   --  Certain fixed-point types and subtypes, including implicit base types\n+   --  and declared first subtypes, have not yet set up a range. This is\n+   --  because the range cannot be set until the Small and Size values are\n+   --  known, and these are not known till the type is frozen.\n \n-   --  To signal this case, Scalar_Range contains an unanalyzed syntactic\n-   --  range whose bounds are unanalyzed real literals. This routine will\n-   --  recognize this case, and transform this range node into a properly\n-   --  typed range with properly analyzed and resolved values.\n+   --  To signal this case, Scalar_Range contains an unanalyzed syntactic range\n+   --  whose bounds are unanalyzed real literals. This routine will recognize\n+   --  this case, and transform this range node into a properly typed range\n+   --  with properly analyzed and resolved values.\n \n    procedure Freeze_Fixed_Point_Type (Typ : Entity_Id) is\n       Rng   : constant Node_Id    := Scalar_Range (Typ);\n@@ -3892,10 +3928,10 @@ package body Freeze is\n             end if;\n \n             --  Compute the fudged bounds. If the number is a model number,\n-            --  then we do nothing to include it, but we are allowed to\n-            --  backoff to the next adjacent model number when we exclude\n-            --  it. If it is not a model number then we straddle the two\n-            --  values with the model numbers on either side.\n+            --  then we do nothing to include it, but we are allowed to backoff\n+            --  to the next adjacent model number when we exclude it. If it is\n+            --  not a model number then we straddle the two values with the\n+            --  model numbers on either side.\n \n             Model_Num := UR_Trunc (Loval / Small) * Small;\n \n@@ -4028,28 +4064,26 @@ package body Freeze is\n                   Actual_Hi   := Hival_Incl_EP;\n                end if;\n \n-               --  One pathological case: normally we never fudge a low\n-               --  bound down, since it would seem to increase the size\n-               --  (if it has any effect), but for ranges containing a\n-               --  single value, or no values, the high bound can be\n-               --  small too large. Consider:\n+               --  One pathological case: normally we never fudge a low bound\n+               --  down, since it would seem to increase the size (if it has\n+               --  any effect), but for ranges containing single value, or no\n+               --  values, the high bound can be small too large. Consider:\n \n                --    type t is delta 2.0**(-14)\n                --      range 131072.0 .. 0;\n \n-               --  That lower bound is *just* outside the range of 32\n-               --  bits, and does need fudging down in this case. Note\n-               --  that the bounds will always have crossed here, since\n-               --  the high bound will be fudged down if necessary, as\n-               --  in the case of:\n+               --  That lower bound is *just* outside the range of 32 bits, and\n+               --  does need fudging down in this case. Note that the bounds\n+               --  will always have crossed here, since the high bound will be\n+               --  fudged down if necessary, as in the case of:\n \n                --    type t is delta 2.0**(-14)\n                --      range 131072.0 .. 131072.0;\n \n-               --  So we can detect the situation by looking for crossed\n-               --  bounds, and if the bounds are crossed, and the low\n-               --  bound is greater than zero, we will always back it\n-               --  off by small, since this is completely harmless.\n+               --  So we detect the situation by looking for crossed bounds,\n+               --  and if the bounds are crossed, and the low bound is greater\n+               --  than zero, we will always back it off by small, since this\n+               --  is completely harmless.\n \n                if Actual_Lo > Actual_Hi then\n                   if UR_Is_Positive (Actual_Lo) then\n@@ -4119,9 +4153,9 @@ package body Freeze is\n          Adjust_Esize_For_Alignment (Typ);\n       end if;\n \n-      --  If we have a base type, then expand the bounds so that they\n-      --  extend to the full width of the allocated size in bits, to\n-      --  avoid junk range checks on intermediate computations.\n+      --  If we have a base type, then expand the bounds so that they extend to\n+      --  the full width of the allocated size in bits, to avoid junk range\n+      --  checks on intermediate computations.\n \n       if Base_Type (Typ) = Typ then\n          Set_Realval (Lo, -(Small * (Uint_2 ** (Actual_Size - 1))));\n@@ -4135,9 +4169,9 @@ package body Freeze is\n       Set_Analyzed (Lo, False);\n       Analyze (Lo);\n \n-      --  Resolve with universal fixed if the base type, and the base\n-      --  type if it is a subtype. Note we can't resolve the base type\n-      --  with itself, that would be a reference before definition.\n+      --  Resolve with universal fixed if the base type, and the base type if\n+      --  it is a subtype. Note we can't resolve the base type with itself,\n+      --  that would be a reference before definition.\n \n       if Typ = Btyp then\n          Resolve (Lo, Universal_Fixed);\n@@ -4360,10 +4394,10 @@ package body Freeze is\n    begin\n       Ensure_Type_Is_SA (Etype (E));\n \n-      --  Reset True_Constant flag, since something strange is going on\n-      --  with the scoping here, and our simple value tracing may not\n-      --  be sufficient for this indication to be reliable. We kill the\n-      --  Constant_Value indication for the same reason.\n+      --  Reset True_Constant flag, since something strange is going on with\n+      --  the scoping here, and our simple value tracing may not be sufficient\n+      --  for this indication to be reliable. We kill the Constant_Value\n+      --  indication for the same reason.\n \n       Set_Is_True_Constant (E, False);\n       Set_Current_Value    (E, Empty);\n@@ -4411,9 +4445,9 @@ package body Freeze is\n       --  Reset the Pure indication on an imported subprogram unless an\n       --  explicit Pure_Function pragma was present. We do this because\n       --  otherwise it is an insidious error to call a non-pure function\n-      --  from a pure unit and have calls mysteriously optimized away.\n-      --  What happens here is that the Import can bypass the normal\n-      --  check to ensure that pure units call only pure subprograms.\n+      --  from pure unit and have calls mysteriously optimized away. What\n+      --  happens here is that the Import can bypass the normal check to\n+      --  ensure that pure units call only pure subprograms.\n \n       if Is_Imported (E)\n         and then Is_Pure (E)\n@@ -4464,8 +4498,8 @@ package body Freeze is\n                null;\n \n             --  If the return type is generic, we have emitted a warning\n-            --  earlier on, and there is nothing else to check here.\n-            --  Specific instantiations may lead to erroneous behavior.\n+            --  earlier on, and there is nothing else to check here. Specific\n+            --  instantiations may lead to erroneous behavior.\n \n             elsif Is_Generic_Type (Etype (E)) then\n                null;\n@@ -4483,8 +4517,8 @@ package body Freeze is\n          end if;\n \n          --  If any of the formals for an exported foreign convention\n-         --  subprogram have defaults, then emit an appropriate warning\n-         --  since this is odd (default cannot be used from non-Ada code)\n+         --  subprogram have defaults, then emit an appropriate warning since\n+         --  this is odd (default cannot be used from non-Ada code)\n \n          if Is_Exported (E) then\n             F := First_Formal (E);\n@@ -4520,6 +4554,17 @@ package body Freeze is\n             end loop;\n          end if;\n       end if;\n+\n+      --  Pragma Inline_Always is disallowed for dispatching subprograms\n+      --  because the address of such subprograms is saved in the dispatch\n+      --  table to support dispatching calls, and dispatching calls cannot\n+      --  be inlined. This is consistent with the restriction against using\n+      --  'Access or 'Address on an Inline_Always subprogram.\n+\n+      if Is_Dispatching_Operation (E) and then Is_Always_Inlined (E) then\n+         Error_Msg_N\n+           (\"pragma Inline_Always not allowed for dispatching subprograms\", E);\n+      end if;\n    end Freeze_Subprogram;\n \n    ----------------------\n@@ -4861,9 +4906,9 @@ package body Freeze is\n          return;\n       end if;\n \n-      --  We only give the warning for non-imported entities of a type\n-      --  for which a non-null base init proc is defined (or for access\n-      --  types which have implicit null initialization).\n+      --  We only give the warning for non-imported entities of a type for\n+      --  which a non-null base init proc is defined (or for access types which\n+      --  have implicit null initialization).\n \n       if Present (Expr)\n         and then (Has_Non_Null_Base_Init_Proc (Typ)"}, {"sha": "35ea324d609f51001e57973e9e823e02733e9958", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -354,8 +354,10 @@ package body Ch10 is\n       elsif Token = Tok_Separate then\n          Set_Unit (Comp_Unit_Node, P_Subunit);\n \n-      elsif Token = Tok_Procedure\n-        or else Token = Tok_Function\n+      elsif Token = Tok_Function\n+        or else Token = Tok_Not\n+        or else Token = Tok_Overriding\n+        or else Token = Tok_Procedure\n       then\n          Set_Unit (Comp_Unit_Node, P_Subprogram (Pf_Decl_Gins_Pbod_Rnam));\n "}, {"sha": "0f35d836258a08ed0b62df92259cbbe44ebae456", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -898,11 +898,13 @@ package body Ch12 is\n \n    --  SUBPROGRAM_DEFAULT ::= DEFAULT_NAME | <>\n \n-   --  DEFAULT_NAME ::= NAME\n+   --  DEFAULT_NAME ::= NAME | null\n \n    --  The caller has checked that the initial tokens are WITH FUNCTION or\n    --  WITH PROCEDURE, and the initial WITH has been scanned out.\n \n+   --  A null default is an Ada 2005 feature.\n+\n    --  Error recovery: cannot raise Error_Resync\n \n    function P_Formal_Subprogram_Declaration return Node_Id is\n@@ -940,6 +942,22 @@ package body Ch12 is\n             Scan; -- past <>\n             T_Semicolon;\n \n+         elsif Token = Tok_Null then\n+            if Ada_Version < Ada_05 then\n+               Error_Msg_SP\n+                 (\"null default subprograms are an Ada 2005 extension\");\n+               Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+            end if;\n+\n+            if Nkind (Spec_Node) = N_Procedure_Specification then\n+               Set_Null_Present (Spec_Node);\n+            else\n+               Error_Msg_SP (\"only procedures can be null\");\n+            end if;\n+\n+            Scan;  --  past NULL\n+            T_Semicolon;\n+\n          else\n             Set_Default_Name (Def_Node, P_Name);\n             T_Semicolon;"}, {"sha": "8aa4fe877282de04076a17b9ba1015f3d351ae1c", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 89, "deletions": 4, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,6 +39,7 @@ package body Ch6 is\n    function P_Defining_Operator_Symbol   return Node_Id;\n \n    procedure Check_Junk_Semicolon_Before_Return;\n+\n    --  Check for common error of junk semicolon before RETURN keyword of\n    --  function specification. If present, skip over it with appropriate\n    --  error message, leaving Scan_Ptr pointing to the RETURN after. This\n@@ -58,7 +59,7 @@ package body Ch6 is\n \n          if Token = Tok_Return then\n             Restore_Scan_State (Scan_State);\n-            Error_Msg_SC (\"Unexpected semicolon ignored\");\n+            Error_Msg_SC (\"unexpected semicolon ignored\");\n             Scan; -- rescan past junk semicolon\n \n          else\n@@ -109,6 +110,13 @@ package body Ch6 is\n    --  | function DEFINING_DESIGNATOR is\n    --      new generic_function_NAME [GENERIC_ACTUAL_PART];\n \n+   --  NULL_PROCEDURE_DECLARATION ::=\n+   --    SUBPROGRAM_SPECIFICATION is null;\n+\n+   --  Null procedures are an Ada 2005 feature. A null procedure declaration\n+   --  is classified as a basic declarative item, but it is parsed here, with\n+   --  other subprogram constructs.\n+\n    --  The value in Pf_Flags indicates which of these possible declarations\n    --  is acceptable to the caller:\n \n@@ -123,7 +131,8 @@ package body Ch6 is\n    --  context is issued. The only possible values for Pf_Flags are those\n    --  defined as constants in the Par package.\n \n-   --  The caller has checked that the initial token is FUNCTION or PROCEDURE\n+   --  The caller has checked that the initial token is FUNCTION, PROCEDURE,\n+   --  NOT or OVERRIDING.\n \n    --  Error recovery: cannot raise Error_Resync\n \n@@ -143,6 +152,13 @@ package body Ch6 is\n       Func        : Boolean;\n       Scan_State  : Saved_Scan_State;\n \n+      --  Flags for optional overriding indication. Two flags are needed,\n+      --  to distinguish positive and negative overriding indicators from\n+      --  the absence of any indicator.\n+\n+      Is_Overriding  : Boolean := False;\n+      Not_Overriding : Boolean := False;\n+\n    begin\n       --  Set up scope stack entry. Note that the Labl field will be set later\n \n@@ -154,6 +170,41 @@ package body Ch6 is\n       Scope.Table (Scope.Last).Ecol := Start_Column;\n       Scope.Table (Scope.Last).Lreq := False;\n \n+      --  Ada2005: scan leading overriding indicator.\n+\n+      if Token = Tok_Not then\n+         Scan;  -- past NOT\n+\n+         if Token = Tok_Overriding then\n+            Scan;  --  past OVERRIDING\n+            Not_Overriding := True;\n+         else\n+            Error_Msg_SC (\"OVERRIDING expected!\");\n+         end if;\n+\n+      elsif Token = Tok_Overriding then\n+         Scan;  --  past OVERRIDING\n+         Is_Overriding := True;\n+      end if;\n+\n+      if (Is_Overriding or else Not_Overriding) then\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_SP (\" overriding indicator is an Ada 2005 extension\");\n+            Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+\n+         --  An overriding indicator is allowed for subprogram declarations,\n+         --  bodies, renamings, stubs, and instantiations.\n+\n+         elsif Pf_Flags /= Pf_Decl_Gins_Pbod_Rnam_Stub then\n+            Error_Msg_SC (\"overriding indicator not allowed here!\");\n+\n+         elsif Token /= Tok_Function\n+           and then Token /= Tok_Procedure\n+         then\n+            Error_Msg_SC (\"FUNCTION or PROCEDURE expected!\");\n+         end if;\n+      end if;\n+\n       Func := (Token = Tok_Function);\n       Fproc_Sloc := Token_Ptr;\n       Scan; -- past FUNCTION or PROCEDURE\n@@ -202,7 +253,7 @@ package body Ch6 is\n \n       if Token = Tok_Is then\n          Save_Scan_State (Scan_State); -- at the IS\n-         T_Is; -- checks for redundant IS's\n+         T_Is; -- checks for redundant IS\n \n          if Token = Tok_New then\n             if not Pf_Flags.Gins then\n@@ -223,6 +274,14 @@ package body Ch6 is\n             Set_Generic_Associations (Inst_Node, P_Generic_Actual_Part_Opt);\n             TF_Semicolon;\n             Pop_Scope_Stack; -- Don't need scope stack entry in this case\n+\n+            if Is_Overriding then\n+               Set_Must_Override (Inst_Node);\n+\n+            elsif Not_Overriding then\n+               Set_Must_Not_Override (Inst_Node);\n+            end if;\n+\n             return Inst_Node;\n \n          else\n@@ -291,6 +350,13 @@ package body Ch6 is\n       Set_Defining_Unit_Name (Specification_Node, Name_Node);\n       Set_Parameter_Specifications (Specification_Node, Fpart_List);\n \n+      if Is_Overriding then\n+         Set_Must_Override (Specification_Node);\n+\n+      elsif Not_Overriding then\n+         Set_Must_Not_Override (Specification_Node);\n+      end if;\n+\n       --  Error check: barriers not allowed on protected functions/procedures\n \n       if Token = Tok_When then\n@@ -384,6 +450,25 @@ package body Ch6 is\n                TF_Semicolon;\n                return Absdec_Node;\n \n+            --  Ada 2005 (AI-248): Parse a null procedure declaration\n+\n+            elsif Token = Tok_Null then\n+               if Ada_Version < Ada_05 then\n+                  Error_Msg_SP (\"null procedures are an Ada 2005 extension\");\n+                  Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+               end if;\n+\n+               Scan; -- past NULL\n+\n+               if Func then\n+                  Error_Msg_SP (\"only procedures can be null\");\n+               else\n+                  Set_Null_Present (Specification_Node);\n+               end if;\n+\n+               TF_Semicolon;\n+               goto Subprogram_Declaration;\n+\n             --  Check for IS NEW with Formal_Part present and handle nicely\n \n             elsif Token = Tok_New then"}, {"sha": "8e58931c366debfe96fa706d0a6a612bfc04cfd3", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 122, "deletions": 4, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -185,6 +185,11 @@ package body Ch9 is\n                end if;\n \n                Scan; -- past WITH\n+\n+               if Token = Tok_Private then\n+                  Error_Msg_SP\n+                    (\"PRIVATE not allowed in task type declaration\");\n+               end if;\n             end if;\n \n             Set_Task_Definition (Task_Node, P_Task_Definition);\n@@ -240,7 +245,7 @@ package body Ch9 is\n          --  Deal gracefully with multiple PRIVATE parts\n \n          while Token = Tok_Private loop\n-            Error_Msg_SC (\"Only one private part allowed per task\");\n+            Error_Msg_SC (\"only one private part allowed per task\");\n             Scan; -- past PRIVATE\n             Append_List (P_Task_Items, Private_Declarations (Def_Node));\n          end loop;\n@@ -284,7 +289,13 @@ package body Ch9 is\n          if Token = Tok_Pragma then\n             Append (P_Pragma, Items);\n \n-         elsif Token = Tok_Entry then\n+         --  Ada 2005 (AI-397): Reserved words NOT and OVERRIDING\n+         --  may begin an entry declaration.\n+\n+         elsif Token = Tok_Entry\n+           or else Token = Tok_Not\n+           or else Token = Tok_Overriding\n+         then\n             Append (P_Entry_Declaration, Items);\n \n          elsif Token = Tok_For then\n@@ -311,7 +322,7 @@ package body Ch9 is\n          elsif Token = Tok_Identifier\n            or else Token in Token_Class_Declk\n          then\n-            Error_Msg_SC (\"Illegal declaration in task definition\");\n+            Error_Msg_SC (\"illegal declaration in task definition\");\n             Resync_Past_Semicolon;\n \n          else\n@@ -454,6 +465,11 @@ package body Ch9 is\n             end if;\n \n             Scan; -- past WITH\n+\n+            if Token = Tok_Private then\n+               Error_Msg_SP\n+                 (\"PRIVATE not allowed in protected type declaration\");\n+            end if;\n          end if;\n \n          Set_Protected_Definition (Protected_Node, P_Protected_Definition);\n@@ -561,6 +577,63 @@ package body Ch9 is\n       L : List_Id;\n       P : Source_Ptr;\n \n+      function P_Entry_Or_Subprogram_With_Indicator return Node_Id;\n+      --  Ada 2005 (AI-397): Parse an entry or a subprogram with an overriding\n+      --  indicator. The caller has checked that the initial token is NOT or\n+      --  OVERRIDING.\n+\n+      ------------------------------------------\n+      -- P_Entry_Or_Subprogram_With_Indicator --\n+      ------------------------------------------\n+\n+      function P_Entry_Or_Subprogram_With_Indicator return Node_Id is\n+         Decl           : Node_Id := Error;\n+         Is_Overriding  : Boolean := False;\n+         Not_Overriding : Boolean := False;\n+\n+      begin\n+         if Token = Tok_Not then\n+            Scan;  -- past NOT\n+\n+            if Token = Tok_Overriding then\n+               Scan;  -- past OVERRIDING\n+               Not_Overriding := True;\n+            else\n+               Error_Msg_SC (\"OVERRIDING expected!\");\n+            end if;\n+\n+         else\n+            Scan;  -- past OVERRIDING\n+            Is_Overriding := True;\n+         end if;\n+\n+         if (Is_Overriding or else Not_Overriding) then\n+            if Ada_Version < Ada_05 then\n+               Error_Msg_SP (\" overriding indicator is an Ada 2005 extension\");\n+               Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+\n+            elsif Token = Tok_Entry then\n+               Decl := P_Entry_Declaration;\n+\n+               Set_Must_Override     (Decl, Is_Overriding);\n+               Set_Must_Not_Override (Decl, Not_Overriding);\n+\n+            elsif Token = Tok_Function or else Token = Tok_Procedure then\n+               Decl := P_Subprogram (Pf_Decl);\n+\n+               Set_Must_Override     (Specification (Decl), Is_Overriding);\n+               Set_Must_Not_Override (Specification (Decl), Not_Overriding);\n+\n+            else\n+               Error_Msg_SC (\"ENTRY, FUNCTION or PROCEDURE expected!\");\n+            end if;\n+         end if;\n+\n+         return Decl;\n+      end P_Entry_Or_Subprogram_With_Indicator;\n+\n+   --  Start of processing for P_Protected_Operation_Declaration_Opt\n+\n    begin\n       --  This loop runs more than once only when a junk declaration\n       --  is skipped.\n@@ -569,6 +642,9 @@ package body Ch9 is\n          if Token = Tok_Pragma then\n             return P_Pragma;\n \n+         elsif Token = Tok_Not or else Token = Tok_Overriding then\n+            return P_Entry_Or_Subprogram_With_Indicator;\n+\n          elsif Token = Tok_Entry then\n             return P_Entry_Declaration;\n \n@@ -669,18 +745,54 @@ package body Ch9 is\n    ------------------------------\n \n    --  ENTRY_DECLARATION ::=\n+   --    [OVERRIDING_INDICATOR]\n    --    entry DEFINING_IDENTIFIER [(DISCRETE_SUBTYPE_DEFINITION)]\n    --      PARAMETER_PROFILE;\n \n-   --  The caller has checked that the initial token is ENTRY\n+   --  The caller has checked that the initial token is ENTRY, NOT or\n+   --  OVERRIDING.\n \n    --  Error recovery: cannot raise Error_Resync\n \n    function P_Entry_Declaration return Node_Id is\n       Decl_Node  : Node_Id;\n       Scan_State : Saved_Scan_State;\n \n+      --  Flags for optional overriding indication. Two flags are needed,\n+      --  to distinguish positive and negative overriding indicators from\n+      --  the absence of any indicator.\n+\n+      Is_Overriding  : Boolean := False;\n+      Not_Overriding : Boolean := False;\n+\n    begin\n+      --  Ada 2005 (AI-397): Scan leading overriding indicator.\n+\n+      if Token = Tok_Not then\n+         Scan;  -- past NOT\n+\n+         if Token = Tok_Overriding then\n+            Scan;  -- part OVERRIDING\n+            Not_Overriding := True;\n+         else\n+            Error_Msg_SC (\"OVERRIDING expected!\");\n+         end if;\n+\n+      elsif Token = Tok_Overriding then\n+         Scan;  -- part OVERRIDING\n+         Is_Overriding := True;\n+      end if;\n+\n+      if (Is_Overriding or else Not_Overriding) then\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_SP (\" overriding indicator is an Ada 2005 extension\");\n+            Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+\n+         elsif Token /= Tok_Entry then\n+            Error_Msg_SC (\"ENTRY expected!\");\n+         end if;\n+      end if;\n+\n       Decl_Node := New_Node (N_Entry_Declaration, Token_Ptr);\n       Scan; -- past ENTRY\n \n@@ -724,6 +836,12 @@ package body Ch9 is\n          end if;\n       end if;\n \n+      if Is_Overriding then\n+         Set_Must_Override (Decl_Node);\n+      elsif Not_Overriding then\n+         Set_Must_Not_Override (Decl_Node);\n+      end if;\n+\n       --  Error recovery check for illegal return\n \n       if Token = Tok_Return then"}, {"sha": "c8c59f3fe9bb8c01ce2b8a8f1aab7cab3c81799d", "filename": "gcc/ada/s-imgwch.adb", "status": "modified", "additions": 23, "deletions": 53, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-imgwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-imgwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-imgwch.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -34,8 +34,6 @@\n with Interfaces; use Interfaces;\n \n with System.Img_Char; use System.Img_Char;\n-with System.WCh_Con;  use System.WCh_Con;\n-with System.WCh_WtS;  use System.WCh_WtS;\n \n package body System.Img_WChar is\n \n@@ -44,73 +42,45 @@ package body System.Img_WChar is\n    --------------------------\n \n    function Image_Wide_Character\n-     (V  : Wide_Character;\n-      EM : WC_Encoding_Method) return String\n+     (V : Wide_Character) return String\n    is\n-      Val : constant Unsigned_16 := Wide_Character'Pos (V);\n-      WS  : Wide_String (1 .. 3);\n-\n    begin\n-      --  If in range of standard character, use standard character routine\n-\n-      if Val < 16#80#\n-        or else (Val <= 16#FF#\n-                  and then EM not in WC_Upper_Half_Encoding_Method)\n-      then\n-         return Image_Character (Character'Val (Val));\n-\n-      --  if the value is one of the last two characters in the type, use\n-      --  their language-defined names (3.5.2(3)).\n-\n-      elsif Val = 16#FFFE# then\n-         return \"FFFE\";\n-\n-      elsif Val = 16#FFFF# then\n-         return \"FFFF\";\n-\n-      --  Otherwise return an appropriate escape sequence (i.e. one matching\n-      --  the convention implemented by Scn.Wide_Char). The easiest thing is\n-      --  to build a wide string for the result, and then use the Wide_Value\n-      --  function to build the resulting String.\n-\n-      else\n-         WS (1) := ''';\n-         WS (2) := V;\n-         WS (3) := ''';\n-\n-         return Wide_String_To_String (WS, EM);\n-      end if;\n+      return\n+        Image_Wide_Wide_Character\n+          (Wide_Wide_Character'Val (Wide_Character'Pos (V)));\n    end Image_Wide_Character;\n \n    -------------------------------\n    -- Image_Wide_Wide_Character --\n    -------------------------------\n \n    function Image_Wide_Wide_Character\n-     (V  : Wide_Wide_Character;\n-      EM : WC_Encoding_Method) return String\n+     (V : Wide_Wide_Character) return String\n    is\n-      Val : constant Unsigned_32 := Wide_Wide_Character'Pos (V);\n-      WS  : Wide_Wide_String (1 .. 3);\n+      Val : Unsigned_32 := Wide_Wide_Character'Pos (V);\n \n    begin\n-      --  If in range of standard Wide_Character, then we use the\n-      --  Wide_Character routine\n+      --  If in range of standard Character, use Character routine\n \n-      if Val <= 16#FFFF# then\n-         return Image_Wide_Character (Wide_Character'Val (Val), EM);\n+      if Val <= 16#FF# then\n+         return Image_Character (Character'Val (Wide_Wide_Character'Pos (V)));\n \n-      --  Otherwise return an appropriate escape sequence (i.e. one matching\n-      --  the convention implemented by Scn.Wide_Wide_Char). The easiest thing\n-      --  is to build a wide string for the result, and then use the\n-      --  Wide_Wide_Value function to build the resulting String.\n+      --  Otherwise value returned is Hex_hhhhhhhh\n \n       else\n-         WS (1) := ''';\n-         WS (2) := V;\n-         WS (3) := ''';\n-\n-         return Wide_Wide_String_To_String (WS, EM);\n+         declare\n+            Result : String (1 .. 12) := \"Hex_hhhhhhhh\";\n+            Hex    : constant array (Unsigned_32 range 0 .. 15) of Character :=\n+                       \"0123456789ABCDEF\";\n+\n+         begin\n+            for J in reverse 5 .. 12 loop\n+               Result (J) := Hex (Val mod 16);\n+               Val := Val / 16;\n+            end loop;\n+\n+            return Result;\n+         end;\n       end if;\n    end Image_Wide_Wide_Character;\n "}, {"sha": "ba180484978941e452eea1861bb79eb6fec40061", "filename": "gcc/ada/s-imgwch.ads", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-imgwch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-imgwch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-imgwch.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                     S Y S T E M . I M G _ W C H A R                      --\n --                                                                          --\n@@ -33,27 +33,13 @@\n \n --  Wide_[Wide_]Character'Image\n \n-with System.WCh_Con;\n-\n package System.Img_WChar is\n pragma Pure (Img_WChar);\n \n-   function Image_Wide_Character\n-     (V  : Wide_Character;\n-      EM : System.WCh_Con.WC_Encoding_Method) return String;\n-   --  Computes Wide_Character'Image (V) and returns the computed result,\n-   --  The argument EM is a constant representing the encoding method in use.\n-   --  The encoding method used is guaranteed to be consistent across a\n-   --  given program execution and to correspond to the method used in the\n-   --  source programs.\n+   function Image_Wide_Character (V : Wide_Character) return String;\n+   --  Computes Wide_Character'Image (V) and returns the computed result\n \n-   function Image_Wide_Wide_Character\n-     (V  : Wide_Wide_Character;\n-      EM : System.WCh_Con.WC_Encoding_Method) return String;\n-   --  Computes Wide_Wide_Character'Image (V) and returns the computed result,\n-   --  The argument EM is a constant representing the encoding method in use.\n-   --  The encoding method used is guaranteed to be consistent across a\n-   --  given program execution and to correspond to the method used in the\n-   --  source programs.\n+   function Image_Wide_Wide_Character (V : Wide_Wide_Character) return String;\n+   --  Computes Wide_Wide_Character'Image (V) and returns the computed result\n \n end System.Img_WChar;"}, {"sha": "6f2938f036fa7dd87179578937df8d78d74c969a", "filename": "gcc/ada/s-valwch.adb", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-valwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-valwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valwch.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -33,8 +33,6 @@\n \n with Interfaces;      use Interfaces;\n with System.Val_Util; use System.Val_Util;\n-with System.WCh_Con;  use System.WCh_Con;\n-with System.WCh_StW;  use System.WCh_StW;\n \n package body System.Val_WChar is\n \n@@ -43,15 +41,14 @@ package body System.Val_WChar is\n    --------------------------\n \n    function Value_Wide_Character\n-      (Str : String;\n-       EM  : WC_Encoding_Method) return Wide_Character\n+      (Str : String) return Wide_Character\n    is\n-      WWC : constant Wide_Wide_Character :=\n-              Value_Wide_Wide_Character (Str, EM);\n-      WWV : constant Unsigned_32 := Wide_Wide_Character'Pos (WWC);\n+      WWC : constant Wide_Wide_Character := Value_Wide_Wide_Character (Str);\n+      WWV : constant Unsigned_32         := Wide_Wide_Character'Pos (WWC);\n    begin\n       if WWV > 16#FFFF# then\n-         raise Constraint_Error;\n+         raise Constraint_Error\n+           with \"out of range character for Value attribute\";\n       else\n          return Wide_Character'Val (WWV);\n       end if;\n@@ -62,8 +59,7 @@ package body System.Val_WChar is\n    -------------------------------\n \n    function Value_Wide_Wide_Character\n-      (Str : String;\n-       EM  : System.WCh_Con.WC_Encoding_Method) return Wide_Wide_Character\n+      (Str : String) return Wide_Wide_Character\n    is\n       F : Natural;\n       L : Natural;\n@@ -81,48 +77,47 @@ package body System.Val_WChar is\n          if L - F = 2 then\n             return Wide_Wide_Character'Val (Character'Pos (S (F + 1)));\n \n-         --  Otherwise must be a wide character in quotes. The easiest\n-         --  thing is to convert the string to a wide wide string and then\n-         --  pick up the single character that it should contain.\n+            --  Otherwise something is very wrong\n \n          else\n-            declare\n-               WS : constant Wide_Wide_String :=\n-                      String_To_Wide_Wide_String (S (F + 1 .. L - 1), EM);\n-\n-            begin\n-               if WS'Length /= 1 then\n-                  raise Constraint_Error;\n-               else\n-                  return WS (WS'First);\n-               end if;\n-            end;\n+            raise Constraint_Error with \"invalid string for Value attribute\";\n          end if;\n \n-      --  the last two values of the type have language-defined names:\n+      --  Deal with Hex_hhhhhhhh cases for wide_[wide_]character cases\n \n-      elsif S = \"FFFE\" then\n-         return Wide_Wide_Character'Val (16#FFFE#);\n+      elsif Str'Length = 12 and then Str (1 .. 4) = \"Hex_\" then\n+         declare\n+            W : Unsigned_32 := 0;\n \n-      elsif S = \"FFFF\" then\n-         return Wide_Wide_Character'Val (16#FFFF#);\n+         begin\n+            for J in 5 .. 12 loop\n+               W := W * 16 + Character'Pos (Str (J));\n \n-      --  Otherwise must be a control character\n+               if Str (J) in '0' .. '9' then\n+                  W := W - Character'Pos ('0');\n+               elsif Str (J) in 'A' .. 'F' then\n+                  W := W - Character'Pos ('A') + 10;\n+               elsif Str (J) in 'a' .. 'f' then\n+                  W := W - Character'Pos ('a') + 10;\n+               else\n+                  raise Constraint_Error\n+                    with \"illegal hex character for Value attribute\";\n+               end if;\n+            end loop;\n \n-      else\n-         for C in Character'Val (16#00#) .. Character'Val (16#1F#) loop\n-            if S (F .. L) = Character'Image (C) then\n-               return Wide_Wide_Character'Val (Character'Pos (C));\n+            if W > 16#7FFF_FFFF# then\n+               raise Constraint_Error\n+                 with \"out of range value for Value attribute\";\n+            else\n+               return Wide_Wide_Character'Val (W);\n             end if;\n-         end loop;\n+         end;\n \n-         for C in Character'Val (16#7F#) .. Character'Val (16#9F#) loop\n-            if S (F .. L) = Character'Image (C) then\n-               return Wide_Wide_Character'Val (Character'Pos (C));\n-            end if;\n-         end loop;\n+      --  Otherwise must be one of the special names for Character\n \n-         raise Constraint_Error;\n+      else\n+         return\n+           Wide_Wide_Character'Val (Character'Pos (Character'Value (Str)));\n       end if;\n    end Value_Wide_Wide_Character;\n "}, {"sha": "c3cc1e18d120b0af9481092284969ba3d289711c", "filename": "gcc/ada/s-valwch.ads", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-valwch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-valwch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valwch.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -33,19 +33,15 @@\n \n --  Processing for Wide_[Wide_]Value attribute\n \n-with System.WCh_Con;\n-\n package System.Val_WChar is\n pragma Pure (Val_WChar);\n \n    function Value_Wide_Character\n-      (Str : String;\n-       EM  : System.WCh_Con.WC_Encoding_Method) return Wide_Character;\n-   --  Computes Wide_Character'Value (Str).\n+      (Str : String) return Wide_Character;\n+   --  Computes Wide_Character'Value (Str)\n \n    function Value_Wide_Wide_Character\n-      (Str : String;\n-       EM  : System.WCh_Con.WC_Encoding_Method) return Wide_Wide_Character;\n-   --  Computes Wide_Character'Value (Str).\n+      (Str : String) return Wide_Wide_Character;\n+   --  Computes Wide_Character'Value (Str)\n \n end System.Val_WChar;"}, {"sha": "72f03a3fb86456793cac8ae94f7cae4e14071a7c", "filename": "gcc/ada/s-widwch.adb", "status": "modified", "additions": 9, "deletions": 61, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-widwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-widwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-widwch.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                     S Y S T E M . W I D _ W C H A R                      --\n --                                                                          --\n@@ -31,17 +31,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.WCh_Con; use System.WCh_Con;\n-\n package body System.Wid_WChar is\n \n    --------------------------\n    -- Width_Wide_Character --\n    --------------------------\n \n    function Width_Wide_Character\n-     (Lo, Hi : Wide_Character;\n-      EM     : WC_Encoding_Method) return Natural\n+     (Lo, Hi : Wide_Character) return Natural\n    is\n       W : Natural;\n       P : Natural;\n@@ -52,36 +49,12 @@ package body System.Wid_WChar is\n          P := Wide_Character'Pos (C);\n \n          --  Here if we find a character in wide character range\n+         --  Width is max value (12) for Hex_hhhhhhhh\n \n          if P > 16#FF# then\n+            return 12;\n \n-            case EM is\n-\n-               when WCEM_Hex =>\n-                  return Natural'Max (W, 5);\n-\n-               when WCEM_Upper =>\n-                  return Natural'Max (W, 2);\n-\n-               when WCEM_Shift_JIS =>\n-                  return Natural'Max (W, 2);\n-\n-               when WCEM_EUC =>\n-                  return Natural'Max (W, 2);\n-\n-               when WCEM_UTF8 =>\n-                  if Hi > Wide_Character'Val (16#07FF#) then\n-                     return Natural'Max (W, 3);\n-                  else\n-                     return Natural'Max (W, 2);\n-                  end if;\n-\n-               when WCEM_Brackets =>\n-                  return Natural'Max (W, 8);\n-\n-            end case;\n-\n-         --  If we are in character range then use length of character image\n+            --  If we are in character range then use length of character image\n \n          else\n             declare\n@@ -100,8 +73,7 @@ package body System.Wid_WChar is\n    -------------------------------\n \n    function Width_Wide_Wide_Character\n-     (Lo, Hi : Wide_Wide_Character;\n-      EM     : WC_Encoding_Method) return Natural\n+     (Lo, Hi : Wide_Wide_Character) return Natural\n    is\n       W : Natural;\n       P : Natural;\n@@ -111,35 +83,11 @@ package body System.Wid_WChar is\n       for C in Lo .. Hi loop\n          P := Wide_Wide_Character'Pos (C);\n \n-         --  Here if we find a character in wide wide character range\n+         --  Here if we find a character in wide wide character range.\n+         --  Width is max value (12) for Hex_hhhhhhhh\n \n          if P > 16#FF# then\n-            case EM is\n-               when WCEM_Hex =>\n-                  return Natural'Max (W, 5);\n-\n-               when WCEM_Upper =>\n-                  return Natural'Max (W, 2);\n-\n-               when WCEM_Shift_JIS =>\n-                  return Natural'Max (W, 2);\n-\n-               when WCEM_EUC =>\n-                  return Natural'Max (W, 2);\n-\n-               when WCEM_UTF8 =>\n-                  if Hi > Wide_Wide_Character'Val (16#FFFF#) then\n-                     return Natural'Max (W, 4);\n-                  elsif Hi > Wide_Wide_Character'Val (16#07FF#) then\n-                     return Natural'Max (W, 3);\n-                  else\n-                     return Natural'Max (W, 2);\n-                  end if;\n-\n-               when WCEM_Brackets =>\n-                  return Natural'Max (W, 10);\n-\n-            end case;\n+            W := 12;\n \n          --  If we are in character range then use length of character image\n "}, {"sha": "6d79aae6f9b0ce02e85f2fb5bf8c246d3b8b7e74", "filename": "gcc/ada/s-widwch.ads", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-widwch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-widwch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-widwch.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                     S Y S T E M . W I D _ W C H A R                      --\n --                                                                          --\n@@ -33,21 +33,16 @@\n \n --  This package contains the routines used for Wide_[Wide_]Character'Width\n \n-with System.WCh_Con;\n-\n package System.Wid_WChar is\n pragma Pure (Wid_WChar);\n \n    function Width_Wide_Character\n-     (Lo, Hi : Wide_Character;\n-      EM     : System.WCh_Con.WC_Encoding_Method) return Natural;\n+     (Lo, Hi : Wide_Character) return Natural;\n    --  Compute Width attribute for non-static type derived from Wide_Character.\n-   --  The arguments are the low and high bounds for the type. EM is the\n-   --  wide-character encoding method.\n+   --  The arguments are the low and high bounds for the type.\n \n    function Width_Wide_Wide_Character\n-     (Lo, Hi : Wide_Wide_Character;\n-      EM     : System.WCh_Con.WC_Encoding_Method) return Natural;\n+     (Lo, Hi : Wide_Wide_Character) return Natural;\n    --  Same function for type derived from Wide_Wide_Character\n \n end System.Wid_WChar;"}, {"sha": "4fdf48fc68553d787026976e398c5bef921c5e1a", "filename": "gcc/ada/s-wwdcha.adb", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-wwdcha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-wwdcha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdcha.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                      S Y S T E M . W W D _ C H A R                       --\n --                                                                          --\n@@ -43,11 +43,20 @@ package body System.WWd_Char is\n    begin\n       W := 0;\n       for C in Lo .. Hi loop\n-         declare\n-            S : constant Wide_String := Character'Wide_Image (C);\n-         begin\n-            W := Natural'Max (W, S'Length);\n-         end;\n+         --  For Character range, use length of image\n+\n+         if Character'Pos (C) < 256 then\n+            declare\n+               S : constant Wide_String := Character'Wide_Image (C);\n+            begin\n+               W := Natural'Max (W, S'Length);\n+            end;\n+\n+            --  For wide character, always max out at 12 (Hex_hhhhhhhh)\n+\n+         else\n+            return 12;\n+         end if;\n       end loop;\n \n       return W;\n@@ -63,11 +72,21 @@ package body System.WWd_Char is\n    begin\n       W := 0;\n       for C in Lo .. Hi loop\n-         declare\n-            S : constant Wide_Wide_String := Character'Wide_Wide_Image (C);\n-         begin\n-            W := Natural'Max (W, S'Length);\n-         end;\n+\n+         --  For Character range, use length of image\n+\n+         if Character'Pos (C) < 256 then\n+            declare\n+               S : constant String := Character'Image (C);\n+            begin\n+               W := Natural'Max (W, S'Length);\n+            end;\n+\n+            --  For wide character, always max out at 12 (Hex_hhhhhhhh)\n+\n+         else\n+            return 12;\n+         end if;\n       end loop;\n \n       return W;"}, {"sha": "a87fd2c11c01a3484a4a1c213ad355626c9183aa", "filename": "gcc/ada/s-wwdwch.adb", "status": "modified", "additions": 16, "deletions": 61, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-wwdwch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fs-wwdwch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdwch.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                     S Y S T E M . W W D _ W C H A R                      --\n --                                                                          --\n@@ -59,7 +59,6 @@ package body System.Wwd_WChar is\n    function Wide_Wide_Width_Wide_Wide_Char\n      (Lo, Hi : Wide_Wide_Character) return Natural\n    is\n-      W  : Natural := 0;\n       LV : constant Unsigned_32 := Wide_Wide_Character'Pos (Lo);\n       HV : constant Unsigned_32 := Wide_Wide_Character'Pos (Hi);\n \n@@ -68,36 +67,22 @@ package body System.Wwd_WChar is\n \n       if LV > HV then\n          return 0;\n-      end if;\n+\n+      --  Return max value (12) for wide character (Hex_hhhhhhhh)\n+\n+      elsif HV > 255 then\n+         return 12;\n \n       --  If any characters in normal character range, then use normal\n       --  Wide_Wide_Width attribute on this range to find out a starting point.\n       --  Otherwise start with zero.\n \n-      if LV <= 255 then\n-         W :=\n+      else\n+         return\n            System.WWd_Char.Wide_Wide_Width_Character\n              (Lo => Character'Val (LV),\n               Hi => Character'Val (Unsigned_32'Min (255, HV)));\n-      else\n-         W := 0;\n       end if;\n-\n-      --  Increase to at least 4 if FFFE or FFFF present. These correspond\n-      --  to the special language defined names FFFE/FFFF for these values.\n-\n-      if 16#FFFF# in LV .. HV or else 16#FFFE# in LV .. HV then\n-         W := Natural'Max (W, 4);\n-      end if;\n-\n-      --  Increase to at least 3 if any wide characters, corresponding to\n-      --  the normal ' character ' sequence. We know that the character fits.\n-\n-      if HV > 255 then\n-         W := Natural'Max (W, 3);\n-      end if;\n-\n-      return W;\n    end Wide_Wide_Width_Wide_Wide_Char;\n \n    -------------------------------\n@@ -107,7 +92,6 @@ package body System.Wwd_WChar is\n    function Wide_Width_Wide_Character\n      (Lo, Hi : Wide_Character) return Natural\n    is\n-      W  : Natural := 0;\n       LV : constant Unsigned_32 := Wide_Character'Pos (Lo);\n       HV : constant Unsigned_32 := Wide_Character'Pos (Hi);\n \n@@ -116,62 +100,33 @@ package body System.Wwd_WChar is\n \n       if LV > HV then\n          return 0;\n-      end if;\n+\n+      --  Return max value (12) for wide character (Hex_hhhhhhhh)\n+\n+      elsif HV > 255 then\n+         return 12;\n \n       --  If any characters in normal character range, then use normal\n       --  Wide_Wide_Width attribute on this range to find out a starting point.\n       --  Otherwise start with zero.\n \n-      if LV <= 255 then\n-         W :=\n+      else\n+         return\n            System.WWd_Char.Wide_Width_Character\n              (Lo => Character'Val (LV),\n               Hi => Character'Val (Unsigned_32'Min (255, HV)));\n-      else\n-         W := 0;\n-      end if;\n-\n-      --  Increase to at least 4 if FFFE or FFFF present. These correspond\n-      --  to the special language defined names FFFE/FFFF for these values.\n-\n-      if 16#FFFF# in LV .. HV or else 16#FFFE# in LV .. HV then\n-         W := Natural'Max (W, 4);\n       end if;\n-\n-      --  Increase to at least 3 if any wide characters, corresponding to\n-      --  the normal 'character' sequence. We know that the character fits.\n-\n-      if HV > 255 then\n-         W := Natural'Max (W, 3);\n-      end if;\n-\n-      return W;\n    end Wide_Width_Wide_Character;\n \n    ------------------------------------\n    -- Wide_Width_Wide_Wide_Character --\n    ------------------------------------\n \n-   --  This is a nasty case, because we get into the business of representing\n-   --  out of range wide wide characters as wide strings. Let's let image do\n-   --  the work here. Too bad if this takes lots of time. It's silly anyway!\n-\n    function Wide_Width_Wide_Wide_Character\n      (Lo, Hi : Wide_Wide_Character) return Natural\n    is\n-      W : Natural;\n-\n    begin\n-      W := 0;\n-      for J in Lo .. Hi loop\n-         declare\n-            S : constant Wide_String := Wide_Wide_Character'Wide_Image (J);\n-         begin\n-            W := Natural'Max (W, S'Length);\n-         end;\n-      end loop;\n-\n-      return W;\n+      return Wide_Wide_Width_Wide_Wide_Char (Lo, Hi);\n    end Wide_Width_Wide_Wide_Character;\n \n end System.Wwd_WChar;"}, {"sha": "315fada0bd238a74f22feede4c957d0d409a0cce", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 219, "deletions": 44, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,6 @@ with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Eval_Fat;\n-with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Expander; use Expander;\n with Freeze;   use Freeze;\n@@ -66,7 +65,6 @@ with Ttypef;   use Ttypef;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n-with Widechar; use Widechar;\n \n package body Sem_Attr is\n \n@@ -381,8 +379,7 @@ package body Sem_Attr is\n             It    : Interp;\n \n             function Get_Kind (E : Entity_Id) return Entity_Kind;\n-            --  Distinguish between access to regular and protected\n-            --  subprograms.\n+            --  Distinguish between access to regular/protected subprograms\n \n             --------------\n             -- Get_Kind --\n@@ -404,18 +401,20 @@ package body Sem_Attr is\n             --  subprogram itself as the designated type. Type-checking in\n             --  this case compares the signatures of the designated types.\n \n+            Set_Etype (N, Any_Type);\n+\n             if not Is_Overloaded (P) then\n-               Acc_Type :=\n-                 New_Internal_Entity\n-                   (Get_Kind (Entity (P)), Current_Scope, Loc, 'A');\n-               Set_Etype (Acc_Type, Acc_Type);\n-               Set_Directly_Designated_Type (Acc_Type, Entity (P));\n-               Set_Etype (N, Acc_Type);\n+               if not Is_Intrinsic_Subprogram (Entity (P)) then\n+                  Acc_Type :=\n+                    New_Internal_Entity\n+                      (Get_Kind (Entity (P)), Current_Scope, Loc, 'A');\n+                  Set_Etype (Acc_Type, Acc_Type);\n+                  Set_Directly_Designated_Type (Acc_Type, Entity (P));\n+                  Set_Etype (N, Acc_Type);\n+               end if;\n \n             else\n                Get_First_Interp (P, Index, It);\n-               Set_Etype (N, Any_Type);\n-\n                while Present (It.Nam) loop\n                   if not Is_Intrinsic_Subprogram (It.Nam) then\n                      Acc_Type :=\n@@ -428,10 +427,10 @@ package body Sem_Attr is\n \n                   Get_Next_Interp (Index, It);\n                end loop;\n+            end if;\n \n-               if Etype (N) = Any_Type then\n-                  Error_Attr (\"prefix of % attribute cannot be intrinsic\", P);\n-               end if;\n+            if Etype (N) = Any_Type then\n+               Error_Attr (\"prefix of % attribute cannot be intrinsic\", P);\n             end if;\n          end Build_Access_Subprogram_Type;\n \n@@ -457,6 +456,12 @@ package body Sem_Attr is\n                Check_Restriction (No_Implicit_Dynamic_Code, P);\n             end if;\n \n+            if Is_Always_Inlined (Entity (P)) then\n+               Error_Attr\n+                 (\"prefix of % attribute cannot be Inline_Always subprogram\",\n+                  P);\n+            end if;\n+\n             --  Build the appropriate subprogram type\n \n             Build_Access_Subprogram_Type (P);\n@@ -630,7 +635,7 @@ package body Sem_Attr is\n          Index : Entity_Id;\n \n          D : Int;\n-         --  Dimension number for array attributes.\n+         --  Dimension number for array attributes\n \n       begin\n          --  Case of string literal or string literal subtype. These cases\n@@ -703,7 +708,7 @@ package body Sem_Attr is\n \n       procedure Check_Array_Type is\n          D : Int;\n-         --  Dimension number for array attributes.\n+         --  Dimension number for array attributes\n \n       begin\n          --  If the type is a string literal type, then this must be generated\n@@ -1217,7 +1222,6 @@ package body Sem_Attr is\n       procedure Check_Stream_Attribute (Nam : TSS_Name_Type) is\n          Etyp : Entity_Id;\n          Btyp : Entity_Id;\n-\n       begin\n          Validate_Non_Static_Attribute_Function_Call;\n \n@@ -1247,17 +1251,24 @@ package body Sem_Attr is\n          --  attribute reference was generated by the expander (in which\n          --  case the underlying type will be used, as described in Sinfo),\n          --  or the attribute was specified explicitly for the type itself\n-         --  or one of its ancestors.\n+         --  or one of its ancestors (taking visibility rules into account if\n+         --  in Ada 2005 mode), or a pragma Stream_Convert applies to Btyp\n+         --  (with no visibility restriction).\n \n-         if Is_Limited_Type (P_Type)\n-           and then Comes_From_Source (N)\n-           and then not Present (Find_Inherited_TSS (Btyp, Nam))\n+         if Comes_From_Source (N)\n+           and then not Stream_Attribute_Available (P_Type, Nam)\n            and then not Has_Rep_Pragma (Btyp, Name_Stream_Convert)\n          then\n             Error_Msg_Name_1 := Aname;\n-            Error_Msg_NE\n-              (\"limited type& has no% attribute\", P, Btyp);\n-            Explain_Limited_Type (P_Type, P);\n+\n+            if Is_Limited_Type (P_Type) then\n+               Error_Msg_NE\n+                 (\"limited type& has no% attribute\", P, P_Type);\n+               Explain_Limited_Type (P_Type, P);\n+            else\n+               Error_Msg_NE\n+                 (\"attribute% for type& is not available\", P, P_Type);\n+            end if;\n          end if;\n \n          --  Check for violation of restriction No_Stream_Attributes\n@@ -1629,14 +1640,63 @@ package body Sem_Attr is\n          end if;\n       end if;\n \n-      if Is_Overloaded (P)\n+      --  Ada 2005 (AI-345): Ensure that the compiler gives exactly the current\n+      --  output compiling in Ada 95 mode\n+\n+      if Ada_Version < Ada_05\n+        and then Is_Overloaded (P)\n         and then Aname /= Name_Access\n         and then Aname /= Name_Address\n         and then Aname /= Name_Code_Address\n         and then Aname /= Name_Count\n         and then Aname /= Name_Unchecked_Access\n       then\n          Error_Attr (\"ambiguous prefix for % attribute\", P);\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Overloaded (P)\n+        and then Aname /= Name_Access\n+        and then Aname /= Name_Address\n+        and then Aname /= Name_Code_Address\n+        and then Aname /= Name_Unchecked_Access\n+      then\n+         --  Ada 2005 (AI-345): Since protected and task types have primitive\n+         --  entry wrappers, the attributes Count, Caller and AST_Entry require\n+         --  a context check\n+\n+         if Ada_Version >= Ada_05\n+           and then (Aname = Name_Count\n+                      or else Aname = Name_Caller\n+                      or else Aname = Name_AST_Entry)\n+         then\n+            declare\n+               Count : Natural := 0;\n+               I     : Interp_Index;\n+               It    : Interp;\n+\n+            begin\n+               Get_First_Interp (P, I, It);\n+\n+               while Present (It.Nam) loop\n+                  if Comes_From_Source (It.Nam) then\n+                     Count := Count + 1;\n+                  else\n+                     Remove_Interp (I);\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+\n+               if Count > 1 then\n+                  Error_Attr (\"ambiguous prefix for % attribute\", P);\n+               else\n+                  Set_Is_Overloaded (P, False);\n+               end if;\n+            end;\n+\n+         else\n+            Error_Attr (\"ambiguous prefix for % attribute\", P);\n+         end if;\n       end if;\n \n       --  Remaining processing depends on attribute\n@@ -1692,6 +1752,20 @@ package body Sem_Attr is\n \n                   Set_Address_Taken (Ent);\n \n+                  --  An Address attribute is accepted when generated by\n+                  --  the compiler for dispatching operation, and an error\n+                  --  is issued once the subprogram is frozen (to avoid\n+                  --  confusing errors about implicit uses of Address in\n+                  --  the dispatch table initialization).\n+\n+                  if Is_Always_Inlined (Entity (P))\n+                    and then Comes_From_Source (P)\n+                  then\n+                     Error_Attr\n+                       (\"prefix of % attribute cannot be Inline_Always\" &\n+                        \" subprogram\", P);\n+                  end if;\n+\n                elsif Is_Object (Ent)\n                  or else Ekind (Ent) = E_Label\n                then\n@@ -1973,7 +2047,7 @@ package body Sem_Attr is\n                     Attribute_Name => Name_Base),\n                 Expression => Relocate_Node (E1)));\n \n-            --  E1 may be overloaded, and its interpretations preserved.\n+            --  E1 may be overloaded, and its interpretations preserved\n \n             Save_Interps (E1, Expression (N));\n             Analyze (N);\n@@ -2413,6 +2487,14 @@ package body Sem_Attr is\n                   if It.Nam = Ent then\n                      null;\n \n+                  --  Ada 2005 (AI-345): Do not consider primitive entry\n+                  --  wrappers generated for task or protected types.\n+\n+                  elsif Ada_Version >= Ada_05\n+                    and then not Comes_From_Source (It.Nam)\n+                  then\n+                     null;\n+\n                   else\n                      Error_Attr (\"ambiguous entry name\", N);\n                   end if;\n@@ -3496,7 +3578,7 @@ package body Sem_Attr is\n          if Is_Real_Type (P_Type) then\n             null;\n \n-         --  If not modular type, test for overflow check required.\n+         --  If not modular type, test for overflow check required\n \n          else\n             if not Is_Modular_Integer_Type (P_Type)\n@@ -3941,7 +4023,7 @@ package body Sem_Attr is\n       P     : constant Node_Id      := Prefix (N);\n \n       C_Type : constant Entity_Id := Etype (N);\n-      --  The type imposed by the context.\n+      --  The type imposed by the context\n \n       E1 : Node_Id;\n       --  First expression, or Empty if none\n@@ -6303,19 +6385,10 @@ package body Sem_Attr is\n \n                      for J in UI_To_Int (Lo) .. UI_To_Int (Hi) loop\n \n-                        --  Assume all wide-character escape sequences are\n-                        --  same length, so we can quit when we reach one.\n-\n-                        --  Is this right for UTF-8?\n+                        --  All wide characters look like Hex_hhhhhhhh\n \n                         if J > 255 then\n-                           if Id = Attribute_Wide_Width then\n-                              W := Int'Max (W, 3);\n-                              exit;\n-                           else\n-                              W := Int'Max (W, Length_Wide);\n-                              exit;\n-                           end if;\n+                           W := 12;\n \n                         else\n                            C := Character'Val (J);\n@@ -6879,9 +6952,7 @@ package body Sem_Attr is\n                --  enclosing composite type.\n \n                if Ada_Version >= Ada_05\n-                 and then Ekind (Btyp) = E_Anonymous_Access_Type\n-                 and then (Is_Array_Type (Scope (Btyp))\n-                             or else Ekind (Scope (Btyp)) = E_Record_Type)\n+                 and then Is_Local_Anonymous_Access (Btyp)\n                  and then Object_Access_Level (P) > Type_Access_Level (Btyp)\n                then\n                   --  In an instance, this is a runtime check, but one we\n@@ -7466,4 +7537,108 @@ package body Sem_Attr is\n       Eval_Attribute (N);\n    end Resolve_Attribute;\n \n+   --------------------------------\n+   -- Stream_Attribute_Available --\n+   --------------------------------\n+\n+   function Stream_Attribute_Available\n+     (Typ          : Entity_Id;\n+      Nam          : TSS_Name_Type;\n+      Partial_View : Node_Id := Empty) return Boolean\n+   is\n+      Etyp : Entity_Id := Typ;\n+\n+      function Has_Specified_Stream_Attribute\n+        (Typ : Entity_Id;\n+         Nam : TSS_Name_Type) return Boolean;\n+      --  True iff there is a visible attribute definition clause specifying\n+      --  attribute Nam for Typ.\n+\n+      ------------------------------------\n+      -- Has_Specified_Stream_Attribute --\n+      ------------------------------------\n+\n+      function Has_Specified_Stream_Attribute\n+        (Typ : Entity_Id;\n+         Nam : TSS_Name_Type) return Boolean\n+      is\n+      begin\n+         return False\n+           or else\n+             (Nam = TSS_Stream_Input\n+               and then Has_Specified_Stream_Input (Typ))\n+           or else\n+             (Nam = TSS_Stream_Output\n+               and then Has_Specified_Stream_Output (Typ))\n+           or else\n+             (Nam = TSS_Stream_Read\n+               and then Has_Specified_Stream_Read (Typ))\n+           or else\n+             (Nam = TSS_Stream_Write\n+               and then Has_Specified_Stream_Write (Typ));\n+      end Has_Specified_Stream_Attribute;\n+\n+   --  Start of processing for Stream_Attribute_Available\n+\n+   begin\n+      --  We need some comments in this body ???\n+\n+      if Has_Specified_Stream_Attribute (Typ, Nam) then\n+         return True;\n+      end if;\n+\n+      if Is_Class_Wide_Type (Typ) then\n+         return not Is_Limited_Type (Typ)\n+           or else Stream_Attribute_Available (Etype (Typ), Nam);\n+      end if;\n+\n+      if Nam = TSS_Stream_Input\n+        and then Is_Abstract (Typ)\n+        and then not Is_Class_Wide_Type (Typ)\n+      then\n+         return False;\n+      end if;\n+\n+      if not (Is_Limited_Type (Typ)\n+        or else (Present (Partial_View)\n+                   and then Is_Limited_Type (Partial_View)))\n+      then\n+         return True;\n+      end if;\n+\n+      if Nam = TSS_Stream_Input then\n+         return Ada_Version >= Ada_05\n+           and then Stream_Attribute_Available (Etyp, TSS_Stream_Read);\n+      elsif Nam = TSS_Stream_Output then\n+         return Ada_Version >= Ada_05\n+           and then Stream_Attribute_Available (Etyp, TSS_Stream_Write);\n+      end if;\n+\n+      --  Case of Read and Write: check for attribute definition clause that\n+      --  applies to an ancestor type.\n+\n+      while Etype (Etyp) /= Etyp loop\n+         Etyp := Etype (Etyp);\n+\n+         if Has_Specified_Stream_Attribute (Etyp, Nam) then\n+            return True;\n+         end if;\n+      end loop;\n+\n+      if Ada_Version < Ada_05 then\n+\n+         --  In Ada 95 mode, also consider a non-visible definition\n+\n+         declare\n+            Btyp : constant Entity_Id := Implementation_Base_Type (Typ);\n+         begin\n+            return Btyp /= Typ\n+              and then Stream_Attribute_Available\n+                         (Btyp, Nam, Partial_View => Typ);\n+         end;\n+      end if;\n+\n+      return False;\n+   end Stream_Attribute_Available;\n+\n end Sem_Attr;"}, {"sha": "2a2c7b4291782613d914cc7b790703e41f1717c5", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 121, "deletions": 142, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,8 +31,9 @@\n \n --  This spec also documents all GNAT implementation defined pragmas\n \n-with Snames; use Snames;\n-with Types;  use Types;\n+with Exp_Tss; use Exp_Tss;\n+with Snames;  use Snames;\n+with Types;   use Types;\n \n package Sem_Attr is\n \n@@ -54,20 +55,18 @@ package Sem_Attr is\n       ------------------\n \n       Attribute_Abort_Signal => True,\n-      --\n-      --  Standard'Abort_Signal (Standard is the only allowed prefix)\n-      --  provides the entity for the special exception used to signal\n-      --  task abort or asynchronous transfer of control. Normally this\n-      --  attribute should only be used in the tasking runtime (it is\n-      --  highly peculiar, and completely outside the normal semantics\n-      --  of Ada, for a user program to intercept the abort exception).\n+      --  Standard'Abort_Signal (Standard is the only allowed prefix) provides\n+      --  the entity for the special exception used to signal task abort or\n+      --  asynchronous transfer of control. Normally this attribute should only\n+      --  be used in the tasking runtime (it is highly peculiar, and completely\n+      --  outside the normal semantics of Ada, for a user program to intercept\n+      --  the abort exception).\n \n       ------------------\n       -- Address_Size --\n       ------------------\n \n       Attribute_Address_Size => True,\n-      --\n       --  Standard'Address_Size (Standard is the only allowed prefix) is\n       --  a static constant giving the number of bits in an Address. It\n       --  is used primarily for constructing the definition of Memory_Size\n@@ -79,7 +78,6 @@ package Sem_Attr is\n       ---------------\n \n       Attribute_Asm_Input => True,\n-      --\n       --  Used only in conjunction with the Asm and Asm_Volatile subprograms\n       --  in package Machine_Code to construct machine instructions. See\n       --  documentation in package Machine_Code in file s-maccod.ads.\n@@ -89,7 +87,6 @@ package Sem_Attr is\n       ----------------\n \n       Attribute_Asm_Output => True,\n-      --\n       --  Used only in conjunction with the Asm and Asm_Volatile subprograms\n       --  in package Machine_Code to construct machine instructions. See\n       --  documentation in package Machine_Code in file s-maccod.ads.\n@@ -99,7 +96,6 @@ package Sem_Attr is\n       ---------------\n \n       Attribute_AST_Entry => True,\n-      --\n       --  E'Ast_Entry, where E is a task entry, yields a value of the\n       --  predefined type System.DEC.AST_Handler, that enables the given\n       --  entry to be called when an AST occurs. If the name to which the\n@@ -117,20 +113,19 @@ package Sem_Attr is\n       ---------\n \n       Attribute_Bit => True,\n-      --\n-      --  Obj'Bit, where Obj is any object, yields the bit offset within\n-      --  the storage unit (byte) that contains the first bit of storage\n-      --  allocated for the object. The value of this attribute is of the\n-      --  type Universal_Integer, and is always a non-negative number not\n-      --  exceeding the value of System.Storage_Unit.\n+      --  Obj'Bit, where Obj is any object, yields the bit offset within the\n+      --  storage unit (byte) that contains the first bit of storage allocated\n+      --  for the object. The attribute value is of type Universal_Integer,\n+      --  and is always a non-negative number not exceeding the value of\n+      --  System.Storage_Unit.\n       --\n       --  For an object that is a variable or a constant allocated in a\n       --  register, the value is zero. (The use of this attribute does not\n       --  force the allocation of a variable to memory).\n       --\n-      --  For an object that is a formal parameter, this attribute applies\n-      --  to either the matching actual parameter or to a copy of the\n-      --  matching actual parameter.\n+      --  For an object that is a formal parameter, this attribute applies to\n+      --  either the matching actual parameter or to a copy of the matching\n+      --  actual parameter.\n       --\n       --  For an access object the value is zero. Note that Obj.all'Bit is\n       --  subject to an Access_Check for the designated object. Similarly\n@@ -145,22 +140,20 @@ package Sem_Attr is\n       ------------------\n \n       Attribute_Code_Address => True,\n-      --\n-      --  subp'Code_Address, where subp is a subprogram entity, gives the\n-      --  address of the first generated instruction for a subprogram. This\n-      --  is often, but not always the same as the 'Address value, which is\n-      --  the address to be used in a call. The differences occur in the case\n-      --  of a nested procedure (where Address yields the address of the\n-      --  trampoline code used to load the static link), and on some systems\n-      --  which use procedure descriptors (in which case Address yields the\n-      --  address of the descriptor).\n+      --  The reference subp'Code_Address, where subp is a subprogram entity,\n+      --  gives the address of the first generated instruction for the sub-\n+      --  program. This is often, but not always the same as the 'Address\n+      --  value, which is the address to be used in a call. The differences\n+      --  occur in the case of a nested procedure (where Address yields the\n+      --  address of the trampoline code used to load the static link), and on\n+      --  some systems which use procedure descriptors (in which case Address\n+      --  yields the address of the descriptor).\n \n       -----------------------\n       -- Default_Bit_Order --\n       -----------------------\n \n       Attribute_Default_Bit_Order => True,\n-      --\n       --  Standard'Default_Bit_Order (Standard is the only permissible prefix),\n       --  provides the value System.Default_Bit_Order as a Pos value (0 for\n       --  High_Order_First, 1 for Low_Order_First). This is used to construct\n@@ -172,22 +165,20 @@ package Sem_Attr is\n       ---------------\n \n       Attribute_Elab_Body => True,\n-      --\n-      --  This attribute can only be applied to a program unit name. It\n-      --  returns the entity for the corresponding elaboration procedure\n-      --  for elaborating the body of the referenced unit. This is used\n-      --  in the main generated elaboration procedure by the binder, and\n-      --  is not normally used in any other context, but there may be\n-      --  specialized situations in which it is useful to be able to\n-      --  call this elaboration procedure from Ada code, e.g. if it\n-      --  is necessary to do selective reelaboration to fix some error.\n+      --  This attribute can only be applied to a program unit name. It returns\n+      --  the entity for the corresponding elaboration procedure for elabor-\n+      --  ating the body of the referenced unit. This is used in the main\n+      --  generated elaboration procedure by the binder, and is not normally\n+      --  used in any other context, but there may be specialized situations in\n+      --  which it is useful to be able to call this elaboration procedure from\n+      --  Ada code, e.g. if it is necessary to do selective reelaboration to\n+      --  fix some error.\n \n       ---------------\n       -- Elab_Spec --\n       ---------------\n \n       Attribute_Elab_Spec => True,\n-      --\n       --  This attribute can only be applied to a program unit name. It\n       --  returns the entity for the corresponding elaboration procedure\n       --  for elaborating the spec of the referenced unit. This is used\n@@ -202,7 +193,6 @@ package Sem_Attr is\n       ----------------\n \n       Attribute_Elaborated => True,\n-      --\n       --  Lunit'Elaborated, where Lunit is a library unit, yields a boolean\n       --  value indicating whether or not the body of the designated library\n       --  unit has been elaborated yet.\n@@ -212,7 +202,6 @@ package Sem_Attr is\n       --------------\n \n       Attribute_Enum_Rep => True,\n-      --\n       --  For every enumeration subtype S, S'Enum_Rep denotes a function\n       --  with the following specification:\n       --\n@@ -228,7 +217,6 @@ package Sem_Attr is\n       -----------------\n \n       Attribute_Fixed_Value => True,\n-      --\n       --  For every fixed-point type S, S'Fixed_Value denotes a function\n       --  with the following specification:\n       --\n@@ -238,18 +226,17 @@ package Sem_Attr is\n       --\n       --    V = Arg * S'Small\n       --\n-      --  The effect is thus equivalent to first converting the argument\n-      --  to the integer type used to represent S, and then doing an\n-      --  unchecked conversion to the fixed-point type. This attribute is\n-      --  primarily intended for use in implementation of the input-output\n-      --  functions for fixed-point values.\n+      --  The effect is thus equivalent to first converting the argument to\n+      --  the integer type used to represent S, and then doing an unchecked\n+      --  conversion to the fixed-point type. This attribute is primarily\n+      --  intended for use in implementation of the input-output functions for\n+      --  fixed-point values.\n \n       -----------------------\n       -- Has_Discriminants --\n       -----------------------\n \n       Attribute_Has_Discriminants => True,\n-      --\n       --  Gtyp'Has_Discriminants, where Gtyp is a generic formal type, yields\n       --  a Boolean value indicating whether or not the actual instantiation\n       --  type has discriminants.\n@@ -259,7 +246,6 @@ package Sem_Attr is\n       ---------\n \n       Attribute_Img => True,\n-      --\n       --  The 'Img function is defined for any prefix, P, that denotes an\n       --  object of scalar type T. P'Img is equivalent to T'Image (P). This\n       --  is convenient for debugging. For example:\n@@ -277,7 +263,6 @@ package Sem_Attr is\n       -------------------\n \n       Attribute_Integer_Value => True,\n-      --\n       --  For every integer type S, S'Integer_Value denotes a function\n       --  with the following specification:\n       --\n@@ -298,7 +283,6 @@ package Sem_Attr is\n       ------------------\n \n       Attribute_Machine_Size => True,\n-      --\n       --  This attribute is identical to the Object_Size attribute. It is\n       --  provided for compatibility with the DEC attribute of this name.\n \n@@ -307,7 +291,6 @@ package Sem_Attr is\n       -----------------------\n \n       Attribute_Maximum_Alignment => True,\n-      --\n       --  Standard'Maximum_Alignment (Standard is the only permissible prefix)\n       --  provides the maximum useful alignment value for the target. This\n       --  is a static value that can be used to specify the alignment for an\n@@ -320,7 +303,6 @@ package Sem_Attr is\n       --------------------\n \n       Attribute_Mechanism_Code => True,\n-      --\n       --  function'Mechanism_Code yeilds an integer code for the mechanism\n       --  used for the result of function, and subprogram'Mechanism_Code (n)\n       --  yields the mechanism used for formal parameter number n (a static\n@@ -342,64 +324,59 @@ package Sem_Attr is\n       --------------------\n \n       Attribute_Null_Parameter => True,\n+      --  A reference T'Null_Parameter denotes an (imaginary) object of type or\n+      --  subtype T allocated at (machine) address zero. The attribute is\n+      --  allowed only as the default expression of a formal parameter, or as\n+      --  an actual expression of a subporgram call. In either case, the\n+      --  subprogram must be imported.\n       --\n-      --  A reference T'Null_Parameter denotes an (imaginary) object of\n-      --  type or subtype T allocated at (machine) address zero. The\n-      --  attribute is allowed only as the default expression of a formal\n-      --  parameter, or as an actual expression of a subporgram call. In\n-      --  either case, the subprogram must be imported.\n-      --\n-      --  The identity of the object is represented by the address zero\n-      --  in the argument list, independent of the passing mechanism\n-      --  (explicit or default).\n+      --  The identity of the object is represented by the address zero in the\n+      --  argument list, independent of the passing mechanism (explicit or\n+      --  default).\n       --\n-      --  The reason that this capability is needed is that for a record\n-      --  or other composite object passed by reference, there is no other\n-      --  way of specifying that a zero address should be passed.\n+      --  The reason that this capability is needed is that for a record or\n+      --  other composite object passed by reference, there is no other way of\n+      --  specifying that a zero address should be passed.\n \n       -----------------\n       -- Object_Size --\n       -----------------\n \n       Attribute_Object_Size => True,\n-      --\n       --  Type'Object_Size is the same as Type'Size for all types except\n       --  fixed-point types and discrete types. For fixed-point types and\n       --  discrete types, this attribute gives the size used for default\n-      --  allocation of objects and components of the size. See section\n-      --  in Einfo (\"Handling of type'Size values\") for further details.\n+      --  allocation of objects and components of the size. See section in\n+      --  Einfo (\"Handling of type'Size values\") for further details.\n \n       -------------------------\n       -- Passed_By_Reference --\n       -------------------------\n \n       Attribute_Passed_By_Reference => True,\n-      --\n-      --  T'Passed_By_Reference for any subtype T returns a boolean value\n-      --  that is true if the type is normally passed by reference and\n-      --  false if the type is normally passed by copy in calls. For scalar\n-      --  types, the result is always False and is static. For non-scalar\n-      --  types, the result is non-static (since it is computed by Gigi).\n+      --  T'Passed_By_Reference for any subtype T returns a boolean value that\n+      --  is true if the type is normally passed by reference and false if the\n+      --  type is normally passed by copy in calls. For scalar types, the\n+      --  result is always False and is static. For non-scalar types, the\n+      --  result is non-static (since it is computed by Gigi).\n \n       ------------------\n       -- Range_Length --\n       ------------------\n \n       Attribute_Range_Length => True,\n-      --\n-      --  T'Range_Length for any discrete type T yields the number of\n-      --  values represented by the subtype (zero for a null range). The\n-      --  result is static for static subtypes. Note that Range_Length\n-      --  applied to the index subtype of a one dimensional array always\n-      --  gives the same result as Range applied to the array itself.\n-      --  The result is of type universal integer.\n+      --  T'Range_Length for any discrete type T yields the number of values\n+      --  represented by the subtype (zero for a null range). The result is\n+      --  static for static subtypes. Note that Range_Length applied to the\n+      --  index subtype of a one dimensional array always gives the same result\n+      --  as Range applied to the array itself. The result is of type universal\n+      --  integer.\n \n       ------------------\n       -- Storage_Unit --\n       ------------------\n \n       Attribute_Storage_Unit => True,\n-      --\n       --  Standard'Storage_Unit (Standard is the only permissible prefix)\n       --  provides the value System.Storage_Unit, and is intended primarily\n       --  for constructing this definition in package System (see note above\n@@ -410,36 +387,33 @@ package Sem_Attr is\n       -----------------\n \n       Attribute_Target_Name => True,\n-      --\n-      --  Standard'Target_Name yields the string identifying the target\n-      --  for the compilation, taken from Sdefault.Target_Name.\n+      --  Standard'Target_Name yields the string identifying the target for the\n+      --  compilation, taken from Sdefault.Target_Name.\n \n       ----------------\n       -- To_Address --\n       ----------------\n \n       Attribute_To_Address => True,\n-      --\n-      --  System'To_Address (Address is the only permissible prefix)\n-      --  is a function that takes any integer value, and converts it into\n-      --  an address value. The semantics is to first convert the integer\n-      --  value to type Integer_Address according to normal conversion\n-      --  rules, and then to convert this to an address using the same\n-      --  semantics as the System.Storage_Elements.To_Address function.\n-      --  The important difference is that this is a static attribute\n-      --  so it can be used in initializations in preealborate packages.\n+      --  System'To_Address (Address is the only permissible prefix) is a\n+      --  function that takes any integer value, and converts it into an\n+      --  address value. The semantics is to first convert the integer value to\n+      --  type Integer_Address according to normal conversion rules, and then\n+      --  to convert this to an address using the same semantics as the\n+      --  System.Storage_Elements.To_Address function. The important difference\n+      --  is that this is a static attribute so it can be used in\n+      --  initializations in preealborate packages.\n \n       ----------------\n       -- Type_Class --\n       ----------------\n \n       Attribute_Type_Class => True,\n-      --\n-      --  T'Type_Class for any type or subtype T yields the value of the\n-      --  type class for the full type of T. If T is a generic formal type,\n-      --  then the value is the value for the corresponding actual subtype.\n-      --  The value of this attribute is of type System.Aux_DEC.Type_Class,\n-      --  which has the following definition:\n+      --  T'Type_Class for any type or subtype T yields the value of the type\n+      --  class for the full type of T. If T is a generic formal type, then the\n+      --  value is the value for the corresponding actual subtype. The value of\n+      --  this attribute is of type System.Aux_DEC.Type_Class, which has the\n+      --  following definition:\n       --\n       --    type Type_Class is\n       --      (Type_Class_Enumeration,\n@@ -452,9 +426,9 @@ package Sem_Attr is\n       --       Type_Class_Task,\n       --       Type_Class_Address);\n       --\n-      --  Protected types yield the value Type_Class_Task, which thus\n-      --  applies to all concurrent types. This attribute is designed to\n-      --  be compatible with the DEC Ada attribute of the same name.\n+      --  Protected types yield the value Type_Class_Task, which thus applies\n+      --  to all concurrent types. This attribute is designed to be compatible\n+      --  with the DEC Ada attribute of the same name.\n       --\n       --  Note: if pragma Extend_System is used to merge the definitions of\n       --  Aux_DEC into System, then the type Type_Class can be referenced\n@@ -465,7 +439,6 @@ package Sem_Attr is\n       -----------------\n \n       Attribute_UET_Address => True,\n-      --\n       --  Unit'UET_Address, where Unit is a program unit, yields the address\n       --  of the unit exception table for the specified unit. This is only\n       --  used in the internal implementation of exception handling. See the\n@@ -476,23 +449,21 @@ package Sem_Attr is\n       ------------------------------\n \n       Attribute_Universal_Literal_String => True,\n-      --\n-      --  The prefix of 'Universal_Literal_String must be a named number.\n-      --  The static result is the string consisting of the characters of\n-      --  the number as defined in the original source. This allows the\n-      --  user program to access the actual text of named numbers without\n-      --  intermediate conversions and without the need to enclose the\n-      --  strings in quotes (which would preclude their use as numbers).\n-      --  This is used internally for the construction of values of the\n-      --  floating-point attributes from the file ttypef.ads, but may\n-      --  also be used by user programs.\n+      --  The prefix of 'Universal_Literal_String must be a named number. The\n+      --  static result is the string consisting of the characters of the\n+      --  number as defined in the original source. This allows the user\n+      --  program to access the actual text of named numbers without\n+      --  intermediate conversions and without the need to enclose the strings\n+      --  in quotes (which would preclude their use as numbers). This is used\n+      --  internally for the construction of values of the floating-point\n+      --  attributes from the file ttypef.ads, but may also be used by user\n+      --  programs.\n \n       -------------------------\n       -- Unrestricted_Access --\n       -------------------------\n \n       Attribute_Unrestricted_Access => True,\n-      --\n       --  The Unrestricted_Access attribute is similar to Access except that\n       --  all accessibility and aliased view checks are omitted. This is very\n       --  much a user-beware attribute. Basically its status is very similar\n@@ -510,32 +481,28 @@ package Sem_Attr is\n       ---------------\n \n       Attribute_VADS_Size => True,\n-      --\n-      --  Typ'VADS_Size yields the Size value typically yielded by some\n-      --  Ada 83 compilers. The differences between VADS_Size and Size\n-      --  is that for scalar types for which no Size has been specified,\n-      --  VADS_Size yields the Object_Size rather than the Value_Size.\n-      --  For example, while Natural'Size is typically 31, the value of\n-      --  Natural'VADS_Size is 32. For all other types, Size and VADS_Size\n-      --  yield the same value.\n+      --  Typ'VADS_Size yields the Size value typically yielded by some Ada 83\n+      --  compilers. The differences between VADS_Size and Size is that for\n+      --  scalar types for which no Size has been specified, VADS_Size yields\n+      --  the Object_Size rather than the Value_Size. For example, while\n+      --  Natural'Size is typically 31, the value of Natural'VADS_Size is 32.\n+      --  For all other types, Size and VADS_Size yield the same value.\n \n       ----------------\n       -- Value_Size --\n       ----------------\n \n       Attribute_Value_Size => True,\n-      --\n-      --  Type'Value_Size is the number of bits required to represent a\n-      --  value of the given subtype. It is the same as Type'Size, but,\n-      --  unlike Size, may be set for non-first subtypes. See section\n-      --  in Einfo (\"Handling of type'Size values\") for further details.\n+      --  Type'Value_Size is the number of bits required to represent value of\n+      --  the given subtype. It is the same as Type'Size, but, unlike Size, may\n+      --  be set for non-first subtypes. See section in Einfo (\"Handling of\n+      --  type'Size values\") for further details.\n \n       ---------------\n       -- Word_Size --\n       ---------------\n \n       Attribute_Word_Size => True,\n-      --\n       --  Standard'Word_Size (Standard is the only permissible prefix)\n       --  provides the value System.Word_Size, and is intended primarily\n       --  for constructing this definition in package System (see note above\n@@ -554,14 +521,26 @@ package Sem_Attr is\n    --  other attributes).\n \n    procedure Resolve_Attribute (N : Node_Id; Typ : Entity_Id);\n-   --  Performs type resolution of attribute. If the attribute yields\n-   --  a universal value, mark its type as that of the context. On\n-   --  the other hand, if the context itself is universal (as in\n-   --  T'Val (T'Pos (X)), mark the type as being the largest type of\n-   --  that class that can be used at run-time. This is correct since\n-   --  either the value gets folded (in which case it doesn't matter\n-   --  what type of the class we give if, since the folding uses universal\n-   --  arithmetic anyway) or it doesn't get folded (in which case it is\n-   --  going to be dealt with at runtime, and the largest type is right).\n+   --  Performs type resolution of attribute. If the attribute yields a\n+   --  universal value, mark its type as that of the context. On the other\n+   --  hand, if the context itself is universal (as in T'Val (T'Pos (X)), mark\n+   --  the type as being the largest type of that class that can be used at\n+   --  run-time. This is correct since either the value gets folded (in which\n+   --  case it doesn't matter what type of the class we give if, since the\n+   --  folding uses universal arithmetic anyway) or it doesn't get folded (in\n+   --  which case it is going to be dealt with at runtime, and the largest type\n+   --  is right).\n+\n+   function Stream_Attribute_Available\n+     (Typ          : Entity_Id;\n+      Nam          : TSS_Name_Type;\n+      Partial_View : Entity_Id := Empty) return Boolean;\n+   --  For a limited type Typ, return True iff the given attribute is\n+   --  available. For Ada 05, availability is defined by 13.13.2(36/1). For Ada\n+   --  95, an attribute is considered to be available if it has been specified\n+   --  using an attribute definition clause for the type, or for its full view,\n+   --  or for an ancestor of either. Parameter Partial_View is used only\n+   --  internally, when checking for an attribute definition clause that is not\n+   --  visible (Ada 95 only).\n \n end Sem_Attr;"}, {"sha": "10846a329fbd770278d6975df562bf819ff9520c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 152, "deletions": 379, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -244,6 +244,137 @@ package body Sem_Ch13 is\n       --  disallow Storage_Size for derived task types, but that is also\n       --  clearly unintentional.\n \n+      procedure Analyze_Stream_TSS_Definition (TSS_Nam : TSS_Name_Type);\n+      --  Common processing for 'Read, 'Write, 'Input and 'Output attribute\n+      --  definition clauses.\n+\n+      procedure Analyze_Stream_TSS_Definition (TSS_Nam : TSS_Name_Type) is\n+         Subp : Entity_Id := Empty;\n+         I    : Interp_Index;\n+         It   : Interp;\n+         Pnam : Entity_Id;\n+\n+         Is_Read : constant Boolean := (TSS_Nam = TSS_Stream_Read);\n+\n+         function Has_Good_Profile (Subp : Entity_Id) return Boolean;\n+         --  Return true if the entity is a subprogram with an appropriate\n+         --  profile for the attribute being defined.\n+\n+         ----------------------\n+         -- Has_Good_Profile --\n+         ----------------------\n+\n+         function Has_Good_Profile (Subp : Entity_Id) return Boolean is\n+            F              : Entity_Id;\n+            Is_Function    : constant Boolean := (TSS_Nam = TSS_Stream_Input);\n+            Expected_Ekind : constant array (Boolean) of Entity_Kind :=\n+                               (False => E_Procedure, True => E_Function);\n+            Typ            : Entity_Id;\n+\n+         begin\n+            if Ekind (Subp) /= Expected_Ekind (Is_Function) then\n+               return False;\n+            end if;\n+\n+            F := First_Formal (Subp);\n+\n+            if No (F)\n+              or else Ekind (Etype (F)) /= E_Anonymous_Access_Type\n+              or else Designated_Type (Etype (F)) /=\n+                               Class_Wide_Type (RTE (RE_Root_Stream_Type))\n+            then\n+               return False;\n+            end if;\n+\n+            if not Is_Function then\n+               Next_Formal (F);\n+\n+               declare\n+                  Expected_Mode : constant array (Boolean) of Entity_Kind :=\n+                                    (False => E_In_Parameter,\n+                                     True  => E_Out_Parameter);\n+               begin\n+                  if Parameter_Mode (F) /= Expected_Mode (Is_Read) then\n+                     return False;\n+                  end if;\n+               end;\n+\n+               Typ := Etype (F);\n+\n+            else\n+               Typ := Etype (Subp);\n+            end if;\n+\n+            return Base_Type (Typ) = Base_Type (Ent)\n+              and then No (Next_Formal (F));\n+\n+         end Has_Good_Profile;\n+\n+      --  Start of processing for Analyze_Stream_TSS_Definition\n+\n+      begin\n+         FOnly := True;\n+\n+         if not Is_Type (U_Ent) then\n+            Error_Msg_N (\"local name must be a subtype\", Nam);\n+            return;\n+         end if;\n+\n+         Pnam := TSS (Base_Type (U_Ent), TSS_Nam);\n+\n+         if Present (Pnam) and then Has_Good_Profile (Pnam) then\n+            Error_Msg_Sloc := Sloc (Pnam);\n+            Error_Msg_Name_1 := Attr;\n+            Error_Msg_N (\"% attribute already defined #\", Nam);\n+            return;\n+         end if;\n+\n+         Analyze (Expr);\n+\n+         if Is_Entity_Name (Expr) then\n+            if not Is_Overloaded (Expr) then\n+               if Has_Good_Profile (Entity (Expr)) then\n+                  Subp := Entity (Expr);\n+               end if;\n+\n+            else\n+               Get_First_Interp (Expr, I, It);\n+\n+               while Present (It.Nam) loop\n+                  if Has_Good_Profile (It.Nam) then\n+                     Subp := It.Nam;\n+                     exit;\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end if;\n+         end if;\n+\n+         if Present (Subp) then\n+            if Is_Abstract (Subp) then\n+               Error_Msg_N (\"stream subprogram must not be abstract\", Expr);\n+               return;\n+            end if;\n+\n+            Set_Entity (Expr, Subp);\n+            Set_Etype (Expr, Etype (Subp));\n+\n+            if TSS_Nam = TSS_Stream_Input then\n+               New_Stream_Function (N, U_Ent, Subp, TSS_Nam);\n+            else\n+               New_Stream_Procedure (N, U_Ent, Subp, TSS_Nam,\n+                                     Out_P => Is_Read);\n+            end if;\n+\n+         else\n+            Error_Msg_Name_1 := Attr;\n+            Error_Msg_N (\"incorrect expression for% attribute\", Expr);\n+         end if;\n+      end Analyze_Stream_TSS_Definition;\n+\n+   --  Start of processing for Analyze_Attribute_Definition_Clause\n+\n    begin\n       Analyze (Nam);\n       Ent := Entity (Nam);\n@@ -252,26 +383,26 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n-      --  Rep clause applies to full view of incomplete type or private type\n-      --  if we have one (if not, this is a premature use of the type).\n-      --  However, certain semantic checks need to be done on the specified\n-      --  entity (i.e. the private view), so we save it in Ent.\n+      --  Rep clause applies to full view of incomplete type or private type if\n+      --  we have one (if not, this is a premature use of the type). However,\n+      --  certain semantic checks need to be done on the specified entity (i.e.\n+      --  the private view), so we save it in Ent.\n \n       if Is_Private_Type (Ent)\n         and then Is_Derived_Type (Ent)\n         and then not Is_Tagged_Type (Ent)\n         and then No (Full_View (Ent))\n       then\n-         --  If this is a private type whose completion is a derivation\n-         --  from another private type, there is no full view, and the\n-         --  attribute belongs to the type itself, not its underlying parent.\n+         --  If this is a private type whose completion is a derivation from\n+         --  another private type, there is no full view, and the attribute\n+         --  belongs to the type itself, not its underlying parent.\n \n          U_Ent := Ent;\n \n       elsif Ekind (Ent) = E_Incomplete_Type then\n \n-         --  The attribute applies to the full view, set the entity\n-         --  of the attribute definition accordingly.\n+         --  The attribute applies to the full view, set the entity of the\n+         --  attribute definition accordingly.\n \n          Ent := Underlying_Type (Ent);\n          U_Ent := Ent;\n@@ -668,94 +799,9 @@ package body Sem_Ch13 is\n          -- Input --\n          -----------\n \n-         when Attribute_Input => Input : declare\n-            Subp : Entity_Id := Empty;\n-            I    : Interp_Index;\n-            It   : Interp;\n-            Pnam : Entity_Id;\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean;\n-            --  Return true if the entity is a function with an appropriate\n-            --  profile for the Input attribute.\n-\n-            ----------------------\n-            -- Has_Good_Profile --\n-            ----------------------\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean is\n-               F  : Entity_Id;\n-               Ok : Boolean := False;\n-\n-            begin\n-               if Ekind (Subp) = E_Function then\n-                  F := First_Formal (Subp);\n-\n-                  if Present (F) and then No (Next_Formal (F)) then\n-                     if Ekind (Etype (F)) = E_Anonymous_Access_Type\n-                       and then\n-                         Designated_Type (Etype (F)) =\n-                           Class_Wide_Type (RTE (RE_Root_Stream_Type))\n-                     then\n-                        Ok := Base_Type (Etype (Subp)) = Base_Type (Ent);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               return Ok;\n-            end Has_Good_Profile;\n-\n-         --  Start of processing for Input attribute definition\n-\n-         begin\n-            FOnly := True;\n-\n-            if not Is_Type (U_Ent) then\n-               Error_Msg_N (\"local name must be a subtype\", Nam);\n-               return;\n-\n-            else\n-               Pnam := TSS (Base_Type (U_Ent), TSS_Stream_Input);\n-\n-               if Present (Pnam)\n-                 and then Base_Type (Etype (Pnam)) = Base_Type (U_Ent)\n-               then\n-                  Error_Msg_Sloc := Sloc (Pnam);\n-                  Error_Msg_N (\"input attribute already defined #\", Nam);\n-                  return;\n-               end if;\n-            end if;\n-\n-            Analyze (Expr);\n-\n-            if Is_Entity_Name (Expr) then\n-               if not Is_Overloaded (Expr) then\n-                  if Has_Good_Profile (Entity (Expr)) then\n-                     Subp := Entity (Expr);\n-                  end if;\n-\n-               else\n-                  Get_First_Interp (Expr, I, It);\n-\n-                  while Present (It.Nam) loop\n-                     if Has_Good_Profile (It.Nam) then\n-                        Subp := It.Nam;\n-                        exit;\n-                     end if;\n-\n-                     Get_Next_Interp (I, It);\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            if Present (Subp) then\n-               Set_Entity (Expr, Subp);\n-               Set_Etype (Expr, Etype (Subp));\n-               New_Stream_Function (N, U_Ent, Subp,  TSS_Stream_Input);\n-            else\n-               Error_Msg_N (\"incorrect expression for input attribute\", Expr);\n-               return;\n-            end if;\n-         end Input;\n+         when Attribute_Input =>\n+            Analyze_Stream_TSS_Definition (TSS_Stream_Input);\n+            Set_Has_Specified_Stream_Input (Ent);\n \n          -------------------\n          -- Machine_Radix --\n@@ -831,198 +877,17 @@ package body Sem_Ch13 is\n          -- Output --\n          ------------\n \n-         when Attribute_Output => Output : declare\n-            Subp : Entity_Id := Empty;\n-            I    : Interp_Index;\n-            It   : Interp;\n-            Pnam : Entity_Id;\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean;\n-            --  Return true if the entity is a procedure with an\n-            --  appropriate profile for the output attribute.\n-\n-            ----------------------\n-            -- Has_Good_Profile --\n-            ----------------------\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean is\n-               F  : Entity_Id;\n-               Ok : Boolean := False;\n-\n-            begin\n-               if Ekind (Subp) = E_Procedure then\n-                  F := First_Formal (Subp);\n-\n-                  if Present (F) then\n-                     if Ekind (Etype (F)) = E_Anonymous_Access_Type\n-                       and then\n-                         Designated_Type (Etype (F)) =\n-                           Class_Wide_Type (RTE (RE_Root_Stream_Type))\n-                     then\n-                        Next_Formal (F);\n-                        Ok :=  Present (F)\n-                          and then Parameter_Mode (F) = E_In_Parameter\n-                          and then Base_Type (Etype (F)) = Base_Type (Ent)\n-                          and then No (Next_Formal (F));\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               return Ok;\n-            end Has_Good_Profile;\n-\n-         --  Start of processing for Output attribute definition\n-\n-         begin\n-            FOnly := True;\n-\n-            if not Is_Type (U_Ent) then\n-               Error_Msg_N (\"local name must be a subtype\", Nam);\n-               return;\n-\n-            else\n-               Pnam := TSS (Base_Type (U_Ent), TSS_Stream_Output);\n-\n-               if Present (Pnam)\n-                 and then\n-                   Base_Type (Etype (Next_Formal (First_Formal (Pnam))))\n-                                                        = Base_Type (U_Ent)\n-               then\n-                  Error_Msg_Sloc := Sloc (Pnam);\n-                  Error_Msg_N (\"output attribute already defined #\", Nam);\n-                  return;\n-               end if;\n-            end if;\n-\n-            Analyze (Expr);\n-\n-            if Is_Entity_Name (Expr) then\n-               if not Is_Overloaded (Expr) then\n-                  if Has_Good_Profile (Entity (Expr)) then\n-                     Subp := Entity (Expr);\n-                  end if;\n-\n-               else\n-                  Get_First_Interp (Expr, I, It);\n-\n-                  while Present (It.Nam) loop\n-                     if Has_Good_Profile (It.Nam) then\n-                        Subp := It.Nam;\n-                        exit;\n-                     end if;\n-\n-                     Get_Next_Interp (I, It);\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            if Present (Subp) then\n-               Set_Entity (Expr, Subp);\n-               Set_Etype (Expr, Etype (Subp));\n-               New_Stream_Procedure (N, U_Ent, Subp, TSS_Stream_Output);\n-            else\n-               Error_Msg_N (\"incorrect expression for output attribute\", Expr);\n-               return;\n-            end if;\n-         end Output;\n+         when Attribute_Output =>\n+            Analyze_Stream_TSS_Definition (TSS_Stream_Output);\n+            Set_Has_Specified_Stream_Output (Ent);\n \n          ----------\n          -- Read --\n          ----------\n \n-         when Attribute_Read => Read : declare\n-            Subp : Entity_Id := Empty;\n-            I    : Interp_Index;\n-            It   : Interp;\n-            Pnam : Entity_Id;\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean;\n-            --  Return true if the entity is a procedure with an appropriate\n-            --  profile for the Read attribute.\n-\n-            ----------------------\n-            -- Has_Good_Profile --\n-            ----------------------\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean is\n-               F     : Entity_Id;\n-               Ok    : Boolean := False;\n-\n-            begin\n-               if Ekind (Subp) = E_Procedure then\n-                  F := First_Formal (Subp);\n-\n-                  if Present (F) then\n-                     if Ekind (Etype (F)) = E_Anonymous_Access_Type\n-                       and then\n-                         Designated_Type (Etype (F)) =\n-                           Class_Wide_Type (RTE (RE_Root_Stream_Type))\n-                     then\n-                        Next_Formal (F);\n-                        Ok :=  Present (F)\n-                          and then Parameter_Mode (F) = E_Out_Parameter\n-                          and then Base_Type (Etype (F)) = Base_Type (Ent)\n-                          and then No (Next_Formal (F));\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               return Ok;\n-            end Has_Good_Profile;\n-\n-         --  Start of processing for Read attribute definition\n-\n-         begin\n-            FOnly := True;\n-\n-            if not Is_Type (U_Ent) then\n-               Error_Msg_N (\"local name must be a subtype\", Nam);\n-               return;\n-\n-            else\n-               Pnam := TSS (Base_Type (U_Ent), TSS_Stream_Read);\n-\n-               if Present (Pnam)\n-                 and then Base_Type (Etype (Next_Formal (First_Formal (Pnam))))\n-                   = Base_Type (U_Ent)\n-               then\n-                  Error_Msg_Sloc := Sloc (Pnam);\n-                  Error_Msg_N (\"read attribute already defined #\", Nam);\n-                  return;\n-               end if;\n-            end if;\n-\n-            Analyze (Expr);\n-\n-            if Is_Entity_Name (Expr) then\n-               if not Is_Overloaded (Expr) then\n-                  if Has_Good_Profile (Entity (Expr)) then\n-                     Subp := Entity (Expr);\n-                  end if;\n-\n-               else\n-                  Get_First_Interp (Expr, I, It);\n-\n-                  while Present (It.Nam) loop\n-                     if Has_Good_Profile (It.Nam) then\n-                        Subp := It.Nam;\n-                        exit;\n-                     end if;\n-\n-                     Get_Next_Interp (I, It);\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            if Present (Subp) then\n-               Set_Entity (Expr, Subp);\n-               Set_Etype (Expr, Etype (Subp));\n-               New_Stream_Procedure (N, U_Ent, Subp, TSS_Stream_Read, True);\n-            else\n-               Error_Msg_N (\"incorrect expression for read attribute\", Expr);\n-               return;\n-            end if;\n-         end Read;\n+         when Attribute_Read =>\n+            Analyze_Stream_TSS_Definition (TSS_Stream_Read);\n+            Set_Has_Specified_Stream_Read (Ent);\n \n          ----------\n          -- Size --\n@@ -1436,101 +1301,9 @@ package body Sem_Ch13 is\n          -- Write --\n          -----------\n \n-         --  Write attribute definition clause\n-         --  check for class-wide case will be performed later\n-\n-         when Attribute_Write => Write : declare\n-            Subp : Entity_Id := Empty;\n-            I    : Interp_Index;\n-            It   : Interp;\n-            Pnam : Entity_Id;\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean;\n-            --  Return true if the entity is a procedure with an\n-            --  appropriate profile for the write attribute.\n-\n-            ----------------------\n-            -- Has_Good_Profile --\n-            ----------------------\n-\n-            function Has_Good_Profile (Subp : Entity_Id) return Boolean is\n-               F     : Entity_Id;\n-               Ok    : Boolean := False;\n-\n-            begin\n-               if Ekind (Subp) = E_Procedure then\n-                  F := First_Formal (Subp);\n-\n-                  if Present (F) then\n-                     if Ekind (Etype (F)) = E_Anonymous_Access_Type\n-                       and then\n-                         Designated_Type (Etype (F)) =\n-                           Class_Wide_Type (RTE (RE_Root_Stream_Type))\n-                     then\n-                        Next_Formal (F);\n-                        Ok :=  Present (F)\n-                          and then Parameter_Mode (F) = E_In_Parameter\n-                          and then Base_Type (Etype (F)) = Base_Type (Ent)\n-                          and then No (Next_Formal (F));\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               return Ok;\n-            end Has_Good_Profile;\n-\n-         --  Start of processing for Write attribute definition\n-\n-         begin\n-            FOnly := True;\n-\n-            if not Is_Type (U_Ent) then\n-               Error_Msg_N (\"local name must be a subtype\", Nam);\n-               return;\n-            end if;\n-\n-            Pnam := TSS (Base_Type (U_Ent), TSS_Stream_Write);\n-\n-            if Present (Pnam)\n-              and then Base_Type (Etype (Next_Formal (First_Formal (Pnam))))\n-                = Base_Type (U_Ent)\n-            then\n-               Error_Msg_Sloc := Sloc (Pnam);\n-               Error_Msg_N (\"write attribute already defined #\", Nam);\n-               return;\n-            end if;\n-\n-            Analyze (Expr);\n-\n-            if Is_Entity_Name (Expr) then\n-               if not Is_Overloaded (Expr) then\n-                  if Has_Good_Profile (Entity (Expr)) then\n-                     Subp := Entity (Expr);\n-                  end if;\n-\n-               else\n-                  Get_First_Interp (Expr, I, It);\n-\n-                  while Present (It.Nam) loop\n-                     if Has_Good_Profile (It.Nam) then\n-                        Subp := It.Nam;\n-                        exit;\n-                     end if;\n-\n-                     Get_Next_Interp (I, It);\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            if Present (Subp) then\n-               Set_Entity (Expr, Subp);\n-               Set_Etype (Expr, Etype (Subp));\n-               New_Stream_Procedure (N, U_Ent, Subp, TSS_Stream_Write);\n-            else\n-               Error_Msg_N (\"incorrect expression for write attribute\", Expr);\n-               return;\n-            end if;\n-         end Write;\n+         when Attribute_Write =>\n+            Analyze_Stream_TSS_Definition (TSS_Stream_Write);\n+            Set_Has_Specified_Stream_Write (Ent);\n \n          --  All other attributes cannot be set\n "}, {"sha": "c8c4a272576f6351cc3d5d95b5a323a9fad5ccee", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1114,48 +1114,10 @@ package body Sem_Ch7 is\n       Found_Explicit : Boolean;\n       Decl_Privates  : Boolean;\n \n-      function Has_Overriding_Pragma (Subp : Entity_Id) return Boolean;\n-      --  Check whether a pragma Overriding has been provided for a primitive\n-      --  operation that is found to be overriding in the private part.\n-\n       function Is_Primitive_Of (T : Entity_Id; S : Entity_Id) return Boolean;\n       --  Check whether an inherited subprogram is an operation of an\n       --  untagged derived type.\n \n-      ---------------------------\n-      -- Has_Overriding_Pragma --\n-      ---------------------------\n-\n-      function Has_Overriding_Pragma (Subp : Entity_Id) return Boolean is\n-         Decl : constant Node_Id := Unit_Declaration_Node (Subp);\n-         Prag : Node_Id;\n-\n-      begin\n-         if No (Decl)\n-           or else Nkind (Decl) /= N_Subprogram_Declaration\n-           or else No (Next (Decl))\n-         then\n-            return False;\n-\n-         else\n-            Prag := Next (Decl);\n-\n-            while Present (Prag)\n-              and then Nkind (Prag) = N_Pragma\n-            loop\n-               if Chars (Prag) = Name_Overriding\n-                 or else Chars (Prag) = Name_Optional_Overriding\n-               then\n-                  return True;\n-               else\n-                  Next (Prag);\n-               end if;\n-            end loop;\n-         end if;\n-\n-         return False;\n-      end Has_Overriding_Pragma;\n-\n       ---------------------\n       -- Is_Primitive_Of --\n       ---------------------\n@@ -1238,20 +1200,9 @@ package body Sem_Ch7 is\n                            Replace_Elmt (Op_Elmt, New_Op);\n                            Remove_Elmt (Op_List, Op_Elmt_2);\n                            Found_Explicit := True;\n+                           Set_Is_Overriding_Operation (New_Op);\n                            Decl_Privates  := True;\n \n-                           --  If explicit_overriding is in effect, check that\n-                           --  the overriding operation is properly labelled.\n-\n-                           if Explicit_Overriding\n-                             and then Comes_From_Source (New_Op)\n-                              and then not Has_Overriding_Pragma (New_Op)\n-                           then\n-                              Error_Msg_NE\n-                                (\"Missing overriding pragma for&\",\n-                                  New_Op, New_Op);\n-                           end if;\n-\n                            exit;\n                         end if;\n \n@@ -1692,9 +1643,13 @@ package body Sem_Ch7 is\n          Set_RM_Size (Priv, RM_Size (Full));\n          Set_Size_Known_At_Compile_Time (Priv, Size_Known_At_Compile_Time\n                                                                       (Full));\n-         Set_Is_Volatile       (Priv, Is_Volatile       (Full));\n-         Set_Treat_As_Volatile (Priv, Treat_As_Volatile (Full));\n-         Set_Is_Ada_2005       (Priv, Is_Ada_2005       (Full));\n+         Set_Is_Volatile        (Priv, Is_Volatile        (Full));\n+         Set_Treat_As_Volatile  (Priv, Treat_As_Volatile  (Full));\n+         Set_Is_Ada_2005        (Priv, Is_Ada_2005        (Full));\n+\n+         if Is_Unchecked_Union (Full) then\n+            Set_Is_Unchecked_Union (Base_Type (Priv));\n+         end if;\n          --  Why is atomic not copied here ???\n \n          if Referenced (Full) then\n@@ -1717,8 +1672,34 @@ package body Sem_Ch7 is\n            and then not Error_Posted (Full)\n          then\n             if Priv_Is_Base_Type then\n-               Set_Access_Disp_Table (Priv, Access_Disp_Table\n-                                                           (Base_Type (Full)));\n+\n+               --  Ada 2005 (AI-345): The full view of a type implementing\n+               --  an interface can be a task type.\n+\n+               --    type T is new I with private;\n+               --  private\n+               --    task type T is new I with ...\n+\n+               if Is_Interface (Etype (Priv))\n+                 and then Is_Concurrent_Type (Base_Type (Full))\n+               then\n+                  --  Protect the frontend against previous errors\n+\n+                  if Present (Corresponding_Record_Type\n+                               (Base_Type (Full)))\n+                  then\n+                     Set_Access_Disp_Table\n+                       (Priv, Access_Disp_Table\n+                               (Corresponding_Record_Type (Base_Type (Full))));\n+                  else\n+                     pragma Assert (Serious_Errors_Detected > 0);\n+                     null;\n+                  end if;\n+\n+               else\n+                  Set_Access_Disp_Table\n+                    (Priv, Access_Disp_Table (Base_Type (Full)));\n+               end if;\n             end if;\n \n             Set_First_Entity (Priv, First_Entity (Full));"}, {"sha": "ee920be0869015fa880a3cb3b0e610465a708de5", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 102, "deletions": 31, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1101,6 +1101,7 @@ package body Sem_Ch8 is\n    procedure Analyze_Subprogram_Renaming (N : Node_Id) is\n       Spec        : constant Node_Id          := Specification (N);\n       Save_AV     : constant Ada_Version_Type := Ada_Version;\n+      Save_AV_Exp : constant Ada_Version_Type := Ada_Version_Explicit;\n       Nam         : constant Node_Id          := Name (N);\n       New_S       : Entity_Id;\n       Old_S       : Entity_Id                 := Empty;\n@@ -1357,9 +1358,24 @@ package body Sem_Ch8 is\n          New_S := Rename_Spec;\n          Set_Has_Completion (Rename_Spec, False);\n \n+         --  Ada 2005: check overriding indicator.\n+\n+         if Must_Override (Specification (N))\n+           and then not Is_Overriding_Operation (Rename_Spec)\n+         then\n+            Error_Msg_NE (\"subprogram& is not overriding\", N, Rename_Spec);\n+\n+         elsif Must_Not_Override (Specification (N))\n+           and then Is_Overriding_Operation (Rename_Spec)\n+         then\n+            Error_Msg_NE\n+              (\"subprogram& overrides inherited operation\", N, Rename_Spec);\n+         end if;\n+\n       else\n          Generate_Definition (New_S);\n          New_Overloaded_Entity (New_S);\n+\n          if Is_Entity_Name (Nam)\n            and then Is_Intrinsic_Subprogram (Entity (Nam))\n          then\n@@ -1422,12 +1438,15 @@ package body Sem_Ch8 is\n          Set_Has_Completion (New_S);\n       end if;\n \n-      --  Find the renamed entity that matches the given specification.\n-      --  Disable Ada_83 because there is no requirement of full conformance\n-      --  between renamed entity and new entity, even though the same circuit\n-      --  is used.\n+      --  Find the renamed entity that matches the given specification. Disable\n+      --  Ada_83 because there is no requirement of full conformance between\n+      --  renamed entity and new entity, even though the same circuit is used.\n+      --  This is a bit of a kludge, which introduces a really irregular use of\n+      --  Ada_Version[_Explicit]. Would be nice to find cleaner way to do this\n+      --  ???\n \n       Ada_Version := Ada_Version_Type'Max (Ada_Version, Ada_95);\n+      Ada_Version_Explicit := Ada_Version;\n \n       if No (Old_S) then\n          Old_S := Find_Renamed_Entity (N, Name (N), New_S, Is_Actual);\n@@ -1444,11 +1463,10 @@ package body Sem_Ch8 is\n             Generate_Reference (Old_S, Nam);\n          end if;\n \n-         --  For a renaming-as-body, require subtype conformance,\n-         --  but if the declaration being completed has not been\n-         --  frozen, then inherit the convention of the renamed\n-         --  subprogram prior to checking conformance (unless the\n-         --  renaming has an explicit convention established; the\n+         --  For a renaming-as-body, require subtype conformance, but if the\n+         --  declaration being completed has not been frozen, then inherit the\n+         --  convention of the renamed subprogram prior to checking conformance\n+         --  (unless the renaming has an explicit convention established; the\n          --  rule stated in the RM doesn't seem to address this ???).\n \n          if Present (Rename_Spec) then\n@@ -1516,15 +1534,15 @@ package body Sem_Ch8 is\n                Set_Alias (New_S, Old_S);\n             end if;\n \n-            --  Note that we do not set Is_Intrinsic_Subprogram if we have\n-            --  a renaming as body, since the entity in this case is not an\n-            --  intrinsic (it calls an intrinsic, but we have a real body\n-            --  for this call, and it is in this body that the required\n-            --  intrinsic processing will take place).\n+            --  Note that we do not set Is_Intrinsic_Subprogram if we have a\n+            --  renaming as body, since the entity in this case is not an\n+            --  intrinsic (it calls an intrinsic, but we have a real body for\n+            --  this call, and it is in this body that the required intrinsic\n+            --  processing will take place).\n \n-            --  Also, if this is a renaming of inequality, the renamed\n-            --  operator is intrinsic, but what matters is the corresponding\n-            --  equality operator, which may be user-defined.\n+            --  Also, if this is a renaming of inequality, the renamed operator\n+            --  is intrinsic, but what matters is the corresponding equality\n+            --  operator, which may be user-defined.\n \n             Set_Is_Intrinsic_Subprogram\n               (New_S,\n@@ -1594,9 +1612,9 @@ package body Sem_Ch8 is\n          Set_Is_Abstract (New_S, Is_Abstract (Old_S));\n          Check_Library_Unit_Renaming (N, Old_S);\n \n-         --  Pathological case: procedure renames entry in the scope of\n-         --  its task. Entry is given by simple name, but body must be built\n-         --  for procedure. Of course if called it will deadlock.\n+         --  Pathological case: procedure renames entry in the scope of its\n+         --  task. Entry is given by simple name, but body must be built for\n+         --  procedure. Of course if called it will deadlock.\n \n          if Ekind (Old_S) = E_Entry then\n             Set_Has_Completion (New_S, False);\n@@ -1621,11 +1639,11 @@ package body Sem_Ch8 is\n          end if;\n \n       else\n-         --  A common error is to assume that implicit operators for types\n-         --  are defined in Standard, or in the scope of a subtype. In those\n-         --  cases where the renamed entity is given with an expanded name,\n-         --  it is worth mentioning that operators for the type are not\n-         --  declared in the scope given by the prefix.\n+         --  A common error is to assume that implicit operators for types are\n+         --  defined in Standard, or in the scope of a subtype. In those cases\n+         --  where the renamed entity is given with an expanded name, it is\n+         --  worth mentioning that operators for the type are not declared in\n+         --  the scope given by the prefix.\n \n          if Nkind (Nam) = N_Expanded_Name\n            and then Nkind (Selector_Name (Nam)) = N_Operator_Symbol\n@@ -1675,7 +1693,40 @@ package body Sem_Ch8 is\n          end if;\n       end if;\n \n+      --  Ada 2005 AI 404: if the new subprogram is dispatching, verify that\n+      --  controlling access parameters are known non-null for the renamed\n+      --  subprogram. Test also applies to a subprogram instantiation that\n+      --  is dispatching.\n+\n+      if Ada_Version >= Ada_05\n+        and then not Is_Dispatching_Operation (Old_S)\n+        and then Is_Dispatching_Operation (New_S)\n+      then\n+         declare\n+            Old_F : Entity_Id;\n+            New_F : Entity_Id;\n+\n+         begin\n+            Old_F := First_Formal (Old_S);\n+            New_F := First_Formal (New_S);\n+            while Present (Old_F) loop\n+               if Ekind (Etype (Old_F)) = E_Anonymous_Access_Type\n+                 and then Is_Controlling_Formal (New_F)\n+                 and then not Can_Never_Be_Null (Old_F)\n+               then\n+                  Error_Msg_N (\"access parameter is controlling,\", New_F);\n+                  Error_Msg_NE (\"\\corresponding parameter of& \" &\n+                    \" must be explicitly null excluding\", New_F, Old_S);\n+               end if;\n+\n+               Next_Formal (Old_F);\n+               Next_Formal (New_F);\n+            end loop;\n+         end;\n+      end if;\n+\n       Ada_Version := Save_AV;\n+      Ada_Version_Explicit := Save_AV_Exp;\n    end Analyze_Subprogram_Renaming;\n \n    -------------------------\n@@ -1699,9 +1750,9 @@ package body Sem_Ch8 is\n       Set_Hidden_By_Use_Clause (N, No_Elist);\n \n       --  Use clause is not allowed in a spec of a predefined package\n-      --  declaration except that packages whose file name starts a-n\n-      --  are OK (these are children of Ada.Numerics, and such packages\n-      --  are never loaded by Rtsfind).\n+      --  declaration except that packages whose file name starts a-n are OK\n+      --  (these are children of Ada.Numerics, and such packages are never\n+      --  loaded by Rtsfind).\n \n       if Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n         and then Name_Buffer (1 .. 3) /= \"a-n\"\n@@ -1809,7 +1860,7 @@ package body Sem_Ch8 is\n \n             if Nkind (Parent (N)) = N_Compilation_Unit then\n                if  Nkind (Id) = N_Identifier then\n-                  Error_Msg_N (\"Type is not directly visible\", Id);\n+                  Error_Msg_N (\"type is not directly visible\", Id);\n \n                elsif Is_Child_Unit (Scope (Entity (Id)))\n                  and then Scope (Entity (Id)) /= System_Aux_Id\n@@ -2130,6 +2181,11 @@ package body Sem_Ch8 is\n         and then Item /= N\n       loop\n          if Nkind (Item) = N_With_Clause\n+\n+            --  Protect the frontend against previously reported\n+            --  critical errors\n+\n+           and then Nkind (Name (Item)) /= N_Selected_Component\n            and then Entity (Name (Item)) = Pack\n          then\n             Par := Nam;\n@@ -3570,8 +3626,23 @@ package body Sem_Ch8 is\n             if Present (Candidate) then\n \n                if Is_Child_Unit (Candidate) then\n-                  Error_Msg_N\n-                    (\"missing with_clause for child unit &\", Selector);\n+\n+                  --  If the candidate is a private child unit and we are\n+                  --  in the visible part of a public unit, specialize the\n+                  --  error message. There might be a private with_clause for\n+                  --  it, but it is not currently active.\n+\n+                  if Is_Private_Descendant (Candidate)\n+                    and then Ekind (Current_Scope) = E_Package\n+                    and then not In_Private_Part (Current_Scope)\n+                    and then not Is_Private_Descendant (Current_Scope)\n+                  then\n+                     Error_Msg_N (\"private child unit& is not visible here\",\n+                       Selector);\n+                  else\n+                     Error_Msg_N\n+                       (\"missing with_clause for child unit &\", Selector);\n+                  end if;\n                else\n                   Error_Msg_NE (\"& is not a visible entity of&\", N, Selector);\n                end if;"}, {"sha": "ab963458c9955ea40e078bedd684f8ce68bf31ed", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 128, "deletions": 53, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -2773,6 +2773,53 @@ package body Sem_Util is\n         or else K = N_Package_Specification;\n    end Has_Declarations;\n \n+   -------------------------------------------\n+   -- Has_Discriminant_Dependent_Constraint --\n+   -------------------------------------------\n+\n+   function Has_Discriminant_Dependent_Constraint\n+     (Comp : Entity_Id) return Boolean\n+   is\n+      Comp_Decl  : constant Node_Id := Parent (Comp);\n+      Subt_Indic : constant Node_Id :=\n+                     Subtype_Indication (Component_Definition (Comp_Decl));\n+      Constr     : Node_Id;\n+      Assn       : Node_Id;\n+\n+   begin\n+      if Nkind (Subt_Indic) = N_Subtype_Indication then\n+         Constr := Constraint (Subt_Indic);\n+\n+         if Nkind (Constr) = N_Index_Or_Discriminant_Constraint then\n+            Assn := First (Constraints (Constr));\n+            while Present (Assn) loop\n+               case Nkind (Assn) is\n+                  when N_Subtype_Indication |\n+                       N_Range              |\n+                       N_Identifier\n+                  =>\n+                     if Depends_On_Discriminant (Assn) then\n+                        return True;\n+                     end if;\n+\n+                  when N_Discriminant_Association =>\n+                     if Depends_On_Discriminant (Expression (Assn)) then\n+                        return True;\n+                     end if;\n+\n+                  when others =>\n+                     null;\n+\n+               end case;\n+\n+               Next (Assn);\n+            end loop;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Has_Discriminant_Dependent_Constraint;\n+\n    --------------------\n    -- Has_Infinities --\n    --------------------\n@@ -3403,58 +3450,9 @@ package body Sem_Util is\n       P_Aliased   : Boolean := False;\n       Comp        : Entity_Id;\n \n-      function Has_Dependent_Constraint (Comp : Entity_Id) return Boolean;\n-      --  Returns True if and only if Comp has a constrained subtype\n-      --  that depends on a discriminant.\n-\n       function Is_Declared_Within_Variant (Comp : Entity_Id) return Boolean;\n       --  Returns True if and only if Comp is declared within a variant part\n \n-      ------------------------------\n-      -- Has_Dependent_Constraint --\n-      ------------------------------\n-\n-      function Has_Dependent_Constraint (Comp : Entity_Id) return Boolean is\n-         Comp_Decl  : constant Node_Id := Parent (Comp);\n-         Subt_Indic : constant Node_Id :=\n-                        Subtype_Indication (Component_Definition (Comp_Decl));\n-         Constr     : Node_Id;\n-         Assn       : Node_Id;\n-\n-      begin\n-         if Nkind (Subt_Indic) = N_Subtype_Indication then\n-            Constr := Constraint (Subt_Indic);\n-\n-            if Nkind (Constr) = N_Index_Or_Discriminant_Constraint then\n-               Assn := First (Constraints (Constr));\n-               while Present (Assn) loop\n-                  case Nkind (Assn) is\n-                     when N_Subtype_Indication |\n-                          N_Range              |\n-                          N_Identifier\n-                     =>\n-                        if Depends_On_Discriminant (Assn) then\n-                           return True;\n-                        end if;\n-\n-                     when N_Discriminant_Association =>\n-                        if Depends_On_Discriminant (Expression (Assn)) then\n-                           return True;\n-                        end if;\n-\n-                     when others =>\n-                        null;\n-\n-                  end case;\n-\n-                  Next (Assn);\n-               end loop;\n-            end if;\n-         end if;\n-\n-         return False;\n-      end Has_Dependent_Constraint;\n-\n       --------------------------------\n       -- Is_Declared_Within_Variant --\n       --------------------------------\n@@ -3503,8 +3501,21 @@ package body Sem_Util is\n \n             end if;\n \n+            --  A heap object is constrained by its initial value\n+\n+            --  Ada 2005 AI-363:if the designated type is a type with a\n+            --  constrained partial view, the resulting heap object is not\n+            --  constrained, and a renaming of the component is now unsafe.\n+\n             if Is_Access_Type (Prefix_Type)\n-              or else Nkind (P) = N_Explicit_Dereference\n+              and then\n+                 not Has_Constrained_Partial_View\n+                   (Designated_Type (Prefix_Type))\n+            then\n+               return False;\n+\n+            elsif Nkind (P) = N_Explicit_Dereference\n+              and then not Has_Constrained_Partial_View (Prefix_Type)\n             then\n                return False;\n             end if;\n@@ -3523,7 +3534,7 @@ package body Sem_Util is\n                             and then In_Package_Body (Current_Scope)))\n \n               and then (Is_Declared_Within_Variant (Comp)\n-                          or else Has_Dependent_Constraint (Comp))\n+                          or else Has_Discriminant_Dependent_Constraint (Comp))\n               and then not P_Aliased\n             then\n                return True;\n@@ -4306,6 +4317,70 @@ package body Sem_Util is\n       end if;\n    end Is_Partially_Initialized_Type;\n \n+   ------------------------------------\n+   -- Is_Potentially_Persistent_Type --\n+   ------------------------------------\n+\n+   function Is_Potentially_Persistent_Type (T : Entity_Id) return Boolean is\n+      Comp : Entity_Id;\n+      Indx : Node_Id;\n+\n+   begin\n+      --  For private type, test corrresponding full type\n+\n+      if Is_Private_Type (T) then\n+         return Is_Potentially_Persistent_Type (Full_View (T));\n+\n+      --  Scalar types are potentially persistent\n+\n+      elsif Is_Scalar_Type (T) then\n+         return True;\n+\n+      --  Record type is potentially persistent if not tagged and the types of\n+      --  all it components are potentially persistent, and no component has\n+      --  an initialization expression.\n+\n+      elsif Is_Record_Type (T)\n+        and then not Is_Tagged_Type (T)\n+        and then not Is_Partially_Initialized_Type (T)\n+      then\n+         Comp := First_Component (T);\n+         while Present (Comp) loop\n+            if not Is_Potentially_Persistent_Type (Etype (Comp)) then\n+               return False;\n+            else\n+               Next_Entity (Comp);\n+            end if;\n+         end loop;\n+\n+         return True;\n+\n+      --  Array type is potentially persistent if its component type is\n+      --  potentially persistent and if all its constraints are static.\n+\n+      elsif Is_Array_Type (T) then\n+         if not Is_Potentially_Persistent_Type (Component_Type (T)) then\n+            return False;\n+         end if;\n+\n+         Indx := First_Index (T);\n+         while Present (Indx) loop\n+            if not Is_OK_Static_Subtype (Etype (Indx)) then\n+               return False;\n+            else\n+               Next_Index (Indx);\n+            end if;\n+         end loop;\n+\n+         return True;\n+\n+      --  All other types are not potentially persistent\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Potentially_Persistent_Type;\n+\n    -----------------------------\n    -- Is_RCI_Pkg_Spec_Or_Body --\n    -----------------------------\n@@ -6476,10 +6551,10 @@ package body Sem_Util is\n       --  the level is the same as that of the enclosing component type.\n \n       Btyp := Base_Type (Typ);\n+\n       if Ekind (Btyp) in Access_Kind then\n          if Ekind (Btyp) = E_Anonymous_Access_Type\n-           and then not Is_Array_Type (Scope (Btyp))      -- Ada 2005 (AI-230)\n-           and then Ekind (Scope (Btyp)) /= E_Record_Type -- Ada 2005 (AI-230)\n+           and then not Is_Local_Anonymous_Access (Typ) -- Ada 2005 (AI-230)\n          then\n             return Scope_Depth (Standard_Standard);\n          end if;"}, {"sha": "7b23a9c320ed3602cf1b812ce22b3bd1ef209416", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -370,6 +370,11 @@ package Sem_Util is\n    function Has_Declarations (N : Node_Id) return Boolean;\n    --  Determines if the node can have declarations\n \n+   function Has_Discriminant_Dependent_Constraint\n+     (Comp : Entity_Id) return Boolean;\n+   --  Returns True if and only if Comp has a constrained subtype\n+   --  that depends on a discriminant.\n+\n    function Has_Infinities (E : Entity_Id) return Boolean;\n    --  Determines if the range of the floating-point type E includes\n    --  infinities. Returns False if E is not a floating-point type.\n@@ -534,6 +539,14 @@ package Sem_Util is\n    --  one field has an initialization expression). Note that initialization\n    --  resulting from the use of pragma Normalized_Scalars does not count.\n \n+   function Is_Potentially_Persistent_Type (T : Entity_Id) return Boolean;\n+   --  Determines if type T is a potentially persistent type. A potentially\n+   --  persistent type is defined (recursively) as a scalar type, a non-tagged\n+   --  record whose components are all of a potentially persistent type, or an\n+   --  array with all static constraints whose component type is potentially\n+   --  persistent. A private type is potentially persistent if the full type\n+   --  is potentially persistent.\n+\n    function Is_RCI_Pkg_Spec_Or_Body (Cunit : Node_Id) return Boolean;\n    --  Return True if a compilation unit is the specification or the\n    --  body of a remote call interface package."}, {"sha": "d72a6e284a60ba0a2dd93274981847cdf2d58ced", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1415,6 +1415,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Private_Extension_Declaration\n         or else NT (N).Nkind = N_Protected_Type_Declaration\n         or else NT (N).Nkind = N_Record_Definition\n+        or else NT (N).Nkind = N_Single_Protected_Declaration\n+        or else NT (N).Nkind = N_Single_Task_Declaration\n         or else NT (N).Nkind = N_Task_Type_Declaration);\n       return List2 (N);\n    end Interface_List;\n@@ -1745,6 +1747,30 @@ package body Sinfo is\n       return Flag8 (N);\n    end Must_Not_Freeze;\n \n+   function Must_Not_Override\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Entry_Declaration\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Function_Specification\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Specification);\n+      return Flag15 (N);\n+   end Must_Not_Override;\n+\n+   function Must_Override\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Entry_Declaration\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Function_Specification\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Specification);\n+      return Flag14 (N);\n+   end Must_Override;\n+\n    function Name\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -1872,6 +1898,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Component_List\n+        or else NT (N).Nkind = N_Procedure_Specification\n         or else NT (N).Nkind = N_Record_Definition);\n       return Flag13 (N);\n    end Null_Present;\n@@ -3939,6 +3966,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Private_Extension_Declaration\n         or else NT (N).Nkind = N_Protected_Type_Declaration\n         or else NT (N).Nkind = N_Record_Definition\n+        or else NT (N).Nkind = N_Single_Protected_Declaration\n+        or else NT (N).Nkind = N_Single_Task_Declaration\n         or else NT (N).Nkind = N_Task_Type_Declaration);\n       Set_List2_With_Parent (N, Val);\n    end Set_Interface_List;\n@@ -4269,6 +4298,30 @@ package body Sinfo is\n       Set_Flag8 (N, Val);\n    end Set_Must_Not_Freeze;\n \n+   procedure Set_Must_Not_Override\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Entry_Declaration\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Function_Specification\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Specification);\n+      Set_Flag15 (N, Val);\n+   end Set_Must_Not_Override;\n+\n+   procedure Set_Must_Override\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Entry_Declaration\n+        or else NT (N).Nkind = N_Function_Instantiation\n+        or else NT (N).Nkind = N_Function_Specification\n+        or else NT (N).Nkind = N_Procedure_Instantiation\n+        or else NT (N).Nkind = N_Procedure_Specification);\n+      Set_Flag14 (N, Val);\n+   end Set_Must_Override;\n+\n    procedure Set_Name\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -4396,6 +4449,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Component_List\n+        or else NT (N).Nkind = N_Procedure_Specification\n         or else NT (N).Nkind = N_Record_Definition);\n       Set_Flag13 (N, Val);\n    end Set_Null_Present;"}, {"sha": "d5da73cb42cfa061eae889860b8baf73f3cd82e1", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -1958,6 +1958,8 @@ package Sinfo is\n       --    DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n       --      [NULL_EXCLUSION] SUBTYPE_INDICATION [:= EXPRESSION];\n       --  | DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n+      --      ACCESS_DEFINITION [:= EXPRESSION];\n+      --  | DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n       --      ARRAY_TYPE_DEFINITION [:= EXPRESSION];\n       --  | SINGLE_TASK_DECLARATION\n       --  | SINGLE_PROTECTED_DECLARATION\n@@ -1994,13 +1996,17 @@ package Sinfo is\n       --  extra temporary (with Is_True_Constant set False), and initialize\n       --  this temporary as required (the temporary itself is not atomic).\n \n+      --  Note: there is not node kind for object definition. Instead, the\n+      --  corresponding field holds a subtype indication, an array type\n+      --  definition, or (Ada 2005, AI-406) an access definition.\n+\n       --  N_Object_Declaration\n       --  Sloc points to first identifier\n       --  Defining_Identifier (Node1)\n       --  Aliased_Present (Flag4) set if ALIASED appears\n       --  Constant_Present (Flag17) set if CONSTANT appears\n       --  Null_Exclusion_Present (Flag11)\n-      --  Object_Definition (Node4) subtype indication/array type definition\n+      --  Object_Definition (Node4) subtype indic./array type def./ access def.\n       --  Expression (Node3) (set to Empty if not present)\n       --  Handler_List_Entry (Node2-Sem)\n       --  Corresponding_Generic_Association (Node5-Sem)\n@@ -3893,8 +3899,10 @@ package Sinfo is\n       -----------------------------------\n \n       --  SUBPROGRAM_SPECIFICATION ::=\n+      --    [[not] overriding]\n       --    procedure DEFINING_PROGRAM_UNIT_NAME PARAMETER_PROFILE\n-      --  | function DEFINING_DESIGNATOR PARAMETER_AND_RESULT_PROFILE\n+      --  | [[not] overriding]\n+      --    function DEFINING_DESIGNATOR PARAMETER_AND_RESULT_PROFILE\n \n       --  Note: there are no separate nodes for the profiles, instead the\n       --  information appears directly in the following nodes.\n@@ -3906,13 +3914,20 @@ package Sinfo is\n       --  Parameter_Specifications (List3) (set to No_List if no formal part)\n       --  Subtype_Mark (Node4) for return type\n       --  Generic_Parent (Node5-Sem)\n+      --  Must_Override (Flag14) set if overriding indicator present\n+      --  Must_Not_Override (Flag15) set if not_overriding indicator present\n \n       --  N_Procedure_Specification\n       --  Sloc points to PROCEDURE\n       --  Defining_Unit_Name (Node1)\n       --  Elaboration_Boolean (Node2-Sem)\n       --  Parameter_Specifications (List3) (set to No_List if no formal part)\n       --  Generic_Parent (Node5-Sem)\n+      --  Null_Present (Flag13) set for null procedure case (Ada 2005 feature)\n+      --  Must_Override (Flag14) set if overriding indicator present\n+      --  Must_Not_Override (Flag15) set if not_overriding indicator present\n+\n+      --  Note: overriding indicator is an Ada 2005 feature\n \n       ---------------------\n       -- 6.1  Designator --\n@@ -4470,11 +4485,13 @@ package Sinfo is\n       ----------------------------------\n \n       --  SINGLE_TASK_DECLARATION ::=\n-      --    task DEFINING_IDENTIFIER [is TASK_DEFINITION];\n+      --    task DEFINING_IDENTIFIER\n+      --      [is [new INTERFACE_LIST with] TASK_DEFINITITION];\n \n       --  N_Single_Task_Declaration\n       --  Sloc points to TASK\n       --  Defining_Identifier (Node1)\n+      --  Interface_List (List2) (set to No_List if none)\n       --  Task_Definition (Node3) (set to Empty if not present)\n \n       --------------------------\n@@ -4553,13 +4570,15 @@ package Sinfo is\n       ---------------------------------------\n \n       --  SINGLE_PROTECTED_DECLARATION ::=\n-      --    protected DEFINING_IDENTIFIER is PROTECTED_DEFINITION;\n+      --    protected DEFINING_IDENTIFIER\n+      --      is [new INTERFACE_LIST with] PROTECTED_DEFINITION;\n \n       --  Note: single protected declarations are not allowed in Ada 83 mode\n \n       --  N_Single_Protected_Declaration\n       --  Sloc points to PROTECTED\n       --  Defining_Identifier (Node1)\n+      --  Interface_List (List2) (set to No_List if none)\n       --  Protected_Definition (Node3)\n \n       -------------------------------\n@@ -4631,6 +4650,7 @@ package Sinfo is\n       ------------------------------\n \n       --  ENTRY_DECLARATION ::=\n+      --    [[not] overriding]\n       --    entry DEFINING_IDENTIFIER\n       --      [(DISCRETE_SUBTYPE_DEFINITION)] PARAMETER_PROFILE;\n \n@@ -4640,6 +4660,10 @@ package Sinfo is\n       --  Discrete_Subtype_Definition (Node4) (set to Empty if not present)\n       --  Parameter_Specifications (List3) (set to No_List if no formal part)\n       --  Corresponding_Body (Node5-Sem)\n+      --  Must_Override (Flag14) set if overriding indicator present\n+      --  Must_Not_Override (Flag15) set if not_overriding indicator present\n+\n+      --  Note: overriding indicator is an Ada 2005 feature\n \n       -----------------------------\n       -- 9.5.2  Accept statement --\n@@ -5489,9 +5513,11 @@ package Sinfo is\n       --  GENERIC_INSTANTIATION ::=\n       --    package DEFINING_PROGRAM_UNIT_NAME is\n       --      new generic_package_NAME [GENERIC_ACTUAL_PART];\n-      --  | procedure DEFINING_PROGRAM_UNIT_NAME is\n+      --  | [[not] overriding]\n+      --    procedure DEFINING_PROGRAM_UNIT_NAME is\n       --      new generic_procedure_NAME [GENERIC_ACTUAL_PART];\n-      --  | function DEFINING_DESIGNATOR is\n+      --  | [[not] overriding]\n+      --    function DEFINING_DESIGNATOR is\n       --      new generic_function_NAME [GENERIC_ACTUAL_PART];\n \n       --  N_Package_Instantiation\n@@ -5512,6 +5538,8 @@ package Sinfo is\n       --  Generic_Associations (List3) (set to No_List if no\n       --   generic actual part)\n       --  Instance_Spec (Node5-Sem)\n+      --  Must_Override (Flag14) set if overriding indicator present\n+      --  Must_Not_Override (Flag15) set if not_overriding indicator present\n       --  ABE_Is_Certain (Flag18-Sem)\n \n       --  N_Function_Instantiation\n@@ -5522,8 +5550,12 @@ package Sinfo is\n       --   generic actual part)\n       --  Parent_Spec (Node4-Sem)\n       --  Instance_Spec (Node5-Sem)\n+      --  Must_Override (Flag14) set if overriding indicator present\n+      --  Must_Not_Override (Flag15) set if not_overriding indicator present\n       --  ABE_Is_Certain (Flag18-Sem)\n \n+      --  Note: overriding indicator is an Ada 2005 feature\n+\n       ------------------------------\n       -- 12.3 Generic Actual Part --\n       ------------------------------\n@@ -7565,6 +7597,12 @@ package Sinfo is\n    function Must_Not_Freeze\n      (N : Node_Id) return Boolean;    -- Flag8\n \n+   function Must_Not_Override\n+     (N : Node_Id) return Boolean;    -- Flag15\n+\n+   function Must_Override\n+     (N : Node_Id) return Boolean;    -- Flag14\n+\n    function Name\n      (N : Node_Id) return Node_Id;    -- Node2\n \n@@ -8366,6 +8404,12 @@ package Sinfo is\n    procedure Set_Must_Not_Freeze\n      (N : Node_Id; Val : Boolean := True);    -- Flag8\n \n+   procedure Set_Must_Not_Override\n+     (N : Node_Id; Val : Boolean := True);    -- Flag15\n+\n+   procedure Set_Must_Override\n+     (N : Node_Id; Val : Boolean := True);    -- Flag14\n+\n    procedure Set_Name\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n@@ -8828,6 +8872,8 @@ package Sinfo is\n    pragma Inline (More_Ids);\n    pragma Inline (Must_Be_Byte_Aligned);\n    pragma Inline (Must_Not_Freeze);\n+   pragma Inline (Must_Not_Override);\n+   pragma Inline (Must_Override);\n    pragma Inline (Name);\n    pragma Inline (Names);\n    pragma Inline (Next_Entity);\n@@ -9092,6 +9138,8 @@ package Sinfo is\n    pragma Inline (Set_More_Ids);\n    pragma Inline (Set_Must_Be_Byte_Aligned);\n    pragma Inline (Set_Must_Not_Freeze);\n+   pragma Inline (Set_Must_Not_Override);\n+   pragma Inline (Set_Must_Override);\n    pragma Inline (Set_Name);\n    pragma Inline (Set_Names);\n    pragma Inline (Set_Next_Entity);"}, {"sha": "4e875fa52a4e62232b170a86edaee83118a456a9", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edd63e9baccac484fcbeed6b082941a159c30244/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=edd63e9baccac484fcbeed6b082941a159c30244", "patch": "@@ -165,6 +165,9 @@ package body Sprint is\n    --  that is currently being written. Note that Debug_Node is always empty\n    --  if a debug source file is not being written.\n \n+   procedure Sprint_And_List (List : List_Id);\n+   --  Print the given list with items separated by vertical \"and\"\n+\n    procedure Sprint_Bar_List (List : List_Id);\n    --  Print the given list with items separated by vertical bars\n \n@@ -479,17 +482,33 @@ package body Sprint is\n       end if;\n    end Source_Dump;\n \n+   ---------------------\n+   -- Sprint_And_List --\n+   ---------------------\n+\n+   procedure Sprint_And_List (List : List_Id) is\n+      Node : Node_Id;\n+   begin\n+      if Is_Non_Empty_List (List) then\n+         Node := First (List);\n+         loop\n+            Sprint_Node (Node);\n+            Next (Node);\n+            exit when Node = Empty;\n+            Write_Str (\" and \");\n+         end loop;\n+      end if;\n+   end Sprint_And_List;\n+\n    ---------------------\n    -- Sprint_Bar_List --\n    ---------------------\n \n    procedure Sprint_Bar_List (List : List_Id) is\n       Node : Node_Id;\n-\n    begin\n       if Is_Non_Empty_List (List) then\n          Node := First (List);\n-\n          loop\n             Sprint_Node (Node);\n             Next (Node);\n@@ -509,7 +528,6 @@ package body Sprint is\n    begin\n       if Is_Non_Empty_List (List) then\n          Node := First (List);\n-\n          loop\n             Sprint_Node (Node);\n             Next (Node);\n@@ -520,7 +538,6 @@ package body Sprint is\n             then\n                Write_Str (\", \");\n             end if;\n-\n          end loop;\n       end if;\n    end Sprint_Comma_List;\n@@ -1146,8 +1163,16 @@ package body Sprint is\n \n             Sprint_Node (Subtype_Indication (Node));\n \n-            if Present (Record_Extension_Part (Node)) then\n+            if Present (Interface_List (Node)) then\n+               Sprint_And_List (Interface_List (Node));\n                Write_Str_With_Col_Check (\" with \");\n+            end if;\n+\n+            if Present (Record_Extension_Part (Node)) then\n+               if No (Interface_List (Node)) then\n+                  Write_Str_With_Col_Check (\" with \");\n+               end if;\n+\n                Sprint_Node (Record_Extension_Part (Node));\n             end if;\n \n@@ -2149,7 +2174,15 @@ package body Sprint is\n             Write_Indent_Str_Sloc (\"protected type \");\n             Write_Id (Defining_Identifier (Node));\n             Write_Discr_Specs (Node);\n-            Write_Str (\" is\");\n+\n+            if Present (Interface_List (Node)) then\n+               Write_Str (\" is new \");\n+               Sprint_And_List (Interface_List (Node));\n+               Write_Str (\" with \");\n+            else\n+               Write_Str (\" is\");\n+            end if;\n+\n             Sprint_Node (Protected_Definition (Node));\n             Write_Id (Defining_Identifier (Node));\n             Write_Char (';');\n@@ -2400,6 +2433,13 @@ package body Sprint is\n          when N_Subprogram_Declaration =>\n             Write_Indent;\n             Sprint_Node_Sloc (Specification (Node));\n+\n+            if Nkind (Specification (Node)) = N_Procedure_Specification\n+              and then Null_Present (Specification (Node))\n+            then\n+               Write_Str_With_Col_Check (\" is null\");\n+            end if;\n+\n             Write_Char (';');\n \n          when N_Subprogram_Info =>\n@@ -2471,8 +2511,18 @@ package body Sprint is\n             Write_Id (Defining_Identifier (Node));\n             Write_Discr_Specs (Node);\n \n+            if Present (Interface_List (Node)) then\n+               Write_Str (\" is new \");\n+               Sprint_And_List (Interface_List (Node));\n+            end if;\n+\n             if Present (Task_Definition (Node)) then\n-               Write_Str (\" is\");\n+               if No (Interface_List (Node)) then\n+                  Write_Str (\" is\");\n+               else\n+                  Write_Str (\" with \");\n+               end if;\n+\n                Sprint_Node (Task_Definition (Node));\n                Write_Id (Defining_Identifier (Node));\n             end if;"}]}