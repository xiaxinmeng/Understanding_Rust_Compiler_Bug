{"sha": "a282a875c8856b024b51b8c643d080a6ea2dd8ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI4MmE4NzVjODg1NmIwMjRiNTFiOGM2NDNkMDgwYTZlYTJkZDhhYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-12T23:14:05Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-12T23:14:05Z"}, "message": "runtime: ignore _Gscan bit when checking status in CgocallDone\n    \n    Also always access the atomicstatus field atomically.\n    \n    The effect of not checking the _Gscan bit is that if the GC decides to\n    scan the stack just as the goroutine is leaving the system call, the\n    goroutine might fail to call exitsyscall.  Then then typically causes\n    a runtime assertion failure later on.  If we do call exitsyscall as we\n    should, it will stall (in casgstatus) until the _Gscan bit is cleared.\n    \n    No separate test.  I've observed causing sporadic failures running the\n    misc/cgo tests, but we don't currently have a way to run those\n    routinely for gccgo.  I should fix that.\n    \n    Reviewed-on: https://go-review.googlesource.com/45392\n\nFrom-SVN: r249138", "tree": {"sha": "d3dcd53208e91dad347a36dceeff7ac3d626c251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3dcd53208e91dad347a36dceeff7ac3d626c251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a282a875c8856b024b51b8c643d080a6ea2dd8ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a282a875c8856b024b51b8c643d080a6ea2dd8ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a282a875c8856b024b51b8c643d080a6ea2dd8ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a282a875c8856b024b51b8c643d080a6ea2dd8ab/comments", "author": null, "committer": null, "parents": [{"sha": "b51483f48f3cc67cf4b508bdd9c4b6a47b44c53a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51483f48f3cc67cf4b508bdd9c4b6a47b44c53a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b51483f48f3cc67cf4b508bdd9c4b6a47b44c53a"}], "stats": {"total": 6, "additions": 3, "deletions": 3}, "files": [{"sha": "d4a312908f0ef14633e04fe9b19f5fffc76008d1", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a282a875c8856b024b51b8c643d080a6ea2dd8ab/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a282a875c8856b024b51b8c643d080a6ea2dd8ab/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a282a875c8856b024b51b8c643d080a6ea2dd8ab", "patch": "@@ -1,4 +1,4 @@\n-61222d34c1b33a369bd86008a0541455dd17727e\n+908fc7e46ebe36658ed86b65a3d165fccb2e8576\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b0ad2f12a6356bf6959e5e210dfeb5656cdfe762", "filename": "libgo/go/runtime/cgo_gccgo.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a282a875c8856b024b51b8c643d080a6ea2dd8ab/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a282a875c8856b024b51b8c643d080a6ea2dd8ab/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go?ref=a282a875c8856b024b51b8c643d080a6ea2dd8ab", "patch": "@@ -54,7 +54,7 @@ func CgocallDone() {\n \n \t// If we are invoked because the C function called _cgo_panic,\n \t// then _cgo_panic will already have exited syscall mode.\n-\tif gp.atomicstatus == _Gsyscall {\n+\tif readgstatus(gp)&^_Gscan == _Gsyscall {\n \t\texitsyscall(0)\n \t}\n "}, {"sha": "038f20e977ef4a8e51ae66ce8ecf7c9680917ddb", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a282a875c8856b024b51b8c643d080a6ea2dd8ab/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a282a875c8856b024b51b8c643d080a6ea2dd8ab/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=a282a875c8856b024b51b8c643d080a6ea2dd8ab", "patch": "@@ -1459,7 +1459,7 @@ func dropm() {\n \n \t// gccgo sets the stack to Gdead here, because the splitstack\n \t// context is not initialized.\n-\tmp.curg.atomicstatus = _Gdead\n+\tatomic.Store(&mp.curg.atomicstatus, _Gdead)\n \tmp.curg.gcstack = nil\n \tmp.curg.gcnextsp = nil\n "}]}