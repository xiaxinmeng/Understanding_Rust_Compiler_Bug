{"sha": "a2c593009fef1564dbef2237ee71e9fd08f5361e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJjNTkzMDA5ZmVmMTU2NGRiZWYyMjM3ZWU3MWU5ZmQwOGY1MzYxZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-05-06T13:41:33Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-05-06T13:42:59Z"}, "message": "Fortran: Assumed and explicit size class arrays [PR46691/99819].\n\n2021-05-06  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran/ChangeLog\n\n\tPR fortran/46691\n\tPR fortran/99819\n\t* class.c (gfc_build_class_symbol): Remove the error that\n\tdisables assumed size class arrays. Class array types that are\n\tnot deferred shape or assumed rank are given a unique name and\n\tplaced in the procedure namespace.\n\t* trans-array.c (gfc_trans_g77_array): Obtain the data pointer\n\tfor class arrays.\n\t(gfc_trans_dummy_array_bias): Suppress the runtime error for\n\textent violations in explicit shape class arrays because it\n\talways fails.\n\t* trans-expr.c (gfc_conv_procedure_call): Handle assumed size\n\tclass actual arguments passed to non-descriptor formal args by\n\tusing the data pointer, stored as the symbol's backend decl.\n\ngcc/testsuite/ChangeLog\n\n\tPR fortran/46691\n\tPR fortran/99819\n\t* gfortran.dg/class_dummy_6.f90: New test.\n\t* gfortran.dg/class_dummy_7.f90: New test.", "tree": {"sha": "131946c90eb097b53e49ef36e78730199828d238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/131946c90eb097b53e49ef36e78730199828d238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2c593009fef1564dbef2237ee71e9fd08f5361e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c593009fef1564dbef2237ee71e9fd08f5361e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c593009fef1564dbef2237ee71e9fd08f5361e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c593009fef1564dbef2237ee71e9fd08f5361e/comments", "author": null, "committer": null, "parents": [{"sha": "eb1aa9ad2afbcd8f3e939310d5785ff8563a8c5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1aa9ad2afbcd8f3e939310d5785ff8563a8c5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb1aa9ad2afbcd8f3e939310d5785ff8563a8c5c"}], "stats": {"total": 179, "additions": 169, "deletions": 10}, "files": [{"sha": "93118ad3455f2cac543e534ba4a50d46a0b37d3b", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=a2c593009fef1564dbef2237ee71e9fd08f5361e", "patch": "@@ -630,6 +630,7 @@ gfc_get_len_component (gfc_expr *e, int k)\n    component '_vptr' which determines the dynamic type.  When this CLASS\n    entity is unlimited polymorphic, then also add a component '_len' to\n    store the length of string when that is stored in it.  */\n+static int ctr = 0;\n \n bool\n gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n@@ -645,13 +646,6 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n \n   gcc_assert (as);\n \n-  if (*as && (*as)->type == AS_ASSUMED_SIZE)\n-    {\n-      gfc_error (\"Assumed size polymorphic objects or components, such \"\n-\t\t \"as that at %C, have not yet been implemented\");\n-      return false;\n-    }\n-\n   if (attr->class_ok)\n     /* Class container has already been built.  */\n     return true;\n@@ -693,7 +687,30 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n   else\n     ns = ts->u.derived->ns;\n \n-  gfc_find_symbol (name, ns, 0, &fclass);\n+  /* Although this might seem to be counterintuitive, we can build separate\n+     class types with different array specs because the TKR interface checks\n+     work on the declared type. All array type other than deferred shape or\n+     assumed rank are added to the function namespace to ensure that they\n+     are properly distinguished.  */\n+  if (attr->dummy && !attr->codimension && (*as)\n+      && !((*as)->type == AS_DEFERRED || (*as)->type == AS_ASSUMED_RANK))\n+    {\n+      char *sname;\n+      ns = gfc_current_ns;\n+      gfc_find_symbol (name, ns, 0, &fclass);\n+      /* If a local class type with this name already exists, update the\n+\t name with an index.  */\n+      if (fclass)\n+\t{\n+\t  fclass = NULL;\n+\t  sname = xasprintf (\"%s_%d\", name, ++ctr);\n+\t  free (name);\n+\t  name = sname;\n+\t}\n+    }\n+  else\n+    gfc_find_symbol (name, ns, 0, &fclass);\n+\n   if (fclass == NULL)\n     {\n       gfc_symtree *st;"}, {"sha": "6d38ea78273c593c6f76c0e226f87838cbefc4a0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=a2c593009fef1564dbef2237ee71e9fd08f5361e", "patch": "@@ -6524,7 +6524,14 @@ gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)\n   /* Set the pointer itself if we aren't using the parameter directly.  */\n   if (TREE_CODE (parm) != PARM_DECL)\n     {\n-      tmp = convert (TREE_TYPE (parm), GFC_DECL_SAVED_DESCRIPTOR (parm));\n+      tmp = GFC_DECL_SAVED_DESCRIPTOR (parm);\n+      if (sym->ts.type == BT_CLASS)\n+\t{\n+\t  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t  tmp = gfc_class_data_get (tmp);\n+\t  tmp = gfc_conv_descriptor_data_get (tmp);\n+\t}\n+      tmp = convert (TREE_TYPE (parm), tmp);\n       gfc_add_modify (&init, parm, tmp);\n     }\n   stmt = gfc_finish_block (&init);\n@@ -6626,7 +6633,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       && VAR_P (sym->ts.u.cl->backend_decl))\n     gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n-  checkparm = (as->type == AS_EXPLICIT\n+  /* TODO: Fix the exclusion of class arrays from extent checking.  */\n+  checkparm = (as->type == AS_EXPLICIT && !is_classarray\n \t       && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS));\n \n   no_repack = !(GFC_DECL_PACKED_ARRAY (tmpdesc)"}, {"sha": "7e3de4176d73d5d80018b6c2ebeb687e31294eed", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a2c593009fef1564dbef2237ee71e9fd08f5361e", "patch": "@@ -6418,6 +6418,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n \n+\t      else if (e->ts.type == BT_CLASS && CLASS_DATA (e)->as\n+\t\t       && CLASS_DATA (e)->as->type == AS_ASSUMED_SIZE\n+\t\t       && nodesc_arg && fsym->ts.type == BT_DERIVED)\n+\t\t/* An assumed size class actual argument being passed to\n+\t\t   a 'no descriptor' formal argument just requires the\n+\t\t   data pointer to be passed. For class dummy arguments\n+\t\t   this is stored in the symbol backend decl..  */\n+\t\tparmse.expr = e->symtree->n.sym->backend_decl;\n+\n \t      else if (gfc_is_class_array_ref (e, NULL)\n \t\t       && fsym && fsym->ts.type == BT_DERIVED)\n \t\t/* The actual argument is a component reference to an"}, {"sha": "79f6e86daa70b04f8339bf9017ce66d944348112", "filename": "gcc/testsuite/gfortran.dg/class_dummy_6.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_6.f90?ref=a2c593009fef1564dbef2237ee71e9fd08f5361e", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR99819 - explicit shape class arrays in different\n+! procedures caused an ICE.\n+!\n+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>\n+!\n+program p\n+   type t\n+      integer :: i\n+   end type\n+   class(t), allocatable :: dum1(:), dum2(:), dum3(:,:)\n+\n+   allocate (t :: dum1(3), dum2(10), dum3(2,5))\n+   dum2%i = [1,2,3,4,5,6,7,8,9,10]\n+   dum3%i = reshape ([1,2,3,4,5,6,7,8,9,10],[2,5])\n+\n+! Somewhat elaborated versions of the PR procedures.\n+   if (f (dum1, dum2, dum3) .ne. 10) stop 1\n+   if (g (dum1) .ne. 3) stop 2\n+\n+! Test the original versions of the procedures.\n+   if (f_original (dum1, dum2) .ne. 3) stop 3\n+   if (g_original (dum2) .ne. 10) stop 4\n+\n+contains\n+   integer function f(x, y, z)\n+      class(t) :: x(:)\n+      class(t) :: y(size( x))\n+      class(t) :: z(2,*)\n+      if (size (y) .ne. 3) stop 5\n+      if (size (z) .ne. 0) stop 6\n+      select type (y)\n+        type is (t)\n+          f = 1\n+          if (any (y%i .ne. [1,2,3])) stop 7\n+        class default\n+          f = 0\n+      end select\n+      select type (z)\n+        type is (t)\n+          f = f*10\n+          if (any (z(1,1:4)%i .ne. [1,3,5,7])) stop 8\n+        class default\n+          f = 0\n+      end select\n+   end\n+   integer function g(z)\n+      class(t) :: z(:)\n+      type(t) :: u(size(z))\n+      g = size (u)\n+   end\n+\n+   integer function f_original(x, y)\n+      class(t) :: x(:)\n+      class(*) :: y(size (x))\n+      f_original = size (y)\n+   end\n+\n+   integer function g_original(z)\n+      class(*) :: z(:)\n+      type(t) :: u(size(z))\n+      g_original = size (u)\n+   end\n+end"}, {"sha": "913426804f3d7aaae474fae99629839b5c2a0731", "filename": "gcc/testsuite/gfortran.dg/class_dummy_7.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c593009fef1564dbef2237ee71e9fd08f5361e/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_dummy_7.f90?ref=a2c593009fef1564dbef2237ee71e9fd08f5361e", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR46691 - enable class assumed size arrays\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+! from http://j3-fortran.org/pipermail/j3/2010-December/004084.html\n+! submitted by Robert Corbett.\n+!\n+       MODULE TYPES\n+         PRIVATE\n+         PUBLIC REC, REC2\n+\n+         TYPE REC\n+           INTEGER A\n+         END TYPE\n+\n+         TYPE, EXTENDS(REC) :: REC2\n+           INTEGER B\n+         END TYPE\n+       END\n+\n+       SUBROUTINE SUB1(A, N)\n+         USE TYPES\n+         CLASS(REC), INTENT(IN) :: A(*)\n+         INTERFACE\n+           SUBROUTINE SUB2(A, N, IARRAY)\n+             USE TYPES\n+             TYPE(REC) A(*)\n+             INTEGER :: N, IARRAY(N)\n+           END\n+         END INTERFACE\n+\n+         CALL SUB2(A, N,[1,2,2,3,3,4,4,5,5,6])\n+         select type (B => A(1:N))\n+             type is (REC2)\n+                 call SUB2(B%REC,N,[1,2,3,4,5,6,7,8,9,10])\n+         end select\n+\n+       END\n+\n+       SUBROUTINE SUB2(A, N, IARRAY)\n+         USE TYPES\n+         TYPE(REC) A(*)\n+         INTEGER :: N, IARRAY(N)\n+         if (any (A(:N)%A .ne. IARRAY(:N))) stop 1\n+       END\n+\n+       PROGRAM MAIN\n+         USE TYPES\n+         CLASS(REC), ALLOCATABLE :: A(:)\n+         INTERFACE\n+           SUBROUTINE SUB1(A, N)\n+             USE TYPES\n+             CLASS(REC), INTENT(IN) :: A(*)\n+           END SUBROUTINE\n+         END INTERFACE\n+\n+         A = [ (REC2(I, I+1), I = 1, 10) ]\n+         CALL SUB1(A, 10)\n+       END"}]}