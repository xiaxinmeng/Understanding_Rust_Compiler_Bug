{"sha": "550a338052c374cb1f6c07ffd883c4046565fdd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwYTMzODA1MmMzNzRjYjFmNmMwN2ZmZDg4M2M0MDQ2NTY1ZmRkNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-16T10:53:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-16T10:53:40Z"}, "message": "[AArch64] Add partial SVE vector modes\n\nThis patch adds extra vector modes that represent a half, quarter or\neighth of what an SVE vector can hold.  This is useful for describing\nthe memory vector involved in an extending load or truncating store.\nIt might also be useful in future for representing \"unpacked\" SVE\nregisters, i.e. registers that contain values in the low bits of a\nwider containing element.\n\nThe new modes could have the same width as an Advanced SIMD mode for\ncertain -msve-vector-bits=N options, so we need to ensure that they\ncome later in the mode list and that Advanced SIMD modes always \"win\".\n\n2019-10-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* genmodes.c (mode_data::order): New field.\n\t(blank_mode): Update accordingly.\n\t(VECTOR_MODES_WITH_PREFIX): Add an order parameter.\n\t(make_vector_modes): Likewise.\n\t(VECTOR_MODES): Update use accordingly.\n\t(cmp_modes): Sort by the new order field ahead of sorting by size.\n\t* config/aarch64/aarch64-modes.def (VNx2QI, VN2xHI, VNx2SI)\n\t(VNx4QI, VNx4HI, VNx8QI): New partial vector modes.\n\t* config/aarch64/aarch64.c (VEC_PARTIAL): New flag value.\n\t(aarch64_classify_vector_mode): Handle the new partial modes.\n\t(aarch64_vl_bytes): New function.\n\t(aarch64_hard_regno_nregs): Use it instead of BYTES_PER_SVE_VECTOR\n\twhen counting the number of registers in an SVE mode.\n\t(aarch64_class_max_nregs): Likewise.\n\t(aarch64_hard_regno_mode_ok): Don't allow partial vectors\n\tin registers yet.\n\t(aarch64_classify_address): Treat partial vectors analogously\n\tto full vectors.\n\t(aarch64_print_address_internal): Consolidate the printing of\n\tMUL VL addresses, using aarch64_vl_bytes as the number of\n\tbytes represented by \"VL\".\n\t(aarch64_vector_mode_supported_p): Reject partial vector modes.\n\nFrom-SVN: r277062", "tree": {"sha": "bb0ffdac0fdaa344fbacf57dbb9ec48a3aa2299d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb0ffdac0fdaa344fbacf57dbb9ec48a3aa2299d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550a338052c374cb1f6c07ffd883c4046565fdd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550a338052c374cb1f6c07ffd883c4046565fdd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550a338052c374cb1f6c07ffd883c4046565fdd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550a338052c374cb1f6c07ffd883c4046565fdd4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b17a646d90ad0cc30daf8432aa60ad0d751d914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b17a646d90ad0cc30daf8432aa60ad0d751d914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b17a646d90ad0cc30daf8432aa60ad0d751d914"}], "stats": {"total": 177, "additions": 144, "deletions": 33}, "files": [{"sha": "56ad96db752a6ebd7d243909cc92c166be10065d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=550a338052c374cb1f6c07ffd883c4046565fdd4", "patch": "@@ -1,3 +1,28 @@\n+2019-10-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* genmodes.c (mode_data::order): New field.\n+\t(blank_mode): Update accordingly.\n+\t(VECTOR_MODES_WITH_PREFIX): Add an order parameter.\n+\t(make_vector_modes): Likewise.\n+\t(VECTOR_MODES): Update use accordingly.\n+\t(cmp_modes): Sort by the new order field ahead of sorting by size.\n+\t* config/aarch64/aarch64-modes.def (VNx2QI, VN2xHI, VNx2SI)\n+\t(VNx4QI, VNx4HI, VNx8QI): New partial vector modes.\n+\t* config/aarch64/aarch64.c (VEC_PARTIAL): New flag value.\n+\t(aarch64_classify_vector_mode): Handle the new partial modes.\n+\t(aarch64_vl_bytes): New function.\n+\t(aarch64_hard_regno_nregs): Use it instead of BYTES_PER_SVE_VECTOR\n+\twhen counting the number of registers in an SVE mode.\n+\t(aarch64_class_max_nregs): Likewise.\n+\t(aarch64_hard_regno_mode_ok): Don't allow partial vectors\n+\tin registers yet.\n+\t(aarch64_classify_address): Treat partial vectors analogously\n+\tto full vectors.\n+\t(aarch64_print_address_internal): Consolidate the printing of\n+\tMUL VL addresses, using aarch64_vl_bytes as the number of\n+\tbytes represented by \"VL\".\n+\t(aarch64_vector_mode_supported_p): Reject partial vector modes.\n+\n 2019-10-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_layout_frame): Use is_constant"}, {"sha": "a9b1bce1356b869634891f6f9705f86234315f72", "filename": "gcc/config/aarch64/aarch64-modes.def", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def?ref=550a338052c374cb1f6c07ffd883c4046565fdd4", "patch": "@@ -82,8 +82,8 @@ INT_MODE (XI, 64);\n    strictly necessary to set the alignment here, since the default would\n    be clamped to BIGGEST_ALIGNMENT anyhow, but it seems clearer.  */\n #define SVE_MODES(NVECS, VB, VH, VS, VD) \\\n-  VECTOR_MODES_WITH_PREFIX (VNx, INT, 16 * NVECS); \\\n-  VECTOR_MODES_WITH_PREFIX (VNx, FLOAT, 16 * NVECS); \\\n+  VECTOR_MODES_WITH_PREFIX (VNx, INT, 16 * NVECS, 0); \\\n+  VECTOR_MODES_WITH_PREFIX (VNx, FLOAT, 16 * NVECS, 0); \\\n   \\\n   ADJUST_NUNITS (VB##QI, aarch64_sve_vg * NVECS * 8); \\\n   ADJUST_NUNITS (VH##HI, aarch64_sve_vg * NVECS * 4); \\\n@@ -108,6 +108,40 @@ SVE_MODES (2, VNx32, VNx16, VNx8, VNx4)\n SVE_MODES (3, VNx48, VNx24, VNx12, VNx6)\n SVE_MODES (4, VNx64, VNx32, VNx16, VNx8)\n \n+/* Partial SVE vectors:\n+\n+      VNx2QI VNx4QI VNx8QI\n+      VNx2HI VNx4HI\n+      VNx2SI\n+\n+   In memory they occupy contiguous locations, in the same way as fixed-length\n+   vectors.  E.g. VNx8QImode is half the size of VNx16QImode.\n+\n+   Passing 1 as the final argument ensures that the modes come after all\n+   other modes in the GET_MODE_WIDER chain, so that we never pick them\n+   in preference to a full vector mode.  */\n+VECTOR_MODES_WITH_PREFIX (VNx, INT, 2, 1);\n+VECTOR_MODES_WITH_PREFIX (VNx, INT, 4, 1);\n+VECTOR_MODES_WITH_PREFIX (VNx, INT, 8, 1);\n+\n+ADJUST_NUNITS (VNx2QI, aarch64_sve_vg);\n+ADJUST_NUNITS (VNx2HI, aarch64_sve_vg);\n+ADJUST_NUNITS (VNx2SI, aarch64_sve_vg);\n+\n+ADJUST_NUNITS (VNx4QI, aarch64_sve_vg * 2);\n+ADJUST_NUNITS (VNx4HI, aarch64_sve_vg * 2);\n+\n+ADJUST_NUNITS (VNx8QI, aarch64_sve_vg * 4);\n+\n+ADJUST_ALIGNMENT (VNx2QI, 1);\n+ADJUST_ALIGNMENT (VNx4QI, 1);\n+ADJUST_ALIGNMENT (VNx8QI, 1);\n+\n+ADJUST_ALIGNMENT (VNx2HI, 2);\n+ADJUST_ALIGNMENT (VNx4HI, 2);\n+\n+ADJUST_ALIGNMENT (VNx2SI, 4);\n+\n /* Quad float: 128-bit floating mode for long doubles.  */\n FLOAT_MODE (TF, 16, ieee_quad_format);\n "}, {"sha": "1f0e74ac1a4ed9e5cd400e9dc9ee48f6e4df18c8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=550a338052c374cb1f6c07ffd883c4046565fdd4", "patch": "@@ -1538,6 +1538,9 @@ const unsigned int VEC_SVE_PRED = 4;\n /* Can be used in combination with VEC_ADVSIMD or VEC_SVE_DATA to indicate\n    a structure of 2, 3 or 4 vectors.  */\n const unsigned int VEC_STRUCT   = 8;\n+/* Can be used in combination with VEC_SVE_DATA to indicate that the\n+   vector has fewer significant bytes than a full SVE vector.  */\n+const unsigned int VEC_PARTIAL  = 16;\n /* Useful combinations of the above.  */\n const unsigned int VEC_ANY_SVE  = VEC_SVE_DATA | VEC_SVE_PRED;\n const unsigned int VEC_ANY_DATA = VEC_ADVSIMD | VEC_SVE_DATA;\n@@ -1558,7 +1561,17 @@ aarch64_classify_vector_mode (machine_mode mode)\n      of -msve-vector-bits.  */\n   switch (mode)\n     {\n-    /* Single SVE vectors.  */\n+    /* Partial SVE QI vectors.  */\n+    case E_VNx2QImode:\n+    case E_VNx4QImode:\n+    case E_VNx8QImode:\n+    /* Partial SVE HI vectors.  */\n+    case E_VNx2HImode:\n+    case E_VNx4HImode:\n+    /* Partial SVE SI vector.  */\n+    case E_VNx2SImode:\n+      return TARGET_SVE ? VEC_SVE_DATA | VEC_PARTIAL : 0;\n+\n     case E_VNx16QImode:\n     case E_VNx8HImode:\n     case E_VNx4SImode:\n@@ -1641,6 +1654,24 @@ aarch64_sve_data_mode_p (machine_mode mode)\n   return aarch64_classify_vector_mode (mode) & VEC_SVE_DATA;\n }\n \n+/* Return the number of defined bytes in one constituent vector of\n+   SVE mode MODE, which has vector flags VEC_FLAGS.  */\n+static poly_int64\n+aarch64_vl_bytes (machine_mode mode, unsigned int vec_flags)\n+{\n+  if (vec_flags & VEC_PARTIAL)\n+    /* A single partial vector.  */\n+    return GET_MODE_SIZE (mode);\n+\n+  if (vec_flags & VEC_SVE_DATA)\n+    /* A single vector or a tuple.  */\n+    return BYTES_PER_SVE_VECTOR;\n+\n+  /* A single predicate.  */\n+  gcc_assert (vec_flags & VEC_SVE_PRED);\n+  return BYTES_PER_SVE_PRED;\n+}\n+\n /* Implement target hook TARGET_ARRAY_MODE.  */\n static opt_machine_mode\n aarch64_array_mode (machine_mode mode, unsigned HOST_WIDE_INT nelems)\n@@ -1769,10 +1800,13 @@ aarch64_hard_regno_nregs (unsigned regno, machine_mode mode)\n     case FP_REGS:\n     case FP_LO_REGS:\n     case FP_LO8_REGS:\n-      if (aarch64_sve_data_mode_p (mode))\n-\treturn exact_div (GET_MODE_SIZE (mode),\n-\t\t\t  BYTES_PER_SVE_VECTOR).to_constant ();\n-      return CEIL (lowest_size, UNITS_PER_VREG);\n+      {\n+\tunsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+\tif (vec_flags & VEC_SVE_DATA)\n+\t  return exact_div (GET_MODE_SIZE (mode),\n+\t\t\t    aarch64_vl_bytes (mode, vec_flags)).to_constant ();\n+\treturn CEIL (lowest_size, UNITS_PER_VREG);\n+      }\n     case PR_REGS:\n     case PR_LO_REGS:\n     case PR_HI_REGS:\n@@ -1796,6 +1830,11 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n     return mode == DImode;\n \n   unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+  /* At the moment, partial vector modes are only useful for memory\n+     references, but that could change in future.  */\n+  if (vec_flags & VEC_PARTIAL)\n+    return false;\n+\n   if (vec_flags & VEC_SVE_PRED)\n     return PR_REGNUM_P (regno);\n \n@@ -7441,9 +7480,15 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \n   HOST_WIDE_INT const_size;\n \n+  /* Whether a vector mode is partial doesn't affect address legitimacy.\n+     Partial vectors like VNx8QImode allow the same indexed addressing\n+     mode and MUL VL addressing mode as full vectors like VNx16QImode;\n+     in both cases, MUL VL counts multiples of GET_MODE_SIZE.  */\n+  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+  vec_flags &= ~VEC_PARTIAL;\n+\n   /* On BE, we use load/store pair for all large int mode load/stores.\n      TI/TFmode may also use a load/store pair.  */\n-  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n   bool advsimd_struct_p = (vec_flags == (VEC_ADVSIMD | VEC_STRUCT));\n   bool load_store_pair_p = (type == ADDR_QUERY_LDP_STP\n \t\t\t    || type == ADDR_QUERY_LDP_STP_N\n@@ -8948,7 +8993,7 @@ aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x,\n \t\t\t\taarch64_addr_query_type type)\n {\n   struct aarch64_address_info addr;\n-  unsigned int size;\n+  unsigned int size, vec_flags;\n \n   /* Check all addresses are Pmode - including ILP32.  */\n   if (GET_MODE (x) != Pmode\n@@ -8964,26 +9009,24 @@ aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x,\n       {\n       case ADDRESS_REG_IMM:\n \tif (known_eq (addr.const_offset, 0))\n-\t  asm_fprintf (f, \"[%s]\", reg_names [REGNO (addr.base)]);\n-\telse if (aarch64_sve_data_mode_p (mode))\n \t  {\n-\t    HOST_WIDE_INT vnum\n-\t      = exact_div (addr.const_offset,\n-\t\t\t   BYTES_PER_SVE_VECTOR).to_constant ();\n-\t    asm_fprintf (f, \"[%s, #%wd, mul vl]\",\n-\t\t\t reg_names[REGNO (addr.base)], vnum);\n+\t    asm_fprintf (f, \"[%s]\", reg_names[REGNO (addr.base)]);\n+\t    return true;\n \t  }\n-\telse if (aarch64_sve_pred_mode_p (mode))\n+\n+\tvec_flags = aarch64_classify_vector_mode (mode);\n+\tif (vec_flags & VEC_ANY_SVE)\n \t  {\n \t    HOST_WIDE_INT vnum\n \t      = exact_div (addr.const_offset,\n-\t\t\t   BYTES_PER_SVE_PRED).to_constant ();\n+\t\t\t   aarch64_vl_bytes (mode, vec_flags)).to_constant ();\n \t    asm_fprintf (f, \"[%s, #%wd, mul vl]\",\n \t\t\t reg_names[REGNO (addr.base)], vnum);\n+\t    return true;\n \t  }\n-\telse\n-\t  asm_fprintf (f, \"[%s, %wd]\", reg_names [REGNO (addr.base)],\n-\t\t       INTVAL (addr.offset));\n+\n+\tasm_fprintf (f, \"[%s, %wd]\", reg_names[REGNO (addr.base)],\n+\t\t     INTVAL (addr.offset));\n \treturn true;\n \n       case ADDRESS_REG_REG:\n@@ -9395,7 +9438,7 @@ aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)\n      can hold MODE, but at the moment we need to handle all modes.\n      Just ignore any runtime parts for registers that can't store them.  */\n   HOST_WIDE_INT lowest_size = constant_lower_bound (GET_MODE_SIZE (mode));\n-  unsigned int nregs;\n+  unsigned int nregs, vec_flags;\n   switch (regclass)\n     {\n     case TAILCALL_ADDR_REGS:\n@@ -9406,11 +9449,12 @@ aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)\n     case FP_REGS:\n     case FP_LO_REGS:\n     case FP_LO8_REGS:\n-      if (aarch64_sve_data_mode_p (mode)\n+      vec_flags = aarch64_classify_vector_mode (mode);\n+      if ((vec_flags & VEC_SVE_DATA)\n \t  && constant_multiple_p (GET_MODE_SIZE (mode),\n-\t\t\t\t  BYTES_PER_SVE_VECTOR, &nregs))\n+\t\t\t\t  aarch64_vl_bytes (mode, vec_flags), &nregs))\n \treturn nregs;\n-      return (aarch64_vector_data_mode_p (mode)\n+      return (vec_flags & VEC_ADVSIMD\n \t      ? CEIL (lowest_size, UNITS_PER_VREG)\n \t      : CEIL (lowest_size, UNITS_PER_WORD));\n     case STACK_REG:\n@@ -15057,7 +15101,7 @@ static bool\n aarch64_vector_mode_supported_p (machine_mode mode)\n {\n   unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n-  return vec_flags != 0 && (vec_flags & VEC_STRUCT) == 0;\n+  return vec_flags != 0 && (vec_flags & (VEC_STRUCT | VEC_PARTIAL)) == 0;\n }\n \n /* Return the full-width SVE vector mode for element mode MODE, if one"}, {"sha": "95522d6b53962a17f994b6490c6d85c76f275a35", "filename": "gcc/genmodes.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550a338052c374cb1f6c07ffd883c4046565fdd4/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=550a338052c374cb1f6c07ffd883c4046565fdd4", "patch": "@@ -53,6 +53,7 @@ struct mode_data\n \n   const char *name;\t\t/* printable mode name -- SI, not SImode */\n   enum mode_class cl;\t\t/* this mode class */\n+  unsigned int order;\t\t/* top-level sorting order */\n   unsigned int precision;\t/* size in bits, equiv to TYPE_PRECISION */\n   unsigned int bytesize;\t/* storage size in addressable units */\n   unsigned int ncomponents;\t/* number of subunits */\n@@ -85,7 +86,7 @@ static struct mode_data *void_mode;\n \n static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n-  -1U, -1U, -1U, -1U,\n+  0, -1U, -1U, -1U, -1U,\n   0, 0, 0, 0, 0, 0,\n   \"<unknown>\", 0, 0, 0, 0, false, false, 0\n };\n@@ -484,14 +485,15 @@ make_complex_modes (enum mode_class cl,\n     }\n }\n \n-/* For all modes in class CL, construct vector modes of width\n-   WIDTH, having as many components as necessary.  */\n-#define VECTOR_MODES_WITH_PREFIX(PREFIX, C, W) \\\n-  make_vector_modes (MODE_##C, #PREFIX, W, __FILE__, __LINE__)\n-#define VECTOR_MODES(C, W) VECTOR_MODES_WITH_PREFIX (V, C, W)\n+/* For all modes in class CL, construct vector modes of width WIDTH,\n+   having as many components as necessary.  ORDER is the sorting order\n+   of the mode, with smaller numbers indicating a higher priority.  */\n+#define VECTOR_MODES_WITH_PREFIX(PREFIX, C, W, ORDER) \\\n+  make_vector_modes (MODE_##C, #PREFIX, W, ORDER, __FILE__, __LINE__)\n+#define VECTOR_MODES(C, W) VECTOR_MODES_WITH_PREFIX (V, C, W, 0)\n static void ATTRIBUTE_UNUSED\n make_vector_modes (enum mode_class cl, const char *prefix, unsigned int width,\n-\t\t   const char *file, unsigned int line)\n+\t\t   unsigned int order, const char *file, unsigned int line)\n {\n   struct mode_data *m;\n   struct mode_data *v;\n@@ -530,6 +532,7 @@ make_vector_modes (enum mode_class cl, const char *prefix, unsigned int width,\n \t}\n \n       v = new_mode (vclass, xstrdup (buf), file, line);\n+      v->order = order;\n       v->component = m;\n       v->ncomponents = ncomponents;\n     }\n@@ -832,6 +835,11 @@ cmp_modes (const void *a, const void *b)\n   const struct mode_data *const m = *(const struct mode_data *const*)a;\n   const struct mode_data *const n = *(const struct mode_data *const*)b;\n \n+  if (m->order > n->order)\n+    return 1;\n+  else if (m->order < n->order)\n+    return -1;\n+\n   if (m->bytesize > n->bytesize)\n     return 1;\n   else if (m->bytesize < n->bytesize)"}]}