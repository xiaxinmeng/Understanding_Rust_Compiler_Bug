{"sha": "2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2NGQ1NGZhNjZhY2ViOWE3NjM3YTZjOWIwNWU4M2RhNzNmYmYxNw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-07-12T14:37:47Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-07-12T14:37:47Z"}, "message": "cpphash.h: (TOKEN_SPELL) Pulled from cpplex.c.\n\n\t* cpphash.h: (TOKEN_SPELL) Pulled from cpplex.c.\n\t* cpplex.c (TOKEN_SPELL) Move to cpphash.h.\n\n\t* cpphash.c: (struct macro_info, alloc_macro, free_macro,\n\tstruct toklist_dummy): New.\n\t(cpp_free_definition): Free macros with free_macro.\n\t(count_params): Don't save paramter spellings.  Save macro\n\tinformation in a struct macro_info.\n\t(parse_define): Don't allocate a token list.\n\t(save_expansion): Allocate the macro's token list, and\n\tsave parameter spellings if necessary.  Use TOKEN_SPELL.\n\t(cpp_create_definition): Make list const.\n\nFrom-SVN: r34985", "tree": {"sha": "72b34acb36220595f92d8f0fb9b891d3aafb73a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72b34acb36220595f92d8f0fb9b891d3aafb73a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/comments", "author": null, "committer": null, "parents": [{"sha": "b9161f44f010d95884a05be53d062f26fe3d4c7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9161f44f010d95884a05be53d062f26fe3d4c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9161f44f010d95884a05be53d062f26fe3d4c7d"}], "stats": {"total": 257, "additions": 167, "deletions": 90}, "files": [{"sha": "efd792c11d74a6677de977f136dd656ec938def2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "patch": "@@ -1,3 +1,18 @@\n+2000-07-12  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpphash.h: (TOKEN_SPELL) Pulled from cpplex.c.\n+\t* cpplex.c (TOKEN_SPELL) Move to cpphash.h.\n+\n+\t* cpphash.c: (struct macro_info, alloc_macro, free_macro,\n+\tstruct toklist_dummy): New.\n+\t(cpp_free_definition): Free macros with free_macro.\n+\t(count_params): Don't save paramter spellings.  Save macro\n+\tinformation in a struct macro_info.\n+\t(parse_define): Don't allocate a token list.\n+\t(save_expansion): Allocate the macro's token list, and\n+\tsave parameter spellings if necessary.  Use TOKEN_SPELL.\n+\t(cpp_create_definition): Make list const.\n+\n 2000-07-12  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* c-typeck.c (pedwarn_c99): Move to"}, {"sha": "c49ba810b9e06daf1ea029f6e37f66ce51f16515", "filename": "gcc/cpphash.c", "status": "modified", "additions": 151, "deletions": 89, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "patch": "@@ -40,6 +40,14 @@ struct hashdummy\n   unsigned short length;\n };\n \n+/* Stores basic information about a macro, before it is allocated.  */\n+struct macro_info\n+{\n+  unsigned int paramlen;\n+  signed short paramc;\n+  unsigned char flags;\n+};\n+\n /* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n #define HASHSIZE 500\n \n@@ -51,15 +59,21 @@ static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n \n static const cpp_token *count_params PARAMS ((cpp_reader *,\n \t\t\t\t\t      const cpp_token *,\n-\t\t\t\t\t      cpp_toklist *));\n+\t\t\t\t\t      struct macro_info *));\n static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n-static cpp_toklist *parse_define PARAMS((cpp_reader *));\n+static const cpp_toklist * parse_define PARAMS((cpp_reader *));\n static int check_macro_redefinition PARAMS((cpp_reader *, cpp_hashnode *hp,\n \t\t\t\t\t     const cpp_toklist *));\n-static int save_expansion PARAMS((cpp_reader *, cpp_toklist *,\n-\t\t\t\t  const cpp_token *, const cpp_token *));\n+static const cpp_toklist * save_expansion PARAMS((cpp_reader *,\n+\t\t\t\t\t\t  const cpp_token *,\n+\t\t\t\t\t\t  const cpp_token *,\n+\t\t\t\t\t\t  struct macro_info *));\n static unsigned int find_param PARAMS ((const cpp_token *,\n \t\t\t\t\tconst cpp_token *));\n+static cpp_toklist * alloc_macro PARAMS ((cpp_reader *,\n+\t\t\t\t\t  struct macro_info *,\n+\t\t\t\t\t  unsigned int, unsigned int));\n+static void free_macro PARAMS((const cpp_toklist *));\n \n /* Calculate hash of a string of length LEN.  */\n unsigned int\n@@ -170,7 +184,7 @@ _cpp_free_definition (h)\n      cpp_hashnode *h;\n {\n   if (h->type == T_MACRO)\n-    _cpp_free_toklist (h->value.expansion);\n+    free_macro (h->value.expansion);\n   h->value.expansion = NULL;\n }\n \n@@ -212,20 +226,23 @@ is__va_args__ (pfile, token)\n   return 1;\n }\n \n-/* Counts the parameters to a function like macro, and saves their\n-   spellings if necessary.  Returns the token that we stopped scanning\n-   at; if it's type isn't CPP_CLOSE_PAREN there was an error, which\n-   has been reported.  */\n+/* Counts the parameters to a function-like macro, the length of their\n+   null-terminated names, and whether the macro is a variable-argument\n+   one.  FIRST is the token immediately after the open parenthesis,\n+   INFO stores the data, and should have paramlen and flags zero.\n+\n+   Returns the token that we stopped scanning at; if it's type isn't\n+   CPP_CLOSE_PAREN there was an error, which has been reported.  */\n static const cpp_token *\n-count_params (pfile, first, list)\n+count_params (pfile, first, info)\n      cpp_reader *pfile;\n      const cpp_token *first;\n-     cpp_toklist *list;\n+     struct macro_info *info;\n {\n-  unsigned int params_len = 0, prev_ident = 0;\n-  const cpp_token *token, *temp;\n+  unsigned int prev_ident = 0;\n+  const cpp_token *token;\n \n-  list->paramc = 0;\n+  info->paramc = 0;\n   for (token = first;; token++)\n     {\n       switch (token->type)\n@@ -251,10 +268,6 @@ count_params (pfile, first, list)\n \t  if (is__va_args__ (pfile, token))\n \t    goto out;\n \n-\t  params_len += token->val.node->length + 1;\n-\t  prev_ident = 1;\n-\t  list->paramc++;\n-\n \t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n \t  if (find_param (first, token))\n \t    {\n@@ -263,6 +276,11 @@ count_params (pfile, first, list)\n \t\t\t\t   token->val.node->name);\n \t      goto out;\n \t    }\n+\n+\t  prev_ident = 1;\n+\t  info->paramc++;\n+\t  if (pfile->save_parameter_spellings)\n+\t    info->paramlen += token->val.node->length + 1;\n \t  break;\n \n \tdefault:\n@@ -271,8 +289,8 @@ count_params (pfile, first, list)\n \t  goto out;\n \n \tcase CPP_CLOSE_PAREN:\n-\t  if (prev_ident || list->paramc == 0)\n-\t    goto scanned;\n+\t  if (prev_ident || info->paramc == 0)\n+\t    goto out;\n \n \t  /* Fall through to pick up the error.  */\n \tcase CPP_COMMA:\n@@ -297,60 +315,42 @@ count_params (pfile, first, list)\n \n \t      tok->type = CPP_NAME;\n \t      tok->val.node = pfile->spec_nodes->n__VA_ARGS__;\n-\t      list->paramc++;\n-\t      params_len += tok->val.node->length + 1;\n+\n+\t      info->paramc++;\n+\t      if (pfile->save_parameter_spellings)\n+\t\tinfo->paramlen += tok->val.node->length + 1;\n \n \t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n \t\tcpp_pedwarn (pfile,\n \t\t\t     \"C89 does not permit anon varargs macros\");\n \t    }\n \t  else\n \t    {\n-\t      list->flags |= GNU_REST_ARGS;\n+\t      info->flags |= GNU_REST_ARGS;\n \t      if (CPP_PEDANTIC (pfile))\n \t\tcpp_pedwarn (pfile,\n \t\t\t     \"ISO C does not permit named varargs parameters\");\n \t    }\n \n-\t  list->flags |= VAR_ARGS;\n+\t  info->flags |= VAR_ARGS;\n \t  token++;\n \t  if (token->type == CPP_CLOSE_PAREN)\n-\t    goto scanned;\n+\t    goto out;\n \t  goto missing_paren;\n \t}\n     }\n \n- scanned:\n-  /* Store the null-terminated parameter spellings of a function, to\n-     provide pedantic warnings to satisfy 6.10.3.2, or for use when\n-     dumping macro definitions.  */\n-  if (list->paramc > 0 && pfile->save_parameter_spellings)\n-    {\n-      U_CHAR *buf;\n-\n-      _cpp_reserve_name_space (list, params_len);\n-      list->params_len = list->name_used = params_len;\n-      buf = list->namebuf;\n-      for (temp = first; temp <= token; temp++)\n-\tif (temp->type == CPP_NAME)\n-\t  {\n-\t    /* copy null too */\n-\t    memcpy (buf, temp->val.node->name, temp->val.node->length + 1);\n-\t    buf += temp->val.node->length + 1;\n-\t  }\n-    }\n-\n  out:\n   return token;\n }\n \n /* Parses a #define directive.  Returns null pointer on error.  */\n-static cpp_toklist *\n+static const cpp_toklist *\n parse_define (pfile)\n      cpp_reader *pfile;\n {\n   const cpp_token *token, *first_param;\n-  cpp_toklist *list;\n+  struct macro_info info;\n   int prev_white = 0;\n \n   /* The first token after the macro's name.  */\n@@ -362,35 +362,28 @@ parse_define (pfile)\n \n   while (token->type == CPP_COMMENT)\n     token++, prev_white = 1;\n-\n-  /* Allocate the expansion's list.  It will go in the hash table.  */\n-  list = (cpp_toklist *) xmalloc (sizeof (cpp_toklist));\n-  _cpp_init_toklist (list, 0);\n   first_param = token + 1;\n-  list->paramc = -1;\t\t/* Object-like macro.  */\n+\n+  /* Assume object-like macro.  */\n+  info.paramc = -1;\n+  info.paramlen = 0;\n+  info.flags = 0;\n \n   if (!prev_white && !(token->flags & PREV_WHITE))\n     {\n       if (token->type == CPP_OPEN_PAREN)\n \t{\n-\t  token = count_params (pfile, first_param, list);\n+\t  token = count_params (pfile, first_param, &info);\n \t  if (token->type != CPP_CLOSE_PAREN)\n-\t    goto error;\n+\t    return 0;\n \t  token++;\n \t}\n       else if (token->type != CPP_EOF)\n \tcpp_pedwarn (pfile,\n \t\t     \"ISO C requires whitespace after the macro name\");\n     }\n \n-  if (save_expansion (pfile, list, token, first_param))\n-    {\n-    error:\n-      _cpp_free_toklist (list);\n-      list = 0;\n-    }\n-\n-  return list;\n+  return save_expansion (pfile, token, first_param, &info);\n }\n \n static int\n@@ -422,19 +415,82 @@ check_macro_redefinition (pfile, hp, list2)\n   return 1;\n }\n \n-/* Copy the tokens of the expansion.  Change the type of macro\n-   arguments from CPP_NAME to CPP_MACRO_ARG.  Remove #'s that\n-   represent stringification, flagging the CPP_MACRO_ARG it operates\n-   on STRINGIFY.  Remove ##'s, flagging the token on its immediate\n-   left PASTE_LEFT.  Returns non-zero on error.  */\n-static int\n-save_expansion (pfile, list, first, first_param)\n+/* This is a dummy structure whose only purpose is getting alignment\n+   correct.  */\n+struct toklist_dummy\n+{\n+  cpp_toklist list;\n+  cpp_token first_token;\n+};\n+\n+\n+/* Allocate space to hold the token list, its tokens, their text, and\n+   the parameter names if needed.  Empty expansions are stored as a\n+   single placemarker token.\n+\n+   These are all allocated in a block together for performance\n+   reasons.  Therefore, this token list cannot be expanded like a\n+   normal token list.  Try to do so, and you lose.  */\n+static cpp_toklist *\n+alloc_macro (pfile, info, ntokens, len)\n+     cpp_reader *pfile;\n+     struct macro_info *info;\n+     unsigned int ntokens, len;\n+{\n+  unsigned int size;\n+  struct toklist_dummy *dummy;\n+  cpp_toklist *list;\n+\n+  size = sizeof (struct toklist_dummy);\n+  size += (ntokens - 1) * sizeof(cpp_token);\n+  size += len + info->paramlen;\n+\n+  dummy = (struct toklist_dummy *) xmalloc (size);\n+  list = (cpp_toklist *) dummy;\n+  \n+  /* Initialize the monster.  */\n+  list->tokens = &dummy->first_token;\n+  list->tokens_used = list->tokens_cap = ntokens;\n+\n+  list->namebuf = (unsigned char *) &list->tokens[ntokens];\n+  list->name_used = list->name_cap = len + info->paramlen;\n+\n+  list->directive = 0;\n+  list->line = pfile->token_list.line;\n+  list->file = pfile->token_list.file;\n+  list->params_len = info->paramlen;\n+  list->paramc = info->paramc;\n+  list->flags = info->flags;\n+\n+  return list;\n+}\n+\n+/* Free a macro allocated by allocate_macro.  */\n+static void\n+free_macro (list)\n+     const cpp_toklist *list;\n+{\n+  free ((PTR) list);\n+}\n+\n+/* Copy the tokens of the expansion, beginning with FIRST until\n+   CPP_EOF.  For a function-like macro, FIRST_PARAM points to the\n+   first parameter.  INFO contains information about the macro.\n+\n+   Change the type of macro arguments in the expansion from CPP_NAME\n+   to CPP_MACRO_ARG.  Remove #'s that represent stringification,\n+   flagging the CPP_MACRO_ARG it operates on STRINGIFY.  Remove ##'s,\n+   flagging the token on its immediate left PASTE_LEFT.  Returns the\n+   token list for the macro expansion, or 0 on error.  */\n+static const cpp_toklist *\n+save_expansion (pfile, first, first_param, info)\n      cpp_reader *pfile;\n-     cpp_toklist *list;\n      const cpp_token *first;\n      const cpp_token *first_param;\n+     struct macro_info *info;\n {\n   const cpp_token *token;\n+  cpp_toklist *list;\n   cpp_token *dest;\n   unsigned int len, ntokens;\n   unsigned char *buf;\n@@ -462,7 +518,7 @@ save_expansion (pfile, list, first, first_param)\n \t{\n \t  /* Stringifying #, but is a normal character if traditional,\n \t     or in object-like macros.  Constraint 6.10.3.2.1.  */\n-\t  if (list->paramc >= 0 && ! CPP_TRADITIONAL (pfile))\n+\t  if (info->paramc >= 0 && ! CPP_TRADITIONAL (pfile))\n \t    {\n \t      if (token[1].type == CPP_NAME\n \t\t  && find_param (first_param, token + 1))\n@@ -472,31 +528,42 @@ save_expansion (pfile, list, first, first_param)\n \t\t  msg = \"'#' is not followed by a macro parameter\";\n \t\terror:\n \t\t  cpp_error_with_line (pfile, token->line, token->col, msg);\n-\t\t  return 1;\n+\t\t  return 0;\n \t\t}\n \t    }\n \t}\n       else if (token->type == CPP_NAME)\n \t{\n \t  /* Constraint 6.10.3.5  */\n-\t  if (!(list->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n-\t    return 1;\n+\t  if (!(info->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n+\t    return 0;\n+\t  /* It might be worth doing a check here that we aren't a\n+\t     macro argument, since we don't store the text of macro\n+\t     arguments.  This would reduce \"len\" and save space.  */\n \t}\n       ntokens++;\n-      if (token_spellings[token->type].type == SPELL_STRING)\n+      if (TOKEN_SPELL (token) == SPELL_STRING)\n \tlen += token->val.str.len;\n     }\n \n-  /* Allocate space to hold the tokens.  Empty expansions are stored\n-     as a single placemarker token.  */\n   if (ntokens == 0)\n     ntokens++;\n-  _cpp_expand_token_space (list, ntokens);\n-  if (len > 0)\n-    _cpp_expand_name_space (list, len);\n+  list = alloc_macro (pfile, info, ntokens, len);\n+  buf = list->namebuf;\n+\n+  /* Store the null-terminated parameter spellings of a macro, to\n+     provide pedantic warnings to satisfy 6.10.3.2, or for use when\n+     dumping macro definitions.  They must go first.  */\n+  if (list->params_len)\n+    for (token = first_param; token < first; token++)\n+      if (token->type == CPP_NAME)\n+\t{\n+\t  /* Copy null too.  */\n+\t  memcpy (buf, token->val.node->name, token->val.node->length + 1);\n+\t  buf += token->val.node->length + 1;\n+\t}\n \n   dest = list->tokens;\n-  buf = list->namebuf + list->name_used;\n   for (token = first; token->type != CPP_EOF; token++)\n     {\n       unsigned int param_no;\n@@ -543,7 +610,7 @@ save_expansion (pfile, list, first, first_param)\n \n       /* Copy the token.  */\n       *dest = *token;\n-      if (token_spellings[token->type].type == SPELL_STRING)\n+      if (TOKEN_SPELL (token) == SPELL_STRING)\n \t{\n \t  memcpy (buf, token->val.str.text, token->val.str.len);\n \t  dest->val.str.text = buf;\n@@ -558,20 +625,15 @@ save_expansion (pfile, list, first, first_param)\n       dest->flags = 0;\n     }\n \n-  list->tokens_used = ntokens;\n-  list->line = pfile->token_list.line;\n-  list->file = pfile->token_list.file;\n-  list->name_used = len;\n-\n-  return 0;\n+  return list;\n }\n \n int\n _cpp_create_definition (pfile, hp)\n      cpp_reader *pfile;\n      cpp_hashnode *hp;\n {\n-  cpp_toklist *list;\n+  const cpp_toklist *list;\n \n   list = parse_define (pfile);\n   if (!list)"}, {"sha": "b527620cf4f5a17229479434a248376ce12d00a2", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "patch": "@@ -43,6 +43,7 @@ struct token_spelling\n };\n \n extern const struct token_spelling token_spellings[];\n+#define TOKEN_SPELL(token) (token_spellings[(token)->type].type)\n \n /* Chained list of answers to an assertion.  */\n struct answer"}, {"sha": "00e2ecbd96385a96328e085b3aa5a79181811944", "filename": "gcc/cpplex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2964d54fa66aceb9a7637a6c9b05e83da73fbf17/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=2964d54fa66aceb9a7637a6c9b05e83da73fbf17", "patch": "@@ -139,7 +139,6 @@ static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n \n /* An upper bound on the number of bytes needed to spell a token,\n    including preceding whitespace.  */\n-#define TOKEN_SPELL(token) token_spellings[(token)->type].type\n #define TOKEN_LEN(token) (5 + (TOKEN_SPELL(token) == SPELL_STRING\t\\\n \t\t\t       ? (token)->val.str.len\t\t\t\\\n \t\t\t       : (TOKEN_SPELL(token) == SPELL_IDENT\t\\"}]}