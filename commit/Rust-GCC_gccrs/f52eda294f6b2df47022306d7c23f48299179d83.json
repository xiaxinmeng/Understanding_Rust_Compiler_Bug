{"sha": "f52eda294f6b2df47022306d7c23f48299179d83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUyZWRhMjk0ZjZiMmRmNDcwMjIzMDZkN2MyM2Y0ODI5OTE3OWQ4Mw==", "commit": {"author": {"name": "Graham Stott", "email": "grahams@redhat.com", "date": "2002-01-03T05:11:05Z"}, "committer": {"name": "Graham Stott", "email": "grahams@gcc.gnu.org", "date": "2002-01-03T05:11:05Z"}, "message": "rtl.h: Update copyright date.\n\n\n        * rtl.h: Update copyright date.\n        (RTL_CHECK1): Wrap long line.\n        (RTL_CHECK2): Likewise.\n        (RTL_CHECKC1): Wrap long line and whitespace.\n        (RTL_CHECKC2): Likewise.\n        (XWINT): Whitespace.\n        (XINT): Likewise.\n        (XSTR): Likewise.\n        (XEXP): Likewise.\n        (XVEC): Likewise.\n        (XMODE): Likewise.\n        (XBITMAP): Likewise.\n        (XTREE): Likewise.\n        (XBBDEF): Likewise.\n        (XTMPL): Likewise.\n        (X0WINT): Likewise.\n        (X0INT):Likewise.\n        (X0UINT): Likewise.\n        (X0STR): Likewise.\n        (X0EXP): Likewise.\n        (X0VEC): Likewise.\n        (X0MODE): Likewise.\n        (X0BITMAP): Likewise.\n        (X0TREE): Likewise.\n        (X0BBDEF): Likewise.\n        (X0ADVFLAGS): Likewise.\n        (X0CSELIB): Likewise.\n        (X0MEMATTR): Likewise.\n        (XCWINT): Likewise.\n        (XCINT): Likewise.\n        (XCUINT): Likewise.\n        (XCSTR): Likewise.\n        (XCEXP): Likewise.\n        (XCVEC): Likewise.\n        (XCMODE): Likewise.\n        (XCBITMAP): Likewise.\n        (XCTREE): Likewise.\n        (XCBBDEF): Likewise.\n        (XCADVFLAGS): Likewise.\n        (XCCSELIB): Likewise.\n        (XC2EXP): Likewise.\n        (INSN_UID): Likewise.\n        (PREV_INSN): Likewise.\n        (PATTERN): Likewise.\n        (INSN_CODE): Likewise.\n        (PUT_REG_NOTE_KIND): Likewise.\n        (CODE_LABEL_NUMBER): Likewise.\n        (NOTE_SOURCE_FILE): Likewise.\n        (NOTE_BLOCK): Likewise.\n        (NOTE_EH_HANDLER): Likewise.\n        (NOTE_RANGE_INFO): Likewise.\n        (NOTE_LIVE_INFO): Likewise.\n        (NOTE_BASIC_BLOCK): Likewise.\n        (NOTE_EXPECTED_VALUE): Likewise.\n        (NOTE_LINE_NUMBER): Likewise.\n        (LABEL_NAME): Likewise.\n        (LABEL_NUSES): Likewise.\n        (LABEL_ALTERNATE_NAME): Likewise.\n        (ADDRESSOF_DECL): Likewise.\n        (JUMP_LABEL): Likewise.\n        (LABEL_NEXTREF): Likewise.\n        (REGNO): Likewise.\n        (ORIGINAL_REGNO: Likewise.\n        (HARD_REGISTER_NUM_P): Add parenthesis.\n        (SUBREG_REG): Whitespace.\n        (SUBREG_BYTE): Likewise.\n        (ASM_OPERANDS_TEMPLATE): Remove parenthesis.\n        (ASM_OPERANDS_OUTPUT_CONSTRAINT): Likewise.\n        (ASM_OPERANDS_OUTPUT_IDX): Likewise.\n        (ASM_OPERANDS_INPUT_VEC): Likewise.\n        (ASM_OPERANDS_INPUT_CONSTRAINT_VEC): Likewise.\n        (ASM_OPERANDS_INPUT): Likewise.\n        (ASM_OPERANDS_INPUT_LENGTH): Likewise.\n        (ASM_OPERANDS_INPUT_CONSTRAINT_EXP): Likewise.\n        (ASM_OPERANDS_INPUT_CONSTRAINT): Likewise.\n        (ASM_OPERANDS_INPUT_MODE): Likewise.\n        (ASM_OPERANDS_SOURCE_FILE): Likewise.\n        (ASM_OPERANDS_SOURCE_LINE): Likewise.\n        (MEM_SET_IN_STRUCT_P): Minor reformat.\n        (TRAP_CONDITION): Whitespace.\n        (TRAP_CODE): Likewise.\n        (COND_EXEC_TEST): Likewise.\n        (COND_EXEC_CODE): Likewise.\n        (FIND_REG_INC_NOTE): Uppercase macro args and add parenthesis.\n        (PHI_NODE_P): Add parenthesis.\n        (plus_constant): Whitespace and add paraenthese.\n\nFrom-SVN: r48497", "tree": {"sha": "e3f6ddb9b3dfbb000b7f8473b19da2c78c869247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3f6ddb9b3dfbb000b7f8473b19da2c78c869247"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f52eda294f6b2df47022306d7c23f48299179d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f52eda294f6b2df47022306d7c23f48299179d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f52eda294f6b2df47022306d7c23f48299179d83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f52eda294f6b2df47022306d7c23f48299179d83/comments", "author": null, "committer": null, "parents": [{"sha": "e03f5d43cb6dd594512afa8ac72ebfe6af2eafc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e03f5d43cb6dd594512afa8ac72ebfe6af2eafc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e03f5d43cb6dd594512afa8ac72ebfe6af2eafc8"}], "stats": {"total": 292, "additions": 194, "deletions": 98}, "files": [{"sha": "8e9597f4aeda7a6bc7e63f042c1739bf57886870", "filename": "gcc/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f52eda294f6b2df47022306d7c23f48299179d83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f52eda294f6b2df47022306d7c23f48299179d83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f52eda294f6b2df47022306d7c23f48299179d83", "patch": "@@ -1,3 +1,92 @@\n+2002-01-03  Graham Stott  <grahams@redhat.com>\n+\n+\t* rtl.h: Update copyright date.\n+\t(RTL_CHECK1): Wrap long line.\n+\t(RTL_CHECK2): Likewise.\n+\t(RTL_CHECKC1): Wrap long line and whitespace.\n+\t(RTL_CHECKC2): Likewise.\n+\t(XWINT): Whitespace.\n+\t(XINT): Likewise.\n+\t(XSTR): Likewise.\n+\t(XEXP): Likewise.\n+\t(XVEC): Likewise.\n+\t(XMODE): Likewise.\n+\t(XBITMAP): Likewise.\n+\t(XTREE): Likewise.\n+\t(XBBDEF): Likewise.\n+\t(XTMPL): Likewise.\n+\t(X0WINT): Likewise.\n+\t(X0INT):Likewise.\n+\t(X0UINT): Likewise.\n+\t(X0STR): Likewise.\n+\t(X0EXP): Likewise.\n+\t(X0VEC): Likewise.\n+\t(X0MODE): Likewise.\n+\t(X0BITMAP): Likewise.\n+\t(X0TREE): Likewise.\n+\t(X0BBDEF): Likewise.\n+\t(X0ADVFLAGS): Likewise.\n+\t(X0CSELIB): Likewise.\n+\t(X0MEMATTR): Likewise.\n+\t(XCWINT): Likewise.\n+\t(XCINT): Likewise.\n+\t(XCUINT): Likewise.\n+\t(XCSTR): Likewise.\n+\t(XCEXP): Likewise.\n+\t(XCVEC): Likewise.\n+\t(XCMODE): Likewise.\n+\t(XCBITMAP): Likewise.\n+\t(XCTREE): Likewise.\n+\t(XCBBDEF): Likewise.\n+\t(XCADVFLAGS): Likewise.\n+\t(XCCSELIB): Likewise.\n+\t(XC2EXP): Likewise.\n+\t(INSN_UID): Likewise.\n+\t(PREV_INSN): Likewise.\n+\t(PATTERN): Likewise.\n+\t(INSN_CODE): Likewise.\n+\t(PUT_REG_NOTE_KIND): Likewise.\n+\t(CODE_LABEL_NUMBER): Likewise.\n+\t(NOTE_SOURCE_FILE): Likewise.\n+\t(NOTE_BLOCK): Likewise.\n+\t(NOTE_EH_HANDLER): Likewise.\n+\t(NOTE_RANGE_INFO): Likewise.\n+\t(NOTE_LIVE_INFO): Likewise.\n+\t(NOTE_BASIC_BLOCK): Likewise.\n+\t(NOTE_EXPECTED_VALUE): Likewise.\n+\t(NOTE_LINE_NUMBER): Likewise.\n+\t(LABEL_NAME): Likewise.\n+\t(LABEL_NUSES): Likewise.\n+\t(LABEL_ALTERNATE_NAME): Likewise.\n+\t(ADDRESSOF_DECL): Likewise.\n+\t(JUMP_LABEL): Likewise.\n+\t(LABEL_NEXTREF): Likewise.\n+\t(REGNO): Likewise.\n+\t(ORIGINAL_REGNO: Likewise.\n+\t(HARD_REGISTER_NUM_P): Add parenthesis.\n+\t(SUBREG_REG): Whitespace.\n+\t(SUBREG_BYTE): Likewise.\n+\t(ASM_OPERANDS_TEMPLATE): Remove parenthesis.\n+\t(ASM_OPERANDS_OUTPUT_CONSTRAINT): Likewise.\n+\t(ASM_OPERANDS_OUTPUT_IDX): Likewise.\n+\t(ASM_OPERANDS_INPUT_VEC): Likewise.\n+\t(ASM_OPERANDS_INPUT_CONSTRAINT_VEC): Likewise.\n+\t(ASM_OPERANDS_INPUT): Likewise.\n+\t(ASM_OPERANDS_INPUT_LENGTH): Likewise.\n+\t(ASM_OPERANDS_INPUT_CONSTRAINT_EXP): Likewise.\n+\t(ASM_OPERANDS_INPUT_CONSTRAINT): Likewise.\n+\t(ASM_OPERANDS_INPUT_MODE): Likewise.\n+\t(ASM_OPERANDS_SOURCE_FILE): Likewise.\n+\t(ASM_OPERANDS_SOURCE_LINE): Likewise.\n+\t(MEM_SET_IN_STRUCT_P): Minor reformat.\n+\t(TRAP_CONDITION): Whitespace.\n+\t(TRAP_CODE): Likewise.\n+\t(COND_EXEC_TEST): Likewise.\n+\t(COND_EXEC_CODE): Likewise.\n+\t(FIND_REG_INC_NOTE): Uppercase macro args and add parenthesis.\n+\t(PHI_NODE_P): Add parenthesis.\n+\t(plus_constant): Whitespace and add parenthesis.\n+\n 2002-01-03  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/avr/avr.c: Fix comment typos."}, {"sha": "76ce3f92db1dfbad1339a8e548f31c6de6f0c330", "filename": "gcc/rtl.h", "status": "modified", "additions": 105, "deletions": 98, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f52eda294f6b2df47022306d7c23f48299179d83/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f52eda294f6b2df47022306d7c23f48299179d83/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f52eda294f6b2df47022306d7c23f48299179d83", "patch": "@@ -1,6 +1,6 @@\n /* Register Transfer Language (RTL) definitions for GNU C-Compiler\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -266,16 +266,19 @@ struct rtvec_def {\n (*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n      enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n      if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n-       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__, __FUNCTION__); \\\n+       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n+\t\t\t\t__FUNCTION__);\t\t\t\t\\\n      if (GET_RTX_FORMAT(_code)[_n] != C1)\t\t\t\t\\\n-       rtl_check_failed_type1(_rtx, _n, C1, __FILE__, __LINE__, __FUNCTION__); \\\n+       rtl_check_failed_type1 (_rtx, _n, C1, __FILE__, __LINE__,\t\\\n+\t\t\t       __FUNCTION__);\t\t\t\t\\\n      &_rtx->fld[_n]; }))\n \n #define RTL_CHECK2(RTX, N, C1, C2) __extension__\t\t\t\\\n (*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n      enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n      if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n-       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__, __FUNCTION__); \\\n+       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n+\t\t\t\t__FUNCTION__);\t\t\t\t\\\n      if (GET_RTX_FORMAT(_code)[_n] != C1\t\t\t\t\\\n \t && GET_RTX_FORMAT(_code)[_n] != C2)\t\t\t\t\\\n        rtl_check_failed_type2 (_rtx, _n, C1, C2, __FILE__, __LINE__,\t\\\n@@ -284,15 +287,17 @@ struct rtvec_def {\n \n #define RTL_CHECKC1(RTX, N, C) __extension__\t\t\t\t\\\n (*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n-     if (GET_CODE (_rtx) != C)\t\t\t\t\t\t\\\n-       rtl_check_failed_code1 (_rtx, C, __FILE__, __LINE__, __FUNCTION__); \\\n+     if (GET_CODE (_rtx) != (C))\t\t\t\t\t\\\n+       rtl_check_failed_code1 (_rtx, (C), __FILE__, __LINE__,\t\t\\\n+\t\t\t       __FUNCTION__);\t\t\t\t\\\n      &_rtx->fld[_n]; }))\n \n #define RTL_CHECKC2(RTX, N, C1, C2) __extension__\t\t\t\\\n (*({ rtx _rtx = (RTX); int _n = (N);\t\t\t\t\t\\\n      enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n-     if (_code != C1 && _code != C2)\t\t\t\t\t\\\n-       rtl_check_failed_code2(_rtx, C1, C2, __FILE__, __LINE__, __FUNCTION__); \\\n+     if (_code != (C1) && _code != (C2))\t\t\t\t\\\n+       rtl_check_failed_code2 (_rtx, (C1), (C2), __FILE__, __LINE__,\t\\\n+\t\t\t       __FUNCTION__); \\\n      &_rtx->fld[_n]; }))\n \n #define RTVEC_ELT(RTVEC, I) __extension__\t\t\t\t\\\n@@ -331,54 +336,54 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n \n #endif\n \n-#define XWINT(RTX, N)\t(RTL_CHECK1(RTX, N, 'w').rtwint)\n-#define XINT(RTX, N)\t(RTL_CHECK2(RTX, N, 'i', 'n').rtint)\n-#define XSTR(RTX, N)\t(RTL_CHECK2(RTX, N, 's', 'S').rtstr)\n-#define XEXP(RTX, N)\t(RTL_CHECK2(RTX, N, 'e', 'u').rtx)\n-#define XVEC(RTX, N)\t(RTL_CHECK2(RTX, N, 'E', 'V').rtvec)\n-#define XMODE(RTX, N)\t(RTL_CHECK1(RTX, N, 'M').rttype)\n-#define XBITMAP(RTX, N) (RTL_CHECK1(RTX, N, 'b').rtbit)\n-#define XTREE(RTX, N)   (RTL_CHECK1(RTX, N, 't').rttree)\n-#define XBBDEF(RTX, N)\t(RTL_CHECK1(RTX, N, 'B').bb)\n-#define XTMPL(RTX, N)\t(RTL_CHECK1(RTX, N, 'T').rtstr)\n+#define XWINT(RTX, N)\t(RTL_CHECK1 (RTX, N, 'w').rtwint)\n+#define XINT(RTX, N)\t(RTL_CHECK2 (RTX, N, 'i', 'n').rtint)\n+#define XSTR(RTX, N)\t(RTL_CHECK2 (RTX, N, 's', 'S').rtstr)\n+#define XEXP(RTX, N)\t(RTL_CHECK2 (RTX, N, 'e', 'u').rtx)\n+#define XVEC(RTX, N)\t(RTL_CHECK2 (RTX, N, 'E', 'V').rtvec)\n+#define XMODE(RTX, N)\t(RTL_CHECK1 (RTX, N, 'M').rttype)\n+#define XBITMAP(RTX, N) (RTL_CHECK1 (RTX, N, 'b').rtbit)\n+#define XTREE(RTX, N)   (RTL_CHECK1 (RTX, N, 't').rttree)\n+#define XBBDEF(RTX, N)\t(RTL_CHECK1 (RTX, N, 'B').bb)\n+#define XTMPL(RTX, N)\t(RTL_CHECK1 (RTX, N, 'T').rtstr)\n \n #define XVECEXP(RTX, N, M)\tRTVEC_ELT (XVEC (RTX, N), M)\n #define XVECLEN(RTX, N)\t\tGET_NUM_ELEM (XVEC (RTX, N))\n \n /* These are like XWINT, etc. except that they expect a '0' field instead\n    of the normal type code.  */\n \n-#define X0WINT(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtwint)\n-#define X0INT(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtint)\n-#define X0UINT(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtuint)\n-#define X0STR(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtstr)\n-#define X0EXP(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtx)\n-#define X0VEC(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtvec)\n-#define X0MODE(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rttype)\n-#define X0BITMAP(RTX, N)   (RTL_CHECK1(RTX, N, '0').rtbit)\n-#define X0TREE(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rttree)\n-#define X0BBDEF(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').bb)\n-#define X0ADVFLAGS(RTX, N) (RTL_CHECK1(RTX, N, '0').rt_addr_diff_vec_flags)\n-#define X0CSELIB(RTX, N)   (RTL_CHECK1(RTX, N, '0').rt_cselib)\n-#define X0MEMATTR(RTX, N)  (RTL_CHECK1(RTX, N, '0').rtmem)\n-\n-#define XCWINT(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rtwint)\n-#define XCINT(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtint)\n-#define XCUINT(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rtuint)\n-#define XCSTR(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtstr)\n-#define XCEXP(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtx)\n-#define XCVEC(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtvec)\n-#define XCMODE(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rttype)\n-#define XCBITMAP(RTX, N, C)   (RTL_CHECKC1(RTX, N, C).rtbit)\n-#define XCTREE(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rttree)\n-#define XCBBDEF(RTX, N, C)    (RTL_CHECKC1(RTX, N, C).bb)\n-#define XCADVFLAGS(RTX, N, C) (RTL_CHECKC1(RTX, N, C).rt_addr_diff_vec_flags)\n-#define XCCSELIB(RTX, N, C)   (RTL_CHECKC1(RTX, N, C).rt_cselib)\n+#define X0WINT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtwint)\n+#define X0INT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtint)\n+#define X0UINT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtuint)\n+#define X0STR(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtstr)\n+#define X0EXP(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtx)\n+#define X0VEC(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtvec)\n+#define X0MODE(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rttype)\n+#define X0BITMAP(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rtbit)\n+#define X0TREE(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rttree)\n+#define X0BBDEF(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').bb)\n+#define X0ADVFLAGS(RTX, N) (RTL_CHECK1 (RTX, N, '0').rt_addr_diff_vec_flags)\n+#define X0CSELIB(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rt_cselib)\n+#define X0MEMATTR(RTX, N)  (RTL_CHECK1 (RTX, N, '0').rtmem)\n+\n+#define XCWINT(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rtwint)\n+#define XCINT(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtint)\n+#define XCUINT(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rtuint)\n+#define XCSTR(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtstr)\n+#define XCEXP(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtx)\n+#define XCVEC(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtvec)\n+#define XCMODE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rttype)\n+#define XCBITMAP(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rtbit)\n+#define XCTREE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rttree)\n+#define XCBBDEF(RTX, N, C)    (RTL_CHECKC1 (RTX, N, C).bb)\n+#define XCADVFLAGS(RTX, N, C) (RTL_CHECKC1 (RTX, N, C).rt_addr_diff_vec_flags)\n+#define XCCSELIB(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rt_cselib)\n \n #define XCVECEXP(RTX, N, M, C)\tRTVEC_ELT (XCVEC (RTX, N, C), M)\n #define XCVECLEN(RTX, N, C)\tGET_NUM_ELEM (XCVEC (RTX, N, C))\n \n-#define XC2EXP(RTX, N, C1, C2)      (RTL_CHECKC2(RTX, N, C1, C2).rtx)\n+#define XC2EXP(RTX, N, C1, C2)      (RTL_CHECKC2 (RTX, N, C1, C2).rtx)\n \f\n /* ACCESS MACROS for particular fields of insns.  */\n \n@@ -387,18 +392,18 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n \n /* Holds a unique number for each insn.\n    These are not necessarily sequentially increasing.  */\n-#define INSN_UID(INSN)  XINT(INSN, 0)\n+#define INSN_UID(INSN)  XINT (INSN, 0)\n \n /* Chain insns together in sequence.  */\n-#define PREV_INSN(INSN)\tXEXP(INSN, 1)\n-#define NEXT_INSN(INSN)\tXEXP(INSN, 2)\n+#define PREV_INSN(INSN)\tXEXP (INSN, 1)\n+#define NEXT_INSN(INSN)\tXEXP (INSN, 2)\n \n /* The body of an insn.  */\n-#define PATTERN(INSN)\tXEXP(INSN, 3)\n+#define PATTERN(INSN)\tXEXP (INSN, 3)\n \n /* Code number of instruction, from when it was recognized.\n    -1 means this instruction has not been recognized yet.  */\n-#define INSN_CODE(INSN) XINT(INSN, 4)\n+#define INSN_CODE(INSN) XINT (INSN, 4)\n \n /* Set up in flow.c; empty before then.\n    Holds a chain of INSN_LIST rtx's whose first operands point at\n@@ -593,7 +598,8 @@ enum reg_note\n \n /* Define macros to extract and insert the reg-note kind in an EXPR_LIST.  */\n #define REG_NOTE_KIND(LINK) ((enum reg_note) GET_MODE (LINK))\n-#define PUT_REG_NOTE_KIND(LINK,KIND) PUT_MODE(LINK, (enum machine_mode) (KIND))\n+#define PUT_REG_NOTE_KIND(LINK, KIND) \\\n+  PUT_MODE (LINK, (enum machine_mode) (KIND))\n \n /* Names for REG_NOTE's in EXPR_LIST insn's.  */\n \n@@ -612,7 +618,7 @@ extern const char * const reg_note_name[];\n /* The label-number of a code-label.  The assembler label\n    is made from `L' and the label-number printed in decimal.\n    Label numbers are unique in a compilation.  */\n-#define CODE_LABEL_NUMBER(INSN)\tXINT(INSN, 5)\n+#define CODE_LABEL_NUMBER(INSN)\tXINT (INSN, 5)\n \n #define LINE_NUMBER NOTE\n \n@@ -623,17 +629,17 @@ extern const char * const reg_note_name[];\n    The NOTE_INSN_RANGE_{START,END} and NOTE_INSN_LIVE notes record their\n    information as an rtx in the field.  */\n \n-#define NOTE_SOURCE_FILE(INSN) \tXCSTR(INSN, 3, NOTE)\n-#define NOTE_BLOCK(INSN)\tXCTREE(INSN, 3, NOTE)\n-#define NOTE_EH_HANDLER(INSN)\tXCINT(INSN, 3, NOTE)\n-#define NOTE_RANGE_INFO(INSN)  \tXCEXP(INSN, 3, NOTE)\n-#define NOTE_LIVE_INFO(INSN)   \tXCEXP(INSN, 3, NOTE)\n-#define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF(INSN, 3, NOTE)\n-#define NOTE_EXPECTED_VALUE(INSN) XCEXP(INSN, 3, NOTE)\n+#define NOTE_SOURCE_FILE(INSN) \tXCSTR (INSN, 3, NOTE)\n+#define NOTE_BLOCK(INSN)\tXCTREE (INSN, 3, NOTE)\n+#define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 3, NOTE)\n+#define NOTE_RANGE_INFO(INSN)  \tXCEXP (INSN, 3, NOTE)\n+#define NOTE_LIVE_INFO(INSN)   \tXCEXP (INSN, 3, NOTE)\n+#define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 3, NOTE)\n+#define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 3, NOTE)\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n-#define NOTE_LINE_NUMBER(INSN) XCINT(INSN, 4, NOTE)\n+#define NOTE_LINE_NUMBER(INSN) XCINT (INSN, 4, NOTE)\n \n /* Nonzero if INSN is a note marking the beginning of a basic block.  */\n #define NOTE_INSN_BASIC_BLOCK_P(INSN) \t\t\t\\\n@@ -733,49 +739,49 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n \n /* The name of a label, in case it corresponds to an explicit label\n    in the input source code.  */\n-#define LABEL_NAME(RTX) XCSTR(RTX, 6, CODE_LABEL)\n+#define LABEL_NAME(RTX) XCSTR (RTX, 6, CODE_LABEL)\n \n /* In jump.c, each label contains a count of the number\n    of LABEL_REFs that point at it, so unused labels can be deleted.  */\n-#define LABEL_NUSES(RTX) XCINT(RTX, 3, CODE_LABEL)\n+#define LABEL_NUSES(RTX) XCINT (RTX, 3, CODE_LABEL)\n \n /* Associate a name with a CODE_LABEL.  */\n-#define LABEL_ALTERNATE_NAME(RTX) XCSTR(RTX, 7, CODE_LABEL)\n+#define LABEL_ALTERNATE_NAME(RTX) XCSTR (RTX, 7, CODE_LABEL)\n \n /* The original regno this ADDRESSOF was built for.  */\n-#define ADDRESSOF_REGNO(RTX) XCUINT(RTX, 1, ADDRESSOF)\n+#define ADDRESSOF_REGNO(RTX) XCUINT (RTX, 1, ADDRESSOF)\n \n /* The variable in the register we took the address of.  */\n-#define ADDRESSOF_DECL(RTX) XCTREE(RTX, 2, ADDRESSOF)\n+#define ADDRESSOF_DECL(RTX) XCTREE (RTX, 2, ADDRESSOF)\n \n /* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n    so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n    be decremented and possibly the label can be deleted.  */\n-#define JUMP_LABEL(INSN)   XCEXP(INSN, 7, JUMP_INSN)\n+#define JUMP_LABEL(INSN)   XCEXP (INSN, 7, JUMP_INSN)\n \n /* Once basic blocks are found in flow.c,\n    each CODE_LABEL starts a chain that goes through\n    all the LABEL_REFs that jump to that label.\n    The chain eventually winds up at the CODE_LABEL: it is circular.  */\n-#define LABEL_REFS(LABEL) XCEXP(LABEL, 4, CODE_LABEL)\n+#define LABEL_REFS(LABEL) XCEXP (LABEL, 4, CODE_LABEL)\n \f\n /* This is the field in the LABEL_REF through which the circular chain\n    of references to a particular label is linked.\n    This chain is set up in flow.c.  */\n \n-#define LABEL_NEXTREF(REF) XCEXP(REF, 1, LABEL_REF)\n+#define LABEL_NEXTREF(REF) XCEXP (REF, 1, LABEL_REF)\n \n /* Once basic blocks are found in flow.c,\n    Each LABEL_REF points to its containing instruction with this field.  */\n \n-#define CONTAINING_INSN(RTX) XCEXP(RTX, 2, LABEL_REF)\n+#define CONTAINING_INSN(RTX) XCEXP (RTX, 2, LABEL_REF)\n \n /* For a REG rtx, REGNO extracts the register number.  ORIGINAL_REGNO holds\n    the number the register originally had; for a pseudo register turned into\n    a hard reg this will hold the old pseudo register number.  */\n \n-#define REGNO(RTX) XCUINT(RTX, 0, REG)\n-#define ORIGINAL_REGNO(RTX) X0UINT(RTX, 1)\n+#define REGNO(RTX) XCUINT (RTX, 0, REG)\n+#define ORIGINAL_REGNO(RTX) X0UINT (RTX, 1)\n \n /* For a REG rtx, REG_FUNCTION_VALUE_P is nonzero if the reg\n    is the current function's return value.  */\n@@ -792,7 +798,7 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n #define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n \n /* 1 if the given register number REG_NO corresponds to a hard register.  */\n-#define HARD_REGISTER_NUM_P(REG_NO) (REG_NO < FIRST_PSEUDO_REGISTER)\n+#define HARD_REGISTER_NUM_P(REG_NO) ((REG_NO) < FIRST_PSEUDO_REGISTER)\n \n /* For a CONST_INT rtx, INTVAL extracts the integer.  */\n \n@@ -814,8 +820,8 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n    SUBREG_BYTE extracts the byte-number.  */\n \n-#define SUBREG_REG(RTX) XCEXP(RTX, 0, SUBREG)\n-#define SUBREG_BYTE(RTX) XCUINT(RTX, 1, SUBREG)\n+#define SUBREG_REG(RTX) XCEXP (RTX, 0, SUBREG)\n+#define SUBREG_BYTE(RTX) XCUINT (RTX, 1, SUBREG)\n \n /* in rtlanal.c */\n extern unsigned int subreg_lsb\t\tPARAMS ((rtx));\n@@ -838,21 +844,21 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n /* Access various components of an ASM_OPERANDS rtx.  */\n \n-#define ASM_OPERANDS_TEMPLATE(RTX) XCSTR ((RTX), 0, ASM_OPERANDS)\n-#define ASM_OPERANDS_OUTPUT_CONSTRAINT(RTX) XCSTR ((RTX), 1, ASM_OPERANDS)\n-#define ASM_OPERANDS_OUTPUT_IDX(RTX) XCINT ((RTX), 2, ASM_OPERANDS)\n-#define ASM_OPERANDS_INPUT_VEC(RTX) XCVEC ((RTX), 3, ASM_OPERANDS)\n-#define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XCVEC ((RTX), 4, ASM_OPERANDS)\n-#define ASM_OPERANDS_INPUT(RTX, N) XCVECEXP ((RTX), 3, (N), ASM_OPERANDS)\n-#define ASM_OPERANDS_INPUT_LENGTH(RTX) XCVECLEN ((RTX), 3, ASM_OPERANDS)\n+#define ASM_OPERANDS_TEMPLATE(RTX) XCSTR (RTX, 0, ASM_OPERANDS)\n+#define ASM_OPERANDS_OUTPUT_CONSTRAINT(RTX) XCSTR (RTX, 1, ASM_OPERANDS)\n+#define ASM_OPERANDS_OUTPUT_IDX(RTX) XCINT (RTX, 2, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT_VEC(RTX) XCVEC (RTX, 3, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XCVEC (RTX, 4, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT(RTX, N) XCVECEXP (RTX, 3, N, ASM_OPERANDS)\n+#define ASM_OPERANDS_INPUT_LENGTH(RTX) XCVECLEN (RTX, 3, ASM_OPERANDS)\n #define ASM_OPERANDS_INPUT_CONSTRAINT_EXP(RTX, N) \\\n-\t\t\tXCVECEXP ((RTX), 4, (N), ASM_OPERANDS)\n+  XCVECEXP (RTX, 4, N, ASM_OPERANDS)\n #define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) \\\n-\t\t\tXSTR (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS), 0)\n+  XSTR (XCVECEXP (RTX, 4, N, ASM_OPERANDS), 0)\n #define ASM_OPERANDS_INPUT_MODE(RTX, N)  \\\n-\t\t\tGET_MODE (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS))\n-#define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR ((RTX), 5, ASM_OPERANDS)\n-#define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT ((RTX), 6, ASM_OPERANDS)\n+  GET_MODE (XCVECEXP (RTX, 4, N, ASM_OPERANDS))\n+#define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR (RTX, 5, ASM_OPERANDS)\n+#define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT (RTX, 6, ASM_OPERANDS)\n \n /* For a MEM RTX, 1 if we should keep the alias set for this mem\n    unchanged when we access a component.  Set to 1, or example, when we\n@@ -876,7 +882,8 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n    RTX.  Otherwise, vice versa.  Use this macro only when you are\n    *sure* that you know that the MEM is in a structure, or is a\n    scalar.  VAL is evaluated only once.  */\n-#define MEM_SET_IN_STRUCT_P(RTX, VAL) do {\t\\\n+#define MEM_SET_IN_STRUCT_P(RTX, VAL)\t\t\\\n+do {\t\t\t\t\t\t\\\n   if (VAL)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       MEM_IN_STRUCT_P (RTX) = 1;\t\t\\\n@@ -970,14 +977,14 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n #define SET_IS_RETURN_P(RTX) ((RTX)->jump)\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n-#define TRAP_CONDITION(RTX) XCEXP(RTX, 0, TRAP_IF)\n-#define TRAP_CODE(RTX) XCEXP(RTX, 1, TRAP_IF)\n+#define TRAP_CONDITION(RTX) XCEXP (RTX, 0, TRAP_IF)\n+#define TRAP_CODE(RTX) XCEXP (RTX, 1, TRAP_IF)\n \n /* For a COND_EXEC rtx, COND_EXEC_TEST is the condition to base\n    conditionally executing the code on, COND_EXEC_CODE is the code\n    to execute if the condition is true.  */\n-#define COND_EXEC_TEST(RTX) XCEXP(RTX, 0, COND_EXEC)\n-#define COND_EXEC_CODE(RTX) XCEXP(RTX, 1, COND_EXEC)\n+#define COND_EXEC_TEST(RTX) XCEXP (RTX, 0, COND_EXEC)\n+#define COND_EXEC_CODE(RTX) XCEXP (RTX, 1, COND_EXEC)\n \n /* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n #define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n@@ -999,12 +1006,12 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n /* Don't continue this line--convex cc version 4.1 would lose.  */\n #if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n-#define FIND_REG_INC_NOTE(insn, reg)\t\t\t\t\\\n-  (reg != NULL_RTX && REG_P ((rtx) (reg))\t\t\t\\\n-   ? find_regno_note ((insn), REG_INC, REGNO ((rtx) (reg)))\t\\\n-   : find_reg_note ((insn), REG_INC, (reg)))\n+#define FIND_REG_INC_NOTE(INSN, REG)\t\t\t\\\n+  ((REG) != NULL_RTX && REG_P ((REG))\t\t\t\\\n+   ? find_regno_note ((INSN), REG_INC, REGNO (REG))\t\\\n+   : find_reg_note ((INSN), REG_INC, (REG)))\n #else\n-#define FIND_REG_INC_NOTE(insn, reg) 0\n+#define FIND_REG_INC_NOTE(INSN, REG) 0\n #endif\n \n /* Indicate whether the machine has any sort of auto increment addressing.\n@@ -1180,7 +1187,7 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n /* Determine if the insn is a PHI node.  */\n #define PHI_NODE_P(X)\t\t\t\t\\\n-  (X && GET_CODE (X) == INSN\t\t\t\\\n+  ((X) && GET_CODE (X) == INSN\t\t\t\\\n    && GET_CODE (PATTERN (X)) == SET\t\t\\\n    && GET_CODE (SET_SRC (PATTERN (X))) == PHI)\n \f\n@@ -1198,7 +1205,7 @@ extern int generating_concat_p;\n /* In expmed.c */\n extern int ceil_log2\t\t\tPARAMS ((unsigned HOST_WIDE_INT));\n \n-#define plus_constant(X,C) plus_constant_wide (X, (HOST_WIDE_INT) (C))\n+#define plus_constant(X, C) plus_constant_wide ((X), (HOST_WIDE_INT) (C))\n \n /* In builtins.c */\n extern rtx expand_builtin_expect_jump\tPARAMS ((tree, rtx, rtx));"}]}