{"sha": "5ee53a067403d9cccadb7f599652581c298088b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVlNTNhMDY3NDAzZDljY2NhZGI3ZjU5OTY1MjU4MWMyOTgwODhiMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-09-22T11:57:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-09-22T11:57:43Z"}, "message": "ipa-inline-transform.c (inline_call): Always update jump functions after inlining.\n\n\t* ipa-inline-transform.c (inline_call): Always update jump functions\n\tafter inlining.\n\t* ipa-inline.c (ipa_inline): Likewise; do not call\n\tipa_create_all_structures_for_iinln.\n\t(ipa_inline): Always free jump functions.\n\t* ipa-inline-analysis.c (evaluate_conditions_for_edge): Remove\n\thack.\n\t(remap_edge_predicates): Fix pasto.\n\t(inline_merge_summary): Remove nlined edge predicate; remove hack.\n\t(inline_analyze_function): Always initialize jump functions.\n\t(inline_generate_summary): Likewise.\n\t(inline_write_summary): Always write jump functions when ipa-cp\n\tis not doing that.\n\t(inline_read_summary): Always read jump functions when ipa-cp\n\tis not doing that.\n\t* ipa-prop.c (iinlining_processed_edges): Remove.\n\t(update_indirect_edges_after_inlining): Do not use\n\tiinlining_processed_edges; instead set param_index to -1.\n\t(propagate_info_to_inlined_callees): Only try to indirect inlining\n\twhen asked to do so; update jump functions of indirect calls, too;\n\tremove jump functions of the inlined edge.\n\t(ipa_edge_duplication_hook): Do not copy iinlining_processed_edges.\n\t(ipa_create_all_structures_for_iinln): Remove.\n\t(ipa_free_all_structures_after_iinln): Do not free\n\tiinlining_processed_edges.\n\t* ipa-prop.h (ipa_create_all_structures_for_iinln): Remove.\n\nFrom-SVN: r179083", "tree": {"sha": "b8f1b5b279159d592c4f9d9ddd21e222f26b5fd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f1b5b279159d592c4f9d9ddd21e222f26b5fd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ee53a067403d9cccadb7f599652581c298088b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee53a067403d9cccadb7f599652581c298088b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ee53a067403d9cccadb7f599652581c298088b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee53a067403d9cccadb7f599652581c298088b3/comments", "author": null, "committer": null, "parents": [{"sha": "aa0b3f8f8d4748aaaee4892ed0d5d85abb2e86f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0b3f8f8d4748aaaee4892ed0d5d85abb2e86f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa0b3f8f8d4748aaaee4892ed0d5d85abb2e86f6"}], "stats": {"total": 142, "additions": 78, "deletions": 64}, "files": [{"sha": "d5cd52f05de614fa5e26632c348d8cd66078c035", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ee53a067403d9cccadb7f599652581c298088b3", "patch": "@@ -1,3 +1,32 @@\n+2011-09-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-transform.c (inline_call): Always update jump functions\n+\tafter inlining.\n+\t* ipa-inline.c (ipa_inline): Likewise; do not call\n+\tipa_create_all_structures_for_iinln.\n+\t(ipa_inline): Always free jump functions.\n+\t* ipa-inline-analysis.c (evaluate_conditions_for_edge): Remove\n+\thack.\n+\t(remap_edge_predicates): Fix pasto.\n+\t(inline_merge_summary): Remove nlined edge predicate; remove hack.\n+\t(inline_analyze_function): Always initialize jump functions.\n+\t(inline_generate_summary): Likewise.\n+\t(inline_write_summary): Always write jump functions when ipa-cp\n+\tis not doing that.\n+\t(inline_read_summary): Always read jump functions when ipa-cp\n+\tis not doing that.\n+\t* ipa-prop.c (iinlining_processed_edges): Remove.\n+\t(update_indirect_edges_after_inlining): Do not use\n+\tiinlining_processed_edges; instead set param_index to -1.\n+\t(propagate_info_to_inlined_callees): Only try to indirect inlining\n+\twhen asked to do so; update jump functions of indirect calls, too;\n+\tremove jump functions of the inlined edge.\n+\t(ipa_edge_duplication_hook): Do not copy iinlining_processed_edges.\n+\t(ipa_create_all_structures_for_iinln): Remove.\n+\t(ipa_free_all_structures_after_iinln): Do not free\n+\tiinlining_processed_edges.\n+\t* ipa-prop.h (ipa_create_all_structures_for_iinln): Remove.\n+\n 2011-09-22  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/arm/predicates.md (expandable_comparison_operator): New"}, {"sha": "50474245a497f275a53bf4259e3bac3d1608560a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=5ee53a067403d9cccadb7f599652581c298088b3", "patch": "@@ -619,10 +619,7 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n   struct inline_summary *info = inline_summary (callee);\n   int i;\n \n-  if (ipa_node_params_vector && info->conds\n-      /* FIXME: it seems that we forget to get argument count in some cases,\n-\t probaby for previously indirect edges or so.  */\n-      && ipa_get_cs_argument_count (IPA_EDGE_REF (e)))\n+  if (ipa_node_params_vector && info->conds)\n     {\n       struct ipa_node_params *parms_info;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n@@ -634,7 +631,8 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n       else\n         parms_info = IPA_NODE_REF (e->caller);\n \n-      VEC_safe_grow_cleared (tree, heap, known_vals, count);\n+      if (count)\n+        VEC_safe_grow_cleared (tree, heap, known_vals, count);\n       for (i = 0; i < count; i++)\n \t{\n \t  tree cst = ipa_cst_from_jfunc (parms_info,\n@@ -2062,26 +2060,29 @@ remap_edge_predicates (struct cgraph_node *node,\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       struct predicate p;\n-      if (es->predicate)\n+      if (e->inline_failed)\n \t{\n-\t  p = remap_predicate (info, callee_info,\n-\t\t\t       es->predicate, operand_map, possible_truths,\n-\t\t\t       toplev_predicate);\n-\t  edge_set_predicate (e, &p);\n-\t  /* TODO: We should remove the edge for code that will be optimized out,\n-\t     but we need to keep verifiers and tree-inline happy.\n-\t     Make it cold for now.  */\n-\t  if (false_predicate_p (&p))\n+\t  if (es->predicate)\n \t    {\n-\t      e->count = 0;\n-\t      e->frequency = 0;\n+\t      p = remap_predicate (info, callee_info,\n+\t\t\t\t   es->predicate, operand_map, possible_truths,\n+\t\t\t\t   toplev_predicate);\n+\t      edge_set_predicate (e, &p);\n+\t      /* TODO: We should remove the edge for code that will be optimized out,\n+\t\t but we need to keep verifiers and tree-inline happy.\n+\t\t Make it cold for now.  */\n+\t      if (false_predicate_p (&p))\n+\t\t{\n+\t\t  e->count = 0;\n+\t\t  e->frequency = 0;\n+\t\t}\n \t    }\n+\t  else\n+\t    edge_set_predicate (e, toplev_predicate);\n \t}\n-      if (!e->inline_failed)\n+      else\n \tremap_edge_predicates (e->callee, info, callee_info, operand_map,\n \t\t\t       possible_truths, toplev_predicate);\n-      else\n-\tedge_set_predicate (e, toplev_predicate);\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n@@ -2122,25 +2123,23 @@ inline_merge_summary (struct cgraph_edge *edge)\n   VEC (int, heap) *operand_map = NULL;\n   int i;\n   struct predicate toplev_predicate;\n+  struct predicate true_p = true_predicate ();\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n   else\n     toplev_predicate = true_predicate ();\n \n-  if (ipa_node_params_vector && callee_info->conds\n-      /* FIXME: it seems that we forget to get argument count in some cases,\n-\t probaby for previously indirect edges or so.\n-\t Removing the test leads to ICE on tramp3d.  */\n-      && ipa_get_cs_argument_count (IPA_EDGE_REF (edge)))\n+  if (ipa_node_params_vector && callee_info->conds)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n       int count = ipa_get_cs_argument_count (args);\n       int i;\n \n       clause = evaluate_conditions_for_edge (edge, true);\n-      VEC_safe_grow_cleared (int, heap, operand_map, count);\n+      if (count)\n+        VEC_safe_grow_cleared (int, heap, operand_map, count);\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, i);\n@@ -2176,6 +2175,9 @@ inline_merge_summary (struct cgraph_edge *edge)\n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n \n+  /* We do not maintain predicates of inlined edges, free it.  */\n+  edge_set_predicate (edge, &true_p);\n+\n   info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n }\n@@ -2389,9 +2391,7 @@ inline_analyze_function (struct cgraph_node *node)\n   if (dump_file)\n     fprintf (dump_file, \"\\nAnalyzing function: %s/%u\\n\",\n \t     cgraph_node_name (node), node->uid);\n-  /* FIXME: We should remove the optimize check after we ensure we never run\n-     IPA passes when not optimizing.  */\n-  if (flag_indirect_inlining && optimize && !node->thunk.thunk_p)\n+  if (optimize && !node->thunk.thunk_p)\n     inline_indirect_intraprocedural_analysis (node);\n   compute_inline_parameters (node, false);\n \n@@ -2419,8 +2419,7 @@ inline_generate_summary (void)\n   function_insertion_hook_holder =\n       cgraph_add_function_insertion_hook (&add_new_function, NULL);\n \n-  if (flag_indirect_inlining)\n-    ipa_register_cgraph_hooks ();\n+  ipa_register_cgraph_hooks ();\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->alias)\n@@ -2572,7 +2571,7 @@ inline_read_summary (void)\n \t   this should never happen.  */\n \tfatal_error (\"ipa inline summary is missing in input file\");\n     }\n-  if (flag_indirect_inlining)\n+  if (optimize)\n     {\n       ipa_register_cgraph_hooks ();\n       if (!flag_ipa_cp)\n@@ -2676,7 +2675,7 @@ inline_write_summary (cgraph_node_set set,\n   produce_asm (ob, NULL);\n   destroy_output_block (ob);\n \n-  if (flag_indirect_inlining && !flag_ipa_cp)\n+  if (optimize && !flag_ipa_cp)\n     ipa_prop_write_jump_functions (set);\n }\n "}, {"sha": "2609e4257056c624b46ead0abe20bab7d3362731", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=5ee53a067403d9cccadb7f599652581c298088b3", "patch": "@@ -248,7 +248,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;\n \n-  if (flag_indirect_inlining && optimize)\n+  if (optimize)\n     return ipa_propagate_indirect_call_infos (curr, new_edges);\n   else\n     return false;"}, {"sha": "f069914cf647055f69f45fca8a5da521cc87be84", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=5ee53a067403d9cccadb7f599652581c298088b3", "patch": "@@ -1659,10 +1659,8 @@ ipa_inline (void)\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int i;\n \n-  if (in_lto_p && flag_indirect_inlining)\n+  if (in_lto_p && optimize)\n     ipa_update_after_lto_read ();\n-  if (flag_indirect_inlining)\n-    ipa_create_all_structures_for_iinln ();\n \n   if (dump_file)\n     dump_inline_summaries (dump_file);\n@@ -1757,7 +1755,7 @@ ipa_inline (void)\n     }\n \n   /* Free ipa-prop structures if they are no longer needed.  */\n-  if (flag_indirect_inlining)\n+  if (optimize)\n     ipa_free_all_structures_after_iinln ();\n \n   if (dump_file)"}, {"sha": "52f583a7871418579fe298204049f550bb8db6eb", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5ee53a067403d9cccadb7f599652581c298088b3", "patch": "@@ -56,10 +56,6 @@ VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n /* Vector where the parameter infos are actually stored. */\n VEC (ipa_edge_args_t, gc) *ipa_edge_args_vector;\n \n-/* Bitmap with all UIDs of call graph edges that have been already processed\n-   by indirect inlining.  */\n-static bitmap iinlining_processed_edges;\n-\n /* Holders of ipa cgraph hooks: */\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n@@ -1699,18 +1695,14 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n       struct ipa_jump_func *jfunc;\n \n       next_ie = ie->next_callee;\n-      if (bitmap_bit_p (iinlining_processed_edges, ie->uid))\n-\tcontinue;\n \n-      /* If we ever use indirect edges for anything other than indirect\n-\t inlining, we will need to skip those with negative param_indices. */\n       if (ici->param_index == -1)\n \tcontinue;\n \n       /* We must check range due to calls with variable number of arguments:  */\n       if (ici->param_index >= ipa_get_cs_argument_count (top))\n \t{\n-\t  bitmap_set_bit (iinlining_processed_edges, ie->uid);\n+\t  ici->param_index = -1;\n \t  continue;\n \t}\n \n@@ -1725,7 +1717,10 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t}\n       else\n \t/* Either we can find a destination for this edge now or never. */\n-\tbitmap_set_bit (iinlining_processed_edges, ie->uid);\n+\tici->param_index = -1;\n+\n+      if (!flag_indirect_inlining)\n+\tcontinue;\n \n       if (ici->polymorphic)\n \tnew_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc);\n@@ -1771,6 +1766,8 @@ propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n       res |= propagate_info_to_inlined_callees (cs, e->callee, new_edges);\n     else\n       update_jump_functions_after_inlining (cs, e);\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    update_jump_functions_after_inlining (cs, e);\n \n   return res;\n }\n@@ -1785,13 +1782,19 @@ bool\n ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t   VEC (cgraph_edge_p, heap) **new_edges)\n {\n+  bool changed;\n   /* Do nothing if the preparation phase has not been carried out yet\n      (i.e. during early inlining).  */\n   if (!ipa_node_params_vector)\n     return false;\n   gcc_assert (ipa_edge_args_vector);\n \n-  return propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n+  changed = propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n+\n+  /* We do not keep jump functions of inlined edges up to date. Better to free\n+     them so we do not access them accidentally.  */\n+  ipa_free_edge_args_substructures (IPA_EDGE_REF (cs));\n+  return changed;\n }\n \n /* Frees all dynamically allocated structures that the argument info points\n@@ -1889,10 +1892,6 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \n   new_args->jump_functions = VEC_copy (ipa_jump_func_t, gc,\n \t\t\t\t       old_args->jump_functions);\n-\n-  if (iinlining_processed_edges\n-      && bitmap_bit_p (iinlining_processed_edges, src->uid))\n-    bitmap_set_bit (iinlining_processed_edges, dst->uid);\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n@@ -1963,21 +1962,13 @@ ipa_unregister_cgraph_hooks (void)\n   function_insertion_hook_holder = NULL;\n }\n \n-/* Allocate all necessary data structures necessary for indirect inlining.  */\n-\n-void\n-ipa_create_all_structures_for_iinln (void)\n-{\n-  iinlining_processed_edges = BITMAP_ALLOC (NULL);\n-}\n-\n /* Free all ipa_node_params and all ipa_edge_args structures if they are no\n    longer needed after ipa-cp.  */\n \n void\n ipa_free_all_structures_after_ipa_cp (void)\n {\n-  if (!flag_indirect_inlining)\n+  if (!optimize)\n     {\n       ipa_free_all_edge_args ();\n       ipa_free_all_node_params ();\n@@ -1993,8 +1984,6 @@ ipa_free_all_structures_after_ipa_cp (void)\n void\n ipa_free_all_structures_after_iinln (void)\n {\n-  BITMAP_FREE (iinlining_processed_edges);\n-\n   ipa_free_all_edge_args ();\n   ipa_free_all_node_params ();\n   ipa_unregister_cgraph_hooks ();"}, {"sha": "1b7ba69f270f8645d693140fb9311be2564d94d5", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee53a067403d9cccadb7f599652581c298088b3/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=5ee53a067403d9cccadb7f599652581c298088b3", "patch": "@@ -282,7 +282,6 @@ void ipa_free_edge_args_substructures (struct ipa_edge_args *);\n void ipa_free_node_params_substructures (struct ipa_node_params *);\n void ipa_free_all_node_params (void);\n void ipa_free_all_edge_args (void);\n-void ipa_create_all_structures_for_iinln (void);\n void ipa_free_all_structures_after_ipa_cp (void);\n void ipa_free_all_structures_after_iinln (void);\n void ipa_register_cgraph_hooks (void);"}]}