{"sha": "7035307e8f5291aa613c07f49f899444b9e65c80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAzNTMwN2U4ZjUyOTFhYTYxM2MwN2Y0OWY4OTk0NDRiOWU2NWM4MA==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-04-14T22:43:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-04-14T22:43:47Z"}, "message": "Sync to current external repository.\n\nuser:        Ian Lance Taylor <iant@golang.org>\ndate:        Thu Apr 10 09:25:24 2014 -0700\nfiles:       go/expressions.cc\ndescription:\ncompiler: add checks for constant overflow\n\nPrevent extremely large constants from eating all of memory.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Apr 07 16:57:09 2014 -0700\nfiles:       go/gogo-tree.cc go/gogo.cc go/gogo.h go/statements.cc\ndescription:\ncompiler: Use backend interface for variable initialization.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Thu Apr 03 19:56:05 2014 -0700\nfiles:       go/backend.h go/gogo-tree.cc go/gogo.cc go/gogo.h\ndescription:\ncompiler: Use backend interface to build function code.\n\n\nchangeset:   1269:6e30875d539e\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Wed Apr 02 13:16:00 2014 -0700\nfiles:       go/backend.h go/gogo-tree.cc go/gogo.cc go/gogo.h\ndescription:\ncompiler: Use backend interface for building function defer wrappers.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Mar 31 12:42:49 2014 -0700\nfiles:       go/expressions.cc go/gogo-tree.cc go/gogo.cc go/gogo.h\ndescription:\ncompiler: Use backend interface for memory allocation.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Thu Mar 27 14:22:49 2014 -0700\nfiles:       go/backend.h go/expressions.cc go/expressions.h\ndescription:\ncompiler: Use backend interface for fixed array construction.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Mar 17 21:25:04 2014 -0700\nfiles:       go/expressions.cc\ndescription:\ncompiler: Check for loops in self-referential array types. Fixes issue 7525.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Mar 17 14:31:59 2014 -0700\nfiles:       go/gogo.cc go/parse.cc\ndescription:\ncompiler: Don't declare blank labels. Fixes issue 7539.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Mar 17 13:12:32 2014 -0700\nfiles:       go/backend.h go/expressions.cc go/expressions.h go/runtime.def\ndescription:\ncompiler: Use backend interface for call expressions.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Wed Mar 12 13:34:27 2014 -0700\nfiles:       go/expressions.cc go/expressions.h go/gogo-tree.cc go/statements.cc\ndescription:\ncompiler: Use backend interface map construction.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Tue Mar 11 12:53:06 2014 -0700\nfiles:       go/backend.h go/expressions.cc go/gogo-tree.cc go/gogo.h\ndescription:\ncompiler: Use backend interface for string expressions.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Sat Mar 08 15:56:59 2014 -0800\nfiles:       go/backend.h go/expressions.cc go/expressions.h\ndescription:\ncompiler: Use backend interface for array and string indexing.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Fri Mar 07 16:02:18 2014 -0800\nfiles:       go/expressions.cc\ndescription:\ncompiler: Use backend interface for constant expressions.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Thu Mar 06 16:00:18 2014 -0800\nfiles:       go/expressions.cc\ndescription:\ncompiler: Use backend interface for struct construction.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Wed Mar 05 13:09:37 2014 -0800\nfiles:       go/expressions.cc\ndescription:\ncompiler: Use backend interface for type conversions.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Tue Mar 04 07:03:47 2014 -0800\nfiles:       go/expressions.cc go/expressions.h go/gogo-tree.cc go/gogo.h go/runtime.def libgo/runtime/chan.c\ndescription:\ncompiler: Use backend interface for channel receive.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Mar 03 15:18:57 2014 -0800\nfiles:       go/backend.h go/expressions.cc go/runtime.def\ndescription:\ncompiler: Use backend interface for builtin calls.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Mar 03 07:44:35 2014 -0800\nfiles:       go/expressions.cc go/expressions.h go/types.cc go/types.h\ndescription:\ncompiler: Use backend interface for string info.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Fri Feb 28 10:45:55 2014 -0800\nfiles:       go/expressions.cc go/expressions.h go/gogo-tree.cc go/statements.cc\ndescription:\ncompiler: Use backend interface for map indexing.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Wed Feb 26 14:13:10 2014 -0800\nfiles:       go/expressions.cc go/expressions.h\ndescription:\ncompiler: Use backend interface for slice value expressions.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Wed Feb 26 13:12:19 2014 -0800\nfiles:       go/backend.h go/expressions.cc go/expressions.h go/gogo-tree.cc go/runtime.def go/statements.cc\ndescription:\ncompiler: Use backend interface for interface values.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Feb 24 12:30:13 2014 -0800\nfiles:       go/expressions.cc go/expressions.h go/parse.cc go/statements.cc\ndescription:\ncompiler: Change Heap_composite_expression to Heap_expression.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Thu Feb 20 19:47:06 2014 -0800\nfiles:       go/expressions.cc go/expressions.h go/gogo-tree.cc go/gogo.cc go/gogo.h go/types.cc go/types.h\ndescription:\ncompiler: Use backend interface for interface method table expressions.\n\n\nuser:        Chris Manghane <cmang@golang.org>\ndate:        Mon Feb 03 14:36:20 2014 -0800\nfiles:       go/expressions.cc go/expressions.h\ndescription:\ncompiler: Add compound expressions to the frontend.\n\n\n\t* go-gcc.cc: Include \"convert.h\".\n\t(Gcc_backend::string_constant_expression): New function.\n\t(Gcc_backend::real_part_expression): Likewise.\n\t(Gcc_backend::imag_part_expression): Likewise.\n\t(Gcc_backend::complex_expression): Likewise.\n\t(Gcc_backend::constructor_expression): Likewise.\n\t(Gcc_backend::array_constructor_expression): Likewise.\n\t(Gcc_backend::pointer_offset_expression): Likewise.\n\t(Gcc_backend::array_index_expression): Likewise.\n\t(Gcc_backend::call_expression): Likewise.\n\t(Gcc_backend::exception_handler_statement): Likewise.\n\t(Gcc_backend::function_defer_statement): Likewise.\n\t(Gcc_backend::function_set_parameters): Likewise.\n\t(Gcc_backend::function_set_body): Likewise.\n\t(Gcc_backend::convert_expression): Handle various type\n\tconversions.\n\nFrom-SVN: r209393", "tree": {"sha": "b131f3f58afbe5406406926c7d499bebab24fdf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b131f3f58afbe5406406926c7d499bebab24fdf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7035307e8f5291aa613c07f49f899444b9e65c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7035307e8f5291aa613c07f49f899444b9e65c80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7035307e8f5291aa613c07f49f899444b9e65c80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7035307e8f5291aa613c07f49f899444b9e65c80/comments", "author": null, "committer": null, "parents": [{"sha": "88f592e3f4117e5da3da84f9bd2b1da8c4bc9a99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f592e3f4117e5da3da84f9bd2b1da8c4bc9a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f592e3f4117e5da3da84f9bd2b1da8c4bc9a99"}], "stats": {"total": 5890, "additions": 2997, "deletions": 2893}, "files": [{"sha": "0d153fa02e66cc375730196942bb58bdfa0ee391", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -1,3 +1,22 @@\n+2014-04-14  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc: Include \"convert.h\".\n+\t(Gcc_backend::string_constant_expression): New function.\n+\t(Gcc_backend::real_part_expression): Likewise.\n+\t(Gcc_backend::imag_part_expression): Likewise.\n+\t(Gcc_backend::complex_expression): Likewise.\n+\t(Gcc_backend::constructor_expression): Likewise.\n+\t(Gcc_backend::array_constructor_expression): Likewise.\n+\t(Gcc_backend::pointer_offset_expression): Likewise.\n+\t(Gcc_backend::array_index_expression): Likewise.\n+\t(Gcc_backend::call_expression): Likewise.\n+\t(Gcc_backend::exception_handler_statement): Likewise.\n+\t(Gcc_backend::function_defer_statement): Likewise.\n+\t(Gcc_backend::function_set_parameters): Likewise.\n+\t(Gcc_backend::function_set_body): Likewise.\n+\t(Gcc_backend::convert_expression): Handle various type\n+\tconversions.\n+\n 2014-03-03  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::immutable_struct): If IS_COMMON, set"}, {"sha": "3abefaee9e667a54d9b350dc94dca733a061d64d", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 443, "deletions": 4, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -29,6 +29,7 @@\n #include \"stor-layout.h\"\n #include \"varasm.h\"\n #include \"tree-iterator.h\"\n+#include \"convert.h\"\n #include \"basic-block.h\"\n #include \"gimple-expr.h\"\n #include \"toplev.h\"\n@@ -234,6 +235,18 @@ class Gcc_backend : public Backend\n   Bexpression*\n   complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag);\n \n+  Bexpression*\n+  string_constant_expression(const std::string& val);\n+\n+  Bexpression*\n+  real_part_expression(Bexpression* bcomplex, Location);\n+\n+  Bexpression*\n+  imag_part_expression(Bexpression* bcomplex, Location);\n+\n+  Bexpression*\n+  complex_expression(Bexpression* breal, Bexpression* bimag, Location);\n+\n   Bexpression*\n   convert_expression(Btype* type, Bexpression* expr, Location);\n \n@@ -259,6 +272,23 @@ class Gcc_backend : public Backend\n   Bexpression*\n   binary_expression(Operator, Bexpression*, Bexpression*, Location);\n \n+  Bexpression*\n+  constructor_expression(Btype*, const std::vector<Bexpression*>&, Location);\n+\n+  Bexpression*\n+  array_constructor_expression(Btype*, const std::vector<unsigned long>&,\n+                               const std::vector<Bexpression*>&, Location);\n+\n+  Bexpression*\n+  pointer_offset_expression(Bexpression* base, Bexpression* offset, Location);\n+\n+  Bexpression*\n+  array_index_expression(Bexpression* array, Bexpression* index, Location);\n+\n+  Bexpression*\n+  call_expression(Bexpression* fn, const std::vector<Bexpression*>& args,\n+                  Location);\n+\n   // Statements.\n \n   Bstatement*\n@@ -294,6 +324,10 @@ class Gcc_backend : public Backend\n   Bstatement*\n   statement_list(const std::vector<Bstatement*>&);\n \n+  Bstatement*\n+  exception_handler_statement(Bstatement* bstat, Bstatement* except_stmt,\n+                              Bstatement* finally_stmt, Location);\n+\n   // Blocks.\n \n   Bblock*\n@@ -372,6 +406,16 @@ class Gcc_backend : public Backend\n            bool is_visible, bool is_declaration, bool is_inlinable,\n            bool disable_split_stack, bool in_unique_section, Location);\n \n+  Bstatement*\n+  function_defer_statement(Bfunction* function, Bexpression* undefer,\n+                           Bexpression* defer, Location);\n+\n+  bool\n+  function_set_parameters(Bfunction* function, const std::vector<Bvariable*>&);\n+\n+  bool\n+  function_set_body(Bfunction* function, Bstatement* code_stmt);\n+\n  private:\n   // Make a Bexpression from a tree.\n   Bexpression*\n@@ -974,18 +1018,108 @@ Gcc_backend::complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag)\n   return tree_to_expr(ret);\n }\n \n+// Make a constant string expression.\n+\n+Bexpression*\n+Gcc_backend::string_constant_expression(const std::string& val)\n+{\n+  tree index_type = build_index_type(size_int(val.length()));\n+  tree const_char_type = build_qualified_type(unsigned_char_type_node,\n+\t\t\t\t\t      TYPE_QUAL_CONST);\n+  tree string_type = build_array_type(const_char_type, index_type);\n+  string_type = build_variant_type_copy(string_type);\n+  TYPE_STRING_FLAG(string_type) = 1;\n+  tree string_val = build_string(val.length(), val.data());\n+  TREE_TYPE(string_val) = string_type;\n+\n+  return this->make_expression(string_val);\n+}\n+\n+// Return the real part of a complex expression.\n+\n+Bexpression*\n+Gcc_backend::real_part_expression(Bexpression* bcomplex, Location location)\n+{\n+  tree complex_tree = bcomplex->get_tree();\n+  if (complex_tree == error_mark_node)\n+    return this->error_expression();\n+  gcc_assert(COMPLEX_FLOAT_TYPE_P(TREE_TYPE(complex_tree)));\n+  tree ret = fold_build1_loc(location.gcc_location(), REALPART_EXPR,\n+                             TREE_TYPE(TREE_TYPE(complex_tree)),\n+                             complex_tree);\n+  return this->make_expression(ret);\n+}\n+\n+// Return the imaginary part of a complex expression.\n+\n+Bexpression*\n+Gcc_backend::imag_part_expression(Bexpression* bcomplex, Location location)\n+{\n+  tree complex_tree = bcomplex->get_tree();\n+  if (complex_tree == error_mark_node)\n+    return this->error_expression();\n+  gcc_assert(COMPLEX_FLOAT_TYPE_P(TREE_TYPE(complex_tree)));\n+  tree ret = fold_build1_loc(location.gcc_location(), IMAGPART_EXPR,\n+                             TREE_TYPE(TREE_TYPE(complex_tree)),\n+                             complex_tree);\n+  return this->make_expression(ret);\n+}\n+\n+// Make a complex expression given its real and imaginary parts.\n+\n+Bexpression*\n+Gcc_backend::complex_expression(Bexpression* breal, Bexpression* bimag,\n+                                Location location)\n+{\n+  tree real_tree = breal->get_tree();\n+  tree imag_tree = bimag->get_tree();\n+  if (real_tree == error_mark_node || imag_tree == error_mark_node)\n+    return this->error_expression();\n+  gcc_assert(TYPE_MAIN_VARIANT(TREE_TYPE(real_tree))\n+            == TYPE_MAIN_VARIANT(TREE_TYPE(imag_tree)));\n+  gcc_assert(SCALAR_FLOAT_TYPE_P(TREE_TYPE(real_tree)));\n+  tree ret = fold_build2_loc(location.gcc_location(), COMPLEX_EXPR,\n+                             build_complex_type(TREE_TYPE(real_tree)),\n+                             real_tree, imag_tree);\n+  return this->make_expression(ret);\n+}\n+\n // An expression that converts an expression to a different type.\n \n Bexpression*\n-Gcc_backend::convert_expression(Btype* type, Bexpression* expr, Location)\n+Gcc_backend::convert_expression(Btype* type, Bexpression* expr,\n+\t\t\t\tLocation location)\n {\n   tree type_tree = type->get_tree();\n   tree expr_tree = expr->get_tree();\n-  if (type_tree == error_mark_node || expr_tree == error_mark_node)\n+  if (type_tree == error_mark_node\n+      || expr_tree == error_mark_node\n+      || TREE_TYPE(expr_tree) == error_mark_node)\n     return this->error_expression();\n \n-  tree ret = fold_convert(type_tree, expr_tree);\n-  return tree_to_expr(ret);\n+  tree ret;\n+  if (this->type_size(type) == 0)\n+    {\n+      // Do not convert zero-sized types.\n+      ret = expr_tree;\n+    }\n+  else if (TREE_CODE(type_tree) == INTEGER_TYPE)\n+    ret = fold(convert_to_integer(type_tree, expr_tree));\n+  else if (TREE_CODE(type_tree) == REAL_TYPE)\n+    ret = fold(convert_to_real(type_tree, expr_tree));\n+  else if (TREE_CODE(type_tree) == COMPLEX_TYPE)\n+    ret = fold(convert_to_complex(type_tree, expr_tree));\n+  else if (TREE_CODE(type_tree) == POINTER_TYPE\n+           && TREE_CODE(TREE_TYPE(expr_tree)) == INTEGER_TYPE)\n+    ret = fold(convert_to_pointer(type_tree, expr_tree));\n+  else if (TREE_CODE(type_tree) == RECORD_TYPE\n+           || TREE_CODE(type_tree) == ARRAY_TYPE)\n+    ret = fold_build1_loc(location.gcc_location(), VIEW_CONVERT_EXPR,\n+                          type_tree, expr_tree);\n+  else\n+    ret = fold_convert_loc(location.gcc_location(), type_tree, expr_tree);\n+\n+  return this->make_expression(ret);\n }\n \n // Get the address of a function.\n@@ -1243,6 +1377,205 @@ Gcc_backend::binary_expression(Operator op, Bexpression* left,\n   return this->make_expression(ret);\n }\n \n+// Return an expression that constructs BTYPE with VALS.\n+\n+Bexpression*\n+Gcc_backend::constructor_expression(Btype* btype,\n+                                    const std::vector<Bexpression*>& vals,\n+                                    Location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_expression();\n+\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc(init, vals.size());\n+\n+  bool is_constant = true;\n+  tree field = TYPE_FIELDS(type_tree);\n+  for (std::vector<Bexpression*>::const_iterator p = vals.begin();\n+       p != vals.end();\n+       ++p, field = DECL_CHAIN(field))\n+    {\n+      gcc_assert(field != NULL_TREE);\n+      tree val = (*p)->get_tree();\n+      if (TREE_TYPE(field) == error_mark_node\n+          || val == error_mark_node\n+          || TREE_TYPE(val) == error_mark_node)\n+        return this->error_expression();\n+\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt* elt = init->quick_push(empty);\n+      elt->index = field;\n+      elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n+                                    val);\n+      if (!TREE_CONSTANT(elt->value))\n+\tis_constant = false;\n+    }\n+  gcc_assert(field == NULL_TREE);\n+  tree ret = build_constructor(type_tree, init);\n+  if (is_constant)\n+    TREE_CONSTANT(ret) = 1;\n+\n+  return this->make_expression(ret);\n+}\n+\n+Bexpression*\n+Gcc_backend::array_constructor_expression(\n+    Btype* array_btype, const std::vector<unsigned long>& indexes,\n+    const std::vector<Bexpression*>& vals, Location)\n+{\n+  tree type_tree = array_btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_expression();\n+\n+  gcc_assert(indexes.size() == vals.size());\n+  vec<constructor_elt, va_gc> *init;\n+  vec_alloc(init, vals.size());\n+\n+  bool is_constant = true;\n+  for (size_t i = 0; i < vals.size(); ++i)\n+    {\n+      tree index = size_int(indexes[i]);\n+      tree val = (vals[i])->get_tree();\n+\n+      if (index == error_mark_node\n+          || val == error_mark_node)\n+        return this->error_expression();\n+\n+      if (!TREE_CONSTANT(val))\n+        is_constant = false;\n+\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt* elt = init->quick_push(empty);\n+      elt->index = index;\n+      elt->value = val;\n+    }\n+\n+  tree ret = build_constructor(type_tree, init);\n+  if (is_constant)\n+    TREE_CONSTANT(ret) = 1;\n+  return this->make_expression(ret);\n+}\n+\n+// Return an expression for the address of BASE[INDEX].\n+\n+Bexpression*\n+Gcc_backend::pointer_offset_expression(Bexpression* base, Bexpression* index,\n+                                       Location location)\n+{\n+  tree base_tree = base->get_tree();\n+  tree index_tree = index->get_tree();\n+  tree element_type_tree = TREE_TYPE(TREE_TYPE(base_tree));\n+  if (base_tree == error_mark_node\n+      || TREE_TYPE(base_tree) == error_mark_node\n+      || index_tree == error_mark_node\n+      || element_type_tree == error_mark_node)\n+    return this->error_expression();\n+\n+  tree element_size = TYPE_SIZE_UNIT(element_type_tree);\n+  index_tree = fold_convert_loc(location.gcc_location(), sizetype, index_tree);\n+  tree offset = fold_build2_loc(location.gcc_location(), MULT_EXPR, sizetype,\n+                                index_tree, element_size);\n+  tree ptr = fold_build2_loc(location.gcc_location(), POINTER_PLUS_EXPR,\n+                             TREE_TYPE(base_tree), base_tree, offset);\n+  return this->make_expression(ptr);\n+}\n+\n+// Return an expression representing ARRAY[INDEX]\n+\n+Bexpression*\n+Gcc_backend::array_index_expression(Bexpression* array, Bexpression* index,\n+                                    Location location)\n+{\n+  tree array_tree = array->get_tree();\n+  tree index_tree = index->get_tree();\n+  if (array_tree == error_mark_node\n+      || TREE_TYPE(array_tree) == error_mark_node\n+      || index_tree == error_mark_node)\n+    return this->error_expression();\n+\n+  tree ret = build4_loc(location.gcc_location(), ARRAY_REF,\n+\t\t\tTREE_TYPE(TREE_TYPE(array_tree)), array_tree,\n+                        index_tree, NULL_TREE, NULL_TREE);\n+  return this->make_expression(ret);\n+}\n+\n+// Create an expression for a call to FN_EXPR with FN_ARGS.\n+Bexpression*\n+Gcc_backend::call_expression(Bexpression* fn_expr,\n+                             const std::vector<Bexpression*>& fn_args,\n+                             Location location)\n+{\n+  tree fn = fn_expr->get_tree();\n+  if (fn == error_mark_node || TREE_TYPE(fn) == error_mark_node)\n+    return this->error_expression();\n+\n+  gcc_assert(FUNCTION_POINTER_TYPE_P(TREE_TYPE(fn)));\n+  tree rettype = TREE_TYPE(TREE_TYPE(TREE_TYPE(fn)));\n+\n+  size_t nargs = fn_args.size();\n+  tree* args = nargs == 0 ? NULL : new tree[nargs];\n+  for (size_t i = 0; i < nargs; ++i)\n+    {\n+      args[i] = fn_args.at(i)->get_tree();\n+      if (args[i] == error_mark_node)\n+        return this->error_expression();\n+    }\n+\n+  tree fndecl = fn;\n+  if (TREE_CODE(fndecl) == ADDR_EXPR)\n+    fndecl = TREE_OPERAND(fndecl, 0);\n+\n+  // This is to support builtin math functions when using 80387 math.\n+  tree excess_type = NULL_TREE;\n+  if (optimize\n+      && TREE_CODE(fndecl) == FUNCTION_DECL\n+      && DECL_IS_BUILTIN(fndecl)\n+      && DECL_BUILT_IN_CLASS(fndecl) == BUILT_IN_NORMAL\n+      && nargs > 0\n+      && ((SCALAR_FLOAT_TYPE_P(rettype)\n+\t   && SCALAR_FLOAT_TYPE_P(TREE_TYPE(args[0])))\n+\t  || (COMPLEX_FLOAT_TYPE_P(rettype)\n+\t      && COMPLEX_FLOAT_TYPE_P(TREE_TYPE(args[0])))))\n+    {\n+      excess_type = excess_precision_type(TREE_TYPE(args[0]));\n+      if (excess_type != NULL_TREE)\n+\t{\n+\t  tree excess_fndecl = mathfn_built_in(excess_type,\n+\t\t\t\t\t       DECL_FUNCTION_CODE(fndecl));\n+\t  if (excess_fndecl == NULL_TREE)\n+\t    excess_type = NULL_TREE;\n+\t  else\n+\t    {\n+\t      fn = build_fold_addr_expr_loc(location.gcc_location(),\n+                                            excess_fndecl);\n+\t      for (size_t i = 0; i < nargs; ++i)\n+\t\t{\n+\t\t  if (SCALAR_FLOAT_TYPE_P(TREE_TYPE(args[i]))\n+\t\t      || COMPLEX_FLOAT_TYPE_P(TREE_TYPE(args[i])))\n+\t\t    args[i] = ::convert(excess_type, args[i]);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  tree ret =\n+      build_call_array_loc(location.gcc_location(),\n+                           excess_type != NULL_TREE ? excess_type : rettype,\n+                           fn, nargs, args);\n+\n+  if (excess_type != NULL_TREE)\n+    {\n+      // Calling convert here can undo our excess precision change.\n+      // That may or may not be a bug in convert_to_real.\n+      ret = build1_loc(location.gcc_location(), NOP_EXPR, rettype, ret);\n+    }\n+\n+  delete[] args;\n+  return this->make_expression(ret);\n+}\n+\n // An expression as a statement.\n \n Bstatement*\n@@ -1402,6 +1735,40 @@ Gcc_backend::return_statement(Bfunction* bfunction,\n   return this->make_statement(ret);\n }\n \n+// Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if an\n+// error occurs.  EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and if not\n+// NULL, it will always be executed.  This is used for handling defers in Go\n+// functions.  In C++, the resulting code is of this form:\n+//   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n+\n+Bstatement*\n+Gcc_backend::exception_handler_statement(Bstatement* bstat,\n+                                         Bstatement* except_stmt,\n+                                         Bstatement* finally_stmt,\n+                                         Location location)\n+{\n+  tree stat_tree = bstat->get_tree();\n+  tree except_tree = except_stmt == NULL ? NULL_TREE : except_stmt->get_tree();\n+  tree finally_tree = finally_stmt == NULL\n+      ? NULL_TREE\n+      : finally_stmt->get_tree();\n+\n+  if (stat_tree == error_mark_node\n+      || except_tree == error_mark_node\n+      || finally_tree == error_mark_node)\n+    return this->error_statement();\n+\n+  if (except_tree != NULL_TREE)\n+    stat_tree = build2_loc(location.gcc_location(), TRY_CATCH_EXPR,\n+                           void_type_node, stat_tree,\n+                           build2_loc(location.gcc_location(), CATCH_EXPR,\n+                                      void_type_node, NULL, except_tree));\n+  if (finally_tree != NULL_TREE)\n+    stat_tree = build2_loc(location.gcc_location(), TRY_FINALLY_EXPR,\n+                           void_type_node, stat_tree, finally_tree);\n+  return this->make_statement(stat_tree);\n+}\n+\n // If.\n \n Bstatement*\n@@ -2070,6 +2437,78 @@ Gcc_backend::function(Btype* fntype, const std::string& name,\n   return new Bfunction(decl);\n }\n \n+// Create a statement that runs all deferred calls for FUNCTION.  This should\n+// be a statement that looks like this in C++:\n+//   finish:\n+//     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n+\n+Bstatement*\n+Gcc_backend::function_defer_statement(Bfunction* function, Bexpression* undefer,\n+                                      Bexpression* defer, Location location)\n+{\n+  tree undefer_tree = undefer->get_tree();\n+  tree defer_tree = defer->get_tree();\n+\n+  if (undefer_tree == error_mark_node\n+      || defer_tree == error_mark_node)\n+    return this->error_statement();\n+\n+  tree stmt_list = NULL;\n+  Blabel* blabel = this->label(function, \"\", location);\n+  Bstatement* label_def = this->label_definition_statement(blabel);\n+  append_to_statement_list(label_def->get_tree(), &stmt_list);\n+\n+  Bstatement* jump_stmt = this->goto_statement(blabel, location);\n+  tree jump = jump_stmt->get_tree();\n+  tree catch_body = build2(COMPOUND_EXPR, void_type_node, defer_tree, jump);\n+  catch_body = build2(CATCH_EXPR, void_type_node, NULL, catch_body);\n+  tree try_catch =\n+      build2(TRY_CATCH_EXPR, void_type_node, undefer_tree, catch_body);\n+  append_to_statement_list(try_catch, &stmt_list);\n+\n+  return this->make_statement(stmt_list);\n+}\n+\n+// Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n+// This will only be called for a function definition.\n+\n+bool\n+Gcc_backend::function_set_parameters(Bfunction* function,\n+                                     const std::vector<Bvariable*>& param_vars)\n+{\n+  tree func_tree = function->get_tree();\n+  if (func_tree == error_mark_node)\n+    return false;\n+\n+  tree params = NULL_TREE;\n+  tree *pp = &params;\n+  for (std::vector<Bvariable*>::const_iterator pv = param_vars.begin();\n+       pv != param_vars.end();\n+       ++pv)\n+    {\n+      *pp = (*pv)->get_tree();\n+      gcc_assert(*pp != error_mark_node);\n+      pp = &DECL_CHAIN(*pp);\n+    }\n+  *pp = NULL_TREE;\n+  DECL_ARGUMENTS(func_tree) = params;\n+  return true;\n+}\n+\n+// Set the function body for FUNCTION using the code in CODE_BLOCK.\n+\n+bool\n+Gcc_backend::function_set_body(Bfunction* function, Bstatement* code_stmt)\n+{\n+  tree func_tree = function->get_tree();\n+  tree code = code_stmt->get_tree();\n+\n+  if (func_tree == error_mark_node || code == error_mark_node)\n+    return false;\n+  DECL_SAVED_TREE(func_tree) = code;\n+  return true;\n+}\n+\n // The single backend.\n \n static Gcc_backend gcc_backend;"}, {"sha": "fd657ecc989f90329ba7cb3e79be4e9d5d6e10ae", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -269,6 +269,22 @@ class Backend\n   virtual Bexpression*\n   complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag) = 0;\n \n+  // Return an expression for the string value VAL.\n+  virtual Bexpression*\n+  string_constant_expression(const std::string& val) = 0;\n+\n+  // Return an expression for the real part of BCOMPLEX.\n+  virtual Bexpression*\n+  real_part_expression(Bexpression* bcomplex, Location) = 0;\n+\n+  // Return an expression for the imaginary part of BCOMPLEX.\n+  virtual Bexpression*\n+  imag_part_expression(Bexpression* bcomplex, Location) = 0;\n+\n+  // Return an expression for the complex number (BREAL, BIMAG).\n+  virtual Bexpression*\n+  complex_expression(Bexpression* breal, Bexpression* bimag, Location) = 0;\n+\n   // Return an expression that converts EXPR to TYPE.\n   virtual Bexpression*\n   convert_expression(Btype* type, Bexpression* expr, Location) = 0;\n@@ -312,6 +328,38 @@ class Backend\n   binary_expression(Operator op, Bexpression* left, Bexpression* right,\n                     Location) = 0;\n \n+  // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n+  // backend representation a of struct.  VALS must be in the same order as the\n+  // corresponding fields in BTYPE.\n+  virtual Bexpression*\n+  constructor_expression(Btype* btype, const std::vector<Bexpression*>& vals,\n+                         Location) = 0;\n+\n+  // Return an expression that constructs an array of BTYPE with INDEXES and\n+  // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n+  // in INDEXES must be in the same order as the corresponding value in VALS.\n+  virtual Bexpression*\n+  array_constructor_expression(Btype* btype,\n+                               const std::vector<unsigned long>& indexes,\n+                               const std::vector<Bexpression*>& vals,\n+                               Location) = 0;\n+\n+  // Return an expression for the address of BASE[INDEX].\n+  // BASE has a pointer type.  This is used for slice indexing.\n+  virtual Bexpression*\n+  pointer_offset_expression(Bexpression* base, Bexpression* index,\n+                            Location) = 0;\n+\n+  // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n+  // fixed-length array, not a slice.\n+  virtual Bexpression*\n+  array_index_expression(Bexpression* array, Bexpression* index, Location) = 0;\n+\n+  // Create an expression for a call to FN with ARGS.\n+  virtual Bexpression*\n+  call_expression(Bexpression* fn, const std::vector<Bexpression*>& args,\n+                  Location) = 0;\n+\n   // Statements.\n \n   // Create an error statement.  This is used for cases which should\n@@ -367,6 +415,15 @@ class Backend\n   virtual Bstatement*\n   statement_list(const std::vector<Bstatement*>&) = 0;\n \n+  // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n+  // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n+  // if not NULL, it will always be executed.  This is used for handling defers\n+  // in Go functions.  In C++, the resulting code is of this form:\n+  //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n+  virtual Bstatement*\n+  exception_handler_statement(Bstatement* bstat, Bstatement* except_stmt,\n+                              Bstatement* finally_stmt, Location) = 0;\n+\n   // Blocks.\n \n   // Create a block.  The frontend will call this function when it\n@@ -570,6 +627,26 @@ class Backend\n   function(Btype* fntype, const std::string& name, const std::string& asm_name,\n            bool is_visible, bool is_declaration, bool is_inlinable,\n            bool disable_split_stack, bool in_unique_section, Location) = 0;\n+\n+  // Create a statement that runs all deferred calls for FUNCTION.  This should\n+  // be a statement that looks like this in C++:\n+  //   finish:\n+  //     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n+  virtual Bstatement*\n+  function_defer_statement(Bfunction* function, Bexpression* undefer,\n+                           Bexpression* check_defer, Location) = 0;\n+\n+  // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n+  // This will only be called for a function definition.  Returns true on\n+  // success, false on failure.\n+  virtual bool\n+  function_set_parameters(Bfunction* function,\n+                         const std::vector<Bvariable*>& param_vars) = 0;\n+\n+  // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n+  // true on success, false on failure.\n+  virtual bool\n+  function_set_body(Bfunction* function, Bstatement* code_stmt) = 0;\n };\n \n // The backend interface has to define this function."}, {"sha": "bd2e3183bfe9aa01c4886ce897ca94157fbc5038", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1872, "deletions": 1792, "changes": 3664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=7035307e8f5291aa613c07f49f899444b9e65c80"}, {"sha": "dc9ad71c8205c21ea9b0391f67a18b89402342a0", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 96, "deletions": 43, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -74,6 +74,7 @@ class Expression\n     EXPRESSION_UNKNOWN_REFERENCE,\n     EXPRESSION_BOOLEAN,\n     EXPRESSION_STRING,\n+    EXPRESSION_STRING_INFO,\n     EXPRESSION_INTEGER,\n     EXPRESSION_FLOAT,\n     EXPRESSION_COMPLEX,\n@@ -95,19 +96,23 @@ class Expression\n     EXPRESSION_UNSAFE_CONVERSION,\n     EXPRESSION_STRUCT_CONSTRUCTION,\n     EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n-    EXPRESSION_OPEN_ARRAY_CONSTRUCTION,\n+    EXPRESSION_SLICE_CONSTRUCTION,\n     EXPRESSION_MAP_CONSTRUCTION,\n     EXPRESSION_COMPOSITE_LITERAL,\n-    EXPRESSION_HEAP_COMPOSITE,\n+    EXPRESSION_HEAP,\n     EXPRESSION_RECEIVE,\n     EXPRESSION_TYPE_DESCRIPTOR,\n     EXPRESSION_TYPE_INFO,\n     EXPRESSION_SLICE_INFO,\n+    EXPRESSION_SLICE_VALUE,\n     EXPRESSION_INTERFACE_INFO,\n+    EXPRESSION_INTERFACE_VALUE,\n+    EXPRESSION_INTERFACE_MTABLE,\n     EXPRESSION_STRUCT_FIELD_OFFSET,\n     EXPRESSION_MAP_DESCRIPTOR,\n     EXPRESSION_LABEL_ADDR,\n-    EXPRESSION_CONDITIONAL\n+    EXPRESSION_CONDITIONAL,\n+    EXPRESSION_COMPOUND\n   };\n \n   Expression(Expression_classification, Location);\n@@ -188,6 +193,20 @@ class Expression\n   static Expression*\n   make_string(const std::string&, Location);\n \n+  // Make an expression that evaluates to some characteristic of an string.\n+  // For simplicity, the enum values must match the field indexes in the\n+  // underlying struct.\n+  enum String_info\n+    {\n+      // The underlying data in the string.\n+      STRING_INFO_DATA,\n+      // The length of the string.\n+      STRING_INFO_LENGTH\n+    };\n+\n+  static Expression*\n+  make_string_info(Expression* string, String_info, Location);\n+\n   // Make a character constant expression.  TYPE should be NULL for an\n   // abstract type.\n   static Expression*\n@@ -312,9 +331,9 @@ class Expression\n   static Expression*\n   make_slice_composite_literal(Type*, Expression_list*, Location);\n \n-  // Take a composite literal and allocate it on the heap.\n+  // Take an expression and allocate it on the heap.\n   static Expression*\n-  make_heap_composite(Expression*, Location);\n+  make_heap_expression(Expression*, Location);\n \n   // Make a receive expression.  VAL is NULL for a unary receive.\n   static Receive_expression*\n@@ -358,21 +377,38 @@ class Expression\n   static Expression*\n   make_slice_info(Expression* slice, Slice_info, Location);\n \n+  // Make an expression for a slice value.\n+  static Expression*\n+  make_slice_value(Type*, Expression* valptr, Expression* len, Expression* cap,\n+                   Location);\n \n-  // Make an expression that evaluates to some characteristic of a\n+  // Make an expression that evaluates to some characteristic of an\n   // interface.  For simplicity, the enum values must match the field indexes\n-  // of a non-empty interface in the underlying struct.\n+  // in the underlying struct.\n   enum Interface_info\n     {\n+      // The type descriptor of an empty interface.\n+      INTERFACE_INFO_TYPE_DESCRIPTOR = 0,\n       // The methods of an interface.\n-      INTERFACE_INFO_METHODS,\n+      INTERFACE_INFO_METHODS = 0,\n       // The first argument to pass to an interface method.\n       INTERFACE_INFO_OBJECT\n     };\n \n   static Expression*\n   make_interface_info(Expression* iface, Interface_info, Location);\n \n+  // Make an expression for an interface value.\n+  static Expression*\n+  make_interface_value(Type*, Expression*, Expression*, Location);\n+\n+  // Make an expression that builds a reference to the interface method table\n+  // for TYPE that satisfies interface ITYPE. IS_POINTER is true if this is a\n+  // reference to the interface method table for the pointer receiver type.\n+  static Expression*\n+  make_interface_mtable_ref(Interface_type* itype, Type* type,\n+                            bool is_pointer, Location);\n+\n   // Make an expression which evaluates to the offset of a field in a\n   // struct.  This is only used for type descriptors, so there is no\n   // location parameter.\n@@ -393,6 +429,10 @@ class Expression\n   static Expression*\n   make_conditional(Expression*, Expression*, Expression*, Location);\n \n+  // Make a compound expression.\n+  static Expression*\n+  make_compound(Expression*, Expression*, Location);\n+\n   // Return the expression classification.\n   Expression_classification\n   classification() const\n@@ -700,19 +740,19 @@ class Expression\n   tree\n   get_tree(Translate_context*);\n \n-  // Return a tree handling any conversions which must be done during\n+  // Return an expression handling any conversions which must be done during\n   // assignment.\n-  static tree\n-  convert_for_assignment(Translate_context*, Type* lhs_type, Type* rhs_type,\n-\t\t\t tree rhs_tree, Location location);\n+  static Expression*\n+  convert_for_assignment(Gogo*, Type* lhs_type, Expression* rhs,\n+                         Location location);\n \n-  // Return a tree converting a value of one interface type to another\n+  // Return an expression converting a value of one interface type to another\n   // interface type.  If FOR_TYPE_GUARD is true this is for a type\n   // assertion.\n-  static tree\n-  convert_interface_to_interface(Translate_context*, Type* lhs_type,\n-\t\t\t\t Type* rhs_type, tree rhs_tree,\n-\t\t\t\t bool for_type_guard, Location);\n+  static Expression*\n+  convert_interface_to_interface(Type* lhs_type,\n+                                 Expression* rhs, bool for_type_guard,\n+                                 Location);\n \n   // Return a backend expression implementing the comparison LEFT OP RIGHT.\n   // TYPE is the type of both sides.\n@@ -736,12 +776,10 @@ class Expression\n   static Expression*\n   import_expression(Import*);\n \n-  // Return a tree which checks that VAL, of arbitrary integer type,\n-  // is non-negative and is not more than the maximum value of\n-  // BOUND_TYPE.  If SOFAR is not NULL, it is or'red into the result.\n-  // The return value may be NULL if SOFAR is NULL.\n-  static tree\n-  check_bounds(tree val, tree bound_type, tree sofar, Location);\n+  // Return an expression which checks that VAL, of arbitrary integer type,\n+  // is non-negative and is not more than the maximum integer value.\n+  static Expression*\n+  check_bounds(Expression* val, Location);\n \n   // Dump an expression to a dump constext.\n   void\n@@ -881,17 +919,14 @@ class Expression\n \t    : NULL);\n   }\n \n-  static tree\n-  convert_type_to_interface(Translate_context*, Type*, Type*, tree,\n-\t\t\t    Location);\n+  static Expression*\n+  convert_type_to_interface(Type*, Expression*, Location);\n \n-  static tree\n-  get_interface_type_descriptor(Translate_context*, Type*, tree,\n-\t\t\t\tLocation);\n+  static Expression*\n+  get_interface_type_descriptor(Expression*);\n \n-  static tree\n-  convert_interface_to_type(Translate_context*, Type*, Type*, tree,\n-\t\t\t    Location);\n+  static Expression*\n+  convert_interface_to_type(Type*, Expression*, Location);\n \n   // The expression classification.\n   Expression_classification classification_;\n@@ -1408,8 +1443,8 @@ class Call_expression : public Expression\n   Call_expression(Expression* fn, Expression_list* args, bool is_varargs,\n \t\t  Location location)\n     : Expression(EXPRESSION_CALL, location),\n-      fn_(fn), args_(args), type_(NULL), results_(NULL), tree_(NULL),\n-      is_varargs_(is_varargs), are_hidden_fields_ok_(false),\n+      fn_(fn), args_(args), type_(NULL), results_(NULL), call_(NULL),\n+      call_temp_(NULL), is_varargs_(is_varargs), are_hidden_fields_ok_(false),\n       varargs_are_lowered_(false), types_are_determined_(false),\n       is_deferred_(false), issued_error_(false)\n   { }\n@@ -1489,6 +1524,9 @@ class Call_expression : public Expression\n   virtual Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n+  virtual Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   bool\n   do_discarding_value()\n   { return true; }\n@@ -1550,8 +1588,8 @@ class Call_expression : public Expression\n   interface_method_function(Interface_field_reference_expression*,\n \t\t\t    Expression**);\n \n-  tree\n-  set_results(Translate_context*, tree);\n+  Bexpression*\n+  set_results(Translate_context*, Bexpression*);\n \n   // The function to call.\n   Expression* fn_;\n@@ -1563,8 +1601,10 @@ class Call_expression : public Expression\n   // The list of temporaries which will hold the results if the\n   // function returns a tuple.\n   std::vector<Temporary_statement*>* results_;\n-  // The tree for the call, used for a call which returns a tuple.\n-  tree tree_;\n+  // The backend expression for the call, used for a call which returns a tuple.\n+  Bexpression* call_;\n+  // A temporary variable to store this call if the function returns a tuple.\n+  Temporary_statement* call_temp_;\n   // True if the last argument is a varargs argument (f(a...)).\n   bool is_varargs_;\n   // True if this statement may pass hidden fields in the arguments.\n@@ -1838,7 +1878,7 @@ class Map_index_expression : public Expression\n \t\t       Location location)\n     : Expression(EXPRESSION_MAP_INDEX, location),\n       map_(map), index_(index), is_lvalue_(false),\n-      is_in_tuple_assignment_(false)\n+      is_in_tuple_assignment_(false), value_pointer_(NULL)\n   { }\n \n   // Return the map.\n@@ -1881,18 +1921,21 @@ class Map_index_expression : public Expression\n   set_is_in_tuple_assignment()\n   { this->is_in_tuple_assignment_ = true; }\n \n-  // Return a tree for the map index.  This returns a tree which\n+  // Return an expression for the map index.  This returns an expression which\n   // evaluates to a pointer to a value in the map.  If INSERT is true,\n   // the key will be inserted if not present, and the value pointer\n   // will be zero initialized.  If INSERT is false, and the key is not\n   // present in the map, the pointer will be NULL.\n-  tree\n-  get_value_pointer(Translate_context*, bool insert);\n+  Expression*\n+  get_value_pointer(bool insert);\n \n  protected:\n   int\n   do_traverse(Traverse*);\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   Type*\n   do_type();\n \n@@ -1934,6 +1977,8 @@ class Map_index_expression : public Expression\n   bool is_lvalue_;\n   // Whether this is in a tuple assignment to a pair of values.\n   bool is_in_tuple_assignment_;\n+  // A pointer to the value at this index.\n+  Expression* value_pointer_;\n };\n \n // An expression which represents a method bound to its first\n@@ -2230,6 +2275,9 @@ class Type_guard_expression : public Expression\n   int\n   do_traverse(Traverse* traverse);\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   Type*\n   do_type()\n   { return this->type_; }\n@@ -2268,7 +2316,7 @@ class Receive_expression : public Expression\n  public:\n   Receive_expression(Expression* channel, Location location)\n     : Expression(EXPRESSION_RECEIVE, location),\n-      channel_(channel)\n+      channel_(channel), temp_receiver_(NULL)\n   { }\n \n   // Return the channel.\n@@ -2288,6 +2336,9 @@ class Receive_expression : public Expression\n   Type*\n   do_type();\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   void\n   do_determine_type(const Type_context*)\n   { this->channel_->determine_type_no_context(); }\n@@ -2314,6 +2365,8 @@ class Receive_expression : public Expression\n  private:\n   // The channel from which we are receiving.\n   Expression* channel_;\n+  // A temporary reference to the variable storing the received data.\n+  Temporary_statement* temp_receiver_;\n };\n \n // A numeric constant.  This is used both for untyped constants and"}, {"sha": "e92acae7af45021cafcdae60db2c850c39612cfb", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 37, "deletions": 887, "changes": 924, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -636,10 +636,10 @@ class Var_init\n {\n  public:\n   Var_init()\n-    : var_(NULL), init_(NULL_TREE)\n+    : var_(NULL), init_(NULL)\n   { }\n \n-  Var_init(Named_object* var, tree init)\n+  Var_init(Named_object* var, Bstatement* init)\n     : var_(var), init_(init)\n   { }\n \n@@ -649,15 +649,15 @@ class Var_init\n   { return this->var_; }\n \n   // Return the initialization expression.\n-  tree\n+  Bstatement*\n   init() const\n   { return this->init_; }\n \n  private:\n   // The variable being initialized.\n   Named_object* var_;\n-  // The initialization expression to run.\n-  tree init_;\n+  // The initialization statement.\n+  Bstatement* init_;\n };\n \n typedef std::list<Var_init> Var_inits;\n@@ -868,15 +868,13 @@ Gogo::write_globals()\n \t  // initializer purely for its side effects.\n \t  bool is_sink = no->name()[0] == '_' && no->name()[1] == '.';\n \n-\t  tree var_init_tree = NULL_TREE;\n+          Bstatement* var_init_stmt = NULL;\n \t  if (!no->var_value()->has_pre_init())\n \t    {\n-\t      tree init = no->var_value()->get_init_tree(this, NULL);\n-\t      if (init == error_mark_node)\n-\t\tgo_assert(saw_errors());\n-\t      else if (init == NULL_TREE)\n+              Bexpression* var_binit = no->var_value()->get_init(this, NULL);\n+              if (var_binit == NULL)\n \t\t;\n-\t      else if (TREE_CONSTANT(init))\n+\t      else if (TREE_CONSTANT(expr_to_tree(var_binit)))\n \t\t{\n \t\t  if (expression_requires(no->var_value()->init(), NULL,\n \t\t\t\t\t  this->var_depends_on(no->var_value()),\n@@ -885,17 +883,20 @@ Gogo::write_globals()\n \t\t\t     \"initialization expression for %qs depends \"\n \t\t\t     \"upon itself\",\n \t\t\t     no->message_name().c_str());\n-\t\t  this->backend()->global_variable_set_init(var,\n-\t\t\t\t\t\t\t    tree_to_expr(init));\n+\t\t  this->backend()->global_variable_set_init(var, var_binit);\n \t\t}\n-\t      else if (is_sink\n-\t\t       || int_size_in_bytes(TREE_TYPE(init)) == 0\n-\t\t       || int_size_in_bytes(TREE_TYPE(vec[i])) == 0)\n-\t\tvar_init_tree = init;\n+\t      else if (is_sink)\n+\t\tvar_init_stmt =\n+                    this->backend()->expression_statement(var_binit);\n \t      else\n-\t\tvar_init_tree = fold_build2_loc(no->location().gcc_location(),\n-                                                MODIFY_EXPR, void_type_node,\n-                                                vec[i], init);\n+                {\n+                  Location loc = no->var_value()->location();\n+                  Bexpression* var_expr =\n+                      this->backend()->var_expression(var, loc);\n+                  var_init_stmt =\n+                      this->backend()->assignment_statement(var_expr, var_binit,\n+                                                            loc);\n+                }\n \t    }\n \t  else\n \t    {\n@@ -907,27 +908,34 @@ Gogo::write_globals()\n \t\tpush_struct_function(init_fndecl);\n \t      else\n \t\tpush_cfun(DECL_STRUCT_FUNCTION(init_fndecl));\n-\t      tree var_decl = is_sink ? NULL_TREE : vec[i];\n-\t      var_init_tree = no->var_value()->get_init_block(this, NULL,\n-\t\t\t\t\t\t\t      var_decl);\n+\t      Bvariable* var_decl = is_sink ? NULL : var;\n+              var_init_stmt =\n+                  no->var_value()->get_init_block(this, NULL, var_decl);\n+\n \t      pop_cfun();\n \t    }\n \n-\t  if (var_init_tree != NULL_TREE && var_init_tree != error_mark_node)\n+\t  if (var_init_stmt != NULL)\n \t    {\n \t      if (no->var_value()->init() == NULL\n \t\t  && !no->var_value()->has_pre_init())\n-\t\tappend_to_statement_list(var_init_tree, &var_init_stmt_list);\n+\t\tappend_to_statement_list(stat_to_tree(var_init_stmt),\n+                                         &var_init_stmt_list);\n \t      else\n-\t\tvar_inits.push_back(Var_init(no, var_init_tree));\n+\t\tvar_inits.push_back(Var_init(no, var_init_stmt));\n \t    }\n \t  else if (this->var_depends_on(no->var_value()) != NULL)\n \t    {\n \t      // This variable is initialized from something that is\n \t      // not in its init or preinit.  This variable needs to\n \t      // participate in dependency analysis sorting, in case\n \t      // some other variable depends on this one.\n-\t      var_inits.push_back(Var_init(no, integer_zero_node));\n+              Btype* int_btype =\n+                  Type::lookup_integer_type(\"int\")->get_backend(this);\n+              Bexpression* zero = this->backend()->zero_expression(int_btype);\n+              Bstatement* zero_stmt =\n+                  this->backend()->expression_statement(zero);\n+\t      var_inits.push_back(Var_init(no, zero_stmt));\n \t    }\n \n \t  if (!is_sink && no->var_value()->type()->has_pointer())\n@@ -950,7 +958,7 @@ Gogo::write_globals()\n       for (Var_inits::const_iterator p = var_inits.begin();\n \t   p != var_inits.end();\n \t   ++p)\n-\tappend_to_statement_list(p->init(), &init_stmt_list);\n+\tappend_to_statement_list(stat_to_tree(p->init()), &init_stmt_list);\n     }\n \n   // After all the variables are initialized, call the \"init\"\n@@ -1106,7 +1114,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t\tcfun->function_end_locus =\n                   func->block()->end_location().gcc_location();\n \n-\t\tfunc->build_tree(gogo, this);\n+\t\tfunc->build(gogo, this);\n \n \t\tgimplify_function_tree(decl);\n \n@@ -1139,84 +1147,6 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n   return ret;\n }\n \n-// Get the initial value of a variable as a tree.  This does not\n-// consider whether the variable is in the heap--it returns the\n-// initial value as though it were always stored in the stack.\n-\n-tree\n-Variable::get_init_tree(Gogo* gogo, Named_object* function)\n-{\n-  go_assert(this->preinit_ == NULL);\n-  if (this->init_ == NULL)\n-    {\n-      go_assert(!this->is_parameter_);\n-      if (this->is_global_ || this->is_in_heap())\n-\treturn NULL;\n-      Btype* btype = this->type_->get_backend(gogo);\n-      return expr_to_tree(gogo->backend()->zero_expression(btype));\n-    }\n-  else\n-    {\n-      Translate_context context(gogo, function, NULL, NULL);\n-      tree rhs_tree = this->init_->get_tree(&context);\n-      return Expression::convert_for_assignment(&context, this->type(),\n-\t\t\t\t\t\tthis->init_->type(),\n-\t\t\t\t\t\trhs_tree, this->location());\n-    }\n-}\n-\n-// Get the initial value of a variable when a block is required.\n-// VAR_DECL is the decl to set; it may be NULL for a sink variable.\n-\n-tree\n-Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n-{\n-  go_assert(this->preinit_ != NULL);\n-\n-  // We want to add the variable assignment to the end of the preinit\n-  // block.  The preinit block may have a TRY_FINALLY_EXPR and a\n-  // TRY_CATCH_EXPR; if it does, we want to add to the end of the\n-  // regular statements.\n-\n-  Translate_context context(gogo, function, NULL, NULL);\n-  Bblock* bblock = this->preinit_->get_backend(&context);\n-  tree block_tree = block_to_tree(bblock);\n-  if (block_tree == error_mark_node)\n-    return error_mark_node;\n-  go_assert(TREE_CODE(block_tree) == BIND_EXPR);\n-  tree statements = BIND_EXPR_BODY(block_tree);\n-  while (statements != NULL_TREE\n-\t && (TREE_CODE(statements) == TRY_FINALLY_EXPR\n-\t     || TREE_CODE(statements) == TRY_CATCH_EXPR))\n-    statements = TREE_OPERAND(statements, 0);\n-\n-  // It's possible to have pre-init statements without an initializer\n-  // if the pre-init statements set the variable.\n-  if (this->init_ != NULL)\n-    {\n-      tree rhs_tree = this->init_->get_tree(&context);\n-      if (rhs_tree == error_mark_node)\n-\treturn error_mark_node;\n-      if (var_decl == NULL_TREE)\n-\tappend_to_statement_list(rhs_tree, &statements);\n-      else\n-\t{\n-\t  tree val = Expression::convert_for_assignment(&context, this->type(),\n-\t\t\t\t\t\t\tthis->init_->type(),\n-\t\t\t\t\t\t\trhs_tree,\n-\t\t\t\t\t\t\tthis->location());\n-\t  if (val == error_mark_node)\n-\t    return error_mark_node;\n-\t  tree set = fold_build2_loc(this->location().gcc_location(),\n-                                     MODIFY_EXPR, void_type_node, var_decl,\n-                                     val);\n-\t  append_to_statement_list(set, &statements);\n-\t}\n-    }\n-\n-  return block_tree;\n-}\n-\n // Get the backend representation.\n \n Bfunction*\n@@ -1272,469 +1202,6 @@ Function::get_decl() const\n   return function_to_tree(this->fndecl_);\n }\n \n-// We always pass the receiver to a method as a pointer.  If the\n-// receiver is actually declared as a non-pointer type, then we copy\n-// the value into a local variable, so that it has the right type.  In\n-// this function we create the real PARM_DECL to use, and set\n-// DEC_INITIAL of the var_decl to be the value passed in.\n-\n-tree\n-Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n-{\n-  if (var_decl == error_mark_node)\n-    return error_mark_node;\n-  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n-  tree val_type = TREE_TYPE(var_decl);\n-  bool is_in_heap = no->var_value()->is_in_heap();\n-  if (is_in_heap)\n-    {\n-      go_assert(POINTER_TYPE_P(val_type));\n-      val_type = TREE_TYPE(val_type);\n-    }\n-\n-  source_location loc = DECL_SOURCE_LOCATION(var_decl);\n-  std::string name = IDENTIFIER_POINTER(DECL_NAME(var_decl));\n-  name += \".pointer\";\n-  tree id = get_identifier_from_string(name);\n-  tree parm_decl = build_decl(loc, PARM_DECL, id, build_pointer_type(val_type));\n-  DECL_CONTEXT(parm_decl) = current_function_decl;\n-  DECL_ARG_TYPE(parm_decl) = TREE_TYPE(parm_decl);\n-\n-  go_assert(DECL_INITIAL(var_decl) == NULL_TREE);\n-  tree init = build_fold_indirect_ref_loc(loc, parm_decl);\n-\n-  if (is_in_heap)\n-    {\n-      tree size = TYPE_SIZE_UNIT(val_type);\n-      tree space = gogo->allocate_memory(no->var_value()->type(), size,\n-\t\t\t\t\t no->location());\n-      space = save_expr(space);\n-      space = fold_convert(build_pointer_type(val_type), space);\n-      tree spaceref = build_fold_indirect_ref_loc(no->location().gcc_location(),\n-                                                  space);\n-      TREE_THIS_NOTRAP(spaceref) = 1;\n-      tree set = fold_build2_loc(loc, MODIFY_EXPR, void_type_node,\n-\t\t\t\t spaceref, init);\n-      init = fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(space), set, space);\n-    }\n-\n-  DECL_INITIAL(var_decl) = init;\n-\n-  return parm_decl;\n-}\n-\n-// If we take the address of a parameter, then we need to copy it into\n-// the heap.  We will access it as a local variable via an\n-// indirection.\n-\n-tree\n-Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree var_decl)\n-{\n-  if (var_decl == error_mark_node)\n-    return error_mark_node;\n-  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n-  Location loc(DECL_SOURCE_LOCATION(var_decl));\n-\n-  std::string name = IDENTIFIER_POINTER(DECL_NAME(var_decl));\n-  name += \".param\";\n-  tree id = get_identifier_from_string(name);\n-\n-  tree type = TREE_TYPE(var_decl);\n-  go_assert(POINTER_TYPE_P(type));\n-  type = TREE_TYPE(type);\n-\n-  tree parm_decl = build_decl(loc.gcc_location(), PARM_DECL, id, type);\n-  DECL_CONTEXT(parm_decl) = current_function_decl;\n-  DECL_ARG_TYPE(parm_decl) = type;\n-\n-  tree size = TYPE_SIZE_UNIT(type);\n-  tree space = gogo->allocate_memory(no->var_value()->type(), size, loc);\n-  space = save_expr(space);\n-  space = fold_convert(TREE_TYPE(var_decl), space);\n-  tree spaceref = build_fold_indirect_ref_loc(loc.gcc_location(), space);\n-  TREE_THIS_NOTRAP(spaceref) = 1;\n-  tree init = build2(COMPOUND_EXPR, TREE_TYPE(space),\n-\t\t     build2(MODIFY_EXPR, void_type_node, spaceref, parm_decl),\n-\t\t     space);\n-  DECL_INITIAL(var_decl) = init;\n-\n-  return parm_decl;\n-}\n-\n-// Get a tree for function code.\n-\n-void\n-Function::build_tree(Gogo* gogo, Named_object* named_function)\n-{\n-  tree fndecl = this->get_decl();\n-  go_assert(fndecl != NULL_TREE);\n-\n-  tree params = NULL_TREE;\n-  tree* pp = &params;\n-\n-  tree declare_vars = NULL_TREE;\n-  for (Bindings::const_definitions_iterator p =\n-\t this->block_->bindings()->begin_definitions();\n-       p != this->block_->bindings()->end_definitions();\n-       ++p)\n-    {\n-      if ((*p)->is_variable() && (*p)->var_value()->is_parameter())\n-\t{\n-\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n-\t  *pp = var_to_tree(bvar);\n-\n-\t  // We always pass the receiver to a method as a pointer.  If\n-\t  // the receiver is declared as a non-pointer type, then we\n-\t  // copy the value into a local variable.\n-\t  if ((*p)->var_value()->is_receiver()\n-\t      && (*p)->var_value()->type()->points_to() == NULL)\n-\t    {\n-\t      tree parm_decl = this->make_receiver_parm_decl(gogo, *p, *pp);\n-\t      tree var = *pp;\n-\t      if (var != error_mark_node)\n-\t\t{\n-\t\t  go_assert(TREE_CODE(var) == VAR_DECL);\n-\t\t  DECL_CHAIN(var) = declare_vars;\n-\t\t  declare_vars = var;\n-\t\t}\n-\t      *pp = parm_decl;\n-\t    }\n-\t  else if ((*p)->var_value()->is_in_heap())\n-\t    {\n-\t      // If we take the address of a parameter, then we need\n-\t      // to copy it into the heap.\n-\t      tree parm_decl = this->copy_parm_to_heap(gogo, *p, *pp);\n-\t      tree var = *pp;\n-\t      if (var != error_mark_node)\n-\t\t{\n-\t\t  go_assert(TREE_CODE(var) == VAR_DECL);\n-\t\t  DECL_CHAIN(var) = declare_vars;\n-\t\t  declare_vars = var;\n-\t\t}\n-\t      *pp = parm_decl;\n-\t    }\n-\n-\t  if (*pp != error_mark_node)\n-\t    {\n-\t      go_assert(TREE_CODE(*pp) == PARM_DECL);\n-\t      pp = &DECL_CHAIN(*pp);\n-\t    }\n-\t}\n-      else if ((*p)->is_result_variable())\n-\t{\n-\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n-\t  tree var_decl = var_to_tree(bvar);\n-\n-\t  Type* type = (*p)->result_var_value()->type();\n-\t  tree init;\n-\t  if (!(*p)->result_var_value()->is_in_heap())\n-\t    {\n-\t      Btype* btype = type->get_backend(gogo);\n-\t      init = expr_to_tree(gogo->backend()->zero_expression(btype));\n-\t    }\n-\t  else\n-\t    {\n-\t      Location loc = (*p)->location();\n-\t      tree type_tree = type_to_tree(type->get_backend(gogo));\n-\t      tree space = gogo->allocate_memory(type,\n-\t\t\t\t\t\t TYPE_SIZE_UNIT(type_tree),\n-\t\t\t\t\t\t loc);\n-\t      tree ptr_type_tree = build_pointer_type(type_tree);\n-\t      init = fold_convert_loc(loc.gcc_location(), ptr_type_tree, space);\n-\t    }\n-\n-\t  if (var_decl != error_mark_node)\n-\t    {\n-\t      go_assert(TREE_CODE(var_decl) == VAR_DECL);\n-\t      DECL_INITIAL(var_decl) = init;\n-\t      DECL_CHAIN(var_decl) = declare_vars;\n-\t      declare_vars = var_decl;\n-\t    }\n-\t}\n-    }\n-\n-  *pp = NULL_TREE;\n-\n-  DECL_ARGUMENTS(fndecl) = params;\n-\n-  // If we need a closure variable, fetch it by calling a runtime\n-  // function.  The caller will have called __go_set_closure before\n-  // the function call.\n-  if (this->closure_var_ != NULL)\n-    {\n-      Bvariable* bvar =\n-\tthis->closure_var_->get_backend_variable(gogo, named_function);\n-      tree var_decl = var_to_tree(bvar);\n-      if (var_decl != error_mark_node)\n-\t{\n-\t  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n-\t  static tree get_closure_fndecl;\n-\t  tree get_closure = Gogo::call_builtin(&get_closure_fndecl,\n-\t\t\t\t\t\tthis->location_,\n-\t\t\t\t\t\t\"__go_get_closure\",\n-\t\t\t\t\t\t0,\n-\t\t\t\t\t\tptr_type_node);\n-\n-\t  // Mark the __go_get_closure function as pure, since it\n-\t  // depends only on the global variable g.\n-\t  DECL_PURE_P(get_closure_fndecl) = 1;\n-\n-\t  get_closure = fold_convert_loc(this->location_.gcc_location(),\n-\t\t\t\t\t TREE_TYPE(var_decl), get_closure);\n-\t  DECL_INITIAL(var_decl) = get_closure;\n-\t  DECL_CHAIN(var_decl) = declare_vars;\n-\t  declare_vars = var_decl;\n-\t}\n-    }\n-\n-  if (this->block_ != NULL)\n-    {\n-      go_assert(DECL_INITIAL(fndecl) == NULL_TREE);\n-\n-      // Declare variables if necessary.\n-      tree bind = NULL_TREE;\n-      tree defer_init = NULL_TREE;\n-      if (declare_vars != NULL_TREE || this->defer_stack_ != NULL)\n-\t{\n-\t  tree block = make_node(BLOCK);\n-\t  BLOCK_SUPERCONTEXT(block) = fndecl;\n-\t  DECL_INITIAL(fndecl) = block;\n-\t  BLOCK_VARS(block) = declare_vars;\n-\t  TREE_USED(block) = 1;\n-\n-\t  bind = build3(BIND_EXPR, void_type_node, BLOCK_VARS(block),\n-\t\t\tNULL_TREE, block);\n-\t  TREE_SIDE_EFFECTS(bind) = 1;\n-\n-\t  if (this->defer_stack_ != NULL)\n-\t    {\n-\t      Translate_context dcontext(gogo, named_function, this->block_,\n-\t\t\t\t\t tree_to_block(bind));\n-\t      Bstatement* bdi = this->defer_stack_->get_backend(&dcontext);\n-\t      defer_init = stat_to_tree(bdi);\n-\t    }\n-\t}\n-\n-      // Build the trees for all the statements in the function.\n-      Translate_context context(gogo, named_function, NULL, NULL);\n-      Bblock* bblock = this->block_->get_backend(&context);\n-      tree code = block_to_tree(bblock);\n-\n-      tree init = NULL_TREE;\n-      tree except = NULL_TREE;\n-      tree fini = NULL_TREE;\n-\n-      // Initialize variables if necessary.\n-      for (tree v = declare_vars; v != NULL_TREE; v = DECL_CHAIN(v))\n-\t{\n-\t  tree dv = build1(DECL_EXPR, void_type_node, v);\n-\t  SET_EXPR_LOCATION(dv, DECL_SOURCE_LOCATION(v));\n-\t  append_to_statement_list(dv, &init);\n-\t}\n-\n-      // If we have a defer stack, initialize it at the start of a\n-      // function.\n-      if (defer_init != NULL_TREE && defer_init != error_mark_node)\n-\t{\n-\t  SET_EXPR_LOCATION(defer_init,\n-                            this->block_->start_location().gcc_location());\n-\t  append_to_statement_list(defer_init, &init);\n-\n-\t  // Clean up the defer stack when we leave the function.\n-\t  this->build_defer_wrapper(gogo, named_function, &except, &fini);\n-\t}\n-\n-      if (code != NULL_TREE && code != error_mark_node)\n-\t{\n-\t  if (init != NULL_TREE)\n-\t    code = build2(COMPOUND_EXPR, void_type_node, init, code);\n-\t  if (except != NULL_TREE)\n-\t    code = build2(TRY_CATCH_EXPR, void_type_node, code,\n-\t\t\t  build2(CATCH_EXPR, void_type_node, NULL, except));\n-\t  if (fini != NULL_TREE)\n-\t    code = build2(TRY_FINALLY_EXPR, void_type_node, code, fini);\n-\t}\n-\n-      // Stick the code into the block we built for the receiver, if\n-      // we built on.\n-      if (bind != NULL_TREE && code != NULL_TREE && code != error_mark_node)\n-\t{\n-\t  BIND_EXPR_BODY(bind) = code;\n-\t  code = bind;\n-\t}\n-\n-      DECL_SAVED_TREE(fndecl) = code;\n-    }\n-\n-  // If we created a descriptor for the function, make sure we emit it.\n-  if (this->descriptor_ != NULL)\n-    {\n-      Translate_context context(gogo, NULL, NULL, NULL);\n-      this->descriptor_->get_tree(&context);\n-    }\n-}\n-\n-// Build the wrappers around function code needed if the function has\n-// any defer statements.  This sets *EXCEPT to an exception handler\n-// and *FINI to a finally handler.\n-\n-void\n-Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n-\t\t\t      tree *except, tree *fini)\n-{\n-  Location end_loc = this->block_->end_location();\n-\n-  // Add an exception handler.  This is used if a panic occurs.  Its\n-  // purpose is to stop the stack unwinding if a deferred function\n-  // calls recover.  There are more details in\n-  // libgo/runtime/go-unwind.c.\n-\n-  tree stmt_list = NULL_TREE;\n-\n-  Expression* call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n-\t\t\t\t\tthis->defer_stack(end_loc));\n-  Translate_context context(gogo, named_function, NULL, NULL);\n-  tree call_tree = call->get_tree(&context);\n-  if (call_tree != error_mark_node)\n-    append_to_statement_list(call_tree, &stmt_list);\n-\n-  tree retval = this->return_value(gogo, named_function, end_loc, &stmt_list);\n-  tree set;\n-  if (retval == NULL_TREE)\n-    set = NULL_TREE;\n-  else\n-    set = fold_build2_loc(end_loc.gcc_location(), MODIFY_EXPR, void_type_node,\n-\t\t\t  DECL_RESULT(this->get_decl()), retval);\n-  tree ret_stmt = fold_build1_loc(end_loc.gcc_location(), RETURN_EXPR,\n-                                  void_type_node, set);\n-  append_to_statement_list(ret_stmt, &stmt_list);\n-\n-  go_assert(*except == NULL_TREE);\n-  *except = stmt_list;\n-\n-  // Add some finally code to run the defer functions.  This is used\n-  // both in the normal case, when no panic occurs, and also if a\n-  // panic occurs to run any further defer functions.  Of course, it\n-  // is possible for a defer function to call panic which should be\n-  // caught by another defer function.  To handle that we use a loop.\n-  //  finish:\n-  //   try { __go_undefer(); } catch { __go_check_defer(); goto finish; }\n-  //   if (return values are named) return named_vals;\n-\n-  stmt_list = NULL;\n-\n-  tree label = create_artificial_label(end_loc.gcc_location());\n-  tree define_label = fold_build1_loc(end_loc.gcc_location(), LABEL_EXPR,\n-                                      void_type_node, label);\n-  append_to_statement_list(define_label, &stmt_list);\n-\n-  call = Runtime::make_call(Runtime::UNDEFER, end_loc, 1,\n-\t\t\t    this->defer_stack(end_loc));\n-  tree undefer = call->get_tree(&context);\n-\n-  call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n-\t\t\t    this->defer_stack(end_loc));\n-  tree defer = call->get_tree(&context);\n-\n-  if (undefer == error_mark_node || defer == error_mark_node)\n-    return;\n-\n-  tree jump = fold_build1_loc(end_loc.gcc_location(), GOTO_EXPR, void_type_node,\n-                              label);\n-  tree catch_body = build2(COMPOUND_EXPR, void_type_node, defer, jump);\n-  catch_body = build2(CATCH_EXPR, void_type_node, NULL, catch_body);\n-  tree try_catch = build2(TRY_CATCH_EXPR, void_type_node, undefer, catch_body);\n-\n-  append_to_statement_list(try_catch, &stmt_list);\n-\n-  if (this->type_->results() != NULL\n-      && !this->type_->results()->empty()\n-      && !this->type_->results()->front().name().empty())\n-    {\n-      // If the result variables are named, and we are returning from\n-      // this function rather than panicing through it, we need to\n-      // return them again, because they might have been changed by a\n-      // defer function.  The runtime routines set the defer_stack\n-      // variable to true if we are returning from this function.\n-      retval = this->return_value(gogo, named_function, end_loc,\n-\t\t\t\t  &stmt_list);\n-      set = fold_build2_loc(end_loc.gcc_location(), MODIFY_EXPR, void_type_node,\n-\t\t\t    DECL_RESULT(this->get_decl()), retval);\n-      ret_stmt = fold_build1_loc(end_loc.gcc_location(), RETURN_EXPR,\n-                                 void_type_node, set);\n-\n-      Expression* ref =\n-\tExpression::make_temporary_reference(this->defer_stack_, end_loc);\n-      tree tref = ref->get_tree(&context);\n-      tree s = build3_loc(end_loc.gcc_location(), COND_EXPR, void_type_node,\n-                          tref, ret_stmt, NULL_TREE);\n-\n-      append_to_statement_list(s, &stmt_list);\n-\n-    }\n-  \n-  go_assert(*fini == NULL_TREE);\n-  *fini = stmt_list;\n-}\n-\n-// Return the value to assign to DECL_RESULT(this->get_decl()).  This may\n-// also add statements to STMT_LIST, which need to be executed before\n-// the assignment.  This is used for a return statement with no\n-// explicit values.\n-\n-tree\n-Function::return_value(Gogo* gogo, Named_object* named_function,\n-\t\t       Location location, tree* stmt_list) const\n-{\n-  const Typed_identifier_list* results = this->type_->results();\n-  if (results == NULL || results->empty())\n-    return NULL_TREE;\n-\n-  go_assert(this->results_ != NULL);\n-  if (this->results_->size() != results->size())\n-    {\n-      go_assert(saw_errors());\n-      return error_mark_node;\n-    }\n-\n-  tree retval;\n-  if (results->size() == 1)\n-    {\n-      Bvariable* bvar =\n-\tthis->results_->front()->get_backend_variable(gogo,\n-\t\t\t\t\t\t      named_function);\n-      tree ret = var_to_tree(bvar);\n-      if (this->results_->front()->result_var_value()->is_in_heap())\n-\tret = build_fold_indirect_ref_loc(location.gcc_location(), ret);\n-      return ret;\n-    }\n-  else\n-    {\n-      tree rettype = TREE_TYPE(DECL_RESULT(this->get_decl()));\n-      retval = create_tmp_var(rettype, \"RESULT\");\n-      tree field = TYPE_FIELDS(rettype);\n-      int index = 0;\n-      for (Typed_identifier_list::const_iterator pr = results->begin();\n-\t   pr != results->end();\n-\t   ++pr, ++index, field = DECL_CHAIN(field))\n-\t{\n-\t  go_assert(field != NULL);\n-\t  Named_object* no = (*this->results_)[index];\n-\t  Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n-\t  tree val = var_to_tree(bvar);\n-\t  if (no->result_var_value()->is_in_heap())\n-\t    val = build_fold_indirect_ref_loc(location.gcc_location(), val);\n-\t  tree set = fold_build2_loc(location.gcc_location(), MODIFY_EXPR,\n-                                     void_type_node,\n-\t\t\t\t     build3(COMPONENT_REF, TREE_TYPE(field),\n-\t\t\t\t\t    retval, field, NULL_TREE),\n-\t\t\t\t     val);\n-\t  append_to_statement_list(set, stmt_list);\n-\t}\n-      return retval;\n-    }\n-}\n-\n // Build the descriptor for a function declaration.  This won't\n // necessarily happen if the package has just a declaration for the\n // function and no other reference to it, but we may still need the\n@@ -1834,38 +1301,6 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n     return NULL_TREE;\n }\n \n-// Return a tree which allocates SIZE bytes which will holds value of\n-// type TYPE.\n-\n-tree\n-Gogo::allocate_memory(Type* type, tree size, Location location)\n-{\n-  // If the package imports unsafe, then it may play games with\n-  // pointers that look like integers.\n-  if (this->imported_unsafe_ || type->has_pointer())\n-    {\n-      static tree new_fndecl;\n-      return Gogo::call_builtin(&new_fndecl,\n-\t\t\t\tlocation,\n-\t\t\t\t\"__go_new\",\n-\t\t\t\t1,\n-\t\t\t\tptr_type_node,\n-\t\t\t\tsizetype,\n-\t\t\t\tsize);\n-    }\n-  else\n-    {\n-      static tree new_nopointers_fndecl;\n-      return Gogo::call_builtin(&new_nopointers_fndecl,\n-\t\t\t\tlocation,\n-\t\t\t\t\"__go_new_nopointers\",\n-\t\t\t\t1,\n-\t\t\t\tptr_type_node,\n-\t\t\t\tsizetype,\n-\t\t\t\tsize);\n-    }\n-}\n-\n // Build a builtin struct with a list of fields.  The name is\n // STRUCT_NAME.  STRUCT_TYPE is NULL_TREE or an empty RECORD_TYPE\n // node; this exists so that the struct can have fields which point to\n@@ -1915,94 +1350,6 @@ Gogo::builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n   return struct_type;\n }\n \n-// Return a type to use for pointer to const char for a string.\n-\n-tree\n-Gogo::const_char_pointer_type_tree()\n-{\n-  static tree type;\n-  if (type == NULL_TREE)\n-    {\n-      tree const_char_type = build_qualified_type(unsigned_char_type_node,\n-\t\t\t\t\t\t  TYPE_QUAL_CONST);\n-      type = build_pointer_type(const_char_type);\n-      go_preserve_from_gc(type);\n-    }\n-  return type;\n-}\n-\n-// Return a tree for a string constant.\n-\n-tree\n-Gogo::string_constant_tree(const std::string& val)\n-{\n-  tree index_type = build_index_type(size_int(val.length()));\n-  tree const_char_type = build_qualified_type(unsigned_char_type_node,\n-\t\t\t\t\t      TYPE_QUAL_CONST);\n-  tree string_type = build_array_type(const_char_type, index_type);\n-  string_type = build_variant_type_copy(string_type);\n-  TYPE_STRING_FLAG(string_type) = 1;\n-  tree string_val = build_string(val.length(), val.data());\n-  TREE_TYPE(string_val) = string_type;\n-  return string_val;\n-}\n-\n-// Return a tree for a Go string constant.\n-\n-tree\n-Gogo::go_string_constant_tree(const std::string& val)\n-{\n-  tree string_type = type_to_tree(Type::make_string_type()->get_backend(this));\n-\n-  vec<constructor_elt, va_gc> *init;\n-  vec_alloc(init, 2);\n-\n-  constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = init->quick_push(empty);\n-  tree field = TYPE_FIELDS(string_type);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__data\") == 0);\n-  elt->index = field;\n-  tree str = Gogo::string_constant_tree(val);\n-  elt->value = fold_convert(TREE_TYPE(field),\n-\t\t\t    build_fold_addr_expr(str));\n-\n-  elt = init->quick_push(empty);\n-  field = DECL_CHAIN(field);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__length\") == 0);\n-  elt->index = field;\n-  elt->value = build_int_cst_type(TREE_TYPE(field), val.length());\n-\n-  tree constructor = build_constructor(string_type, init);\n-  TREE_READONLY(constructor) = 1;\n-  TREE_CONSTANT(constructor) = 1;\n-\n-  return constructor;\n-}\n-\n-// Return a tree for a pointer to a Go string constant.  This is only\n-// used for type descriptors, so we return a pointer to a constant\n-// decl.\n-\n-tree\n-Gogo::ptr_go_string_constant_tree(const std::string& val)\n-{\n-  tree pval = this->go_string_constant_tree(val);\n-\n-  tree decl = build_decl(UNKNOWN_LOCATION, VAR_DECL,\n-\t\t\t create_tmp_var_name(\"SP\"), TREE_TYPE(pval));\n-  DECL_EXTERNAL(decl) = 0;\n-  TREE_PUBLIC(decl) = 0;\n-  TREE_USED(decl) = 1;\n-  TREE_READONLY(decl) = 1;\n-  TREE_CONSTANT(decl) = 1;\n-  TREE_STATIC(decl) = 1;\n-  DECL_ARTIFICIAL(decl) = 1;\n-  DECL_INITIAL(decl) = pval;\n-  rest_of_decl_compilation(decl, 1, 0);\n-\n-  return build_fold_addr_expr(decl);\n-}\n-\n // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n // the slice.  VALUES is the value pointer and COUNT is the number of\n // entries.  If CAPACITY is not NULL, it is the capacity; otherwise\n@@ -2048,136 +1395,6 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n   return build_constructor(slice_type_tree, init);\n }\n \n-// Build an interface method table for a type: a list of function\n-// pointers, one for each interface method.  This is used for\n-// interfaces.\n-\n-tree\n-Gogo::interface_method_table_for_type(const Interface_type* interface,\n-\t\t\t\t      Type* type, bool is_pointer)\n-{\n-  const Typed_identifier_list* interface_methods = interface->methods();\n-  go_assert(!interface_methods->empty());\n-\n-  std::string mangled_name = ((is_pointer ? \"__go_pimt__\" : \"__go_imt_\")\n-\t\t\t      + interface->mangled_name(this)\n-\t\t\t      + \"__\"\n-\t\t\t      + type->mangled_name(this));\n-\n-  tree id = get_identifier_from_string(mangled_name);\n-\n-  // See whether this interface has any hidden methods.\n-  bool has_hidden_methods = false;\n-  for (Typed_identifier_list::const_iterator p = interface_methods->begin();\n-       p != interface_methods->end();\n-       ++p)\n-    {\n-      if (Gogo::is_hidden_name(p->name()))\n-\t{\n-\t  has_hidden_methods = true;\n-\t  break;\n-\t}\n-    }\n-\n-  // We already know that the named type is convertible to the\n-  // interface.  If the interface has hidden methods, and the named\n-  // type is defined in a different package, then the interface\n-  // conversion table will be defined by that other package.\n-  if (has_hidden_methods\n-      && type->named_type() != NULL\n-      && type->named_type()->named_object()->package() != NULL)\n-    {\n-      tree array_type = build_array_type(const_ptr_type_node, NULL);\n-      tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL, id, array_type);\n-      TREE_READONLY(decl) = 1;\n-      TREE_CONSTANT(decl) = 1;\n-      TREE_PUBLIC(decl) = 1;\n-      DECL_EXTERNAL(decl) = 1;\n-      go_preserve_from_gc(decl);\n-      return decl;\n-    }\n-\n-  size_t count = interface_methods->size();\n-  vec<constructor_elt, va_gc> *pointers;\n-  vec_alloc(pointers, count + 1);\n-\n-  // The first element is the type descriptor.\n-  constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = pointers->quick_push(empty);\n-  elt->index = size_zero_node;\n-  Type* td_type;\n-  if (!is_pointer)\n-    td_type = type;\n-  else\n-    td_type = Type::make_pointer_type(type);\n-\n-  Location loc = Linemap::predeclared_location();\n-  Bexpression* tdp_bexpr = td_type->type_descriptor_pointer(this, loc);\n-  tree tdp = expr_to_tree(tdp_bexpr);\n-  elt->value = fold_convert(const_ptr_type_node, tdp);\n-\n-  Named_type* nt = type->named_type();\n-  Struct_type* st = type->struct_type();\n-  go_assert(nt != NULL || st != NULL);\n-  size_t i = 1;\n-  for (Typed_identifier_list::const_iterator p = interface_methods->begin();\n-       p != interface_methods->end();\n-       ++p, ++i)\n-    {\n-      bool is_ambiguous;\n-      Method* m;\n-      if (nt != NULL)\n-\tm = nt->method_function(p->name(), &is_ambiguous);\n-      else\n-\tm = st->method_function(p->name(), &is_ambiguous);\n-      go_assert(m != NULL);\n-\n-      Named_object* no = m->named_object();\n-      Bfunction* bf;\n-      if (no->is_function())\n-\tbf = no->func_value()->get_or_make_decl(this, no);\n-      else if (no->is_function_declaration())\n-\tbf = no->func_declaration_value()->get_or_make_decl(this, no);\n-      else\n-\tgo_unreachable();\n-      tree fndecl = build_fold_addr_expr(function_to_tree(bf));\n-\n-      elt = pointers->quick_push(empty);\n-      elt->index = size_int(i);\n-      elt->value = fold_convert(const_ptr_type_node, fndecl);\n-    }\n-  go_assert(i == count + 1);\n-\n-  tree array_type = build_array_type(const_ptr_type_node,\n-\t\t\t\t     build_index_type(size_int(count)));\n-  tree constructor = build_constructor(array_type, pointers);\n-\n-  tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL, id, array_type);\n-  TREE_STATIC(decl) = 1;\n-  TREE_USED(decl) = 1;\n-  TREE_READONLY(decl) = 1;\n-  TREE_CONSTANT(decl) = 1;\n-  DECL_INITIAL(decl) = constructor;\n-\n-  // If the interface type has hidden methods, and the table is for a\n-  // named type, then this is the only definition of the table.\n-  // Otherwise it is a comdat table which may be defined in multiple\n-  // packages.\n-  if (has_hidden_methods && type->named_type() != NULL)\n-    TREE_PUBLIC(decl) = 1;\n-  else\n-    {\n-      make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n-      resolve_unique_section(decl, 1, 0);\n-    }\n-\n-  rest_of_decl_compilation(decl, 1, 0);\n-\n-  go_preserve_from_gc(decl);\n-\n-  return decl;\n-}\n-\n // Mark a function as a builtin library function.\n \n void\n@@ -2250,70 +1467,3 @@ Gogo::call_builtin(tree* pdecl, Location location, const char* name,\n \n   return ret;\n }\n-\n-// Return a tree for receiving a value of type TYPE_TREE on CHANNEL.\n-// TYPE_DESCRIPTOR_TREE is the channel's type descriptor.  This does a\n-// blocking receive and returns the value read from the channel.\n-\n-tree\n-Gogo::receive_from_channel(tree type_tree, tree type_descriptor_tree,\n-\t\t\t   tree channel, Location location)\n-{\n-  if (type_tree == error_mark_node || channel == error_mark_node)\n-    return error_mark_node;\n-\n-  if (int_size_in_bytes(type_tree) <= 8\n-      && !AGGREGATE_TYPE_P(type_tree)\n-      && !FLOAT_TYPE_P(type_tree))\n-    {\n-      static tree receive_small_fndecl;\n-      tree call = Gogo::call_builtin(&receive_small_fndecl,\n-\t\t\t\t     location,\n-\t\t\t\t     \"__go_receive_small\",\n-\t\t\t\t     2,\n-\t\t\t\t     uint64_type_node,\n-\t\t\t\t     TREE_TYPE(type_descriptor_tree),\n-\t\t\t\t     type_descriptor_tree,\n-\t\t\t\t     ptr_type_node,\n-\t\t\t\t     channel);\n-      if (call == error_mark_node)\n-\treturn error_mark_node;\n-      // This can panic if there are too many operations on a closed\n-      // channel.\n-      TREE_NOTHROW(receive_small_fndecl) = 0;\n-      int bitsize = GET_MODE_BITSIZE(TYPE_MODE(type_tree));\n-      tree int_type_tree = go_type_for_size(bitsize, 1);\n-      return fold_convert_loc(location.gcc_location(), type_tree,\n-\t\t\t      fold_convert_loc(location.gcc_location(),\n-                                               int_type_tree, call));\n-    }\n-  else\n-    {\n-      tree tmp = create_tmp_var(type_tree, get_name(type_tree));\n-      DECL_IGNORED_P(tmp) = 0;\n-      TREE_ADDRESSABLE(tmp) = 1;\n-      tree make_tmp = build1(DECL_EXPR, void_type_node, tmp);\n-      SET_EXPR_LOCATION(make_tmp, location.gcc_location());\n-      tree tmpaddr = build_fold_addr_expr(tmp);\n-      tmpaddr = fold_convert(ptr_type_node, tmpaddr);\n-      static tree receive_big_fndecl;\n-      tree call = Gogo::call_builtin(&receive_big_fndecl,\n-\t\t\t\t     location,\n-\t\t\t\t     \"__go_receive_big\",\n-\t\t\t\t     3,\n-\t\t\t\t     void_type_node,\n-\t\t\t\t     TREE_TYPE(type_descriptor_tree),\n-\t\t\t\t     type_descriptor_tree,\n-\t\t\t\t     ptr_type_node,\n-\t\t\t\t     channel,\n-\t\t\t\t     ptr_type_node,\n-\t\t\t\t     tmpaddr);\n-      if (call == error_mark_node)\n-\treturn error_mark_node;\n-      // This can panic if there are too many operations on a closed\n-      // channel.\n-      TREE_NOTHROW(receive_big_fndecl) = 0;\n-      return build2(COMPOUND_EXPR, type_tree, make_tmp,\n-\t\t    build2(COMPOUND_EXPR, type_tree, call, tmp));\n-    }\n-}"}, {"sha": "6df4b6bf325f39c0970874acb16a0301aa5b91e9", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 386, "deletions": 4, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -1005,6 +1005,10 @@ Label*\n Gogo::add_label_definition(const std::string& label_name,\n \t\t\t   Location location)\n {\n+  // A label with a blank identifier is never declared or defined.\n+  if (label_name == \"_\")\n+    return NULL;\n+\n   go_assert(!this->functions_.empty());\n   Function* func = this->functions_.back().function->func_value();\n   Label* label = func->add_label_definition(this, label_name, location);\n@@ -3330,6 +3334,7 @@ Build_method_tables::type(Type* type)\n   Struct_type* st = type->struct_type();\n   if (nt != NULL || st != NULL)\n     {\n+      Translate_context context(this->gogo_, NULL, NULL, NULL);\n       for (std::vector<Interface_type*>::const_iterator p =\n \t     this->interfaces_.begin();\n \t   p != this->interfaces_.end();\n@@ -3343,24 +3348,46 @@ Build_method_tables::type(Type* type)\n \t      if ((*p)->implements_interface(Type::make_pointer_type(nt),\n \t\t\t\t\t     NULL))\n \t\t{\n-\t\t  nt->interface_method_table(this->gogo_, *p, false);\n-\t\t  nt->interface_method_table(this->gogo_, *p, true);\n+\t\t  nt->interface_method_table(*p, false)->get_tree(&context);\n+                  nt->interface_method_table(*p, true)->get_tree(&context);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if ((*p)->implements_interface(Type::make_pointer_type(st),\n \t\t\t\t\t     NULL))\n \t\t{\n-\t\t  st->interface_method_table(this->gogo_, *p, false);\n-\t\t  st->interface_method_table(this->gogo_, *p, true);\n+\t\t  st->interface_method_table(*p, false)->get_tree(&context);\n+\t\t  st->interface_method_table(*p, true)->get_tree(&context);\n \t\t}\n \t    }\n \t}\n     }\n   return TRAVERSE_CONTINUE;\n }\n \n+// Return an expression which allocates memory to hold values of type TYPE.\n+\n+Expression*\n+Gogo::allocate_memory(Type* type, Location location)\n+{\n+  Btype* btype = type->get_backend(this);\n+  size_t size = this->backend()->type_size(btype);\n+  mpz_t size_val;\n+  mpz_init_set_ui(size_val, size);\n+  Type* uintptr = Type::lookup_integer_type(\"uintptr\");\n+  Expression* size_expr =\n+    Expression::make_integer(&size_val, uintptr, location);\n+\n+  // If the package imports unsafe, then it may play games with\n+  // pointers that look like integers.\n+  bool use_new_pointers = this->imported_unsafe_ || type->has_pointer();\n+  return Runtime::make_call((use_new_pointers\n+\t\t\t     ? Runtime::NEW\n+\t\t\t     : Runtime::NEW_NOPOINTERS),\n+                            location, 1, size_expr);\n+}\n+\n // Traversal class used to check for return statements.\n \n class Check_return_statements_traverse : public Traverse\n@@ -4111,6 +4138,293 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n   return this->fndecl_;\n }\n \n+// Build the backend representation for the function code.\n+\n+void\n+Function::build(Gogo* gogo, Named_object* named_function)\n+{\n+  Translate_context context(gogo, named_function, NULL, NULL);\n+\n+  // A list of parameter variables for this function.\n+  std::vector<Bvariable*> param_vars;\n+\n+  // Variables that need to be declared for this function and their\n+  // initial values.\n+  std::vector<Bvariable*> vars;\n+  std::vector<Bexpression*> var_inits;\n+  for (Bindings::const_definitions_iterator p =\n+\t this->block_->bindings()->begin_definitions();\n+       p != this->block_->bindings()->end_definitions();\n+       ++p)\n+    {\n+      Location loc = (*p)->location();\n+      if ((*p)->is_variable() && (*p)->var_value()->is_parameter())\n+\t{\n+\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n+          Bvariable* parm_bvar = bvar;\n+\n+\t  // We always pass the receiver to a method as a pointer.  If\n+\t  // the receiver is declared as a non-pointer type, then we\n+\t  // copy the value into a local variable.\n+\t  if ((*p)->var_value()->is_receiver()\n+\t      && (*p)->var_value()->type()->points_to() == NULL)\n+\t    {\n+\t      std::string name = (*p)->name() + \".pointer\";\n+\t      Type* var_type = (*p)->var_value()->type();\n+\t      Variable* parm_var =\n+\t\t  new Variable(Type::make_pointer_type(var_type), NULL, false,\n+\t\t\t       true, false, loc);\n+\t      Named_object* parm_no =\n+                  Named_object::make_variable(name, NULL, parm_var);\n+              parm_bvar = parm_no->get_backend_variable(gogo, named_function);\n+\n+              vars.push_back(bvar);\n+\t      Expression* parm_ref =\n+                  Expression::make_var_reference(parm_no, loc);\n+\t      parm_ref = Expression::make_unary(OPERATOR_MULT, parm_ref, loc);\n+\t      if ((*p)->var_value()->is_in_heap())\n+\t\tparm_ref = Expression::make_heap_expression(parm_ref, loc);\n+              var_inits.push_back(tree_to_expr(parm_ref->get_tree(&context)));\n+\t    }\n+\t  else if ((*p)->var_value()->is_in_heap())\n+\t    {\n+\t      // If we take the address of a parameter, then we need\n+\t      // to copy it into the heap.\n+\t      std::string parm_name = (*p)->name() + \".param\";\n+\t      Variable* parm_var = new Variable((*p)->var_value()->type(), NULL,\n+\t\t\t\t\t\tfalse, true, false, loc);\n+\t      Named_object* parm_no =\n+\t\t  Named_object::make_variable(parm_name, NULL, parm_var);\n+\t      parm_bvar = parm_no->get_backend_variable(gogo, named_function);\n+\n+              vars.push_back(bvar);\n+\t      Expression* var_ref =\n+\t\t  Expression::make_var_reference(parm_no, loc);\n+\t      var_ref = Expression::make_heap_expression(var_ref, loc);\n+              var_inits.push_back(tree_to_expr(var_ref->get_tree(&context)));\n+\t    }\n+          param_vars.push_back(parm_bvar);\n+\t}\n+      else if ((*p)->is_result_variable())\n+\t{\n+\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n+\n+\t  Type* type = (*p)->result_var_value()->type();\n+\t  Bexpression* init;\n+\t  if (!(*p)->result_var_value()->is_in_heap())\n+\t    {\n+\t      Btype* btype = type->get_backend(gogo);\n+\t      init = gogo->backend()->zero_expression(btype);\n+\t    }\n+\t  else\n+            {\n+              Expression* alloc = Expression::make_allocation(type, loc);\n+              init = tree_to_expr(alloc->get_tree(&context));\n+            }\n+\n+          vars.push_back(bvar);\n+          var_inits.push_back(init);\n+\t}\n+    }\n+  if (!gogo->backend()->function_set_parameters(this->fndecl_, param_vars))\n+    {\n+      go_assert(saw_errors());\n+      return;\n+    }\n+\n+  // If we need a closure variable, fetch it by calling a runtime\n+  // function.  The caller will have called __go_set_closure before\n+  // the function call.\n+  if (this->closure_var_ != NULL)\n+    {\n+      Bvariable* closure_bvar =\n+\tthis->closure_var_->get_backend_variable(gogo, named_function);\n+      vars.push_back(closure_bvar);\n+\n+      Expression* closure =\n+          Runtime::make_call(Runtime::GET_CLOSURE, this->location_, 0);\n+      var_inits.push_back(tree_to_expr(closure->get_tree(&context)));\n+    }\n+\n+  if (this->block_ != NULL)\n+    {\n+      // Declare variables if necessary.\n+      Bblock* var_decls = NULL;\n+\n+      Bstatement* defer_init = NULL;\n+      if (!vars.empty() || this->defer_stack_ != NULL)\n+\t{\n+          var_decls =\n+              gogo->backend()->block(this->fndecl_, NULL, vars,\n+                                     this->block_->start_location(),\n+                                     this->block_->end_location());\n+\n+\t  if (this->defer_stack_ != NULL)\n+\t    {\n+\t      Translate_context dcontext(gogo, named_function, this->block_,\n+                                         var_decls);\n+              defer_init = this->defer_stack_->get_backend(&dcontext);\n+\t    }\n+\t}\n+\n+      // Build the backend representation for all the statements in the\n+      // function.\n+      Translate_context context(gogo, named_function, NULL, NULL);\n+      Bblock* code_block = this->block_->get_backend(&context);\n+\n+      // Initialize variables if necessary.\n+      std::vector<Bstatement*> init;\n+      go_assert(vars.size() == var_inits.size());\n+      for (size_t i = 0; i < vars.size(); ++i)\n+\t{\n+          Bstatement* init_stmt =\n+              gogo->backend()->init_statement(vars[i], var_inits[i]);\n+          init.push_back(init_stmt);\n+\t}\n+      Bstatement* var_init = gogo->backend()->statement_list(init);\n+\n+      // Initialize all variables before executing this code block.\n+      Bstatement* code_stmt = gogo->backend()->block_statement(code_block);\n+      code_stmt = gogo->backend()->compound_statement(var_init, code_stmt);\n+\n+      // If we have a defer stack, initialize it at the start of a\n+      // function.\n+      Bstatement* except = NULL;\n+      Bstatement* fini = NULL;\n+      if (defer_init != NULL)\n+\t{\n+\t  // Clean up the defer stack when we leave the function.\n+\t  this->build_defer_wrapper(gogo, named_function, &except, &fini);\n+\n+          // Wrap the code for this function in an exception handler to handle\n+          // defer calls.\n+          code_stmt =\n+              gogo->backend()->exception_handler_statement(code_stmt,\n+                                                           except, fini,\n+                                                           this->location_);\n+\t}\n+\n+      // Stick the code into the block we built for the receiver, if\n+      // we built one.\n+      if (var_decls != NULL)\n+        {\n+          std::vector<Bstatement*> code_stmt_list(1, code_stmt);\n+          gogo->backend()->block_add_statements(var_decls, code_stmt_list);\n+          code_stmt = gogo->backend()->block_statement(var_decls);\n+        }\n+\n+      if (!gogo->backend()->function_set_body(this->fndecl_, code_stmt))\n+        {\n+          go_assert(saw_errors());\n+          return;\n+        }\n+    }\n+\n+  // If we created a descriptor for the function, make sure we emit it.\n+  if (this->descriptor_ != NULL)\n+    {\n+      Translate_context context(gogo, NULL, NULL, NULL);\n+      this->descriptor_->get_tree(&context);\n+    }\n+}\n+\n+// Build the wrappers around function code needed if the function has\n+// any defer statements.  This sets *EXCEPT to an exception handler\n+// and *FINI to a finally handler.\n+\n+void\n+Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n+\t\t\t      Bstatement** except, Bstatement** fini)\n+{\n+  Location end_loc = this->block_->end_location();\n+\n+  // Add an exception handler.  This is used if a panic occurs.  Its\n+  // purpose is to stop the stack unwinding if a deferred function\n+  // calls recover.  There are more details in\n+  // libgo/runtime/go-unwind.c.\n+\n+  std::vector<Bstatement*> stmts;\n+  Expression* call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n+\t\t\t\t\tthis->defer_stack(end_loc));\n+  Translate_context context(gogo, named_function, NULL, NULL);\n+  Bexpression* defer = tree_to_expr(call->get_tree(&context));\n+  stmts.push_back(gogo->backend()->expression_statement(defer));\n+\n+  Bstatement* ret_bstmt = this->return_value(gogo, named_function, end_loc);\n+  if (ret_bstmt != NULL)\n+    stmts.push_back(ret_bstmt);\n+\n+  go_assert(*except == NULL);\n+  *except = gogo->backend()->statement_list(stmts);\n+\n+  call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n+                            this->defer_stack(end_loc));\n+  defer = tree_to_expr(call->get_tree(&context));\n+\n+  call = Runtime::make_call(Runtime::UNDEFER, end_loc, 1,\n+        \t\t    this->defer_stack(end_loc));\n+  Bexpression* undefer = tree_to_expr(call->get_tree(&context));\n+  Bstatement* function_defer =\n+      gogo->backend()->function_defer_statement(this->fndecl_, undefer, defer,\n+                                                end_loc);\n+  stmts = std::vector<Bstatement*>(1, function_defer);\n+  if (this->type_->results() != NULL\n+      && !this->type_->results()->empty()\n+      && !this->type_->results()->front().name().empty())\n+    {\n+      // If the result variables are named, and we are returning from\n+      // this function rather than panicing through it, we need to\n+      // return them again, because they might have been changed by a\n+      // defer function.  The runtime routines set the defer_stack\n+      // variable to true if we are returning from this function.\n+\n+      ret_bstmt = this->return_value(gogo, named_function, end_loc);\n+      Bexpression* nil =\n+          tree_to_expr(Expression::make_nil(end_loc)->get_tree(&context));\n+      Bexpression* ret =\n+          gogo->backend()->compound_expression(ret_bstmt, nil, end_loc);\n+      Expression* ref =\n+\tExpression::make_temporary_reference(this->defer_stack_, end_loc);\n+      Bexpression* bref = tree_to_expr(ref->get_tree(&context));\n+      ret = gogo->backend()->conditional_expression(NULL, bref, ret, NULL,\n+                                                    end_loc);\n+      stmts.push_back(gogo->backend()->expression_statement(ret));\n+    }\n+\n+  go_assert(*fini == NULL);\n+  *fini = gogo->backend()->statement_list(stmts);\n+}\n+\n+// Return the statement that assigns values to this function's result struct.\n+\n+Bstatement*\n+Function::return_value(Gogo* gogo, Named_object* named_function,\n+\t\t       Location location) const\n+{\n+  const Typed_identifier_list* results = this->type_->results();\n+  if (results == NULL || results->empty())\n+    return NULL;\n+\n+  go_assert(this->results_ != NULL);\n+  if (this->results_->size() != results->size())\n+    {\n+      go_assert(saw_errors());\n+      return gogo->backend()->error_statement();\n+    }\n+\n+  std::vector<Bexpression*> vals(results->size());\n+  for (size_t i = 0; i < vals.size(); ++i)\n+    {\n+      Named_object* no = (*this->results_)[i];\n+      Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n+      Bexpression* val = gogo->backend()->var_expression(bvar, location);\n+      if (no->result_var_value()->is_in_heap())\n+        val = gogo->backend()->indirect_expression(val, true, location);\n+      vals[i] = val;\n+    }\n+  return gogo->backend()->return_statement(this->fndecl_, vals, location);\n+}\n+\n // Class Block.\n \n Block::Block(Block* enclosing, Location location)\n@@ -4857,6 +5171,74 @@ Variable::determine_type()\n     }\n }\n \n+// Get the initial value of a variable.  This does not\n+// consider whether the variable is in the heap--it returns the\n+// initial value as though it were always stored in the stack.\n+\n+Bexpression*\n+Variable::get_init(Gogo* gogo, Named_object* function)\n+{\n+  go_assert(this->preinit_ == NULL);\n+  Location loc = this->location();\n+  if (this->init_ == NULL)\n+    {\n+      go_assert(!this->is_parameter_);\n+      if (this->is_global_ || this->is_in_heap())\n+\treturn NULL;\n+      Btype* btype = this->type()->get_backend(gogo);\n+      return gogo->backend()->zero_expression(btype);\n+    }\n+  else\n+    {\n+      Translate_context context(gogo, function, NULL, NULL);\n+      Expression* init = Expression::make_cast(this->type(), this->init_, loc);\n+      return tree_to_expr(init->get_tree(&context));\n+    }\n+}\n+\n+// Get the initial value of a variable when a block is required.\n+// VAR_DECL is the decl to set; it may be NULL for a sink variable.\n+\n+Bstatement*\n+Variable::get_init_block(Gogo* gogo, Named_object* function,\n+                         Bvariable* var_decl)\n+{\n+  go_assert(this->preinit_ != NULL);\n+\n+  // We want to add the variable assignment to the end of the preinit\n+  // block.\n+\n+  Translate_context context(gogo, function, NULL, NULL);\n+  Bblock* bblock = this->preinit_->get_backend(&context);\n+\n+  // It's possible to have pre-init statements without an initializer\n+  // if the pre-init statements set the variable.\n+  Bstatement* decl_init = NULL;\n+  if (this->init_ != NULL)\n+    {\n+      if (var_decl == NULL)\n+        {\n+          Bexpression* init_bexpr =\n+              tree_to_expr(this->init_->get_tree(&context));\n+          decl_init = gogo->backend()->expression_statement(init_bexpr);\n+        }\n+      else\n+\t{\n+          Location loc = this->location();\n+          Expression* val_expr =\n+              Expression::convert_for_assignment(gogo, this->type(),\n+                                                 this->init_, this->location());\n+          Bexpression* val = tree_to_expr(val_expr->get_tree(&context));\n+          Bexpression* var_ref = gogo->backend()->var_expression(var_decl, loc);\n+          decl_init = gogo->backend()->assignment_statement(var_ref, val, loc);\n+\t}\n+    }\n+  Bstatement* block_stmt = gogo->backend()->block_statement(bblock);\n+  if (decl_init != NULL)\n+    block_stmt = gogo->backend()->compound_statement(block_stmt, decl_init);\n+  return block_stmt;\n+}\n+\n // Export the variable\n \n void"}, {"sha": "3dc401d695575d4182b8c7e0782cabc4ceedf127", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 15, "deletions": 51, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -612,34 +612,9 @@ class Gogo\n   void\n   build_interface_method_tables();\n \n-  // Build an interface method table for a type: a list of function\n-  // pointers, one for each interface method.  This returns a decl.\n-  tree\n-  interface_method_table_for_type(const Interface_type*, Type*,\n-\t\t\t\t  bool is_pointer);\n-\n-  // Return a tree which allocate SIZE bytes to hold values of type\n-  // TYPE.\n-  tree\n-  allocate_memory(Type *type, tree size, Location);\n-\n-  // Return a type to use for pointer to const char.\n-  static tree\n-  const_char_pointer_type_tree();\n-\n-  // Build a string constant with the right type.\n-  static tree\n-  string_constant_tree(const std::string&);\n-\n-  // Build a Go string constant.  This returns a pointer to the\n-  // constant.\n-  tree\n-  go_string_constant_tree(const std::string&);\n-\n-  // Receive a value from a channel.\n-  static tree\n-  receive_from_channel(tree type_tree, tree type_descriptor_tree, tree channel,\n-\t\t       Location);\n+  // Return an expression which allocates memory to hold values of type TYPE.\n+  Expression*\n+  allocate_memory(Type *type, Location);\n \n  private:\n   // During parsing, we keep a stack of functions.  Each function on\n@@ -687,11 +662,6 @@ class Gogo\n   void\n   register_gc_vars(const std::vector<Named_object*>&, tree*);\n \n-  // Build a pointer to a Go string constant.  This returns a pointer\n-  // to the pointer.\n-  tree\n-  ptr_go_string_constant_tree(const std::string&);\n-\n   // Type used to map import names to packages.\n   typedef std::map<std::string, Package*> Imports;\n \n@@ -1119,14 +1089,14 @@ class Function\n   tree\n   get_decl() const;\n \n-  // Set the function decl to hold a tree of the function code.\n+  // Set the function decl to hold a backend representation of the function\n+  // code.\n   void\n-  build_tree(Gogo*, Named_object*);\n+  build(Gogo*, Named_object*);\n \n-  // Get the value to return when not explicitly specified.  May also\n-  // add statements to execute first to STMT_LIST.\n-  tree\n-  return_value(Gogo*, Named_object*, Location, tree* stmt_list) const;\n+  // Get the statement that assigns values to this function's result struct.\n+  Bstatement*\n+  return_value(Gogo*, Named_object*, Location) const;\n \n   // Get a tree for the variable holding the defer stack.\n   Expression*\n@@ -1151,14 +1121,8 @@ class Function\n   // Type for mapping from label names to Label objects.\n   typedef Unordered_map(std::string, Label*) Labels;\n \n-  tree\n-  make_receiver_parm_decl(Gogo*, Named_object*, tree);\n-\n-  tree\n-  copy_parm_to_heap(Gogo*, Named_object*, tree);\n-\n   void\n-  build_defer_wrapper(Gogo*, Named_object*, tree*, tree*);\n+  build_defer_wrapper(Gogo*, Named_object*, Bstatement**, Bstatement**);\n \n   typedef std::vector<std::pair<Named_object*,\n \t\t\t\tLocation> > Closure_fields;\n@@ -1531,16 +1495,16 @@ class Variable\n   get_backend_variable(Gogo*, Named_object*, const Package*,\n \t\t       const std::string&);\n \n-  // Get the initial value of the variable as a tree.  This may only\n+  // Get the initial value of the variable.  This may only\n   // be called if has_pre_init() returns false.\n-  tree\n-  get_init_tree(Gogo*, Named_object* function);\n+  Bexpression*\n+  get_init(Gogo*, Named_object* function);\n \n   // Return a series of statements which sets the value of the\n   // variable in DECL.  This should only be called is has_pre_init()\n   // returns true.  DECL may be NULL for a sink variable.\n-  tree\n-  get_init_block(Gogo*, Named_object* function, tree decl);\n+  Bstatement*\n+  get_init_block(Gogo*, Named_object* function, Bvariable* decl);\n \n   // Export the variable.\n   void"}, {"sha": "3d60171dde2772741f1a6313460eca1b0aabde44", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -2955,7 +2955,7 @@ Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n   Struct_type* st = closure_var->var_value()->type()->deref()->struct_type();\n   Expression* cv = Expression::make_struct_composite_literal(st, initializer,\n \t\t\t\t\t\t\t     location);\n-  return Expression::make_heap_composite(cv, location);\n+  return Expression::make_heap_expression(cv, location);\n }\n \n // PrimaryExpr = Operand { Selector | Index | Slice | TypeGuard | Call } .\n@@ -3538,7 +3538,7 @@ Parse::unary_expr(bool may_be_sink, bool may_be_composite_lit,\n \texpr = Expression::make_type(Type::make_pointer_type(expr->type()),\n \t\t\t\t     location);\n       else if (op == OPERATOR_AND && expr->is_composite_literal())\n-\texpr = Expression::make_heap_composite(expr, location);\n+\texpr = Expression::make_heap_expression(expr, location);\n       else if (op != OPERATOR_CHANOP)\n \texpr = Expression::make_unary(op, expr, location);\n       else\n@@ -3765,7 +3765,8 @@ Parse::labeled_stmt(const std::string& label_name, Location location)\n     {\n       // Mark the label as used to avoid a useless error about an\n       // unused label.\n-      label->set_is_used();\n+      if (label != NULL)\n+        label->set_is_used();\n \n       error_at(location, \"missing statement after label\");\n       this->unget_token(Token::make_operator_token(OPERATOR_SEMICOLON,"}, {"sha": "8c6e82b226768469b78f09f39372d6027ec18a89", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -142,11 +142,8 @@ DEF_GO_RUNTIME(SEND_SMALL, \"__go_send_small\", P3(TYPE, CHAN, UINT64), R0())\n // Send a big value on a channel.\n DEF_GO_RUNTIME(SEND_BIG, \"__go_send_big\", P3(TYPE, CHAN, POINTER), R0())\n \n-// Receive a small value from a channel.\n-DEF_GO_RUNTIME(RECEIVE_SMALL, \"__go_receive_small\", P2(TYPE, CHAN), R1(UINT64))\n-\n-// Receive a big value from a channel.\n-DEF_GO_RUNTIME(RECEIVE_BIG, \"__go_receive_big\", P3(TYPE, CHAN, POINTER), R0())\n+// Receive a value from a channel.\n+DEF_GO_RUNTIME(RECEIVE, \"__go_receive\", P3(TYPE, CHAN, POINTER), R0())\n \n // Receive a value from a channel returning whether it is closed.\n DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P3(TYPE, CHAN, POINTER),\n@@ -208,7 +205,7 @@ DEF_GO_RUNTIME(RUNTIME_ERROR, \"__go_runtime_error\", P1(INT32), R0())\n \n \n // Close.\n-DEF_GO_RUNTIME(CLOSE, \"__go_close\", P1(CHAN), R0())\n+DEF_GO_RUNTIME(CLOSE, \"__go_builtin_close\", P1(CHAN), R0())\n \n \n // Copy.\n@@ -233,6 +230,11 @@ DEF_GO_RUNTIME(NEW_NOPOINTERS, \"__go_new_nopointers\", P1(UINTPTR), R1(POINTER))\n // Start a new goroutine.\n DEF_GO_RUNTIME(GO, \"__go_go\", P2(FUNC_PTR, POINTER), R0())\n \n+// Get the function closure.\n+DEF_GO_RUNTIME(GET_CLOSURE, \"__go_get_closure\", P0(), R1(POINTER))\n+\n+// Set the function closure.\n+DEF_GO_RUNTIME(SET_CLOSURE, \"__go_set_closure\", P1(POINTER), R0())\n \n // Defer a function.\n DEF_GO_RUNTIME(DEFER, \"__go_defer\", P3(BOOLPTR, FUNC_PTR, POINTER), R0())\n@@ -270,7 +272,7 @@ DEF_GO_RUNTIME(IFACEI2T2, \"runtime.ifaceI2T2\", P3(TYPE, IFACE, POINTER),\n \n // A type assertion from one interface type to another.  This is\n // used for a type assertion.\n-DEF_GO_RUNTIME(ASSERT_INTERFACE, \"__go_assert_interface\", P2(TYPE, TYPE), R0())\n+DEF_GO_RUNTIME(ASSERT_INTERFACE, \"__go_assert_interface\", P2(TYPE, TYPE), R1(POINTER))\n \n // Convert one interface type to another.  This is used for an\n // assignment."}, {"sha": "49a864faa442e8294cb1f4b64b728de7569f514f", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -264,8 +264,7 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n   Variable* var = this->var_->var_value();\n   Bvariable* bvar = this->var_->get_backend_variable(context->gogo(),\n \t\t\t\t\t\t     context->function());\n-  tree init = var->get_init_tree(context->gogo(), context->function());\n-  Bexpression* binit = init == NULL ? NULL : tree_to_expr(init);\n+  Bexpression* binit = var->get_init(context->gogo(), context->function());\n \n   if (!var->is_in_heap())\n     {\n@@ -638,13 +637,17 @@ Assignment_statement::do_check_types(Gogo*)\n Bstatement*\n Assignment_statement::do_get_backend(Translate_context* context)\n {\n-  tree rhs_tree = this->rhs_->get_tree(context);\n   if (this->lhs_->is_sink_expression())\n-    return context->backend()->expression_statement(tree_to_expr(rhs_tree));\n+    {\n+      tree rhs_tree = this->rhs_->get_tree(context);\n+      return context->backend()->expression_statement(tree_to_expr(rhs_tree));\n+    }\n+\n   tree lhs_tree = this->lhs_->get_tree(context);\n-  rhs_tree = Expression::convert_for_assignment(context, this->lhs_->type(),\n-\t\t\t\t\t\tthis->rhs_->type(), rhs_tree,\n-\t\t\t\t\t\tthis->location());\n+  Expression* rhs =\n+      Expression::convert_for_assignment(context->gogo(), this->lhs_->type(),\n+                                         this->rhs_, this->location());\n+  tree rhs_tree = rhs->get_tree(context);\n   return context->backend()->assignment_statement(tree_to_expr(lhs_tree),\n \t\t\t\t\t\t  tree_to_expr(rhs_tree),\n \t\t\t\t\t\t  this->location());\n@@ -2187,7 +2190,7 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n \t\t\t\t\t      location);\n \n   // Allocate the initialized struct on the heap.\n-  constructor = Expression::make_heap_composite(constructor, location);\n+  constructor = Expression::make_heap_expression(constructor, location);\n \n   // Look up the thunk.\n   Named_object* named_thunk = gogo->lookup(thunk_name, NULL);"}, {"sha": "91a535f01c8c50d6fbd5b6b680ff40962fbbd061", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 17, "deletions": 52, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -3075,34 +3075,6 @@ String_type::do_get_backend(Gogo* gogo)\n   return backend_string_type;\n }\n \n-// Return a tree for the length of STRING.\n-\n-tree\n-String_type::length_tree(Gogo*, tree string)\n-{\n-  tree string_type = TREE_TYPE(string);\n-  go_assert(TREE_CODE(string_type) == RECORD_TYPE);\n-  tree length_field = DECL_CHAIN(TYPE_FIELDS(string_type));\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(length_field)),\n-\t\t    \"__length\") == 0);\n-  return fold_build3(COMPONENT_REF, TREE_TYPE(length_field), string,\n-\t\t     length_field, NULL_TREE);\n-}\n-\n-// Return a tree for a pointer to the bytes of STRING.\n-\n-tree\n-String_type::bytes_tree(Gogo*, tree string)\n-{\n-  tree string_type = TREE_TYPE(string);\n-  go_assert(TREE_CODE(string_type) == RECORD_TYPE);\n-  tree bytes_field = TYPE_FIELDS(string_type);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(bytes_field)),\n-\t\t    \"__data\") == 0);\n-  return fold_build3(COMPONENT_REF, TREE_TYPE(bytes_field), string,\n-\t\t     bytes_field, NULL_TREE);\n-}\n-\n // The type descriptor for the string type.\n \n Expression*\n@@ -4916,9 +4888,8 @@ Struct_type::method_function(const std::string& name, bool* is_ambiguous) const\n // the interface INTERFACE.  IS_POINTER is true if this is for a\n // pointer to THIS.\n \n-tree\n-Struct_type::interface_method_table(Gogo* gogo,\n-\t\t\t\t    const Interface_type* interface,\n+Expression*\n+Struct_type::interface_method_table(Interface_type* interface,\n \t\t\t\t    bool is_pointer)\n {\n   std::pair<Struct_type*, Struct_type::Struct_method_table_pair*>\n@@ -4937,7 +4908,7 @@ Struct_type::interface_method_table(Gogo* gogo,\n       ins.first->second = smtp;\n     }\n \n-  return Type::interface_method_table(gogo, this, interface, is_pointer,\n+  return Type::interface_method_table(this, interface, is_pointer,\n \t\t\t\t      &smtp->first, &smtp->second);\n }\n \n@@ -8198,13 +8169,12 @@ Named_type::method_function(const std::string& name, bool* is_ambiguous) const\n // the interface INTERFACE.  IS_POINTER is true if this is for a\n // pointer to THIS.\n \n-tree\n-Named_type::interface_method_table(Gogo* gogo, const Interface_type* interface,\n-\t\t\t\t   bool is_pointer)\n+Expression*\n+Named_type::interface_method_table(Interface_type* interface, bool is_pointer)\n {\n-  return Type::interface_method_table(gogo, this, interface, is_pointer,\n-\t\t\t\t      &this->interface_method_tables_,\n-\t\t\t\t      &this->pointer_interface_method_tables_);\n+  return Type::interface_method_table(this, interface, is_pointer,\n+                                      &this->interface_method_tables_,\n+                                      &this->pointer_interface_method_tables_);\n }\n \n // Return whether a named type has any hidden fields.\n@@ -9385,9 +9355,9 @@ Type::method_function(const Methods* methods, const std::string& name,\n // Return a pointer to the interface method table for TYPE for the\n // interface INTERFACE.\n \n-tree\n-Type::interface_method_table(Gogo* gogo, Type* type,\n-\t\t\t     const Interface_type *interface,\n+Expression*\n+Type::interface_method_table(Type* type,\n+\t\t\t     Interface_type *interface,\n \t\t\t     bool is_pointer,\n \t\t\t     Interface_method_tables** method_tables,\n \t\t\t     Interface_method_tables** pointer_tables)\n@@ -9399,23 +9369,18 @@ Type::interface_method_table(Gogo* gogo, Type* type,\n   if (*pimt == NULL)\n     *pimt = new Interface_method_tables(5);\n \n-  std::pair<const Interface_type*, tree> val(interface, NULL_TREE);\n+  std::pair<Interface_type*, Expression*> val(interface, NULL);\n   std::pair<Interface_method_tables::iterator, bool> ins = (*pimt)->insert(val);\n \n+  Location loc = Linemap::predeclared_location();\n   if (ins.second)\n     {\n       // This is a new entry in the hash table.\n-      go_assert(ins.first->second == NULL_TREE);\n-      ins.first->second = gogo->interface_method_table_for_type(interface,\n-\t\t\t\t\t\t\t\ttype,\n-\t\t\t\t\t\t\t\tis_pointer);\n+      go_assert(ins.first->second == NULL);\n+      ins.first->second =\n+\tExpression::make_interface_mtable_ref(interface, type, is_pointer, loc);\n     }\n-\n-  tree decl = ins.first->second;\n-  if (decl == error_mark_node)\n-    return error_mark_node;\n-  go_assert(decl != NULL_TREE && TREE_CODE(decl) == VAR_DECL);\n-  return build_fold_addr_expr(decl);\n+  return Expression::make_unary(OPERATOR_AND, ins.first->second, loc);\n }\n \n // Look for field or method NAME for TYPE.  Return an Expression for"}, {"sha": "d2ca1bf27fb3ceca658e0939b69d1726fca86ca9", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -1019,14 +1019,14 @@ class Type\n \n   // A mapping from interfaces to the associated interface method\n   // tables for this type.  This maps to a decl.\n-  typedef Unordered_map_hash(const Interface_type*, tree, Type_hash_identical,\n+  typedef Unordered_map_hash(Interface_type*, Expression*, Type_hash_identical,\n \t\t\t     Type_identical) Interface_method_tables;\n \n   // Return a pointer to the interface method table for TYPE for the\n   // interface INTERFACE.\n-  static tree\n-  interface_method_table(Gogo* gogo, Type* type,\n-\t\t\t const Interface_type *interface, bool is_pointer,\n+  static Expression*\n+  interface_method_table(Type* type,\n+\t\t\t Interface_type *interface, bool is_pointer,\n \t\t\t Interface_method_tables** method_tables,\n \t\t\t Interface_method_tables** pointer_tables);\n \n@@ -1688,14 +1688,6 @@ class String_type : public Type\n     : Type(TYPE_STRING)\n   { }\n \n-  // Return a tree for the length of STRING.\n-  static tree\n-  length_tree(Gogo*, tree string);\n-\n-  // Return a tree which points to the bytes of STRING.\n-  static tree\n-  bytes_tree(Gogo*, tree string);\n-\n  protected:\n   bool\n   do_has_pointer() const\n@@ -2205,9 +2197,8 @@ class Struct_type : public Type\n   // the interface INTERFACE.  If IS_POINTER is true, set the type\n   // descriptor to a pointer to this type, otherwise set it to this\n   // type.\n-  tree\n-  interface_method_table(Gogo*, const Interface_type* interface,\n-\t\t\t bool is_pointer);\n+  Expression*\n+  interface_method_table(Interface_type* interface, bool is_pointer);\n \n   // Traverse just the field types of a struct type.\n   int\n@@ -2946,9 +2937,8 @@ class Named_type : public Type\n   // the interface INTERFACE.  If IS_POINTER is true, set the type\n   // descriptor to a pointer to this type, otherwise set it to this\n   // type.\n-  tree\n-  interface_method_table(Gogo*, const Interface_type* interface,\n-\t\t\t bool is_pointer);\n+  Expression*\n+  interface_method_table(Interface_type* interface, bool is_pointer);\n \n   // Whether this type has any hidden fields.\n   bool"}, {"sha": "38a2aafc7753f18b782e1c55d060b29f6db45855", "filename": "libgo/runtime/chan.c", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7035307e8f5291aa613c07f49f899444b9e65c80/libgo%2Fruntime%2Fchan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7035307e8f5291aa613c07f49f899444b9e65c80/libgo%2Fruntime%2Fchan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.c?ref=7035307e8f5291aa613c07f49f899444b9e65c80", "patch": "@@ -483,31 +483,10 @@ __go_send_big(ChanType *t, Hchan* c, byte* p)\n \truntime_chansend(t, c, p, nil, runtime_getcallerpc(&t));\n }\n \n-// The compiler generates a call to __go_receive_small to receive a\n-// value 8 bytes or smaller.\n-uint64\n-__go_receive_small(ChanType *t, Hchan* c)\n-{\n-\tunion {\n-\t\tbyte b[sizeof(uint64)];\n-\t\tuint64 v;\n-\t} u;\n-\tbyte *p;\n-\n-\tu.v = 0;\n-#ifndef WORDS_BIGENDIAN\n-\tp = u.b;\n-#else\n-\tp = u.b + sizeof(uint64) - t->__element_type->__size;\n-#endif\n-\truntime_chanrecv(t, c, p, nil, nil);\n-\treturn u.v;\n-}\n-\n-// The compiler generates a call to __go_receive_big to receive a\n-// value larger than 8 bytes.\n+// The compiler generates a call to __go_receive to receive a\n+// value from a channel.\n void\n-__go_receive_big(ChanType *t, Hchan* c, byte* p)\n+__go_receive(ChanType *t, Hchan* c, byte* p)\n {\n \truntime_chanrecv(t, c, p, nil, nil);\n }"}]}