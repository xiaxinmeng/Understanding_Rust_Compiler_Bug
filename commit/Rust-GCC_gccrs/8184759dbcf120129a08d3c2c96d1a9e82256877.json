{"sha": "8184759dbcf120129a08d3c2c96d1a9e82256877", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE4NDc1OWRiY2YxMjAxMjlhMDhkM2MyYzk2ZDFhOWU4MjI1Njg3Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-28T15:30:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-28T15:30:22Z"}, "message": "tree-ssa-dom.c (vrp_element_p): Define.\n\n\t* tree-ssa-dom.c (vrp_element_p): Define.\n\t(vrp_hash_elt): Change the type of records to\n\tVEC(vrp_element_p,heap).\n\t(vrp_free): New.\n\t(tree_ssa_dominator_optimize): Pass vrp_free to htab_create.\n\tUpdate uses of VRP records.\n\t(simplify_cond_and_lookup_avail_expr, record_range): Update\n\tuses of VRP records.\n\nFrom-SVN: r100293", "tree": {"sha": "30d6cd3e874cef793fb77f68edac9e8a6ecafa55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30d6cd3e874cef793fb77f68edac9e8a6ecafa55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8184759dbcf120129a08d3c2c96d1a9e82256877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8184759dbcf120129a08d3c2c96d1a9e82256877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8184759dbcf120129a08d3c2c96d1a9e82256877", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8184759dbcf120129a08d3c2c96d1a9e82256877/comments", "author": null, "committer": null, "parents": [{"sha": "ddcf783b5977764f654fb6e9f754265478acf2f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddcf783b5977764f654fb6e9f754265478acf2f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddcf783b5977764f654fb6e9f754265478acf2f6"}], "stats": {"total": 66, "additions": 44, "deletions": 22}, "files": [{"sha": "f046e635712f6f80e31faf428cff44278188abe3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8184759dbcf120129a08d3c2c96d1a9e82256877/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8184759dbcf120129a08d3c2c96d1a9e82256877/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8184759dbcf120129a08d3c2c96d1a9e82256877", "patch": "@@ -1,3 +1,14 @@\n+2005-05-28  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-dom.c (vrp_element_p): Define.\n+\t(vrp_hash_elt): Change the type of records to\n+\tVEC(vrp_element_p,heap).\n+\t(vrp_free): New.\n+\t(tree_ssa_dominator_optimize): Pass vrp_free to htab_create.\n+\tUpdate uses of VRP records.\n+\t(simplify_cond_and_lookup_avail_expr, record_range): Update\n+\tuses of VRP records.\n+\n 2005-05-27  Ian Lance Taylor  <ian@airs.com>\n \n \t* c-decl.c (add_stmt): Add C frontend specific version."}, {"sha": "dc546d45fafb030197ef2f8b5624568b6688bcec", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8184759dbcf120129a08d3c2c96d1a9e82256877/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8184759dbcf120129a08d3c2c96d1a9e82256877/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=8184759dbcf120129a08d3c2c96d1a9e82256877", "patch": "@@ -228,12 +228,17 @@ struct vrp_element\n    with useful information is very low.  */\n static htab_t vrp_data;\n \n+typedef struct vrp_element *vrp_element_p;\n+\n+DEF_VEC_P(vrp_element_p);\n+DEF_VEC_ALLOC_P(vrp_element_p,heap);\n+\n /* An entry in the VRP_DATA hash table.  We record the variable and a\n    varray of VRP_ELEMENT records associated with that variable.  */\n struct vrp_hash_elt\n {\n   tree var;\n-  varray_type records;\n+  VEC(vrp_element_p,heap) *records;\n };\n \n /* Array of variables which have their values constrained by operations\n@@ -350,6 +355,18 @@ free_all_edge_infos (void)\n     }\n }\n \n+/* Free an instance of vrp_hash_elt.  */\n+\n+static void\n+vrp_free (void *data)\n+{\n+  struct vrp_hash_elt *elt = data;\n+  struct VEC(vrp_element_p,heap) **vrp_elt = &elt->records;\n+\n+  VEC_free (vrp_element_p, heap, *vrp_elt);\n+  free (elt);\n+}\n+\n /* Jump threading, redundancy elimination and const/copy propagation. \n \n    This pass may expose new symbols that need to be renamed into SSA.  For\n@@ -367,7 +384,8 @@ tree_ssa_dominator_optimize (void)\n \n   /* Create our hash tables.  */\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n-  vrp_data = htab_create (ceil_log2 (num_ssa_names), vrp_hash, vrp_eq, free);\n+  vrp_data = htab_create (ceil_log2 (num_ssa_names), vrp_hash, vrp_eq,\n+\t\t\t  vrp_free);\n   avail_exprs_stack = VEC_alloc (tree, heap, 20);\n   const_and_copies_stack = VEC_alloc (tree, heap, 20);\n   nonzero_vars_stack = VEC_alloc (tree, heap, 20);\n@@ -1116,7 +1134,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t the array backwards popping off records associated with our\n \t block.  Once we hit a record not associated with our block\n \t we are done.  */\n-      varray_type var_vrp_records;\n+      VEC(vrp_element_p,heap) **var_vrp_records;\n \n       if (var == NULL)\n \tbreak;\n@@ -1127,17 +1145,17 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n       slot = htab_find_slot (vrp_data, &vrp_hash_elt, NO_INSERT);\n \n       vrp_hash_elt_p = (struct vrp_hash_elt *) *slot;\n-      var_vrp_records = vrp_hash_elt_p->records;\n+      var_vrp_records = &vrp_hash_elt_p->records;\n \n-      while (VARRAY_ACTIVE_SIZE (var_vrp_records) > 0)\n+      while (VEC_length (vrp_element_p, *var_vrp_records) > 0)\n \t{\n \t  struct vrp_element *element\n-\t    = (struct vrp_element *)VARRAY_TOP_GENERIC_PTR (var_vrp_records);\n+\t    = VEC_last (vrp_element_p, *var_vrp_records);\n \n \t  if (element->bb != bb)\n \t    break;\n   \n-\t  VARRAY_POP (var_vrp_records);\n+\t  VEC_pop (vrp_element_p, *var_vrp_records);\n \t}\n     }\n \n@@ -2041,7 +2059,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t  int limit;\n \t  tree low, high, cond_low, cond_high;\n \t  int lowequal, highequal, swapped, no_overlap, subset, cond_inverted;\n-\t  varray_type vrp_records;\n+\t  VEC(vrp_element_p,heap) **vrp_records;\n \t  struct vrp_element *element;\n \t  struct vrp_hash_elt vrp_hash_elt, *vrp_hash_elt_p;\n \t  void **slot;\n@@ -2094,11 +2112,9 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t    return NULL;\n \n \t  vrp_hash_elt_p = (struct vrp_hash_elt *) *slot;\n-\t  vrp_records = vrp_hash_elt_p->records;\n-\t  if (vrp_records == NULL)\n-\t    return NULL;\n+\t  vrp_records = &vrp_hash_elt_p->records;\n \n-\t  limit = VARRAY_ACTIVE_SIZE (vrp_records);\n+\t  limit = VEC_length (vrp_element_p, *vrp_records);\n \n \t  /* If we have no value range records for this variable, or we are\n \t     unable to extract a range for this condition, then there is\n@@ -2130,8 +2146,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t     conditional into the current range. \n \n \t     These properties also help us avoid unnecessary work.  */\n-\t   element\n-\t     = (struct vrp_element *)VARRAY_GENERIC_PTR (vrp_records, limit - 1);\n+\t   element = VEC_last (vrp_element_p, *vrp_records);\n \n \t  if (element->high && element->low)\n \t    {\n@@ -2170,8 +2185,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t\t{\n \t\t  /* Get the high/low value from the previous element.  */\n \t\t  struct vrp_element *prev\n-\t\t    = (struct vrp_element *)VARRAY_GENERIC_PTR (vrp_records,\n-\t\t\t\t\t\t\t\tlimit - 2);\n+\t\t    = VEC_index (vrp_element_p, *vrp_records, limit - 2);\n \t\t  low = prev->low;\n \t\t  high = prev->high;\n \n@@ -3311,7 +3325,7 @@ record_range (tree cond, basic_block bb)\n     {\n       struct vrp_hash_elt *vrp_hash_elt;\n       struct vrp_element *element;\n-      varray_type *vrp_records_p;\n+      VEC(vrp_element_p,heap) **vrp_records_p;\n       void **slot;\n \n \n@@ -3323,7 +3337,7 @@ record_range (tree cond, basic_block bb)\n       if (*slot == NULL)\n \t*slot = (void *) vrp_hash_elt;\n       else\n-\tfree (vrp_hash_elt);\n+\tvrp_free (vrp_hash_elt);\n \n       vrp_hash_elt = (struct vrp_hash_elt *) *slot;\n       vrp_records_p = &vrp_hash_elt->records;\n@@ -3334,10 +3348,7 @@ record_range (tree cond, basic_block bb)\n       element->cond = cond;\n       element->bb = bb;\n \n-      if (*vrp_records_p == NULL)\n-\tVARRAY_GENERIC_PTR_INIT (*vrp_records_p, 2, \"vrp records\");\n-      \n-      VARRAY_PUSH_GENERIC_PTR (*vrp_records_p, element);\n+      VEC_safe_push (vrp_element_p, heap, *vrp_records_p, element);\n       VEC_safe_push (tree, heap, vrp_variables_stack, TREE_OPERAND (cond, 0));\n     }\n }"}]}