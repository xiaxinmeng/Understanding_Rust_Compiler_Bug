{"sha": "362db0b23d017f8c40517507ee453802e5662814", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYyZGIwYjIzZDAxN2Y4YzQwNTE3NTA3ZWU0NTM4MDJlNTY2MjgxNA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2013-08-13T19:43:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-08-13T19:43:47Z"}, "message": "trans.c (Handled_Sequence_Of_Statements_to_gnu): If there is no End_Label...\n\n\t* gcc-interface/trans.c (Handled_Sequence_Of_Statements_to_gnu): If\n\tthere is no End_Label, attach cleanup actions to the sloc of the HSS\n\tnode instead.\n\t(Exception_Handler_to_gnu_zcx): Associate cleanup actions with the sloc\n\tof the handler itself.\n\t(add_cleanup): Clear column information in sloc of cleanup actions.\n\t(Sloc_to_locus1): New static function.\n\t(Sloc_to_locus): Call it.\n\t(set_expr_location_from_node1): New static function.\n\t(set_expr_location_from_node): Call it.\n\nFrom-SVN: r201702", "tree": {"sha": "8b11bc148fdce20108a72848c453f3ddce69a082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b11bc148fdce20108a72848c453f3ddce69a082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/362db0b23d017f8c40517507ee453802e5662814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362db0b23d017f8c40517507ee453802e5662814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/362db0b23d017f8c40517507ee453802e5662814", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/362db0b23d017f8c40517507ee453802e5662814/comments", "author": null, "committer": null, "parents": [{"sha": "8ec9249b2a85aba9f44435fbf37ddbcb4d186047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec9249b2a85aba9f44435fbf37ddbcb4d186047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ec9249b2a85aba9f44435fbf37ddbcb4d186047"}], "stats": {"total": 75, "additions": 59, "deletions": 16}, "files": [{"sha": "65481468941b43515f3cd3cdd23f4209010f936a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=362db0b23d017f8c40517507ee453802e5662814", "patch": "@@ -1,3 +1,16 @@\n+2013-08-13  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gcc-interface/trans.c (Handled_Sequence_Of_Statements_to_gnu): If\n+\tthere is no End_Label, attach cleanup actions to the sloc of the HSS\n+\tnode instead.\n+\t(Exception_Handler_to_gnu_zcx): Associate cleanup actions with the sloc\n+\tof the handler itself.\n+\t(add_cleanup): Clear column information in sloc of cleanup actions.\n+\t(Sloc_to_locus1): New static function.\n+\t(Sloc_to_locus): Call it.\n+\t(set_expr_location_from_node1): New static function.\n+\t(set_expr_location_from_node): Call it.\n+\n 2013-08-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Call_to_gnu): Deal with specific conditional"}, {"sha": "d2f73561d7c03f41e1c9f08158b142d8aab5c1a6", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=362db0b23d017f8c40517507ee453802e5662814", "patch": "@@ -257,6 +257,8 @@ static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static void validate_unchecked_conversion (Node_Id);\n static tree maybe_implicit_deref (tree);\n static void set_expr_location_from_node (tree, Node_Id);\n+static void set_expr_location_from_node1 (tree, Node_Id, bool);\n+static bool Sloc_to_locus1 (Source_Ptr, location_t *, bool);\n static bool set_end_locus_from_node (tree, Node_Id);\n static void set_gnu_expr_location_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, bool, bool, bool);\n@@ -4471,6 +4473,10 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n   tree gnu_result;\n   tree gnu_expr;\n   Node_Id gnat_temp;\n+  /* Node providing the sloc for the cleanup actions.  */\n+  Node_Id gnat_cleanup_loc_node = (Present (End_Label (gnat_node)) ?\n+                                   End_Label (gnat_node) :\n+                                   gnat_node);\n \n   /* The GCC exception handling mechanism can handle both ZCX and SJLJ schemes\n      and we have our own SJLJ mechanism.  To call the GCC mechanism, we call\n@@ -4520,15 +4526,15 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \n       /* When we exit this block, restore the saved value.  */\n       add_cleanup (build_call_n_expr (set_jmpbuf_decl, 1, gnu_jmpsave_decl),\n-\t\t   End_Label (gnat_node));\n+\t\t   gnat_cleanup_loc_node);\n     }\n \n   /* If we are to call a function when exiting this block, add a cleanup\n      to the binding level we made above.  Note that add_cleanup is FIFO\n      so we must register this cleanup after the EH cleanup just above.  */\n   if (at_end)\n     add_cleanup (build_call_n_expr (gnat_to_gnu (At_End_Proc (gnat_node)), 0),\n-\t\t End_Label (gnat_node));\n+\t\t gnat_cleanup_loc_node);\n \n   /* Now build the tree for the declarations and statements inside this block.\n      If this is SJLJ, set our jmp_buf as the current buffer.  */\n@@ -4641,14 +4647,18 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       /* Now make the TRY_CATCH_EXPR for the block.  */\n       gnu_result = build2 (TRY_CATCH_EXPR, void_type_node,\n \t\t\t   gnu_inner_block, gnu_handlers);\n-      /* Set a location.  We need to find a uniq location for the dispatching\n+      /* Set a location.  We need to find a unique location for the dispatching\n \t code, otherwise we can get coverage or debugging issues.  Try with\n \t the location of the end label.  */\n       if (Present (End_Label (gnat_node))\n \t  && Sloc_to_locus (Sloc (End_Label (gnat_node)), &locus))\n \tSET_EXPR_LOCATION (gnu_result, locus);\n       else\n-\tset_expr_location_from_node (gnu_result, gnat_node);\n+        /* Clear column information so that the exception handler of an\n+           implicit transient block does not incorrectly inherit the slocs\n+           of a decision, which would otherwise confuse control flow based\n+           coverage analysis tools.  */\n+\tset_expr_location_from_node1 (gnu_result, gnat_node, True);\n     }\n   else\n     gnu_result = gnu_inner_block;\n@@ -4843,9 +4853,10 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n   add_stmt_with_node (build_call_n_expr (begin_handler_decl, 1,\n \t\t\t\t\t gnu_incoming_exc_ptr),\n \t\t      gnat_node);\n-  /* ??? We don't seem to have an End_Label at hand to set the location.  */\n+  /* We don't have an End_Label at hand to set the location of the cleanup\n+     actions, so we use that of the exception handler itself instead.  */\n   add_cleanup (build_call_n_expr (end_handler_decl, 1, gnu_incoming_exc_ptr),\n-\t       Empty);\n+\t       gnat_node);\n   add_stmt_list (Statements (gnat_node));\n   gnat_poplevel ();\n \n@@ -7397,13 +7408,15 @@ mark_visited (tree t)\n }\n \n /* Add GNU_CLEANUP, a cleanup action, to the current code group and\n-   set its location to that of GNAT_NODE if present.  */\n+   set its location to that of GNAT_NODE if present, but with column info\n+   cleared so that conditional branches generated as part of the cleanup\n+   code do not interfere with coverage analysis tools.  */\n \n static void\n add_cleanup (tree gnu_cleanup, Node_Id gnat_node)\n {\n   if (Present (gnat_node))\n-    set_expr_location_from_node (gnu_cleanup, gnat_node);\n+    set_expr_location_from_node1 (gnu_cleanup, gnat_node, True);\n   append_to_statement_list (gnu_cleanup, &current_stmt_group->cleanups);\n }\n \n@@ -9018,10 +9031,11 @@ maybe_implicit_deref (tree exp)\n \f\n /* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n    location and false if it doesn't.  In the former case, set the Gigi global\n-   variable REF_FILENAME to the simple debug file name as given by sinput.  */\n+   variable REF_FILENAME to the simple debug file name as given by sinput.\n+   If clear_column is True, set column information to 0.  */\n \n-bool\n-Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n+static bool\n+Sloc_to_locus1 (Source_Ptr Sloc, location_t *locus, bool clear_column)\n {\n   if (Sloc == No_Location)\n     return false;\n@@ -9035,7 +9049,7 @@ Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n     {\n       Source_File_Index file = Get_Source_File_Index (Sloc);\n       Logical_Line_Number line = Get_Logical_Line_Number (Sloc);\n-      Column_Number column = Get_Column_Number (Sloc);\n+      Column_Number column = (clear_column ? 0 : Get_Column_Number (Sloc));\n       struct line_map *map = LINEMAPS_ORDINARY_MAP_AT (line_table, file - 1);\n \n       /* We can have zero if pragma Source_Reference is in effect.  */\n@@ -9054,20 +9068,36 @@ Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n   return true;\n }\n \n+/* Similar to the above, not clearing the column information.  */\n+\n+bool\n+Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n+{\n+  return Sloc_to_locus1 (Sloc, locus, False);\n+}\n+\n /* Similar to set_expr_location, but start with the Sloc of GNAT_NODE and\n    don't do anything if it doesn't correspond to a source location.  */\n \n static void\n-set_expr_location_from_node (tree node, Node_Id gnat_node)\n+set_expr_location_from_node1 (tree node, Node_Id gnat_node, bool clear_column)\n {\n   location_t locus;\n \n-  if (!Sloc_to_locus (Sloc (gnat_node), &locus))\n+  if (!Sloc_to_locus1 (Sloc (gnat_node), &locus, clear_column))\n     return;\n \n   SET_EXPR_LOCATION (node, locus);\n }\n \n+/* Similar to the above, not clearing the column information.  */\n+\n+static void\n+set_expr_location_from_node (tree node, Node_Id gnat_node)\n+{\n+  set_expr_location_from_node1 (node, gnat_node, False);\n+}\n+\n /* More elaborate version of set_expr_location_from_node to be used in more\n    general contexts, for example the result of the translation of a generic\n    GNAT node.  */"}, {"sha": "e7b318fa9bfedb960f26d7d6b8a25d8c56b9a1f2", "filename": "gcc/ada/sigtramp-ppcvxw.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2Fsigtramp-ppcvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2Fsigtramp-ppcvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-ppcvxw.c?ref=362db0b23d017f8c40517507ee453802e5662814", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                         Asm Implementation File                          *\n  *                                                                          *\n- *         Copyright (C) 2011-2012, Free Software Foundation, Inc.          *\n+ *         Copyright (C) 2011-2013, Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "8672ca372b67846ff0ef72f08975b6757edb0515", "filename": "gcc/ada/terminals.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2Fterminals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/362db0b23d017f8c40517507ee453802e5662814/gcc%2Fada%2Fterminals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fterminals.c?ref=362db0b23d017f8c40517507ee453802e5662814", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *                     Copyright (C) 2008-2012, AdaCore                     *\n+ *                     Copyright (C) 2008-2013, AdaCore                     *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}]}