{"sha": "14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyMTJkYzQyMmVkMDlmODMyNGJiZmQxZGVjNjYyY2JiMmZkYmUwZQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2021-05-17T07:35:25Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-07T16:23:17Z"}, "message": "[Ada] Implement new legality checks specified by AI12-0412\n\ngcc/ada/\n\n\t* freeze.adb (Check_Inherited_Conditions): Setting of Ekind,\n\tLSP_Subprogram, and Is_Wrapper needs to happen for null\n\tprocedures as well as other wrapper cases, so the code is moved\n\tfrom the else part in front of the if statement.  (Fixes a\n\tlatent bug encountered while working on this set of changes.)\n\t* sem_attr.adb (Resolve_Attribute): Report an error for the case\n\tof an Access attribute applied to a primitive of an abstract\n\ttype when the primitive has any nonstatic Pre'Class or\n\tPost'Class expressions.\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Report an error for\n\tthe case of a actual subprogram associated with a nonabstract\n\tformal subprogram when the actual is a primitive of an abstract\n\ttype and the primitive has any nonstatic Pre'Class or Post'Class\n\texpressions.\n\t* sem_disp.adb (Check_Dispatching_Context): Remove special\n\ttesting for null procedures, and replace it with a relaxed test\n\tthat avoids getting an error about illegal calls to abstract\n\tsubprograms in cases where RM 6.1.1(7/5) applies in\n\tPre/Post'Class aspects. Also, remove special test for\n\tPostcondition, which seems to be unnecessary, update associated\n\tcomments, and fix a typo in one comment.\n\t(Check_Dispatching_Call): Remove an unneeded return statement,\n\tand report an error for the case of a nondispatching call to a\n\tnonabstract subprogram of an abstract type where the subprogram\n\thas nonstatic Pre/Post'Class aspects.\n\t* sem_util.ads\n\t(Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post): New function.\n\t(In_Pre_Post_Condition): Add a flag formal Class_Wide_Only,\n\tdefaulted to False, for indicating whether the function should\n\tonly test for the node being within class-wide pre- and\n\tpostconditions.\n\t* sem_util.adb\n\t(Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post): New function\n\tto determine whether a subprogram is a primitive of an abstract\n\ttype where the primitive has class-wide Pre/Post'Class aspects\n\tspecified with nonstatic expressions.\n\t(In_Pre_Post_Condition): Extend testing to account for the new\n\tformal Class_Wide_Only.", "tree": {"sha": "af2dbac374746f603bbb0e98b8636057ad5ed3b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af2dbac374746f603bbb0e98b8636057ad5ed3b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5be1e443cef81f458545f5dae1a91860ca1ae71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5be1e443cef81f458545f5dae1a91860ca1ae71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5be1e443cef81f458545f5dae1a91860ca1ae71"}], "stats": {"total": 205, "additions": 159, "deletions": 46}, "files": [{"sha": "37964337c3ae338268d36f9ea742f551772ebefc", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "patch": "@@ -1671,6 +1671,12 @@ package body Freeze is\n                --  type declaration that generates inherited operation. For\n                --  a null procedure, the declaration implies a null body.\n \n+               --  Before insertion, do some minimal decoration of fields\n+\n+               Mutate_Ekind (New_Id, Ekind (Par_Prim));\n+               Set_LSP_Subprogram (New_Id, Par_Prim);\n+               Set_Is_Wrapper (New_Id);\n+\n                if Nkind (New_Spec) = N_Procedure_Specification\n                  and then Null_Present (New_Spec)\n                then\n@@ -1684,12 +1690,6 @@ package body Freeze is\n                     Build_Class_Wide_Clone_Call\n                       (Loc, Decls, Par_Prim, New_Spec);\n \n-                  --  Adding minimum decoration\n-\n-                  Mutate_Ekind (New_Id, Ekind (Par_Prim));\n-                  Set_LSP_Subprogram (New_Id, Par_Prim);\n-                  Set_Is_Wrapper (New_Id);\n-\n                   Insert_List_After_And_Analyze\n                     (Par_R, New_List (New_Decl, New_Body));\n "}, {"sha": "d1a91d8864ec46c7c583c50e1c64d5f9e44201f9", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "patch": "@@ -11499,6 +11499,25 @@ package body Sem_Attr is\n                Error_Msg_F (\"context requires a non-protected subprogram\", P);\n             end if;\n \n+            --  AI12-0412: The rule in RM 6.1.1(18.2/5) disallows applying\n+            --  attribute Access to a primitive of an abstract type when the\n+            --  primitive has any Pre'Class or Post'Class aspects specified\n+            --  with nonstatic expressions.\n+\n+            if Attr_Id = Attribute_Access\n+              and then Ekind (Btyp) in E_Access_Subprogram_Type\n+                                     | E_Anonymous_Access_Subprogram_Type\n+              and then Is_Entity_Name (P)\n+              and then Is_Dispatching_Operation (Entity (P))\n+              and then\n+                Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post (Entity (P))\n+            then\n+               Error_Msg_N\n+                 (\"attribute not allowed for primitive of abstract type with \"\n+                   & \"nonstatic class-wide pre/postconditions\",\n+                  N);\n+            end if;\n+\n             --  The context cannot be a pool-specific type, but this is a\n             --  legality rule, not a resolution rule, so it must be checked\n             --  separately, after possibly disambiguation (see AI-245)."}, {"sha": "78d2426610cdef34bcccc4b0a5675adfb6ceb2ff", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "patch": "@@ -3790,15 +3790,31 @@ package body Sem_Ch8 is\n             Set_Has_Delayed_Freeze (New_S, False);\n             Freeze_Before (N, New_S);\n \n-            --  An abstract subprogram is only allowed as an actual in the case\n-            --  where the formal subprogram is also abstract.\n-\n             if (Ekind (Old_S) = E_Procedure or else Ekind (Old_S) = E_Function)\n-              and then Is_Abstract_Subprogram (Old_S)\n               and then not Is_Abstract_Subprogram (Formal_Spec)\n             then\n-               Error_Msg_N\n-                 (\"abstract subprogram not allowed as generic actual\", Nam);\n+               --  An abstract subprogram is only allowed as an actual in the\n+               --  case where the formal subprogram is also abstract.\n+\n+               if Is_Abstract_Subprogram (Old_S) then\n+                  Error_Msg_N\n+                    (\"abstract subprogram not allowed as generic actual\", Nam);\n+               end if;\n+\n+               --  AI12-0412: A primitive of an abstract type with Pre'Class\n+               --  or Post'Class aspects specified with nonstatic expressions\n+               --  is not allowed as actual for a nonabstract formal subprogram\n+               --  (see RM 6.1.1(18.2/5).\n+\n+               if Is_Dispatching_Operation (Old_S)\n+                 and then\n+                   Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post (Old_S)\n+               then\n+                  Error_Msg_N\n+                    (\"primitive of abstract type with nonstatic class-wide \"\n+                      & \"pre/postconditions not allowed as actual\",\n+                     Nam);\n+               end if;\n             end if;\n          end if;\n "}, {"sha": "064e2b5da141c627890639c68e94e8a633a5775d", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "patch": "@@ -612,29 +612,32 @@ package body Sem_Disp is\n                Set_Entity (Name (N), Alias (Subp));\n                return;\n \n-            --  An obscure special case: a null procedure may have a class-\n-            --  wide pre/postcondition that includes a call to an abstract\n-            --  subp. Calls within the expression may not have been rewritten\n-            --  as dispatching calls yet, because the null body appears in\n-            --  the current declarative part. The expression will be properly\n-            --  rewritten/reanalyzed when the postcondition procedure is built.\n-\n-            --  Similarly, if this is a pre/postcondition for an abstract\n-            --  subprogram, it may call another abstract function which is\n-            --  a primitive of an abstract type. The call is non-dispatching\n-            --  but will be legal in overridings of the operation. However,\n-            --  if the call is tag-indeterminate we want to continue with\n-            --  with the error checking below, as this case is illegal even\n-            --  for abstract subprograms (see AI12-0170).\n-\n-            elsif (Is_Subprogram (Scop)\n-                    or else Chars (Scop) = Name_Postcondition)\n+            --  If this is a pre/postcondition for an abstract subprogram,\n+            --  it may call another abstract function that is a primitive\n+            --  of an abstract type. The call is nondispatching but will be\n+            --  legal in overridings of the operation. However, if the call\n+            --  is tag-indeterminate we want to continue with with the error\n+            --  checking below, as this case is illegal even for abstract\n+            --  subprograms (see AI12-0170).\n+\n+            --  Similarly, as per AI12-0412, a nonabstract subprogram may\n+            --  have a class-wide pre/postcondition that includes a call to\n+            --  an abstract primitive of the subprogram's controlling type.\n+            --  Certain operations (nondispatching calls, 'Access, use as\n+            --  a generic actual) applied to such a nonabstract subprogram\n+            --  are illegal in the case where the type is abstract (see\n+            --  RM 6.1.1(18.2/5)).\n+\n+            elsif Is_Subprogram (Scop)\n+              and then not Is_Tag_Indeterminate (N)\n+              and then In_Pre_Post_Condition (Call, Class_Wide_Only => True)\n+\n+              --  The tagged type associated with the called subprogram must be\n+              --  the same as that of the subprogram with a class-wide aspect.\n+\n+              and then Is_Dispatching_Operation (Scop)\n               and then\n-                ((Is_Abstract_Subprogram (Scop)\n-                   and then not Is_Tag_Indeterminate (N))\n-                  or else\n-                    (Nkind (Parent (Scop)) = N_Procedure_Specification\n-                      and then Null_Present (Parent (Scop))))\n+                Find_Dispatching_Type (Subp) = Find_Dispatching_Type (Scop)\n             then\n                null;\n \n@@ -663,7 +666,7 @@ package body Sem_Disp is\n                --  provides a tag to make the call dispatching. This requires\n                --  the call to be the actual in an enclosing call, and that\n                --  actual must be controlling. If the call is an operand of\n-               --  equality, the other operand must not ve abstract.\n+               --  equality, the other operand must not be abstract.\n \n                if not Is_Tagged_Type (Typ)\n                  and then not\n@@ -970,7 +973,6 @@ package body Sem_Disp is\n             end loop;\n \n             Check_Dispatching_Context (N);\n-            return;\n \n          elsif Nkind (Parent (N)) in N_Subexpr then\n             Check_Dispatching_Context (N);\n@@ -985,6 +987,23 @@ package body Sem_Disp is\n             return;\n          end if;\n \n+         --  If this is a nondispatching call to a nonabstract subprogram\n+         --  and the subprogram has any Pre'Class or Post'Class aspects with\n+         --  nonstatic values, then report an error. This is specified by\n+         --  RM 6.1.1(18.2/5) (by AI12-0412).\n+\n+         if No (Control)\n+           and then not Is_Abstract_Subprogram (Subp_Entity)\n+           and then\n+             Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post (Subp_Entity)\n+         then\n+            Error_Msg_N\n+              (\"nondispatching call to nonabstract subprogram of \"\n+                & \"abstract type with nonstatic class-wide \"\n+                & \"pre/postconditions\",\n+               N);\n+         end if;\n+\n       else\n          --  If dispatching on result, the enclosing call, if any, will\n          --  determine the controlling argument. Otherwise this is the"}, {"sha": "12e5aa8977594fe25e5dcc48116220a3067718d7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "patch": "@@ -13295,6 +13295,44 @@ package body Sem_Util is\n           and then Nkind (Node (First_Elmt (Constits))) = N_Null;\n    end Has_Null_Refinement;\n \n+   ------------------------------------------\n+   -- Has_Nonstatic_Class_Wide_Pre_Or_Post --\n+   ------------------------------------------\n+\n+   function Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post\n+     (Subp : Entity_Id) return Boolean\n+   is\n+      Disp_Type  : constant Entity_Id := Find_Dispatching_Type (Subp);\n+      Prag       : Node_Id;\n+      Pragma_Arg : Node_Id;\n+\n+   begin\n+      if Present (Disp_Type)\n+        and then Is_Abstract_Type (Disp_Type)\n+        and then Present (Contract (Subp))\n+      then\n+         Prag := Pre_Post_Conditions (Contract (Subp));\n+\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) in Name_Precondition | Name_Postcondition\n+              and then Class_Present (Prag)\n+            then\n+               Pragma_Arg :=\n+                 Nlists.First\n+                   (Pragma_Argument_Associations (Prag));\n+\n+               if not Is_Static_Expression (Expression (Pragma_Arg)) then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post;\n+\n    -------------------------------\n    -- Has_Overriding_Initialize --\n    -------------------------------\n@@ -14431,7 +14469,9 @@ package body Sem_Util is\n    -- In_Pre_Post_Condition --\n    ---------------------------\n \n-   function In_Pre_Post_Condition (N : Node_Id) return Boolean is\n+   function In_Pre_Post_Condition\n+     (N : Node_Id; Class_Wide_Only : Boolean := False) return Boolean\n+   is\n       Par     : Node_Id;\n       Prag    : Node_Id := Empty;\n       Prag_Id : Pragma_Id;\n@@ -14457,13 +14497,24 @@ package body Sem_Util is\n       if Present (Prag) then\n          Prag_Id := Get_Pragma_Id (Prag);\n \n-         return\n-           Prag_Id = Pragma_Post\n-             or else Prag_Id = Pragma_Post_Class\n-             or else Prag_Id = Pragma_Postcondition\n-             or else Prag_Id = Pragma_Pre\n-             or else Prag_Id = Pragma_Pre_Class\n-             or else Prag_Id = Pragma_Precondition;\n+         if Class_Wide_Only then\n+            return\n+              Prag_Id = Pragma_Post_Class\n+                or else Prag_Id = Pragma_Pre_Class\n+                or else (Class_Present (Prag)\n+                          and then (Prag_Id = Pragma_Post\n+                                     or else Prag_Id = Pragma_Postcondition\n+                                     or else Prag_Id = Pragma_Pre\n+                                     or else Prag_Id = Pragma_Precondition));\n+         else\n+            return\n+              Prag_Id = Pragma_Post\n+                or else Prag_Id = Pragma_Post_Class\n+                or else Prag_Id = Pragma_Postcondition\n+                or else Prag_Id = Pragma_Pre\n+                or else Prag_Id = Pragma_Pre_Class\n+                or else Prag_Id = Pragma_Precondition;\n+         end if;\n \n       --  Otherwise the node is not enclosed by a pre/postcondition pragma\n "}, {"sha": "fb8309f4a2bcfa8a4575288a1b428fa079c0920c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14212dc422ed09f8324bbfd1dec662cbb2fdbe0e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=14212dc422ed09f8324bbfd1dec662cbb2fdbe0e", "patch": "@@ -1516,6 +1516,12 @@ package Sem_Util is\n    --  integer for use in compile-time checking. Note: Level is restricted to\n    --  be non-dynamic.\n \n+   function Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post\n+     (Subp : Entity_Id) return Boolean;\n+   --  Return True if Subp is a primitive of an abstract type, where the\n+   --  primitive has a class-wide pre- or postcondition whose expression\n+   --  is nonstatic.\n+\n    function Has_Overriding_Initialize (T : Entity_Id) return Boolean;\n    --  Predicate to determine whether a controlled type has a user-defined\n    --  Initialize primitive (and, in Ada 2012, whether that primitive is\n@@ -1634,9 +1640,11 @@ package Sem_Util is\n    function In_Pragma_Expression (N : Node_Id; Nam : Name_Id) return Boolean;\n    --  Returns true if the expression N occurs within a pragma with name Nam\n \n-   function In_Pre_Post_Condition (N : Node_Id) return Boolean;\n+   function In_Pre_Post_Condition\n+     (N : Node_Id; Class_Wide_Only : Boolean := False) return Boolean;\n    --  Returns True if node N appears within a pre/postcondition pragma. Note\n-   --  the pragma Check equivalents are NOT considered.\n+   --  the pragma Check equivalents are NOT considered. If Class_Wide_Only is\n+   --  True, then tests for N appearing within a class-wide pre/postcondition.\n \n    function In_Quantified_Expression (N : Node_Id) return Boolean;\n    --  Returns true if the expression N occurs within a quantified expression"}]}