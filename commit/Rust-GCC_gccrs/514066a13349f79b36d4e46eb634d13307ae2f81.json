{"sha": "514066a13349f79b36d4e46eb634d13307ae2f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE0MDY2YTEzMzQ5Zjc5YjM2ZDRlNDZlYjYzNGQxMzMwN2FlMmY4MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-14T23:29:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-14T23:29:48Z"}, "message": "sh.c (sh_builtin_saveregs): Use get_varargs_alias_set.\n\n        * sh.c (sh_builtin_saveregs): Use get_varargs_alias_set.\n        (sh_build_va_list, sh_va_start, sh_va_arg): New.\n        * sh.h (BUILD_VA_LIST_TYPE): New.\n        (EXPAND_BUILTIN_VA_START, EXPAND_BUILTIN_VA_ARG): New.\n\nFrom-SVN: r29415", "tree": {"sha": "0bce71613860f8c27d895cbfd8ba2386c7c68fff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bce71613860f8c27d895cbfd8ba2386c7c68fff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/514066a13349f79b36d4e46eb634d13307ae2f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514066a13349f79b36d4e46eb634d13307ae2f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/514066a13349f79b36d4e46eb634d13307ae2f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514066a13349f79b36d4e46eb634d13307ae2f81/comments", "author": null, "committer": null, "parents": [{"sha": "5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d3f2bd5232e09d93e100f16c73ac1b0de44ff8d"}], "stats": {"total": 289, "additions": 280, "deletions": 9}, "files": [{"sha": "15274ae8b3908d6329aeac7fdcaede2eebc538e7", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 268, "deletions": 9, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514066a13349f79b36d4e46eb634d13307ae2f81/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514066a13349f79b36d4e46eb634d13307ae2f81/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=514066a13349f79b36d4e46eb634d13307ae2f81", "patch": "@@ -3889,25 +3889,26 @@ sh_builtin_saveregs ()\n   int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n   int ptrsize = GET_MODE_SIZE (Pmode);\n   rtx valist, regbuf, fpregs;\n-  int bufsize, regno;\n+  int bufsize, regno, alias_set;\n \n   /* Allocate block of memory for the regs. */\n   /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n      Or can assign_stack_local accept a 0 SIZE argument?  */\n   bufsize = (n_intregs * UNITS_PER_WORD) + (n_floatregs * UNITS_PER_WORD);\n \n   regbuf = assign_stack_local (BLKmode, bufsize, 0);\n-  MEM_SET_IN_STRUCT_P (regbuf, 1);\n+  alias_set = get_varargs_alias_set ();\n+  MEM_ALIAS_SET (regbuf) = alias_set;\n \n   /* Save int args.\n      This is optimized to only save the regs that are necessary.  Explicitly\n      named args need not be saved.  */\n   if (n_intregs > 0)\n     move_block_from_reg (BASE_ARG_REG (SImode) + first_intreg,\n-\t\t\t gen_rtx_MEM (BLKmode, \n-\t\t\t\t      plus_constant (XEXP (regbuf, 0),\n-\t\t\t\t\t\t     (n_floatregs\n-\t\t\t\t\t\t      * UNITS_PER_WORD))),\n+\t\t\t change_address (regbuf, BLKmode,\n+\t\t\t\t\t plus_constant (XEXP (regbuf, 0),\n+\t\t\t\t\t\t\t(n_floatregs\n+\t\t\t\t\t\t\t * UNITS_PER_WORD))), \n \t\t\t n_intregs, n_intregs * UNITS_PER_WORD);\n \n   /* Save float args.\n@@ -3924,34 +3925,292 @@ sh_builtin_saveregs ()\n \t\t\t GEN_INT (n_floatregs * UNITS_PER_WORD)));\n   if (TARGET_SH4)\n     {\n+      rtx mem;\n       for (regno = NPARM_REGS (DFmode) - 2; regno >= first_floatreg; regno -= 2)\n \t{\n \t  emit_insn (gen_addsi3 (fpregs, fpregs,\n \t\t\t\t GEN_INT (-2 * UNITS_PER_WORD)));\n-\t  emit_move_insn (gen_rtx (MEM, DFmode, fpregs),\n+\t  mem = gen_rtx_MEM (DFmode, fpregs);\n+\t  MEM_ALIAS_SET (mem) = alias_set;\n+\t  emit_move_insn (mem, \n \t\t\t  gen_rtx (REG, DFmode, BASE_ARG_REG (DFmode) + regno));\n \t}\n       regno = first_floatreg;\n       if (regno & 1)\n \t{\n \t  emit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n-\t  emit_move_insn (gen_rtx (MEM, SFmode, fpregs),\n+\t  mem = gen_rtx_MEM (SFmode, fpregs);\n+\t  MEM_ALIAS_SET (mem) = alias_set;\n+\t  emit_move_insn (mem,\n \t\t\t  gen_rtx (REG, SFmode, BASE_ARG_REG (SFmode) + regno\n \t\t\t\t\t\t- (TARGET_LITTLE_ENDIAN != 0)));\n \t}\n     }\n   else\n     for (regno = NPARM_REGS (SFmode) - 1; regno >= first_floatreg; regno--)\n       {\n+        rtx mem;\n \temit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n-\temit_move_insn (gen_rtx_MEM (SFmode, fpregs),\n+\tmem = gen_rtx_MEM (SFmode, fpregs);\n+\tMEM_ALIAS_SET (mem) = alias_set;\n+\temit_move_insn (mem,\n \t\t\tgen_rtx_REG (SFmode, BASE_ARG_REG (SFmode) + regno));\n       }\n \n   /* Return the address of the regbuf.  */\n   return XEXP (regbuf, 0);\n }\n \n+/* Define the `__builtin_va_list' type for the ABI.  */\n+\n+tree\n+sh_build_va_list ()\n+{\n+  tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n+  tree record;\n+\n+  if ((! TARGET_SH3E && ! TARGET_SH4) || TARGET_HITACHI)\n+    return ptr_type_node;\n+\n+  record = make_node (RECORD_TYPE);\n+\n+  f_next_o = build_decl (FIELD_DECL, get_identifier (\"__va_next_o\"),\n+\t\t\t ptr_type_node);\n+  f_next_o_limit = build_decl (FIELD_DECL,\n+\t\t\t       get_identifier (\"__va_next_o_limit\"),\n+\t\t\t       ptr_type_node);\n+  f_next_fp = build_decl (FIELD_DECL, get_identifier (\"__va_next_fp\"),\n+\t\t\t  ptr_type_node);\n+  f_next_fp_limit = build_decl (FIELD_DECL,\n+\t\t\t\tget_identifier (\"__va_next_fp_limit\"),\n+\t\t\t\tptr_type_node);\n+  f_next_stack = build_decl (FIELD_DECL, get_identifier (\"__va_next_stack\"),\n+\t\t\t     ptr_type_node);\n+\n+  DECL_FIELD_CONTEXT (f_next_o) = record;\n+  DECL_FIELD_CONTEXT (f_next_o_limit) = record;\n+  DECL_FIELD_CONTEXT (f_next_fp) = record;\n+  DECL_FIELD_CONTEXT (f_next_fp_limit) = record;\n+  DECL_FIELD_CONTEXT (f_next_stack) = record;\n+\n+  TYPE_FIELDS (record) = f_next_o;\n+  TREE_CHAIN (f_next_o) = f_next_o_limit;\n+  TREE_CHAIN (f_next_o_limit) = f_next_fp;\n+  TREE_CHAIN (f_next_fp) = f_next_fp_limit;\n+  TREE_CHAIN (f_next_fp_limit) = f_next_stack;\n+\n+  layout_type (record);\n+\n+  return record;\n+}\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+\n+void\n+sh_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg;\n+{\n+  tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n+  tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n+  tree t, u;\n+  int nfp, nint;\n+\n+  if ((! TARGET_SH3E && ! TARGET_SH4) || TARGET_HITACHI)\n+    {\n+      std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n+      return;\n+    }\n+\n+  f_next_o = TYPE_FIELDS (va_list_type_node);\n+  f_next_o_limit = TREE_CHAIN (f_next_o);\n+  f_next_fp = TREE_CHAIN (f_next_o_limit);\n+  f_next_fp_limit = TREE_CHAIN (f_next_fp);\n+  f_next_stack = TREE_CHAIN (f_next_fp_limit);\n+\n+  next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o);\n+  next_o_limit = build (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n+\t\t\tvalist, f_next_o_limit);\n+  next_fp = build (COMPONENT_REF, TREE_TYPE (f_next_fp), valist, f_next_fp);\n+  next_fp_limit = build (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n+\t\t\t valist, f_next_fp_limit);\n+  next_stack = build (COMPONENT_REF, TREE_TYPE (f_next_stack),\n+\t\t      valist, f_next_stack);\n+\n+  /* Call __builtin_saveregs.  */\n+  u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n+  t = build (MODIFY_EXPR, ptr_type_node, next_fp, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  nfp = current_function_args_info.arg_count[SH_ARG_FLOAT];\n+  if (nfp < 8)\n+    nfp = 8 - nfp;\n+  else\n+    nfp = 0;\n+  u = fold (build (PLUS_EXPR, ptr_type_node, u,\n+\t\t   build_int_2 (UNITS_PER_WORD * nfp, 0)));\n+  t = build (MODIFY_EXPR, ptr_type_node, next_fp_limit, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = build (MODIFY_EXPR, ptr_type_node, next_o, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  nint = current_function_args_info.arg_count[SH_ARG_INT];\n+  if (nint < 4)\n+    nint = 4 - nint;\n+  else\n+    nint = 0;\n+  u = fold (build (PLUS_EXPR, ptr_type_node, u,\n+\t\t   build_int_2 (UNITS_PER_WORD * nint, 0)));\n+  t = build (MODIFY_EXPR, ptr_type_node, next_o_limit, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  u = make_tree (ptr_type_node, nextarg);\n+  if (! stdarg_p && (nint == 0 || nfp == 0))\n+    {\n+      u = fold (build (PLUS_EXPR, ptr_type_node, u,\n+\t\t       build_int_2 (-UNITS_PER_WORD, -1)));\n+    }\n+  t = build (MODIFY_EXPR, ptr_type_node, next_stack, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+/* Implement `va_arg'.  */\n+\n+rtx\n+sh_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  HOST_WIDE_INT size, rsize;\n+  tree base, tmp, pptr_type_node;\n+  rtx addr_rtx, r;\n+\n+  size = int_size_in_bytes (type);\n+  rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n+  pptr_type_node = build_pointer_type (ptr_type_node);\n+\n+  if ((TARGET_SH3E || TARGET_SH4) && ! TARGET_HITACHI)\n+    {\n+      tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n+      tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n+      int pass_as_float;\n+      rtx lab_false, lab_over;\n+\n+      f_next_o = TYPE_FIELDS (va_list_type_node);\n+      f_next_o_limit = TREE_CHAIN (f_next_o);\n+      f_next_fp = TREE_CHAIN (f_next_o_limit);\n+      f_next_fp_limit = TREE_CHAIN (f_next_fp);\n+      f_next_stack = TREE_CHAIN (f_next_fp_limit);\n+\n+      next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o);\n+      next_o_limit = build (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n+\t\t\t    valist, f_next_o_limit);\n+      next_fp = build (COMPONENT_REF, TREE_TYPE (f_next_fp),\n+\t\t       valist, f_next_fp);\n+      next_fp_limit = build (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n+\t\t\t     valist, f_next_fp_limit);\n+      next_stack = build (COMPONENT_REF, TREE_TYPE (f_next_stack),\n+\t\t\t  valist, f_next_stack);\n+\n+      if (TARGET_SH4)\n+\t{\n+\t  pass_as_float = ((TREE_CODE (type) == REAL_TYPE && size <= 8)\n+\t\t\t   || (TREE_CODE (type) == COMPLEX_TYPE\n+\t\t\t       && TREE_CODE (TREE_TYPE (type)) == REAL_TYPE\n+\t\t\t       && size <= 16));\n+\t}\n+      else\n+\t{\n+\t  pass_as_float = (TREE_CODE (type) == REAL_TYPE && size == 4);\n+\t}\n+\n+      addr_rtx = gen_reg_rtx (Pmode);\n+      lab_false = gen_label_rtx ();\n+      lab_over = gen_label_rtx ();\n+\n+      if (pass_as_float)\n+\t{\n+\t  emit_cmp_and_jump_insns (expand_expr (next_fp, NULL_RTX, Pmode,\n+\t\t\t\t\t\tEXPAND_NORMAL),\n+\t\t\t\t   expand_expr (next_fp_limit, NULL_RTX,\n+\t\t\t\t\t\tPmode, EXPAND_NORMAL),\n+\t\t\t\t   GE, const1_rtx, Pmode, 1, 1, lab_false);\n+\n+\t  if (TYPE_ALIGN (type) > BITS_PER_WORD)\n+\t    {\n+\t      tmp = build (BIT_AND_EXPR, ptr_type_node, next_fp,\n+\t\t\t   build_int_2 (UNITS_PER_WORD, 0));\n+\t      tmp = build (PLUS_EXPR, ptr_type_node, next_fp, tmp);\n+\t      tmp = build (MODIFY_EXPR, ptr_type_node, next_fp, tmp);\n+\t      TREE_SIDE_EFFECTS (tmp) = 1;\n+\t      expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t    }\n+\n+\t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_fp);\n+\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != addr_rtx)\n+\t    emit_move_insn (addr_rtx, r);\n+\n+\t  emit_jump_insn (gen_jump (lab_over));\n+\t  emit_barrier ();\n+\t  emit_label (lab_false);\n+\n+\t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n+\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != addr_rtx)\n+\t    emit_move_insn (addr_rtx, r);\n+\t}\n+      else\n+\t{\n+\t  tmp = build (PLUS_EXPR, ptr_type_node, next_o,\n+\t\t       build_int_2 (rsize, 0));\n+\t  \n+\t  emit_cmp_and_jump_insns (expand_expr (tmp, NULL_RTX, Pmode,\n+\t\t\t\t\t\tEXPAND_NORMAL),\n+\t\t\t\t   expand_expr (next_o_limit, NULL_RTX,\n+\t\t\t\t\t\tPmode, EXPAND_NORMAL),\n+\t\t\t\t   GT, const1_rtx, Pmode, 1, 1, lab_false);\n+\n+\t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_o);\n+\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != addr_rtx)\n+\t    emit_move_insn (addr_rtx, r);\n+\n+\t  emit_jump_insn (gen_jump (lab_over));\n+\t  emit_barrier ();\n+\t  emit_label (lab_false);\n+\n+\t  if (size > 4 && ! TARGET_SH4)\n+\t    {\n+\t      tmp = build (MODIFY_EXPR, ptr_type_node, next_o, next_o_limit);\n+\t      TREE_SIDE_EFFECTS (tmp) = 1;\n+\t      expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t    }\n+\n+\t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_stack);\n+\t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);\n+\t  if (r != addr_rtx)\n+\t    emit_move_insn (addr_rtx, r);\n+\t}\n+\n+      emit_label (lab_over);\n+\n+      tmp = make_tree (pptr_type_node, addr_rtx);\n+      valist = build1 (INDIRECT_REF, ptr_type_node, tmp);\n+    }\n+\n+  /* ??? In va-sh.h, there had been code to make values larger than\n+     size 8 indirect.  This does not match the FUNCTION_ARG macros.  */\n+\n+  return std_expand_builtin_va_arg (valist, type);\n+}\n+\n /* Define the offset between two registers, one to be eliminated, and\n    the other its replacement, at the start of a routine.  */\n "}, {"sha": "93f27a49ace703d2d43e69dbddb00d9ffbafc960", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/514066a13349f79b36d4e46eb634d13307ae2f81/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/514066a13349f79b36d4e46eb634d13307ae2f81/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=514066a13349f79b36d4e46eb634d13307ae2f81", "patch": "@@ -1076,6 +1076,18 @@ extern int current_function_anonymous_args;\n #define SETUP_INCOMING_VARARGS(ASF, MODE, TYPE, PAS, ST) \\\n   current_function_anonymous_args = 1;\n \n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = sh_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  sh_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  sh_va_arg (valist, type)\n+\n /* Call the function profiler with a given profile label.\n    We use two .aligns, so as to make sure that both the .long is aligned\n    on a 4 byte boundary, and that the .long is a fixed distance (2 bytes)"}]}