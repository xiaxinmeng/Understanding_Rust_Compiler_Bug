{"sha": "6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIzMDM0ZWFiYTgzOTM1ZDlmNmRmYjIwZDJlZmJkYjM0YjViMDBiZg==", "commit": {"author": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-08-27T08:49:57Z"}, "committer": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-08-27T08:49:57Z"}, "message": "lra: Canonicalize mult to shift in address reloads\n\nInside a (mem) RTX, it is canonical to write multiplications by powers\nof two using a (mult) [0]. Outside of a (mem), the canonical way to\nwrite multiplications by powers of two is using (ashift).\n\nNow I observed that LRA does not quite respect this RTL canonicalization\nrule.  When compiling gcc/testsuite/gcc.dg/torture/pr34330.c with -Os\n-ftree-vectorize, the RTL in the dump \"281r.ira\" has the insn:\n\n(set (reg:SI 111)\n     (mem:SI (plus:DI (mult:DI (reg:DI 101 [ ivtmp.9 ])\n                 (const_int 4 [0x4]))\n             (reg/v/f:DI 105 [ b ]))))\n\nbut LRA then proceeds to generate a reload, and we get the following\nnon-canonical insn in \"282r.reload\":\n\n(set (reg:DI 7 x7 [121])\n     (plus:DI (mult:DI (reg:DI 5 x5 [orig:101 ivtmp.9 ] [101])\n             (const_int 4 [0x4]))\n         (reg/v/f:DI 1 x1 [orig:105 b ] [105])))\n\nThis patch fixes LRA to ensure that we generate canonical RTL in this\ncase. After the patch, we get the following insn in \"282r.reload\":\n\n(set (reg:DI 7 x7 [121])\n        (plus:DI (ashift:DI (reg:DI 5 x5 [orig:101 ivtmp.9 ] [101])\n                (const_int 2 [0x2]))\n            (reg/v/f:DI 1 x1 [orig:105 b ] [105])))\n\n[0] : https://gcc.gnu.org/onlinedocs/gccint/Insn-Canonicalizations.html\n\ngcc/ChangeLog:\n\n\t* lra-constraints.c (canonicalize_reload_addr): New.\n\t(curr_insn_transform): Use canonicalize_reload_addr to ensure we\n\tgenerate canonical RTL for an address reload.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/mem-shift-canonical.c: New test.", "tree": {"sha": "ea51767e5a6e332d27d8e48c0ad3ccc7487d76e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea51767e5a6e332d27d8e48c0ad3ccc7487d76e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf/comments", "author": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "795944c4563b4d9abf6d4bd9963f41fa1249d9d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795944c4563b4d9abf6d4bd9963f41fa1249d9d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795944c4563b4d9abf6d4bd9963f41fa1249d9d9"}], "stats": {"total": 70, "additions": 66, "deletions": 4}, "files": [{"sha": "580da9c3ed668cf3b81a73a3cd122486dda89993", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf", "patch": "@@ -131,6 +131,7 @@\n #include \"lra-int.h\"\n #include \"print-rtl.h\"\n #include \"function-abi.h\"\n+#include \"rtl-iter.h\"\n \n /* Value of LRA_CURR_RELOAD_NUM at the beginning of BB of the current\n    insn.  Remember that LRA_CURR_RELOAD_NUM is the number of emitted\n@@ -570,6 +571,33 @@ init_curr_insn_input_reloads (void)\n   curr_insn_input_reloads_num = 0;\n }\n \n+/* The canonical form of an rtx inside a MEM is not necessarily the same as the\n+   canonical form of the rtx outside the MEM.  Fix this up in the case that\n+   we're reloading an address (and therefore pulling it outside a MEM).  */\n+static rtx\n+canonicalize_reload_addr (rtx addr)\n+{\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, addr, NONCONST)\n+    {\n+      rtx x = *iter;\n+      if (GET_CODE (x) == MULT && CONST_INT_P (XEXP (x, 1)))\n+\t{\n+\t  const HOST_WIDE_INT ci = INTVAL (XEXP (x, 1));\n+\t  const int pwr2 = exact_log2 (ci);\n+\t  if (pwr2 > 0)\n+\t    {\n+\t      /* Rewrite this to use a shift instead, which is canonical when\n+\t\t outside of a MEM.  */\n+\t      PUT_CODE (x, ASHIFT);\n+\t      XEXP (x, 1) = GEN_INT (pwr2);\n+\t    }\n+\t}\n+    }\n+\n+  return addr;\n+}\n+\n /* Create a new pseudo using MODE, RCLASS, ORIGINAL or reuse already\n    created input reload pseudo (only if TYPE is not OP_OUT).  Don't\n    reuse pseudo if IN_SUBREG_P is true and the reused pseudo should be\n@@ -4362,12 +4390,19 @@ curr_insn_transform (bool check_only_p)\n \t    {\n \t      rtx addr = *loc;\n \t      enum rtx_code code = GET_CODE (addr);\n-\t      \n+\t      bool align_p = false;\n+\n \t      if (code == AND && CONST_INT_P (XEXP (addr, 1)))\n-\t\t/* (and ... (const_int -X)) is used to align to X bytes.  */\n-\t\taddr = XEXP (*loc, 0);\n+\t\t{\n+\t\t  /* (and ... (const_int -X)) is used to align to X bytes.  */\n+\t\t  align_p = true;\n+\t\t  addr = XEXP (*loc, 0);\n+\t\t}\n+\t      else\n+\t\taddr = canonicalize_reload_addr (addr);\n+\n \t      lra_emit_move (new_reg, addr);\n-\t      if (addr != *loc)\n+\t      if (align_p)\n \t\temit_move_insn (new_reg, gen_rtx_AND (GET_MODE (new_reg), new_reg, XEXP (*loc, 1)));\n \t    }\n \t  before = get_insns ();"}, {"sha": "36beed497a0724bf9dc3d160c4c7738e20b2be95", "filename": "gcc/testsuite/gcc.target/aarch64/mem-shift-canonical.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmem-shift-canonical.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmem-shift-canonical.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmem-shift-canonical.c?ref=6b3034eaba83935d9f6dfb20d2efbdb34b5b00bf", "patch": "@@ -0,0 +1,27 @@\n+/* This test is a copy of gcc.dg/torture/pr34330.c: here we are looking for\n+   specific patterns being matched in the AArch64 backend.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -ftree-vectorize -dp\" } */\n+\n+\n+struct T\n+{\n+  int t;\n+  struct { short s1, s2, s3, s4; } *s;\n+};\n+\n+void\n+foo (int *a, int *b, int *c, int *d, struct T *e)\n+{\n+  int i;\n+  for (i = 0; i < e->t; i++)\n+    {\n+      e->s[i].s1 = a[i];\n+      e->s[i].s2 = b[i];\n+      e->s[i].s3 = c[i];\n+      e->s[i].s4 = d[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times \"add_lsl_di\" 3 } } */"}]}