{"sha": "d16e2ddd2666efed093ce826228c786715823cb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE2ZTJkZGQyNjY2ZWZlZDA5M2NlODI2MjI4Yzc4NjcxNTgyM2NiNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-04-04T17:52:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-04-04T17:52:27Z"}, "message": "re PR tree-optimization/79390 (10% performance drop in SciMark2 LU after r242550)\n\n\tPR tree-optimization/79390\n\t* target.h (struct noce_if_info): Declare.\n\t* targhooks.h (default_noce_conversion_profitable_p): Declare.\n\t* target.def (noce_conversion_profitable_p): New target hook.\n\t* ifcvt.h (struct noce_if_info): New type, moved from ...\n\t* ifcvt.c (struct noce_if_info): ... here.\n\t(noce_conversion_profitable_p): Renamed to ...\n\t(default_noce_conversion_profitable_p): ... this.  No longer\n\tstatic nor inline.\n\t(noce_try_store_flag_constants, noce_try_addcc,\n\tnoce_try_store_flag_mask, noce_try_cmove, noce_try_cmove_arith,\n\tnoce_convert_multiple_sets): Use targetm.noce_conversion_profitable_p\n\tinstead of noce_conversion_profitable_p.\n\t* config/i386/i386.c: Include ifcvt.h.\n\t(ix86_option_override_internal): Don't override\n\tPARAM_MAX_RTL_IF_CONVERSION_INSNS default.\n\t(ix86_noce_conversion_profitable_p): New function.\n\t(TARGET_NOCE_CONVERSION_PROFITABLE_P): Redefine.\n\t* config/i386/x86-tune.def (X86_TUNE_ONE_IF_CONV_INSN): Adjust comment.\n\t* doc/tm.texi.in (TARGET_NOCE_CONVERSION_PROFITABLE_P): Add.\n\t* doc/tm.texi: Regenerated.\n\n\t* gcc.target/i386/pr79390.c: New test.\n\t* gcc.dg/ifcvt-4.c: Use -mtune-ctrl=^one_if_conv_insn for i?86/x86_64.\n\nFrom-SVN: r246686", "tree": {"sha": "90baf0fa1babd2f5a7a6862baa9740fc718762aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90baf0fa1babd2f5a7a6862baa9740fc718762aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d16e2ddd2666efed093ce826228c786715823cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d16e2ddd2666efed093ce826228c786715823cb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d16e2ddd2666efed093ce826228c786715823cb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d16e2ddd2666efed093ce826228c786715823cb4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2b2c4b9fbb1c5ee3c8756e6b6ecc6e490fad035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2b2c4b9fbb1c5ee3c8756e6b6ecc6e490fad035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2b2c4b9fbb1c5ee3c8756e6b6ecc6e490fad035"}], "stats": {"total": 300, "additions": 209, "deletions": 91}, "files": [{"sha": "d537ac5099a6366f372f6ed502b36a7379914668", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -1,3 +1,27 @@\n+2017-04-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79390\n+\t* target.h (struct noce_if_info): Declare.\n+\t* targhooks.h (default_noce_conversion_profitable_p): Declare.\n+\t* target.def (noce_conversion_profitable_p): New target hook.\n+\t* ifcvt.h (struct noce_if_info): New type, moved from ...\n+\t* ifcvt.c (struct noce_if_info): ... here.\n+\t(noce_conversion_profitable_p): Renamed to ...\n+\t(default_noce_conversion_profitable_p): ... this.  No longer\n+\tstatic nor inline.\n+\t(noce_try_store_flag_constants, noce_try_addcc,\n+\tnoce_try_store_flag_mask, noce_try_cmove, noce_try_cmove_arith,\n+\tnoce_convert_multiple_sets): Use targetm.noce_conversion_profitable_p\n+\tinstead of noce_conversion_profitable_p.\n+\t* config/i386/i386.c: Include ifcvt.h.\n+\t(ix86_option_override_internal): Don't override\n+\tPARAM_MAX_RTL_IF_CONVERSION_INSNS default.\n+\t(ix86_noce_conversion_profitable_p): New function.\n+\t(TARGET_NOCE_CONVERSION_PROFITABLE_P): Redefine.\n+\t* config/i386/x86-tune.def (X86_TUNE_ONE_IF_CONV_INSN): Adjust comment.\n+\t* doc/tm.texi.in (TARGET_NOCE_CONVERSION_PROFITABLE_P): Add.\n+\t* doc/tm.texi: Regenerated.\n+\n 2017-04-04  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Grammar"}, {"sha": "96faffd81e876fb0b428f3a652c98ef40f47acbf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest-rtl.h\"\n #include \"print-rtl.h\"\n #include \"intl.h\"\n+#include \"ifcvt.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -6104,13 +6105,6 @@ ix86_option_override_internal (bool main_args_p,\n \t\t\t opts->x_param_values,\n \t\t\t opts_set->x_param_values);\n \n-  /* Restrict number of if-converted SET insns to 1.  */\n-  if (TARGET_ONE_IF_CONV_INSN)\n-    maybe_set_param_value (PARAM_MAX_RTL_IF_CONVERSION_INSNS,\n-\t\t\t   1,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   opts_set->x_param_values);\n-\n   /* Enable sw prefetching at -O3 for CPUS that prefetching is helpful.  */\n   if (opts->x_flag_prefetch_loop_arrays < 0\n       && HAVE_prefetch\n@@ -50629,6 +50623,41 @@ ix86_max_noce_ifcvt_seq_cost (edge e)\n     return BRANCH_COST (true, predictable_p) * COSTS_N_INSNS (2);\n }\n \n+/* Return true if SEQ is a good candidate as a replacement for the\n+   if-convertible sequence described in IF_INFO.  */\n+\n+static bool\n+ix86_noce_conversion_profitable_p (rtx_insn *seq, struct noce_if_info *if_info)\n+{\n+  if (TARGET_ONE_IF_CONV_INSN && if_info->speed_p)\n+    {\n+      int cmov_cnt = 0;\n+      /* Punt if SEQ contains more than one CMOV or FCMOV instruction.\n+\t Maybe we should allow even more conditional moves as long as they\n+\t are used far enough not to stall the CPU, or also consider\n+\t IF_INFO->TEST_BB succ edge probabilities.  */\n+      for (rtx_insn *insn = seq; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  rtx set = single_set (insn);\n+\t  if (!set)\n+\t    continue;\n+\t  if (GET_CODE (SET_SRC (set)) != IF_THEN_ELSE)\n+\t    continue;\n+\t  rtx src = SET_SRC (set);\n+\t  enum machine_mode mode = GET_MODE (src);\n+\t  if (GET_MODE_CLASS (mode) != MODE_INT\n+\t      && GET_MODE_CLASS (mode) != MODE_FLOAT)\n+\t    continue;\n+\t  if ((!REG_P (XEXP (src, 1)) && !MEM_P (XEXP (src, 1)))\n+\t      || (!REG_P (XEXP (src, 2)) && !MEM_P (XEXP (src, 2))))\n+\t    continue;\n+\t  /* insn is CMOV or FCMOV.  */\n+\t  if (++cmov_cnt > 1)\n+\t    return false;\n+\t}\n+    }\n+  return default_noce_conversion_profitable_p (seq, if_info);\n+}\n \n /* Implement targetm.vectorize.init_cost.  */\n \n@@ -52181,6 +52210,10 @@ ix86_run_selftests (void)\n \n #undef TARGET_MAX_NOCE_IFCVT_SEQ_COST\n #define TARGET_MAX_NOCE_IFCVT_SEQ_COST ix86_max_noce_ifcvt_seq_cost\n+\n+#undef TARGET_NOCE_CONVERSION_PROFITABLE_P\n+#define TARGET_NOCE_CONVERSION_PROFITABLE_P ix86_noce_conversion_profitable_p\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::ix86_run_selftests"}, {"sha": "c642f452e00f613ee37f25595d455939cddfa098", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -547,7 +547,7 @@ DEF_TUNE (X86_TUNE_PROMOTE_QI_REGS, \"promote_qi_regs\", 0U)\n    the unroll factor so that the unrolled loop fits the loop buffer.  */\n DEF_TUNE (X86_TUNE_ADJUST_UNROLL, \"adjust_unroll_factor\", m_BDVER3 | m_BDVER4)\n \n-/* X86_TUNE_ONE_IF_CONV_INSNS: Restrict a number of set insns to be\n-   if-converted to one.  */\n+/* X86_TUNE_ONE_IF_CONV_INSNS: Restrict a number of cmov insns in\n+   if-converted sequence to one.  */\n DEF_TUNE (X86_TUNE_ONE_IF_CONV_INSN, \"one_if_conv_insn\",\n \t  m_SILVERMONT | m_KNL | m_INTEL | m_CORE_ALL | m_GENERIC)"}, {"sha": "c4f2c893c8e63b7c9df6626ca3a0710c6aad6933", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -6644,6 +6644,12 @@ The default implementation of this hook uses the\n and uses a multiple of @code{BRANCH_COST} otherwise.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_NOCE_CONVERSION_PROFITABLE_P (rtx_insn *@var{seq}, struct noce_if_info *@var{if_info})\n+This hook returns true if the instruction sequence @code{seq} is a good\n+candidate as a replacement for the if-convertible sequence described in\n+@code{if_info}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P (void)\n This predicate controls the use of the eager delay slot filler to disallow\n speculatively executed instructions being placed in delay slots.  Targets"}, {"sha": "1c471d8da35f3640d9a34f4a760b4e25969a7ad0", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -4796,6 +4796,8 @@ Define this macro if a non-short-circuit operation produced by\n \n @hook TARGET_MAX_NOCE_IFCVT_SEQ_COST\n \n+@hook TARGET_NOCE_CONVERSION_PROFITABLE_P\n+\n @hook TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P\n \n @node Scheduling"}, {"sha": "e51ccab26b2984f8831f9af49ff77e53e05ec917", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 15, "deletions": 82, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -760,76 +760,6 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n   return FALSE;\n }\n \f\n-/* Used by noce_process_if_block to communicate with its subroutines.\n-\n-   The subroutines know that A and B may be evaluated freely.  They\n-   know that X is a register.  They should insert new instructions\n-   before cond_earliest.  */\n-\n-struct noce_if_info\n-{\n-  /* The basic blocks that make up the IF-THEN-{ELSE-,}JOIN block.  */\n-  basic_block test_bb, then_bb, else_bb, join_bb;\n-\n-  /* The jump that ends TEST_BB.  */\n-  rtx_insn *jump;\n-\n-  /* The jump condition.  */\n-  rtx cond;\n-\n-  /* Reversed jump condition.  */\n-  rtx rev_cond;\n-\n-  /* New insns should be inserted before this one.  */\n-  rtx_insn *cond_earliest;\n-\n-  /* Insns in the THEN and ELSE block.  There is always just this\n-     one insns in those blocks.  The insns are single_set insns.\n-     If there was no ELSE block, INSN_B is the last insn before\n-     COND_EARLIEST, or NULL_RTX.  In the former case, the insn\n-     operands are still valid, as if INSN_B was moved down below\n-     the jump.  */\n-  rtx_insn *insn_a, *insn_b;\n-\n-  /* The SET_SRC of INSN_A and INSN_B.  */\n-  rtx a, b;\n-\n-  /* The SET_DEST of INSN_A.  */\n-  rtx x;\n-\n-  /* The original set destination that the THEN and ELSE basic blocks finally\n-     write their result to.  */\n-  rtx orig_x;\n-  /* True if this if block is not canonical.  In the canonical form of\n-     if blocks, the THEN_BB is the block reached via the fallthru edge\n-     from TEST_BB.  For the noce transformations, we allow the symmetric\n-     form as well.  */\n-  bool then_else_reversed;\n-\n-  /* True if the contents of then_bb and else_bb are a\n-     simple single set instruction.  */\n-  bool then_simple;\n-  bool else_simple;\n-\n-  /* True if we're optimisizing the control block for speed, false if\n-     we're optimizing for size.  */\n-  bool speed_p;\n-\n-  /* An estimate of the original costs.  When optimizing for size, this is the\n-     combined cost of COND, JUMP and the costs for THEN_BB and ELSE_BB.\n-     When optimizing for speed, we use the costs of COND plus the minimum of\n-     the costs for THEN_BB and ELSE_BB, as computed in the next field.  */\n-  unsigned int original_cost;\n-\n-  /* Maximum permissible cost for the unconditional sequence we should\n-     generate to replace this branch.  */\n-  unsigned int max_seq_cost;\n-\n-  /* The name of the noce transform that succeeded in if-converting\n-     this structure.  Used for debugging.  */\n-  const char *transform_name;\n-};\n-\n static rtx noce_emit_store_flag (struct noce_if_info *, rtx, int, int);\n static int noce_try_move (struct noce_if_info *);\n static int noce_try_ifelse_collapse (struct noce_if_info *);\n@@ -857,11 +787,14 @@ noce_reversed_cond_code (struct noce_if_info *if_info)\n   return reversed_comparison_code (if_info->cond, if_info->jump);\n }\n \n-/* Return TRUE if SEQ is a good candidate as a replacement for the\n-   if-convertible sequence described in IF_INFO.  */\n+/* Return true if SEQ is a good candidate as a replacement for the\n+   if-convertible sequence described in IF_INFO.\n+   This is the default implementation that targets can override\n+   through a target hook.  */\n \n-inline static bool\n-noce_conversion_profitable_p (rtx_insn *seq, struct noce_if_info *if_info)\n+bool\n+default_noce_conversion_profitable_p (rtx_insn *seq,\n+\t\t\t\t      struct noce_if_info *if_info)\n {\n   bool speed_p = if_info->speed_p;\n \n@@ -1544,7 +1477,7 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \tnoce_emit_move_insn (if_info->x, target);\n \n       seq = end_ifcvt_sequence (if_info);\n-      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n+      if (!seq || !targetm.noce_conversion_profitable_p (seq, if_info))\n \treturn FALSE;\n \n       emit_insn_before_setloc (seq, if_info->jump,\n@@ -1605,7 +1538,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = end_ifcvt_sequence (if_info);\n-\t      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n+\t      if (!seq || !targetm.noce_conversion_profitable_p (seq, if_info))\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n@@ -1647,7 +1580,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = end_ifcvt_sequence (if_info);\n-\t      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n+\t      if (!seq || !targetm.noce_conversion_profitable_p (seq, if_info))\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n@@ -1698,7 +1631,7 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n \t    noce_emit_move_insn (if_info->x, target);\n \n \t  seq = end_ifcvt_sequence (if_info);\n-\t  if (!seq || !noce_conversion_profitable_p (seq, if_info))\n+\t  if (!seq || !targetm.noce_conversion_profitable_p (seq, if_info))\n \t    return FALSE;\n \n \t  emit_insn_before_setloc (seq, if_info->jump,\n@@ -1850,7 +1783,7 @@ noce_try_cmove (struct noce_if_info *if_info)\n \t    noce_emit_move_insn (if_info->x, target);\n \n \t  seq = end_ifcvt_sequence (if_info);\n-\t  if (!seq || !noce_conversion_profitable_p (seq, if_info))\n+\t  if (!seq || !targetm.noce_conversion_profitable_p (seq, if_info))\n \t    return FALSE;\n \n \t  emit_insn_before_setloc (seq, if_info->jump,\n@@ -1903,7 +1836,7 @@ noce_try_cmove (struct noce_if_info *if_info)\n \t\tnoce_emit_move_insn (if_info->x, target);\n \n \t      seq = end_ifcvt_sequence (if_info);\n-\t      if (!seq || !noce_conversion_profitable_p (seq, if_info))\n+\t      if (!seq || !targetm.noce_conversion_profitable_p (seq, if_info))\n \t\treturn FALSE;\n \n \t      emit_insn_before_setloc (seq, if_info->jump,\n@@ -2345,7 +2278,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n     noce_emit_move_insn (x, target);\n \n   ifcvt_seq = end_ifcvt_sequence (if_info);\n-  if (!ifcvt_seq || !noce_conversion_profitable_p (ifcvt_seq, if_info))\n+  if (!ifcvt_seq || !targetm.noce_conversion_profitable_p (ifcvt_seq, if_info))\n     return FALSE;\n \n   emit_insn_before_setloc (ifcvt_seq, if_info->jump,\n@@ -3308,7 +3241,7 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n   /* Actually emit the sequence if it isn't too expensive.  */\n   rtx_insn *seq = get_insns ();\n \n-  if (!noce_conversion_profitable_p (seq, if_info))\n+  if (!targetm.noce_conversion_profitable_p (seq, if_info))\n     {\n       end_sequence ();\n       return FALSE;"}, {"sha": "1935de5e82f76a72b5b678b2abf4a7cc88d4abbc", "filename": "gcc/ifcvt.h", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fifcvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Fifcvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.h?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -40,4 +40,74 @@ struct ce_if_block\n   int pass;\t\t\t\t/* Pass number.  */\n };\n \n+/* Used by noce_process_if_block to communicate with its subroutines.\n+\n+   The subroutines know that A and B may be evaluated freely.  They\n+   know that X is a register.  They should insert new instructions\n+   before cond_earliest.  */\n+\n+struct noce_if_info\n+{\n+  /* The basic blocks that make up the IF-THEN-{ELSE-,}JOIN block.  */\n+  basic_block test_bb, then_bb, else_bb, join_bb;\n+\n+  /* The jump that ends TEST_BB.  */\n+  rtx_insn *jump;\n+\n+  /* The jump condition.  */\n+  rtx cond;\n+\n+  /* Reversed jump condition.  */\n+  rtx rev_cond;\n+\n+  /* New insns should be inserted before this one.  */\n+  rtx_insn *cond_earliest;\n+\n+  /* Insns in the THEN and ELSE block.  There is always just this\n+     one insns in those blocks.  The insns are single_set insns.\n+     If there was no ELSE block, INSN_B is the last insn before\n+     COND_EARLIEST, or NULL_RTX.  In the former case, the insn\n+     operands are still valid, as if INSN_B was moved down below\n+     the jump.  */\n+  rtx_insn *insn_a, *insn_b;\n+\n+  /* The SET_SRC of INSN_A and INSN_B.  */\n+  rtx a, b;\n+\n+  /* The SET_DEST of INSN_A.  */\n+  rtx x;\n+\n+  /* The original set destination that the THEN and ELSE basic blocks finally\n+     write their result to.  */\n+  rtx orig_x;\n+  /* True if this if block is not canonical.  In the canonical form of\n+     if blocks, the THEN_BB is the block reached via the fallthru edge\n+     from TEST_BB.  For the noce transformations, we allow the symmetric\n+     form as well.  */\n+  bool then_else_reversed;\n+\n+  /* True if the contents of then_bb and else_bb are a\n+     simple single set instruction.  */\n+  bool then_simple;\n+  bool else_simple;\n+\n+  /* True if we're optimisizing the control block for speed, false if\n+     we're optimizing for size.  */\n+  bool speed_p;\n+\n+  /* An estimate of the original costs.  When optimizing for size, this is the\n+     combined cost of COND, JUMP and the costs for THEN_BB and ELSE_BB.\n+     When optimizing for speed, we use the costs of COND plus the minimum of\n+     the costs for THEN_BB and ELSE_BB, as computed in the next field.  */\n+  unsigned int original_cost;\n+\n+  /* Maximum permissible cost for the unconditional sequence we should\n+     generate to replace this branch.  */\n+  unsigned int max_seq_cost;\n+\n+  /* The name of the noce transform that succeeded in if-converting\n+     this structure.  Used for debugging.  */\n+  const char *transform_name;\n+};\n+\n #endif /* GCC_IFCVT_H */"}, {"sha": "6bebfd5b9d6b7001a19fd5a41700ac3667408c00", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -3660,6 +3660,16 @@ and uses a multiple of @code{BRANCH_COST} otherwise.\",\n unsigned int, (edge e),\n default_max_noce_ifcvt_seq_cost)\n \n+/* Return true if the given instruction sequence is a good candidate\n+   as a replacement for the if-convertible sequence.  */\n+DEFHOOK\n+(noce_conversion_profitable_p,\n+ \"This hook returns true if the instruction sequence @code{seq} is a good\\n\\\n+candidate as a replacement for the if-convertible sequence described in\\n\\\n+@code{if_info}.\",\n+bool, (rtx_insn *seq, struct noce_if_info *if_info),\n+default_noce_conversion_profitable_p)\n+\n /* Permit speculative instructions in delay slots during delayed-branch \n    scheduling.  */\n DEFHOOK"}, {"sha": "393de408b9726b2242303081d28ebe49c2325998", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -140,6 +140,9 @@ struct ddg;\n /* This is defined in cfgloop.h .  */\n struct loop;\n \n+/* This is defined in ifcvt.h.  */\n+struct noce_if_info;\n+\n /* This is defined in tree-ssa-alias.h.  */\n struct ao_ref;\n "}, {"sha": "18070df7839f5515e55a841c91bb0d95f86b1099", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -257,6 +257,8 @@ extern void default_setup_incoming_vararg_bounds (cumulative_args_t ca ATTRIBUTE\n extern bool default_optab_supported_p (int, machine_mode, machine_mode,\n \t\t\t\t       optimization_type);\n extern unsigned int default_max_noce_ifcvt_seq_cost (edge);\n+extern bool default_noce_conversion_profitable_p (rtx_insn *,\n+\t\t\t\t\t\t  struct noce_if_info *);\n extern unsigned int default_min_arithmetic_precision (void);\n \n extern enum flt_eval_method"}, {"sha": "6d1ed2227b750c6774731e6aabfe7365d6bd0f2b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -1,3 +1,9 @@\n+2017-04-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79390\n+\t* gcc.target/i386/pr79390.c: New test.\n+\t* gcc.dg/ifcvt-4.c: Use -mtune-ctrl=^one_if_conv_insn for i?86/x86_64.\n+\n 2017-04-04  Volker Reichelt  <v.reichelt@netcologne.de>\n \n \tPR c++/80296"}, {"sha": "87bae3cbe440f942fd2f1a9d7d987c333ec09740", "filename": "gcc/testsuite/gcc.dg/ifcvt-4.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fifcvt-4.c?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -1,6 +1,7 @@\n /* { dg-options \"-fdump-rtl-ce1 -O2 --param max-rtl-if-conversion-insns=3 --param max-rtl-if-conversion-unpredictable-cost=100\" } */\n /* { dg-additional-options \"-misel\" { target { powerpc*-*-* } } } */\n /* { dg-additional-options \"-march=z196\" { target { s390x-*-* } } } */\n+/* { dg-additional-options \"-mtune-ctrl=^one_if_conv_insn\" { target { i?86-*-* x86_64-*-* } } } */\n /* { dg-skip-if \"Multiple set if-conversion not guaranteed on all subtargets\" { \"arm*-*-* hppa*64*-*-* s390-*-* visium-*-*\" riscv*-*-* } }  */\n /* { dg-skip-if \"\" { \"s390x-*-*\" } { \"-m31\" } }  */\n "}, {"sha": "1c7d601297893d073bfde4cdc67b2d292d79da14", "filename": "gcc/testsuite/gcc.target/i386/pr79390.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr79390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16e2ddd2666efed093ce826228c786715823cb4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr79390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr79390.c?ref=d16e2ddd2666efed093ce826228c786715823cb4", "patch": "@@ -0,0 +1,28 @@\n+/* PR tree-optimization/79390 */\n+/* { dg-do compile { target lp64 } } */\n+/* { dg-options \"-O2 -march=haswell -mtune=haswell -mfpmath=sse\" } */\n+/* Make sure we emit a conditional move in this loop.  */\n+\n+extern double A[32];\n+\n+int\n+foo (void)\n+{\n+  double t = A[0];\n+  int jp = 0;\n+  int i;\n+\n+  for (i = 0; i < 32; i++)\n+    {\n+      double ab = A[i];\n+      if (ab > t)\n+\t{\n+\t  jp = i;\n+\t  t = ab;\n+\t}\n+    }\n+ \n+  return jp;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\\\t\\]cmov\\[a-z]+\\[ \\\\t\\]\" } } */"}]}