{"sha": "baa3ffb19c54fa334ac2884f6acb5d31aa79ac32", "node_id": "C_kwDOANBUbNoAKGJhYTNmZmIxOWM1NGZhMzM0YWMyODg0ZjZhY2I1ZDMxYWE3OWFjMzI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-23T11:58:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-23T13:20:27Z"}, "message": "tree-optimization/106722 - uninit analysis with long def -> use path\n\nThe following applies similar measures as r13-2133-ge66cf626c72d58\nto the computation of the use predicate when the path from PHI def\nto use is too long and we run into compute_control_dep_chain limits.\n\nIt also moves the preprocessor define limits internal.\n\nThis resolves the reduced testcase but not the original one.\n\n\tPR tree-optimization/106722\n\t* gimple-predicate-analysis.h (MAX_NUM_CHAINS, MAX_CHAIN_LEN,\n\tMAX_POSTDOM_CHECK, MAX_SWITCH_CASES): Move ...\n\t* gimple-predicate-analysis.cc: ... here and document.\n\t(simple_control_dep_chain): New function, factored from\n\tpredicate::use_cannot_happen.\n\t(predicate::use_cannot_happen): Adjust.\n\t(predicate::predicate): Use simple_control_dep_chain as fallback.\n\n\t* g++.dg/uninit-pr106722-1.C: New testcase.", "tree": {"sha": "e80aaddb11403cd82cba20563f4ce099557b5278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e80aaddb11403cd82cba20563f4ce099557b5278"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b25c5d6133d356a34aee72a24fd4cdec5637cc17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25c5d6133d356a34aee72a24fd4cdec5637cc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25c5d6133d356a34aee72a24fd4cdec5637cc17"}], "stats": {"total": 137, "additions": 117, "deletions": 20}, "files": [{"sha": "a4291657d0bf05d348de643f7f87c0292f2193a8", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 52, "deletions": 16, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=baa3ffb19c54fa334ac2884f6acb5d31aa79ac32", "patch": "@@ -46,6 +46,19 @@\n \n #define DEBUG_PREDICATE_ANALYZER 1\n \n+/* In our predicate normal form we have MAX_NUM_CHAINS or predicates\n+   and in those MAX_CHAIN_LEN (inverted) and predicates.  */\n+#define MAX_NUM_CHAINS 8\n+#define MAX_CHAIN_LEN 5\n+\n+/* When enumerating paths between two blocks this limits the number of\n+   post-dominator skips between two edges possibly defining a predicate.  */\n+#define MAX_POSTDOM_CHECK 8\n+\n+/* The limit for the number of switch cases when we do the linear search\n+   for the case corresponding to an edge.  */\n+#define MAX_SWITCH_CASES 40\n+\n /* Return true if, when BB1 is postdominating BB2, BB1 is a loop exit.  */\n \n static bool\n@@ -1034,6 +1047,36 @@ is_degenerate_phi (gimple *phi, pred_info *pred)\n   return true;\n }\n \n+/* If compute_control_dep_chain bailed out due to limits this routine\n+   tries to build a partial sparse path using dominators.  Returns\n+   path edges whose predicates are always true when reaching E.  */\n+\n+static void\n+simple_control_dep_chain (vec<edge>& chain, basic_block from, basic_block to)\n+{\n+  if (!dominated_by_p (CDI_DOMINATORS, to, from))\n+    return;\n+\n+  basic_block src = to;\n+  while (src != from\n+\t && chain.length () <= MAX_CHAIN_LEN)\n+    {\n+      basic_block dest = src;\n+      src = get_immediate_dominator (CDI_DOMINATORS, src);\n+      edge pred_e;\n+      if (single_pred_p (dest)\n+\t  && (pred_e = find_edge (src, dest)))\n+\tchain.safe_push (pred_e);\n+    }\n+}\n+\n+static void\n+simple_control_dep_chain (vec<edge>& chain, basic_block from, edge to)\n+{\n+  chain.safe_push (to);\n+  simple_control_dep_chain (chain, from, to->src);\n+}\n+\n /* Recursively compute the control dependence chains (paths of edges)\n    from the dependent basic block, DEP_BB, up to the dominating basic\n    block, DOM_BB (the head node of a chain should be dominated by it),\n@@ -1273,20 +1316,8 @@ predicate::use_cannot_happen (gphi *phi, unsigned opnds)\n \t  /* If compute_control_dep_chain bailed out due to limits\n \t     build a partial sparse path using dominators.  Collect\n \t     only edges whose predicates are always true when reaching E.  */\n-\t  cur_chain.truncate (0);\n-\t  cur_chain.quick_push (e);\n-\t  basic_block src = e->src;\n-\t  while (src->index != ENTRY_BLOCK\n-\t\t && cur_chain.length () <= MAX_CHAIN_LEN)\n-\t    {\n-\t      basic_block dest = src;\n-\t      src = get_immediate_dominator (CDI_DOMINATORS, src);\n-\t      edge pred_e;\n-\t      if (single_pred_p (dest)\n-\t\t  && (pred_e = find_edge (src, dest)))\n-\t\tcur_chain.quick_push (pred_e);\n-\t    }\n-\t  dep_chains[0] = cur_chain.copy ();\n+\t  simple_control_dep_chain (dep_chains[0],\n+\t\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (cfun), e);\n \t  num_chains++;\n \t}\n \n@@ -1737,8 +1768,13 @@ predicate::predicate (basic_block def_bb, basic_block use_bb, func_t &eval)\n   auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n   auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n \n-  compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n-\t\t\t     cur_chain, &num_calls);\n+  if (!compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n+\t\t\t\t  cur_chain, &num_calls))\n+    {\n+      gcc_assert (num_chains == 0);\n+      simple_control_dep_chain (dep_chains[0], cd_root, use_bb);\n+      num_chains++;\n+    }\n \n   if (DEBUG_PREDICATE_ANALYZER && dump_file)\n     {"}, {"sha": "77672291c360431144b1ec6f38b06927869fd435", "filename": "gcc/gimple-predicate-analysis.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32/gcc%2Fgimple-predicate-analysis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32/gcc%2Fgimple-predicate-analysis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.h?ref=baa3ffb19c54fa334ac2884f6acb5d31aa79ac32", "patch": "@@ -22,10 +22,6 @@\n #ifndef GIMPLE_PREDICATE_ANALYSIS_H_INCLUDED\n #define GIMPLE_PREDICATE_ANALYSIS_H_INCLUDED\n \n-#define MAX_NUM_CHAINS 8\n-#define MAX_CHAIN_LEN 5\n-#define MAX_POSTDOM_CHECK 8\n-#define MAX_SWITCH_CASES 40\n \n /* Represents a simple Boolean predicate.  */\n struct pred_info"}, {"sha": "a10f8dd88c7ef6df17f2c3dc242a3bcb12c7d563", "filename": "gcc/testsuite/g++.dg/uninit-pr106722-1.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pr106722-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3ffb19c54fa334ac2884f6acb5d31aa79ac32/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pr106722-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pr106722-1.C?ref=baa3ffb19c54fa334ac2884f6acb5d31aa79ac32", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do compile }\n+// { dg-require-effective-target c++11 }\n+// { dg-options \"-O2 -Wmaybe-uninitialized --param logical-op-non-short-circuit=0\" }\n+long pow2p_hwi_x;\n+bool exact_log2___trans_tmp_5, exact_log2___trans_tmp_4;\n+int exact_log2(long x) {\n+  exact_log2___trans_tmp_5 = pow2p_hwi_x && exact_log2___trans_tmp_4;\n+  return exact_log2___trans_tmp_5 ? x : 1;\n+}\n+enum signop {};\n+template <typename T1, typename T2> void rshift(T1, T2, signop);\n+struct generic_wide_int {\n+  template <typename T> generic_wide_int(T);\n+};\n+template <unsigned N, typename> struct poly_int_pod {\n+  bool is_constant() const;\n+  template <typename T> bool is_constant(T *) const;\n+  int coeffs[N];\n+};\n+template <unsigned N, typename C>\n+template <typename T>\n+bool poly_int_pod<N, C>::is_constant(T *const_value) const {\n+  if (is_constant()) {\n+    *const_value = coeffs[0];\n+    return true;\n+  }\n+  return false;\n+}\n+struct poly_int : poly_int_pod<1, int> {\n+  template <typename C0> poly_int(C0);\n+};\n+enum tree_code_class {} tree_code_type;\n+void tree_class_check_failed(int *, tree_code_class, char *, int, char *)\n+    __attribute__((__noreturn__));\n+int tree_class_check___t, tree_class_check___l,\n+    vect_gen_vector_loop_niters_loop_vinfo;\n+char tree_class_check___f, tree_class_check___g;\n+tree_code_class tree_class_check___class;\n+int *tree_class_check() {\n+  if (tree_code_type)\n+    tree_class_check_failed(&tree_class_check___t, tree_class_check___class,\n+                            &tree_class_check___f, tree_class_check___l,\n+                            &tree_class_check___g);\n+  return &tree_class_check___t;\n+}\n+int *build_int_cst(int, long);\n+bool is_gimple_val(int);\n+void force_gimple_operand(int, int *, bool, int);\n+void vect_gen_vector_loop_niters(bool niters_no_overflow) {\n+  poly_int vf(vect_gen_vector_loop_niters_loop_vinfo);\n+  int *log_vf = nullptr;\n+  long const_vf;\n+  if (vf.is_constant(&const_vf))\n+    log_vf = build_int_cst(0, 0);\n+  if (is_gimple_val(0)) {\n+    int stmts;\n+    force_gimple_operand(0, &stmts, true, 0);\n+    if (stmts && log_vf)\n+      if (niters_no_overflow) {\n+        generic_wide_int __trans_tmp_1(tree_class_check());\n+        int __trans_tmp_2 = exact_log2(const_vf); // { dg-bogus \"uninitialized\" }\n+        rshift(__trans_tmp_1, __trans_tmp_2, (signop)0);\n+      }\n+  }\n+}"}]}