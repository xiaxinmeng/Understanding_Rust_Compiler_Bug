{"sha": "aa5147f00a99f736c4c75871979f738241579084", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1MTQ3ZjAwYTk5ZjczNmM0Yzc1ODcxOTc5ZjczODI0MTU3OTA4NA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:47:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:47:12Z"}, "message": "sem_res.adb (Resolve_Allocator): Propagate any coextensions that appear in the subtree to the current allocator...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_res.adb (Resolve_Allocator): Propagate any coextensions that\n\tappear in the subtree to the current allocator if it is not a static\n\tcoextension.\n\t(Resolve_Allocator): Perform cleanup if resolution has determined that\n\tthe allocator is not a coextension.\n\t(Resolve): Skip an interpretation hidden by an abstract operator only\n\twhen the type of the interpretation matches that of the context.\n\t(Resolve): When looping through all possible interpretations of a node,\n\tdo not consider those that are hidden by abstract operators.\n\t(Resolve_Actuals): When verifying that an access to class-wide object\n\tis an actual  for a controlling formal, ignore anonymous access to\n\tsubprograms whose return type is an access to class_wide type.\n\t(Resolve_Slice): If the prefix of the slice is a selected component\n\twhose type depends on discriminants, build its actual subtype before\n\tapplying range checks on the bounds of the slice.\n\t(Valid_Conversion): In an instance or inlined body, compare root types,\n\tto prevent anomalies between private and public views.\n\t(Resolve): Improve error message for ambiguous fixed multiplication\n\texpressions that involve universal_fixed multiplying operations.\n\nFrom-SVN: r127447", "tree": {"sha": "fe3c7f04bfbb68679b926d252f03659644669819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe3c7f04bfbb68679b926d252f03659644669819"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa5147f00a99f736c4c75871979f738241579084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa5147f00a99f736c4c75871979f738241579084", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa5147f00a99f736c4c75871979f738241579084", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa5147f00a99f736c4c75871979f738241579084/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11560bcc3526da0ab979df1349f3339068e5345a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11560bcc3526da0ab979df1349f3339068e5345a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11560bcc3526da0ab979df1349f3339068e5345a"}], "stats": {"total": 241, "additions": 167, "deletions": 74}, "files": [{"sha": "94a57c93bd274c10c1c6580afb7bb3c5980786cd", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 167, "deletions": 74, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa5147f00a99f736c4c75871979f738241579084/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa5147f00a99f736c4c75871979f738241579084/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=aa5147f00a99f736c4c75871979f738241579084", "patch": "@@ -522,7 +522,7 @@ package body Sem_Res is\n                --  Warn about the danger\n \n                Error_Msg_N\n-                 (\"creation of & object may raise Storage_Error?\",\n+                 (\"?creation of & object may raise Storage_Error!\",\n                   Scope (Disc));\n \n                <<No_Danger>>\n@@ -732,7 +732,7 @@ package body Sem_Res is\n \n             --  for generating a stub function\n \n-            if Nkind (Parent (N)) = N_Return_Statement\n+            if Nkind (Parent (N)) = N_Simple_Return_Statement\n               and then Same_Argument_List\n             then\n                exit when not Is_List_Member (Parent (N));\n@@ -768,8 +768,8 @@ package body Sem_Res is\n          end if;\n       end loop;\n \n-      Error_Msg_N (\"possible infinite recursion?\", N);\n-      Error_Msg_N (\"\\Storage_Error may be raised at run time?\", N);\n+      Error_Msg_N (\"!?possible infinite recursion\", N);\n+      Error_Msg_N (\"\\!?Storage_Error may be raised at run time\", N);\n \n       return True;\n    end Check_Infinite_Recursion;\n@@ -793,29 +793,42 @@ package body Sem_Res is\n       -------------\n \n       function Uses_SS (T : Entity_Id) return Boolean is\n-         Comp : Entity_Id;\n-         Expr : Node_Id;\n+         Comp      : Entity_Id;\n+         Expr      : Node_Id;\n+         Full_Type : Entity_Id := Underlying_Type (T);\n \n       begin\n-         if Is_Controlled (T) then\n+         --  Normally we want to use the underlying type, but if it's not set\n+         --  then continue with T.\n+\n+         if not Present (Full_Type) then\n+            Full_Type := T;\n+         end if;\n+\n+         if Is_Controlled (Full_Type) then\n             return False;\n \n-         elsif Is_Array_Type (T) then\n-            return Uses_SS (Component_Type (T));\n+         elsif Is_Array_Type (Full_Type) then\n+            return Uses_SS (Component_Type (Full_Type));\n \n-         elsif Is_Record_Type (T) then\n-            Comp := First_Component (T);\n+         elsif Is_Record_Type (Full_Type) then\n+            Comp := First_Component (Full_Type);\n             while Present (Comp) loop\n                if Ekind (Comp) = E_Component\n                  and then Nkind (Parent (Comp)) = N_Component_Declaration\n                then\n-                  Expr := Expression (Parent (Comp));\n+                  --  The expression for a dynamic component may be rewritten\n+                  --  as a dereference, so retrieve original node.\n+\n+                  Expr := Original_Node (Expression (Parent (Comp)));\n \n-                  --  The expression for a dynamic component may be\n-                  --  rewritten as a dereference. Retrieve original\n-                  --  call.\n+                  --  Return True if the expression is a call to a function\n+                  --  (including an attribute function such as Image) with\n+                  --  a result that requires a transient scope.\n \n-                  if Nkind (Original_Node (Expr)) = N_Function_Call\n+                  if (Nkind (Expr) = N_Function_Call\n+                       or else (Nkind (Expr) = N_Attribute_Reference\n+                                 and then Present (Expressions (Expr))))\n                     and then Requires_Transient_Scope (Etype (Expr))\n                   then\n                      return True;\n@@ -1374,34 +1387,55 @@ package body Sem_Res is\n \n    begin\n       if Is_Binary then\n-         if    Op_Name =  Name_Op_And      then Kind := N_Op_And;\n-         elsif Op_Name =  Name_Op_Or       then Kind := N_Op_Or;\n-         elsif Op_Name =  Name_Op_Xor      then Kind := N_Op_Xor;\n-         elsif Op_Name =  Name_Op_Eq       then Kind := N_Op_Eq;\n-         elsif Op_Name =  Name_Op_Ne       then Kind := N_Op_Ne;\n-         elsif Op_Name =  Name_Op_Lt       then Kind := N_Op_Lt;\n-         elsif Op_Name =  Name_Op_Le       then Kind := N_Op_Le;\n-         elsif Op_Name =  Name_Op_Gt       then Kind := N_Op_Gt;\n-         elsif Op_Name =  Name_Op_Ge       then Kind := N_Op_Ge;\n-         elsif Op_Name =  Name_Op_Add      then Kind := N_Op_Add;\n-         elsif Op_Name =  Name_Op_Subtract then Kind := N_Op_Subtract;\n-         elsif Op_Name =  Name_Op_Concat   then Kind := N_Op_Concat;\n-         elsif Op_Name =  Name_Op_Multiply then Kind := N_Op_Multiply;\n-         elsif Op_Name =  Name_Op_Divide   then Kind := N_Op_Divide;\n-         elsif Op_Name =  Name_Op_Mod      then Kind := N_Op_Mod;\n-         elsif Op_Name =  Name_Op_Rem      then Kind := N_Op_Rem;\n-         elsif Op_Name =  Name_Op_Expon    then Kind := N_Op_Expon;\n+         if    Op_Name =  Name_Op_And      then\n+            Kind := N_Op_And;\n+         elsif Op_Name =  Name_Op_Or       then\n+            Kind := N_Op_Or;\n+         elsif Op_Name =  Name_Op_Xor      then\n+            Kind := N_Op_Xor;\n+         elsif Op_Name =  Name_Op_Eq       then\n+            Kind := N_Op_Eq;\n+         elsif Op_Name =  Name_Op_Ne       then\n+            Kind := N_Op_Ne;\n+         elsif Op_Name =  Name_Op_Lt       then\n+            Kind := N_Op_Lt;\n+         elsif Op_Name =  Name_Op_Le       then\n+            Kind := N_Op_Le;\n+         elsif Op_Name =  Name_Op_Gt       then\n+            Kind := N_Op_Gt;\n+         elsif Op_Name =  Name_Op_Ge       then\n+            Kind := N_Op_Ge;\n+         elsif Op_Name =  Name_Op_Add      then\n+            Kind := N_Op_Add;\n+         elsif Op_Name =  Name_Op_Subtract then\n+            Kind := N_Op_Subtract;\n+         elsif Op_Name =  Name_Op_Concat   then\n+            Kind := N_Op_Concat;\n+         elsif Op_Name =  Name_Op_Multiply then\n+            Kind := N_Op_Multiply;\n+         elsif Op_Name =  Name_Op_Divide   then\n+            Kind := N_Op_Divide;\n+         elsif Op_Name =  Name_Op_Mod      then\n+            Kind := N_Op_Mod;\n+         elsif Op_Name =  Name_Op_Rem      then\n+            Kind := N_Op_Rem;\n+         elsif Op_Name =  Name_Op_Expon    then\n+            Kind := N_Op_Expon;\n          else\n             raise Program_Error;\n          end if;\n \n       --  Unary operators\n \n       else\n-         if    Op_Name =  Name_Op_Add      then Kind := N_Op_Plus;\n-         elsif Op_Name =  Name_Op_Subtract then Kind := N_Op_Minus;\n-         elsif Op_Name =  Name_Op_Abs      then Kind := N_Op_Abs;\n-         elsif Op_Name =  Name_Op_Not      then Kind := N_Op_Not;\n+         if    Op_Name =  Name_Op_Add      then\n+            Kind := N_Op_Plus;\n+         elsif Op_Name =  Name_Op_Subtract then\n+            Kind := N_Op_Minus;\n+         elsif Op_Name =  Name_Op_Abs      then\n+            Kind := N_Op_Abs;\n+         elsif Op_Name =  Name_Op_Not      then\n+            Kind := N_Op_Not;\n          else\n             raise Program_Error;\n          end if;\n@@ -1746,7 +1780,7 @@ package body Sem_Res is\n          Interp_Loop : while Present (It.Typ) loop\n \n             --  We are only interested in interpretations that are compatible\n-            --  with the expected type, any other interpretations are ignored\n+            --  with the expected type, any other interpretations are ignored.\n \n             if not Covers (Typ, It.Typ) then\n                if Debug_Flag_V then\n@@ -1755,6 +1789,20 @@ package body Sem_Res is\n                end if;\n \n             else\n+               --  Skip the current interpretation if it is disabled by an\n+               --  abstract operator. This action is performed only when the\n+               --  type against which we are resolving is the same as the\n+               --  type of the interpretation.\n+\n+               if Ada_Version >= Ada_05\n+                 and then It.Typ = Typ\n+                 and then Typ /= Universal_Integer\n+                 and then Typ /= Universal_Real\n+                 and then Present (It.Abstract_Op)\n+               then\n+                  goto Continue;\n+               end if;\n+\n                --  First matching interpretation\n \n                if not Found then\n@@ -1818,7 +1866,7 @@ package body Sem_Res is\n                            end loop;\n                         end;\n \n-                     elsif Nkind (N) in  N_Binary_Op\n+                     elsif Nkind (N) in N_Binary_Op\n                        and then (Etype (Left_Opnd (N)) = Any_Type\n                                   or else Etype (Right_Opnd (N)) = Any_Type)\n                      then\n@@ -1913,8 +1961,21 @@ package body Sem_Res is\n                        and then Scope (It.Nam) = Standard_Standard\n                        and then Present (Err_Type)\n                      then\n-                        Error_Msg_N\n-                          (\"\\\\possible interpretation (predefined)#!\", N);\n+                        --  Special-case the message for universal_fixed\n+                        --  operators, which are not declared with the type\n+                        --  of the operand, but appear forever in Standard.\n+\n+                        if  It.Typ = Universal_Fixed\n+                          and then Scope (It.Nam) = Standard_Standard\n+                        then\n+                           Error_Msg_N\n+                             (\"\\\\possible interpretation as \" &\n+                                \"universal_fixed operation \" &\n+                                  \"(RM 4.5.5 (19))\", N);\n+                        else\n+                           Error_Msg_N\n+                             (\"\\\\possible interpretation (predefined)#!\", N);\n+                        end if;\n \n                      elsif\n                        Nkind (Parent (It.Nam)) = N_Full_Type_Declaration\n@@ -1985,6 +2046,8 @@ package body Sem_Res is\n \n             end if;\n \n+            <<Continue>>\n+\n             --  Move to next interpretation\n \n             exit Interp_Loop when No (It.Typ);\n@@ -2190,11 +2253,13 @@ package body Sem_Res is\n                         Get_First_Interp (Name (N), Index, It);\n                         while Present (It.Nam) loop\n                            Error_Msg_Sloc := Sloc (It.Nam);\n-                           Error_Msg_Node_2 := It.Typ;\n-                           Error_Msg_NE (\"\\&  declared#, type&\", N, It.Nam);\n+                           Error_Msg_Node_2 := It.Nam;\n+                           Error_Msg_NE\n+                             (\"\\\\  type& for & declared#\", N, It.Typ);\n                            Get_Next_Interp (Index, It);\n                         end loop;\n                      end;\n+\n                   else\n                      Error_Msg_N (\"\\use -gnatf for details\", N);\n                   end if;\n@@ -2534,7 +2599,7 @@ package body Sem_Res is\n                if not Is_Aliased_View (Act) then\n                   Error_Msg_NE\n                     (\"object in prefixed call to& must be aliased\"\n-                         & \" ('R'M'-2005 4.3.1 (13))\",\n+                         & \" (RM-2005 4.3.1 (13))\",\n                     Prefix (Act), Nam);\n                end if;\n \n@@ -3012,11 +3077,11 @@ package body Sem_Res is\n                if Ada_Version >= Ada_05\n                  and then Is_Access_Type (F_Typ)\n                  and then Can_Never_Be_Null (F_Typ)\n-                 and then Nkind (A) = N_Null\n+                 and then Known_Null (A)\n                then\n                   Apply_Compile_Time_Constraint_Error\n                     (N      => A,\n-                     Msg    => \"(Ada 2005) NULL not allowed in \"\n+                     Msg    => \"(Ada 2005) null not allowed in \"\n                                & \"null-excluding formal?\",\n                      Reason => CE_Null_Not_Allowed);\n                end if;\n@@ -3127,6 +3192,7 @@ package body Sem_Res is\n             elsif Is_Access_Type (A_Typ)\n               and then Is_Access_Type (F_Typ)\n               and then Ekind (F_Typ) /= E_Access_Subprogram_Type\n+              and then Ekind (F_Typ) /= E_Anonymous_Access_Subprogram_Type\n               and then (Is_Class_Wide_Type (Designated_Type (A_Typ))\n                          or else (Nkind (A) = N_Attribute_Reference\n                                    and then\n@@ -3634,8 +3700,8 @@ package body Sem_Res is\n          declare\n             Loc : constant Source_Ptr := Sloc (N);\n          begin\n-            Error_Msg_N (\"?allocation from empty storage pool\", N);\n-            Error_Msg_N (\"\\?Storage_Error will be raised at run time\", N);\n+            Error_Msg_N (\"?allocation from empty storage pool!\", N);\n+            Error_Msg_N (\"\\?Storage_Error will be raised at run time!\", N);\n             Insert_Action (N,\n               Make_Raise_Storage_Error (Loc,\n                 Reason => SE_Empty_Storage_Pool));\n@@ -3659,26 +3725,32 @@ package body Sem_Res is\n       if Nkind (N) = N_Allocator then\n \n          --  An anonymous access discriminant is the definition of a\n-         --  coextension\n+         --  coextension.\n \n          if Ekind (Typ) = E_Anonymous_Access_Type\n            and then Nkind (Associated_Node_For_Itype (Typ)) =\n                       N_Discriminant_Specification\n          then\n             --  Avoid marking an allocator as a dynamic coextension if it is\n-            --  withing a static construct.\n+            --  within a static construct.\n \n             if not Is_Static_Coextension (N) then\n-               Set_Is_Coextension (N);\n+               Set_Is_Dynamic_Coextension (N);\n             end if;\n \n          --  Cleanup for potential static coextensions\n \n          else\n-            Set_Is_Static_Coextension (N, False);\n+            Set_Is_Dynamic_Coextension (N, False);\n+            Set_Is_Static_Coextension  (N, False);\n          end if;\n \n-         Propagate_Coextensions (N);\n+         --  There is no need to propagate any nested coextensions if they\n+         --  are marked as static since they will be rewritten on the spot.\n+\n+         if not Is_Static_Coextension (N) then\n+            Propagate_Coextensions (N);\n+         end if;\n       end if;\n    end Resolve_Allocator;\n \n@@ -4269,7 +4341,7 @@ package body Sem_Res is\n                then\n                   Rtype := Etype (N);\n                   Error_Msg_NE\n-                    (\"& should not be used in entry body ('R'M C.7(17))?\",\n+                    (\"?& should not be used in entry body (RM C.7(17))\",\n                      N, Nam);\n                   Error_Msg_NE\n                     (\"\\Program_Error will be raised at run time?\", N, Nam);\n@@ -4535,9 +4607,9 @@ package body Sem_Res is\n \n                      Set_Has_Recursive_Call (Nam);\n                      Error_Msg_N\n-                       (\"possible infinite recursion?\", N);\n+                       (\"?possible infinite recursion!\", N);\n                      Error_Msg_N\n-                       (\"\\Storage_Error may be raised at run time?\", N);\n+                       (\"\\?Storage_Error may be raised at run time!\", N);\n                   end if;\n \n                   exit Scope_Loop;\n@@ -5485,10 +5557,8 @@ package body Sem_Res is\n       begin\n          if Ekind (Etype (R)) =  E_Allocator_Type then\n             Acc := Designated_Type (Etype (R));\n-\n          elsif Ekind (Etype (L)) =  E_Allocator_Type then\n             Acc := Designated_Type (Etype (L));\n-\n          else\n             return Empty;\n          end if;\n@@ -5568,7 +5638,7 @@ package body Sem_Res is\n            and then Entity (R) = Standard_True\n            and then Comes_From_Source (R)\n          then\n-            Error_Msg_N (\"comparison with True is redundant?\", R);\n+            Error_Msg_N (\"?comparison with True is redundant!\", R);\n          end if;\n \n          Check_Unset_Reference (L);\n@@ -6462,7 +6532,7 @@ package body Sem_Res is\n            and then not Is_Boolean_Type (Typ)\n            and then Parent_Is_Boolean\n          then\n-            Error_Msg_N (\"?not expression should be parenthesized here\", N);\n+            Error_Msg_N (\"?not expression should be parenthesized here!\", N);\n          end if;\n \n          Resolve (Right_Opnd (N), B_Typ);\n@@ -6627,7 +6697,7 @@ package body Sem_Res is\n                  and then Warn_On_Bad_Fixed_Value\n                then\n                   Error_Msg_N\n-                    (\"static fixed-point value is not a multiple of Small?\",\n+                    (\"?static fixed-point value is not a multiple of Small!\",\n                      N);\n                end if;\n \n@@ -6992,6 +7062,23 @@ package body Sem_Res is\n                   and then not Is_Constrained (Etype (Name)))\n       then\n          Array_Type := Get_Actual_Subtype (Name);\n+\n+      --  If the name is a selected component that depends on discriminants,\n+      --  build an actual subtype for it. This can happen only when the name\n+      --  itself is overloaded; otherwise the actual subtype is created when\n+      --  the selected component is analyzed.\n+\n+      elsif Nkind (Name) = N_Selected_Component\n+        and then Full_Analysis\n+        and then Depends_On_Discriminant (First_Index (Array_Type))\n+      then\n+         declare\n+            Act_Decl : constant Node_Id :=\n+                         Build_Actual_Subtype_Of_Component (Array_Type, Name);\n+         begin\n+            Insert_Action (N, Act_Decl);\n+            Array_Type := Defining_Identifier (Act_Decl);\n+         end;\n       end if;\n \n       --  If name was overloaded, set slice type correctly now\n@@ -7368,11 +7455,11 @@ package body Sem_Res is\n               and then abs (Realval (Rop)) < Delta_Value (Standard_Duration)\n             then\n                Error_Msg_N\n-                 (\"universal real operand can only \" &\n-                  \"be interpreted as Duration?\",\n+                 (\"?universal real operand can only \" &\n+                  \"be interpreted as Duration!\",\n                   Rop);\n                Error_Msg_N\n-                 (\"\\precision will be lost in the conversion\", Rop);\n+                 (\"\\?precision will be lost in the conversion!\", Rop);\n             end if;\n \n          elsif Is_Numeric_Type (Typ)\n@@ -7452,7 +7539,7 @@ package body Sem_Res is\n            and then Etype (Entity (Orig_N)) = Orig_T\n          then\n             Error_Msg_NE\n-              (\"?useless conversion, & has this type\", N, Entity (Orig_N));\n+              (\"?useless conversion, & has this type!\", N, Entity (Orig_N));\n          end if;\n       end if;\n \n@@ -7494,7 +7581,11 @@ package body Sem_Res is\n                     (\"type conversions require visibility of the full view\",\n                      N);\n \n-               elsif From_With_Type (Target) then\n+               elsif From_With_Type (Target)\n+                 and then not\n+                   (Is_Access_Type (Target_Typ)\n+                      and then Present (Non_Limited_View (Etype (Target))))\n+               then\n                   Error_Msg_Qual_Level := 99;\n                   Error_Msg_NE (\"missing with-clause on package &\", N,\n                     Cunit_Entity (Get_Source_Unit (Base_Type (Target))));\n@@ -7735,7 +7826,7 @@ package body Sem_Res is\n                --  If we fall through warning should be issued\n \n                Error_Msg_N\n-                 (\"?unary minus expression should be parenthesized here\", N);\n+                 (\"?unary minus expression should be parenthesized here!\", N);\n             end if;\n          end if;\n       end;\n@@ -8161,10 +8252,10 @@ package body Sem_Res is\n       end loop;\n \n       if Nkind (N) = N_Real_Literal then\n-         Error_Msg_NE (\"real literal interpreted as }?\", N, T1);\n+         Error_Msg_NE (\"?real literal interpreted as }!\", N, T1);\n \n       else\n-         Error_Msg_NE (\"universal_fixed expression interpreted as }?\", N, T1);\n+         Error_Msg_NE (\"?universal_fixed expression interpreted as }!\", N, T1);\n       end if;\n \n       return T1;\n@@ -8803,7 +8894,7 @@ package body Sem_Res is\n                Operand);\n             Error_Msg_N\n               (\"\\value has deeper accessibility than any master \" &\n-               \"('R'M 3.10.2 (13))\",\n+               \"(RM 3.10.2 (13))\",\n                Operand);\n \n             if Is_Entity_Name (Operand)\n@@ -8884,11 +8975,13 @@ package body Sem_Res is\n       elsif Root_Type (Target_Type) = Root_Type (Opnd_Type) then\n          return True;\n \n-      --  In an instance, there may be inconsistent views of the same\n-      --  type, or types derived from the same type.\n+      --  In an instance or an inlined body, there may be inconsistent\n+      --  views of the same type, or of types derived from a common root.\n \n-      elsif In_Instance\n-        and then Underlying_Type (Target_Type) = Underlying_Type (Opnd_Type)\n+      elsif (In_Instance or In_Inlined_Body)\n+        and then\n+           Root_Type (Underlying_Type (Target_Type)) =\n+           Root_Type (Underlying_Type (Opnd_Type))\n       then\n          return True;\n "}]}