{"sha": "0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFjNzMxODlkNmRhMmVjY2RhM2IxZmZiNGJiZTg5OTgxYjQ4NzlmNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T16:45:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T16:45:30Z"}, "message": "[multiple changes]\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_warn.adb (Check_Infinite_Loop_Warning.Test_Ref): Add defence\n\tagainst missing parent.\n\n2009-04-07  Thomas Quinot  <quinot@adacore.com>\n\n\t* xoscons.adb: Minor reformatting\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* rtsfind.ads: Remove obsolete string concatenation entries\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): Redo handling of bounds\n\n2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Check_Body_Required): Handle properly imported\n\tsubprograms.\n\n2009-04-07  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n\tAttribute_Address): When Init_Or_Norm_Scalars is True and the object\n\tis of a scalar or string type then suppress the setting of the\n\texpression to Empty.\n\n\t* freeze.adb (Warn_Overlay): Also emit the warnings about default\n\tinitialization for the cases of scalar and string objects when\n\tInit_Or_Norm_Scalars is True.\n\nFrom-SVN: r145694", "tree": {"sha": "bfc18dbf05196f8b80023ca115c77ad85245ea20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfc18dbf05196f8b80023ca115c77ad85245ea20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/comments", "author": null, "committer": null, "parents": [{"sha": "13d138bfb15b542cb490f5685ba6e109d356dfe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13d138bfb15b542cb490f5685ba6e109d356dfe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13d138bfb15b542cb490f5685ba6e109d356dfe4"}], "stats": {"total": 510, "additions": 360, "deletions": 150}, "files": [{"sha": "9211323337b733c5fd3d19ab1113b3e81b6296fc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "patch": "@@ -1,3 +1,36 @@\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_warn.adb (Check_Infinite_Loop_Warning.Test_Ref): Add defence\n+\tagainst missing parent.\n+\n+2009-04-07  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* xoscons.adb: Minor reformatting\n+\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* rtsfind.ads: Remove obsolete string concatenation entries\n+\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): Redo handling of bounds\n+\n+2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Check_Body_Required): Handle properly imported\n+\tsubprograms.\n+\n+2009-04-07  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n+\tAttribute_Address): When Init_Or_Norm_Scalars is True and the object\n+\tis of a scalar or string type then suppress the setting of the\n+\texpression to Empty.\n+\n+\t* freeze.adb (Warn_Overlay): Also emit the warnings about default\n+\tinitialization for the cases of scalar and string objects when\n+\tInit_Or_Norm_Scalars is True.\n+\n 2009-04-07  Bob Duff  <duff@adacore.com>\n \n \t* s-secsta.ads, g-pehage.ads, s-fileio.ads: Minor comment fixes"}, {"sha": "ebfd212f491abadc805cd843325e72c9c761ce54", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "patch": "@@ -34,6 +34,7 @@ with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n+with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch7;  use Sem_Ch7;\n@@ -91,6 +92,14 @@ package body Exp_Ch13 is\n             --  call to the init proc, and must be respected. Note that for\n             --  packed types we do not build equivalent aggregates.\n \n+            --  Also, if Init_Or_Norm_Scalars applies, then we need to retain\n+            --  any default initialization for objects of scalar types and\n+            --  types with scalar components. Normally a composite type will\n+            --  have an init_proc in the presence of Init_Or_Norm_Scalars,\n+            --  so when that flag is set we have just have to do a test for\n+            --  scalar and string types (the predefined string types such as\n+            --  String and Wide_String don't have an init_proc).\n+\n             declare\n                Decl : constant Node_Id := Declaration_Node (Ent);\n                Typ  : constant Entity_Id := Etype (Ent);\n@@ -106,6 +115,13 @@ package body Exp_Ch13 is\n                       Present (Static_Initialization (Base_Init_Proc (Typ)))\n                   then\n                      null;\n+\n+                  elsif Init_Or_Norm_Scalars\n+                    and then\n+                      (Is_Scalar_Type (Typ) or else Is_String_Type (Typ))\n+                  then\n+                     null;\n+\n                   else\n                      Set_Expression (Decl, Empty);\n                   end if;"}, {"sha": "df1d2bb26a9b30d1f4e55f8a62c85ebe2c6f8aeb", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 164, "deletions": 111, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "patch": "@@ -2158,6 +2158,12 @@ package body Exp_Ch4 is\n       Concatenation_Error : exception;\n       --  Raised if concatenation is sure to raise a CE\n \n+      Result_May_Be_Null : Boolean := True;\n+      --  Reset to False if at least one operand is encountered which is known\n+      --  at compile time to be non-null. Used for handling the special case\n+      --  of setting the high bound to the last operand high bound for a null\n+      --  result, thus ensuring a proper high bound in the super-flat case.\n+\n       N : constant Nat := List_Length (Opnds);\n       --  Number of concatenation operands including possibly null operands\n \n@@ -2177,38 +2183,47 @@ package body Exp_Ch4 is\n       --  Set to length of operand. Entries in this array are set only if the\n       --  corresponding entry in Is_Fixed_Length is True.\n \n-      Fixed_Low_Bound : array (1 .. N) of Uint;\n-      --  Set to lower bound of operand. Entries in this array are set only\n-      --  if the corresponding entry in Is_Fixed_Length is True.\n+      Opnd_Low_Bound : array (1 .. N) of Node_Id;\n+      --  Set to lower bound of operand. Either an integer literal in the case\n+      --  where the bound is known at compile time, else actual lower bound.\n+      --  The operand low bound is of type Ityp.\n+\n+      Opnd_High_Bound : array (1 .. N) of Node_Id;\n+      --  Set to upper bound of operand. Either an integer literal in the case\n+      --  where the bound is known at compile time, else actual upper bound.\n+      --  The operand bound is of type Ityp.\n \n       Var_Length : array (1 .. N) of Entity_Id;\n       --  Set to an entity of type Natural that contains the length of an\n       --  operand whose length is not known at compile time. Entries in this\n       --  array are set only if the corresponding entry in Is_Fixed_Length\n-      --  is False.\n+      --  is False. The entity is of type Intyp.\n \n       Aggr_Length : array (0 .. N) of Node_Id;\n       --  The J'th entry in an expression node that represents the total length\n       --  of operands 1 through J. It is either an integer literal node, or a\n       --  reference to a constant entity with the right value, so it is fine\n       --  to just do a Copy_Node to get an appropriate copy. The extra zero'th\n-      --  entry always is set to zero.\n+      --  entry always is set to zero. The length is of type Intyp.\n \n       Low_Bound : Node_Id;\n-      --  An tree node representing the low bound of the result. This is either\n-      --  an integer literal node, or an identifier reference to a constant\n-      --  entity initialized to the appropriate value.\n+      --  A tree node representing the low bound of the result (of type Ityp).\n+      --  This is either an integer literal node, or an identifier reference to\n+      --  a constant entity initialized to the appropriate value.\n+\n+      High_Bound : Node_Id;\n+      --  A tree node representing the high bound of the result (of type Ityp)\n \n       Result : Node_Id;\n-      --  Result of the concatenation\n+      --  Result of the concatenation (of type Ityp)\n \n       function To_Intyp (X : Node_Id) return Node_Id;\n       --  Given a node of type Ityp, returns the corresponding value of type\n       --  Intyp. For non-enumeration types, this is the identity. For enum\n-      --  types. the Pos of the value is returned.\n+      --  types, the Pos of the value is returned.\n \n       function To_Ityp (X : Node_Id) return Node_Id;\n-      --  The inverse function (uses Val in the case of enumeration types\n+      --  The inverse function (uses Val in the case of enumeration types)\n \n       --------------\n       -- To_Intyp --\n@@ -2247,9 +2262,9 @@ package body Exp_Ch4 is\n          --  Case where we will do a type conversion\n \n          else\n-            --  If the value is known at compile time, and known to be out\n-            --  of range of the index type or the base type, we can signal\n-            --  that we are sure to have a constraint error at run time.\n+            --  If the value is known at compile time, and known to be out of\n+            --  range of the index type or the base type, we can signal that\n+            --  we are sure to have a constraint error at run time.\n \n             --  There are two reasons for doing this. First of all, it is of\n             --  course nice to detect situations of certain exceptions, and\n@@ -2287,12 +2302,13 @@ package body Exp_Ch4 is\n \n       --  Local Declarations\n \n-      Opnd : Node_Id;\n-      Ent  : Entity_Id;\n-      Len  : Uint;\n-      J    : Nat;\n-      Clen : Node_Id;\n-      Set  : Boolean;\n+      Opnd     : Node_Id;\n+      Opnd_Typ : Entity_Id;\n+      Ent      : Entity_Id;\n+      Len      : Uint;\n+      J        : Nat;\n+      Clen     : Node_Id;\n+      Set      : Boolean;\n \n    begin\n       Aggr_Length (0) := Make_Integer_Literal (Loc, 0);\n@@ -2312,7 +2328,7 @@ package body Exp_Ch4 is\n       --  For enumeration types, we can simply use Standard_Integer, this is\n       --  sufficient since the actual number of enumeration literals cannot\n       --  possibly exceed the range of integer (remember we will be doing the\n-      --  arithmetic with POS values, not represaentation values).\n+      --  arithmetic with POS values, not representation values).\n \n       if Is_Enumeration_Type (Ityp) then\n          Intyp := Standard_Integer;\n@@ -2347,6 +2363,7 @@ package body Exp_Ch4 is\n       J := 1;\n       while J <= N loop\n          Opnd := Remove_Head (Opnds);\n+         Opnd_Typ := Etype (Opnd);\n \n          --  The parent got messed up when we put the operands in a list,\n          --  so now put back the proper parent for the saved operand.\n@@ -2359,52 +2376,71 @@ package body Exp_Ch4 is\n \n          --  Singleton element (or character literal) case\n \n-         if Base_Type (Etype (Opnd)) = Ctyp then\n+         if Base_Type (Opnd_Typ) = Ctyp then\n             NN := NN + 1;\n             Operands (NN) := Opnd;\n             Is_Fixed_Length (NN) := True;\n             Fixed_Length (NN) := Uint_1;\n+            Result_May_Be_Null := False;\n \n-            --  Set lower bound to lower bound of index subtype. This is not\n-            --  right where the index subtype bound is dynamic ???\n+            --  Set bounds of operand\n \n-            if Compile_Time_Known_Value (Type_Low_Bound (Ityp)) then\n-               Fixed_Low_Bound (NN) :=\n-                 Expr_Value (Type_Low_Bound (Ityp));\n-            else\n-               Fixed_Low_Bound (NN) :=\n-                 Expr_Value (Type_Low_Bound (Base_Type (Ityp)));\n-            end if;\n+            Opnd_Low_Bound (NN) :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Reference_To (Ityp, Loc),\n+                Attribute_Name => Name_First);\n+\n+            --  ??? The addition below is dubious, what if Ityp is an enum\n+            --  type, shouldn't this be Ityp'Succ (Ityp'First)?\n+\n+            Opnd_High_Bound (NN) :=\n+              Make_Op_Add (Loc,\n+                Left_Opnd =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => New_Reference_To (Ityp, Loc),\n+                    Attribute_Name => Name_First),\n+                Right_Opnd => Make_Integer_Literal (Loc, 1));\n \n             Set := True;\n \n          --  String literal case (can only occur for strings of course)\n \n          elsif Nkind (Opnd) = N_String_Literal then\n-            Len := UI_From_Int (String_Length (Strval (Opnd)));\n+            Len := String_Literal_Length (Opnd_Typ);\n \n-            --  We can safely skip null string literals, since they are\n-            --  considered to have a lower bound of 1.\n+            --  Skip null string literal unless last operand\n \n-            if Len = 0 then\n+            if J < N and then Len = 0 then\n                goto Continue;\n             end if;\n \n             NN := NN + 1;\n             Operands (NN) := Opnd;\n             Is_Fixed_Length (NN) := True;\n+\n+            --  Set length and bounds\n+\n             Fixed_Length (NN) := Len;\n-            Fixed_Low_Bound (NN) := Uint_1;\n+\n+            Opnd_Low_Bound (NN) :=\n+              New_Copy_Tree (String_Literal_Low_Bound (Opnd_Typ));\n+\n+            Opnd_High_Bound (NN) :=\n+              Make_Op_Add (Loc,\n+                Left_Opnd  =>\n+                  New_Copy_Tree (String_Literal_Low_Bound (Opnd_Typ)),\n+                Right_Opnd => Make_Integer_Literal (Loc, 1));\n+\n             Set := True;\n+            Result_May_Be_Null := False;\n \n          --  All other cases\n \n          else\n             --  Check constrained case with known bounds\n \n-            if Is_Constrained (Etype (Opnd)) then\n+            if Is_Constrained (Opnd_Typ) then\n                declare\n-                  Opnd_Typ : constant Entity_Id := Etype (Opnd);\n                   Index    : constant Node_Id   := First_Index (Opnd_Typ);\n                   Indx_Typ : constant Entity_Id := Etype (Index);\n                   Lo       : constant Node_Id   := Type_Low_Bound  (Indx_Typ);\n@@ -2425,40 +2461,61 @@ package body Exp_Ch4 is\n                                   UI_Max (Hival - Loval + 1, Uint_0);\n \n                      begin\n-                        --  Exclude the null length case where the lower bound\n-                        --  is other than 1 or the type is other than string,\n-                        --  because annoyingly we need to keep such an operand\n-                        --  around in case it is the one that supplies a lower\n-                        --  bound to the result.\n-\n-                        if (Loval = 1 and then Atyp = Standard_String)\n-                          or Len > 0\n-                        then\n-                           --  Skip null string case (lower bound = 1)\n-\n-                           if Len = 0 then\n-                              goto Continue;\n-                           end if;\n-\n-                           NN := NN + 1;\n-                           Operands (NN) := Opnd;\n-                           Is_Fixed_Length (NN) := True;\n-                           Fixed_Length (NN)    := Len;\n-                           Fixed_Low_Bound (NN) := Expr_Value (Lo);\n-                           Set := True;\n+                        if Len > 0 then\n+                           Result_May_Be_Null := False;\n+                        end if;\n+\n+                        --  Exclude null length case except for last operand\n+                        --  (where we may need it to get proper bounds).\n+\n+                        if Len = 0 and then J < N then\n+                           goto Continue;\n                         end if;\n+\n+                        NN := NN + 1;\n+                        Operands (NN) := Opnd;\n+                        Is_Fixed_Length (NN) := True;\n+                        Fixed_Length (NN)    := Len;\n+\n+                        --  ??? case where Ityp is an enum type?\n+\n+                        Opnd_Low_Bound (NN) :=\n+                          Make_Integer_Literal (Loc,\n+                            Intval => Expr_Value (Lo));\n+\n+                        Opnd_High_Bound (NN) :=\n+                          Make_Integer_Literal (Loc,\n+                            Intval => Expr_Value (Hi));\n+\n+                        Set := True;\n                      end;\n                   end if;\n                end;\n             end if;\n \n-            --  All cases where the length is not known at compile time, or\n-            --  the special case of an operand which is known to be null but\n-            --  has a lower bound other than 1 or is other than a string type.\n-            --  Capture length of operand in entity.\n+            --  All cases where the length is not known at compile time, or the\n+            --  special case of an operand which is known to be null but has a\n+            --  lower bound other than 1 or is other than a string type.\n \n             if not Set then\n                NN := NN + 1;\n+\n+               --  Capture operand bounds\n+\n+               Opnd_Low_Bound (NN) :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     Duplicate_Subexpr (Opnd, Name_Req => True),\n+                   Attribute_Name => Name_First);\n+\n+               Opnd_High_Bound (NN) :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     Duplicate_Subexpr (Opnd, Name_Req => True),\n+                   Attribute_Name => Name_Last);\n+\n+               --  Capture length of operand in entity\n+\n                Operands (NN) := Opnd;\n                Is_Fixed_Length (NN) := False;\n \n@@ -2487,7 +2544,7 @@ package body Exp_Ch4 is\n          --  Set next entry in aggregate length array\n \n          --  For first entry, make either integer literal for fixed length\n-         --  or a reference to the saved length for variable length\n+         --  or a reference to the saved length for variable length.\n \n          if NN = 1 then\n             if Is_Fixed_Length (1) then\n@@ -2554,9 +2611,7 @@ package body Exp_Ch4 is\n \n       if NN = 0 then\n          Start_String;\n-         Result :=\n-           Make_String_Literal (Loc,\n-             Strval => End_String);\n+         Result := Make_String_Literal (Loc, Strval => End_String);\n          goto Done;\n       end if;\n \n@@ -2586,28 +2641,26 @@ package body Exp_Ch4 is\n       --  ancestor is the first subtype of this root type.\n \n       if Is_Constrained (First_Subtype (Root_Type (Atyp))) then\n-         Low_Bound := To_Intyp (\n+         Low_Bound :=\n            Make_Attribute_Reference (Loc,\n              Prefix         =>\n                New_Occurrence_Of (First_Subtype (Root_Type (Atyp)), Loc),\n-             Attribute_Name => Name_First));\n+             Attribute_Name => Name_First);\n \n       --  If the first operand in the list has known length we know that\n       --  the lower bound of the result is the lower bound of this operand.\n \n       elsif Is_Fixed_Length (1) then\n-         Low_Bound :=\n-           Make_Integer_Literal (Loc,\n-             Intval => Fixed_Low_Bound (1));\n+         Low_Bound := Opnd_Low_Bound (1);\n \n       --  OK, we don't know the lower bound, we have to build a horrible\n       --  expression actions node of the form\n \n       --     if Cond1'Length /= 0 then\n-      --        Opnd1'First\n+      --        Opnd1 low bound\n       --     else\n       --        if Opnd2'Length /= 0 then\n-      --          Opnd2'First\n+      --          Opnd2 low bound\n       --        else\n       --           ...\n \n@@ -2626,23 +2679,9 @@ package body Exp_Ch4 is\n             ---------------------\n \n             function Get_Known_Bound (J : Nat) return Node_Id is\n-               Lo : Node_Id;\n-\n             begin\n-               if Is_Fixed_Length (J) then\n-                  return\n-                    Make_Integer_Literal (Loc,\n-                      Intval => Fixed_Low_Bound (J));\n-               end if;\n-\n-               Lo := To_Intyp (\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix =>\n-                     Duplicate_Subexpr (Operands (J), Name_Req => True),\n-                   Attribute_Name => Name_First));\n-\n-               if J = NN then\n-                  return Lo;\n+               if Is_Fixed_Length (J) or else J = NN then\n+                  return New_Copy (Opnd_Low_Bound (J));\n \n                else\n                   return\n@@ -2653,7 +2692,7 @@ package body Exp_Ch4 is\n                           Left_Opnd  => New_Reference_To (Var_Length (J), Loc),\n                           Right_Opnd => Make_Integer_Literal (Loc, 0)),\n \n-                        Lo,\n+                        New_Copy (Opnd_Low_Bound (J)),\n                         Get_Known_Bound (J + 1)));\n                end if;\n             end Get_Known_Bound;\n@@ -2667,17 +2706,40 @@ package body Exp_Ch4 is\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Ent,\n                 Constant_Present    => True,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (Intyp, Loc),\n+                Object_Definition   => New_Occurrence_Of (Ityp, Loc),\n                 Expression          => Get_Known_Bound (1)),\n               Suppress => All_Checks);\n \n             Low_Bound := New_Reference_To (Ent, Loc);\n          end;\n       end if;\n \n-      --  Now we build the result, which is a reference to the array entity\n-      --  we will construct with appropriate bounds.\n+      --  Now find the upper bound. This is normally the Low_Bound + Length - 1\n+      --  but there is one exception, namely when the result is null in which\n+      --  case the bounds come from the last operand (so that we get the proper\n+      --  bounds if the last operand is super-flat).\n+\n+      High_Bound :=\n+        To_Ityp (\n+          Make_Op_Add (Loc,\n+            Left_Opnd  => To_Intyp (New_Copy (Low_Bound)),\n+            Right_Opnd =>\n+              Make_Op_Subtract (Loc,\n+                Left_Opnd  => New_Copy (Aggr_Length (NN)),\n+                Right_Opnd => Make_Integer_Literal (Loc, 1))));\n+\n+      if Result_May_Be_Null then\n+         High_Bound :=\n+           Make_Conditional_Expression (Loc,\n+             Expressions => New_List (\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+               Opnd_High_Bound (NN),\n+               High_Bound));\n+      end if;\n+\n+      --  Now we construct an array object with appropriate bounds\n \n       Ent :=\n         Make_Defining_Identifier (Loc,\n@@ -2686,24 +2748,15 @@ package body Exp_Ch4 is\n       Insert_Action (Cnode,\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Ent,\n-\n           Object_Definition   =>\n             Make_Subtype_Indication (Loc,\n               Subtype_Mark => New_Occurrence_Of (Atyp, Loc),\n               Constraint   =>\n                 Make_Index_Or_Discriminant_Constraint (Loc,\n                   Constraints => New_List (\n                     Make_Range (Loc,\n-                      Low_Bound => To_Ityp (New_Copy (Low_Bound)),\n-                      High_Bound => To_Ityp (\n-                        Make_Op_Add (Loc,\n-                          Left_Opnd  => New_Copy (Low_Bound),\n-                          Right_Opnd =>\n-                            Make_Op_Subtract (Loc,\n-                              Left_Opnd  => New_Copy (Aggr_Length (NN)),\n-                              Right_Opnd =>\n-                                Make_Integer_Literal (Loc,\n-                                  Intval => Uint_1))))))))),\n+                      Low_Bound  => Low_Bound,\n+                      High_Bound => High_Bound))))),\n \n         Suppress => All_Checks);\n \n@@ -2713,18 +2766,16 @@ package body Exp_Ch4 is\n          declare\n             Lo : constant Node_Id :=\n                    Make_Op_Add (Loc,\n-                     Left_Opnd  => New_Copy (Low_Bound),\n+                     Left_Opnd  => To_Intyp (New_Copy (Low_Bound)),\n                      Right_Opnd => Aggr_Length (J - 1));\n \n             Hi : constant Node_Id :=\n                    Make_Op_Add (Loc,\n-                     Left_Opnd  => New_Copy (Low_Bound),\n+                     Left_Opnd  => To_Intyp (New_Copy (Low_Bound)),\n                      Right_Opnd =>\n                        Make_Op_Subtract (Loc,\n                          Left_Opnd  => Aggr_Length (J),\n-                         Right_Opnd =>\n-                           Make_Integer_Literal (Loc,\n-                             Intval => 1)));\n+                         Right_Opnd => Make_Integer_Literal (Loc, 1)));\n \n          begin\n             --  Singleton case, simple assignment\n@@ -2757,6 +2808,8 @@ package body Exp_Ch4 is\n          end;\n       end loop;\n \n+      --  Finally we build the result, which is a reference to the array object\n+\n       Result := New_Reference_To (Ent, Loc);\n \n    <<Done>>"}, {"sha": "9a2372efe1a0838337e9026551d5a8b7d8852305", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "patch": "@@ -5509,13 +5509,19 @@ package body Freeze is\n       end if;\n \n       --  We only give the warning for non-imported entities of a type for\n-      --  which a non-null base init proc is defined (or for access types which\n-      --  have implicit null initialization).\n+      --  which a non-null base init proc is defined, or for objects of access\n+      --  types with implicit null initialization, or when Initialize_Scalars\n+      --  applies and the type is scalar or a string type (the latter being\n+      --  tested for because predefined String types are initialized by inline\n+      --  code rather than by an init_proc).\n \n       if Present (Expr)\n-        and then (Has_Non_Null_Base_Init_Proc (Typ)\n-                    or else Is_Access_Type (Typ))\n         and then not Is_Imported (Ent)\n+        and then (Has_Non_Null_Base_Init_Proc (Typ)\n+                    or else Is_Access_Type (Typ)\n+                    or else (Init_Or_Norm_Scalars\n+                              and then (Is_Scalar_Type (Typ)\n+                                         or else Is_String_Type (Typ))))\n       then\n          if Nkind (Expr) = N_Attribute_Reference\n            and then Is_Entity_Name (Prefix (Expr))"}, {"sha": "314dc83c8a4a850a1a56df5bd0f5dec4da777a2b", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "patch": "@@ -322,10 +322,6 @@ package Rtsfind is\n       System_Storage_Elements,\n       System_Storage_Pools,\n       System_Stream_Attributes,\n-      System_String_Ops,\n-      System_String_Ops_Concat_3,\n-      System_String_Ops_Concat_4,\n-      System_String_Ops_Concat_5,\n       System_Task_Info,\n       System_Tasking,\n       System_Threads,\n@@ -1320,17 +1316,6 @@ package Rtsfind is\n      RE_W_WC,                            -- System.Stream_Attributes\n      RE_W_WWC,                           -- System.Stream_Attributes\n \n-     RE_Str_Concat,                      -- System.String_Ops\n-     RE_Str_Concat_CC,                   -- System.String_Ops\n-     RE_Str_Concat_CS,                   -- System.String_Ops\n-     RE_Str_Concat_SC,                   -- System.String_Ops\n-\n-     RE_Str_Concat_3,                    -- System.String_Ops_Concat_3\n-\n-     RE_Str_Concat_4,                    -- System.String_Ops_Concat_4\n-\n-     RE_Str_Concat_5,                    -- System.String_Ops_Concat_5\n-\n      RE_String_Input,                    -- System.Strings.Stream_Ops\n      RE_String_Input_Blk_IO,             -- System.Strings.Stream_Ops\n      RE_String_Output,                   -- System.Strings.Stream_Ops\n@@ -2474,17 +2459,6 @@ package Rtsfind is\n      RE_W_WC                             => System_Stream_Attributes,\n      RE_W_WWC                            => System_Stream_Attributes,\n \n-     RE_Str_Concat                       => System_String_Ops,\n-     RE_Str_Concat_CC                    => System_String_Ops,\n-     RE_Str_Concat_CS                    => System_String_Ops,\n-     RE_Str_Concat_SC                    => System_String_Ops,\n-\n-     RE_Str_Concat_3                     => System_String_Ops_Concat_3,\n-\n-     RE_Str_Concat_4                     => System_String_Ops_Concat_4,\n-\n-     RE_Str_Concat_5                     => System_String_Ops_Concat_5,\n-\n      RE_String_Input                     => System_Strings_Stream_Ops,\n      RE_String_Input_Blk_IO              => System_Strings_Stream_Ops,\n      RE_String_Output                    => System_Strings_Stream_Ops,"}, {"sha": "a135cd9f2cc0672cab88f8d132a5ff7f1f0502e7", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 130, "deletions": 8, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "patch": "@@ -3905,9 +3905,6 @@ package body Sem_Ch10 is\n       -- Check_Body_Required --\n       -------------------------\n \n-      --  ??? misses pragma Import on subprograms\n-      --  ??? misses pragma Import on renamed subprograms\n-\n       procedure Check_Body_Required is\n          PA : constant List_Id :=\n                 Pragmas_After (Aux_Decls_Node (Parent (P_Unit)));\n@@ -3923,6 +3920,97 @@ package body Sem_Ch10 is\n             Decl             : Node_Id;\n             Incomplete_Decls : constant Elist_Id := New_Elmt_List;\n \n+            Subp_List        : constant Elist_Id := New_Elmt_List;\n+\n+            procedure Check_Pragma_Import (P : Node_Id);\n+            --  If a pragma import applies to a previous subprogram, the\n+            --  enclosing unit may not need a body. The processing is\n+            --  syntactic and does not require a declaration to be analyzed,\n+            --  The code below also handles pragma import when applied to\n+            --  a subprogram that renames another. In this case the pragma\n+            --  applies to the renamed entity\n+            --  Chains of multiple renames are not handled by the code below.\n+            --  It is probably impossible to handle all cases without proper\n+            --  name resolution. In such cases the algorithm is conservative\n+            --  and will indicate that a body is needed???\n+\n+            -------------------------\n+            -- Check_Pragma_Import --\n+            -------------------------\n+\n+            procedure Check_Pragma_Import (P : Node_Id) is\n+               Arg      : Node_Id;\n+               Prev_Id  : Elmt_Id;\n+               Subp_Id  : Elmt_Id;\n+               Imported : Node_Id;\n+\n+               procedure Remove_Homonyms (E : Node_Id);\n+               --  Make one pass over list of subprograms, Called again if\n+               --  subprogram is a renaming. E is known to be an identifier.\n+\n+               ---------------------\n+               -- Remove_Homonyms --\n+               ---------------------\n+\n+               procedure Remove_Homonyms (E : Entity_Id) is\n+                  R : Entity_Id := Empty;\n+                  --  Name of renamed entity, if any.\n+\n+               begin\n+                  Subp_Id := First_Elmt (Subp_List);\n+\n+                  while Present (Subp_Id) loop\n+                     if Chars (Node (Subp_Id)) = Chars (E) then\n+                        if Nkind (Parent (Parent (Node (Subp_Id))))\n+                          /=  N_Subprogram_Renaming_Declaration\n+                        then\n+                           Prev_Id := Subp_Id;\n+                           Next_Elmt (Subp_Id);\n+                           Remove_Elmt (Subp_List, Prev_Id);\n+                        else\n+                           R := Name (Parent (Parent (Node (Subp_Id))));\n+                           exit;\n+                        end if;\n+                     else\n+                        Next_Elmt (Subp_Id);\n+                     end if;\n+                  end loop;\n+\n+                  if Present (R) then\n+                     if Nkind (R) = N_Identifier then\n+                        Remove_Homonyms (R);\n+\n+                     elsif Nkind (R) = N_Selected_Component then\n+                        Remove_Homonyms (Selector_Name (R));\n+\n+                     else\n+                        --  renaming of attribute\n+\n+                        null;\n+                     end if;\n+                  end if;\n+               end Remove_Homonyms;\n+\n+               --  Start of processing for Check_Pragma_Import\n+\n+            begin\n+\n+               --  Find name of entity in Import pragma. We have not analyzed\n+               --  the construct, so we must guard against syntax errors.\n+\n+               Arg := Next (First (Pragma_Argument_Associations (P)));\n+\n+               if No (Arg)\n+                 or else Nkind (Expression (Arg)) /= N_Identifier\n+               then\n+                  return;\n+               else\n+                  Imported := Expression (Arg);\n+               end if;\n+\n+               Remove_Homonyms (Imported);\n+            end Check_Pragma_Import;\n+\n          begin\n             --  Search for Elaborate Body pragma\n \n@@ -3942,15 +4030,15 @@ package body Sem_Ch10 is\n \n             while Present (Decl) loop\n \n-               --  Subprogram that comes from source means body required\n-               --  This is where a test for Import is missing ???\n+               --  Subprogram that comes from source means body may be needed.\n+               --  Save for subsequent examination of import pragmas.\n \n                if Comes_From_Source (Decl)\n                  and then (Nkind_In (Decl, N_Subprogram_Declaration,\n+                                           N_Subprogram_Renaming_Declaration,\n                                            N_Generic_Subprogram_Declaration))\n                then\n-                  Set_Body_Required (Library_Unit (N));\n-                  return;\n+                  Append_Elmt (Defining_Entity (Decl), Subp_List);\n \n                --  Package declaration of generic package declaration. We need\n                --  to recursively examine nested declarations.\n@@ -3959,6 +4047,11 @@ package body Sem_Ch10 is\n                                      N_Generic_Package_Declaration)\n                then\n                   Check_Declarations (Specification (Decl));\n+\n+               elsif Nkind (Decl) = N_Pragma\n+                 and then Pragma_Name (Decl) = Name_Import\n+               then\n+                  Check_Pragma_Import (Decl);\n                end if;\n \n                Next (Decl);\n@@ -3972,9 +4065,10 @@ package body Sem_Ch10 is\n             while Present (Decl) loop\n                if Comes_From_Source (Decl)\n                  and then (Nkind_In (Decl, N_Subprogram_Declaration,\n+                                           N_Subprogram_Renaming_Declaration,\n                                            N_Generic_Subprogram_Declaration))\n                then\n-                  Set_Body_Required (Library_Unit (N));\n+                  Append_Elmt (Defining_Entity (Decl), Subp_List);\n \n                elsif Nkind_In (Decl, N_Package_Declaration,\n                                      N_Generic_Package_Declaration)\n@@ -3985,6 +4079,11 @@ package body Sem_Ch10 is\n \n                elsif Nkind (Decl) = N_Incomplete_Type_Declaration then\n                   Append_Elmt (Decl, Incomplete_Decls);\n+\n+               elsif Nkind (Decl) = N_Pragma\n+                 and then Pragma_Name (Decl) = Name_Import\n+               then\n+                  Check_Pragma_Import (Decl);\n                end if;\n \n                Next (Decl);\n@@ -4022,6 +4121,29 @@ package body Sem_Ch10 is\n                   Next_Elmt (Inc);\n                end loop;\n             end;\n+\n+            --  Finally, check whether there are subprograms that still\n+            --  require a body.\n+\n+            if not Is_Empty_Elmt_List (Subp_List) then\n+               declare\n+                  Subp_Id : Elmt_Id;\n+\n+               begin\n+                  Subp_Id := First_Elmt (Subp_List);\n+\n+                  while Present (Subp_Id) loop\n+                     if Nkind (Parent (Parent (Node (Subp_Id))))\n+                        /= N_Subprogram_Renaming_Declaration\n+                     then\n+                        Set_Body_Required (Library_Unit (N));\n+                        return;\n+                     end if;\n+\n+                     Next_Elmt (Subp_Id);\n+                  end loop;\n+               end;\n+            end if;\n          end Check_Declarations;\n \n       --  Start of processing for Check_Body_Required"}, {"sha": "31f931e4679272a73dc7547f7d3a9386aea75db0", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ac73189d6da2eccda3b1ffb4bbe89981b4879f4/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=0ac73189d6da2eccda3b1ffb4bbe89981b4879f4", "patch": "@@ -490,7 +490,13 @@ package body Sem_Warn is\n                   P := Parent (P);\n                   exit when P = Loop_Statement;\n \n-                  if Nkind (P) = N_Procedure_Call_Statement then\n+                  --  Abandon if at procedure call, or something strange is\n+                  --  going on (perhaps a node with no parent that should\n+                  --  have one but does not?) As always, for a warning we\n+                  --  prefer to just abandon the warning than get into the\n+                  --  business of complaining about the tree structure here!\n+\n+                  if No (P) or else Nkind (P) = N_Procedure_Call_Statement then\n                      return Abandon;\n                   end if;\n                end loop;"}]}