{"sha": "9596236a48a791fd47e057d842bdb12622e27751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU5NjIzNmE0OGE3OTFmZDQ3ZTA1N2Q4NDJiZGIxMjYyMmUyNzc1MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-10T17:30:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-10T17:30:00Z"}, "message": "[multiple changes]\n\n2003-11-10  Ed Falis  <falis@gnat.com>\n\n\t* 5ytiitho.adb: (procStartHookAdd): Definition and call deleted\n\n\t* 5zinit.adb: (Install_Handler): Moved back to spec\n\t(Install_Signal_Handlers): Deleted\n\n\t* 5zthrini.adb: Added context clause for System.Storage_Elements\n\t(Register): Only handles creation of taskVar; initialization moved to\n\tThread_Body_Enter.\n\t(Reset_TSD): Deleted; replaced by Thread_Body_Enter\n\tAdded declaration of environment task secondary stack and\n\tinitialization.\n\n\t* s-thread.adb: Implement bodies for thread body processing\n\n\t* s-thread.ads:\n\tAdded comment identifying supported targets for pragma Thread_Body.\n\n2003-11-10  Pascal Obry  <obry@gnat.com>\n\n\t* adaint.c (_gnat_stat) [WIN32]: Check if name is not bigger than\n\tGNAT_MAX_PATH_LEN.\n\n\t* s-fileio.adb:\n\t(Open): Properly check for string length before copying into the buffer.\n\tRaises Name_Error if buffer is too small. Note that this was a potential\n\tbuffer overflow.\n\n2003-11-10  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* bindgen.adb, comperr.adb: Code clean ups.\n\t* gnatvsn.ads, gnatvsn.adb (Get_Gnat_Version_Type): New function.\n\n2003-11-10  Sergey Rybin  <rybin@act-europe.fr>\n\n\t* gnat1drv.adb: Add call to Sem_Elim.Initialize.\n\n2003-11-10  Vincent Celier  <celier@gnat.com>\n\n\t* gprcmd.adb:\n\t(Gprcmd): Add new command \"prefix\" to get the prefix of the GNAT\n\tinstallation.\n\n\t* make.adb (Scan_Make_Arg): Transmit -nostdlib to the compiler\n\n\t* prj.adb: (Project_Empty): Add new boolean component Virtual\n\n\t* prj.ads: (Virtual_Prefix): New constant string\n\t(Project_Data): New boolean component Virtual\n\n\t* prj-nmsc.adb (Language_Independent_Check): Adjust error message when\n\ta library project is extended by a virtual extending project.\n\n\t* prj-part.adb:\n\tModifications throughout to implement extending-all project, including:\n\t(Virtual_Hash, Processed_Hash): New hash tables\n\t(Create_Virtual_Extending_Project): New procedure\n\t(Look_For_Virtual_Projects_For): New procedure\n\n\t* prj-proc.adb:\n\t(Process): After checking the projects, if main project is an\n\textending-all project, set the object directory of all virtual extending\n\tproject to the object directory of the main project.\n\tAdjust error message when a virtual extending project has the same\n\tobject directory as an project being extended.\n\t(Recursive_Process): If name starts with the virtual prefix, set Virtual\n\tto True in the project data.\n\n\t* prj-tree.adb:\n\t(Default_Project_Node): Add new boolean component Extending_All\n\t(Is_Extending_All): New function\n\t(Set_Is_Extending_All): New procedure\n\n\t* prj-tree.ads: (Is_Extending_All): New function\n\t(Set_Is_Extending_All): New procedure\n\t(Project_Node_Record): New boolean component Extending_All\n\n\t* switch-c.adb: (Scan_Front_End_Switches): Process -nostdlib\n\n\t* vms_data.ads:\n\tAdd qualifier /NOSTD_LIBRARIES (-nostdlib) for the compiler\n\n\t* bld.adb (Recursive_Process): If MAKE_ROOT is not defined, call\n\t\"gprcmd prefix\" to define it.\n\n2003-11-10  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* einfo.ads: Fix a typo and remove an extraneous word in comments.\n\n\t* lib-load.adb:\n\t(Create_Dummy_Package_Unit): Set the scope of the entity for the\n\tcreated dummy package to Standard_Standard, not to itself, to\n\tdefend other parts of the front-end against encoutering a cycle in\n\tthe scope chain.\n\n\t* sem_ch10.adb:\n\t(Analyze_With_Clause): When setting the entities for the successive\n\tN_Expanded_Names that constitute the name of a child unit, do not\n\tattempt to go further than Standard_Standard in the chain of scopes.\n\tThis case arises from the placeholder units created by\n\tCreate_Dummy_Package_Unit in the case of a with_clause for a\n\tnonexistent child unit.\n\n2003-11-10  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_ch6.adb:\n\t(Expand_Thread_Body): Place subprogram on scope stack, so that new\n\tdeclarations are given the proper scope.\n\n\t* sem_ch13.adb:\n\t(Check_Expr_Constants): Reject an expression that contains a constant\n\tcreated during expansion, and that appears after the object to which\n\tthe address clause applies.\n\n\t* sem_ch5.adb (Check_Controlled_Array_Attribute): Subsidiary of\n\tAnalyze_Iteration_Scheme, to rewrite a loop parameter specification\n\tthat uses 'Range of a function call with controlled components, so\n\tthat the function result can be finalized before starting the loop.\n\n\t* sem_ch8.adb:\n\t(Find_Selected_Component): Improve error message when prefix is\n\tan implicit dereference of an incomplete type.\n\n2003-11-10  Robert Dewar  <dewar@gnat.com>\n\n\t* opt.ads: New Print_Standard flag for -gnatS switch\n\n\t* sem_ch13.adb: Remove some additional checks for unaligned arrays\n\n\t* cstand.adb (Create_Standard): Print out package standard if -gnatS\n\tswitch set\n\n\t* debug.adb: Update doc for -gnatds to discuss relationship with new\n\t-gnatS flag\n\n\t* sinfo.adb: Add new field Entity_Or_Associated_Node\n\n\t* sinfo.ads: Add new field Entity_Or_Associated_Node\n\tUpdate documentation for Associated_Node and Entity fields to clarify\n\trelationship and usage.\n\n\t* sprint.adb:\n\t(Write_Id): Properly process Associated_Node field in generic template\n\n\t* switch-c.adb:\n\tRecognize new -gnatS switch for printing package Standard\n\tThis replaces gnatpsta\n\n\t* usage.adb:\n\tAdd line for  new -gnatS switch for printing package Standard\n\tThis replaces gnatpsta\n\nFrom-SVN: r73423", "tree": {"sha": "dfac0747347cf48fa2234302e88ccacf93d8df72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfac0747347cf48fa2234302e88ccacf93d8df72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9596236a48a791fd47e057d842bdb12622e27751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9596236a48a791fd47e057d842bdb12622e27751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9596236a48a791fd47e057d842bdb12622e27751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9596236a48a791fd47e057d842bdb12622e27751/comments", "author": null, "committer": null, "parents": [{"sha": "e6178121705e52b01c0e1e73b6100471cfd4b23c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6178121705e52b01c0e1e73b6100471cfd4b23c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6178121705e52b01c0e1e73b6100471cfd4b23c"}], "stats": {"total": 1450, "additions": 1185, "deletions": 265}, "files": [{"sha": "ad2924d559d8e1de854bfbb0106ecf539ff5bffa", "filename": "gcc/ada/5ytiitho.adb", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2F5ytiitho.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2F5ytiitho.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ytiitho.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -35,10 +35,9 @@\n --  This is the VxWorks AE 653 version of this procedure\n \n separate (System.Threads.Initialization)\n-\n procedure Initialize_Task_Hooks is\n \n-   --  When defining the following routines for export in an AE 1.1\n+   --  When defining the following routine for export in an AE 1.1\n    --  simulation of AE653, Interfaces.C.int may be used for the\n    --  parameters of FUNCPTR.\n    type FUNCPTR is access function (T : OSI.Thread_Id) return OSI.STATUS;\n@@ -51,16 +50,7 @@ procedure Initialize_Task_Hooks is\n    pragma Import (C, procCreateHookAdd, \"procCreateHookAdd\");\n    --  Registers task registration routine for AE653\n \n-   procedure procStartHookAdd (StartHookFunction : FUNCPTR);\n-   pragma Import (C, procStartHookAdd, \"procStartHookAdd\");\n-   --  Registers task restart routine for AE653\n-\n-   Result : OSI.STATUS;\n begin\n-   --  Register the exported routines with the vThreads ARINC API\n+   --  Register the exported routine with the vThreads ARINC API\n    procCreateHookAdd (Register'Access);\n-   procStartHookAdd (Reset_TSD'Access);\n-   --  Register the environment task\n-   Result := Register (OSI.taskIdSelf);\n-   pragma Assert (Result /= -1);\n end Initialize_Task_Hooks;"}, {"sha": "e384d3b51169e1ab3590fe560a9ce82a11b27a42", "filename": "gcc/ada/5zinit.adb", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2F5zinit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2F5zinit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zinit.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -104,11 +104,6 @@ package body System.Init is\n    --  Common procedure that is executed when a SIGFPE, SIGILL,\n    --  SIGSEGV, or SIGBUS is captured.\n \n-   procedure Install_Handler;\n-   pragma Export (C, Install_Handler, \"__gnat_install_handler\");\n-   --  Install handler for the synchronous signals. The C profile\n-   --  here is what is expected by the binder-generated main.\n-\n    ------------------------\n    -- GNAT_Error_Handler --\n    ------------------------\n@@ -238,16 +233,6 @@ package body System.Init is\n       end if;\n    end Set_Globals;\n \n-   -----------------------------\n-   -- Install_Signal_Handlers --\n-   -----------------------------\n-\n-   function Install_Signal_Handlers return Interfaces.C.int is\n-   begin\n-      Install_Handler;\n-      return 0;\n-   end Install_Signal_Handlers;\n-\n    ---------------------\n    -- Install_Handler --\n    ---------------------"}, {"sha": "22777f49e7cb55d0e30d900202a2db95b9a68d82", "filename": "gcc/ada/5zthrini.adb", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2F5zthrini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2F5zthrini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zthrini.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -35,6 +35,7 @@\n --  the task hook libraries should be included in the VxWorks kernel.\n \n with System.Secondary_Stack;\n+with System.Storage_Elements;\n with Interfaces.C;\n with Unchecked_Conversion;\n \n@@ -64,12 +65,16 @@ package body System.Threads.Initialization is\n    --------------\n \n    function Register (T : OSI.Thread_Id) return OSI.STATUS is\n-      TSD : ATSD_Access := new ATSD;\n       Result : OSI.STATUS;\n    begin\n       --  It cannot be assumed that the caller of this routine has a ATSD;\n       --  so neither this procedure nor the procedures that it calls should\n-      --  raise or handle exceptions,  or make use of a secondary stack.\n+      --  raise or handle exceptions, or make use of a secondary stack.\n+\n+      --  This routine is only necessary because taskVarAdd cannot be\n+      --  executed once an AE653 partition has entered normal mode\n+      --  (depending on configRecord.c, allocation could be disabled).\n+      --  Otherwise, everything could have been done in Thread_Body_Enter.\n \n       if OSI.taskIdVerify (T) = OSI.ERROR\n         or else OSI.taskVarGet (T, Current_ATSD'Access) /= OSI.ERROR\n@@ -78,36 +83,34 @@ package body System.Threads.Initialization is\n       end if;\n \n       Result := OSI.taskVarAdd (T, Current_ATSD'Access);\n-      pragma Assert (Result /= -1);\n-      Result := OSI.taskVarSet (T, Current_ATSD'Access, TSD.all'Address);\n-      pragma Assert (Result /= -1);\n-      TSD.Sec_Stack_Addr := SSS.SS_Create;\n-      SSS.SS_Init (TSD.Sec_Stack_Addr);\n+      pragma Assert (Result /= OSI.ERROR);\n+\n       return Result;\n    end Register;\n \n-   ---------------\n-   -- Reset_TSD --\n-   ---------------\n+   subtype Default_Sec_Stack is\n+     System.Storage_Elements.Storage_Array\n+       (1 .. SSS.Default_Secondary_Stack_Size);\n \n-   function Reset_TSD (T : OSI.Thread_Id) return OSI.STATUS is\n-      TSD_Ptr : int;\n-      function To_Address is new Unchecked_Conversion\n-        (Interfaces.C.int, ATSD_Access);\n-   begin\n-      TSD_Ptr := OSI.taskVarGet (T, Current_ATSD'Access);\n-      pragma Assert (TSD_Ptr /= OSI.ERROR);\n+   Main_Sec_Stack : aliased Default_Sec_Stack;\n \n-      --  Just reset the secondary stack pointer.  The implementation here\n-      --  assumes that the fixed secondary stack implementation is used.\n-      --  If not, there will be a memory leak (along with allocation, which\n-      --  is prohibited for ARINC processes once the system enters \"normal\"\n-      --  mode).\n+   --  Secondary stack for environment task\n \n-      SSS.SS_Init (To_Address (TSD_Ptr).Sec_Stack_Addr);\n-      return OSI.OK;\n-   end Reset_TSD;\n+   Main_ATSD : aliased ATSD;\n+\n+   --  TSD for environment task\n \n begin\n    Initialize_Task_Hooks;\n+\n+   --  Register the environment task\n+   declare\n+      Result : Interfaces.C.int := Register (OSI.taskIdSelf);\n+      pragma Assert (Result /= OSI.ERROR);\n+   begin\n+      Thread_Body_Enter\n+        (Main_Sec_Stack'Address,\n+         Main_Sec_Stack'Size / System.Storage_Unit,\n+         Main_ATSD'Address);\n+   end;\n end System.Threads.Initialization;"}, {"sha": "52e00960b0e9c625835a956a9e47db473fa16c11", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -1339,7 +1339,10 @@ __gnat_stat (char *name, struct stat *statbuf)\n      terminated by a directory separator except if just after a drive name.  */\n   int name_len  = strlen (name);\n   char last_char = name[name_len - 1];\n-  char win32_name[4096];\n+  char win32_name[GNAT_MAX_PATH_LEN + 2];\n+\n+  if (name_len > GNAT_MAX_PATH_LEN)\n+    return -1;\n \n   strcpy (win32_name, name);\n "}, {"sha": "82b9135c2ecaedce4d4caf1dae60796da6b89963", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -1894,9 +1894,7 @@ package body Bindgen is\n    ---------------------\n \n    procedure Gen_Output_File (Filename : String) is\n-      Public_Version : constant Boolean := Gnat_Version_Type = \"PUBLIC \";\n-      --  Set true if this is the public version of GNAT\n-\n+      Is_Public_Version : constant Boolean := Get_Gnat_Build_Type = Public;\n    begin\n       --  Acquire settings for Interrupt_State pragmas\n \n@@ -1929,7 +1927,7 @@ package body Bindgen is\n \n       --  Get the time stamp of the former bind for public version warning\n \n-      if Public_Version then\n+      if Is_Public_Version then\n          Record_Time_From_Last_Bind;\n       end if;\n \n@@ -1944,7 +1942,7 @@ package body Bindgen is\n       --  Periodically issue a warning when the public version is used on\n       --  big projects\n \n-      if Public_Version then\n+      if Is_Public_Version then\n          Public_Version_Warning;\n       end if;\n    end Gen_Output_File;"}, {"sha": "725e9ca37402d7fd130fd5206576cfd5968ac7ba", "filename": "gcc/ada/bld.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fbld.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fbld.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbld.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -2595,6 +2595,25 @@ package body Bld is\n                --  Include some utility functions and saved all reserved\n                --  env. vars. by including Makefile.prolog.\n \n+               New_Line;\n+\n+               --  First, if MAKE_ROOT is not defined, try to get GNAT prefix\n+\n+               Put (\"   ifeq ($(\");\n+               Put (MAKE_ROOT);\n+               Put (\"),)\");\n+               New_Line;\n+\n+               Put (\"      MAKE_ROOT=$(shell gprcmd prefix)\");\n+               New_Line;\n+\n+               Put (\"   endif\");\n+               New_Line;\n+\n+               New_Line;\n+\n+               --  If MAKE_ROOT is still not defined, then fail\n+\n                Put (\"   ifeq ($(\");\n                Put (MAKE_ROOT);\n                Put (\"),)\");"}, {"sha": "81b8db54e3d36e9d03b6db5b7b1de91aea469cdb", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -80,12 +80,6 @@ package body Comperr is\n       --  the FSF version of GNAT, but there are specializations for\n       --  the GNATPRO and Public releases by Ada Core Technologies.\n \n-      Public_Version  : constant Boolean := Gnat_Version_Type = \"PUBLIC \";\n-      --  Set True for the public version of GNAT\n-\n-      GNATPRO_Version : constant Boolean := Gnat_Version_Type = \"GNATPRO\";\n-      --  Set True for the GNATPRO version of GNAT\n-\n       procedure End_Line;\n       --  Add blanks up to column 76, and then a final vertical bar\n \n@@ -99,6 +93,9 @@ package body Comperr is\n          Write_Eol;\n       end End_Line;\n \n+      Is_Public_Version : constant Boolean := Get_Gnat_Build_Type = Public;\n+      Is_FSF_Version    : constant Boolean := Get_Gnat_Build_Type = FSF;\n+\n    --  Start of processing for Compiler_Abort\n \n    begin\n@@ -264,7 +261,13 @@ package body Comperr is\n             --  Otherwise we use the standard fixed text\n \n             else\n-               if Public_Version or GNATPRO_Version then\n+               if Is_FSF_Version then\n+                  Write_Str\n+                    (\"| Please submit a bug report; see\" &\n+                     \" http://gcc.gnu.org/bugs.html.\");\n+                  End_Line;\n+\n+               else\n                   Write_Str\n                     (\"| Please submit bug report by email \" &\n                      \"to report@gnat.com.\");\n@@ -274,15 +277,9 @@ package body Comperr is\n                     (\"| Use a subject line meaningful to you\" &\n                      \" and us to track the bug.\");\n                   End_Line;\n-\n-               else\n-                  Write_Str\n-                    (\"| Please submit a bug report; see\" &\n-                     \" http://gcc.gnu.org/bugs.html.\");\n-                  End_Line;\n                end if;\n \n-               if GNATPRO_Version then\n+               if not (Is_Public_Version and Is_FSF_Version) then\n                   Write_Str\n                     (\"| (include your customer number #nnn \" &\n                      \"in the subject line).\");\n@@ -307,7 +304,7 @@ package body Comperr is\n                  (\"| (concatenated together with no headers between files).\");\n                End_Line;\n \n-               if Public_Version then\n+               if Is_Public_Version then\n                   Write_Str\n                     (\"| (use plain ASCII or MIME attachment).\");\n                   End_Line;\n@@ -317,7 +314,7 @@ package body Comperr is\n                      \"for submitting bugs.\");\n                   End_Line;\n \n-               elsif GNATPRO_Version then\n+               elsif not Is_FSF_Version then\n                   Write_Str\n                     (\"| (use plain ASCII or MIME attachment, or FTP \"\n                      & \"to your customer directory).\");"}, {"sha": "9cad4bea44dc5d2a829eff6bc72cf209c5afec49", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -33,6 +33,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Output;   use Output;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -120,6 +121,9 @@ package body CStand is\n       return          Entity_Id;\n    --  Builds a new entity for Standard\n \n+   procedure Print_Standard;\n+   --  Print representation of package Standard if switch set\n+\n    procedure Set_Integer_Bounds\n      (Id  : Entity_Id;\n       Typ : Entity_Id;\n@@ -1243,6 +1247,12 @@ package body CStand is\n       --  The Error node has an Etype of Any_Type to help error recovery\n \n       Set_Etype (Error, Any_Type);\n+\n+      --  Print representation of standard if switch set\n+\n+      if Opt.Print_Standard then\n+         Print_Standard;\n+      end if;\n    end Create_Standard;\n \n    ------------------------------------\n@@ -1417,6 +1427,249 @@ package body CStand is\n       return E;\n    end New_Standard_Entity;\n \n+   --------------------\n+   -- Print_Standard --\n+   --------------------\n+\n+   procedure Print_Standard is\n+\n+      procedure P (Item : String) renames Output.Write_Line;\n+      --  Short-hand, since we do a lot of line writes here!\n+\n+      procedure P_Int_Range (Size : Pos);\n+      --  Prints the range of an integer based on its Size\n+\n+      procedure P_Float_Range (Id : Entity_Id);\n+      --  Prints the bounds range for the given float type entity\n+\n+      -------------------\n+      -- P_Float_Range --\n+      -------------------\n+\n+      procedure P_Float_Range (Id : Entity_Id) is\n+         Digs : constant Nat := UI_To_Int (Digits_Value (Id));\n+\n+      begin\n+         Write_Str (\"     range \");\n+\n+         if Vax_Float (Id) then\n+            if Digs = VAXFF_Digits then\n+               Write_Str (VAXFF_First'Universal_Literal_String);\n+               Write_Str (\" .. \");\n+               Write_Str (VAXFF_Last'Universal_Literal_String);\n+\n+            elsif Digs = VAXDF_Digits then\n+               Write_Str (VAXDF_First'Universal_Literal_String);\n+               Write_Str (\" .. \");\n+               Write_Str (VAXDF_Last'Universal_Literal_String);\n+\n+            else\n+               pragma Assert (Digs = VAXGF_Digits);\n+\n+               Write_Str (VAXGF_First'Universal_Literal_String);\n+               Write_Str (\" .. \");\n+               Write_Str (VAXGF_Last'Universal_Literal_String);\n+            end if;\n+\n+         elsif Is_AAMP_Float (Id) then\n+            if Digs = AAMPS_Digits then\n+               Write_Str (AAMPS_First'Universal_Literal_String);\n+               Write_Str (\" .. \");\n+               Write_Str (AAMPS_Last'Universal_Literal_String);\n+\n+            else\n+               pragma Assert (Digs = AAMPL_Digits);\n+               Write_Str (AAMPL_First'Universal_Literal_String);\n+               Write_Str (\" .. \");\n+               Write_Str (AAMPL_Last'Universal_Literal_String);\n+            end if;\n+\n+         elsif Digs = IEEES_Digits then\n+            Write_Str (IEEES_First'Universal_Literal_String);\n+            Write_Str (\" .. \");\n+            Write_Str (IEEES_Last'Universal_Literal_String);\n+\n+\n+         elsif Digs = IEEEL_Digits then\n+            Write_Str (IEEEL_First'Universal_Literal_String);\n+            Write_Str (\" .. \");\n+            Write_Str (IEEEL_Last'Universal_Literal_String);\n+\n+         else\n+            pragma Assert (Digs = IEEEX_Digits);\n+\n+            Write_Str (IEEEX_First'Universal_Literal_String);\n+            Write_Str (\" .. \");\n+            Write_Str (IEEEX_Last'Universal_Literal_String);\n+         end if;\n+\n+         Write_Str (\";\");\n+         Write_Eol;\n+      end P_Float_Range;\n+\n+      -----------------\n+      -- P_Int_Range --\n+      -----------------\n+\n+      procedure P_Int_Range (Size : Pos) is\n+      begin\n+         Write_Str (\" is range -(2 **\");\n+         Write_Int (Size - 1);\n+         Write_Str (\")\");\n+         Write_Str (\" .. +(2 **\");\n+         Write_Int (Size - 1);\n+         Write_Str (\" - 1);\");\n+         Write_Eol;\n+      end P_Int_Range;\n+\n+   --  Start of processing for Print_Standard\n+\n+   begin\n+      P (\"--  Representation of package Standard\");\n+      Write_Eol;\n+      P (\"--  This is not accurate Ada, since new base types cannot be \");\n+      P (\"--  created, but the listing shows the target dependent\");\n+      P (\"--  characteristics of the Standard types for this compiler\");\n+      Write_Eol;\n+\n+      P (\"package Standard is\");\n+      P (\"pragma Pure(Standard);\");\n+      Write_Eol;\n+\n+      P (\"   type Boolean is (False, True);\");\n+      P (\"   for Boolean'Size use 1;\");\n+      P (\"   for Boolean use (False => 0, True => 1);\");\n+      Write_Eol;\n+\n+      --  Integer types\n+\n+      Write_Str (\"   type Integer\");\n+      P_Int_Range (Standard_Integer_Size);\n+      Write_Str (\"   for Integer'Size use \");\n+      Write_Int (Standard_Integer_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      P (\"   subtype Natural  is Integer range 0 .. Integer'Last;\");\n+      P (\"   subtype Positive is Integer range 1 .. Integer'Last;\");\n+      Write_Eol;\n+\n+      Write_Str (\"   type Short_Short_Integer\");\n+      P_Int_Range (Standard_Short_Short_Integer_Size);\n+      Write_Str (\"   for Short_Short_Integer'Size use \");\n+      Write_Int (Standard_Short_Short_Integer_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      Write_Str (\"   type Short_Integer\");\n+      P_Int_Range (Standard_Short_Integer_Size);\n+      Write_Str (\"   for Short_Integer'Size use \");\n+      Write_Int (Standard_Short_Integer_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      Write_Str (\"   type Long_Integer\");\n+      P_Int_Range (Standard_Long_Integer_Size);\n+      Write_Str (\"   for Long_Integer'Size use \");\n+      Write_Int (Standard_Long_Integer_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      Write_Str (\"   type Long_Long_Integer\");\n+      P_Int_Range (Standard_Long_Long_Integer_Size);\n+      Write_Str (\"   for Long_Long_Integer'Size use \");\n+      Write_Int (Standard_Long_Long_Integer_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      --  Floating point types\n+\n+      Write_Str (\"   type Short_Float is digits \");\n+      Write_Int (Standard_Short_Float_Digits);\n+      Write_Eol;\n+      P_Float_Range (Standard_Short_Float);\n+      Write_Str (\"   for Short_Float'Size use \");\n+      Write_Int (Standard_Short_Float_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      Write_Str (\"   type Float is digits \");\n+      Write_Int (Standard_Float_Digits);\n+      Write_Eol;\n+      P_Float_Range (Standard_Float);\n+      Write_Str (\"   for Float'Size use \");\n+      Write_Int (Standard_Float_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      Write_Str (\"   type Long_Float is digits \");\n+      Write_Int (Standard_Long_Float_Digits);\n+      Write_Eol;\n+      P_Float_Range (Standard_Long_Float);\n+      Write_Str (\"   for Long_Float'Size use \");\n+      Write_Int (Standard_Long_Float_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      Write_Str (\"   type Long_Long_Float is digits \");\n+      Write_Int (Standard_Long_Long_Float_Digits);\n+      Write_Eol;\n+      P_Float_Range (Standard_Long_Long_Float);\n+      Write_Str (\"   for Long_Long_Float'Size use \");\n+      Write_Int (Standard_Long_Long_Float_Size);\n+      P (\";\");\n+      Write_Eol;\n+\n+      P (\"   type Character is (...)\");\n+      Write_Str (\"   for Character'Size use \");\n+      Write_Int (Standard_Character_Size);\n+      P (\";\");\n+      P (\"   --  See RM A.1(35) for details of this type\");\n+      Write_Eol;\n+\n+      P (\"   type Wide_Character is (...)\");\n+      Write_Str (\"   for Wide_Character'Size use \");\n+      Write_Int (Standard_Wide_Character_Size);\n+      P (\";\");\n+      P (\"   --  See RM A.1(36) for details of this type\");\n+      Write_Eol;\n+\n+      P (\"   type String is array (Positive range <>) of Character;\");\n+      P (\"   pragma Pack (String);\");\n+      Write_Eol;\n+\n+      P (\"   type Wide_String is array (Positive range <>)\" &\n+         \" of Wide_Character;\");\n+      P (\"   pragma Pack (Wide_String);\");\n+      Write_Eol;\n+\n+      --  Here it's OK to use the Duration type of the host compiler since\n+      --  the implementation of Duration in GNAT is target independent.\n+\n+      if Duration_32_Bits_On_Target then\n+         P (\"   type Duration is delta 0.020\");\n+         P (\"     range -((2 ** 31 - 1) * 0.020) ..\");\n+         P (\"           +((2 ** 31 - 1) * 0.020);\");\n+         P (\"   for Duration'Small use 0.020;\");\n+      else\n+         P (\"   type Duration is delta 0.000000001\");\n+         P (\"     range -((2 ** 63 - 1) * 0.000000001) ..\");\n+         P (\"           +((2 ** 63 - 1) * 0.000000001);\");\n+         P (\"   for Duration'Small use 0.000000001;\");\n+      end if;\n+\n+      Write_Eol;\n+\n+      P (\"   Constraint_Error : exception;\");\n+      P (\"   Program_Error    : exception;\");\n+      P (\"   Storage_Error    : exception;\");\n+      P (\"   Tasking_Error    : exception;\");\n+      P (\"   Numeric_Error    : exception renames Constraint_Error;\");\n+      Write_Eol;\n+\n+      P (\"end Standard;\");\n+   end Print_Standard;\n+\n    ----------------------\n    -- Set_Float_Bounds --\n    ----------------------"}, {"sha": "3c6a67f5ac04f4de09fb208195c24a1ab667e413", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -338,7 +338,9 @@ package body Debug is\n    --  dz   Print source of package Standard. Normally the source print out\n    --       does not include package Standard, even if the -df switch is set.\n    --       This switch forces output of the source recreated from the internal\n-   --       tree built for Standard.\n+   --       tree built for Standard. Note that this differs from -gnatS in\n+   --       that it prints from the actual tree using the normal Sprint\n+   --       circuitry for printing trees.\n \n    --  dA   Forces output of representation information, including full\n    --       information for all internal type and object entities, as well"}, {"sha": "9a6a2d8edc53601355a1a1a2452b21fd25fe02ea", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -930,7 +930,7 @@ package Einfo is\n --       the record that is the fat pointer representation of an RAST.\n \n --    Esize (Uint12)\n---       Present in all types and subtypes, an also for components, constants,\n+--       Present in all types and subtypes, and also for components, constants,\n --       and variables. Contains the Object_Size of the type or of the object.\n --       A value of zero indicates that the value is not yet known.\n --\n@@ -2830,7 +2830,7 @@ package Einfo is\n --       Present in all type and subtype entities. Contains the value of\n --       type'Size as defined in the RM. See also the Esize field and\n --       and the description on \"Handling of Type'Size Values\". A value\n---       of zero for in this field for a non-discrete type means that\n+--       of zero in this field for a non-discrete type means that\n --       the front end has not yet determined the size value. For the\n --       case of a discrete type, this field is always set by the front\n --       end and zero is a legitimate value for a type with one value."}, {"sha": "5ac60af114ffc70b5db4fc01bd47ed9646ceac2b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -2944,6 +2944,8 @@ package body Exp_Ch6 is\n          Excep_Handlers : List_Id;\n \n       begin\n+         New_Scope (Spec_Id);\n+\n          --  Get proper setting for secondary stack size\n \n          if List_Length (Pragma_Argument_Associations (TB_Pragma)) = 2 then\n@@ -3046,6 +3048,7 @@ package body Exp_Ch6 is\n              Exception_Handlers => Excep_Handlers));\n \n          Analyze (Handled_Statement_Sequence (N));\n+         End_Scope;\n       end Expand_Thread_Body;\n \n    --  Start of processing for Expand_N_Subprogram_Body"}, {"sha": "6f9b8a0f2c6c5e9be5ebedd8fb150425befc7e52", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -54,6 +54,7 @@ with Sem;\n with Sem_Ch8;\n with Sem_Ch12;\n with Sem_Ch13;\n+with Sem_Elim;\n with Sem_Eval;\n with Sem_Type;\n with Sinfo;    use Sinfo;\n@@ -118,6 +119,7 @@ begin\n       Sem_Ch8.Initialize;\n       Sem_Ch12.Initialize;\n       Sem_Ch13.Initialize;\n+      Sem_Elim.Initialize;\n       Sem_Eval.Initialize;\n       Sem_Type.Init_Interp_Tables;\n "}, {"sha": "b15c6faf582fc699b79f85765d69ff6e4b688c35", "filename": "gcc/ada/gnatvsn.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgnatvsn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgnatvsn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatvsn.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -40,6 +40,15 @@ package body Gnatvsn is\n    --  check for the nul character in Gnat_Version_String.\n    pragma Import (C, Version_String, \"version_string\");\n \n+   -------------------------\n+   -- Get_Gnat_Build_Type --\n+   -------------------------\n+\n+   function Get_Gnat_Build_Type return Gnat_Build_Type is\n+   begin\n+      return FSF;\n+   end Get_Gnat_Build_Type;\n+\n    -------------------------\n    -- Gnat_Version_String --\n    -------------------------"}, {"sha": "9cbb871a7a2318bdcec7081917e73fd19518e9e0", "filename": "gcc/ada/gnatvsn.ads", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgnatvsn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgnatvsn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatvsn.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -45,12 +45,24 @@ package Gnatvsn is\n    --  Static string identifying this version, that can be used as an argument\n    --  to e.g. pragma Ident.\n \n-   Gnat_Version_Type : constant String := \"FSF    \";\n-   --  GNAT FSF version. This version of GNAT is part of a Free Software\n-   --  Foundation release of the GNU Compiler Collection (GCC). The binder\n-   --  will not output informational messages regarding intended use,\n-   --  and the bug box generated by Comperr will give information on\n-   --  how to report bugs and list the \"no warranty\" information.\n+   type Gnat_Build_Type is (FSF, Public);\n+   --  See Get_Gnat_Build_Type below for the meaning of these values.\n+\n+   function Get_Gnat_Build_Type return Gnat_Build_Type;\n+   --  This function returns one of the following values of Gnat_Build_Type:\n+   --\n+   --    FSF\n+   --       GNAT FSF version. This version of GNAT is part of a Free Software\n+   --       Foundation release of the GNU Compiler Collection (GCC). The binder\n+   --       will not output informational messages regarding intended use,\n+   --       and the bug box generated by Comperr will give information on\n+   --       how to report bugs and list the \"no warranty\" information.\n+   --\n+   --    Public\n+   --       GNAT Public version.\n+   --       The binder will output informational messages, and the bug box\n+   --       generated by the package Comperr will give appropriate bug\n+   --       submission instructions.\n \n    Ver_Len_Max : constant := 32;\n    --  Longest possible length for Gnat_Version_String in this or any"}, {"sha": "5cefb3b8684178babc1a688a64e090e57c188d87", "filename": "gcc/ada/gprcmd.adb", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgprcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fgprcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprcmd.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -37,6 +37,7 @@\n --    extend       handle recursive directories (\"/**\" notation)\n --    deps         post process dependency makefiles\n --    stamp        copy file time stamp from file1 to file2\n+--    prefix       get the prefix of the GNAT installation\n \n with Ada.Characters.Handling;   use Ada.Characters.Handling;\n with Ada.Command_Line;          use Ada.Command_Line;\n@@ -45,6 +46,8 @@ with GNAT.OS_Lib;               use GNAT.OS_Lib;\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.Regpat;               use GNAT.Regpat;\n with Gnatvsn;\n+with Osint;                     use Osint;\n+with Namet;                     use Namet;\n \n procedure Gprcmd is\n \n@@ -418,6 +421,40 @@ begin\n       elsif Cmd = \"stamp\" then\n          Check_Args (Argument_Count = 3);\n          Copy_Time_Stamp (Argument (2), Argument (3));\n+\n+      elsif Cmd = \"prefix\" then\n+\n+         --  Find the GNAT prefix. gprcmd is found in <prefix>/bin.\n+         --  So we find the full path of gprcmd, verify that it is in a\n+         --  subdirectory \"bin\", and return the <prefix> if it is the case.\n+         --  Otherwise, nothing is returned.\n+\n+         Find_Program_Name;\n+\n+         declare\n+            Path : String_Access :=\n+                     Locate_Exec_On_Path (Name_Buffer (1 .. Name_Len));\n+            Index : Natural;\n+\n+         begin\n+            if Path /= null then\n+               Index := Path'Last;\n+\n+               while Index >= Path'First + 4 loop\n+                  exit when Path (Index) = Directory_Separator;\n+                  Index := Index - 1;\n+               end loop;\n+\n+               if Index > Path'First + 5\n+                 and then Path (Index - 3 .. Index - 1) = \"bin\"\n+                 and then Path (Index - 4) = Directory_Separator\n+               then\n+                  --  We have found the <prefix>, return it.\n+\n+                  Put (Path (Path'First .. Index - 5));\n+               end if;\n+            end if;\n+         end;\n       end if;\n    end;\n end Gprcmd;"}, {"sha": "2f669751b000823618cb80d3caf6144eca67bacc", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -78,7 +78,6 @@ package body Lib.Load is\n    is\n       Unum         : Unit_Number_Type;\n       Cunit_Entity : Entity_Id;\n-      Scope_Entity : Entity_Id;\n       Cunit        : Node_Id;\n       Du_Name      : Node_Or_Entity_Id;\n       End_Lab      : Node_Id;\n@@ -98,11 +97,12 @@ package body Lib.Load is\n          Du_Name := Cunit_Entity;\n          End_Lab := New_Occurrence_Of (Cunit_Entity, No_Location);\n \n-         Scope_Entity := Standard_Standard;\n-\n       --  Child package\n \n-      else -- Nkind (Name (With_Node)) = N_Expanded_Name\n+      else\n+\n+         --  Nkind (Name (With_Node)) = N_Expanded_Name\n+\n          Cunit_Entity :=\n            Make_Defining_Identifier (No_Location,\n              Chars => Chars (Selector_Name (Name (With_Node))));\n@@ -113,19 +113,14 @@ package body Lib.Load is\n \n          Set_Is_Child_Unit (Cunit_Entity);\n \n-         if Nkind (Du_Name) = N_Defining_Program_Unit_Name then\n-            Scope_Entity := Defining_Identifier (Du_Name);\n-         else\n-            Scope_Entity := Du_Name;\n-         end if;\n-\n          End_Lab :=\n            Make_Designator (No_Location,\n              Name => New_Copy_Tree (Prefix (Name (With_Node))),\n              Identifier => New_Occurrence_Of (Cunit_Entity, No_Location));\n+\n       end if;\n \n-      Set_Scope (Cunit_Entity, Scope_Entity);\n+      Set_Scope (Cunit_Entity, Standard_Standard);\n \n       Cunit :=\n         Make_Compilation_Unit (No_Location,"}, {"sha": "21d299ebb85ccdd65beb69031131fc3e968952dc", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -460,8 +460,7 @@ package body Lib is\n    end Generic_Separately_Compiled;\n \n    function Generic_Separately_Compiled\n-     (Sfile : File_Name_Type)\n-      return  Boolean\n+     (Sfile : File_Name_Type) return Boolean\n    is\n    begin\n       --  Exactly the same as previous function, but works directly on a file\n@@ -534,8 +533,7 @@ package body Lib is\n    ----------------------------------\n \n    function Get_Cunit_Entity_Unit_Number\n-     (E    : Entity_Id)\n-      return Unit_Number_Type\n+     (E : Entity_Id) return Unit_Number_Type\n    is\n    begin\n       for U in Units.First .. Units.Last loop\n@@ -613,8 +611,7 @@ package body Lib is\n    --------------------------------\n \n    function In_Extended_Main_Code_Unit\n-     (N    : Node_Or_Entity_Id)\n-      return Boolean\n+     (N : Node_Or_Entity_Id) return Boolean\n    is\n    begin\n       if Sloc (N) = Standard_Location then\n@@ -647,10 +644,7 @@ package body Lib is\n       end if;\n    end In_Extended_Main_Code_Unit;\n \n-   function In_Extended_Main_Code_Unit\n-     (Loc :  Source_Ptr)\n-      return Boolean\n-   is\n+   function In_Extended_Main_Code_Unit (Loc : Source_Ptr) return Boolean is\n    begin\n       if Loc = Standard_Location then\n          return True;\n@@ -676,8 +670,7 @@ package body Lib is\n    ----------------------------------\n \n    function In_Extended_Main_Source_Unit\n-     (N    : Node_Or_Entity_Id)\n-      return Boolean\n+     (N : Node_Or_Entity_Id) return Boolean\n    is\n       Nloc : constant Source_Ptr := Sloc (N);\n       Mloc : constant Source_Ptr := Sloc (Cunit (Main_Unit));\n@@ -718,8 +711,7 @@ package body Lib is\n    end In_Extended_Main_Source_Unit;\n \n    function In_Extended_Main_Source_Unit\n-     (Loc  : Source_Ptr)\n-      return Boolean\n+     (Loc : Source_Ptr) return Boolean\n    is\n       Mloc : constant Source_Ptr := Sloc (Cunit (Main_Unit));\n "}, {"sha": "836491b01452d9596d452fbdefdb76130cee9a7f", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -462,8 +462,7 @@ package Lib is\n    --  and False otherwise.\n \n    function In_Extended_Main_Code_Unit\n-     (N    : Node_Or_Entity_Id)\n-      return Boolean;\n+     (N : Node_Or_Entity_Id) return Boolean;\n    --  Return True if the node is in the generated code of the extended main\n    --  unit, defined as the main unit, its specification (if any), and all\n    --  its subunits (considered recursively). Units for which this enquiry\n@@ -472,15 +471,12 @@ package Lib is\n    --  If the main unit is itself a subunit, then the extended main unit\n    --  includes its parent unit, and the parent unit spec if it is separate.\n \n-   function In_Extended_Main_Code_Unit\n-     (Loc :  Source_Ptr)\n-      return Boolean;\n+   function In_Extended_Main_Code_Unit (Loc : Source_Ptr) return Boolean;\n    --  Same function as above, but argument is a source pointer rather\n    --  than a node.\n \n    function In_Extended_Main_Source_Unit\n-     (N    : Node_Or_Entity_Id)\n-      return Boolean;\n+     (N : Node_Or_Entity_Id) return Boolean;\n    --  Return True if the node is in the source text of the extended main\n    --  unit, defined as the main unit, its specification (if any), and all\n    --  its subunits (considered recursively). Units for which this enquiry\n@@ -490,9 +486,7 @@ package Lib is\n    --  a subunit, then the extended main unit includes its parent unit,\n    --  and the parent unit spec if it is separate.\n \n-   function In_Extended_Main_Source_Unit\n-     (Loc :  Source_Ptr)\n-      return Boolean;\n+   function In_Extended_Main_Source_Unit (Loc : Source_Ptr) return Boolean;\n    --  Same function as above, but argument is a source pointer rather\n    --  than a node.\n \n@@ -515,8 +509,7 @@ package Lib is\n    --  could not have been built without making a unit table entry.\n \n    function Get_Cunit_Entity_Unit_Number\n-     (E    : Entity_Id)\n-      return Unit_Number_Type;\n+     (E : Entity_Id) return Unit_Number_Type;\n    --  Return unit number of the unit whose compilation unit spec entity is\n    --  the one passed as an argument. This must always succeed since the\n    --  entity could not have been built without making a unit table entry.\n@@ -603,8 +596,7 @@ package Lib is\n    --  compiled with the current approach.\n \n    function Generic_Separately_Compiled\n-     (Sfile : File_Name_Type)\n-      return  Boolean;\n+     (Sfile : File_Name_Type) return  Boolean;\n    --  Same as the previous function, but works directly on a unit file name.\n \n private"}, {"sha": "d734dd54f10cc6c082416613d0e70eaab5a2a42d", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -3595,7 +3595,7 @@ package body Make is\n                         end loop Look_For_Foreign;\n                      end if;\n \n-                     --  The, find all mains, or if there is a foreign\n+                     --  Then, find all mains, or if there is a foreign\n                      --  language, all the Ada mains.\n \n                      while Value /= Prj.Nil_String loop\n@@ -6848,11 +6848,13 @@ package body Make is\n             --  linking with all standard library files.\n \n             Opt.No_Stdlib := True;\n+\n+            Add_Switch (Argv, Compiler, And_Save => And_Save);\n             Add_Switch (Argv, Binder, And_Save => And_Save);\n \n          elsif Argv (2 .. Argv'Last) = \"nostdinc\" then\n \n-            --  Pass -nostdinv to the Compiler and to gnatbind\n+            --  Pass -nostdinc to the Compiler and to gnatbind\n \n             Opt.No_Stdinc := True;\n             Add_Switch (Argv, Compiler, And_Save => And_Save);"}, {"sha": "356564a12ab979b8b54d58fc88a2c4d6647b771f", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -719,6 +719,11 @@ package Opt is\n    --  Set to True to enable output of generated code in source form. This\n    --  flag is set by the -gnatG switch.\n \n+   Print_Standard : Boolean := False;\n+   --  GNAT\n+   --  Set to true to enable printing of package standard in source form.\n+   --  This flag is set by the -gnatS switch\n+\n    Propagate_Exceptions : Boolean := False;\n    --  GNAT\n    --  Indicates if subprogram descriptor exception tables should be"}, {"sha": "5a47f8770fbc59f5cbca71b73133a5c34e957606", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -2973,11 +2973,28 @@ package body Prj.Nmsc is\n                   end if;\n \n                   if Lib_Dir.Default then\n-                     Error_Msg\n-                       (Project,\n-                        \"a project extending a library project must specify \" &\n-                          \"an attribute Library_Dir\",\n-                        Data.Location);\n+\n+                     --  If the extending project is a virtual project, we\n+                     --  put the error message in the library project that\n+                     --  is extended, rather than in the extending all project.\n+                     --  Of course, we cannot put it in the virtual extending\n+                     --  project, because it has no source.\n+\n+                     if Data.Virtual then\n+                        Error_Msg_Name_1 := Extended_Data.Name;\n+\n+                        Error_Msg\n+                          (Project,\n+                           \"library project % cannot be virtually extended\",\n+                           Extended_Data.Location);\n+\n+                     else\n+                        Error_Msg\n+                          (Project,\n+                           \"a project extending a library project must \" &\n+                           \"specify an attribute Library_Dir\",\n+                           Data.Location);\n+                     end if;\n                   end if;\n \n                   Projects.Table (Data.Extends).Library := False;\n@@ -3001,6 +3018,7 @@ package body Prj.Nmsc is\n                Data.Library_Dir, Data.Display_Library_Dir);\n \n             if Data.Library_Dir = No_Name then\n+\n                --  Get the absolute name of the library directory that\n                --  does not exist, to report an error.\n "}, {"sha": "73d7c574575d87fbad6baffc7d274ac6aff30e10", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 386, "deletions": 13, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -35,6 +35,7 @@ with Prj.Err;  use Prj.Err;\n with Scans;    use Scans;\n with Sinput;   use Sinput;\n with Sinput.P; use Sinput.P;\n+with Snames;\n with Table;\n with Types;    use Types;\n \n@@ -44,6 +45,8 @@ with Ada.Exceptions;             use Ada.Exceptions;\n with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n with GNAT.OS_Lib;                use GNAT.OS_Lib;\n \n+with System.HTable;              use System.HTable;\n+\n pragma Elaborate_All (GNAT.OS_Lib);\n \n package body Prj.Part is\n@@ -62,6 +65,11 @@ package body Prj.Part is\n    --  The path name(s) of directories where project files may reside.\n    --  May be empty.\n \n+   type Extension_Origin is (None, Extending_Simple, Extending_All);\n+   --  Type of parameter From_Extended for procedures Parse_Single_Project and\n+   --  Post_Parse_Context_Clause. Extending_All means that we are parsing the\n+   --  tree rooted at an extending all project.\n+\n    ------------------------------------\n    -- Local Packages and Subprograms --\n    ------------------------------------\n@@ -105,6 +113,42 @@ package body Prj.Part is\n    --  limited imported projects when there is a circularity with at least\n    --  one limited imported project file.\n \n+   package Virtual_Hash is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Project_Node_Id,\n+      No_Element => Empty_Node,\n+      Key        => Project_Node_Id,\n+      Hash       => Prj.Tree.Hash,\n+      Equal      => \"=\");\n+   --  Hash table to store the node id of the project for which a virtual\n+   --  extending project need to be created.\n+\n+   package Processed_Hash is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Project_Node_Id,\n+      Hash       => Prj.Tree.Hash,\n+      Equal      => \"=\");\n+   --  Hash table to store the project process when looking for project that\n+   --  need to have a virtual extending project, to avoid processing the same\n+   --  project twice.\n+\n+   procedure Create_Virtual_Extending_Project\n+     (For_Project  : Project_Node_Id;\n+      Main_Project : Project_Node_Id);\n+   --  Create a virtual extending project of For_Project. Main_Project is\n+   --  the extending all project.\n+\n+   procedure Look_For_Virtual_Projects_For\n+     (Proj                : Project_Node_Id;\n+      Potentially_Virtual : Boolean);\n+   --  Look for projects that need to have a virtual extending project.\n+   --  This procedure is recursive. If called with Potentially_Virtual set to\n+   --  True, then Proj may need an virtual extending project; otherwise it\n+   --  does not (because it is already extended), but other projects that it\n+   --  imports may need to be virtually extended.\n+\n    procedure Pre_Parse_Context_Clause (Context_Clause : out With_Id);\n    --  Parse the context clause of a project.\n    --  Store the paths and locations of the imported projects in table Withs.\n@@ -115,7 +159,7 @@ package body Prj.Part is\n      (Context_Clause    : With_Id;\n       Imported_Projects : out Project_Node_Id;\n       Project_Directory : Name_Id;\n-      From_Extended     : Boolean);\n+      From_Extended     : Extension_Origin);\n    --  Parse the imported projects that have been stored in table Withs,\n    --  if any. From_Extended is used for the call to Parse_Single_Project\n    --  below.\n@@ -124,10 +168,10 @@ package body Prj.Part is\n      (Project       : out Project_Node_Id;\n       Path_Name     : String;\n       Extended      : Boolean;\n-      From_Extended : Boolean);\n+      From_Extended : Extension_Origin);\n    --  Parse a project file.\n    --  Recursive procedure: it calls itself for imported and extended\n-   --  projects. When From_Extended is True, if the project has already\n+   --  projects. When From_Extended is not None, if the project has already\n    --  been parsed and is an extended project A, return the ultimate\n    --  (not extended) project that extends A.\n \n@@ -148,6 +192,132 @@ package body Prj.Part is\n    --  Returns No_Name if the path name is invalid, because the corresponding\n    --  project name does not have the syntax of an ada identifier.\n \n+   --------------------------------------\n+   -- Create_Virtual_Extending_Project --\n+   --------------------------------------\n+\n+   procedure Create_Virtual_Extending_Project\n+     (For_Project  : Project_Node_Id;\n+      Main_Project : Project_Node_Id)\n+   is\n+\n+      Virtual_Name : constant String :=\n+                       Virtual_Prefix &\n+                         Get_Name_String (Name_Of (For_Project));\n+      --  The name of the virtual extending project\n+\n+      Virtual_Name_Id : Name_Id;\n+      --  Virtual extending project name id\n+\n+      Virtual_Path_Id : Name_Id;\n+      --  Fake path name of the virtual extending project. The directory is\n+      --  the same directory as the extending all project.\n+\n+      Virtual_Dir_Id  : constant Name_Id :=\n+                          Immediate_Directory_Of (Path_Name_Of (Main_Project));\n+      --  The directory of the extending all project\n+\n+      --  The source of the virtual extending project is something like:\n+\n+      --  project V$<project name> extends <project path> is\n+\n+      --     for Source_Dirs use ();\n+\n+      --  end V$<project name>;\n+\n+      --  The project directory cannot be specified during parsing; it will be\n+      --  put directly in the virtual extending project data during processing.\n+\n+      --  Nodes that made up the virtual extending project\n+\n+      Virtual_Project         : constant Project_Node_Id :=\n+                                  Default_Project_Node (N_Project);\n+      With_Clause             : constant Project_Node_Id :=\n+                                  Default_Project_Node (N_With_Clause);\n+      Project_Declaration     : constant Project_Node_Id :=\n+                                  Default_Project_Node (N_Project_Declaration);\n+      Source_Dirs_Declaration : constant Project_Node_Id :=\n+                                  Default_Project_Node (N_Declarative_Item);\n+      Source_Dirs_Attribute   : constant Project_Node_Id :=\n+                                  Default_Project_Node\n+                                    (N_Attribute_Declaration, List);\n+      Source_Dirs_Expression  : constant Project_Node_Id :=\n+                                  Default_Project_Node (N_Expression, List);\n+      Source_Dirs_Term        : constant Project_Node_Id :=\n+                                  Default_Project_Node (N_Term, List);\n+      Source_Dirs_List        : constant Project_Node_Id :=\n+                                  Default_Project_Node\n+                                    (N_Literal_String_List, List);\n+\n+   begin\n+      --  Get the virtual name id\n+\n+      Name_Len := Virtual_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Virtual_Name;\n+      Virtual_Name_Id := Name_Find;\n+\n+      --  Get the virtual path name\n+\n+      Get_Name_String (Path_Name_Of (Main_Project));\n+\n+      while Name_Len > 0\n+        and then Name_Buffer (Name_Len) /= Directory_Separator\n+        and then Name_Buffer (Name_Len) /= '/'\n+      loop\n+         Name_Len := Name_Len - 1;\n+      end loop;\n+\n+      Name_Buffer (Name_Len + 1 .. Name_Len + Virtual_Name'Length) :=\n+        Virtual_Name;\n+      Name_Len := Name_Len + Virtual_Name'Length;\n+      Virtual_Path_Id := Name_Find;\n+\n+      --  With clause\n+\n+      Set_Name_Of (With_Clause, Virtual_Name_Id);\n+      Set_Path_Name_Of (With_Clause, Virtual_Path_Id);\n+      Set_Project_Node_Of (With_Clause, Virtual_Project);\n+      Set_Next_With_Clause_Of\n+        (With_Clause, First_With_Clause_Of (Main_Project));\n+      Set_First_With_Clause_Of (Main_Project, With_Clause);\n+\n+      --  Virtual project node\n+\n+      Set_Name_Of (Virtual_Project, Virtual_Name_Id);\n+      Set_Path_Name_Of (Virtual_Project, Virtual_Path_Id);\n+      Set_Location_Of (Virtual_Project, Location_Of (Main_Project));\n+      Set_Directory_Of (Virtual_Project, Virtual_Dir_Id);\n+      Set_Project_Declaration_Of (Virtual_Project, Project_Declaration);\n+      Set_Extended_Project_Path_Of\n+        (Virtual_Project, Path_Name_Of (For_Project));\n+\n+      --  Project declaration\n+\n+      Set_First_Declarative_Item_Of\n+        (Project_Declaration, Source_Dirs_Declaration);\n+      Set_Extended_Project_Of (Project_Declaration, For_Project);\n+\n+      --  Source_Dirs declaration\n+\n+      Set_Current_Item_Node (Source_Dirs_Declaration, Source_Dirs_Attribute);\n+\n+      --  Source_Dirs attribute\n+\n+      Set_Name_Of (Source_Dirs_Attribute, Snames.Name_Source_Dirs);\n+      Set_Expression_Of (Source_Dirs_Attribute, Source_Dirs_Expression);\n+\n+      --  Source_Dirs expression\n+\n+      Set_First_Term (Source_Dirs_Expression, Source_Dirs_Term);\n+\n+      --  Source_Dirs term\n+\n+      Set_Current_Term (Source_Dirs_Term, Source_Dirs_List);\n+\n+      --  Source_Dirs empty list: nothing to do\n+\n+   end Create_Virtual_Extending_Project;\n+\n    ----------------------------\n    -- Immediate_Directory_Of --\n    ----------------------------\n@@ -181,6 +351,73 @@ package body Prj.Part is\n       return Name_Find;\n    end Immediate_Directory_Of;\n \n+   -----------------------------------\n+   -- Look_For_Virtual_Projects_For --\n+   -----------------------------------\n+\n+   procedure Look_For_Virtual_Projects_For\n+     (Proj                : Project_Node_Id;\n+      Potentially_Virtual : Boolean)\n+\n+   is\n+      Declaration : Project_Node_Id := Empty_Node;\n+      --  Node for the project declaration of Proj\n+\n+      With_Clause : Project_Node_Id := Empty_Node;\n+      --  Node for a with clause of Proj\n+\n+      Imported    : Project_Node_Id := Empty_Node;\n+      --  Node for a project imported by Proj\n+\n+      Extended    : Project_Node_Id := Empty_Node;\n+      --  Node for the eventual project extended by Proj\n+\n+   begin\n+      --  Nothing to do if Proj is not defined or if it has already been\n+      --  processed.\n+\n+      if Proj /= Empty_Node and then not Processed_Hash.Get (Proj) then\n+         --  Make sure the project will not be processed again\n+\n+         Processed_Hash.Set (Proj, True);\n+\n+         Declaration := Project_Declaration_Of (Proj);\n+\n+         if Declaration /= Empty_Node then\n+            Extended := Extended_Project_Of (Declaration);\n+         end if;\n+\n+         --  If this is a project that may need a virtual extending project\n+         --  and it is not itself an extending project, put it in the list.\n+\n+         if Potentially_Virtual and then Extended = Empty_Node then\n+            Virtual_Hash.Set (Proj, Proj);\n+         end if;\n+\n+         --  Now check the projects it imports\n+\n+         With_Clause := First_With_Clause_Of (Proj);\n+\n+         while With_Clause /= Empty_Node loop\n+            Imported := Project_Node_Of (With_Clause);\n+\n+            if Imported /= Empty_Node then\n+               Look_For_Virtual_Projects_For\n+                 (Imported, Potentially_Virtual => True);\n+            end if;\n+\n+            With_Clause := Next_With_Clause_Of (With_Clause);\n+         end loop;\n+\n+         --  Check also the eventual project extended by Proj. As this project\n+         --  is already extended, call recursively with Potentially_Virtual\n+         --  being False.\n+\n+         Look_For_Virtual_Projects_For\n+           (Extended, Potentially_Virtual => False);\n+      end if;\n+   end Look_For_Virtual_Projects_For;\n+\n    -----------\n    -- Parse --\n    -----------\n@@ -228,7 +465,84 @@ package body Prj.Part is\n            (Project       => Project,\n             Path_Name     => Path_Name,\n             Extended      => False,\n-            From_Extended => False);\n+            From_Extended => None);\n+\n+         --  If Project is an extending-all project, create the eventual\n+         --  virtual extending projects and check that there are no illegally\n+         --  imported projects.\n+\n+         if Project /= Empty_Node and then Is_Extending_All (Project) then\n+            --  First look for projects that potentially need a virtual\n+            --  extending project.\n+\n+            Virtual_Hash.Reset;\n+            Processed_Hash.Reset;\n+\n+            --  Mark the extending all project as processed, to avoid checking\n+            --  the imported projects in case of a \"limited with\" on this\n+            --  extending all project.\n+\n+            Processed_Hash.Set (Project, True);\n+\n+            declare\n+               Declaration : constant Project_Node_Id :=\n+                 Project_Declaration_Of (Project);\n+            begin\n+               Look_For_Virtual_Projects_For\n+                 (Extended_Project_Of (Declaration),\n+                  Potentially_Virtual => False);\n+            end;\n+\n+            --  Now, check the projects directly imported by the main project.\n+            --  Remove from the potentially virtual any project extended by one\n+            --  of these imported projects. For non extending imported\n+            --  projects, check that they do not belong to the project tree of\n+            --  the project being \"extended-all\" by the main project.\n+\n+            declare\n+               With_Clause : Project_Node_Id :=\n+                 First_With_Clause_Of (Project);\n+               Imported    : Project_Node_Id := Empty_Node;\n+               Declaration : Project_Node_Id := Empty_Node;\n+\n+            begin\n+               while With_Clause /= Empty_Node loop\n+                  Imported := Project_Node_Of (With_Clause);\n+\n+                  if Imported /= Empty_Node then\n+                     Declaration := Project_Declaration_Of (Imported);\n+\n+                     if Extended_Project_Of (Declaration) /= Empty_Node then\n+                        loop\n+                           Imported := Extended_Project_Of (Declaration);\n+                           exit when Imported = Empty_Node;\n+                           Virtual_Hash.Remove (Imported);\n+                           Declaration := Project_Declaration_Of (Imported);\n+                        end loop;\n+\n+                     elsif Virtual_Hash.Get (Imported) /= Empty_Node then\n+                        Error_Msg\n+                          (\"this project cannot be imported directly\",\n+                           Location_Of (With_Clause));\n+                     end if;\n+\n+                  end if;\n+\n+                  With_Clause := Next_With_Clause_Of (With_Clause);\n+               end loop;\n+            end;\n+\n+            --  Now create all the virtual extending projects\n+\n+            declare\n+               Proj : Project_Node_Id := Virtual_Hash.Get_First;\n+            begin\n+               while Proj /= Empty_Node loop\n+                  Create_Virtual_Extending_Project (Proj, Project);\n+                  Proj := Virtual_Hash.Get_Next;\n+               end loop;\n+            end;\n+         end if;\n \n          --  If there were any kind of error during the parsing, serious\n          --  or not, then the parsing fails.\n@@ -338,7 +652,7 @@ package body Prj.Part is\n      (Context_Clause    : With_Id;\n       Imported_Projects : out Project_Node_Id;\n       Project_Directory : Name_Id;\n-      From_Extended     : Boolean)\n+      From_Extended     : Extension_Origin)\n    is\n       Current_With_Clause : With_Id := Context_Clause;\n \n@@ -494,7 +808,7 @@ package body Prj.Part is\n      (Project       : out Project_Node_Id;\n       Path_Name     : String;\n       Extended      : Boolean;\n-      From_Extended : Boolean)\n+      From_Extended : Extension_Origin)\n    is\n       Normed_Path_Name    : Name_Id;\n       Canonical_Path_Name : Name_Id;\n@@ -583,7 +897,7 @@ package body Prj.Part is\n                --  in an extended project, replace A with the ultimate project\n                --  extending A.\n \n-               if From_Extended then\n+               if From_Extended /= None then\n                   declare\n                      Decl : Project_Node_Id :=\n                        Project_Declaration_Of\n@@ -745,13 +1059,26 @@ package body Prj.Part is\n \n          declare\n             Imported_Projects : Project_Node_Id := Empty_Node;\n+            From_Ext : Extension_Origin := None;\n \n          begin\n+            --  Extending_All is always propagated\n+\n+            if From_Extended = Extending_All then\n+               From_Ext := Extending_All;\n+\n+            --  Otherwise, From_Extended is set to Extending_Single if the\n+            --  current project is an extending project.\n+\n+            elsif Extended then\n+               From_Ext := Extending_Simple;\n+            end if;\n+\n             Post_Parse_Context_Clause\n               (Context_Clause    => First_With,\n                Imported_Projects => Imported_Projects,\n                Project_Directory => Project_Directory,\n-               From_Extended     => Extended);\n+               From_Extended     => From_Ext);\n             Set_First_With_Clause_Of (Project, Imported_Projects);\n          end;\n \n@@ -797,6 +1124,12 @@ package body Prj.Part is\n          --  We are extending another project\n \n          Scan; -- scan past EXTENDS\n+\n+         if Token = Tok_All then\n+            Set_Is_Extending_All (Project);\n+            Scan; --  scan past ALL\n+         end if;\n+\n          Expect (Tok_String_Literal, \"literal string\");\n \n          if Token = Tok_String_Literal then\n@@ -836,18 +1169,58 @@ package body Prj.Part is\n                   end if;\n \n                else\n-                  Parse_Single_Project\n-                    (Project       => Extended_Project,\n-                     Path_Name     => Extended_Project_Path_Name,\n-                     Extended      => True,\n-                     From_Extended => False);\n+                  declare\n+                     From_Extended : Extension_Origin := None;\n+\n+                  begin\n+                     if Is_Extending_All (Project) then\n+                        From_Extended := Extending_All;\n+                     end if;\n+\n+                     Parse_Single_Project\n+                       (Project       => Extended_Project,\n+                        Path_Name     => Extended_Project_Path_Name,\n+                        Extended      => True,\n+                        From_Extended => From_Extended);\n+                  end;\n+\n+                  --  A project that extends an extending-all project is also\n+                  --  an extending-all project.\n+\n+                  if Is_Extending_All (Extended_Project) then\n+                     Set_Is_Extending_All (Project);\n+                  end if;\n                end if;\n             end;\n \n             Scan; -- scan past the extended project path\n          end if;\n       end if;\n \n+      --  Check that a non extending-all project does not import an\n+      --  extending-all project.\n+\n+      if not Is_Extending_All (Project) then\n+         declare\n+            With_Clause : Project_Node_Id := First_With_Clause_Of (Project);\n+            Imported    : Project_Node_Id := Empty_Node;\n+\n+         begin\n+            With_Clause_Loop :\n+            while With_Clause /= Empty_Node loop\n+               Imported := Project_Node_Of (With_Clause);\n+               With_Clause := Next_With_Clause_Of (With_Clause);\n+\n+               if Is_Extending_All (Imported) then\n+                  Error_Msg_Name_1 := Name_Of (Imported);\n+                  Error_Msg (\"cannot import extending-all project {\",\n+                             Token_Ptr);\n+                  exit With_Clause_Loop;\n+               end if;\n+            end loop With_Clause_Loop;\n+         end;\n+      end if;\n+\n       --  Check that a project with a name including a dot either imports\n       --  or extends the project whose name precedes the last dot.\n "}, {"sha": "21585af36cdf5c8677b3b27e8c05e91564e21c7a", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -840,6 +840,25 @@ package body Prj.Proc is\n          Check (Project);\n       end if;\n \n+      --  If main project is an extending all project, set the object\n+      --  directory of all virtual extending projects to the object directory\n+      --  of the main project.\n+\n+      if Project /= No_Project\n+        and then Is_Extending_All (From_Project_Node)\n+      then\n+         declare\n+            Object_Dir : constant Name_Id :=\n+              Projects.Table (Project).Object_Directory;\n+         begin\n+            for Index in Projects.First .. Projects.Last loop\n+               if Projects.Table (Index).Virtual then\n+                  Projects.Table (Index).Object_Directory := Object_Dir;\n+               end if;\n+            end loop;\n+         end;\n+      end if;\n+\n       --  Check that no extended project shares its object directory with\n       --  another project.\n \n@@ -855,20 +874,39 @@ package body Prj.Proc is\n                     and then Projects.Table (Prj).Sources_Present\n                     and then Projects.Table (Prj).Object_Directory = Obj_Dir\n                   then\n-                     Error_Msg_Name_1 := Projects.Table (Extending).Name;\n-                     Error_Msg_Name_2 := Projects.Table (Extended).Name;\n+                     if Projects.Table (Extending).Virtual then\n+                        Error_Msg_Name_1 := Projects.Table (Extended).Name;\n \n-                     if Error_Report = null then\n-                        Error_Msg (\"project % cannot extend project %\",\n-                                   Projects.Table (Extending).Location);\n+                        if Error_Report = null then\n+                           Error_Msg\n+                             (\"project % cannot be extended by \" &\n+                              \"a virtual project\",\n+                              Projects.Table (Extending).Location);\n+\n+                        else\n+                           Error_Report\n+                             (\"project \"\"\" &\n+                              Get_Name_String (Error_Msg_Name_1) &\n+                              \"\"\" cannot be extended by a virtual project\",\n+                              Project);\n+                        end if;\n \n                      else\n-                        Error_Report\n-                          (\"project \"\"\" &\n-                             Get_Name_String (Error_Msg_Name_1) &\n-                             \"\"\" cannot extend project \"\"\" &\n-                             Get_Name_String (Error_Msg_Name_2) & '\"',\n-                           Project);\n+                        Error_Msg_Name_1 := Projects.Table (Extending).Name;\n+                        Error_Msg_Name_2 := Projects.Table (Extended).Name;\n+\n+                        if Error_Report = null then\n+                           Error_Msg (\"project % cannot extend project %\",\n+                                      Projects.Table (Extending).Location);\n+\n+                        else\n+                           Error_Report\n+                             (\"project \"\"\" &\n+                              Get_Name_String (Error_Msg_Name_1) &\n+                              \"\"\" cannot extend project \"\"\" &\n+                              Get_Name_String (Error_Msg_Name_2) & '\"',\n+                              Project);\n+                        end if;\n                      end if;\n \n                      Error_Msg_Name_1 := Projects.Table (Extended).Name;\n@@ -1789,6 +1827,18 @@ package body Prj.Proc is\n \n             Processed_Data.Name := Name;\n \n+            Get_Name_String (Name);\n+\n+            --  If name starts with the virtual prefix, flag the project as\n+            --  being a virtual extending project.\n+\n+            if Name_Len > Virtual_Prefix'Length\n+              and then Name_Buffer (1 .. Virtual_Prefix'Length) =\n+                         Virtual_Prefix\n+            then\n+               Processed_Data.Virtual := True;\n+            end if;\n+\n             Processed_Data.Display_Path_Name :=\n               Path_Name_Of (From_Project_Node);\n             Get_Name_String (Processed_Data.Display_Path_Name);"}, {"sha": "74cd73d7b135074bcd847dc104f9b153a3abb146", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -166,7 +166,8 @@ package body Prj.Tree is\n             Field1           => Empty_Node,\n             Field2           => Empty_Node,\n             Field3           => Empty_Node,\n-            Case_Insensitive => False);\n+            Case_Insensitive => False,\n+            Extending_All    => False);\n       return Project_Nodes.Last;\n    end Default_Project_Node;\n \n@@ -485,6 +486,19 @@ package body Prj.Tree is\n       return Project_Nodes.Table (Node).Field1;\n    end First_With_Clause_Of;\n \n+   ----------------------\n+   -- Is_Extending_All --\n+   ----------------------\n+\n+   function Is_Extending_All (Node  : Project_Node_Id) return Boolean is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+            Project_Nodes.Table (Node).Kind = N_Project);\n+      return Project_Nodes.Table (Node).Extending_All;\n+   end Is_Extending_All;\n+\n    ----------\n    -- Hash --\n    ----------\n@@ -1237,6 +1251,19 @@ package body Prj.Tree is\n       Project_Nodes.Table (Node).Field1 := To;\n    end Set_First_With_Clause_Of;\n \n+   --------------------------\n+   -- Set_Is_Extending_All --\n+   --------------------------\n+\n+   procedure Set_Is_Extending_All (Node  : Project_Node_Id) is\n+   begin\n+      pragma Assert\n+        (Node /= Empty_Node\n+          and then\n+            Project_Nodes.Table (Node).Kind = N_Project);\n+      Project_Nodes.Table (Node).Extending_All := True;\n+   end Set_Is_Extending_All;\n+\n    -----------------\n    -- Set_Kind_Of --\n    -----------------"}, {"sha": "15156e869d317eb74a264610ed293ae5a535bf74", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -135,6 +135,10 @@ package Prj.Tree is\n    --  N_Variable_Declaration, N_Typed_Variable_Declaration, N_Expression,\n    --  N_Term, N_Variable_Reference or N_Attribute_Reference nodes.\n \n+   function Is_Extending_All (Node  : Project_Node_Id) return Boolean;\n+   pragma Inline (Is_Extending_All);\n+   --  Only valid for N_Project\n+\n    function First_Variable_Of\n      (Node  : Project_Node_Id)\n       return  Variable_Node_Id;\n@@ -220,7 +224,7 @@ package Prj.Tree is\n      (Node  : Project_Node_Id)\n       return Project_Node_Id;\n    pragma Inline (Extended_Project_Of);\n-   --  Only valid for N_With_Clause nodes\n+   --  Only valid for N_Project_Declaration nodes\n \n    function Current_Item_Node\n      (Node  : Project_Node_Id)\n@@ -425,6 +429,9 @@ package Prj.Tree is\n       To   : Variable_Kind);\n    pragma Inline (Set_Expression_Kind_Of);\n \n+   procedure Set_Is_Extending_All (Node  : Project_Node_Id);\n+   pragma Inline (Set_Is_Extending_All);\n+\n    procedure Set_First_Variable_Of\n      (Node : Project_Node_Id;\n       To   : Variable_Node_Id);\n@@ -685,6 +692,10 @@ package Prj.Tree is\n          --  N_Atribute_Reference. It indicates for an associative array\n          --  attribute, that the index is case insensitive.\n \n+         Extending_All : Boolean := False;\n+         --  This flag is significant only for N_Project. It indicates that\n+         --  the project \"extends all\" another project.\n+\n       end record;\n \n       --  type Project_Node_Kind is"}, {"sha": "04fc0e6c8480a6d9771fa8715c7b6da3fb818d7f", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -77,6 +77,7 @@ package body Prj is\n      (First_Referred_By              => No_Project,\n       Name                           => No_Name,\n       Path_Name                      => No_Name,\n+      Virtual                        => False,\n       Display_Path_Name              => No_Name,\n       Location                       => No_Location,\n       Mains                          => Nil_String,"}, {"sha": "bfb67d6d3955119bb82f608bf716e374adc9d1ff", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -47,6 +47,10 @@ package Prj is\n    --  Default value of parameter Packages of procedures Parse, in Prj.Pars and\n    --  Prj.Part, indicating that all packages should be checked.\n \n+   Virtual_Prefix : constant String := \"v$\";\n+   --  The prefix for virtual extending projects. Because of the '$', which is\n+   --  normally forbidden for project names, there cannot be any name clash.\n+\n    Project_File_Extension : String := \".gpr\";\n    --  The standard project file name extension.\n    --  It is not a constant, because Canonical_Case_File_Name is called\n@@ -339,6 +343,9 @@ package Prj is\n       --  The path name of the project file.\n       --  Set by Prj.Proc.Process.\n \n+      Virtual : Boolean := False;\n+      --  True for virtual extending projects\n+\n       Display_Path_Name : Name_Id := No_Name;\n \n       Location : Source_Ptr := No_Location;"}, {"sha": "b60cce5215c504ed75466dd2e4638a1ff220771d", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -812,6 +812,10 @@ package body System.File_IO is\n          --  Normal case of non-null name given\n \n          else\n+            if Name'Length > Namelen then\n+               raise Name_Error;\n+            end if;\n+\n             Namestr (1 .. Name'Length) := Name;\n             Namestr (Name'Length + 1)  := ASCII.NUL;\n          end if;"}, {"sha": "850a423b8f5227cdb44fd0d335546a334392e42f", "filename": "gcc/ada/s-thread.adb", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fs-thread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fs-thread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -33,18 +33,21 @@\n \n --  This is the VxWorks/Cert version of this package\n \n+with System.Init;\n+with System.Secondary_Stack;\n+\n with Unchecked_Conversion;\n \n package body System.Threads is\n \n+   package SSS renames System.Secondary_Stack;\n+\n    Current_ATSD  : aliased System.Address := System.Null_Address;\n    pragma Export (C, Current_ATSD, \"__gnat_current_atsd\");\n \n    function From_Address is\n       new Unchecked_Conversion (Address, ATSD_Access);\n \n-\n-\n    -----------------------\n    -- Get_Current_Excep --\n    -----------------------\n@@ -109,11 +112,18 @@ package body System.Threads is\n       Sec_Stack_Size       : Natural;\n       Process_ATSD_Address : System.Address)\n    is\n-      pragma Unreferenced (Sec_Stack_Address);\n-      pragma Unreferenced (Sec_Stack_Size);\n-      pragma Unreferenced (Process_ATSD_Address);\n+      --  Current_ATSD must already be a taskVar of taskIdSelf.\n+      --  No assertion because taskVarGet is not available on VxWorks/CERT\n+\n+      TSD : ATSD_Access := From_Address (Process_ATSD_Address);\n+\n    begin\n-      null;\n+      TSD.Sec_Stack_Addr := Sec_Stack_Address;\n+      SSS.SS_Init (TSD.Sec_Stack_Addr, Sec_Stack_Size);\n+      Current_ATSD := Process_ATSD_Address;\n+\n+      System.Init.Install_Handler;\n+      System.Init.Init_Float;\n    end Thread_Body_Enter;\n \n    ----------------------------------\n@@ -125,6 +135,7 @@ package body System.Threads is\n    is\n       pragma Unreferenced (EO);\n    begin\n+      --  No action for this target\n       null;\n    end Thread_Body_Exceptional_Exit;\n \n@@ -134,6 +145,7 @@ package body System.Threads is\n \n    procedure Thread_Body_Leave is\n    begin\n+      --  No action for this target\n       null;\n    end Thread_Body_Leave;\n "}, {"sha": "6badd1668b4bd8254af2f18adfcdec43235c91ee", "filename": "gcc/ada/s-thread.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fs-thread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fs-thread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -34,6 +34,9 @@\n --  This package provides facilities to register a thread to the runtime,\n --  and allocate its task specific datas.\n \n+--  pragma Thread_Body is currently supported for:\n+--  VxWorks AE653 with the restricted / cert runtime\n+\n with Ada.Exceptions;\n \n package System.Threads is"}, {"sha": "323afa4d62c20fa449863ee07fa97b9d2b974f52", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -1749,7 +1749,14 @@ package body Sem_Ch10 is\n \n             Generate_Reference (Par_Name, Pref);\n             Pref := Prefix (Pref);\n-            Par_Name := Scope (Par_Name);\n+\n+            --  If E_Name is the dummy entity for a nonexistent unit,\n+            --  its scope is set to Standard_Standard, and no attempt\n+            --  should be made to further unwind scopes.\n+\n+            if Par_Name /= Standard_Standard then\n+               Par_Name := Scope (Par_Name);\n+            end if;\n          end loop;\n \n          if Present (Entity (Pref))"}, {"sha": "4a954a1dc4b0b487c5a3d36e8902a789be40b8e4", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -543,37 +543,37 @@ package body Sem_Ch12 is\n    --  those nodes that contain global information. At instantiation, the\n    --  information from the associated node is placed on the new copy, so\n    --  that name resolution is not repeated.\n-\n+   --\n    --  Three kinds of source nodes have associated nodes:\n-\n+   --\n    --    a) those that can reference (denote) entities, that is identifiers,\n    --       character literals, expanded_names, operator symbols, operators,\n    --       and attribute reference nodes. These nodes have an Entity field\n    --       and are the set of nodes that are in N_Has_Entity.\n-\n+   --\n    --    b) aggregates (N_Aggregate and N_Extension_Aggregate)\n-\n+   --\n    --    c) selected components (N_Selected_Component)\n-\n+   --\n    --  For the first class, the associated node preserves the entity if it is\n-   --  global. If the generic contains nested instantiations, the associated_\n+   --  global. If the generic contains nested instantiations, the associated\n    --  node itself has been recopied, and a chain of them must be followed.\n-\n+   --\n    --  For aggregates, the associated node allows retrieval of the type, which\n    --  may otherwise not appear in the generic. The view of this type may be\n    --  different between generic and instantiation, and the full view can be\n    --  installed before the instantiation is analyzed. For aggregates of\n    --  type extensions, the same view exchange may have to be performed for\n    --  some of the ancestor types, if their view is private at the point of\n    --  instantiation.\n-\n+   --\n    --  Nodes that are selected components in the parse tree may be rewritten\n    --  as expanded names after resolution, and must be treated as potential\n    --  entity holders. which is why they also have an Associated_Node.\n-\n+   --\n    --  Nodes that do not come from source, such as freeze nodes, do not appear\n    --  in the generic tree, and need not have an associated node.\n-\n+   --\n    --  The associated node is stored in the Associated_Node field. Note that\n    --  this field overlaps Entity, which is fine, because the whole point is\n    --  that we don't need or want the normal Entity field in this situation."}, {"sha": "8ebf0c639e839c9480717e8199f5adef10dcfb1a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 67, "deletions": 79, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -2153,29 +2153,6 @@ package body Sem_Ch13 is\n                               CC, Rectype);\n                         end if;\n \n-                        --  Test for large object that is not on a storage unit\n-                        --  boundary, defined as a large packed array not\n-                        --  represented by a modular type, or an object for\n-                        --  which a size of greater than 64 bits is specified.\n-\n-                        if Fbit mod SSU /= 0 then\n-                           if (Is_Packed_Array_Type (Etype (Comp))\n-                                and then Is_Array_Type\n-                                     (Packed_Array_Type (Etype (Comp))))\n-                             or else Esize (Etype (Comp)) > Max_Unaligned_Field\n-                           then\n-                              if SSU = 8 then\n-                                 Error_Msg_N\n-                                   (\"large component must be on byte boundary\",\n-                                    First_Bit (CC));\n-                              else\n-                                 Error_Msg_N\n-                                   (\"large component must be on word boundary\",\n-                                    First_Bit (CC));\n-                              end if;\n-                           end if;\n-                        end if;\n-\n                         --  This information is also set in the\n                         --  corresponding component of the base type,\n                         --  found by accessing the Original_Record_Component\n@@ -2602,6 +2579,9 @@ package body Sem_Ch13 is\n       --------------------------\n \n       procedure Check_Expr_Constants (Nod : Node_Id) is\n+         Loc_U_Ent : constant Source_Ptr := Sloc (U_Ent);\n+         Ent       : Entity_Id           := Empty;\n+\n       begin\n          if Nkind (Nod) in N_Has_Etype\n            and then Etype (Nod) = Any_Type\n@@ -2614,6 +2594,7 @@ package body Sem_Ch13 is\n                return;\n \n             when N_Identifier | N_Expanded_Name =>\n+               Ent := Entity (Nod);\n \n                --  We need to look at the original node if it is different\n                --  from the node, since we may have rewritten things and\n@@ -2627,85 +2608,92 @@ package body Sem_Ch13 is\n                   --  is not constant, even if the constituents might be\n                   --  acceptable, as in  A'Address + offset.\n \n-                  if Ekind (Entity (Nod)) = E_Variable\n-                    and then Nkind (Declaration_Node (Entity (Nod)))\n+                  if Ekind (Ent) = E_Variable\n+                    and then Nkind (Declaration_Node (Ent))\n                       = N_Object_Declaration\n                     and then\n-                      No (Expression (Declaration_Node (Entity (Nod))))\n+                      No (Expression (Declaration_Node (Ent)))\n+                  then\n+                     Error_Msg_NE\n+                       (\"invalid address clause for initialized object &!\",\n+                        Nod, U_Ent);\n+\n+                  --  If entity is constant, it may be the result of expanding\n+                  --  a check. We must verify that its declaration appears\n+                  --  before the object in question, else we also reject the\n+                  --  address clause.\n+\n+                  elsif Ekind (Ent) = E_Constant\n+                    and then In_Same_Source_Unit (Ent, U_Ent)\n+                    and then Sloc (Ent) > Loc_U_Ent\n                   then\n                      Error_Msg_NE\n                        (\"invalid address clause for initialized object &!\",\n                         Nod, U_Ent);\n                   end if;\n+\n                   return;\n                end if;\n \n                --  Otherwise look at the identifier and see if it is OK.\n \n-               declare\n-                  Ent       : constant Entity_Id  := Entity (Nod);\n-                  Loc_Ent   : constant Source_Ptr := Sloc (Ent);\n-                  Loc_U_Ent : constant Source_Ptr := Sloc (U_Ent);\n-\n-               begin\n-                  if Ekind (Ent) = E_Named_Integer\n-                       or else\n-                     Ekind (Ent) = E_Named_Real\n-                       or else\n-                     Is_Type (Ent)\n-                  then\n-                     return;\n-\n-                  elsif\n-                     Ekind (Ent) = E_Constant\n-                       or else\n-                     Ekind (Ent) = E_In_Parameter\n-                  then\n-                     --  This is the case where we must have Ent defined\n-                     --  before U_Ent. Clearly if they are in different\n-                     --  units this requirement is met since the unit\n-                     --  containing Ent is already processed.\n-\n-                     if not In_Same_Source_Unit (Ent, U_Ent) then\n-                        return;\n+               if Ekind (Ent) = E_Named_Integer\n+                    or else\n+                  Ekind (Ent) = E_Named_Real\n+                    or else\n+                  Is_Type (Ent)\n+               then\n+                  return;\n \n-                     --  Otherwise location of Ent must be before the\n-                     --  location of U_Ent, that's what prior defined means.\n+               elsif\n+                  Ekind (Ent) = E_Constant\n+                    or else\n+                  Ekind (Ent) = E_In_Parameter\n+               then\n+                  --  This is the case where we must have Ent defined\n+                  --  before U_Ent. Clearly if they are in different\n+                  --  units this requirement is met since the unit\n+                  --  containing Ent is already processed.\n \n-                     elsif Loc_Ent < Loc_U_Ent then\n-                        return;\n+                  if not In_Same_Source_Unit (Ent, U_Ent) then\n+                     return;\n \n-                     else\n-                        Error_Msg_NE\n-                          (\"invalid address clause for initialized object &!\",\n-                           Nod, U_Ent);\n-                        Error_Msg_Name_1 := Chars (Ent);\n-                        Error_Msg_Name_2 := Chars (U_Ent);\n-                        Error_Msg_N\n-                          (\"\\% must be defined before % ('R'M 13.1(22))!\",\n-                           Nod);\n-                     end if;\n+                  --  Otherwise location of Ent must be before the\n+                  --  location of U_Ent, that's what prior defined means.\n \n-                  elsif Nkind (Original_Node (Nod)) = N_Function_Call then\n-                     Check_Expr_Constants (Original_Node (Nod));\n+                  elsif Sloc (Ent) < Loc_U_Ent then\n+                     return;\n \n                   else\n                      Error_Msg_NE\n                        (\"invalid address clause for initialized object &!\",\n                         Nod, U_Ent);\n+                     Error_Msg_Name_1 := Chars (Ent);\n+                     Error_Msg_Name_2 := Chars (U_Ent);\n+                     Error_Msg_N\n+                       (\"\\% must be defined before % ('R'M 13.1(22))!\",\n+                        Nod);\n+                  end if;\n \n-                     if Comes_From_Source (Ent) then\n-                        Error_Msg_Name_1 := Chars (Ent);\n-                        Error_Msg_N\n-                          (\"\\reference to variable% not allowed\"\n-                             & \" ('R'M 13.1(22))!\", Nod);\n-                     else\n-                        Error_Msg_N\n-                          (\"non-static expression not allowed\"\n-                             & \" ('R'M 13.1(22))!\", Nod);\n-                     end if;\n+               elsif Nkind (Original_Node (Nod)) = N_Function_Call then\n+                  Check_Expr_Constants (Original_Node (Nod));\n+\n+               else\n+                  Error_Msg_NE\n+                    (\"invalid address clause for initialized object &!\",\n+                     Nod, U_Ent);\n+\n+                  if Comes_From_Source (Ent) then\n+                     Error_Msg_Name_1 := Chars (Ent);\n+                     Error_Msg_N\n+                       (\"\\reference to variable% not allowed\"\n+                          & \" ('R'M 13.1(22))!\", Nod);\n+                  else\n+                     Error_Msg_N\n+                       (\"non-static expression not allowed\"\n+                          & \" ('R'M 13.1(22))!\", Nod);\n                   end if;\n-               end;\n+               end if;\n \n             when N_Integer_Literal   |\n                  N_Real_Literal      |"}, {"sha": "d819cc4d1066014205941a47d42fc81dcf593049", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -33,6 +33,7 @@ with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Lib.Xref; use Lib.Xref;\n with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Case; use Sem_Case;\n@@ -1002,7 +1003,64 @@ package body Sem_Ch5 is\n    -- Analyze_Iteration_Scheme --\n    ------------------------------\n \n+\n    procedure Analyze_Iteration_Scheme (N : Node_Id) is\n+      procedure Check_Controlled_Array_Attribute (DS : Node_Id);\n+      --  If the bounds are given by a 'Range reference on a function call\n+      --  that returns a controlled array, introduce an explicit declaration\n+      --  to capture the bounds, so that the function result can be finalized\n+      --  in timely fashion.\n+\n+      --------------------------------------\n+      -- Check_Controlled_Array_Attribute --\n+      --------------------------------------\n+\n+      procedure Check_Controlled_Array_Attribute (DS : Node_Id) is\n+      begin\n+         if Nkind (DS) = N_Attribute_Reference\n+            and then Is_Entity_Name (Prefix (DS))\n+            and then Ekind (Entity (Prefix (DS))) = E_Function\n+            and then Is_Array_Type (Etype (Entity (Prefix (DS))))\n+            and then\n+              Is_Controlled (\n+                Component_Type (Etype (Entity (Prefix (DS)))))\n+            and then Expander_Active\n+         then\n+            declare\n+               Loc  : constant Source_Ptr := Sloc (N);\n+               Arr  : constant Entity_Id :=\n+                        Etype (Entity (Prefix (DS)));\n+               Indx : constant Entity_Id :=\n+                        Base_Type (Etype (First_Index (Arr)));\n+               Subt : constant Entity_Id :=\n+                        Make_Defining_Identifier\n+                          (Loc, New_Internal_Name ('S'));\n+               Decl : Node_Id;\n+\n+            begin\n+               Decl :=\n+                 Make_Subtype_Declaration (Loc,\n+                   Defining_Identifier => Subt,\n+                   Subtype_Indication  =>\n+                      Make_Subtype_Indication (Loc,\n+                        Subtype_Mark  => New_Reference_To (Indx, Loc),\n+                        Constraint =>\n+                          Make_Range_Constraint (Loc,\n+                            Relocate_Node (DS))));\n+               Insert_Before (Parent (N), Decl);\n+               Analyze (Decl);\n+\n+               Rewrite (DS,\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix => New_Reference_To (Subt, Loc),\n+                    Attribute_Name => Attribute_Name (DS)));\n+               Analyze (DS);\n+            end;\n+         end if;\n+      end Check_Controlled_Array_Attribute;\n+\n+   --  Start of processing for Analyze_Iteration_Scheme\n+\n    begin\n       --  For an infinite loop, there is no iteration scheme\n \n@@ -1080,6 +1138,7 @@ package body Sem_Ch5 is\n                      Set_Etype (DS, Any_Type);\n                   end if;\n \n+                  Check_Controlled_Array_Attribute (DS);\n                   Make_Index (DS, LP);\n \n                   Set_Ekind          (Id, E_Loop_Parameter);"}, {"sha": "bd752a7fdde47be437861bb680b506d8ee4a0877", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -4060,6 +4060,15 @@ package body Sem_Ch8 is\n                Error_Msg_N (\n                 \"invalid prefix in selected component&\", P);\n \n+               if Is_Access_Type (P_Type)\n+                 and then Ekind (Designated_Type (P_Type)) = E_Incomplete_Type\n+               then\n+                  Error_Msg_Node_2 := Selector_Name (N);\n+                  Error_Msg_NE (\n+                    \"\\incomplete type& has no visible component&\", P,\n+                      Designated_Type (P_Type));\n+               end if;\n+\n             else\n                Error_Msg_N (\n                 \"invalid prefix in selected component\", P);"}, {"sha": "368c22aa6af9ce18f9fb46e51495b2857daa0a60", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -930,6 +930,15 @@ package body Sinfo is\n       return Node4 (N);\n    end Entity;\n \n+   function Entity_Or_Associated_Node\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind in N_Has_Entity\n+        or else NT (N).Nkind = N_Freeze_Entity);\n+      return Node4 (N);\n+   end Entity_Or_Associated_Node;\n+\n    function Entry_Body_Formal_Part\n       (N : Node_Id) return Node_Id is\n    begin"}, {"sha": "0e96df1a076c874d05d0449d096acb41c1fd5739", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -393,7 +393,7 @@ package Sinfo is\n    --  abbreviations are used:\n \n    --  Note: the utility program that creates the Treeprs spec (in the file\n-   --  treeprs.ads) knows about the special fields here, so it must be\n+   --  xtreeprs.adb) knows about the special fields here, so it must be\n    --  modified if any change is made to these fields.\n \n    --    \"plus fields for binary operator\"\n@@ -567,14 +567,18 @@ package Sinfo is\n \n    --  Associated_Node (Node4-Sem)\n    --    Present in nodes that can denote an entity: identifiers, character\n-   --    literals, operator symbols, expanded names, operator nodes and\n+   --    literals, operator symbols, expanded names, operator nodes, and\n    --    attribute reference nodes (all these nodes have an Entity field).\n    --    This field is also present in N_Aggregate, N_Selected_Component,\n-   --    and N_Extension_Aggregate nodes. This field is used during generic\n-   --    processing to relate nodes in the original template to nodes in the\n-   --    generic copy. It overlaps the Entity field, and is used to capture\n-   --    global references in the analyzed copy and place them in the instance.\n-   --    See description in Sem_Ch12 for further details on this usage.\n+   --    and N_Extension_Aggregate nodes. This field is used in generic\n+   --    processing to create links between the generic template and the\n+   --    generic copy. See Sem_Ch12.Get_Associated_Node for full details.\n+   --    Note that this field overlaps Entity, which is fine, since, as\n+   --    explained in Sem_Ch12, the normal function of Entity is not\n+   --    required at the point where the Associated_Node is set. Note\n+   --    also, that in generic templates, this means that the Entity field\n+   --    does not necessarily point to an Entity. Since the back end is\n+   --    expected to ignore generic templates, this is harmless.\n \n    --  At_End_Proc (Node1)\n    --    This field is present in an N_Handled_Sequence_Of_Statements node.\n@@ -861,8 +865,16 @@ package Sinfo is\n    --    incorrect (e.g. during overload resolution, Entity is initially\n    --    set to the first possible correct interpretation, and then later\n    --    modified if necessary to contain the correct value after resolution).\n-   --    Note that Associated_Node overlays this field during the processing\n-   --    of generics. See Sem_Ch12 for further details.\n+   --    Note that this field overlaps Associated_Node, which is used during\n+   --    generic processing (see Sem_Ch12 for details). Note also that in\n+   --    generic templates, this means that the Entity field does not always\n+   --    point to an Entity. Since the back end is expected to ignore\n+   --    generic templates, this is harmless.\n+\n+   --  Entity_Or_Associated_Node (Node4-Sem)\n+   --    A synonym for both Entity and Asasociated_Node. Used by convention\n+   --    in the code when referencing this field in cases where it is not\n+   --    known whether the field contains an Entity or an Associated_Node.\n \n    --  Etype (Node5-Sem)\n    --    Appears in all expression nodes, all direct names, and all\n@@ -7107,6 +7119,9 @@ package Sinfo is\n    function Entity\n      (N : Node_Id) return Node_Id;    -- Node4\n \n+   function Entity_Or_Associated_Node\n+     (N : Node_Id) return Node_Id;    -- Node4\n+\n    function Entry_Body_Formal_Part\n      (N : Node_Id) return Node_Id;    -- Node5\n \n@@ -8491,6 +8506,7 @@ package Sinfo is\n    pragma Inline (End_Label);\n    pragma Inline (End_Span);\n    pragma Inline (Entity);\n+   pragma Inline (Entity_Or_Associated_Node);\n    pragma Inline (Entry_Body_Formal_Part);\n    pragma Inline (Entry_Call_Alternative);\n    pragma Inline (Entry_Call_Statement);"}, {"sha": "0ab0e473eb5469a3ec1f5bdcad1729e183122667", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -61,7 +61,7 @@ package body Sprint is\n \n    Dump_Generated_Only : Boolean;\n    --  Set True if the -gnatG (dump generated tree) debug flag is set\n-   --  or for Print_Generated_Code (-gnatG) or Dump_Gnerated_Code (-gnatD).\n+   --  or for Print_Generated_Code (-gnatG) or Dump_Generated_Code (-gnatD).\n \n    Dump_Freeze_Null : Boolean;\n    --  Set True if freeze nodes and non-source null statements output\n@@ -2782,10 +2782,11 @@ package body Sprint is\n       then\n          Write_Id (Entity (Parent (N)));\n \n-      --  For any other kind of node with an associated entity, output it.\n+      --  For any other node with an associated entity, output it\n \n       elsif Nkind (N) in N_Has_Entity\n-        and then Present (Entity (N))\n+        and then Present (Entity_Or_Associated_Node (N))\n+        and then Nkind (Entity_Or_Associated_Node (N)) in N_Entity\n       then\n          Write_Id (Entity (N));\n "}, {"sha": "5f4e6cabadcee03b498ce373ee5b86578dd58e4d", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -96,8 +96,8 @@ package body Switch.C is\n \n             when False =>\n \n-            --  There are only two front-end switches that\n-            --  do not start with -gnat, namely -I and --RTS\n+            --  There are few front-end switches that\n+            --  do not start with -gnat: -I, --RTS, -nostdlib\n \n                if Switch_Chars (Ptr) = 'I' then\n                   Store_Switch := False;\n@@ -119,6 +119,14 @@ package body Switch.C is\n \n                   Ptr := Max + 1;\n \n+               --  Processing of -nostdlib\n+\n+               elsif Ptr + 7 = Max\n+                 and then Switch_Chars (Ptr .. Ptr + 7) = \"nostdlib\"\n+               then\n+                  Opt.No_Stdlib := True;\n+                  Ptr := Max + 1;\n+\n                --  Processing of the --RTS switch. --RTS has been modified by\n                --  gcc and is now of the form -fRTS\n \n@@ -637,6 +645,12 @@ package body Switch.C is\n                Ptr := Ptr + 1;\n                Operating_Mode := Check_Syntax;\n \n+            --  Processing for S switch\n+\n+            when 'S' =>\n+               Print_Standard := True;\n+               Ptr := Ptr + 1;\n+\n             --  Processing for t switch\n \n             when 't' =>"}, {"sha": "76b1c3ebdb9aefee77f2fb09748bdc9ab044c7ea", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -277,6 +277,11 @@ begin\n    Write_Switch_Char (\"s\");\n    Write_Line (\"Syntax check only\");\n \n+   --  Lines for -gnatS switch\n+\n+   Write_Switch_Char (\"S\");\n+   Write_Line (\"Print listing of package Standard\");\n+\n    --  Lines for -gnatt switch\n \n    Write_Switch_Char (\"t\");"}, {"sha": "d98e62ad05028b81f0b0bccf98781784e89e6be7", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9596236a48a791fd47e057d842bdb12622e27751/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=9596236a48a791fd47e057d842bdb12622e27751", "patch": "@@ -1526,6 +1526,12 @@ package VMS_Data is\n    --\n    --   Do not look in the default directory for source files of the runtime.\n \n+   S_GCC_Nostlib : aliased constant S := \"/NOSTD_LIBRARIES \"              &\n+                                            \"-nostdlib\";\n+   --        /NOSTD_LIBRARIES\n+   --\n+   --    Do not look for library files in the system default directory.\n+\n    S_GCC_Opt     : aliased constant S := \"/OPTIMIZE=\"                      &\n                                             \"ALL \"                         &\n                                                \"-O2,!-O0,!-O1,!-O3 \"       &\n@@ -2809,6 +2815,7 @@ package VMS_Data is\n       S_GCC_Noadc   'Access,\n       S_GCC_Noload  'Access,\n       S_GCC_Nostinc 'Access,\n+      S_GCC_Nostlib 'Access,\n       S_GCC_Opt     'Access,\n       S_GCC_OptX    'Access,\n       S_GCC_Polling 'Access,"}]}