{"sha": "f04986a90b4ece27f2d144881adaf9f3d7cd6731", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA0OTg2YTkwYjRlY2UyN2YyZDE0NDg4MWFkYWY5ZjNkN2NkNjczMQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-01-06T21:32:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-01-06T21:32:48Z"}, "message": "PR fortran/PR53876 PR fortran/PR54990 PR fortran/PR54992\n\n2013-01-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/PR53876\n\tPR fortran/PR54990\n\tPR fortran/PR54992\n\t* trans-array.c (build_array_ref): Check the TYPE_CANONICAL\n\tto see if it is GFC_CLASS_TYPE_P.\n\t* trans-expr.c (gfc_get_vptr_from_expr): The same.\n\t(gfc_conv_class_to_class): If the types are not the same,\n\tcast parmese->expr to the type of ctree.\n\t* trans-types.c (gfc_get_derived_type): GFC_CLASS_TYPE_P of\n\tCLASS components must be set.\n\n2013-01-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/PR53876\n\tPR fortran/PR54990\n\tPR fortran/PR54992\n\t* gfortran.dg/class_array_15.f03: New test.\n\nFrom-SVN: r194953", "tree": {"sha": "dfd2767db2b73b5d9034f73b9a1615edf6c836fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfd2767db2b73b5d9034f73b9a1615edf6c836fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f04986a90b4ece27f2d144881adaf9f3d7cd6731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f04986a90b4ece27f2d144881adaf9f3d7cd6731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f04986a90b4ece27f2d144881adaf9f3d7cd6731", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f04986a90b4ece27f2d144881adaf9f3d7cd6731/comments", "author": null, "committer": null, "parents": [{"sha": "1ab05c31a0854497acc8503d4aca9b36d38c3f28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ab05c31a0854497acc8503d4aca9b36d38c3f28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ab05c31a0854497acc8503d4aca9b36d38c3f28"}], "stats": {"total": 324, "additions": 247, "deletions": 77}, "files": [{"sha": "8c2cb3cc4b185c24bd7501c5e020aee861360212", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f04986a90b4ece27f2d144881adaf9f3d7cd6731", "patch": "@@ -1,3 +1,16 @@\n+2013-01-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/PR53876\n+\tPR fortran/PR54990\n+\tPR fortran/PR54992\n+\t* trans-array.c (build_array_ref): Check the TYPE_CANONICAL\n+\tto see if it is GFC_CLASS_TYPE_P.\n+\t* trans-expr.c (gfc_get_vptr_from_expr): The same.\n+\t(gfc_conv_class_to_class): If the types are not the same,\n+\tcast parmese->expr to the type of ctree.\n+\t* trans-types.c (gfc_get_derived_type): GFC_CLASS_TYPE_P of\n+\tCLASS components must be set.\n+\n 2013-01-06  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/42769"}, {"sha": "794322ac79af0ced2417fbb17d95a8a5092da08e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 67, "deletions": 58, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f04986a90b4ece27f2d144881adaf9f3d7cd6731", "patch": "@@ -1,6 +1,6 @@\n /* Array translation routines\n    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011, 2012\n+   2011, 2012, 2013\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -159,7 +159,7 @@ gfc_conv_descriptor_data_get (tree desc)\n /* This provides WRITE access to the data field.\n \n    TUPLES_P is true if we are generating tuples.\n-   \n+\n    This function gets called through the following macros:\n      gfc_conv_descriptor_data_set\n      gfc_conv_descriptor_data_set.  */\n@@ -593,7 +593,7 @@ gfc_get_temp_ss (tree type, tree string_length, int dimen)\n \n   return ss;\n }\n-\t\t\n+\n \n /* Creates and initializes a scalar type gfc_ss struct.  */\n \n@@ -1363,7 +1363,7 @@ gfc_put_offset_into_var (stmtblock_t * pblock, tree * poffset,\n \n /* Variables needed for bounds-checking.  */\n static bool first_len;\n-static tree first_len_val; \n+static tree first_len_val;\n static bool typespec_chararray_ctor;\n \n static void\n@@ -2206,7 +2206,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \n   if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n       && expr->ts.type == BT_CHARACTER && !typespec_chararray_ctor)\n-    {  \n+    {\n       first_len_val = gfc_create_var (gfc_charlen_type_node, \"len\");\n       first_len = true;\n     }\n@@ -2217,7 +2217,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n   if (expr->ts.type == BT_CHARACTER)\n     {\n       bool const_string;\n-      \n+\n       /* get_array_ctor_strlen walks the elements of the constructor, if a\n \t typespec was given, we already know the string length and want the one\n \t specified there.  */\n@@ -2924,9 +2924,9 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n       gcc_assert (se->loop);\n       index = se->loop->loopvar[se->loop->order[i]];\n \n-      /* Pointer functions can have stride[0] different from unity. \n+      /* Pointer functions can have stride[0] different from unity.\n \t Use the stride returned by the function call and stored in\n-\t the descriptor for the temporary.  */ \n+\t the descriptor for the temporary.  */\n       if (se->ss && se->ss->info->type == GFC_SS_FUNCTION\n \t  && se->ss->info->expr\n \t  && se->ss->info->expr->symtree\n@@ -2986,7 +2986,7 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n \t  ts = &ref->u.c.component->ts;\n \t  class_ref = ref;\n \t  break;\n-\t}\t   \n+\t}\n     }\n \n   if (ts == NULL)\n@@ -3099,31 +3099,40 @@ static tree\n build_array_ref (tree desc, tree offset, tree decl)\n {\n   tree tmp;\n+  tree type;\n \n-  /* Class array references need special treatment because the assigned\n-     type size needs to be used to point to the element.  */ \n+  /* Class container types do not always have the GFC_CLASS_TYPE_P\n+     but the canonical type does.  */\n   if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n-\t&& TREE_CODE (desc) == COMPONENT_REF\n-\t&& GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (desc, 0))))\n+      && TREE_CODE (desc) == COMPONENT_REF)\n     {\n-      tree type = gfc_get_element_type (TREE_TYPE (desc));\n-      tmp = TREE_OPERAND (desc, 0);\n-      tmp = gfc_get_class_array_ref (offset, tmp);\n-      tmp = fold_convert (build_pointer_type (type), tmp);\n-      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+      type = TREE_TYPE (TREE_OPERAND (desc, 0));\n+      if (TYPE_CANONICAL (type)\n+\t  && GFC_CLASS_TYPE_P (TYPE_CANONICAL (type)))\n+\ttype = TYPE_CANONICAL (type);\n     }\n   else\n+    type = NULL;\n+\n+  /* Class array references need special treatment because the assigned\n+     type size needs to be used to point to the element.  */\n+  if (type && GFC_CLASS_TYPE_P (type))\n     {\n-      tmp = gfc_conv_array_data (desc);\n+      type = gfc_get_element_type (TREE_TYPE (desc));\n+      tmp = TREE_OPERAND (desc, 0);\n+      tmp = gfc_get_class_array_ref (offset, tmp);\n+      tmp = fold_convert (build_pointer_type (type), tmp);\n       tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-      tmp = gfc_build_array_ref (tmp, offset, decl);\n+      return tmp;\n     }\n \n+  tmp = gfc_conv_array_data (desc);\n+  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+  tmp = gfc_build_array_ref (tmp, offset, decl);\n   return tmp;\n }\n \n \n-\n /* Build an array reference.  se->expr already holds the array descriptor.\n    This should be either a variable, indirect variable reference or component\n    reference.  For arrays which do not have a descriptor, se->expr will be\n@@ -3202,7 +3211,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t      tmp = tmpse.expr;\n \t    }\n \n-\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, \n+\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n \t\t\t\t  indexse.expr, tmp);\n \t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t    \"below lower bound of %%ld\", n+1, sym->name);\n@@ -3964,8 +3973,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t\t       stride_pos, stride_neg);\n \n \t      /* Check the start of the range against the lower and upper\n-\t\t bounds of the array, if the range is not empty. \n-\t         If upper bound is present, include both bounds in the \n+\t\t bounds of the array, if the range is not empty.\n+\t         If upper bound is present, include both bounds in the\n \t\t error message.  */\n \t      if (check_upper)\n \t\t{\n@@ -4012,7 +4021,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  free (msg);\n \t\t}\n-\t      \n+\n \t      /* Compute the last element of the range, which is not\n \t\t necessarily \"end\" (think 0:5:3, which doesn't contain 5)\n \t\t and check it against both lower and upper bounds.  */\n@@ -4041,12 +4050,12 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n \t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, tmp),\n-\t\t     fold_convert (long_integer_type_node, ubound), \n+\t\t     fold_convert (long_integer_type_node, ubound),\n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  gfc_trans_runtime_check (true, false, tmp3, &inner,\n \t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, tmp),\n-\t\t     fold_convert (long_integer_type_node, ubound), \n+\t\t     fold_convert (long_integer_type_node, ubound),\n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  free (msg);\n \t\t}\n@@ -4885,7 +4894,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t      ubound = lower[n];\n \t    }\n \t}\n-      gfc_conv_descriptor_lbound_set (descriptor_block, descriptor, \n+      gfc_conv_descriptor_lbound_set (descriptor_block, descriptor,\n \t\t\t\t      gfc_rank_cst[n], se.expr);\n       conv_lbound = se.expr;\n \n@@ -4916,11 +4925,11 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       /* Check whether multiplying the stride by the number of\n \t elements in this dimension would overflow. We must also check\n \t whether the current dimension has zero size in order to avoid\n-\t division by zero. \n+\t division by zero.\n       */\n-      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, \n-\t\t\t     gfc_array_index_type, \n-\t\t\t     fold_convert (gfc_array_index_type, \n+      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t     gfc_array_index_type,\n+\t\t\t     fold_convert (gfc_array_index_type,\n \t\t\t\t\t   TYPE_MAX_VALUE (gfc_array_index_type)),\n \t\t\t\t\t   size);\n       cond = gfc_unlikely (fold_build2_loc (input_location, LT_EXPR,\n@@ -4935,7 +4944,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       tmp = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n \t\t\t     *overflow, tmp);\n       *overflow = gfc_evaluate_now (tmp, pblock);\n-      \n+\n       /* Multiply the stride by the number of elements in this dimension.  */\n       stride = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\tgfc_array_index_type, stride, size);\n@@ -4966,7 +4975,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t      ubound = lower[n];\n \t    }\n \t}\n-      gfc_conv_descriptor_lbound_set (descriptor_block, descriptor, \n+      gfc_conv_descriptor_lbound_set (descriptor_block, descriptor,\n \t\t\t\t      gfc_rank_cst[n], se.expr);\n \n       if (n < rank + corank - 1)\n@@ -5019,7 +5028,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   /* First check for overflow. Since an array of type character can\n      have zero element_size, we must check for that before\n      dividing.  */\n-  tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, \n+  tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n \t\t\t size_type_node,\n \t\t\t TYPE_MAX_VALUE (size_type_node), element_size);\n   cond = gfc_unlikely (fold_build2_loc (input_location, LT_EXPR,\n@@ -5210,7 +5219,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n     {\n       cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n \t\t\t   boolean_type_node, var_overflow, integer_zero_node));\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, \n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n \t\t\t     error, gfc_finish_block (&elseblock));\n     }\n   else\n@@ -5221,7 +5230,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (expr->ts.type == BT_CLASS)\n     {\n       tmp = build_int_cst (unsigned_char_type_node, 0);\n-      /* With class objects, it is best to play safe and null the \n+      /* With class objects, it is best to play safe and null the\n \t memory because we cannot know if dynamic types have allocatable\n \t components or not.  */\n       tmp = build_call_expr_loc (input_location,\n@@ -5233,7 +5242,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   /* Update the array descriptors. */\n   if (dimension)\n     gfc_conv_descriptor_offset_set (&set_descriptor_block, se->expr, offset);\n-  \n+\n   set_descriptor = gfc_finish_block (&set_descriptor_block);\n   if (status != NULL_TREE)\n     {\n@@ -5243,7 +5252,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n       gfc_add_expr_to_block (&se->pre,\n \t\t fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t  gfc_likely (cond), set_descriptor,\n-\t\t\t\t  build_empty_stmt (input_location))); \n+\t\t\t\t  build_empty_stmt (input_location)));\n     }\n   else\n       gfc_add_expr_to_block (&se->pre, set_descriptor);\n@@ -5331,7 +5340,7 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n       /* A single scalar or derived type value.  Create an array with all\n          elements equal to that value.  */\n       gfc_init_se (&se, NULL);\n-      \n+\n       if (expr->expr_type == EXPR_CONSTANT)\n \tgfc_conv_constant (&se, expr);\n       else\n@@ -5743,7 +5752,7 @@ gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)\n       tmp = gfc_conv_expr_present (sym);\n       stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n     }\n-  \n+\n   gfc_add_init_cleanup (block, stmt, NULL_TREE);\n }\n \n@@ -5945,7 +5954,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n \t      asprintf (&msg, \"Dimension %d of array '%s' has extent \"\n \t\t\t\"%%ld instead of %%ld\", n+1, sym->name);\n \n-\t      gfc_trans_runtime_check (true, false, tmp, &init, &loc, msg, \n+\t      gfc_trans_runtime_check (true, false, tmp, &init, &loc, msg,\n \t\t\tfold_convert (long_integer_type_node, temp),\n \t\t\tfold_convert (long_integer_type_node, stride2));\n \n@@ -6069,7 +6078,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       gfc_add_expr_to_block (&cleanup, tmp);\n \n       stmtCleanup = gfc_finish_block (&cleanup);\n-\t\n+\n       /* Only do the cleanup if the array was repacked.  */\n       tmp = build_fold_indirect_ref_loc (input_location, dumdesc);\n       tmp = gfc_conv_descriptor_data_get (tmp);\n@@ -6381,7 +6390,7 @@ walk_coarray (gfc_expr *e)\n \t EXPR is the right-hand side of a pointer assignment and\n \t se->expr is the descriptor for the previously-evaluated\n \t left-hand side.  The function creates an assignment from\n-\t EXPR to se->expr.  \n+\t EXPR to se->expr.\n \n \n    The se->force_tmp flag disables the non-copying descriptor optimization\n@@ -6495,7 +6504,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  return;\n \t}\n       break;\n-      \n+\n     case EXPR_FUNCTION:\n       /* A transformational function return value will be a temporary\n \t array descriptor.  We still need to go through the scalarizer\n@@ -6785,7 +6794,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  /* Vector subscripts need copying and are handled elsewhere.  */\n \t  if (info->ref)\n \t    gcc_assert (info->ref->u.ar.dimen_type[n] == DIMEN_RANGE);\n- \n+\n \t  /* look for the corresponding scalarizer dimension: dim.  */\n \t  for (dim = 0; dim < ndim; dim++)\n \t    if (ss->dim[dim] == n)\n@@ -7011,9 +7020,9 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \n       if (!sym->attr.pointer\n \t  && sym->as\n-\t  && sym->as->type != AS_ASSUMED_SHAPE \n+\t  && sym->as->type != AS_ASSUMED_SHAPE\n \t  && sym->as->type != AS_DEFERRED\n-\t  && sym->as->type != AS_ASSUMED_RANK \n+\t  && sym->as->type != AS_ASSUMED_RANK\n \t  && !sym->attr.allocatable)\n         {\n \t  /* Some variables are declared directly, others are declared as\n@@ -7071,7 +7080,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \t\t       && expr->symtree->n.sym->attr.allocatable;\n \n   /* Or ultimate allocatable components.  */\n-  ultimate_alloc_comp = contiguous && ultimate_alloc_comp; \n+  ultimate_alloc_comp = contiguous && ultimate_alloc_comp;\n \n   if (no_pack || array_constructor || good_allocatable || ultimate_alloc_comp)\n     {\n@@ -7254,7 +7263,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \n tree\n gfc_trans_dealloc_allocated (tree descriptor, bool coarray)\n-{ \n+{\n   tree tmp;\n   tree var;\n   stmtblock_t block;\n@@ -7454,7 +7463,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       tmp = gfc_conv_array_data (decl);\n       var = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     tmp);\n-\t\n+\n       /* Get the number of elements - 1 and set the counter.  */\n       if (GFC_DESCRIPTOR_TYPE_P (decl_type))\n \t{\n@@ -7578,7 +7587,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      /* Allocatable CLASS components.  */\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      \n+\n \t      /* Add reference to '_data' component.  */\n \t      tmp = CLASS_DATA (c)->backend_decl;\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n@@ -7725,7 +7734,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t      null_cond = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t   boolean_type_node, src_data,\n-\t\t\t\t           null_pointer_node); \t\n+\t\t\t\t           null_pointer_node);\n \n \t      gfc_add_expr_to_block (&fnblock, build3_v (COND_EXPR, null_cond,\n \t\t\t\t\t\t\t tmp, null_data));\n@@ -8030,7 +8039,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n     as = NULL;\n \n   /* If the lhs shape is not the same as the rhs jump to setting the\n-     bounds and doing the reallocation.......  */ \n+     bounds and doing the reallocation.......  */\n   for (n = 0; n < expr1->rank; n++)\n     {\n       /* Check the shape.  */\n@@ -8051,13 +8060,13 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       tmp = build3_v (COND_EXPR, cond,\n \t\t      build1_v (GOTO_EXPR, jump_label1),\n \t\t      build_empty_stmt (input_location));\n-      gfc_add_expr_to_block (&fblock, tmp);\t  \n+      gfc_add_expr_to_block (&fblock, tmp);\n     }\n \n   /* ....else jump past the (re)alloc code.  */\n   tmp = build1_v (GOTO_EXPR, jump_label2);\n   gfc_add_expr_to_block (&fblock, tmp);\n-    \n+\n   /* Add the label to start automatic (re)allocation.  */\n   tmp = build1_v (LABEL_EXPR, jump_label1);\n   gfc_add_expr_to_block (&fblock, tmp);\n@@ -8096,7 +8105,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n      unallocated allocatable variable, then it is allocated with each\n      deferred type parameter equal to the corresponding type parameters\n      of expr , with the shape of expr , and with each lower bound equal\n-     to the corresponding element of LBOUND(expr).\"  \n+     to the corresponding element of LBOUND(expr).\"\n      Reuse size1 to keep a dimension-by-dimension track of the\n      stride of the new array.  */\n   size1 = gfc_index_one_node;\n@@ -8340,7 +8349,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n \t\t\t\t\t\tsym->backend_decl);\n       type = TREE_TYPE (descriptor);\n     }\n-  \n+\n   /* NULLIFY the data pointer.  */\n   if (GFC_DESCRIPTOR_TYPE_P (type) && !sym->attr.save)\n     gfc_conv_descriptor_data_set (&init, descriptor, null_pointer_node);"}, {"sha": "9452e27696271a2141d2835ded1d548365e16bcc", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f04986a90b4ece27f2d144881adaf9f3d7cd6731", "patch": "@@ -198,16 +198,31 @@ gfc_vtable_final_get (tree decl)\n #undef VTABLE_FINAL_FIELD\n \n \n-/* Obtain the vptr of the last class reference in an expression.  */\n+/* Obtain the vptr of the last class reference in an expression.\n+   Return NULL_TREE if no class reference is found.  */\n \n tree\n gfc_get_vptr_from_expr (tree expr)\n {\n-  tree tmp = expr;\n-  while (tmp && !GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n-    tmp = TREE_OPERAND (tmp, 0);\n-  tmp = gfc_class_vptr_get (tmp);\n-  return tmp;\n+  tree tmp;\n+  tree type;\n+\n+  for (tmp = expr; tmp; tmp = TREE_OPERAND (tmp, 0))\n+    {\n+      type = TREE_TYPE (tmp);\n+      while (type)\n+\t{\n+\t  if (GFC_CLASS_TYPE_P (type))\n+\t    return gfc_class_vptr_get (tmp);\n+\t  if (type != TYPE_CANONICAL (type))\n+\t    type = TYPE_CANONICAL (type);\n+\t  else\n+\t    type = NULL_TREE;\n+\t}\n+      if (TREE_CODE (tmp) == VAR_DECL)\n+\tbreak;\n+    }\n+  return NULL_TREE;\n }\n \n \n@@ -594,7 +609,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n     }\n   else\n     {\n-      if (CLASS_DATA (e)->attr.codimension)\n+      if (TREE_TYPE (parmse->expr) != TREE_TYPE (ctree))\n \tparmse->expr = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n \t\t\t\t\tTREE_TYPE (ctree), parmse->expr);\n       gfc_add_modify (&block, ctree, parmse->expr);\n@@ -1562,6 +1577,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n       c->norestrict_decl = f2;\n       field = f2;\n     }\n+\n   tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t decl, field, NULL_TREE);\n "}, {"sha": "cd9bde614c14400795ba5fb651e44b51b1faac3c", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f04986a90b4ece27f2d144881adaf9f3d7cd6731", "patch": "@@ -1,6 +1,6 @@\n /* Backend support for Fortran 95 basic types and derived types.\n    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010, 2011, 2012\n+   2010, 2011, 2012, 2013\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -124,7 +124,7 @@ int gfc_atomic_logical_kind;\n \n /* The kind size used for record offsets. If the target system supports\n    kind=8, this will be set to 8, otherwise it is set to 4.  */\n-int gfc_intio_kind; \n+int gfc_intio_kind;\n \n /* The integer kind used to store character lengths.  */\n int gfc_charlen_int_kind;\n@@ -138,7 +138,7 @@ gfc_try\n gfc_check_any_c_kind (gfc_typespec *ts)\n {\n   int i;\n-  \n+\n   for (i = 0; i < ISOCBINDING_NUMBER; i++)\n     {\n       /* Check for any C interoperable kind for the given type/kind in ts.\n@@ -400,16 +400,16 @@ gfc_init_kinds (void)\n       i_index += 1;\n     }\n \n-  /* Set the kind used to match GFC_INT_IO in libgfortran.  This is \n+  /* Set the kind used to match GFC_INT_IO in libgfortran.  This is\n      used for large file access.  */\n \n   if (saw_i8)\n     gfc_intio_kind = 8;\n   else\n     gfc_intio_kind = 4;\n \n-  /* If we do not at least have kind = 4, everything is pointless.  */  \n-  gcc_assert(saw_i4);  \n+  /* If we do not at least have kind = 4, everything is pointless.  */\n+  gcc_assert(saw_i4);\n \n   /* Set the maximum integer kind.  Used with at least BOZ constants.  */\n   gfc_max_integer_kind = gfc_integer_kinds[i_index - 1].kind;\n@@ -550,7 +550,7 @@ gfc_init_kinds (void)\n   else\n     gfc_default_real_kind = gfc_real_kinds[0].kind;\n \n-  /* Choose the default double kind.  If -fdefault-real and -fdefault-double \n+  /* Choose the default double kind.  If -fdefault-real and -fdefault-double\n      are specified, we use kind=8, if it's available.  If -fdefault-real is\n      specified without -fdefault-double, we use kind=16, if it's available.\n      Otherwise we do not change anything.  */\n@@ -1624,10 +1624,10 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n \t  type = build_pointer_type (type);\n \n \t  if (restricted)\n-\t    type = build_qualified_type (type, TYPE_QUAL_RESTRICT);\t\n+\t    type = build_qualified_type (type, TYPE_QUAL_RESTRICT);\n \n \t  GFC_ARRAY_TYPE_P (type) = 1;\n-\t  TYPE_LANG_SPECIFIC (type) = TYPE_LANG_SPECIFIC (TREE_TYPE (type)); \n+\t  TYPE_LANG_SPECIFIC (type) = TYPE_LANG_SPECIFIC (TREE_TYPE (type));\n \t}\n \n       return type;\n@@ -2286,7 +2286,7 @@ gfc_copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to,\n      a derived type, we need a copy of its component declarations.\n      This is done by recursing into gfc_get_derived_type and\n      ensures that the component's component declarations have\n-     been built.  If it is a character, we need the character \n+     been built.  If it is a character, we need the character\n      length, as well.  */\n   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)\n     {\n@@ -2367,7 +2367,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n          BT_INTEGER that needs to fit a void * for the purpose of the\n          iso_c_binding derived types.  */\n       derived->ts.f90_type = BT_VOID;\n-      \n+\n       return derived->backend_decl;\n     }\n \n@@ -2532,6 +2532,15 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t  field_type = build_pointer_type_for_mode (TREE_TYPE (field_type),\n \t\t\t\t\t\t    ptr_mode, true);\n \n+      /* Ensure that the CLASS language specific flag is set.  */\n+      if (c->ts.type == BT_CLASS)\n+\t{\n+\t  if (POINTER_TYPE_P (field_type))\n+\t    GFC_CLASS_TYPE_P (TREE_TYPE (field_type)) = 1;\n+\t  else\n+\t    GFC_CLASS_TYPE_P (field_type) = 1;\n+\t}\n+\n       field = gfc_add_field_to_struct (typenode,\n \t\t\t\t       get_identifier (c->name),\n \t\t\t\t       field_type, &chain);\n@@ -2832,7 +2841,7 @@ gfc_get_function_type (gfc_symbol * sym)\n \t   && sym->ts.kind == gfc_default_real_kind\n \t   && !sym->attr.always_explicit)\n     {\n-      /* Special case: f2c calling conventions require that (scalar) \n+      /* Special case: f2c calling conventions require that (scalar)\n \t default REAL functions return the C type double instead.  f2c\n \t compatibility is only an issue with functions that don't\n \t require an explicit interface, as only these could be"}, {"sha": "0f15221d3c5b902b7b793fbe5d9b86a95b9d96fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f04986a90b4ece27f2d144881adaf9f3d7cd6731", "patch": "@@ -1,3 +1,10 @@\n+2013-01-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/PR53876\n+\tPR fortran/PR54990\n+\tPR fortran/PR54992\n+\t* gfortran.dg/class_array_15.f03: New test.\n+\n 2013-01-06  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/42769"}, {"sha": "7d1d4d7181bec0b505a11e728731db1f9fc05d49", "filename": "gcc/testsuite/gfortran.dg/class_array_15.f03", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_15.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04986a90b4ece27f2d144881adaf9f3d7cd6731/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_15.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_15.f03?ref=f04986a90b4ece27f2d144881adaf9f3d7cd6731", "patch": "@@ -0,0 +1,116 @@\n+! { dg-do run }\n+!\n+! Tests the fixes for three bugs with the same underlying cause.  All are regressions\n+! that come about because class array elements end up with a different tree type\n+! to the class array.  In addition, the language specific flag that marks a class\n+! container is not being set.\n+!\n+! PR53876 contributed by Prince Ogunbade  <pogos77@hotmail.com>\n+! PR54990 contributed by Janus Weil  <janus@gcc.gnu.org>\n+! PR54992 contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+! The two latter bugs were reported by Andrew Benson\n+! starting at http://gcc.gnu.org/ml/fortran/2012-10/msg00087.html\n+!\n+module G_Nodes\n+  type :: nc\n+    type(tn), pointer :: hostNode\n+  end type nc\n+  type, extends(nc) :: ncBh\n+  end type ncBh\n+  type, public, extends(ncBh) :: ncBhStd\n+    double precision :: massSeedData\n+  end type ncBhStd\n+  type, public :: tn\n+    class (ncBh), allocatable, dimension(:) :: cBh\n+  end type tn\n+  type(ncBhStd) :: defaultBhC\n+contains\n+  subroutine Node_C_Bh_Move(targetNode)\n+    implicit none\n+    type (tn  ), intent(inout) , target       :: targetNode\n+    class(ncBh), allocatable   , dimension(:) :: instancesTemporary\n+! These two lines resulted in the wrong result:\n+    allocate(instancesTemporary(2),source=defaultBhC)\n+    call Move_Alloc(instancesTemporary,targetNode%cBh)\n+! These two lines gave the correct result:\n+!!deallocate(targetNode%cBh)\n+!!allocate(targetNode%cBh(2))\n+    targetNode%cBh(1)%hostNode => targetNode\n+    targetNode%cBh(2)%hostNode => targetNode\n+    return\n+  end subroutine Node_C_Bh_Move\n+  function bhGet(self,instance)\n+    implicit none\n+    class (ncBh), pointer               :: bhGet\n+    class (tn  ), intent(inout), target :: self\n+    integer     , intent(in   )         :: instance\n+    bhGet => self%cBh(instance)\n+    return\n+  end function bhGet\n+end module G_Nodes\n+\n+  call pr53876\n+  call pr54990\n+  call pr54992\n+end\n+\n+subroutine pr53876\n+  IMPLICIT NONE\n+  TYPE :: individual\n+    integer :: icomp ! Add an extra component to test offset\n+    REAL, DIMENSION(:), ALLOCATABLE :: genes\n+  END TYPE\n+  CLASS(individual), DIMENSION(:), ALLOCATABLE :: indv\n+  allocate (indv(2), source = [individual(1, [99,999]), &\n+                               individual(2, [999,9999])])\n+  CALL display_indv(indv(2)) ! Similarly, reference 2nd element to test offset\n+CONTAINS\n+  SUBROUTINE display_indv(self)\n+    CLASS(individual),  INTENT(IN) :: self\n+    if (any(self%genes .ne. [999,9999]) )call abort\n+  END SUBROUTINE\n+END\n+\n+subroutine pr54990\n+  implicit none\n+  type :: ncBhStd\n+    integer :: i\n+  end type\n+  type, extends(ncBhStd) :: ncBhStde\n+    integer :: i2(2)\n+  end type\n+  type :: tn\n+    integer :: i ! Add an extra component to test offset\n+    class (ncBhStd), allocatable, dimension(:) :: cBh\n+  end type\n+  integer :: i\n+  type(tn), target :: a\n+  allocate (a%cBh(2), source = [(ncBhStde(i*99, [1,2]), i = 1,2)])\n+  select type (q => a%cBh(2)) ! Similarly, reference 2nd element to test offset\n+    type is (ncBhStd)\n+      call abort\n+    type is (ncBhStde)\n+      if (q%i .ne. 198) call abort ! This tests that the component really gets the\n+  end select                       ! language specific flag denoting a class type\n+end\n+\n+subroutine pr54992  ! This test remains as the original.\n+  use G_Nodes\n+  implicit none\n+  type (tn), target  :: b\n+  class(ncBh), pointer :: bh\n+  class(ncBh), allocatable, dimension(:) :: t\n+  allocate(b%cBh(1),source=defaultBhC)\n+  b%cBh(1)%hostNode => b\n+! #1 this worked\n+  if (loc(b) .ne. loc(b%cBh(1)%hostNode)) call abort\n+  call Node_C_Bh_Move(b)\n+! #2 this worked\n+  if (loc(b) .ne. loc(b%cBh(1)%hostNode)) call abort\n+  if (loc(b) .ne. loc(b%cBh(2)%hostNode)) call abort\n+! #3 this did not\n+  bh => bhGet(b,instance=1)\n+  if (loc (b) .ne. loc(bh%hostNode)) call abort\n+  bh => bhGet(b,instance=2)\n+  if (loc (b) .ne. loc(bh%hostNode)) call abort\n+end"}]}