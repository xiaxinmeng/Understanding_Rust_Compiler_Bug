{"sha": "ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2YTFlMzUzMjJhOGI5YjAwOGM1ZmVmN2E4ZWZmZGJmMTdiNjhlYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-18T07:12:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-18T07:12:46Z"}, "message": "ipa-inline-transform.c (preserve_function_body_p): Look for first non-thunk clone.\n\n\t* ipa-inline-transform.c (preserve_function_body_p): Look for\n\tfirst non-thunk clone.\n\t(save_function_body): Save into first non-thunk.\n\t* lto-cgraph.c (lto_output_edge): When streaming thunk do not look\n\tup call stmt id.\n\t(lto_output_node): Inline thunks don't need body in every\n\tpartition.\n\t* lto-streamer-in.c: Do not fixup thunk clones.\n\t* cgraphclones.c (cgraph_node::create_edge_including_clone): Skip\n\tthunks.\n\t* tree-inline.c (copy_bb): Be prepared for target node to be new after\n\tfolding suceeds.\n\nFrom-SVN: r236357", "tree": {"sha": "51f4dc565b802a5108ca6b8ff2ddbbb66ebc9e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51f4dc565b802a5108ca6b8ff2ddbbb66ebc9e33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/comments", "author": null, "committer": null, "parents": [{"sha": "df8b0a111998b29f47616001251333ce36984353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8b0a111998b29f47616001251333ce36984353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df8b0a111998b29f47616001251333ce36984353"}], "stats": {"total": 105, "additions": 71, "deletions": 34}, "files": [{"sha": "40d723b2b179ba5339d7126fd996438c218b76ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "patch": "@@ -1,3 +1,18 @@\n+2016-05-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-transform.c (preserve_function_body_p): Look for\n+\tfirst non-thunk clone.\n+\t(save_function_body): Save into first non-thunk.\n+\t* lto-cgraph.c (lto_output_edge): When streaming thunk do not look\n+\tup call stmt id.\n+\t(lto_output_node): Inline thunks don't need body in every\n+\tpartition.\n+\t* lto-streamer-in.c: Do not fixup thunk clones.\n+\t* cgraphclones.c (cgraph_node::create_edge_including_clone): Skip\n+\tthunks.\n+\t* tree-inline.c (copy_bb): Be prepared for target node to be new after\n+\tfolding suceeds.\n+\n 2016-05-17  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \tPR middle-end/63586"}, {"sha": "686c28900210c73e924902f6401fd403a1f46f35", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "patch": "@@ -771,33 +771,35 @@ cgraph_node::create_edge_including_clones (cgraph_node *callee,\n   node = clones;\n   if (node)\n     while (node != this)\n-      {\n-\tcgraph_edge *edge = node->get_edge (old_stmt);\n-\n-        /* It is possible that clones already contain the edge while\n-\t   master didn't.  Either we promoted indirect call into direct\n-\t   call in the clone or we are processing clones of unreachable\n-\t   master where edges has been removed.  */\n-\tif (edge)\n-\t  edge->set_call_stmt (stmt);\n-\telse if (! node->get_edge (stmt))\n-\t  {\n-\t    edge = node->create_edge (callee, stmt, count, freq);\n-\t    edge->inline_failed = reason;\n-\t  }\n+      /* Thunk clones do not get updated while copying inline function body.  */\n+      if (!node->thunk.thunk_p)\n+\t{\n+\t  cgraph_edge *edge = node->get_edge (old_stmt);\n+\n+\t  /* It is possible that clones already contain the edge while\n+\t     master didn't.  Either we promoted indirect call into direct\n+\t     call in the clone or we are processing clones of unreachable\n+\t     master where edges has been removed.  */\n+\t  if (edge)\n+\t    edge->set_call_stmt (stmt);\n+\t  else if (! node->get_edge (stmt))\n+\t    {\n+\t      edge = node->create_edge (callee, stmt, count, freq);\n+\t      edge->inline_failed = reason;\n+\t    }\n \n-\tif (node->clones)\n-\t  node = node->clones;\n-\telse if (node->next_sibling_clone)\n-\t  node = node->next_sibling_clone;\n-\telse\n-\t  {\n-\t    while (node != this && !node->next_sibling_clone)\n-\t      node = node->clone_of;\n-\t    if (node != this)\n-\t      node = node->next_sibling_clone;\n-\t  }\n-      }\n+\t  if (node->clones)\n+\t    node = node->clones;\n+\t  else if (node->next_sibling_clone)\n+\t    node = node->next_sibling_clone;\n+\t  else\n+\t    {\n+\t      while (node != this && !node->next_sibling_clone)\n+\t\tnode = node->clone_of;\n+\t      if (node != this)\n+\t\tnode = node->next_sibling_clone;\n+\t    }\n+\t}\n }\n \n /* Remove the node from cgraph and all inline clones inlined into it."}, {"sha": "90a0d7ebbb78f8fd8fc86c08b03e6086d1756109", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "patch": "@@ -506,6 +506,22 @@ save_inline_function_body (struct cgraph_node *node)\n \n   /* first_clone will be turned into real function.  */\n   first_clone = node->clones;\n+\n+  /* Arrange first clone to not be thunk as those do not have bodies.  */\n+  if (first_clone->thunk.thunk_p)\n+    {\n+      while (first_clone->thunk.thunk_p)\n+        first_clone = first_clone->next_sibling_clone;\n+      first_clone->prev_sibling_clone->next_sibling_clone\n+\t= first_clone->next_sibling_clone;\n+      if (first_clone->next_sibling_clone)\n+\tfirst_clone->next_sibling_clone->prev_sibling_clone\n+\t   = first_clone->prev_sibling_clone;\n+      first_clone->next_sibling_clone = node->clones;\n+      first_clone->prev_sibling_clone = NULL;\n+      node->clones->prev_sibling_clone = first_clone;\n+      node->clones = first_clone;\n+    }\n   first_clone->decl = copy_node (node->decl);\n   first_clone->decl->decl_with_vis.symtab_node = first_clone;\n   gcc_assert (first_clone == cgraph_node::get (first_clone->decl));\n@@ -514,7 +530,8 @@ save_inline_function_body (struct cgraph_node *node)\n      first_clone.  */\n   if (first_clone->next_sibling_clone)\n     {\n-      for (n = first_clone->next_sibling_clone; n->next_sibling_clone; n = n->next_sibling_clone)\n+      for (n = first_clone->next_sibling_clone; n->next_sibling_clone;\n+\t   n = n->next_sibling_clone)\n         n->clone_of = first_clone;\n       n->clone_of = first_clone;\n       n->next_sibling_clone = first_clone->clones;\n@@ -587,9 +604,10 @@ preserve_function_body_p (struct cgraph_node *node)\n   gcc_assert (symtab->global_info_ready);\n   gcc_assert (!node->alias && !node->thunk.thunk_p);\n \n-  /* Look if there is any clone around.  */\n-  if (node->clones && !node->clones->thunk.thunk_p)\n-    return true;\n+  /* Look if there is any non-thunk clone around.  */\n+  for (node = node->clones; node; node = node->next_sibling_clone)\n+    if (!node->thunk.thunk_p)\n+      return true;\n   return false;\n }\n "}, {"sha": "5cef2bae159616d67cdecea0c6e04b69b9052897", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "patch": "@@ -259,7 +259,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   streamer_write_gcov_count_stream (ob->main_stream, edge->count);\n \n   bp = bitpack_create (ob->main_stream);\n-  uid = (!gimple_has_body_p (edge->caller->decl)\n+  uid = (!gimple_has_body_p (edge->caller->decl) || edge->caller->thunk.thunk_p\n \t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt) + 1);\n   bp_pack_enum (&bp, cgraph_inline_failed_t,\n \t        CIF_N_REASONS, edge->inline_failed);\n@@ -398,7 +398,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n \n-  if (node->analyzed && (!boundary_p || node->alias || node->thunk.thunk_p))\n+  if (node->analyzed && (!boundary_p || node->alias\n+\t\t\t || (node->thunk.thunk_p && !node->global.inlined_to)))\n     tag = LTO_symtab_analyzed_node;\n   else\n     tag = LTO_symtab_unavail_node;"}, {"sha": "3a353cd04370e03336ed0451171fc4b85d427963", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "patch": "@@ -953,7 +953,8 @@ fixup_call_stmt_edges (struct cgraph_node *orig, gimple **stmts)\n   if (orig->clones)\n     for (node = orig->clones; node != orig;)\n       {\n-\tfixup_call_stmt_edges_1 (node, stmts, fn);\n+\tif (!node->thunk.thunk_p)\n+\t  fixup_call_stmt_edges_1 (node, stmts, fn);\n \tif (node->clones)\n \t  node = node->clones;\n \telse if (node->next_sibling_clone)"}, {"sha": "4eb8d200411da081a89a91cbf243cd110738c153", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ec6a1e35322a8b9b008c5fef7a8effdbf17b68eb", "patch": "@@ -2063,7 +2063,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  && id->dst_node->definition\n \t\t  && (fn = gimple_call_fndecl (stmt)) != NULL)\n \t\t{\n-\t\t  struct cgraph_node *dest = cgraph_node::get (fn);\n+\t\t  struct cgraph_node *dest = cgraph_node::get_create (fn);\n \n \t\t  /* We have missing edge in the callgraph.  This can happen\n \t\t     when previous inlining turned an indirect call into a"}]}