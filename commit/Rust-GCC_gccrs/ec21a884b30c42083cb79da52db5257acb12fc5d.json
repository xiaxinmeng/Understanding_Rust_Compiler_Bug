{"sha": "ec21a884b30c42083cb79da52db5257acb12fc5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyMWE4ODRiMzBjNDIwODNjYjc5ZGE1MmRiNTI1N2FjYjEyZmM1ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-12-29T17:15:14Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-12-29T17:15:14Z"}, "message": "rs6000.c (init_float128_ieee): Remove IEEE 128-bit comparison functions in cmp_optab and ucmp_optab.\n\n2015-12-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (init_float128_ieee): Remove IEEE 128-bit\n\tcomparison functions in cmp_optab and ucmp_optab.\n\t(rs6000_generate_compare): Rewrite IEEE 128-bit floating point\n\tsoftware emulation comparisons to only use __eqkf2, __gekf2,\n\t__lekf2, and __unordkf2 functions.\n\t(rs6000_invalid_binary_op): Add support for -mfloat128-convert.\n\n\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Define\n\t__FLOAT128_HARDWARE__ if hardware IEEE 128-bit support is\n\tavailable.\n\n\t* config/rs6000/rs6000.opt (-mfloat128-convert): Add debug switch\n\tto allow IBM extended double and IEEE 128-bit floating point to be\n\tconverted with default conversions.\n\n\t* config/rs6000/rs6000.md (extendkftf2): Add converters between\n\tKFmode and TFmode if -mabi=ieeelongdouble.\n\t(trunctfkf2): Likewise.\n\t(ieee128_mfvsrd): Split 64-bit integer conversions into 32-bit and\n\t64-bit insns.\n\t(ieee128_mfvsrd_64bit): Likewise.\n\t(ieee128_mfvsrd_32bit): Likewise.\n\t(ieee128_mtvsrd): Likewise.\n\t(ieee128_mtvsrd_64bit): Likewise.\n\t(ieee128_mtvsrd_32bit): Likewise.\n\n\t* doc/extend.texi (Floating Types): Document that complex\n\t__float128 does not work currently.\n\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document that\n\t-mfloat128 is only supported on PowerPC 64-bit Linux systems.\n\nFrom-SVN: r231996", "tree": {"sha": "5ceb4a02404f0471ca1c43bbca8a105917573652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ceb4a02404f0471ca1c43bbca8a105917573652"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec21a884b30c42083cb79da52db5257acb12fc5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec21a884b30c42083cb79da52db5257acb12fc5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec21a884b30c42083cb79da52db5257acb12fc5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec21a884b30c42083cb79da52db5257acb12fc5d/comments", "author": null, "committer": null, "parents": [{"sha": "1c645536272780edf11eacc98bf2fa014f8c1489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c645536272780edf11eacc98bf2fa014f8c1489", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c645536272780edf11eacc98bf2fa014f8c1489"}], "stats": {"total": 266, "additions": 168, "deletions": 98}, "files": [{"sha": "1643888b2c880935c46e98301e893673e2420067", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec21a884b30c42083cb79da52db5257acb12fc5d", "patch": "@@ -1,3 +1,37 @@\n+2015-12-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (init_float128_ieee): Remove IEEE 128-bit\n+\tcomparison functions in cmp_optab and ucmp_optab.\n+\t(rs6000_generate_compare): Rewrite IEEE 128-bit floating point\n+\tsoftware emulation comparisons to only use __eqkf2, __gekf2,\n+\t__lekf2, and __unordkf2 functions.\n+\t(rs6000_invalid_binary_op): Add support for -mfloat128-convert.\n+\n+\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Define\n+\t__FLOAT128_HARDWARE__ if hardware IEEE 128-bit support is\n+\tavailable.\n+\n+\t* config/rs6000/rs6000.opt (-mfloat128-convert): Add debug switch\n+\tto allow IBM extended double and IEEE 128-bit floating point to be\n+\tconverted with default conversions.\n+\n+\t* config/rs6000/rs6000.md (extendkftf2): Add converters between\n+\tKFmode and TFmode if -mabi=ieeelongdouble.\n+\t(trunctfkf2): Likewise.\n+\t(ieee128_mfvsrd): Split 64-bit integer conversions into 32-bit and\n+\t64-bit insns.\n+\t(ieee128_mfvsrd_64bit): Likewise.\n+\t(ieee128_mfvsrd_32bit): Likewise.\n+\t(ieee128_mtvsrd): Likewise.\n+\t(ieee128_mtvsrd_64bit): Likewise.\n+\t(ieee128_mtvsrd_32bit): Likewise.\n+\n+\t* doc/extend.texi (Floating Types): Document that complex\n+\t__float128 does not work currently.\n+\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document that\n+\t-mfloat128 is only supported on PowerPC 64-bit Linux systems.\n+\n 2015-12-28  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_le_vsx_move): Verify that"}, {"sha": "85b4b3cfcb0e6b0ba5f1e2a04720b7dcf0f4a502", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=ec21a884b30c42083cb79da52db5257acb12fc5d", "patch": "@@ -412,6 +412,8 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"__RSQRTEF__\");\n   if (TARGET_FLOAT128)\n     builtin_define (\"__FLOAT128__\");\n+  if (TARGET_FLOAT128_HW)\n+    builtin_define (\"__FLOAT128_HARDWARE__\");\n \n   if (TARGET_EXTRA_BUILTINS && cpp_get_options (pfile)->lang != CLK_ASM)\n     {"}, {"sha": "a71d0b635448dd8f305555ae300c56e29f246ad7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 83, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ec21a884b30c42083cb79da52db5257acb12fc5d", "patch": "@@ -16501,8 +16501,6 @@ init_float128_ieee (machine_mode mode)\n       set_optab_libfunc (lt_optab, mode, \"__ltkf2\");\n       set_optab_libfunc (le_optab, mode, \"__lekf2\");\n       set_optab_libfunc (unord_optab, mode, \"__unordkf2\");\n-      set_optab_libfunc (cmp_optab, mode, \"__cmpokf2\");\t\t/* fcmpo */\n-      set_optab_libfunc (ucmp_optab, mode, \"__cmpukf2\");\t/* fcmpu */\n \n       set_conv_libfunc (sext_optab, mode, SFmode, \"__extendsfkf2\");\n       set_conv_libfunc (sext_optab, mode, DFmode, \"__extenddfkf2\");\n@@ -20297,7 +20295,9 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n   rtx op0 = XEXP (cmp, 0);\n   rtx op1 = XEXP (cmp, 1);\n \n-  if (FLOAT_MODE_P (mode))\n+  if (!TARGET_FLOAT128_HW && FLOAT128_VECTOR_P (mode))\n+    comp_mode = CCmode;\n+  else if (FLOAT_MODE_P (mode))\n     comp_mode = CCFPmode;\n   else if (code == GTU || code == LTU\n \t   || code == GEU || code == LEU)\n@@ -20503,106 +20503,77 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n       emit_insn (cmp);\n     }\n \n-  /* IEEE 128-bit support in VSX registers.  If we do not have IEEE 128-bit\n-     hardware, the comparison functions (__cmpokf2 and __cmpukf2) returns 0..15\n-     that is laid out the same way as the PowerPC CR register would for a\n-     normal floating point comparison from the fcmpo and fcmpu\n-     instructions.  */\n-  else if (!TARGET_FLOAT128_HW && FLOAT128_IEEE_P (mode))\n+  /* IEEE 128-bit support in VSX registers when we do not have hardware\n+     support.  */\n+  else if (!TARGET_FLOAT128_HW && FLOAT128_VECTOR_P (mode))\n     {\n-      rtx and_reg = gen_reg_rtx (SImode);\n+      rtx libfunc = NULL_RTX;\n+      bool uneq_or_ltgt = false;\n       rtx dest = gen_reg_rtx (SImode);\n-      rtx libfunc = optab_libfunc (ucmp_optab, mode);\n-      HOST_WIDE_INT mask_value = 0;\n-\n-      /* Values that __cmpokf2/__cmpukf2 returns.  */\n-#define PPC_CMP_UNORDERED\t0x1\t\t/* isnan (a) || isnan (b).  */\n-#define PPC_CMP_EQUAL\t\t0x2\t\t/* a == b.  */\n-#define PPC_CMP_GREATER_THEN\t0x4\t\t/* a > b.  */\n-#define PPC_CMP_LESS_THEN\t0x8\t\t/* a < b.  */\n \n       switch (code)\n \t{\n \tcase EQ:\n-\t  mask_value = PPC_CMP_EQUAL;\n-\t  code = NE;\n-\t  break;\n-\n \tcase NE:\n-\t  mask_value = PPC_CMP_EQUAL;\n-\t  code = EQ;\n+\t  libfunc = optab_libfunc (eq_optab, mode);\n \t  break;\n \n \tcase GT:\n-\t  mask_value = PPC_CMP_GREATER_THEN;\n-\t  code = NE;\n-\t  break;\n-\n \tcase GE:\n-\t  mask_value = PPC_CMP_GREATER_THEN | PPC_CMP_EQUAL;\n-\t  code = NE;\n+\t  libfunc = optab_libfunc (ge_optab, mode);\n \t  break;\n \n \tcase LT:\n-\t  mask_value = PPC_CMP_LESS_THEN;\n-\t  code = NE;\n-\t  break;\n-\n \tcase LE:\n-\t  mask_value = PPC_CMP_LESS_THEN | PPC_CMP_EQUAL;\n-\t  code = NE;\n-\t  break;\n-\n-\tcase UNLE:\n-\t  mask_value = PPC_CMP_GREATER_THEN;\n-\t  code = EQ;\n+\t  libfunc = optab_libfunc (le_optab, mode);\n \t  break;\n \n-\tcase UNLT:\n-\t  mask_value = PPC_CMP_GREATER_THEN | PPC_CMP_EQUAL;\n-\t  code = EQ;\n+\tcase UNORDERED:\n+\tcase ORDERED:\n+\t  libfunc = optab_libfunc (unord_optab, mode);\n+\t  code = (code == UNORDERED) ? NE : EQ;\n \t  break;\n \n \tcase UNGE:\n-\t  mask_value = PPC_CMP_LESS_THEN;\n-\t  code = EQ;\n+\tcase UNGT:\n+\t  libfunc = optab_libfunc (le_optab, mode);\n+\t  code = (code == UNGE) ? GE : GT;\n \t  break;\n \n-\tcase UNGT:\n-\t  mask_value = PPC_CMP_LESS_THEN | PPC_CMP_EQUAL;\n-\t  code = EQ;\n+\tcase UNLE:\n+\tcase UNLT:\n+\t  libfunc = optab_libfunc (ge_optab, mode);\n+\t  code = (code == UNLE) ? LE : LT;\n \t  break;\n \n \tcase UNEQ:\n-\t  mask_value = PPC_CMP_EQUAL | PPC_CMP_UNORDERED;\n-\t  code = NE;\n-\n \tcase LTGT:\n-\t  mask_value = PPC_CMP_EQUAL | PPC_CMP_UNORDERED;\n-\t  code = EQ;\n-\t  break;\n-\n-\tcase UNORDERED:\n-\t  mask_value = PPC_CMP_UNORDERED;\n-\t  code = NE;\n-\t  break;\n-\n-\tcase ORDERED:\n-\t  mask_value = PPC_CMP_UNORDERED;\n-\t  code = EQ;\n+\t  libfunc = optab_libfunc (le_optab, mode);\n+\t  uneq_or_ltgt = true;\n+\t  code = (code = UNEQ) ? NE : EQ;\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n-      gcc_assert (mask_value != 0);\n-      and_reg = emit_library_call_value (libfunc, and_reg, LCT_CONST, SImode, 2,\n-\t\t\t\t\t op0, mode, op1, mode);\n+      gcc_assert (libfunc);\n+      dest = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n+\t\t\t\t      SImode, 2, op0, mode, op1, mode);\n \n-      emit_insn (gen_andsi3 (dest, and_reg, GEN_INT (mask_value)));\n-      compare_result = gen_reg_rtx (CCmode);\n-      comp_mode = CCmode;\n+      /* If this is UNEQ or LTGT, we call __lekf2, which returns -1 for less\n+\t than, 0 for equal, +1 for greater, and +2 for nan.  We add 1, to give\n+\t a value of 0..3, and then do and AND immediate of 1 to isolate whether\n+\t it is 0/Nan (i.e. bottom bit is 0), or less than/greater than\n+\t (i.e. bottom bit is 1).  */\n+      if (uneq_or_ltgt)\n+\t{\n+\t  rtx add_result = gen_reg_rtx (SImode);\n+\t  rtx and_result = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_addsi3 (add_result, dest, GEN_INT (1)));\n+\t  emit_insn (gen_andsi3 (and_result, add_result, GEN_INT (1)));\n+\t  dest = and_result;\n+\t}\n \n       emit_insn (gen_rtx_SET (compare_result,\n \t\t\t      gen_rtx_COMPARE (comp_mode, dest, const0_rtx)));\n@@ -20706,24 +20677,29 @@ rs6000_invalid_binary_op (int op ATTRIBUTE_UNUSED,\n     mode2 = GET_MODE_INNER (mode2);\n \n   /* Don't allow IEEE 754R 128-bit binary floating point and IBM extended\n-     double to intermix.  */\n+     double to intermix unless -mfloat128-convert.  */\n   if (mode1 == mode2)\n     return NULL;\n \n-  if ((mode1 == KFmode && mode2 == IFmode)\n-      || (mode1 == IFmode && mode2 == KFmode))\n-    return N_(\"__float128 and __ibm128 cannot be used in the same expression\");\n+  if (!TARGET_FLOAT128_CVT)\n+    {\n+      if ((mode1 == KFmode && mode2 == IFmode)\n+\t  || (mode1 == IFmode && mode2 == KFmode))\n+\treturn N_(\"__float128 and __ibm128 cannot be used in the same \"\n+\t\t  \"expression\");\n \n-  if (TARGET_IEEEQUAD\n-      && ((mode1 == IFmode && mode2 == TFmode)\n-\t  || (mode1 == TFmode && mode2 == IFmode)))\n-    return N_(\"__ibm128 and long double cannot be used in the same expression\");\n+      if (TARGET_IEEEQUAD\n+\t  && ((mode1 == IFmode && mode2 == TFmode)\n+\t      || (mode1 == TFmode && mode2 == IFmode)))\n+\treturn N_(\"__ibm128 and long double cannot be used in the same \"\n+\t\t  \"expression\");\n \n-  if (!TARGET_IEEEQUAD\n-      && ((mode1 == KFmode && mode2 == TFmode)\n-\t  || (mode1 == TFmode && mode2 == KFmode)))\n-    return N_(\"__float128 and long double cannot be used in the same \"\n-\t      \"expression\");\n+      if (!TARGET_IEEEQUAD\n+\t  && ((mode1 == KFmode && mode2 == TFmode)\n+\t      || (mode1 == TFmode && mode2 == KFmode)))\n+\treturn N_(\"__float128 and long double cannot be used in the same \"\n+\t\t  \"expression\");\n+    }\n \n   return NULL;\n }"}, {"sha": "0b035ca8f918b0942a929e939c213c1553e0d6bf", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ec21a884b30c42083cb79da52db5257acb12fc5d", "patch": "@@ -13352,6 +13352,40 @@\n   \"xscvdpqp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")])\n \n+;; Conversion between KFmode and TFmode if TFmode is ieee 128-bit floating\n+;; point is a simple copy.\n+(define_insn_and_split \"extendkftf2\"\n+  [(set (match_operand:TF 0 \"vsx_register_operand\" \"=wa,?wa\")\n+\t(float_extend:TF (match_operand:KF 1 \"vsx_register_operand\" \"0,wa\")))]\n+  \"TARGET_FLOAT128 && TARGET_IEEEQUAD\"\n+  \"@\n+   #\n+   xxlor %x0,%x1,%x1\"\n+  \"&& reload_completed  && REGNO (operands[0]) == REGNO (operands[1])\"\n+  [(const_int 0)]\n+{\n+  emit_note (NOTE_INSN_DELETED);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"*,vecsimple\")\n+   (set_attr \"length\" \"0,4\")])\n+\n+(define_insn_and_split \"trunctfkf2\"\n+  [(set (match_operand:KF 0 \"vsx_register_operand\" \"=wa,?wa\")\n+\t(float_extend:KF (match_operand:TF 1 \"vsx_register_operand\" \"0,wa\")))]\n+  \"TARGET_FLOAT128 && TARGET_IEEEQUAD\"\n+  \"@\n+   #\n+   xxlor %x0,%x1,%x1\"\n+  \"&& reload_completed  && REGNO (operands[0]) == REGNO (operands[1])\"\n+  [(const_int 0)]\n+{\n+  emit_note (NOTE_INSN_DELETED);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"*,vecsimple\")\n+   (set_attr \"length\" \"0,4\")])\n+\n (define_insn \"trunc<mode>df2_hw\"\n   [(set (match_operand:DF 0 \"altivec_register_operand\" \"=v\")\n \t(float_truncate:DF\n@@ -13476,7 +13510,7 @@\n   \"xscv<su>dqp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")])\n \n-(define_insn \"*ieee128_mfvsrd\"\n+(define_insn \"*ieee128_mfvsrd_64bit\"\n   [(set (match_operand:DI 0 \"reg_or_indexed_operand\" \"=wr,Z,wi\")\n \t(unspec:DI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v,v\")]\n \t\t   UNSPEC_IEEE128_MOVE))]\n@@ -13487,6 +13521,17 @@\n    xxlor %x0,%x1,%x1\"\n   [(set_attr \"type\" \"mftgpr,vecsimple,fpstore\")])\n \n+\n+(define_insn \"*ieee128_mfvsrd_32bit\"\n+  [(set (match_operand:DI 0 \"reg_or_indexed_operand\" \"=Z,wi\")\n+\t(unspec:DI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v\")]\n+\t\t   UNSPEC_IEEE128_MOVE))]\n+  \"TARGET_FLOAT128_HW && !TARGET_POWERPC64\"\n+  \"@\n+   stxsdx %x1,%y0\n+   xxlor %x0,%x1,%x1\"\n+  [(set_attr \"type\" \"vecsimple,fpstore\")])\n+\n (define_insn \"*ieee128_mfvsrwz\"\n   [(set (match_operand:SI 0 \"reg_or_indexed_operand\" \"=r,Z\")\n \t(unspec:SI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v\")]\n@@ -13512,17 +13557,27 @@\n   [(set_attr \"type\" \"mffgpr,fpload,mffgpr,fpload\")])\n \n \n-(define_insn \"*ieee128_mtvsrd\"\n+(define_insn \"*ieee128_mtvsrd_64bit\"\n   [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v,v,v\")\n \t(unspec:V2DI [(match_operand:DI 1 \"nonimmediate_operand\" \"wr,Z,wi\")]\n \t\t     UNSPEC_IEEE128_MOVE))]\n-  \"TARGET_FLOAT128_HW\"\n+  \"TARGET_FLOAT128_HW && TARGET_POWERPC64\"\n   \"@\n    mtvsrd %x0,%1\n    lxsdx %x0,%y1\n    xxlor %x0,%x1,%x1\"\n   [(set_attr \"type\" \"mffgpr,fpload,vecsimple\")])\n \n+(define_insn \"*ieee128_mtvsrd_32bit\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v,v\")\n+\t(unspec:V2DI [(match_operand:DI 1 \"nonimmediate_operand\" \"Z,wi\")]\n+\t\t     UNSPEC_IEEE128_MOVE))]\n+  \"TARGET_FLOAT128_HW && !TARGET_POWERPC64\"\n+  \"@\n+   lxsdx %x0,%y1\n+   xxlor %x0,%x1,%x1\"\n+  [(set_attr \"type\" \"fpload,vecsimple\")])\n+\n ;; IEEE 128-bit instructions with round to odd semantics\n (define_insn \"*trunc<mode>df2_odd\"\n   [(set (match_operand:DF 0 \"vsx_register_operand\" \"=v\")"}, {"sha": "8064f23a39ccfadee4bf0ba291a073c64851c587", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=ec21a884b30c42083cb79da52db5257acb12fc5d", "patch": "@@ -632,3 +632,7 @@ Enable/disable IEEE 128-bit floating point via the __float128 keyword.\n mfloat128-hardware\n Target Report Mask(FLOAT128_HW) Var(rs6000_isa_flags)\n Enable/disable using IEEE 128-bit floating point instructions.\n+\n+mfloat128-convert\n+Target Undocumented Mask(FLOAT128_CVT) Var(rs6000_isa_flags)\n+Enable/disable default conversions between __float128 & long double."}, {"sha": "65b6a96f1d69a0b78a70c5d4b6ac2576094a96c9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=ec21a884b30c42083cb79da52db5257acb12fc5d", "patch": "@@ -954,22 +954,20 @@ typedef _Complex float __attribute__((mode(TC))) _Complex128;\n typedef _Complex float __attribute__((mode(XC))) _Complex80;\n @end smallexample\n \n-On PowerPC Linux, Freebsd and Darwin systems, the default for\n-@code{long double} is to use the IBM extended floating point format\n-that uses a pair of @code{double} values to extend the precision.\n-This means that the mode @code{TCmode} was already used by the\n-traditional IBM long double format, and you would need to use the mode\n-@code{KCmode}:\n+On PowerPC 64-bit Linux systems there are currently problems in using\n+the complex @code{__float128} type.  When these problems are fixed,\n+you would use:\n \n @smallexample\n typedef _Complex float __attribute__((mode(KC))) _Complex128;\n @end smallexample\n \n-Not all targets support additional floating-point types.  @code{__float80}\n-and @code{__float128} types are supported on x86 and IA-64 targets.\n-The @code{__float128} type is supported on hppa HP-UX.\n-The @code{__float128} type is supported on PowerPC systems by default\n-if the vector scalar instruction set (VSX) is enabled.\n+Not all targets support additional floating-point types.\n+@code{__float80} and @code{__float128} types are supported on x86 and\n+IA-64 targets.  The @code{__float128} type is supported on hppa HP-UX.\n+The @code{__float128} type is supported on PowerPC 64-bit Linux\n+systems by default if the vector scalar instruction set (VSX) is\n+enabled.\n \n On the PowerPC, @code{__ibm128} provides access to the IBM extended\n double format, and it is intended to be used by the library functions"}, {"sha": "b85f9b5942db9adba11939b93db6006687ae1c4c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec21a884b30c42083cb79da52db5257acb12fc5d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ec21a884b30c42083cb79da52db5257acb12fc5d", "patch": "@@ -19690,7 +19690,8 @@ hardware instructions.\n \n The VSX instruction set (@option{-mvsx}, @option{-mcpu=power7}, or\n @option{-mcpu=power8}) must be enabled to use the @option{-mfloat128}\n-option.\n+option.  The @code{-mfloat128} option only works on PowerPC 64-bit\n+Linux systems.\n \n @item -mfloat128-hardware\n @itemx -mno-float128-hardware"}]}