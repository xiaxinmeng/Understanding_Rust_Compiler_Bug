{"sha": "652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUyYzRjNzFhMWIxZjBjOTJiNmEwNjMwNWQ4MmMzNTRiNzJlMTZlMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-04-12T08:35:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-04-12T08:35:01Z"}, "message": "cfgloop.h (estimated_loop_iterations_int): Ditch 'conservative' parameter.\n\n2012-04-12  Richard Guenther  <rguenther@suse.de>\n\n\t* cfgloop.h (estimated_loop_iterations_int): Ditch\n\t'conservative' parameter.\n\t(max_stmt_executions_int): Likewise.\n\t(estimated_loop_iterations): Likewise.\n\t(max_stmt_executions): Likewise.\n\t(max_loop_iterations): Declare.\n\t(max_loop_iterations_int): Likewise.\n\t(estimated_stmt_executions): Likewise.\n\t(estimated_stmt_executions_int): Likewise.\n\t* tree-ssa-loop-niter.c (estimated_loop_iterations):\n\tSplit parts to ...\n\t(max_loop_iterations): ... this.\n\t(estimated_loop_iterations_int): Split parts to ...\n\t(max_loop_iterations_int): ... this.\n\t(max_stmt_executions_int): Split parts to ...\n\t(estimated_stmt_executions_int): ... this.\n\t(max_stmt_executions): Split parts to ...\n\t(estimated_stmt_executions): ... this.\n\t* graphite-sese-to-poly.c (build_loop_iteration_domains): Adjust.\n\t* predict.c (predict_loops): Likewise.\n\t* tree-data-ref.c (max_stmt_executions_tree): Likewise.\n\t(analyze_siv_subscript_cst_affine): Likewise.\n\t(compute_overlap_steps_for_affine_1_2): Likewise.\n\t(analyze_subscript_affine_affine): Likewise.\n\t(init_omega_for_ddr_1): Likewise.\n\t* tree-parloops.c (parallelize_loops): Likewise.\n\t* tree-ssa-loop-ivopts.c (avg_loop_niter): Likewise.\n\t(may_eliminate_iv): Likewise.\n\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Likewise.\n\t(loop_prefetch_arrays): Likewise.\n\t* tree-vrp.c (adjust_range_with_scev): Likewise.\n\nFrom-SVN: r186372", "tree": {"sha": "609890225d25b25313d4652ae56016555d5edca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/609890225d25b25313d4652ae56016555d5edca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c924efa4bd23c9a0668a8a34eada8446ff41021", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c924efa4bd23c9a0668a8a34eada8446ff41021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c924efa4bd23c9a0668a8a34eada8446ff41021"}], "stats": {"total": 195, "additions": 146, "deletions": 49}, "files": [{"sha": "d702e02d88670ca9e61d1980c3064a56dae61103", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -1,3 +1,37 @@\n+2012-04-12  Richard Guenther  <rguenther@suse.de>\n+\n+\t* cfgloop.h (estimated_loop_iterations_int): Ditch\n+\t'conservative' parameter.\n+\t(max_stmt_executions_int): Likewise.\n+\t(estimated_loop_iterations): Likewise.\n+\t(max_stmt_executions): Likewise.\n+\t(max_loop_iterations): Declare.\n+\t(max_loop_iterations_int): Likewise.\n+\t(estimated_stmt_executions): Likewise.\n+\t(estimated_stmt_executions_int): Likewise.\n+\t* tree-ssa-loop-niter.c (estimated_loop_iterations):\n+\tSplit parts to ...\n+\t(max_loop_iterations): ... this.\n+\t(estimated_loop_iterations_int): Split parts to ...\n+\t(max_loop_iterations_int): ... this.\n+\t(max_stmt_executions_int): Split parts to ...\n+\t(estimated_stmt_executions_int): ... this.\n+\t(max_stmt_executions): Split parts to ...\n+\t(estimated_stmt_executions): ... this.\n+\t* graphite-sese-to-poly.c (build_loop_iteration_domains): Adjust.\n+\t* predict.c (predict_loops): Likewise.\n+\t* tree-data-ref.c (max_stmt_executions_tree): Likewise.\n+\t(analyze_siv_subscript_cst_affine): Likewise.\n+\t(compute_overlap_steps_for_affine_1_2): Likewise.\n+\t(analyze_subscript_affine_affine): Likewise.\n+\t(init_omega_for_ddr_1): Likewise.\n+\t* tree-parloops.c (parallelize_loops): Likewise.\n+\t* tree-ssa-loop-ivopts.c (avg_loop_niter): Likewise.\n+\t(may_eliminate_iv): Likewise.\n+\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Likewise.\n+\t(loop_prefetch_arrays): Likewise.\n+\t* tree-vrp.c (adjust_range_with_scev): Likewise.\n+\n 2012-04-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.h (RETURN_ADDR_RTX): Use NULL_RTX instead of 0."}, {"sha": "82c8881fe582477f2a39c66fbf9bc59a03e414b6", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -279,10 +279,14 @@ extern unsigned expected_loop_iterations (const struct loop *);\n extern rtx doloop_condition_get (rtx);\n \n void estimate_numbers_of_iterations_loop (struct loop *, bool);\n-HOST_WIDE_INT estimated_loop_iterations_int (struct loop *, bool);\n-HOST_WIDE_INT max_stmt_executions_int (struct loop *, bool);\n-bool estimated_loop_iterations (struct loop *, bool, double_int *);\n-bool max_stmt_executions (struct loop *, bool, double_int *);\n+bool estimated_loop_iterations (struct loop *, double_int *);\n+bool max_loop_iterations (struct loop *, double_int *);\n+HOST_WIDE_INT estimated_loop_iterations_int (struct loop *);\n+HOST_WIDE_INT max_loop_iterations_int (struct loop *);\n+bool max_stmt_executions (struct loop *, double_int *);\n+bool estimated_stmt_executions (struct loop *, double_int *);\n+HOST_WIDE_INT max_stmt_executions_int (struct loop *);\n+HOST_WIDE_INT estimated_stmt_executions_int (struct loop *);\n \n /* Loop manipulation.  */\n extern bool can_duplicate_loop_p (const struct loop *loop);"}, {"sha": "4a2ca40ba134e66efbb2c12874be36489cf01bba", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -1092,7 +1092,7 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n       scan_tree_for_params (SCOP_REGION (scop), nb_iters, ub_expr, one);\n       mpz_clear (one);\n \n-      if (max_stmt_executions (loop, true, &nit))\n+      if (max_stmt_executions (loop, &nit))\n \tadd_upper_bounds_from_estimated_nit (scop, nit, dim, ub_expr);\n \n       /* loop_i <= expr_nb_iters */"}, {"sha": "8ed2e833cf78afa78133b392be1c934ceb0f1b03", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -994,7 +994,7 @@ predict_loops (void)\n \t     the loop, use it to predict this exit.  */\n \t  else if (n_exits == 1)\n \t    {\n-\t      nitercst = max_stmt_executions_int (loop, false);\n+\t      nitercst = estimated_stmt_executions_int (loop);\n \t      if (nitercst < 0)\n \t\tcontinue;\n \t      if (nitercst > max)"}, {"sha": "c4e78f3fe6e4905118775e97688bfbd8ac1cf125", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -1709,7 +1709,7 @@ max_stmt_executions_tree (struct loop *loop)\n {\n   double_int nit;\n \n-  if (!max_stmt_executions (loop, true, &nit))\n+  if (!max_stmt_executions (loop, &nit))\n     return chrec_dont_know;\n \n   if (!double_int_fits_to_tree_p (unsigned_type_node, nit))\n@@ -1791,7 +1791,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \n \t\t      /* Perform weak-zero siv test to see if overlap is\n \t\t\t outside the loop bounds.  */\n-\t\t      numiter = max_stmt_executions_int (loop, true);\n+\t\t      numiter = max_stmt_executions_int (loop);\n \n \t\t      if (numiter >= 0\n \t\t\t  && compare_tree_int (tmp, numiter) > 0)\n@@ -1869,7 +1869,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \n \t\t      /* Perform weak-zero siv test to see if overlap is\n \t\t\t outside the loop bounds.  */\n-\t\t      numiter = max_stmt_executions_int (loop, true);\n+\t\t      numiter = max_stmt_executions_int (loop);\n \n \t\t      if (numiter >= 0\n \t\t\t  && compare_tree_int (tmp, numiter) > 0)\n@@ -2049,10 +2049,9 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n   step_y = int_cst_value (CHREC_RIGHT (chrec_a));\n   step_z = int_cst_value (CHREC_RIGHT (chrec_b));\n \n-  niter_x =\n-    max_stmt_executions_int (get_chrec_loop (CHREC_LEFT (chrec_a)), true);\n-  niter_y = max_stmt_executions_int (get_chrec_loop (chrec_a), true);\n-  niter_z = max_stmt_executions_int (get_chrec_loop (chrec_b), true);\n+  niter_x = max_stmt_executions_int (get_chrec_loop (CHREC_LEFT (chrec_a)));\n+  niter_y = max_stmt_executions_int (get_chrec_loop (chrec_a));\n+  niter_z = max_stmt_executions_int (get_chrec_loop (chrec_b));\n \n   if (niter_x < 0 || niter_y < 0 || niter_z < 0)\n     {\n@@ -2377,8 +2376,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  HOST_WIDE_INT niter, niter_a, niter_b;\n \t  affine_fn ova, ovb;\n \n-\t  niter_a = max_stmt_executions_int (get_chrec_loop (chrec_a), true);\n-\t  niter_b = max_stmt_executions_int (get_chrec_loop (chrec_b), true);\n+\t  niter_a = max_stmt_executions_int (get_chrec_loop (chrec_a));\n+\t  niter_b = max_stmt_executions_int (get_chrec_loop (chrec_b));\n \t  niter = MIN (niter_a, niter_b);\n \t  step_a = int_cst_value (CHREC_RIGHT (chrec_a));\n \t  step_b = int_cst_value (CHREC_RIGHT (chrec_b));\n@@ -2485,10 +2484,10 @@ analyze_subscript_affine_affine (tree chrec_a,\n \n \t  if (i1 > 0 && j1 > 0)\n \t    {\n-\t      HOST_WIDE_INT niter_a = max_stmt_executions_int\n-\t\t(get_chrec_loop (chrec_a), true);\n-\t      HOST_WIDE_INT niter_b = max_stmt_executions_int\n-\t\t(get_chrec_loop (chrec_b), true);\n+\t      HOST_WIDE_INT niter_a\n+\t\t= max_stmt_executions_int (get_chrec_loop (chrec_a));\n+\t      HOST_WIDE_INT niter_b\n+\t\t= max_stmt_executions_int (get_chrec_loop (chrec_b));\n \t      HOST_WIDE_INT niter = MIN (niter_a, niter_b);\n \n \t      /* (X0, Y0) is a solution of the Diophantine equation:\n@@ -3782,7 +3781,7 @@ init_omega_for_ddr_1 (struct data_reference *dra, struct data_reference *drb,\n   for (i = 0; i <= DDR_INNER_LOOP (ddr)\n \t && VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), i, loopi); i++)\n     {\n-      HOST_WIDE_INT nbi = max_stmt_executions_int (loopi, true);\n+      HOST_WIDE_INT nbi = max_stmt_executions_int (loopi);\n \n       /* 0 <= loop_x */\n       ineq = omega_add_zero_geq (pb, omega_black);"}, {"sha": "a7f4f9026b782bcbf674fc5dfe6d440c9c93240e", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -2192,7 +2192,7 @@ parallelize_loops (void)\n \t     header-copied loops correctly - see PR46886.  */\n \t  || !do_while_loop_p (loop))\n \tcontinue;\n-      estimated = max_stmt_executions_int (loop, false);\n+      estimated = estimated_stmt_executions_int (loop);\n       /* FIXME: Bypass this check as graphite doesn't update the\n       count and frequency correctly now.  */\n       if (!flag_loop_parallelize_all"}, {"sha": "3c11c0e483455a0b9fc16122d0b5778a1de45d81", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -115,7 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n static inline HOST_WIDE_INT\n avg_loop_niter (struct loop *loop)\n {\n-  HOST_WIDE_INT niter = max_stmt_executions_int (loop, false);\n+  HOST_WIDE_INT niter = estimated_stmt_executions_int (loop);\n   if (niter == -1)\n     return AVG_LOOP_NITER (loop);\n \n@@ -4694,7 +4694,7 @@ may_eliminate_iv (struct ivopts_data *data,\n           /* See if we can take advantage of infered loop bound information.  */\n           if (data->loop_single_exit_p)\n             {\n-              if (!estimated_loop_iterations (loop, true, &max_niter))\n+              if (!max_loop_iterations (loop, &max_niter))\n                 return false;\n               /* The loop bound is already adjusted by adding 1.  */\n               if (double_int_ucmp (max_niter, period_value) > 0)"}, {"sha": "2529b367300e00a147c4ec8b430e08eb88f135f7", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 83, "deletions": 23, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -3052,25 +3052,28 @@ estimate_numbers_of_iterations_loop (struct loop *loop, bool use_undefined_p)\n    the function returns false, otherwise returns true.  */\n \n bool\n-estimated_loop_iterations (struct loop *loop, bool conservative,\n-\t\t\t   double_int *nit)\n+estimated_loop_iterations (struct loop *loop, double_int *nit)\n {\n   estimate_numbers_of_iterations_loop (loop, true);\n-  if (conservative)\n-    {\n-      if (!loop->any_upper_bound)\n-\treturn false;\n+  if (!loop->any_estimate)\n+    return false;\n \n-      *nit = loop->nb_iterations_upper_bound;\n-    }\n-  else\n-    {\n-      if (!loop->any_estimate)\n-\treturn false;\n+  *nit = loop->nb_iterations_estimate;\n+  return true;\n+}\n \n-      *nit = loop->nb_iterations_estimate;\n-    }\n+/* Sets NIT to an upper bound for the maximum number of executions of the\n+   latch of the LOOP.  If we have no reliable estimate, the function returns\n+   false, otherwise returns true.  */\n+\n+bool\n+max_loop_iterations (struct loop *loop, double_int *nit)\n+{\n+  estimate_numbers_of_iterations_loop (loop, true);\n+  if (!loop->any_upper_bound)\n+    return false;\n \n+  *nit = loop->nb_iterations_upper_bound;\n   return true;\n }\n \n@@ -3079,12 +3082,32 @@ estimated_loop_iterations (struct loop *loop, bool conservative,\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-estimated_loop_iterations_int (struct loop *loop, bool conservative)\n+estimated_loop_iterations_int (struct loop *loop)\n+{\n+  double_int nit;\n+  HOST_WIDE_INT hwi_nit;\n+\n+  if (!estimated_loop_iterations (loop, &nit))\n+    return -1;\n+\n+  if (!double_int_fits_in_shwi_p (nit))\n+    return -1;\n+  hwi_nit = double_int_to_shwi (nit);\n+\n+  return hwi_nit < 0 ? -1 : hwi_nit;\n+}\n+\n+/* Similar to max_loop_iterations, but returns the estimate only\n+   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n+   on the number of iterations of LOOP could not be derived, returns -1.  */\n+\n+HOST_WIDE_INT\n+max_loop_iterations_int (struct loop *loop)\n {\n   double_int nit;\n   HOST_WIDE_INT hwi_nit;\n \n-  if (!estimated_loop_iterations (loop, conservative, &nit))\n+  if (!max_loop_iterations (loop, &nit))\n     return -1;\n \n   if (!double_int_fits_in_shwi_p (nit))\n@@ -3099,9 +3122,9 @@ estimated_loop_iterations_int (struct loop *loop, bool conservative)\n    the number of execution of the latch by one.  */\n \n HOST_WIDE_INT\n-max_stmt_executions_int (struct loop *loop, bool conservative)\n+max_stmt_executions_int (struct loop *loop)\n {\n-  HOST_WIDE_INT nit = estimated_loop_iterations_int (loop, conservative);\n+  HOST_WIDE_INT nit = max_loop_iterations_int (loop);\n   HOST_WIDE_INT snit;\n \n   if (nit == -1)\n@@ -3113,17 +3136,54 @@ max_stmt_executions_int (struct loop *loop, bool conservative)\n   return snit < 0 ? -1 : snit;\n }\n \n+/* Returns an estimate for the number of executions of statements\n+   in the LOOP.  For statements before the loop exit, this exceeds\n+   the number of execution of the latch by one.  */\n+\n+HOST_WIDE_INT\n+estimated_stmt_executions_int (struct loop *loop)\n+{\n+  HOST_WIDE_INT nit = estimated_loop_iterations_int (loop);\n+  HOST_WIDE_INT snit;\n+\n+  if (nit == -1)\n+    return -1;\n+\n+  snit = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) nit + 1);\n+\n+  /* If the computation overflows, return -1.  */\n+  return snit < 0 ? -1 : snit;\n+}\n+\n+/* Sets NIT to the estimated maximum number of executions of the latch of the\n+   LOOP, plus one.  If we have no reliable estimate, the function returns\n+   false, otherwise returns true.  */\n+\n+bool\n+max_stmt_executions (struct loop *loop, double_int *nit)\n+{\n+  double_int nit_minus_one;\n+\n+  if (!max_loop_iterations (loop, nit))\n+    return false;\n+\n+  nit_minus_one = *nit;\n+\n+  *nit = double_int_add (*nit, double_int_one);\n+\n+  return double_int_ucmp (*nit, nit_minus_one) > 0;\n+}\n+\n /* Sets NIT to the estimated number of executions of the latch of the\n-   LOOP, plus one.  If CONSERVATIVE is true, we must be sure that NIT is at\n-   least as large as the number of iterations.  If we have no reliable\n-   estimate, the function returns false, otherwise returns true.  */\n+   LOOP, plus one.  If we have no reliable estimate, the function returns\n+   false, otherwise returns true.  */\n \n bool\n-max_stmt_executions (struct loop *loop, bool conservative, double_int *nit)\n+estimated_stmt_executions (struct loop *loop, double_int *nit)\n {\n   double_int nit_minus_one;\n \n-  if (!estimated_loop_iterations (loop, conservative, nit))\n+  if (!estimated_loop_iterations (loop, nit))\n     return false;\n \n   nit_minus_one = *nit;"}, {"sha": "eab1fff221842663ffdab667dbe7e1f57782e524", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -1548,7 +1548,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n \tcontinue;\n \n       aloop = VEC_index (loop_p, vloops, i);\n-      vol = max_stmt_executions_int (aloop, false);\n+      vol = estimated_stmt_executions_int (aloop);\n       if (vol < 0)\n \tvol = expected_loop_iterations (aloop);\n       volume *= vol;\n@@ -1800,7 +1800,7 @@ loop_prefetch_arrays (struct loop *loop)\n     return false;\n \n   ahead = (PREFETCH_LATENCY + time - 1) / time;\n-  est_niter = max_stmt_executions_int (loop, false);\n+  est_niter = estimated_stmt_executions_int (loop);\n \n   /* Prefetching is not likely to be profitable if the trip count to ahead\n      ratio is too small.  */"}, {"sha": "a53ceeb52b4cc57cf3540329b9dbc53766e6b1e0", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652c4c71a1b1f0c92b6a06305d82c354b72e16e0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=652c4c71a1b1f0c92b6a06305d82c354b72e16e0", "patch": "@@ -3420,7 +3420,7 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop,\n     {\n       double_int nit;\n \n-      if (estimated_loop_iterations (loop, true, &nit))\n+      if (max_loop_iterations (loop, &nit))\n \t{\n \t  value_range_t maxvr = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n \t  double_int dtmp;"}]}