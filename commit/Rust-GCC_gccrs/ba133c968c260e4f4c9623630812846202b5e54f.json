{"sha": "ba133c968c260e4f4c9623630812846202b5e54f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmExMzNjOTY4YzI2MGU0ZjRjOTYyMzYzMDgxMjg0NjIwMmI1ZTU0Zg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-15T07:57:13Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-15T07:57:13Z"}, "message": "cpp.texi: Update documentation for -include and -imacros.\n\n\t* cpp.texi: Update documentation for -include and -imacros.\n\t* cppfiles.c (struct include_file): Remove \"defined\" memeber.\n\t(find_or_create_entry): Make a copy of the file name, and\n\tsimplify it.\n\t(open_file): Update to ensure we use the simplified filename.\n\t(stack_include_file): Don't set search_from.\n\t(cpp_included): Don't simplify the path name here.\n\t(find_include_file): New prototype.  Call search_from to\n\tget the start of the \"\" include chain.  Don't simplify the\n\tfilenames here.\n\t(_cpp_execute_include): New prototype.  Move diagnostics to\n\tdo_include_common.  Update.\n\t(_cpp_pop_file_buffer): Don't set defined.\n\t(search_from): New prototype.  Use the preprocessor's cwd\n\tfor files included from the command line.\n\t(read_name_map): Don't simplify the pathname here.\n\t* cpphash.h (enum include_type): New.\n\t(struct buffer): Delete search from.  New search_cached.\n\t(_cpp_execute_include): Update prototype.\n\t* cppinit.c (do_includes): Use _cpp_execute_include.\n\t* cpplib.c (do_include_common): New function.\n\t(do_include, do_include_next, do_import): Use it.\n\nFrom-SVN: r40486", "tree": {"sha": "8a4a56e335e3fea702888b8f8de7fa5ee14ec72e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4a56e335e3fea702888b8f8de7fa5ee14ec72e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba133c968c260e4f4c9623630812846202b5e54f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba133c968c260e4f4c9623630812846202b5e54f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba133c968c260e4f4c9623630812846202b5e54f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba133c968c260e4f4c9623630812846202b5e54f/comments", "author": null, "committer": null, "parents": [{"sha": "a3eab6194fe9c17e2609882621404955cb03c662", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3eab6194fe9c17e2609882621404955cb03c662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3eab6194fe9c17e2609882621404955cb03c662"}], "stats": {"total": 276, "additions": 170, "deletions": 106}, "files": [{"sha": "3161f0a9224d7de9d13ad656038769617536a800", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba133c968c260e4f4c9623630812846202b5e54f", "patch": "@@ -1,3 +1,28 @@\n+2001-03-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpp.texi: Update documentation for -include and -imacros.\n+\t* cppfiles.c (struct include_file): Remove \"defined\" memeber.\n+\t(find_or_create_entry): Make a copy of the file name, and\n+\tsimplify it.\n+\t(open_file): Update to ensure we use the simplified filename.\n+\t(stack_include_file): Don't set search_from.\n+\t(cpp_included): Don't simplify the path name here.\n+\t(find_include_file): New prototype.  Call search_from to\n+\tget the start of the \"\" include chain.  Don't simplify the\n+\tfilenames here.\n+\t(_cpp_execute_include): New prototype.  Move diagnostics to\n+\tdo_include_common.  Update.\n+\t(_cpp_pop_file_buffer): Don't set defined.\n+\t(search_from): New prototype.  Use the preprocessor's cwd\n+\tfor files included from the command line.\n+\t(read_name_map): Don't simplify the pathname here.\n+\t* cpphash.h (enum include_type): New.\n+\t(struct buffer): Delete search from.  New search_cached.\n+\t(_cpp_execute_include): Update prototype.\n+\t* cppinit.c (do_includes): Use _cpp_execute_include.\n+\t* cpplib.c (do_include_common): New function.\n+\t(do_include, do_include_next, do_import): Use it.\n+\n 2001-03-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* varasm.c (assemble_alias): Use DECL_ASSEMBLER_NAME, not the"}, {"sha": "316ebbff7bd53c01a60aa01c9ce269104ae15dd6", "filename": "gcc/cpp.texi", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=ba133c968c260e4f4c9623630812846202b5e54f", "patch": "@@ -3596,16 +3596,31 @@ activities.\n \n @item -imacros @var{file}\n @findex -imacros\n-Process @var{file} as input, discarding the resulting output, before\n-processing the regular input file.  Because the output generated from\n-@var{file} is discarded, the only effect of @samp{-imacros @var{file}}\n-is to make the macros defined in @var{file} available for use in the\n-main input.\n+Process @var{file} as input and discard the resulting output.\n+\n+This has all the effects of @code{#include \"file\"} appearing on the\n+first line of the main source file, such as generating dependencies and\n+being listed with the @samp{-H} option, except that no output is\n+generated, and that the first directory searched for @var{file} is the\n+preprocessor's working directory @emph{instead of} the directory\n+containing the main source file.  If not found there, it is searched for\n+in the remainder of the @code{#include \"...\"} search chain as normal.\n+\n+Because the output is discarded, the main effect of @samp{-imacros\n+@var{file}} is to make the macros defined in @var{file} available for\n+use in the main input.\n \n @item -include @var{file}\n @findex -include\n-Process @var{file} as input, and include all the resulting output,\n-before processing the regular input file.  \n+Process @var{file} as input, and include all the resulting output.\n+\n+This has all the effects of @code{#include \"file\"} appearing on the\n+first line of the main source file, such as generating dependencies and\n+being listed with the @samp{-H} option, except that the first directory\n+searched for @var{file} is the preprocessor's working directory\n+@emph{instead of} the directory containing the main source file.  If not\n+found there, it is searched for in the remainder of the @code{#include\n+\"...\"}  search chain as normal.\n \n @item -idirafter @var{dir}\n @findex -idirafter"}, {"sha": "434d3e44babc294633f93315dcc65cb30e7fc98b", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 72, "deletions": 73, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=ba133c968c260e4f4c9623630812846202b5e54f", "patch": "@@ -70,18 +70,16 @@ struct include_file\n   unsigned short include_count;\t/* number of times file has been read */\n   unsigned short refcnt;\t/* number of stacked buffers using this file */\n   unsigned char mapped;\t\t/* file buffer is mmapped */\n-  unsigned char defined;\t/* cmacro prevents inclusion in this state */\n };\n \n /* The cmacro works like this: If it's NULL, the file is to be\n    included again.  If it's NEVER_REREAD, the file is never to be\n    included again.  Otherwise it is a macro hashnode, and the file is\n-   to be included again if the macro is defined or not as specified by\n-   DEFINED.  */\n+   to be included again if the macro is defined.  */\n #define NEVER_REREAD ((const cpp_hashnode *)-1)\n #define DO_NOT_REREAD(inc) \\\n ((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n-\t\t   || ((inc)->cmacro->type == NT_MACRO) == (inc)->defined))\n+\t\t   || (inc)->cmacro->type == NT_MACRO))\n #define NO_INCLUDE_PATH ((struct include_file *) -1)\n \n static struct file_name_map *read_name_map\n@@ -90,9 +88,10 @@ static char *read_filename_string PARAMS ((int, FILE *));\n static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n \t\t\t\t\t struct search_path *));\n static struct search_path *search_from PARAMS ((cpp_reader *,\n-\t\t\t\t\t\tstruct include_file *));\n+\t\t\t\t\t\tenum include_type));\n static struct include_file *\n-\tfind_include_file PARAMS ((cpp_reader *, const cpp_token *, int));\n+\tfind_include_file PARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t   enum include_type));\n static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n static void read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n@@ -155,20 +154,25 @@ _cpp_never_reread (file)\n   file->cmacro = NEVER_REREAD;\n }\n \n-/* Lookup a simplified filename, and create an entry if none exists.  */\n+/* Lookup a filename, which is simplified after making a copy, and\n+   create an entry if none exists.  */\n static splay_tree_node\n find_or_create_entry (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n   splay_tree_node node;\n   struct include_file *file;\n+  char *name = xstrdup (fname);\n \n-  node = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) fname);\n-  if (! node)\n+  _cpp_simplify_pathname (name);\n+  node = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) name);\n+  if (node)\n+    free (name);\n+  else\n     {\n       file = xcnew (struct include_file);\n-      file->name = xstrdup (fname);\n+      file->name = name;\n       node = splay_tree_insert (pfile->all_include_files,\n \t\t\t\t(splay_tree_key) file->name,\n \t\t\t\t(splay_tree_value) file);\n@@ -177,8 +181,7 @@ find_or_create_entry (pfile, fname)\n   return node;\n }\n \n-/* Enter a simplified file name in the splay tree, for the sake of\n-   cpp_included ().  */\n+/* Enter a file name in the splay tree, for the sake of cpp_included.  */\n void\n _cpp_fake_include (pfile, fname)\n      cpp_reader *pfile;\n@@ -234,7 +237,7 @@ open_file (pfile, filename)\n   if (filename[0] == '\\0')\n     file->fd = 0;\n   else\n-    file->fd = open (filename, O_RDONLY | O_NOCTTY | O_BINARY, 0666);\n+    file->fd = open (file->name, O_RDONLY | O_NOCTTY | O_BINARY, 0666);\n \n   if (file->fd != -1 && fstat (file->fd, &file->st) == 0)\n     {\n@@ -251,7 +254,7 @@ open_file (pfile, filename)\n \n   /* Don't issue an error message if the file doesn't exist.  */\n   if (errno != ENOENT && errno != ENOTDIR)\n-    cpp_error_from_errno (pfile, filename);\n+    cpp_error_from_errno (pfile, file->name);\n \n   /* Create a negative node for this path, and return null.  */\n   file->fd = -2;\n@@ -308,7 +311,6 @@ stack_include_file (pfile, inc)\n   fp->inc = inc;\n   fp->inc->refcnt++;\n   fp->sysp = sysp;\n-  fp->search_from = search_from (pfile, inc);\n \n   /* Initialise controlling macro state.  */\n   pfile->mi_state = MI_OUTSIDE;\n@@ -487,7 +489,7 @@ cpp_included (pfile, fname)\n       if (CPP_OPTION (pfile, remap))\n \tn = remap_filename (pfile, name, path);\n       else\n-\tn = _cpp_simplify_pathname (name);\n+\tn = name;\n \n       nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) n);\n       if (nd && nd->value)\n@@ -503,10 +505,10 @@ cpp_included (pfile, fname)\n    from a #include_next directive, set INCLUDE_NEXT to true.  */\n \n static struct include_file *\n-find_include_file (pfile, header, include_next)\n+find_include_file (pfile, header, type)\n      cpp_reader *pfile;\n      const cpp_token *header;\n-     int include_next;\n+     enum include_type type;\n {\n   const char *fname = (const char *) header->val.str.text;\n   struct search_path *path;\n@@ -519,12 +521,12 @@ find_include_file (pfile, header, include_next)\n   /* For #include_next, skip in the search path past the dir in which\n      the current file was found, but if it was found via an absolute\n      path use the normal search logic.  */\n-  if (include_next && pfile->buffer->inc->foundhere)\n+  if (type == IT_INCLUDE_NEXT && pfile->buffer->inc->foundhere)\n     path = pfile->buffer->inc->foundhere->next;\n   else if (header->type == CPP_HEADER_NAME)\n     path = CPP_OPTION (pfile, bracket_include);\n   else\n-    path = pfile->buffer->search_from;\n+    path = search_from (pfile, type);\n \n   if (path == NULL)\n     {\n@@ -542,7 +544,7 @@ find_include_file (pfile, header, include_next)\n       if (CPP_OPTION (pfile, remap))\n \tn = remap_filename (pfile, name, path);\n       else\n-\tn = _cpp_simplify_pathname (name);\n+\tn = name;\n \n       file = open_file (pfile, n);\n       if (file)\n@@ -653,30 +655,14 @@ handle_missing_header (pfile, fname, angle_brackets)\n     cpp_error_from_errno (pfile, fname);\n }\n \n-void\n-_cpp_execute_include (pfile, header, no_reinclude, include_next)\n+/* Returns non-zero if a buffer was stacked.  */\n+int\n+_cpp_execute_include (pfile, header, type)\n      cpp_reader *pfile;\n      const cpp_token *header;\n-     int no_reinclude;\n-     int include_next;\n+     enum include_type type;\n {\n-  struct include_file *inc;\n-\n-  /* Help protect #include or similar from recursion.  */\n-  if (pfile->buffer_stack_depth >= CPP_STACK_MAX)\n-    {\n-      cpp_fatal (pfile, \"#include nested too deeply\");\n-      return;\n-    }\n-\n-  /* Check we've tidied up #include before entering the buffer.  */\n-  if (pfile->context->prev)\n-    {\n-      cpp_ice (pfile, \"attempt to push file buffer with contexts stacked\");\n-      return;\n-    }\n-\n-  inc = find_include_file (pfile, header, include_next);\n+  struct include_file *inc = find_include_file (pfile, header, type);\n \n   if (inc == 0)\n     handle_missing_header (pfile, (const char *) header->val.str.text,\n@@ -688,9 +674,13 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n \n       stack_include_file (pfile, inc);\n \n-      if (no_reinclude)\n+      if (type == IT_IMPORT)\n \t_cpp_never_reread (inc);\n+\n+      return 1;\n     }\n+\n+  return 0;\n }\n \n /* Locate HEADER, and determine whether it is newer than the current\n@@ -749,13 +739,10 @@ _cpp_pop_file_buffer (pfile, buf)\n   if (pfile->include_depth)\n     pfile->include_depth--;\n \n-  /* Record the inclusion-preventing macro and its definedness.  */\n+  /* Record the inclusion-preventing macro, which could be NULL\n+     meaning no controlling macro, if we haven't got it already.  */\n   if (pfile->mi_state == MI_OUTSIDE && inc->cmacro == NULL)\n-    {\n-      /* This could be NULL meaning no controlling macro.  */\n-      inc->cmacro = pfile->mi_cmacro;\n-      inc->defined = 1;\n-    }\n+    inc->cmacro = pfile->mi_cmacro;\n \n   /* Invalidate control macros in the #including file.  */\n   pfile->mi_state = MI_FAILED;\n@@ -767,41 +754,55 @@ _cpp_pop_file_buffer (pfile, buf)\n \n /* Returns the first place in the include chain to start searching for\n    \"\" includes.  This involves stripping away the basename of the\n-   current file, unless -I- was specified.  */\n+   current file, unless -I- was specified.\n+\n+   If we're handling -include or -imacros, use the \"\" chain, but with\n+   the preprocessor's cwd prepended.  */\n static struct search_path *\n-search_from (pfile, inc)\n+search_from (pfile, type)\n      cpp_reader *pfile;\n-     struct include_file *inc;\n+     enum include_type type;\n {\n   cpp_buffer *buffer = pfile->buffer;\n   unsigned int dlen;\n \n+  /* Command line uses the cwd, and does not cache the result.  */\n+  if (type == IT_CMDLINE)\n+    goto use_cwd;\n+\n   /* Ignore the current file's directory if -I- was given.  */\n   if (CPP_OPTION (pfile, ignore_srcdir))\n     return CPP_OPTION (pfile, quote_include);\n \n-  dlen = lbasename (inc->name) - inc->name;\n-  if (dlen)\n-    {\n-      /* We don't guarantee NAME is null-terminated.  This saves\n-\t allocating and freeing memory, and duplicating it when faking\n-\t buffers in cpp_push_buffer.  Drop a trailing '/'.  */\n-      buffer->dir.name = inc->name;\n-      if (dlen > 1)\n-\tdlen--;\n-    }\n-  else\n+  if (! buffer->search_cached)\n     {\n-      buffer->dir.name = \".\";\n-      dlen = 1;\n-    }\n+      buffer->search_cached = 1;\n \n-  if (dlen > pfile->max_include_len)\n-    pfile->max_include_len = dlen;\n+      dlen = lbasename (buffer->inc->name) - buffer->inc->name;\n \n-  buffer->dir.len = dlen;\n-  buffer->dir.next = CPP_OPTION (pfile, quote_include);\n-  buffer->dir.sysp = buffer->sysp;\n+      if (dlen)\n+\t{\n+\t  /* We don't guarantee NAME is null-terminated.  This saves\n+\t     allocating and freeing memory, and duplicating it when faking\n+\t     buffers in cpp_push_buffer.  Drop a trailing '/'.  */\n+\t  buffer->dir.name = buffer->inc->name;\n+\t  if (dlen > 1)\n+\t    dlen--;\n+\t}\n+      else\n+\t{\n+\tuse_cwd:\n+\t  buffer->dir.name = \".\";\n+\t  dlen = 1;\n+\t}\n+\n+      if (dlen > pfile->max_include_len)\n+\tpfile->max_include_len = dlen;\n+\n+      buffer->dir.len = dlen;\n+      buffer->dir.next = CPP_OPTION (pfile, quote_include);\n+      buffer->dir.sysp = buffer->sysp;\n+    }\n \n   return &buffer->dir;\n }\n@@ -928,8 +929,6 @@ read_name_map (pfile, dirname)\n \t      strcpy (ptr->map_to + dirlen + 1, to);\n \t      free (to);\n \t    }\t      \n-\t  /* Simplify the result now.  */\n-\t  _cpp_simplify_pathname (ptr->map_to);\n \n \t  ptr->map_next = map_list_ptr->map_list_map;\n \t  map_list_ptr->map_list_map = ptr;"}, {"sha": "9cac65d64c8ab877602ff9b50ca51c7aab8fb179", "filename": "gcc/cpphash.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=ba133c968c260e4f4c9623630812846202b5e54f", "patch": "@@ -96,6 +96,9 @@ struct search_path\n enum mi_state {MI_FAILED = 0, MI_OUTSIDE};\n enum mi_ind {MI_IND_NONE = 0, MI_IND_NOT};\n \n+/* #include types.  */\n+enum include_type {IT_INCLUDE, IT_INCLUDE_NEXT, IT_IMPORT, IT_CMDLINE};\n+\n typedef struct toklist toklist;\n struct toklist\n {\n@@ -222,17 +225,16 @@ struct cpp_buffer\n      containing files that matches the current status.  */\n   unsigned char include_stack_listed;\n \n+  /* Nonzero means that the directory to start searching for \"\"\n+     include files has been calculated and stored in \"dir\" below.  */\n+  unsigned char search_cached;\n+\n   /* Buffer type.  */\n   ENUM_BITFIELD (cpp_buffer_type) type : 8;\n \n   /* The directory of the this buffer's file.  Its NAME member is not\n      allocated, so we don't need to worry about freeing it.  */\n   struct search_path dir;\n-\n-  /* The directory to start searching for \"\" include files.  Is either\n-     \"dir\" above, or options.quote_include, depending upon whether -I-\n-     was on the command line.  */\n-  struct search_path *search_from;\n };\n \n /* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n@@ -411,8 +413,9 @@ extern void _cpp_fake_include\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_never_reread\t\tPARAMS ((struct include_file *));\n extern char *_cpp_simplify_pathname\tPARAMS ((char *));\n extern int _cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n-extern void _cpp_execute_include\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const cpp_token *, int, int));\n+extern int _cpp_execute_include\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const cpp_token *,\n+\t\t\t\t\t\t enum include_type));\n extern int _cpp_compare_file_date       PARAMS ((cpp_reader *,\n \t\t\t\t\t\t const cpp_token *));\n extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));"}, {"sha": "13a0e645b92531940aedd93571c10e3a5968ad1c", "filename": "gcc/cppinit.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=ba133c968c260e4f4c9623630812846202b5e54f", "patch": "@@ -885,8 +885,15 @@ do_includes (pfile, p, scan)\n \t use the #include \"\" search path if cpp_read_file fails.  */\n       if (CPP_OPTION (pfile, preprocessed))\n \tcpp_error (pfile, \"-include and -imacros cannot be used with -fpreprocessed\");\n-      else if (_cpp_read_file (pfile, p->arg) && scan)\n-\tcpp_scan_buffer_nooutput (pfile, 0);\n+      else\n+\t{\n+\t  cpp_token header;\n+\t  header.type = CPP_STRING;\n+\t  header.val.str.text = (const unsigned char *) p->arg;\n+\t  header.val.str.len = strlen (p->arg);\n+\t  if (_cpp_execute_include (pfile, &header, IT_CMDLINE) && scan)\n+\t    cpp_scan_buffer_nooutput (pfile, 0);\n+\t}\n       q = p->next;\n       free (p);\n       p = q;"}, {"sha": "00fb1483cc0e7e02a1b45bed35e86be75e4e9c61", "filename": "gcc/cpplib.c", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba133c968c260e4f4c9623630812846202b5e54f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ba133c968c260e4f4c9623630812846202b5e54f", "patch": "@@ -95,6 +95,7 @@ static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n static cpp_hashnode *lex_macro_node\tPARAMS ((cpp_reader *));\n+static void do_include_common\tPARAMS ((cpp_reader *, enum include_type));\n static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n@@ -585,48 +586,62 @@ parse_include (pfile, header)\n   return 0;\n }\n \n+/* Handle #include, #include_next and #import.  */\n static void\n-do_include (pfile)\n+do_include_common (pfile, type)\n      cpp_reader *pfile;\n+     enum include_type type;\n {\n   cpp_token header;\n \n   if (!parse_include (pfile, &header))\n-    _cpp_execute_include (pfile, &header, 0, 0);\n+    {\n+      /* Prevent #include recursion.  */\n+      if (pfile->buffer_stack_depth >= CPP_STACK_MAX)\n+\tcpp_fatal (pfile, \"#include nested too deeply\");\n+      else if (pfile->context->prev)\n+\tcpp_ice (pfile, \"attempt to push file buffer with contexts stacked\");\n+      else\n+\t{\n+\t  /* For #include_next, if this is the primary source file,\n+\t     warn and use the normal search logic.  */\n+\t  if (type == IT_INCLUDE_NEXT && ! pfile->buffer->prev)\n+\t    {\n+\t      cpp_warning (pfile, \"#include_next in primary source file\");\n+\t      type = IT_INCLUDE;\n+\t    }\n+\n+\t  _cpp_execute_include (pfile, &header, type);\n+\t}\n+    }\n }\n \n static void\n-do_import (pfile)\n+do_include (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_token header;\n+  do_include_common (pfile, IT_INCLUDE);\n+}\n \n+static void\n+do_import (pfile)\n+     cpp_reader *pfile;\n+{\n   if (!pfile->import_warning && CPP_OPTION (pfile, warn_import))\n     {\n       pfile->import_warning = 1;\n       cpp_warning (pfile,\n \t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n-  if (!parse_include (pfile, &header))\n-    _cpp_execute_include (pfile, &header, 1, 0);\n+  do_include_common (pfile, IT_IMPORT);\n }\n \n static void\n do_include_next (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_token header;\n-\n-  if (!parse_include (pfile, &header))\n-    {\n-      /* If this is the primary source file, warn and use the normal\n-\t search logic.  */\n-      if (! pfile->buffer->prev)\n-\tcpp_warning (pfile, \"#include_next in primary source file\");\n-\n-      _cpp_execute_include (pfile, &header, 0, pfile->buffer->prev != 0);\n-    }\n+  do_include_common (pfile, IT_INCLUDE_NEXT);\n }\n \n /* Subroutine of do_line.  Read possible flags after file name.  LAST"}]}