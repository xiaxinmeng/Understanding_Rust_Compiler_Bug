{"sha": "e16acfcd1431d5448b7e958ab72f783e1f0f1263", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE2YWNmY2QxNDMxZDU0NDhiN2U5NThhYjcyZjc4M2UxZjBmMTI2Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-03T10:27:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-03T10:27:51Z"}, "message": "params.c (set_param_value): Use gcc_assert & gcc_unreachable.\n\n\t* params.c (set_param_value): Use gcc_assert & gcc_unreachable.\n\t* passes.c (open_dump_file, rest_of_handle_final): Likewise.\n\t* postreload-gcse.c (expr_equiv_p, oprs_unchanged_p,\n\thash_scan_set, reg_set_between_after_reload_p,\n\treg_used_between_after_reload_p, get_avail_load_store_reg,\n\teliminate_partially_redundant_load): Likewise.\n\t* postreload.c (reload_cse_simplify_set,\n\treload_combine_note_use): Likewise.\n\t* predict.c (predict_insn, expected_value_to_br_prob,\n\tpropagate_freq, expensive_function_p): Likewise.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* profile.c (instrument_edges, instrument_values,\n\tcompute_branch_probabilities, branch_prob, union_groups,\n\ttree_register_profile_hooks, rtl_register_profile_hooks): Likewise.\n\t* protoize.c (in_system_include_dir, file_could_be_converted,\n\tfile_normally_convertible, gen_aux_info_file, seek_to_line,\n\tdo_cleaning): Likewise.\n\t* tree-ssa-alias.c (collect_points_to_info_r): Likewise.\n\t* tree-ssa-ccp.c (execute_fold_all_builtins): Likewise.\n\t* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.\n\nFrom-SVN: r97485", "tree": {"sha": "42e511f518e210b0b0c5e1e5363178088482aec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42e511f518e210b0b0c5e1e5363178088482aec3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e16acfcd1431d5448b7e958ab72f783e1f0f1263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16acfcd1431d5448b7e958ab72f783e1f0f1263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e16acfcd1431d5448b7e958ab72f783e1f0f1263", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16acfcd1431d5448b7e958ab72f783e1f0f1263/comments", "author": null, "committer": null, "parents": [{"sha": "f73d56667d8c9b6344e930bac2928a7cca46ab4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f73d56667d8c9b6344e930bac2928a7cca46ab4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f73d56667d8c9b6344e930bac2928a7cca46ab4c"}], "stats": {"total": 184, "additions": 88, "deletions": 96}, "files": [{"sha": "0ed910677f9386307386e17b51417f654996b6d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -1,3 +1,26 @@\n+2005-04-03  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* params.c (set_param_value): Use gcc_assert & gcc_unreachable.\n+\t* passes.c (open_dump_file, rest_of_handle_final): Likewise.\n+\t* postreload-gcse.c (expr_equiv_p, oprs_unchanged_p,\n+\thash_scan_set, reg_set_between_after_reload_p,\n+\treg_used_between_after_reload_p, get_avail_load_store_reg,\n+\teliminate_partially_redundant_load): Likewise.\n+\t* postreload.c (reload_cse_simplify_set,\n+\treload_combine_note_use): Likewise.\n+\t* predict.c (predict_insn, expected_value_to_br_prob,\n+\tpropagate_freq, expensive_function_p): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* profile.c (instrument_edges, instrument_values,\n+\tcompute_branch_probabilities, branch_prob, union_groups,\n+\ttree_register_profile_hooks, rtl_register_profile_hooks): Likewise.\n+\t* protoize.c (in_system_include_dir, file_could_be_converted,\n+\tfile_normally_convertible, gen_aux_info_file, seek_to_line,\n+\tdo_cleaning): Likewise.\n+\t* tree-ssa-alias.c (collect_points_to_info_r): Likewise.\n+\t* tree-ssa-ccp.c (execute_fold_all_builtins): Likewise.\n+\t* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.\n+\n 2005-04-03 Mostafa Hagog <mustafa@il.ibm.com>\n \n \t* cfg.c (clear_bb_flags): Don't clear BB_DISABLE_SCHEDULE."}, {"sha": "965c7cccff7a926c51a21d82e421f89a565b72a1", "filename": "gcc/params.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -61,8 +61,7 @@ set_param_value (const char *name, int value)\n   size_t i;\n \n   /* Make sure nobody tries to set a parameter to an invalid value.  */\n-  if (value == INVALID_PARAM_VAL)\n-    abort ();\n+  gcc_assert (value != INVALID_PARAM_VAL);\n \n   /* Scan the parameter table to find a matching entry.  */\n   for (i = 0; i < num_compiler_params; ++i)"}, {"sha": "a34c97553daabd20e58936429802143a4beeaf5d", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -120,8 +120,7 @@ open_dump_file (enum tree_dump_index index, tree decl)\n \n   timevar_push (TV_DUMP);\n \n-  if (dump_file != NULL || dump_file_name != NULL)\n-    abort ();\n+  gcc_assert (!dump_file && !dump_file_name);\n \n   dump_file_name = get_dump_file_name (index);\n   initializing_dump = !dump_initialized_p (index);\n@@ -285,11 +284,9 @@ rest_of_handle_final (void)\n        different from the DECL_NAME name used in the source file.  */\n \n     x = DECL_RTL (current_function_decl);\n-    if (!MEM_P (x))\n-      abort ();\n+    gcc_assert (MEM_P (x));\n     x = XEXP (x, 0);\n-    if (GET_CODE (x) != SYMBOL_REF)\n-      abort ();\n+    gcc_assert (GET_CODE (x) == SYMBOL_REF);\n     fnname = XSTR (x, 0);\n \n     assemble_start_function (current_function_decl, fnname);"}, {"sha": "79b11eebf614d964e02294d946fc98c565880f52", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -309,9 +309,8 @@ expr_equiv_p (const void *exp1p, const void *exp2p)\n   struct expr *exp1 = (struct expr *) exp1p;\n   struct expr *exp2 = (struct expr *) exp2p;\n   int equiv_p = exp_equiv_p (exp1->expr, exp2->expr, 0, true);\n-  if (equiv_p\n-      && exp1->hash != exp2->hash)\n-    abort ();\n+  \n+  gcc_assert (!equiv_p || exp1->hash == exp2->hash);\n   return equiv_p;\n }\n \f\n@@ -489,11 +488,8 @@ oprs_unchanged_p (rtx x, rtx insn, bool after_insn)\n   switch (code)\n     {\n     case REG:\n-#ifdef ENABLE_CHECKING\n       /* We are called after register allocation.  */\n-      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-\tabort ();\n-#endif\n+      gcc_assert (REGNO (x) < FIRST_PSEUDO_REGISTER);\n       if (after_insn)\n \t/* If the last CUID setting the insn is less than the CUID of\n \t   INSN, then reg X is not changed in or after INSN.  */\n@@ -741,11 +737,8 @@ hash_scan_set (rtx insn)\n   if (JUMP_P (insn) || set_noop_p (pat))\n     return;\n \n-#ifdef ENABLE_CHEKCING\n   /* We shouldn't have any EH_REGION notes post reload.  */\n-  if (find_reg_note (insn, REG_EH_REGION, NULL_RTX))\n-    abort ();\n-#endif\n+  gcc_assert (!find_reg_note (insn, REG_EH_REGION, NULL_RTX));\n \n   if (REG_P (dest))\n     {\n@@ -856,11 +849,8 @@ reg_set_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n {\n   rtx insn;\n \n-#ifdef ENABLE_CHECKING\n   /* We are called after register allocation.  */\n-  if (!REG_P (reg) || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n-#endif\n+  gcc_assert (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER);\n \n   if (from_insn == to_insn)\n     return NULL_RTX;\n@@ -893,11 +883,8 @@ reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n {\n   rtx insn;\n \n-#ifdef ENABLE_CHECKING\n   /* We are called after register allocation.  */\n-  if (!REG_P (reg) || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n-#endif\n+  gcc_assert (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER);\n \n   if (from_insn == to_insn)\n     return NULL_RTX;\n@@ -947,11 +934,15 @@ reg_set_or_used_since_bb_start (rtx reg, basic_block bb, rtx up_to_insn)\n static rtx\n get_avail_load_store_reg (rtx insn)\n {\n-  if (REG_P (SET_DEST (PATTERN (insn))))  /* A load.  */\n+  if (REG_P (SET_DEST (PATTERN (insn))))\n+    /* A load.  */\n     return SET_DEST(PATTERN(insn));\n-  if (REG_P (SET_SRC (PATTERN (insn))))  /* A store.  */\n-    return SET_SRC (PATTERN (insn));\n-  abort ();\n+  else\n+    {\n+      /* A store.  */\n+      gcc_assert (REG_P (SET_SRC (PATTERN (insn))));\n+      return SET_SRC (PATTERN (insn));\n+    }\n }\n \n /* Return nonzero if the predecessors of BB are \"well behaved\".  */\n@@ -1044,8 +1035,9 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n \t{\n \t  /* Check if the loaded register is not used.  */\n \t  avail_insn = a_occr->insn;\n-\t  if (! (avail_reg = get_avail_load_store_reg (avail_insn)))\n-\t    abort ();\n+\t  avail_reg = get_avail_load_store_reg (avail_insn);\n+\t  gcc_assert (avail_reg);\n+\t  \n \t  /* Make sure we can generate a move from register avail_reg to\n \t     dest.  */\n \t  extract_insn (gen_move_insn (copy_rtx (dest),\n@@ -1116,8 +1108,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n       /* Set avail_reg to be the register having the value of the\n \t memory.  */\n       avail_reg = get_avail_load_store_reg (avail_insn);\n-      if (! avail_reg)\n-\tabort ();\n+      gcc_assert (avail_reg);\n \n       insert_insn_on_edge (gen_move_insn (copy_rtx (dest),\n \t\t\t\t\t  copy_rtx (avail_reg)),"}, {"sha": "16cb818d59b7dce9751cd94a1eae96db48a1334c", "filename": "gcc/postreload.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -293,7 +293,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \t\t  if (this_val == trunc_int_for_mode (this_val, GET_MODE (src)))\n \t\t    break;\n \t\tdefault:\n-\t\t  abort ();\n+\t\t  gcc_unreachable ();\n \t\t}\n \t      this_rtx = GEN_INT (this_val);\n \t    }\n@@ -1068,8 +1068,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n       if (REG_P (SET_DEST (x)))\n \t{\n \t  /* No spurious CLOBBERs of pseudo registers may remain.  */\n-\t  if (REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER)\n-\t    abort ();\n+\t  gcc_assert (REGNO (SET_DEST (x)) < FIRST_PSEUDO_REGISTER);\n \t  return;\n \t}\n       break;\n@@ -1089,8 +1088,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n \tint nregs;\n \n \t/* No spurious USEs of pseudo registers may remain.  */\n-\tif (regno >= FIRST_PSEUDO_REGISTER)\n-\t  abort ();\n+\tgcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n \tnregs = hard_regno_nregs[regno][GET_MODE (x)];\n "}, {"sha": "37b1f20e3b5ffc11cec76870c2192d2aa7fc6472", "filename": "gcc/predict.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -181,8 +181,7 @@ tree_predicted_by_p (basic_block bb, enum br_predictor predictor)\n static void\n predict_insn (rtx insn, enum br_predictor predictor, int probability)\n {\n-  if (!any_condjump_p (insn))\n-    abort ();\n+  gcc_assert (any_condjump_p (insn));\n   if (!flag_guess_branch_prob)\n     return;\n \n@@ -1440,8 +1439,7 @@ expected_value_to_br_prob (void)\n       cond = simplify_rtx (cond);\n \n       /* Turn the condition into a scaled branch probability.  */\n-      if (cond != const_true_rtx && cond != const0_rtx)\n-\tabort ();\n+      gcc_assert (cond == const_true_rtx || cond == const0_rtx);\n       predict_insn_def (insn, PRED_BUILTIN_EXPECT,\n \t\t        cond == const_true_rtx ? TAKEN : NOT_TAKEN);\n     }\n@@ -1610,9 +1608,8 @@ propagate_freq (struct loop *loop, bitmap tovisit)\n \t{\n #ifdef ENABLE_CHECKING\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    if (bitmap_bit_p (tovisit, e->src->index)\n-\t\t&& !(e->flags & EDGE_DFS_BACK))\n-\t      abort ();\n+\t    gcc_assert (!bitmap_bit_p (tovisit, e->src->index)\n+\t\t\t|| (e->flags & EDGE_DFS_BACK));\n #endif\n \n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -1756,8 +1753,7 @@ expensive_function_p (int threshold)\n \n   /* We can not compute accurately for large thresholds due to scaled\n      frequencies.  */\n-  if (threshold > BB_FREQ_MAX)\n-    abort ();\n+  gcc_assert (threshold <= BB_FREQ_MAX);\n \n   /* Frequencies are out of range.  This either means that function contains\n      internal loop executing more than BB_FREQ_MAX times or profile feedback"}, {"sha": "56f4da69fe591e0ea3a33fad61b63dbde4c97209", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -607,7 +607,7 @@ print_rtx (rtx in_rtx)\n \t  case LABEL_STATIC_ENTRY: fputs (\" [entry]\", outfile); break;\n \t  case LABEL_GLOBAL_ENTRY: fputs (\" [global entry]\", outfile); break;\n \t  case LABEL_WEAK_ENTRY: fputs (\" [weak entry]\", outfile); break;\n-\t  default: abort();\n+\t  default: gcc_unreachable ();\n \t}\n       break;\n "}, {"sha": "6065558abe9e43f81de6c549ae7183f5c04faed5", "filename": "gcc/profile.c", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -150,8 +150,7 @@ instrument_edges (struct edge_list *el)\n \n \t  if (!inf->ignore && !inf->on_tree)\n \t    {\n-\t      if (e->flags & EDGE_ABNORMAL)\n-\t\tabort ();\n+\t      gcc_assert (!(e->flags & EDGE_ABNORMAL));\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Edge %d to %d instrumented%s\\n\",\n \t\t\t e->src->index, e->dest->index,\n@@ -197,7 +196,7 @@ instrument_values (histogram_values values)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       if (!coverage_counter_alloc (t, hist->n_counters))\n \tcontinue;\n@@ -221,7 +220,7 @@ instrument_values (histogram_values values)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   VEC_free (histogram_value, values);\n@@ -430,8 +429,7 @@ compute_branch_probabilities (void)\n \t\t  /* Calculate count for remaining edge by conservation.  */\n \t\t  total = bb->count - total;\n \n-\t\t  if (! e)\n-\t\t    abort ();\n+\t\t  gcc_assert (e);\n \t\t  EDGE_INFO (e)->count_valid = 1;\n \t\t  e->count = total;\n \t\t  bi->succ_count--;\n@@ -458,8 +456,7 @@ compute_branch_probabilities (void)\n \t\t  /* Calculate count for remaining edge by conservation.  */\n \t\t  total = bb->count - total + e->count;\n \n-\t\t  if (! e)\n-\t\t    abort ();\n+\t\t  gcc_assert (e);\n \t\t  EDGE_INFO (e)->count_valid = 1;\n \t\t  e->count = total;\n \t\t  bi->pred_count--;\n@@ -481,8 +478,7 @@ compute_branch_probabilities (void)\n      succ and pred count of zero.  */\n   FOR_EACH_BB (bb)\n     {\n-      if (BB_INFO (bb)->succ_count || BB_INFO (bb)->pred_count)\n-\tabort ();\n+      gcc_assert (!BB_INFO (bb)->succ_count && !BB_INFO (bb)->pred_count);\n     }\n \n   /* For every edge, calculate its branch probability and add a reg_note\n@@ -1116,8 +1112,7 @@ branch_prob (void)\n \n       n_instrumented = instrument_edges (el);\n \n-      if (n_instrumented != num_instrumented)\n-\tabort ();\n+      gcc_assert (n_instrumented == num_instrumented);\n \n       if (flag_profile_values)\n \tinstrument_values (values);\n@@ -1177,8 +1172,7 @@ union_groups (basic_block bb1, basic_block bb2)\n \n   /* ??? I don't have a place for the rank field.  OK.  Lets go w/o it,\n      this code is unlikely going to be performance problem anyway.  */\n-  if (bb1g == bb2g)\n-    abort ();\n+  gcc_assert (bb1g != bb2g);\n \n   bb1g->aux = bb2g;\n }\n@@ -1322,17 +1316,15 @@ end_branch_prob (void)\n void\n tree_register_profile_hooks (void)\n {\n+  gcc_assert (ir_type ());\n   profile_hooks = &tree_profile_hooks;\n-  if (!ir_type ())\n-    abort ();\n }\n \n /* Set up hooks to enable RTL-based profiling.  */\n \n void\n rtl_register_profile_hooks (void)\n {\n+  gcc_assert (!ir_type ());\n   profile_hooks = &rtl_profile_hooks;\n-  if (ir_type ())\n-    abort ();\n }"}, {"sha": "b9e100c7fc7fe4a72920090a7e77c1c0e2d5ea9d", "filename": "gcc/protoize.c", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -34,7 +34,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n #endif\n-#undef abort\n #include \"version.h\"\n \n /* Include getopt.h for the sake of getopt_long.  */\n@@ -641,8 +640,7 @@ in_system_include_dir (const char *path)\n {\n   const struct default_include *p;\n \n-  if (! IS_ABSOLUTE_PATH (path))\n-    abort ();\t\t/* Must be an absolutized filename.  */\n+  gcc_assert (IS_ABSOLUTE_PATH (path));\n \n   for (p = cpp_include_defaults; p->fname; p++)\n     if (!strncmp (path, p->fname, strlen (p->fname))\n@@ -679,10 +677,8 @@ file_could_be_converted (const char *path)\n \tdir_last_slash = slash;\n     }\n #endif\n-    if (dir_last_slash)\n-      *dir_last_slash = '\\0';\n-    else\n-      abort ();  /* Should have been an absolutized filename.  */\n+    gcc_assert (dir_last_slash);\n+    *dir_last_slash = '\\0';\n   }\n \n   if (access (path, W_OK))\n@@ -723,10 +719,8 @@ file_normally_convertible (const char *path)\n \tdir_last_slash = slash;\n     }\n #endif\n-    if (dir_last_slash)\n-      *dir_last_slash = '\\0';\n-    else\n-      abort ();  /* Should have been an absolutized filename.  */\n+    gcc_assert (dir_last_slash);\n+    *dir_last_slash = '\\0';\n   }\n \n   if (access (path, R_OK))\n@@ -1930,7 +1924,7 @@ gen_aux_info_file (const char *base_filename)\n \t  }\n \treturn 1;\n       }\n-    abort ();\n+    gcc_unreachable ();\n   }\n }\n \f\n@@ -2742,8 +2736,7 @@ check_source (int cond, const char *clean_p)\n static const char *\n seek_to_line (int n)\n {\n-  if (n < last_known_line_number)\n-    abort ();\n+  gcc_assert (n >= last_known_line_number);\n \n   while (n > last_known_line_number)\n     {\n@@ -3670,8 +3663,8 @@ do_cleaning (char *new_clean_text_base, const char *new_clean_text_limit)\n \t    {\n \t      if (!ISSPACE ((const unsigned char)*scan_p))\n \t\t*scan_p = ' ';\n-\t      if (++scan_p >= new_clean_text_limit)\n-\t\tabort ();\n+\t      ++scan_p;\n+\t      gcc_assert (scan_p < new_clean_text_limit);\n \t    }\n \t  *scan_p++ = ' ';\n \t  *scan_p = ' ';\n@@ -3685,8 +3678,8 @@ do_cleaning (char *new_clean_text_base, const char *new_clean_text_limit)\n \t    {\n \t      if (!ISSPACE ((const unsigned char)*scan_p))\n \t\t*scan_p = ' ';\n-\t      if (++scan_p >= new_clean_text_limit)\n-\t\tabort ();\n+\t      ++scan_p;\n+\t      gcc_assert (scan_p < new_clean_text_limit);\n \t    }\n \t  *scan_p++ = ' ';\n \t  break;\n@@ -3700,8 +3693,8 @@ do_cleaning (char *new_clean_text_base, const char *new_clean_text_limit)\n \t\tscan_p[1] = ' ';\n \t      if (!ISSPACE ((const unsigned char)*scan_p))\n \t\t*scan_p = ' ';\n-\t      if (++scan_p >= new_clean_text_limit)\n-\t\tabort ();\n+\t      ++scan_p;\n+\t      gcc_assert (scan_p < new_clean_text_limit);\n \t    }\n \t  *scan_p++ = ' ';\n \t  break;\n@@ -3715,8 +3708,8 @@ do_cleaning (char *new_clean_text_base, const char *new_clean_text_limit)\n \t\tscan_p[1] = ' ';\n \t      if (!ISSPACE ((const unsigned char)*scan_p))\n \t\t*scan_p = ' ';\n-\t      if (++scan_p >= new_clean_text_limit)\n-\t\tabort ();\n+\t      ++scan_p;\n+\t      gcc_assert (scan_p < new_clean_text_limit);\n \t    }\n \t  if (!ISSPACE ((const unsigned char)*scan_p))\n \t    *scan_p = ' ';"}, {"sha": "0dc48e3825f369b0e02dda0ed10c33318ff65037", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -2065,8 +2065,7 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n   switch (TREE_CODE (stmt))\n     {\n     case RETURN_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (stmt, 0)) != MODIFY_EXPR)\n-\tabort ();\n+      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR);\n       stmt = TREE_OPERAND (stmt, 0);\n       /* FALLTHRU  */\n "}, {"sha": "d8a850d357b7dc1276fa5fef9b4cb1cad5779c03", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -2204,8 +2204,12 @@ execute_fold_all_builtins (void)\n \t  if (!set_rhs (stmtp, result))\n \t    {\n \t      result = convert_to_gimple_builtin (&i, result);\n-\t      if (result && !set_rhs (stmtp, result))\n-\t\tabort ();\n+\t      if (result)\n+\t\t{\n+\t\t  bool ok = set_rhs (stmtp, result);\n+\t\t  \n+\t\t  gcc_assert (ok);\n+\t\t}\n \t    }\n \t  modify_stmt (*stmtp);\n \t  if (maybe_clean_eh_stmt (*stmtp)"}, {"sha": "7853d69acd363e62fb5518789b527f89ff2fa34e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16acfcd1431d5448b7e958ab72f783e1f0f1263/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=e16acfcd1431d5448b7e958ab72f783e1f0f1263", "patch": "@@ -2348,8 +2348,8 @@ static rtx\n produce_memory_decl_rtl (tree obj, int *regno)\n {\n   rtx x;\n-  if (!obj)\n-    abort ();\n+  \n+  gcc_assert (obj);\n   if (TREE_STATIC (obj) || DECL_EXTERNAL (obj))\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (obj));"}]}