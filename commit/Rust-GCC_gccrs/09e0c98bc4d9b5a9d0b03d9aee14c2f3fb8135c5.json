{"sha": "09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDllMGM5OGJjNGQ5YjVhOWQwYjAzZDlhZWUxNGMyZjNmYjgxMzVjNQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2019-02-11T16:50:33Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2019-02-11T16:50:33Z"}, "message": "rs6000.c (rs6000_gimple_fold_builtin): Shift-right and shift-left vector built-ins need to include a TRUNC_MOD_EXPR...\n\n[gcc]\n\n2019-02-11  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Shift-right\n\tand shift-left vector built-ins need to include a TRUNC_MOD_EXPR\n\tfor correct semantics.\n\n[gcc/testsuite]\n\n2019-02-11  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* gcc.target/powerpc/vec-sld-modulo.c: New.\n\t* gcc.target/powerpc/vec-srad-modulo.c: New.\n\t* gcc.target/powerpc/vec-srd-modulo.c: New.\n\nFrom-SVN: r268771", "tree": {"sha": "913679e02a025d06d9209c215dcd642fde878353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/913679e02a025d06d9209c215dcd642fde878353"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/comments", "author": null, "committer": null, "parents": [{"sha": "ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7fa4886350037f892f9565f5a26c3ecd7ffc16"}], "stats": {"total": 199, "additions": 191, "deletions": 8}, "files": [{"sha": "4a66632e740127b616230f7782b0d777890062db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "patch": "@@ -1,3 +1,9 @@\n+2019-02-11  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Shift-right\n+\tand shift-left vector built-ins need to include a TRUNC_MOD_EXPR\n+\tfor correct semantics.\n+\n 2019-02-11  Alan Modra  <amodra@gmail.com>\n \n \t* doc/invoke.texi (man page RS/6000 and PowerPC Options): Mention"}, {"sha": "ff51e48eae46bac1a4ef738d1ba0c7025936f13a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "patch": "@@ -15735,13 +15735,37 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VSRAH:\n     case ALTIVEC_BUILTIN_VSRAW:\n     case P8V_BUILTIN_VSRAD:\n-      arg0 = gimple_call_arg (stmt, 0);\n-      arg1 = gimple_call_arg (stmt, 1);\n-      lhs = gimple_call_lhs (stmt);\n-      g = gimple_build_assign (lhs, RSHIFT_EXPR, arg0, arg1);\n-      gimple_set_location (g, gimple_location (stmt));\n-      gsi_replace (gsi, g, true);\n-      return true;\n+      {\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\ttree arg1_type = TREE_TYPE (arg1);\n+\ttree unsigned_arg1_type = unsigned_type_for (TREE_TYPE (arg1));\n+\ttree unsigned_element_type = unsigned_type_for (TREE_TYPE (arg1_type));\n+\tlocation_t loc = gimple_location (stmt);\n+\t/* Force arg1 into the range valid matching the arg0 type.  */\n+\t/* Build a vector consisting of the max valid bit-size values.  */\n+\tint n_elts = VECTOR_CST_NELTS (arg1);\n+\ttree element_size = build_int_cst (unsigned_element_type,\n+\t\t\t\t\t   128 / n_elts);\n+\ttree_vector_builder elts (unsigned_arg1_type, n_elts, 1);\n+\tfor (int i = 0; i < n_elts; i++)\n+\t  elts.safe_push (element_size);\n+\ttree modulo_tree = elts.build ();\n+\t/* Modulo the provided shift value against that vector.  */\n+\tgimple_seq stmts = NULL;\n+\ttree unsigned_arg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   unsigned_arg1_type, arg1);\n+\ttree new_arg1 = gimple_build (&stmts, loc, TRUNC_MOD_EXPR,\n+\t\t\t\t      unsigned_arg1_type, unsigned_arg1,\n+\t\t\t\t      modulo_tree);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t/* And finally, do the shift.  */\n+\tg = gimple_build_assign (lhs, RSHIFT_EXPR, arg0, new_arg1);\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n    /* Flavors of vector shift left.\n       builtin_altivec_vsl{b,h,w} -> vsl{b,h,w}.  */\n     case ALTIVEC_BUILTIN_VSLB:\n@@ -15795,14 +15819,34 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \targ0 = gimple_call_arg (stmt, 0);\n \targ1 = gimple_call_arg (stmt, 1);\n \tlhs = gimple_call_lhs (stmt);\n+\ttree arg1_type = TREE_TYPE (arg1);\n+\ttree unsigned_arg1_type = unsigned_type_for (TREE_TYPE (arg1));\n+\ttree unsigned_element_type = unsigned_type_for (TREE_TYPE (arg1_type));\n+\tlocation_t loc = gimple_location (stmt);\n \tgimple_seq stmts = NULL;\n \t/* Convert arg0 to unsigned.  */\n \ttree arg0_unsigned\n \t  = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n \t\t\t  unsigned_type_for (TREE_TYPE (arg0)), arg0);\n+\t/* Force arg1 into the range valid matching the arg0 type.  */\n+\t/* Build a vector consisting of the max valid bit-size values.  */\n+\tint n_elts = VECTOR_CST_NELTS (arg1);\n+\ttree element_size = build_int_cst (unsigned_element_type,\n+\t\t\t\t\t   128 / n_elts);\n+\ttree_vector_builder elts (unsigned_arg1_type, n_elts, 1);\n+\tfor (int i = 0; i < n_elts; i++)\n+\t  elts.safe_push (element_size);\n+\ttree modulo_tree = elts.build ();\n+\t/* Modulo the provided shift value against that vector.  */\n+\ttree unsigned_arg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   unsigned_arg1_type, arg1);\n+\ttree new_arg1 = gimple_build (&stmts, loc, TRUNC_MOD_EXPR,\n+\t\t\t\t      unsigned_arg1_type, unsigned_arg1,\n+\t\t\t\t      modulo_tree);\n+\t/* Do the shift.  */\n \ttree res\n \t  = gimple_build (&stmts, RSHIFT_EXPR,\n-\t\t\t  TREE_TYPE (arg0_unsigned), arg0_unsigned, arg1);\n+\t\t\t  TREE_TYPE (arg0_unsigned), arg0_unsigned, new_arg1);\n \t/* Convert result back to the lhs type.  */\n \tres = gimple_build (&stmts, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), res);\n \tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);"}, {"sha": "78aa1bc3c4c8cb30cc7e73d55423deb0c0609abe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "patch": "@@ -1,3 +1,9 @@\n+2019-02-11  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-sld-modulo.c: New.\n+\t* gcc.target/powerpc/vec-srad-modulo.c: New.\n+\t* gcc.target/powerpc/vec-srd-modulo.c: New.\n+\n 2019-02-11  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/89009"}, {"sha": "de7c04577ab19ca5764e71c35fa84e3a3a1fd59f", "filename": "gcc/testsuite/gcc.target/powerpc/vec-sld-modulo.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-sld-modulo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-sld-modulo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-sld-modulo.c?ref=09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "patch": "@@ -0,0 +1,42 @@\n+/* Test that using a character splat to set up a shift-left\n+   for a doubleword vector works correctly after gimple folding.  */\n+\n+/* { dg-do run { target { vsx_hw } } } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#include <altivec.h>\n+\n+typedef __vector unsigned long long vui64_t;\n+\n+static inline vui64_t\n+vec_sldi (vui64_t vra, const unsigned int shb)\n+{\n+  vui64_t lshift;\n+  vui64_t result;\n+\n+  /* Note legitimate use of wrong-type splat due to expectation that only\n+     lower 6-bits are read.  */\n+  lshift = (vui64_t) vec_splat_s8 (shb);\n+\n+  /* Vector Shift Left Doublewords based on the lower 6-bits\n+     of corresponding element of lshift.  */\n+  result = vec_vsld (vra, lshift);\n+\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) vui64_t\n+test_sldi_4 (vui64_t a)\n+{\n+  return vec_sldi (a, 4);\n+}\n+\n+int\n+main ()\n+{\n+  vui64_t x = {-256, 1025};\n+  x = test_sldi_4 (x);\n+  if (x[0] != -4096 || x[1] != 16400)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "f18049c386fce3da59bf430016686adbbbbe3269", "filename": "gcc/testsuite/gcc.target/powerpc/vec-srad-modulo.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-srad-modulo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-srad-modulo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-srad-modulo.c?ref=09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "patch": "@@ -0,0 +1,43 @@\n+/* Test that using a character splat to set up a shift-right algebraic\n+   for a doubleword vector works correctly after gimple folding.  */\n+\n+/* { dg-do run { target { vsx_hw } } } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#include <altivec.h>\n+\n+typedef __vector unsigned long long vui64_t;\n+typedef __vector long long vi64_t;\n+\n+static inline vi64_t\n+vec_sradi (vi64_t vra, const unsigned int shb)\n+{\n+  vui64_t rshift;\n+  vi64_t result;\n+\n+  /* Note legitimate use of wrong-type splat due to expectation that only\n+     lower 6-bits are read.  */\n+  rshift = (vui64_t) vec_splat_s8 (shb);\n+\n+  /* Vector Shift Right Algebraic Doublewords based on the lower 6-bits\n+     of corresponding element of rshift.  */\n+  result = vec_vsrad (vra, rshift);\n+\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) vi64_t\n+test_sradi_4 (vi64_t a)\n+{\n+  return vec_sradi (a, 4);\n+}\n+\n+int\n+main ()\n+{\n+  vi64_t x = {-256, 1025};\n+  x = test_sradi_4 (x);\n+  if (x[0] != -16 || x[1] != 64)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "0370f1534b7a9f3ccf37278cc4c72934332f0eb2", "filename": "gcc/testsuite/gcc.target/powerpc/vec-srd-modulo.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-srd-modulo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-srd-modulo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-srd-modulo.c?ref=09e0c98bc4d9b5a9d0b03d9aee14c2f3fb8135c5", "patch": "@@ -0,0 +1,42 @@\n+/* Test that using a character splat to set up a shift-right logical\n+   for a doubleword vector works correctly after gimple folding.  */\n+\n+/* { dg-do run { target { vsx_hw } } } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#include <altivec.h>\n+\n+typedef __vector unsigned long long vui64_t;\n+\n+static inline vui64_t\n+vec_srdi (vui64_t vra, const unsigned int shb)\n+{\n+  vui64_t rshift;\n+  vui64_t result;\n+\n+  /* Note legitimate use of wrong-type splat due to expectation that only\n+     lower 6-bits are read.  */\n+  rshift = (vui64_t) vec_splat_s8 (shb);\n+\n+  /* Vector Shift Right [Logical] Doublewords based on the lower 6-bits\n+     of corresponding element of rshift.  */\n+  result = vec_vsrd (vra, rshift);\n+\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) vui64_t\n+test_srdi_4 (vui64_t a)\n+{\n+  return vec_srdi (a, 4);\n+}\n+\n+int\n+main ()\n+{\n+  vui64_t x = {1992357, 1025};\n+  x = test_srdi_4 (x);\n+  if (x[0] != 124522 || x[1] != 64)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}