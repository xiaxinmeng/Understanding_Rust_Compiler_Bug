{"sha": "6e7a4706fdf5641516cd85b20d5ac9070a348e15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3YTQ3MDZmZGY1NjQxNTE2Y2Q4NWIyMGQ1YWM5MDcwYTM0OGUxNQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2006-01-23T15:16:19Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2006-01-23T15:16:19Z"}, "message": "r110130@banpei: zack | 2006-01-22 14:52:43 -0800\n\n r110130@banpei:  zack | 2006-01-22 14:52:43 -0800\n \t* rtl.def (match_code): Add second argument.\n \t* genpreds.c (write_extract_subexp): New function.\n \t(write_match_code): Add path argument.  Use write_extract_subexp.\n \t(write_predicate_expr): Pass path to write_match_code.\n \t(mark_mode_tests): MATCH_CODE applied to a subexpression does\n \tnot perform a mode test.\n \t* genrecog.c (compute_predicate_codes): MATCH_CODE applied to\n \ta subexpression does not constrain the top-level code set.\n \t* read-rtl.c (read_rtx_variadic): New function.\n \t(read_rtx_1): Use it; allow AND and IOR to be variadic.\n \t* doc/md.texi: Document new notation.\n \t* config/i386/predicates.md (cmpsi_operand_1): Fold into ...\n \t(cmpsi_operand): ... here, using new notation.\n\nFrom-SVN: r110126", "tree": {"sha": "ffc73708bd6be59b11ab8a71a9537d0d6289dced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffc73708bd6be59b11ab8a71a9537d0d6289dced"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e7a4706fdf5641516cd85b20d5ac9070a348e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7a4706fdf5641516cd85b20d5ac9070a348e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7a4706fdf5641516cd85b20d5ac9070a348e15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7a4706fdf5641516cd85b20d5ac9070a348e15/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ff09968f1d0f5523b026701374f4a0386eb054c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff09968f1d0f5523b026701374f4a0386eb054c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff09968f1d0f5523b026701374f4a0386eb054c"}], "stats": {"total": 190, "additions": 159, "deletions": 31}, "files": [{"sha": "eaaf2d87fe01e77e0447e285b08f5970e381b62a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e7a4706fdf5641516cd85b20d5ac9070a348e15", "patch": "@@ -1,3 +1,19 @@\n+2006-01-22  Zack Weinberg  <zackw@panix.com>\n+\n+\t* rtl.def (match_code): Add second argument.\n+\t* genpreds.c (write_extract_subexp): New function.\n+\t(write_match_code): Add path argument.  Use write_extract_subexp.\n+\t(write_predicate_expr): Pass path to write_match_code.\n+\t(mark_mode_tests): MATCH_CODE applied to a subexpression does\n+\tnot perform a mode test.\n+\t* genrecog.c (compute_predicate_codes): MATCH_CODE applied to\n+\ta subexpression does not constrain the top-level code set.\n+\t* read-rtl.c (read_rtx_variadic): New function.\n+\t(read_rtx_1): Use it; allow AND and IOR to be variadic.\n+\t* doc/md.texi: Document new notation.\n+\t* config/i386/predicates.md (cmpsi_operand_1): Fold into ...\n+\t(cmpsi_operand): ... here, using new notation.\n+\n 2006-01-22  Zack Weinberg  <zackw@panix.com>\n \n \t* varray.c: Remove GENERATOR_FILE #ifdefs."}, {"sha": "acc01eeb537b11cb0ca75393991f797d3cb7ed0e", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=6e7a4706fdf5641516cd85b20d5ac9070a348e15", "patch": "@@ -931,21 +931,16 @@\n ;; ??? It seems likely that this will only work because cmpsi is an\n ;; expander, and no actual insns use this.\n \n-(define_predicate \"cmpsi_operand_1\"\n-  (match_code \"and\")\n-{\n-  return (GET_MODE (op) == SImode\n-\t  && GET_CODE (XEXP (op, 0)) == ZERO_EXTRACT\n-\t  && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (XEXP (op, 0), 2)) == CONST_INT\n-\t  && INTVAL (XEXP (XEXP (op, 0), 1)) == 8\n-\t  && INTVAL (XEXP (XEXP (op, 0), 2)) == 8\n-\t  && GET_CODE (XEXP (op, 1)) == CONST_INT);\n-})\n-\n (define_predicate \"cmpsi_operand\"\n   (ior (match_operand 0 \"nonimmediate_operand\")\n-       (match_operand 0 \"cmpsi_operand_1\")))\n+       (and (match_code \"and\")\n+\t    (match_code \"zero_extract\" \"0\")\n+\t    (match_code \"const_int\"    \"1\")\n+\t    (match_code \"const_int\"    \"01\")\n+\t    (match_code \"const_int\"    \"02\")\n+\t    (match_test \"INTVAL (XEXP (XEXP (op, 0), 1)) == 8\")\n+\t    (match_test \"INTVAL (XEXP (XEXP (op, 0), 2)) == 8\")\n+       )))\n \n (define_predicate \"compare_operator\"\n   (match_code \"compare\"))"}, {"sha": "df16e9370c32e9a2d8a4ac1e0b7f5a9ae11d4a04", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=6e7a4706fdf5641516cd85b20d5ac9070a348e15", "patch": "@@ -898,9 +898,27 @@ limitations in @command{genrecog}, you can only refer to generic\n predicates and predicates that have already been defined.\n \n @item MATCH_CODE\n-This expression has one operand, a string constant containing a\n-comma-separated list of RTX code names (in lower case).  It evaluates\n-to true if @var{op} has any of the listed codes.\n+This expression evaluates to true if @var{op} or a specified\n+subexpression of @var{op} has one of a given list of RTX codes.\n+\n+The first operand of this expression is a string constant containing a\n+comma-separated list of RTX code names (in lower case).  These are the\n+codes for which the @code{MATCH_CODE} will be true.\n+\n+The second operand is a string constant which indicates what\n+subexpression of @var{op} to examine.  If it is absent or the empty\n+string, @var{op} itself is examined.  Otherwise, the string constant\n+must be a sequence of digits and/or lowercase letters.  Each character\n+indicates a subexpression to extract from the current expression; for\n+the first character this is @var{op}, for the second and subsequent\n+characters it is the result of the previous character.  A digit\n+@var{n} extracts @samp{@w{XEXP (@var{e}, @var{n})}}; a letter @var{l}\n+extracts @samp{@w{XVECEXP (@var{e}, 0, @var{n})}} where @var{n} is the\n+alphabetic ordinal of @var{l} (0 for `a', 1 for 'b', and so on).  The\n+@code{MATCH_CODE} then examines the RTX code of the subexpression\n+extracted by the complete string.  It is not possible to extract\n+components of an @code{rtvec} that is not at position 0 within its RTX\n+object.\n \n @item MATCH_TEST\n This expression has one operand, a string constant containing a C\n@@ -915,7 +933,10 @@ evaluates to true if the C expression evaluates to a nonzero value.\n @itemx IF_THEN_ELSE\n The basic @samp{MATCH_} expressions can be combined using these\n logical operators, which have the semantics of the C operators\n-@samp{&&}, @samp{||}, @samp{!}, and @samp{@w{? :}} respectively.\n+@samp{&&}, @samp{||}, @samp{!}, and @samp{@w{? :}} respectively.  As\n+in Common Lisp, you may give an @code{AND} or @code{IOR} expression an\n+arbitrary number of arguments; this has exactly the same effect as\n+writing a chain of two-argument @code{AND} or @code{IOR} expressions.\n @end table\n \n @item"}, {"sha": "bfd681cc7b8b724091f8e110742e10def3e5d704", "filename": "gcc/genpreds.c", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=6e7a4706fdf5641516cd85b20d5ac9070a348e15", "patch": "@@ -148,11 +148,11 @@ write_predicate_subfunction (struct pred_data *p)\n \n /* Given an RTL expression EXP, find all subexpressions which we may\n    assume to perform mode tests.  Normal MATCH_OPERAND does;\n-   MATCH_CODE does if and only if it accepts CONST_INT or\n-   CONST_DOUBLE; and we have to assume that MATCH_TEST does not.\n-   These combine in almost-boolean fashion - the only exception is\n-   that (not X) must be assumed not to perform a mode test, whether or\n-   not X does.\n+   MATCH_CODE does if it applies to the whole expression and accepts\n+   CONST_INT or CONST_DOUBLE; and we have to assume that MATCH_TEST\n+   does not.  These combine in almost-boolean fashion - the only\n+   exception is that (not X) must be assumed not to perform a mode\n+   test, whether or not X does.\n \n    The mark is the RTL /v flag, which is true for subexpressions which\n    do *not* perform mode tests.\n@@ -174,8 +174,9 @@ mark_mode_tests (rtx exp)\n       break;\n \n     case MATCH_CODE:\n-      if (!strstr (XSTR (exp, 0), \"const_int\")\n-\t  && !strstr (XSTR (exp, 0), \"const_double\"))\n+      if (XSTR (exp, 1)[0] != '\\0'\n+\t  || (!strstr (XSTR (exp, 0), \"const_int\")\n+\t      && !strstr (XSTR (exp, 0), \"const_double\")))\n \tNO_MODE_TEST (exp) = 1;\n       break;\n \n@@ -305,17 +306,56 @@ add_mode_tests (struct pred_data *p)\n   *pos = and_exp;\n }\n \n+/* PATH is a string describing a path from the root of an RTL\n+   expression to an inner subexpression to be tested.  Output\n+   code which computes the subexpression from the variable\n+   holding the root of the expression.  */\n+static void\n+write_extract_subexp (const char *path)\n+{\n+  int len = strlen (path);\n+  int i;\n+\n+  /* We first write out the operations (XEXP or XVECEXP) in reverse\n+     order, then write \"op\", then the indices in forward order.  */\n+  for (i = len - 1; i >= 0; i--)\n+    {\n+      if (ISLOWER (path[i]))\n+\tfputs (\"XVECEXP (\", stdout);\n+      else if (ISDIGIT (path[i]))\n+\tfputs (\"XEXP (\", stdout);\n+      else\n+\t{\n+\t  error (\"bad character in path string '%s'\", path);\n+\t  return;\n+\t}\n+    }\n+\n+  fputs (\"op\", stdout);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      if (ISLOWER (path[i]))\n+\tprintf (\", 0, %d)\", path[i] - 'a');\n+      else if (ISDIGIT (path[i]))\n+\tprintf (\", %d)\", path[i] - '0');\n+      else\n+\tgcc_unreachable ();\n+    }\n+}\n \n /* CODES is a list of RTX codes.  Write out an expression which\n    determines whether the operand has one of those codes.  */\n static void\n-write_match_code (const char *codes)\n+write_match_code (const char *path, const char *codes)\n {\n   const char *code;\n \n   while ((code = scan_comma_elt (&codes)) != 0)\n     {\n-      fputs (\"GET_CODE (op) == \", stdout);\n+      fputs (\"GET_CODE (\", stdout);\n+      write_extract_subexp (path);\n+      fputs (\") == \", stdout);\n       while (code < codes)\n \t{\n \t  putchar (TOUPPER (*code));\n@@ -374,7 +414,7 @@ write_predicate_expr (const char *name, rtx exp)\n       break;\n \n     case MATCH_CODE:\n-      write_match_code (XSTR (exp, 0));\n+      write_match_code (XSTR (exp, 1), XSTR (exp, 0));\n       break;\n \n     case MATCH_TEST:"}, {"sha": "56d65985d25fdd41836302d2a60c7715de46aa35", "filename": "gcc/genrecog.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=6e7a4706fdf5641516cd85b20d5ac9070a348e15", "patch": "@@ -270,7 +270,15 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n       break;\n \n     case MATCH_CODE:\n-      /* MATCH_CODE allows a specified list of codes.  */\n+      /* MATCH_CODE allows a specified list of codes.  However, if it\n+\t does not apply to the top level of the expression, it does not\n+\t constrain the set of codes for the top level.  */\n+      if (XSTR (exp, 1)[0] != '\\0')\n+\t{\n+\t  memset (codes, Y, NUM_RTX_CODE);\n+\t  break;\n+\t}\n+\n       memset (codes, N, NUM_RTX_CODE);\n       {\n \tconst char *next_code = XSTR (exp, 0);"}, {"sha": "5eb642ee0a23f512f5d0813c9517bec5285557a8", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=6e7a4706fdf5641516cd85b20d5ac9070a348e15", "patch": "@@ -145,6 +145,7 @@ static int find_macro (struct macro_group *, const char *, FILE *);\n static struct mapping *read_mapping (struct macro_group *, htab_t, FILE *);\n static void check_code_macro (struct mapping *, FILE *);\n static rtx read_rtx_1 (FILE *, struct map_value **);\n+static rtx read_rtx_variadic (FILE *, struct map_value **, rtx);\n \n /* The mode and code macro structures.  */\n static struct macro_group modes, codes;\n@@ -1696,7 +1697,49 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \n   c = read_skip_spaces (infile);\n   if (c != ')')\n-    fatal_expected_char (infile, ')', c);\n+    {\n+      /* Syntactic sugar for AND and IOR, allowing Lisp-like\n+\t arbitrary number of arguments for them.  */\n+      if (c == '(' && (GET_CODE (return_rtx) == AND\n+\t\t       || GET_CODE (return_rtx) == IOR))\n+\treturn read_rtx_variadic (infile, mode_maps, return_rtx);\n+      else\n+\tfatal_expected_char (infile, ')', c);\n+    }\n \n   return return_rtx;\n }\n+\n+/* Mutually recursive subroutine of read_rtx which reads\n+   (thing x1 x2 x3 ...) and produces RTL as if\n+   (thing x1 (thing x2 (thing x3 ...)))  had been written.\n+   When called, FORM is (thing x1 x2), and the file position\n+   is just past the leading parenthesis of x3.  Only works\n+   for THINGs which are dyadic expressions, e.g. AND, IOR.  */\n+static rtx\n+read_rtx_variadic (FILE *infile, struct map_value **mode_maps, rtx form)\n+{\n+  char c = '(';\n+  rtx p = form, q;\n+\n+  do\n+    {\n+      ungetc (c, infile);\n+\n+      q = rtx_alloc (GET_CODE (p));\n+      PUT_MODE (q, GET_MODE (p));\n+\n+      XEXP (q, 0) = XEXP (p, 1);\n+      XEXP (q, 1) = read_rtx_1 (infile, mode_maps);\n+      \n+      XEXP (p, 1) = q;\n+      p = q;\n+      c = read_skip_spaces (infile);\n+    }\n+  while (c == '(');\n+\n+  if (c != ')')\n+    fatal_expected_char (infile, ')', c);\n+\n+  return form;\n+}"}, {"sha": "8710f54890f4c2a37bbece29c726a05a60becc86", "filename": "gcc/rtl.def", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7a4706fdf5641516cd85b20d5ac9070a348e15/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=6e7a4706fdf5641516cd85b20d5ac9070a348e15", "patch": "@@ -727,8 +727,13 @@ DEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", RTX_MATCH)\n \n /* Appears only in define_predicate/define_special_predicate\n    expressions.  Evaluates true only if the operand has an RTX code\n-   from the set given by the argument (a comma-separated list).  */\n-DEF_RTL_EXPR(MATCH_CODE, \"match_code\", \"s\", RTX_MATCH)\n+   from the set given by the argument (a comma-separated list).  If the\n+   second argument is present and nonempty, it is a sequence of digits\n+   and/or letters which indicates the subexpression to test, using the\n+   same syntax as genextract/genrecog's location strings: 0-9 for\n+   XEXP (op, n), a-z for XVECEXP (op, 0, n); each character applies to\n+   the result of the one before it.  */\n+DEF_RTL_EXPR(MATCH_CODE, \"match_code\", \"ss\", RTX_MATCH)\n \n /* Appears only in define_predicate/define_special_predicate\n     expressions.  The argument is a C expression to be injected at this"}]}