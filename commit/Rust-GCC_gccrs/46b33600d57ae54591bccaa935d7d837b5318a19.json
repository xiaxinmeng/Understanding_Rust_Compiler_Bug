{"sha": "46b33600d57ae54591bccaa935d7d837b5318a19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZiMzM2MDBkNTdhZTU0NTkxYmNjYWE5MzVkN2Q4MzdiNTMxOGExOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-20T17:50:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-20T17:50:48Z"}, "message": "real.c (real_hash): New.\n\n        * real.c (real_hash): New.\n        * real.h: Declare it.\n        * cse.c (canon_hash): Use it.\n        * cselib.c (hash_rtx): Likewise.\n        * emit-rtl.c (const_double_htab_hash): Likewise.\n        * rtl.h (CONST_DOUBLE_REAL_VALUE): New.\n        * varasm.c (struct rtx_const): Reduce vector size; separate\n        integer and fp vectors.\n        (HASHBITS): Remove.\n        (const_hash_1): Rename from const_hash.  Use real_hash.  Do not\n        take modulus MAX_HASH_TABLE.\n        (const_hash): New.  Do take modulus MAX_HASH_TABLE.\n        (output_constant_def): Do not take modulus MAX_HASH_TABLE.\n        (SYMHASH): Don't use HASHBITS.\n        (decode_rtx_const): Copy only active bits from REAL_VALUE_TYPE.\n        Fix CONST_VECTOR thinko wrt fp vectors.  Fix kind comparison.\n        (simplify_subtraction): Fix kind comparison.\n        (const_hash_rtx): Return unsigned int.  Don't use HASHBITS.\n        Use a union to pun integer array.\n        * config/rs6000/rs6000.c (rs6000_hash_constant): Use real_hash;\n        only hash two words of integral CONST_DOUBLE.\n\nFrom-SVN: r57356", "tree": {"sha": "89d914be5aa639096dbd44d7f9d3e884503d85a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89d914be5aa639096dbd44d7f9d3e884503d85a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46b33600d57ae54591bccaa935d7d837b5318a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b33600d57ae54591bccaa935d7d837b5318a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b33600d57ae54591bccaa935d7d837b5318a19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b33600d57ae54591bccaa935d7d837b5318a19/comments", "author": null, "committer": null, "parents": [{"sha": "40ad65d05ee933ba6d04684e9ddaa6e841c5e4a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ad65d05ee933ba6d04684e9ddaa6e841c5e4a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40ad65d05ee933ba6d04684e9ddaa6e841c5e4a6"}], "stats": {"total": 307, "additions": 216, "deletions": 91}, "files": [{"sha": "53e5000c0d1b2af4513186c55790783594c54f79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -1,3 +1,27 @@\n+2002-09-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* real.c (real_hash): New.\n+\t* real.h: Declare it.\n+\t* cse.c (canon_hash): Use it.\n+\t* cselib.c (hash_rtx): Likewise.\n+\t* emit-rtl.c (const_double_htab_hash): Likewise.\n+\t* rtl.h (CONST_DOUBLE_REAL_VALUE): New.\n+\t* varasm.c (struct rtx_const): Reduce vector size; separate\n+\tinteger and fp vectors.\n+\t(HASHBITS): Remove.\n+\t(const_hash_1): Rename from const_hash.  Use real_hash.  Do not\n+\ttake modulus MAX_HASH_TABLE.\n+\t(const_hash): New.  Do take modulus MAX_HASH_TABLE.\n+\t(output_constant_def): Do not take modulus MAX_HASH_TABLE.\n+\t(SYMHASH): Don't use HASHBITS.\n+\t(decode_rtx_const): Copy only active bits from REAL_VALUE_TYPE.\n+\tFix CONST_VECTOR thinko wrt fp vectors.  Fix kind comparison.\n+\t(simplify_subtraction): Fix kind comparison.\n+\t(const_hash_rtx): Return unsigned int.  Don't use HASHBITS.\n+\tUse a union to pun integer array.\n+\t* config/rs6000/rs6000.c (rs6000_hash_constant): Use real_hash;\n+\tonly hash two words of integral CONST_DOUBLE.\n+\n 2002-09-20  Steve Ellcey  <sje@cup.hp.com>\n \n \t* config/ia64/hpux.h (STARTFILE_SPEC): Modify."}, {"sha": "ba0249cba7e40e0fe042e3eb68fc60c59f183335", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -11412,18 +11412,34 @@ static unsigned\n rs6000_hash_constant (k)\n      rtx k;\n {\n-  unsigned result = (GET_CODE (k) << 3) ^ GET_MODE (k);\n-  const char *format = GET_RTX_FORMAT (GET_CODE (k));\n-  int flen = strlen (format);\n-  int fidx;\n+  enum rtx_code code = GET_CODE (k);\n+  enum machine_mode mode = GET_MODE (k);\n+  unsigned result = (code << 3) ^ mode;\n+  const char *format;\n+  int flen, fidx;\n   \n-  if (GET_CODE (k) == LABEL_REF)\n-    return result * 1231 + (unsigned) INSN_UID (XEXP (k, 0));\n+  format = GET_RTX_FORMAT (code);\n+  flen = strlen (format);\n+  fidx = 0;\n \n-  if (GET_CODE (k) == CODE_LABEL)\n-    fidx = 3;\n-  else\n-    fidx = 0;\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+      return result * 1231 + (unsigned) INSN_UID (XEXP (k, 0));\n+\n+    case CONST_DOUBLE:\n+      if (mode != VOIDmode)\n+\treturn real_hash (CONST_DOUBLE_REAL_VALUE (k)) * result;\n+      flen = 2;\n+      break;\n+\n+    case CODE_LABEL:\n+      fidx = 3;\n+      break;\n+\n+    default:\n+      break;\n+    }\n \n   for (; fidx < flen; fidx++)\n     switch (format[fidx])\n@@ -11460,6 +11476,7 @@ rs6000_hash_constant (k)\n       default:\n \tabort ();\n       }\n+\n   return result;\n }\n "}, {"sha": "3571cc7c730a4f447a260f295c20088680efca1d", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -2320,11 +2320,7 @@ canon_hash (x, mode)\n \t the integers representing the constant.  */\n       hash += (unsigned) code + (unsigned) GET_MODE (x);\n       if (GET_MODE (x) != VOIDmode)\n-\tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n-\t  {\n-\t    unsigned HOST_WIDE_INT tem = XWINT (x, i);\n-\t    hash += tem;\n-\t  }\n+\thash += real_hash (CONST_DOUBLE_REAL_VALUE (x));\n       else\n \thash += ((unsigned) CONST_DOUBLE_LOW (x)\n \t\t + (unsigned) CONST_DOUBLE_HIGH (x));"}, {"sha": "9c54015f1e84d4d56db48f7da25639d20157e5e7", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -581,8 +581,7 @@ hash_rtx (x, mode, create)\n \t the integers representing the constant.  */\n       hash += (unsigned) code + (unsigned) GET_MODE (x);\n       if (GET_MODE (x) != VOIDmode)\n-\tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n-\t  hash += XWINT (x, i);\n+\thash += real_hash (CONST_DOUBLE_REAL_VALUE (x));\n       else\n \thash += ((unsigned) CONST_DOUBLE_LOW (x)\n \t\t + (unsigned) CONST_DOUBLE_HIGH (x));"}, {"sha": "bfcc289cca420c5e53d3f6ee09b8f66bebd0d037", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -221,12 +221,13 @@ static hashval_t\n const_double_htab_hash (x)\n      const void *x;\n {\n-  hashval_t h = 0;\n-  size_t i;\n   rtx value = (rtx) x;\n+  hashval_t h;\n \n-  for (i = 0; i < sizeof(CONST_DOUBLE_FORMAT)-1; i++)\n-    h ^= XWINT (value, i);\n+  if (GET_MODE (value) == VOIDmode)\n+    h = CONST_DOUBLE_LOW (value) ^ CONST_DOUBLE_HIGH (value);\n+  else\n+    h = real_hash (CONST_DOUBLE_REAL_VALUE (value));\n   return h;\n }\n "}, {"sha": "d746ab61223a77d2ceefc2dd951506637072710a", "filename": "gcc/real.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -2311,6 +2311,47 @@ significand_size (mode)\n \n   return fmt->p * fmt->log2_b;\n }\n+\n+/* Return a hash value for the given real value.  */\n+/* ??? The \"unsigned int\" return value is intended to be hashval_t,\n+   but I didn't want to pull hashtab.h into real.h.  */\n+\n+unsigned int\n+real_hash (r)\n+     const REAL_VALUE_TYPE *r;\n+{\n+  unsigned int h;\n+  size_t i;\n+\n+  h = r->class | (r->sign << 2);\n+  switch (r->class)\n+    {\n+    case rvc_zero:\n+    case rvc_inf:\n+      break;\n+\n+    case rvc_normal:\n+      h |= r->exp << 3;\n+      /* FALLTHRU */\n+\n+    case rvc_nan:\n+      if (sizeof(unsigned long) > sizeof(unsigned int))\n+\tfor (i = 0; i < SIGSZ; ++i)\n+\t  {\n+\t    unsigned long s = r->sig[i];\n+\t    h ^= s ^ (s >> (HOST_BITS_PER_LONG / 2));\n+\t  }\n+      else\n+\tfor (i = 0; i < SIGSZ; ++i)\n+\t  h ^= r->sig[i];\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return h;\n+}\n \f\n /* IEEE single-precision format.  */\n "}, {"sha": "d59e5202a1f87b928aa572b2de0325315d011953", "filename": "gcc/real.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -169,6 +169,8 @@ extern bool real_nan\t\tPARAMS ((REAL_VALUE_TYPE *, const char *,\n \n extern void real_2expN\t\tPARAMS ((REAL_VALUE_TYPE *, int));\n \n+extern unsigned int real_hash\tPARAMS ((const REAL_VALUE_TYPE *));\n+\n /* ====================================================================== */\n /* Crap.  */\n "}, {"sha": "249233cb161c43d80ba642cd4bdd0f56fdb9e60f", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -1010,14 +1010,13 @@ enum label_kind\n #define INTVAL(RTX) XCWINT(RTX, 0, CONST_INT)\n \n /* For a CONST_DOUBLE:\n-   The usual two ints that hold the value.\n-   For a DImode, that is all there are;\n-    and CONST_DOUBLE_LOW is the low-order word and ..._HIGH the high-order.\n-   For a float, the number of ints varies,\n-    and CONST_DOUBLE_LOW is the one that should come first *in memory*.\n-    So use &CONST_DOUBLE_LOW(r) as the address of an array of ints.  */\n+   For a DImode, there are two integers CONST_DOUBLE_LOW is the\n+     low-order word and ..._HIGH the high-order.\n+   For a float, there is a REAL_VALUE_TYPE structure, and \n+     CONST_DOUBLE_REAL_VALUE(r) is a pointer to it.  */\n #define CONST_DOUBLE_LOW(r) XCWINT (r, 0, CONST_DOUBLE)\n #define CONST_DOUBLE_HIGH(r) XCWINT (r, 1, CONST_DOUBLE)\n+#define CONST_DOUBLE_REAL_VALUE(r) ((struct real_value *)&CONST_DOUBLE_LOW(r))\n \n /* For a CONST_VECTOR, return element #n.  */\n #define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)"}, {"sha": "702cf82446d794c5246d61ca0f9432170fce7f60", "filename": "gcc/varasm.c", "status": "modified", "additions": 110, "deletions": 64, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b33600d57ae54591bccaa935d7d837b5318a19/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=46b33600d57ae54591bccaa935d7d837b5318a19", "patch": "@@ -136,13 +136,14 @@ static HOST_WIDE_INT const_alias_set;\n static const char *strip_reg_name\tPARAMS ((const char *));\n static int contains_pointers_p\t\tPARAMS ((tree));\n static void decode_addr_const\t\tPARAMS ((tree, struct addr_const *));\n-static int const_hash\t\t\tPARAMS ((tree));\n+static unsigned int const_hash\t\tPARAMS ((tree));\n+static unsigned int const_hash_1\tPARAMS ((tree));\n static int compare_constant\t\tPARAMS ((tree, tree));\n static tree copy_constant\t\tPARAMS ((tree));\n static void output_constant_def_contents  PARAMS ((tree, int, int));\n static void decode_rtx_const\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t       struct rtx_const *));\n-static int const_hash_rtx\t\tPARAMS ((enum machine_mode, rtx));\n+static unsigned int const_hash_rtx\tPARAMS ((enum machine_mode, rtx));\n static int compare_constant_rtx\n   PARAMS ((enum machine_mode, rtx, struct constant_descriptor_rtx *));\n static struct constant_descriptor_rtx * record_constant_rtx\n@@ -2166,11 +2167,15 @@ struct rtx_const GTY(())\n       HOST_WIDE_INT low;\n     } GTY ((tag (\"0\"))) di;\n \n-    /* The max vector size we have is 8 wide.  This should be enough.  */\n-    struct rtx_const_vec {\n-      HOST_WIDE_INT veclo;\n-      HOST_WIDE_INT vechi; \n-    } GTY ((tag (\"2\"))) vec[16];\n+    /* The max vector size we have is 8 wide; two variants for\n+       integral and floating point vectors.  */\n+    struct rtx_const_int_vec {\n+      HOST_WIDE_INT high;\n+      HOST_WIDE_INT low;\n+    } GTY ((tag (\"2\"))) int_vec[8];\n+\n+    REAL_VALUE_TYPE GTY ((tag (\"3\"))) fp_vec[8];\n+\n   } GTY ((desc (\"%1.kind >= RTX_INT\"), descbits (\"1\"))) un;\n };\n \n@@ -2193,7 +2198,6 @@ struct constant_descriptor_tree GTY(())\n   tree value;\n };\n \n-#define HASHBITS 30\n #define MAX_HASH_TABLE 1009\n static GTY(()) struct constant_descriptor_tree *\n   const_hash_table[MAX_HASH_TABLE];\n@@ -2238,12 +2242,20 @@ const_str_htab_eq (x, y)\n \n /* Compute a hash code for a constant expression.  */\n \n-static int\n+static unsigned int\n const_hash (exp)\n      tree exp;\n+{\n+  return const_hash_1 (exp) % MAX_HASH_TABLE;\n+}\n+\n+static unsigned int\n+const_hash_1 (exp)\n+     tree exp;\n {\n   const char *p;\n-  int len, hi, i;\n+  unsigned int hi;\n+  int len, i;\n   enum tree_code code = TREE_CODE (exp);\n \n   /* Either set P and LEN to the address and len of something to hash and\n@@ -2257,18 +2269,16 @@ const_hash (exp)\n       break;\n \n     case REAL_CST:\n-      p = (char *) &TREE_REAL_CST (exp);\n-      len = sizeof TREE_REAL_CST (exp);\n-      break;\n+      return real_hash (TREE_REAL_CST_PTR (exp));\n \n     case STRING_CST:\n       p = TREE_STRING_POINTER (exp);\n       len = TREE_STRING_LENGTH (exp);\n       break;\n \n     case COMPLEX_CST:\n-      return (const_hash (TREE_REALPART (exp)) * 5\n-\t      + const_hash (TREE_IMAGPART (exp)));\n+      return (const_hash_1 (TREE_REALPART (exp)) * 5\n+\t      + const_hash_1 (TREE_IMAGPART (exp)));\n \n     case CONSTRUCTOR:\n       if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n@@ -2285,23 +2295,11 @@ const_hash (exp)\n \t{\n \t  tree link;\n \n-\t  /* For record type, include the type in the hashing.\n-\t     We do not do so for array types\n-\t     because (1) the sizes of the elements are sufficient\n-\t     and (2) distinct array types can have the same constructor.\n-\t     Instead, we include the array size because the constructor could\n-\t     be shorter.  */\n-\t  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n-\t    hi = ((unsigned long) TREE_TYPE (exp) & ((1 << HASHBITS) - 1))\n-\t      % MAX_HASH_TABLE;\n-\t  else\n-\t    hi = ((5 + int_size_in_bytes (TREE_TYPE (exp)))\n-\t\t  & ((1 << HASHBITS) - 1)) % MAX_HASH_TABLE;\n+\t  hi = 5 + int_size_in_bytes (TREE_TYPE (exp));\n \n \t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n \t    if (TREE_VALUE (link))\n-\t      hi\n-\t\t= (hi * 603 + const_hash (TREE_VALUE (link))) % MAX_HASH_TABLE;\n+\t      hi = hi * 603 + const_hash_1 (TREE_VALUE (link));\n \n \t  return hi;\n \t}\n@@ -2325,34 +2323,29 @@ const_hash (exp)\n \t  hi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;\n \telse\n \t  abort ();\n-\n-\thi &= (1 << HASHBITS) - 1;\n-\thi %= MAX_HASH_TABLE;\n       }\n       return hi;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      return (const_hash (TREE_OPERAND (exp, 0)) * 9\n-\t      + const_hash (TREE_OPERAND (exp, 1)));\n+      return (const_hash_1 (TREE_OPERAND (exp, 0)) * 9\n+\t      + const_hash_1 (TREE_OPERAND (exp, 1)));\n \n     case NOP_EXPR:\n     case CONVERT_EXPR:\n     case NON_LVALUE_EXPR:\n-      return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;\n+      return const_hash_1 (TREE_OPERAND (exp, 0)) * 7 + 2;\n \n     default:\n       /* A language specific constant. Just hash the code.  */\n-      return (int) code % MAX_HASH_TABLE;\n+      return code;\n     }\n \n   /* Compute hashing function */\n   hi = len;\n   for (i = 0; i < len; i++)\n     hi = ((hi * 613) + (unsigned) (p[i]));\n \n-  hi &= (1 << HASHBITS) - 1;\n-  hi %= MAX_HASH_TABLE;\n   return hi;\n }\n \n@@ -2691,7 +2684,7 @@ output_constant_def (exp, defer)\n      to see if any of them describes EXP.  If yes, the descriptor records\n      the label number already assigned.  */\n \n-  hash = const_hash (exp) % MAX_HASH_TABLE;\n+  hash = const_hash (exp);\n \n   for (desc = const_hash_table[hash]; desc; desc = desc->next)\n     if (compare_constant (exp, desc->value))\n@@ -2910,8 +2903,7 @@ struct pool_constant GTY(())\n /* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.\n    The argument is XSTR (... , 0)  */\n \n-#define SYMHASH(LABEL)\t\\\n-  ((((unsigned long) (LABEL)) & ((1 << HASHBITS) - 1))  % MAX_RTX_HASH_TABLE)\n+#define SYMHASH(LABEL)\t(((unsigned long) (LABEL)) % MAX_RTX_HASH_TABLE)\n \f\n /* Initialize constant pool hashing for a new function.  */\n \n@@ -2958,8 +2950,29 @@ decode_rtx_const (mode, x, value)\n       value->kind = RTX_DOUBLE;\n       if (GET_MODE (x) != VOIDmode)\n \t{\n+\t  const REAL_VALUE_TYPE *r = CONST_DOUBLE_REAL_VALUE (x);\n+\n \t  value->mode = GET_MODE (x);\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (value->un.du, x);\n+\n+\t  /* Copy the REAL_VALUE_TYPE by members so that we don't\n+\t     copy garbage from the original structure into our\n+\t     carefully cleaned hashing structure.  */\n+\t  value->un.du.class = r->class;\n+\t  value->un.du.sign = r->sign;\n+\t  switch (r->class)\n+\t    {\n+\t    case rvc_zero:\n+\t    case rvc_inf:\n+\t      break;\n+\t    case rvc_normal:\n+\t      value->un.du.exp = r->exp;\n+\t      /* FALLTHRU */\n+\t    case rvc_nan:\n+\t      memcpy (value->un.du.sig, r->sig, sizeof (r->sig));\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n \t}\n       else\n \t{\n@@ -2971,28 +2984,59 @@ decode_rtx_const (mode, x, value)\n     case CONST_VECTOR:\n       {\n \tint units, i;\n-\trtx elt;\n \n \tunits = CONST_VECTOR_NUNITS (x);\n \tvalue->kind = RTX_VECTOR;\n \tvalue->mode = mode;\n \n-\tfor (i = 0; i < units; ++i)\n+\tif (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n \t  {\n-\t    elt = CONST_VECTOR_ELT (x, i);\n-\t    if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t    for (i = 0; i < units; ++i)\n \t      {\n-\t\tvalue->un.vec[i].veclo = (HOST_WIDE_INT) INTVAL (elt);\n-\t\tvalue->un.vec[i].vechi = 0;\n+\t        rtx elt = CONST_VECTOR_ELT (x, i);\n+\t        if (GET_CODE (elt) == CONST_INT)\n+\t          {\n+\t\t    value->un.int_vec[i].low = INTVAL (elt);\n+\t\t    value->un.int_vec[i].high = 0;\n+\t          }\n+\t\telse\n+\t          {\n+\t\t    value->un.int_vec[i].low = CONST_DOUBLE_LOW (elt);\n+\t\t    value->un.int_vec[i].high = CONST_DOUBLE_HIGH (elt);\n+\t\t  }\n \t      }\n-\t    else if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t  }\n+\telse if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t  {\n+\t    for (i = 0; i < units; ++i)\n \t      {\n-\t\tvalue->un.vec[i].veclo = (HOST_WIDE_INT) CONST_DOUBLE_LOW (elt);\n-\t\tvalue->un.vec[i].vechi = (HOST_WIDE_INT) CONST_DOUBLE_HIGH (elt);\n+\t\tconst REAL_VALUE_TYPE *r\n+\t\t  = CONST_DOUBLE_REAL_VALUE (CONST_VECTOR_ELT (x, i));\n+\t\tREAL_VALUE_TYPE *d = &value->un.fp_vec[i];\n+\n+\t        /* Copy the REAL_VALUE_TYPE by members so that we don't\n+\t           copy garbage from the original structure into our\n+\t           carefully cleaned hashing structure.  */\n+\t        d->class = r->class;\n+\t        d->sign = r->sign;\n+\t        switch (r->class)\n+\t          {\n+\t          case rvc_zero:\n+\t          case rvc_inf:\n+\t            break;\n+\t          case rvc_normal:\n+\t            d->exp = r->exp;\n+\t            /* FALLTHRU */\n+\t          case rvc_nan:\n+\t            memcpy (d->sig, r->sig, sizeof (r->sig));\n+\t            break;\n+\t          default:\n+\t            abort ();\n+\t          }\n \t      }\n-\t    else\n-\t      abort ();\n \t  }\n+\telse\n+\t  abort ();\n       }\n       break;\n \n@@ -3047,7 +3091,7 @@ decode_rtx_const (mode, x, value)\n \t}\n     }\n \n-  if (value->kind > RTX_VECTOR && value->un.addr.base != 0)\n+  if (value->kind >= RTX_INT && value->un.addr.base != 0)\n     switch (GET_CODE (value->un.addr.base))\n       {\n #if 0\n@@ -3079,7 +3123,7 @@ simplify_subtraction (x)\n   decode_rtx_const (GET_MODE (x), XEXP (x, 0), &val0);\n   decode_rtx_const (GET_MODE (x), XEXP (x, 1), &val1);\n \n-  if (val0.kind > RTX_DOUBLE\n+  if (val0.kind >= RTX_INT\n       && val0.kind == val1.kind\n       && val0.un.addr.base == val1.un.addr.base)\n     return GEN_INT (val0.un.addr.offset - val1.un.addr.offset);\n@@ -3089,25 +3133,27 @@ simplify_subtraction (x)\n \n /* Compute a hash code for a constant RTL expression.  */\n \n-static int\n+static unsigned int\n const_hash_rtx (mode, x)\n      enum machine_mode mode;\n      rtx x;\n {\n-  int hi;\n+  union {\n+    struct rtx_const value;\n+    unsigned int data[sizeof(struct rtx_const) / sizeof (unsigned int)];\n+  } u;\n+\n+  unsigned int hi;\n   size_t i;\n \n-  struct rtx_const value;\n-  decode_rtx_const (mode, x, &value);\n+  decode_rtx_const (mode, x, &u.value);\n \n   /* Compute hashing function */\n   hi = 0;\n-  for (i = 0; i < sizeof value / sizeof (int); i++)\n-    hi += ((int *) &value)[i];\n+  for (i = 0; i < ARRAY_SIZE (u.data); i++)\n+    hi = hi * 613 + u.data[i];\n \n-  hi &= (1 << HASHBITS) - 1;\n-  hi %= MAX_RTX_HASH_TABLE;\n-  return hi;\n+  return hi % MAX_RTX_HASH_TABLE;\n }\n \n /* Compare a constant rtl object X with a constant-descriptor DESC."}]}