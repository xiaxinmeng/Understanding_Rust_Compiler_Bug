{"sha": "d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdiNmFlZThjZDM0NjMyOGI2ZjIyZmM0MTVmZmMyOGI5Y2Y4YTI4NQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-05-07T12:39:59Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-05-07T12:39:59Z"}, "message": "[libcpp] Reimplement mkdeps data structures\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-05/msg00293.html\n\t* include/mkdeps.h (deps_write): Add PHONY arg.\n\t(deps_phony_targets): Delete.\n\t* init.c (cpp_finish): Just call deps_write.\n\t* mkdeps.c (struct mkdeps): Add local vector class.  Reimplement\n\tvector handling.\n\t(munge): Munge to static buffer.\n\t(apply_vpath): Adjust vector handling.\n\t(deps_init, deps_free): Use new, delete.\n\t(deps_add_target): Do not munge here.  Record quoting low water mark.\n\t(deps_add_dep): Do not munge here.\n\t(deps_add_vpath): Adjust vector handling.\n\t(make_write_name): New.  Munge on demand here.\n\t(make_write_vec): New.\n\t(deps_phony_targets): Delete.\n\t(make_write): New.\n\t(deps_write): Forward to deps_Write.\n\t(deps_save, deps_restore): Adjust vector handling.\n\nFrom-SVN: r270943", "tree": {"sha": "d5215a9bd23a4458a51a91a6c508044421f4bb88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5215a9bd23a4458a51a91a6c508044421f4bb88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7664eeb700d9e95339f04a1c308a095b53d7a5fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7664eeb700d9e95339f04a1c308a095b53d7a5fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7664eeb700d9e95339f04a1c308a095b53d7a5fb"}], "stats": {"total": 533, "additions": 281, "deletions": 252}, "files": [{"sha": "df8da71f3297205bd592be8264c27951b77deea1", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "patch": "@@ -1,3 +1,23 @@\n+2019-05-07  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* include/mkdeps.h (deps_write): Add PHONY arg.\n+\t(deps_phony_targets): Delete.\n+\t* init.c (cpp_finish): Just call deps_write.\n+\t* mkdeps.c (struct mkdeps): Add local vector class.  Reimplement\n+\tvector handling.\n+\t(munge): Munge to static buffer.\n+\t(apply_vpath): Adjust vector handling.\n+\t(deps_init, deps_free): Use new, delete.\n+\t(deps_add_target): Do not munge here.  Record quoting low water mark.\n+\t(deps_add_dep): Do not munge here.\n+\t(deps_add_vpath): Adjust vector handling.\n+\t(make_write_name): New.  Munge on demand here.\n+\t(make_write_vec): New.\n+\t(deps_phony_targets): Delete.\n+\t(make_write): New.\n+\t(deps_write): Forward to deps_Write.\n+\t(deps_save, deps_restore): Adjust vector handling.\n+\n 2019-05-06  Nathan Sidwell  <nathan@acm.org>\n \n \t* include/mkdeps.h: Rename struct deps to struct mkdeps."}, {"sha": "e0ac21f5d076d71694777432c1ec5b306137941a", "filename": "libcpp/include/mkdeps.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2Finclude%2Fmkdeps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2Finclude%2Fmkdeps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fmkdeps.h?ref=d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "patch": "@@ -57,7 +57,7 @@ extern void deps_add_dep (struct mkdeps *, const char *);\n \n /* Write out a deps buffer to a specified file.  The third argument\n    is the number of columns to word-wrap at (0 means don't wrap).  */\n-extern void deps_write (const struct mkdeps *, FILE *, unsigned int);\n+extern void deps_write (const struct mkdeps *, FILE *, bool, unsigned int);\n \n /* Write out a deps buffer to a file, in a form that can be read back\n    with deps_restore.  Returns nonzero on error, in which case the\n@@ -70,10 +70,4 @@ extern int deps_save (struct mkdeps *, FILE *);\n    in which case that filename is skipped.  */\n extern int deps_restore (struct mkdeps *, FILE *, const char *);\n \n-/* For each dependency *except the first*, emit a dummy rule for that\n-   file, causing it to depend on nothing.  This is used to work around\n-   the intermediate-file deletion misfeature in Make, in some\n-   automatic dependency schemes.  */\n-extern void deps_phony_targets (const struct mkdeps *, FILE *);\n-\n #endif /* ! LIBCPP_MKDEPS_H */"}, {"sha": "c0c9020fdb7fda9578409da518e3cdd6ddae5ff7", "filename": "libcpp/init.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "patch": "@@ -764,14 +764,9 @@ cpp_finish (cpp_reader *pfile, FILE *deps_stream)\n   while (pfile->buffer)\n     _cpp_pop_buffer (pfile);\n \n-  if (CPP_OPTION (pfile, deps.style) != DEPS_NONE\n-      && deps_stream)\n-    {\n-      deps_write (pfile->deps, deps_stream, 72);\n-\n-      if (CPP_OPTION (pfile, deps.phony_targets))\n-\tdeps_phony_targets (pfile->deps, deps_stream);\n-    }\n+  if (CPP_OPTION (pfile, deps.style) != DEPS_NONE && deps_stream)\n+    deps_write (pfile->deps, deps_stream,\n+\t\tCPP_OPTION (pfile, deps.phony_targets), 72);\n \n   /* Report on headers that could use multiple include guards.  */\n   if (CPP_OPTION (pfile, print_include_names))"}, {"sha": "a9a050cf110434a68bc0afb58a2307c283a9b3d5", "filename": "libcpp/mkdeps.c", "status": "modified", "additions": 257, "deletions": 237, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6aee8cd346328b6f22fc415ffc28b9cf8a285/libcpp%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmkdeps.c?ref=d7b6aee8cd346328b6f22fc415ffc28b9cf8a285", "patch": "@@ -24,129 +24,184 @@ along with this program; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"mkdeps.h\"\n \n+/* Not set up to just include std::vector et al, here's a simple\n+   implementation.  */\n+\n /* Keep this structure local to this file, so clients don't find it\n    easy to start making assumptions.  */\n struct mkdeps\n {\n-  const char **targetv;\n-  unsigned int ntargets;\t/* number of slots actually occupied */\n-  unsigned int targets_size;\t/* amt of allocated space - in words */\n-\n-  const char **depv;\n-  unsigned int ndeps;\n-  unsigned int deps_size;\n-\n-  const char **vpathv;\n-  size_t *vpathlv;\n-  unsigned int nvpaths;\n-  unsigned int vpaths_size;\n-};\n-\n-static const char *munge (const char *);\n-\n-/* Given a filename, quote characters in that filename which are\n-   significant to Make.  Note that it's not possible to quote all such\n-   characters - e.g. \\n, %, *, ?, [, \\ (in some contexts), and ~ are\n-   not properly handled.  It isn't possible to get this right in any\n-   current version of Make.  (??? Still true?  Old comment referred to\n-   3.76.1.)  */\n-\n-static const char *\n-munge (const char *filename)\n-{\n-  int len;\n-  const char *p, *q;\n-  char *dst, *buffer;\n-\n-  for (p = filename, len = 0; *p; p++, len++)\n+public:\n+  /* T has trivial cctor & dtor.  */\n+  template <typename T>\n+  class vec\n+  {\n+  private:\n+    T *ary;\n+    unsigned num;\n+    unsigned alloc;\n+\n+  public:\n+    vec ()\n+      : ary (NULL), num (0), alloc (0)\n+      {}\n+    ~vec ()\n+      {\n+\tXDELETEVEC (ary);\n+      }\n+\n+  public:\n+    unsigned size () const\n     {\n-      switch (*p)\n-\t{\n-\tcase ' ':\n-\tcase '\\t':\n-\t  /* GNU make uses a weird quoting scheme for white space.\n-\t     A space or tab preceded by 2N+1 backslashes represents\n-\t     N backslashes followed by space; a space or tab\n-\t     preceded by 2N backslashes represents N backslashes at\n-\t     the end of a file name; and backslashes in other\n-\t     contexts should not be doubled.  */\n-\t  for (q = p - 1; filename <= q && *q == '\\\\';  q--)\n-\t    len++;\n-\t  len++;\n-\t  break;\n-\n-\tcase '$':\n-\t  /* '$' is quoted by doubling it.  */\n-\t  len++;\n-\t  break;\n-\n-\tcase '#':\n-\t  /* '#' is quoted with a backslash.  */\n-\t  len++;\n-\t  break;\n-\t}\n+      return num;\n     }\n-\n-  /* Now we know how big to make the buffer.  */\n-  buffer = XNEWVEC (char, len + 1);\n-\n-  for (p = filename, dst = buffer; *p; p++, dst++)\n+    const T &operator[] (unsigned ix) const\n     {\n-      switch (*p)\n+      return ary[ix];\n+    }\n+    void push (const T &elt)\n+    {\n+      if (num == alloc)\n \t{\n-\tcase ' ':\n-\tcase '\\t':\n-\t  for (q = p - 1; filename <= q && *q == '\\\\';  q--)\n-\t    *dst++ = '\\\\';\n-\t  *dst++ = '\\\\';\n-\t  break;\n-\n-\tcase '$':\n-\t  *dst++ = '$';\n-\t  break;\n-\n-\tcase '#':\n-\t  *dst++ = '\\\\';\n-\t  break;\n-\n-\tdefault:\n-\t  /* nothing */;\n+\t  alloc = alloc ? alloc * 2 : 16;\n+\t  ary = XRESIZEVEC (T, ary, alloc);\n \t}\n-      *dst = *p;\n+      ary[num++] = elt;\n     }\n+  };\n+  struct velt\n+  {\n+    const char *str;\n+    size_t len;\n+  };\n+\n+  mkdeps ()\n+    : quote_lwm (0)\n+  {\n+  }\n+  ~mkdeps ()\n+  {\n+    unsigned int i;\n+\n+    for (i = targets.size (); i--;)\n+      free (const_cast <char *> (targets[i]));\n+    for (i = deps.size (); i--;)\n+      free (const_cast <char *> (deps[i]));\n+    for (i = vpath.size (); i--;)\n+      XDELETEVEC (vpath[i].str);\n+  }\n+\n+public:\n+  vec<const char *> targets;\n+  vec<const char *> deps;\n+  vec<velt> vpath;\n+\n+public:\n+  unsigned short quote_lwm;\n+};\n \n-  *dst = '\\0';\n-  return buffer;\n-}\n+/* Apply Make quoting to STR, TRAIL etc.  Note that it's not possible\n+   to quote all such characters - e.g. \\n, %, *, ?, [, \\ (in some\n+   contexts), and ~ are not properly handled.  It isn't possible to\n+   get this right in any current version of Make.  (??? Still true?\n+   Old comment referred to 3.76.1.)  */\n \n-/* If T begins with any of the partial pathnames listed in d->vpathv,\n-   then advance T to point beyond that pathname.  */\n static const char *\n-apply_vpath (struct mkdeps *d, const char *t)\n+munge (const char *str, const char *trail = NULL, ...)\n {\n-  if (d->vpathv)\n+  static unsigned alloc;\n+  static char *buf;\n+  unsigned dst = 0;\n+  va_list args;\n+  if (trail)\n+    va_start (args, trail);\n+\n+  for (bool first = true; str; first = false)\n     {\n-      unsigned int i;\n-      for (i = 0; i < d->nvpaths; i++)\n+      unsigned slashes = 0;\n+      char c;\n+      for (const char *probe = str; (c = *probe++);)\n \t{\n-\t  if (!filename_ncmp (d->vpathv[i], t, d->vpathlv[i]))\n+\t  if (alloc < dst + 4 + slashes)\n \t    {\n-\t      const char *p = t + d->vpathlv[i];\n-\t      if (!IS_DIR_SEPARATOR (*p))\n-\t\tgoto not_this_one;\n+\t      alloc = alloc * 2 + 32;\n+\t      buf = XRESIZEVEC (char, buf, alloc);\n+\t    }\n \n-\t      /* Do not simplify $(vpath)/../whatever.  ??? Might not\n-\t\t be necessary. */\n-\t      if (p[1] == '.' && p[2] == '.' && IS_DIR_SEPARATOR (p[3]))\n-\t\tgoto not_this_one;\n+\t  switch (c)\n+\t    {\n+\t    case '\\\\':\n+\t      slashes++;\n+\t      break;\n \n-\t      /* found a match */\n-\t      t = t + d->vpathlv[i] + 1;\n+\t    case '$':\n+\t      buf[dst++] = '$';\n+\t      goto def;\n+\n+\t    case ' ':\n+\t    case '\\t':\n+\t      /* GNU make uses a weird quoting scheme for white space.\n+\t\t A space or tab preceded by 2N+1 backslashes\n+\t\t represents N backslashes followed by space; a space\n+\t\t or tab preceded by 2N backslashes represents N\n+\t\t backslashes at the end of a file name; and\n+\t\t backslashes in other contexts should not be\n+\t\t doubled.  */\n+\t      while (slashes--)\n+\t\tbuf[dst++] = '\\\\';\n+\t      /* FALLTHROUGH  */\n+\n+\t    case '#':\n+\t    case ':':\n+\t      buf[dst++] = '\\\\';\n+\t      /* FALLTHROUGH  */\n+\n+\t    default:\n+\t    def:\n+\t      slashes = 0;\n \t      break;\n \t    }\n-\tnot_this_one:;\n+\n+\t  buf[dst++] = c;\n \t}\n+\n+      if (first)\n+\tstr = trail;\n+      else\n+\tstr = va_arg (args, const char *);\n     }\n+  if (trail)\n+    va_end (args);\n+\n+  buf[dst] = 0;\n+  return buf;\n+}\n+\n+/* If T begins with any of the partial pathnames listed in d->vpathv,\n+   then advance T to point beyond that pathname.  */\n+static const char *\n+apply_vpath (struct mkdeps *d, const char *t)\n+{\n+  if (unsigned len = d->vpath.size ())\n+    for (unsigned i = len; i--;)\n+      {\n+\tif (!filename_ncmp (d->vpath[i].str, t, d->vpath[i].len))\n+\t  {\n+\t    const char *p = t + d->vpath[i].len;\n+\t    if (!IS_DIR_SEPARATOR (*p))\n+\t      goto not_this_one;\n+\n+\t    /* Do not simplify $(vpath)/../whatever.  ??? Might not\n+\t       be necessary. */\n+\t    if (p[1] == '.' && p[2] == '.' && IS_DIR_SEPARATOR (p[3]))\n+\t      goto not_this_one;\n+\n+\t    /* found a match */\n+\t    t = t + d->vpath[i].len + 1;\n+\t    break;\n+\t  }\n+      not_this_one:;\n+      }\n \n   /* Remove leading ./ in any case.  */\n   while (t[0] == '.' && IS_DIR_SEPARATOR (t[1]))\n@@ -166,57 +221,28 @@ apply_vpath (struct mkdeps *d, const char *t)\n struct mkdeps *\n deps_init (void)\n {\n-  return XCNEW (struct mkdeps);\n+  return new mkdeps ();\n }\n \n void\n deps_free (struct mkdeps *d)\n {\n-  unsigned int i;\n-\n-  if (d->targetv)\n-    {\n-      for (i = 0; i < d->ntargets; i++)\n-\tfree ((void *) d->targetv[i]);\n-      free (d->targetv);\n-    }\n-\n-  if (d->depv)\n-    {\n-      for (i = 0; i < d->ndeps; i++)\n-\tfree ((void *) d->depv[i]);\n-      free (d->depv);\n-    }\n-\n-  if (d->vpathv)\n-    {\n-      for (i = 0; i < d->nvpaths; i++)\n-\tfree ((void *) d->vpathv[i]);\n-      free (d->vpathv);\n-      free (d->vpathlv);\n-    }\n-\n-  free (d);\n+  delete d;\n }\n \n /* Adds a target T.  We make a copy, so it need not be a permanent\n    string.  QUOTE is true if the string should be quoted.  */\n void\n deps_add_target (struct mkdeps *d, const char *t, int quote)\n {\n-  if (d->ntargets == d->targets_size)\n+  t = apply_vpath (d, t);\n+  if (!quote)\n     {\n-      d->targets_size = d->targets_size * 2 + 4;\n-      d->targetv = XRESIZEVEC (const char *, d->targetv, d->targets_size);\n+      gcc_assert (d->quote_lwm == d->targets.size ());\n+      d->quote_lwm++;\n     }\n \n-  t = apply_vpath (d, t);\n-  if (quote)\n-    t = munge (t);  /* Also makes permanent copy.  */\n-  else\n-    t = xstrdup (t);\n-\n-  d->targetv[d->ntargets++] = t;\n+  d->targets.push (xstrdup (t));\n }\n \n /* Sets the default target if none has been given already.  An empty\n@@ -226,7 +252,7 @@ void\n deps_add_default_target (struct mkdeps *d, const char *tgt)\n {\n   /* Only if we have no targets.  */\n-  if (d->ntargets)\n+  if (d->targets.size ())\n     return;\n \n   if (tgt[0] == '\\0')\n@@ -255,110 +281,106 @@ deps_add_default_target (struct mkdeps *d, const char *tgt)\n void\n deps_add_dep (struct mkdeps *d, const char *t)\n {\n-  t = munge (apply_vpath (d, t));  /* Also makes permanent copy.  */\n+  t = apply_vpath (d, t);\n \n-  if (d->ndeps == d->deps_size)\n-    {\n-      d->deps_size = d->deps_size * 2 + 8;\n-      d->depv = XRESIZEVEC (const char *, d->depv, d->deps_size);\n-    }\n-  d->depv[d->ndeps++] = t;\n+  d->deps.push (xstrdup (t));\n }\n \n void\n deps_add_vpath (struct mkdeps *d, const char *vpath)\n {\n   const char *elem, *p;\n-  char *copy;\n-  size_t len;\n \n   for (elem = vpath; *elem; elem = p)\n     {\n-      for (p = elem; *p && *p != ':'; p++);\n-      len = p - elem;\n-      copy = XNEWVEC (char, len + 1);\n-      memcpy (copy, elem, len);\n-      copy[len] = '\\0';\n+      for (p = elem; *p && *p != ':'; p++)\n+\tcontinue;\n+      mkdeps::velt elt;\n+      elt.len = p - elem;\n+      char *str = XNEWVEC (char, elt.len + 1);\n+      elt.str = str;\n+      memcpy (str, elem, elt.len);\n+      str[elt.len] = '\\0';\n       if (*p == ':')\n \tp++;\n \n-      if (d->nvpaths == d->vpaths_size)\n-\t{\n-\t  d->vpaths_size = d->vpaths_size * 2 + 8;\n-\t  d->vpathv = XRESIZEVEC (const char *, d->vpathv, d->vpaths_size);\n-\t  d->vpathlv = XRESIZEVEC (size_t, d->vpathlv, d->vpaths_size);\n-\t}\n-      d->vpathv[d->nvpaths] = copy;\n-      d->vpathlv[d->nvpaths] = len;\n-      d->nvpaths++;\n+      d->vpath.push (elt);\n     }\n }\n \n-void\n-deps_write (const struct mkdeps *d, FILE *fp, unsigned int colmax)\n-{\n-  unsigned int size, i, column;\n+/* Write NAME, with a leading space to FP, a Makefile.  Advance COL as\n+   appropriate, wrap at COLMAX, returning new column number.  Iff\n+   QUOTE apply quoting.  Append TRAIL.  */\n \n-  column = 0;\n-  if (colmax && colmax < 34)\n-    colmax = 34;\n+static unsigned\n+make_write_name (const char *name, FILE *fp, unsigned col, unsigned colmax,\n+\t\t bool quote = true, const char *trail = NULL)\n+{\n+  if (quote)\n+    name = munge (name, trail, NULL);\n+  unsigned size = strlen (name);\n \n-  for (i = 0; i < d->ntargets; i++)\n+  if (col)\n     {\n-      size = strlen (d->targetv[i]);\n-      column += size;\n-      if (i)\n+      if (colmax && col + size> colmax)\n \t{\n-\t  if (colmax && column > colmax)\n-\t    {\n-\t      fputs (\" \\\\\\n \", fp);\n-\t      column = 1 + size;\n-\t    }\n-\t  else\n-\t    {\n-\t      putc (' ', fp);\n-\t      column++;\n-\t    }\n+\t  fputs (\" \\\\\\n\", fp);\n+\t  col = 0;\n \t}\n-      fputs (d->targetv[i], fp);\n+      col++;\n+      fputs (\" \", fp);\n     }\n \n-  putc (':', fp);\n-  column++;\n+  col += size;\n+  fputs (name, fp);\n \n-  for (i = 0; i < d->ndeps; i++)\n-    {\n-      size = strlen (d->depv[i]);\n-      column += size;\n-      if (colmax && column > colmax)\n-\t{\n-\t  fputs (\" \\\\\\n \", fp);\n-\t  column = 1 + size;\n-\t}\n-      else\n-\t{\n-\t  putc (' ', fp);\n-\t  column++;\n-\t}\n-      fputs (d->depv[i], fp);\n-    }\n-  putc ('\\n', fp);\n+  return col;\n }\n \n-void\n-deps_phony_targets (const struct mkdeps *d, FILE *fp)\n+/* Write all the names in VEC via make_write_name.  */\n+\n+static unsigned\n+make_write_vec (const mkdeps::vec<const char *> &vec, FILE *fp,\n+\t\tunsigned col, unsigned colmax, unsigned quote_lwm = 0,\n+\t\tconst char *trail = NULL)\n {\n-  unsigned int i;\n+  for (unsigned ix = 0; ix != vec.size (); ix++)\n+    col = make_write_name (vec[ix], fp, col, colmax, ix >= quote_lwm, trail);\n+  return col;\n+}\n \n-  for (i = 1; i < d->ndeps; i++)\n+/* Write the dependencies to a Makefile.  If PHONY is true, add\n+   .PHONY targets for all the dependencies too.  */\n+\n+static void\n+make_write (const struct mkdeps *d, FILE *fp, bool phony, unsigned int colmax)\n+{\n+  unsigned column = 0;\n+  if (colmax && colmax < 34)\n+    colmax = 34;\n+\n+  if (d->deps.size ())\n     {\n-      putc ('\\n', fp);\n-      fputs (d->depv[i], fp);\n-      putc (':', fp);\n-      putc ('\\n', fp);\n+      column = make_write_vec (d->targets, fp, 0, colmax, d->quote_lwm);\n+      fputs (\":\", fp);\n+      column++;\n+      column = make_write_vec (d->deps, fp, column, colmax);\n+      fputs (\"\\n\", fp);\n+      if (phony)\n+\tfor (unsigned i = 1; i < d->deps.size (); i++)\n+\t  fprintf (fp, \"%s:\\n\", munge (d->deps[i]));\n     }\n }\n \n+/* Write out dependencies according to the selected format (which is\n+   only Make at the moment).  */\n+\n+void\n+deps_write (const struct mkdeps *d, FILE *fp, bool phony, unsigned int colmax)\n+{\n+  make_write (d, fp, phony, colmax);\n+}\n+\n /* Write out a deps buffer to a file, in a form that can be read back\n    with deps_restore.  Returns nonzero on error, in which case the\n    error number will be in errno.  */\n@@ -367,71 +389,69 @@ int\n deps_save (struct mkdeps *deps, FILE *f)\n {\n   unsigned int i;\n+  size_t size;\n \n   /* The cppreader structure contains makefile dependences.  Write out this\n      structure.  */\n \n   /* The number of dependences.  */\n-  if (fwrite (&deps->ndeps, sizeof (deps->ndeps), 1, f) != 1)\n-      return -1;\n+  size = deps->deps.size ();\n+  if (fwrite (&size, sizeof (size), 1, f) != 1)\n+    return -1;\n+\n   /* The length of each dependence followed by the string.  */\n-  for (i = 0; i < deps->ndeps; i++)\n+  for (i = 0; i < deps->deps.size (); i++)\n     {\n-      size_t num_to_write = strlen (deps->depv[i]);\n-      if (fwrite (&num_to_write, sizeof (size_t), 1, f) != 1)\n-          return -1;\n-      if (fwrite (deps->depv[i], num_to_write, 1, f) != 1)\n-          return -1;\n+      size = strlen (deps->deps[i]);\n+      if (fwrite (&size, sizeof (size), 1, f) != 1)\n+\treturn -1;\n+      if (fwrite (deps->deps[i], size, 1, f) != 1)\n+\treturn -1;\n     }\n \n   return 0;\n }\n \n /* Read back dependency information written with deps_save into\n-   the deps buffer.  The third argument may be NULL, in which case\n+   the deps sizefer.  The third argument may be NULL, in which case\n    the dependency information is just skipped, or it may be a filename,\n    in which case that filename is skipped.  */\n \n int\n deps_restore (struct mkdeps *deps, FILE *fd, const char *self)\n {\n-  unsigned int i, count;\n-  size_t num_to_read;\n-  size_t buf_size = 512;\n-  char *buf;\n+  size_t size;\n+  char *buf = NULL;\n+  size_t buf_size = 0;\n \n   /* Number of dependences.  */\n-  if (fread (&count, 1, sizeof (count), fd) != sizeof (count))\n+  if (fread (&size, sizeof (size), 1, fd) != 1)\n     return -1;\n \n-  buf = XNEWVEC (char, buf_size);\n-\n   /* The length of each dependence string, followed by the string.  */\n-  for (i = 0; i < count; i++)\n+  for (unsigned i = size; i--;)\n     {\n       /* Read in # bytes in string.  */\n-      if (fread (&num_to_read, 1, sizeof (size_t), fd) != sizeof (size_t))\n-\t{\n-\t  free (buf);\n-\t  return -1;\n-\t}\n-      if (buf_size < num_to_read + 1)\n+      if (fread (&size, sizeof (size), 1, fd) != 1)\n+\treturn -1;\n+\n+      if (size >= buf_size)\n \t{\n-\t  buf_size = num_to_read + 1 + 127;\n+\t  buf_size = size + 512;\n \t  buf = XRESIZEVEC (char, buf, buf_size);\n \t}\n-      if (fread (buf, 1, num_to_read, fd) != num_to_read)\n+      if (fread (buf, 1, size, fd) != size)\n \t{\n-\t  free (buf);\n+\t  XDELETEVEC (buf);\n \t  return -1;\n \t}\n-      buf[num_to_read] = '\\0';\n+      buf[size] = 0;\n \n       /* Generate makefile dependencies from .pch if -nopch-deps.  */\n       if (self != NULL && filename_cmp (buf, self) != 0)\n         deps_add_dep (deps, buf);\n     }\n \n-  free (buf);\n+  XDELETEVEC (buf);\n   return 0;\n }"}]}