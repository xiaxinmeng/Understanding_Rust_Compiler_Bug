{"sha": "1df65b8982b0b941a3d6ac1e84437fff08e3462c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRmNjViODk4MmIwYjk0MWEzZDZhYzFlODQ0MzdmZmYwOGUzNDYyYw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-30T08:56:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-30T08:56:23Z"}, "message": "[Ada] Secondary stack implementation clean up\n\nThis patch reimplements the secondary stack runtime support as follows:\n\n   * The compiler interface remains unchanged. This applies to both types and\n     subprograms used by the compiler to create and manage secondary stacks.\n\n   * The secondary stack is no longer a doubly linked list of chunks.\n\n   * Various allocation scenarios are now handled by the same mechanism.\n\nIn addition, the patch introduces a lightweight private interface for testing\npurposes.\n\n------------\n-- Source --\n------------\n\n--  comparator.ads\n\ngeneric\n   type Field_Typ is private;\n   --  The type of the field being compared\n\n   with function Image (Val : Field_Typ) return String;\n   --  Field-to-String converted\n\nprocedure Comparator\n  (Field_Nam    : String;\n   Actual_Val   : Field_Typ;\n   Expected_Val : Field_Typ);\n--  Compare actual value Actual_Val against expected value Expected_Val for\n--  field Field_Nam. Emit an error if this is not the case.\n\n--  comparator.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Comparator\n  (Field_Nam    : String;\n   Actual_Val   : Field_Typ;\n   Expected_Val : Field_Typ)\nis\nbegin\n   if Actual_Val /= Expected_Val then\n      Put_Line (Field_Nam);\n      Put_Line (\"  Actual   :\" & Image (Actual_Val));\n      Put_Line (\"  Expected :\" & Image (Expected_Val));\n   end if;\nend Comparator;\n\n--  debugger.ads\n\npackage Debugger is\n\n   Verbouse : constant Boolean := False;\n   --  Set to True in order to obtain verbouse output\n\n   procedure Output (Msg : String);\n   --  Emit Msg to standard output if Verbouse is True\n\nend Debugger;\n\n--  debugger.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\npackage body Debugger is\n\n   ------------\n   -- Output --\n   ------------\n\n   procedure Output (Msg : String) is\n   begin\n      if Verbouse then\n         Put_Line (Msg);\n      end if;\n   end Output;\nend Debugger;\n\n--  s-sestte.ads\n\npackage System.Secondary_Stack.Tester is\n\n   procedure Test_Dynamic_Stack_Dynamic_Chunks;\n   --  Test various properties of a dynamic stack's dynamic chunks\n\n   procedure Test_Dynamic_Stack_Illegal_Allocations;\n   --  Test whether illegal allocations on a dynamic stack are properly\n   --  detected and reported.\n\n   procedure Test_Dynamic_Stack_Static_Chunk;\n   --  Test various properties of a dynamic stack's static chunk\n\n   procedure Test_Dynamic_Stack_Zero_Chunk_Size;\n   --  Test various properties of a dynamic stack with default chunk size of\n   --  zero.\n\n   procedure Test_Static_Stack_Illegal_Allocations;\n   --  Test whether illegal allocations on a static stack are properly\n   --  detected and reported.\n\n   procedure Test_Static_Stack_Overflow;\n   --  Test whether overflow of a static stack's static chunk is properly\n   --  detected and reported.\n\n   procedure Test_Static_Stack_Static_Chunk;\n   --  Test various properties of a static chunk's static chunk\n\nend System.Secondary_Stack.Tester;\n\n--  s-sestte.adb\n\nwith Ada.Assertions;          use Ada.Assertions;\nwith Ada.Text_IO;             use Ada.Text_IO;\nwith System;                  use System;\nwith System.Parameters;       use System.Parameters;\nwith System.Soft_Links;       use System.Soft_Links;\nwith System.Storage_Elements; use System.Storage_Elements;\n\nwith Comparator;\nwith Debugger;                use Debugger;\n\npackage body System.Secondary_Stack.Tester is\n\n   Units : constant := Standard'Maximum_Alignment;\n   --  Each allocation of the secondary stack is rouded up to the nearest\n   --  multiple of the maximum alignment. This value is called a \"unit\" in\n   --  order to facilitate further allocations.\n\n   -----------------------\n   -- Local subprograms --\n   -----------------------\n\n   procedure Compare_Boolean is\n     new Comparator\n           (Field_Typ => Boolean,\n            Image     => Boolean'Image);\n\n   procedure Compare_Chunk_Count is\n     new Comparator\n           (Field_Typ => Chunk_Count,\n            Image     => Chunk_Count'Image);\n\n   procedure Compare_Chunk_Id is\n     new Comparator\n           (Field_Typ => Chunk_Id,\n            Image     => Chunk_Id'Image);\n\n   procedure Compare_Memory_Index is\n     new Comparator\n           (Field_Typ => Memory_Index,\n            Image     => Memory_Index'Image);\n\n   procedure Compare_Memory_Size is\n     new Comparator\n           (Field_Typ => Memory_Size,\n            Image     => Memory_Size'Image);\n\n   procedure Compare_MSWI is\n     new Comparator\n           (Field_Typ => Memory_Size_With_Invalid,\n            Image     => Memory_Size_With_Invalid'Image);\n\n   procedure Initialize_Stack (Size : Memory_Size);\n   --  Create a new secondary stack for the calling task where the default\n   --  chunk size is Size.\n\n   procedure Match_Chunk\n     (Match_Nam : String;\n      Actual    : Chunk_Info;\n      Expected  : Chunk_Info);\n   --  Check whether actual chunk info Actual matches expected chunk info\n   --  Expected. Match_Nam is the name of the match.\n\n   procedure Match_Pointer\n     (Actual    : Stack_Pointer_Info;\n      Expected  : Stack_Pointer_Info);\n   --  Check whether actual pointer info Actual matches expected pointer info\n   --  Expected.\n\n   procedure Match_Stack\n     (Match_Nam : String;\n      Actual    : Stack_Info;\n      Expected  : Stack_Info);\n   --  Check whether actual stack info Stack matches expected stack info\n   --  Expected. Match_Nam is the name of the match.\n\n   procedure Test_Static_Chunk (Def_Chunk_Size : Memory_Size);\n   --  Common testing for properties of the static chunk for both static and\n   --  dynamic secondary stacks. Def_Chunk_Size denotes the default size of a\n   --  secondary stack chunk. This routine assumes that the secondary stack\n   --  can fit 12 * Units.\n\n   ----------------------\n   -- Initialize_Stack --\n   ----------------------\n\n   procedure Initialize_Stack (Size : Memory_Size) is\n      Stack : SS_Stack_Ptr;\n\n   begin\n      --  Obtain the secondary stack of the calling task\n\n      Stack := Get_Sec_Stack.all;\n\n      --  If the calling task has an existing secodnary stack, destroy it\n      --  because this scenario utilizes a custom secondary stack.\n\n      if Stack /= null then\n\n         --  Destroy the existing secondary stack because it will be replaced\n         --  with a new one.\n\n         SS_Free (Stack);\n         pragma Assert (Stack = null);\n      end if;\n\n      --  Create a brand new empty secondary stack\n\n      SS_Init (Stack, Size);\n      pragma Assert (Stack /= null);\n\n      --  Associate the secondary stack with the calling task\n\n      Set_Sec_Stack (Stack);\n   end Initialize_Stack;\n\n   -----------------\n   -- Match_Chunk --\n   -----------------\n\n   procedure Match_Chunk\n     (Match_Nam : String;\n      Actual    : Chunk_Info;\n      Expected  : Chunk_Info)\n   is\n   begin\n      Output (Match_Nam);\n\n      Compare_MSWI\n        (\"Size\",               Actual.Size,\n                               Expected.Size);\n      Compare_MSWI\n        (\"Size_Up_To_Chunk\",   Actual.Size_Up_To_Chunk,\n                               Expected.Size_Up_To_Chunk);\n   end Match_Chunk;\n\n   -------------------\n   -- Match_Pointer --\n   -------------------\n\n   procedure Match_Pointer\n     (Actual    : Stack_Pointer_Info;\n      Expected  : Stack_Pointer_Info)\n   is\n   begin\n      Compare_Memory_Index\n        (\"Byte\",               Actual.Byte,\n                               Expected.Byte);\n      Compare_Chunk_Id\n        (\"Chunk\",              Actual.Chunk,\n                               Expected.Chunk);\n   end Match_Pointer;\n\n   -----------------\n   -- Match_Stack --\n   -----------------\n\n   procedure Match_Stack\n     (Match_Nam : String;\n      Actual    : Stack_Info;\n      Expected  : Stack_Info)\n   is\n   begin\n      Output (Match_Nam);\n\n      Compare_Memory_Size\n        (\"Default_Chunk_Size\", Actual.Default_Chunk_Size,\n                               Expected.Default_Chunk_Size);\n      Compare_Boolean\n        (\"Freeable\",           Actual.Freeable,\n                               Expected.Freeable);\n      Compare_Memory_Size\n        (\"High_Water_Mark\",    Actual.High_Water_Mark,\n                               Expected.High_Water_Mark);\n      Compare_Chunk_Count\n        (\"Number_Of_Chunks\",   Actual.Number_Of_Chunks,\n                               Expected.Number_Of_Chunks);\n\n      Match_Pointer (Actual.Top, Expected.Top);\n   end Match_Stack;\n\n   ---------------------------------------\n   -- Test_Dynamic_Stack_Dynamic_Chunks --\n   ---------------------------------------\n\n   procedure Test_Dynamic_Stack_Dynamic_Chunks is\n      Def_Chunk_Size : constant Memory_Size := 4 * Units;\n\n      Dummy_1 : Address;\n      Dummy_2 : Address;\n      Dummy_3 : Address;\n      Dummy_4 : Address;\n      Mark    : Mark_Id;\n\n   begin\n      Output (\"#### Test_DSDCs ####\");\n\n      --  Create a brand new empty secondary stack\n      --\n      --       1  2  3  4\n      --    +------------+\n      --    |            |\n      --    +------------+\n\n      Initialize_Stack (Def_Chunk_Size);\n\n      Match_Stack\n        (Match_Nam => \"Empty stack\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 0,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"Empty stack, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --       Mark\n      --       |\n      --       1  2  3  4\n      --    +------------+\n      --    |            |\n      --    +------------+\n\n      Mark := SS_Mark;\n\n      --       Mark                           Top.Byte\n      --       |                              |\n      --       1  2  3  4      1  2  3  4  5  6\n      --    +------------+  +---------------+\n      --    |            |->|###############|\n      --    +------------+  +---------------+\n      --       1  2  3  4      5  6  7  8  9\n      --                                   |\n      --                                   HWM\n\n      SS_Allocate (Dummy_1, 5 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 5u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 9 * Units,\n            Number_Of_Chunks   => 2,\n            Top                => (Byte => (5 * Units) + 1, Chunk => 2)));\n\n      Match_Chunk\n        (Match_Nam => \"After 5u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 5u allocation, chunk 2\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 2),\n         Expected  =>\n           (Size             => 5 * Units,\n            Size_Up_To_Chunk => 4 * Units));\n\n      --       Mark                                     Top.Byte\n      --       |                                        |\n      --       1  2  3  4      1  2  3  4  5      1  2  3  4\n      --    +------------+  +---------------+  +------------+\n      --    |            |->|###############|->|######      |\n      --    +------------+  +---------------+  +------------+\n      --       1  2  3  4      5  6  7  8  9     10 11 12 13\n      --                                             |\n      --                                             HWM\n      --\n      --  Note that the size of Chunk 3 defaults to 4 because the request is\n      --  smaller than the default chunk size.\n\n      SS_Allocate (Dummy_2, 2 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 2u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 11 * Units,\n            Number_Of_Chunks   => 3,\n            Top                => (Byte => (2 * Units) + 1, Chunk => 3)));\n\n      Match_Chunk\n        (Match_Nam => \"After 2u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 2u allocation, chunk 2\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 2),\n         Expected  =>\n           (Size             => 5 * Units,\n            Size_Up_To_Chunk => 4 * Units));\n\n      Match_Chunk\n        (Match_Nam => \"After 2u allocation, chunk 3\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 3),\n         Expected  =>\n           (Size             => 4 * Units,\n            Size_Up_To_Chunk => 9 * Units));\n\n      --       Top.Byte\n      --       |\n      --       1  2  3  4         1  2  3  4  5         1  2  3  4\n      --    +------------+     +---------------+     +------------+\n      --    |            | --> |###############| --> |######      |\n      --    +------------+     +---------------+     +------------+\n      --       1  2  3  4         5  6  7  8  9        10 11 12 13\n      --                                                   |\n      --                                                   HWM\n\n      SS_Release (Mark);\n\n      --                Top.Byte\n      --                |\n      --       1  2  3  4         1  2  3  4  5         1  2  3  4\n      --    +------------+     +---------------+     +------------+\n      --    |#########   | --> |###############| --> |######      |\n      --    +------------+     +---------------+     +------------+\n      --       1  2  3  4         5  6  7  8  9         10 11 12 13\n      --                                                   |\n      --                                                   HWM\n\n      SS_Allocate (Dummy_3, 3 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 3u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 11 * Units,\n            Number_Of_Chunks   => 3,\n            Top                => (Byte => (3 * Units) + 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"After 3u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 3u allocation, chunk 2\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 2),\n         Expected  =>\n           (Size             => 5 * Units,\n            Size_Up_To_Chunk => 4 * Units));\n\n      Match_Chunk\n        (Match_Nam => \"After 3u allocation, chunk 3\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 3),\n         Expected  =>\n           (Size             => 4 * Units,\n            Size_Up_To_Chunk => 9 * Units));\n\n      --                                                  Top.Byte\n      --                                                  |\n      --       1  2  3  4         1  2  3  4  5  6  7  8  9\n      --    +------------+     +------------------------+\n      --    |#########   | --> |########################|\n      --    +------------+     +------------------------+\n      --       1  2  3  4         5  6  7  8  9 10 11 12\n      --                                               |\n      --                                               HWM\n\n      SS_Allocate (Dummy_4, 8 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 8u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 12 * Units,\n            Number_Of_Chunks   => 2,\n            Top                => (Byte => (8 * Units) + 1, Chunk => 2)));\n\n      Match_Chunk\n        (Match_Nam => \"After 8u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 8u allocation, chunk 2\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 2),\n         Expected  =>\n           (Size             => 8 * Units,\n            Size_Up_To_Chunk => 4 * Units));\n\n   exception\n      when others =>\n         Put_Line (\"Test_DSDCs: unexpected exception\");\n   end Test_Dynamic_Stack_Dynamic_Chunks;\n\n   --------------------------------------------\n   -- Test_Dynamic_Stack_Illegal_Allocations --\n   --------------------------------------------\n\n   procedure Test_Dynamic_Stack_Illegal_Allocations is\n      Def_Chunk_Size : constant Memory_Size := 4 * Units;\n\n      Dummy_1 : Address;\n      Dummy_2 : Address;\n\n   begin\n      Output (\"#### Test_DSIA ####\");\n\n      --  Create a brand new empty secondary stack\n      --\n      --       1  2  3  4\n      --    +------------+\n      --    |            |\n      --    +------------+\n\n      Initialize_Stack (Def_Chunk_Size);\n\n      Match_Stack\n        (Match_Nam => \"Empty stack\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 0,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"Empty stack, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --  It should not be possible to allocate an object of size zero\n\n      Zero_Allocation : begin\n         SS_Allocate (Dummy_1, 0);\n         Put_Line (\"Test_DSIA: ERROR: zero allocation succeeded\");\n\n      exception\n         when Assertion_Error =>\n            Match_Stack\n              (Match_Nam => \"After zero allocation\",\n               Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n               Expected  =>\n                 (Default_Chunk_Size => Def_Chunk_Size,\n                  Freeable           => True,\n                  High_Water_Mark    => 0,\n                  Number_Of_Chunks   => 1,\n                  Top                => (Byte => 1, Chunk => 1)));\n\n            Match_Chunk\n              (Match_Nam => \"After zero allocation\",\n               Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n               Expected  =>\n                 (Size             => Def_Chunk_Size,\n                  Size_Up_To_Chunk => 0));\n\n         when others =>\n            Put_Line (\"Test_DSIA: zero allocation: unexpected exception\");\n      end Zero_Allocation;\n\n      --  It should not be possible to allocate an object of negative size\n\n      Negative_Allocation : begin\n         SS_Allocate (Dummy_2, -8);\n         Put_Line (\"Test_DSIA: ERROR: negative allocation succeeded\");\n\n      exception\n         when Assertion_Error =>\n            Match_Stack\n              (Match_Nam => \"After negative allocation\",\n               Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n               Expected  =>\n                 (Default_Chunk_Size => Def_Chunk_Size,\n                  Freeable           => True,\n                  High_Water_Mark    => 0,\n                  Number_Of_Chunks   => 1,\n                  Top                => (Byte => 1, Chunk => 1)));\n\n            Match_Chunk\n              (Match_Nam => \"After negative allocation\",\n               Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n               Expected  =>\n                 (Size             => Def_Chunk_Size,\n                  Size_Up_To_Chunk => 0));\n\n         when others =>\n            Put_Line (\"Test_DSIA: negative allocation: unexpected exception\");\n      end Negative_Allocation;\n\n   exception\n      when others =>\n         Put_Line (\"Test_DSIA: unexpected exception\");\n   end Test_Dynamic_Stack_Illegal_Allocations;\n\n   -------------------------------------\n   -- Test_Dynamic_Stack_Static_Chunk --\n   -------------------------------------\n\n   procedure Test_Dynamic_Stack_Static_Chunk is\n      Def_Chunk_Size : constant Memory_Size := 12 * Units;\n\n      Dummy_1 : Address;\n      Dummy_2 : Address;\n      Dummy_3 : Address;\n      Dummy_4 : Address;\n      Mark_1  : Mark_Id;\n      Mark_2  : Mark_Id;\n\n   begin\n      Output (\"#### Test_DSSC ####\");\n\n      --  Create a brand new empty secondary stack\n      --\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------+\n      --    |                                    |\n      --    +------------------------------------+\n\n      Initialize_Stack  (Def_Chunk_Size);\n      Test_Static_Chunk (Def_Chunk_Size);\n\n   exception\n      when others =>\n         Put_Line (\"Test_DSSC: unexpected exception\");\n   end Test_Dynamic_Stack_Static_Chunk;\n\n   ----------------------------------------\n   -- Test_Dynamic_Stack_Zero_Chunk_Size --\n   ----------------------------------------\n\n   procedure Test_Dynamic_Stack_Zero_Chunk_Size is\n      Def_Chunk_Size : constant Memory_Size := 0;\n\n      Dummy_1 : Address;\n      Dummy_2 : Address;\n      Mark    : Mark_Id;\n\n   begin\n      Output (\"#### Test_DSZCS ####\");\n\n      --  Create a brand new empty secondary stack\n      --\n      --    ++\n      --    ||\n      --    ++\n\n      Initialize_Stack (Def_Chunk_Size);\n\n      Match_Stack\n        (Match_Nam => \"Empty stack\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 0,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"Empty stack, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --       Mark\n      --       |\n      --       1\n      --    ++\n      --    ||\n      --    ++\n\n      Mark := SS_Mark;\n\n      --       Mark         Top.Byte\n      --       |            |\n      --       |   1  2  3  4\n      --    ++  +---------+\n      --    ||->|#########|\n      --    ++  +---------+\n      --           1  2  3\n      --                 |\n      --                 HWM\n\n      SS_Allocate (Dummy_1, 3 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 3u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 3 * Units,\n            Number_Of_Chunks   => 2,\n            Top                => (Byte => (3 * Units) + 1, Chunk => 2)));\n\n      Match_Chunk\n        (Match_Nam => \"After 3u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 3u allocation, chunk 2\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 2),\n         Expected  =>\n           (Size             => 3 * Units,\n            Size_Up_To_Chunk => 0));\n\n      --       Mark                   Top.Byte\n      --       |                      |\n      --       |   1  2  3      1  2  3\n      --    ++  +---------+  +------+\n      --    ||->|#########|->|######|\n      --    ++  +---------+  +------+\n      --           1  2  3      4  5\n      --                           |\n      --                           HWM\n\n      SS_Allocate (Dummy_2, 2 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 2u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 5 * Units,\n            Number_Of_Chunks   => 3,\n            Top                => (Byte => (2 * Units) + 1, Chunk => 3)));\n\n      Match_Chunk\n        (Match_Nam => \"After 2u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 2u allocation, chunk 2\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 2),\n         Expected  =>\n           (Size             => 3 * Units,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 2u allocation, chunk 3\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 3),\n         Expected  =>\n           (Size             => 2 * Units,\n            Size_Up_To_Chunk => 3 * Units));\n\n      --       Top.Byte\n      --       |\n      --       |   1  2  3      1  2\n      --    ++  +---------+  +------+\n      --    ||->|#########|->|######|\n      --    ++  +---------+  +------+\n      --           1  2  3      4  5\n      --                           |\n      --                           HWM\n\n      SS_Release (Mark);\n\n      --                             Top.Byte\n      --                             |\n      --           1  2  3  4  5  6  7\n      --    ++  +------------------+\n      --    ||->|##################|\n      --    ++  +------------------+\n      --           1  2  3  4  5  6\n      --                          |\n      --                          HWM\n\n      SS_Allocate (Dummy_2, 6 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 6u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 6 * Units,\n            Number_Of_Chunks   => 2,\n            Top                => (Byte => (6 * Units) + 1, Chunk => 2)));\n\n      Match_Chunk\n        (Match_Nam => \"After 6u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      Match_Chunk\n        (Match_Nam => \"After 6u allocation, chunk 2\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 2),\n         Expected  =>\n           (Size             => 6 * Units,\n            Size_Up_To_Chunk => 0));\n\n   exception\n      when others =>\n         Put_Line (\"Test_DSZCS: unexpected exception\");\n   end Test_Dynamic_Stack_Zero_Chunk_Size;\n\n   -----------------------\n   -- Test_Static_Chunk --\n   -----------------------\n\n   procedure Test_Static_Chunk (Def_Chunk_Size : Memory_Size) is\n      Dummy_1 : Address;\n      Dummy_2 : Address;\n      Dummy_3 : Address;\n      Dummy_4 : Address;\n      Mark_1  : Mark_Id;\n      Mark_2  : Mark_Id;\n\n   begin\n      --  This routine assumes an empty secondary stack\n\n      Match_Stack\n        (Match_Nam => \"Empty stack\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 0,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"Empty stack, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --                   Top.Byte\n      --                   |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |############\n      --    +------------------------------------. . .\n      --                |\n      --                HWM\n\n      SS_Allocate (Dummy_1, 4 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 4u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 4 * Units,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => (4 * Units) + 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"After 4u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --                   Mark_1\n      --                   Top.Byte\n      --                   |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |############\n      --    +------------------------------------. . .\n      --                |\n      --                HWM\n\n      Mark_1 := SS_Mark;\n\n      --                   Mark_1\n      --                   |              Top.Byte\n      --                   |              |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |###########################\n      --    +------------------------------------. . .\n      --                               |\n      --                               HWM\n\n      SS_Allocate (Dummy_2, 5 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 5u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 9 * Units,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => (9 * Units) + 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"After 5u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --                   Mark_1         Mark_2\n      --                   |              Top.Byte\n      --                   |              |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |###########################\n      --    +------------------------------------. . .\n      --                               |\n      --                               HWM\n\n      Mark_2 := SS_Mark;\n\n      --                   Mark_1         Mark_2\n      --                   |              |     Top.Byte\n      --                   |              |     |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |#################################\n      --    +------------------------------------. . .\n      --                                     |\n      --                                     HWM\n\n      SS_Allocate (Dummy_3, 2 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 2u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 11 * Units,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => (11 * Units) + 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"After 2u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --                   Mark_1\n      --                   |              Top.Byte\n      --                   |              |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |#################################\n      --    +------------------------------------. . .\n      --                                     |\n      --                                     HWM\n\n      SS_Release (Mark_2);\n\n      Match_Stack\n        (Match_Nam => \"After Mark_2 release\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 11 * Units,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => (9 * Units) + 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"After Mark_2 release, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --                   Top.Byte\n      --                   |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |#################################\n      --    +------------------------------------. . .\n      --                                     |\n      --                                     HWM\n\n      SS_Release (Mark_1);\n\n      Match_Stack\n        (Match_Nam => \"After Mark_1 release\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 11 * Units,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => (4 * Units) + 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"After Mark_1 release, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n\n      --                                        Top.Byte\n      --                                        |\n      --       1  2  3  4  5  6  7  8  9 10 11 12\n      --    +------------------------------------. . .\n      --    |#################################\n      --    +------------------------------------. . .\n      --                                     |\n      --                                     HWM\n\n      SS_Allocate (Dummy_4, 6 * Units);\n\n      Match_Stack\n        (Match_Nam => \"After 6u allocation\",\n         Actual    => Get_Stack_Info (Get_Sec_Stack.all),\n         Expected  =>\n           (Default_Chunk_Size => Def_Chunk_Size,\n            Freeable           => True,\n            High_Water_Mark    => 11 * Units,\n            Number_Of_Chunks   => 1,\n            Top                => (Byte => (10 * Units) + 1, Chunk => 1)));\n\n      Match_Chunk\n        (Match_Nam => \"After 6u allocation, chunk 1\",\n         Actual    => Get_Chunk_Info (Get_Sec_Stack.all, 1),\n         Expected  =>\n           (Size             => Def_Chunk_Size,\n            Size_Up_To_Chunk => 0));\n   end Test_Static_Chunk;\n\n   -------------------------------------------\n   -- Test_Static_Stack_Illegal_Allocations --\n   -------------------------------------------\n\n   procedure Test_Static_Stack_Illegal_Allocations is\n      Dummy_1 : Address;\n      Dummy_2 : Address;\n\n   begin\n      Output (\"#### Test_SSIA ####\");\n\n      --  It should not be possible to allocate an object of size zero\n\n      Zero_Allocation : begin\n         SS_Allocate (Dummy_1, 0);\n         Put_Line (\"Test_SSIA: ERROR: zero allocation succeeded\");\n\n      exception\n         when Assertion_Error =>\n            Output (\"After zero allocation\");\n\n         when others =>\n            Put_Line (\"Test_SSIA: zero allocation: unexpected exception\");\n      end Zero_Allocation;\n\n      --  It should not be possible to allocate an object of negative size\n\n      Negative_Allocation : begin\n         SS_Allocate (Dummy_2, -8);\n         Put_Line (\"Test_SSIA: ERROR: negative allocation succeeded\");\n\n      exception\n         when Assertion_Error =>\n            Output (\"After negative allocation\");\n\n         when others =>\n            Put_Line (\"Test_SSIA: negative allocation: unexpected exception\");\n      end Negative_Allocation;\n\n   exception\n      when others =>\n         Put_Line (\"Test_SSIA: unexpected exception\");\n   end Test_Static_Stack_Illegal_Allocations;\n\n   --------------------------------\n   -- Test_Static_Stack_Overflow --\n   --------------------------------\n\n   procedure Test_Static_Stack_Overflow is\n      Info  : constant Stack_Info := Get_Stack_Info (Get_Sec_Stack.all);\n      Dummy : Address;\n\n   begin\n      Output (\"#### Test_SSO ####\");\n\n      --  Try to overflow the static chunk\n\n      Overflow : begin\n         SS_Allocate (Dummy, Storage_Offset (Info.Default_Chunk_Size));\n         Put_Line (\"Test_SSO: ERROR: Overflow not detected\");\n\n      exception\n         when Storage_Error =>\n            Output (\"After overflow\");\n\n         when others =>\n            Put_Line (\"Test_SSO: overflow: unexpected exception\");\n      end Overflow;\n\n   exception\n      when others =>\n         Put_Line (\"Test_SSO: unexpected exception\");\n   end Test_Static_Stack_Overflow;\n\n   ------------------------------------\n   -- Test_Static_Stack_Static_Chunk --\n   ------------------------------------\n\n   procedure Test_Static_Stack_Static_Chunk is\n      Info : Stack_Info;\n\n   begin\n      Output (\"#### Test_SSSC ####\");\n\n      Info := Get_Stack_Info (Get_Sec_Stack.all);\n      Test_Static_Chunk (Info.Default_Chunk_Size);\n\n   exception\n      when others =>\n         Put_Line (\"Test_SSSC: unexpected exception\");\n   end Test_Static_Stack_Static_Chunk;\n\nend System.Secondary_Stack.Tester;\n\n--  main.adb\n\nwith Ada.Text_IO;                   use Ada.Text_IO;\nwith System.Parameters;             use System.Parameters;\nwith System.Secondary_Stack.Tester; use System.Secondary_Stack.Tester;\n\nprocedure Main is\n   task Tester;\n\n   --  The various scenarios are tested within a task because this guarantees\n   --  that on a normal compilation, the task's secondary stack is created on\n   --  the heap and can be safely freed and replaced with a custom one.\n\n   task body Tester is\n   begin\n      if Sec_Stack_Dynamic then\n         Test_Dynamic_Stack_Static_Chunk;\n         Test_Dynamic_Stack_Dynamic_Chunks;\n         Test_Dynamic_Stack_Zero_Chunk_Size;\n         Test_Dynamic_Stack_Illegal_Allocations;\n      else\n         Test_Static_Stack_Static_Chunk;\n         Test_Static_Stack_Overflow;\n         Test_Static_Stack_Illegal_Allocations;\n      end if;\n   end Tester;\n\nbegin null; end Main;\n\n-----------------\n-- Compilation --\n-----------------\n\n$ gnatmake -a -f -q -gnata -gnatws main.adb\n$ ./main\n\n2018-05-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/s-secsta.adb: Reimplement the secondary stack support.\n\t* libgnat/s-secsta.ads: Update the documentation of all routines in the\n\tpublic part of the package.  Reimplement the private part of the\n\tpackage to account for the new secondary stack structure.  Add types\n\tand subprograms for testing purposes.  Add several documentation\n\tsections.\n\nFrom-SVN: r260924", "tree": {"sha": "2b2b06ff2b53607110876d76e93db9aca1044bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b2b06ff2b53607110876d76e93db9aca1044bbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1df65b8982b0b941a3d6ac1e84437fff08e3462c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df65b8982b0b941a3d6ac1e84437fff08e3462c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1df65b8982b0b941a3d6ac1e84437fff08e3462c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df65b8982b0b941a3d6ac1e84437fff08e3462c/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f537fc00c7c21ad07b184aa056df733a4cb87c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f537fc00c7c21ad07b184aa056df733a4cb87c83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f537fc00c7c21ad07b184aa056df733a4cb87c83"}], "stats": {"total": 1649, "additions": 1108, "deletions": 541}, "files": [{"sha": "6c1f204b9e597fddaab1d4b928b4d654fadab012", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df65b8982b0b941a3d6ac1e84437fff08e3462c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df65b8982b0b941a3d6ac1e84437fff08e3462c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1df65b8982b0b941a3d6ac1e84437fff08e3462c", "patch": "@@ -1,3 +1,12 @@\n+2018-05-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* libgnat/s-secsta.adb: Reimplement the secondary stack support.\n+\t* libgnat/s-secsta.ads: Update the documentation of all routines in the\n+\tpublic part of the package.  Reimplement the private part of the\n+\tpackage to account for the new secondary stack structure.  Add types\n+\tand subprograms for testing purposes.  Add several documentation\n+\tsections.\n+\n 2018-05-30  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_aggr.adb, exp_ch3.adb, exp_ch4.adb, exp_ch7.adb, exp_unst.adb,"}, {"sha": "1cb51d0449c21a4c4d44d6057a9376d8e1dd661e", "filename": "gcc/ada/libgnat/s-secsta.adb", "status": "modified", "additions": 750, "deletions": 393, "changes": 1143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df65b8982b0b941a3d6ac1e84437fff08e3462c/gcc%2Fada%2Flibgnat%2Fs-secsta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df65b8982b0b941a3d6ac1e84437fff08e3462c/gcc%2Fada%2Flibgnat%2Fs-secsta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-secsta.adb?ref=1df65b8982b0b941a3d6ac1e84437fff08e3462c", "patch": "@@ -34,386 +34,605 @@ pragma Compiler_Unit_Warning;\n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n \n+with System;                  use System;\n with System.Parameters;       use System.Parameters;\n with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n \n package body System.Secondary_Stack is\n \n-   procedure Free is new Ada.Unchecked_Deallocation (Chunk_Id, Chunk_Ptr);\n+   ------------------------------------\n+   -- Binder Allocated Stack Support --\n+   ------------------------------------\n+\n+   --  When at least one of the following restrictions\n+   --\n+   --    No_Implicit_Heap_Allocations\n+   --    No_Implicit_Task_Allocations\n+   --\n+   --  is in effect, the binder creates a static secondary stack pool, where\n+   --  each stack has a default size. Assignment of these stacks to tasks is\n+   --  performed by SS_Init. The following variables are defined in this unit\n+   --  in order to avoid depending on the binder. Their values are set by the\n+   --  binder.\n+\n+   Binder_SS_Count : Natural;\n+   pragma Export (Ada, Binder_SS_Count, \"__gnat_binder_ss_count\");\n+   --  The number of secondary stacks in the pool created by the binder\n+\n+   Binder_Default_SS_Size : Size_Type;\n+   pragma Export (Ada, Binder_Default_SS_Size, \"__gnat_default_ss_size\");\n+   --  The default secondary stack size as specified by the binder. The value\n+   --  is defined here rather than in init.c or System.Init because the ZFP and\n+   --  Ravenscar-ZFP run-times lack these locations.\n+\n+   Binder_Default_SS_Pool : Address;\n+   pragma Export (Ada, Binder_Default_SS_Pool, \"__gnat_default_ss_pool\");\n+   --  The address of the secondary stack pool created by the binder\n+\n+   Binder_Default_SS_Pool_Index : Natural := 0;\n+   --  Index into the secondary stack pool created by the binder\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   procedure Allocate_Dynamic\n+     (Stack    : SS_Stack_Ptr;\n+      Mem_Size : Memory_Size;\n+      Addr     : out Address);\n+   pragma Inline (Allocate_Dynamic);\n+   --  Allocate enough space on dynamic secondary stack Stack to fit a request\n+   --  of size Mem_Size. Addr denotes the address of the first byte of the\n+   --  allocation.\n+\n+   procedure Allocate_On_Chunk\n+     (Stack      : SS_Stack_Ptr;\n+      Prev_Chunk : SS_Chunk_Ptr;\n+      Chunk      : SS_Chunk_Ptr;\n+      Byte       : Memory_Index;\n+      Mem_Size   : Memory_Size;\n+      Addr       : out Address);\n+   pragma Inline (Allocate_On_Chunk);\n+   --  Allocate enough space on chunk Chunk to fit a request of size Mem_Size.\n+   --  Stack is the owner of the allocation Chunk. Prev_Chunk is the preceding\n+   --  chunk of Chunk. Byte indicates the first free byte within Chunk. Addr\n+   --  denotes the address of the first byte of the allocation. This routine\n+   --  updates the state of Stack.all to reflect the side effects of the\n+   --  allocation.\n+\n+   procedure Allocate_Static\n+     (Stack    : SS_Stack_Ptr;\n+      Mem_Size : Memory_Size;\n+      Addr     : out Address);\n+   pragma Inline (Allocate_Static);\n+   --  Allocate enough space on static secondary stack Stack to fit a request\n+   --  of size Mem_Size. Addr denotes the address of the first byte of the\n+   --  allocation.\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (SS_Chunk, SS_Chunk_Ptr);\n    --  Free a dynamically allocated chunk\n \n-   procedure SS_Allocate_Dynamic\n-     (Stack       : SS_Stack_Ptr;\n-      Mem_Request : SS_Ptr;\n-      Addr        : out Address);\n-   pragma Inline (SS_Allocate_Dynamic);\n-   --  Allocate enough space on dynamic secondary stack Stack to accommodate an\n-   --  object of size Mem_Request. Addr denotes the address where the object is\n-   --  to be placed.\n-\n-   procedure SS_Allocate_Static\n-     (Stack       : SS_Stack_Ptr;\n-      Mem_Request : SS_Ptr;\n-      Addr        : out Address);\n-   pragma Inline (SS_Allocate_Static);\n-   --  Allocate enough space on static secondary stack Stack to accommodate an\n-   --  object of size Mem_Request. Addr denotes the address where the object is\n-   --  to be placed.\n-\n-   -----------------\n-   -- SS_Allocate --\n-   -----------------\n-\n-   procedure SS_Allocate\n-     (Addr         : out Address;\n-      Storage_Size : Storage_Count)\n+   procedure Free is new Ada.Unchecked_Deallocation (SS_Stack, SS_Stack_Ptr);\n+   --  Free a dynamically allocated secondary stack\n+\n+   function Has_Enough_Free_Memory\n+     (Chunk    : SS_Chunk_Ptr;\n+      Byte     : Memory_Index;\n+      Mem_Size : Memory_Size) return Boolean;\n+   pragma Inline (Has_Enough_Free_Memory);\n+   --  Determine whether chunk Chunk has enough room to fit a memory request of\n+   --  size Mem_Size, starting from the first free byte of the chunk denoted by\n+   --  Byte.\n+\n+   function Number_Of_Chunks (Stack : SS_Stack_Ptr) return Chunk_Count;\n+   pragma Inline (Number_Of_Chunks);\n+   --  Count the number of static and dynamic chunks of secondary stack Stack\n+\n+   function Size_Up_To_And_Including (Chunk : SS_Chunk_Ptr) return Memory_Size;\n+   pragma Inline (Size_Up_To_And_Including);\n+   --  Calculate the size of secondary stack which houses chunk Chunk, from the\n+   --  start of the secondary stack up to and including Chunk itself. The size\n+   --  includes the following kinds of memory:\n+   --\n+   --    * Free memory in used chunks due to alignment holes\n+   --    * Occupied memory by allocations\n+   --\n+   --  This is a constant time operation, regardless of the secondary stack's\n+   --  nature.\n+\n+   function Top_Chunk_Id (Stack : SS_Stack_Ptr) return Chunk_Id_With_Invalid;\n+   pragma Inline (Top_Chunk_Id);\n+   --  Obtain the Chunk_Id of the chunk indicated by secondary stack Stack's\n+   --  pointer.\n+\n+   function Used_Memory_Size (Stack : SS_Stack_Ptr) return Memory_Size;\n+   pragma Inline (Used_Memory_Size);\n+   --  Calculate the size of stack Stack's occupied memory usage. This includes\n+   --  the following kinds of memory:\n+   --\n+   --    * Free memory in used chunks due to alignment holes\n+   --    * Occupied memory by allocations\n+   --\n+   --  This is a constant time operation, regardless of the secondary stack's\n+   --  nature.\n+\n+   ----------------------\n+   -- Allocate_Dynamic --\n+   ----------------------\n+\n+   procedure Allocate_Dynamic\n+     (Stack    : SS_Stack_Ptr;\n+      Mem_Size : Memory_Size;\n+      Addr     : out Address)\n    is\n-      function Round_Up (Size : Storage_Count) return SS_Ptr;\n-      pragma Inline (Round_Up);\n-      --  Round up Size to the nearest multiple of the maximum alignment on the\n-      --  target.\n+      function Allocate_New_Chunk return SS_Chunk_Ptr;\n+      pragma Inline (Allocate_New_Chunk);\n+      --  Create a new chunk which is big enough to fit a request of size\n+      --  Mem_Size.\n \n-      function Round_Up_Overflows (Size : Storage_Count) return Boolean;\n-      pragma Inline (Round_Up_Overflows);\n-      --  Determine whether a round up of Size to the nearest multiple of the\n-      --  maximum alignment will overflow the operation.\n-\n-      --------------\n-      -- Round_Up --\n-      --------------\n+      ------------------------\n+      -- Allocate_New_Chunk --\n+      ------------------------\n \n-      function Round_Up (Size : Storage_Count) return SS_Ptr is\n-         Max_Align : constant SS_Ptr := SS_Ptr (Standard'Maximum_Alignment);\n+      function Allocate_New_Chunk return SS_Chunk_Ptr is\n+         Chunk_Size : Memory_Size;\n \n       begin\n-         return ((SS_Ptr (Size) + Max_Align - 1) / Max_Align) * Max_Align;\n-      end Round_Up;\n+         --  The size of the new chunk must fit the memory request precisely.\n+         --  In the case where the memory request is way too small, use the\n+         --  default chunk size. This avoids creating multiple tiny chunks.\n \n-      ------------------------\n-      -- Round_Up_Overflows --\n-      ------------------------\n+         Chunk_Size := Mem_Size;\n \n-      function Round_Up_Overflows (Size : Storage_Count) return Boolean is\n-         Max_Align : constant Storage_Count := Standard'Maximum_Alignment;\n+         if Chunk_Size < Stack.Default_Chunk_Size then\n+            Chunk_Size := Stack.Default_Chunk_Size;\n+         end if;\n \n-      begin\n-         return Storage_Count (SS_Ptr'Last) - Max_Align < Size;\n-      end Round_Up_Overflows;\n+         return new SS_Chunk (Chunk_Size);\n \n-      --  Local variables\n+      --  The creation of the new chunk may exhaust the heap. Raise a new\n+      --  Storage_Error to indicate that the secondary stack is exhausted\n+      --  as well.\n \n-      Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n-      --  The secondary stack of the current task\n+      exception\n+         when Storage_Error =>\n+            raise Storage_Error with \"secondary stack exhausted\";\n+      end Allocate_New_Chunk;\n+\n+      --  Local variables\n \n-      Mem_Request : SS_Ptr;\n+      Next_Chunk : SS_Chunk_Ptr;\n \n-   --  Start of processing for SS_Allocate\n+   --  Start of processing for Allocate_Dynamic\n \n    begin\n-      --  It should not be possible to allocate an object of size zero\n+      --  Determine whether the chunk indicated by the stack pointer is big\n+      --  enough to fit the memory request and if it is, allocate on it.\n+\n+      if Has_Enough_Free_Memory\n+           (Chunk    => Stack.Top.Chunk,\n+            Byte     => Stack.Top.Byte,\n+            Mem_Size => Mem_Size)\n+      then\n+         Allocate_On_Chunk\n+           (Stack      => Stack,\n+            Prev_Chunk => null,\n+            Chunk      => Stack.Top.Chunk,\n+            Byte       => Stack.Top.Byte,\n+            Mem_Size   => Mem_Size,\n+            Addr       => Addr);\n \n-      pragma Assert (Storage_Size > 0);\n+         return;\n+      end if;\n \n-      --  Round up the requested allocation size to the nearest multiple of the\n-      --  maximum alignment value for the target. This ensures efficient stack\n-      --  access. Check that the rounding operation does not overflow SS_Ptr.\n+      --  At this point it is known that the chunk indicated by the stack\n+      --  pointer is not big enough to fit the memory request. Examine all\n+      --  subsequent chunks, and apply the following criteria:\n+      --\n+      --    * If the current chunk is too small, free it\n+      --\n+      --    * If the current chunk is big enough, allocate on it\n+      --\n+      --  This ensures that no space is wasted. The process is costly, however\n+      --  allocation is costly in general. Paying the price here keeps routines\n+      --  SS_Mark and SS_Release cheap.\n \n-      if Round_Up_Overflows (Storage_Size) then\n-         raise Storage_Error;\n-      end if;\n+      while Stack.Top.Chunk.Next /= null loop\n \n-      Mem_Request := Round_Up (Storage_Size);\n+         --  The current chunk is big enough to fit the memory request,\n+         --  allocate on it.\n \n-      if Sec_Stack_Dynamic then\n-         SS_Allocate_Dynamic (Stack, Mem_Request, Addr);\n+         if Has_Enough_Free_Memory\n+              (Chunk    => Stack.Top.Chunk.Next,\n+               Byte     => Stack.Top.Chunk.Next.Memory'First,\n+               Mem_Size => Mem_Size)\n+         then\n+            Allocate_On_Chunk\n+              (Stack      => Stack,\n+               Prev_Chunk => Stack.Top.Chunk,\n+               Chunk      => Stack.Top.Chunk.Next,\n+               Byte       => Stack.Top.Chunk.Next.Memory'First,\n+               Mem_Size   => Mem_Size,\n+               Addr       => Addr);\n \n-      else\n-         SS_Allocate_Static (Stack, Mem_Request, Addr);\n-      end if;\n-   end SS_Allocate;\n+            return;\n+\n+         --  Otherwise the chunk is too small, free it\n \n-   -------------------------\n-   -- SS_Allocate_Dynamic --\n-   -------------------------\n+         else\n+            Next_Chunk := Stack.Top.Chunk.Next.Next;\n+\n+            --  Unchain the chunk from the stack. This keeps the next candidate\n+            --  chunk situated immediately after Top.Chunk.\n+            --\n+            --    Top.Chunk     Top.Chunk.Next   Top.Chunk.Next.Next\n+            --        |               |              (Next_Chunk)\n+            --        v               v                   v\n+            --    +-------+     +------------+     +--------------+\n+            --    |       | --> |            | --> |              |\n+            --    +-------+     +------------+     +--------------+\n+            --                   to be freed\n+\n+            Free (Stack.Top.Chunk.Next);\n+            Stack.Top.Chunk.Next := Next_Chunk;\n+         end if;\n+      end loop;\n \n-   procedure SS_Allocate_Dynamic\n-     (Stack       : SS_Stack_Ptr;\n-      Mem_Request : SS_Ptr;\n-      Addr        : out Address)\n+      --  At this point one of the following outcomes took place:\n+      --\n+      --    * Top.Chunk is the last chunk in the stack\n+      --\n+      --    * Top.Chunk was not the last chunk originally. It was followed by\n+      --      chunks which were too small and as a result were deleted, thus\n+      --      making Top.Chunk the last chunk in the stack.\n+      --\n+      --  Either way, nothing should be hanging off the chunk indicated by the\n+      --  stack pointer.\n+\n+      pragma Assert (Stack.Top.Chunk.Next = null);\n+\n+      --  Create a new chunk big enough to fit the memory request, and allocate\n+      --  on it.\n+\n+      Stack.Top.Chunk.Next := Allocate_New_Chunk;\n+\n+      Allocate_On_Chunk\n+        (Stack      => Stack,\n+         Prev_Chunk => Stack.Top.Chunk,\n+         Chunk      => Stack.Top.Chunk.Next,\n+         Byte       => Stack.Top.Chunk.Next.Memory'First,\n+         Mem_Size   => Mem_Size,\n+         Addr       => Addr);\n+   end Allocate_Dynamic;\n+\n+   -----------------------\n+   -- Allocate_On_Chunk --\n+   -----------------------\n+\n+   procedure Allocate_On_Chunk\n+     (Stack      : SS_Stack_Ptr;\n+      Prev_Chunk : SS_Chunk_Ptr;\n+      Chunk      : SS_Chunk_Ptr;\n+      Byte       : Memory_Index;\n+      Mem_Size   : Memory_Size;\n+      Addr       : out Address)\n    is\n-      procedure Delete_Chunk (Chunk : in out Chunk_Ptr);\n-      pragma Inline (Delete_Chunk);\n-      --  Unchain chunk Chunk from the secondary stack and delete it\n+      New_High_Water_Mark : Memory_Size;\n \n-      procedure Link_Chunks (First : Chunk_Ptr; Second : Chunk_Ptr);\n-      pragma Inline (Link_Chunks);\n-      --  Link chunk Second to chunk First\n+   begin\n+      --  The allocation occurs on a reused or a brand new chunk. Such a chunk\n+      --  must always be connected to some previous chunk.\n \n-      procedure Update_Max;\n-      pragma Inline (Update_Max);\n-      --  Raise the Max watermark if needed, based on Stack.Top\n+      if Prev_Chunk /= null then\n+         pragma Assert (Prev_Chunk.Next = Chunk);\n \n-      ------------------\n-      -- Delete_Chunk --\n-      ------------------\n+         --  Update the Size_Up_To_Chunk because this value is invalidated for\n+         --  reused and new chunks.\n+         --\n+         --                         Prev_Chunk          Chunk\n+         --                             v                 v\n+         --    . . . . . . .     +--------------+     +--------\n+         --                . --> |##############| --> |\n+         --    . . . . . . .     +--------------+     +--------\n+         --                       |            |\n+         --    -------------------+------------+\n+         --      Size_Up_To_Chunk      Size\n+         --\n+         --  The Size_Up_To_Chunk is equal to the size of the whole stack up to\n+         --  the previous chunk, plus the size of the previous chunk itself.\n \n-      procedure Delete_Chunk (Chunk : in out Chunk_Ptr) is\n-         Next : constant Chunk_Ptr := Chunk.Next;\n-         Prev : constant Chunk_Ptr := Chunk.Prev;\n+         Chunk.Size_Up_To_Chunk := Size_Up_To_And_Including (Prev_Chunk);\n+      end if;\n \n-      begin\n-         --  A chunk must always succeed another chunk. In the base case, that\n-         --  chunk is the Internal_Chunk.\n+      --  The chunk must have enough room to fit the memory request. If this is\n+      --  not the case, then a previous step picked the wrong chunk.\n \n-         pragma Assert (Prev /= null);\n+      pragma Assert (Has_Enough_Free_Memory (Chunk, Byte, Mem_Size));\n \n-         Chunk.Next := null;    --        Chunk --> X\n-         Chunk.Prev := null;    --  X <-- Chunk\n+      --  The first byte of the allocation is the first free byte within the\n+      --  chunk.\n \n-         --  The chunk being deleted is the last chunk\n+      Addr := Chunk.Memory (Byte)'Address;\n \n-         if Next = null then\n-            Prev.Next := null;  --  Prev --> X\n+      --  The chunk becomes the chunk indicated by the stack pointer. This is\n+      --  either the currently indicated chunk, an existing chunk, or a brand\n+      --  new chunk.\n \n-         --  Otherwise link both the Prev and Next chunks\n+      Stack.Top.Chunk := Chunk;\n \n-         else\n-            Link_Chunks (Prev, Next);\n-         end if;\n+      --  The next free byte is immediately after the memory request\n+      --\n+      --          Addr     Top.Byte\n+      --          |        |\n+      --    +-----|--------|----+\n+      --    |##############|    |\n+      --    +-------------------+\n \n-         Free (Chunk);\n-      end Delete_Chunk;\n+      --  ??? this calculation may overflow on 32bit targets\n \n-      -----------------\n-      -- Link_Chunks --\n-      -----------------\n+      Stack.Top.Byte := Byte + Mem_Size;\n \n-      procedure Link_Chunks (First : Chunk_Ptr; Second : Chunk_Ptr) is\n-      begin\n-         First.Next  := Second;  --  First --> Second\n-         Second.Prev := First;   --  First <-- Second\n-      end Link_Chunks;\n+      --  At this point the next free byte cannot go beyond the memory capacity\n+      --  of the chunk indicated by the stack pointer, except when the chunk is\n+      --  full, in which case it indicates the byte beyond the chunk. Ensure\n+      --  that the occupied memory is at most as much as the capacity of the\n+      --  chunk. Top.Byte - 1 denotes the last occupied byte.\n+\n+      pragma Assert (Stack.Top.Byte - 1 <= Stack.Top.Chunk.Size);\n+\n+      --  Calculate the new high water mark now that the memory request has\n+      --  been fulfilled, and update if necessary. The new high water mark is\n+      --  technically the size of the used memory by the whole stack.\n+\n+      New_High_Water_Mark := Used_Memory_Size (Stack);\n+\n+      if New_High_Water_Mark > Stack.High_Water_Mark then\n+         Stack.High_Water_Mark := New_High_Water_Mark;\n+      end if;\n+   end Allocate_On_Chunk;\n+\n+   ---------------------\n+   -- Allocate_Static --\n+   ---------------------\n+\n+   procedure Allocate_Static\n+     (Stack    : SS_Stack_Ptr;\n+      Mem_Size : Memory_Size;\n+      Addr     : out Address)\n+   is\n+   begin\n+      --  Static secondary stack allocations are performed only on the static\n+      --  chunk. There should be no dynamic chunks following the static chunk.\n+\n+      pragma Assert (Stack.Top.Chunk = Stack.Static_Chunk'Access);\n+      pragma Assert (Stack.Top.Chunk.Next = null);\n+\n+      --  Raise Storage_Error if the static chunk does not have enough room to\n+      --  fit the memory request. This indicates that the stack is about to be\n+      --  depleted.\n+\n+      if not Has_Enough_Free_Memory\n+               (Chunk    => Stack.Top.Chunk,\n+                Byte     => Stack.Top.Byte,\n+                Mem_Size => Mem_Size)\n+      then\n+         raise Storage_Error with \"secondary stack exhaused\";\n+      end if;\n+\n+      Allocate_On_Chunk\n+        (Stack      => Stack,\n+         Prev_Chunk => null,\n+         Chunk      => Stack.Top.Chunk,\n+         Byte       => Stack.Top.Byte,\n+         Mem_Size   => Mem_Size,\n+         Addr       => Addr);\n+   end Allocate_Static;\n+\n+   --------------------\n+   -- Get_Chunk_Info --\n+   --------------------\n+\n+   function Get_Chunk_Info\n+     (Stack : SS_Stack_Ptr;\n+      C_Id  : Chunk_Id) return Chunk_Info\n+   is\n+      function Find_Chunk return SS_Chunk_Ptr;\n+      pragma Inline (Find_Chunk);\n+      --  Find the chunk which corresponds to Id. Return null if no such chunk\n+      --  exists.\n \n       ----------------\n-      -- Update_Max --\n+      -- Find_Chunk --\n       ----------------\n \n-      procedure Update_Max is\n+      function Find_Chunk return SS_Chunk_Ptr is\n+         Chunk : SS_Chunk_Ptr;\n+         Id    : Chunk_Id;\n+\n       begin\n-         if Stack.Top > Stack.Max then\n-            Stack.Max := Stack.Top;\n-         end if;\n-      end Update_Max;\n+         Chunk := Stack.Static_Chunk'Access;\n+         Id    := 1;\n+         while Chunk /= null loop\n+            if Id = C_Id then\n+               return Chunk;\n+            end if;\n+\n+            Chunk := Chunk.Next;\n+            Id    := Id + 1;\n+         end loop;\n+\n+         return null;\n+      end Find_Chunk;\n \n       --  Local variables\n \n-      Chunk      : Chunk_Ptr;\n-      Chunk_Size : SS_Ptr;\n-      Next_Chunk : Chunk_Ptr;\n-      Top_Chunk  : Chunk_Ptr;\n+      Chunk : constant SS_Chunk_Ptr := Find_Chunk;\n \n-   --  Start of processing for SS_Allocate_Dynamic\n+   --  Start of processing for Get_Chunk_Info\n \n    begin\n-      --  Find the chunk where Top lives by going in reverse, starting from\n-      --  Current_Chunk.\n-      --\n-      --          Top\n-      --          |\n-      --    +--------+ --> +----------+ --> +-----------------+\n-      --    |#####|  |     |####      |     |###########      |\n-      --    +--------+ <-- +----------+ <-- +-----------------+\n-      --                                             ^\n-      --                                        Current_Chunk\n-\n-      Top_Chunk := Stack.Current_Chunk;\n-\n-      while Top_Chunk.First > Stack.Top loop\n-         Top_Chunk := Top_Chunk.Prev;\n-      end loop;\n-\n-      --  Inspect Top_Chunk to determine whether the remaining space is big\n-      --  enough to fit the object.\n-      --\n-      --      Addr Top\n-      --      |    |\n-      --    +--------+ ...\n-      --    |######| |\n-      --    +--------+ ...\n-      --         ^\n-      --     Top_Chunk\n-\n-      if Top_Chunk.Last - Stack.Top + 1 >= Mem_Request then\n-         Addr      := Top_Chunk.Mem (Stack.Top)'Address;\n-         Stack.Top := Stack.Top + Mem_Request;\n-         Update_Max;\n+      if Chunk = null then\n+         return Invalid_Chunk;\n \n-         return;\n+      else\n+         return (Size             => Chunk.Size,\n+                 Size_Up_To_Chunk => Chunk.Size_Up_To_Chunk);\n       end if;\n+   end Get_Chunk_Info;\n \n-      --  At this point it is known that Top_Chunk is not big enough to fit\n-      --  the object. Examine subsequent chunks using the following criteria:\n-      --\n-      --    * If a chunk is too small to fit the object, delete it\n-      --\n-      --    * If a chunk is big enough to fit the object, use that chunk\n+   --------------------\n+   -- Get_Stack_Info --\n+   --------------------\n \n-      Chunk := Top_Chunk.Next;\n-      while Chunk /= null loop\n+   function Get_Stack_Info (Stack : SS_Stack_Ptr) return Stack_Info is\n+      Info : Stack_Info;\n \n-         --  Capture the next chunk in case the current one is deleted\n+   begin\n+      Info.Default_Chunk_Size := Stack.Default_Chunk_Size;\n+      Info.Freeable           := Stack.Freeable;\n+      Info.High_Water_Mark    := Stack.High_Water_Mark;\n+      Info.Number_Of_Chunks   := Number_Of_Chunks (Stack);\n+      Info.Top.Byte           := Stack.Top.Byte;\n+      Info.Top.Chunk          := Top_Chunk_Id (Stack);\n+\n+      return Info;\n+   end Get_Stack_Info;\n+\n+   ----------------------------\n+   -- Has_Enough_Free_Memory --\n+   ----------------------------\n+\n+   function Has_Enough_Free_Memory\n+     (Chunk    : SS_Chunk_Ptr;\n+      Byte     : Memory_Index;\n+      Mem_Size : Memory_Size) return Boolean\n+   is\n+   begin\n+      --  Byte - 1 denotes the last occupied byte. Subtracting that byte from\n+      --  the memory capacity of the chunk yields the size of the free memory\n+      --  within the chunk. The chunk can fit the request as long as the free\n+      --  memory is as big as the request.\n \n-         Next_Chunk := Chunk.Next;\n+      return Chunk.Size - (Byte - 1) >= Mem_Size;\n+   end Has_Enough_Free_Memory;\n \n-         --  The current chunk is too small to fit the object and must be\n-         --  deleted to avoid creating a hole in the secondary stack. Note\n-         --  that this may delete the Current_Chunk.\n+   ----------------------\n+   -- Number_Of_Chunks --\n+   ----------------------\n \n-         if Chunk.Last - Chunk.First + 1 < Mem_Request then\n-            Delete_Chunk (Chunk);\n+   function Number_Of_Chunks (Stack : SS_Stack_Ptr) return Chunk_Count is\n+      Chunk : SS_Chunk_Ptr;\n+      Count : Chunk_Count;\n \n-         --  Otherwise the chunk is big enough to fit the object. Use this\n-         --  chunk to store the object.\n-         --\n-         --                    Addr   Top\n-         --                    |      |\n-         --    +--------+ --> +----------+ ... ...................\n-         --    |#####   |     |#######|  |     :                 :\n-         --    +--------+ <-- +----------+ ... ...................\n-         --        ^               ^                    ^\n-         --    Top_Chunk         Chunk             Current_Chunk\n+   begin\n+      Chunk := Stack.Static_Chunk'Access;\n+      Count := 0;\n+      while Chunk /= null loop\n+         Chunk := Chunk.Next;\n+         Count := Count + 1;\n+      end loop;\n \n-         else\n-            Addr      := Chunk.Mem (Chunk.First)'Address;\n-            Stack.Top := Chunk.First + Mem_Request;\n-            Update_Max;\n+      return Count;\n+   end Number_Of_Chunks;\n \n-            return;\n-         end if;\n+   ------------------------------\n+   -- Size_Up_To_And_Including --\n+   ------------------------------\n \n-         Chunk := Next_Chunk;\n-      end loop;\n+   function Size_Up_To_And_Including\n+     (Chunk : SS_Chunk_Ptr) return Memory_Size\n+   is\n+   begin\n+      return Chunk.Size_Up_To_Chunk + Chunk.Size;\n+   end Size_Up_To_And_Including;\n \n-      --  At this point one of the following outcomes took place:\n-      --\n-      --    * Top_Chunk is the last chunk in the secondary stack\n-      --\n-      --    * Top_Chunk was not the last chunk originally. It was followed by\n-      --      chunks which were too small to fit the object and as a result\n-      --      were deleted, thus making Top_Chunk the last chunk.\n+   -----------------\n+   -- SS_Allocate --\n+   -----------------\n \n-      pragma Assert (Top_Chunk.Next = null);\n+   procedure SS_Allocate\n+     (Addr         : out Address;\n+      Storage_Size : Storage_Count)\n+   is\n+      function Round_Up (Size : Storage_Count) return Memory_Size;\n+      pragma Inline (Round_Up);\n+      --  Round Size up to the nearest multiple of the maximum alignment\n \n-      --  Create a new chunk big enough to fit the object. The size of the\n-      --  chunk must be at least the minimum default size.\n+      --------------\n+      -- Round_Up --\n+      --------------\n \n-      if Mem_Request <= Stack.Size then\n-         Chunk_Size := Stack.Size;\n-      else\n-         Chunk_Size := Mem_Request;\n-      end if;\n+      function Round_Up (Size : Storage_Count) return Memory_Size is\n+         Algn_MS : constant Memory_Size := Standard'Maximum_Alignment;\n+         Size_MS : constant Memory_Size := Memory_Size (Size);\n \n-      --  Check that the indexing limits are not exceeded\n+      begin\n+         --  Detect a case where the Storage_Size is very large and may yield\n+         --  a rounded result which is outside the range of Chunk_Memory_Size.\n+         --  Treat this case as secondary-stack depletion.\n \n-      if SS_Ptr'Last - Top_Chunk.Last < Chunk_Size then\n-         raise Storage_Error;\n-      end if;\n+         if Memory_Size'Last - Algn_MS < Size_MS then\n+            raise Storage_Error with \"secondary stack exhaused\";\n+         end if;\n \n-      Chunk :=\n-        new Chunk_Id\n-              (First => Top_Chunk.Last + 1,\n-               Last  => Top_Chunk.Last + Chunk_Size);\n+         return ((Size_MS + Algn_MS - 1) / Algn_MS) * Algn_MS;\n+      end Round_Up;\n \n-      --  Grow the secondary stack by adding the new chunk to Top_Chunk. The\n-      --  new chunk also becomes the Current_Chunk because it is the last in\n-      --  the list of chunks.\n-      --\n-      --                    Addr      Top\n-      --                    |         |\n-      --    +--------+ --> +-------------+\n-      --    |#####   |     |##########|  |\n-      --    +--------+ <-- +-------------+\n-      --        ^                ^\n-      --    Top_Chunk       Current_Chunk\n-\n-      Link_Chunks (Top_Chunk, Chunk);\n-      Stack.Current_Chunk := Chunk;\n-\n-      Addr      := Chunk.Mem (Chunk.First)'Address;\n-      Stack.Top := Chunk.First + Mem_Request;\n-      Update_Max;\n-   end SS_Allocate_Dynamic;\n-\n-   ------------------------\n-   -- SS_Allocate_Static --\n-   ------------------------\n-\n-   procedure SS_Allocate_Static\n-     (Stack       : SS_Stack_Ptr;\n-      Mem_Request : SS_Ptr;\n-      Addr        : out Address)\n-   is\n-   begin\n-      --  Check if the max stack usage is increasing\n+      --  Local variables\n \n-      if Stack.Max - Stack.Top < Mem_Request then\n+      Stack    : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n+      Mem_Size : Memory_Size;\n \n-         --  Check if the stack will be exceeded. Note that Stack.Top points to\n-         --  the first free byte, therefore the Stack.Top of a fully allocated\n-         --  stack is equal to Stack.Size + 1. This check prevents overflow.\n+   --  Start of processing for SS_Allocate\n \n-         if Stack.Size - Stack.Top + 1 < Mem_Request then\n-            raise Storage_Error;\n-         end if;\n+   begin\n+      --  It should not be possible to request an allocation of negative or\n+      --  zero size.\n \n-         --  Record new max usage\n+      pragma Assert (Storage_Size > 0);\n \n-         Stack.Max := Stack.Top + Mem_Request;\n-      end if;\n+      --  Round the requested size up to the nearest multiple of the maximum\n+      --  alignment to ensure efficient access.\n \n-      --  Set resulting address and update top of stack pointer\n-      --\n-      --        Addr   Top\n-      --        |      |\n-      --    +-------------------+\n-      --    |##########|        |\n-      --    +-------------------+\n-      --              ^\n-      --        Internal_Chunk\n+      Mem_Size := Round_Up (Storage_Size);\n \n-      Addr      := Stack.Internal_Chunk.Mem (Stack.Top)'Address;\n-      Stack.Top := Stack.Top + Mem_Request;\n-   end SS_Allocate_Static;\n+      if Sec_Stack_Dynamic then\n+         Allocate_Dynamic (Stack, Mem_Size, Addr);\n+      else\n+         Allocate_Static  (Stack, Mem_Size, Addr);\n+      end if;\n+   end SS_Allocate;\n \n    -------------\n    -- SS_Free --\n    -------------\n \n    procedure SS_Free (Stack : in out SS_Stack_Ptr) is\n-      procedure Free is\n-        new Ada.Unchecked_Deallocation (SS_Stack, SS_Stack_Ptr);\n-\n-      Chunk : Chunk_Ptr;\n+      Static_Chunk : constant SS_Chunk_Ptr := Stack.Static_Chunk'Access;\n+      Next_Chunk   : SS_Chunk_Ptr;\n \n    begin\n-      --  If using dynamic secondary stack, free any external chunks\n+      --  Free all dynamically allocated chunks. The first dynamic chunk is\n+      --  found immediately after the static chunk of the stack.\n \n-      if SP.Sec_Stack_Dynamic then\n-         Chunk := Stack.Current_Chunk;\n+      while Static_Chunk.Next /= null loop\n+         Next_Chunk := Static_Chunk.Next.Next;\n+         Free (Static_Chunk.Next);\n+         Static_Chunk.Next := Next_Chunk;\n+      end loop;\n \n-         --  Go to top of linked list and free backwards. Do not free the\n-         --  internal chunk as it is part of SS_Stack.\n+      --  At this point one of the following outcomes has taken place:\n+      --\n+      --    * The stack lacks any dynamic chunks\n+      --\n+      --    * The stack had dynamic chunks which were all freed\n+      --\n+      --  Either way, there should be nothing hanging off the static chunk\n \n-         while Chunk.Next /= null loop\n-            Chunk := Chunk.Next;\n-         end loop;\n+      pragma Assert (Static_Chunk.Next = null);\n \n-         while Chunk.Prev /= null loop\n-            Chunk := Chunk.Prev;\n-            Free (Chunk.Next);\n-         end loop;\n-      end if;\n+      --  Free the stack only when it was dynamically allocated\n \n       if Stack.Freeable then\n          Free (Stack);\n@@ -428,71 +647,89 @@ package body System.Secondary_Stack is\n       Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n \n    begin\n-      --  Stack.Max points to the first untouched byte in the stack, thus the\n-      --  maximum number of bytes that have been allocated on the stack is one\n-      --  less the value of Stack.Max.\n-\n-      return Long_Long_Integer (Stack.Max - 1);\n+      return Long_Long_Integer (Stack.High_Water_Mark);\n    end SS_Get_Max;\n \n    -------------\n    -- SS_Info --\n    -------------\n \n    procedure SS_Info is\n-      Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n-   begin\n-      Put_Line (\"Secondary Stack information:\");\n+      procedure SS_Info_Dynamic (Stack : SS_Stack_Ptr);\n+      pragma Inline (SS_Info_Dynamic);\n+      --  Output relevant information concerning dynamic secondary stack Stack\n+\n+      function Total_Memory_Size (Stack : SS_Stack_Ptr) return Memory_Size;\n+      pragma Inline (Total_Memory_Size);\n+      --  Calculate the size of stack Stack's total memory usage. This includes\n+      --  the following kinds of memory:\n+      --\n+      --    * Free memory in used chunks due to alignment holes\n+      --    * Free memory in the topmost chunk due to partial usage\n+      --    * Free memory in unused chunks following the chunk indicated by the\n+      --      stack pointer.\n+      --    * Memory occupied by allocations\n+      --\n+      --  This is a linear-time operation on the number of chunks.\n \n-      --  Case of fixed secondary stack\n+      ---------------------\n+      -- SS_Info_Dynamic --\n+      ---------------------\n \n-      if not SP.Sec_Stack_Dynamic then\n-         Put_Line (\"  Total size              : \"\n-                   & SS_Ptr'Image (Stack.Size)\n-                   & \" bytes\");\n+      procedure SS_Info_Dynamic (Stack : SS_Stack_Ptr) is\n+      begin\n+         Put_Line\n+           (\"  Number of Chunks        : \" & Number_Of_Chunks (Stack)'Img);\n \n-         Put_Line (\"  Current allocated space : \"\n-                   & SS_Ptr'Image (Stack.Top - 1)\n-                   & \" bytes\");\n+         Put_Line\n+           (\"  Default size of Chunks  : \" & Stack.Default_Chunk_Size'Img);\n+      end SS_Info_Dynamic;\n \n-      --  Case of dynamic secondary stack\n+      -----------------------\n+      -- Total_Memory_Size --\n+      -----------------------\n \n-      else\n-         declare\n-            Chunk     : Chunk_Ptr := Stack.Current_Chunk;\n-            Nb_Chunks : Integer   := 1;\n+      function Total_Memory_Size (Stack : SS_Stack_Ptr) return Memory_Size is\n+         Chunk : SS_Chunk_Ptr;\n+         Total : Memory_Size;\n \n-         begin\n-            while Chunk.Prev /= null loop\n-               Chunk := Chunk.Prev;\n-            end loop;\n+      begin\n+         --  The total size of the stack is equal to the size of the stack up\n+         --  to the chunk indicated by the stack pointer, plus the size of the\n+         --  indicated chunk, plus the size of any subsequent chunks.\n \n-            while Chunk.Next /= null loop\n-               Nb_Chunks := Nb_Chunks + 1;\n-               Chunk := Chunk.Next;\n-            end loop;\n+         Total := Size_Up_To_And_Including (Stack.Top.Chunk);\n \n-            --  Current Chunk information\n+         Chunk := Stack.Top.Chunk.Next;\n+         while Chunk /= null loop\n+            Total := Total + Chunk.Size;\n+            Chunk := Chunk.Next;\n+         end loop;\n+\n+         return Total;\n+      end Total_Memory_Size;\n \n-            --  Note that First of each chunk is one more than Last of the\n-            --  previous one, so Chunk.Last is the total size of all chunks;\n-            --  we do not need to walk all the chunks to compute the total\n-            --  size.\n+      --  Local variables\n \n-            Put_Line (\"  Total size              : \"\n-                      & SS_Ptr'Image (Chunk.Last)\n-                      & \" bytes\");\n+      Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n \n-            Put_Line (\"  Current allocated space : \"\n-                      & SS_Ptr'Image (Stack.Top - 1)\n-                      & \" bytes\");\n+   --  Start of processing for SS_Info\n+\n+   begin\n+      Put_Line (\"Secondary Stack information:\");\n \n-            Put_Line (\"  Number of Chunks        : \"\n-                      & Integer'Image (Nb_Chunks));\n+      Put_Line\n+        (\"  Total size              : \"\n+         & Total_Memory_Size (Stack)'Img\n+         & \" bytes\");\n \n-            Put_Line (\"  Default size of Chunks  : \"\n-                      & SP.Size_Type'Image (Stack.Size));\n-         end;\n+      Put_Line\n+        (\"  Current allocated space : \"\n+         & Used_Memory_Size (Stack)'Img\n+         & \" bytes\");\n+\n+      if Sec_Stack_Dynamic then\n+         SS_Info_Dynamic (Stack);\n       end if;\n    end SS_Info;\n \n@@ -502,93 +739,166 @@ package body System.Secondary_Stack is\n \n    procedure SS_Init\n      (Stack : in out SS_Stack_Ptr;\n-      Size  : SP.Size_Type := SP.Unspecified_Size)\n+      Size  : Size_Type := Unspecified_Size)\n    is\n-      Stack_Size : Size_Type;\n+      function Next_Available_Binder_Sec_Stack return SS_Stack_Ptr;\n+      pragma Inline (Next_Available_Binder_Sec_Stack);\n+      --  Return a pointer to the next available stack from the pool created by\n+      --  the binder. This routine updates global Default_Sec_Stack_Pool_Index.\n+\n+      -------------------------------------\n+      -- Next_Available_Binder_Sec_Stack --\n+      -------------------------------------\n+\n+      function Next_Available_Binder_Sec_Stack return SS_Stack_Ptr is\n+\n+         --  The default-sized secondary stack pool generated by the binder\n+         --  is passed to this unit as an Address because it is not possible\n+         --  to define a pointer to an array of unconstrained components. The\n+         --  pointer is instead obtained using an unchecked conversion to a\n+         --  constrained array of secondary stacks with the same size as that\n+         --  specified by the binder.\n+\n+         --  WARNING: The following data structure must be synchronized with\n+         --  the one created in Bindgen.Gen_Output_File_Ada. The version in\n+         --  bindgen is called Sec_Default_Sized_Stacks.\n+\n+         type SS_Pool is\n+           array (1 .. Binder_SS_Count)\n+             of aliased SS_Stack (Binder_Default_SS_Size);\n+\n+         type SS_Pool_Ptr is access SS_Pool;\n+         --  A reference to the secondary stack pool\n+\n+         function To_SS_Pool_Ptr is\n+           new Ada.Unchecked_Conversion (Address, SS_Pool_Ptr);\n+\n+         --  Use an unchecked conversion to obtain a pointer to one of the\n+         --  secondary stacks from the pool generated by the binder. There\n+         --  are several reasons for using the conversion:\n+         --\n+         --    * Accessibility checks prevent a value of a local pointer to be\n+         --      stored outside this scope. The conversion is safe because the\n+         --      pool is global to the whole application.\n+         --\n+         --    * Unchecked_Access may circumvent the accessibility checks, but\n+         --      it is incompatible with restriction No_Unchecked_Access.\n+         --\n+         --    * Unrestricted_Access may circumvent the accessibility checks,\n+         --      but it is incompatible with pure Ada constructs.\n+         --      ??? cannot find the restriction or switch\n+\n+         pragma Warnings (Off);\n+         function To_SS_Stack_Ptr is\n+           new Ada.Unchecked_Conversion (Address, SS_Stack_Ptr);\n+         pragma Warnings (On);\n+\n+         Pool : SS_Pool_Ptr;\n+\n+      begin\n+         --  Obtain a typed view of the pool\n+\n+         Pool := To_SS_Pool_Ptr (Binder_Default_SS_Pool);\n+\n+         --  Advance the stack index to the next available stack\n+\n+         Binder_Default_SS_Pool_Index := Binder_Default_SS_Pool_Index + 1;\n+\n+         --  Return a pointer to the next available stack\n+\n+         return To_SS_Stack_Ptr (Pool (Binder_Default_SS_Pool_Index)'Address);\n+      end Next_Available_Binder_Sec_Stack;\n+\n+      --  Local variables\n+\n+      Stack_Size : Memory_Size_With_Invalid;\n+\n+   --  Start of processing for SS_Init\n \n    begin\n-      --  If Stack is not null then the stack has been allocated outside the\n-      --  package (by the compiler or the user) and all that is left to do is\n-      --  initialize the stack. Otherwise, SS_Init will allocate a secondary\n-      --  stack from either the heap or the default-sized secondary stack pool\n-      --  generated by the binder. In the later case, this pool is generated\n-      --  only when the either No_Implicit_Heap_Allocations\n-      --  or No_Implicit_Task_Allocations are active, and SS_Init will allocate\n-      --  all requests for a secondary stack of Unspecified_Size from this\n-      --  pool.\n+      --  Allocate a new stack on the heap or use one from the pool created by\n+      --  the binder.\n \n       if Stack = null then\n+\n+         --  The caller requested a pool-allocated stack. Determine the proper\n+         --  size of the stack based on input from the binder or the runtime in\n+         --  case the pool is exhausted.\n+\n          if Size = Unspecified_Size then\n \n-            --  Cover the case when bootstraping with an old compiler that does\n-            --  not set Default_SS_Size.\n+            --  Use the default secondary stack size as specified by the binder\n+            --  only when it has been set. This prevents a bootstrap issue with\n+            --  older compilers where the size is never set.\n+\n+            if Binder_Default_SS_Size > 0 then\n+               Stack_Size := Binder_Default_SS_Size;\n+\n+            --  Otherwise use the default stack size of the particular runtime\n \n-            if Default_SS_Size > 0 then\n-               Stack_Size := Default_SS_Size;\n             else\n                Stack_Size := Runtime_Default_Sec_Stack_Size;\n             end if;\n \n+         --  Otherwise the caller requested a heap-allocated stack. Use the\n+         --  specified size directly.\n+\n          else\n             Stack_Size := Size;\n          end if;\n \n+         --  The caller requested a pool-allocated stack. Use one as long as\n+         --  the pool created by the binder has available stacks. This stack\n+         --  cannot be deallocated.\n+\n          if Size = Unspecified_Size\n            and then Binder_SS_Count > 0\n-           and then Num_Of_Assigned_Stacks < Binder_SS_Count\n+           and then Binder_Default_SS_Pool_Index < Binder_SS_Count\n          then\n-            --  The default-sized secondary stack pool is passed from the\n-            --  binder to this package as an Address since it is not possible\n-            --  to have a pointer to an array of unconstrained objects. A\n-            --  pointer to the pool is obtainable via an unchecked conversion\n-            --  to a constrained array of SS_Stacks that mirrors the one used\n-            --  by the binder.\n-\n-            --  However, Ada understandably does not allow a local pointer to\n-            --  a stack in the pool to be stored in a pointer outside of this\n-            --  scope. While the conversion is safe in this case, since a view\n-            --  of a global object is being used, using Unchecked_Access\n-            --  would prevent users from specifying the restriction\n-            --  No_Unchecked_Access whenever the secondary stack is used. As\n-            --  a workaround, the local stack pointer is converted to a global\n-            --  pointer via System.Address.\n-\n-            declare\n-               type Stk_Pool_Array is array (1 .. Binder_SS_Count) of\n-                 aliased SS_Stack (Default_SS_Size);\n-               type Stk_Pool_Access is access Stk_Pool_Array;\n-\n-               function To_Stack_Pool is new\n-                 Ada.Unchecked_Conversion (Address, Stk_Pool_Access);\n-\n-               pragma Warnings (Off);\n-               function To_Global_Ptr is new\n-                 Ada.Unchecked_Conversion (Address, SS_Stack_Ptr);\n-               pragma Warnings (On);\n-               --  Suppress aliasing warning since the pointer we return will\n-               --  be the only access to the stack.\n-\n-               Local_Stk_Address : System.Address;\n-\n-            begin\n-               Num_Of_Assigned_Stacks := Num_Of_Assigned_Stacks + 1;\n-\n-               Local_Stk_Address :=\n-                 To_Stack_Pool\n-                   (Default_Sized_SS_Pool) (Num_Of_Assigned_Stacks)'Address;\n-               Stack := To_Global_Ptr (Local_Stk_Address);\n-            end;\n-\n+            Stack := Next_Available_Binder_Sec_Stack;\n             Stack.Freeable := False;\n+\n+         --  Otherwise the caller requested a heap-allocated stack, or the pool\n+         --  created by the binder ran out of available stacks. This stack can\n+         --  be deallocated.\n+\n          else\n+            --  It should not be possible to create a stack with a negative\n+            --  default chunk size.\n+\n+            pragma Assert (Stack_Size in Memory_Size);\n+\n             Stack := new SS_Stack (Stack_Size);\n             Stack.Freeable := True;\n          end if;\n+\n+      --  Otherwise the stack was already created either by the compiler or by\n+      --  the user, and is about to be reused.\n+\n+      else\n+         null;\n       end if;\n \n-      Stack.Top := 1;\n-      Stack.Max := 1;\n-      Stack.Current_Chunk := Stack.Internal_Chunk'Access;\n+      --  The static chunk becomes the chunk indicated by the stack pointer.\n+      --  Note that the stack may still hold dynamic chunks, which in turn may\n+      --  be reused or freed.\n+\n+      Stack.Top.Chunk := Stack.Static_Chunk'Access;\n+\n+      --  The first free byte is the first free byte of the chunk indicated by\n+      --  the stack pointer.\n+\n+      Stack.Top.Byte := Stack.Top.Chunk.Memory'First;\n+\n+      --  Since the chunk indicated by the stack pointer is also the first\n+      --  chunk in the stack, there are no prior chunks, therefore the size\n+      --  of the stack up to the chunk is zero.\n+\n+      Stack.Top.Chunk.Size_Up_To_Chunk := 0;\n+\n+      --  Reset the high water mark to account for brand new allocations\n+\n+      Stack.High_Water_Mark := 0;\n    end SS_Init;\n \n    -------------\n@@ -599,7 +909,7 @@ package body System.Secondary_Stack is\n       Stack : constant SS_Stack_Ptr := Get_Sec_Stack.all;\n \n    begin\n-      return (Sec_Stack => Stack, Sptr => Stack.Top);\n+      return (Stack => Stack, Top => Stack.Top);\n    end SS_Mark;\n \n    ----------------\n@@ -608,7 +918,54 @@ package body System.Secondary_Stack is\n \n    procedure SS_Release (M : Mark_Id) is\n    begin\n-      M.Sec_Stack.Top := M.Sptr;\n+      M.Stack.Top := M.Top;\n    end SS_Release;\n \n+   ------------------\n+   -- Top_Chunk_Id --\n+   ------------------\n+\n+   function Top_Chunk_Id (Stack : SS_Stack_Ptr) return Chunk_Id_With_Invalid is\n+      Chunk : SS_Chunk_Ptr;\n+      Id    : Chunk_Id;\n+\n+   begin\n+      Chunk := Stack.Static_Chunk'Access;\n+      Id    := 1;\n+      while Chunk /= null loop\n+         if Chunk = Stack.Top.Chunk then\n+            return Id;\n+         end if;\n+\n+         Chunk := Chunk.Next;\n+         Id    := Id + 1;\n+      end loop;\n+\n+      return Invalid_Chunk_Id;\n+   end Top_Chunk_Id;\n+\n+   ----------------------\n+   -- Used_Memory_Size --\n+   ----------------------\n+\n+   function Used_Memory_Size (Stack : SS_Stack_Ptr) return Memory_Size is\n+   begin\n+      --  The size of the occupied memory is equal to the size up to the chunk\n+      --  indicated by the stack pointer, plus the size in use by the indicated\n+      --  chunk itself. Top.Byte - 1 is the last occupied byte.\n+      --\n+      --                                     Top.Byte\n+      --                                     |\n+      --    . . . . . . .     +--------------|----+\n+      --                . ..> |##############|    |\n+      --    . . . . . . .     +-------------------+\n+      --                       |             |\n+      --    -------------------+-------------+\n+      --      Size_Up_To_Chunk   size in use\n+\n+      --  ??? this calculation may overflow on 32bit targets\n+\n+      return Stack.Top.Chunk.Size_Up_To_Chunk + Stack.Top.Byte - 1;\n+   end Used_Memory_Size;\n+\n end System.Secondary_Stack;"}, {"sha": "0452f40022dccfdc5171633cc017219108132409", "filename": "gcc/ada/libgnat/s-secsta.ads", "status": "modified", "additions": 349, "deletions": 148, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1df65b8982b0b941a3d6ac1e84437fff08e3462c/gcc%2Fada%2Flibgnat%2Fs-secsta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1df65b8982b0b941a3d6ac1e84437fff08e3462c/gcc%2Fada%2Flibgnat%2Fs-secsta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-secsta.ads?ref=1df65b8982b0b941a3d6ac1e84437fff08e3462c", "patch": "@@ -37,193 +37,394 @@ with System.Storage_Elements;\n package System.Secondary_Stack is\n    pragma Preelaborate;\n \n-   package SP renames System.Parameters;\n+   package SP  renames System.Parameters;\n    package SSE renames System.Storage_Elements;\n \n-   type SS_Stack (Size : SP.Size_Type) is private;\n-   --  Data structure for secondary stacks\n+   use type SP.Size_Type;\n+\n+   type SS_Stack (Default_Chunk_Size : SP.Size_Type) is private;\n+   --  An abstraction for a heap structure maintained in a stack-like fashion.\n+   --  The structure is comprised of chunks which accommodate allocations of\n+   --  varying sizes. See the private part of the package for further details.\n+   --  Default_Chunk_Size indicates the size of the static chunk, and provides\n+   --  a minimum size for all dynamic chunks.\n \n    type SS_Stack_Ptr is access all SS_Stack;\n-   --  Pointer to secondary stack objects\n+   --  A reference to a secondary stack\n+\n+   type Mark_Id is private;\n+   --  An abstraction for tracking the state of the secondary stack\n \n    procedure SS_Init\n      (Stack : in out SS_Stack_Ptr;\n       Size  : SP.Size_Type := SP.Unspecified_Size);\n-   --  Initialize the secondary stack Stack. If Stack is null allocate a stack\n-   --  from the heap or from the default-sized secondary stack pool if the\n-   --  pool exists and the requested size is Unspecified_Size.\n+   --  Initialize or reuse a secondary stack denoted by reference Stack. If\n+   --  Stack is null, create a new stack of size Size in the following manner:\n+   --\n+   --    * If Size denotes Unspecified_Size, allocate the stack from the binder\n+   --      generated pool as long as the pool has not been exhausted.\n+   --\n+   --    * Otherwise allocate the stack from the heap.\n+   --\n+   --  If Stack is not null, reset the state of the stack. No existing chunks\n+   --  are freed because they may be reused again.\n \n    procedure SS_Allocate\n      (Addr         : out Address;\n       Storage_Size : SSE.Storage_Count);\n-   --  Allocate enough space for a 'Storage_Size' bytes object with Maximum\n-   --  alignment. The address of the allocated space is returned in Addr.\n+   --  Allocate enough space on the secondary stack of the invoking task to\n+   --  accommodate an alloction of size Storage_Size. Return the address of the\n+   --  first byte of the allocation in Addr. The routine may carry out one or\n+   --  more of the following actions:\n+   --\n+   --    * Reuse an existing chunk that is big enough to accommodate the\n+   --      requested Storage_Size.\n+   --\n+   --    * Free an existing chunk that is too small to accommodate the\n+   --      requested Storage_Size.\n+   --\n+   --    * Create a new chunk that fits the requested Storage_Size.\n \n    procedure SS_Free (Stack : in out SS_Stack_Ptr);\n-   --  Release the memory allocated for the Stack. If the stack was statically\n-   --  allocated the SS_Stack record is not freed.\n-\n-   type Mark_Id is private;\n-   --  Type used to mark the stack for mark/release processing\n+   --  Free all dynamic chunks of secondary stack Stack. If possible, free the\n+   --  stack itself.\n \n    function SS_Mark return Mark_Id;\n-   --  Return the Mark corresponding to the current state of the stack\n+   --  Capture and return the state of the invoking task's secondary stack\n \n    procedure SS_Release (M : Mark_Id);\n-   --  Restore the state of the stack corresponding to the mark M\n+   --  Restore the state of the invoking task's secondary stack to mark M\n \n    function SS_Get_Max return Long_Long_Integer;\n-   --  Return the high water mark of the secondary stack for the current\n-   --  secondary stack in bytes.\n+   --  Return the high water mark of the invoking task's secondary stack, in\n+   --  bytes.\n \n    generic\n       with procedure Put_Line (S : String);\n    procedure SS_Info;\n-   --  Debugging procedure used to print out secondary Stack allocation\n-   --  information. This procedure is generic in order to avoid a direct\n-   --  dependance on a particular IO package.\n+   --  Debugging procedure for outputting the internals of the invoking task's\n+   --  secondary stack. This procedure is generic in order to avoid a direct\n+   --  dependence on a particular IO package. Instantiate with Text_IO.Put_Line\n+   --  for example.\n \n private\n    SS_Pool : Integer;\n    --  Unused entity that is just present to ease the sharing of the pool\n-   --  mechanism for specific allocation/deallocation in the compiler\n-\n-   -------------------------------------\n-   -- Secondary Stack Data Structures --\n-   -------------------------------------\n-\n-   --  This package provides fixed and dynamically sized secondary stack\n-   --  implementations centered around a common data structure SS_Stack. This\n-   --  record contains an initial secondary stack allocation of the requested\n-   --  size, and markers for the current top of the stack and the high-water\n-   --  mark of the stack. A SS_Stack can be either pre-allocated outside the\n-   --  package or SS_Init can allocate a stack from the heap or the\n-   --  default-sized secondary stack from a pool generated by the binder.\n-\n-   --  For dynamically allocated secondary stacks, the stack can grow via a\n-   --  linked list of stack chunks allocated from the heap. New chunks are\n-   --  allocated once the initial static allocation and any existing chunks are\n-   --  exhausted. The following diagram illustrated the data structures used\n-   --  for a dynamically allocated secondary stack:\n-   --\n-   --                                       +------------------+\n-   --                                       |       Next       |\n-   --                                       +------------------+\n-   --                                       |                  | Last (300)\n-   --                                       |                  |\n-   --                                       |                  |\n-   --                                       |                  |\n-   --                                       |                  |\n-   --                                       |                  |\n-   --                                       |                  | First (201)\n-   --                                       +------------------+\n-   --    +-----------------+       +------> |          |       |\n-   --    |                 | (100) |        +--------- | ------+\n-   --    |                 |       |                ^  |\n-   --    |                 |       |                |  |\n-   --    |                 |       |                |  V\n-   --    |                 |       |        +------ | ---------+\n-   --    |                 |       |        |       |          |\n-   --    |                 |       |        +------------------+\n-   --    |                 |       |        |                  | Last (200)\n-   --    |                 |       |        |         C        |\n-   --    |                 | (1)   |        |         H        |\n-   --    +-----------------+       |  +---->|         U        |\n-   --    |  Current_Chunk ---------+  |     |         N        |\n-   --    +-----------------+          |     |         K        |\n-   --    |       Top      ------------+     |                  | First (101)\n-   --    +-----------------+                +------------------+\n-   --    |       Size      |                |       Prev       |\n-   --    +-----------------+                +------------------+\n-   --\n-   --  The implementation used by the runtime is controlled via the constant\n-   --  System.Parameter.Sec_Stack_Dynamic. If True, the implementation is\n-   --  permitted to grow the secondary stack at runtime. The implementation is\n-   --  designed for the compiler to include only code to support the desired\n-   --  secondary stack behavior.\n-\n-   subtype SS_Ptr is SP.Size_Type;\n-   --  Stack pointer value for the current position within the secondary stack.\n-   --  Size_Type is used as the base type since the Size discriminate of\n-   --  SS_Stack forms the bounds of the internal memory array.\n-\n-   type Memory is array (SS_Ptr range <>) of SSE.Storage_Element;\n-   for Memory'Alignment use Standard'Maximum_Alignment;\n-   --  The region of memory that holds the stack itself. Requires maximum\n-   --  alignment for efficient stack operations.\n-\n-   --  Chunk_Id\n-\n-   --  Chunk_Id is a contiguous block of dynamically allocated stack. First\n-   --  and Last indicate the range of secondary stack addresses present in the\n-   --  chunk. Chunk_Ptr points to a Chunk_Id block.\n-\n-   type Chunk_Id (First, Last : SS_Ptr);\n-   type Chunk_Ptr is access all Chunk_Id;\n-\n-   type Chunk_Id (First, Last : SS_Ptr) is record\n-      Prev, Next : Chunk_Ptr;\n-      Mem        : Memory (First .. Last);\n+   --  mechanism for specific allocation/deallocation in the compiler.\n+\n+   ------------------\n+   -- Introduction --\n+   ------------------\n+\n+   --  The secondary stack is a runtime data structure managed in a stack-like\n+   --  fashion. It is part of the runtime support for functions that return\n+   --  results of caller-unknown size.\n+   --\n+   --  The secondary stack is utilized as follows:\n+   --\n+   --    * The compiler pushes the caller-unknown size result on the secondary\n+   --      stack as part of return statement or build-in-place semantics.\n+   --\n+   --    * The caller receives a reference to the result.\n+   --\n+   --    * Using the reference, the caller may \"offload\" the result into its\n+   --      primary stack, or use it in-place while still on the secondary\n+   --      stack.\n+   --\n+   --    * Once the caller has utilized the result, the compiler reclaims the\n+   --      memory occupied by the result by popping the secondary stack up to\n+   --      a safe limit.\n+\n+   ------------\n+   -- Design --\n+   ------------\n+\n+   --  1) Chunk\n+   --\n+   --  The secondary stack is a linked structure which consist of \"chunks\".\n+   --  A chunk is both a memory storage and a linked-list node. Addresses of\n+   --  allocated objects refer to addresses within the memory storage of a\n+   --  chunk. Chunks come in two variants - static and dynamic.\n+   --\n+   --  1.1) Static chunk\n+   --\n+   --  The secondary stack has exactly one static chunk that is created on the\n+   --  primary stack. The static chunk allows secondary-stack usage on targets\n+   --  where dynamic allocation is not available or desirable. The static chunk\n+   --  is always the \"first\" chunk and precedes all dynamic chunks.\n+   --\n+   --  1.2) Dynamic chunk\n+   --\n+   --  The secondary stack may have zero or more dynamic chunks, created on the\n+   --  heap. Dynamic chunks allow the secondary stack to grow beyond the limits\n+   --  of the initial static chunk. They provide a finer-grained management of\n+   --  the memory by means of reuse and deallocation.\n+   --\n+   --  2) Mark\n+   --\n+   --  The secondary stack captures its state in a \"mark\". The mark is used by\n+   --  the compiler to indicate how far the stack can be safely popped after a\n+   --  sequence of pushes has taken place.\n+   --\n+   --  3) Secondary stack\n+   --\n+   --  The secondary stack maintains a singly-linked list of chunks, starting\n+   --  with the static chunk, along with a stack pointer.\n+   --\n+   --  4) Allocation\n+   --\n+   --  The process of allocation equates to \"pushing\" on the secondary stack.\n+   --  Depending on whether dynamic allocation is allowed or not, there are\n+   --  two variants of allocation - static and dynamic.\n+   --\n+   --  4.1) Static allocation\n+   --\n+   --  In this case the secondary stack has only the static chunk to work with.\n+   --  The requested size is reserved on the static chunk and the stack pointer\n+   --  is advanced. If the requested size will overflow the static chunk, then\n+   --  Storage_Error is raised.\n+   --\n+   --  4.2) Dynamic allocation\n+   --\n+   --  In this case the secondary stack may carry out several actions depending\n+   --  on how much free memory is available in the chunk indicated by the stack\n+   --  pointer.\n+   --\n+   --    * If the indicated chunk is big enough, allocation is carried out on\n+   --      it.\n+   --\n+   --    * If the indicated chunk is too small, subsequent chunks (if any) are\n+   --      examined. If a subsequent chunk is big enough, allocation is carried\n+   --      out on it, otherwise the subsequent chunk is deallocated.\n+   --\n+   --    * If none of the chunks following and including the indicated chunk\n+   --      are big enough, a new chunk is created and the allocation is carried\n+   --      out on it.\n+   --\n+   --  This model of operation has several desirable effects:\n+   --\n+   --    * Leftover chunks from prior allocations, followed by at least one pop\n+   --      are either reused or deallocated. This compacts the memory footprint\n+   --      of the secondary stack.\n+   --\n+   --    * When a new chunk is created, its size is exactly the requested size.\n+   --      This keeps the memory usage of the secondary stack tight.\n+   --\n+   --    * Allocation is in general an expensive operation. Compaction is thus\n+   --      added to this cost, rather than penalizing mark and pop operations.\n+   --\n+   --  5) Marking\n+   --\n+   --  The process of marking involves capturing the secondary-stack pointer\n+   --  in a mark for later restore.\n+   --\n+   --  6) Releasing\n+   --\n+   --  The process of releasing equates to \"popping\" the secondary stack. It\n+   --  moves the stack pointer to a previously captured mark, causing chunks\n+   --  to become reusable or deallocatable during the allocation process.\n+\n+   ------------------\n+   -- Architecture --\n+   ------------------\n+\n+   --      Secondary stack\n+   --\n+   --      +------------+\n+   --      | Top.Byte  ------------------------+\n+   --      | Top.Chunk ------------------+     |\n+   --      |            |                |     |\n+   --      |            |                v     |\n+   --      +------------+   +--------+   +-----|--+   +--------+\n+   --      | Memory     |   | Memory |   | Memo|y |   | Memory |\n+   --      | #########  |   | #####  |   | ####|  |   | #####  |\n+   --      |            |   |        |   |        |   |        |\n+   --      | Next      ---> | Next  ---> | Next  ---> | Next  ---> x\n+   --      +------------+   +--------+   +--------+   +--------+\n+   --\n+   --       Static chunk     Chunk 2      Chunk 3      Chunk 4\n+\n+   --------------------------\n+   -- Memory-related types --\n+   --------------------------\n+\n+   subtype Memory_Size_With_Invalid is SP.Size_Type;\n+   --  Memory storage size which also includes an invalid negative range\n+\n+   Invalid_Memory_Size : constant Memory_Size_With_Invalid := -1;\n+\n+   subtype Memory_Size is\n+     Memory_Size_With_Invalid range 0 .. SP.Size_Type'Last;\n+   --  The memory storage size of a single chunk or the whole secondary stack.\n+   --  A non-negative size is considered a \"valid\" size.\n+\n+   subtype Memory_Index is Memory_Size;\n+   --  Index into the memory storage of a single chunk\n+\n+   type Chunk_Memory is array (Memory_Size range <>) of SSE.Storage_Element;\n+   for Chunk_Memory'Alignment use Standard'Maximum_Alignment;\n+   --  The memory storage of a single chunk. It utilizes maximum alignment in\n+   --  order to guarantee efficient operations.\n+\n+   --------------\n+   -- SS_Chunk --\n+   --------------\n+\n+   type SS_Chunk (Size : Memory_Size);\n+   --  Abstraction for a chunk. Size indicates the memory capacity of the\n+   --  chunk.\n+\n+   type SS_Chunk_Ptr is access all SS_Chunk;\n+   --  Reference to the static or any dynamic chunk\n+\n+   type SS_Chunk (Size : Memory_Size) is record\n+      Next : SS_Chunk_Ptr;\n+      --  Pointer to the next chunk. The direction of the pointer is from the\n+      --  static chunk to the first dynamic chunk, and so on.\n+\n+      Size_Up_To_Chunk : Memory_Size;\n+      --  The size of the secondary stack up to, but excluding the current\n+      --  chunk. This value aids in calculating the total amount of memory\n+      --  the stack is consuming, for high-water-mark update purposes.\n+\n+      Memory : Chunk_Memory (1 .. Size);\n+      --  The memory storage of the chunk. The 1-indexing facilitates various\n+      --  size and indexing calculations.\n    end record;\n \n-   --  Secondary stack data structure\n+   -------------------\n+   -- Stack_Pointer --\n+   -------------------\n+\n+   --  Abstraction for a secondary stack pointer\n \n-   type SS_Stack (Size : SP.Size_Type) is record\n-      Top : SS_Ptr;\n-      --  Index of next available location in the stack. Initialized to 1 and\n-      --  then incremented on Allocate and decremented on Release.\n+   type Stack_Pointer is record\n+      Byte : Memory_Index;\n+      --  The position of the first free byte within the memory storage of\n+      --  Chunk.all. Byte - 1 denotes the last occupied byte within Chunk.all.\n \n-      Max : SS_Ptr;\n-      --  Contains the high-water mark of Top. Initialized to 1 and then\n-      --  may be incremented on Allocate but never decremented. Since\n-      --  Top = Size + 1 represents a fully used stack, Max - 1 indicates\n-      --  the size of the stack used in bytes.\n+      Chunk : SS_Chunk_Ptr;\n+      --  Reference to the chunk that accommodated the most recent allocation.\n+      --  This could be the static or any dynamic chunk.\n+   end record;\n \n-      Current_Chunk : Chunk_Ptr;\n-      --  A link to the chunk containing the highest range of the stack\n+   --------------\n+   -- SS_Stack --\n+   --------------\n \n+   type SS_Stack (Default_Chunk_Size : SP.Size_Type) is record\n       Freeable : Boolean;\n-      --  Indicates if an object of this type can be freed\n+      --  Indicates whether the secondary stack can be freed\n+\n+      High_Water_Mark : Memory_Size;\n+      --  The maximum amount of memory in use throughout the lifetime of the\n+      --  secondary stack.\n+\n+      Top : Stack_Pointer;\n+      --  The stack pointer\n \n-      Internal_Chunk : aliased Chunk_Id (1, Size);\n-      --  Initial memory allocation of the secondary stack\n+      Static_Chunk : aliased SS_Chunk (Default_Chunk_Size);\n+      --  A special chunk with a default size. On targets that do not support\n+      --  dynamic allocations, this chunk represents the capacity of the whole\n+      --  secondary stack.\n    end record;\n \n+   -------------\n+   -- Mark_Id --\n+   -------------\n+\n    type Mark_Id is record\n-      Sec_Stack : SS_Stack_Ptr;\n-      Sptr      : SS_Ptr;\n+      Stack : SS_Stack_Ptr;\n+      --  The secondary stack whose mark was taken\n+\n+      Top : Stack_Pointer;\n+      --  The value of Stack.Top at the point in time when the mark was taken\n+   end record;\n+\n+   ------------------\n+   -- Testing Aids --\n+   ------------------\n+\n+   --  The following section provides lightweight versions of all abstractions\n+   --  used to implement a secondary stack. The contents of these versions may\n+   --  look identical to the original abstractions, however there are several\n+   --  important implications:\n+   --\n+   --    * The versions do not expose pointers.\n+   --\n+   --    * The types of the versions are all definite. In addition, there are\n+   --      no per-object constrained components. As a result, the versions do\n+   --      not involve the secondary stack or the heap in any way.\n+   --\n+   --    * The types of the versions do not contain potentially big components.\n+\n+   subtype Chunk_Id_With_Invalid is Natural;\n+   --  Numeric Id of a chunk with value zero\n+\n+   Invalid_Chunk_Id : constant Chunk_Id_With_Invalid := 0;\n+\n+   subtype Chunk_Id is\n+     Chunk_Id_With_Invalid range 1 .. Chunk_Id_With_Invalid'Last;\n+   --  Numeric Id of a chunk. A positive Id is considered \"valid\" because a\n+   --  secondary stack will have at least one chunk (the static chunk).\n+\n+   subtype Chunk_Count is Natural;\n+   --  Number of chunks in a secondary stack\n+\n+   --  Lightweight version of SS_Chunk\n+\n+   type Chunk_Info is record\n+      Size : Memory_Size_With_Invalid;\n+      --  The memory capacity of the chunk\n+\n+      Size_Up_To_Chunk : Memory_Size_With_Invalid;\n+      --  The size of the secondary stack up to, but excluding the current\n+      --  chunk.\n+   end record;\n+\n+   Invalid_Chunk : constant Chunk_Info :=\n+                     (Size             => Invalid_Memory_Size,\n+                      Size_Up_To_Chunk => Invalid_Memory_Size);\n+\n+   --  Lightweight version of Stack_Pointer\n+\n+   type Stack_Pointer_Info is record\n+      Byte : Memory_Index;\n+      --  The position of the first free byte within the memory storage of\n+      --  Chunk. Byte - 1 denotes the last occupied byte within Chunk.\n+\n+      Chunk : Chunk_Id_With_Invalid;\n+      --  The Id of the chunk that accommodated the most recent allocation.\n+      --  This could be the static or any dynamic chunk.\n+   end record;\n+\n+   --  Lightweight version of SS_Stack\n+\n+   type Stack_Info is record\n+      Default_Chunk_Size : Memory_Size;\n+      --  The default memory capacity of a chunk\n+\n+      Freeable : Boolean;\n+      --  Indicates whether the secondary stack can be freed\n+\n+      High_Water_Mark : Memory_Size;\n+      --  The maximum amount of memory in use throughout the lifetime of the\n+      --  secondary stack.\n+\n+      Number_Of_Chunks : Chunk_Count;\n+      --  The total number of static and dynamic chunks in the secondary stack\n+\n+      Top : Stack_Pointer_Info;\n+      --  The stack pointer\n    end record;\n-   --  Contains the pointer to the secondary stack object and the stack pointer\n-   --  value corresponding to the top of the stack at the time of the mark\n-   --  call.\n-\n-   ------------------------------------\n-   -- Binder Allocated Stack Support --\n-   ------------------------------------\n-\n-   --  When the No_Implicit_Heap_Allocations or No_Implicit_Task_Allocations\n-   --  restrictions are in effect the binder statically generates secondary\n-   --  stacks for tasks who are using default-sized secondary stack. Assignment\n-   --  of these stacks to tasks is handled by SS_Init. The following variables\n-   --  assist SS_Init and are defined here so the runtime does not depend on\n-   --  the binder.\n-\n-   Binder_SS_Count : Natural;\n-   pragma Export (Ada, Binder_SS_Count, \"__gnat_binder_ss_count\");\n-   --  The number of default sized secondary stacks allocated by the binder\n-\n-   Default_SS_Size : SP.Size_Type;\n-   pragma Export (Ada, Default_SS_Size, \"__gnat_default_ss_size\");\n-   --  The default size for secondary stacks. Defined here and not in init.c/\n-   --  System.Init because these locations are not present on ZFP or\n-   --  Ravenscar-SFP run-times.\n-\n-   Default_Sized_SS_Pool : System.Address;\n-   pragma Export (Ada, Default_Sized_SS_Pool, \"__gnat_default_ss_pool\");\n-   --  Address to the secondary stack pool generated by the binder that\n-   --  contains default sized stacks.\n-\n-   Num_Of_Assigned_Stacks : Natural := 0;\n-   --  The number of currently allocated secondary stacks\n+\n+   function Get_Chunk_Info\n+     (Stack : SS_Stack_Ptr;\n+      C_Id  : Chunk_Id) return Chunk_Info;\n+   --  Obtain the information attributes of a chunk that belongs to secondary\n+   --  stack Stack and is identified by Id C_Id.\n+\n+   function Get_Stack_Info (Stack : SS_Stack_Ptr) return Stack_Info;\n+   --  Obtain the information attributes of secondary stack Stack\n \n end System.Secondary_Stack;"}]}