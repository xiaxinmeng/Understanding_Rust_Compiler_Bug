{"sha": "74f0c611c681e93dfb49bcd0d525f76d8c46af24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRmMGM2MTFjNjgxZTkzZGZiNDliY2QwZDUyNWY3NmQ4YzQ2YWYyNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-29T01:22:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-29T01:22:15Z"}, "message": "re PR inline-asm/15740 (ICE caused by a memory operand in an asm statement)\n\n\tPR inline-asm/15740\n        * gimplify.c (gimplify_asm_expr): Move resolve asm names ...\n        * c-typeck.c (build_asm_expr): ... here.  Validate input\n        constraints.  Mark memory inputs addressable.\n\n        * semantics.c (finish_asm_stmt): Resolve asm names.  Validate input\n        constraints.  Mark memory inputs addressable.\n\nFrom-SVN: r92693", "tree": {"sha": "54bc73bf49c5c1cd15ddc720798149307cd44186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54bc73bf49c5c1cd15ddc720798149307cd44186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74f0c611c681e93dfb49bcd0d525f76d8c46af24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74f0c611c681e93dfb49bcd0d525f76d8c46af24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74f0c611c681e93dfb49bcd0d525f76d8c46af24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74f0c611c681e93dfb49bcd0d525f76d8c46af24/comments", "author": null, "committer": null, "parents": [{"sha": "85f3cc42950bc89d6f494397c4ebb39bc830a66e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f3cc42950bc89d6f494397c4ebb39bc830a66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f3cc42950bc89d6f494397c4ebb39bc830a66e"}], "stats": {"total": 211, "additions": 144, "deletions": 67}, "files": [{"sha": "d89c8923645436f2fad9631ac0079217a416b0b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74f0c611c681e93dfb49bcd0d525f76d8c46af24", "patch": "@@ -1,3 +1,10 @@\n+2004-12-28  Richard Henderson  <rth@redhat.com>\n+\n+\tPR inline-asm/15740\n+\t* gimplify.c (gimplify_asm_expr): Move resolve asm names ...\n+\t* c-typeck.c (build_asm_expr): ... here.  Validate input\n+\tconstraints.  Mark memory inputs addressable.\n+\n 2004-12-28  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \tPR target/18321"}, {"sha": "5eae3aa7d5ec5edca018333d3b94488ff8623c9d", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=74f0c611c681e93dfb49bcd0d525f76d8c46af24", "patch": "@@ -6287,47 +6287,74 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n   tree args;\n   int i;\n   const char *constraint;\n+  const char **oconstraints;\n   bool allows_mem, allows_reg, is_inout;\n-  int ninputs;\n-  int noutputs;\n+  int ninputs, noutputs;\n \n   ninputs = list_length (inputs);\n   noutputs = list_length (outputs);\n+  oconstraints = (const char **) alloca (noutputs * sizeof (const char *));\n+\n+  string = resolve_asm_operand_names (string, outputs, inputs);\n \n   /* Remove output conversions that change the type but not the mode.  */\n   for (i = 0, tail = outputs; tail; ++i, tail = TREE_CHAIN (tail))\n     {\n       tree output = TREE_VALUE (tail);\n+\n+      /* ??? Really, this should not be here.  Users should be using a\n+\t proper lvalue, dammit.  But there's a long history of using casts\n+\t in the output operands.  In cases like longlong.h, this becomes a\n+\t primitive form of typechecking -- if the cast can be removed, then\n+\t the output operand had a type of the proper width; otherwise we'll\n+\t get an error.  Gross, but ...  */\n       STRIP_NOPS (output);\n-      TREE_VALUE (tail) = output;\n-      lvalue_or_else (output, lv_asm);\n+\n+      if (!lvalue_or_else (output, lv_asm))\n+\toutput = error_mark_node;\n \n       constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n+      oconstraints[i] = constraint;\n \n-      if (!parse_output_constraint (&constraint, i, ninputs, noutputs,\n-                                    &allows_mem, &allows_reg, &is_inout))\n-        {\n-          /* By marking this operand as erroneous, we will not try\n-          to process this operand again in expand_asm_operands.  */\n-          TREE_VALUE (tail) = error_mark_node;\n-          continue;\n-        }\n+      if (parse_output_constraint (&constraint, i, ninputs, noutputs,\n+\t\t\t\t   &allows_mem, &allows_reg, &is_inout))\n+\t{\n+\t  /* If the operand is going to end up in memory,\n+\t     mark it addressable.  */\n+\t  if (!allows_reg && !c_mark_addressable (output))\n+\t    output = error_mark_node;\n+\t}\n+      else\n+        output = error_mark_node;\n \n-      /* If the operand is a DECL that is going to end up in\n-        memory, assume it is addressable.  This is a bit more\n-        conservative than it would ideally be; the exact test is\n-        buried deep in expand_asm_operands and depends on the\n-        DECL_RTL for the OPERAND -- which we don't have at this\n-        point.  */\n-      if (!allows_reg && DECL_P (output))\n-        c_mark_addressable (output);\n+      TREE_VALUE (tail) = output;\n     }\n \n   /* Perform default conversions on array and function inputs.\n      Don't do this for other types as it would screw up operands\n      expected to be in memory.  */\n-  for (tail = inputs; tail; tail = TREE_CHAIN (tail))\n-    TREE_VALUE (tail) = default_function_array_conversion (TREE_VALUE (tail));\n+  for (i = 0, tail = inputs; tail; ++i, tail = TREE_CHAIN (tail))\n+    {\n+      tree input;\n+\n+      constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n+      input = TREE_VALUE (tail);\n+\n+      input = default_function_array_conversion (input);\n+\n+      if (parse_input_constraint (&constraint, i, ninputs, noutputs, 0,\n+\t\t\t\t  oconstraints, &allows_mem, &allows_reg))\n+\t{\n+\t  /* If the operand is going to end up in memory,\n+\t     mark it addressable.  */\n+\t  if (!allows_reg && allows_mem && !c_mark_addressable (input))\n+\t    input = error_mark_node;\n+\t}\n+      else\n+\tinput = error_mark_node;\n+\n+      TREE_VALUE (tail) = input;\n+    }\n \n   args = build_stmt (ASM_EXPR, string, outputs, inputs, clobbers);\n \n@@ -6337,6 +6364,7 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n       ASM_VOLATILE_P (args) = 1;\n       ASM_INPUT_P (args) = 1;\n     }\n+\n   return args;\n }\n \f"}, {"sha": "9e96120e8083bdea8c3ffc0ae699eb1832741ab3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=74f0c611c681e93dfb49bcd0d525f76d8c46af24", "patch": "@@ -1,3 +1,9 @@\n+2004-12-28  Richard Henderson  <rth@redhat.com>\n+\n+\tPR inline-asm/15740\n+\t* semantics.c (finish_asm_stmt): Resolve asm names.  Validate input\n+\tconstraints.  Mark memory inputs addressable.\n+\n 2004-12-27  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (expand_static_init): Don't use shortcut if"}, {"sha": "b34de199adb045bf66f99983bf79fbd229d2644a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=74f0c611c681e93dfb49bcd0d525f76d8c46af24", "patch": "@@ -1139,62 +1139,80 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \n   if (!processing_template_decl)\n     {\n+      int ninputs, noutputs;\n+      const char *constraint;\n+      const char **oconstraints;\n+      bool allows_mem, allows_reg, is_inout;\n+      tree operand;\n       int i;\n-      int ninputs;\n-      int noutputs;\n \n-      for (t = input_operands; t; t = TREE_CHAIN (t))\n+      ninputs = list_length (input_operands);\n+      noutputs = list_length (output_operands);\n+      oconstraints = (const char **) alloca (noutputs * sizeof (char *));\n+\n+      string = resolve_asm_operand_names (string, output_operands,\n+\t\t\t\t\t  input_operands);\n+\n+      for (i = 0, t = output_operands; t; t = TREE_CHAIN (t), ++i)\n \t{\n-\t  tree converted_operand \n-\t    = decay_conversion (TREE_VALUE (t)); \n-\t  \n+\t  operand = TREE_VALUE (t);\n+\n+\t  /* ??? Really, this should not be here.  Users should be using a\n+\t     proper lvalue, dammit.  But there's a long history of using\n+\t     casts in the output operands.  In cases like longlong.h, this\n+\t     becomes a primitive form of typechecking -- if the cast can be\n+\t     removed, then the output operand had a type of the proper width;\n+\t     otherwise we'll get an error.  Gross, but ...  */\n+\t  STRIP_NOPS (operand);\n+\n+\t  if (!lvalue_or_else (operand, lv_asm))\n+\t    operand = error_mark_node;\n+\n+\t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+\t  oconstraints[i] = constraint;\n+\n+\t  if (parse_output_constraint (&constraint, i, ninputs, noutputs,\n+\t\t\t\t       &allows_mem, &allows_reg, &is_inout))\n+\t    {\n+\t      /* If the operand is going to end up in memory,\n+\t\t mark it addressable.  */\n+\t      if (!allows_reg && !cxx_mark_addressable (operand))\n+\t\toperand = error_mark_node;\n+\t    }\n+\t  else\n+\t    operand = error_mark_node;\n+\n+\t  TREE_VALUE (t) = operand;\n+\t}\n+\n+      for (i = 0, t = input_operands; t; ++i, t = TREE_CHAIN (t))\n+\t{\n+\t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+\t  operand = decay_conversion (TREE_VALUE (t)); \n+\n \t  /* If the type of the operand hasn't been determined (e.g.,\n \t     because it involves an overloaded function), then issue\n \t     an error message.  There's no context available to\n \t     resolve the overloading.  */\n-\t  if (TREE_TYPE (converted_operand) == unknown_type_node)\n+\t  if (TREE_TYPE (operand) == unknown_type_node)\n \t    {\n \t      error (\"type of asm operand %qE could not be determined\", \n                      TREE_VALUE (t));\n-\t      converted_operand = error_mark_node;\n+\t      operand = error_mark_node;\n \t    }\n-\t  TREE_VALUE (t) = converted_operand;\n-\t}\n-\n-      ninputs = list_length (input_operands);\n-      noutputs = list_length (output_operands);\n-\n-      for (i = 0, t = output_operands; t; t = TREE_CHAIN (t), ++i)\n-\t{\n-\t  bool allows_mem;\n-\t  bool allows_reg;\n-\t  bool is_inout;\n-\t  const char *constraint;\n-\t  tree operand;\n \n-\t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n-\t  operand = TREE_VALUE (t);\n-\n-\t  if (!parse_output_constraint (&constraint,\n-\t\t\t\t\ti, ninputs, noutputs,\n-\t\t\t\t\t&allows_mem,\n-\t\t\t\t\t&allows_reg,\n-\t\t\t\t\t&is_inout))\n+\t  if (parse_input_constraint (&constraint, i, ninputs, noutputs, 0,\n+\t\t\t\t      oconstraints, &allows_mem, &allows_reg))\n \t    {\n-\t      /* By marking this operand as erroneous, we will not try\n-\t\t to process this operand again in expand_asm_operands.  */\n-\t      TREE_VALUE (t) = error_mark_node;\n-\t      continue;\n+\t      /* If the operand is going to end up in memory,\n+\t\t mark it addressable.  */\n+\t      if (!allows_reg && allows_mem && !cxx_mark_addressable (operand))\n+\t\toperand = error_mark_node;\n \t    }\n+\t  else\n+\t    operand = error_mark_node;\n \n-\t  /* If the operand is a DECL that is going to end up in\n-\t     memory, assume it is addressable.  This is a bit more\n-\t     conservative than it would ideally be; the exact test is\n-\t     buried deep in expand_asm_operands and depends on the\n-\t     DECL_RTL for the OPERAND -- which we don't have at this\n-\t     point.  */\n-\t  if (!allows_reg && DECL_P (operand))\n-\t    cxx_mark_addressable (operand);\n+\t  TREE_VALUE (t) = operand;\n \t}\n     }\n "}, {"sha": "ca3759769b133331ef42cefa728e2495df7f7a98", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=74f0c611c681e93dfb49bcd0d525f76d8c46af24", "patch": "@@ -3262,10 +3262,6 @@ gimplify_asm_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   bool allows_mem, allows_reg, is_inout;\n   enum gimplify_status ret, tret;\n \n-  ASM_STRING (expr)\n-    = resolve_asm_operand_names (ASM_STRING (expr), ASM_OUTPUTS (expr),\n-\t\t\t\t ASM_INPUTS (expr));\n-\n   ret = GS_ALL_DONE;\n   for (i = 0, link = ASM_OUTPUTS (expr); link; ++i, link = TREE_CHAIN (link))\n     {"}, {"sha": "4e3244169c779d9d83b42779251dddbfcd392274", "filename": "gcc/testsuite/g++.dg/opt/asm2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fasm2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fasm2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fasm2.C?ref=74f0c611c681e93dfb49bcd0d525f76d8c46af24", "patch": "@@ -0,0 +1,11 @@\n+/* PR inline-asm/15740 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+void foo(void)\n+{\n+  int a, b;\n+  a = 1;\n+  b = a + 1;\n+  asm (\"\" : : \"m\" (a));\n+}"}, {"sha": "4e3244169c779d9d83b42779251dddbfcd392274", "filename": "gcc/testsuite/gcc.dg/asm-9.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f0c611c681e93dfb49bcd0d525f76d8c46af24/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-9.c?ref=74f0c611c681e93dfb49bcd0d525f76d8c46af24", "patch": "@@ -0,0 +1,11 @@\n+/* PR inline-asm/15740 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+void foo(void)\n+{\n+  int a, b;\n+  a = 1;\n+  b = a + 1;\n+  asm (\"\" : : \"m\" (a));\n+}"}]}