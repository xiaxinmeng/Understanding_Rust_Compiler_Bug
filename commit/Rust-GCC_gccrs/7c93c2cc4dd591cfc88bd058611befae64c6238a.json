{"sha": "7c93c2cc4dd591cfc88bd058611befae64c6238a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M5M2MyY2M0ZGQ1OTFjZmM4OGJkMDU4NjExYmVmYWU2NGM2MjM4YQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-04-01T07:58:44Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-04-01T07:58:44Z"}, "message": "i386.c (ix86_decompose_address): Look inside SUBREGs to fix addresses involving EBP and ESP.\n\n2005-04-01  Paolo Bonzini  <bonzini@gnu.org>\n\t    Jan Hubicka  <jh@suse.cz>\n\n\t* config/i386/i386.c (ix86_decompose_address): Look inside SUBREGs\n\tto fix addresses involving EBP and ESP.\n\t(aligned_operand, legitimate_address_p, ix86_address_cost): Be prepared\n\tfor SUBREGed registers.\n\t(legitimate_address_p): Accept SUBREGed registers.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r97376", "tree": {"sha": "1bff3f6a8b4f1bf49c00a449469810462a27c491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bff3f6a8b4f1bf49c00a449469810462a27c491"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c93c2cc4dd591cfc88bd058611befae64c6238a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c93c2cc4dd591cfc88bd058611befae64c6238a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c93c2cc4dd591cfc88bd058611befae64c6238a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c93c2cc4dd591cfc88bd058611befae64c6238a/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a288c5cd8c7b0201e0cfbbaba19193c7782969b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a288c5cd8c7b0201e0cfbbaba19193c7782969b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a288c5cd8c7b0201e0cfbbaba19193c7782969b4"}], "stats": {"total": 95, "additions": 65, "deletions": 30}, "files": [{"sha": "ab5c35f55052d33b912981f136b52db35d920725", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c93c2cc4dd591cfc88bd058611befae64c6238a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c93c2cc4dd591cfc88bd058611befae64c6238a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c93c2cc4dd591cfc88bd058611befae64c6238a", "patch": "@@ -1,3 +1,12 @@\n+2005-04-01  Paolo Bonzini  <bonzini@gnu.org>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\t* config/i386/i386.c (ix86_decompose_address): Look inside SUBREGs\n+\tto fix addresses involving EBP and ESP.\n+\t(aligned_operand, legitimate_address_p, ix86_address_cost): Be prepared\n+\tfor SUBREGed registers.\n+\t(legitimate_address_p): Accept SUBREGed registers.\n+\n 2005-04-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/19406"}, {"sha": "802103531d6720c733b57a4aaf1d79077f2e8ba4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c93c2cc4dd591cfc88bd058611befae64c6238a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c93c2cc4dd591cfc88bd058611befae64c6238a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7c93c2cc4dd591cfc88bd058611befae64c6238a", "patch": "@@ -4663,9 +4663,8 @@ ix86_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n int\n ix86_decompose_address (rtx addr, struct ix86_address *out)\n {\n-  rtx base = NULL_RTX;\n-  rtx index = NULL_RTX;\n-  rtx disp = NULL_RTX;\n+  rtx base = NULL_RTX, index = NULL_RTX, disp = NULL_RTX;\n+  rtx base_reg, index_reg;\n   HOST_WIDE_INT scale = 1;\n   rtx scale_rtx = NULL_RTX;\n   int retval = 1;\n@@ -4767,34 +4766,37 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n       scale = INTVAL (scale_rtx);\n     }\n \n+  base_reg = base && GET_CODE (base) == SUBREG ? SUBREG_REG (base) : base;\n+  index_reg = index && GET_CODE (index) == SUBREG ? SUBREG_REG (index) : index;\n+\n   /* Allow arg pointer and stack pointer as index if there is not scaling.  */\n-  if (base && index && scale == 1\n-      && (index == arg_pointer_rtx\n-\t  || index == frame_pointer_rtx\n-\t  || (REG_P (index) && REGNO (index) == STACK_POINTER_REGNUM)))\n+  if (base_reg && index_reg && scale == 1\n+      && (index_reg == arg_pointer_rtx\n+\t  || index_reg == frame_pointer_rtx\n+\t  || (REG_P (index_reg) && REGNO (index_reg) == STACK_POINTER_REGNUM)))\n     {\n-      rtx tmp = base;\n-      base = index;\n-      index = tmp;\n+      rtx tmp;\n+      tmp = base, base = index, index = tmp;\n+      tmp = base_reg, base_reg = index_reg, index_reg = tmp;\n     }\n \n   /* Special case: %ebp cannot be encoded as a base without a displacement.  */\n-  if ((base == hard_frame_pointer_rtx\n-       || base == frame_pointer_rtx\n-       || base == arg_pointer_rtx) && !disp)\n+  if ((base_reg == hard_frame_pointer_rtx\n+       || base_reg == frame_pointer_rtx\n+       || base_reg == arg_pointer_rtx) && !disp)\n     disp = const0_rtx;\n \n   /* Special case: on K6, [%esi] makes the instruction vector decoded.\n      Avoid this by transforming to [%esi+0].  */\n   if (ix86_tune == PROCESSOR_K6 && !optimize_size\n-      && base && !index && !disp\n-      && REG_P (base)\n-      && REGNO_REG_CLASS (REGNO (base)) == SIREG)\n+      && base_reg && !index_reg && !disp\n+      && REG_P (base_reg)\n+      && REGNO_REG_CLASS (REGNO (base_reg)) == SIREG)\n     disp = const0_rtx;\n \n   /* Special case: encode reg+reg instead of reg*2.  */\n   if (!base && index && scale && scale == 2)\n-    base = index, scale = 1;\n+    base = index, base_reg = index_reg, scale = 1;\n \n   /* Special case: scaling cannot be encoded without base or displacement.  */\n   if (!base && !disp && index && scale != 1)\n@@ -4823,6 +4825,11 @@ ix86_address_cost (rtx x)\n   if (!ix86_decompose_address (x, &parts))\n     abort ();\n \n+  if (parts.base && GET_CODE (parts.base) == SUBREG)\n+    parts.base = SUBREG_REG (parts.base);\n+  if (parts.index && GET_CODE (parts.index) == SUBREG)\n+    parts.index = SUBREG_REG (parts.index);\n+\n   /* More complex memory references are better.  */\n   if (parts.disp && parts.disp != const0_rtx)\n     cost--;\n@@ -5172,15 +5179,23 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \n   /* Validate base register.\n \n-     Don't allow SUBREG's here, it can lead to spill failures when the base\n-     is one word out of a two word structure, which is represented internally\n-     as a DImode int.  */\n+     Don't allow SUBREG's that span more than a word here.  It can lead to spill\n+     failures when the base is one word out of a two word structure, which is\n+     represented internally as a DImode int.  */\n \n   if (base)\n     {\n+      rtx reg;\n       reason_rtx = base;\n-\n-      if (GET_CODE (base) != REG)\n+  \n+      if (REG_P (base))\n+  \treg = base;\n+      else if (GET_CODE (base) == SUBREG\n+\t       && REG_P (SUBREG_REG (base))\n+\t       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (base)))\n+\t\t  <= UNITS_PER_WORD)\n+  \treg = SUBREG_REG (base);\n+      else\n \t{\n \t  reason = \"base is not a register\";\n \t  goto report_error;\n@@ -5192,8 +5207,8 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \t  goto report_error;\n \t}\n \n-      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (base))\n-\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (base)))\n+      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (reg))\n+\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (reg)))\n \t{\n \t  reason = \"base is not valid\";\n \t  goto report_error;\n@@ -5202,15 +5217,21 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \n   /* Validate index register.\n \n-     Don't allow SUBREG's here, it can lead to spill failures when the index\n-     is one word out of a two word structure, which is represented internally\n-     as a DImode int.  */\n+     Don't allow SUBREG's that span more than a word here -- same as above.  */\n \n   if (index)\n     {\n+      rtx reg;\n       reason_rtx = index;\n \n-      if (GET_CODE (index) != REG)\n+      if (REG_P (index))\n+  \treg = index;\n+      else if (GET_CODE (index) == SUBREG\n+\t       && REG_P (SUBREG_REG (index))\n+\t       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (index)))\n+\t\t  <= UNITS_PER_WORD)\n+  \treg = SUBREG_REG (index);\n+      else\n \t{\n \t  reason = \"index is not a register\";\n \t  goto report_error;\n@@ -5222,8 +5243,8 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \t  goto report_error;\n \t}\n \n-      if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (index))\n-\t  || (! strict && ! REG_OK_FOR_INDEX_NONSTRICT_P (index)))\n+      if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (reg))\n+\t  || (! strict && ! REG_OK_FOR_INDEX_NONSTRICT_P (reg)))\n \t{\n \t  reason = \"index is not valid\";\n \t  goto report_error;\n@@ -11834,6 +11855,11 @@ memory_address_length (rtx addr)\n   if (! ix86_decompose_address (addr, &parts))\n     abort ();\n \n+  if (parts.base && GET_CODE (parts.base) == SUBREG)\n+    parts.base = SUBREG_REG (parts.base);\n+  if (parts.index && GET_CODE (parts.index) == SUBREG)\n+    parts.index = SUBREG_REG (parts.index);\n+\n   base = parts.base;\n   index = parts.index;\n   disp = parts.disp;"}]}