{"sha": "4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ1ZjNmYmQ2MWFkN2U2YTEzNDI0ZmE3MjBiZGEzODg4ZDZlZjQyOQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2001-08-11T12:21:17Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2001-08-11T12:21:17Z"}, "message": "pt.c (maybe_fold_nontype_arg): Use TREE_TYPE of ARG as the criterion to avoid rebuilding expression tree...\n\n\t* pt.c (maybe_fold_nontype_arg): Use TREE_TYPE of ARG as the\n\tcriterion to avoid rebuilding expression tree instead of\n\tprocessing_template_decl.\n\n\t* g++.dg/template/unify1.C: New test.\n\nFrom-SVN: r44793", "tree": {"sha": "257e9e80272c3ee42c1a95508d54acfe64463c0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/257e9e80272c3ee42c1a95508d54acfe64463c0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/comments", "author": null, "committer": null, "parents": [{"sha": "91b54f7f3fcabd08aaa16079441956e7d3d8bebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b54f7f3fcabd08aaa16079441956e7d3d8bebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b54f7f3fcabd08aaa16079441956e7d3d8bebf"}], "stats": {"total": 59, "additions": 49, "deletions": 10}, "files": [{"sha": "29894a3a3fcc14c16b593a6262628735d9a2c1bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "patch": "@@ -1,3 +1,9 @@\n+2001-08-11  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* pt.c (maybe_fold_nontype_arg): Use TREE_TYPE of ARG as the\n+\tcriterion to avoid rebuilding expression tree instead of\n+\tprocessing_template_decl.\n+\n 2001-08-07  Jason Merrill  <jason_merrill@redhat.com>\n \n \tSupport named return value optimization for inlines, too."}, {"sha": "853fd81764367d37146b428b8aac3b604c33391a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "patch": "@@ -5280,12 +5280,7 @@ static tree\n maybe_fold_nontype_arg (arg)\n      tree arg;\n {\n-  /* If we're not in a template, ARG is already as simple as it's going to\n-     get, and trying to reprocess the trees will break.  */\n-  if (! processing_template_decl)\n-    return arg;\n-\n-  if (!TYPE_P (arg) && !uses_template_parms (arg))\n+  if (arg && !TYPE_P (arg) && !uses_template_parms (arg))\n     {\n       /* Sometimes, one of the args was an expression involving a\n \t template constant parameter, like N - 1.  Now that we've\n@@ -5295,10 +5290,18 @@ maybe_fold_nontype_arg (arg)\n \t fool build_expr_from_tree() into building an actual\n \t tree.  */\n \n-      int saved_processing_template_decl = processing_template_decl; \n-      processing_template_decl = 0;\n-      arg = fold (build_expr_from_tree (arg));\n-      processing_template_decl = saved_processing_template_decl; \n+      /* If the TREE_TYPE of ARG is not NULL_TREE, ARG is already\n+\t as simple as it's going to get, and trying to reprocess\n+\t the trees will break.  */\n+      if (!TREE_TYPE (arg))\n+\t{\n+\t  int saved_processing_template_decl = processing_template_decl; \n+\t  processing_template_decl = 0;\n+\t  arg = build_expr_from_tree (arg);\n+\t  processing_template_decl = saved_processing_template_decl; \n+\t}\n+\n+      arg = fold (arg);\n     }\n   return arg;\n }"}, {"sha": "c360084b36bff390fb54c56e603a8263ac95448f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "patch": "@@ -1,3 +1,7 @@\n+2001-08-11  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* g++.dg/template/unify1.C: New test.\n+\n 2001-08-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/abi/empty4.C: New test."}, {"sha": "2f0a18cf4574e083d08295c033ded217aed27e39", "filename": "gcc/testsuite/g++.dg/template/unify1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d5f3fbd61ad7e6a13424fa720bda3888d6ef429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Funify1.C?ref=4d5f3fbd61ad7e6a13424fa720bda3888d6ef429", "patch": "@@ -0,0 +1,26 @@\n+// Test non-type template argument folding.\n+// Origin: smacdonald@seimac.com\n+\n+// { dg-do compile }\n+\n+template < int I1, int I2 >\n+class unit\n+{\n+public:\n+  unit() {}\n+  unit( const unit<I1,I2>& ) {}\n+ \n+  template< int Q1, int Q2 >\n+  unit< I1 - Q1, I2 - Q2 > operator / ( const unit< Q1, Q2 >& rhs ) const {\n+    return unit< I1 - Q1, I2 - Q2 >();\n+  }\n+ \n+};\n+ \n+int main()\n+{\n+  const unit<1,0> u1;\n+  const unit<2,0> u2;\n+ \n+  unit<-1,0> u3( u1 / u2 );\n+}"}]}