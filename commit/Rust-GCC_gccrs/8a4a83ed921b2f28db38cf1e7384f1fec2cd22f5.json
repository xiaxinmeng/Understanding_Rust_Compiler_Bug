{"sha": "8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE0YTgzZWQ5MjFiMmYyOGRiMzhjZjFlNzM4NGYxZmVjMmNkMjJmNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-11T08:07:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-11T08:07:52Z"}, "message": "Move all varpool routines out of cgraph/cgraphunit to varpool.c\n\n\n\tMove all varpool routines out of cgraph/cgraphunit to varpool.c\n\t* cgraph.c: Update comments.\n\t(cgraph_varpool_hash,\n\tcgraph_varpool_nodes, cgraph_varpool_last_needed_node\n\tcgraph_varpool_node_name, cgraph_varpool_node,\n\tcgraph_varpol_mode_for_asm, cgraph_varpool_mark_needed_node,\n\tcgraph_variable_initializer_availability): Move to\n\tvarpool.c and drop cgraph_ prefixes.\n\t(cgraph_varpool_enqueue_needed_node, cgraph_varpool_reset_queue,\n\tcgraph_varpool_first_unanalyzed_node, cgraph_varpool_finalize_decl):\n\tmove to varpool.c; drop cgraph_ prefix; make static.\n\t(dump_cgraph_varpool_node): Move to varpool.c under name\n\tdump_varpool_node.\n\t(dump_varpool, hash_varpool_node, eq_varpool_node,\n\tdecide_is_variable_needed): Move to varpool.c\n\t(decl_assembler_name_equal): Move to tree.c.\n\t(availability_names): Rename to ...\n\t(cgraph_availability_names): ... this one.\n\t(dump_cgraph_node): Update.\n\t* cgraph.h: Reorder declarations now in varpool.c\n\t(cgraph_vailablity_names): Declare.\n\t(struct cgraph_varpool_node): Rename to ...\n\t(struct varpool_node): ... this one.\n\t(cgraph_varpool_first_unanalyzed_node, cgraph_varpool_nodes_queue,\n\tcgraph_varpool_first_unanalyzed_node, cgraph_varpool_node,\n\tcgraph_varpool_node_for_asm, cgraph_varpool_mark_needed_node,\n\tcgraph_varpool_finalize_decl, cgraph_varpool_enqueue_needed_node,\n\tcgraph_varpool_reset_queue, cgraph_varpool_assemble_pending_decls,\n\tcgraph_variable_initializer_availability): Rename to ...\n\t(varpool_first_unanalyzed_node, varpool_nodes_queue,\n\tvarpool_first_unanalyzed_node, varpool_node,\n\tvarpool_node_for_asm, varpool_mark_needed_node,\n\tvarpool_finalize_decl, varpool_enqueue_needed_node,\n\tvarpool_assemble_pending_decls, variable_initializer_availability):\n\tRename to ...\n\t* tree.c (decl_assembler_name_equal): Move here from cgraph.c.\n\t* tree.h (decl_assembler_name_equal): Declare.\n\t* omp-low.c (lower_omp_critical): Update.\n\t* ipa-reference (analyze_variable, static_execute): Likewise.\n\t* toplev.c (wrapup_global_declaration_2, compile_file): Update.\n\t* cgraphunit.c: Update comments.\n\t(cgraph_varpool_assembled_nodes_queue): Move to varpool.c under name\n\tvarpool_assembled_nodes_queue.\n\t(cgraph_varpool_analyze_pending_decls): Move to varpool.c under name\n\tvarpool_analyze_pending_decls.\n\t(cgraph_varpool_remove_unreferenced_decls): Move to varpool.c under name\n\tvarpool_remove_unreferenced_decls.\n\t(record_reference): Update.\n\t(cgraph_create_edges): Update.\n\t(record_referneces_in_initializer): New function.\n\t(cgraph_varpool_assemble_decl): Move to varpool.c under name\n\tvarpool_assemble_decl; make global.\n\t(cgraph_varpool_assemble_pending_decls): Move to varpool.c under name\n\tvarpool_assemble_pending_decls.\n\t(process_function_and_variable_attributes, cgraph_finalize_compilation_unit,\n\tstruct cgraph_order_sort, cgraph_output_in_order,\n\tcgraph_function_and_variable_invisibility, cgraph_optimize,\n\tcgraph_increase_alignment): Update.\n\t* dwarf2out.c (decls_for_scope): Likewise.\n\t* ipa-type-escape.c (analyze_variable, type_escape_execute): Likewise.\n\t* except.c (output_ttype): Likewise.\n\t* varasm.c (mark_decl_referenced): Likewise.\n\t(find_decl_and_mark_referenced, assemble_alias): update.\n\t* Makefile.in: Add varpool.c, gt-varpool.c and remove gt-cgraphunit.c\n\t* passes.c (rest_of_decl_compilation): Update.\n\n\t* cp/decl2.c (var_finalized_p): Update for renamed varpool functions.\n\t* fortran/f59-lang.c (gfc_expand_function): Update for renamed varpool functions.\n\nFrom-SVN: r119731", "tree": {"sha": "d172f85045dead90ab3d5c93716d8db81074fdec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d172f85045dead90ab3d5c93716d8db81074fdec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/comments", "author": null, "committer": null, "parents": [{"sha": "ce133c3fa2b6dba35d406285f420fef56cb2c445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce133c3fa2b6dba35d406285f420fef56cb2c445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce133c3fa2b6dba35d406285f420fef56cb2c445"}], "stats": {"total": 1210, "additions": 682, "deletions": 528}, "files": [{"sha": "7d7cf2828c2554275dcfed5ae7a754226d1f646c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -1,3 +1,71 @@\n+2006-12-11  Jan Hubicka  <jh@suse.cz>\n+\n+\tMove all varpool routines out of cgraph/cgraphunit to varpool.c\n+\t* cgraph.c: Update comments.\n+\t(cgraph_varpool_hash,\n+\tcgraph_varpool_nodes, cgraph_varpool_last_needed_node\n+\tcgraph_varpool_node_name, cgraph_varpool_node,\n+\tcgraph_varpol_mode_for_asm, cgraph_varpool_mark_needed_node,\n+\tcgraph_variable_initializer_availability): Move to\n+\tvarpool.c and drop cgraph_ prefixes.\n+\t(cgraph_varpool_enqueue_needed_node, cgraph_varpool_reset_queue,\n+\tcgraph_varpool_first_unanalyzed_node, cgraph_varpool_finalize_decl):\n+\tmove to varpool.c; drop cgraph_ prefix; make static.\n+\t(dump_cgraph_varpool_node): Move to varpool.c under name\n+\tdump_varpool_node.\n+\t(dump_varpool, hash_varpool_node, eq_varpool_node,\n+\tdecide_is_variable_needed): Move to varpool.c\n+\t(decl_assembler_name_equal): Move to tree.c.\n+\t(availability_names): Rename to ...\n+\t(cgraph_availability_names): ... this one.\n+\t(dump_cgraph_node): Update.\n+\t* cgraph.h: Reorder declarations now in varpool.c\n+\t(cgraph_vailablity_names): Declare.\n+\t(struct cgraph_varpool_node): Rename to ...\n+\t(struct varpool_node): ... this one.\n+\t(cgraph_varpool_first_unanalyzed_node, cgraph_varpool_nodes_queue,\n+\tcgraph_varpool_first_unanalyzed_node, cgraph_varpool_node,\n+\tcgraph_varpool_node_for_asm, cgraph_varpool_mark_needed_node,\n+\tcgraph_varpool_finalize_decl, cgraph_varpool_enqueue_needed_node,\n+\tcgraph_varpool_reset_queue, cgraph_varpool_assemble_pending_decls,\n+\tcgraph_variable_initializer_availability): Rename to ...\n+\t(varpool_first_unanalyzed_node, varpool_nodes_queue,\n+\tvarpool_first_unanalyzed_node, varpool_node,\n+\tvarpool_node_for_asm, varpool_mark_needed_node,\n+\tvarpool_finalize_decl, varpool_enqueue_needed_node,\n+\tvarpool_assemble_pending_decls, variable_initializer_availability):\n+\tRename to ...\n+\t* tree.c (decl_assembler_name_equal): Move here from cgraph.c.\n+\t* tree.h (decl_assembler_name_equal): Declare.\n+\t* omp-low.c (lower_omp_critical): Update.\n+\t* ipa-reference (analyze_variable, static_execute): Likewise.\n+\t* toplev.c (wrapup_global_declaration_2, compile_file): Update.\n+\t* cgraphunit.c: Update comments.\n+\t(cgraph_varpool_assembled_nodes_queue): Move to varpool.c under name\n+\tvarpool_assembled_nodes_queue.\n+\t(cgraph_varpool_analyze_pending_decls): Move to varpool.c under name\n+\tvarpool_analyze_pending_decls.\n+\t(cgraph_varpool_remove_unreferenced_decls): Move to varpool.c under name\n+\tvarpool_remove_unreferenced_decls.\n+\t(record_reference): Update.\n+\t(cgraph_create_edges): Update.\n+\t(record_referneces_in_initializer): New function.\n+\t(cgraph_varpool_assemble_decl): Move to varpool.c under name\n+\tvarpool_assemble_decl; make global.\n+\t(cgraph_varpool_assemble_pending_decls): Move to varpool.c under name\n+\tvarpool_assemble_pending_decls.\n+\t(process_function_and_variable_attributes, cgraph_finalize_compilation_unit,\n+\tstruct cgraph_order_sort, cgraph_output_in_order,\n+\tcgraph_function_and_variable_invisibility, cgraph_optimize,\n+\tcgraph_increase_alignment): Update.\n+\t* dwarf2out.c (decls_for_scope): Likewise.\n+\t* ipa-type-escape.c (analyze_variable, type_escape_execute): Likewise.\n+\t* except.c (output_ttype): Likewise.\n+\t* varasm.c (mark_decl_referenced): Likewise.\n+\t(find_decl_and_mark_referenced, assemble_alias): update.\n+\t* Makefile.in: Add varpool.c, gt-varpool.c and remove gt-cgraphunit.c\n+\t* passes.c (rest_of_decl_compilation): Update.\n+\n 2006-12-11  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Use "}, {"sha": "8613e6c40a05d207b8e87e68352d0486ee0df9ba", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -1024,7 +1024,7 @@ OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n   cgraph.o cgraphunit.o tree-nomudflap.o ipa.o ipa-inline.o                \\\n   ipa-utils.o ipa-reference.o ipa-pure-const.o ipa-type-escape.o           \\\n-  ipa-prop.o ipa-cp.o\n+  ipa-prop.o ipa-cp.o varpool.o\n \n OBJS = $(OBJS-common) $(out_object_file) $(OBJS-archive)\n \n@@ -2290,11 +2290,16 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n    $(TREE_INLINE_H) $(VARRAY_H) $(TREE_DUMP_H)\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(FLAGS_H) $(GGC_H) \\\n+   $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(TREE_GIMPLE_H) \\\n+   $(TREE_FLOW_H) tree-pass.h $(C_COMMON_H) debug.h $(DIAGNOSTIC_H) \\\n+   $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) ipa-prop.h \n+varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(TREE_GIMPLE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(C_COMMON_H) debug.h $(DIAGNOSTIC_H) \\\n    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) ipa-prop.h \\\n-   gt-cgraphunit.h\n+   gt-varpool.h\n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \n ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) ipa-prop.h \\\n@@ -2873,8 +2878,8 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n   $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \\\n   $(srcdir)/tree-ssa-structalias.c \\\n-  $(srcdir)/c-pragma.h $(srcdir)/omp-low.c \\\n-  $(srcdir)/targhooks.c $(srcdir)/cgraphunit.c $(out_file) \\\n+  $(srcdir)/c-pragma.h $(srcdir)/omp-low.c $(srcdir)/varpool.c \\\n+  $(srcdir)/targhooks.c $(out_file) \\\n   @all_gtfiles@\n \n GTFILES_FILES_LANGS = @all_gtfiles_files_langs@\n@@ -2904,8 +2909,8 @@ gt-tree-mudflap.h gt-tree-vect-generic.h \\\n gt-tree-profile.h gt-tree-ssa-address.h \\\n gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n-gt-tree-ssa-propagate.h \\\n-gt-tree-ssa-structalias.h gt-ipa-inline.h gt-cgraphunit.h \\\n+gt-tree-ssa-propagate.h gt-varpool.h \\\n+gt-tree-ssa-structalias.h gt-ipa-inline.h \\\n gt-stringpool.h gt-targhooks.h gt-omp-low.h : s-gtype ; @true\n \n define echo_quoted_to_gtyp"}, {"sha": "7706098ab3c96ab091a280abc31e88d88668140f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 288, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-/*  This file contains basic routines manipulating call graph and variable pool\n+/*  This file contains basic routines manipulating call graph\n \n The callgraph:\n \n@@ -69,15 +69,7 @@ The callgraph:\n \n       Each edge has \"inline_failed\" field.  When the field is set to NULL,\n       the call will be inlined.  When it is non-NULL it contains a reason\n-      why inlining wasn't performed.\n-\n-\n-The varpool data structure:\n-\n-    Varpool is used to maintain variables in similar manner as call-graph\n-    is used for functions.  Most of the API is symmetric replacing cgraph\n-    function prefix by cgraph_varpool  */\n-\n+      why inlining wasn't performed.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -130,18 +122,6 @@ bool cgraph_global_info_ready = false;\n /* Set when the cgraph is fully build and the basic flags are computed.  */\n bool cgraph_function_flags_ready = false;\n \n-/* Hash table used to convert declarations into nodes.  */\n-static GTY((param_is (struct cgraph_varpool_node))) htab_t cgraph_varpool_hash;\n-\n-/* Queue of cgraph nodes scheduled to be lowered and output.  */\n-struct cgraph_varpool_node *cgraph_varpool_nodes_queue, *cgraph_varpool_first_unanalyzed_node;\n-\n-/* The linked list of cgraph varpool nodes.  */\n-struct cgraph_varpool_node *cgraph_varpool_nodes;\n-\n-/* End of the varpool queue.  Needs to be QTYed to work with PCH.  */\n-static GTY(()) struct cgraph_varpool_node *cgraph_varpool_last_needed_node;\n-\n /* Linked list of cgraph asm nodes.  */\n struct cgraph_asm_node *cgraph_asm_nodes;\n \n@@ -243,40 +223,6 @@ cgraph_insert_node_to_hashtable (struct cgraph_node *node)\n   *slot = node;\n }\n \n-/* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n-\n-static bool\n-decl_assembler_name_equal (tree decl, tree asmname)\n-{\n-  tree decl_asmname = DECL_ASSEMBLER_NAME (decl);\n-\n-  if (decl_asmname == asmname)\n-    return true;\n-\n-  /* If the target assembler name was set by the user, things are trickier.\n-     We have a leading '*' to begin with.  After that, it's arguable what\n-     is the correct thing to do with -fleading-underscore.  Arguably, we've\n-     historically been doing the wrong thing in assemble_alias by always\n-     printing the leading underscore.  Since we're not changing that, make\n-     sure user_label_prefix follows the '*' before matching.  */\n-  if (IDENTIFIER_POINTER (decl_asmname)[0] == '*')\n-    {\n-      const char *decl_str = IDENTIFIER_POINTER (decl_asmname) + 1;\n-      size_t ulp_len = strlen (user_label_prefix);\n-\n-      if (ulp_len == 0)\n-\t;\n-      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n-\tdecl_str += ulp_len;\n-      else\n-\treturn false;\n-\n-      return strcmp (decl_str, IDENTIFIER_POINTER (asmname)) == 0;\n-    }\n-\n-  return false;\n-}\n-\n \n /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n    Return NULL if there's no such node.  */\n@@ -683,15 +629,8 @@ cgraph_node_name (struct cgraph_node *node)\n   return lang_hooks.decl_printable_name (node->decl, 2);\n }\n \n-/* Return name of the node used in debug output.  */\n-static const char *\n-cgraph_varpool_node_name (struct cgraph_varpool_node *node)\n-{\n-  return lang_hooks.decl_printable_name (node->decl, 2);\n-}\n-\n /* Names used to print out the availability enum.  */\n-static const char * const availability_names[] =\n+const char * const cgraph_availability_names[] =\n   {\"unset\", \"not_available\", \"overwrittable\", \"available\", \"local\"};\n \n /* Dump given cgraph node.  */\n@@ -706,7 +645,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t     node->global.inlined_to->uid);\n   if (cgraph_function_flags_ready)\n     fprintf (f, \" availability:%s\",\n-\t     availability_names [cgraph_function_body_availability (node)]);\n+\t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n   if (node->master_clone && node->master_clone->uid != node->uid)\n     fprintf (f, \"(%i)\", node->master_clone->uid);\n   if (node->count)\n@@ -785,100 +724,6 @@ dump_cgraph (FILE *f)\n     dump_cgraph_node (f, node);\n }\n \n-/* Dump given cgraph node.  */\n-void\n-dump_cgraph_varpool_node (FILE *f, struct cgraph_varpool_node *node)\n-{\n-  fprintf (f, \"%s:\", cgraph_varpool_node_name (node));\n-  fprintf (f, \" availability:%s\",\n-\t   cgraph_function_flags_ready\n-\t   ? availability_names[cgraph_variable_initializer_availability (node)]\n-\t   : \"not-ready\");\n-  if (DECL_INITIAL (node->decl))\n-    fprintf (f, \" initialized\");\n-  if (node->needed)\n-    fprintf (f, \" needed\");\n-  if (node->analyzed)\n-    fprintf (f, \" analyzed\");\n-  if (node->finalized)\n-    fprintf (f, \" finalized\");\n-  if (node->output)\n-    fprintf (f, \" output\");\n-  if (node->externally_visible)\n-    fprintf (f, \" externally_visible\");\n-  fprintf (f, \"\\n\");\n-}\n-\n-/* Dump the callgraph.  */\n-\n-void\n-dump_varpool (FILE *f)\n-{\n-  struct cgraph_varpool_node *node;\n-\n-  fprintf (f, \"variable pool:\\n\\n\");\n-  for (node = cgraph_varpool_nodes; node; node = node->next_needed)\n-    dump_cgraph_varpool_node (f, node);\n-}\n-\n-/* Returns a hash code for P.  */\n-\n-static hashval_t\n-hash_varpool_node (const void *p)\n-{\n-  const struct cgraph_varpool_node *n = (const struct cgraph_varpool_node *) p;\n-  return (hashval_t) DECL_UID (n->decl);\n-}\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-eq_varpool_node (const void *p1, const void *p2)\n-{\n-  const struct cgraph_varpool_node *n1 =\n-    (const struct cgraph_varpool_node *) p1;\n-  const struct cgraph_varpool_node *n2 =\n-    (const struct cgraph_varpool_node *) p2;\n-  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n-}\n-\n-/* Return cgraph_varpool node assigned to DECL.  Create new one when needed.  */\n-struct cgraph_varpool_node *\n-cgraph_varpool_node (tree decl)\n-{\n-  struct cgraph_varpool_node key, *node, **slot;\n-\n-  gcc_assert (DECL_P (decl) && TREE_CODE (decl) != FUNCTION_DECL);\n-\n-  if (!cgraph_varpool_hash)\n-    cgraph_varpool_hash = htab_create_ggc (10, hash_varpool_node,\n-\t\t\t\t\t   eq_varpool_node, NULL);\n-  key.decl = decl;\n-  slot = (struct cgraph_varpool_node **)\n-    htab_find_slot (cgraph_varpool_hash, &key, INSERT);\n-  if (*slot)\n-    return *slot;\n-  node = GGC_CNEW (struct cgraph_varpool_node);\n-  node->decl = decl;\n-  node->order = cgraph_order++;\n-  node->next = cgraph_varpool_nodes;\n-  cgraph_varpool_nodes = node;\n-  *slot = node;\n-  return node;\n-}\n-\n-struct cgraph_varpool_node *\n-cgraph_varpool_node_for_asm (tree asmname)\n-{\n-  struct cgraph_varpool_node *node;\n-\n-  for (node = cgraph_varpool_nodes; node ; node = node->next)\n-    if (decl_assembler_name_equal (node->decl, asmname))\n-      return node;\n-\n-  return NULL;\n-}\n-\n /* Set the DECL_ASSEMBLER_NAME and update cgraph hashtables.  */\n void\n change_decl_assembler_name (tree decl, tree name)\n@@ -898,116 +743,6 @@ change_decl_assembler_name (tree decl, tree name)\n   SET_DECL_ASSEMBLER_NAME (decl, name);\n }\n \n-/* Helper function for finalization code - add node into lists so it will\n-   be analyzed and compiled.  */\n-void\n-cgraph_varpool_enqueue_needed_node (struct cgraph_varpool_node *node)\n-{\n-  if (cgraph_varpool_last_needed_node)\n-    cgraph_varpool_last_needed_node->next_needed = node;\n-  cgraph_varpool_last_needed_node = node;\n-  node->next_needed = NULL;\n-  if (!cgraph_varpool_nodes_queue)\n-    cgraph_varpool_nodes_queue = node;\n-  if (!cgraph_varpool_first_unanalyzed_node)\n-    cgraph_varpool_first_unanalyzed_node = node;\n-  notice_global_symbol (node->decl);\n-}\n-\n-/* Reset the queue of needed nodes.  */\n-void\n-cgraph_varpool_reset_queue (void)\n-{\n-  cgraph_varpool_last_needed_node = NULL;\n-  cgraph_varpool_nodes_queue = NULL;\n-  cgraph_varpool_first_unanalyzed_node = NULL;\n-}\n-\n-/* Notify finalize_compilation_unit that given node is reachable\n-   or needed.  */\n-void\n-cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *node)\n-{\n-  if (!node->needed && node->finalized\n-      && !TREE_ASM_WRITTEN (node->decl))\n-    cgraph_varpool_enqueue_needed_node (node);\n-  node->needed = 1;\n-}\n-\n-/* Determine if variable DECL is needed.  That is, visible to something\n-   either outside this translation unit, something magic in the system\n-   configury, or (if not doing unit-at-a-time) to something we haven't\n-   seen yet.  */\n-\n-bool\n-decide_is_variable_needed (struct cgraph_varpool_node *node, tree decl)\n-{\n-  /* If the user told us it is used, then it must be so.  */\n-  if (node->externally_visible)\n-    return true;\n-  if (!flag_unit_at_a_time\n-      && lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-    return true;\n-\n-  /* ??? If the assembler name is set by hand, it is possible to assemble\n-     the name later after finalizing the function and the fact is noticed\n-     in assemble_name then.  This is arguably a bug.  */\n-  if (DECL_ASSEMBLER_NAME_SET_P (decl)\n-      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-    return true;\n-\n-  /* If we decided it was needed before, but at the time we didn't have\n-     the definition available, then it's still needed.  */\n-  if (node->needed)\n-    return true;\n-\n-  /* Externally visible variables must be output.  The exception is\n-     COMDAT variables that must be output only when they are needed.  */\n-  if (TREE_PUBLIC (decl) && !flag_whole_program && !DECL_COMDAT (decl)\n-      && !DECL_EXTERNAL (decl))\n-    return true;\n-\n-  /* When not reordering top level variables, we have to assume that\n-     we are going to keep everything.  */\n-  if (flag_unit_at_a_time && flag_toplevel_reorder)\n-    return false;\n-\n-  /* We want to emit COMDAT variables only when absolutely necessary.  */\n-  if (DECL_COMDAT (decl))\n-    return false;\n-  return true;\n-}\n-\n-void\n-cgraph_varpool_finalize_decl (tree decl)\n-{\n-  struct cgraph_varpool_node *node = cgraph_varpool_node (decl);\n-\n-  /* The first declaration of a variable that comes through this function\n-     decides whether it is global (in C, has external linkage)\n-     or local (in C, has internal linkage).  So do nothing more\n-     if this function has already run.  */\n-  if (node->finalized)\n-    {\n-      if (cgraph_global_info_ready || (!flag_unit_at_a_time && !flag_openmp))\n-\tcgraph_varpool_assemble_pending_decls ();\n-      return;\n-    }\n-  if (node->needed)\n-    cgraph_varpool_enqueue_needed_node (node);\n-  node->finalized = true;\n-\n-  if (decide_is_variable_needed (node, decl))\n-    cgraph_varpool_mark_needed_node (node);\n-  /* Since we reclaim unreachable nodes at the end of every language\n-     level unit, we need to be conservative about possible entry points\n-     there.  */\n-  else if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-    cgraph_varpool_mark_needed_node (node);\n-  if (cgraph_global_info_ready || (!flag_unit_at_a_time && !flag_openmp))\n-    cgraph_varpool_assemble_pending_decls ();\n-}\n-\n /* Add a top-level asm statement to the list.  */\n \n struct cgraph_asm_node *\n@@ -1181,25 +916,6 @@ cgraph_function_body_availability (struct cgraph_node *node)\n   return avail;\n }\n \n-/* Return variable availability.  See cgraph.h for description of individual\n-   return values.  */\n-enum availability\n-cgraph_variable_initializer_availability (struct cgraph_varpool_node *node)\n-{\n-  gcc_assert (cgraph_function_flags_ready);\n-  if (!node->finalized)\n-    return AVAIL_NOT_AVAILABLE;\n-  if (!TREE_PUBLIC (node->decl))\n-    return AVAIL_AVAILABLE;\n-  /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n-     care of at least two notable extensions - the COMDAT variables\n-     used to share template instantiations in C++.  */\n-  if (!(*targetm.binds_local_p) (node->decl) && !DECL_COMDAT (node->decl))\n-    return AVAIL_OVERWRITABLE;\n-  return AVAIL_AVAILABLE;\n-}\n-\n-\n /* Add the function FNDECL to the call graph.  FNDECL is assumed to be\n    in low GIMPLE form and ready to be processed by cgraph_finalize_function.\n "}, {"sha": "b60239c36629171199467c6e8568d8aa55586704", "filename": "gcc/cgraph.h", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -46,6 +46,8 @@ enum availability\n   AVAIL_LOCAL\n };\n \n+extern const char * const cgraph_availability_names[];\n+\n /* Information about the function collected locally.\n    Available after function is analyzed.  */\n \n@@ -204,16 +206,16 @@ typedef struct cgraph_edge *cgraph_edge_p;\n DEF_VEC_P(cgraph_edge_p);\n DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n \n-/* The cgraph_varpool data structure.\n-   Each static variable decl has assigned cgraph_varpool_node.  */\n+/* The varpool data structure.\n+   Each static variable decl has assigned varpool_node.  */\n \n-struct cgraph_varpool_node GTY(())\n+struct varpool_node GTY(())\n {\n   tree decl;\n-  /* Pointer to the next function in cgraph_varpool_nodes.  */\n-  struct cgraph_varpool_node *next;\n-  /* Pointer to the next function in cgraph_varpool_nodes_queue.  */\n-  struct cgraph_varpool_node *next_needed;\n+  /* Pointer to the next function in varpool_nodes.  */\n+  struct varpool_node *next;\n+  /* Pointer to the next function in varpool_nodes_queue.  */\n+  struct varpool_node *next_needed;\n   /* Ordering of all cgraph nodes.  */\n   int order;\n \n@@ -256,18 +258,13 @@ extern bool cgraph_function_flags_ready;\n extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n extern GTY(()) struct cgraph_node *cgraph_expand_queue;\n \n-extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_first_unanalyzed_node;\n-extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n-extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes;\n extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n extern GTY(()) int cgraph_order;\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n void dump_cgraph_node (FILE *, struct cgraph_node *);\n void cgraph_insert_node_to_hashtable (struct cgraph_node *node);\n-void dump_varpool (FILE *);\n-void dump_cgraph_varpool_node (FILE *, struct cgraph_varpool_node *);\n void cgraph_remove_edge (struct cgraph_edge *);\n void cgraph_remove_node (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n@@ -288,28 +285,19 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type,\n \t\t\t\t\tint, bool);\n \n-struct cgraph_varpool_node *cgraph_varpool_node (tree);\n-struct cgraph_varpool_node *cgraph_varpool_node_for_asm (tree asmname);\n-void cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\n-void cgraph_varpool_finalize_decl (tree);\n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n \n struct cgraph_asm_node *cgraph_add_asm_node (tree);\n \n bool cgraph_function_possibly_inlined_p (tree);\n void cgraph_unnest_node (struct cgraph_node *);\n-void cgraph_varpool_enqueue_needed_node (struct cgraph_varpool_node *);\n-void cgraph_varpool_reset_queue (void);\n-bool decide_is_variable_needed (struct cgraph_varpool_node *, tree);\n \n enum availability cgraph_function_body_availability (struct cgraph_node *);\n-enum availability cgraph_variable_initializer_availability (struct cgraph_varpool_node *);\n bool cgraph_is_master_clone (struct cgraph_node *);\n struct cgraph_node *cgraph_master_clone (struct cgraph_node *);\n void cgraph_add_new_function (tree);\n \n /* In cgraphunit.c  */\n-bool cgraph_varpool_assemble_pending_decls (void);\n void cgraph_finalize_function (tree, bool);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_optimize (void);\n@@ -327,11 +315,33 @@ struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tvarray_type);\n void cgraph_analyze_function (struct cgraph_node *);\n struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n+void record_references_in_initializer (tree);\n \n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);\n int cgraph_postorder (struct cgraph_node **);\n \n+/* In varpool.c  */\n+\n+extern GTY(()) struct varpool_node *varpool_nodes_queue;\n+extern GTY(()) struct varpool_node *varpool_nodes;\n+\n+struct varpool_node *varpool_node (tree);\n+struct varpool_node *varpool_node_for_asm (tree asmname);\n+void varpool_mark_needed_node (struct varpool_node *);\n+void dump_varpool (FILE *);\n+void dump_varpool_node (FILE *, struct varpool_node *);\n+\n+void varpool_finalize_decl (tree);\n+bool decide_is_variable_needed (struct varpool_node *, tree);\n+enum availability cgraph_variable_initializer_availability (struct varpool_node *);\n+\n+bool varpool_assemble_pending_decls (void);\n+bool varpool_assemble_decl (struct varpool_node *node);\n+bool varpool_analyze_pending_decls (void);\n+void varpool_output_debug_info (void);\n+void varpool_remove_unreferenced_decls (void);\n+\n /* In ipa-inline.c  */\n bool cgraph_decide_inlining_incrementally (struct cgraph_node *, bool);\n void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool, bool);"}, {"sha": "73015b6f29b68f50880d8df37150dfc58ca21c55", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 42, "deletions": 186, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -35,7 +35,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n       (There is one exception needed for implementing GCC extern inline\n \tfunction.)\n \n-    - cgraph_varpool_finalize_variable\n+    - varpool_finalize_variable\n \n       This function has same behavior as the above but is used for static\n       variables.\n@@ -60,7 +60,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n       modify calling conventions, do better inlining or similar optimizations.\n \n     - cgraph_mark_needed_node\n-    - cgraph_varpool_mark_needed_node\n+    - varpool_mark_needed_node\n \n       When function or variable is referenced by some hidden way the call-graph\n       data structure must be updated accordingly by this function.\n@@ -82,8 +82,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n       This function is used to expand function and pass it into RTL back-end.\n       Front-end should not make any assumptions about when this function can be\n       called.  In particular cgraph_assemble_pending_functions,\n-      cgraph_varpool_assemble_pending_variables, cgraph_finalize_function,\n-      cgraph_varpool_finalize_function, cgraph_optimize can cause arbitrarily\n+      varpool_assemble_pending_variables, cgraph_finalize_function,\n+      varpool_finalize_function, cgraph_optimize can cause arbitrarily\n       previously finalized functions to be expanded.\n \n     We implement two compilation modes.\n@@ -168,9 +168,6 @@ static tree record_reference (tree *, int *, void *);\n static void cgraph_output_pending_asms (void);\n static void cgraph_increase_alignment (void);\n \n-/* Lists all assembled variables to be sent to debugger output later on.  */\n-static GTY(()) struct cgraph_varpool_node *cgraph_varpool_assembled_nodes_queue;\n-\n /* Records tree nodes seen in record_reference.  Simply using\n    walk_tree_without_duplicates doesn't guarantee each node is visited\n    once because it gets a new htab upon each recursive call from\n@@ -265,83 +262,6 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   return false;\n }\n \n-/* Walk the decls we marked as necessary and see if they reference new\n-   variables or functions and add them into the worklists.  */\n-static bool\n-cgraph_varpool_analyze_pending_decls (void)\n-{\n-  bool changed = false;\n-  timevar_push (TV_CGRAPH);\n-\n-  while (cgraph_varpool_first_unanalyzed_node)\n-    {\n-      tree decl = cgraph_varpool_first_unanalyzed_node->decl;\n-\n-      cgraph_varpool_first_unanalyzed_node->analyzed = true;\n-\n-      cgraph_varpool_first_unanalyzed_node = cgraph_varpool_first_unanalyzed_node->next_needed;\n-\n-      /* Compute the alignment early so function body expanders are\n-\t already informed about increased alignment.  */\n-      align_variable (decl, 0);\n-\n-      if (DECL_INITIAL (decl))\n-\t{\n-\t  visited_nodes = pointer_set_create ();\n-\t  walk_tree (&DECL_INITIAL (decl), record_reference, NULL, visited_nodes);\n-\t  pointer_set_destroy (visited_nodes);\n-\t  visited_nodes = NULL;\n-\t}\n-      changed = true;\n-    }\n-  timevar_pop (TV_CGRAPH);\n-  return changed;\n-}\n-\n-/* Optimization of function bodies might've rendered some variables as\n-   unnecessary so we want to avoid these from being compiled.\n-\n-   This is done by pruning the queue and keeping only the variables that\n-   really appear needed (ie they are either externally visible or referenced\n-   by compiled function). Re-doing the reachability analysis on variables\n-   brings back the remaining variables referenced by these.  */\n-static void\n-cgraph_varpool_remove_unreferenced_decls (void)\n-{\n-  struct cgraph_varpool_node *next, *node = cgraph_varpool_nodes_queue;\n-\n-  cgraph_varpool_reset_queue ();\n-\n-  if (errorcount || sorrycount)\n-    return;\n-\n-  while (node)\n-    {\n-      tree decl = node->decl;\n-      next = node->next_needed;\n-      node->needed = 0;\n-\n-      if (node->finalized\n-\t  && ((DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t      || node->force_output\n-\t      || decide_is_variable_needed (node, decl)\n-\t      /* ??? Cgraph does not yet rule the world with an iron hand,\n-\t\t and does not control the emission of debug information.\n-\t\t After a variable has its DECL_RTL set, we must assume that\n-\t\t it may be referenced by the debug information, and we can\n-\t\t no longer elide it.  */\n-\t      || DECL_RTL_SET_P (decl)))\n-\tcgraph_varpool_mark_needed_node (node);\n-\n-      node = next;\n-    }\n-  /* Make sure we mark alias targets as used targets.  */\n-  finish_aliases_1 ();\n-  cgraph_varpool_analyze_pending_decls ();\n-}\n-\n-\n /* When not doing unit-at-a-time, output all functions enqueued.\n    Return true when such a functions were found.  */\n \n@@ -521,7 +441,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t after rtl has been generated.  */\n       if (TREE_STATIC (t) || DECL_EXTERNAL (t))\n \t{\n-\t  cgraph_varpool_mark_needed_node (cgraph_varpool_node (t));\n+\t  varpool_mark_needed_node (varpool_node (t));\n \t  if (lang_hooks.callgraph.analyze_expr)\n \t    return lang_hooks.callgraph.analyze_expr (tp, walk_subtrees,\n \t\t\t\t\t\t      data);\n@@ -602,7 +522,7 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n       if (TREE_CODE (decl) == VAR_DECL\n \t  && (TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n \t  && flag_unit_at_a_time)\n-\tcgraph_varpool_finalize_decl (decl);\n+\tvarpool_finalize_decl (decl);\n       else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n \twalk_tree (&DECL_INITIAL (decl), record_reference, node, visited_nodes);\n     }\n@@ -611,6 +531,16 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n   visited_nodes = NULL;\n }\n \n+void\n+record_references_in_initializer (tree decl)\n+{\n+  visited_nodes = pointer_set_create ();\n+  walk_tree (&DECL_INITIAL (decl), record_reference, NULL, visited_nodes);\n+  pointer_set_destroy (visited_nodes);\n+  visited_nodes = NULL;\n+}\n+\n+\n /* Give initial reasons why inlining would fail.  Those gets\n    either NULLified or usually overwritten by more precise reason\n    later.  */\n@@ -844,78 +774,6 @@ verify_cgraph (void)\n     verify_cgraph_node (node);\n }\n \n-/* Output one variable, if necessary.  Return whether we output it.  */\n-static bool\n-cgraph_varpool_assemble_decl (struct cgraph_varpool_node *node)\n-{\n-  tree decl = node->decl;\n-\n-  if (!TREE_ASM_WRITTEN (decl)\n-      && !node->alias\n-      && !DECL_EXTERNAL (decl)\n-      && (TREE_CODE (decl) != VAR_DECL || !DECL_HAS_VALUE_EXPR_P (decl)))\n-    {\n-      assemble_variable (decl, 0, 1, 0);\n-      return TREE_ASM_WRITTEN (decl);\n-    }\n-\n-  return false;\n-}\n-\n-/* Output all variables enqueued to be assembled.  */\n-bool\n-cgraph_varpool_assemble_pending_decls (void)\n-{\n-  bool changed = false;\n-\n-  if (errorcount || sorrycount)\n-    return false;\n-\n-  /* EH might mark decls as needed during expansion.  This should be safe since\n-     we don't create references to new function, but it should not be used\n-     elsewhere.  */\n-  cgraph_varpool_analyze_pending_decls ();\n-\n-  while (cgraph_varpool_nodes_queue)\n-    {\n-      struct cgraph_varpool_node *node = cgraph_varpool_nodes_queue;\n-\n-      cgraph_varpool_nodes_queue = cgraph_varpool_nodes_queue->next_needed;\n-      if (cgraph_varpool_assemble_decl (node))\n-\t{\n-\t  changed = true;\n-\t  node->next_needed = cgraph_varpool_assembled_nodes_queue;\n-\t  cgraph_varpool_assembled_nodes_queue = node;\n-\t  node->finalized = 1;\n-\t}\n-      else\n-        node->next_needed = NULL;\n-    }\n-  return changed;\n-}\n-/* Output all variables enqueued to be assembled.  */\n-static void\n-cgraph_varpool_output_debug_info (void)\n-{\n-  timevar_push (TV_SYMOUT);\n-  if (errorcount == 0 && sorrycount == 0)\n-    while (cgraph_varpool_assembled_nodes_queue)\n-      {\n-\tstruct cgraph_varpool_node *node = cgraph_varpool_assembled_nodes_queue;\n-\n-\t/* Local static variables are never seen by check_global_declarations\n-\t   so we need to output debug info by hand.  */\n-\tif (DECL_CONTEXT (node->decl)\n-\t    && (TREE_CODE (DECL_CONTEXT (node->decl)) == BLOCK\n-\t\t|| TREE_CODE (DECL_CONTEXT (node->decl)) == FUNCTION_DECL)\n-\t    && errorcount == 0 && sorrycount == 0)\n-\t     (*debug_hooks->global_decl) (node->decl);\n-\tcgraph_varpool_assembled_nodes_queue = node->next_needed;\n-\tnode->next_needed = 0;\n-      }\n-  timevar_pop (TV_SYMOUT);\n-}\n-\n /* Output all asm statements we have stored up to be output.  */\n \n static void\n@@ -990,10 +848,10 @@ cgraph_analyze_function (struct cgraph_node *node)\n \n static void\n process_function_and_variable_attributes (struct cgraph_node *first,\n-                                          struct cgraph_varpool_node *first_var)\n+                                          struct varpool_node *first_var)\n {\n   struct cgraph_node *node;\n-  struct cgraph_varpool_node *vnode;\n+  struct varpool_node *vnode;\n \n   for (node = cgraph_nodes; node != first; node = node->next)\n     {\n@@ -1018,14 +876,14 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t    }\n \t}\n     }\n-  for (vnode = cgraph_varpool_nodes; vnode != first_var; vnode = vnode->next)\n+  for (vnode = varpool_nodes; vnode != first_var; vnode = vnode->next)\n     {\n       tree decl = vnode->decl;\n       if (lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n \t{\n \t  mark_decl_referenced (decl);\n \t  if (vnode->finalized)\n-\t    cgraph_varpool_mark_needed_node (vnode);\n+\t    varpool_mark_needed_node (vnode);\n \t}\n       if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n@@ -1036,7 +894,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t  else\n \t    {\n \t      if (vnode->finalized)\n-\t\tcgraph_varpool_mark_needed_node (vnode);\n+\t\tvarpool_mark_needed_node (vnode);\n \t      vnode->externally_visible = true;\n \t    }\n \t}\n@@ -1053,7 +911,7 @@ cgraph_finalize_compilation_unit (void)\n      intermodule optimization.  */\n   static struct cgraph_node *first_analyzed;\n   struct cgraph_node *first_processed = first_analyzed;\n-  static struct cgraph_varpool_node *first_analyzed_var;\n+  static struct varpool_node *first_analyzed_var;\n \n   if (errorcount || sorrycount)\n     return;\n@@ -1064,7 +922,7 @@ cgraph_finalize_compilation_unit (void)\n     {\n       cgraph_output_pending_asms ();\n       cgraph_assemble_pending_functions ();\n-      cgraph_varpool_output_debug_info ();\n+      varpool_output_debug_info ();\n       return;\n     }\n \n@@ -1078,8 +936,8 @@ cgraph_finalize_compilation_unit (void)\n   process_function_and_variable_attributes (first_processed,\n \t\t\t\t\t    first_analyzed_var);\n   first_processed = cgraph_nodes;\n-  first_analyzed_var = cgraph_varpool_nodes;\n-  cgraph_varpool_analyze_pending_decls ();\n+  first_analyzed_var = varpool_nodes;\n+  varpool_analyze_pending_decls ();\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Initial entry points:\");\n@@ -1125,8 +983,8 @@ cgraph_finalize_compilation_unit (void)\n       process_function_and_variable_attributes (first_processed,\n \t\t\t\t\t\tfirst_analyzed_var);\n       first_processed = cgraph_nodes;\n-      first_analyzed_var = cgraph_varpool_nodes;\n-      cgraph_varpool_analyze_pending_decls ();\n+      first_analyzed_var = varpool_nodes;\n+      varpool_analyze_pending_decls ();\n     }\n \n   /* Collect entry points to the unit.  */\n@@ -1328,7 +1186,7 @@ struct cgraph_order_sort\n   union\n   {\n     struct cgraph_node *f;\n-    struct cgraph_varpool_node *v;\n+    struct varpool_node *v;\n     struct cgraph_asm_node *a;\n   } u;\n };\n@@ -1347,15 +1205,15 @@ cgraph_output_in_order (void)\n   struct cgraph_order_sort *nodes;\n   int i;\n   struct cgraph_node *pf;\n-  struct cgraph_varpool_node *pv;\n+  struct varpool_node *pv;\n   struct cgraph_asm_node *pa;\n \n   max = cgraph_order;\n   size = max * sizeof (struct cgraph_order_sort);\n   nodes = (struct cgraph_order_sort *) alloca (size);\n   memset (nodes, 0, size);\n \n-  cgraph_varpool_analyze_pending_decls ();\n+  varpool_analyze_pending_decls ();\n \n   for (pf = cgraph_nodes; pf; pf = pf->next)\n     {\n@@ -1368,7 +1226,7 @@ cgraph_output_in_order (void)\n \t}\n     }\n \n-  for (pv = cgraph_varpool_nodes_queue; pv; pv = pv->next_needed)\n+  for (pv = varpool_nodes_queue; pv; pv = pv->next_needed)\n     {\n       i = pv->order;\n       gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n@@ -1394,7 +1252,7 @@ cgraph_output_in_order (void)\n \t  break;\n \n \tcase ORDER_VAR:\n-\t  cgraph_varpool_assemble_decl (nodes[i].u.v);\n+\t  varpool_assemble_decl (nodes[i].u.v);\n \t  break;\n \n \tcase ORDER_ASM:\n@@ -1427,7 +1285,7 @@ static void\n cgraph_function_and_variable_visibility (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_varpool_node *vnode;\n+  struct varpool_node *vnode;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n@@ -1447,7 +1305,7 @@ cgraph_function_and_variable_visibility (void)\n \t\t\t   && !DECL_EXTERNAL (node->decl)\n \t\t\t   && !node->local.externally_visible);\n     }\n-  for (vnode = cgraph_varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     {\n       if (vnode->needed\n \t  && !flag_whole_program\n@@ -1525,16 +1383,16 @@ cgraph_optimize (void)\n   if (!flag_unit_at_a_time)\n     {\n       cgraph_output_pending_asms ();\n-      cgraph_varpool_assemble_pending_decls ();\n-      cgraph_varpool_output_debug_info ();\n+      varpool_assemble_pending_decls ();\n+      varpool_output_debug_info ();\n       return;\n     }\n \n   process_pending_assemble_externals ();\n \n   /* Frontend may output common variables after the unit has been finalized.\n      It is safe to deal with them here as they are always zero initialized.  */\n-  cgraph_varpool_analyze_pending_decls ();\n+  varpool_analyze_pending_decls ();\n \n   timevar_push (TV_CGRAPHOPT);\n   if (!quiet_flag)\n@@ -1580,10 +1438,10 @@ cgraph_optimize (void)\n       cgraph_output_pending_asms ();\n \n       cgraph_expand_all_functions ();\n-      cgraph_varpool_remove_unreferenced_decls ();\n+      varpool_remove_unreferenced_decls ();\n \n-      cgraph_varpool_assemble_pending_decls ();\n-      cgraph_varpool_output_debug_info ();\n+      varpool_assemble_pending_decls ();\n+      varpool_output_debug_info ();\n     }\n \n   if (cgraph_dump_file)\n@@ -1627,10 +1485,10 @@ cgraph_increase_alignment (void)\n {\n   if (flag_section_anchors && flag_tree_vectorize)\n     {\n-      struct cgraph_varpool_node *vnode;\n+      struct varpool_node *vnode;\n \n       /* Increase the alignment of all global arrays for vectorization.  */\n-      for (vnode = cgraph_varpool_nodes_queue;\n+      for (vnode = varpool_nodes_queue;\n            vnode;\n            vnode = vnode->next_needed)\n         {\n@@ -1923,5 +1781,3 @@ save_inline_function_body (struct cgraph_node *node)\n #endif\n   return first_clone;\n }\n-\n-#include \"gt-cgraphunit.h\""}, {"sha": "54b244ce1f7e9665a76413a7404c0e797771d890", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -1,3 +1,7 @@\n+2006-12-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (var_finalized_p): Update for renamed varpool functions.\n+\n 2006-12-09  Zack Weinberg  <zackw@panix.com>\n \n \t* parser.c (yydebug, enum pragma_omp_clause): Delete."}, {"sha": "0c0695e8b7f9dadd773119ebe6f17ee9f1b0a19a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -1410,7 +1410,7 @@ import_export_class (tree ctype)\n static bool\n var_finalized_p (tree var)\n {\n-  return cgraph_varpool_node (var)->finalized;\n+  return varpool_node (var)->finalized;\n }\n \n /* DECL is a VAR_DECL or FUNCTION_DECL which, for whatever reason,"}, {"sha": "a9f6308a934031507b04948ec5e7506ac971b585", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -12926,7 +12926,7 @@ decls_for_scope (tree stmt, dw_die_ref context_die, int depth)\n \t    add_child_die (context_die, die);\n \t  /* Do not produce debug information for static variables since\n \t     these might be optimized out.  We are called for these later\n-\t     in cgraph_varpool_analyze_pending_decls. */\n+\t     in varpool_analyze_pending_decls. */\n \t  if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n \t    ;\n \t  else"}, {"sha": "9f40dc47694419622f270c4a80252c05dfbea928", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -3581,7 +3581,7 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n     value = const0_rtx;\n   else\n     {\n-      struct cgraph_varpool_node *node;\n+      struct varpool_node *node;\n \n       type = lookup_type_for_runtime (type);\n       value = expand_expr (type, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n@@ -3595,9 +3595,9 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n \t  type = TREE_OPERAND (type, 0);\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n-\t      node = cgraph_varpool_node (type);\n+\t      node = varpool_node (type);\n \t      if (node)\n-\t\tcgraph_varpool_mark_needed_node (node);\n+\t\tvarpool_mark_needed_node (node);\n \t      public = TREE_PUBLIC (type);\n \t    }\n \t}"}, {"sha": "e3b685206ebed59e4c43ee2d7c9394c4e211011d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -1,3 +1,7 @@\n+2006-12-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* f59-lang.c (gfc_expand_function): Update for renamed varpool functions.\n+\n 2006-12-10  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.texi: Update Fortran 2003 section."}, {"sha": "4caaa1a63c315e724b3f77c8b216df8abb6481d8", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -226,7 +226,7 @@ gfc_expand_function (tree fndecl)\n \t\t&& TREE_CODE (TREE_OPERAND (expr, 0)) == VAR_DECL\n \t\t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n \t\t   == UNION_TYPE\n-\t\t&& cgraph_varpool_node (TREE_OPERAND (expr, 0))->needed\n+\t\t&& varpool_node (TREE_OPERAND (expr, 0))->needed\n \t\t&& errorcount == 0 && sorrycount == 0)\n \t      {\n \t\ttimevar_push (TV_SYMOUT);"}, {"sha": "9427fd5db8c6a3ea65e5119531e66151120cf453", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -770,7 +770,7 @@ ipa_init (void)\n    to variables defined within this unit.  */\n \n static void \n-analyze_variable (struct cgraph_varpool_node *vnode)\n+analyze_variable (struct varpool_node *vnode)\n {\n   tree global = vnode->decl;\n   if (TREE_CODE (global) == VAR_DECL)\n@@ -892,7 +892,7 @@ static unsigned int\n static_execute (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_varpool_node *vnode;\n+  struct varpool_node *vnode;\n   struct cgraph_node *w;\n   struct cgraph_node **order =\n     xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n@@ -902,7 +902,7 @@ static_execute (void)\n   ipa_init ();\n \n   /* Process all of the variables first.  */\n-  for (vnode = cgraph_varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     analyze_variable (vnode);\n \n   /* Process all of the functions next. "}, {"sha": "faddb7754cda47252238e2f4a66a07d63dfd3000", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -1337,7 +1337,7 @@ ipa_init (void)\n    to variables defined within this unit.  */\n \n static void \n-analyze_variable (struct cgraph_varpool_node *vnode)\n+analyze_variable (struct varpool_node *vnode)\n {\n   tree global = vnode->decl;\n   tree type = get_canon_type (TREE_TYPE (global), false, false);\n@@ -1674,15 +1674,15 @@ static unsigned int\n type_escape_execute (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_varpool_node *vnode;\n+  struct varpool_node *vnode;\n   unsigned int i;\n   bitmap_iterator bi;\n   splay_tree_node result;\n \n   ipa_init ();\n \n   /* Process all of the variables first.  */\n-  for (vnode = cgraph_varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     analyze_variable (vnode);\n \n   /* Process all of the functions. next"}, {"sha": "edd58d47e2d4ffa97dc309327e28a9f036d676d8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -1,3 +1,8 @@\n+2006-11-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* resource.c (compile_resource_data): Update for new varpool names.\n+\t* java/class.c (build_utf8_ref): Likewise.\n+\n 2006-11-12  David Daney  <ddaney@avtrex.com>\n \n \tPR java/29805"}, {"sha": "b1faafc616c30dc460463677901f0cee4725df60", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -937,7 +937,7 @@ build_utf8_ref (tree name)\n   layout_decl (decl, 0);\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, global_bindings_p (), 0);\n-  cgraph_varpool_mark_needed_node (cgraph_varpool_node (decl));\n+  varpool_mark_needed_node (varpool_node (decl));\n   utf8_decl_list = decl;\n   ref = build1 (ADDR_EXPR, utf8const_ptr_type, decl);\n   IDENTIFIER_UTF8_REF (name) = ref;"}, {"sha": "b0b941cc8dcafb7ec4022481fcbb5d1b7be89783", "filename": "gcc/java/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -93,7 +93,7 @@ compile_resource_data (const char *name, const char *buffer, int length)\n   layout_decl (decl, 0);\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, global_bindings_p (), 0);\n-  cgraph_varpool_finalize_decl (decl);\n+  varpool_finalize_decl (decl);\n \n   resources = tree_cons (NULL_TREE, decl, resources);\n }"}, {"sha": "141efa04b7e1e33a15158a8f7cbb0e69ce9cecb4", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -3929,7 +3929,7 @@ lower_omp_critical (tree *stmt_p, omp_context *ctx)\n \t  DECL_COMMON (decl) = 1;\n \t  DECL_ARTIFICIAL (decl) = 1;\n \t  DECL_IGNORED_P (decl) = 1;\n-\t  cgraph_varpool_finalize_decl (decl);\n+\t  varpool_finalize_decl (decl);\n \n \t  splay_tree_insert (critical_name_mutexes, (splay_tree_key) name,\n \t\t\t     (splay_tree_value) decl);"}, {"sha": "e5faaa464f39c36271deb80f8ac860c46d885946", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -159,7 +159,7 @@ rest_of_decl_compilation (tree decl,\n \t  && !DECL_EXTERNAL (decl))\n \t{\n \t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    cgraph_varpool_finalize_decl (decl);\n+\t    varpool_finalize_decl (decl);\n \t  else\n \t    assemble_variable (decl, top_level, at_end, 0);\n \t}\n@@ -186,7 +186,7 @@ rest_of_decl_compilation (tree decl,\n \n   /* Let cgraph know about the existence of variables.  */\n   if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n-    cgraph_varpool_node (decl);\n+    varpool_node (decl);\n }\n \n /* Called after finishing a record, union or enumeral type.  */"}, {"sha": "0aa6f6cf3ead55e67048cf74749401cfec73112b", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -751,9 +751,9 @@ wrapup_global_declaration_2 (tree decl)\n \n   if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n     {\n-      struct cgraph_varpool_node *node;\n+      struct varpool_node *node;\n       bool needed = true;\n-      node = cgraph_varpool_node (decl);\n+      node = varpool_node (decl);\n \n       if (node->finalized)\n \tneeded = false;\n@@ -1042,7 +1042,7 @@ compile_file (void)\n   if (errorcount || sorrycount)\n     return;\n \n-  cgraph_varpool_assemble_pending_decls ();\n+  varpool_assemble_pending_decls ();\n   finish_aliases_2 ();\n \n   /* This must occur after the loop to output deferred functions."}, {"sha": "2c6f3b855b0919f56af610bcf7c559e5bd74bc1f", "filename": "gcc/tree.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -307,6 +307,40 @@ decl_assembler_name (tree decl)\n   return DECL_WITH_VIS_CHECK (decl)->decl_with_vis.assembler_name;\n }\n \n+/* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n+\n+bool\n+decl_assembler_name_equal (tree decl, tree asmname)\n+{\n+  tree decl_asmname = DECL_ASSEMBLER_NAME (decl);\n+\n+  if (decl_asmname == asmname)\n+    return true;\n+\n+  /* If the target assembler name was set by the user, things are trickier.\n+     We have a leading '*' to begin with.  After that, it's arguable what\n+     is the correct thing to do with -fleading-underscore.  Arguably, we've\n+     historically been doing the wrong thing in assemble_alias by always\n+     printing the leading underscore.  Since we're not changing that, make\n+     sure user_label_prefix follows the '*' before matching.  */\n+  if (IDENTIFIER_POINTER (decl_asmname)[0] == '*')\n+    {\n+      const char *decl_str = IDENTIFIER_POINTER (decl_asmname) + 1;\n+      size_t ulp_len = strlen (user_label_prefix);\n+\n+      if (ulp_len == 0)\n+\t;\n+      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n+\tdecl_str += ulp_len;\n+      else\n+\treturn false;\n+\n+      return strcmp (decl_str, IDENTIFIER_POINTER (asmname)) == 0;\n+    }\n+\n+  return false;\n+}\n+\n /* Compute the number of bytes occupied by a tree with code CODE.\n    This function cannot be used for TREE_VEC, PHI_NODE, or STRING_CST\n    codes, which are of variable length.  */"}, {"sha": "389ea16f75a7a5a6b0afbcb8a67c783ef3ab5a48", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -3496,6 +3496,7 @@ enum ptrmemfunc_vbit_where_t\n #define NULL_TREE (tree) NULL\n \n extern tree decl_assembler_name (tree);\n+extern bool decl_assembler_name_equal (tree decl, tree asmname);\n \n /* Compute the number of bytes occupied by 'node'.  This routine only\n    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */"}, {"sha": "50487d283ffcf9d92a3b50342887db082a15f98f", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -2018,8 +2018,8 @@ mark_decl_referenced (tree decl)\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      struct cgraph_varpool_node *node = cgraph_varpool_node (decl);\n-      cgraph_varpool_mark_needed_node (node);\n+      struct varpool_node *node = varpool_node (decl);\n+      varpool_mark_needed_node (node);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n       node->force_output = true;\n@@ -4808,17 +4808,17 @@ static tree\n find_decl_and_mark_needed (tree decl, tree target)\n {\n   struct cgraph_node *fnode = NULL;\n-  struct cgraph_varpool_node *vnode = NULL;\n+  struct varpool_node *vnode = NULL;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       fnode = cgraph_node_for_asm (target);\n       if (fnode == NULL)\n-\tvnode = cgraph_varpool_node_for_asm (target);\n+\tvnode = varpool_node_for_asm (target);\n     }\n   else\n     {\n-      vnode = cgraph_varpool_node_for_asm (target);\n+      vnode = varpool_node_for_asm (target);\n       if (vnode == NULL)\n \tfnode = cgraph_node_for_asm (target);\n     }\n@@ -4836,7 +4836,7 @@ find_decl_and_mark_needed (tree decl, tree target)\n     }\n   else if (vnode)\n     {\n-      cgraph_varpool_mark_needed_node (vnode);\n+      varpool_mark_needed_node (vnode);\n       return vnode->decl;\n     }\n   else\n@@ -5029,7 +5029,7 @@ assemble_alias (tree decl, tree target)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     cgraph_node (decl)->alias = true;\n   else\n-    cgraph_varpool_node (decl)->alias = true;\n+    varpool_node (decl)->alias = true;\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad o memory.  */"}, {"sha": "2c3a43e2558240a0344f1c97bd20c98e0648906b", "filename": "gcc/varpool.c", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=8a4a83ed921b2f28db38cf1e7384f1fec2cd22f5", "patch": "@@ -0,0 +1,451 @@\n+/* Callgraph handling code.\n+   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"cgraph.h\"\n+#include \"langhooks.h\"\n+#include \"diagnostic.h\"\n+#include \"hashtab.h\"\n+#include \"ggc.h\"\n+#include \"timevar.h\"\n+#include \"debug.h\" \n+#include \"target.h\"\n+#include \"output.h\"\n+\n+/*  This file contains basic routines manipulating variable pool.\n+\n+    Varpool acts as interface in between the front-end and middle-end\n+    and drives the decision process on what variables and when are\n+    going to be compiled.\n+\n+    The varpool nodes are alocated lazilly for declarations\n+    either by frontend or at callgraph construction time.\n+    All variables supposed to be output into final file needs to be\n+    explicitely marked by frontend via VARPOOL_FINALIZE_DECL function.  */\n+\n+/* Hash table used to convert declarations into nodes.  */\n+static GTY((param_is (struct varpool_node))) htab_t varpool_hash;\n+\n+/* The linked list of cgraph varpool nodes.\n+   Linked via node->next pointer.  */\n+struct varpool_node *varpool_nodes;\n+\n+/* Queue of cgraph nodes scheduled to be lowered and output.\n+   The queue is maintained via mark_needed_node, linked via node->next_needed\n+   pointer. \n+\n+   LAST_NNEDED_NODE points to the end of queue, so it can be maintained in forward\n+   order.  QTY is needed to make it friendly to PCH.\n+ \n+   During unit-at-a-time compilation we construct the queue of needed variables\n+   twice: first time it is during cgraph construction, second time it is at the\n+   end of compilation in VARPOOL_REMOVE_UNREFERENCED_DECLS so we can avoid\n+   optimized out variables being output.\n+   \n+   Each variable is thus first analyzed and then later possibly output.  \n+   FIRST_UNANALYZED_NODE points to first node in queue that was not analyzed\n+   yet and is moved via VARPOOL_ANALYZE_PENDING_DECLS.  */\n+   \n+struct varpool_node *varpool_nodes_queue;\n+static GTY(()) struct varpool_node *varpool_last_needed_node;\n+static GTY(()) struct varpool_node *varpool_first_unanalyzed_node;\n+\n+/* Lists all assembled variables to be sent to debugger output later on.  */\n+static GTY(()) struct varpool_node *varpool_assembled_nodes_queue;\n+\n+/* Return name of the node used in debug output.  */\n+static const char *\n+varpool_node_name (struct varpool_node *node)\n+{\n+  return lang_hooks.decl_printable_name (node->decl, 2);\n+}\n+\n+/* Returns a hash code for P.  */\n+static hashval_t\n+hash_varpool_node (const void *p)\n+{\n+  const struct varpool_node *n = (const struct varpool_node *) p;\n+  return (hashval_t) DECL_UID (n->decl);\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+static int\n+eq_varpool_node (const void *p1, const void *p2)\n+{\n+  const struct varpool_node *n1 =\n+    (const struct varpool_node *) p1;\n+  const struct varpool_node *n2 =\n+    (const struct varpool_node *) p2;\n+  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n+}\n+\n+/* Return varpool node assigned to DECL.  Create new one when needed.  */\n+struct varpool_node *\n+varpool_node (tree decl)\n+{\n+  struct varpool_node key, *node, **slot;\n+\n+  gcc_assert (DECL_P (decl) && TREE_CODE (decl) != FUNCTION_DECL);\n+\n+  if (!varpool_hash)\n+    varpool_hash = htab_create_ggc (10, hash_varpool_node,\n+\t\t\t\t\t   eq_varpool_node, NULL);\n+  key.decl = decl;\n+  slot = (struct varpool_node **)\n+    htab_find_slot (varpool_hash, &key, INSERT);\n+  if (*slot)\n+    return *slot;\n+  node = GGC_CNEW (struct varpool_node);\n+  node->decl = decl;\n+  node->order = cgraph_order++;\n+  node->next = varpool_nodes;\n+  varpool_nodes = node;\n+  *slot = node;\n+  return node;\n+}\n+\n+/* Dump given cgraph node.  */\n+void\n+dump_varpool_node (FILE *f, struct varpool_node *node)\n+{\n+  fprintf (f, \"%s:\", varpool_node_name (node));\n+  fprintf (f, \" availability:%s\",\n+\t   cgraph_function_flags_ready\n+\t   ? cgraph_availability_names[cgraph_variable_initializer_availability (node)]\n+\t   : \"not-ready\");\n+  if (DECL_INITIAL (node->decl))\n+    fprintf (f, \" initialized\");\n+  if (node->needed)\n+    fprintf (f, \" needed\");\n+  if (node->analyzed)\n+    fprintf (f, \" analyzed\");\n+  if (node->finalized)\n+    fprintf (f, \" finalized\");\n+  if (node->output)\n+    fprintf (f, \" output\");\n+  if (node->externally_visible)\n+    fprintf (f, \" externally_visible\");\n+  fprintf (f, \"\\n\");\n+}\n+\n+/* Dump the variable pool.  */\n+void\n+dump_varpool (FILE *f)\n+{\n+  struct varpool_node *node;\n+\n+  fprintf (f, \"variable pool:\\n\\n\");\n+  for (node = varpool_nodes; node; node = node->next_needed)\n+    dump_varpool_node (f, node);\n+}\n+\n+/* Given an assembler name, lookup node.  */\n+struct varpool_node *\n+varpool_node_for_asm (tree asmname)\n+{\n+  struct varpool_node *node;\n+\n+  for (node = varpool_nodes; node ; node = node->next)\n+    if (decl_assembler_name_equal (node->decl, asmname))\n+      return node;\n+\n+  return NULL;\n+}\n+\n+/* Helper function for finalization code - add node into lists so it will\n+   be analyzed and compiled.  */\n+static void\n+varpool_enqueue_needed_node (struct varpool_node *node)\n+{\n+  if (varpool_last_needed_node)\n+    varpool_last_needed_node->next_needed = node;\n+  varpool_last_needed_node = node;\n+  node->next_needed = NULL;\n+  if (!varpool_nodes_queue)\n+    varpool_nodes_queue = node;\n+  if (!varpool_first_unanalyzed_node)\n+    varpool_first_unanalyzed_node = node;\n+  notice_global_symbol (node->decl);\n+}\n+\n+/* Notify finalize_compilation_unit that given node is reachable\n+   or needed.  */\n+void\n+varpool_mark_needed_node (struct varpool_node *node)\n+{\n+  if (!node->needed && node->finalized\n+      && !TREE_ASM_WRITTEN (node->decl))\n+    varpool_enqueue_needed_node (node);\n+  node->needed = 1;\n+}\n+\n+/* Reset the queue of needed nodes.  */\n+static void\n+varpool_reset_queue (void)\n+{\n+  varpool_last_needed_node = NULL;\n+  varpool_nodes_queue = NULL;\n+  varpool_first_unanalyzed_node = NULL;\n+}\n+\n+/* Determine if variable DECL is needed.  That is, visible to something\n+   either outside this translation unit, something magic in the system\n+   configury, or (if not doing unit-at-a-time) to something we haven't\n+   seen yet.  */\n+bool\n+decide_is_variable_needed (struct varpool_node *node, tree decl)\n+{\n+  /* If the user told us it is used, then it must be so.  */\n+  if (node->externally_visible)\n+    return true;\n+  if (!flag_unit_at_a_time\n+      && lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n+    return true;\n+\n+  /* ??? If the assembler name is set by hand, it is possible to assemble\n+     the name later after finalizing the function and the fact is noticed\n+     in assemble_name then.  This is arguably a bug.  */\n+  if (DECL_ASSEMBLER_NAME_SET_P (decl)\n+      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+    return true;\n+\n+  /* If we decided it was needed before, but at the time we didn't have\n+     the definition available, then it's still needed.  */\n+  if (node->needed)\n+    return true;\n+\n+  /* Externally visible variables must be output.  The exception is\n+     COMDAT variables that must be output only when they are needed.  */\n+  if (TREE_PUBLIC (decl) && !flag_whole_program && !DECL_COMDAT (decl)\n+      && !DECL_EXTERNAL (decl))\n+    return true;\n+\n+  /* When not reordering top level variables, we have to assume that\n+     we are going to keep everything.  */\n+  if (flag_unit_at_a_time && flag_toplevel_reorder)\n+    return false;\n+\n+  /* We want to emit COMDAT variables only when absolutely necessary.  */\n+  if (DECL_COMDAT (decl))\n+    return false;\n+  return true;\n+}\n+\n+/* Mark DECL as finalized.  By finalizing the declaration, frontend instruct the\n+   middle end to output the variable to asm file, if needed or externally\n+   visible.  */\n+void\n+varpool_finalize_decl (tree decl)\n+{\n+  struct varpool_node *node = varpool_node (decl);\n+\n+  /* The first declaration of a variable that comes through this function\n+     decides whether it is global (in C, has external linkage)\n+     or local (in C, has internal linkage).  So do nothing more\n+     if this function has already run.  */\n+  if (node->finalized)\n+    {\n+      if (cgraph_global_info_ready || (!flag_unit_at_a_time && !flag_openmp))\n+\tvarpool_assemble_pending_decls ();\n+      return;\n+    }\n+  if (node->needed)\n+    varpool_enqueue_needed_node (node);\n+  node->finalized = true;\n+\n+  if (decide_is_variable_needed (node, decl))\n+    varpool_mark_needed_node (node);\n+  /* Since we reclaim unreachable nodes at the end of every language\n+     level unit, we need to be conservative about possible entry points\n+     there.  */\n+  else if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+    varpool_mark_needed_node (node);\n+  if (cgraph_global_info_ready || (!flag_unit_at_a_time && !flag_openmp))\n+    varpool_assemble_pending_decls ();\n+}\n+\n+/* Return variable availability.  See cgraph.h for description of individual\n+   return values.  */\n+enum availability\n+cgraph_variable_initializer_availability (struct varpool_node *node)\n+{\n+  gcc_assert (cgraph_function_flags_ready);\n+  if (!node->finalized)\n+    return AVAIL_NOT_AVAILABLE;\n+  if (!TREE_PUBLIC (node->decl))\n+    return AVAIL_AVAILABLE;\n+  /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n+     care of at least two notable extensions - the COMDAT variables\n+     used to share template instantiations in C++.  */\n+  if (!(*targetm.binds_local_p) (node->decl) && !DECL_COMDAT (node->decl))\n+    return AVAIL_OVERWRITABLE;\n+  return AVAIL_AVAILABLE;\n+}\n+\n+/* Walk the decls we marked as necessary and see if they reference new\n+   variables or functions and add them into the worklists.  */\n+bool\n+varpool_analyze_pending_decls (void)\n+{\n+  bool changed = false;\n+  timevar_push (TV_CGRAPH);\n+\n+  while (varpool_first_unanalyzed_node)\n+    {\n+      tree decl = varpool_first_unanalyzed_node->decl;\n+\n+      varpool_first_unanalyzed_node->analyzed = true;\n+\n+      varpool_first_unanalyzed_node = varpool_first_unanalyzed_node->next_needed;\n+\n+      /* Compute the alignment early so function body expanders are\n+\t already informed about increased alignment.  */\n+      align_variable (decl, 0);\n+\n+      if (DECL_INITIAL (decl))\n+\trecord_references_in_initializer (decl);\n+      changed = true;\n+    }\n+  timevar_pop (TV_CGRAPH);\n+  return changed;\n+}\n+\n+/* Output one variable, if necessary.  Return whether we output it.  */\n+bool\n+varpool_assemble_decl (struct varpool_node *node)\n+{\n+  tree decl = node->decl;\n+\n+  if (!TREE_ASM_WRITTEN (decl)\n+      && !node->alias\n+      && !DECL_EXTERNAL (decl)\n+      && (TREE_CODE (decl) != VAR_DECL || !DECL_HAS_VALUE_EXPR_P (decl)))\n+    {\n+      assemble_variable (decl, 0, 1, 0);\n+      return TREE_ASM_WRITTEN (decl);\n+    }\n+\n+  return false;\n+}\n+\n+/* Optimization of function bodies might've rendered some variables as\n+   unnecessary so we want to avoid these from being compiled.\n+\n+   This is done by pruning the queue and keeping only the variables that\n+   really appear needed (ie they are either externally visible or referenced\n+   by compiled function). Re-doing the reachability analysis on variables\n+   brings back the remaining variables referenced by these.  */\n+void\n+varpool_remove_unreferenced_decls (void)\n+{\n+  struct varpool_node *next, *node = varpool_nodes_queue;\n+\n+  varpool_reset_queue ();\n+\n+  if (errorcount || sorrycount)\n+    return;\n+\n+  while (node)\n+    {\n+      tree decl = node->decl;\n+      next = node->next_needed;\n+      node->needed = 0;\n+\n+      if (node->finalized\n+\t  && ((DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t      || node->force_output\n+\t      || decide_is_variable_needed (node, decl)\n+\t      /* ??? Cgraph does not yet rule the world with an iron hand,\n+\t\t and does not control the emission of debug information.\n+\t\t After a variable has its DECL_RTL set, we must assume that\n+\t\t it may be referenced by the debug information, and we can\n+\t\t no longer elide it.  */\n+\t      || DECL_RTL_SET_P (decl)))\n+\tvarpool_mark_needed_node (node);\n+\n+      node = next;\n+    }\n+  /* Make sure we mark alias targets as used targets.  */\n+  finish_aliases_1 ();\n+  varpool_analyze_pending_decls ();\n+}\n+\n+/* Output all variables enqueued to be assembled.  */\n+bool\n+varpool_assemble_pending_decls (void)\n+{\n+  bool changed = false;\n+\n+  if (errorcount || sorrycount)\n+    return false;\n+\n+  /* EH might mark decls as needed during expansion.  This should be safe since\n+     we don't create references to new function, but it should not be used\n+     elsewhere.  */\n+  varpool_analyze_pending_decls ();\n+\n+  while (varpool_nodes_queue)\n+    {\n+      struct varpool_node *node = varpool_nodes_queue;\n+\n+      varpool_nodes_queue = varpool_nodes_queue->next_needed;\n+      if (varpool_assemble_decl (node))\n+\t{\n+\t  changed = true;\n+\t  node->next_needed = varpool_assembled_nodes_queue;\n+\t  varpool_assembled_nodes_queue = node;\n+\t  node->finalized = 1;\n+\t}\n+      else\n+        node->next_needed = NULL;\n+    }\n+  return changed;\n+}\n+\n+/* Output all variables enqueued to be assembled.  */\n+void\n+varpool_output_debug_info (void)\n+{\n+  timevar_push (TV_SYMOUT);\n+  if (errorcount == 0 && sorrycount == 0)\n+    while (varpool_assembled_nodes_queue)\n+      {\n+\tstruct varpool_node *node = varpool_assembled_nodes_queue;\n+\n+\t/* Local static variables are never seen by check_global_declarations\n+\t   so we need to output debug info by hand.  */\n+\tif (DECL_CONTEXT (node->decl)\n+\t    && (TREE_CODE (DECL_CONTEXT (node->decl)) == BLOCK\n+\t\t|| TREE_CODE (DECL_CONTEXT (node->decl)) == FUNCTION_DECL)\n+\t    && errorcount == 0 && sorrycount == 0)\n+\t     (*debug_hooks->global_decl) (node->decl);\n+\tvarpool_assembled_nodes_queue = node->next_needed;\n+\tnode->next_needed = 0;\n+      }\n+  timevar_pop (TV_SYMOUT);\n+}\n+\n+#include \"gt-varpool.h\""}]}