{"sha": "0601d0cf823bca6293bea3b017e668be2361ed04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYwMWQwY2Y4MjNiY2E2MjkzYmVhM2IwMTdlNjY4YmUyMzYxZWQwNA==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2009-09-15T10:39:13Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2009-09-15T10:39:13Z"}, "message": "New function for checking misalignment\n\nFrom-SVN: r151715", "tree": {"sha": "6da5176cd614d338ccf9a4e80eb154a56282eeb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6da5176cd614d338ccf9a4e80eb154a56282eeb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0601d0cf823bca6293bea3b017e668be2361ed04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0601d0cf823bca6293bea3b017e668be2361ed04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0601d0cf823bca6293bea3b017e668be2361ed04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0601d0cf823bca6293bea3b017e668be2361ed04/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5e447966658e7be35927f8ba65b20933b052b26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e447966658e7be35927f8ba65b20933b052b26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e447966658e7be35927f8ba65b20933b052b26"}], "stats": {"total": 135, "additions": 125, "deletions": 10}, "files": [{"sha": "e64ec0fe9671978cb2b276e0d84847e43cb80153", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -1,3 +1,20 @@\n+2009-09-15  Revital Eres  <eres@il.ibm.com>\n+\n+\t* doc/tm.texi (TARGET_SUPPORT_VECTOR_MISALIGNMENT): Document.\n+\t* targhooks.c (default_builtin_support_vector_misalignment):\n+\tNew builtin function.\n+\t* targhooks.h (default_builtin_support_vector_misalignment):\n+\tDeclare.\n+\t* target.h (builtin_support_vector_misalignment):\n+\tNew field in struct gcc_target.\n+\t* tree-vect-data-refs.c (vect_supportable_dr_alignment): Call\n+\tnew builtin function.\n+\t* target-def.h (TARGET_SUPPORT_VECTOR_MISALIGNMENT):\n+\tDefine.\n+\t* config/rs6000/rs6000.c\n+\t(rs6000_builtin_support_vector_misalignment): New function.\n+\t(TARGET_SUPPORT_VECTOR_MISALIGNMENT): Define.\n+\n 2009-09-15  Jie Zhang  <jie.zhang@analog.com>\n \n \t* config/bfin/bfin.c (length_for_loop): Use NONDEBUG_INSN_P"}, {"sha": "932a7e31d84372022866bb17e55509b876b0a01f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -919,6 +919,10 @@ static tree rs6000_builtin_mul_widen_even (tree);\n static tree rs6000_builtin_mul_widen_odd (tree);\n static tree rs6000_builtin_conversion (unsigned int, tree);\n static tree rs6000_builtin_vec_perm (tree, tree *);\n+static bool rs6000_builtin_support_vector_misalignment (enum\n+\t\t\t\t\t\t\tmachine_mode,\n+\t\t\t\t\t\t\tconst_tree,\n+\t\t\t\t\t\t\tint, bool);\n \n static void def_builtin (int, const char *, tree, int);\n static bool rs6000_vector_alignment_reachable (const_tree, bool);\n@@ -1300,7 +1304,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_VECTORIZE_BUILTIN_CONVERSION rs6000_builtin_conversion\n #undef TARGET_VECTORIZE_BUILTIN_VEC_PERM\n #define TARGET_VECTORIZE_BUILTIN_VEC_PERM rs6000_builtin_vec_perm\n-\n+#undef TARGET_SUPPORT_VECTOR_MISALIGNMENT\n+#define TARGET_SUPPORT_VECTOR_MISALIGNMENT\t\t\\\n+  rs6000_builtin_support_vector_misalignment\n #undef TARGET_VECTOR_ALIGNMENT_REACHABLE\n #define TARGET_VECTOR_ALIGNMENT_REACHABLE rs6000_vector_alignment_reachable\n \n@@ -2895,6 +2901,36 @@ rs6000_vector_alignment_reachable (const_tree type ATTRIBUTE_UNUSED, bool is_pac\n     }\n }\n \n+/* Return true if the vector misalignment factor is supported by the\n+   target.  */ \n+bool\n+rs6000_builtin_support_vector_misalignment (enum machine_mode mode,\n+\t\t\t\t\t    const_tree type,\n+\t\t\t\t\t    int misalignment,\n+\t\t\t\t\t    bool is_packed)\n+{\n+  if (TARGET_VSX)\n+    {\n+      /* Return if movmisalign pattern is not supported for this mode.  */\n+      if (optab_handler (movmisalign_optab, mode)->insn_code ==\n+          CODE_FOR_nothing)\n+        return false;\n+\n+      if (misalignment == -1)\n+\t{\n+\t  /* misalignment factor is unknown at compile time but we know\n+\t     it's word aligned.  */\n+\t  if (rs6000_vector_alignment_reachable (type, is_packed))\n+\t    return true;\n+\t  return false;\n+\t}\n+      /* VSX supports word-aligned vector.  */\n+      if (misalignment % 4 == 0)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Implement targetm.vectorize.builtin_vec_perm.  */\n tree\n rs6000_builtin_vec_perm (tree type, tree *mask_element_type)"}, {"sha": "0139a8bfe6f394e0e0c8d0559aca9fb6dd932eb3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -5679,6 +5679,14 @@ the vectorized function shall be of vector type @var{vec_type_out} and the\n argument types should be @var{vec_type_in}.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SUPPORT_VECTOR_MISALIGNMENT (enum machine_mode @var{mode}, tree @var{type}, int @var{misalignment}, bool @var{is_packed})\n+This hook should return true if the target supports misaligned vector\n+store/load of a specific factor denoted in the @var{misalignment}\n+parameter.  The vector store/load should be of machine mode @var{mode} and\n+the elements in the vectors should be of type @var{type}.  @var{is_packed}\n+parameter is true if the memory access is defined in a packed struct.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "728e018f71de12f94cf5f73ed4e4aaec3e8c6a68", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -388,6 +388,9 @@\n #define TARGET_VECTOR_ALIGNMENT_REACHABLE \\\n   default_builtin_vector_alignment_reachable\n #define TARGET_VECTORIZE_BUILTIN_VEC_PERM 0\n+#define TARGET_SUPPORT_VECTOR_MISALIGNMENT \\\n+  default_builtin_support_vector_misalignment \n+   \n \n #define TARGET_VECTORIZE                                                \\\n   {\t\t\t\t\t\t\t\t\t\\\n@@ -398,7 +401,8 @@\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD,\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST,\t\t\t\\\n     TARGET_VECTOR_ALIGNMENT_REACHABLE,                                  \\\n-    TARGET_VECTORIZE_BUILTIN_VEC_PERM                                   \\\n+    TARGET_VECTORIZE_BUILTIN_VEC_PERM,\t\t\t\t\t\\\n+    TARGET_SUPPORT_VECTOR_MISALIGNMENT\t\t\t\t\\\n   }\n \n #define TARGET_DEFAULT_TARGET_FLAGS 0"}, {"sha": "c57b683a4fc55fcfabf7d4a74bc32ae6a61bb514", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -481,6 +481,11 @@ struct gcc_target\n \n     /* Target builtin that implements vector permute.  */\n     tree (* builtin_vec_perm) (tree, tree*);\n+    /* Return true if the target supports misaligned store/load of a\n+       specific factor denoted in the third parameter.  The last parameter\n+       is true if the access is defined in a packed struct.  */\n+    bool (* builtin_support_vector_misalignment) (enum machine_mode, \n+                                                  const_tree, int, bool);\n   } vectorize;\n \n   /* The initial value of target_flags.  */"}, {"sha": "8480c0b833fcb20ed33673bf82a3057e99ce1db1", "filename": "gcc/targhooks.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -771,6 +771,23 @@ default_builtin_vector_alignment_reachable (const_tree type, bool is_packed)\n   return true;\n }\n \n+/* By default, assume that a target supports any factor of misalignment\n+   memory access if it supports movmisalign patten. \n+   is_packed is true if the memory access is defined in a packed struct.  */\n+bool\n+default_builtin_support_vector_misalignment (enum machine_mode mode,\n+\t\t\t\t\t     const_tree type\n+\t\t\t\t\t     ATTRIBUTE_UNUSED,\n+\t\t\t\t\t     int misalignment\n+\t\t\t\t\t     ATTRIBUTE_UNUSED,\n+\t\t\t\t\t     bool is_packed\n+\t\t\t\t\t     ATTRIBUTE_UNUSED)\n+{\n+  if (optab_handler (movmisalign_optab, mode)->insn_code != CODE_FOR_nothing)\n+    return true;\n+  return false;\n+}\n+\n bool\n default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)\n {"}, {"sha": "7a9355292aed03d2d9900a61c4d54f6443bf9869", "filename": "gcc/targhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -77,6 +77,10 @@ extern tree default_builtin_vectorized_conversion (unsigned int, tree);\n extern tree default_builtin_reciprocal (unsigned int, bool, bool);\n \n extern bool default_builtin_vector_alignment_reachable (const_tree, bool);\n+extern bool\n+default_builtin_support_vector_misalignment (enum machine_mode mode,\n+\t\t\t\t\t     const_tree,\n+\t\t\t\t\t     int, bool); \n \n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */"}, {"sha": "bc18f0272f89fec440ce5640f01b57425f878508", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0601d0cf823bca6293bea3b017e668be2361ed04/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0601d0cf823bca6293bea3b017e668be2361ed04", "patch": "@@ -3455,6 +3455,9 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n \n   if (DR_IS_READ (dr))\n     {\n+      bool is_packed = false;\n+      tree type = (TREE_TYPE (DR_REF (dr)));\n+\n       if (optab_handler (vec_realign_load_optab, mode)->insn_code != \n \t\t\t\t\t\t   \t     CODE_FOR_nothing\n \t  && (!targetm.vectorize.builtin_mask_for_load\n@@ -3468,18 +3471,39 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n \t  else\n \t    return dr_explicit_realign_optimized;\n \t}\n-\n-      if (optab_handler (movmisalign_optab, mode)->insn_code != \n-\t\t\t\t\t\t\t     CODE_FOR_nothing)\n+      if (!known_alignment_for_access_p (dr))\n+\t{\n+\t  tree ba = DR_BASE_OBJECT (dr);\n+\t  \n+\t  if (ba)\n+\t    is_packed = contains_packed_reference (ba);\n+\t}\n+     \n+      if (targetm.vectorize.\n+\t  builtin_support_vector_misalignment (mode, type,\n+\t\t\t\t\t       DR_MISALIGNMENT (dr), is_packed))\n \t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }\n-   else\n-     {\n-       if (movmisalign_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n-         return dr_unaligned_supported;\n-     }\n+  else\n+    {\n+      bool is_packed = false;\n+      tree type = (TREE_TYPE (DR_REF (dr)));\n \n+      if (!known_alignment_for_access_p (dr))\n+\t{\n+\t  tree ba = DR_BASE_OBJECT (dr);\n+\t  \n+\t  if (ba)\n+\t    is_packed = contains_packed_reference (ba);\n+\t}\n+     \n+     if (targetm.vectorize.\n+         builtin_support_vector_misalignment (mode, type, \n+\t\t\t\t\t      DR_MISALIGNMENT (dr), is_packed))\n+       return dr_unaligned_supported;\n+    }\n+  \n   /* Unsupported.  */\n   return dr_unaligned_unsupported;\n }"}]}