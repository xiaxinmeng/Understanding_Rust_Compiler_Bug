{"sha": "ef4adf1f79e380315124ed8bc98cd5b2a6f027ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY0YWRmMWY3OWUzODAzMTUxMjRlZDhiYzk4Y2Q1YjJhNmYwMjdlZg==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2018-10-26T19:33:31Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2018-10-26T19:33:31Z"}, "message": "rs6000-string.c (expand_strncmp_gpr_sequence): Change to a shorter sequence with fewer branches.\n\n2018-10-26  Aaron Sawdey  <acsawdey@linux.ibm.com>\n\n\t* config/rs6000/rs6000-string.c (expand_strncmp_gpr_sequence): Change to\n\ta shorter sequence with fewer branches.\n\t(emit_final_str_compare_gpr): Ditto.\n\nFrom-SVN: r265546", "tree": {"sha": "3a7c24a32a7dd2df970346e08f91139ce5e9b9ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a7c24a32a7dd2df970346e08f91139ce5e9b9ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ffd0bbe152496a667d0854ccb68f36bf3e853205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffd0bbe152496a667d0854ccb68f36bf3e853205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffd0bbe152496a667d0854ccb68f36bf3e853205"}], "stats": {"total": 251, "additions": 143, "deletions": 108}, "files": [{"sha": "ae4aa6ebb7292a0889ce2118b1fe4d0cf8ee5143", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef4adf1f79e380315124ed8bc98cd5b2a6f027ef", "patch": "@@ -1,3 +1,9 @@\n+2018-10-26  Aaron Sawdey  <acsawdey@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000-string.c (expand_strncmp_gpr_sequence): Change to\n+\ta shorter sequence with fewer branches.\n+\t(emit_final_str_compare_gpr): Ditto.\n+\n 2018-10-26  Paul A. Clarke  <pc@us.ibm.com>\n \n \t* config/rs6000/tmmintrin.h: New file."}, {"sha": "96729d9663c9a3ccb8e8017bfb9e776704dd72fb", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 137, "deletions": 108, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef4adf1f79e380315124ed8bc98cd5b2a6f027ef/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=ef4adf1f79e380315124ed8bc98cd5b2a6f027ef", "patch": "@@ -259,7 +259,7 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n       gcc_assert (mode == E_QImode);\n       emit_move_insn (reg, mem);\n       break;\n-      \n+\n     default:\n       gcc_unreachable ();\n       break;\n@@ -726,7 +726,7 @@ expand_compare_loop (rtx operands[])\n     {\n       if (GET_MODE_SIZE (GET_MODE (bytes_rtx)) > GET_MODE_SIZE (word_mode))\n \t/* Do not expect length longer than word_mode.  */\n-\treturn false; \n+\treturn false;\n       else if (GET_MODE_SIZE (GET_MODE (bytes_rtx)) < GET_MODE_SIZE (word_mode))\n \t{\n \t  bytes_rtx = force_reg (GET_MODE (bytes_rtx), bytes_rtx);\n@@ -770,7 +770,7 @@ expand_compare_loop (rtx operands[])\n   rtx j;\n \n   /* Example of generated code for 35 bytes aligned 1 byte.\n-     \n+\n \t     mtctr 8\n \t     li 6,0\n \t     li 5,8\n@@ -798,7 +798,7 @@ expand_compare_loop (rtx operands[])\n \t     popcntd 9,9\n \t     subfe 10,10,10\n \t     or 9,9,10\n-     \n+\n      Compiled with -fno-reorder-blocks for clarity.  */\n \n   /* Structure of what we're going to do:\n@@ -1041,7 +1041,7 @@ expand_compare_loop (rtx operands[])\n       if (!bytes_is_const)\n \t{\n \t  /* If we're dealing with runtime length, we have to check if\n-\t     it's zero after the loop. When length is known at compile\n+\t     it's zero after the loop.  When length is known at compile\n \t     time the no-remainder condition is dealt with above.  By\n \t     doing this after cleanup_label, we also deal with the\n \t     case where length is 0 at the start and we bypass the\n@@ -1411,7 +1411,7 @@ expand_block_compare (rtx operands[])\n   rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n   rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n   /* P7/P8 code uses cond for subfc. but P9 uses\n-     it for cmpld which needs CCUNSmode. */\n+     it for cmpld which needs CCUNSmode.  */\n   rtx cond;\n   if (TARGET_P9_MISC)\n     cond = gen_reg_rtx (CCUNSmode);\n@@ -1655,7 +1655,7 @@ expand_block_compare (rtx operands[])\n \temit_label (convert_label);\n \n       /* We need to produce DI result from sub, then convert to target SI\n-\t while maintaining <0 / ==0 / >0 properties. This sequence works:\n+\t while maintaining <0 / ==0 / >0 properties.  This sequence works:\n \t subfc L,A,B\n \t subfe H,H,H\n \t popcntd L,L\n@@ -1740,7 +1740,7 @@ expand_strncmp_align_check (rtx strncmp_label, rtx src_addr, HOST_WIDE_INT bytes\n    to strcmp/strncmp if we have equality at the end of the inline comparison.\n    P_CLEANUP_LABEL is a pointer to rtx for a label we generate if we need code\n    to clean up and generate the final comparison result.\n-   FINAL_MOVE_LABEL is rtx for a label we can branch to when we can just \n+   FINAL_MOVE_LABEL is rtx for a label we can branch to when we can just\n    set the final result.  */\n static void\n expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n@@ -1763,20 +1763,17 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n   while (bytes_to_compare > 0)\n     {\n       /* GPR compare sequence:\n-         check each 8B with: ld/ld cmpd bne\n-\t If equal, use rldicr/cmpb to check for zero byte.\n+         check each 8B with: ld/ld/cmpb/cmpb/orc./bne\n+\n          cleanup code at end:\n-         cmpb          get byte that differs\n-         cmpb          look for zero byte\n-         orc           combine\n          cntlzd        get bit of first zero/diff byte\n          subfic        convert for rldcl use\n          rldcl rldcl   extract diff/zero byte\n          subf          subtract for final result\n \n          The last compare can branch around the cleanup code if the\n          result is zero because the strings are exactly equal.  */\n-      \n+\n       unsigned int align = compute_current_alignment (base_align, offset);\n       load_mode = select_block_compare_mode (offset, bytes_to_compare, align);\n       load_mode_size = GET_MODE_SIZE (load_mode);\n@@ -1801,34 +1798,49 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \t   rid of the extra bytes.  */\n \tcmp_bytes = bytes_to_compare;\n \n-      rtx addr1 = gen_rtx_PLUS (Pmode, src1_addr, GEN_INT (offset));\n+      rtx offset_reg = gen_reg_rtx (Pmode);\n+      emit_move_insn (offset_reg, GEN_INT (offset));\n+\n+      rtx addr1 = gen_rtx_PLUS (Pmode, src1_addr, offset_reg);\n       do_load_for_compare_from_addr (load_mode, tmp_reg_src1, addr1, orig_src1);\n-      rtx addr2 = gen_rtx_PLUS (Pmode, src2_addr, GEN_INT (offset));\n+      rtx addr2 = gen_rtx_PLUS (Pmode, src2_addr, offset_reg);\n       do_load_for_compare_from_addr (load_mode, tmp_reg_src2, addr2, orig_src2);\n \n       /* We must always left-align the data we read, and\n \t clear any bytes to the right that are beyond the string.\n \t Otherwise the cmpb sequence won't produce the correct\n-\t results.  The beginning of the compare will be done\n-\t with word_mode so will not have any extra shifts or\n-\t clear rights.  */\n+\t results.  However if there is only one byte left, we\n+\t can just subtract to get the final result so the shifts\n+\t and clears are not needed.  */\n \n-      if (load_mode_size < word_mode_size)\n-\t{\n-\t  /* Rotate left first. */\n-\t  rtx sh = GEN_INT (BITS_PER_UNIT * (word_mode_size - load_mode_size));\n-\t  do_rotl3 (tmp_reg_src1, tmp_reg_src1, sh);\n-\t  do_rotl3 (tmp_reg_src2, tmp_reg_src2, sh);\n-\t}\n+      unsigned HOST_WIDE_INT remain = bytes_to_compare - cmp_bytes;\n \n-      if (cmp_bytes < word_mode_size)\n+      /* Loading just a single byte is a special case.  If we are\n+\t loading more than that, we have to check whether we are\n+\t looking at the entire chunk of data.  If not, rotate left and\n+\t clear right so that bytes we aren't supposed to look at are\n+\t zeroed, and the first byte we are supposed to compare is\n+\t leftmost.  */\n+      if (load_mode_size != 1)\n \t{\n-\t  /* Now clear right.  This plus the rotate can be\n-\t     turned into a rldicr instruction. */\n-\t  HOST_WIDE_INT mb = BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n-\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n-\t  do_and3 (tmp_reg_src1, tmp_reg_src1, mask);\n-\t  do_and3 (tmp_reg_src2, tmp_reg_src2, mask);\n+\t  if (load_mode_size < word_mode_size)\n+\t    {\n+\t      /* Rotate left first.  */\n+\t      rtx sh = GEN_INT (BITS_PER_UNIT\n+\t\t\t\t* (word_mode_size - load_mode_size));\n+\t      do_rotl3 (tmp_reg_src1, tmp_reg_src1, sh);\n+\t      do_rotl3 (tmp_reg_src2, tmp_reg_src2, sh);\n+\t    }\n+\n+\t  if (cmp_bytes < word_mode_size)\n+\t    {\n+\t      /* Now clear right.  This plus the rotate can be\n+\t\t turned into a rldicr instruction.  */\n+\t      HOST_WIDE_INT mb = BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n+\t      rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n+\t      do_and3 (tmp_reg_src1, tmp_reg_src1, mask);\n+\t      do_and3 (tmp_reg_src2, tmp_reg_src2, mask);\n+\t    }\n \t}\n \n       /* Cases to handle.  A and B are chunks of the two strings.\n@@ -1842,8 +1854,6 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \t A == B: branch to result 0.\n \t A != B: cleanup code to compute result.  */\n \n-      unsigned HOST_WIDE_INT remain = bytes_to_compare - cmp_bytes;\n-\n       rtx dst_label;\n       if (remain > 0 || equality_compare_rest)\n \t{\n@@ -1857,54 +1867,89 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \t/* Branch to end and produce result of 0.  */\n \tdst_label = final_move_label;\n \n-      rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n-      rtx cond = gen_reg_rtx (CCmode);\n+      if (load_mode_size == 1)\n+\t{\n+\t  /* Special case for comparing just single byte.  */\n+\t  if (equality_compare_rest)\n+\t    {\n+\t      /* Use subf./bne to branch to final_move_label if the\n+\t\t byte differs, otherwise fall through to the strncmp\n+\t\t call.  We must also check for a zero byte here as we\n+\t\t must not make the library call if this is the end of\n+\t\t the string.  */\n+\n+\t      rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, final_move_label);\n+\t      rtx cond = gen_reg_rtx (CCmode);\n+\t      rtx diff_rtx = gen_rtx_MINUS (word_mode,\n+\t\t\t\t\t    tmp_reg_src1, tmp_reg_src2);\n+\t      rs6000_emit_dot_insn (result_reg, diff_rtx, 2, cond);\n+\t      rtx cmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+\n+\t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n+\t\t\t\t\t\t lab_ref, pc_rtx);\n+\t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t      JUMP_LABEL (j) = final_move_label;\n+\t      LABEL_NUSES (final_move_label) += 1;\n \n-      /* Always produce the 0 result, it is needed if\n-\t cmpb finds a 0 byte in this chunk.  */\n-      rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n-      rs6000_emit_dot_insn (result_reg, tmp, 1, cond);\n+\t      /* Check for zero byte here before fall through to\n+\t\t library call.  This catches the case where the\n+\t\t strings are equal and end in a zero byte at this\n+\t\t position.  */\n \n-      rtx cmp_rtx;\n-      if (remain == 0 && !equality_compare_rest)\n-\tcmp_rtx = gen_rtx_EQ (VOIDmode, cond, const0_rtx);\n-      else\n-\tcmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+\t      rtx cond0 = gen_reg_rtx (CCmode);\n+\t      emit_move_insn (cond0, gen_rtx_COMPARE (CCmode, tmp_reg_src1,\n+\t\t\t\t\t\t      const0_rtx));\n \n-      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n-\t\t\t\t\t lab_ref, pc_rtx);\n-      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n-      JUMP_LABEL (j) = dst_label;\n-      LABEL_NUSES (dst_label) += 1;\n+\t      rtx cmp0eq_rtx = gen_rtx_EQ (VOIDmode, cond0, const0_rtx);\n \n-      if (remain > 0 || equality_compare_rest)\n+\t      rtx ifelse0 = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp0eq_rtx,\n+\t\t\t\t\t\t lab_ref, pc_rtx);\n+\t      rtx j0 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse0));\n+\t      JUMP_LABEL (j0) = final_move_label;\n+\t      LABEL_NUSES (final_move_label) += 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This is the last byte to be compared so we can use\n+\t\t subf to compute the final result and branch\n+\t\t unconditionally to final_move_label.  */\n+\n+\t      do_sub3 (result_reg, tmp_reg_src1, tmp_reg_src2);\n+\n+\t      rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_move_label);\n+\t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, fin_ref));\n+\t      JUMP_LABEL (j) = final_move_label;\n+\t      LABEL_NUSES (final_move_label) += 1;\n+\t      emit_barrier ();\n+\t    }\n+\t}\n+      else\n \t{\n-\t  /* Generate a cmpb to test for a 0 byte and branch\n-\t     to final result if found.  */\n \t  rtx cmpb_zero = gen_reg_rtx (word_mode);\n-\t  rtx lab_ref_fin = gen_rtx_LABEL_REF (VOIDmode, final_move_label);\n-\t  rtx condz = gen_reg_rtx (CCmode);\n+\t  rtx cmpb_diff = gen_reg_rtx (word_mode);\n \t  rtx zero_reg = gen_reg_rtx (word_mode);\n+\t  rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n+\t  rtx cond = gen_reg_rtx (CCmode);\n+\n \t  emit_move_insn (zero_reg, GEN_INT (0));\n+\t  do_cmpb3 (cmpb_diff, tmp_reg_src1, tmp_reg_src2);\n \t  do_cmpb3 (cmpb_zero, tmp_reg_src1, zero_reg);\n+\t  rtx not_diff = gen_rtx_NOT (word_mode, cmpb_diff);\n+\t  rtx orc_rtx = gen_rtx_IOR (word_mode, not_diff, cmpb_zero);\n \n-\t  if (cmp_bytes < word_mode_size)\n-\t    {\n-\t      /* Don't want to look at zero bytes past end.  */\n-\t      HOST_WIDE_INT mb =\n-\t\tBITS_PER_UNIT * (word_mode_size - cmp_bytes);\n-\t      rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n-\t      do_and3 (cmpb_zero, cmpb_zero, mask);\n-\t    }\n+\t  rs6000_emit_dot_insn (result_reg, orc_rtx, 2, cond);\n \n-\t  emit_move_insn (condz, gen_rtx_COMPARE (CCmode, cmpb_zero, zero_reg));\n-\t  rtx cmpnz_rtx = gen_rtx_NE (VOIDmode, condz, const0_rtx);\n-\t  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmpnz_rtx,\n-\t\t\t\t\t     lab_ref_fin, pc_rtx);\n-\t  rtx j2 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n-\t  JUMP_LABEL (j2) = final_move_label;\n-\t  LABEL_NUSES (final_move_label) += 1;\n+\t  rtx cmp_rtx;\n+\t  if (remain == 0 && !equality_compare_rest)\n+\t    cmp_rtx = gen_rtx_EQ (VOIDmode, cond, const0_rtx);\n+\t  else\n+\t    cmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n \n+\t  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n+\t\t\t\t\t     lab_ref, pc_rtx);\n+\t  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t  JUMP_LABEL (j) = dst_label;\n+\t  LABEL_NUSES (dst_label) += 1;\n \t}\n \n       offset += cmp_bytes;\n@@ -1915,7 +1960,7 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n   return;\n }\n \n-/* Generate the sequence of compares for strcmp/strncmp using vec/vsx \n+/* Generate the sequence of compares for strcmp/strncmp using vec/vsx\n    instructions.\n \n    BYTES_TO_COMPARE is the number of bytes to be compared.\n@@ -1931,7 +1976,7 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n    to strcmp/strncmp if we have equality at the end of the inline comparison.\n    P_CLEANUP_LABEL is a pointer to rtx for a label we generate if we need code to clean up\n    and generate the final comparison result.\n-   FINAL_MOVE_LABEL is rtx for a label we can branch to when we can just \n+   FINAL_MOVE_LABEL is rtx for a label we can branch to when we can just\n    set the final result.  */\n static void\n expand_strncmp_vec_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n@@ -1982,12 +2027,12 @@ expand_strncmp_vec_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \t bne 6,.Lmismatch\n \n \t Use the overlapping compare trick for the last block if it is\n-\t less than 16 bytes. \n+\t less than 16 bytes.\n       */\n \n       load_mode = V16QImode;\n       load_mode_size = GET_MODE_SIZE (load_mode);\n-      \n+\n       if (bytes_to_compare >= load_mode_size)\n \tcmp_bytes = load_mode_size;\n       else\n@@ -2046,10 +2091,10 @@ expand_strncmp_vec_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n       if (branch_to_cleanup)\n \t{\n \t  /* Branch to cleanup code, otherwise fall through to do more\n-\t     compares. P8 and P9 use different CR bits because on P8\n+\t     compares.  P8 and P9 use different CR bits because on P8\n \t     we are looking at the result of a comparsion vs a\n \t     register of zeroes so the all-true condition means no\n-\t     difference or zero was found. On P9, vcmpnezb sets a byte\n+\t     difference or zero was found.  On P9, vcmpnezb sets a byte\n \t     to 0xff if there is a mismatch or zero, so the all-false\n \t     condition indicates we found no difference or zero.  */\n \t  if (!cleanup_label)\n@@ -2062,7 +2107,7 @@ expand_strncmp_vec_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \t}\n       else\n \t{\n-\t  /* Branch to final return or fall through to cleanup, \n+\t  /* Branch to final return or fall through to cleanup,\n \t     result is already set to 0.  */\n \t  dst_label = final_move_label;\n \t  if (TARGET_P9_VECTOR)\n@@ -2088,10 +2133,7 @@ expand_strncmp_vec_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n /* Generate the final sequence that identifies the differing\n    byte and generates the final result, taking into account\n    zero bytes:\n-   \n-   cmpb              cmpb_result1, src1, src2\n-   cmpb              cmpb_result2, src1, zero\n-   orc               cmpb_result1, cmp_result1, cmpb_result2\n+\n    cntlzd            get bit of first zero/diff byte\n    addi              convert for rldcl use\n    rldcl rldcl       extract diff/zero byte\n@@ -2105,10 +2147,7 @@ static void\n emit_final_str_compare_gpr (rtx str1, rtx str2, rtx result)\n {\n   machine_mode m = GET_MODE (str1);\n-  rtx cmpb_diff = gen_reg_rtx (m);\n-  rtx cmpb_zero = gen_reg_rtx (m);\n   rtx rot_amt = gen_reg_rtx (m);\n-  rtx zero_reg = gen_reg_rtx (m);\n \n   rtx rot1_1 = gen_reg_rtx (m);\n   rtx rot1_2 = gen_reg_rtx (m);\n@@ -2117,12 +2156,7 @@ emit_final_str_compare_gpr (rtx str1, rtx str2, rtx result)\n \n   if (m == SImode)\n     {\n-      emit_insn (gen_cmpbsi3 (cmpb_diff, str1, str2));\n-      emit_insn (gen_movsi (zero_reg, GEN_INT (0)));\n-      emit_insn (gen_cmpbsi3 (cmpb_zero, str1, zero_reg));\n-      emit_insn (gen_one_cmplsi2 (cmpb_diff,cmpb_diff));\n-      emit_insn (gen_iorsi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n-      emit_insn (gen_clzsi2 (rot_amt, cmpb_diff));\n+      emit_insn (gen_clzsi2 (rot_amt, result));\n       emit_insn (gen_addsi3 (rot_amt, rot_amt, GEN_INT (8)));\n       emit_insn (gen_rotlsi3 (rot1_1, str1,\n \t\t\t      gen_lowpart (SImode, rot_amt)));\n@@ -2134,12 +2168,7 @@ emit_final_str_compare_gpr (rtx str1, rtx str2, rtx result)\n     }\n   else if (m == DImode)\n     {\n-      emit_insn (gen_cmpbdi3 (cmpb_diff, str1, str2));\n-      emit_insn (gen_movdi (zero_reg, GEN_INT (0)));\n-      emit_insn (gen_cmpbdi3 (cmpb_zero, str1, zero_reg));\n-      emit_insn (gen_one_cmpldi2 (cmpb_diff,cmpb_diff));\n-      emit_insn (gen_iordi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n-      emit_insn (gen_clzdi2 (rot_amt, cmpb_diff));\n+      emit_insn (gen_clzdi2 (rot_amt, result));\n       emit_insn (gen_adddi3 (rot_amt, rot_amt, GEN_INT (8)));\n       emit_insn (gen_rotldi3 (rot1_1, str1,\n \t\t\t      gen_lowpart (SImode, rot_amt)));\n@@ -2151,7 +2180,7 @@ emit_final_str_compare_gpr (rtx str1, rtx str2, rtx result)\n     }\n   else\n     gcc_unreachable ();\n-    \n+\n   return;\n }\n \n@@ -2169,10 +2198,10 @@ emit_final_str_compare_gpr (rtx str1, rtx str2, rtx result)\n         lbzx 10,28,9    # use that offset to load differing byte\n         lbzx 3,29,9\n         subf 3,3,10     # subtract for final result\n-   \n+\n    P9:\n \t vclzlsbb            # counts trailing bytes with lsb=0\n-\t vextublx            # extract differing byte \n+\t vextublx            # extract differing byte\n \n    STR1 is the reg rtx for data from string 1.\n    STR2 is the reg rtx for data from string 2.\n@@ -2208,7 +2237,7 @@ emit_final_str_compare_vec (rtx str1, rtx str2, rtx result,\n       gcc_assert (TARGET_P8_VECTOR);\n       rtx diffix = gen_reg_rtx (DImode);\n       rtx result_gbbd = gen_reg_rtx (V16QImode);\n-      /* Since each byte of the input is either 00 or FF, the bytes in \n+      /* Since each byte of the input is either 00 or FF, the bytes in\n \t dw0 and dw1 after vgbbd are all identical to each other.  */\n       emit_insn (gen_p8v_vgbbd (result_gbbd, vec_result));\n       /* For LE, we shift by 9 and get BA in the low two bytes then CTZ.\n@@ -2226,7 +2255,7 @@ emit_final_str_compare_vec (rtx str1, rtx str2, rtx result,\n       else\n \temit_insn (gen_ctzdi2 (count, diffix));\n \n-      /* P8 doesn't have a good solution for extracting one byte from \n+      /* P8 doesn't have a good solution for extracting one byte from\n \t a vsx reg like vextublx on P9 so we just compute the offset\n \t of the differing byte and load it from each string.  */\n       do_add3 (off_reg, off_reg, count);\n@@ -2247,7 +2276,7 @@ emit_final_str_compare_vec (rtx str1, rtx str2, rtx result,\n }\n \n /* Expand a string compare operation with length, and return\n-   true if successful. Return false if we should let the\n+   true if successful.  Return false if we should let the\n    compiler generate normal code, probably a strncmp call.\n \n    OPERANDS[0] is the target (result).\n@@ -2279,9 +2308,9 @@ expand_strn_compare (rtx operands[], int no_length)\n   rtx src1_addr = force_reg (Pmode, XEXP (orig_src1, 0));\n   rtx src2_addr = force_reg (Pmode, XEXP (orig_src2, 0));\n \n-  /* If we have a length, it must be constant. This simplifies things\n+  /* If we have a length, it must be constant.  This simplifies things\n      a bit as we don't have to generate code to check if we've exceeded\n-     the length. Later this could be expanded to handle this case.  */\n+     the length.  Later this could be expanded to handle this case.  */\n   if (!no_length && !CONST_INT_P (bytes_rtx))\n     return false;\n \n@@ -2311,7 +2340,7 @@ expand_strn_compare (rtx operands[], int no_length)\n   else\n     bytes = UINTVAL (bytes_rtx);\n \n-  /* Is it OK to use vec/vsx for this. TARGET_VSX means we have at\n+  /* Is it OK to use vec/vsx for this.  TARGET_VSX means we have at\n      least POWER7 but we use TARGET_EFFICIENT_UNALIGNED_VSX which is\n      at least POWER8.  That way we can rely on overlapping compares to\n      do the final comparison of less than 16 bytes.  Also I do not\n@@ -2363,7 +2392,7 @@ expand_strn_compare (rtx operands[], int no_length)\n   rtx final_move_label = gen_label_rtx ();\n   rtx final_label = gen_label_rtx ();\n   rtx begin_compare_label = NULL;\n-  \n+\n   if (base_align < required_align)\n     {\n       /* Generate code that checks distance to 4k boundary for this case.  */\n@@ -2472,7 +2501,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t\t\t\t &cleanup_label, final_move_label);\n \n   offset = compare_length;\n-  \n+\n   if (equality_compare_rest)\n     {\n       /* Update pointers past what has been compared already.  */"}]}