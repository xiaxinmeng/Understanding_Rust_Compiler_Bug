{"sha": "904c09f4531f7c7c04ee867e53ffa4f2cf7ed131", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0YzA5ZjQ1MzFmN2M3YzA0ZWU4NjdlNTNmZmE0ZjJjZjdlZDEzMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-04T18:05:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-04T18:05:30Z"}, "message": "Document machine_mode wrapper classes\n\n2018-01-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/rtl.texi: Document machine_mode wrapper classes.\n\nFrom-SVN: r256259", "tree": {"sha": "7de809998436944db7983fc18e240a2a8777e9bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7de809998436944db7983fc18e240a2a8777e9bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131", "html_url": "https://github.com/Rust-GCC/gccrs/commit/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131/comments", "author": null, "committer": null, "parents": [{"sha": "1de1073520a877b46a0b93c5b0eb4c0b29b97e84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de1073520a877b46a0b93c5b0eb4c0b29b97e84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de1073520a877b46a0b93c5b0eb4c0b29b97e84"}], "stats": {"total": 111, "additions": 111, "deletions": 0}, "files": [{"sha": "d4321eb0312e22fa29134173cc8e30d2e56cda89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=904c09f4531f7c7c04ee867e53ffa4f2cf7ed131", "patch": "@@ -1,3 +1,7 @@\n+2018-01-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/rtl.texi: Document machine_mode wrapper classes.\n+\n 2018-01-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* fold-const.c (fold_ternary_loc): Check tree_fits_uhwi_p before"}, {"sha": "bd9e998f527db28257562ab55e8d1ab098de0686", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904c09f4531f7c7c04ee867e53ffa4f2cf7ed131/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=904c09f4531f7c7c04ee867e53ffa4f2cf7ed131", "patch": "@@ -1414,6 +1414,113 @@ classes.  Currently @code{VOIDmode} and @code{BLKmode} are in\n @code{MODE_RANDOM}.\n @end table\n \n+@cindex machine mode wrapper classes\n+@code{machmode.h} also defines various wrapper classes that combine a\n+@code{machine_mode} with a static assertion that a particular\n+condition holds.  The classes are:\n+\n+@table @code\n+@findex scalar_int_mode\n+@item scalar_int_mode\n+A mode that has class @code{MODE_INT} or @code{MODE_PARTIAL_INT}.\n+\n+@findex scalar_float_mode\n+@item scalar_float_mode\n+A mode that has class @code{MODE_FLOAT} or @code{MODE_DECIMAL_FLOAT}.\n+\n+@findex scalar_mode\n+@item scalar_mode\n+A mode that holds a single numerical value.  In practice this means\n+that the mode is a @code{scalar_int_mode}, is a @code{scalar_float_mode},\n+or has class @code{MODE_FRACT}, @code{MODE_UFRACT}, @code{MODE_ACCUM},\n+@code{MODE_UACCUM} or @code{MODE_POINTER_BOUNDS}.\n+\n+@findex complex_mode\n+@item complex_mode\n+A mode that has class @code{MODE_COMPLEX_INT} or @code{MODE_COMPLEX_FLOAT}.\n+\n+@findex fixed_size_mode\n+@item fixed_size_mode\n+A mode whose size is known at compile time.\n+@end table\n+\n+Named modes use the most constrained of the available wrapper classes,\n+if one exists, otherwise they use @code{machine_mode}.  For example,\n+@code{QImode} is a @code{scalar_int_mode}, @code{SFmode} is a\n+@code{scalar_float_mode} and @code{BLKmode} is a plain\n+@code{machine_mode}.  It is possible to refer to any mode as a raw\n+@code{machine_mode} by adding the @code{E_} prefix, where @code{E}\n+stands for ``enumeration''.  For example, the raw @code{machine_mode}\n+names of the modes just mentioned are @code{E_QImode}, @code{E_SFmode}\n+and @code{E_BLKmode} respectively.\n+\n+The wrapper classes implicitly convert to @code{machine_mode} and to any\n+wrapper class that represents a more general condition; for example\n+@code{scalar_int_mode} and @code{scalar_float_mode} both convert\n+to @code{scalar_mode} and all three convert to @code{fixed_size_mode}.\n+The classes act like @code{machine_mode}s that accept only certain\n+named modes.\n+\n+@findex opt_mode\n+@file{machmode.h} also defines a template class @code{opt_mode<@var{T}>}\n+that holds a @code{T} or nothing, where @code{T} can be either\n+@code{machine_mode} or one of the wrapper classes above.  The main\n+operations on an @code{opt_mode<@var{T}>} @var{x} are as follows:\n+\n+@table @samp\n+@item @var{x}.exists ()\n+Return true if @var{x} holds a mode rather than nothing.\n+\n+@item @var{x}.exists (&@var{y})\n+Return true if @var{x} holds a mode rather than nothing, storing the\n+mode in @var{y} if so.  @var{y} must be assignment-compatible with @var{T}.\n+\n+@item @var{x}.require ()\n+Assert that @var{x} holds a mode rather than nothing and return that mode.\n+\n+@item @var{x} = @var{y}\n+Set @var{x} to @var{y}, where @var{y} is a @var{T} or implicitly converts\n+to a @var{T}.\n+@end table\n+\n+The default constructor sets an @code{opt_mode<@var{T}>} to nothing.\n+There is also a constructor that takes an initial value of type @var{T}.\n+\n+It is possible to use the @file{is-a.h} accessors on a @code{machine_mode}\n+or machine mode wrapper @var{x}:\n+\n+@table @samp\n+@findex is_a\n+@item is_a <@var{T}> (@var{x})\n+Return true if @var{x} meets the conditions for wrapper class @var{T}.\n+\n+@item is_a <@var{T}> (@var{x}, &@var{y})\n+Return true if @var{x} meets the conditions for wrapper class @var{T},\n+storing it in @var{y} if so.  @var{y} must be assignment-compatible with\n+@var{T}.\n+\n+@item as_a <@var{T}> (@var{x})\n+Assert that @var{x} meets the conditions for wrapper class @var{T}\n+and return it as a @var{T}.\n+\n+@item dyn_cast <@var{T}> (@var{x})\n+Return an @code{opt_mode<@var{T}>} that holds @var{x} if @var{x} meets\n+the conditions for wrapper class @var{T} and that holds nothing otherwise.\n+@end table\n+\n+The purpose of these wrapper classes is to give stronger static type\n+checking.  For example, if a function takes a @code{scalar_int_mode},\n+a caller that has a general @code{machine_mode} must either check or\n+assert that the code is indeed a scalar integer first, using one of\n+the functions above.\n+\n+The wrapper classes are normal C++ classes, with user-defined\n+constructors.  Sometimes it is useful to have a POD version of\n+the same type, particularly if the type appears in a @code{union}.\n+The template class @code{pod_mode<@var{T}>} provides a POD version\n+of wrapper class @var{T}.  It is assignment-compatible with @var{T}\n+and implicitly converts to both @code{machine_mode} and @var{T}.\n+\n Here are some C macros that relate to machine modes:\n \n @table @code"}]}