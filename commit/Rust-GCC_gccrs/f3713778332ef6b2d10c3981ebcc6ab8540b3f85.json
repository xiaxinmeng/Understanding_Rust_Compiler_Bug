{"sha": "f3713778332ef6b2d10c3981ebcc6ab8540b3f85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3MTM3NzgzMzJlZjZiMmQxMGMzOTgxZWJjYzZhYjg1NDBiM2Y4NQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-08-14T09:10:13Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-08-14T09:10:13Z"}, "message": "re PR target/49903 ([avr] Redundant comparisons in binary-search switch/case expansion)\n\n\t\n\t* PR target/49903\n\t* config/avr/avr.md (UNSPEC_IDENTITY): New c_enum.\n\t(branch_unspec): New insn.\n\t(branch): Beauty farm.\n\t* config/avr/avr.c (compare_condition): Use JUMP_P.  Test SET_SRC\n\tto be IF_THEN_ELSE.\n\t(avr_compare_pattern, avr_reorg_remove_redundant_compare):\n\tNew static functions.\n\t(avr_reorg): Use them.  Use next_real_insn instead of NEXT_INSN.\n\tUse CONST_INT_P.  Beauty.\n\nFrom-SVN: r177744", "tree": {"sha": "445db3c84b839c8c0923ff0ffe355b8a99eb20bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/445db3c84b839c8c0923ff0ffe355b8a99eb20bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3713778332ef6b2d10c3981ebcc6ab8540b3f85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3713778332ef6b2d10c3981ebcc6ab8540b3f85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3713778332ef6b2d10c3981ebcc6ab8540b3f85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3713778332ef6b2d10c3981ebcc6ab8540b3f85/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdf03377272dc39c9c9ceea453282ba7a8032142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdf03377272dc39c9c9ceea453282ba7a8032142", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdf03377272dc39c9c9ceea453282ba7a8032142"}], "stats": {"total": 369, "additions": 294, "deletions": 75}, "files": [{"sha": "6e8c5adb2e9082996450b5a8b19f927262dcba56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3713778332ef6b2d10c3981ebcc6ab8540b3f85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3713778332ef6b2d10c3981ebcc6ab8540b3f85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3713778332ef6b2d10c3981ebcc6ab8540b3f85", "patch": "@@ -1,3 +1,16 @@\n+2011-08-14  Georg-Johann Lay  <avr@gjlay.de>\n+\t\n+\t* PR target/49903\n+\t* config/avr/avr.md (UNSPEC_IDENTITY): New c_enum.\n+\t(branch_unspec): New insn.\n+\t(branch): Beauty farm.\n+\t* config/avr/avr.c (compare_condition): Use JUMP_P.  Test SET_SRC\n+\tto be IF_THEN_ELSE.\n+\t(avr_compare_pattern, avr_reorg_remove_redundant_compare):\n+\tNew static functions.\n+\t(avr_reorg): Use them.  Use next_real_insn instead of NEXT_INSN.\n+\tUse CONST_INT_P.  Beauty.\n+\n 2011-08-12  David Li  <davidxl@google.com>\n \n \t* cp/class.c (update_vtable_entry_for_fn): Set"}, {"sha": "6bb236cb58423dafe96b263e0dbc4d123beca8d5", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 256, "deletions": 71, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3713778332ef6b2d10c3981ebcc6ab8540b3f85/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3713778332ef6b2d10c3981ebcc6ab8540b3f85/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f3713778332ef6b2d10c3981ebcc6ab8540b3f85", "patch": "@@ -2947,15 +2947,17 @@ static RTX_CODE\n compare_condition (rtx insn)\n {\n   rtx next = next_real_insn (insn);\n-  RTX_CODE cond = UNKNOWN;\n-  if (next && GET_CODE (next) == JUMP_INSN)\n+\n+  if (next && JUMP_P (next))\n     {\n       rtx pat = PATTERN (next);\n       rtx src = SET_SRC (pat);\n-      rtx t = XEXP (src, 0);\n-      cond = GET_CODE (t);\n+      \n+      if (IF_THEN_ELSE == GET_CODE (src))\n+        return GET_CODE (XEXP (src, 0));\n     }\n-  return cond;\n+  \n+  return UNKNOWN;\n }\n \n /* Returns nonzero if INSN is a tst insn that only tests the sign.  */\n@@ -6046,82 +6048,265 @@ avr_normalize_condition (RTX_CODE condition)\n     }\n }\n \n-/* This function optimizes conditional jumps.  */\n+/* Helper function for `avr_reorg'.  */\n+\n+static rtx\n+avr_compare_pattern (rtx insn)\n+{\n+  rtx pattern = single_set (insn);\n+\n+  if (pattern\n+      && NONJUMP_INSN_P (insn)\n+      && SET_DEST (pattern) == cc0_rtx\n+      && GET_CODE (SET_SRC (pattern)) == COMPARE)\n+    {\n+      return pattern;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Helper function for `avr_reorg'.  */\n+\n+/* Expansion of switch/case decision trees leads to code like\n+\n+       cc0 = compare (Reg, Num)\n+       if (cc0 == 0)\n+         goto L1\n+         \n+       cc0 = compare (Reg, Num)\n+       if (cc0 > 0)\n+         goto L2\n+\n+   The second comparison is superfluous and can be deleted.\n+   The second jump condition can be transformed from a\n+   \"difficult\" one to a \"simple\" one because \"cc0 > 0\" and\n+   \"cc0 >= 0\" will have the same effect here.\n+\n+   This function relies on the way switch/case is being expaned\n+   as binary decision tree.  For example code see PR 49903.\n+         \n+   Return TRUE if optimization performed.\n+   Return FALSE if nothing changed.\n+\n+   INSN1 is a comparison, i.e. avr_compare_pattern != 0.\n+\n+   We don't want to do this in text peephole because it is\n+   tedious to work out jump offsets there and the second comparison\n+   might have been transormed by `avr_reorg'.\n+\n+   RTL peephole won't do because peephole2 does not scan across\n+   basic blocks.  */                \n+                        \n+static bool\n+avr_reorg_remove_redundant_compare (rtx insn1)\n+{\n+  rtx comp1, ifelse1, xcond1, branch1;\n+  rtx comp2, ifelse2, xcond2, branch2, insn2;\n+  enum rtx_code code;\n+  rtx jump, target, cond;\n+  \n+  /* Look out for:  compare1 - branch1 - compare2 - branch2  */\n+\n+  branch1 = next_nonnote_nondebug_insn (insn1);\n+  if (!branch1 || !JUMP_P (branch1))\n+    return false;\n+\n+  insn2 = next_nonnote_nondebug_insn (branch1);\n+  if (!insn2 || !avr_compare_pattern (insn2))\n+    return false;\n+\n+  branch2 = next_nonnote_nondebug_insn (insn2);\n+  if (!branch2 || !JUMP_P (branch2))\n+    return false;\n+\n+  comp1 = avr_compare_pattern (insn1);\n+  comp2 = avr_compare_pattern (insn2);\n+  xcond1 = single_set (branch1);\n+  xcond2 = single_set (branch2);\n+  \n+  if (!comp1 || !comp2\n+      || !rtx_equal_p (comp1, comp2)\n+      || !xcond1 || SET_DEST (xcond1) != pc_rtx\n+      || !xcond2 || SET_DEST (xcond2) != pc_rtx\n+      || IF_THEN_ELSE != GET_CODE (SET_SRC (xcond1))\n+      || IF_THEN_ELSE != GET_CODE (SET_SRC (xcond2)))\n+    {\n+      return false;\n+    }\n+\n+  comp1 = SET_SRC (comp1);\n+  ifelse1 = SET_SRC (xcond1);\n+  ifelse2 = SET_SRC (xcond2);\n+\n+  /* comp<n> is COMPARE now and ifelse<n> is IF_THEN_ELSE.  */\n+\n+  if (EQ != GET_CODE (XEXP (ifelse1, 0))\n+      || !REG_P (XEXP (comp1, 0))\n+      || !CONST_INT_P (XEXP (comp1, 1))\n+      || XEXP (ifelse1, 2) != pc_rtx\n+      || XEXP (ifelse2, 2) != pc_rtx\n+      || LABEL_REF != GET_CODE (XEXP (ifelse1, 1))\n+      || LABEL_REF != GET_CODE (XEXP (ifelse2, 1))\n+      || !COMPARISON_P (XEXP (ifelse2, 0))\n+      || cc0_rtx != XEXP (XEXP (ifelse1, 0), 0)\n+      || cc0_rtx != XEXP (XEXP (ifelse2, 0), 0)\n+      || const0_rtx != XEXP (XEXP (ifelse1, 0), 1)\n+      || const0_rtx != XEXP (XEXP (ifelse2, 0), 1))\n+    {\n+      return false;\n+    }\n+\n+  /* We filtered the insn sequence to look like\n+\n+        (set (cc0)\n+             (compare (reg:M N)\n+                      (const_int VAL)))\n+        (set (pc)\n+             (if_then_else (eq (cc0)\n+                               (const_int 0))\n+                           (label_ref L1)\n+                           (pc)))\n+                           \n+        (set (cc0)\n+             (compare (reg:M N)\n+                      (const_int VAL)))\n+        (set (pc)\n+             (if_then_else (CODE (cc0)\n+                                 (const_int 0))\n+                           (label_ref L2)\n+                           (pc)))\n+  */\n+\n+  code = GET_CODE (XEXP (ifelse2, 0));\n+\n+  /* Map GT/GTU to GE/GEU which is easier for AVR.\n+     The first two instructions compare/branch on EQ\n+     so we may replace the difficult\n+        \n+        if (x == VAL)   goto L1;\n+        if (x > VAL)    goto L2;\n+\n+     with easy\n+         \n+         if (x == VAL)   goto L1;\n+         if (x >= VAL)   goto L2;\n+\n+     Similarly, replace LE/LEU by LT/LTU.  */\n+  \n+  switch (code)\n+    {\n+    case EQ:\n+    case LT:  case LTU:\n+    case GE:  case GEU:\n+      break;\n+\n+    case LE:  case LEU:\n+    case GT:  case GTU:\n+      code = avr_normalize_condition (code);\n+      break;\n+      \n+    default:\n+      return false;\n+    }\n+\n+  /* Wrap the branches into UNSPECs so they won't be changed or\n+     optimized in the remainder.  */\n+\n+  target = XEXP (XEXP (ifelse1, 1), 0);\n+  cond = XEXP (ifelse1, 0);\n+  jump = emit_jump_insn_after (gen_branch_unspec (target, cond), insn1);\n+\n+  JUMP_LABEL (jump) = JUMP_LABEL (branch1);\n+\n+  target = XEXP (XEXP (ifelse2, 1), 0);\n+  cond = gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n+  jump = emit_jump_insn_after (gen_branch_unspec (target, cond), insn2);\n+\n+  JUMP_LABEL (jump) = JUMP_LABEL (branch2);\n+\n+  /* The comparisons in insn1 and insn2 are exactly the same;\n+     insn2 is superfluous so delete it.  */\n+     \n+  delete_insn (insn2);\n+  delete_insn (branch1);\n+  delete_insn (branch2);\n+\n+  return true;\n+}\n+\n+\n+/* Implement `TARGET_MACHINE_DEPENDENT_REORG'.  */\n+/* Optimize conditional jumps.  */\n \n static void\n avr_reorg (void)\n {\n-  rtx insn, pattern;\n+  rtx insn = get_insns();\n   \n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  for (insn = next_real_insn (insn); insn; insn = next_real_insn (insn))\n     {\n-      if (! (GET_CODE (insn) == INSN\n-\t     || GET_CODE (insn) == CALL_INSN\n-\t     || GET_CODE (insn) == JUMP_INSN)\n-\t  || !single_set (insn))\n-\tcontinue;\n+      rtx pattern = avr_compare_pattern (insn);\n+      \n+      if (!pattern)\n+        continue;\n \n-      pattern = PATTERN (insn);\n+      if (optimize\n+          && avr_reorg_remove_redundant_compare (insn))\n+        {\n+          continue;\n+        }\n \n-      if (GET_CODE (pattern) == PARALLEL)\n-\tpattern = XVECEXP (pattern, 0, 0);\n-      if (GET_CODE (pattern) == SET\n-\t  && SET_DEST (pattern) == cc0_rtx\n-\t  && compare_diff_p (insn))\n+      if (compare_diff_p (insn))\n \t{\n-\t  if (GET_CODE (SET_SRC (pattern)) == COMPARE)\n-\t    {\n-\t      /* Now we work under compare insn.  */\n-\t      \n-\t      pattern = SET_SRC (pattern);\n-\t      if (true_regnum (XEXP (pattern,0)) >= 0\n-\t\t  && true_regnum (XEXP (pattern,1)) >= 0 )\n-\t\t{\n-\t\t  rtx x = XEXP (pattern,0);\n-\t\t  rtx next = next_real_insn (insn);\n-\t\t  rtx pat = PATTERN (next);\n-\t\t  rtx src = SET_SRC (pat);\n-\t\t  rtx t = XEXP (src,0);\n-\t\t  PUT_CODE (t, swap_condition (GET_CODE (t)));\n-\t\t  XEXP (pattern,0) = XEXP (pattern,1);\n-\t\t  XEXP (pattern,1) = x;\n-\t\t  INSN_CODE (next) = -1;\n-\t\t}\n-\t      else if (true_regnum (XEXP (pattern, 0)) >= 0\n-\t\t       && XEXP (pattern, 1) == const0_rtx)\n-\t        {\n-\t          /* This is a tst insn, we can reverse it.  */\n-\t          rtx next = next_real_insn (insn);\n-\t          rtx pat = PATTERN (next);\n-\t          rtx src = SET_SRC (pat);\n-\t          rtx t = XEXP (src,0);\n+          /* Now we work under compare insn with difficult branch.  */\n+          \n+          rtx next = next_real_insn (insn);\n+          rtx pat = PATTERN (next);\n+\n+          pattern = SET_SRC (pattern);\n+          \n+          if (true_regnum (XEXP (pattern, 0)) >= 0\n+              && true_regnum (XEXP (pattern, 1)) >= 0)\n+            {\n+              rtx x = XEXP (pattern, 0);\n+              rtx src = SET_SRC (pat);\n+              rtx t = XEXP (src,0);\n+              PUT_CODE (t, swap_condition (GET_CODE (t)));\n+              XEXP (pattern, 0) = XEXP (pattern, 1);\n+              XEXP (pattern, 1) = x;\n+              INSN_CODE (next) = -1;\n+            }\n+          else if (true_regnum (XEXP (pattern, 0)) >= 0\n+                   && XEXP (pattern, 1) == const0_rtx)\n+            {\n+              /* This is a tst insn, we can reverse it.  */\n+              rtx src = SET_SRC (pat);\n+              rtx t = XEXP (src,0);\n     \n-\t          PUT_CODE (t, swap_condition (GET_CODE (t)));\n-\t          XEXP (pattern, 1) = XEXP (pattern, 0);\n-\t          XEXP (pattern, 0) = const0_rtx;\n-\t          INSN_CODE (next) = -1;\n-\t          INSN_CODE (insn) = -1;\n-\t        }\n-\t      else if (true_regnum (XEXP (pattern,0)) >= 0\n-\t\t       && GET_CODE (XEXP (pattern,1)) == CONST_INT)\n-\t\t{\n-\t\t  rtx x = XEXP (pattern,1);\n-\t\t  rtx next = next_real_insn (insn);\n-\t\t  rtx pat = PATTERN (next);\n-\t\t  rtx src = SET_SRC (pat);\n-\t\t  rtx t = XEXP (src,0);\n-\t\t  enum machine_mode mode = GET_MODE (XEXP (pattern, 0));\n-\n-\t\t  if (avr_simplify_comparison_p (mode, GET_CODE (t), x))\n-\t\t    {\n-\t\t      XEXP (pattern, 1) = gen_int_mode (INTVAL (x) + 1, mode);\n-\t\t      PUT_CODE (t, avr_normalize_condition (GET_CODE (t)));\n-\t\t      INSN_CODE (next) = -1;\n-\t\t      INSN_CODE (insn) = -1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+              PUT_CODE (t, swap_condition (GET_CODE (t)));\n+              XEXP (pattern, 1) = XEXP (pattern, 0);\n+              XEXP (pattern, 0) = const0_rtx;\n+              INSN_CODE (next) = -1;\n+              INSN_CODE (insn) = -1;\n+            }\n+          else if (true_regnum (XEXP (pattern, 0)) >= 0\n+                   && CONST_INT_P (XEXP (pattern, 1)))\n+            {\n+              rtx x = XEXP (pattern, 1);\n+              rtx src = SET_SRC (pat);\n+              rtx t = XEXP (src,0);\n+              enum machine_mode mode = GET_MODE (XEXP (pattern, 0));\n+              \n+              if (avr_simplify_comparison_p (mode, GET_CODE (t), x))\n+                {\n+                  XEXP (pattern, 1) = gen_int_mode (INTVAL (x) + 1, mode);\n+                  PUT_CODE (t, avr_normalize_condition (GET_CODE (t)));\n+                  INSN_CODE (next) = -1;\n+                  INSN_CODE (insn) = -1;\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "ad0febc333e7405cc3ecca6e7c110efb64940e8c", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3713778332ef6b2d10c3981ebcc6ab8540b3f85/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3713778332ef6b2d10c3981ebcc6ab8540b3f85/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=f3713778332ef6b2d10c3981ebcc6ab8540b3f85", "patch": "@@ -56,6 +56,7 @@\n    UNSPEC_FMULS\n    UNSPEC_FMULSU\n    UNSPEC_COPYSIGN\n+   UNSPEC_IDENTITY\n    ])\n \n (define_c_enum \"unspecv\"\n@@ -3339,16 +3340,36 @@\n (define_insn \"branch\"\n   [(set (pc)\n         (if_then_else (match_operator 1 \"simple_comparison_operator\"\n-                        [(cc0)\n-                         (const_int 0)])\n+                                      [(cc0)\n+                                       (const_int 0)])\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"\"\n-  \"*\n-   return ret_cond_branch (operands[1], avr_jump_mode (operands[0],insn), 0);\"\n+  {\n+    return ret_cond_branch (operands[1], avr_jump_mode (operands[0], insn), 0);\n+  }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n \n+\n+;; Same as above but wrap SET_SRC so that this branch won't be transformed\n+;; or optimized in the remainder.\n+\n+(define_insn \"branch_unspec\"\n+  [(set (pc)\n+        (unspec [(if_then_else (match_operator 1 \"simple_comparison_operator\"\n+                                               [(cc0)\n+                                                (const_int 0)])\n+                               (label_ref (match_operand 0 \"\" \"\"))\n+                               (pc))\n+                 ] UNSPEC_IDENTITY))]\n+  \"\"\n+  {\n+    return ret_cond_branch (operands[1], avr_jump_mode (operands[0], insn), 0);\n+  }\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")])\n+\n ;; ****************************************************************\n ;; AVR does not have following conditional jumps: LE,LEU,GT,GTU.\n ;; Convert them all to proper jumps."}]}