{"sha": "bb4034b3224982145f0cd751c89dfa9d93f7c39d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI0MDM0YjMyMjQ5ODIxNDVmMGNkNzUxYzg5ZGZhOWQ5M2Y3YzM5ZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-09-23T19:54:07Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-09-23T19:54:07Z"}, "message": "(invalidate): New parameter FULL_MODE.  All callers changed.\n\n(set_nonvarying_address_components): Modify initial comment.\n(cse_insn): When call invalidate for dest, use the actual dest not\ninner_dest.\n\nFrom-SVN: r8124", "tree": {"sha": "a401fe2aaf257baa8a8b875b921c78ebbacda8f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a401fe2aaf257baa8a8b875b921c78ebbacda8f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb4034b3224982145f0cd751c89dfa9d93f7c39d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb4034b3224982145f0cd751c89dfa9d93f7c39d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb4034b3224982145f0cd751c89dfa9d93f7c39d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb4034b3224982145f0cd751c89dfa9d93f7c39d/comments", "author": null, "committer": null, "parents": [{"sha": "73f277280f8f89979f1ecea9de0ef8a385f7f0f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73f277280f8f89979f1ecea9de0ef8a385f7f0f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73f277280f8f89979f1ecea9de0ef8a385f7f0f8"}], "stats": {"total": 65, "additions": 38, "deletions": 27}, "files": [{"sha": "904eed7c22516bbac8b5371e15e3233daf6aa9eb", "filename": "gcc/cse.c", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb4034b3224982145f0cd751c89dfa9d93f7c39d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb4034b3224982145f0cd751c89dfa9d93f7c39d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bb4034b3224982145f0cd751c89dfa9d93f7c39d", "patch": "@@ -1480,14 +1480,18 @@ merge_equiv_classes (class1, class2)\n    (because, when a memory reference with a varying address is stored in,\n    all memory references are removed by invalidate_memory\n    so specific invalidation is superfluous).\n+   FULL_MODE, if not VOIDmode, indicates that this much should be invalidated\n+   instead of just the amount indicated by the mode of X.  This is only used\n+   for bitfield stores into memory.\n \n    A nonvarying address may be just a register or just\n    a symbol reference, or it may be either of those plus\n    a numeric offset.  */\n \n static void\n-invalidate (x)\n+invalidate (x, full_mode)\n      rtx x;\n+     enum machine_mode full_mode;\n {\n   register int i;\n   register struct table_elt *p;\n@@ -1562,7 +1566,7 @@ invalidate (x)\n     {\n       if (GET_CODE (SUBREG_REG (x)) != REG)\n \tabort ();\n-      invalidate (SUBREG_REG (x));\n+      invalidate (SUBREG_REG (x), VOIDmode);\n       return;\n     }\n \n@@ -1573,7 +1577,10 @@ invalidate (x)\n   if (GET_CODE (x) != MEM)\n     abort ();\n \n-  set_nonvarying_address_components (XEXP (x, 0), GET_MODE_SIZE (GET_MODE (x)),\n+  if (full_mode == VOIDmode)\n+    full_mode = GET_MODE (x);\n+\n+  set_nonvarying_address_components (XEXP (x, 0), GET_MODE_SIZE (full_mode),\n \t\t\t\t     &base, &start, &end);\n \n   for (i = 0; i < NBUCKETS; i++)\n@@ -2230,9 +2237,10 @@ refers_to_p (x, y)\n    set PBASE, PSTART, and PEND which correspond to the base of the address,\n    the starting offset, and ending offset respectively.\n \n-   ADDR is known to be a nonvarying address. \n+   ADDR is known to be a nonvarying address.  */\n \n-   cse_address_varies_p returns zero for nonvarying addresses.  */\n+/* ??? Despite what the comments say, this function is in fact frequently\n+   passed varying addresses.  This does not appear to cause any problems.  */\n \n static void\n set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n@@ -5998,7 +6006,7 @@ cse_insn (insn, in_libcall_block)\n     {\n       for (tem = CALL_INSN_FUNCTION_USAGE (insn); tem; tem = XEXP (tem, 1))\n \tif (GET_CODE (XEXP (tem, 0)) == CLOBBER)\n-          invalidate (SET_DEST (XEXP (tem, 0)));\n+          invalidate (SET_DEST (XEXP (tem, 0)), VOIDmode);\n     }\n \n   if (GET_CODE (x) == SET)\n@@ -6029,7 +6037,7 @@ cse_insn (insn, in_libcall_block)\n \t  canon_reg (SET_SRC (x), insn);\n \t  apply_change_group ();\n \t  fold_rtx (SET_SRC (x), insn);\n-\t  invalidate (SET_DEST (x));\n+\t  invalidate (SET_DEST (x), VOIDmode);\n \t}\n       else\n \tn_sets = 1;\n@@ -6060,10 +6068,10 @@ cse_insn (insn, in_libcall_block)\n \n \t      if (GET_CODE (clobbered) == REG\n \t\t  || GET_CODE (clobbered) == SUBREG)\n-\t\tinvalidate (clobbered);\n+\t\tinvalidate (clobbered, VOIDmode);\n \t      else if (GET_CODE (clobbered) == STRICT_LOW_PART\n \t\t       || GET_CODE (clobbered) == ZERO_EXTRACT)\n-\t\tinvalidate (XEXP (clobbered, 0));\n+\t\tinvalidate (XEXP (clobbered, 0), GET_MODE (clobbered));\n \t    }\n \t}\n \t    \n@@ -6079,7 +6087,7 @@ cse_insn (insn, in_libcall_block)\n \t\t  canon_reg (SET_SRC (y), insn);\n \t\t  apply_change_group ();\n \t\t  fold_rtx (SET_SRC (y), insn);\n-\t\t  invalidate (SET_DEST (y));\n+\t\t  invalidate (SET_DEST (y), VOIDmode);\n \t\t}\n \t      else if (SET_DEST (y) == pc_rtx\n \t\t       && GET_CODE (SET_SRC (y)) == LABEL_REF)\n@@ -6969,10 +6977,10 @@ cse_insn (insn, in_libcall_block)\n \t{\n \t  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n \t      || GET_CODE (dest) == MEM)\n-\t    invalidate (dest);\n+\t    invalidate (dest, VOIDmode);\n \t  else if (GET_CODE (dest) == STRICT_LOW_PART\n \t\t   || GET_CODE (dest) == ZERO_EXTRACT)\n-\t    invalidate (XEXP (dest, 0));\n+\t    invalidate (XEXP (dest, 0), GET_MODE (dest));\n \t  sets[i].rtl = 0;\n \t}\n \n@@ -7107,18 +7115,21 @@ cse_insn (insn, in_libcall_block)\n   for (i = 0; i < n_sets; i++)\n     if (sets[i].rtl)\n       {\n-\tregister rtx dest = sets[i].inner_dest;\n+\t/* We can't use the inner dest, because the mode associated with\n+\t   a ZERO_EXTRACT is significant.  */\n+\tregister rtx dest = SET_DEST (sets[i].rtl);\n \n \t/* Needed for registers to remove the register from its\n \t   previous quantity's chain.\n \t   Needed for memory if this is a nonvarying address, unless\n \t   we have just done an invalidate_memory that covers even those.  */\n \tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n-\t    || (! writes_memory.all && ! cse_rtx_addr_varies_p (dest)))\n-\t  invalidate (dest);\n+\t    || (GET_CODE (dest) == MEM && ! writes_memory.all\n+\t\t&& ! cse_rtx_addr_varies_p (dest)))\n+\t  invalidate (dest, VOIDmode);\n \telse if (GET_CODE (dest) == STRICT_LOW_PART\n \t\t || GET_CODE (dest) == ZERO_EXTRACT)\n-\t  invalidate (XEXP (dest, 0));\n+\t  invalidate (XEXP (dest, 0), GET_MODE (dest));\n       }\n \n   /* Make sure registers mentioned in destinations\n@@ -7430,7 +7441,7 @@ invalidate_from_clobbers (w, x)\n \n       /* This should be *very* rare.  */\n       if (TEST_HARD_REG_BIT (hard_regs_in_table, STACK_POINTER_REGNUM))\n-\tinvalidate (stack_pointer_rtx);\n+\tinvalidate (stack_pointer_rtx, VOIDmode);\n     }\n \n   if (GET_CODE (x) == CLOBBER)\n@@ -7440,10 +7451,10 @@ invalidate_from_clobbers (w, x)\n \t{\n \t  if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n \t      || (GET_CODE (ref) == MEM && ! w->all))\n-\t    invalidate (ref);\n+\t    invalidate (ref, VOIDmode);\n \t  else if (GET_CODE (ref) == STRICT_LOW_PART\n \t\t   || GET_CODE (ref) == ZERO_EXTRACT)\n-\t    invalidate (XEXP (ref, 0));\n+\t    invalidate (XEXP (ref, 0), GET_MODE (ref));\n \t}\n     }\n   else if (GET_CODE (x) == PARALLEL)\n@@ -7459,10 +7470,10 @@ invalidate_from_clobbers (w, x)\n \t\t{\n \t\t  if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n \t\t      || (GET_CODE (ref) == MEM && !w->all))\n-\t\t    invalidate (ref);\n+\t\t    invalidate (ref, VOIDmode);\n \t\t  else if (GET_CODE (ref) == STRICT_LOW_PART\n \t\t\t   || GET_CODE (ref) == ZERO_EXTRACT)\n-\t\t    invalidate (XEXP (ref, 0));\n+\t\t    invalidate (XEXP (ref, 0), GET_MODE (ref));\n \t\t}\n \t    }\n \t}\n@@ -7592,10 +7603,10 @@ cse_around_loop (loop_start)\n       if (GET_CODE (p->exp) == MEM || GET_CODE (p->exp) == REG\n \t  || (GET_CODE (p->exp) == SUBREG\n \t      && GET_CODE (SUBREG_REG (p->exp)) == REG))\n-\tinvalidate (p->exp);\n+\tinvalidate (p->exp, VOIDmode);\n       else if (GET_CODE (p->exp) == STRICT_LOW_PART\n \t       || GET_CODE (p->exp) == ZERO_EXTRACT)\n-\tinvalidate (XEXP (p->exp, 0));\n+\tinvalidate (XEXP (p->exp, 0), GET_MODE (p->exp));\n \n   /* Process insns starting after LOOP_START until we hit a CALL_INSN or\n      a CODE_LABEL (we could handle a CALL_INSN, but it isn't worth it).\n@@ -7654,10 +7665,10 @@ invalidate_skipped_set (dest, set)\n \n   if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n       || (! skipped_writes_memory.all && ! cse_rtx_addr_varies_p (dest)))\n-    invalidate (dest);\n+    invalidate (dest, VOIDmode);\n   else if (GET_CODE (dest) == STRICT_LOW_PART\n \t   || GET_CODE (dest) == ZERO_EXTRACT)\n-    invalidate (XEXP (dest, 0));\n+    invalidate (XEXP (dest, 0), GET_MODE (dest));\n }\n \n /* Invalidate all insns from START up to the end of the function or the\n@@ -7809,10 +7820,10 @@ cse_set_around_loop (x, insn, loop_start)\n   if (GET_CODE (SET_DEST (x)) == REG || GET_CODE (SET_DEST (x)) == SUBREG\n       || (GET_CODE (SET_DEST (x)) == MEM && ! writes_memory.all\n \t  && ! cse_rtx_addr_varies_p (SET_DEST (x))))\n-    invalidate (SET_DEST (x));\n+    invalidate (SET_DEST (x), VOIDmode);\n   else if (GET_CODE (SET_DEST (x)) == STRICT_LOW_PART\n \t   || GET_CODE (SET_DEST (x)) == ZERO_EXTRACT)\n-    invalidate (XEXP (SET_DEST (x), 0));\n+    invalidate (XEXP (SET_DEST (x), 0), GET_MODE (SET_DEST (x)));\n }\n \f\n /* Find the end of INSN's basic block and return its range,"}]}