{"sha": "953ff28998b59b0912be907d74f7afa5a8ed1e9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUzZmYyODk5OGI1OWIwOTEyYmU5MDdkNzRmN2FmYTVhOGVkMWU5Yw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-01-18T19:21:25Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-01-18T19:21:25Z"}, "message": "[multiple changes]\n\n2006-01-18  Richard Henderson  <rth@redhat.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n            Diego Novillo  <dnovillo@redhat.com>\n\n\t* libgomp: New directory.\n\t* Makefile.def: Add target_module libgomp.\n\t* Makefile.in: Regenerate.\n\t* configure.in (target_libraries): Add target-libgomp.\n\t* configure: Regenerate.\n\n\ncontrib/\n\n2006-01-18  Richard Henderson  <rth@redhat.com>\n            Diego Novillo  <dnovillo@redhat.com>\n\n\t* gcc_update (files_and_dependencies): Add libgomp files.\n\n\ngcc/\n\n2006-01-18  Richard Henderson  <rth@redhat.com>\n            Aldy Hernandez  <aldyh@redhat.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n            Diego Novillo  <dnovillo@redhat.com>\n\n\t* omp-low.c: New file.\n\t* c-omp.c: New file.\n\n2006-01-18  Richard Henderson  <rth@redhat.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n            Diego Novillo  <dnovillo@redhat.com>\n\n\t* doc/invoke.texi: Document -fopenmp.\n\t* tree-dump.h (debug_function): Declare.\n\n\t* hooks.c (hook_bool_tree_bool_false): New function.\n\t(hook_tree_tree_null): Remove.\n\t(hook_tree_tree_tree_null): New.\n\t* hooks.h: Update to match.\n\n\t* tree-pretty-print.c (debug_tree_chain): New.\n\t(print_generic_expr): Handle TDF_CHAIN.\n\t(dump_generic_node): Handle BLOCK.\n\tDo not abort with incomplete SWITCH_EXPRs.\n\tDo not dump body of an OpenMP directive if TDF_SLIM is given.\n\t<case OMP_PARALLEL, OMP_FOR, OMP_SECTIONS>: Don't\n\tprint space after directive name.\n\t<OMP_FOR>: Handle printing OMP_FOR_PRE_BODY.\n\tHandle OMP_MASTER and OMP_ORDERED.\n\tHandle printing of OMP_BODY just in one place, goto\n\tdump_omp_body in the rest of OMP_* nodes that have\n\tOMP_BODY.\n\tDon't handle clause nodes here.  Update omp statements to\n\tuse dump_omp_clauses.\n\tHandle OMP_SINGLE, OMP_SECTIONS, OMP_SECTION,\n\tOMP_CLAUSE_ORDERED, OMP_CLAUSE_SCHEDULE, OMP_ATOMIC,\n\tOMP_CRITICAL, OMP_CLAUSE_NOWAIT, GOMP_CLAUSE_IF,\n\tGOMP_CLAUSE_NUM_THREADS, GOMP_FOR, GOMP_CLAUSE_SHARED,\n\tGOMP_CLAUSE_FIRSTPRIVATE, GOMP_CLAUSE_LASTPRIVATE,\n\tGOMP_CLAUSE_COPYIN and GOMP_CLAUSE_COPYPRIVATE.\n\tAdjust output for GOMP_PARALLEL.\n\t(dump_omp_clauses): New.\n\t(print_declaration): Dump DECL_VALUE_EXPR.\n\t(op_symbol_1): Split out of op_symbol.\n\t(dumping_stmts): Remove.  Update all users.\n\n\t* cgraph.c (cgraph_analyze_queue): New.\n\t(cgraph_add_new_function): New.\n\t* cgraph.h (cgraph_analyze_queue): Declare.\n\t(cgraph_add_new_function): Declare.\n\t(cgraph_lower_function): Remove.\n\n\t* tree.c (walk_tree): Walk OMP_CLAUSE_CHAIN of OMP_CLAUSE_*\n\tnodes.  Use switch for all nodes, handle most of IS_EXPR_CODE_CLASS\n\tand TYPE_P nodes in its default clause.\n\t(empty_body_p): New.\n\t(tree_range_check_failed): New.\n\t(build5_stat): New.\n\n\t* tree.h (OMP_CLAUSE_REDUCTION_INIT,\n\tOMP_CLAUSE_REDUCTION_MERGE,\n\tOMP_CLAUSE_REDUCTION_PLACEHOLDER,\n\tOMP_CLAUSE_PRIVATE_DEBUG,\n\tOMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE, OMP_FOR_PRE_BODY,\n\tOMP_MASTER_BODY, OMP_ORDERED_BODY OMP_BODY,\n\tOMP_CLAUSES, OMP_CLAUSE_DECL, OMP_CLAUSE_DEFAULT_KIND,\n\tOMP_CLAUSE_CHAIN, OMP_CLAUSE_OUTER_DECL,\n\tOMP_CLAUSE_INNER_DECL, OMP_CLAUSE_NUM_THREADS_EXPR,\n\tOMP_CLAUSE_IF_EXPR, OMP_CLAUSE_SCHEDULE_CHUNK_EXPR,\n\tOMP_CLAUSE_SCHEDULE_CHUNK_SIZE. OMP_PARALLEL_VAR_INIT,\n\tOMP_PARALLEL_VAR_REDUC, OMP_FOR_VAR_INIT,\n\tOMP_FOR_VAR_LAST, OMP_FOR_VAR_REDUC,\n\tOMP_SECTIONS_VAR_INIT, OMP_SECTIONS_VAR_LAST,\n\tOMP_SECTIONS_VAR_REDUC, OMP_CLAUSE_REDUCTION_CODE\n\tOMP_SINGLE_CLAUSES, OMP_SINGLE_BODY,\n\tOMP_CLAUSE_SCHEDULE_CHUNK_SIZE, OMP_SECTION_BODY,\n\tOMP_CRITICAL_NAME, OMP_CRITICAL_BODY): New.\n\t(TREE_RANGE_CHECK): New.\n\t(empty_body_p): Declare.\n\t(enum omp_clause_default_kind): New.\n\t(build_string_literal): Declare.\n\t(enum omp_clause_schedule_kind, OMP_CLAUSE_SCHEDULE_KIND): New.\n\t(build5_stat, build5): Declare.\n\n\t* tree-pass.h (TDF_CHAIN): Define.\n\t* tree-pass.h (PROP_gimple_lomp): Define.\n\t(pass_lower_omp): Declare.\n\n\t* diagnostic.h (debug_tree_chain): Declare.\n\n\t* builtins.c (get_builtin_sync_mode): Use 0 as last argument to\n\tmode_for_size.\n\t(expand_builtin): Handle sync BUILT_IN_*_16 builtins.\n\t* builtins.c (build_string_literal): Make extern.\n\n\t* gcc.c (include_spec_function): New.\n\t(static_spec_functions): Add it.\n\t(main): Move load of libgomp.spec ...\n\t(LINK_COMMAND_SPEC): ... here.\n\t(link_gomp_spec): New.\n\t(static_specs): Include it.\n\t(LINK_COMMAND_SPEC): Add link_gomp.\n\t(GOMP_SELF_SPECS): New.\n\t(driver_self_specs): Include it.\n\t(switch_matches): Don't mark inline.\n\t(main): Load libgomp.spec.\n\n\t* tree-gimple.c (is_gimple_stmt): True for OMP_MASTER,\n\tOMP_ORDERED, OMP_CRITICAL, OMP_SECTIONS, OMP_SECTION,\n\tand OMP_SINGLE, OMP_FOR and OMP_PARALLEL.\n\n\t* tree-gimple.h (enum omp_parallel): Declare.\n\t(determine_parallel_type): Declare.\n\t(omp_firstprivatize_variable): Declare.\n\t(omp_reduction_init): Declare.\n\t(diagnose_omp_structured_block_errors): Declare.\n\t(struct walk_stmt_info): Add want_return_expr.\n\t(struct walk_stmt_info): Add want_bind_expr, want_locations.\n\t(find_omp_clause): Declare.\n\t(insert_field_into_struct): Declare.\n\t(struct walk_stmt_info): Move from tree-nested.c\n\t(walk_stmts): Declare.\n\n\t* c-cppbuiltin.c (c_cpp_builtins): If -fopenmp, #define _OPENMP\n\tto 200505.\n\n\t* cgraphunit.c (cgraph_lower_function): Make static.\n\t(cgraph_finalize_pending_functions): New.\n\t(cgraph_finalize_function): Call it.\n\t(cgraph_finalize_compilation_unit): Likewise.\n\n\t* builtin-types.def (BT_I16, BT_FN_I16_VPTR_I16,\n\tBT_FN_BOOL_VPTR_I16_I16, BT_FN_I16_VPTR_I16_I16): Add.\n\t(BT_FN_UINT_UINT): New.\n\t(DEF_FUNCTION_TYPE_6, DEF_FUNCTION_TYPE_7,\n\tDEF_FUNCTION_TYPE_VAR_4): Document.\n\t(BT_PTR_LONG, BT_PTR_PTR, BT_FN_BOOL, BT_FN_INT,\n\tBT_FN_VOID_PTRPTR, BT_PTR_FN_VOID_PTR,\n\tBT_FN_BOOL_LONGPTR_LONGPTR, BT_FN_VOID_OMPFN_PTR_UINT,\n\tBT_FN_VOID_OMPFN_PTR_UINT_UINT,\n\tBT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n\tBT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG): New.\n\n\t* builtins.def: Update DEF_BUILTIN comment to include COND argument.\n\tMove all DEF_SYNC_BUILTIN () and DEF_GOMP_BUILTIN () builtins\n\tinto separate files.\n\t(DEF_GOMP_BUILTIN): New.\n\t(BUILT_IN_OMP_GET_THREAD_NUM, BUILT_IN_GOMP_BARRIER,\n\tBUILT_IN_GOMP_CRITICAL_START, BUILT_IN_GOMP_CRITICAL_END,\n\tBUILT_IN_GOMP_CRITICAL_NAME_START, BUILT_IN_GOMP_CRITICAL_NAME_END,\n\tBUILT_IN_GOMP_LOOP_STATIC_START, BUILT_IN_GOMP_LOOP_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_GUIDED_START, BUILT_IN_GOMP_LOOP_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_ORDERED_STATIC_START,\n\tBUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_ORDERED_GUIDED_START,\n\tBUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_STATIC_NEXT, BUILT_IN_GOMP_LOOP_DYNAMIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_GUIDED_NEXT, BUILT_IN_GOMP_LOOP_RUNTIME_NEXT,\n\tBUILT_IN_GOMP_LOOP_ORDERED_STATIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_ORDERED_GUIDED_NEXT,\n\tBUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_NEXT,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC_START,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_GUIDED_START,\n\tBUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_END, BUILT_IN_GOMP_LOOP_END_NOWAIT,\n\tBUILT_IN_GOMP_ORDERED_START, BUILT_IN_GOMP_ORDERED_END,\n\tBUILT_IN_GOMP_PARALLEL_START, BUILT_IN_GOMP_PARALLEL_END,\n\tBUILT_IN_GOMP_SECTIONS_START, BUILT_IN_GOMP_SECTIONS_NEXT,\n\tBUILT_IN_GOMP_PARALLEL_SECTIONS_START, BUILT_IN_GOMP_SECTIONS_END,\n\tBUILT_IN_GOMP_SECTIONS_END_NOWAIT, BUILT_IN_GOMP_SINGLE_START,\n\tBUILT_IN_GOMP_SINGLE_COPY_START, BUILT_IN_GOMP_SINGLE_COPY_END): New.\n\t* sync-builtins.def: New file, moved from builtins.def.\n\t* omp-builtins.def: New file, moved from builtins.def.\n\n\t* c-objc-common.h (LANG_HOOKS_OMP_PREDETERMINED_SHARING): Redefine.\n\n\t* gimple-low.c (lower_function_body): Clear data.\n\t(lower_stmt): Do not handle COMPOUND_EXPR.\n\tRemove call to print_node_brief.\n\n\t* c-tree.h (c_finish_omp_clauses): New prototype.\n\t(C_DECL_THREADPRIVATE_P): Define.\n\t(lookup_name_no_remap, c_omp_remap_private): Remove\n\t(c_begin_omp_parallel, c_finish_omp_parallel): Update.\n\t(check_for_loop_decls): Update decl.\n\t(lookup_name_no_remap, c_omp_remap_private): Declare.\n\t(build_indirect_ref, build_modify_expr, pushdecl,\n\tpushdecl_top_level): Move to c-common.h.\n\n\t* dwarf2out.c (loc_descriptor_from_tree_1): Don't set unsignedp\n\tbefore the switch, but just in the 2 places that need it.\n\n\t* c-decl.c (diagnose_mismatched_decls): Do not check for\n\tmismatched thread-local attributes when OLDDECL is marked\n\tthreadprivate and NEWDECL has no thread-local attributes.\n\t(merge_decls): Merge C_DECL_THREADPRIVATE_P.\n\t(c_gimple_diagnostics_recursively): Rename from\n\tc_warn_unused_result_recursively.  Invoke\n\tdiagnose_omp_structured_block_errors.\n\t(check_for_loop_decls): Return a singular decl found.\n\n\t* langhooks.c (lhd_omp_predetermined_sharing): Return\n\tOMP_CLAUSE_DEFAULT_SHARED for DECL_ARTIFICIAL decls.\n\t(lhd_omp_firstprivatize_type_sizes): New.\n\t(lhd_omp_assignment): New.\n\t(lhd_omp_predetermined_sharing): New.\n\n\t* langhooks.h (struct gimplify_omp_ctx): Forward declare.\n\t(struct lang_hooks_for_types): Add\n\tomp_firstprivatize_type_sizes, omp_privatize_by_reference,\n\tomp_predetermined_sharing, omp_disregard_value_expr,\n\tomp_private_debug_clause, omp_clause_default_ctor,\n\tomp_clause_copy_ctor, omp_clause_assign_op, omp_clause_dtor.\n\n\t(c_finish_omp_clauses): New.\n\t(c_finish_bc_stmt): Diagnose break within omp for.\n\t(c_begin_omp_parallel, c_finish_omp_parallel): New.\n\t(build_unary_op): Return error_mark after reporting\n\ta readonly_error.\n\t(build_modify_expr): Likewise.\n\n\t* gimplify.c: Include optabs.h and pointer-set.h.\n\t(enum gimplify_omp_var_data): Declare.\n\t(struct gimplify_omp_ctx): Declare.\n\t(struct gimplify_ctx): Add fields prev_context, combined_pre_p\n\tand combined_ctxp.\n\t(gimplify_ctxp, gimplify_omp_ctxp): New local variables.\n\t(push_gimplify_context, pop_gimplify_context): Allow nesting.\n\t(splay_tree_compare_decl_uid): New.\n\t(new_omp_context): New.\n\t(delete_omp_context): New.\n\t(gimple_add_tmp_var): Call omp_add_variable.\n\t(gimplify_bind_expr): Likewise.\n\t(gimplify_var_or_parm_decl): If omp_notice_variable returned\n\ttrue, disregard DECL_VALUE_EXPR on the decl if any.\n\t(gimplify_expr_in_ctx): New.\n\t(omp_firstprivatize_variable, omp_firstprivatize_type_sizes\n\tomp_add_variable, omp_notice_variable, omp_is_private\n\tgimplify_scan_omp_clauses, gimplify_adjust_omp_clauses_1\n\tgimplify_adjust_omp_clauses, gimplify_omp_parallel\n\tgimplify_omp_for, gimplify_omp_workshare, goa_lhs_expr_p\n\tgimplify_omp_atomic_fetch_op, goa_stabilize_expr\n\tgimplify_omp_atomic_pipeline, gimplify_omp_atomic_mutex\n\tgimplify_omp_atomic): New.\n\t(gimplify_expr): Handle OMP_PARALLEL, OMP_FOR, OMP_SECTIONS,\n\tOMP_SINGLE, OMP_SECTION, OMP_MASTER, OMP_ORDERED,\n\tOMP_CRITICAL and OMP_ATOMIC.\n\t(gimplify_body): Verify gimplify_ctxp is empty after gimplification.\n\n\t* c-pragma.h (enum pragma_kind): Add\n\tPRAGMA_OMP_ATOMIC, PRAGMA_OMP_BARRIER,\n\tPRAGMA_OMP_CRITICAL, PRAGMA_OMP_FLUSH, PRAGMA_OMP_FOR,\n\tPRAGMA_OMP_MASTER, PRAGMA_OMP_ORDERED,\n\tPRAGMA_OMP_PARALLEL, PRAGMA_OMP_PARALLEL_FOR,\n\tPRAGMA_OMP_PARALLEL_SECTIONS, PRAGMA_OMP_SECTION,\n\tPRAGMA_OMP_SECTIONS, PRAGMA_OMP_SINGLE,\n\tPRAGMA_OMP_THREADPRIVATE.\n\n\t* tree.def (OMP_PARALLEL, OMP_FOR, OMP_SECTIONS,\n\tOMP_SINGLE, OMP_SECTION, OMP_MASTER, OMP_ORDERED,\n\tOMP_CRITICAL, OMP_ATOMIC, OMP_CLAUSE_PRIVATE,\n\tOMP_CLAUSE_SHARED, OMP_CLAUSE_FIRSTPRIVATE,\n\tOMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_REDUCTION,\n\tOMP_CLAUSE_COPYIN, OMP_CLAUSE_COPYPRIVATE,\n\tOMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS,\n\tOMP_CLAUSE_SCHEDULE, OMP_CLAUSE_NOWAIT,\n\tOMP_CLAUSE_ORDERED, OMP_CLAUSE_DEFAULT): Define.\n\n\t* print-tree.c (print_node): Dump DECL_VALUE_EXPR.\n\n\t* tree-ssa-dce.c (find_control_dependence): Do not assume that\n\tENTRY_BLOCK_PTR->next_bb == single_succ (ENTRY_BLOCK_PTR).\n\n\t* tree-nested.c (convert_call_expr): Call walk_body on OMP_BODY for\n\tOpenMP directives.\n\t(struct nesting_info): Add field_map,\n\tsuppress_expansion, debug_var_chain.\n\t(create_nesting_tree): Initialize them.\n\t(lookup_field_for_decl): Use field_map.\n\t(get_nonlocal_debug_decl, get_local_debug_decl): New.\n\t(convert_local_omp_clauses): New.\n\t(finalize_nesting_tree_1): Add debug_var_chain to toplevel block.\n\t(walk_body): Split out of walk_function.\n\t(convert_nonlocal_omp_clauses, convert_local_omp_clauses): New.\n\t(convert_nonlocal_reference): Handle omp statements.\n\t(convert_local_reference): Likewise.\n\t(unnest_nesting_tree_1): Split out of finalize_nesting_tree_1.\n\t(unnest_nesting_tree): New.\n\t(lower_nested_functions): Call it.\n\t(insert_field_into_struct): Make extern.\n\t(struct walk_stmt_info): Move to tree-gimple.h.\n\t(walk_stmts): Make extern.\n\n\t* omp-builtins.def: New file.\n\n\t* tree-iterator.c (expr_only): Clarify comment.\n\n\t* c-common.h (pushdecl_top_level, pushdecl,\n\tbuild_modify_expr, build_indirect_ref,\n\tc_finish_omp_master, c_finish_omp_critical,\n\tc_finish_omp_ordered, c_finish_omp_barrier,\n\tc_finish_omp_atomic, c_finish_omp_flush,\n\tc_finish_omp_for, c_split_parallel_clauses,\n\tomp_clause_default_kind, c_omp_sharing_predetermined,\n\tc_omp_remap_decl): Declare.\n\n\t* Makefile.in (BUILTINS_DEF): Add omp-builtins.def.\n\t(OBJS-common): Add omp-low.o.\n\t(c-omp.o, omp-low.o): Add.\n\t(gimplify.o): Add dependency on $(OPTABS_H).\n\t(GTFILES): Add omp-low.c.\n\t(gt-stringpool.h): Add.\n\n\t* tree-cfg.c (set_bb_for_stmt): Do not update the\n\tblock-to-labels map if we are currently expanding to RTL.\n\t(tree_node_can_be_shared): Remove unnecessary CONSTANT_CLASS_P\n\tchecks.\n\tHandle IDENTIFIER_NODE.\n\t(tree_verify_flow_info): Do not ICE when emitting error\n\tmessages about invalid labels.\n\t(dump_function_to_file): Reset CFUN before emitting the body\n\tof the function.\n\t(debug_function): New.\n\n\t* passes.c (init_optimization_passes): Schedule\n\tpass_lower_omp.\n\n\t* langhooks-def.h (lhd_omp_predetermined_sharing,\n\tlhd_omp_assignment, lhd_omp_firstprivatize_type_sizes):\n\tDeclare.\n\t(LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES): Define.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Use it.\n\t(LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE,\n\tLANG_HOOKS_OMP_PREDETERMINED_SHARING,\n\tLANG_HOOKS_OMP_DISREGARD_VALUE_EXPR,\n\tLANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE,\n\tLANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR,\n\tLANG_HOOKS_OMP_CLAUSE_COPY_CTOR,\n\tLANG_HOOKS_OMP_CLAUSE_ASSIGN_OP,\n\tLANG_HOOKS_OMP_CLAUSE_DTOR): Define.\n\t(LANG_HOOK_DECLS): Use them.\n\n\n2006-01-18  Dmitry Kurochkin <dmitry.kurochkin@gmail.com>\n\t    Richard Henderson  <rth@redhat.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n            Diego Novillo  <dnovillo@redhat.com>\n\n\t* c-parser.c (pragma_omp_clause): Define.\n\t(c_parser_declaration_or_fndef): Document OpenMP syntax.\n\t(c_parser_compound_statement): Likewise.\n\t(c_parser_statement): Likewise.\n\t(c_parser_pragma): Handle omp pragmas.\n\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n\tOMP_PARALLEL_CLAUSE_MASK, OMP_SINGLE_CLAUSE_MASK): Define.\n\t(c_parser_omp_clause_name, check_no_duplicate_clause,\n\tc_parser_omp_variable_list,\n\tc_parser_omp_var_list_parens, c_parser_omp_clause_copyin,\n\tc_parser_omp_clause_copyprivate,\n\tc_parser_omp_clause_default,\n\tc_parser_omp_clause_firstprivate, c_parser_omp_clause_if,\n\tc_parser_omp_clause_lastprivate,\n\tc_parser_omp_clause_nowait,\n\tc_parser_omp_clause_num_threads,\n\tc_parser_omp_clause_ordered, c_parser_omp_clause_private,\n\tc_parser_omp_clause_reduction,\n\tc_parser_omp_clause_schedule, c_parser_omp_clause_shared,\n\tc_parser_omp_all_clauses, c_parser_omp_structured_block,\n\tc_parser_omp_atomic, c_parser_omp_barrier,\n\tc_parser_omp_critical, c_parser_omp_flush,\n\tc_parser_omp_for_loop, c_parser_omp_for,\n\tc_parser_omp_master, c_parser_omp_ordered,\n\tc_parser_omp_sections_scope, c_parser_omp_sections,\n\tc_parser_omp_parallel, c_parser_omp_single,\n\tc_parser_omp_construct, c_parser_omp_threadprivate): New.\n\t* c-pragma.c (init_pragma): Do omp pragma registration here.\n\t* c.opt (fopenmp): New flag.\n\n\n2006-01-18  Eric Christopher  <echristo@apple.com>\n\n\t* gcc.c (GOMP_SELF_SPECS): Bracket in #ifndef/#endif.\n\t* config/darwin.h (GOMP_SELF_SPECS): Define.\n\n\ntestsuite/\n\n2006-01-18  Richard Henderson  <rth@redhat.com>\n            Aldy Hernandez  <aldyh@redhat.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n            Diego Novillo  <dnovillo@redhat.com>\n            Uros Bizjak  <uros@kss-loka.si>\n\n\t* testsuite/gcc.dg/gomp: New directory.\n\nFrom-SVN: r109902", "tree": {"sha": "b7647b4100a528e9911385ca6d0d57a23899ae2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7647b4100a528e9911385ca6d0d57a23899ae2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/953ff28998b59b0912be907d74f7afa5a8ed1e9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953ff28998b59b0912be907d74f7afa5a8ed1e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953ff28998b59b0912be907d74f7afa5a8ed1e9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953ff28998b59b0912be907d74f7afa5a8ed1e9c/comments", "author": null, "committer": null, "parents": [{"sha": "1902704eb765abf8ec8acfbf8c2a459f1e7eb65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1902704eb765abf8ec8acfbf8c2a459f1e7eb65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1902704eb765abf8ec8acfbf8c2a459f1e7eb65b"}], "stats": {"total": 33663, "additions": 33157, "deletions": 506}, "files": [{"sha": "c90bddb9746845520e739ff988098010409a6a73", "filename": "ChangeLog", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -1,3 +1,13 @@\n+2006-01-18  Richard Henderson  <rth@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* libgomp: New directory.\n+\t* Makefile.def: Add target_module libgomp.\n+\t* Makefile.in: Regenerate.\n+\t* configure.in (target_libraries): Add target-libgomp.\n+\t* configure: Regenerate.\n+\n 2006-01-05  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* Makefile.tpl (clean-stage[+id+]-[+prefix+][+module+]): Remove\n@@ -17,10 +27,10 @@\n \t(EXTRA_HOST_FLAGS): Add it.\n \t(EXTRA_GCC_FLAGS): Remove flags already specified in flags_to_pass.\n \n-        * Makefile.tpl (stage[+id+]-start, stage[+id+]-end): Do not try\n-        to use symbolic links between directories.  Avoid race conditions\n-        or make them harmless.\n-        * configure.in: Do not try to use symbolic links between directories.\n+\t* Makefile.tpl (stage[+id+]-start, stage[+id+]-end): Do not try\n+\tto use symbolic links between directories.  Avoid race conditions\n+\tor make them harmless.\n+\t* configure.in: Do not try to use symbolic links between directories.\n \n \t* Makefile.def (LEAN): Pass.\n \t* Makefile.tpl (LEAN): Define.\n@@ -33,8 +43,8 @@\n \t([+bootstrap-target+]-lean): New.\n \t* configure.in: Remove lean bootstrap support from here.\n \n-        * Makefile.in: Regenerate.\n-        * configure: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n \n 2006-01-04  Ben Elliston  <bje@au.ibm.com>\n "}, {"sha": "cdf25d2ee3689a79e1269398433a6356d5d2f9ac", "filename": "Makefile.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -137,6 +137,7 @@ target_modules = { module= boehm-gc; };\n target_modules = { module= qthreads; };\n target_modules = { module= rda; };\n target_modules = { module= libada; };\n+target_modules = { module= libgomp; lib_path=.libs; };\n \n // These are (some of) the make targets to be done in each subdirectory.\n // Not all; these are the ones which don't have special options."}, {"sha": "f8fb0472c39c29fc32421f451703a37726982d97", "filename": "Makefile.in", "status": "modified", "additions": 391, "deletions": 15, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -356,7 +356,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that prorgams built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libssp)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/.libs:\n@@ -370,6 +370,10 @@ TARGET_LIB_PATH_libmudflap = $$r/$(TARGET_SUBDIR)/libmudflap/.libs:\n TARGET_LIB_PATH_libssp = $$r/$(TARGET_SUBDIR)/libssp/.libs:\n @endif target-libssp\n \n+@if target-libgomp\n+TARGET_LIB_PATH_libgomp = $$r/$(TARGET_SUBDIR)/libgomp/.libs:\n+@endif target-libgomp\n+\n \n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n@@ -633,7 +637,8 @@ configure-target:  \\\n     maybe-configure-target-boehm-gc \\\n     maybe-configure-target-qthreads \\\n     maybe-configure-target-rda \\\n-    maybe-configure-target-libada\n+    maybe-configure-target-libada \\\n+    maybe-configure-target-libgomp\n \n # The target built for a native non-bootstrap build.\n .PHONY: all\n@@ -752,7 +757,8 @@ all-target:  \\\n     maybe-all-target-boehm-gc \\\n     maybe-all-target-qthreads \\\n     maybe-all-target-rda \\\n-    maybe-all-target-libada\n+    maybe-all-target-libada \\\n+    maybe-all-target-libgomp\n \n # Do a target for all the subdirectories.  A ``make do-X'' will do a\n # ``make X'' in all subdirectories (because, in general, there is a\n@@ -859,7 +865,8 @@ info-target:  \\\n     maybe-info-target-boehm-gc \\\n     maybe-info-target-qthreads \\\n     maybe-info-target-rda \\\n-    maybe-info-target-libada\n+    maybe-info-target-libada \\\n+    maybe-info-target-libgomp\n \n .PHONY: do-dvi\n do-dvi:\n@@ -961,7 +968,8 @@ dvi-target:  \\\n     maybe-dvi-target-boehm-gc \\\n     maybe-dvi-target-qthreads \\\n     maybe-dvi-target-rda \\\n-    maybe-dvi-target-libada\n+    maybe-dvi-target-libada \\\n+    maybe-dvi-target-libgomp\n \n .PHONY: do-html\n do-html:\n@@ -1063,7 +1071,8 @@ html-target:  \\\n     maybe-html-target-boehm-gc \\\n     maybe-html-target-qthreads \\\n     maybe-html-target-rda \\\n-    maybe-html-target-libada\n+    maybe-html-target-libada \\\n+    maybe-html-target-libgomp\n \n .PHONY: do-TAGS\n do-TAGS:\n@@ -1165,7 +1174,8 @@ TAGS-target:  \\\n     maybe-TAGS-target-boehm-gc \\\n     maybe-TAGS-target-qthreads \\\n     maybe-TAGS-target-rda \\\n-    maybe-TAGS-target-libada\n+    maybe-TAGS-target-libada \\\n+    maybe-TAGS-target-libgomp\n \n .PHONY: do-install-info\n do-install-info:\n@@ -1267,7 +1277,8 @@ install-info-target:  \\\n     maybe-install-info-target-boehm-gc \\\n     maybe-install-info-target-qthreads \\\n     maybe-install-info-target-rda \\\n-    maybe-install-info-target-libada\n+    maybe-install-info-target-libada \\\n+    maybe-install-info-target-libgomp\n \n .PHONY: do-installcheck\n do-installcheck:\n@@ -1369,7 +1380,8 @@ installcheck-target:  \\\n     maybe-installcheck-target-boehm-gc \\\n     maybe-installcheck-target-qthreads \\\n     maybe-installcheck-target-rda \\\n-    maybe-installcheck-target-libada\n+    maybe-installcheck-target-libada \\\n+    maybe-installcheck-target-libgomp\n \n .PHONY: do-mostlyclean\n do-mostlyclean:\n@@ -1471,7 +1483,8 @@ mostlyclean-target:  \\\n     maybe-mostlyclean-target-boehm-gc \\\n     maybe-mostlyclean-target-qthreads \\\n     maybe-mostlyclean-target-rda \\\n-    maybe-mostlyclean-target-libada\n+    maybe-mostlyclean-target-libada \\\n+    maybe-mostlyclean-target-libgomp\n \n .PHONY: do-clean\n do-clean:\n@@ -1573,7 +1586,8 @@ clean-target:  \\\n     maybe-clean-target-boehm-gc \\\n     maybe-clean-target-qthreads \\\n     maybe-clean-target-rda \\\n-    maybe-clean-target-libada\n+    maybe-clean-target-libada \\\n+    maybe-clean-target-libgomp\n \n .PHONY: do-distclean\n do-distclean:\n@@ -1675,7 +1689,8 @@ distclean-target:  \\\n     maybe-distclean-target-boehm-gc \\\n     maybe-distclean-target-qthreads \\\n     maybe-distclean-target-rda \\\n-    maybe-distclean-target-libada\n+    maybe-distclean-target-libada \\\n+    maybe-distclean-target-libgomp\n \n .PHONY: do-maintainer-clean\n do-maintainer-clean:\n@@ -1777,7 +1792,8 @@ maintainer-clean-target:  \\\n     maybe-maintainer-clean-target-boehm-gc \\\n     maybe-maintainer-clean-target-qthreads \\\n     maybe-maintainer-clean-target-rda \\\n-    maybe-maintainer-clean-target-libada\n+    maybe-maintainer-clean-target-libada \\\n+    maybe-maintainer-clean-target-libgomp\n \n \n # Here are the targets which correspond to the do-X targets.\n@@ -1932,7 +1948,8 @@ check-target:  \\\n     maybe-check-target-boehm-gc \\\n     maybe-check-target-qthreads \\\n     maybe-check-target-rda \\\n-    maybe-check-target-libada\n+    maybe-check-target-libada \\\n+    maybe-check-target-libgomp\n \n do-check:\n \t@: $(MAKE); $(unstage)\n@@ -2131,7 +2148,8 @@ install-target:  \\\n     maybe-install-target-boehm-gc \\\n     maybe-install-target-qthreads \\\n     maybe-install-target-rda \\\n-    maybe-install-target-libada\n+    maybe-install-target-libada \\\n+    maybe-install-target-libgomp\n \n uninstall:\n \t@echo \"the uninstall target is not supported in this tree\"\n@@ -35545,6 +35563,362 @@ maintainer-clean-target-libada:\n \n \n \n+\n+\n+.PHONY: configure-target-libgomp maybe-configure-target-libgomp\n+maybe-configure-target-libgomp:\n+@if target-libgomp\n+maybe-configure-target-libgomp: configure-target-libgomp\n+configure-target-libgomp:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libgomp...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libgomp ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libgomp/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libgomp/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libgomp/multilib.tmp $(TARGET_SUBDIR)/libgomp/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libgomp/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libgomp/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libgomp/multilib.tmp $(TARGET_SUBDIR)/libgomp/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libgomp/multilib.tmp $(TARGET_SUBDIR)/libgomp/multilib.out; \\\n+\tfi\n+\t@test ! -f $(TARGET_SUBDIR)/libgomp/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libgomp ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo Configuring in $(TARGET_SUBDIR)/libgomp; \\\n+\tcd \"$(TARGET_SUBDIR)/libgomp\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libgomp/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libgomp\"; \\\n+\tlibsrcdir=\"$$s/libgomp\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) $${srcdiroption}  \\\n+\t  || exit 1\n+@endif target-libgomp\n+\n+\n+\n+\n+\n+.PHONY: all-target-libgomp maybe-all-target-libgomp\n+maybe-all-target-libgomp:\n+@if target-libgomp\n+TARGET-target-libgomp=all\n+maybe-all-target-libgomp: all-target-libgomp\n+all-target-libgomp: configure-target-libgomp\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  $(TARGET-target-libgomp))\n+@endif target-libgomp\n+\n+\n+\n+\n+\n+.PHONY: check-target-libgomp maybe-check-target-libgomp\n+maybe-check-target-libgomp:\n+@if target-libgomp\n+maybe-check-target-libgomp: check-target-libgomp\n+\n+check-target-libgomp:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-libgomp\n+\n+.PHONY: install-target-libgomp maybe-install-target-libgomp\n+maybe-install-target-libgomp:\n+@if target-libgomp\n+maybe-install-target-libgomp: install-target-libgomp\n+\n+install-target-libgomp: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libgomp\n+\n+# Other targets (info, dvi, etc.)\n+\n+.PHONY: maybe-info-target-libgomp info-target-libgomp\n+maybe-info-target-libgomp:\n+@if target-libgomp\n+maybe-info-target-libgomp: info-target-libgomp\n+\n+info-target-libgomp: \\\n+    configure-target-libgomp \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-dvi-target-libgomp dvi-target-libgomp\n+maybe-dvi-target-libgomp:\n+@if target-libgomp\n+maybe-dvi-target-libgomp: dvi-target-libgomp\n+\n+dvi-target-libgomp: \\\n+    configure-target-libgomp \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-html-target-libgomp html-target-libgomp\n+maybe-html-target-libgomp:\n+@if target-libgomp\n+maybe-html-target-libgomp: html-target-libgomp\n+\n+html-target-libgomp: \\\n+    configure-target-libgomp \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-TAGS-target-libgomp TAGS-target-libgomp\n+maybe-TAGS-target-libgomp:\n+@if target-libgomp\n+maybe-TAGS-target-libgomp: TAGS-target-libgomp\n+\n+TAGS-target-libgomp: \\\n+    configure-target-libgomp \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-install-info-target-libgomp install-info-target-libgomp\n+maybe-install-info-target-libgomp:\n+@if target-libgomp\n+maybe-install-info-target-libgomp: install-info-target-libgomp\n+\n+install-info-target-libgomp: \\\n+    configure-target-libgomp \\\n+    info-target-libgomp \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-installcheck-target-libgomp installcheck-target-libgomp\n+maybe-installcheck-target-libgomp:\n+@if target-libgomp\n+maybe-installcheck-target-libgomp: installcheck-target-libgomp\n+\n+installcheck-target-libgomp: \\\n+    configure-target-libgomp \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-mostlyclean-target-libgomp mostlyclean-target-libgomp\n+maybe-mostlyclean-target-libgomp:\n+@if target-libgomp\n+maybe-mostlyclean-target-libgomp: mostlyclean-target-libgomp\n+\n+mostlyclean-target-libgomp: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-clean-target-libgomp clean-target-libgomp\n+maybe-clean-target-libgomp:\n+@if target-libgomp\n+maybe-clean-target-libgomp: clean-target-libgomp\n+\n+clean-target-libgomp: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-distclean-target-libgomp distclean-target-libgomp\n+maybe-distclean-target-libgomp:\n+@if target-libgomp\n+maybe-distclean-target-libgomp: distclean-target-libgomp\n+\n+distclean-target-libgomp: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+.PHONY: maybe-maintainer-clean-target-libgomp maintainer-clean-target-libgomp\n+maybe-maintainer-clean-target-libgomp:\n+@if target-libgomp\n+maybe-maintainer-clean-target-libgomp: maintainer-clean-target-libgomp\n+\n+maintainer-clean-target-libgomp: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libgomp/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libgomp\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgomp && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libgomp\n+\n+\n+\n # ----------\n # GCC module\n # ----------\n@@ -37054,6 +37428,8 @@ configure-target-rda: maybe-all-gcc\n \n configure-target-libada: maybe-all-gcc\n \n+configure-target-libgomp: maybe-all-gcc\n+\n \n \n configure-target-boehm-gc: maybe-all-target-newlib maybe-all-target-libgloss"}, {"sha": "663a7a5357cb70b257fed54d05b4acf10697de12", "filename": "configure", "status": "modified", "additions": 151, "deletions": 107, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -909,7 +909,8 @@ target_libraries=\"target-libiberty \\\n \t\ttarget-libgfortran \\\n \t\t${libgcj} \\\n \t\ttarget-libobjc \\\n-\t\ttarget-libada\"\n+\t\ttarget-libada \\\n+\t\ttarget-libgomp\"\n \n # these tools are built using the target libraries, and are intended to\n # run only in the target environment\n@@ -1146,6 +1147,30 @@ no)\n     esac\n esac\n \n+# Allow --disable-libgomp to exclude target-libgomp\n+case $enable_libgomp in\n+yes)\n+    ;;\n+no)\n+    noconfigdirs=\"$noconfigdirs target-libgomp\"\n+    ;;\n+\"\")\n+    # Enable libgomp by default on hosted POSIX systems.\n+    case \"${target}\" in\n+    *-*-linux*-gnu | *-*-gnu* | *-*-k*bsd*-gnu)\n+\t;;\n+    *-*-netbsd* | *-*-freebsd* | *-*-openbsd*)\n+\t;;\n+    *-*-solaris2* | *-*-sysv4* | *-*-irix* | *-*-osf* | *-*-hpux*)\n+\t;;\n+    *-*-darwin*)\n+\t;;\n+    *)\n+\tnoconfigdirs=\"$noconfigdirs target-libgomp\"\n+\t;;\n+    esac\n+esac\n+\n \n case \"${target}\" in\n   *-*-chorusos)\n@@ -1827,7 +1852,7 @@ else\n   # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1831: checking for $ac_word\" >&5\n+echo \"configure:1856: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1857,7 +1882,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1861: checking for $ac_word\" >&5\n+echo \"configure:1886: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1908,7 +1933,7 @@ fi\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1912: checking for $ac_word\" >&5\n+echo \"configure:1937: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1940,7 +1965,7 @@ fi\n fi\n \n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:1944: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n+echo \"configure:1969: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -1951,12 +1976,12 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext << EOF\n \n-#line 1955 \"configure\"\n+#line 1980 \"configure\"\n #include \"confdefs.h\"\n \n main(){return(0);}\n EOF\n-if { (eval echo configure:1960: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1985: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -1982,12 +2007,12 @@ if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:1986: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo \"configure:2011: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1991: checking whether we are using GNU C\" >&5\n+echo \"configure:2016: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1996,7 +2021,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2000: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2025: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -2015,7 +2040,7 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:2019: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:2044: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2082,7 +2107,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}gnatbind\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2086: checking for $ac_word\" >&5\n+echo \"configure:2111: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2114,7 +2139,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"gnatbind\", so it can be a program name with args.\n set dummy gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2118: checking for $ac_word\" >&5\n+echo \"configure:2143: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2147,7 +2172,7 @@ fi\n fi\n \n echo $ac_n \"checking whether compiler driver understands Ada\"\"... $ac_c\" 1>&6\n-echo \"configure:2151: checking whether compiler driver understands Ada\" >&5\n+echo \"configure:2176: checking whether compiler driver understands Ada\" >&5\n if eval \"test \\\"`echo '$''{'acx_cv_cc_gcc_supports_ada'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2179,7 +2204,7 @@ else\n fi\n \n echo $ac_n \"checking how to compare bootstrapped objects\"\"... $ac_c\" 1>&6\n-echo \"configure:2183: checking how to compare bootstrapped objects\" >&5\n+echo \"configure:2208: checking how to compare bootstrapped objects\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_prog_cmp_skip'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2277,9 +2302,9 @@ saved_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"$CFLAGS $gmpinc\"\n # Check GMP actually works\n echo $ac_n \"checking for correct version of gmp.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2281: checking for correct version of gmp.h\" >&5\n+echo \"configure:2306: checking for correct version of gmp.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 2283 \"configure\"\n+#line 2308 \"configure\"\n #include \"confdefs.h\"\n #include \"gmp.h\"\n int main() {\n@@ -2290,7 +2315,7 @@ choke me\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2294: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2319: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"yes\" 1>&6\n else\n@@ -2303,20 +2328,20 @@ rm -f conftest*\n \n if test x\"$have_gmp\" = xyes; then\n   echo $ac_n \"checking for MPFR\"\"... $ac_c\" 1>&6\n-echo \"configure:2307: checking for MPFR\" >&5\n+echo \"configure:2332: checking for MPFR\" >&5\n \n   saved_LIBS=\"$LIBS\"\n   LIBS=\"$LIBS $gmplibs\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2312 \"configure\"\n+#line 2337 \"configure\"\n #include \"confdefs.h\"\n #include <gmp.h>\n #include <mpfr.h>\n int main() {\n mpfr_t n; mpfr_init(n);\n ; return 0; }\n EOF\n-if { (eval echo configure:2320: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2345: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"yes\" 1>&6\n else\n@@ -3312,7 +3337,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3316: checking for $ac_word\" >&5\n+echo \"configure:3341: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_YACC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3352,7 +3377,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3356: checking for $ac_word\" >&5\n+echo \"configure:3381: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_BISON'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3391,7 +3416,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3395: checking for $ac_word\" >&5\n+echo \"configure:3420: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_M4'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3430,7 +3455,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3434: checking for $ac_word\" >&5\n+echo \"configure:3459: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LEX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3470,7 +3495,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3474: checking for $ac_word\" >&5\n+echo \"configure:3499: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_FLEX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3509,7 +3534,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3513: checking for $ac_word\" >&5\n+echo \"configure:3538: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_MAKEINFO'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3562,7 +3587,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3566: checking for $ac_word\" >&5\n+echo \"configure:3591: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_EXPECT'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3603,7 +3628,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3607: checking for $ac_word\" >&5\n+echo \"configure:3632: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RUNTEST'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3651,7 +3676,7 @@ test -n \"$target_alias\" && ncn_target_tool_prefix=$target_alias-\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3655: checking for $ac_word\" >&5\n+echo \"configure:3680: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3682,7 +3707,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3686: checking for $ac_word\" >&5\n+echo \"configure:3711: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3726,7 +3751,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3730: checking for $ac_word\" >&5\n+echo \"configure:3755: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3757,7 +3782,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3761: checking for $ac_word\" >&5\n+echo \"configure:3786: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3801,7 +3826,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3805: checking for $ac_word\" >&5\n+echo \"configure:3830: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3832,7 +3857,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3836: checking for $ac_word\" >&5\n+echo \"configure:3861: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3876,7 +3901,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3880: checking for $ac_word\" >&5\n+echo \"configure:3905: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3907,7 +3932,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3911: checking for $ac_word\" >&5\n+echo \"configure:3936: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3951,7 +3976,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3955: checking for $ac_word\" >&5\n+echo \"configure:3980: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LIPO'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3982,7 +4007,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3986: checking for $ac_word\" >&5\n+echo \"configure:4011: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LIPO'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4026,7 +4051,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4030: checking for $ac_word\" >&5\n+echo \"configure:4055: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4057,7 +4082,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4061: checking for $ac_word\" >&5\n+echo \"configure:4086: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4101,7 +4126,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4105: checking for $ac_word\" >&5\n+echo \"configure:4130: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4132,7 +4157,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4136: checking for $ac_word\" >&5\n+echo \"configure:4161: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4171,7 +4196,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4175: checking for $ac_word\" >&5\n+echo \"configure:4200: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4202,7 +4227,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4206: checking for $ac_word\" >&5\n+echo \"configure:4231: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4241,7 +4266,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4245: checking for $ac_word\" >&5\n+echo \"configure:4270: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4272,7 +4297,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4276: checking for $ac_word\" >&5\n+echo \"configure:4301: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4316,7 +4341,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4320: checking for $ac_word\" >&5\n+echo \"configure:4345: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4347,7 +4372,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4351: checking for $ac_word\" >&5\n+echo \"configure:4376: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4391,7 +4416,7 @@ fi\n     # Extract the first word of \"${ncn_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4395: checking for $ac_word\" >&5\n+echo \"configure:4420: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4422,7 +4447,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4426: checking for $ac_word\" >&5\n+echo \"configure:4451: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4473,7 +4498,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4477: checking for $ac_word\" >&5\n+echo \"configure:4502: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4504,7 +4529,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4508: checking for $ac_word\" >&5\n+echo \"configure:4533: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4548,7 +4573,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4552: checking for $ac_word\" >&5\n+echo \"configure:4577: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4579,7 +4604,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4583: checking for $ac_word\" >&5\n+echo \"configure:4608: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4623,7 +4648,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4627: checking for $ac_word\" >&5\n+echo \"configure:4652: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4654,7 +4679,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4658: checking for $ac_word\" >&5\n+echo \"configure:4683: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4698,7 +4723,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4702: checking for $ac_word\" >&5\n+echo \"configure:4727: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4729,7 +4754,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4733: checking for $ac_word\" >&5\n+echo \"configure:4758: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4773,7 +4798,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4777: checking for $ac_word\" >&5\n+echo \"configure:4802: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4804,7 +4829,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4808: checking for $ac_word\" >&5\n+echo \"configure:4833: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4848,7 +4873,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4852: checking for $ac_word\" >&5\n+echo \"configure:4877: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GCC_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4879,7 +4904,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4883: checking for $ac_word\" >&5\n+echo \"configure:4908: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GCC_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4918,7 +4943,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4922: checking for $ac_word\" >&5\n+echo \"configure:4947: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GCJ_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4949,7 +4974,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4953: checking for $ac_word\" >&5\n+echo \"configure:4978: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GCJ_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4993,7 +5018,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4997: checking for $ac_word\" >&5\n+echo \"configure:5022: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GFORTRAN_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5024,7 +5049,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5028: checking for $ac_word\" >&5\n+echo \"configure:5053: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GFORTRAN_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5068,7 +5093,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5072: checking for $ac_word\" >&5\n+echo \"configure:5097: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5099,7 +5124,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5103: checking for $ac_word\" >&5\n+echo \"configure:5128: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5143,7 +5168,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5147: checking for $ac_word\" >&5\n+echo \"configure:5172: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LIPO_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5174,7 +5199,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5178: checking for $ac_word\" >&5\n+echo \"configure:5203: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LIPO_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5218,7 +5243,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5222: checking for $ac_word\" >&5\n+echo \"configure:5247: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5249,7 +5274,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5253: checking for $ac_word\" >&5\n+echo \"configure:5278: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5293,7 +5318,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5297: checking for $ac_word\" >&5\n+echo \"configure:5322: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJDUMP_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5324,7 +5349,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5328: checking for $ac_word\" >&5\n+echo \"configure:5353: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJDUMP_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5368,7 +5393,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5372: checking for $ac_word\" >&5\n+echo \"configure:5397: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5399,7 +5424,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5403: checking for $ac_word\" >&5\n+echo \"configure:5428: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5438,7 +5463,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5442: checking for $ac_word\" >&5\n+echo \"configure:5467: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5469,7 +5494,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5473: checking for $ac_word\" >&5\n+echo \"configure:5498: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5513,7 +5538,7 @@ fi\n     # Extract the first word of \"${ncn_target_tool_prefix}${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5517: checking for $ac_word\" >&5\n+echo \"configure:5542: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5544,7 +5569,7 @@ fi\n     # Extract the first word of \"${ncn_progname}\", so it can be a program name with args.\n set dummy ${ncn_progname}; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5548: checking for $ac_word\" >&5\n+echo \"configure:5573: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5587,7 +5612,7 @@ fi\n RAW_CXX_FOR_TARGET=\"$CXX_FOR_TARGET\"\n \n echo $ac_n \"checking where to find the target ar\"\"... $ac_c\" 1>&6\n-echo \"configure:5591: checking where to find the target ar\" >&5\n+echo \"configure:5616: checking where to find the target ar\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5612,7 +5637,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target as\"\"... $ac_c\" 1>&6\n-echo \"configure:5616: checking where to find the target as\" >&5\n+echo \"configure:5641: checking where to find the target as\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5637,7 +5662,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target cc\"\"... $ac_c\" 1>&6\n-echo \"configure:5641: checking where to find the target cc\" >&5\n+echo \"configure:5666: checking where to find the target cc\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5662,7 +5687,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target c++\"\"... $ac_c\" 1>&6\n-echo \"configure:5666: checking where to find the target c++\" >&5\n+echo \"configure:5691: checking where to find the target c++\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5690,7 +5715,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target c++ for libstdc++\"\"... $ac_c\" 1>&6\n-echo \"configure:5694: checking where to find the target c++ for libstdc++\" >&5\n+echo \"configure:5719: checking where to find the target c++ for libstdc++\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5718,7 +5743,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target dlltool\"\"... $ac_c\" 1>&6\n-echo \"configure:5722: checking where to find the target dlltool\" >&5\n+echo \"configure:5747: checking where to find the target dlltool\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5743,7 +5768,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target gcc\"\"... $ac_c\" 1>&6\n-echo \"configure:5747: checking where to find the target gcc\" >&5\n+echo \"configure:5772: checking where to find the target gcc\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5768,7 +5793,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target gcj\"\"... $ac_c\" 1>&6\n-echo \"configure:5772: checking where to find the target gcj\" >&5\n+echo \"configure:5797: checking where to find the target gcj\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5796,7 +5821,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target gfortran\"\"... $ac_c\" 1>&6\n-echo \"configure:5800: checking where to find the target gfortran\" >&5\n+echo \"configure:5825: checking where to find the target gfortran\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5824,7 +5849,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target ld\"\"... $ac_c\" 1>&6\n-echo \"configure:5828: checking where to find the target ld\" >&5\n+echo \"configure:5853: checking where to find the target ld\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5849,7 +5874,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target lipo\"\"... $ac_c\" 1>&6\n-echo \"configure:5853: checking where to find the target lipo\" >&5\n+echo \"configure:5878: checking where to find the target lipo\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5864,7 +5889,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target nm\"\"... $ac_c\" 1>&6\n-echo \"configure:5868: checking where to find the target nm\" >&5\n+echo \"configure:5893: checking where to find the target nm\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5889,7 +5914,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target objdump\"\"... $ac_c\" 1>&6\n-echo \"configure:5893: checking where to find the target objdump\" >&5\n+echo \"configure:5918: checking where to find the target objdump\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5914,7 +5939,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target ranlib\"\"... $ac_c\" 1>&6\n-echo \"configure:5918: checking where to find the target ranlib\" >&5\n+echo \"configure:5943: checking where to find the target ranlib\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5939,7 +5964,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target strip\"\"... $ac_c\" 1>&6\n-echo \"configure:5943: checking where to find the target strip\" >&5\n+echo \"configure:5968: checking where to find the target strip\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -5964,7 +5989,7 @@ else\n   fi\n fi\n echo $ac_n \"checking where to find the target windres\"\"... $ac_c\" 1>&6\n-echo \"configure:5968: checking where to find the target windres\" >&5\n+echo \"configure:5993: checking where to find the target windres\" >&5\n if test \"x${build}\" != \"x${host}\" ; then\n   # Canadian cross, just use what we found\n   echo \"$ac_t\"\"pre-installed\" 1>&6\n@@ -6017,7 +6042,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:6021: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:6046: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -6142,15 +6167,34 @@ trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15\n # Transform confdefs.h into DEFS.\n # Protect against shell expansion while executing Makefile rules.\n # Protect against Makefile macro expansion.\n-cat > conftest.defs <<\\EOF\n-s%#define \\([A-Za-z_][A-Za-z0-9_]*\\) *\\(.*\\)%-D\\1=\\2%g\n-s%[ \t`~#$^&*(){}\\\\|;'\"<>?]%\\\\&%g\n-s%\\[%\\\\&%g\n-s%\\]%\\\\&%g\n-s%\\$%$$%g\n-EOF\n-DEFS=`sed -f conftest.defs confdefs.h | tr '\\012' ' '`\n-rm -f conftest.defs\n+#\n+# If the first sed substitution is executed (which looks for macros that\n+# take arguments), then we branch to the quote section.  Otherwise,\n+# look for a macro that doesn't take arguments.\n+cat >confdef2opt.sed <<\\_ACEOF\n+t clear\n+: clear\n+s,^[ \t]*#[ \t]*define[ \t][ \t]*\\([^ \t(][^ \t(]*([^)]*)\\)[ \t]*\\(.*\\),-D\\1=\\2,g\n+t quote\n+s,^[ \t]*#[ \t]*define[ \t][ \t]*\\([^ \t][^ \t]*\\)[ \t]*\\(.*\\),-D\\1=\\2,g\n+t quote\n+d\n+: quote\n+s,[ \t`~#$^&*(){}\\\\|;'\"<>?],\\\\&,g\n+s,\\[,\\\\&,g\n+s,\\],\\\\&,g\n+s,\\$,$$,g\n+p\n+_ACEOF\n+# We use echo to avoid assuming a particular line-breaking character.\n+# The extra dot is to prevent the shell from consuming trailing\n+# line-breaks from the sub-command output.  A line-break within\n+# single-quotes doesn't work because, if this script is created in a\n+# platform that uses two characters for line-breaks (e.g., DOS), tr\n+# would break.\n+ac_LF_and_DOT=`echo; echo .`\n+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr \"$ac_LF_and_DOT\" ' .'`\n+rm -f confdef2opt.sed\n \n \n # Without the \"./\", some shells look in PATH for config.status."}, {"sha": "401d2dca4bf4f2a333148683ce6dc8ed88c71cfd", "filename": "configure.in", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -151,7 +151,8 @@ target_libraries=\"target-libiberty \\\n \t\ttarget-libgfortran \\\n \t\t${libgcj} \\\n \t\ttarget-libobjc \\\n-\t\ttarget-libada\"\n+\t\ttarget-libada \\\n+\t\ttarget-libgomp\"\n \n # these tools are built using the target libraries, and are intended to\n # run only in the target environment\n@@ -341,7 +342,7 @@ no)\n     ;;\n \"\")\n     case \"${target}\" in\n-    *-*-linux*-gnu | *-*-gnu* | *-*-k*bsd*-gnu)\n+    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu)\n         # Enable libmudflap by default in GNU and friends.\n \t;;\n     *-*-freebsd*)\n@@ -354,6 +355,30 @@ no)\n     esac\n esac\n \n+# Allow --disable-libgomp to exclude target-libgomp\n+case $enable_libgomp in\n+yes)\n+    ;;\n+no)\n+    noconfigdirs=\"$noconfigdirs target-libgomp\"\n+    ;;\n+\"\")\n+    # Enable libgomp by default on hosted POSIX systems.\n+    case \"${target}\" in\n+    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu)\n+\t;;\n+    *-*-netbsd* | *-*-freebsd* | *-*-openbsd*)\n+\t;;\n+    *-*-solaris2* | *-*-sysv4* | *-*-irix* | *-*-osf* | *-*-hpux*)\n+\t;;\n+    *-*-darwin*)\n+\t;;\n+    *)\n+\tnoconfigdirs=\"$noconfigdirs target-libgomp\"\n+\t;;\n+    esac\n+esac\n+\n \n case \"${target}\" in\n   *-*-chorusos)"}, {"sha": "8b310e1aa4d418d54cc9dcecda97d827eee38a2b", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -1,3 +1,8 @@\n+2006-01-18  Richard Henderson  <rth@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* gcc_update (files_and_dependencies): Add libgomp files.\n+\n 2005-12-06  Ben Elliston  <bje@au.ibm.com>\n \n \t* newcvsroot: Remove."}, {"sha": "0ec373945a007bd7f89e6e477ec6a5e7727ffaad", "filename": "contrib/gcc_update", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -112,6 +112,10 @@ libjava/libltdl/config-h.in: libjava/libltdl/configure.ac libjava/libltdl/acloca\n libcpp/aclocal.m4: libcpp/configure.ac\n libcpp/Makefile.in: libcpp/configure.ac libcpp/aclocal.m4\n libcpp/configure: libcpp/configure.ac libcpp/aclocal.m4\n+libgomp/aclocal.m4: libgomp/configure.ac libgomp/acinclude.m4\n+libgomp/Makefile.in: libgomp/Makefile.am libgomp/aclocal.m4\n+libgomp/configure: libgomp/configure.ac libgomp/aclocal.m4\n+libgomp/config.h.in: libgomp/configure.ac libgomp/aclocal.m4\n # Top level\n Makefile.in: Makefile.tpl Makefile.def\n configure: configure.in config/acx.m4"}, {"sha": "b57d517e78922bc512d6f89edc9b49eb077cd3e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -1,3 +1,353 @@\n+2006-01-18  Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* omp-low.c: New file.\n+\t* c-omp.c: New file.\n+\n+2006-01-18  Richard Henderson  <rth@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* doc/invoke.texi: Document -fopenmp.\n+\t* tree-dump.h (debug_function): Declare.\n+\t* hooks.c (hook_bool_tree_bool_false): New function.\n+\t(hook_tree_tree_null): Remove.\n+\t(hook_tree_tree_tree_null): New.\n+\t* hooks.h: Update to match.\n+\t* tree-pretty-print.c (debug_tree_chain): New.\n+\t(print_generic_expr): Handle TDF_CHAIN.\n+\t(dump_generic_node): Handle BLOCK.\n+\tDo not abort with incomplete SWITCH_EXPRs.\n+\tDo not dump body of an OpenMP directive if TDF_SLIM is given.\n+\t<case OMP_PARALLEL, OMP_FOR, OMP_SECTIONS>: Don't\n+\tprint space after directive name.\n+\t<OMP_FOR>: Handle printing OMP_FOR_PRE_BODY.\n+\tHandle OMP_MASTER and OMP_ORDERED.\n+\tHandle printing of OMP_BODY just in one place, goto\n+\tdump_omp_body in the rest of OMP_* nodes that have\n+\tOMP_BODY.\n+\tDon't handle clause nodes here.  Update omp statements to\n+\tuse dump_omp_clauses.\n+\tHandle OMP_SINGLE, OMP_SECTIONS, OMP_SECTION,\n+\tOMP_CLAUSE_ORDERED, OMP_CLAUSE_SCHEDULE, OMP_ATOMIC,\n+\tOMP_CRITICAL, OMP_CLAUSE_NOWAIT, GOMP_CLAUSE_IF,\n+\tGOMP_CLAUSE_NUM_THREADS, GOMP_FOR, GOMP_CLAUSE_SHARED,\n+\tGOMP_CLAUSE_FIRSTPRIVATE, GOMP_CLAUSE_LASTPRIVATE,\n+\tGOMP_CLAUSE_COPYIN and GOMP_CLAUSE_COPYPRIVATE.\n+\tAdjust output for GOMP_PARALLEL.\n+\t(dump_omp_clauses): New.\n+\t(print_declaration): Dump DECL_VALUE_EXPR.\n+\t(op_symbol_1): Split out of op_symbol.\n+\t(dumping_stmts): Remove.  Update all users.\n+\t* cgraph.c (cgraph_analyze_queue): New.\n+\t(cgraph_add_new_function): New.\n+\t* cgraph.h (cgraph_analyze_queue): Declare.\n+\t(cgraph_add_new_function): Declare.\n+\t(cgraph_lower_function): Remove.\n+\t* tree.c (walk_tree): Walk OMP_CLAUSE_CHAIN of OMP_CLAUSE_*\n+\tnodes.  Use switch for all nodes, handle most of IS_EXPR_CODE_CLASS\n+\tand TYPE_P nodes in its default clause.\n+\t(empty_body_p): New.\n+\t(tree_range_check_failed): New.\n+\t(build5_stat): New.\n+\t* tree.h (OMP_CLAUSE_REDUCTION_INIT,\n+\tOMP_CLAUSE_REDUCTION_MERGE,\n+\tOMP_CLAUSE_REDUCTION_PLACEHOLDER,\n+\tOMP_CLAUSE_PRIVATE_DEBUG,\n+\tOMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE, OMP_FOR_PRE_BODY,\n+\tOMP_MASTER_BODY, OMP_ORDERED_BODY OMP_BODY,\n+\tOMP_CLAUSES, OMP_CLAUSE_DECL, OMP_CLAUSE_DEFAULT_KIND,\n+\tOMP_CLAUSE_CHAIN, OMP_CLAUSE_OUTER_DECL,\n+\tOMP_CLAUSE_INNER_DECL, OMP_CLAUSE_NUM_THREADS_EXPR,\n+\tOMP_CLAUSE_IF_EXPR, OMP_CLAUSE_SCHEDULE_CHUNK_EXPR,\n+\tOMP_CLAUSE_SCHEDULE_CHUNK_SIZE. OMP_PARALLEL_VAR_INIT,\n+\tOMP_PARALLEL_VAR_REDUC, OMP_FOR_VAR_INIT,\n+\tOMP_FOR_VAR_LAST, OMP_FOR_VAR_REDUC,\n+\tOMP_SECTIONS_VAR_INIT, OMP_SECTIONS_VAR_LAST,\n+\tOMP_SECTIONS_VAR_REDUC, OMP_CLAUSE_REDUCTION_CODE\n+\tOMP_SINGLE_CLAUSES, OMP_SINGLE_BODY,\n+\tOMP_CLAUSE_SCHEDULE_CHUNK_SIZE, OMP_SECTION_BODY,\n+\tOMP_CRITICAL_NAME, OMP_CRITICAL_BODY): New.\n+\t(TREE_RANGE_CHECK): New.\n+\t(empty_body_p): Declare.\n+\t(enum omp_clause_default_kind): New.\n+\t(build_string_literal): Declare.\n+\t(enum omp_clause_schedule_kind, OMP_CLAUSE_SCHEDULE_KIND): New.\n+\t(build5_stat, build5): Declare.\n+\t* tree-pass.h (TDF_CHAIN): Define.\n+\t* tree-pass.h (PROP_gimple_lomp): Define.\n+\t(pass_lower_omp): Declare.\n+\t* diagnostic.h (debug_tree_chain): Declare.\n+\t* builtins.c (get_builtin_sync_mode): Use 0 as last argument to\n+\tmode_for_size.\n+\t(expand_builtin): Handle sync BUILT_IN_*_16 builtins.\n+\t* builtins.c (build_string_literal): Make extern.\n+\t* gcc.c (include_spec_function): New.\n+\t(static_spec_functions): Add it.\n+\t(main): Move load of libgomp.spec ...\n+\t(LINK_COMMAND_SPEC): ... here.\n+\t(link_gomp_spec): New.\n+\t(static_specs): Include it.\n+\t(LINK_COMMAND_SPEC): Add link_gomp.\n+\t(GOMP_SELF_SPECS): New.\n+\t(driver_self_specs): Include it.\n+\t(switch_matches): Don't mark inline.\n+\t(main): Load libgomp.spec.\n+\t* tree-gimple.c (is_gimple_stmt): True for OMP_MASTER,\n+\tOMP_ORDERED, OMP_CRITICAL, OMP_SECTIONS, OMP_SECTION,\n+\tand OMP_SINGLE, OMP_FOR and OMP_PARALLEL.\n+\t* tree-gimple.h (enum omp_parallel): Declare.\n+\t(determine_parallel_type): Declare.\n+\t(omp_firstprivatize_variable): Declare.\n+\t(omp_reduction_init): Declare.\n+\t(diagnose_omp_structured_block_errors): Declare.\n+\t(struct walk_stmt_info): Add want_return_expr.\n+\t(struct walk_stmt_info): Add want_bind_expr, want_locations.\n+\t(find_omp_clause): Declare.\n+\t(insert_field_into_struct): Declare.\n+\t(struct walk_stmt_info): Move from tree-nested.c\n+\t(walk_stmts): Declare.\n+\t* c-cppbuiltin.c (c_cpp_builtins): If -fopenmp, #define _OPENMP\n+\tto 200505.\n+\t* cgraphunit.c (cgraph_lower_function): Make static.\n+\t(cgraph_finalize_pending_functions): New.\n+\t(cgraph_finalize_function): Call it.\n+\t(cgraph_finalize_compilation_unit): Likewise.\n+\t* builtin-types.def (BT_I16, BT_FN_I16_VPTR_I16,\n+\tBT_FN_BOOL_VPTR_I16_I16, BT_FN_I16_VPTR_I16_I16): Add.\n+\t(BT_FN_UINT_UINT): New.\n+\t(DEF_FUNCTION_TYPE_6, DEF_FUNCTION_TYPE_7,\n+\tDEF_FUNCTION_TYPE_VAR_4): Document.\n+\t(BT_PTR_LONG, BT_PTR_PTR, BT_FN_BOOL, BT_FN_INT,\n+\tBT_FN_VOID_PTRPTR, BT_PTR_FN_VOID_PTR,\n+\tBT_FN_BOOL_LONGPTR_LONGPTR, BT_FN_VOID_OMPFN_PTR_UINT,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_UINT,\n+\tBT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\tBT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n+\tBT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG): New.\n+\t* builtins.def: Update DEF_BUILTIN comment to include COND argument.\n+\tMove all DEF_SYNC_BUILTIN () and DEF_GOMP_BUILTIN () builtins\n+\tinto separate files.\n+\t(DEF_GOMP_BUILTIN): New.\n+\t(BUILT_IN_OMP_GET_THREAD_NUM, BUILT_IN_GOMP_BARRIER,\n+\tBUILT_IN_GOMP_CRITICAL_START, BUILT_IN_GOMP_CRITICAL_END,\n+\tBUILT_IN_GOMP_CRITICAL_NAME_START, BUILT_IN_GOMP_CRITICAL_NAME_END,\n+\tBUILT_IN_GOMP_LOOP_STATIC_START, BUILT_IN_GOMP_LOOP_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_GUIDED_START, BUILT_IN_GOMP_LOOP_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_STATIC_START,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_GUIDED_START,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_STATIC_NEXT, BUILT_IN_GOMP_LOOP_DYNAMIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_GUIDED_NEXT, BUILT_IN_GOMP_LOOP_RUNTIME_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_STATIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_GUIDED_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_NEXT,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC_START,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_GUIDED_START,\n+\tBUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_END, BUILT_IN_GOMP_LOOP_END_NOWAIT,\n+\tBUILT_IN_GOMP_ORDERED_START, BUILT_IN_GOMP_ORDERED_END,\n+\tBUILT_IN_GOMP_PARALLEL_START, BUILT_IN_GOMP_PARALLEL_END,\n+\tBUILT_IN_GOMP_SECTIONS_START, BUILT_IN_GOMP_SECTIONS_NEXT,\n+\tBUILT_IN_GOMP_PARALLEL_SECTIONS_START, BUILT_IN_GOMP_SECTIONS_END,\n+\tBUILT_IN_GOMP_SECTIONS_END_NOWAIT, BUILT_IN_GOMP_SINGLE_START,\n+\tBUILT_IN_GOMP_SINGLE_COPY_START, BUILT_IN_GOMP_SINGLE_COPY_END): New.\n+\t* sync-builtins.def: New file, moved from builtins.def.\n+\t* omp-builtins.def: New file, moved from builtins.def.\n+\t* c-objc-common.h (LANG_HOOKS_OMP_PREDETERMINED_SHARING): Redefine.\n+\t* gimple-low.c (lower_function_body): Clear data.\n+\t(lower_stmt): Do not handle COMPOUND_EXPR.\n+\tRemove call to print_node_brief.\n+\t* c-tree.h (c_finish_omp_clauses): New prototype.\n+\t(C_DECL_THREADPRIVATE_P): Define.\n+\t(lookup_name_no_remap, c_omp_remap_private): Remove\n+\t(c_begin_omp_parallel, c_finish_omp_parallel): Update.\n+\t(check_for_loop_decls): Update decl.\n+\t(lookup_name_no_remap, c_omp_remap_private): Declare.\n+\t(build_indirect_ref, build_modify_expr, pushdecl,\n+\tpushdecl_top_level): Move to c-common.h.\n+\t* dwarf2out.c (loc_descriptor_from_tree_1): Don't set unsignedp\n+\tbefore the switch, but just in the 2 places that need it.\n+\t* c-decl.c (diagnose_mismatched_decls): Do not check for\n+\tmismatched thread-local attributes when OLDDECL is marked\n+\tthreadprivate and NEWDECL has no thread-local attributes.\n+\t(merge_decls): Merge C_DECL_THREADPRIVATE_P.\n+\t(c_gimple_diagnostics_recursively): Rename from\n+\tc_warn_unused_result_recursively.  Invoke\n+\tdiagnose_omp_structured_block_errors.\n+\t(check_for_loop_decls): Return a singular decl found.\n+\t* langhooks.c (lhd_omp_predetermined_sharing): Return\n+\tOMP_CLAUSE_DEFAULT_SHARED for DECL_ARTIFICIAL decls.\n+\t(lhd_omp_firstprivatize_type_sizes): New.\n+\t(lhd_omp_assignment): New.\n+\t(lhd_omp_predetermined_sharing): New.\n+\t* langhooks.h (struct gimplify_omp_ctx): Forward declare.\n+\t(struct lang_hooks_for_types): Add\n+\tomp_firstprivatize_type_sizes, omp_privatize_by_reference,\n+\tomp_predetermined_sharing, omp_disregard_value_expr,\n+\tomp_private_debug_clause, omp_clause_default_ctor,\n+\tomp_clause_copy_ctor, omp_clause_assign_op, omp_clause_dtor.\n+\t(c_finish_omp_clauses): New.\n+\t(c_finish_bc_stmt): Diagnose break within omp for.\n+\t(c_begin_omp_parallel, c_finish_omp_parallel): New.\n+\t(build_unary_op): Return error_mark after reporting\n+\ta readonly_error.\n+\t(build_modify_expr): Likewise.\n+\t* gimplify.c: Include optabs.h and pointer-set.h.\n+\t(enum gimplify_omp_var_data): Declare.\n+\t(struct gimplify_omp_ctx): Declare.\n+\t(struct gimplify_ctx): Add fields prev_context, combined_pre_p\n+\tand combined_ctxp.\n+\t(gimplify_ctxp, gimplify_omp_ctxp): New local variables.\n+\t(push_gimplify_context, pop_gimplify_context): Allow nesting.\n+\t(splay_tree_compare_decl_uid): New.\n+\t(new_omp_context): New.\n+\t(delete_omp_context): New.\n+\t(gimple_add_tmp_var): Call omp_add_variable.\n+\t(gimplify_bind_expr): Likewise.\n+\t(gimplify_var_or_parm_decl): If omp_notice_variable returned\n+\ttrue, disregard DECL_VALUE_EXPR on the decl if any.\n+\t(gimplify_expr_in_ctx): New.\n+\t(omp_firstprivatize_variable, omp_firstprivatize_type_sizes\n+\tomp_add_variable, omp_notice_variable, omp_is_private\n+\tgimplify_scan_omp_clauses, gimplify_adjust_omp_clauses_1\n+\tgimplify_adjust_omp_clauses, gimplify_omp_parallel\n+\tgimplify_omp_for, gimplify_omp_workshare, goa_lhs_expr_p\n+\tgimplify_omp_atomic_fetch_op, goa_stabilize_expr\n+\tgimplify_omp_atomic_pipeline, gimplify_omp_atomic_mutex\n+\tgimplify_omp_atomic): New.\n+\t(gimplify_expr): Handle OMP_PARALLEL, OMP_FOR, OMP_SECTIONS,\n+\tOMP_SINGLE, OMP_SECTION, OMP_MASTER, OMP_ORDERED,\n+\tOMP_CRITICAL and OMP_ATOMIC.\n+\t(gimplify_body): Verify gimplify_ctxp is empty after gimplification.\n+\t* c-pragma.h (enum pragma_kind): Add\n+\tPRAGMA_OMP_ATOMIC, PRAGMA_OMP_BARRIER,\n+\tPRAGMA_OMP_CRITICAL, PRAGMA_OMP_FLUSH, PRAGMA_OMP_FOR,\n+\tPRAGMA_OMP_MASTER, PRAGMA_OMP_ORDERED,\n+\tPRAGMA_OMP_PARALLEL, PRAGMA_OMP_PARALLEL_FOR,\n+\tPRAGMA_OMP_PARALLEL_SECTIONS, PRAGMA_OMP_SECTION,\n+\tPRAGMA_OMP_SECTIONS, PRAGMA_OMP_SINGLE,\n+\tPRAGMA_OMP_THREADPRIVATE.\n+\t* tree.def (OMP_PARALLEL, OMP_FOR, OMP_SECTIONS,\n+\tOMP_SINGLE, OMP_SECTION, OMP_MASTER, OMP_ORDERED,\n+\tOMP_CRITICAL, OMP_ATOMIC, OMP_CLAUSE_PRIVATE,\n+\tOMP_CLAUSE_SHARED, OMP_CLAUSE_FIRSTPRIVATE,\n+\tOMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_REDUCTION,\n+\tOMP_CLAUSE_COPYIN, OMP_CLAUSE_COPYPRIVATE,\n+\tOMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS,\n+\tOMP_CLAUSE_SCHEDULE, OMP_CLAUSE_NOWAIT,\n+\tOMP_CLAUSE_ORDERED, OMP_CLAUSE_DEFAULT): Define.\n+\t* print-tree.c (print_node): Dump DECL_VALUE_EXPR.\n+\t* tree-ssa-dce.c (find_control_dependence): Do not assume that\n+\tENTRY_BLOCK_PTR->next_bb == single_succ (ENTRY_BLOCK_PTR).\n+\t* tree-nested.c (convert_call_expr): Call walk_body on OMP_BODY for\n+\tOpenMP directives.\n+\t(struct nesting_info): Add field_map,\n+\tsuppress_expansion, debug_var_chain.\n+\t(create_nesting_tree): Initialize them.\n+\t(lookup_field_for_decl): Use field_map.\n+\t(get_nonlocal_debug_decl, get_local_debug_decl): New.\n+\t(convert_local_omp_clauses): New.\n+\t(finalize_nesting_tree_1): Add debug_var_chain to toplevel block.\n+\t(walk_body): Split out of walk_function.\n+\t(convert_nonlocal_omp_clauses, convert_local_omp_clauses): New.\n+\t(convert_nonlocal_reference): Handle omp statements.\n+\t(convert_local_reference): Likewise.\n+\t(unnest_nesting_tree_1): Split out of finalize_nesting_tree_1.\n+\t(unnest_nesting_tree): New.\n+\t(lower_nested_functions): Call it.\n+\t(insert_field_into_struct): Make extern.\n+\t(struct walk_stmt_info): Move to tree-gimple.h.\n+\t(walk_stmts): Make extern.\n+\t* omp-builtins.def: New file.\n+\t* tree-iterator.c (expr_only): Clarify comment.\n+\t* c-common.h (pushdecl_top_level, pushdecl,\n+\tbuild_modify_expr, build_indirect_ref,\n+\tc_finish_omp_master, c_finish_omp_critical,\n+\tc_finish_omp_ordered, c_finish_omp_barrier,\n+\tc_finish_omp_atomic, c_finish_omp_flush,\n+\tc_finish_omp_for, c_split_parallel_clauses,\n+\tomp_clause_default_kind, c_omp_sharing_predetermined,\n+\tc_omp_remap_decl): Declare.\n+\t* Makefile.in (BUILTINS_DEF): Add omp-builtins.def.\n+\t(OBJS-common): Add omp-low.o.\n+\t(c-omp.o, omp-low.o): Add.\n+\t(gimplify.o): Add dependency on $(OPTABS_H).\n+\t(GTFILES): Add omp-low.c.\n+\t(gt-stringpool.h): Add.\n+\t* tree-cfg.c (set_bb_for_stmt): Do not update the\n+\tblock-to-labels map if we are currently expanding to RTL.\n+\t(tree_node_can_be_shared): Remove unnecessary CONSTANT_CLASS_P\n+\tchecks.\n+\tHandle IDENTIFIER_NODE.\n+\t(tree_verify_flow_info): Do not ICE when emitting error\n+\tmessages about invalid labels.\n+\t(dump_function_to_file): Reset CFUN before emitting the body\n+\tof the function.\n+\t(debug_function): New.\n+\t* passes.c (init_optimization_passes): Schedule\n+\tpass_lower_omp.\n+\t* langhooks-def.h (lhd_omp_predetermined_sharing,\n+\tlhd_omp_assignment, lhd_omp_firstprivatize_type_sizes):\n+\tDeclare.\n+\t(LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES): Define.\n+\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Use it.\n+\t(LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE,\n+\tLANG_HOOKS_OMP_PREDETERMINED_SHARING,\n+\tLANG_HOOKS_OMP_DISREGARD_VALUE_EXPR,\n+\tLANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE,\n+\tLANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR,\n+\tLANG_HOOKS_OMP_CLAUSE_COPY_CTOR,\n+\tLANG_HOOKS_OMP_CLAUSE_ASSIGN_OP,\n+\tLANG_HOOKS_OMP_CLAUSE_DTOR): Define.\n+\t(LANG_HOOK_DECLS): Use them.\n+\n+2006-01-18  Dmitry Kurochkin <dmitry.kurochkin@gmail.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* c-parser.c (pragma_omp_clause): Define.\n+\t(c_parser_declaration_or_fndef): Document OpenMP syntax.\n+\t(c_parser_compound_statement): Likewise.\n+\t(c_parser_statement): Likewise.\n+\t(c_parser_pragma): Handle omp pragmas.\n+\t(OMP_FOR_CLAUSE_MASK, OMP_SECTIONS_CLAUSE_MASK,\n+\tOMP_PARALLEL_CLAUSE_MASK, OMP_SINGLE_CLAUSE_MASK): Define.\n+\t(c_parser_omp_clause_name, check_no_duplicate_clause,\n+\tc_parser_omp_variable_list,\n+\tc_parser_omp_var_list_parens, c_parser_omp_clause_copyin,\n+\tc_parser_omp_clause_copyprivate,\n+\tc_parser_omp_clause_default,\n+\tc_parser_omp_clause_firstprivate, c_parser_omp_clause_if,\n+\tc_parser_omp_clause_lastprivate,\n+\tc_parser_omp_clause_nowait,\n+\tc_parser_omp_clause_num_threads,\n+\tc_parser_omp_clause_ordered, c_parser_omp_clause_private,\n+\tc_parser_omp_clause_reduction,\n+\tc_parser_omp_clause_schedule, c_parser_omp_clause_shared,\n+\tc_parser_omp_all_clauses, c_parser_omp_structured_block,\n+\tc_parser_omp_atomic, c_parser_omp_barrier,\n+\tc_parser_omp_critical, c_parser_omp_flush,\n+\tc_parser_omp_for_loop, c_parser_omp_for,\n+\tc_parser_omp_master, c_parser_omp_ordered,\n+\tc_parser_omp_sections_scope, c_parser_omp_sections,\n+\tc_parser_omp_parallel, c_parser_omp_single,\n+\tc_parser_omp_construct, c_parser_omp_threadprivate): New.\n+\t* c-pragma.c (init_pragma): Do omp pragma registration here.\n+\t* c.opt (fopenmp): New flag.\n+\n+2006-01-18  Eric Christopher  <echristo@apple.com>\n+\n+\t* gcc.c (GOMP_SELF_SPECS): Bracket in #ifndef/#endif.\n+\t* config/darwin.h (GOMP_SELF_SPECS): Define.\n+\n 2006-01-18  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* rtl.h: Remove the prototype for reg_alloc."}, {"sha": "dd2c8452926d9326ebea92d623e477ad752de16a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -737,7 +737,7 @@ RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \\\n   input.h real.h statistics.h\n RTL_H = $(RTL_BASE_H) genrtl.h\n PARAMS_H = params.h params.def\n-BUILTINS_DEF = builtins.def sync-builtins.def\n+BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def\n TREE_H = tree.h tree.def $(MACHMODE_H) tree-check.h $(BUILTINS_DEF) \\\n           input.h statistics.h vec.h treestruct.def\n BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h varray.h $(PARTITION_H) \\\n@@ -948,7 +948,7 @@ C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n   c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n   c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \\\n-  c-gimplify.o tree-mudflap.o c-pretty-print.o\n+  c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o\n \n # Language-specific object files for C.\n C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n@@ -963,7 +963,7 @@ OBJS-common = \\\n  tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \\\n  tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n- tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o\t\t   \\\n+ omp-low.o tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o\t   \\\n  tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o\t\t   \\\n  tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t\t\t\t   \\\n  tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o\t\t   \\\n@@ -1671,6 +1671,9 @@ c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \\\n \t  -DHOST_MACHINE=\\\"$(host)\\\" -DTARGET_MACHINE=\\\"$(target)\\\" \\\n \t  $< $(OUTPUT_OPTION)\n \n+c-omp.o : c-omp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+\t$(FUNCTION_H) $(C_COMMON_H) toplev.h $(TREE_GIMPLE_H)\n+\n # Language-independent files.\n \n DRIVER_DEFINES = \\\n@@ -2034,12 +2037,16 @@ gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n    $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h except.h $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) output.h \\\n-   $(GGC_H) gt-gimplify.h $(HASHTAB_H) real.h $(TARGET_H) toplev.h\n+   $(GGC_H) gt-gimplify.h $(HASHTAB_H) real.h $(TARGET_H) toplev.h $(OPTABS_H)\n gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n    $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    except.h $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) tree-pass.h \\\n    $(HASHTAB_H) toplev.h\n+omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+   $(RTL_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \\\n+   $(TREE_FLOW_H) $(TIMEVAR_H) $(FLAGS_H) $(EXPR_H) toplev.h tree-pass.h \\\n+   $(GGC_H)\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    $(TM_H) coretypes.h\n@@ -2859,7 +2866,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n   $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \\\n   $(srcdir)/tree-ssa-structalias.c \\\n-  $(srcdir)/c-pragma.h \\\n+  $(srcdir)/c-pragma.h $(srcdir)/omp-low.c \\\n   $(srcdir)/targhooks.c $(out_file) \\\n   @all_gtfiles@\n \n@@ -2893,7 +2900,7 @@ gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \\\n gt-tree-ssa-structalias.h \\\n-gt-stringpool.h gt-targhooks.h : s-gtype ; @true\n+gt-stringpool.h gt-targhooks.h gt-omp-low.h : s-gtype ; @true\n \n define echo_quoted_to_gtyp\n  echo \"\\\"$(gtyp)\\\", \" >> tmp-gtyp.h"}, {"sha": "1e97d6e68beefea48552a50d62cf32f7f03afee3", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -33,6 +33,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    DEF_FUNCTION_TYPE_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n    DEF_FUNCTION_TYPE_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\n    DEF_FUNCTION_TYPE_5 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\n+   DEF_FUNCTION_TYPE_6 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)\n+   DEF_FUNCTION_TYPE_7 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)\n \n      These macros describe function types.  ENUM is as above.  The\n      RETURN type is one of the enumerals already defined.  ARG1, ARG2,\n@@ -43,6 +45,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    DEF_FUNCTION_TYPE_VAR_2 (ENUM, RETURN, ARG1, ARG2)\n    DEF_FUNCTION_TYPE_VAR_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n    DEF_FUNCTION_TYPE_VAR_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\n+   DEF_FUNCTION_TYPE_VAR_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\n \n      Similar, but for function types that take variable arguments.\n      For example:\n@@ -115,10 +118,14 @@ DEF_PRIMITIVE_TYPE (BT_I8, builtin_type_for_size (BITS_PER_UNIT*8, 1))\n DEF_PRIMITIVE_TYPE (BT_I16, builtin_type_for_size (BITS_PER_UNIT*16, 1))\n \n DEF_POINTER_TYPE (BT_PTR_CONST_STRING, BT_CONST_STRING)\n+DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n+DEF_POINTER_TYPE (BT_PTR_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_0 (BT_FN_VOID, BT_VOID)\n+DEF_FUNCTION_TYPE_0 (BT_FN_BOOL, BT_BOOL)\n DEF_FUNCTION_TYPE_0 (BT_FN_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_0 (BT_FN_PID, BT_PID)\n+DEF_FUNCTION_TYPE_0 (BT_FN_INT, BT_INT)\n DEF_FUNCTION_TYPE_0 (BT_FN_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_0 (BT_FN_FLOAT, BT_FLOAT)\n DEF_FUNCTION_TYPE_0 (BT_FN_DOUBLE, BT_DOUBLE)\n@@ -194,6 +201,10 @@ DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT32_DFLOAT32, BT_DFLOAT32, BT_DFLOAT32)\n DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT64_DFLOAT64, BT_DFLOAT64, BT_DFLOAT64)\n DEF_FUNCTION_TYPE_1 (BT_FN_DFLOAT128_DFLOAT128, BT_DFLOAT128, BT_DFLOAT128)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTRPTR, BT_VOID, BT_PTR_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n+\n+DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING, \n@@ -281,6 +292,8 @@ DEF_FUNCTION_TYPE_2 (BT_FN_I2_VPTR_I2, BT_I2, BT_VOLATILE_PTR, BT_I2)\n DEF_FUNCTION_TYPE_2 (BT_FN_I4_VPTR_I4, BT_I4, BT_VOLATILE_PTR, BT_I4)\n DEF_FUNCTION_TYPE_2 (BT_FN_I8_VPTR_I8, BT_I8, BT_VOLATILE_PTR, BT_I8)\n DEF_FUNCTION_TYPE_2 (BT_FN_I16_VPTR_I16, BT_I16, BT_VOLATILE_PTR, BT_I16)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_LONGPTR_LONGPTR,\n+\t\t     BT_BOOL, BT_PTR_LONG, BT_PTR_LONG)\n \n DEF_FUNCTION_TYPE_3 (BT_FN_STRING_STRING_CONST_STRING_SIZE,\n \t\t     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE)\n@@ -343,6 +356,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_I4_VPTR_I4_I4, BT_I4, BT_VOLATILE_PTR, BT_I4, BT_I4)\n DEF_FUNCTION_TYPE_3 (BT_FN_I8_VPTR_I8_I8, BT_I8, BT_VOLATILE_PTR, BT_I8, BT_I8)\n DEF_FUNCTION_TYPE_3 (BT_FN_I16_VPTR_I16_I16, BT_I16, BT_VOLATILE_PTR,\n \t\t     BT_I16, BT_I16)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_OMPFN_PTR_UINT, BT_VOID, BT_PTR_FN_VOID_PTR,\n+\t\t     BT_PTR, BT_UINT)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)\n@@ -358,14 +373,29 @@ DEF_FUNCTION_TYPE_4 (BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE,\n \t\t     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE, BT_SIZE)\n DEF_FUNCTION_TYPE_4 (BT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_FILEPTR, BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n \n DEF_FUNCTION_TYPE_5 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING,\n \t\t     BT_VALIST_ARG)\n+DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG)\n \n DEF_FUNCTION_TYPE_6 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_SIZE, BT_INT, BT_SIZE,\n \t\t     BT_CONST_STRING, BT_VALIST_ARG)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t     BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n+\t\t     BT_LONG, BT_LONG, BT_LONG)\n+\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n+\t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)\n@@ -404,3 +434,4 @@ DEF_FUNCTION_TYPE_VAR_5 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR,\n DEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,\n \t\t     BT_PTR, BT_PTR_FN_VOID_VAR, BT_PTR, BT_SIZE)\n+"}, {"sha": "2d4322f97004d28d4d5f3743ae42778d61030a80", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -76,7 +76,6 @@ static const char *c_getstr (tree);\n static rtx c_readstr (const char *, enum machine_mode);\n static int target_char_cast (tree, char *);\n static rtx get_memory_rtx (tree, tree);\n-static tree build_string_literal (int, const char *);\n static int apply_args_size (void);\n static int apply_result_size (void);\n #if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n@@ -4785,7 +4784,7 @@ expand_builtin_copysign (tree arglist, rtx target, rtx subtarget)\n \n /* Create a new constant string literal and return a char* pointer to it.\n    The STRING_CST value is the LEN characters at STR.  */\n-static tree\n+tree\n build_string_literal (int len, const char *str)\n {\n   tree t, elem, index, type;"}, {"sha": "b0d54a085d0aa44870eb797757e1c744bff8712c", "filename": "gcc/builtins.def", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -23,7 +23,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* Before including this file, you should define a macro:\n \n      DEF_BUILTIN (ENUM, NAME, CLASS, TYPE, LIBTYPE, BOTH_P,\n-                  FALLBACK_P, NONANSI_P, ATTRS, IMPLICIT)\n+                  FALLBACK_P, NONANSI_P, ATTRS, IMPLICIT, COND)\n \n    This macro will be called once for each builtin function.  The\n    ENUM will be of type `enum built_in_function', and will indicate\n@@ -61,8 +61,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    define it's meaning.  When user uses floorf we may assume that the\n    floorf has the meaning we expect, but we can't produce floorf by\n    simplifying floor((double)float) since the runtime need not implement\n-   it.  */\n-   \n+   it.\n+\n+   The builtins is registered only if COND is true.  */\n+\n /* A GCC builtin (like __builtin_saveregs) is provided by the\n    compiler, but does not correspond to a function in the standard\n    library.  */\n@@ -133,6 +135,13 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, 0, 0, false, false, \\\n \t       false, 0, false, false)\n \n+/* Builtin used by the implementation of GNU OpenMP.  None of these are\n+   actually implemented in the compiler; they're all in libgomp.  */\n+#undef DEF_GOMP_BUILTIN\n+#define DEF_GOMP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+               false, true, true, ATTRS, false, flag_openmp)\n+\n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for\n    `errno'.  If !flag_errno_math they are instead \"const\".  */\n@@ -711,3 +720,6 @@ DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, \"profile_func_exit\")\n \n /* Synchronization Primitives.  */\n #include \"sync-builtins.def\"\n+\n+/* OpenMP builtins.  */\n+#include \"omp-builtins.def\""}, {"sha": "6da433c6524146ccd72e74e4fc7d4ade902ef25f", "filename": "gcc/c-common.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -296,6 +296,10 @@ extern tree push_stmt_list (void);\n extern tree pop_stmt_list (tree);\n extern tree add_stmt (tree);\n extern void push_cleanup (tree, tree, bool);\n+extern tree pushdecl_top_level (tree);\n+extern tree pushdecl (tree);\n+extern tree build_modify_expr (tree, enum tree_code, tree);\n+extern tree build_indirect_ref (tree, const char *);\n \n extern int c_expand_decl (tree);\n \n@@ -934,6 +938,21 @@ extern void pp_file_change (const struct line_map *);\n extern void pp_dir_change (cpp_reader *, const char *);\n extern bool check_missing_format_attribute (tree, tree);\n \n+/* In c-omp.c  */\n+extern tree c_finish_omp_master (tree);\n+extern tree c_finish_omp_critical (tree, tree);\n+extern tree c_finish_omp_ordered (tree);\n+extern void c_finish_omp_barrier (void);\n+extern void c_finish_omp_atomic (enum tree_code, tree, tree);\n+extern void c_finish_omp_flush (void);\n+extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);\n+extern void c_split_parallel_clauses (tree, tree *, tree *);\n+extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n+\n+/* Not in c-omp.c; provided by the front end.  */\n+extern bool c_omp_sharing_predetermined (tree);\n+extern tree c_omp_remap_decl (tree, bool);\n+\n /* In order for the format checking to accept the C frontend\n    diagnostic framework extensions, you must include this file before\n    toplev.h, not after.  The C front end formats are a subset of those"}, {"sha": "f54d17e86e6ebe3652024cae83596cf9d426ba47", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -544,6 +544,9 @@ c_cpp_builtins (cpp_reader *pfile)\n   else if (flag_stack_protect == 1)\n     cpp_define (pfile, \"__SSP__=1\");\n \n+  if (flag_openmp)\n+    cpp_define (pfile, \"_OPENMP=200505\");\n+\n   /* A straightforward target hook doesn't work, because of problems\n      linking that hook's body when part of non-C front ends.  */\n # define preprocessing_asm_p() (cpp_get_options (pfile)->lang == CLK_ASM)"}, {"sha": "a3b56c0b63451fe97651c3e4956cb704ae1a69a8", "filename": "gcc/c-decl.c", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -1385,7 +1385,14 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n     {\n       /* Only variables can be thread-local, and all declarations must\n \t agree on this property.  */\n-      if (DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))\n+      if (C_DECL_THREADPRIVATE_P (olddecl) && !DECL_THREAD_LOCAL_P (newdecl))\n+\t{\n+\t  /* Nothing to check.  Since OLDDECL is marked threadprivate\n+\t     and NEWDECL does not have a thread-local attribute, we\n+\t     will merge the threadprivate attribute into NEWDECL.  */\n+\t  ;\n+\t}\n+      else if (DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))\n \t{\n \t  if (DECL_THREAD_LOCAL_P (newdecl))\n \t    error (\"thread-local declaration of %q+D follows \"\n@@ -1672,6 +1679,13 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n    if (DECL_INITIAL (newdecl) == 0)\n     DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \n+  /* Merge the threadprivate attribute.  */\n+  if (TREE_CODE (olddecl) == VAR_DECL && C_DECL_THREADPRIVATE_P (olddecl))\n+    {\n+      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);\n+      C_DECL_THREADPRIVATE_P (newdecl) = 1;\n+    }\n+\n    if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))\n      {\n        /* Merge the unused-warning information.  */\n@@ -6454,21 +6468,25 @@ store_parm_decls (void)\n   cfun->x_dont_save_pending_sizes_p = 1;\n }\n \f\n-/* Handle attribute((warn_unused_result)) on FNDECL and all its nested\n-   functions.  */\n+/* Emit diagnostics that require gimple input for detection.  Operate on\n+   FNDECL and all its nested functions.  */\n \n static void\n-c_warn_unused_result_recursively (tree fndecl)\n+c_gimple_diagnostics_recursively (tree fndecl)\n {\n   struct cgraph_node *cgn;\n \n   /* Handle attribute((warn_unused_result)).  Relies on gimple input.  */\n   c_warn_unused_result (&DECL_SAVED_TREE (fndecl));\n \n+  /* Notice when OpenMP structured block constraints are violated.  */\n+  if (flag_openmp)\n+    diagnose_omp_structured_block_errors (fndecl);\n+\n   /* Finalize all nested functions now.  */\n   cgn = cgraph_node (fndecl);\n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n-    c_warn_unused_result_recursively (cgn->decl);\n+    c_gimple_diagnostics_recursively (cgn->decl);\n }\n \n /* Finish up a function declaration and compile that function\n@@ -6596,7 +6614,7 @@ finish_function (void)\n       if (!decl_function_context (fndecl))\n         {\n           c_genericize (fndecl);\n-          c_warn_unused_result_recursively (fndecl);\n+          c_gimple_diagnostics_recursively (fndecl);\n \n \t  /* ??? Objc emits functions after finalizing the compilation unit.\n \t     This should be cleaned up later and this conditional removed.  */\n@@ -6650,19 +6668,23 @@ c_expand_body (tree fndecl)\n }\n \f\n /* Check the declarations given in a for-loop for satisfying the C99\n-   constraints.  */\n-void\n+   constraints.  If exactly one such decl is found, return it.  */\n+\n+tree\n check_for_loop_decls (void)\n {\n   struct c_binding *b;\n+  tree one_decl = NULL_TREE;\n+  int n_decls = 0;\n+\n \n   if (!flag_isoc99)\n     {\n       /* If we get here, declarations have been used in a for loop without\n \t the C99 for loop scope.  This doesn't make much sense, so don't\n \t allow it.  */\n       error (\"%<for%> loop initial declaration used outside C99 mode\");\n-      return;\n+      return NULL_TREE;\n     }\n   /* C99 subclause 6.8.5 paragraph 3:\n \n@@ -6713,7 +6735,12 @@ check_for_loop_decls (void)\n \t  error (\"declaration of non-variable %q+D in %<for%> loop \"\n \t\t \"initial declaration\", decl);\n \t}\n+\n+      n_decls++;\n+      one_decl = decl;\n     }\n+\n+  return n_decls == 1 ? one_decl : NULL_TREE;\n }\n \f\n /* Save and reinitialize the variables"}, {"sha": "136445ca68e82d287bd6d7ebd8dae67cca34e976", "filename": "gcc/c-objc-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -134,4 +134,7 @@ extern void c_initialize_diagnostics (diagnostic_context *);\n #undef LANG_HOOKS_GIMPLIFY_EXPR\n #define LANG_HOOKS_GIMPLIFY_EXPR c_gimplify_expr\n \n+#undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n+#define LANG_HOOKS_OMP_PREDETERMINED_SHARING c_omp_predetermined_sharing\n+\n #endif /* GCC_C_OBJC_COMMON */"}, {"sha": "30e7e64b47b5d4c2f26417b805780b5048f587ce", "filename": "gcc/c-omp.c", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,429 @@\n+/* This file contains routines to construct GNU OpenMP constructs, \n+   called from parsing in the C and C++ front ends.\n+\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>,\n+\t\t  Diego Novillo <dnovillo@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"c-common.h\"\n+#include \"toplev.h\"\n+#include \"tree-gimple.h\"\n+#include \"bitmap.h\"\n+#include \"langhooks.h\"\n+\n+\n+/* Complete a #pragma omp master construct.  STMT is the structured-block\n+   that follows the pragma.  */\n+\n+tree\n+c_finish_omp_master (tree stmt)\n+{\n+  return add_stmt (build1 (OMP_MASTER, void_type_node, stmt));\n+}\n+\n+/* Complete a #pragma omp critical construct.  STMT is the structured-block\n+   that follows the pragma, NAME is the identifier in the pragma, or null\n+   if it was omitted.  */\n+\n+tree\n+c_finish_omp_critical (tree body, tree name)\n+{\n+  tree stmt = make_node (OMP_CRITICAL);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_CRITICAL_BODY (stmt) = body;\n+  OMP_CRITICAL_NAME (stmt) = name;\n+  return add_stmt (stmt);\n+}\n+\n+/* Complete a #pragma omp ordered construct.  STMT is the structured-block\n+   that follows the pragma.  */\n+\n+tree\n+c_finish_omp_ordered (tree stmt)\n+{\n+  return add_stmt (build1 (OMP_ORDERED, void_type_node, stmt));\n+}\n+\n+\n+/* Complete a #pragma omp barrier construct.  */\n+\n+void\n+c_finish_omp_barrier (void)\n+{\n+  tree x;\n+\n+  x = built_in_decls[BUILT_IN_GOMP_BARRIER];\n+  x = build_function_call_expr (x, NULL);\n+  add_stmt (x);\n+}\n+\n+\n+/* Complete a #pragma omp atomic construct.  The expression to be \n+   implemented atomically is LHS code= RHS.  */\n+\n+void\n+c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n+{\n+  tree x, type, addr;\n+\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n+    return;\n+\n+  /* ??? According to one reading of the OpenMP spec, complex type are\n+     supported, but there are no atomic stores for any architecture.\n+     But at least icc 9.0 doesn't support complex types here either.\n+     And lets not even talk about vector types...  */\n+  type = TREE_TYPE (lhs);\n+  if (!INTEGRAL_TYPE_P (type)\n+      && !POINTER_TYPE_P (type)\n+      && !SCALAR_FLOAT_TYPE_P (type))\n+    {\n+      error (\"invalid expression type for %<#pragma omp atomic%>\");\n+      return;\n+    }\n+\n+  /* ??? Validate that rhs does not overlap lhs.  */\n+\n+  /* Take and save the address of the lhs.  From then on we'll reference it\n+     via indirection.  */\n+  addr = build_unary_op (ADDR_EXPR, lhs, 0);\n+  if (addr == error_mark_node)\n+    return;\n+  addr = save_expr (addr);\n+  lhs = build_indirect_ref (addr, NULL);\n+\n+  /* There are lots of warnings, errors, and conversions that need to happen\n+     in the course of interpreting a statement.  Use the normal mechanisms\n+     to do this, and then take it apart again.  */\n+  x = build_modify_expr (lhs, code, rhs);\n+  if (x == error_mark_node)\n+    return;\n+  gcc_assert (TREE_CODE (x) == MODIFY_EXPR);  \n+  rhs = TREE_OPERAND (x, 1);\n+\n+  /* Punt the actual generation of atomic operations to common code.  */\n+  add_stmt (build2 (OMP_ATOMIC, void_type_node, addr, rhs));\n+}\n+\n+\n+/* Complete a #pragma omp flush construct.  We don't do anything with the\n+   variable list that the syntax allows.  */\n+\n+void\n+c_finish_omp_flush (void)\n+{\n+  tree x;\n+\n+  x = built_in_decls[BUILT_IN_SYNCHRONIZE];\n+  x = build_function_call_expr (x, NULL);\n+  add_stmt (x);\n+}\n+\n+\n+/* Check and canonicalize #pragma omp for increment expression.\n+   Helper function for c_finish_omp_for.  */\n+\n+static tree\n+check_omp_for_incr_expr (tree exp, tree decl)\n+{\n+  tree t;\n+\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (exp))\n+      || TYPE_PRECISION (TREE_TYPE (exp)) < TYPE_PRECISION (TREE_TYPE (decl)))\n+    return error_mark_node;\n+\n+  if (exp == decl)\n+    return build_int_cst (TREE_TYPE (exp), 0);\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case NOP_EXPR:\n+      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 0), decl);\n+      if (t != error_mark_node)\n+        return fold_convert (TREE_TYPE (exp), t);\n+      break;\n+    case MINUS_EXPR:\n+      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 0), decl);\n+      if (t != error_mark_node)\n+        return fold_build2 (MINUS_EXPR, TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n+      break;\n+    case PLUS_EXPR:\n+      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 0), decl);\n+      if (t != error_mark_node)\n+        return fold_build2 (PLUS_EXPR, TREE_TYPE (exp), t, TREE_OPERAND (exp, 1));\n+      t = check_omp_for_incr_expr (TREE_OPERAND (exp, 1), decl);\n+      if (t != error_mark_node)\n+        return fold_build2 (PLUS_EXPR, TREE_TYPE (exp), TREE_OPERAND (exp, 0), t);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Validate and emit code for the OpenMP directive #pragma omp for.\n+   INIT, COND, INCR, BODY and PRE_BODY are the five basic elements\n+   of the loop (initialization expression, controlling predicate, increment\n+   expression, body of the loop and statements to go before the loop).\n+   DECL is the iteration variable.  */\n+\n+tree\n+c_finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n+\t\t  tree incr, tree body, tree pre_body)\n+{\n+  location_t elocus = locus;\n+  bool fail = false;\n+\n+  if (EXPR_HAS_LOCATION (init))\n+    elocus = EXPR_LOCATION (init);\n+\n+  /* Validate the iteration variable.  */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      error (\"%Hinvalid type for iteration variable %qE\", &elocus, decl);\n+      fail = true;\n+    }\n+  if (TYPE_UNSIGNED (TREE_TYPE (decl)))\n+    warning (0, \"%Hiteration variable %qE is unsigned\", &elocus, decl);\n+\n+  /* In the case of \"for (int i = 0...)\", init will be a decl.  It should\n+     have a DECL_INITIAL that we can turn into an assignment.  */\n+  if (init == decl)\n+    {\n+      elocus = DECL_SOURCE_LOCATION (decl);\n+\n+      init = DECL_INITIAL (decl);\n+      if (init == NULL)\n+\t{\n+\t  error (\"%H%qE is not initialized\", &elocus, decl);\n+\t  init = integer_zero_node;\n+\t  fail = true;\n+\t}\n+\n+      init = build_modify_expr (decl, NOP_EXPR, init);\n+      SET_EXPR_LOCATION (init, elocus);\n+    }\n+  gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+  gcc_assert (TREE_OPERAND (init, 0) == decl);\n+  \n+  if (cond == NULL_TREE)\n+    {\n+      error (\"%Hmissing controlling predicate\", &elocus);\n+      fail = true;\n+    }\n+  else\n+    {\n+      bool cond_ok = false;\n+\n+      if (EXPR_HAS_LOCATION (cond))\n+\telocus = EXPR_LOCATION (cond);\n+\n+      if (TREE_CODE (cond) == LT_EXPR\n+\t  || TREE_CODE (cond) == LE_EXPR\n+\t  || TREE_CODE (cond) == GT_EXPR\n+\t  || TREE_CODE (cond) == GE_EXPR)\n+\t{\n+\t  tree op0 = TREE_OPERAND (cond, 0);\n+\t  tree op1 = TREE_OPERAND (cond, 1);\n+\n+\t  /* 2.5.1.  The comparison in the condition is computed in the type\n+\t     of DECL, otherwise the behavior is undefined.\n+\n+\t     For example:\n+\t     long n; int i;\n+\t     i < n;\n+\n+\t     according to ISO will be evaluated as:\n+\t     (long)i < n;\n+\n+\t     We want to force:\n+\t     i < (int)n;  */\n+\t  if (TREE_CODE (op0) == NOP_EXPR\n+\t      && decl == TREE_OPERAND (op0, 0))\n+\t    {\n+\t      TREE_OPERAND (cond, 0) = TREE_OPERAND (op0, 0);\n+\t      TREE_OPERAND (cond, 1) = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n+\t\t\t\t\t\t    TREE_OPERAND (cond, 1));\n+\t    }\n+\t  else if (TREE_CODE (op1) == NOP_EXPR\n+\t\t   && decl == TREE_OPERAND (op1, 0))\n+\t    {\n+\t      TREE_OPERAND (cond, 1) = TREE_OPERAND (op1, 0);\n+\t      TREE_OPERAND (cond, 0) = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n+\t\t\t\t\t\t    TREE_OPERAND (cond, 0));\n+\t    }\n+\n+\t  if (decl == TREE_OPERAND (cond, 0))\n+\t    cond_ok = true;\n+\t  else if (decl == TREE_OPERAND (cond, 1))\n+\t    {\n+\t      TREE_SET_CODE (cond, swap_tree_comparison (TREE_CODE (cond)));\n+\t      TREE_OPERAND (cond, 1) = TREE_OPERAND (cond, 0);\n+\t      TREE_OPERAND (cond, 0) = decl;\n+\t      cond_ok = true;\n+\t    }\n+\t}\n+\n+      if (!cond_ok)\n+\t{\n+\t  error (\"%Hinvalid controlling predicate\", &elocus);\n+\t  fail = true;\n+\t}\n+    }\n+\n+  if (incr == NULL_TREE)\n+    {\n+      error (\"%Hmissing increment expression\", &elocus);\n+      fail = true;\n+    }\n+  else\n+    {\n+      bool incr_ok = false;\n+\n+      if (EXPR_HAS_LOCATION (incr))\n+\telocus = EXPR_LOCATION (incr);\n+\n+      /* Check all the valid increment expressions: v++, v--, ++v, --v,\n+\t v = v + incr, v = incr + v and v = v - incr.  */\n+      switch (TREE_CODE (incr))\n+\t{\n+\tcase POSTINCREMENT_EXPR:\n+\tcase PREINCREMENT_EXPR:\n+\tcase POSTDECREMENT_EXPR:\n+\tcase PREDECREMENT_EXPR:\n+\t  incr_ok = (TREE_OPERAND (incr, 0) == decl);\n+\t  break;\n+\n+\tcase MODIFY_EXPR:\n+\t  if (TREE_OPERAND (incr, 0) != decl)\n+\t    break;\n+\t  if (TREE_OPERAND (incr, 1) == decl)\n+\t    break;\n+\t  if (TREE_CODE (TREE_OPERAND (incr, 1)) == PLUS_EXPR\n+\t      && (TREE_OPERAND (TREE_OPERAND (incr, 1), 0) == decl\n+\t\t  || TREE_OPERAND (TREE_OPERAND (incr, 1), 1) == decl))\n+\t    incr_ok = true;\n+\t  else if (TREE_CODE (TREE_OPERAND (incr, 1)) == MINUS_EXPR\n+\t\t   && TREE_OPERAND (TREE_OPERAND (incr, 1), 0) == decl)\n+\t    incr_ok = true;\n+\t  else\n+\t    {\n+\t      tree t = check_omp_for_incr_expr (TREE_OPERAND (incr, 1), decl);\n+\t      if (t != error_mark_node)\n+\t\t{\n+\t\t  incr_ok = true;\n+\t\t  t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n+\t\t  incr = build2 (MODIFY_EXPR, void_type_node, decl, t);\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      if (!incr_ok)\n+\t{\n+\t  error (\"%Hinvalid increment expression\", &elocus);\n+\t  fail = true;\n+\t}\n+    }\n+\n+  if (fail)\n+    return NULL;\n+  else\n+    {\n+      tree t = make_node (OMP_FOR);\n+\n+      TREE_TYPE (t) = void_type_node;\n+      OMP_FOR_INIT (t) = init;\n+      OMP_FOR_COND (t) = cond;\n+      OMP_FOR_INCR (t) = incr;\n+      OMP_FOR_BODY (t) = body;\n+      OMP_FOR_PRE_BODY (t) = pre_body;\n+\n+      SET_EXPR_LOCATION (t, locus);\n+      return add_stmt (t);\n+    }\n+}\n+\n+\n+/* Divide CLAUSES into two lists: those that apply to a parallel construct,\n+   and those that apply to a work-sharing construct.  Place the results in\n+   *PAR_CLAUSES and *WS_CLAUSES respectively.  In addition, add a nowait\n+   clause to the work-sharing list.  */\n+\n+void\n+c_split_parallel_clauses (tree clauses, tree *par_clauses, tree *ws_clauses)\n+{\n+  tree next;\n+\n+  *par_clauses = NULL;\n+  *ws_clauses = make_node (OMP_CLAUSE_NOWAIT);\n+\n+  for (; clauses ; clauses = next)\n+    {\n+      next = OMP_CLAUSE_CHAIN (clauses);\n+\n+      switch (TREE_CODE (clauses))\n+\t{\n+\tcase OMP_CLAUSE_PRIVATE:\n+\tcase OMP_CLAUSE_SHARED:\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_COPYIN:\n+\tcase OMP_CLAUSE_IF:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  OMP_CLAUSE_CHAIN (clauses) = *par_clauses;\n+\t  *par_clauses = clauses;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\tcase OMP_CLAUSE_ORDERED:\n+\t  OMP_CLAUSE_CHAIN (clauses) = *ws_clauses;\n+\t  *ws_clauses = clauses;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+/* True if OpenMP sharing attribute of DECL is predetermined.  */\n+\n+enum omp_clause_default_kind\n+c_omp_predetermined_sharing (tree decl)\n+{\n+  /* Variables with const-qualified type having no mutable member\n+     are predetermined shared.  */\n+  if (TREE_READONLY (decl))\n+    return OMP_CLAUSE_DEFAULT_SHARED;\n+\n+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+}"}, {"sha": "e594d1fbd34cfe1e24d4f74eff872bf63ab10492", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1343, "deletions": 8, "changes": 1351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -200,6 +200,26 @@ static const struct resword reswords[] =\n };\n #define N_reswords (sizeof reswords / sizeof (struct resword))\n \n+/* All OpenMP clauses.  OpenMP 2.5.  */\n+typedef enum pragma_omp_clause {\n+  PRAGMA_OMP_CLAUSE_NONE = 0,\n+\n+  PRAGMA_OMP_CLAUSE_COPYIN,\n+  PRAGMA_OMP_CLAUSE_COPYPRIVATE,\n+  PRAGMA_OMP_CLAUSE_DEFAULT,\n+  PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n+  PRAGMA_OMP_CLAUSE_IF,\n+  PRAGMA_OMP_CLAUSE_LASTPRIVATE,\n+  PRAGMA_OMP_CLAUSE_NOWAIT,\n+  PRAGMA_OMP_CLAUSE_NUM_THREADS,\n+  PRAGMA_OMP_CLAUSE_ORDERED,\n+  PRAGMA_OMP_CLAUSE_PRIVATE,\n+  PRAGMA_OMP_CLAUSE_REDUCTION,\n+  PRAGMA_OMP_CLAUSE_SCHEDULE,\n+  PRAGMA_OMP_CLAUSE_SHARED\n+} pragma_omp_clause;\n+\n+\n /* Initialization routine for this file.  */\n \n void\n@@ -981,6 +1001,10 @@ static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n static tree c_parser_expr_list (c_parser *, bool);\n+static void c_parser_omp_construct (c_parser *);\n+static void c_parser_omp_threadprivate (c_parser *);\n+static void c_parser_omp_barrier (c_parser *);\n+static void c_parser_omp_flush (c_parser *);\n \n enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n static bool c_parser_pragma (c_parser *, enum pragma_context);\n@@ -1189,7 +1213,12 @@ c_parser_external_declaration (c_parser *parser)\n    absence is diagnosed through the diagnosis of implicit int.  In GNU\n    C we also allow but diagnose declarations without declaration\n    specifiers, but only at top level (elsewhere they conflict with\n-   other syntax).  */\n+   other syntax).\n+   \n+   OpenMP:\n+   \n+   declaration:\n+     threadprivate-directive  */\n \n static void\n c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n@@ -3256,7 +3285,16 @@ c_parser_initval (c_parser *parser, struct c_expr *after)\n    prefix attributes on the declaration.  ??? The syntax follows the\n    old parser in requiring something after label declarations.\n    Although they are erroneous if the labels declared aren't defined,\n-   is it useful for the syntax to be this way?  */\n+   is it useful for the syntax to be this way?\n+   \n+   OpenMP:\n+   \n+   block-item:\n+     openmp-directive\n+\n+   openmp-directive:\n+     barrier-directive\n+     flush-directive  */\n \n static tree\n c_parser_compound_statement (c_parser *parser)\n@@ -3527,7 +3565,53 @@ c_parser_label (c_parser *parser)\n    objc-throw-statement:\n      @throw expression ;\n      @throw ;\n-*/\n+\n+   OpenMP:\n+\n+   statement:\n+     openmp-construct\n+\n+   openmp-construct:\n+     parallel-construct\n+     for-construct\n+     sections-construct\n+     single-construct\n+     parallel-for-construct\n+     parallel-sections-construct\n+     master-construct\n+     critical-construct\n+     atomic-construct\n+     ordered-construct\n+\n+   parallel-construct:\n+     parallel-directive structured-block\n+\n+   for-construct:\n+     for-directive iteration-statement\n+\n+   sections-construct:\n+     sections-directive section-scope\n+\n+   single-construct:\n+     single-directive structured-block\n+\n+   parallel-for-construct:\n+     parallel-for-directive iteration-statement\n+\n+   parallel-sections-construct:\n+     parallel-sections-directive section-scope\n+\n+   master-construct:\n+     master-directive structured-block\n+\n+   critical-construct:\n+     critical-directive structured-block\n+\n+   atomic-construct:\n+     atomic-directive expression-statement\n+\n+   ordered-construct:\n+     ordered-directive structured-block  */\n \n static void\n c_parser_statement (c_parser *parser)\n@@ -6344,12 +6428,13 @@ c_parser_objc_keywordexpr (c_parser *parser)\n }\n \n \f\n-/* Handle pragmas.  ALLOW_STMT is true if we're within the context of\n-   a function and such pragmas are to be allowed.  Returns true if we\n-   actually parsed such a pragma.  */\n+/* Handle pragmas.  Some OpenMP pragmas are associated with, and therefore\n+   should be considered, statements.  ALLOW_STMT is true if we're within\n+   the context of a function and such pragmas are to be allowed.  Returns\n+   true if we actually parsed such a pragma.  */\n \n static bool\n-c_parser_pragma (c_parser *parser, enum pragma_context context ATTRIBUTE_UNUSED)\n+c_parser_pragma (c_parser *parser, enum pragma_context context)\n {\n   unsigned int id;\n \n@@ -6358,13 +6443,56 @@ c_parser_pragma (c_parser *parser, enum pragma_context context ATTRIBUTE_UNUSED)\n \n   switch (id)\n     {\n+    case PRAGMA_OMP_BARRIER:\n+      if (context != pragma_compound)\n+\t{\n+\t  if (context == pragma_stmt)\n+\t    c_parser_error (parser, \"%<#pragma omp barrier%> may only be \"\n+\t\t\t    \"used in compound statements\");\n+\t  goto bad_stmt;\n+\t}\n+      c_parser_omp_barrier (parser);\n+      return false;\n+\n+    case PRAGMA_OMP_FLUSH:\n+      if (context != pragma_compound)\n+\t{\n+\t  if (context == pragma_stmt)\n+\t    c_parser_error (parser, \"%<#pragma omp flush%> may only be \"\n+\t\t\t    \"used in compound statements\");\n+\t  goto bad_stmt;\n+\t}\n+      c_parser_omp_flush (parser);\n+      return false;\n+\n+    case PRAGMA_OMP_THREADPRIVATE:\n+      c_parser_omp_threadprivate (parser);\n+      return false;\n+\n+    case PRAGMA_OMP_SECTION:\n+      error (\"%<#pragma omp section%> may only be used in \"\n+\t     \"%<#pragma omp sections%> construct\");\n+      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+      return false;\n+\n     case PRAGMA_GCC_PCH_PREPROCESS:\n       c_parser_error (parser, \"%<#pragma GCC pch_preprocess%> must be first\");\n       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n       return false;\n \n     default:\n-      gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n+      if (id < PRAGMA_FIRST_EXTERNAL)\n+\t{\n+\t  if (context == pragma_external)\n+\t    {\n+\t    bad_stmt:\n+\t      c_parser_error (parser, \"expected declaration specifiers\");\n+\t      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+\t      return false;\n+\t    }\n+\t  c_parser_omp_construct (parser);\n+\t  return true;\n+\t}\n       break;\n     }\n \n@@ -6419,6 +6547,1213 @@ c_parser_pragma_pch_preprocess (c_parser *parser)\n   if (name)\n     c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));\n }\n+\f\n+/* OpenMP 2.5 parsing routines.  */\n+\n+/* Returns name of the next clause.\n+   If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and\n+   the token is not consumed.  Otherwise appropriate pragma_omp_clause is\n+   returned and the token is consumed.  */\n+\n+static pragma_omp_clause\n+c_parser_omp_clause_name (c_parser *parser)\n+{\n+  pragma_omp_clause result = PRAGMA_OMP_CLAUSE_NONE;\n+\n+  if (c_parser_next_token_is_keyword (parser, RID_IF))\n+    result = PRAGMA_OMP_CLAUSE_IF;\n+  else if (c_parser_next_token_is_keyword (parser, RID_DEFAULT))\n+    result = PRAGMA_OMP_CLAUSE_DEFAULT;\n+  else if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      switch (p[0])\n+\t{\n+\tcase 'c':\n+\t  if (!strcmp (\"copyin\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_COPYIN;\n+          else if (!strcmp (\"copyprivate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n+\t  break;\n+\tcase 'f':\n+\t  if (!strcmp (\"firstprivate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE;\n+\t  break;\n+\tcase 'l':\n+\t  if (!strcmp (\"lastprivate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;\n+\t  break;\n+\tcase 'n':\n+\t  if (!strcmp (\"nowait\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n+\t  else if (!strcmp (\"num_threads\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NUM_THREADS;\n+\t  break;\n+\tcase 'o':\n+\t  if (!strcmp (\"ordered\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_ORDERED;\n+\t  break;\n+\tcase 'p':\n+\t  if (!strcmp (\"private\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_PRIVATE;\n+\t  break;\n+\tcase 'r':\n+\t  if (!strcmp (\"reduction\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_REDUCTION;\n+\t  break;\n+\tcase 's':\n+\t  if (!strcmp (\"schedule\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_SCHEDULE;\n+\t  else if (!strcmp (\"shared\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_SHARED;\n+\t  break;\n+\t}\n+    }\n+\n+  if (result != PRAGMA_OMP_CLAUSE_NONE)\n+    c_parser_consume_token (parser);\n+\n+  return result;\n+}\n+\n+/* Validate that a clause of the given type does not already exist.  */\n+\n+static void\n+check_no_duplicate_clause (tree clauses, enum tree_code code, const char *name)\n+{\n+  tree c;\n+\n+  for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+    if (TREE_CODE (c) == code)\n+      {\n+\terror (\"too many %qs clauses\", name);\n+\tbreak;\n+      }\n+}\n+\n+/* OpenMP 2.5:\n+   variable-list:\n+     identifier\n+     variable-list , identifier\n+\n+   If KIND is nonzero, create the appropriate node and install the decl\n+   in OMP_CLAUSE_DECL and add the node to the head of the list.\n+\n+   If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;\n+   return the list created.  */\n+\n+static tree\n+c_parser_omp_variable_list (c_parser *parser, enum tree_code kind, tree list)\n+{\n+  if (c_parser_next_token_is_not (parser, CPP_NAME)\n+      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+    c_parser_error (parser, \"expected identifier\");\n+\n+  while (c_parser_next_token_is (parser, CPP_NAME)\n+\t && c_parser_peek_token (parser)->id_kind == C_ID_ID)\n+    {\n+      tree t = lookup_name (c_parser_peek_token (parser)->value);\n+\n+      if (t == NULL_TREE)\n+\tundeclared_variable (c_parser_peek_token (parser)->value,\n+\t\t\t     c_parser_peek_token (parser)->location);\n+      else if (t == error_mark_node)\n+\t;\n+      else if (kind != 0)\n+\t{\n+\t  tree u = make_node (kind);\n+\t  OMP_CLAUSE_DECL (u) = t;\n+\t  OMP_CLAUSE_CHAIN (u) = list;\n+\t  list = u;\n+\t}\n+      else\n+\tlist = tree_cons (t, NULL_TREE, list);\n+\n+      c_parser_consume_token (parser);\n+\n+      if (c_parser_next_token_is_not (parser, CPP_COMMA))\n+\tbreak;\n+\n+      c_parser_consume_token (parser);\n+    }\n+\n+  return list;\n+}\n+\n+/* Similarly, but expect leading and trailing parenthesis.  This is a very\n+   common case for omp clauses.  */\n+\n+static tree\n+c_parser_omp_var_list_parens (c_parser *parser, enum tree_code kind, tree list)\n+{\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      list = c_parser_omp_variable_list (parser, kind, list);\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+    }\n+  return list;\n+}\n+\n+/* OpenMP 2.5:\n+   copyin ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_copyin (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_COPYIN, list);\n+}\n+\n+/* OpenMP 2.5:\n+   copyprivate ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_copyprivate (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_COPYPRIVATE, list);\n+}\n+\n+/* OpenMP 2.5:\n+   default ( shared | none ) */\n+\n+static tree\n+c_parser_omp_clause_default (c_parser *parser, tree list)\n+{\n+  enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+  tree c;\n+\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return list;\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      switch (p[0])\n+\t{\n+\tcase 'n':\n+\t  if (strcmp (\"none\", p) != 0)\n+\t    goto invalid_kind;\n+\t  kind = OMP_CLAUSE_DEFAULT_NONE;\n+\t  break;\n+\n+\tcase 's':\n+\t  if (strcmp (\"shared\", p) != 0)\n+\t    goto invalid_kind;\n+\t  kind = OMP_CLAUSE_DEFAULT_SHARED;\n+\t  break;\n+\n+\tdefault:\n+\t  goto invalid_kind;\n+\t}\n+\n+      c_parser_consume_token (parser);\n+    }\n+  else\n+    {\n+    invalid_kind:\n+      c_parser_error (parser, \"expected %<none%> or %<shared%>\");\n+    }\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+  if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n+    return list;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, \"default\");\n+  c = make_node (OMP_CLAUSE_DEFAULT);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  OMP_CLAUSE_DEFAULT_KIND (c) = kind;\n+\n+  return c;\n+}\n+\n+/* OpenMP 2.5:\n+   firstprivate ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_firstprivate (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_FIRSTPRIVATE, list);\n+}\n+\n+/* OpenMP 2.5:\n+   if ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_if (c_parser *parser, tree list)\n+{\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+    {\n+      tree t = c_parser_paren_condition (parser);\n+      tree c;\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\");\n+\n+      c = make_node (OMP_CLAUSE_IF);\n+      OMP_CLAUSE_IF_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+  else\n+    c_parser_error (parser, \"expected %<(%>\");\n+\n+  return list;\n+}\n+\n+/* OpenMP 2.5:\n+   lastprivate ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_lastprivate (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_LASTPRIVATE, list);\n+}\n+\n+/* OpenMP 2.5:\n+   nowait */\n+\n+static tree\n+c_parser_omp_clause_nowait (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  tree c;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, \"nowait\");\n+\n+  c = make_node (OMP_CLAUSE_NOWAIT);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+/* OpenMP 2.5:\n+   num_threads ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n+{\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      tree c, t = c_parser_expression (parser).value;\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+\n+      /* Attempt to statically determine when the number isn't positive.  */\n+      c = fold_build2 (LE_EXPR, boolean_type_node, t,\n+\t\t       build_int_cst (TREE_TYPE (t), 0));\n+      if (c == boolean_true_node)\n+\t{\n+\t  warning (0, \"%<num_threads%> value must be positive\");\n+\t  t = integer_one_node;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS, \"num_threads\");\n+\n+      c = make_node (OMP_CLAUSE_NUM_THREADS);\n+      OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenMP 2.5:\n+   ordered */\n+\n+static tree\n+c_parser_omp_clause_ordered (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  tree c;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED, \"ordered\");\n+\n+  c = make_node (OMP_CLAUSE_ORDERED);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+/* OpenMP 2.5:\n+   private ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_private (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_PRIVATE, list);\n+}\n+\n+/* OpenMP 2.5:\n+   reduction ( reduction-operator : variable-list )\n+\n+   reduction-operator:\n+     One of: + * - & ^ | && || */\n+\n+static tree\n+c_parser_omp_clause_reduction (c_parser *parser, tree list)\n+{\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      enum tree_code code;\n+\n+      switch (c_parser_peek_token (parser)->type)\n+\t{\n+\tcase CPP_PLUS:\n+\t  code = PLUS_EXPR;\n+\t  break;\n+\tcase CPP_MULT:\n+\t  code = MULT_EXPR;\n+\t  break;\n+\tcase CPP_MINUS:\n+\t  code = MINUS_EXPR;\n+\t  break;\n+\tcase CPP_AND:\n+\t  code = BIT_AND_EXPR;\n+\t  break;\n+\tcase CPP_XOR:\n+\t  code = BIT_XOR_EXPR;\n+\t  break;\n+\tcase CPP_OR:\n+\t  code = BIT_IOR_EXPR;\n+\t  break;\n+\tcase CPP_AND_AND:\n+\t  code = TRUTH_ANDIF_EXPR;\n+\t  break;\n+\tcase CPP_OR_OR:\n+\t  code = TRUTH_ORIF_EXPR;\n+\t  break;\n+\tdefault:\n+\t  c_parser_error (parser,\n+\t\t\t  \"expected %<+%>, %<*%>, %<-%>, %<&%>, \"\n+\t\t\t  \"%<^%>, %<|%>, %<&&%>, or %<||%>\");\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);\n+\t  return list;\n+\t}\n+      c_parser_consume_token (parser);\n+      if (c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n+\t{\n+\t  tree nl, c;\n+\n+\t  nl = c_parser_omp_variable_list (parser, OMP_CLAUSE_REDUCTION, list);\n+\t  for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n+\t    OMP_CLAUSE_REDUCTION_CODE (c) = code;\n+\n+\t  list = nl;\n+\t}\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+    }\n+  return list;\n+}\n+\n+/* OpenMP 2.5:\n+   schedule ( schedule-kind )\n+   schedule ( schedule-kind , expression )\n+\n+   schedule-kind:\n+     static | dynamic | guided | runtime\n+*/\n+\n+static tree\n+c_parser_omp_clause_schedule (c_parser *parser, tree list)\n+{\n+  tree c, t;\n+\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return list;\n+\n+  c = make_node (OMP_CLAUSE_SCHEDULE);\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      tree kind = c_parser_peek_token (parser)->value;\n+      const char *p = IDENTIFIER_POINTER (kind);\n+\n+      switch (p[0])\n+\t{\n+\tcase 'd':\n+\t  if (strcmp (\"dynamic\", p) != 0)\n+\t    goto invalid_kind;\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;\n+\t  break;\n+\n+        case 'g':\n+\t  if (strcmp (\"guided\", p) != 0)\n+\t    goto invalid_kind;\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;\n+\t  break;\n+\n+\tcase 'r':\n+\t  if (strcmp (\"runtime\", p) != 0)\n+\t    goto invalid_kind;\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;\n+\t  break;\n+\n+\tdefault:\n+\t  goto invalid_kind;\n+\t}\n+    }\n+  else if (c_parser_next_token_is_keyword (parser, RID_STATIC))\n+    OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;\n+  else\n+    goto invalid_kind;\n+\n+  c_parser_consume_token (parser);\n+  if (c_parser_next_token_is (parser, CPP_COMMA))\n+    {\n+      c_parser_consume_token (parser);\n+\n+      t = c_parser_expr_no_commas (parser, NULL).value;\n+\n+      if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n+\terror (\"schedule %<runtime%> does not take \"\n+\t       \"a %<chunk_size%> parameter\");\n+      else if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE)\n+\tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n+      else\n+\tc_parser_error (parser, \"expected integer expression\");\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+    }\n+  else\n+    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t       \"expected %<,%> or %<)%>\");\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\");\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+\n+ invalid_kind:\n+  c_parser_error (parser, \"invalid schedule kind\");\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);\n+  return list;\n+}\n+\n+/* OpenMP 2.5:\n+   shared ( variable-list ) */\n+\n+static tree\n+c_parser_omp_clause_shared (c_parser *parser, tree list)\n+{\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_SHARED, list);\n+}\n+\n+/* Parse all OpenMP clauses.  The set clauses allowed by the directive\n+   is a bitmask in MASK.  Return the list of clauses found; the result\n+   of clause default goes in *pdefault.  */\n+\n+static tree\n+c_parser_omp_all_clauses (c_parser *parser, unsigned int mask,\n+\t\t\t  const char *where)\n+{\n+  tree clauses = NULL;\n+\n+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    {\n+      const pragma_omp_clause c_kind = c_parser_omp_clause_name (parser);\n+      const char *c_name;\n+      tree prev = clauses;\n+\n+      switch (c_kind)\n+\t{\n+\tcase PRAGMA_OMP_CLAUSE_COPYIN:\n+\t  clauses = c_parser_omp_clause_copyin (parser, clauses);\n+\t  c_name = \"copyin\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_COPYPRIVATE:\n+\t  clauses = c_parser_omp_clause_copyprivate (parser, clauses);\n+\t  c_name = \"copyprivate\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DEFAULT:\n+\t  clauses = c_parser_omp_clause_default (parser, clauses);\n+\t  c_name = \"default\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:\n+\t  clauses = c_parser_omp_clause_firstprivate (parser, clauses);\n+\t  c_name = \"firstprivate\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_IF:\n+\t  clauses = c_parser_omp_clause_if (parser, clauses);\n+\t  c_name = \"if\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_LASTPRIVATE:\n+\t  clauses = c_parser_omp_clause_lastprivate (parser, clauses);\n+\t  c_name = \"lastprivate\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NOWAIT:\n+\t  clauses = c_parser_omp_clause_nowait (parser, clauses);\n+\t  c_name = \"nowait\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NUM_THREADS:\n+\t  clauses = c_parser_omp_clause_num_threads (parser, clauses);\n+\t  c_name = \"num_threads\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_ORDERED:\n+\t  clauses = c_parser_omp_clause_ordered (parser, clauses);\n+\t  c_name = \"ordered\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_PRIVATE:\n+\t  clauses = c_parser_omp_clause_private (parser, clauses);\n+\t  c_name = \"private\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_REDUCTION:\n+\t  clauses = c_parser_omp_clause_reduction (parser, clauses);\n+\t  c_name = \"reduction\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_SCHEDULE:\n+\t  clauses = c_parser_omp_clause_schedule (parser, clauses);\n+\t  c_name = \"schedule\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_SHARED:\n+\t  clauses = c_parser_omp_clause_shared (parser, clauses);\n+\t  c_name = \"shared\";\n+\t  break;\n+\tdefault:\n+\t  c_parser_error (parser, \"expected %<#pragma omp%> clause\");\n+\t  goto saw_error;\n+\t}\n+\n+      if (((mask >> c_kind) & 1) == 0 && !parser->error)\n+\t{\n+\t  /* Remove the invalid clause(s) from the list to avoid\n+\t     confusing the rest of the compiler.  */\n+\t  clauses = prev;\n+\t  error (\"%qs is not valid for %qs\", c_name, where);\n+\t}\n+    }\n+\n+ saw_error:\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  return c_finish_omp_clauses (clauses);\n+}\n+\n+/* OpenMP 2.5:\n+   structured-block:\n+     statement\n+\n+   In practice, we're also interested in adding the statement to an\n+   outer node.  So it is convenient if we work around the fact that\n+   c_parser_statement calls add_stmt.  */\n+\n+static tree\n+c_parser_omp_structured_block (c_parser *parser)\n+{\n+  tree stmt = push_stmt_list ();\n+  c_parser_statement (parser);\n+  return pop_stmt_list (stmt);\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp atomic new-line\n+     expression-stmt\n+\n+   expression-stmt:\n+     x binop= expr | x++ | ++x | x-- | --x\n+   binop:\n+     +, *, -, /, &, ^, |, <<, >>\n+\n+  where x is an lvalue expression with scalar type.  */\n+\n+static void\n+c_parser_omp_atomic (c_parser *parser)\n+{\n+  tree lhs, rhs;\n+  enum tree_code code;\n+\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  lhs = c_parser_unary_expression (parser).value;\n+  switch (TREE_CODE (lhs))\n+    {\n+    case ERROR_MARK:\n+    saw_error:\n+      c_parser_skip_to_end_of_block_or_statement (parser);\n+      return;\n+\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      lhs = TREE_OPERAND (lhs, 0);\n+      code = PLUS_EXPR;\n+      rhs = integer_one_node;\n+      break;\n+\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      lhs = TREE_OPERAND (lhs, 0);\n+      code = MINUS_EXPR;\n+      rhs = integer_one_node;\n+      break;\n+\n+    default:\n+      switch (c_parser_peek_token (parser)->type)\n+\t{\n+\tcase CPP_MULT_EQ:\n+\t  code = MULT_EXPR;\n+\t  break;\n+\tcase CPP_DIV_EQ:\n+\t  code = TRUNC_DIV_EXPR;\n+\t  break;\n+\tcase CPP_PLUS_EQ:\n+\t  code = PLUS_EXPR;\n+\t  break;\n+\tcase CPP_MINUS_EQ:\n+\t  code = MINUS_EXPR;\n+\t  break;\n+\tcase CPP_LSHIFT_EQ:\n+\t  code = LSHIFT_EXPR;\n+\t  break;\n+\tcase CPP_RSHIFT_EQ:\n+\t  code = RSHIFT_EXPR;\n+\t  break;\n+\tcase CPP_AND_EQ:\n+\t  code = BIT_AND_EXPR;\n+\t  break;\n+\tcase CPP_OR_EQ:\n+\t  code = BIT_IOR_EXPR;\n+\t  break;\n+\tcase CPP_XOR_EQ:\n+\t  code = BIT_XOR_EXPR;\n+\t  break;\n+\tdefault:\n+\t  c_parser_error (parser,\n+\t\t\t  \"invalid operator for %<#pragma omp atomic%>\");\n+\t  goto saw_error;\n+\t}\n+\n+      c_parser_consume_token (parser);\n+      rhs = c_parser_expression (parser).value;\n+      break;\n+    }\n+  c_finish_omp_atomic (code, lhs, rhs);\n+  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+}\n+\n+\n+/* OpenMP 2.5:\n+   # pragma omp barrier new-line\n+*/\n+\n+static void\n+c_parser_omp_barrier (c_parser *parser)\n+{\n+  c_parser_consume_pragma (parser);\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  c_finish_omp_barrier ();\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp critical [(name)] new-line\n+     structured-block\n+*/\n+\n+static tree\n+c_parser_omp_critical (c_parser *parser)\n+{\n+  tree stmt, name = NULL;\n+\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+    {\n+      c_parser_consume_token (parser);\n+      if (c_parser_next_token_is (parser, CPP_NAME))\n+\t{\n+\t  name = c_parser_peek_token (parser)->value;\n+\t  c_parser_consume_token (parser);\n+\t  c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\t}\n+      else\n+\tc_parser_error (parser, \"expected identifier\");\n+    }\n+  else if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    c_parser_error (parser, \"expected %<(%> or end of line\");\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  stmt = c_parser_omp_structured_block (parser);\n+  return c_finish_omp_critical (stmt, name);\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp flush flush-vars[opt] new-line\n+\n+   flush-vars:\n+     ( variable-list ) */\n+\n+static void\n+c_parser_omp_flush (c_parser *parser)\n+{\n+  c_parser_consume_pragma (parser);\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+    c_parser_omp_var_list_parens (parser, 0, NULL);\n+  else if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    c_parser_error (parser, \"expected %<(%> or end of line\");\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  c_finish_omp_flush ();\n+}\n+\n+/* Parse the restricted form of the for statment allowed by OpenMP.\n+   The real trick here is to determine the loop control variable early\n+   so that we can push a new decl if necessary to make it private.  */\n+\n+static tree\n+c_parser_omp_for_loop (c_parser *parser)\n+{\n+  tree decl, cond, incr, save_break, save_cont, body, init;\n+  location_t loc;\n+\n+  if (!c_parser_next_token_is_keyword (parser, RID_FOR))\n+    {\n+      c_parser_error (parser, \"for statement expected\");\n+      return NULL;\n+    }\n+  loc = c_parser_peek_token (parser)->location;\n+  c_parser_consume_token (parser);\n+\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return NULL;\n+\n+  /* Parse the initialization declaration or expression.  */\n+  if (c_parser_next_token_starts_declspecs (parser))\n+    {\n+      c_parser_declaration_or_fndef (parser, true, true, true, true);\n+      decl = check_for_loop_decls ();\n+      if (decl == NULL)\n+\tgoto error_init;\n+      init = decl;\n+    }\n+  else if (c_parser_next_token_is (parser, CPP_NAME)\n+\t   && c_parser_peek_2nd_token (parser)->type == CPP_EQ)\n+    {\n+      decl = c_parser_postfix_expression (parser).value;\n+\n+      c_parser_require (parser, CPP_EQ, \"expected %<=%>\");\n+\n+      init = c_parser_expr_no_commas (parser, NULL).value;\n+      init = build_modify_expr (decl, NOP_EXPR, init);\n+      init = c_process_expr_stmt (init);\n+\n+      c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+    }\n+  else\n+    goto error_init;\n+\n+  /* Parse the loop condition.  */\n+  cond = NULL_TREE;\n+  if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n+    {\n+      cond = c_parser_expression_conv (parser).value;\n+      cond = c_objc_common_truthvalue_conversion (cond);\n+      if (EXPR_P (cond))\n+\tSET_EXPR_LOCATION (cond, input_location);\n+    }\n+  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\n+  /* Parse the increment expression.  */\n+  incr = NULL_TREE;\n+  if (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n+    incr = c_process_expr_stmt (c_parser_expression (parser).value);\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+ parse_body:\n+  save_break = c_break_label;\n+  c_break_label = size_one_node;\n+  save_cont = c_cont_label;\n+  c_cont_label = NULL_TREE;\n+  body = push_stmt_list ();\n+\n+  add_stmt (c_parser_c99_block_statement (parser));\n+  if (c_cont_label)\n+    add_stmt (build1 (LABEL_EXPR, void_type_node, c_cont_label));\n+\n+  body = pop_stmt_list (body);\n+  c_break_label = save_break;\n+  c_cont_label = save_cont;\n+\n+  /* Only bother calling c_finish_omp_for if we havn't already generated\n+     an error from the initialization parsing.  */\n+  if (decl != NULL)\n+    return c_finish_omp_for (loc, decl, init, cond, incr, body, NULL);\n+  return NULL;\n+\n+ error_init:\n+  c_parser_error (parser, \"expected iteration declaration or initialization\");\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  decl = init = cond = incr = NULL_TREE;\n+  goto parse_body;\n+}\n+\n+/* OpenMP 2.5:\n+   #pragma omp for for-clause[optseq] new-line\n+     for-loop\n+*/\n+\n+#define OMP_FOR_CLAUSE_MASK\t\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_ORDERED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+c_parser_omp_for (c_parser *parser)\n+{\n+  tree block, clauses, ret;\n+\n+  clauses = c_parser_omp_all_clauses (parser, OMP_FOR_CLAUSE_MASK,\n+\t\t\t\t      \"#pragma omp for\");\n+\n+  block = c_begin_compound_stmt (true);\n+  ret = c_parser_omp_for_loop (parser);\n+  if (ret)\n+    OMP_FOR_CLAUSES (ret) = clauses;\n+  block = c_end_compound_stmt (block, true);\n+  add_stmt (block);\n+\n+  return ret;\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp master new-line\n+     structured-block\n+*/\n+\n+static tree\n+c_parser_omp_master (c_parser *parser)\n+{\n+  c_parser_skip_to_pragma_eol (parser);\n+  return c_finish_omp_master (c_parser_omp_structured_block (parser));\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp ordered new-line\n+     structured-block\n+*/\n+\n+static tree\n+c_parser_omp_ordered (c_parser *parser)\n+{\n+  c_parser_skip_to_pragma_eol (parser);\n+  return c_finish_omp_ordered (c_parser_omp_structured_block (parser));\n+}\n+\n+/* OpenMP 2.5:\n+\n+   section-scope:\n+     { section-sequence }\n+\n+   section-sequence:\n+     section-directive[opt] structured-block\n+     section-sequence section-directive structured-block  */\n+\n+static tree\n+c_parser_omp_sections_scope (c_parser *parser)\n+{\n+  tree stmt, substmt;\n+  bool error_suppress = false;\n+  location_t loc;\n+\n+  if (!c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n+    {\n+      /* Avoid skipping until the end of the block.  */\n+      parser->error = false;\n+      return NULL_TREE;\n+    }\n+\n+  stmt = push_stmt_list ();\n+\n+  loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_peek_token (parser)->pragma_kind != PRAGMA_OMP_SECTION)\n+    {\n+      substmt = push_stmt_list ();\n+\n+      while (1)\n+\t{\n+          c_parser_statement (parser);\n+\n+\t  if (c_parser_peek_token (parser)->pragma_kind == PRAGMA_OMP_SECTION)\n+\t    break;\n+\t  if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n+\t    break;\n+\t  if (c_parser_next_token_is (parser, CPP_EOF))\n+\t    break;\n+\t}\n+\n+      substmt = pop_stmt_list (substmt);\n+      substmt = build1 (OMP_SECTION, void_type_node, substmt);\n+      SET_EXPR_LOCATION (substmt, loc);\n+      add_stmt (substmt);\n+    }\n+\n+  while (1)\n+    {\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n+\tbreak;\n+      if (c_parser_next_token_is (parser, CPP_EOF))\n+\tbreak;\n+\n+      loc = c_parser_peek_token (parser)->location;\n+      if (c_parser_peek_token (parser)->pragma_kind == PRAGMA_OMP_SECTION)\n+\t{\n+\t  c_parser_consume_pragma (parser);\n+\t  c_parser_skip_to_pragma_eol (parser);\n+\t  error_suppress = false;\n+\t}\n+      else if (!error_suppress)\n+\t{\n+\t  error (\"expected %<#pragma omp section%> or %<}%>\");\n+\t  error_suppress = true;\n+\t}\n+\n+      substmt = c_parser_omp_structured_block (parser);\n+      substmt = build1 (OMP_SECTION, void_type_node, substmt);\n+      SET_EXPR_LOCATION (substmt, loc);\n+      add_stmt (substmt);\n+    }\n+  c_parser_skip_until_found (parser, CPP_CLOSE_BRACE,\n+\t\t\t     \"expected %<#pragma omp section%> or %<}%>\");\n+\n+  substmt = pop_stmt_list (stmt);\n+\n+  stmt = make_node (OMP_SECTIONS);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_SECTIONS_BODY (stmt) = substmt;\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp sections sections-clause[optseq] newline\n+     sections-scope\n+*/\n+\n+#define OMP_SECTIONS_CLAUSE_MASK\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+c_parser_omp_sections (c_parser *parser)\n+{\n+  tree block, clauses, ret;\n+\n+  clauses = c_parser_omp_all_clauses (parser, OMP_SECTIONS_CLAUSE_MASK,\n+\t\t\t\t      \"#pragma omp sections\");\n+\n+  block = c_begin_compound_stmt (true);\n+  ret = c_parser_omp_sections_scope (parser);\n+  if (ret)\n+    OMP_SECTIONS_CLAUSES (ret) = clauses;\n+  block = c_end_compound_stmt (block, true);\n+  add_stmt (block);\n+\n+  return ret;\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma parallel parallel-clause new-line\n+   # pragma parallel for parallel-for-clause new-line\n+   # pragma parallel sections parallel-sections-clause new-line\n+*/\n+\n+#define OMP_PARALLEL_CLAUSE_MASK\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_IF)\t\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_DEFAULT)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_SHARED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_COPYIN)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\n+static tree\n+c_parser_omp_parallel (c_parser *parser)\n+{\n+  enum pragma_kind p_kind = PRAGMA_OMP_PARALLEL;\n+  const char *p_name = \"#pragma omp parallel\";\n+  tree stmt, clauses, par_clause, ws_clause, block;\n+  unsigned int mask = OMP_PARALLEL_CLAUSE_MASK;\n+\n+  if (c_parser_next_token_is_keyword (parser, RID_FOR))\n+    {\n+      c_parser_consume_token (parser);\n+      p_kind = PRAGMA_OMP_PARALLEL_FOR;\n+      p_name = \"#pragma omp parallel for\";\n+      mask |= OMP_FOR_CLAUSE_MASK;\n+      mask &= ~(1u << PRAGMA_OMP_CLAUSE_NOWAIT);\n+    }\n+  else if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"sections\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  p_kind = PRAGMA_OMP_PARALLEL_SECTIONS;\n+\t  p_name = \"#pragma omp parallel sections\";\n+\t  mask |= OMP_SECTIONS_CLAUSE_MASK;\n+\t  mask &= ~(1u << PRAGMA_OMP_CLAUSE_NOWAIT);\n+\t}\n+    }\n+\n+  clauses = c_parser_omp_all_clauses (parser, mask, p_name);\n+\n+  switch (p_kind)\n+    {\n+    case PRAGMA_OMP_PARALLEL:\n+      block = c_begin_omp_parallel ();\n+      c_parser_statement (parser);\n+      stmt = c_finish_omp_parallel (clauses, block);\n+      break;\n+\n+    case PRAGMA_OMP_PARALLEL_FOR:\n+      block = c_begin_omp_parallel ();\n+      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n+      stmt = c_parser_omp_for_loop (parser);\n+      if (stmt)\n+\tOMP_FOR_CLAUSES (stmt) = ws_clause;\n+      stmt = c_finish_omp_parallel (par_clause, block);\n+      break;\n+\n+    case PRAGMA_OMP_PARALLEL_SECTIONS:\n+      block = c_begin_omp_parallel ();\n+      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n+      stmt = c_parser_omp_sections_scope (parser);\n+      if (stmt)\n+\tOMP_SECTIONS_CLAUSES (stmt) = ws_clause;\n+      stmt = c_finish_omp_parallel (par_clause, block);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return stmt;\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp single single-clause[optseq] new-line\n+     structured-block\n+*/\n+\n+#define OMP_SINGLE_CLAUSE_MASK\t\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_COPYPRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+c_parser_omp_single (c_parser *parser)\n+{\n+  tree stmt = make_node (OMP_SINGLE);\n+  TREE_TYPE (stmt) = void_type_node;\n+\n+  OMP_SINGLE_CLAUSES (stmt)\n+    = c_parser_omp_all_clauses (parser, OMP_SINGLE_CLAUSE_MASK,\n+\t\t\t\t\"#pragma omp single\");\n+  OMP_SINGLE_BODY (stmt) = c_parser_omp_structured_block (parser);\n+\n+  return add_stmt (stmt);\n+}\n+\n+\n+/* Main entry point to parsing most OpenMP pragmas.  */\n+\n+static void\n+c_parser_omp_construct (c_parser *parser)\n+{\n+  enum pragma_kind p_kind;\n+  location_t loc;\n+  tree stmt;\n+\n+  loc = c_parser_peek_token (parser)->location;\n+  p_kind = c_parser_peek_token (parser)->pragma_kind;\n+  c_parser_consume_pragma (parser);\n+\n+  switch (p_kind)\n+    {\n+    case PRAGMA_OMP_ATOMIC:\n+      c_parser_omp_atomic (parser);\n+      return;\n+    case PRAGMA_OMP_CRITICAL:\n+      stmt = c_parser_omp_critical (parser);\n+      break;\n+    case PRAGMA_OMP_FOR:\n+      stmt = c_parser_omp_for (parser);\n+      break;\n+    case PRAGMA_OMP_MASTER:\n+      stmt = c_parser_omp_master (parser);\n+      break;\n+    case PRAGMA_OMP_ORDERED:\n+      stmt = c_parser_omp_ordered (parser);\n+      break;\n+    case PRAGMA_OMP_PARALLEL:\n+      stmt = c_parser_omp_parallel (parser);\n+      break;\n+    case PRAGMA_OMP_SECTIONS:\n+      stmt = c_parser_omp_sections (parser);\n+      break;\n+    case PRAGMA_OMP_SINGLE:\n+      stmt = c_parser_omp_single (parser);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (stmt)\n+    SET_EXPR_LOCATION (stmt, loc);\n+}\n+\n+\n+/* OpenMP 2.5:\n+   # pragma omp threadprivate (variable-list) */\n+\n+static void\n+c_parser_omp_threadprivate (c_parser *parser)\n+{\n+  tree vars, t;\n+\n+  c_parser_consume_pragma (parser);\n+  vars = c_parser_omp_var_list_parens (parser, 0, NULL);\n+\n+  if (!targetm.have_tls)\n+    sorry (\"threadprivate variables not supported in this target\");\n+\n+  /* Mark every variable in VARS to be assigned thread local storage.  */\n+  for (t = vars; t; t = TREE_CHAIN (t))\n+    {\n+      tree v = TREE_PURPOSE (t);\n+\n+      /* If V had already been marked threadprivate, it doesn't matter\n+\t whether it had been used prior to this point.  */\n+      if (TREE_USED (v) && !C_DECL_THREADPRIVATE_P (v))\n+\terror (\"%qE declared %<threadprivate%> after first use\", v);\n+      else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))\n+\terror (\"automatic variable %qE cannot be %<threadprivate%>\", v);\n+      else if (! COMPLETE_TYPE_P (TREE_TYPE (v)))\n+\terror (\"%<threadprivate%> %qE has incomplete type\", v);\n+      else\n+\t{\n+\t  if (! DECL_THREAD_LOCAL_P (v))\n+\t    {\n+\t      DECL_TLS_MODEL (v) = decl_default_tls_model (v);\n+\t      /* If rtl has been already set for this var, call\n+\t\t make_decl_rtl once again, so that encode_section_info\n+\t\t has a chance to look at the new decl flags.  */\n+\t      if (DECL_RTL_SET_P (v))\n+\t\tmake_decl_rtl (v);\n+\t    }\n+\t  C_DECL_THREADPRIVATE_P (v) = 1;\n+\t}\n+    }\n+\n+  c_parser_skip_to_pragma_eol (parser);\n+}\n+\n \f\n /* Parse a single source file.  */\n "}, {"sha": "554e57f932b8de921b223bf5725c203dc866d353", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -724,6 +724,32 @@ c_invoke_pragma_handler (unsigned int id)\n void\n init_pragma (void)\n {\n+  if (flag_openmp && !flag_preprocess_only)\n+    {\n+      struct omp_pragma_def { const char *name; unsigned int id; };\n+      static const struct omp_pragma_def omp_pragmas[] = {\n+\t{ \"atomic\", PRAGMA_OMP_ATOMIC },\n+\t{ \"barrier\", PRAGMA_OMP_BARRIER },\n+\t{ \"critical\", PRAGMA_OMP_CRITICAL },\n+\t{ \"flush\", PRAGMA_OMP_FLUSH },\n+\t{ \"for\", PRAGMA_OMP_FOR },\n+\t{ \"master\", PRAGMA_OMP_MASTER },\n+\t{ \"ordered\", PRAGMA_OMP_ORDERED },\n+\t{ \"parallel\", PRAGMA_OMP_PARALLEL },\n+\t{ \"section\", PRAGMA_OMP_SECTION },\n+\t{ \"sections\", PRAGMA_OMP_SECTIONS },\n+\t{ \"single\", PRAGMA_OMP_SINGLE },\n+\t{ \"threadprivate\", PRAGMA_OMP_THREADPRIVATE }\n+      };\n+\n+      const int n_omp_pragmas = sizeof (omp_pragmas) / sizeof (*omp_pragmas);\n+      int i;\n+\n+      for (i = 0; i < n_omp_pragmas; ++i)\n+\tcpp_register_deferred_pragma (parse_in, \"omp\", omp_pragmas[i].name,\n+\t\t\t\t      omp_pragmas[i].id, true, true);\n+    }\n+\n   cpp_register_deferred_pragma (parse_in, \"GCC\", \"pch_preprocess\",\n \t\t\t\tPRAGMA_GCC_PCH_PREPROCESS, false, false);\n "}, {"sha": "28ef4e8f39b596b643cb9ce9c3699cb07f2df49b", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -29,6 +29,21 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n typedef enum pragma_kind {\n   PRAGMA_NONE = 0,\n \n+  PRAGMA_OMP_ATOMIC,\n+  PRAGMA_OMP_BARRIER,\n+  PRAGMA_OMP_CRITICAL,\n+  PRAGMA_OMP_FLUSH,\n+  PRAGMA_OMP_FOR,\n+  PRAGMA_OMP_MASTER,\n+  PRAGMA_OMP_ORDERED,\n+  PRAGMA_OMP_PARALLEL,\n+  PRAGMA_OMP_PARALLEL_FOR,\n+  PRAGMA_OMP_PARALLEL_SECTIONS,\n+  PRAGMA_OMP_SECTION,\n+  PRAGMA_OMP_SECTIONS,\n+  PRAGMA_OMP_SINGLE,\n+  PRAGMA_OMP_THREADPRIVATE,\n+\n   PRAGMA_GCC_PCH_PREPROCESS,\n \n   PRAGMA_FIRST_EXTERNAL"}, {"sha": "f67c4d20796aa9ee5c0247debb531e9952f2020b", "filename": "gcc/c-tree.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -129,6 +129,10 @@ struct lang_type GTY(())\n #define C_DECL_UNDEFINABLE_VM(EXP)\t\\\n   DECL_LANG_FLAG_5 (LABEL_DECL_CHECK (EXP))\n \n+/* Record whether a variable has been declared threadprivate by\n+   #pragma omp threadprivate.  */\n+#define C_DECL_THREADPRIVATE_P(DECL) DECL_LANG_FLAG_3 (VAR_DECL_CHECK (DECL))\n+\n /* Nonzero for a decl which either doesn't exist or isn't a prototype.\n    N.B. Could be simplified if all built-in decls had complete prototypes\n    (but this is presently difficult because some of them need FILE*).  */\n@@ -431,7 +435,6 @@ extern int global_bindings_p (void);\n extern void push_scope (void);\n extern tree pop_scope (void);\n extern void insert_block (tree);\n-extern tree pushdecl (tree);\n extern void c_expand_body (tree);\n \n extern void c_init_decl_processing (void);\n@@ -441,7 +444,7 @@ extern int quals_from_declspecs (const struct c_declspecs *);\n extern struct c_declarator *build_array_declarator (tree, struct c_declspecs *,\n \t\t\t\t\t\t    bool, bool);\n extern tree build_enumerator (tree, tree);\n-extern void check_for_loop_decls (void);\n+extern tree check_for_loop_decls (void);\n extern void mark_forward_parm_decls (void);\n extern void declare_parm_level (void);\n extern void undeclared_variable (tree, location_t);\n@@ -461,7 +464,6 @@ extern void pending_xref_error (void);\n extern void c_push_function_context (struct function *);\n extern void c_pop_function_context (struct function *);\n extern void push_parm_decl (const struct c_parm *);\n-extern tree pushdecl_top_level (tree);\n extern struct c_declarator *set_array_declarator_inner (struct c_declarator *,\n \t\t\t\t\t\t\tstruct c_declarator *,\n \t\t\t\t\t\t\tbool);\n@@ -529,7 +531,6 @@ extern tree default_conversion (tree);\n extern struct c_expr default_function_array_conversion (struct c_expr);\n extern tree composite_type (tree, tree);\n extern tree build_component_ref (tree, tree);\n-extern tree build_indirect_ref (tree, const char *);\n extern tree build_array_ref (tree, tree);\n extern tree build_external_ref (tree, int, location_t);\n extern void pop_maybe_used (bool);\n@@ -542,7 +543,6 @@ extern tree build_conditional_expr (tree, tree, tree);\n extern tree build_compound_expr (tree, tree);\n extern tree c_cast_expr (struct c_type_name *, tree);\n extern tree build_c_cast (tree, tree);\n-extern tree build_modify_expr (tree, enum tree_code, tree);\n extern void store_init_value (tree, tree);\n extern void error_init (const char *);\n extern void pedwarn_init (const char *);\n@@ -577,6 +577,9 @@ extern tree c_finish_goto_ptr (tree);\n extern void c_begin_vm_scope (unsigned int);\n extern void c_end_vm_scope (unsigned int);\n extern tree c_expr_to_decl (tree, bool *, bool *, bool *);\n+extern tree c_begin_omp_parallel (void);\n+extern tree c_finish_omp_parallel (tree, tree);\n+extern tree c_finish_omp_clauses (tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "06ffefd3028258df3490d699d2f43ae615e351cb", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 268, "deletions": 6, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -2931,10 +2931,13 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \n \t/* Report a read-only lvalue.  */\n \tif (TREE_READONLY (arg))\n-\t  readonly_error (arg,\n-\t\t\t  ((code == PREINCREMENT_EXPR\n-\t\t\t    || code == POSTINCREMENT_EXPR)\n-\t\t\t   ? lv_increment : lv_decrement));\n+\t  {\n+\t    readonly_error (arg,\n+\t\t\t    ((code == PREINCREMENT_EXPR\n+\t\t\t      || code == POSTINCREMENT_EXPR)\n+\t\t\t     ? lv_increment : lv_decrement));\n+\t    return error_mark_node;\n+\t  }\n \n \tif (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n \t  val = boolean_increment (code, arg);\n@@ -3645,7 +3648,10 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       || ((TREE_CODE (lhstype) == RECORD_TYPE\n \t   || TREE_CODE (lhstype) == UNION_TYPE)\n \t  && C_TYPE_FIELDS_READONLY (lhstype)))\n-    readonly_error (lhs, lv_assign);\n+    {\n+      readonly_error (lhs, lv_assign);\n+      return error_mark_node;\n+    }\n \n   /* If storing into a structure or union member,\n      it has probably been given type `int'.\n@@ -7310,13 +7316,24 @@ c_finish_bc_stmt (tree *label_p, bool is_break)\n       if (!skip)\n \t*label_p = label = create_artificial_label ();\n     }\n-  else if (TREE_CODE (label) != LABEL_DECL)\n+  else if (TREE_CODE (label) == LABEL_DECL)\n+    ;\n+  else switch (TREE_INT_CST_LOW (label))\n     {\n+    case 0:\n       if (is_break)\n \terror (\"break statement not within loop or switch\");\n       else\n         error (\"continue statement not within a loop\");\n       return NULL_TREE;\n+\n+    case 1:\n+      gcc_assert (is_break);\n+      error (\"break statement used with OpenMP for loop\");\n+      return NULL_TREE;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n \n   if (skip)\n@@ -8443,3 +8460,248 @@ c_expr_to_decl (tree expr, bool *tc ATTRIBUTE_UNUSED,\n   else\n     return expr;\n }\n+\n+\f\n+/* Like c_begin_compound_stmt, except force the retension of the BLOCK.  */\n+\n+tree\n+c_begin_omp_parallel (void)\n+{\n+  tree block;\n+\n+  keep_next_level ();\n+  block = c_begin_compound_stmt (true);\n+\n+  return block;\n+}\n+\n+tree\n+c_finish_omp_parallel (tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = c_end_compound_stmt (block, true);\n+\n+  stmt = make_node (OMP_PARALLEL);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_PARALLEL_CLAUSES (stmt) = clauses;\n+  OMP_PARALLEL_BODY (stmt) = block;\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* For all elements of CLAUSES, validate them vs OpenMP constraints.\n+   Remove any elements from the list that are invalid.  */\n+\n+tree\n+c_finish_omp_clauses (tree clauses)\n+{\n+  bitmap_head generic_head, firstprivate_head, lastprivate_head;\n+  tree c, t, *pc = &clauses;\n+  const char *name;\n+\n+  bitmap_obstack_initialize (NULL);\n+  bitmap_initialize (&generic_head, &bitmap_default_obstack);\n+  bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n+  bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n+\n+  for (pc = &clauses, c = clauses; c ; c = *pc)\n+    {\n+      bool remove = false;\n+      bool need_complete = false;\n+      bool need_implicitly_determined = false;\n+\n+      switch (TREE_CODE (c))\n+\t{\n+\tcase OMP_CLAUSE_SHARED:\n+\t  name = \"shared\";\n+\t  need_implicitly_determined = true;\n+\t  goto check_dup_generic;\n+\n+\tcase OMP_CLAUSE_PRIVATE:\n+\t  name = \"private\";\n+\t  need_complete = true;\n+\t  need_implicitly_determined = true;\n+\t  goto check_dup_generic;\n+\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  name = \"reduction\";\n+\t  need_implicitly_determined = true;\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n+\t      || POINTER_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%qE has invalid type for %<reduction%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (FLOAT_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      enum tree_code r_code = OMP_CLAUSE_REDUCTION_CODE (c);\n+\t      const char *r_name = NULL;\n+\n+\t      switch (r_code)\n+\t\t{\n+\t\tcase PLUS_EXPR:\n+\t\tcase MULT_EXPR:\n+\t\tcase MINUS_EXPR:\n+\t\t  break;\n+\t\tcase BIT_AND_EXPR:\n+\t\t  r_name = \"&\";\n+\t\t  break;\n+\t\tcase BIT_XOR_EXPR:\n+\t\t  r_name = \"^\";\n+\t\t  break;\n+\t\tcase BIT_IOR_EXPR:\n+\t\t  r_name = \"|\";\n+\t\t  break;\n+\t\tcase TRUTH_ANDIF_EXPR:\n+\t\t  r_name = \"&&\";\n+\t\t  break;\n+\t\tcase TRUTH_ORIF_EXPR:\n+\t\t  r_name = \"||\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      if (r_name)\n+\t\t{\n+\t\t  error (\"%qE has invalid type for %<reduction(%s)%>\",\n+\t\t\t t, r_name);\n+\t\t  remove = true;\n+\t\t}\n+\t    }\n+\t  goto check_dup_generic;\n+\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\t  name = \"copyprivate\";\n+\t  goto check_dup_generic;\n+\n+\tcase OMP_CLAUSE_COPYIN:\n+\t  name = \"copyin\";\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != VAR_DECL || !DECL_THREAD_LOCAL_P (t))\n+\t    {\n+\t      error (\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  goto check_dup_generic;\n+\n+\tcheck_dup_generic:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error (\"%qE is not a variable in clause %qs\", t, name);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  name = \"firstprivate\";\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  need_complete = true;\n+\t  need_implicitly_determined = true;\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error (\"%qE is not a variable in clause %<firstprivate%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&firstprivate_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  name = \"lastprivate\";\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  need_complete = true;\n+\t  need_implicitly_determined = true;\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      error (\"%qE is not a variable in clause %<lastprivate%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&lastprivate_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_IF:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\tcase OMP_CLAUSE_NOWAIT:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (!remove)\n+\t{\n+\t  t = OMP_CLAUSE_DECL (c);\n+\n+\t  if (need_complete)\n+\t    {\n+\t      t = require_complete_type (t);\n+\t      if (t == error_mark_node)\n+\t\tremove = true;\n+\t    }\n+\n+\t  if (need_implicitly_determined)\n+\t    {\n+\t      const char *share_name = NULL;\n+\n+\t      if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t\tshare_name = \"threadprivate\";\n+\t      else switch (c_omp_predetermined_sharing (t))\n+\t\t{\n+\t\tcase OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n+\t\t  break;\n+\t\tcase OMP_CLAUSE_DEFAULT_SHARED:\n+\t\t  share_name = \"shared\";\n+\t\t  break;\n+\t\tcase OMP_CLAUSE_DEFAULT_PRIVATE:\n+\t\t  share_name = \"private\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      if (share_name)\n+\t\t{\n+\t\t  error (\"%qE is predetermined %qs for %qs\",\n+\t\t\t t, share_name, name);\n+\t\t  remove = true;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (remove)\n+\t*pc = OMP_CLAUSE_CHAIN (c);\n+      else\n+\tpc = &OMP_CLAUSE_CHAIN (c);\n+    }\n+\n+  bitmap_obstack_release (NULL);\n+  return clauses;\n+}"}, {"sha": "9d11ca6f0522276276543a8f3aa47bdee37f02a1", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -617,6 +617,10 @@ fobjc-sjlj-exceptions\n ObjC ObjC++ Var(flag_objc_sjlj_exceptions) Init(-1)\n Enable Objective-C setjmp exception handling runtime\n \n+fopenmp\n+C ObjC C++ ObjC++ Var(flag_openmp)\n+Enable OpenMP\n+\n foperator-names\n C++ ObjC++\n Recognize C++ kewords like \\\"compl\\\" and \\\"xor\\\""}, {"sha": "4e4add8dd04c902d570c8507cdcc0fadb10fce84", "filename": "gcc/cgraph.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -113,6 +113,9 @@ struct cgraph_node *cgraph_nodes;\n /* Queue of cgraph nodes scheduled to be lowered.  */\n struct cgraph_node *cgraph_nodes_queue;\n \n+/* Queue of cgraph nodes scheduled to be analyzed.  */\n+struct cgraph_node *cgraph_analyze_queue;\n+\n /* Number of nodes in existence.  */\n int cgraph_n_nodes;\n \n@@ -1091,4 +1094,20 @@ cgraph_variable_initializer_availability (struct cgraph_varpool_node *node)\n   return AVAIL_AVAILABLE;\n }\n \n+\n+/* Add the function FNDECL to the call graph.  This assumes that the\n+   body of FNDECL is in GENERIC form and ready to be processed by\n+   cgraph_finalize_function.  */\n+\n+void\n+cgraph_add_new_function (tree fndecl)\n+{\n+  /* We're called while lowering another function.  We can't do anything\n+     at this time without recursing.  Which would cause a GC at an \n+     inappropriate time.  */\n+  struct cgraph_node *n = cgraph_node (fndecl);\n+  n->next_needed = cgraph_analyze_queue;\n+  cgraph_analyze_queue = n;\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "600b00e2193f5a24bcfcf983984d5bc88c32325c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -239,6 +239,7 @@ extern GTY(()) int cgraph_max_uid;\n extern bool cgraph_global_info_ready;\n extern bool cgraph_function_flags_ready;\n extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n+extern GTY(()) struct cgraph_node *cgraph_analyze_queue;\n \n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_first_unanalyzed_node;\n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n@@ -288,12 +289,12 @@ enum availability cgraph_function_body_availability (struct cgraph_node *);\n enum availability cgraph_variable_initializer_availability (struct cgraph_varpool_node *);\n bool cgraph_is_master_clone (struct cgraph_node *);\n struct cgraph_node *cgraph_master_clone (struct cgraph_node *);\n+void cgraph_add_new_function (tree);\n \n /* In cgraphunit.c  */\n bool cgraph_assemble_pending_functions (void);\n bool cgraph_varpool_assemble_pending_decls (void);\n void cgraph_finalize_function (tree, bool);\n-void cgraph_lower_function (struct cgraph_node *);\n void cgraph_finalize_compilation_unit (void);\n void cgraph_optimize (void);\n void cgraph_mark_needed_node (struct cgraph_node *);\n@@ -307,6 +308,7 @@ void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n                                                 varray_type, varray_type);\n+void cgraph_analyze_function (struct cgraph_node *);\n struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n \n /* In ipa.c  */"}, {"sha": "995bcb9c5af1a23049dec73eb8388d8d46ed5ccd", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -171,7 +171,6 @@ static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n static tree record_reference (tree *, int *, void *);\n-static void cgraph_analyze_function (struct cgraph_node *node);\n \n /* Records tree nodes seen in record_reference.  Simply using\n    walk_tree_without_duplicates doesn't guarantee each node is visited\n@@ -410,6 +409,29 @@ cgraph_reset_node (struct cgraph_node *node)\n     }\n }\n \n+static void\n+cgraph_lower_function (struct cgraph_node *node)\n+{\n+  if (node->lowered)\n+    return;\n+  tree_lowering_passes (node->decl);\n+  node->lowered = true;\n+}\n+\n+static void\n+cgraph_finalize_pending_functions (void)\n+{\n+  struct cgraph_node *next, *node = cgraph_analyze_queue;\n+\n+  cgraph_analyze_queue = NULL;\n+  for (; node ; node = next)\n+    {\n+      next = node->next_needed;\n+      node->next_needed = NULL;\n+      cgraph_finalize_function (node->decl, true);\n+    }\n+}\n+\n /* DECL has been parsed.  Take it, queue it, compile it at the whim of the\n    logic in effect.  If NESTED is true, then our caller cannot stand to have\n    the garbage collector run at the moment.  We would need to either create\n@@ -436,6 +458,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   if (!flag_unit_at_a_time)\n     {\n       cgraph_analyze_function (node);\n+      cgraph_finalize_pending_functions ();\n       cgraph_decide_inlining_incrementally (node, false);\n     }\n \n@@ -465,15 +488,6 @@ cgraph_finalize_function (tree decl, bool nested)\n     do_warn_unused_parameter (decl);\n }\n \n-void\n-cgraph_lower_function (struct cgraph_node *node)\n-{\n-  if (node->lowered)\n-    return;\n-  tree_lowering_passes (node->decl);\n-  node->lowered = true;\n-}\n-\n /* Walk tree and record all calls.  Called via walk_tree.  */\n static tree\n record_reference (tree *tp, int *walk_subtrees, void *data)\n@@ -878,7 +892,7 @@ cgraph_output_pending_asms (void)\n }\n \n /* Analyze the function scheduled to be output.  */\n-static void\n+void\n cgraph_analyze_function (struct cgraph_node *node)\n {\n   tree decl = node->decl;\n@@ -968,6 +982,7 @@ cgraph_finalize_compilation_unit (void)\n       gcc_assert (DECL_SAVED_TREE (decl));\n \n       cgraph_analyze_function (node);\n+      cgraph_finalize_pending_functions ();\n \n       for (edge = node->callees; edge; edge = edge->next_callee)\n \tif (!edge->callee->reachable)"}, {"sha": "ddd508e5bb19a9f036b95bb6412efa9fa0ede0c1", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -834,4 +834,10 @@ void add_framework_path (char *);\n \n #define WINT_TYPE \"int\"\n \n+/* Every program on darwin links against libSystem which contains the pthread\n+   routines, so there's no need to explicitly call out when doing threaded\n+   work.  */\n+#undef GOMP_SELF_SPECS\n+#define GOMP_SELF_SPECS \"\"\n+\n #endif /* CONFIG_DARWIN_H */"}, {"sha": "242cf47b42f49c8339bb0c29362e04fb54aa999d", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -203,5 +203,6 @@ extern void print_generic_decl (FILE *, tree, int);\n \n extern void debug_generic_expr (tree);\n extern void debug_generic_stmt (tree);\n+extern void debug_tree_chain (tree);\n extern void debug_c_tree (tree);\n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "629e4a9f4aa1d8ffab9ec803d0f1e512bea7f448", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -765,7 +765,7 @@ See S/390 and zSeries Options.\n -fargument-noalias-global  -fleading-underscore @gol\n -ftls-model=@var{model} @gol\n -ftrapv  -fwrapv  -fbounds-check @gol\n--fvisibility}\n+-fvisibility  -fopenmp}\n @end table\n \n @menu\n@@ -4701,6 +4701,15 @@ instrumentation (and therefore faster execution) and still provides\n some protection against outright memory corrupting writes, but allows\n erroneously read data to propagate within a program.\n \n+@item -fopenmp\n+@opindex fopenmp\n+@cindex openmp parallel\n+Enable handling of OpenMP directives @code{#pragma omp} in C/C++ and\n+@code{!$omp} in Fortran.  When @option{-fopenmp} is specified, the\n+compiler generates parallel code according to the OpenMP Application\n+Program Interface v2.5.  To generate the final exectuable, the runtime\n+library @code{libgomp} must be linked in using @option{-lgomp}.\n+\n @item -fstrength-reduce\n @opindex fstrength-reduce\n Perform the optimizations of loop strength reduction and"}, {"sha": "87d92e833e1a7775957d4538917a09995a320267", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -9015,7 +9015,6 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n {\n   dw_loc_descr_ref ret, ret1;\n   int have_address = 0;\n-  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));\n   enum dwarf_location_atom op;\n \n   /* ??? Most of the time we do not take proper care for sign/zero\n@@ -9159,6 +9158,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \tHOST_WIDE_INT bitsize, bitpos, bytepos;\n \tenum machine_mode mode;\n \tint volatilep;\n+\tint unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));\n \n \tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n \t\t\t\t   &unsignedp, &volatilep, false);\n@@ -9257,7 +9257,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       goto do_binop;\n \n     case RSHIFT_EXPR:\n-      op = (unsignedp ? DW_OP_shr : DW_OP_shra);\n+      op = (TYPE_UNSIGNED (TREE_TYPE (loc)) ? DW_OP_shr : DW_OP_shra);\n       goto do_binop;\n \n     case PLUS_EXPR:"}, {"sha": "bff3ae8de4cf48cef60a22f23e51b407dce05109", "filename": "gcc/gcc.c", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -352,6 +352,7 @@ static const char *if_exists_spec_function (int, const char **);\n static const char *if_exists_else_spec_function (int, const char **);\n static const char *replace_outfile_spec_function (int, const char **);\n static const char *version_compare_spec_function (int, const char **);\n+static const char *include_spec_function (int, const char **);\n \f\n /* The Specs Language\n \n@@ -698,7 +699,8 @@ proper position among the other output files.  */\n %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\\\n     %(linker) %l \" LINK_PIE_SPEC \"%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\\\n     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n-    %{static:} %{L*} %(mfwrap) %(link_libgcc) %o %(mflib)\\\n+    %{static:} %{L*} %(mfwrap) %{fopenmp:%:include(libgomp.spec)%(link_gomp)}\\\n+    %(link_libgcc) %o %(mflib)\\\n     %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\\\n     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\\\n     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}\"\n@@ -737,6 +739,7 @@ static const char *link_spec = LINK_SPEC;\n static const char *lib_spec = LIB_SPEC;\n static const char *mfwrap_spec = MFWRAP_SPEC;\n static const char *mflib_spec = MFLIB_SPEC;\n+static const char *link_gomp_spec = \"\";\n static const char *libgcc_spec = LIBGCC_SPEC;\n static const char *endfile_spec = ENDFILE_SPEC;\n static const char *startfile_spec = STARTFILE_SPEC;\n@@ -835,7 +838,15 @@ static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n #define DRIVER_SELF_SPECS \"\"\n #endif\n \n-static const char *const driver_self_specs[] = { DRIVER_SELF_SPECS };\n+/* Adding -fopenmp should imply pthreads.  This is particularly important\n+   for targets that use different start files and suchlike.  */\n+#ifndef GOMP_SELF_SPECS\n+#define GOMP_SELF_SPECS \"%{fopenmp: -pthread}\"\n+#endif\n+\n+static const char *const driver_self_specs[] = {\n+  DRIVER_SELF_SPECS, GOMP_SELF_SPECS\n+};\n \n #ifndef OPTION_DEFAULT_SPECS\n #define OPTION_DEFAULT_SPECS { \"\", \"\" }\n@@ -1534,6 +1545,7 @@ static struct spec_list static_specs[] =\n   INIT_STATIC_SPEC (\"lib\",\t\t\t&lib_spec),\n   INIT_STATIC_SPEC (\"mfwrap\",\t\t\t&mfwrap_spec),\n   INIT_STATIC_SPEC (\"mflib\",\t\t\t&mflib_spec),\n+  INIT_STATIC_SPEC (\"link_gomp\",\t\t&link_gomp_spec),\n   INIT_STATIC_SPEC (\"libgcc\",\t\t\t&libgcc_spec),\n   INIT_STATIC_SPEC (\"startfile\",\t\t&startfile_spec),\n   INIT_STATIC_SPEC (\"switches_need_spaces\",\t&switches_need_spaces),\n@@ -1581,6 +1593,7 @@ static const struct spec_function static_spec_functions[] =\n   { \"if-exists-else\",\t\tif_exists_else_spec_function },\n   { \"replace-outfile\",\t\treplace_outfile_spec_function },\n   { \"version-compare\",\t\tversion_compare_spec_function },\n+  { \"include\",\t\t\tinclude_spec_function },\n   { 0, 0 }\n };\n \n@@ -3281,11 +3294,11 @@ process_command (int argc, const char **argv)\n     }\n \n   /* If there is a -V or -b option (or both), process it now, before\n-     trying to interpret the rest of the command line. \n+     trying to interpret the rest of the command line.\n      Use heuristic that all configuration names must have at least\n      one dash '-'. This allows us to pass options starting with -b.  */\n   if (argc > 1 && argv[1][0] == '-'\n-      && (argv[1][1] == 'V' || \n+      && (argv[1][1] == 'V' ||\n \t ((argv[1][1] == 'b') && (NULL != strchr(argv[1] + 2,'-')))))\n     {\n       const char *new_version = DEFAULT_TARGET_VERSION;\n@@ -5518,10 +5531,10 @@ input_suffix_matches (const char *atom, const char *end_atom)\n \t  && input_suffix[end_atom - atom] == '\\0');\n }\n \n-/* Inline subroutine of handle_braces.  Returns true if a switch\n+/* Subroutine of handle_braces.  Returns true if a switch\n    matching the atom bracketed by ATOM and END_ATOM appeared on the\n    command line.  */\n-static inline bool\n+static bool\n switch_matches (const char *atom, const char *end_atom, int starred)\n {\n   int i;\n@@ -6458,7 +6471,7 @@ main (int argc, char **argv)\n   if (combine_flag)\n     combine_inputs = true;\n   else\n-    combine_inputs = false;  \n+    combine_inputs = false;\n \n   for (i = 0; (int) i < n_infiles; i++)\n     {\n@@ -6489,7 +6502,7 @@ main (int argc, char **argv)\n       infiles[i].compiled = false;\n       infiles[i].preprocessed = false;\n     }\n-    \n+\n   if (!combine_inputs && have_c && have_o && lang_n_infiles > 1)\n    fatal (\"cannot specify -o with -c or -S with multiple files\");\n \n@@ -7780,3 +7793,22 @@ version_compare_spec_function (int argc, const char **argv)\n \n   return argv[nargs + 2];\n }\n+\n+/* %:include builtin spec function.  This differs from %include in that it\n+   can be nested inside a spec, and thus be conditionalized.  It takes\n+   one argument, the filename, and looks for it in the startfile path.\n+   The result is always NULL, i.e. an empty expansion.  */\n+\n+static const char *\n+include_spec_function (int argc, const char **argv)\n+{\n+  char *file;\n+\n+  if (argc != 1)\n+    abort ();\n+\n+  file = find_a_file (&startfile_prefixes, argv[0], R_OK, 0);\n+  read_specs (file ? file : argv[0], FALSE);\n+\n+  return NULL;\n+}"}, {"sha": "2a49eedfd6b11d04f069f8f1b74c9a7876896990", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -69,13 +69,12 @@ lower_function_body (void)\n \n   gcc_assert (TREE_CODE (bind) == BIND_EXPR);\n \n+  memset (&data, 0, sizeof (data));\n   data.block = DECL_INITIAL (current_function_decl);\n   BLOCK_SUBBLOCKS (data.block) = NULL_TREE;\n   BLOCK_CHAIN (data.block) = NULL_TREE;\n   TREE_ASM_WRITTEN (data.block) = 1;\n \n-  data.return_statements = NULL_TREE;\n-\n   *body_p = alloc_stmt_list ();\n   i = tsi_start (*body_p);\n   tsi_link_after (&i, bind, TSI_NEW_STMT);\n@@ -196,11 +195,6 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n       break;\n \n     default:\n-#ifdef ENABLE_CHECKING\n-      print_node_brief (stderr, \"\", stmt, 0);\n-      internal_error (\"unexpected node\");\n-#endif\n-    case COMPOUND_EXPR:\n       gcc_unreachable ();\n     }\n "}, {"sha": "acd0468a3386ca84850a75883be0d596fcf13e62", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1208, "deletions": 24, "changes": 1232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -46,21 +46,67 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"target.h\"\n+#include \"optabs.h\"\n+#include \"pointer-set.h\"\n \n-static struct gimplify_ctx\n+\n+enum gimplify_omp_var_data\n+{\n+  GOVD_SEEN = 1,\n+  GOVD_EXPLICIT = 2,\n+  GOVD_SHARED = 4,\n+  GOVD_PRIVATE = 8,\n+  GOVD_FIRSTPRIVATE = 16,\n+  GOVD_LASTPRIVATE = 32,\n+  GOVD_REDUCTION = 64,\n+  GOVD_LOCAL = 128,\n+  GOVD_DEBUG_PRIVATE = 256,\n+  GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n+\t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LOCAL)\n+};\n+\n+struct gimplify_omp_ctx\n {\n+  struct gimplify_omp_ctx *outer_context;\n+  splay_tree variables;\n+  struct pointer_set_t *privatized_types;\n+  location_t location;\n+  enum omp_clause_default_kind default_kind;\n+  bool is_parallel;\n+};\n+\n+struct gimplify_ctx\n+{\n+  struct gimplify_ctx *prev_context;\n+\n   tree current_bind_expr;\n   tree temps;\n   tree conditional_cleanups;\n   tree exit_label;\n   tree return_temp;\n+  \n   VEC(tree,heap) *case_labels;\n   /* The formal temporary table.  Should this be persistent?  */\n   htab_t temp_htab;\n+\n   int conditions;\n   bool save_stack;\n   bool into_ssa;\n-} *gimplify_ctxp;\n+\n+  /* When gimplifying combined omp parallel directives (omp parallel\n+     loop and omp parallel sections), any prefix code needed to setup\n+     the associated worksharing construct needs to be emitted in the\n+     pre-queue of its parent parallel, otherwise the lowering process\n+     will move that code to the child function.  Similarly, we need to\n+     move up to the gimplification context of the parent parallel\n+     directive so temporaries are declared in the right context.  */\n+  tree *combined_pre_p;\n+  struct gimplify_ctx *combined_ctxp;\n+};\n+\n+static struct gimplify_ctx *gimplify_ctxp;\n+static struct gimplify_omp_ctx *gimplify_omp_ctxp;\n+\n \n \n /* Formal (expression) temporary table handling: Multiple occurrences of\n@@ -116,14 +162,14 @@ gimple_tree_eq (const void *p1, const void *p2)\n void\n push_gimplify_context (void)\n {\n-  gcc_assert (!gimplify_ctxp);\n-  gimplify_ctxp\n-    = (struct gimplify_ctx *) xcalloc (1, sizeof (struct gimplify_ctx));\n+  struct gimplify_ctx *c;\n+\n+  c = (struct gimplify_ctx *) xcalloc (1, sizeof (struct gimplify_ctx));\n+  c->prev_context = gimplify_ctxp;\n   if (optimize)\n-    gimplify_ctxp->temp_htab\n-      = htab_create (1000, gimple_tree_hash, gimple_tree_eq, free);\n-  else\n-    gimplify_ctxp->temp_htab = NULL;\n+    c->temp_htab = htab_create (1000, gimple_tree_hash, gimple_tree_eq, free);\n+\n+  gimplify_ctxp = c;\n }\n \n /* Tear down a context for the gimplifier.  If BODY is non-null, then\n@@ -133,28 +179,23 @@ push_gimplify_context (void)\n void\n pop_gimplify_context (tree body)\n {\n+  struct gimplify_ctx *c = gimplify_ctxp;\n   tree t;\n \n-  gcc_assert (gimplify_ctxp && !gimplify_ctxp->current_bind_expr);\n+  gcc_assert (c && !c->current_bind_expr);\n+  gimplify_ctxp = c->prev_context;\n \n-  for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n+  for (t = c->temps; t ; t = TREE_CHAIN (t))\n     DECL_GIMPLE_FORMAL_TEMP_P (t) = 0;\n \n   if (body)\n-    declare_tmp_vars (gimplify_ctxp->temps, body);\n+    declare_tmp_vars (c->temps, body);\n   else\n-    record_vars (gimplify_ctxp->temps);\n-\n-#if 0\n-  if (!quiet_flag && optimize)\n-    fprintf (stderr, \" collisions: %f \",\n-\t     htab_collisions (gimplify_ctxp->temp_htab));\n-#endif\n+    record_vars (c->temps);\n \n   if (optimize)\n-    htab_delete (gimplify_ctxp->temp_htab);\n-  free (gimplify_ctxp);\n-  gimplify_ctxp = NULL;\n+    htab_delete (c->temp_htab);\n+  free (c);\n }\n \n static void\n@@ -214,6 +255,48 @@ gimple_pop_condition (tree *pre_p)\n     }\n }\n \n+/* A stable comparison routine for use with splay trees and DECLs.  */\n+\n+static int\n+splay_tree_compare_decl_uid (splay_tree_key xa, splay_tree_key xb)\n+{\n+  tree a = (tree) xa;\n+  tree b = (tree) xb;\n+\n+  return DECL_UID (a) - DECL_UID (b);\n+}\n+\n+/* Create a new omp construct that deals with variable remapping.  */\n+\n+static struct gimplify_omp_ctx *\n+new_omp_context (bool is_parallel)\n+{\n+  struct gimplify_omp_ctx *c;\n+\n+  c = XCNEW (struct gimplify_omp_ctx);\n+  c->outer_context = gimplify_omp_ctxp;\n+  c->variables = splay_tree_new (splay_tree_compare_decl_uid, 0, 0);\n+  c->privatized_types = pointer_set_create ();\n+  c->location = input_location;\n+  c->is_parallel = is_parallel;\n+  c->default_kind = OMP_CLAUSE_DEFAULT_SHARED;\n+\n+  return c;\n+}\n+\n+/* Destroy an omp construct that deals with variable remapping.  */\n+\n+static void\n+delete_omp_context (struct gimplify_omp_ctx *c)\n+{\n+  splay_tree_delete (c->variables);\n+  pointer_set_destroy (c->privatized_types);\n+  XDELETE (c);\n+}\n+\n+static void omp_add_variable (struct gimplify_omp_ctx *, tree, unsigned int);\n+static bool omp_notice_variable (struct gimplify_omp_ctx *, tree, bool);\n+\n /* A subroutine of append_to_statement_list{,_force}.  T is not NULL.  */\n \n static void\n@@ -601,6 +684,16 @@ gimple_add_tmp_var (tree tmp)\n     {\n       TREE_CHAIN (tmp) = gimplify_ctxp->temps;\n       gimplify_ctxp->temps = tmp;\n+\n+      /* Mark temporaries local within the nearest enclosing parallel.  */\n+      if (gimplify_omp_ctxp)\n+\t{\n+\t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+\t  while (ctx && !ctx->is_parallel)\n+\t    ctx = ctx->outer_context;\n+\t  if (ctx)\n+\t    omp_add_variable (ctx, tmp, GOVD_LOCAL | GOVD_SEEN);\n+\t}\n     }\n   else if (cfun)\n     record_vars (tmp);\n@@ -933,6 +1026,16 @@ gimplify_bind_expr (tree *expr_p, tree temp, tree *pre_p)\n \tDECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n     }\n \n+  /* Mark variables seen in this bind expr as locals.  */\n+  if (gimplify_omp_ctxp)\n+    {\n+      struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+\n+      for (t = BIND_EXPR_VARS (bind_expr); t ; t = TREE_CHAIN (t))\n+\tif (TREE_CODE (t) == VAR_DECL && !is_global_var (t))\n+\t  omp_add_variable (ctx, t, GOVD_LOCAL | GOVD_SEEN);\n+    }\n+\n   gimple_push_bind_expr (bind_expr);\n   gimplify_ctxp->save_stack = false;\n \n@@ -1282,9 +1385,16 @@ static enum gimplify_status\n gimplify_case_label_expr (tree *expr_p)\n {\n   tree expr = *expr_p;\n+  struct gimplify_ctx *ctxp;\n+\n+  /* Invalid OpenMP programs can play Duff's Device type games with\n+     #pragma omp parallel.  At least in the C front end, we don't\n+     detect such invalid branches until after gimplification.  */\n+  for (ctxp = gimplify_ctxp; ; ctxp = ctxp->prev_context)\n+    if (ctxp->case_labels)\n+      break;\n \n-  gcc_assert (gimplify_ctxp->case_labels);\n-  VEC_safe_push (tree, heap, gimplify_ctxp->case_labels, expr);\n+  VEC_safe_push (tree, heap, ctxp->case_labels, expr);\n   *expr_p = build1 (LABEL_EXPR, void_type_node, CASE_LABEL (expr));\n   return GS_ALL_DONE;\n }\n@@ -1491,6 +1601,10 @@ gimplify_var_or_parm_decl (tree *expr_p)\n       return GS_ERROR;\n     }\n \n+  /* When within an OpenMP context, notice uses of variables.  */\n+  if (gimplify_omp_ctxp && omp_notice_variable (gimplify_omp_ctxp, decl, true))\n+    return GS_ALL_DONE;\n+\n   /* If the decl is an alias for another expression, substitute it now.  */\n   if (DECL_HAS_VALUE_EXPR_P (decl))\n     {\n@@ -4017,6 +4131,1049 @@ gimplify_to_stmt_list (tree *stmt_p)\n     }\n }\n \n+/* Gimplify *EXPR_P as if it had been used inside the gimplification\n+   context CTX_P.  The other arguments are as in gimplify_expr.  */\n+\n+static enum gimplify_status\n+gimplify_expr_in_ctx (tree *expr_p, tree *pre_p, tree *post_p, \n+\t\t      bool (* gimple_test_f) (tree), fallback_t fallback,\n+\t\t      struct gimplify_ctx *ctx_p,\n+\t\t      struct gimplify_omp_ctx *omp_ctx_p)\n+{\n+  enum gimplify_status ret;\n+  struct gimplify_ctx *prev_ctxp;\n+  struct gimplify_omp_ctx *prev_omp_ctxp;\n+  \n+  prev_ctxp = gimplify_ctxp;\n+  gimplify_ctxp = ctx_p;\n+  prev_omp_ctxp = gimplify_omp_ctxp;\n+  gimplify_omp_ctxp = omp_ctx_p;\n+  ret = gimplify_expr (expr_p, pre_p, post_p, gimple_test_f, fallback);\n+  gimplify_ctxp = prev_ctxp;\n+  gimplify_omp_ctxp = prev_omp_ctxp;\n+\n+  return ret;\n+}\n+\n+/* Add FIRSTPRIVATE entries for DECL in the OpenMP the surrounding parallels\n+   to CTX.  If entries already exist, force them to be some flavor of private.\n+   If there is no enclosing parallel, do nothing.  */\n+\n+void\n+omp_firstprivatize_variable (struct gimplify_omp_ctx *ctx, tree decl)\n+{\n+  splay_tree_node n;\n+\n+  if (decl == NULL || !DECL_P (decl))\n+    return;\n+\n+  do\n+    {\n+      n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n+      if (n != NULL)\n+\t{\n+\t  if (n->value & GOVD_SHARED)\n+\t    n->value = GOVD_FIRSTPRIVATE | (n->value & GOVD_SEEN);\n+\t  else\n+\t    return;\n+\t}\n+      else if (ctx->is_parallel)\n+\tomp_add_variable (ctx, decl, GOVD_FIRSTPRIVATE);\n+\n+      ctx = ctx->outer_context;\n+    }\n+  while (ctx);\n+}\n+\n+/* Similarly for each of the type sizes of TYPE.  */\n+\n+static void\n+omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *ctx, tree type)\n+{\n+  if (type == NULL || type == error_mark_node)\n+    return;\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  if (pointer_set_insert (ctx->privatized_types, type))\n+    return;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+    case REAL_TYPE:\n+      omp_firstprivatize_variable (ctx, TYPE_MIN_VALUE (type));\n+      omp_firstprivatize_variable (ctx, TYPE_MAX_VALUE (type));\n+      break;\n+\n+    case ARRAY_TYPE:\n+      omp_firstprivatize_type_sizes (ctx, TREE_TYPE (type));\n+      omp_firstprivatize_type_sizes (ctx, TYPE_DOMAIN (type));\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree field;\n+\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  if (TREE_CODE (field) == FIELD_DECL)\n+\t    {\n+\t      omp_firstprivatize_variable (ctx, DECL_FIELD_OFFSET (field));\n+\t      omp_firstprivatize_type_sizes (ctx, TREE_TYPE (field));\n+\t    }\n+      }\n+      break;\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      omp_firstprivatize_type_sizes (ctx, TREE_TYPE (type));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  omp_firstprivatize_variable (ctx, TYPE_SIZE (type));\n+  omp_firstprivatize_variable (ctx, TYPE_SIZE_UNIT (type));\n+  lang_hooks.types.omp_firstprivatize_type_sizes (ctx, type);\n+}\n+\n+/* Add an entry for DECL in the OpenMP context CTX with FLAGS.  */\n+\n+static void\n+omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n+{\n+  splay_tree_node n;\n+  unsigned int nflags;\n+  tree t;\n+\n+  if (decl == error_mark_node || TREE_TYPE (decl) == error_mark_node)\n+    return;\n+\n+  /* Never elide decls whose type has TREE_ADDRESSABLE set.  This means\n+     there are constructors involved somewhere.  */\n+  if (TREE_ADDRESSABLE (TREE_TYPE (decl))\n+      || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+    flags |= GOVD_SEEN;\n+\n+  n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n+  if (n != NULL)\n+    {\n+      /* We shouldn't be re-adding the decl with the same data\n+\t sharing class.  */\n+      gcc_assert ((n->value & GOVD_DATA_SHARE_CLASS & flags) == 0);\n+      /* The only combination of data sharing classes we should see is\n+\t FIRSTPRIVATE and LASTPRIVATE.  */\n+      nflags = n->value | flags;\n+      gcc_assert ((nflags & GOVD_DATA_SHARE_CLASS)\n+\t\t  == (GOVD_FIRSTPRIVATE | GOVD_LASTPRIVATE));\n+      n->value = nflags;\n+      return;\n+    }\n+\n+  /* When adding a variable-sized variable, we have to handle all sorts\n+     of additional bits of data: the pointer replacement variable, and \n+     the parameters of the type.  */\n+  if (!TREE_CONSTANT (DECL_SIZE (decl)))\n+    {\n+      /* Add the pointer replacement variable as PRIVATE if the variable\n+\t replacement is private, else FIRSTPRIVATE since we'll need the\n+\t address of the original variable either for SHARED, or for the\n+\t copy into or out of the context.  */\n+      if (!(flags & GOVD_LOCAL))\n+\t{\n+\t  nflags = flags & GOVD_PRIVATE ? GOVD_PRIVATE : GOVD_FIRSTPRIVATE;\n+\t  nflags |= flags & GOVD_SEEN;\n+\t  t = DECL_VALUE_EXPR (decl);\n+\t  gcc_assert (TREE_CODE (t) == INDIRECT_REF);\n+\t  t = TREE_OPERAND (t, 0);\n+\t  gcc_assert (DECL_P (t));\n+\t  omp_add_variable (ctx, t, nflags);\n+\t}\n+\n+      /* Add all of the variable and type parameters (which should have\n+\t been gimplified to a formal temporary) as FIRSTPRIVATE.  */\n+      omp_firstprivatize_variable (ctx, DECL_SIZE_UNIT (decl));\n+      omp_firstprivatize_variable (ctx, DECL_SIZE (decl));\n+      omp_firstprivatize_type_sizes (ctx, TREE_TYPE (decl));\n+\n+      /* The variable-sized variable itself is never SHARED, only some form\n+\t of PRIVATE.  The sharing would take place via the pointer variable\n+\t which we remapped above.  */\n+      if (flags & GOVD_SHARED)\n+\tflags = GOVD_PRIVATE | GOVD_DEBUG_PRIVATE\n+\t\t| (flags & (GOVD_SEEN | GOVD_EXPLICIT));\n+\n+      /* We're going to make use of the TYPE_SIZE_UNIT at least in the \n+\t alloca statement we generate for the variable, so make sure it\n+\t is available.  This isn't automatically needed for the SHARED\n+\t case, since we won't be allocating local storage then.  */\n+      else\n+\tomp_notice_variable (ctx, TYPE_SIZE_UNIT (TREE_TYPE (decl)), true);\n+    }\n+  else if (lang_hooks.decls.omp_privatize_by_reference (decl))\n+    {\n+      gcc_assert ((flags & GOVD_LOCAL) == 0);\n+      omp_firstprivatize_type_sizes (ctx, TREE_TYPE (decl));\n+\n+      /* Similar to the direct variable sized case above, we'll need the\n+\t size of references being privatized.  */\n+      if ((flags & GOVD_SHARED) == 0)\n+\t{\n+\t  t = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (decl)));\n+\t  if (!TREE_CONSTANT (t))\n+\t    omp_notice_variable (ctx, t, true);\n+\t}\n+    }\n+\n+  splay_tree_insert (ctx->variables, (splay_tree_key)decl, flags);\n+}\n+\n+/* Record the fact that DECL was used within the OpenMP context CTX.\n+   IN_CODE is true when real code uses DECL, and false when we should\n+   merely emit default(none) errors.  Return true if DECL is going to\n+   be remapped and thus DECL shouldn't be gimplified into its\n+   DECL_VALUE_EXPR (if any).  */\n+\n+static bool\n+omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n+{\n+  splay_tree_node n;\n+  unsigned flags = in_code ? GOVD_SEEN : 0;\n+  bool ret = false, shared;\n+\n+  if (decl == error_mark_node || TREE_TYPE (decl) == error_mark_node)\n+    return false;\n+\n+  /* Threadprivate variables are predetermined.  */\n+  if (is_global_var (decl))\n+    {\n+      if (DECL_THREAD_LOCAL_P (decl))\n+\treturn false;\n+\n+      if (DECL_HAS_VALUE_EXPR_P (decl))\n+\t{\n+\t  tree value = get_base_address (DECL_VALUE_EXPR (decl));\n+\n+\t  if (value && DECL_P (value) && DECL_THREAD_LOCAL_P (value))\n+\t    return false;\n+\t}\n+    }\n+\n+  n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n+  if (n == NULL)\n+    {\n+      enum omp_clause_default_kind default_kind, kind;\n+\n+      if (!ctx->is_parallel)\n+\tgoto do_outer;\n+\n+      /* ??? Some compiler-generated variables (like SAVE_EXPRs) could be\n+\t remapped firstprivate instead of shared.  To some extent this is\n+\t addressed in omp_firstprivatize_type_sizes, but not effectively.  */\n+      default_kind = ctx->default_kind;\n+      kind = lang_hooks.decls.omp_predetermined_sharing (decl);\n+      if (kind != OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n+\tdefault_kind = kind;\n+\n+      switch (default_kind)\n+\t{\n+\tcase OMP_CLAUSE_DEFAULT_NONE:\n+\t  error (\"%qs not specified in enclosing parallel\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t  error (\"%Henclosing parallel\", &ctx->location);\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_DEFAULT_SHARED:\n+\t  flags |= GOVD_SHARED;\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULT_PRIVATE:\n+\t  flags |= GOVD_PRIVATE;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      omp_add_variable (ctx, decl, flags);\n+\n+      shared = (flags & GOVD_SHARED) != 0;\n+      ret = lang_hooks.decls.omp_disregard_value_expr (decl, shared);\n+      goto do_outer;\n+    }\n+\n+  shared = ((flags | n->value) & GOVD_SHARED) != 0;\n+  ret = lang_hooks.decls.omp_disregard_value_expr (decl, shared);\n+\n+  /* If nothing changed, there's nothing left to do.  */\n+  if ((n->value & flags) == flags)\n+    return ret;\n+  flags |= n->value;\n+  n->value = flags;\n+\n+ do_outer:\n+  /* If the variable is private in the current context, then we don't\n+     need to propagate anything to an outer context.  */\n+  if (flags & GOVD_PRIVATE)\n+    return ret;\n+  if (ctx->outer_context\n+      && omp_notice_variable (ctx->outer_context, decl, in_code))\n+    return true;\n+  return ret;\n+}\n+\n+/* Verify that DECL is private within CTX.  If there's specific information\n+   to the contrary in the innermost scope, generate an error.  */\n+\n+static bool\n+omp_is_private (struct gimplify_omp_ctx *ctx, tree decl)\n+{\n+  splay_tree_node n;\n+\n+  n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n+  if (n != NULL)\n+    {\n+      if (n->value & GOVD_SHARED)\n+\t{\n+\t  if (ctx == gimplify_omp_ctxp)\n+\t    error (\"iteration variable %qs should be private\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t  n->value = GOVD_PRIVATE;\n+\t}\n+      return true;\n+    }\n+\n+  if (ctx->outer_context)\n+    return omp_is_private (ctx->outer_context, decl);\n+  else if (ctx->is_parallel)\n+    return false;\n+  else\n+    return !is_global_var (decl);\n+}\n+\n+/* Scan the OpenMP clauses in *LIST_P, installing mappings into a new\n+   and previous omp contexts.  */\n+\n+static void\n+gimplify_scan_omp_clauses (tree *list_p, tree *pre_p, bool in_parallel)\n+{\n+  struct gimplify_omp_ctx *ctx, *outer_ctx;\n+  tree c;\n+\n+  ctx = new_omp_context (in_parallel);\n+  outer_ctx = ctx->outer_context;\n+\n+  while ((c = *list_p) != NULL)\n+    {\n+      enum gimplify_status gs;\n+      bool remove = false;\n+      bool notice_outer = true;\n+      unsigned int flags;\n+      tree decl;\n+\n+      switch (TREE_CODE (c))\n+\t{\n+\tcase OMP_CLAUSE_PRIVATE:\n+\t  flags = GOVD_PRIVATE | GOVD_EXPLICIT;\n+\t  notice_outer = false;\n+\t  goto do_add;\n+\tcase OMP_CLAUSE_SHARED:\n+\t  flags = GOVD_SHARED | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  flags = GOVD_FIRSTPRIVATE | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  flags = GOVD_LASTPRIVATE | GOVD_SEEN | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  flags = GOVD_REDUCTION | GOVD_SEEN | GOVD_EXPLICIT;\n+\t  goto do_add;\n+\n+\tdo_add:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (decl == error_mark_node || TREE_TYPE (decl) == error_mark_node)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\t  omp_add_variable (ctx, decl, flags);\n+\t  if (TREE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t      && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t    {\n+\t      omp_add_variable (ctx, OMP_CLAUSE_REDUCTION_PLACEHOLDER (c),\n+\t\t\t\tGOVD_LOCAL);\n+\t      gimplify_omp_ctxp = ctx;\n+\t      push_gimplify_context ();\n+\t      gimplify_stmt (&OMP_CLAUSE_REDUCTION_INIT (c));\n+\t      pop_gimplify_context (OMP_CLAUSE_REDUCTION_INIT (c));\n+\t      push_gimplify_context ();\n+\t      gimplify_stmt (&OMP_CLAUSE_REDUCTION_MERGE (c));\n+\t      pop_gimplify_context (OMP_CLAUSE_REDUCTION_MERGE (c));\n+\t      gimplify_omp_ctxp = outer_ctx;\n+\t    }\n+\t  if (notice_outer)\n+\t    goto do_notice;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_COPYIN:\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (decl == error_mark_node || TREE_TYPE (decl) == error_mark_node)\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n+\tdo_notice:\n+\t  if (outer_ctx)\n+\t    omp_notice_variable (outer_ctx, decl, true);\n+\t  break;\n+\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  if (gimplify_ctxp->combined_pre_p)\n+\t    {\n+\t      gcc_assert (gimplify_omp_ctxp == outer_ctx);\n+\t      gs = gimplify_expr_in_ctx (&OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c),\n+\t\t\t\t\t gimplify_ctxp->combined_pre_p, NULL,\n+\t\t\t\t\t is_gimple_val, fb_rvalue,\n+\t\t\t\t\t gimplify_ctxp->combined_ctxp,\n+\t\t\t\t\t outer_ctx->outer_context);\n+\t      if (gs == GS_ERROR)\n+\t\tremove = true;\n+\t      break;\n+\t    }\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_IF:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\t  gs = gimplify_expr (&TREE_OPERAND (c, 0), pre_p, NULL,\n+\t\t\t      is_gimple_val, fb_rvalue);\n+\t  if (gs == GS_ERROR)\n+\t    remove = true;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NOWAIT:\n+\tcase OMP_CLAUSE_ORDERED:\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  ctx->default_kind = OMP_CLAUSE_DEFAULT_KIND (c);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (remove)\n+\t*list_p = OMP_CLAUSE_CHAIN (c);\n+      else\n+\tlist_p = &OMP_CLAUSE_CHAIN (c);\n+    }\n+\n+  gimplify_omp_ctxp = ctx;\n+}\n+\n+/* For all variables that were not actually used within the context,\n+   remove PRIVATE, SHARED, and FIRSTPRIVATE clauses.  */\n+\n+static int\n+gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n+{\n+  tree *list_p = (tree *) data;\n+  tree decl = (tree) n->key;\n+  unsigned flags = n->value;\n+  enum tree_code code;\n+  tree clause;\n+  bool private_debug;\n+\n+  if (flags & (GOVD_EXPLICIT | GOVD_LOCAL))\n+    return 0;\n+  if ((flags & GOVD_SEEN) == 0)\n+    return 0;\n+  if (flags & GOVD_DEBUG_PRIVATE)\n+    {\n+      gcc_assert ((flags & GOVD_DATA_SHARE_CLASS) == GOVD_PRIVATE);\n+      private_debug = true;\n+    }\n+  else\n+    private_debug\n+      = lang_hooks.decls.omp_private_debug_clause (decl,\n+\t\t\t\t\t\t   !!(flags & GOVD_SHARED));\n+  if (private_debug)\n+    code = OMP_CLAUSE_PRIVATE;\n+  else if (flags & GOVD_SHARED)\n+    {\n+      if (is_global_var (decl))\n+\treturn 0;\n+      code = OMP_CLAUSE_SHARED;\n+    }\n+  else if (flags & GOVD_PRIVATE)\n+    code = OMP_CLAUSE_PRIVATE;\n+  else if (flags & GOVD_FIRSTPRIVATE)\n+    code = OMP_CLAUSE_FIRSTPRIVATE;\n+  else\n+    gcc_unreachable ();\n+\n+  clause = build1 (code, void_type_node, decl);\n+  OMP_CLAUSE_CHAIN (clause) = *list_p;\n+  if (private_debug)\n+    OMP_CLAUSE_PRIVATE_DEBUG (clause) = 1;\n+  *list_p = clause;\n+\n+  return 0;\n+}\n+\n+static void\n+gimplify_adjust_omp_clauses (tree *list_p)\n+{\n+  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n+  tree c, decl;\n+\n+  while ((c = *list_p) != NULL)\n+    {\n+      splay_tree_node n;\n+      bool remove = false;\n+\n+      switch (TREE_CODE (c))\n+\t{\n+\tcase OMP_CLAUSE_PRIVATE:\n+\tcase OMP_CLAUSE_SHARED:\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t  remove = !(n->value & GOVD_SEEN);\n+\t  if (! remove)\n+\t    {\n+\t      bool shared = TREE_CODE (c) == OMP_CLAUSE_SHARED;\n+\t      if ((n->value & GOVD_DEBUG_PRIVATE)\n+\t\t  || lang_hooks.decls.omp_private_debug_clause (decl, shared))\n+\t\t{\n+\t\t  gcc_assert ((n->value & GOVD_DEBUG_PRIVATE) == 0\n+\t\t\t      || ((n->value & GOVD_DATA_SHARE_CLASS)\n+\t\t\t\t  == GOVD_PRIVATE));\n+\t\t  TREE_SET_CODE (c, OMP_CLAUSE_PRIVATE);\n+\t\t  OMP_CLAUSE_PRIVATE_DEBUG (c) = 1;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  /* Make sure OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE is set to\n+\t     accurately reflect the presence of a FIRSTPRIVATE clause.  */\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n+\t  OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c)\n+\t    = (n->value & GOVD_FIRSTPRIVATE) != 0;\n+\t  break;\n+\t  \n+\tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_COPYIN:\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\tcase OMP_CLAUSE_IF:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\tcase OMP_CLAUSE_NOWAIT:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (remove)\n+\t*list_p = OMP_CLAUSE_CHAIN (c);\n+      else\n+\tlist_p = &OMP_CLAUSE_CHAIN (c);\n+    }\n+\n+  /* Add in any implicit data sharing.  */\n+  splay_tree_foreach (ctx->variables, gimplify_adjust_omp_clauses_1, list_p);\n+  \n+  gimplify_omp_ctxp = ctx->outer_context;\n+  delete_omp_context (ctx);\n+}\n+\n+/* Gimplify the contents of an OMP_PARALLEL statement.  This involves\n+   gimplification of the body, as well as scanning the body for used\n+   variables.  We need to do this scan now, because variable-sized\n+   decls will be decomposed during gimplification.  */\n+\n+static enum gimplify_status\n+gimplify_omp_parallel (tree *expr_p, tree *pre_p)\n+{\n+  tree expr = *expr_p;\n+\n+  gimplify_scan_omp_clauses (&OMP_PARALLEL_CLAUSES (expr), pre_p, true);\n+\n+  push_gimplify_context ();\n+\n+  if (determine_parallel_type (expr) == IS_COMBINED_PARALLEL)\n+    {\n+      gimplify_ctxp->combined_pre_p = pre_p;\n+      gimplify_ctxp->combined_ctxp = gimplify_ctxp->prev_context;\n+    }\n+\n+  gimplify_stmt (&OMP_PARALLEL_BODY (expr));\n+  pop_gimplify_context (OMP_PARALLEL_BODY (expr));\n+\n+  gimplify_ctxp->combined_pre_p = NULL;\n+  gimplify_ctxp->combined_ctxp = NULL;\n+\n+  gimplify_adjust_omp_clauses (&OMP_PARALLEL_CLAUSES (expr));\n+\n+  return GS_ALL_DONE;\n+}\n+\n+/* Gimplify the gross structure of an OMP_FOR statement.  */\n+\n+static enum gimplify_status\n+gimplify_omp_for (tree *expr_p, tree *pre_p)\n+{\n+  tree for_stmt, decl, t;\n+  enum gimplify_status ret = 0;\n+  struct gimplify_omp_ctx *outer_combined_omp_ctxp = NULL;\n+\n+  for_stmt = *expr_p;\n+\n+  if (gimplify_ctxp->combined_pre_p)\n+    outer_combined_omp_ctxp = gimplify_omp_ctxp->outer_context;\n+\n+  gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, false);\n+\n+  t = OMP_FOR_INIT (for_stmt);\n+  gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n+  decl = TREE_OPERAND (t, 0);\n+  gcc_assert (DECL_P (decl));\n+  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (decl)));\n+  gcc_assert (!TYPE_UNSIGNED (TREE_TYPE (decl)));\n+\n+  /* Make sure the iteration variable is private.  */\n+  if (omp_is_private (gimplify_omp_ctxp, decl))\n+    omp_notice_variable (gimplify_omp_ctxp, decl, true);\n+  else\n+    omp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n+\n+  /* Gimplify inside our parent's context if this is part of a combined\n+     parallel+workshare directive.  */\n+  if (gimplify_ctxp->combined_pre_p)\n+    ret |= gimplify_expr_in_ctx (&TREE_OPERAND (t, 1),\n+\t\t\t\t gimplify_ctxp->combined_pre_p, NULL,\n+\t\t\t\t is_gimple_val, fb_rvalue,\n+\t\t\t\t gimplify_ctxp->combined_ctxp,\n+\t\t\t\t outer_combined_omp_ctxp);\n+  else\n+    ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\t  NULL, is_gimple_val, fb_rvalue);\n+\n+  t = OMP_FOR_COND (for_stmt);\n+  gcc_assert (COMPARISON_CLASS_P (t));\n+  gcc_assert (TREE_OPERAND (t, 0) == decl);\n+\n+  /* Gimplify inside our parent's context if this is part of a combined\n+     parallel+workshare directive.  */\n+  if (gimplify_ctxp->combined_pre_p)\n+    ret |= gimplify_expr_in_ctx (&TREE_OPERAND (t, 1),\n+\t\t\t\t gimplify_ctxp->combined_pre_p, NULL,\n+\t\t\t\t is_gimple_val, fb_rvalue,\n+\t\t\t\t gimplify_ctxp->combined_ctxp,\n+\t\t\t\t outer_combined_omp_ctxp);\n+  else\n+    ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\t  NULL, is_gimple_val, fb_rvalue);\n+\n+  t = OMP_FOR_INCR (for_stmt);\n+  switch (TREE_CODE (t))\n+    {\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      t = build_int_cst (TREE_TYPE (decl), 1);\n+      goto build_modify;\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      t = build_int_cst (TREE_TYPE (decl), -1);\n+      goto build_modify;\n+    build_modify:\n+      t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n+      t = build2 (MODIFY_EXPR, void_type_node, decl, t);\n+      OMP_FOR_INCR (for_stmt) = t;\n+      break;\n+      \n+    case MODIFY_EXPR:\n+      gcc_assert (TREE_OPERAND (t, 0) == decl);\n+      t = TREE_OPERAND (t, 1);\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase PLUS_EXPR:\n+\t  if (TREE_OPERAND (t, 1) == decl)\n+\t    {\n+\t      TREE_OPERAND (t, 1) = TREE_OPERAND (t, 0);\n+\t      TREE_OPERAND (t, 0) = decl;\n+\t      break;\n+\t    }\n+\tcase MINUS_EXPR:\n+\t  gcc_assert (TREE_OPERAND (t, 0) == decl);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      /* Gimplify inside our parent's context if this is part of a\n+\t combined parallel+workshare directive.  */\n+      if (gimplify_ctxp->combined_pre_p)\n+\tret |= gimplify_expr_in_ctx (&TREE_OPERAND (t, 1),\n+\t\t\t\t     gimplify_ctxp->combined_pre_p, NULL,\n+\t\t\t\t     is_gimple_val, fb_rvalue,\n+\t\t\t\t     gimplify_ctxp->combined_ctxp,\n+\t\t\t\t     outer_combined_omp_ctxp);\n+      else\n+\tret |= gimplify_expr (&TREE_OPERAND (t, 1),\n+\t\t\t      &OMP_FOR_PRE_BODY (for_stmt), NULL,\n+\t\t\t      is_gimple_val, fb_rvalue);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gimplify_to_stmt_list (&OMP_FOR_BODY (for_stmt));\n+  gimplify_adjust_omp_clauses (&OMP_FOR_CLAUSES (for_stmt));\n+\n+  return ret == GS_ALL_DONE ? GS_ALL_DONE : GS_ERROR;\n+}\n+\n+/* Gimplify the gross structure of other OpenMP worksharing constructs.\n+   In particular, OMP_SECTIONS and OMP_SINGLE.  */\n+\n+static enum gimplify_status\n+gimplify_omp_workshare (tree *expr_p, tree *pre_p)\n+{\n+  tree stmt = *expr_p;\n+\n+  gimplify_scan_omp_clauses (&OMP_CLAUSES (stmt), pre_p, false);\n+  gimplify_to_stmt_list (&OMP_BODY (stmt));\n+  gimplify_adjust_omp_clauses (&OMP_CLAUSES (stmt));\n+\n+  return GS_ALL_DONE;\n+}\n+\n+/* A subroutine of gimplify_omp_atomic.  The front end is supposed to have\n+   stabilized the lhs of the atomic operation as *ADDR.  Return true if \n+   EXPR is this stabilized form.  */\n+\n+static bool\n+goa_lhs_expr_p (tree expr, tree addr)\n+{\n+  /* Also include casts to other type variants.  The C front end is fond\n+     of adding these for e.g. volatile variables.  This is like \n+     STRIP_TYPE_NOPS but includes the main variant lookup.  */\n+  while ((TREE_CODE (expr) == NOP_EXPR\n+          || TREE_CODE (expr) == CONVERT_EXPR\n+          || TREE_CODE (expr) == NON_LVALUE_EXPR)\n+         && TREE_OPERAND (expr, 0) != error_mark_node\n+         && (TYPE_MAIN_VARIANT (TREE_TYPE (expr))\n+             == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (expr, 0)))))\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (TREE_CODE (expr) == INDIRECT_REF && TREE_OPERAND (expr, 0) == addr)\n+    return true;\n+  if (TREE_CODE (addr) == ADDR_EXPR && expr == TREE_OPERAND (addr, 0))\n+    return true;\n+  return false;\n+}\n+\n+/* A subroutine of gimplify_omp_atomic.  Attempt to implement the atomic\n+   operation as a __sync_fetch_and_op builtin.  INDEX is log2 of the\n+   size of the data type, and thus usable to find the index of the builtin\n+   decl.  Returns GS_UNHANDLED if the expression is not of the proper form.  */\n+\n+static enum gimplify_status\n+gimplify_omp_atomic_fetch_op (tree *expr_p, tree addr, tree rhs, int index)\n+{\n+  enum built_in_function base;\n+  tree decl, args, itype;\n+  enum insn_code *optab;\n+\n+  /* Check for one of the supported fetch-op operations.  */\n+  switch (TREE_CODE (rhs))\n+    {\n+    case PLUS_EXPR:\n+      base = BUILT_IN_FETCH_AND_ADD_N;\n+      optab = sync_add_optab;\n+      break;\n+    case MINUS_EXPR:\n+      base = BUILT_IN_FETCH_AND_SUB_N;\n+      optab = sync_add_optab;\n+      break;\n+    case BIT_AND_EXPR:\n+      base = BUILT_IN_FETCH_AND_AND_N;\n+      optab = sync_and_optab;\n+      break;\n+    case BIT_IOR_EXPR:\n+      base = BUILT_IN_FETCH_AND_OR_N;\n+      optab = sync_ior_optab;\n+      break;\n+    case BIT_XOR_EXPR:\n+      base = BUILT_IN_FETCH_AND_XOR_N;\n+      optab = sync_xor_optab;\n+      break;\n+    default:\n+      return GS_UNHANDLED;\n+    }\n+\n+  /* Make sure the expression is of the proper form.  */\n+  if (goa_lhs_expr_p (TREE_OPERAND (rhs, 0), addr))\n+    rhs = TREE_OPERAND (rhs, 1);\n+  else if (commutative_tree_code (TREE_CODE (rhs))\n+\t   && goa_lhs_expr_p (TREE_OPERAND (rhs, 1), addr))\n+    rhs = TREE_OPERAND (rhs, 0);\n+  else\n+    return GS_UNHANDLED;\n+\n+  decl = built_in_decls[base + index + 1];\n+  itype = TREE_TYPE (TREE_TYPE (decl));\n+\n+  if (optab[TYPE_MODE (itype)] == CODE_FOR_nothing)\n+    return GS_UNHANDLED;\n+\n+  args = tree_cons (NULL, fold_convert (itype, rhs), NULL);\n+  args = tree_cons (NULL, addr, args);\n+  *expr_p = build_function_call_expr (decl, args);\n+  return GS_OK;\n+}\n+\n+/* A subroutine of gimplify_omp_atomic_pipeline.  Walk *EXPR_P and replace\n+   appearences of *LHS_ADDR with LHS_VAR.  If an expression does not involve\n+   the lhs, evaluate it into a temporary.  Return 1 if the lhs appeared as\n+   a subexpression, 0 if it did not, or -1 if an error was encountered.  */\n+\n+static int\n+goa_stabilize_expr (tree *expr_p, tree *pre_p, tree lhs_addr, tree lhs_var)\n+{\n+  tree expr = *expr_p;\n+  int saw_lhs;\n+\n+  if (goa_lhs_expr_p (expr, lhs_addr))\n+    {\n+      *expr_p = lhs_var;\n+      return 1;\n+    }\n+  if (is_gimple_val (expr))\n+    return 0;\n+ \n+  saw_lhs = 0;\n+  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+    {\n+    case tcc_binary:\n+      saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 1), pre_p,\n+\t\t\t\t     lhs_addr, lhs_var);\n+    case tcc_unary:\n+      saw_lhs |= goa_stabilize_expr (&TREE_OPERAND (expr, 0), pre_p,\n+\t\t\t\t     lhs_addr, lhs_var);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (saw_lhs == 0)\n+    {\n+      enum gimplify_status gs;\n+      gs = gimplify_expr (expr_p, pre_p, NULL, is_gimple_val, fb_rvalue);\n+      if (gs != GS_ALL_DONE)\n+\tsaw_lhs = -1;\n+    }\n+\n+  return saw_lhs;\n+}\n+\n+/* A subroutine of gimplify_omp_atomic.  Implement the atomic operation as:\n+\n+\toldval = *addr;\n+      repeat:\n+\tnewval = rhs;\t// with oldval replacing *addr in rhs\n+\toldval = __sync_val_compare_and_swap (addr, oldval, newval);\n+\tif (oldval != newval)\n+\t  goto repeat;\n+\n+   INDEX is log2 of the size of the data type, and thus usable to find the\n+   index of the builtin decl.  */\n+\n+static enum gimplify_status\n+gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n+\t\t\t      tree rhs, int index)\n+{\n+  tree oldval, oldival, oldival2, newval, newival, label;\n+  tree type, itype, cmpxchg, args, x, iaddr;\n+\n+  cmpxchg = built_in_decls[BUILT_IN_VAL_COMPARE_AND_SWAP_N + index + 1];\n+  type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n+  itype = TREE_TYPE (TREE_TYPE (cmpxchg));\n+\n+  if (sync_compare_and_swap[TYPE_MODE (itype)] == CODE_FOR_nothing)\n+    return GS_UNHANDLED;\n+\n+  oldval = create_tmp_var (type, NULL);\n+  newval = create_tmp_var (type, NULL);\n+\n+  /* Precompute as much of RHS as possible.  In the same walk, replace\n+     occurrences of the lhs value with our temporary.  */\n+  if (goa_stabilize_expr (&rhs, pre_p, addr, oldval) < 0)\n+    return GS_ERROR;\n+\n+  x = build_fold_indirect_ref (addr);\n+  x = build2 (MODIFY_EXPR, void_type_node, oldval, x);\n+  gimplify_and_add (x, pre_p);\n+\n+  /* For floating-point values, we'll need to view-convert them to integers\n+     so that we can perform the atomic compare and swap.  Simplify the \n+     following code by always setting up the \"i\"ntegral variables.  */\n+  if (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type))\n+    {\n+      oldival = oldval;\n+      newival = newval;\n+      iaddr = addr;\n+    }\n+  else\n+    {\n+      oldival = create_tmp_var (itype, NULL);\n+      newival = create_tmp_var (itype, NULL);\n+\n+      x = build1 (VIEW_CONVERT_EXPR, itype, oldval);\n+      x = build2 (MODIFY_EXPR, void_type_node, oldival, x);\n+      gimplify_and_add (x, pre_p);\n+      iaddr = fold_convert (build_pointer_type (itype), addr);\n+    }\n+\n+  oldival2 = create_tmp_var (itype, NULL);\n+\n+  label = create_artificial_label ();\n+  x = build1 (LABEL_EXPR, void_type_node, label);\n+  gimplify_and_add (x, pre_p);\n+\n+  x = build2 (MODIFY_EXPR, void_type_node, newval, rhs);\n+  gimplify_and_add (x, pre_p);\n+\n+  if (newval != newival)\n+    {\n+      x = build1 (VIEW_CONVERT_EXPR, itype, newval);\n+      x = build2 (MODIFY_EXPR, void_type_node, newival, x);\n+      gimplify_and_add (x, pre_p);\n+    }\n+\n+  x = build2 (MODIFY_EXPR, void_type_node, oldival2, oldival);\n+  gimplify_and_add (x, pre_p);\n+\n+  args = tree_cons (NULL, fold_convert (itype, newival), NULL);\n+  args = tree_cons (NULL, fold_convert (itype, oldival), args);\n+  args = tree_cons (NULL, iaddr, args);\n+  x = build_function_call_expr (cmpxchg, args);\n+  if (oldval == oldival)\n+    x = fold_convert (type, x);\n+  x = build2 (MODIFY_EXPR, void_type_node, oldival, x);\n+  gimplify_and_add (x, pre_p);\n+\n+  /* For floating point, be prepared for the loop backedge.  */\n+  if (oldval != oldival)\n+    {\n+      x = build1 (VIEW_CONVERT_EXPR, type, oldival);\n+      x = build2 (MODIFY_EXPR, void_type_node, oldval, x);\n+      gimplify_and_add (x, pre_p);\n+    }\n+\n+  /* Note that we always perform the comparison as an integer, even for\n+     floating point.  This allows the atomic operation to properly \n+     succeed even with NaNs and -0.0.  */\n+  x = build3 (COND_EXPR, void_type_node,\n+\t      build2 (NE_EXPR, boolean_type_node, oldival, oldival2),\n+\t      build1 (GOTO_EXPR, void_type_node, label), NULL);\n+  gimplify_and_add (x, pre_p);\n+\n+  *expr_p = NULL;\n+  return GS_ALL_DONE;\n+}\n+\n+/* A subroutine of gimplify_omp_atomic.  Implement the atomic operation as:\n+\n+\tGOMP_atomic_start ();\n+\t*addr = rhs;\n+\tGOMP_atomic_end ();\n+\n+   The result is not globally atomic, but works so long as all parallel\n+   references are within #pragma omp atomic directives.  According to\n+   responses received from omp@openmp.org, appears to be within spec.\n+   Which makes sense, since that's how several other compilers handle\n+   this situation as well.  */\n+\n+static enum gimplify_status\n+gimplify_omp_atomic_mutex (tree *expr_p, tree *pre_p, tree addr, tree rhs)\n+{\n+  tree t;\n+\n+  t = built_in_decls[BUILT_IN_GOMP_ATOMIC_START];\n+  t = build_function_call_expr (t, NULL);\n+  gimplify_and_add (t, pre_p);\n+\n+  t = build_fold_indirect_ref (addr);\n+  t = build2 (MODIFY_EXPR, void_type_node, t, rhs);\n+  gimplify_and_add (t, pre_p);\n+  \n+  t = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n+  t = build_function_call_expr (t, NULL);\n+  gimplify_and_add (t, pre_p);\n+\n+  *expr_p = NULL;\n+  return GS_ALL_DONE;\n+}\n+\n+/* Gimplify an OMP_ATOMIC statement.  */\n+\n+static enum gimplify_status\n+gimplify_omp_atomic (tree *expr_p, tree *pre_p)\n+{\n+  tree addr = TREE_OPERAND (*expr_p, 0);\n+  tree rhs = TREE_OPERAND (*expr_p, 1);\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n+  HOST_WIDE_INT index;\n+\n+  /* Make sure the type is one of the supported sizes.  */\n+  index = tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n+  index = exact_log2 (index);\n+  if (index >= 0 && index <= 4)\n+    {\n+      enum gimplify_status gs;\n+      unsigned int align;\n+\n+      if (DECL_P (TREE_OPERAND (addr, 0)))\n+\talign = DECL_ALIGN_UNIT (TREE_OPERAND (addr, 0));\n+      else if (TREE_CODE (TREE_OPERAND (addr, 0)) == COMPONENT_REF\n+\t       && TREE_CODE (TREE_OPERAND (TREE_OPERAND (addr, 0), 1))\n+\t\t  == FIELD_DECL)\n+\talign = DECL_ALIGN_UNIT (TREE_OPERAND (TREE_OPERAND (addr, 0), 1));\n+      else\n+\talign = TYPE_ALIGN_UNIT (type);\n+\n+      /* __sync builtins require strict data alignment.  */\n+      if (exact_log2 (align) >= index)\n+\t{\n+\t  /* When possible, use specialized atomic update functions.  */\n+\t  if (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type))\n+\t    {\n+\t      gs = gimplify_omp_atomic_fetch_op (expr_p, addr, rhs, index);\n+\t      if (gs != GS_UNHANDLED)\n+\t\treturn gs;\n+\t    }\n+\n+\t  /* If we don't have specialized __sync builtins, try and implement\n+\t     as a compare and swap loop.  */\n+\t  gs = gimplify_omp_atomic_pipeline (expr_p, pre_p, addr, rhs, index);\n+\t  if (gs != GS_UNHANDLED)\n+\t    return gs;\n+\t}\n+    }\n+\n+  /* The ultimate fallback is wrapping the operation in a mutex.  */\n+  return gimplify_omp_atomic_mutex (expr_p, pre_p, addr, rhs);\n+}\n \n /*  Gimplifies the expression tree pointed to by EXPR_P.  Return 0 if\n     gimplification failed.\n@@ -4441,6 +5598,30 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n+\tcase OMP_PARALLEL:\n+\t  ret = gimplify_omp_parallel (expr_p, pre_p);\n+\t  break;\n+\n+\tcase OMP_FOR:\n+\t  ret = gimplify_omp_for (expr_p, pre_p);\n+\t  break;\n+\n+\tcase OMP_SECTIONS:\n+\tcase OMP_SINGLE:\n+\t  ret = gimplify_omp_workshare (expr_p, pre_p);\n+\t  break;\n+\n+\tcase OMP_SECTION:\n+\tcase OMP_MASTER:\n+\tcase OMP_ORDERED:\n+\tcase OMP_CRITICAL:\n+\t  gimplify_to_stmt_list (&OMP_BODY (*expr_p));\n+\t  break;\n+\n+\tcase OMP_ATOMIC:\n+\t  ret = gimplify_omp_atomic (expr_p, pre_p);\n+\t  break;\n+\n \tdefault:\n \t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))\n \t    {\n@@ -4880,6 +6061,8 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   tree body, parm_stmts;\n \n   timevar_push (TV_TREE_GIMPLIFY);\n+\n+  gcc_assert (gimplify_ctxp == NULL);\n   push_gimplify_context ();\n \n   /* Unshare most shared trees in the body and in that of any nested functions.\n@@ -4933,6 +6116,7 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   *body_p = body;\n \n   pop_gimplify_context (body);\n+  gcc_assert (gimplify_ctxp == NULL);\n \n #ifdef ENABLE_CHECKING\n   walk_tree (body_p, check_pointer_types_r, NULL, NULL);"}, {"sha": "a5028de43fbdd190eb9eef800939f12c07fa9ed0", "filename": "gcc/hooks.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -185,6 +185,12 @@ hook_bool_tree_tree_false (tree a ATTRIBUTE_UNUSED, tree b ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+bool\n+hook_bool_tree_bool_false (tree a ATTRIBUTE_UNUSED, bool b ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n bool\n hook_bool_rtx_false (rtx a ATTRIBUTE_UNUSED)\n {\n@@ -256,6 +262,12 @@ hook_tree_tree_tree_bool_null (tree t0 ATTRIBUTE_UNUSED, tree t1 ATTRIBUTE_UNUSE\n   return NULL;\n }\n \n+tree\n+hook_tree_tree_tree_null (tree t0 ATTRIBUTE_UNUSED, tree t1 ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n+\n /* Generic hook that takes a rtx and returns a NULL string.  */\n const char *\n hook_constcharptr_rtx_null (rtx r ATTRIBUTE_UNUSED)"}, {"sha": "eab42ab5faafda609062f64dc6bbd58c0a5d2b80", "filename": "gcc/hooks.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -40,6 +40,8 @@ extern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\n extern bool hook_bool_rtx_int_int_intp_false (rtx, int, int, int *);\n extern bool hook_bool_constcharptr_size_t_false (const char *, size_t);\n extern bool hook_bool_size_t_constcharptr_int_true (size_t, const char *, int);\n+extern bool hook_bool_tree_tree_false (tree, tree);\n+extern bool hook_bool_tree_bool_false (tree, bool);\n \n extern void hook_void_void (void);\n extern void hook_void_constcharptr (const char *);\n@@ -53,19 +55,20 @@ extern int hook_int_rtx_0 (rtx);\n extern int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);\n extern int hook_int_void_no_regs (void);\n \n+extern tree hook_tree_tree_tree_null (tree, tree);\n+extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);\n+extern tree hook_tree_tree_tree_bool_null (tree, tree, bool);\n+\n extern unsigned hook_uint_uint_constcharptrptr_0 (unsigned, const char **);\n \n extern bool default_can_output_mi_thunk_no_vcall (tree, HOST_WIDE_INT,\n \t\t\t\t\t   HOST_WIDE_INT, tree);\n \n-extern bool hook_bool_tree_tree_false (tree, tree);\n-\n extern rtx hook_rtx_rtx_identity (rtx);\n extern rtx hook_rtx_rtx_null (rtx);\n extern rtx hook_rtx_tree_int_null (tree, int);\n-extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);\n+\n extern const char *hook_constcharptr_tree_null (tree);\n-extern tree hook_tree_tree_tree_bool_null (tree, tree, bool);\n extern const char *hook_constcharptr_rtx_null (rtx);\n extern const char *hook_constcharptr_tree_tree_null (tree, tree);\n extern const char *hook_constcharptr_int_tree_null (int, tree);"}, {"sha": "168220e31a1a8d1253ef5e35789fdade76677f41", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -88,6 +88,11 @@ extern tree lhd_callgraph_analyze_expr (tree *, int *, tree);\n \n /* Declarations for tree gimplification hooks.  */\n extern int lhd_gimplify_expr (tree *, tree *, tree *);\n+extern enum omp_clause_default_kind lhd_omp_predetermined_sharing (tree);\n+extern tree lhd_omp_assignment (tree, tree, tree);\n+struct gimplify_omp_ctx;\n+extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,\n+\t\t\t\t\t       tree);\n \n #define LANG_HOOKS_NAME\t\t\t\"GNU unknown\"\n #define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct lang_identifier)\n@@ -213,6 +218,8 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_TYPE_PROMOTES_TO lhd_type_promotes_to\n #define LANG_HOOKS_REGISTER_BUILTIN_TYPE lhd_register_builtin_type\n #define LANG_HOOKS_TYPE_MAX_SIZE\tlhd_return_null_tree\n+#define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n+  lhd_omp_firstprivatize_type_sizes\n #define LANG_HOOKS_HASH_TYPES\t\ttrue\n \n #define LANG_HOOKS_FOR_TYPES_INITIALIZER { \\\n@@ -226,6 +233,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_REGISTER_BUILTIN_TYPE, \\\n   LANG_HOOKS_INCOMPLETE_TYPE_ERROR, \\\n   LANG_HOOKS_TYPE_MAX_SIZE, \\\n+  LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES, \\\n   LANG_HOOKS_HASH_TYPES \\\n }\n \n@@ -239,6 +247,14 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_PREPARE_ASSEMBLE_VARIABLE NULL\n #define LANG_HOOKS_DECL_OK_FOR_SIBCALL\tlhd_decl_ok_for_sibcall\n #define LANG_HOOKS_COMDAT_GROUP lhd_comdat_group\n+#define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE hook_bool_tree_false\n+#define LANG_HOOKS_OMP_PREDETERMINED_SHARING lhd_omp_predetermined_sharing\n+#define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR hook_bool_tree_bool_false\n+#define LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE hook_bool_tree_bool_false\n+#define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR hook_tree_tree_tree_null\n+#define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR lhd_omp_assignment\n+#define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP lhd_omp_assignment\n+#define LANG_HOOKS_OMP_CLAUSE_DTOR hook_tree_tree_tree_null\n \n #define LANG_HOOKS_DECLS { \\\n   LANG_HOOKS_GLOBAL_BINDINGS_P, \\\n@@ -249,7 +265,15 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_WRITE_GLOBALS, \\\n   LANG_HOOKS_PREPARE_ASSEMBLE_VARIABLE, \\\n   LANG_HOOKS_DECL_OK_FOR_SIBCALL, \\\n-  LANG_HOOKS_COMDAT_GROUP \\\n+  LANG_HOOKS_COMDAT_GROUP, \\\n+  LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE, \\\n+  LANG_HOOKS_OMP_PREDETERMINED_SHARING, \\\n+  LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR, \\\n+  LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE, \\\n+  LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR, \\\n+  LANG_HOOKS_OMP_CLAUSE_COPY_CTOR, \\\n+  LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP, \\\n+  LANG_HOOKS_OMP_CLAUSE_DTOR \\\n }\n \n /* The whole thing.  The structure is defined in langhooks.h.  */"}, {"sha": "69be1f571d409a6d6e516eefd6d67d9838a53786", "filename": "gcc/langhooks.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -550,3 +550,31 @@ lhd_expr_to_decl (tree expr, bool *tc ATTRIBUTE_UNUSED,\n {\n   return expr;\n }\n+\n+/* Return sharing kind if OpenMP sharing attribute of DECL is\n+   predetermined, OMP_CLAUSE_DEFAULT_UNSPECIFIED otherwise.  */\n+\n+enum omp_clause_default_kind\n+lhd_omp_predetermined_sharing (tree decl ATTRIBUTE_UNUSED)\n+{\n+  if (DECL_ARTIFICIAL (decl))\n+    return OMP_CLAUSE_DEFAULT_SHARED;\n+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+}\n+\n+/* Generate code to copy SRC to DST.  */\n+\n+tree\n+lhd_omp_assignment (tree clause ATTRIBUTE_UNUSED, tree dst, tree src)\n+{\n+  return build2 (MODIFY_EXPR, void_type_node, dst, src);\n+}\n+\n+/* Register language specific type size variables as potentially OpenMP\n+   firstprivate variables.  */\n+\n+void\n+lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *c ATTRIBUTE_UNUSED,\n+\t\t\t\t   tree t ATTRIBUTE_UNUSED)\n+{\n+}"}, {"sha": "eb6aaaff12ed332b13b127931f023662e212207a", "filename": "gcc/langhooks.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -25,6 +25,8 @@ Boston, MA 02110-1301, USA.  */\n \n struct diagnostic_context;\n \n+struct gimplify_omp_ctx;\n+\n /* A print hook for print_tree ().  */\n typedef void (*lang_print_tree_hook) (FILE *, tree, int indent);\n \n@@ -142,6 +144,10 @@ struct lang_hooks_for_types\n      for a type.  */\n   tree (*max_size) (tree);\n \n+  /* Register language specific type size variables as potentially OpenMP\n+     firstprivate variables.  */\n+  void (*omp_firstprivatize_type_sizes) (struct gimplify_omp_ctx *, tree);\n+\n   /* Nonzero if types that are identical are to be hashed so that only\n      one copy is kept.  If a language requires unique types for each\n      user-specified type, such as Ada, this should be set to TRUE.  */\n@@ -192,6 +198,38 @@ struct lang_hooks_for_decls\n      value will be the string already stored in an\n      IDENTIFIER_NODE.)  */\n   const char * (*comdat_group) (tree);\n+\n+  /* True if OpenMP should privatize what this DECL points to rather\n+     than the DECL itself.  */\n+  bool (*omp_privatize_by_reference) (tree);\n+\n+  /* Return sharing kind if OpenMP sharing attribute of DECL is\n+     predetermined, OMP_CLAUSE_DEFAULT_UNSPECIFIED otherwise.  */\n+  enum omp_clause_default_kind (*omp_predetermined_sharing) (tree);\n+\n+  /* Return true if DECL's DECL_VALUE_EXPR (if any) should be\n+     disregarded in OpenMP construct, because it is going to be\n+     remapped during OpenMP lowering.  SHARED is true if DECL\n+     is going to be shared, false if it is going to be privatized.  */\n+  bool (*omp_disregard_value_expr) (tree, bool);\n+\n+  /* Return true if DECL that is shared iff SHARED is true should\n+     be put into OMP_CLAUSE_PRIVATE_DEBUG.  */\n+  bool (*omp_private_debug_clause) (tree, bool);\n+\n+  /* Build and return code for a default constructor for DECL in\n+     response to CLAUSE.  Return NULL if nothing to be done.  */\n+  tree (*omp_clause_default_ctor) (tree clause, tree decl);\n+\n+  /* Build and return code for a copy constructor from SRC to DST.  */\n+  tree (*omp_clause_copy_ctor) (tree clause, tree dst, tree src);\n+\n+  /* Similarly, except use an assignment operator instead.  */\n+  tree (*omp_clause_assign_op) (tree clause, tree dst, tree src);\n+\n+  /* Build and return code destructing DECL.  Return NULL if nothing\n+     to be done.  */\n+  tree (*omp_clause_dtor) (tree clause, tree decl);\n };\n \n /* Language-specific hooks.  See langhooks-def.h for defaults.  */"}, {"sha": "596beae97aafe6caf6c45ac35922fc05b39e6ab6", "filename": "gcc/omp-builtins.def", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,152 @@\n+/* This file contains the definitions and documentation for the\n+   OpenMP builtins used in the GNU compiler.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* Before including this file, you should define a macro:\n+\n+     DEF_GOMP_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n+\n+   See builtins.def for details.  */\n+\n+DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_THREAD_NUM, \"omp_get_thread_num\",\n+\t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_NUM_THREADS, \"omp_get_num_threads\",\n+\t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LIST)\n+\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ATOMIC_START, \"GOMP_atomic_start\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ATOMIC_END, \"GOMP_atomic_end\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_BARRIER, \"GOMP_barrier\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_START, \"GOMP_critical_start\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_END, \"GOMP_critical_end\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_NAME_START,\n+\t\t  \"GOMP_critical_name_start\",\n+\t\t  BT_FN_VOID_PTRPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_NAME_END,\n+\t\t  \"GOMP_critical_name_end\",\n+\t\t  BT_FN_VOID_PTRPTR, ATTR_NOTHROW_LIST)\n+/* NOTE: Do not change the order of BUILT_IN_GOMP_LOOP_*_START.  They\n+   are used in index arithmetic with enum omp_clause_schedule_kind\n+   in omp-low.c.  */\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_STATIC_START,\n+\t\t  \"GOMP_loop_static_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DYNAMIC_START,\n+\t\t  \"GOMP_loop_dynamic_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_GUIDED_START,\n+\t\t  \"GOMP_loop_guided_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_RUNTIME_START,\n+\t\t  \"GOMP_loop_runtime_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_STATIC_START,\n+\t\t  \"GOMP_loop_ordered_static_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_START,\n+\t\t  \"GOMP_loop_ordered_dynamic_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_GUIDED_START,\n+\t\t  \"GOMP_loop_ordered_guided_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_START,\n+\t\t  \"GOMP_loop_ordered_runtime_start\",\n+\t\t  BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_STATIC_NEXT, \"GOMP_loop_static_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_DYNAMIC_NEXT, \"GOMP_loop_dynamic_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_GUIDED_NEXT, \"GOMP_loop_guided_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_RUNTIME_NEXT, \"GOMP_loop_runtime_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_STATIC_NEXT,\n+\t\t  \"GOMP_loop_ordered_static_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_DYNAMIC_NEXT,\n+\t\t  \"GOMP_loop_ordered_dynamic_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_GUIDED_NEXT,\n+\t\t  \"GOMP_loop_ordered_guided_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_NEXT,\n+\t\t  \"GOMP_loop_ordered_runtime_next\",\n+\t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+/* NOTE: Do not change the order of BUILT_IN_GOMP_PARALLEL_LOOP_*_START.\n+   They are used in index arithmetic with enum omp_clause_schedule_kind\n+   in omp-low.c.  */\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START,\n+\t\t  \"GOMP_parallel_loop_static_start\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_DYNAMIC_START,\n+\t\t  \"GOMP_parallel_loop_dynamic_start\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_GUIDED_START,\n+\t\t  \"GOMP_parallel_loop_guided_start\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_LOOP_RUNTIME_START,\n+\t\t  \"GOMP_parallel_loop_runtime_start\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END, \"GOMP_loop_end\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_END_NOWAIT, \"GOMP_loop_end_nowait\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ORDERED_START, \"GOMP_ordered_start\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ORDERED_END, \"GOMP_ordered_end\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_START, \"GOMP_parallel_start\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_END, \"GOMP_parallel_end\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_START, \"GOMP_sections_start\",\n+\t\t  BT_FN_UINT_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_NEXT, \"GOMP_sections_next\",\n+\t\t  BT_FN_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_SECTIONS_START,\n+\t\t  \"GOMP_parallel_sections_start\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_UINT_UINT, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_END, \"GOMP_sections_end\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_END_NOWAIT,\n+\t\t  \"GOMP_sections_end_nowait\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_START, \"GOMP_single_start\",\n+\t\t  BT_FN_BOOL, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_START, \"GOMP_single_copy_start\",\n+\t\t  BT_FN_PTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_END, \"GOMP_single_copy_end\",\n+\t\t  BT_FN_VOID_PTR, ATTR_NOTHROW_LIST)"}, {"sha": "65907f0089c7d351f483cd89b7cdabfd25d9fe5a", "filename": "gcc/omp-low.c", "status": "added", "additions": 3309, "deletions": 0, "changes": 3309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "e2d18c9593fa1a205621b6ab46b0af761f2f82c5", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -462,6 +462,7 @@ init_optimization_passes (void)\n   p = &all_lowering_passes;\n   NEXT_PASS (pass_remove_useless_stmts);\n   NEXT_PASS (pass_mudflap_1);\n+  NEXT_PASS (pass_lower_omp);\n   NEXT_PASS (pass_lower_cf);\n   NEXT_PASS (pass_lower_eh);\n   NEXT_PASS (pass_build_cfg);"}, {"sha": "a371f09813eb5dc58bbd5cd757fc6318133f09b1", "filename": "gcc/print-tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -506,6 +506,10 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t\t   (void *) DECL_STRUCT_FUNCTION (node));\n \t}\n \n+      if ((TREE_CODE (node) == VAR_DECL || TREE_CODE (node) == PARM_DECL)\n+\t  && DECL_HAS_VALUE_EXPR_P (node))\n+\tprint_node (file, \"value-expr\", DECL_VALUE_EXPR (node), indent + 4);\n+\n       /* Print the decl chain only if decl is at second level.  */\n       if (indent == 4)\n \tprint_node (file, \"chain\", TREE_CHAIN (node), indent + 4);"}, {"sha": "15e47619f176708f0d935abfee56a406e22c6c38", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -1,3 +1,11 @@\n+2006-01-18  Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\t    Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* testsuite/gcc.dg/gomp: New directory.\n+\n 2006-01-18  Paul Thomas  <pault@gcc.gnu.org>\n \t    Steven G. Kargl  <kargls@comcast.net>\n "}, {"sha": "f7f2924ce1a02d5f596c4533c93a7b9e201b69ee", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.1.1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.1.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.1.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.1.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+\n+void\n+a1 (int n, float *a, float *b)\n+{\n+  int i;\n+#pragma omp parallel for\n+  for (i = 1; i < n; i++)\t/* i is private by default */\n+    b[i] = (a[i] + a[i - 1]) / 2.0;\n+}"}, {"sha": "750bc378c644ddc9077af415801dfce0a3e25ee0", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.10.1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.10.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.10.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.10.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+#include <stdio.h>\n+void\n+work1 ()\n+{\n+}\n+\n+void\n+work2 ()\n+{\n+}\n+void\n+a10 ()\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp single\n+    printf (\"Beginning work1.\\n\");\n+    work1 ();\n+#pragma omp single\n+    printf (\"Finishing work1.\\n\");\n+#pragma omp single nowait\n+    printf (\"Finished work1 and beginning work2.\\n\");\n+    work2 ();\n+  }\n+}"}, {"sha": "fab948dd73686dfa4b37439c56c3195e85f98270", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.12.1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.12.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.12.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.12.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+\n+#include <stdio.h>\n+extern float average (float, float, float);\n+void\n+a12 (float *x, float *xold, int n, float tol)\n+{\n+  int c, i, toobig;\n+  float error, y;\n+  c = 0;\n+#pragma omp parallel\n+  {\n+    do\n+      {\n+#pragma omp for private(i)\n+\tfor (i = 1; i < n - 1; ++i)\n+\t  {\n+\t    xold[i] = x[i];\n+\t  }\n+#pragma omp single\n+\t{\n+\t  toobig = 0;\n+\t}\n+#pragma omp for private(i,y,error) reduction(+:toobig)\n+\tfor (i = 1; i < n - 1; ++i)\n+\t  {\n+\t    y = x[i];\n+\t    x[i] = average (xold[i - 1], x[i], xold[i + 1]);\n+\t    error = y - x[i];\n+\t    if (error > tol || error < -tol)\n+\t      ++toobig;\n+\t  }\n+#pragma omp master\n+\t{\n+\t  ++c;\n+\t  printf (\"iteration %d, toobig=%d\\n\", c, toobig);\n+\t}\n+      }\n+    while (toobig > 0);\n+  }\n+}"}, {"sha": "cc0fcc25d79d0593945bc4abb94e86b87ff99480", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.13.1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.13.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.13.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.13.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+int dequeue (float *a);\n+void work (int i, float *a);\n+void\n+a13 (float *x, float *y)\n+{\n+  int ix_next, iy_next;\n+#pragma omp parallel shared(x, y) private(ix_next, iy_next)\n+  {\n+#pragma omp critical (xaxis)\n+    ix_next = dequeue (x);\n+    work (ix_next, x);\n+#pragma omp critical (yaxis)\n+    iy_next = dequeue (y);\n+    work (iy_next, y);\n+  }\n+}"}, {"sha": "14a7ed0bde6aef1a72f80749afeb8ef1ba2043c8", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.14.1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.14.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.14.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.14.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+void\n+a14 ()\n+{\n+  int i = 1;\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    {\n+#pragma omp critical (name)\n+      {\n+#pragma omp parallel\n+\t{\n+#pragma omp single\n+\t  {\n+\t    i++;\n+\t  }\n+\t}\n+      }\n+    }\n+  }\n+}"}, {"sha": "c460f7566ef791b56435bc3a6dc7c3adea12fe13", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.17.1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.17.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.17.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.17.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+void\n+a17_1_wrong ()\n+{\n+  union\n+  {\n+    int n;\n+    float x;\n+  } u;\n+#pragma omp parallel\n+  {\n+#pragma omp atomic\n+    u.n++;\n+#pragma omp atomic\n+    u.x += 1.0;\n+/* Incorrect because the atomic constructs reference the same location\n+     through incompatible types */\n+  }\n+}"}, {"sha": "aaaec7ea35183e663a74294c75fd89c41c6cdd2a", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.17.2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.17.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.17.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.17.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+void\n+a17_2_wrong ()\n+{\n+  int x;\n+  int *i;\n+  float *r;\n+  i = &x;\n+  r = (float *) &x;\n+#pragma omp parallel\n+  {\n+#pragma omp atomic\n+    *i += 1;\n+#pragma omp atomic\n+    *r += 1.0;\n+/* Incorrect because the atomic constructs reference the same location\n+     through incompatible types */\n+  }\n+}"}, {"sha": "d43e0cf45f5dd245ea0ebcc3c840e6599fd5d976", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.20.1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.20.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.20.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.20.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+void\n+a20_wrong ()\n+{\n+  int a = 1;\n+#pragma omp parallel\n+  {\n+    if (a != 0)\n+#pragma omp flush(a)\t/* { dg-error \"'#pragma omp flush' may only\" } */\n+/* incorrect as flush cannot be immediate substatement\n+    of if statement */\n+      if (a != 0)\n+#pragma omp barrier\t/* { dg-error \"'#pragma omp barrier' may only\" } */\n+/* incorrect as barrier cannot be immediate substatement\n+    of if statement */\n+  }\n+}"}, {"sha": "4f1138356245170fc0b02521747a936a1fd1f0a3", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.20.2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.20.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.20.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.20.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+void\n+a20 ()\n+{\n+  int a = 1;\n+#pragma omp parallel\n+  {\n+    if (a != 0)\n+      {\n+#pragma omp flush(a)\n+      }\n+    if (a != 0)\n+      {\n+#pragma omp barrier\n+      }\n+  }\n+}"}, {"sha": "a9b81d0c39992961ba6019fc3a89405a3fa30d9f", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.21.2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.21.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.21.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.21.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+void\n+work (int i)\n+{\n+}\n+\n+void\n+a21_wrong (int n)\n+{\n+  int i;\n+#pragma omp for ordered\n+  for (i = 0; i < n; i++)\n+    {\n+/* incorrect because an iteration may not execute more than one\n+    ordered region */\n+#pragma omp ordered\n+      work (i);\n+#pragma omp ordered\n+      work (i + 1);\n+    }\n+}"}, {"sha": "4d1ed6a52866587f41cb6fa17a69e671de130ddd", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.21.3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.21.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.21.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.21.3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+void work (int);\n+\n+void\n+a21_good (int n)\n+{\n+  int i;\n+#pragma omp for ordered\n+  for (i = 0; i < n; i++)\n+    {\n+      if (i <= 10)\n+\t{\n+#pragma omp ordered\n+\t  work (i);\n+\t}\n+      if (i > 10)\n+\t{\n+#pragma omp ordered\n+\t  work (i + 1);\n+\t}\n+    }\n+}"}, {"sha": "e3586838a34086ff082afbdf439fcdc0674beacb", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.22.1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+int counter = 0;\n+#pragma omp threadprivate(counter)\n+int\n+increment_counter ()\n+{\n+  counter++;\n+  return (counter);\n+}"}, {"sha": "7a6e901a8c73806ae5a337900480820a78df0ac7", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.22.2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.22.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+int\n+increment_counter_2 ()\n+{\n+  static int counter = 0;\n+#pragma omp threadprivate(counter)\n+  counter++;\n+  return (counter);\n+}"}, {"sha": "9d8baa37f2341a87618be3e56a03ec96d9b30144", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.24.1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.24.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+extern int omp_get_num_threads (void);\n+int x, y, t, z[1000];\n+#pragma omp threadprivate(x)\n+void\n+a24 (int a)\n+{\n+  const int c = 1;\n+  int i = 0;\n+  int l = 0;\n+#pragma omp parallel default(none) private(a) shared(z)\n+  {\n+    int j = omp_get_num_threads ();\n+    /* O.K. - j is declared within parallel region */\n+    /* O.K.  -  a is listed in private clause */\n+    /*       -  z is listed in shared clause */\n+    x = c;\t\t\t/* O.K.  -  x is threadprivate */\n+    \t\t\t\t/*       -  c has const-qualified type */\n+    z[i] = y;\n+    /* { dg-error \"'i' not specified\" \"\" { target *-*-* } 21 } */\n+    /* { dg-error \"enclosing parallel\" \"\" { target *-*-* } 13 } */\n+    /* { dg-error \"'y' not specified\" \"\" { target *-*-* } 21 }  */\n+#pragma omp for firstprivate(y)\n+    for (i = 0; i < 10; i++)\n+      {\n+\tz[i] = y;\t\t/* O.K. - i is the loop iteration variable */\n+\t\t\t\t/*      - y is listed in firstprivate clause */\n+      }\n+    z[l] = t;\n+    /* { dg-error \"'l' not specified\" \"\" { target *-*-* } 31 } */\n+    /* { dg-error \"'t' not specified\" \"\" { target *-*-* } 31 }  */\n+  }\n+}"}, {"sha": "b655edc107c11e98469592508d5a16f83615d730", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.26.2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.26.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.26.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.26.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -std=c99\" } */\n+\n+int a;\n+void\n+g (int k)\n+{\n+  a = k;\t\t\t/* The global \"a\", not the private \"a\" in f */\n+}\n+\n+void\n+f (int n)\n+{\n+  int a = 0;\n+#pragma omp parallel for private(a)\n+  for (int i = 1; i < n; i++)\n+    {\n+      a = i;\n+      g (a * 2);\t\t/* Private copy of \"a\" */\n+    }\n+}"}, {"sha": "faa6ac6212865210a312835752bb63abf7c4c843", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.27.1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.27.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.27.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.27.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+void\n+a27 ()\n+{\n+  int i, a;\n+#pragma omp parallel private(a)\n+  {\n+#pragma omp parallel for private(a)\n+    for (i = 0; i < 10; i++)\n+      {\n+\t/* do work here */\n+      }\n+  }\n+}"}, {"sha": "e34be4c42961a4d70fd755318a8b49e188d4db20", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.30.1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.30.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.30.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.30.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+void\n+a30 (int n, float *a, float *b)\n+{\n+  int i;\n+#pragma omp parallel\n+  {\n+#pragma omp for lastprivate(i)\n+    for (i = 0; i < n - 1; i++)\n+      a[i] = b[i] + b[i + 1];\n+  }\n+  a[i] = b[i];\t\t\t/* i == n-1 here */\n+}"}, {"sha": "cbb3f60df44e3efbca392b39987ae11d7487f93d", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.31.1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.31.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.31.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.31.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+void\n+a31_1 (float *x, int *y, int n)\n+{\n+  int i, b;\n+  float a;\n+  a = 0.0;\n+  b = 0;\n+#pragma omp parallel for private(i) shared(x, y, n) \\\n+                         reduction(+:a) reduction(^:b)\n+  for (i = 0; i < n; i++)\n+    {\n+      a += x[i];\n+      b ^= y[i];\n+    }\n+}"}, {"sha": "f9da3f4fc20fe7b4414a1f0451b184cb31264e50", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.31.2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.31.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.31.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.31.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+void\n+a31_2 (float *x, int *y, int n)\n+{\n+  int i, b, b_p;\n+  float a, a_p;\n+  a = 0.0;\n+  b = 0;\n+#pragma omp parallel shared(a, b, x, y, n) \\\n+                     private(a_p, b_p)\n+  {\n+    a_p = 0.0;\n+    b_p = 0;\n+#pragma omp for private(i)\n+    for (i = 0; i < n; i++)\n+      {\n+\ta_p += x[i];\n+\tb_p ^= y[i];\n+      }\n+#pragma omp critical\n+    {\n+      a += a_p;\n+      b ^= b_p;\n+    }\n+  }\n+}"}, {"sha": "d2cb316f3cc0ec4cb15b898a7fcb4756f67f6a45", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.32.1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.32.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.32.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.32.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+#include <stdlib.h>\n+float *work;\n+int size;\n+float tol;\n+void build (void);\n+#pragma omp threadprivate(work,size,tol)\n+void\n+a32 (float t, int n)\n+{\n+  tol = t;\n+  size = n;\n+#pragma omp parallel copyin(tol,size)\n+  {\n+    build ();\n+  }\n+}\n+void\n+build ()\n+{\n+  int i;\n+  work = (float *) malloc (sizeof (float) * size);\n+  for (i = 0; i < size; ++i)\n+    work[i] = tol;\n+}"}, {"sha": "99c06da6a5dc305f2153c7b5950c75b983091fba", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.33.1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+#include <stdio.h>\n+float x, y;\n+#pragma omp threadprivate(x, y)\n+void\n+init (float a, float b)\n+{\n+#pragma omp single copyprivate(a,b,x,y)\n+  {\n+    scanf (\"%f %f %f %f\", &a, &b, &x, &y);\n+  }\n+}"}, {"sha": "a0da739dd84f32d70f32ec3a2cb66886252c088c", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.33.2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.33.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+float\n+read_next ()\n+{\n+  float *tmp;\n+  float return_val;\n+#pragma omp single copyprivate(tmp)\n+  {\n+    tmp = (float *) malloc (sizeof (float));\n+  }\t\t\t\t/* copies the pointer only */\n+#pragma omp master\n+  {\n+    scanf (\"%f\", tmp);\n+  }\n+#pragma omp barrier\n+  return_val = *tmp;\n+#pragma omp barrier\n+#pragma omp single nowait\n+  {\n+    free (tmp);\n+  }\n+  return return_val;\n+}"}, {"sha": "e5ae7a61efc0129563141cc80ffa35e4ef84c252", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.34.1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.34.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.34.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.34.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+\n+void\n+work (int i, int j)\n+{\n+}\n+\n+void\n+good_nesting (int n)\n+{\n+  int i, j;\n+#pragma omp parallel default(shared)\n+  {\n+#pragma omp for\n+    for (i = 0; i < n; i++)\n+      {\n+#pragma omp parallel shared(i, n)\n+\t{\n+#pragma omp for\n+\t  for (j = 0; j < n; j++)\n+\t    work (i, j);\n+\t}\n+      }\n+  }\n+}"}, {"sha": "7cc265fec02e64bbb9f76735a21a869f3d26abab", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.34.2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.34.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.34.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.34.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+void\n+work (int i, int j)\n+{\n+}\n+\n+void\n+work1 (int i, int n)\n+{\n+  int j;\n+#pragma omp parallel default(shared)\n+  {\n+#pragma omp for\n+    for (j = 0; j < n; j++)\n+      work (i, j);\n+  }\n+}\n+void\n+good_nesting2 (int n)\n+{\n+  int i;\n+#pragma omp parallel default(shared)\n+  {\n+#pragma omp for\n+    for (i = 0; i < n; i++)\n+      work1 (i, n);\n+  }\n+}"}, {"sha": "95556c948c717378cfcaaa985d5c71b225c18dd9", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+void\n+work (int i, int j)\n+{\n+}\n+\n+void\n+wrong1 (int n)\n+{\n+#pragma omp parallel default(shared)\n+  {\n+    int i, j;\n+#pragma omp for\n+    for (i = 0; i < n; i++)\n+      {\n+\t/* incorrect nesting of loop regions */\n+#pragma omp for\n+\tfor (j = 0; j < n; j++)\n+\t  work (i, j);\n+      }\n+  }\n+}"}, {"sha": "165c86e278f3cd0846331f876307afed430f739a", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+\n+void work (int, int);\n+\n+void\n+work1 (int i, int n)\n+{\n+  int j;\n+  /* incorrect nesting of loop regions */\n+#pragma omp for\n+  for (j = 0; j < n; j++)\n+    work (i, j);\n+}\n+\n+void\n+wrong2 (int n)\n+{\n+#pragma omp parallel default(shared)\n+  {\n+    int i;\n+#pragma omp for\n+    for (i = 0; i < n; i++)\n+      work1 (i, n);\n+  }\n+}"}, {"sha": "f99e09b36c55be7497bb8294c9e5c1d7ceb1f3ca", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+void work (int, int);\n+\n+void\n+wrong3 (int n)\n+{\n+#pragma omp parallel default(shared)\n+  {\n+    int i;\n+#pragma omp for\n+    for (i = 0; i < n; i++)\n+      {\n+/* incorrect nesting of regions */\n+#pragma omp single\n+\twork (i, 0);\n+      }\n+  }\n+}"}, {"sha": "88824031cc2bb3187a92ec9908d4289c2c0d937b", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+void\n+wrong4 (int n)\n+{\n+#pragma omp parallel default(shared)\n+  {\n+    int i;\n+#pragma omp for\n+    for (i = 0; i < n; i++)\n+      {\n+\twork (i, 0);\n+\t/* incorrect nesting of barrier region in a loop region */\n+#pragma omp barrier\n+\twork (i, 1);\n+      }\n+  }\n+}"}, {"sha": "7b53015571ead0efcdb80d71295826ec26514a9c", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.5.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.5.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+\n+void\n+wrong5 (int n)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp critical\n+    {\n+      work (n, 0);\n+/* incorrect nesting of barrier region in a critical region */\n+#pragma omp barrier\n+      work (n, 1);\n+    }\n+  }\n+}"}, {"sha": "6385db308970b44d1e864bd5d02487ad7a330774", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.6.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+\n+void\n+wrong6 (int n)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp single\n+    {\n+      work (n, 0);\n+/* incorrect nesting of barrier region in a single region */\n+#pragma omp barrier\n+      work (n, 1);\n+    }\n+  }\n+}"}, {"sha": "3581ee27d7dabdb9227812b2aaecb56eaee86e5b", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.37.1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.37.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.37.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.37.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+extern int omp_get_num_threads (void);\n+void work (int i);\n+void\n+incorrect ()\n+{\n+  int np, i;\n+  np = omp_get_num_threads ();\t/* misplaced */\n+#pragma omp parallel for schedule(static)\n+  for (i = 0; i < np; i++)\n+    work (i);\n+}"}, {"sha": "64256c78d886b99ed8f80240fb9099f5bd69c6cb", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.37.2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.37.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.37.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.37.2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+\n+extern int omp_get_thread_num (void);\n+void work (int i);\n+void\n+correct ()\n+{\n+  int i;\n+#pragma omp parallel private(i)\n+  {\n+    i = omp_get_thread_num ();\n+    work (i);\n+  }\n+}"}, {"sha": "eed21b367ccd722f07c06b8ca08145e87dc2e1ee", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.8.1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.8.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.8.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.8.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+#include <math.h>\n+void\n+a8 (int n, int m, float *a, float *b, float *y, float *z)\n+{\n+  int i;\n+#pragma omp parallel\n+  {\n+#pragma omp for nowait\n+    for (i = 1; i < n; i++)\n+      b[i] = (a[i] + a[i - 1]) / 2.0;\n+#pragma omp for nowait\n+    for (i = 0; i < m; i++)\n+      y[i] = sqrt (z[i]);\n+  }\n+}"}, {"sha": "45be33f16ea326644d6594c3a5b711b91e2c85da", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.9.1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.9.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.9.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.9.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+void XAXIS ();\n+void YAXIS ();\n+void ZAXIS ();\n+void\n+a9 ()\n+{\n+#pragma omp parallel sections\n+  {\n+#pragma omp section\n+    XAXIS ();\n+#pragma omp section\n+    YAXIS ();\n+#pragma omp section\n+    ZAXIS ();\n+  }\n+}"}, {"sha": "3e4bc569ba7fdb1db0fa101d110efe43238fe2db", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-1.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do compile } */\n+\n+int x;\n+volatile int y;\n+volatile unsigned char z;\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    x++;\n+  #pragma omp atomic\n+    x--;\n+  #pragma omp atomic\n+    ++x;\n+  #pragma omp atomic\n+    --x;\n+  #pragma omp atomic\n+    x += 1;\n+  #pragma omp atomic\n+    x -= y;\n+  #pragma omp atomic\n+    x |= 1;\n+  #pragma omp atomic\n+    x &= 1;\n+  #pragma omp atomic\n+    x ^= 1;\n+  #pragma omp atomic\n+    x *= 3;\n+  #pragma omp atomic\n+    x /= 3;\n+  #pragma omp atomic\n+    x /= 3;\n+  #pragma omp atomic\n+    x <<= 3;\n+  #pragma omp atomic\n+    x >>= 3;\n+}\n+\n+void f2(void)\n+{\n+  #pragma omp atomic\n+    y++;\n+  #pragma omp atomic\n+    y--;\n+  #pragma omp atomic\n+    ++y;\n+  #pragma omp atomic\n+    --y;\n+  #pragma omp atomic\n+    y += 1;\n+  #pragma omp atomic\n+    y -= x;\n+  #pragma omp atomic\n+    y |= 1;\n+  #pragma omp atomic\n+    y &= 1;\n+  #pragma omp atomic\n+    y ^= 1;\n+  #pragma omp atomic\n+    y *= 3;\n+  #pragma omp atomic\n+    y /= 3;\n+  #pragma omp atomic\n+    y /= 3;\n+  #pragma omp atomic\n+    y <<= 3;\n+  #pragma omp atomic\n+    y >>= 3;\n+}\n+\n+void f3(void)\n+{\n+  #pragma omp atomic\n+    z++;\n+  #pragma omp atomic\n+    z--;\n+  #pragma omp atomic\n+    ++z;\n+  #pragma omp atomic\n+    --z;\n+  #pragma omp atomic\n+    z += 1;\n+  #pragma omp atomic\n+    z |= 1;\n+  #pragma omp atomic\n+    z &= 1;\n+  #pragma omp atomic\n+    z ^= 1;\n+  #pragma omp atomic\n+    z *= 3;\n+  #pragma omp atomic\n+    z /= 3;\n+  #pragma omp atomic\n+    z /= 3;\n+  #pragma omp atomic\n+    z <<= 3;\n+  #pragma omp atomic\n+    z >>= 3;\n+}"}, {"sha": "720ec9e8ba0dc1690e733af9a451f42f3a0a1505", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+float x, y;\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    x++;\n+  #pragma omp atomic\n+    x--;\n+  #pragma omp atomic\n+    ++x;\n+  #pragma omp atomic\n+    --x;\n+  #pragma omp atomic\n+    x += 1;\n+  #pragma omp atomic\n+    x -= y;\n+  #pragma omp atomic\n+    x *= 3;\n+  #pragma omp atomic\n+    x /= 3;\n+}"}, {"sha": "0c612a160612c3c252b89205ebb7a4b475b6bef3", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int *xyzzy;\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    xyzzy++;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"xyzzy, 4\" 1 \"gimple\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "7f27370d535b6f1f1c360d25195ee1e6b2631395", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+int a[4];\n+int *p;\n+struct S { int x; int y[4]; } s;\n+int *bar(void);\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    a[4] += 1;\n+  #pragma omp atomic\n+    *p += 1;\n+  #pragma omp atomic\n+    s.x += 1;\n+  #pragma omp atomic\n+    s.y[*p] += 1;\n+  #pragma omp atomic\n+    s.y[*p] *= 42;\n+  #pragma omp atomic\n+    *bar() += 1;\n+  #pragma omp atomic\n+    *bar() *= 42;\n+}"}, {"sha": "445f7805f7082c7178c92e22e58b2fc70ed595bb", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-5.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+\n+int x;\n+const int y;\n+int bar(void);\n+\n+void f1(void)\n+{\n+  register int z;\n+\n+  #pragma omp atomic\n+    x %= 2;\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    x = x + 1;\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    x = 1;\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    ++y;\t\t/* { dg-error \"read-only variable\" } */\n+  #pragma omp atomic\n+    y--;\t\t/* { dg-error \"read-only variable\" } */\n+  #pragma omp atomic\n+    y += 1;\t\t/* { dg-error \"read-only variable\" } */\n+  #pragma omp atomic\n+    z += 1;\t\t/* { dg-error \"register variable\" } */\n+  #pragma omp atomic\n+    bar();\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    bar() += 1;\t\t/* { dg-error \"lvalue required\" } */\n+  #pragma omp atomic a\t/* { dg-error \"expected end of line\" } */\n+    x++;\n+  #pragma omp atomic\n+    ;\t\t\t/* { dg-error \"expected expression\" } */\n+  #pragma omp atomic\n+  #pragma omp atomic\t/* { dg-error \"expected expression\" } */\n+    ;\n+  /* Check that we didn't get stuck on the pragma eol marker.  */\n+  undef;\t\t/* { dg-error \"\" } */\n+}"}, {"sha": "0d56becd85eb044104c83efa99e81971a2f6e872", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-6.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-6.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+\n+int x[10], z;\n+double y[10];\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    x[z] /= y[z];\n+}"}, {"sha": "612e97f453039bfcadd32e28f95ffdb84379edfa", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-7.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-7.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+double x, y;\n+\n+void f2(void)\n+{\n+  #pragma omp atomic\n+    y++;\n+  #pragma omp atomic\n+    y--;\n+  #pragma omp atomic\n+    ++y;\n+  #pragma omp atomic\n+    --y;\n+  #pragma omp atomic\n+    y += 1;\n+  #pragma omp atomic\n+    y -= x;\n+  #pragma omp atomic\n+    y *= 3;\n+  #pragma omp atomic\n+    y /= 3;\n+}"}, {"sha": "2f04151f0ed854ca5fa89e898978cb141c4df15d", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-8.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+long double z;\n+\n+void f3(void)\n+{\n+  #pragma omp atomic\n+    z++;\n+  #pragma omp atomic\n+    z--;\n+  #pragma omp atomic\n+    ++z;\n+  #pragma omp atomic\n+    --z;\n+  #pragma omp atomic\n+    z += 1;\n+  #pragma omp atomic\n+    z *= 3;\n+  #pragma omp atomic\n+    z /= 3;\n+}"}, {"sha": "128e9df5e4aef5dbdc4ef4603884308554a05593", "filename": "gcc/testsuite/gcc.dg/gomp/atomic-9.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fatomic-9.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+volatile int *bar(void);\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    *bar() += 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__sync_fetch_and_add\" 1 \"gimple\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "ef7c9afb18b590c588797539d709eefaae411bc2", "filename": "gcc/testsuite/gcc.dg/gomp/barrier-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+void f1(void)\n+{\n+  #pragma omp barrier\n+}\n+\n+void f2(_Bool p)\n+{\n+  if (p)\n+    {\n+      #pragma omp barrier\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_barrier\" 2 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "6e94d0c25c6906abde0ee2674cd8f3b683173493", "filename": "gcc/testsuite/gcc.dg/gomp/barrier-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+void f1(void)\n+{\n+  #pragma omp barrier a\t\t/* { dg-error \"expected end of line\" } */\n+}\n+\n+/* OpenMP 2.5, section 2.7.3:\n+\n+   Note that because the barrier construct does not have a C language\n+   statement as part of its syntax, there are some restrictions on its\n+   placement within a program. The barrier directive may only be placed\n+   in the program at a position where ignoring or deleting the directive\n+   would result in a program with correct syntax.  */\n+\n+void f2(void)\n+{\n+  label:\n+    #pragma omp barrier\n+}\t\t/* { dg-error \"label at end of compound statement\" } */\n+\n+void f3(_Bool p)\n+{\n+  if (p)\n+    #pragma omp barrier\t\t/* { dg-error \"compound statements\" } */\n+}"}, {"sha": "abc66e580fdd5c4b87c3d1c80a1e4bf11fdc3fab", "filename": "gcc/testsuite/gcc.dg/gomp/block-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  bad1:\n+  #pragma omp parallel\n+    goto bad1;\t\t\t// { dg-error \"invalid exit\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"invalid entry\" }\n+  #pragma omp parallel\n+    {\n+      bad2: ;\n+    }\n+\n+  #pragma omp parallel\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+}"}, {"sha": "76ee3974508eb1d39cffebc6025056e0c236a16b", "filename": "gcc/testsuite/gcc.dg/gomp/block-10.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-10.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+\n+void foo(int i)\n+{\n+  int j;\n+  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  {\n+  #pragma omp parallel\n+    { case 0:; }\n+  }\n+  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  {\n+  #pragma omp for\n+    for (j = 0; j < 10; ++ j)\n+      { case 1:; }\n+  }\n+  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  {\n+  #pragma omp critical\n+    { case 2:; }\n+  }\n+  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  {\n+  #pragma omp master\n+    { case 3:; }\n+  }\n+  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  {\n+  #pragma omp sections\n+    { case 4:;\n+    #pragma omp section\n+       { case 5:; }\n+    }\n+  }\n+  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  {\n+  #pragma omp ordered\n+    { default:; }\n+  }\n+}"}, {"sha": "c2800061b6e78b2ca523b536021e1a3bf41dafb9", "filename": "gcc/testsuite/gcc.dg/gomp/block-11.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-11.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,19 @@\n+/* PR c++/24516 */\n+/* { dg-do compile } */\n+\n+void\n+bar (int *p)\n+{\n+  int m;\n+#pragma omp parallel for\n+  for (m = 0; m < 1000; ++m)\n+    switch (p[m])\n+      {\n+      case 1:\n+\tp[m] = 2;\n+\tbreak;\n+      default:\n+\tp[m] = 3;\n+\tbreak;\n+      }\n+}"}, {"sha": "810b2da07b45c886ca6bb8aee0806a6801a3ee53", "filename": "gcc/testsuite/gcc.dg/gomp/block-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i, j;\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    break;\t\t\t// { dg-error \"break\" }\n+\n+  bad1:\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    goto bad1;\t\t\t// { dg-error \"invalid exit\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"invalid entry\" }\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    {\n+      bad2: ;\n+    }\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    for (j = 0; j < 10; ++j)\n+      if (i == j)\n+\tbreak;\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    continue;\n+}"}, {"sha": "160047c394cb263021a8c839f2b41b25a0aaccfc", "filename": "gcc/testsuite/gcc.dg/gomp/block-3.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do compile }\n+\n+extern int test(int);\n+void foo()\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; ++i)\n+    {\n+      #pragma omp sections\n+      {\n+\tcontinue;\t\t// { dg-error \"invalid exit\" }\n+      }\n+    }\n+\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      { bad1: ; }\n+    #pragma omp section\n+      goto bad1;\t\t// { dg-error \"invalid exit\" }\n+    }\n+\n+  #pragma omp sections\n+    {\n+      goto bad2;\t\t// { dg-error \"invalid exit\" }\n+    }\n+  bad2:;\n+\n+  goto bad3;\t\t\t// { dg-error \"invalid entry\" }\n+  #pragma omp sections\n+    {\n+      bad3: ;\n+    }\n+\n+  #pragma omp sections\n+    {\n+      goto ok1;\n+      ok1:;\n+\n+    #pragma omp section\n+      for (i = 0; i < 10; ++i)\n+\tif (test(i))\n+\t  break;\n+\telse\n+\t  continue;\n+\n+    #pragma omp section\n+      switch (i)\n+\t{\n+\tcase 0:\n+\t  break;\n+\tdefault:\n+\t  test(i);\n+\t}\n+    }\n+}"}, {"sha": "815d36b2e3950017b7915971a0012bca40c93bf1", "filename": "gcc/testsuite/gcc.dg/gomp/block-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  #pragma omp critical\n+    {\n+      return;\t\t// { dg-error \"invalid exit\" }\n+    }\n+}"}, {"sha": "450106feeb13d1339e01e8ab0f6c14fa0a140ae8", "filename": "gcc/testsuite/gcc.dg/gomp/block-5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  #pragma omp master\n+    {\n+      goto bad1;\t// { dg-error \"invalid exit\" }\n+    }\n+\n+  #pragma omp master\n+    {\n+    bad1:\n+      return;\t\t// { dg-error \"invalid exit\" }\n+    }\n+}"}, {"sha": "fa4c5eab5f4cbc6f2c5a61577ce79164bf526846", "filename": "gcc/testsuite/gcc.dg/gomp/block-6.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  #pragma omp ordered\n+    {\n+      return;\t\t// { dg-error \"invalid exit\" }\n+    }\n+}"}, {"sha": "802b3b3a383feb89e70fc806e2bc2e5ea9acc824", "filename": "gcc/testsuite/gcc.dg/gomp/block-7.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i, j;\n+  for (i = 0; i < 10; ++i)\n+    {\n+      #pragma omp for\n+      for (j = ({ continue; 0; });\t// { dg-error \"invalid exit\" }\n+\t   j < ({ continue; 10; });\t// { dg-error \"invalid exit\" }\n+\t   j += ({ continue; 1; }))\t// { dg-error \"invalid exit\" }\n+\tcontinue;\n+\n+      #pragma omp for\n+      for (j = ({ break; 0; });\t\t// { dg-error \"invalid exit\" }\n+\t   j < ({ break; 10; });\t// { dg-error \"invalid exit\" }\n+\t   j += ({ break; 1; }))\t// { dg-error \"invalid exit\" }\n+\tbreak;\t\t\t\t// { dg-error \"break\" }\n+    }\n+}"}, {"sha": "177acaa28c0426b2f0019886973941ab08e1c7c5", "filename": "gcc/testsuite/gcc.dg/gomp/block-8.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+// PR 24451\n+\n+int foo()\n+{\n+  int i;\n+\n+  #pragma omp parallel for\n+  for (i = 0; i < 10; ++i)\n+    return 0;\t\t\t// { dg-error \"invalid exit\" }\n+}"}, {"sha": "9217cb74990232687cb5e2c381a71c319d30abd2", "filename": "gcc/testsuite/gcc.dg/gomp/block-9.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-9.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+\n+void foo(int i)\n+{\n+  int j;\n+  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  {\n+  #pragma omp parallel\n+    { case 0:; }\n+  #pragma omp for\n+    for (j = 0; j < 10; ++ j)\n+      { case 1:; }\n+  #pragma omp critical\n+    { case 2:; }\n+  #pragma omp master\n+    { case 3:; }\n+  #pragma omp sections\n+    { case 4:;\n+    #pragma omp section\n+       { case 5:; }\n+    }\n+  #pragma omp ordered\n+    { default:; }\n+  }\n+}"}, {"sha": "ace9738043a98016e8f6ed24653e3398f79f3ec6", "filename": "gcc/testsuite/gcc.dg/gomp/clause-1.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+#define p parallel\n+\n+extern void bar (void);\n+extern char q[];\n+int t;\n+#pragma omp threadprivate (t)\n+\n+void\n+foo (int x)\n+{\n+  char *p;\n+  struct S { int i; int j; } s;\n+  char a[32];\n+  double d;\n+  int i;\n+  const int c = 8;\n+#pragma omp p shared (x, x) /* { dg-error \"more than once\" } */\n+    ;\n+#pragma omp p private (x) private (x) /* { dg-error \"more than once\" } */\n+    ;\n+#pragma omp p shared (x) firstprivate (x) /* { dg-error \"more than once\" } */\n+    ;\n+#pragma omp p firstprivate (x, x) /* { dg-error \"more than once\" } */\n+    ;\n+#pragma omp p for shared (x) lastprivate (x) /* { dg-error \"more than\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p for private (x) lastprivate (x) /* { dg-error \"more than\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p for lastprivate (x, x) /* { dg-error \"more than once\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp single private (x) copyprivate (x) /* { dg-error \"more than\" } */\n+    ;\n+#pragma omp p shared (bar) /* { dg-error \"is not a variable\" } */\n+    ;\n+#pragma omp p private (bar) /* { dg-error \"is not a variable\" } */\n+    ;\n+#pragma omp p firstprivate (bar) /* { dg-error \"is not a variable\" } */\n+    ;\n+#pragma omp p reduction (+:p) /* { dg-error \"has invalid type for\" } */\n+    ;\n+#pragma omp p reduction (*:s) /* { dg-error \"has invalid type for\" } */\n+    ;\n+#pragma omp p reduction (-:a) /* { dg-error \"has invalid type for\" } */\n+    ;\n+  d = 0;\n+#pragma omp p reduction (*:d)\n+    ;\n+#pragma omp p reduction (|:d) /* { dg-error \"has invalid type for\" } */\n+    ;\n+#pragma omp p reduction (&&:d) /* { dg-error \"has invalid type for\" } */\n+    ;\n+#pragma omp p copyin (d) /* { dg-error \"must be 'threadprivate'\" } */\n+    ;\n+#pragma omp p copyin (x) /* { dg-error \"must be 'threadprivate'\" } */\n+    ;\n+#pragma omp p for firstprivate (x) lastprivate (x)\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p private (q) /* { dg-error \"incomplete type\" } */\n+    ;\n+#pragma omp p firstprivate (q) /* { dg-error \"incomplete type\" } */\n+    ;\n+#pragma omp p for lastprivate (q) /* { dg-error \"incomplete type\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p shared (t) /* { dg-error \"predetermined 'threadprivate'\" } */\n+    ;\n+#pragma omp p private (t) /* { dg-error \"predetermined 'threadprivate'\" } */\n+    ;\n+#pragma omp p firstprivate (t) /* { dg-error \"predetermined 'threadpriv\" } */\n+    ;\n+#pragma omp p for lastprivate (t) /* { dg-error \"predetermined 'threadpr\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p reduction (*:t) /* { dg-error \"predetermined 'threadprivate\" } */\n+    ;\n+#pragma omp p shared (c) /* { dg-error \"predetermined 'shared'\" } */\n+    ;\n+#pragma omp p private (c) /* { dg-error \"predetermined 'shared'\" } */\n+    ;\n+#pragma omp p firstprivate (c) /* { dg-error \"predetermined 'shared'\" } */\n+    ;\n+#pragma omp p for lastprivate (c) /* { dg-error \"predetermined 'shared'\" } */\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p reduction (*:c) /* { dg-error \"predetermined 'shared'\" } */\n+    ;\n+}"}, {"sha": "117f82f8134f75d3ff67a8d53132f3769fbdb003", "filename": "gcc/testsuite/gcc.dg/gomp/copyin-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcopyin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcopyin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcopyin-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls }\n+\n+int i, j;\n+\n+#pragma omp threadprivate (i)\n+\n+void bar(void);\n+void foo(void)\n+{\n+  int k;\n+  extern int l;\n+  extern int m;\n+\n+#pragma omp threadprivate (m)\n+\n+  #pragma omp parallel copyin(i)\n+    bar();\n+  #pragma omp parallel copyin(j)\t// { dg-error \"threadprivate\" }\n+    bar();\n+  #pragma omp parallel copyin(k)\t// { dg-error \"threadprivate\" }\n+    bar();\n+  #pragma omp parallel copyin(l)\t// { dg-error \"threadprivate\" }\n+    bar();\n+  #pragma omp parallel copyin(m)\n+    bar();\n+}"}, {"sha": "bdc7bad7b823de5bbf6743dbf064089e02fad036", "filename": "gcc/testsuite/gcc.dg/gomp/critical-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp critical\n+    bar(0);\n+\n+  /* Note that \"name\" is in its own namespace, thus this foo is not\n+     the same as the function.  */\n+  #pragma omp critical(foo)\n+  {\n+    bar(1);\n+    bar(2);\n+  }\n+\n+  #pragma omp critical\n+  #pragma omp critical(foo)\n+    bar(3);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_start\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_end\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_start\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_end\" 2 \"omplower\" } } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "d1ba3963f8f0fe73fde3c4dc654afadcc8eae466", "filename": "gcc/testsuite/gcc.dg/gomp/critical-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+\n+void f1(void)\n+{\n+  #pragma omp critical a\t/* { dg-error \"expected\" } */\n+    ;\n+  #pragma omp critical (\t/* { dg-error \"expected identifier\" } */\n+    ;\n+  #pragma omp critical (a\t/* { dg-error \"expected .\\\\).\" } */\n+    ;\n+  #pragma omp critical (a b)\t/* { dg-error \"expected .\\\\).\" } */\n+}\t\t\t\t/* { dg-error \"expected expression\" } */"}, {"sha": "9cd73ac046c282ed94b29f04f0ad3a3e63d3d2fa", "filename": "gcc/testsuite/gcc.dg/gomp/critical-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-omplower\" }\n+\n+void bar(void);\n+void foo(void)\n+{\n+  #pragma omp critical (xyzzy)\n+    bar();\n+}\n+\n+// { dg-final { scan-tree-dump-times \"\\\\&\\\\.gomp_critical_user_xyzzy\" 2 \"omplower\" } }"}, {"sha": "18af1d80d119e8cae7af8ed40e3f961a159a9e30", "filename": "gcc/testsuite/gcc.dg/gomp/empty.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fempty.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fempty.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fempty.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fopenmp -fdump-tree-omplower\" } */\n+\n+main()\n+{\n+#pragma omp parallel\n+    {;}\n+}\n+\n+/* There should not be a GOMP_parallel_start call.  */\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_start\" 0 \"omplower\"} } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "d1a4d4a5bfb2debc35d4fdd5be3a044c3634f06f", "filename": "gcc/testsuite/gcc.dg/gomp/flush-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fflush-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fflush-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fflush-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+void f1(void)\n+{\n+  #pragma omp flush\n+}\n+\n+int x, y, z;\n+\n+void f2(_Bool p)\n+{\n+  if (p)\n+    {\n+      #pragma omp flush (x)\n+    }\n+  else\n+    {\n+      #pragma omp flush (x, y, z)\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__sync_synchronize\" 3 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "c2685d837ae0b70b495372eaad3b10c02e1ac80e", "filename": "gcc/testsuite/gcc.dg/gomp/flush-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fflush-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fflush-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fflush-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+\n+void f1(void)\n+{\n+  #pragma omp flush a\t/* { dg-error \"expected\" } */\n+  #pragma omp flush (\t/* { dg-error \"expected identifier\" } */\n+  #pragma omp flush (b\t/* { dg-error \"undeclared|expected|for each\" } */\n+  #pragma omp flush (c d)\t/* { dg-error \"undeclared|expected\" } */\n+  #pragma omp flush (e)\t\t/* { dg-error \"undeclared\" } */\n+}"}, {"sha": "59b1528e49215d0aa012c74d52fc342fe5d8b88e", "filename": "gcc/testsuite/gcc.dg/gomp/for-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+\n+void foo (int j, int k)\n+{\n+  int i;\n+\n+  /* Valid loops.  */\n+  #pragma omp for\n+  for (i = 0; i < 10; i++)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = j; i <= 10; i+=4)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = j; i > 0; i = i - 1)\n+    baz (j);\n+\n+  #pragma omp for\n+  for (i = j; i >= k; i--)\n+    baz (i);\n+\n+  /* Malformed parallel loops.  */\n+  #pragma omp for\n+  i = 0;\t\t/* { dg-error \"for statement expected\" } */\n+  for ( ; i < 10; )\n+    {\n+      baz (i);\n+      i++;\n+    }\n+\n+  #pragma omp for\n+  for (i = 0; ; i--)\t/* { dg-error \"missing controlling predicate\" } */\n+    {\n+      if (i >= 10)\n+\tbreak;\t\t/* { dg-error \"break\" } */\n+      baz (i);\n+    }\n+\n+  #pragma omp for\n+  for (i = 0; i < 10 && j > 4; i-=3)\t/* { dg-error \"invalid controlling predicate\" } */\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; i-=3, j+=2)\t/* { dg-error \"invalid increment expression\" } */\n+    baz (i);\n+}"}, {"sha": "9dfac165b0a62682bb5d98c42be8833a0cbc1419", "filename": "gcc/testsuite/gcc.dg/gomp/for-10.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-10.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(runtime) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_start\" 1 \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_next\" 1 \"lower\" } } */\n+/* { dg-final { cleanup-tree-dump \"lower\" } } */"}, {"sha": "8c747cdb981d616aa6fb70e5b48a81edb0abb3b1", "filename": "gcc/testsuite/gcc.dg/gomp/for-11.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-11.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -fopenmp\" } */\n+\n+extern void baz (int);\n+\n+void foo (int j, int k)\n+{\n+  int i;\n+\n+  /* Valid loops.  */\n+  #pragma omp for\n+  for (i = 0; i < 10; i++)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = j; i <= 10; i+=4)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = j; i > 0; i = i - 1)\n+    baz (j);\n+\n+  #pragma omp for\n+  for (i = j; i >= k; i--)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (int l = j; l < 10; l++)\n+    baz (l);\n+\n+  /* Malformed parallel loops.  */\n+  #pragma omp for\n+  i = 0;\t\t/* { dg-error \"for statement expected\" } */\n+  for ( ; i < 10; )\n+    {\n+      baz (i);\n+      i++;\n+    }\n+\n+  #pragma omp for\n+  for (i = 0; ; i--)\t/* { dg-error \"missing controlling predicate\" } */\n+    {\n+      if (i >= 10)\n+\tbreak;\t\t/* { dg-error \"break\" } */\n+      baz (i);\n+    }\n+\n+  #pragma omp for\n+  for (i = 0;\n+       i < 10 && j > 4; /* { dg-error \"invalid controlling predicate\" } */\n+       i-=3)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = 0;\n+       i < 10;\n+       i-=3, j+=2)\t/* { dg-error \"invalid increment expression\" } */\n+    baz (i);\n+\n+  int m = 0;\n+  #pragma omp for\n+  for (; m < 10; m++)\t/* { dg-error \"expected\" } */\n+    baz (m);\n+\n+  m = 0;\n+  #pragma omp for\n+  for (int n = 0; m < 10; m++)\t/* { dg-error \"invalid controlling predicate|invalid increment expression\" } */\n+    baz (m);\n+\n+  #pragma omp for\n+  for (m = 0; m < 10; i++)\t/* { dg-error \"invalid increment expression\" } */\n+    baz (m);\n+}"}, {"sha": "98318d7d5aec216412e4f1c8f145ac9c6d7d8c99", "filename": "gcc/testsuite/gcc.dg/gomp/for-12.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-12.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,12 @@\n+int foo (void)\n+{\n+  int i, a;\n+\n+  a = 30;\n+\n+  #pragma omp parallel for lastprivate (a)\n+  for (i = 0; i < 10; i++)\n+    a = a + i;\n+\n+  return a;\n+}"}, {"sha": "16e971f1927142e27838a753067fb4b37a60cf05", "filename": "gcc/testsuite/gcc.dg/gomp/for-13.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-13.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+// At one point in development, a typo disabled the remapping of the\n+// for iteration variable as private.\n+\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-lower\" }\n+\n+extern void bar(int);\n+void foo(void)\n+{\n+  int i;\n+\n+#pragma omp parallel for default(none)\n+  for (i = 0; i < 10; i++)\n+    bar(i);\n+}\n+\n+// { dg-final { scan-tree-dump-times \"omp_data_o\" 0 \"lower\" } }\n+// { dg-final { cleanup-tree-dump \"lower\" } }"}, {"sha": "fb26413702580d956d9f5a092ffb5836d27f909f", "filename": "gcc/testsuite/gcc.dg/gomp/for-14.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-14.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+\n+extern int printf (const char *, ...);\n+extern void foo (int *);\n+\n+int main (void)\n+{\n+  double d = 6;\n+  int i = 1, j = 6, k = 8;\n+#pragma omp parallel shared(d) private(i) num_threads (4)\n+  {\n+    i = 4;\n+#pragma omp for lastprivate(j)\n+    for (j = 1; j <= k; j++)\n+      printf (\"%s %d %d %d %p %g\\n\", \"Hello, World!\", i, j, k, &j, d);\n+    printf (\"%s %d %g\\n\", \"Hello, World!\", i, d);\n+  }\n+  return 0;\n+}"}, {"sha": "28c2c926cb7daaddc8cacaa04d2c2708b72ee811", "filename": "gcc/testsuite/gcc.dg/gomp/for-15.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-15.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void foo()\n+{\n+\tlong n = 10;\n+\tint i;\n+#pragma omp for\n+\tfor (i=0; i < n; ++i) ;\n+#pragma omp for\n+\tfor (i=0; n > i; ++i) ;\n+}"}, {"sha": "2f221e4c13af601c9eed577377dd98b14cdb7301", "filename": "gcc/testsuite/gcc.dg/gomp/for-16.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-16.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+// PR 24703\n+// { dg-do compile }\n+\n+void work(int);\n+int work_param;\n+int sphinx_omp_thread_count;\n+int schedule_loop_cap;\n+\n+int measure_omp_parallel_for_dynamic (void)\n+{\n+  int j;\n+\n+#pragma omp parallel for schedule(dynamic)\n+  for(j=0; j < sphinx_omp_thread_count * schedule_loop_cap; j++)\n+    work(work_param);\n+\n+  return 0;\n+}"}, {"sha": "1c51f1a4c860ac1b6e366a9a2a96b9b52d7ad3d6", "filename": "gcc/testsuite/gcc.dg/gomp/for-17.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-17.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */\n+extern int bar (int);\n+\n+void\n+foo (void)\n+{\n+  int j, k = 1, l = 30, m = 4;\n+  long int o = 4;\n+  long long int p = 0;\n+#pragma omp for\n+  for (j = k; j <= l; j += m - 1)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += bar (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + m - 1)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + bar (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = ({ int n; n = k; n; }); j <= l; j++)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= ({ int n; n = l; n; }); j++)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += ({ int n; n = 1; n; }))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += m + 1)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += o)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + o)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = o + 1 + j)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = o + m + j)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += o + p)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + o + p)\n+    ;\n+#pragma omp for\n+  for (j = l; j >= k; j -= o)\n+    ;\n+#pragma omp for\n+  for (j = l; j >= k; j -= p)\n+    ;\n+#pragma omp for\n+  for (j = l; j >= k; j -= o + p)\n+    ;\n+}"}, {"sha": "c875a0c5f818893d3f0cb0a27d379c1a14d905d4", "filename": "gcc/testsuite/gcc.dg/gomp/for-18.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-18.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fopenmp -fdump-tree-omplower\" } */\n+\n+void\n+foo (int *a, int i)\n+{\n+  int j, k = 1, l = 30, m = 4;\n+#pragma omp parallel for num_threads (3 * i) schedule (dynamic, i * 4)\n+  for (j = 0; j <= l; j++)\n+    a[j] = 1;\n+#pragma omp parallel for num_threads (3 * i) schedule (dynamic, i * 4)\n+  for (j = k; j <= l; j += (m - 1))\n+    a[j] = 2;\n+#pragma omp parallel for num_threads (3 * i) schedule (dynamic, 4)\n+  for (j = 0; j <= l; j++)\n+    a[j] = 3;\n+#pragma omp parallel for num_threads (3 * i) schedule (dynamic, 4)\n+  for (j = k; j <= l; j += (m - 1))\n+    a[j] = 4;\n+}\n+\n+void\n+bar (int *a, int i)\n+{\n+  int j, k = 1, l = 30, m = 4;\n+#pragma omp parallel for num_threads (3 * i) schedule (guided, i * 4)\n+  for (j = 0; j <= l; j++)\n+    a[j] = 1;\n+#pragma omp parallel for num_threads (3 * i) schedule (guided, i * 4)\n+  for (j = k; j <= l; j += (m - 1))\n+    a[j] = 2;\n+#pragma omp parallel for num_threads (3 * i) schedule (guided, 4)\n+  for (j = 0; j <= l; j++)\n+    a[j] = 3;\n+#pragma omp parallel for num_threads (3 * i) schedule (guided, 4)\n+  for (j = k; j <= l; j += (m - 1))\n+    a[j] = 4;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_dynamic_start\" 4 \"omplower\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_guided_start\" 4 \"omplower\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "a202ba4799f6140bbae42fff854916abe599047d", "filename": "gcc/testsuite/gcc.dg/gomp/for-19.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-19.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,21 @@\n+/* Verify that if GOMP_parallel_loop_dynamic_start is used, variables\n+   mentioned in the INIT, COND and INCR expressions aren't unnecessarily\n+   copied to the omp_fn function.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fopenmp -fdump-tree-gimple\" } */\n+\n+void foo (int *a, int i, int j, int k, int l, int m)\n+{\n+#pragma omp parallel for num_threads (3 * i) schedule (dynamic, i * 4)\n+  for (j = 0; j <= (6 * l + 4 * k); j++)\n+    a[j] = 1;\n+#pragma omp parallel for num_threads (3 * i) schedule (dynamic, i * 4)\n+  for (j = m; j <= l; j += (k + l - m))\n+    a[j] = 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a\\\\)\" 2 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(k\\\\)\" 0 \"gimple\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(l\\\\)\" 0 \"gimple\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(m\\\\)\" 0 \"gimple\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "37e5929afa124b455fbb669db71ea58f4a784ddb", "filename": "gcc/testsuite/gcc.dg/gomp/for-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp for nowait\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for nowait nowait\t\t/* { dg-error \"too many\" } */\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for ordered\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for ordered ordered\t/* { dg-error \"too many\" } */\n+  for (i = 0; i < 10; ++i) ;\n+}"}, {"sha": "f3b0dbda7c8847e5d2d3e6d78a4bab2343f285e3", "filename": "gcc/testsuite/gcc.dg/gomp/for-3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,62 @@\n+// { dg-do compile }\n+\n+int bar ();\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp for schedule\t\t// { dg-error \"expected '\\\\('\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule static\t// { dg-error \"expected '\\\\('\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (\t\t// { dg-error \"invalid schedule kind\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static )\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( foo )\t// { dg-error \"invalid schedule kind\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static 1\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static 1 ) nowait\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1 ) nowait\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1, 1 ) nowait\t// { dg-error \"expected '\\\\)'\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1 + 1 ) nowait\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1.0 )\t// { dg-error \"expected integer expression\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (dynamic)\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (dynamic, bar ())\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (guided)\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (guided, bar ())\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (runtime)\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (runtime, bar ())\t// { dg-error \"does not take\" }\n+  for (i = 0; i < 10; ++i) ;\n+}"}, {"sha": "c5f1bb8d13df6df83c1f46b0aac675268ceca161", "filename": "gcc/testsuite/gcc.dg/gomp/for-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(dynamic)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_start\" 1 \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_next\" 1 \"lower\" } } */\n+/* { dg-final { cleanup-tree-dump \"lower\" } } */"}, {"sha": "6d9722a97f418a8035504fbbca5c033b19087faa", "filename": "gcc/testsuite/gcc.dg/gomp/for-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(guided)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_start\" 1 \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_next\" 1 \"lower\" } } */\n+/* { dg-final { cleanup-tree-dump \"lower\" } } */"}, {"sha": "9361205e7575d128e7152d87b3391bb0bb7a3c34", "filename": "gcc/testsuite/gcc.dg/gomp/for-6.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(runtime)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_start\" 1 \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_next\" 1 \"lower\" } } */\n+/* { dg-final { cleanup-tree-dump \"lower\" } } */"}, {"sha": "b3eb997cb3825e3088abb080ae8daa7ef29bd8f9", "filename": "gcc/testsuite/gcc.dg/gomp/for-7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-7.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(static) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_start\" 1 \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_next\" 1 \"lower\" } } */\n+/* { dg-final { cleanup-tree-dump \"lower\" } } */"}, {"sha": "c1386ce4a414a01fd7508eacc8375b7f22c28823", "filename": "gcc/testsuite/gcc.dg/gomp/for-8.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-8.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(dynamic) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_start\" 1 \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_next\" 1 \"lower\" } } */\n+/* { dg-final { cleanup-tree-dump \"lower\" } } */"}, {"sha": "2a554d515271024adc702aa1e7f0721327c34bcd", "filename": "gcc/testsuite/gcc.dg/gomp/for-9.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-9.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(guided) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_start\" 1 \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_next\" 1 \"lower\" } } */\n+/* { dg-final { cleanup-tree-dump \"lower\" } } */"}, {"sha": "cb1b338468964d4ba439d3741a7858298d6911e4", "filename": "gcc/testsuite/gcc.dg/gomp/gomp.exp", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fgomp.exp?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,14 @@\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [find $srcdir/$subdir *.c]] \\\n+\t\"\" \"-fopenmp\"\n+\n+# All done.\n+dg-finish"}, {"sha": "b04610d2ccf78b755659fbd5cbebf1dd516e74b6", "filename": "gcc/testsuite/gcc.dg/gomp/macro-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmacro-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmacro-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmacro-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+\n+#define N 10\n+\n+extern void bar(void);\n+void foo(void)\n+{\n+  #pragma omp parallel num_threads(N)\n+    bar();\n+}"}, {"sha": "75d6490cd7c3d3889ef68f1dbc46a302e5eca975", "filename": "gcc/testsuite/gcc.dg/gomp/macro-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmacro-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmacro-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmacro-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+#define p\tparallel\n+#define s(x)\tshared(x##1, x##2)\n+#define d(x)\tdefault(x)\n+\n+void bar(int, int, int, int);\n+void foo(void)\n+{\n+  int a1, a2, b1, b2;\n+\n+  #pragma omp p s(a) s(b) d(none)\n+    bar(a1, a2, b1, b2);\n+}"}, {"sha": "2681c216a3ff79dd086b715798af4e3619480e75", "filename": "gcc/testsuite/gcc.dg/gomp/master-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp master\n+    bar(0);\n+\n+  #pragma omp master\n+  {\n+    bar(1);\n+    bar(2);\n+  }\n+\n+  /* Yes, this is legal -- structured-block contains statement contains\n+     openmp-construct contains master-construct.  */\n+  #pragma omp master\n+  #pragma omp master\n+  #pragma omp master\n+    ;\n+}"}, {"sha": "3b0bdfc90a465a4896ace6b64894680a519c383e", "filename": "gcc/testsuite/gcc.dg/gomp/master-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+void f1(void)\n+{\n+  #pragma omp master asdf\t/* { dg-error \"expected\" } */\n+  #pragma omp master\n+}\t\t\t\t/* { dg-error \"expected expression\" } */"}, {"sha": "37966106df58a4af596743b1ee63caa787a32778", "filename": "gcc/testsuite/gcc.dg/gomp/master-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp master\n+    bar(0);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"omp_get_thread_num\" 1 \"omplower\" } } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "f792ef96bcde2d9bf7c1a5891ad8d236d8230938", "filename": "gcc/testsuite/gcc.dg/gomp/num-threads-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnum-threads-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnum-threads-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnum-threads-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+\n+extern void bar(void);\n+void foo(void)\n+{\n+  #pragma omp parallel num_threads (0)\t/* { dg-warning \"must be positive\" } */\n+    {\n+      bar ();\n+    }\n+}"}, {"sha": "ca06aeef9ef72250b4c003553bcb67af20a9c2ad", "filename": "gcc/testsuite/gcc.dg/gomp/omp-parallel-if.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fomp-parallel-if.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fomp-parallel-if.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fomp-parallel-if.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+extern int foo(void);\n+extern void bar(void);\n+\n+int main ()\n+{\n+  /* Malformed uses of 'if' and 'num_threads'.  */\n+  #pragma omp parallel if (foo () > 10) if (foo () == 3) /* { dg-error \"too many\" } */\n+    {\n+      bar ();\n+    }\n+\n+  #pragma omp parallel num_threads (3) num_threads (20)\t/* { dg-error \"too many\" } */\n+    {\n+      bar ();\n+    }\n+\n+  /* Valid uses of 'if' and 'num_threads'.  */\n+  #pragma omp parallel if (foo () == 10) num_threads (foo ())\n+    {\n+      bar ();\n+    }\n+}"}, {"sha": "a1cd7f486028d190698de65cc27be78b8b2bb3c9", "filename": "gcc/testsuite/gcc.dg/gomp/ordered-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp ordered\n+    bar(0);\n+\n+  #pragma omp ordered\n+  {\n+    bar(1);\n+    bar(2);\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_ordered_start\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_ordered_end\" 2 \"omplower\" } } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "2884b10261c2d1cb7ff609cd66b49365892fd8ed", "filename": "gcc/testsuite/gcc.dg/gomp/ordered-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+void f1(void)\n+{\n+  #pragma omp ordered asdf\t/* { dg-error \"expected\" } */\n+  #pragma omp ordered\n+}\t\t\t\t/* { dg-error \"expected expression\" } */"}, {"sha": "c5c233b76eb89bd36884522cf06aad216f56c5a0", "filename": "gcc/testsuite/gcc.dg/gomp/parallel-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp parallel\n+    {\n+    #pragma omp parallel\n+      {\n+      #pragma omp parallel\n+        {\n+ \t  i++;\n+\t}\n+      }\n+    }\n+}"}, {"sha": "68e577766b1f481a39f1bb1c117d5faab4cca3c8", "filename": "gcc/testsuite/gcc.dg/gomp/parallel-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp parallel default(none)\t\t// { dg-error \"enclosing\" }\n+    {\n+    #pragma omp parallel\n+      {\n+      #pragma omp parallel default(none)\t// { dg-error \"enclosing\" }\n+        {\n+ \t  i++;\t\t\t\t\t// { dg-error \"not specified\" }\n+\t}\n+      }\n+    }\n+}"}, {"sha": "633d7ba5998301c4e84a6eabfbfad8de40f7bf8d", "filename": "gcc/testsuite/gcc.dg/gomp/parallel-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+\n+extern int printf (const char *, ...);\n+\n+int main (void)\n+{\n+  double d = 6;\n+  int i = 1;\n+#pragma omp parallel shared(d) private(i) num_threads (4 + i)\n+  {\n+    i = 4;\n+    printf (\"%s %d %g\\n\", \"Hello, World!\", i, d);\n+  }\n+  return 0;\n+}"}, {"sha": "b8cd174a31b479bda91092cc759123c2964dee46", "filename": "gcc/testsuite/gcc.dg/gomp/parallel-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fparallel-4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+extern void bar (void);\n+\n+int main (void)\n+{\n+  int i;\n+#pragma omp parallel for nowait /* { dg-error \"'nowait'\" } */\n+  for (i = 0; i < 10; i++)\n+    bar ();\n+}"}, {"sha": "43704908e43de34b39717efbe1c65bcacf9d65aa", "filename": "gcc/testsuite/gcc.dg/gomp/sections-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+\n+extern void bar(int);\n+\n+void f1(void)\n+{\n+  #pragma omp sections nowait\n+    {\n+      bar (1);\n+    #pragma omp section\n+      bar (2);\n+    #pragma omp section\n+      bar (3);\n+    #pragma omp section\n+      bar (4);\n+    #pragma omp section\n+      bar (5);\n+    }\n+}\n+\n+void f2(void)\n+{\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      {\n+        bar (1);\n+        bar (1);\n+      }\n+    #pragma omp section\n+      bar (2);\n+    #pragma omp section\n+      bar (3);\n+    #pragma omp section\n+      bar (4);\n+    #pragma omp section\n+      bar (5);\n+    }\n+}"}, {"sha": "aabdfaf8069aef31c2c0eda8f23c02c04ad1fe03", "filename": "gcc/testsuite/gcc.dg/gomp/sections-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+extern void bar(int);\n+void foo(void)\n+{\n+  #pragma omp sections\n+    bar (0);\t\t// { dg-error \"expected\" }\n+\n+  #pragma omp sections\n+    {\n+    }\t\t\t// { dg-error \"expected\" }\n+\n+  #pragma omp sections\n+    {\n+      bar (1);\n+    }\n+\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      bar(2);\n+      bar(3);\t\t// { dg-error \"expected\" }\n+      bar(4);\n+    #pragma omp section\n+      bar(5);\n+      bar(6);\t\t// { dg-error \"expected\" }\n+      bar(7);\n+    }\n+}"}, {"sha": "d8fb2a09d3059e4a734e4dfbd8c13d5cf325adfe", "filename": "gcc/testsuite/gcc.dg/gomp/sections-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,15 @@\n+\n+// { dg-do compile }\n+\n+extern void bar (void);\n+\n+int main (void)\n+{\n+  #pragma omp parallel sections nowait /* { dg-error \"'nowait'\" } */\n+    {\n+    #pragma omp section\n+\t{ bar(); }\n+    #pragma omp section\n+\t{ bar(); }\n+    }\n+}"}, {"sha": "44e7de98c209f7e6fe52fc33a8a2c4ac540781eb", "filename": "gcc/testsuite/gcc.dg/gomp/sections-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsections-4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,13 @@\n+/* PR c++/24613 */\n+/* { dg-compile } */\n+\n+#pragma omp section\t/* { dg-error \"may only be used in\" } */\n+\n+int i;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp section\t/* { dg-error \"may only be used in\" } */\n+    i++;\n+}"}, {"sha": "90d389b7292592fcb53f02997f5d8d07dde48d39", "filename": "gcc/testsuite/gcc.dg/gomp/sharing-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+#include <stdlib.h>\n+\n+int thrglobalvar;\n+#pragma omp threadprivate (thrglobalvar)\n+int globalvar;\n+const int constvar = 8;\n+\n+int\n+foo (int x)\n+{\n+  return x;\n+}\n+\n+int\n+bar (int *x)\n+{\n+  return *x;\n+}\n+\n+int\n+main (void)\n+{\n+  static int thrlocvar;\n+#pragma omp threadprivate (thrlocvar)\n+  static int locvar;\n+  static int *p;\n+  int i, j, s, l;\n+\n+  p = malloc (sizeof (int));\n+  if (p == NULL)\n+    return 0;\n+  *p = 7;\n+  s = 6;\n+  l = 0;\n+#pragma omp parallel for /* { dg-error \"enclosing parallel\" } */ \\\n+  default (none) private (p) shared (s) \n+  for (i = 0; i < 64; i++)\n+    {\n+      int k = foo (0);\t/* Predetermined - private (automatic var declared */\n+      k++;\t\t/* in scope of construct).  */\n+      thrglobalvar++;\t/* Predetermined - threadprivate.  */\n+      thrlocvar++;\t/* Predetermined - threadprivate.  */\n+      foo (i);\t\t/* Predetermined - private (omp for loop variable).  */\n+      foo (constvar);\t/* Predetermined - shared (const qualified type).  */\n+      foo (*p);\t\t/* *p predetermined - shared (heap allocated */\n+      (*p)++;\t\t/* storage).  */\n+      bar (p);\t\t/* Explicitly determined - private.  */\n+      foo (s);\t\t/* Explicitly determined - shared.  */\n+      globalvar++;\t/* { dg-error \"not specified in\" } */\n+      locvar++;\t\t/* { dg-error \"not specified in\" } */\n+      l++;\t\t/* { dg-error \"not specified in\" } */\n+      for (j = 0; j < 2; j++); /* { dg-error \"not specified in\" } */\n+    }\n+  return 0;\n+}"}, {"sha": "33bbb3bade894c2c05bbbc2f3d8448e9955cc460", "filename": "gcc/testsuite/gcc.dg/gomp/sharing-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (void)\n+{\n+  int i;\n+  int a[10];\n+  #pragma omp parallel private (i) shared (a)\n+  {\n+    i = 1;\n+    #pragma omp parallel shared (a, i)\n+    {\n+      #pragma omp master\n+\ti = 2;\n+      #pragma omp parallel private (i) shared (a)\n+      {\n+\tfor (i = 0; i < 10; i++)\n+\t  a[i] = i + 1;\n+      }\n+      #pragma omp master\n+\ti = 3;\n+    }\n+    i = 4;\n+  }\n+}"}, {"sha": "36f72e3abb94cc7be324f2de863b5930b847caea", "filename": "gcc/testsuite/gcc.dg/gomp/sharing-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fsharing-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+#define N       50\n+#define CHUNKSIZE   5\n+\n+main ()\n+{\n+  int i, chunk;\n+  float c[N];\n+\n+  chunk = CHUNKSIZE;\n+#pragma omp parallel for shared (c, chunk) schedule (dynamic, chunk)\n+  for (i = 0; i < N; i++)\n+    c[i] = i;\n+\n+  return 0;\n+}"}, {"sha": "8996d818b3121ed4006a415d754e7d43ef47ac84", "filename": "gcc/testsuite/gcc.dg/gomp/static.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fstatic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fstatic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fstatic.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,14 @@\n+static int bork;\n+\n+void bar(void);\n+\n+void foobar (void)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp for lastprivate(bork)\n+    for (bork = 0; bork < 100; bork++) {\n+        bar();\n+    }\n+  }\n+}"}, {"sha": "9dc102e7e61db44454bca6484931faf94b5c50c9", "filename": "gcc/testsuite/gcc.dg/gomp/tls-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls }\n+\n+int tp1;\n+static int tp2;\n+extern int tp3;\n+\n+int tp4 = 1;\n+static int tp5 = 1;\n+\n+#pragma omp threadprivate (tp1, tp2, tp3, tp4, tp5)\n+\n+#pragma omp threadprivate (undef)\t// { dg-error \"undeclared\" }\n+\n+int tp6;\n+int foo(void) { return tp6; }\n+\n+#pragma omp threadprivate (tp6)\t\t// { dg-error \"after first use\" }"}, {"sha": "80275f9081c20e98be4166769c4df415b167e3a6", "filename": "gcc/testsuite/gcc.dg/gomp/tls-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftls-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+extern char buf[];\n+#pragma omp threadprivate (buf)\t/* { dg-error \"has incomplete type\" } */\n+\n+void\n+foo (void)\n+{\n+  int i;\n+#pragma omp threadprivate (i) /* { dg-error \"automatic variable\" } */\n+  i = 0;\n+}"}, {"sha": "223e617b461dc44fa77539debf6c896d6d00f08e", "filename": "gcc/testsuite/gcc.dg/gomp/uninit-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Funinit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Funinit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Funinit-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,13 @@\n+// PR 24612\n+// { dg-do compile }\n+// { dg-options \"-O -Wuninitialized -fopenmp\" }\n+\n+void foo()\n+{\n+    int i;\n+#pragma omp parallel shared(i)\n+    {\n+      i = 0;\n+      ++i;\n+    }\n+}"}, {"sha": "bb37f33e60f747d6a20e1d1bf654632b81abfd5e", "filename": "gcc/testsuite/gcc.dg/gomp/vla-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+void foo(int n)\n+{\n+  int A[n];\n+\n+  #pragma omp parallel default(none)\t// { dg-error \"enclosing\" }\n+    {\n+      A[0] = 0;\t\t\t\t// { dg-error \"'A' not specified\" }\n+    }\n+}"}, {"sha": "fc18ffc5743a370ddbd499623bfac4385a2c446b", "filename": "gcc/testsuite/gcc.dg/gomp/vla-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+void foo(int n, int i)\n+{\n+  int A[n];\n+\n+  #pragma omp parallel private(A)\n+    {\n+      A[i] = 0;\n+    }\n+}"}, {"sha": "b1677b833ef7d26efdd1a365a09674236886a769", "filename": "gcc/testsuite/gcc.dg/gomp/vla-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+void foo(int n, int i)\n+{\n+  int A[n];\n+\n+  #pragma omp parallel shared(A)\n+    {\n+      A[i] = sizeof(A);\n+    }\n+}"}, {"sha": "2c3c0aa43b7d53f0d129562a45939249a01e8730", "filename": "gcc/testsuite/gcc.dg/gomp/vla-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+void foo(int n, int i)\n+{\n+  int A[n];\n+\n+  #pragma omp parallel firstprivate(A)\n+    {\n+      A[i] = 1;\n+    }\n+}"}, {"sha": "6c6d5517af845a876ae4a6d155b0a360c0ed3af1", "filename": "gcc/testsuite/gcc.dg/gomp/vla-5.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fvla-5.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+void foo(int n, int i)\n+{\n+  int A[n];\n+\n+  #pragma omp parallel sections lastprivate(A)\n+    {\n+      A[i] = 1;\n+    }\n+}"}, {"sha": "45e78ddf2e2578b8b10c3c11e9eebd9d58489ace", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -2746,9 +2746,12 @@ set_bb_for_stmt (tree t, basic_block bb)\n       stmt_ann_t ann = get_stmt_ann (t);\n       ann->bb = bb;\n \n-      /* If the statement is a label, add the label to block-to-labels map\n-\t so that we can speed up edge creation for GOTO_EXPRs.  */\n-      if (TREE_CODE (t) == LABEL_EXPR)\n+      /* If the statement is a label, add the label to block-to-labels\n+\t map so that we can speed up edge creation for GOTO_EXPRs.\n+\t Note that LABEL_TO_BLOCK_MAP may not exist if we are\n+\t currently expanding into RTL (in which case, this mapping is\n+\t unnecessary, anyway).  */\n+      if (TREE_CODE (t) == LABEL_EXPR && !currently_expanding_to_rtl)\n \t{\n \t  int uid;\n \n@@ -3475,25 +3478,20 @@ static bool\n tree_node_can_be_shared (tree t)\n {\n   if (IS_TYPE_OR_DECL_P (t)\n-      /* We check for constants explicitly since they are not considered\n-\t gimple invariants if they overflowed.  */\n-      || CONSTANT_CLASS_P (t)\n       || is_gimple_min_invariant (t)\n       || TREE_CODE (t) == SSA_NAME\n-      || t == error_mark_node)\n+      || t == error_mark_node\n+      || TREE_CODE (t) == IDENTIFIER_NODE)\n     return true;\n \n   if (TREE_CODE (t) == CASE_LABEL_EXPR)\n     return true;\n \n   while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n-\t  /* We check for constants explicitly since they are not considered\n-\t     gimple invariants if they overflowed.  */\n-\t  && (CONSTANT_CLASS_P (TREE_OPERAND (t, 1))\n-\t      || is_gimple_min_invariant (TREE_OPERAND (t, 1))))\n-\t || (TREE_CODE (t) == COMPONENT_REF\n-\t     || TREE_CODE (t) == REALPART_EXPR\n-\t     || TREE_CODE (t) == IMAGPART_EXPR))\n+\t   && is_gimple_min_invariant (TREE_OPERAND (t, 1)))\n+\t || TREE_CODE (t) == COMPONENT_REF\n+\t || TREE_CODE (t) == REALPART_EXPR\n+\t || TREE_CODE (t) == IMAGPART_EXPR)\n     t = TREE_OPERAND (t, 0);\n \n   if (DECL_P (t))\n@@ -3670,27 +3668,29 @@ tree_verify_flow_info (void)\n \n \t  if (prev_stmt && DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n \t    {\n-\t      error (\"nonlocal label %s is not first \"\n-\t\t     \"in a sequence of labels in bb %d\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n-\t\t     bb->index);\n+\t      error (\"nonlocal label \");\n+\t      print_generic_expr (stderr, LABEL_EXPR_LABEL (stmt), 0);\n+\t      fprintf (stderr, \" is not first in a sequence of labels in bb %d\",\n+\t\t       bb->index);\n \t      err = 1;\n \t    }\n \n \t  if (label_to_block (LABEL_EXPR_LABEL (stmt)) != bb)\n \t    {\n-\t      error (\"label %s to block does not match in bb %d\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n-\t\t     bb->index);\n+\t      error (\"label \");\n+\t      print_generic_expr (stderr, LABEL_EXPR_LABEL (stmt), 0);\n+\t      fprintf (stderr, \" to block does not match in bb %d\",\n+\t\t       bb->index);\n \t      err = 1;\n \t    }\n \n \t  if (decl_function_context (LABEL_EXPR_LABEL (stmt))\n \t      != current_function_decl)\n \t    {\n-\t      error (\"label %s has incorrect context in bb %d\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n-\t\t     bb->index);\n+\t      error (\"label \");\n+\t      print_generic_expr (stderr, LABEL_EXPR_LABEL (stmt), 0);\n+\t      fprintf (stderr, \" has incorrect context in bb %d\",\n+\t\t       bb->index);\n \t      err = 1;\n \t    }\n \t}\n@@ -3712,12 +3712,13 @@ tree_verify_flow_info (void)\n \n \t  if (TREE_CODE (stmt) == LABEL_EXPR)\n \t    {\n-\t      error (\"label %s in the middle of basic block %d\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (LABEL_EXPR_LABEL (stmt))),\n-\t\t     bb->index);\n+\t      error (\"label \");\n+\t      print_generic_expr (stderr, LABEL_EXPR_LABEL (stmt), 0);\n+\t      fprintf (stderr, \" in the middle of basic block %d\", bb->index);\n \t      err = 1;\n \t    }\n \t}\n+\n       bsi = bsi_last (bb);\n       if (bsi_end_p (bsi))\n \tcontinue;\n@@ -3854,7 +3855,7 @@ tree_verify_flow_info (void)\n \t\t  }\n \t\tif (! tree_int_cst_lt (CASE_LOW (prev), CASE_LOW (c)))\n \t\t  {\n-\t\t    error (\"case labels not sorted:\");\n+\t\t    error (\"case labels not sorted: \");\n \t\t    print_generic_expr (stderr, prev, 0);\n \t\t    fprintf (stderr,\" is greater than \");\n \t\t    print_generic_expr (stderr, c, 0);\n@@ -4503,7 +4504,8 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n   bool ignore_topmost_bind = false, any_var = false;\n   basic_block bb;\n   tree chain;\n-\n+  struct function *saved_cfun;\n+  \n   fprintf (file, \"%s (\", lang_hooks.decl_printable_name (fn, 2));\n \n   arg = DECL_ARGUMENTS (fn);\n@@ -4524,6 +4526,10 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n       return;\n     }\n \n+  /* Switch CFUN to point to FN.  */\n+  saved_cfun = cfun;\n+  cfun = DECL_STRUCT_FUNCTION (fn);\n+\n   /* When GIMPLE is lowered, the variables are no longer available in\n      BIND_EXPRs, so display them separately.  */\n   if (cfun && cfun->decl == fn && cfun->unexpanded_var_list)\n@@ -4565,7 +4571,7 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n       /* Make a tree based dump.  */\n       chain = DECL_SAVED_TREE (fn);\n \n-      if (TREE_CODE (chain) == BIND_EXPR)\n+      if (chain && TREE_CODE (chain) == BIND_EXPR)\n \t{\n \t  if (ignore_topmost_bind)\n \t    {\n@@ -4591,6 +4597,18 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n     }\n \n   fprintf (file, \"\\n\\n\");\n+\n+  /* Restore CFUN.  */\n+  cfun = saved_cfun;\n+}\n+\n+\n+/* Dump FUNCTION_DECL FN to stderr using FLAGS (see TDF_* in tree.h)  */\n+\n+void\n+debug_function (tree fn, int flags)\n+{\n+  dump_function_to_file (fn, stderr, flags);\n }\n \n "}, {"sha": "00b14404f4a1d992f1bc00bd29c43c589d5d2c12", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -91,6 +91,7 @@ extern void queue_and_dump_index (dump_info_p, const char *, tree, int);\n extern void queue_and_dump_type (dump_info_p, tree);\n extern void dump_function (enum tree_dump_index, tree);\n extern void dump_function_to_file (tree, FILE *, int);\n+extern void debug_function (tree, int);\n extern int dump_flag (dump_info_p, int, tree);\n \n extern unsigned int dump_register (const char *, const char *, const char *, "}, {"sha": "5edf55833f3929edf4ded60ac53dc5596f98ff39", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -216,6 +216,14 @@ is_gimple_stmt (tree t)\n     case RESX_EXPR:\n     case PHI_NODE:\n     case STATEMENT_LIST:\n+    case OMP_PARALLEL:\n+    case OMP_FOR:\n+    case OMP_SECTIONS:\n+    case OMP_SECTION:\n+    case OMP_SINGLE:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n       /* These are always void.  */\n       return true;\n "}, {"sha": "ff1a6d20a39d6f55d4cea923f8e81d741919b398", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -109,6 +109,21 @@ enum gimplify_status {\n   GS_ALL_DONE\t= 1\t/* The expression is fully gimplified.  */\n };\n \n+/* Type of parallel constructs.  Used to decide what runtime function\n+   to use for launching children threads and the gimplification\n+   strategy.  */\n+\n+enum omp_parallel_type {\n+    IS_NOT_PARALLEL = 0,\n+\n+    /* Regular omp parallel  */\n+    IS_PARALLEL,\n+\n+    /* Combined parallel + workshare (parallel loop and parallel\n+       sections).  */\n+    IS_COMBINED_PARALLEL\n+};\n+\n extern enum gimplify_status gimplify_expr (tree *, tree *, tree *,\n \t\t\t\t\t   bool (*) (tree), fallback_t);\n extern void gimplify_type_sizes (tree, tree *);\n@@ -130,8 +145,77 @@ extern tree alloc_stmt_list (void);\n extern void free_stmt_list (tree);\n extern tree force_labels_r (tree *, int *, void *);\n extern enum gimplify_status gimplify_va_arg_expr (tree *, tree *, tree *);\n+struct gimplify_omp_ctx;\n+extern void omp_firstprivatize_variable (struct gimplify_omp_ctx *, tree);\n+\n+/* In omp-low.c.  */\n+extern tree find_omp_clause (tree, enum tree_code);\n+extern void diagnose_omp_structured_block_errors (tree);\n+extern tree omp_reduction_init (tree, tree);\n+enum omp_parallel_type determine_parallel_type (tree stmt);\n \n /* In tree-nested.c.  */\n extern void lower_nested_functions (tree);\n+extern void insert_field_into_struct (tree, tree);\n+\n+/* Convenience routines to walk all statements of a gimple function.\n+   The difference between these walkers and the generic walk_tree is\n+   that walk_stmt provides context information to the callback\n+   routine to know whether it is currently on the LHS or RHS of an\n+   assignment (IS_LHS) or contexts where only GIMPLE values are\n+   allowed (VAL_ONLY).\n+   \n+   This is useful in walkers that need to re-write sub-expressions\n+   inside statements while making sure the result is still in GIMPLE\n+   form.\n+\n+   Note that this is useful exclusively before the code is converted\n+   into SSA form.  Once the program is in SSA form, the standard\n+   operand interface should be used to analyze/modify statements.  */\n+\n+struct walk_stmt_info\n+{\n+  /* For each statement, we invoke CALLBACK via walk_tree.  The passed\n+     data is a walk_stmt_info structure.  */\n+  walk_tree_fn callback;\n+\n+  /* Points to the current statement being walked.  */\n+  tree_stmt_iterator tsi;\n+  \n+  /* Additional data that CALLBACK may want to carry through the\n+     recursion.  */\n+  void *info;\n+\n+  /* Indicates whether the *TP being examined may be replaced \n+     with something that matches is_gimple_val (if true) or something\n+     slightly more complicated (if false).  \"Something\" technically \n+     means the common subset of is_gimple_lvalue and is_gimple_rhs, \n+     but we never try to form anything more complicated than that, so\n+     we don't bother checking.\n+\n+     Also note that CALLBACK should update this flag while walking the\n+     sub-expressions of a statement.  For instance, when walking the\n+     statement 'foo (&var)', the flag VAL_ONLY will initially be set\n+     to true, however, when walking &var, the operand of that\n+     ADDR_EXPR does not need to be a GIMPLE value.  */\n+  bool val_only;\n+\n+  /* True if we are currently walking the LHS of an assignment.  */\n+  bool is_lhs;\n+\n+  /* Optional.  Set to true by CALLBACK if it made any changes.  */\n+  bool changed;\n+\n+  /* True if we're interested in seeing BIND_EXPRs.  */\n+  bool want_bind_expr;\n+\n+  /* True if we're interested in seeing RETURN_EXPRs.  */\n+  bool want_return_expr;\n+\n+  /* True if we're interested in location information.  */\n+  bool want_locations;\n+};\n+\n+void walk_stmts (struct walk_stmt_info *, tree *);\n \n #endif /* _TREE_SIMPLE_H  */"}, {"sha": "c4c30104731d7d4bc537e0a7eab9574adce9a924", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -330,8 +330,9 @@ expr_last (tree expr)\n   return expr;\n }\n \n-/* If EXPR is a single statement, naked or in a STATEMENT_LIST, then\n-   return it.  Otherwise return NULL.  */\n+/* If EXPR is a single statement return it.  If EXPR is a\n+   STATEMENT_LIST containing exactly one statement S, return S.\n+   Otherwise, return NULL.  */\n \n tree \n expr_only (tree expr)"}, {"sha": "4c65a1dc227cf91c09a6c7829e641f9731f9dcc1", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 422, "deletions": 44, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -89,9 +89,13 @@ struct nesting_info GTY ((chain_next (\"%h.next\")))\n   struct nesting_info *inner;\n   struct nesting_info *next;\n   \n+  htab_t GTY ((param_is (struct var_map_elt))) field_map;\n   htab_t GTY ((param_is (struct var_map_elt))) var_map;\n+  bitmap suppress_expansion;\n+\n   tree context;\n   tree new_local_var_chain;\n+  tree debug_var_chain;\n   tree frame_type;\n   tree frame_decl;\n   tree chain_field;\n@@ -180,7 +184,7 @@ build_addr (tree exp, tree context)\n \n /* Insert FIELD into TYPE, sorted by alignment requirements.  */\n \n-static void\n+void\n insert_field_into_struct (tree type, tree field)\n {\n   tree *p;\n@@ -264,7 +268,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n   tree field;\n \n   dummy.old = decl;\n-  slot = htab_find_slot (info->var_map, &dummy, insert);\n+  slot = htab_find_slot (info->field_map, &dummy, insert);\n   if (!slot)\n     {\n       gcc_assert (insert != INSERT);\n@@ -538,37 +542,21 @@ get_nl_goto_field (struct nesting_info *info)\n   return field;\n }\n \f\n-/* Convenience routines to walk all statements of a gimple function.\n-\n-   For each statement, we invoke CALLBACK via walk_tree.  The passed\n-   data is a walk_stmt_info structure.  Of note here is a TSI that\n-   points to the current statement being walked.  The VAL_ONLY flag\n-   that indicates whether the *TP being examined may be replaced \n-   with something that matches is_gimple_val (if true) or something\n-   slightly more complicated (if false).  \"Something\" technically \n-   means the common subset of is_gimple_lvalue and is_gimple_rhs, \n-   but we never try to form anything more complicated than that, so\n-   we don't bother checking.  */\n-\n-struct walk_stmt_info\n-{\n-  walk_tree_fn callback;\n-  tree_stmt_iterator tsi;\n-  struct nesting_info *info;\n-  bool val_only;\n-  bool is_lhs;\n-  bool changed;\n-};\n+/* Iterate over all sub-statements of *TP calling walk_tree with\n+   WI->CALLBACK for every sub-expression in each statement found.  */\n \n-/* A subroutine of walk_function.  Iterate over all sub-statements of *TP.  */\n-\n-static void\n+void\n walk_stmts (struct walk_stmt_info *wi, tree *tp)\n {\n   tree t = *tp;\n+  int walk_subtrees;\n+\n   if (!t)\n     return;\n \n+  if (wi->want_locations && EXPR_HAS_LOCATION (t))\n+    input_location = EXPR_LOCATION (t);\n+\n   switch (TREE_CODE (t))\n     {\n     case STATEMENT_LIST:\n@@ -598,11 +586,26 @@ walk_stmts (struct walk_stmt_info *wi, tree *tp)\n       walk_stmts (wi, &TREE_OPERAND (t, 0));\n       walk_stmts (wi, &TREE_OPERAND (t, 1));\n       break;\n+\n     case BIND_EXPR:\n+      if (wi->want_bind_expr)\n+\t{\n+\t  walk_subtrees = 1;\n+\t  wi->callback (tp, &walk_subtrees, wi);\n+\t  if (!walk_subtrees)\n+\t    break;\n+\t}\n       walk_stmts (wi, &BIND_EXPR_BODY (t));\n       break;\n \n     case RETURN_EXPR:\n+      if (wi->want_return_expr)\n+\t{\n+\t  walk_subtrees = 1;\n+\t  wi->callback (tp, &walk_subtrees, wi);\n+\t  if (!walk_subtrees)\n+\t    break;\n+\t}\n       walk_stmts (wi, &TREE_OPERAND (t, 0));\n       break;\n \n@@ -628,10 +631,10 @@ walk_stmts (struct walk_stmt_info *wi, tree *tp)\n     }\n }\n \n-/* Invoke CALLBACK on all statements of INFO->CONTEXT.  */\n+/* Invoke CALLBACK on all statements of *STMT_P.  */\n \n static void\n-walk_function (walk_tree_fn callback, struct nesting_info *info)\n+walk_body (walk_tree_fn callback, struct nesting_info *info, tree *stmt_p)\n {\n   struct walk_stmt_info wi;\n \n@@ -640,7 +643,15 @@ walk_function (walk_tree_fn callback, struct nesting_info *info)\n   wi.info = info;\n   wi.val_only = true;\n \n-  walk_stmts (&wi, &DECL_SAVED_TREE (info->context));\n+  walk_stmts (&wi, stmt_p);\n+}\n+\n+/* Invoke CALLBACK on all statements of INFO->CONTEXT.  */\n+\n+static inline void\n+walk_function (walk_tree_fn callback, struct nesting_info *info)\n+{\n+  walk_body (callback, info, &DECL_SAVED_TREE (info->context));\n }\n \n /* Similarly for ROOT and all functions nested underneath, depth first.  */\n@@ -707,7 +718,9 @@ static struct nesting_info *\n create_nesting_tree (struct cgraph_node *cgn)\n {\n   struct nesting_info *info = GGC_CNEW (struct nesting_info);\n+  info->field_map = htab_create_ggc (7, var_map_hash, var_map_eq, ggc_free);\n   info->var_map = htab_create_ggc (7, var_map_hash, var_map_eq, ggc_free);\n+  info->suppress_expansion = BITMAP_GGC_ALLOC ();\n   info->context = cgn->decl;\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n@@ -794,6 +807,80 @@ get_frame_field (struct nesting_info *info, tree target_context,\n   return x;\n }\n \n+/* A subroutine of convert_nonlocal_reference.  Create a local variable\n+   in the nested function with DECL_VALUE_EXPR set to reference the true\n+   variable in the parent function.  This is used both for debug info \n+   and in OpenMP lowering.  */\n+\n+static tree\n+get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n+{\n+  struct var_map_elt *elt, dummy;\n+  tree target_context;\n+  struct nesting_info *i;\n+  tree x, field, new_decl;\n+  void **slot;\n+\n+  dummy.old = decl;\n+  slot = htab_find_slot (info->var_map, &dummy, INSERT);\n+  elt = *slot;\n+\n+  if (elt)\n+    return elt->new;\n+\n+  target_context = decl_function_context (decl);\n+\n+  /* A copy of the code in get_frame_field, but without the temporaries.  */\n+  if (info->context == target_context)\n+    {\n+      /* Make sure frame_decl gets created.  */\n+      (void) get_frame_type (info);\n+      x = info->frame_decl;\n+      i = info;\n+    }\n+  else\n+    {\n+      x = get_chain_decl (info);\n+      for (i = info->outer; i->context != target_context; i = i->outer)\n+\t{\n+\t  field = get_chain_field (i);\n+\t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\t  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n+\t}\n+      x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+    }\n+\n+  field = lookup_field_for_decl (i, decl, INSERT);\n+  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n+  if (use_pointer_in_frame (decl))\n+    x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\n+  /* ??? We should be remapping types as well, surely.  */\n+  new_decl = build_decl (VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n+  DECL_CONTEXT (new_decl) = info->context;\n+  DECL_SOURCE_LOCATION (new_decl) = DECL_SOURCE_LOCATION (decl);\n+  DECL_ARTIFICIAL (new_decl) = DECL_ARTIFICIAL (decl);\n+  DECL_IGNORED_P (new_decl) = DECL_IGNORED_P (decl);\n+  TREE_THIS_VOLATILE (new_decl) = TREE_THIS_VOLATILE (decl);\n+  TREE_SIDE_EFFECTS (new_decl) = TREE_SIDE_EFFECTS (decl);\n+  TREE_READONLY (new_decl) = TREE_READONLY (decl);\n+  TREE_ADDRESSABLE (new_decl) = TREE_ADDRESSABLE (decl);\n+  DECL_SEEN_IN_BIND_EXPR_P (new_decl) = 1;\n+\n+  SET_DECL_VALUE_EXPR (new_decl, x);\n+  DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n+\n+  elt = ggc_alloc (sizeof (*elt));\n+  elt->old = decl;\n+  elt->new = new_decl;\n+  *slot = elt;\n+\n+  TREE_CHAIN (new_decl) = info->debug_var_chain;\n+  info->debug_var_chain = new_decl;\n+\n+  return new_decl;\n+}\n+\n /* Called via walk_function+walk_tree, rewrite all references to VAR\n    and PARM_DECLs that belong to outer functions.\n \n@@ -802,12 +889,16 @@ get_frame_field (struct nesting_info *info, tree target_context,\n    be CHAIN->FOO.  For two levels it'll be CHAIN->__chain->FOO.  Further\n    indirections apply to decls for which use_pointer_in_frame is true.  */\n \n+static bool convert_nonlocal_omp_clauses (tree *, struct walk_stmt_info *);\n+\n static tree\n convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp;\n+  tree save_local_var_chain;\n+  bitmap save_suppress;\n \n   *walk_subtrees = 0;\n   switch (TREE_CODE (t))\n@@ -821,19 +912,23 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n     case PARM_DECL:\n       if (decl_function_context (t) != info->context)\n \t{\n-\t  tree target_context = decl_function_context (t);\n-\t  struct nesting_info *i;\n \t  tree x;\n \t  wi->changed = true;\n \n-\t  for (i = info->outer; i->context != target_context; i = i->outer)\n-\t    continue;\n-\t  x = lookup_field_for_decl (i, t, INSERT);\n-\t  x = get_frame_field (info, target_context, x, &wi->tsi);\n-\t  if (use_pointer_in_frame (t))\n+\t  x = get_nonlocal_debug_decl (info, t);\n+\t  if (!bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))\n \t    {\n-\t      x = init_tmp_var (info, x, &wi->tsi);\n-\t      x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\t      tree target_context = decl_function_context (t);\n+\t      struct nesting_info *i;\n+\t      for (i = info->outer; i->context != target_context; i = i->outer)\n+\t\tcontinue;\n+\t      x = lookup_field_for_decl (i, t, INSERT);\n+\t      x = get_frame_field (info, target_context, x, &wi->tsi);\n+\t      if (use_pointer_in_frame (t))\n+\t\t{\n+\t\t  x = init_tmp_var (info, x, &wi->tsi);\n+\t\t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\t\t}\n \t    }\n \n \t  if (wi->val_only)\n@@ -935,6 +1030,43 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n       walk_tree (tp, convert_nonlocal_reference, wi, NULL);\n       break;\n \n+    case OMP_PARALLEL:\n+      save_suppress = info->suppress_expansion;\n+      if (convert_nonlocal_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))\n+\t{\n+\t  tree c;\n+\t  c = get_chain_decl (info);\n+\t  c = build1 (OMP_CLAUSE_FIRSTPRIVATE, void_type_node, c);\n+\t  OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (t);\n+\t  OMP_PARALLEL_CLAUSES (t) = c;\n+\t}\n+\n+      save_local_var_chain = info->new_local_var_chain;\n+      info->new_local_var_chain = NULL;\n+\n+      walk_body (convert_nonlocal_reference, info, &OMP_PARALLEL_BODY (t));\n+\n+      if (info->new_local_var_chain)\n+\tdeclare_tmp_vars (info->new_local_var_chain, OMP_PARALLEL_BODY (t));\n+      info->new_local_var_chain = save_local_var_chain;\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n+    case OMP_FOR:\n+    case OMP_SECTIONS:\n+    case OMP_SINGLE:\n+      save_suppress = info->suppress_expansion;\n+      convert_nonlocal_omp_clauses (&OMP_CLAUSES (t), wi);\n+      walk_body (convert_nonlocal_reference, info, &OMP_BODY (t));\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n+    case OMP_SECTION:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+      walk_body (convert_nonlocal_reference, info, &OMP_BODY (t));\n+      break;\n+\n     default:\n       if (!IS_TYPE_OR_DECL_P (t))\n \t{\n@@ -948,17 +1080,128 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+static bool\n+convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n+{\n+  struct nesting_info *info = wi->info;\n+  bool need_chain = false;\n+  tree clause, decl;\n+  int dummy;\n+  bitmap new_suppress;\n+\n+  new_suppress = BITMAP_GGC_ALLOC ();\n+  bitmap_copy (new_suppress, info->suppress_expansion);\n+\n+  for (clause = *pclauses; clause ; clause = OMP_CLAUSE_CHAIN (clause))\n+    {\n+      switch (TREE_CODE (clause))\n+\t{\n+\tcase OMP_CLAUSE_PRIVATE:\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\tcase OMP_CLAUSE_SHARED:\n+\t  decl = OMP_CLAUSE_DECL (clause);\n+\t  if (decl_function_context (decl) != info->context)\n+\t    {\n+\t      bitmap_set_bit (new_suppress, DECL_UID (decl));\n+\t      OMP_CLAUSE_DECL (clause) = get_nonlocal_debug_decl (info, decl);\n+\t      need_chain = true;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  if (OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause) == NULL)\n+\t    break;\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_IF:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n+\t  convert_nonlocal_reference (&TREE_OPERAND (clause, 0), &dummy, wi);\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NOWAIT:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_COPYIN:\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  info->suppress_expansion = new_suppress;\n+\n+  return need_chain;\n+}\n+\n+/* A subroutine of convert_local_reference.  Create a local variable\n+   in the parent function with DECL_VALUE_EXPR set to reference the\n+   field in FRAME.  This is used both for debug info and in OpenMP\n+   lowering.  */\n+\n+static tree\n+get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n+{\n+  struct var_map_elt *elt, dummy;\n+  tree x, new_decl;\n+  void **slot;\n+\n+  dummy.old = decl;\n+  slot = htab_find_slot (info->var_map, &dummy, INSERT);\n+  elt = *slot;\n+\n+  if (elt)\n+    return elt->new;\n+\n+  /* Make sure frame_decl gets created.  */\n+  (void) get_frame_type (info);\n+  x = info->frame_decl;\n+  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n+\n+  new_decl = build_decl (VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n+  DECL_CONTEXT (new_decl) = info->context;\n+  DECL_SOURCE_LOCATION (new_decl) = DECL_SOURCE_LOCATION (decl);\n+  DECL_ARTIFICIAL (new_decl) = DECL_ARTIFICIAL (decl);\n+  DECL_IGNORED_P (new_decl) = DECL_IGNORED_P (decl);\n+  TREE_THIS_VOLATILE (new_decl) = TREE_THIS_VOLATILE (decl);\n+  TREE_SIDE_EFFECTS (new_decl) = TREE_SIDE_EFFECTS (decl);\n+  TREE_READONLY (new_decl) = TREE_READONLY (decl);\n+  TREE_ADDRESSABLE (new_decl) = TREE_ADDRESSABLE (decl);\n+  DECL_SEEN_IN_BIND_EXPR_P (new_decl) = 1;\n+\n+  SET_DECL_VALUE_EXPR (new_decl, x);\n+  DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n+\n+  elt = ggc_alloc (sizeof (*elt));\n+  elt->old = decl;\n+  elt->new = new_decl;\n+  *slot = elt;\n+\n+  TREE_CHAIN (new_decl) = info->debug_var_chain;\n+  info->debug_var_chain = new_decl;\n+\n+  return new_decl;\n+}\n+\n /* Called via walk_function+walk_tree, rewrite all references to VAR\n    and PARM_DECLs that were referenced by inner nested functions.\n    The rewrite will be a structure reference to the local frame variable.  */\n \n+static bool convert_local_omp_clauses (tree *, struct walk_stmt_info *);\n+\n static tree\n convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp, field, x;\n   bool save_val_only;\n+  tree save_local_var_chain;\n+  bitmap save_suppress;\n \n   *walk_subtrees = 0;\n   switch (TREE_CODE (t))\n@@ -984,7 +1227,9 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t    break;\n \t  wi->changed = true;\n \n-\t  x = get_frame_field (info, info->context, field, &wi->tsi);\n+\t  x = get_local_debug_decl (info, t, field);\n+\t  if (!bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))\n+\t    x = get_frame_field (info, info->context, field, &wi->tsi);\n \n \t  if (wi->val_only)\n \t    {\n@@ -1066,6 +1311,43 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n       wi->val_only = save_val_only;\n       break;\n \n+    case OMP_PARALLEL:\n+      save_suppress = info->suppress_expansion;\n+      if (convert_local_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))\n+\t{\n+\t  tree c;\n+\t  (void) get_frame_type (info);\n+\t  c = build1 (OMP_CLAUSE_SHARED, void_type_node, info->frame_decl);\n+\t  OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (t);\n+\t  OMP_PARALLEL_CLAUSES (t) = c;\n+\t}\n+\n+      save_local_var_chain = info->new_local_var_chain;\n+      info->new_local_var_chain = NULL;\n+\n+      walk_body (convert_local_reference, info, &OMP_PARALLEL_BODY (t));\n+\n+      if (info->new_local_var_chain)\n+\tdeclare_tmp_vars (info->new_local_var_chain, OMP_PARALLEL_BODY (t));\n+      info->new_local_var_chain = save_local_var_chain;\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n+    case OMP_FOR:\n+    case OMP_SECTIONS:\n+    case OMP_SINGLE:\n+      save_suppress = info->suppress_expansion;\n+      convert_local_omp_clauses (&OMP_CLAUSES (t), wi);\n+      walk_body (convert_local_reference, info, &OMP_BODY (t));\n+      info->suppress_expansion = save_suppress;\n+      break;\n+\n+    case OMP_SECTION:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+      walk_body (convert_local_reference, info, &OMP_BODY (t));\n+      break;\n+\n     default:\n       if (!IS_TYPE_OR_DECL_P (t))\n \t{\n@@ -1079,6 +1361,70 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+static bool\n+convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n+{\n+  struct nesting_info *info = wi->info;\n+  bool need_frame = false;\n+  tree clause, decl;\n+  int dummy;\n+  bitmap new_suppress;\n+\n+  new_suppress = BITMAP_GGC_ALLOC ();\n+  bitmap_copy (new_suppress, info->suppress_expansion);\n+\n+  for (clause = *pclauses; clause ; clause = OMP_CLAUSE_CHAIN (clause))\n+    {\n+      switch (TREE_CODE (clause))\n+\t{\n+\tcase OMP_CLAUSE_PRIVATE:\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\tcase OMP_CLAUSE_SHARED:\n+\t  decl = OMP_CLAUSE_DECL (clause);\n+\t  if (decl_function_context (decl) == info->context\n+\t      && !use_pointer_in_frame (decl))\n+\t    {\n+\t      tree field = lookup_field_for_decl (info, decl, NO_INSERT);\n+\t      if (field)\n+\t\t{\n+\t\t  bitmap_set_bit (new_suppress, DECL_UID (decl));\n+\t\t  OMP_CLAUSE_DECL (clause)\n+\t\t    = get_local_debug_decl (info, decl, field);\n+\t\t  need_frame = true;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  if (OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause) == NULL)\n+\t    break;\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_IF:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\t  wi->val_only = true;\n+\t  wi->is_lhs = false;\n+\t  convert_local_reference (&TREE_OPERAND (clause, 0), &dummy, wi);\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NOWAIT:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_COPYIN:\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  info->suppress_expansion = new_suppress;\n+\n+  return need_frame;\n+}\n+\n /* Called via walk_function+walk_tree, rewrite all GOTO_EXPRs that \n    reference labels from outer functions.  The rewrite will be a \n    call to __builtin_nonlocal_goto.  */\n@@ -1292,6 +1638,15 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n       *walk_subtrees = 1;\n       break;\n \n+    case OMP_FOR:\n+    case OMP_SECTIONS:\n+    case OMP_SINGLE:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n+      walk_body (convert_call_expr, info, &OMP_BODY (t));\n+      break;\n+\n     default:\n       break;\n     }\n@@ -1336,7 +1691,6 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n   tree stmt_list = NULL;\n   tree context = root->context;\n   struct function *sf;\n-  struct cgraph_node *node;\n \n   /* If we created a non-local frame type or decl, we need to lay them\n      out at this time.  */\n@@ -1449,10 +1803,33 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n   if (root->new_local_var_chain)\n     declare_tmp_vars (root->new_local_var_chain,\n \t\t      DECL_SAVED_TREE (root->context));\n+  if (root->debug_var_chain)\n+    declare_tmp_vars (root->debug_var_chain,\n+\t\t      DECL_SAVED_TREE (root->context));\n \n   /* Dump the translated tree function.  */\n   dump_function (TDI_nested, root->context);\n-  node = cgraph_node (root->context);\n+}\n+\n+static void\n+finalize_nesting_tree (struct nesting_info *root)\n+{\n+  do\n+    {\n+      if (root->inner)\n+\tfinalize_nesting_tree (root->inner);\n+      finalize_nesting_tree_1 (root);\n+      root = root->next;\n+    }\n+  while (root);\n+}\n+\n+/* Unnest the nodes and pass them to cgraph.  */\n+\n+static void\n+unnest_nesting_tree_1 (struct nesting_info *root)\n+{\n+  struct cgraph_node *node = cgraph_node (root->context);\n \n   /* For nested functions update the cgraph to reflect unnesting.\n      We also delay finalizing of these functions up to this point.  */\n@@ -1464,13 +1841,13 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n }\n \n static void\n-finalize_nesting_tree (struct nesting_info *root)\n+unnest_nesting_tree (struct nesting_info *root)\n {\n   do\n     {\n       if (root->inner)\n-\tfinalize_nesting_tree (root->inner);\n-      finalize_nesting_tree_1 (root);\n+\tunnest_nesting_tree (root->inner);\n+      unnest_nesting_tree_1 (root);\n       root = root->next;\n     }\n   while (root);\n@@ -1516,6 +1893,7 @@ lower_nested_functions (tree fndecl)\n   walk_all_functions (convert_nl_goto_receiver, root);\n   convert_all_function_calls (root);\n   finalize_nesting_tree (root);\n+  unnest_nesting_tree (root);\n   free_nesting_tree (root);\n   root = NULL;\n }"}, {"sha": "90327ba8864d353c421f7690405741eb60ae59d6", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -68,6 +68,8 @@ enum tree_dump_index\n #define TDF_STMTADDR\t(1 << 12)\t/* Address of stmt.  */\n \n #define TDF_GRAPH\t(1 << 13)\t/* a graph dump is being emitted */\n+#define TDF_CHAIN\t(1 << 14)\t/* Follow TREE_CHAIN when\n+\t\t\t\t\t   dumping *_DECLs.  */\n \n extern char *get_dump_file_name (enum tree_dump_index);\n extern int dump_enabled_p (enum tree_dump_index);\n@@ -149,6 +151,7 @@ struct dump_file_info\n #define PROP_no_crit_edges      (1 << 7)\n #define PROP_rtl\t\t(1 << 8)\n #define PROP_alias\t\t(1 << 9)\n+#define PROP_gimple_lomp\t(1 << 10)\t/* lowered OpenMP directives */\n \n #define PROP_trees \\\n   (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh)\n@@ -259,6 +262,7 @@ extern struct tree_opt_pass pass_lower_complex_O0;\n extern struct tree_opt_pass pass_lower_complex;\n extern struct tree_opt_pass pass_lower_vector;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n+extern struct tree_opt_pass pass_lower_omp;\n extern struct tree_opt_pass pass_object_sizes;\n extern struct tree_opt_pass pass_fold_builtins;\n extern struct tree_opt_pass pass_stdarg;"}, {"sha": "d7e3391a3e41685e962f74d86d0e3ab6bf15af7c", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 368, "deletions": 39, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -35,6 +35,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* Local functions, macros and variables.  */\n static int op_prio (tree);\n+static const char *op_symbol_1 (enum tree_code);\n static const char *op_symbol (tree);\n static void pretty_print_string (pretty_printer *, const char*);\n static void print_call_name (pretty_printer *, tree);\n@@ -58,7 +59,6 @@ static void dump_generic_bb_buff (pretty_printer *, basic_block, int, int);\n \n static pretty_printer buffer;\n static int initialized = 0;\n-static bool dumping_stmts;\n \n /* Try to print something for an unknown tree code.  */\n \n@@ -97,12 +97,18 @@ debug_generic_stmt (tree t)\n   fprintf (stderr, \"\\n\");\n }\n \n+void\n+debug_tree_chain (tree t)\n+{\n+  print_generic_expr (stderr, t, TDF_VOPS|TDF_UID|TDF_CHAIN);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n /* Prints declaration DECL to the FILE with details specified by FLAGS.  */\n void\n print_generic_decl (FILE *file, tree decl, int flags)\n {\n   maybe_init_pretty_print (file);\n-  dumping_stmts = true;\n   print_declaration (&buffer, decl, 2, flags);\n   pp_write_text_to_stream (&buffer);\n }\n@@ -114,7 +120,6 @@ void\n print_generic_stmt (FILE *file, tree t, int flags)\n {\n   maybe_init_pretty_print (file);\n-  dumping_stmts = true;\n   dump_generic_node (&buffer, t, 0, flags, true);\n   pp_flush (&buffer);\n }\n@@ -129,7 +134,6 @@ print_generic_stmt_indented (FILE *file, tree t, int flags, int indent)\n   int i;\n \n   maybe_init_pretty_print (file);\n-  dumping_stmts = true;\n \n   for (i = 0; i < indent; i++)\n     pp_space (&buffer);\n@@ -144,7 +148,6 @@ void\n print_generic_expr (FILE *file, tree t, int flags)\n {\n   maybe_init_pretty_print (file);\n-  dumping_stmts = false;\n   dump_generic_node (&buffer, t, 0, flags, false);\n }\n \n@@ -154,21 +157,34 @@ print_generic_expr (FILE *file, tree t, int flags)\n static void\n dump_decl_name (pretty_printer *buffer, tree node, int flags)\n {\n-  if (DECL_NAME (node))\n-    pp_tree_identifier (buffer, DECL_NAME (node));\n+  tree t = node;\n \n-  if ((flags & TDF_UID)\n-      || DECL_NAME (node) == NULL_TREE)\n+  while (t)\n     {\n-      if (TREE_CODE (node) == LABEL_DECL\n-\t  && LABEL_DECL_UID (node) != -1)\n-\tpp_printf (buffer, \"L.\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t   LABEL_DECL_UID (node));\n-      else\n+      if (DECL_NAME (t))\n+\tpp_tree_identifier (buffer, DECL_NAME (t));\n+\n+      if ((flags & TDF_UID)\n+\t  || DECL_NAME (t) == NULL_TREE)\n+\t{\n+\t  if (TREE_CODE (t) == LABEL_DECL\n+\t      && LABEL_DECL_UID (t) != -1)\n+\t    pp_printf (buffer, \"L.\" HOST_WIDE_INT_PRINT_DEC,\n+\t\tLABEL_DECL_UID (t));\n+\t  else\n+\t    {\n+\t      char c = TREE_CODE (t) == CONST_DECL ? 'C' : 'D';\n+\t      pp_printf (buffer, \"%c.%u\", c, DECL_UID (t));\n+\t    }\n+\t}\n+\n+      if (flags & TDF_CHAIN)\n \t{\n-\t  char c = TREE_CODE (node) == CONST_DECL ? 'C' : 'D';\n-\t  pp_printf (buffer, \"%c.%u\", c, DECL_UID (node));\n+\t  t = TREE_CHAIN (t);\n+\t  pp_string (buffer, \" \");\n \t}\n+      else\n+\tt = NULL_TREE;\n     }\n }\n \n@@ -246,6 +262,140 @@ dump_array_domain (pretty_printer *buffer, tree domain, int spc, int flags)\n   pp_character (buffer, ']');\n }\n \n+/* Dump the list of OpenMP clauses.  */\n+\n+static void\n+dump_omp_clauses (pretty_printer *buffer, tree clause, int spc, int flags)\n+{\n+  const char *name;\n+\n+  if (clause == NULL)\n+    return;\n+\n+  pp_space (buffer);\n+  while (1)\n+    {\n+      switch (TREE_CODE (clause))\n+\t{\n+\tcase OMP_CLAUSE_PRIVATE:\n+\t  name = \"private\";\n+\t  goto print_remap;\n+\tcase OMP_CLAUSE_SHARED:\n+\t  name = \"shared\";\n+\t  goto print_remap;\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  name = \"firstprivate\";\n+\t  goto print_remap;\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  name = \"lastprivate\";\n+\t  goto print_remap;\n+\tcase OMP_CLAUSE_COPYIN:\n+\t  name = \"copyin\";\n+\t  goto print_remap;\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\t  name = \"copyprivate\";\n+\t  goto print_remap;\n+\tprint_remap:\n+\t  pp_string (buffer, name);\n+\t  pp_character (buffer, '(');\n+\t  dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_character (buffer, ')');\n+\t  break;\n+\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  pp_string (buffer, \"reduction(\");\n+\t  pp_string (buffer, op_symbol_1 (OMP_CLAUSE_REDUCTION_CODE (clause)));\n+\t  pp_character (buffer, ':');\n+\t  dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_character (buffer, ')');\n+\t  break;\n+\n+\tcase OMP_CLAUSE_IF:\n+\t  pp_string (buffer, \"if(\");\n+\t  dump_generic_node (buffer, OMP_CLAUSE_IF_EXPR (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_character (buffer, ')');\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\t  pp_string (buffer, \"num_threads(\");\n+\t  dump_generic_node (buffer, OMP_CLAUSE_NUM_THREADS_EXPR (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_character (buffer, ')');\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NOWAIT:\n+\t  pp_string (buffer, \"nowait\");\n+\t  break;\n+\tcase OMP_CLAUSE_ORDERED:\n+\t  pp_string (buffer, \"ordered\");\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  pp_string (buffer, \"default(\");\n+\t  switch (OMP_CLAUSE_DEFAULT_KIND (clause))\n+\t    {\n+\t    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULT_SHARED:\n+\t      pp_string (buffer, \"shared\");\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULT_NONE:\n+\t      pp_string (buffer, \"none\");\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULT_PRIVATE:\n+\t      pp_string (buffer, \"private\");\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  pp_character (buffer, ')');\n+\t  break;\n+\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  pp_string (buffer, \"schedule(\");\n+\t  switch (OMP_CLAUSE_SCHEDULE_KIND (clause))\n+\t    {\n+\t    case OMP_CLAUSE_SCHEDULE_STATIC:\n+\t      pp_string (buffer, \"static\");\n+\t      break;\n+\t    case OMP_CLAUSE_SCHEDULE_DYNAMIC:\n+\t      pp_string (buffer, \"dynamic\");\n+\t      break;\n+\t    case OMP_CLAUSE_SCHEDULE_GUIDED:\n+\t      pp_string (buffer, \"guided\");\n+\t      break;\n+\t    case OMP_CLAUSE_SCHEDULE_RUNTIME:\n+\t      pp_string (buffer, \"runtime\");\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  if (OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause))\n+\t    {\n+\t      pp_character (buffer, ',');\n+\t      dump_generic_node (buffer,\n+\t\t\t\t OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause),\n+\t\t\t\t spc, flags, false);\n+\t    }\n+\t  pp_character (buffer, ')');\n+\t  break;\n+\n+\tdefault:\n+\t  /* Should never happen.  */\n+\t  dump_generic_node (buffer, clause, spc, flags, false);\n+\t  break;\n+\t}\n+\n+      clause = OMP_CLAUSE_CHAIN (clause);\n+      if (clause == NULL)\n+\treturn;\n+      pp_space (buffer);\n+    }\n+}\n+\n /* Dump the node NODE on the pretty_printer BUFFER, SPC spaces of indent.\n    FLAGS specifies details to show in the dump (see TDF_* in tree.h).  If\n    IS_STMT is true, the object printed is considered to be a statement\n@@ -275,9 +425,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n   if (is_stmt && (flags & TDF_STMTADDR))\n     pp_printf (buffer, \"<&%p> \", (void *)node);\n \n-  if (dumping_stmts\n-      && (flags & TDF_LINENO)\n-      && EXPR_HAS_LOCATION (node))\n+  if ((flags & TDF_LINENO) && EXPR_HAS_LOCATION (node))\n     {\n       expanded_location xloc = expand_location (EXPR_LOCATION (node));\n       pp_character (buffer, '[');\n@@ -340,10 +488,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       }\n       break;\n \n-    case BLOCK:\n-      NIY;\n-      break;\n-\n     case VOID_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n@@ -823,8 +967,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t  }\n \n \tdump_generic_node (buffer, TREE_OPERAND (node, 0),\n-\t\t\t   spc, flags, dumping_stmts);\n-\tif (dumping_stmts)\n+\t\t\t   spc, flags, !(flags & TDF_SLIM));\n+\tif (flags & TDF_SLIM)\n \t  newline_and_indent (buffer, spc);\n \telse\n \t  {\n@@ -837,8 +981,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t     tp = &TREE_OPERAND (*tp, 1))\n \t  {\n \t    dump_generic_node (buffer, TREE_OPERAND (*tp, 0),\n-\t\t\t       spc, flags, dumping_stmts);\n-\t    if (dumping_stmts)\n+\t\t\t       spc, flags, !(flags & TDF_SLIM));\n+\t    if (flags & TDF_SLIM)\n \t      newline_and_indent (buffer, spc);\n \t    else\n \t      {\n@@ -847,7 +991,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t      }\n \t  }\n \n-\tdump_generic_node (buffer, *tp, spc, flags, dumping_stmts);\n+\tdump_generic_node (buffer, *tp, spc, flags, !(flags & TDF_SLIM));\n       }\n       break;\n \n@@ -856,7 +1000,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \ttree_stmt_iterator si;\n \tbool first = true;\n \n-\tif ((flags & TDF_SLIM) || !dumping_stmts)\n+\tif (flags & TDF_SLIM)\n \t  {\n \t    pp_string (buffer, \"<STATEMENT_LIST>\");\n \t    break;\n@@ -1360,7 +1504,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t  if (SWITCH_BODY (node))\n \t    {\n \t      newline_and_indent (buffer, spc+4);\n-\t      dump_generic_node (buffer, SWITCH_BODY (node), spc+4, flags, true);\n+\t      dump_generic_node (buffer, SWITCH_BODY (node), spc+4, flags,\n+\t\t                 true);\n \t    }\n \t  else\n \t    {\n@@ -1370,10 +1515,16 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t\t{\n \t\t  tree elt = TREE_VEC_ELT (vec, i);\n \t\t  newline_and_indent (buffer, spc+4);\n-\t\t  dump_generic_node (buffer, elt, spc+4, flags, false);\n-\t\t  pp_string (buffer, \" goto \");\n-\t\t  dump_generic_node (buffer, CASE_LABEL (elt), spc+4, flags, true);\n-\t\t  pp_semicolon (buffer);\n+\t\t  if (elt)\n+\t\t    {\n+\t\t      dump_generic_node (buffer, elt, spc+4, flags, false);\n+\t\t      pp_string (buffer, \" goto \");\n+\t\t      dump_generic_node (buffer, CASE_LABEL (elt), spc+4,\n+\t\t\t\t\t flags, true);\n+\t\t      pp_semicolon (buffer);\n+\t\t    }\n+\t\t  else\n+\t\t    pp_string (buffer, \"case ???: goto ???;\");\n \t\t}\n \t    }\n \t  newline_and_indent (buffer, spc+2);\n@@ -1535,6 +1686,110 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case OMP_PARALLEL:\n+      pp_string (buffer, \"#pragma omp parallel\");\n+      dump_omp_clauses (buffer, OMP_PARALLEL_CLAUSES (node), spc, flags);\n+\n+    dump_omp_body:\n+      if (!(flags & TDF_SLIM) && OMP_BODY (node))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  newline_and_indent (buffer, spc + 4);\n+\t  dump_generic_node (buffer, OMP_BODY (node), spc + 4, flags, false);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+      is_expr = false;\n+      break;\n+\n+    case OMP_FOR:\n+      pp_string (buffer, \"#pragma omp for\");\n+      dump_omp_clauses (buffer, OMP_FOR_CLAUSES (node), spc, flags);\n+\n+      if (!(flags & TDF_SLIM))\n+\t{\n+\t  if (OMP_FOR_PRE_BODY (node))\n+\t    {\n+\t      newline_and_indent (buffer, spc + 2);\n+\t      pp_character (buffer, '{');\n+\t      spc += 4;\n+\t      newline_and_indent (buffer, spc);\n+\t      dump_generic_node (buffer, OMP_FOR_PRE_BODY (node),\n+\t\t  spc, flags, false);\n+\t    }\n+\t  newline_and_indent (buffer, spc);\n+\t  pp_string (buffer, \"for (\");\n+\t  dump_generic_node (buffer, OMP_FOR_INIT (node), spc, flags, false);\n+\t  pp_string (buffer, \"; \");\n+\t  dump_generic_node (buffer, OMP_FOR_COND (node), spc, flags, false);\n+\t  pp_string (buffer, \"; \");\n+\t  dump_generic_node (buffer, OMP_FOR_INCR (node), spc, flags, false);\n+\t  pp_string (buffer, \")\");\n+\t  if (OMP_FOR_BODY (node))\n+\t    {\n+\t      newline_and_indent (buffer, spc + 2);\n+\t      pp_character (buffer, '{');\n+\t      newline_and_indent (buffer, spc + 4);\n+\t      dump_generic_node (buffer, OMP_FOR_BODY (node), spc + 4, flags,\n+\t\t  false);\n+\t      newline_and_indent (buffer, spc + 2);\n+\t      pp_character (buffer, '}');\n+\t    }\n+\t  if (OMP_FOR_PRE_BODY (node))\n+\t    {\n+\t      spc -= 4;\n+\t      newline_and_indent (buffer, spc + 2);\n+\t      pp_character (buffer, '}');\n+\t    }\n+\t}\n+      is_expr = false;\n+      break;\n+\n+    case OMP_SECTIONS:\n+      pp_string (buffer, \"#pragma omp sections\");\n+      dump_omp_clauses (buffer, OMP_SECTIONS_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OMP_SECTION:\n+      pp_string (buffer, \"#pragma omp section\");\n+      goto dump_omp_body;\n+ \n+    case OMP_MASTER:\n+      pp_string (buffer, \"#pragma omp master\");\n+      goto dump_omp_body;\n+\n+    case OMP_ORDERED:\n+      pp_string (buffer, \"#pragma omp ordered\");\n+      goto dump_omp_body;\n+\n+    case OMP_CRITICAL:\n+      pp_string (buffer, \"#pragma omp critical\");\n+      if (OMP_CRITICAL_NAME (node))\n+\t{\n+\t  pp_space (buffer);\n+\t  pp_character (buffer, '(');\n+          dump_generic_node (buffer, OMP_CRITICAL_NAME (node), spc,\n+\t\t\t     flags, false);\n+\t  pp_character (buffer, ')');\n+\t}\n+      goto dump_omp_body;\n+\n+    case OMP_ATOMIC:\n+      pp_string (buffer, \"#pragma omp atomic\");\n+      newline_and_indent (buffer, spc + 2);\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_space (buffer);\n+      pp_character (buffer, '=');\n+      pp_space (buffer);\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      break;\n+\n+    case OMP_SINGLE:\n+      pp_string (buffer, \"#pragma omp single\");\n+      dump_omp_clauses (buffer, OMP_SINGLE_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n     case REDUC_MAX_EXPR:\n       pp_string (buffer, \" REDUC_MAX_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n@@ -1553,6 +1808,64 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case BLOCK:\n+      {\n+\ttree t;\n+\tpp_string (buffer, \"BLOCK\");\n+\n+\tif (BLOCK_ABSTRACT (node))\n+\t  pp_string (buffer, \" [abstract]\");\n+\n+\tif (TREE_ASM_WRITTEN (node))\n+\t  pp_string (buffer, \" [written]\");\n+\n+\tnewline_and_indent (buffer, spc + 2);\n+\n+\tif (BLOCK_SUPERCONTEXT (node))\n+\t  {\n+\t    pp_string (buffer, \"SUPERCONTEXT: \");\n+\t    if (TREE_CODE (BLOCK_SUPERCONTEXT (node)) == BLOCK)\n+\t      pp_printf (buffer, \"BLOCK %p\",\n+\t\t         (void *)BLOCK_SUPERCONTEXT (node));\n+\t    else\n+\t      dump_generic_node (buffer, BLOCK_SUPERCONTEXT (node), 0, flags,\n+\t\t\t\t false);\n+\t    newline_and_indent (buffer, spc + 2);\n+\t  }\n+\n+\tif (BLOCK_SUBBLOCKS (node))\n+\t  {\n+\t    pp_string (buffer, \"SUBBLOCKS: \");\n+\t    for (t = BLOCK_SUBBLOCKS (node); t; t = BLOCK_CHAIN (t))\n+\t      pp_printf (buffer, \"%p \", (void *)t);\n+\t    newline_and_indent (buffer, spc + 2);\n+\t  }\n+\n+\tif (BLOCK_VARS (node))\n+\t  {\n+\t    pp_string (buffer, \"VARS: \");\n+\t    for (t = BLOCK_VARS (node); t; t = TREE_CHAIN (t))\n+\t      {\n+\t\tdump_generic_node (buffer, t, 0, flags, false);\n+\t\tpp_string (buffer, \" \");\n+\t      }\n+\t    newline_and_indent (buffer, spc + 2);\n+\t  }\n+\n+\tif (BLOCK_ABSTRACT_ORIGIN (node))\n+\t  {\n+\t    pp_string (buffer, \"ABSTRACT_ORIGIN: \");\n+\t    if (TREE_CODE (BLOCK_ABSTRACT_ORIGIN (node)) == BLOCK)\n+\t      pp_printf (buffer, \"BLOCK %p\",\n+\t\t\t (void *)BLOCK_ABSTRACT_ORIGIN (node));\n+\t    else\n+\t      dump_generic_node (buffer, BLOCK_ABSTRACT_ORIGIN (node), 0, flags,\n+\t\t\t\t false);\n+\t    newline_and_indent (buffer, spc + 2);\n+\t  }\n+      }\n+    break;\n+\n     default:\n       NIY;\n     }\n@@ -1645,6 +1958,13 @@ print_declaration (pretty_printer *buffer, tree t, int spc, int flags)\n \t}\n     }\n \n+  if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t))\n+    {\n+      pp_string (buffer, \" [value-expr: \");\n+      dump_generic_node (buffer, DECL_VALUE_EXPR (t), spc, flags, false);\n+      pp_character (buffer, ']');\n+    }\n+\n   pp_character (buffer, ';');\n }\n \n@@ -1857,11 +2177,9 @@ op_prio (tree op)\n /* Return the symbol associated with operator OP.  */\n \n static const char *\n-op_symbol (tree op)\n+op_symbol_1 (enum tree_code code)\n {\n-  gcc_assert (op);\n-\n-  switch (TREE_CODE (op))\n+  switch (code)\n     {\n     case MODIFY_EXPR:\n       return \"=\";\n@@ -2005,11 +2323,23 @@ op_symbol (tree op)\n     case POSTINCREMENT_EXPR:\n       return \"++ \";\n \n+    case MAX_EXPR:\n+      return \"max\";\n+\n+    case MIN_EXPR:\n+      return \"min\";\n+\n     default:\n       return \"<<< ??? >>>\";\n     }\n }\n \n+static const char *\n+op_symbol (tree op)\n+{\n+  return op_symbol_1 (TREE_CODE (op));\n+}\n+\n /* Prints the name of a CALL_EXPR.  */\n \n static void\n@@ -2236,7 +2566,6 @@ void\n dump_generic_bb (FILE *file, basic_block bb, int indent, int flags)\n {\n   maybe_init_pretty_print (file);\n-  dumping_stmts = true;\n   dump_generic_bb_buff (&buffer, bb, indent, flags);\n   pp_flush (&buffer);\n }"}, {"sha": "c8b98d357c8ce9c82d57f6f0529ccad6844cd1b0", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -182,7 +182,7 @@ find_control_dependence (struct edge_list *el, int edge_index)\n   gcc_assert (INDEX_EDGE_PRED_BB (el, edge_index) != EXIT_BLOCK_PTR);\n \n   if (INDEX_EDGE_PRED_BB (el, edge_index) == ENTRY_BLOCK_PTR)\n-    ending_block = ENTRY_BLOCK_PTR->next_bb;\n+    ending_block = single_succ (ENTRY_BLOCK_PTR);\n   else\n     ending_block = find_pdom (INDEX_EDGE_PRED_BB (el, edge_index));\n "}, {"sha": "140676b6bd8bf579e64ca9aeba30da9e17198f2e", "filename": "gcc/tree.c", "status": "modified", "additions": 262, "deletions": 162, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -2944,6 +2944,34 @@ build4_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   return t;\n }\n \n+tree\n+build5_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n+\t     tree arg2, tree arg3, tree arg4 MEM_STAT_DECL)\n+{\n+  bool constant, read_only, side_effects, invariant;\n+  tree t;\n+\n+  gcc_assert (TREE_CODE_LENGTH (code) == 5);\n+\n+  t = make_node_stat (code PASS_MEM_STAT);\n+  TREE_TYPE (t) = tt;\n+\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+\n+  PROCESS_ARG(0);\n+  PROCESS_ARG(1);\n+  PROCESS_ARG(2);\n+  PROCESS_ARG(3);\n+  PROCESS_ARG(4);\n+\n+  TREE_SIDE_EFFECTS (t) = side_effects;\n+  TREE_THIS_VOLATILE (t)\n+    = (TREE_CODE_CLASS (code) == tcc_reference\n+       && arg0 && TREE_THIS_VOLATILE (arg0));\n+\n+  return t;\n+}\n+\n tree\n build7_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n \t     tree arg2, tree arg3, tree arg4, tree arg5,\n@@ -6032,6 +6060,41 @@ tree_class_check_failed (const tree node, const enum tree_code_class cl,\n      tree_code_name[TREE_CODE (node)], function, trim_filename (file), line);\n }\n \n+/* Similar to tree_check_failed, except that instead of specifying a\n+   dozen codes, use the knowledge that they're all sequential.  */\n+\n+void\n+tree_range_check_failed (const tree node, const char *file, int line,\n+\t\t\t const char *function, enum tree_code c1,\n+\t\t\t enum tree_code c2)\n+{\n+  char *buffer;\n+  unsigned length = 0;\n+  enum tree_code c;\n+\n+  for (c = c1; c <= c2; ++c)\n+    length += 4 + strlen (tree_code_name[c]);\n+\n+  length += strlen (\"expected \");\n+  buffer = alloca (length);\n+  length = 0;\n+\n+  for (c = c1; c <= c2; ++c)\n+    {\n+      const char *prefix = length ? \" or \" : \"expected \";\n+\n+      strcpy (buffer + length, prefix);\n+      length += strlen (prefix);\n+      strcpy (buffer + length, tree_code_name[c]);\n+      length += strlen (tree_code_name[c]);\n+    }\n+\n+  internal_error (\"tree check: %s, have %s in %s, at %s:%d\",\n+\t\t  buffer, tree_code_name[TREE_CODE (node)],\n+\t\t  function, trim_filename (file), line);\n+}\n+\n+\n /* Similar to tree_check_failed, except that we check that a tree does\n    not have the specified code, given in CL.  */\n \n@@ -7145,9 +7208,11 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n      interesting below this point in the tree.  */\n   if (!walk_subtrees)\n     {\n+      /* But we still need to check our siblings.  */\n       if (code == TREE_LIST)\n-\t/* But we still need to check our siblings.  */\n \tWALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n+      else if (code >= OMP_CLAUSE_PRIVATE && code <= OMP_CLAUSE_DEFAULT)\n+\tWALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n       else\n \treturn NULL_TREE;\n     }\n@@ -7157,190 +7222,199 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n   if (result || ! walk_subtrees)\n     return result;\n \n-  /* If this is a DECL_EXPR, walk into various fields of the type that it's\n-     defining.  We only want to walk into these fields of a type in this\n-     case.  Note that decls get walked as part of the processing of a\n-     BIND_EXPR.\n-\n-     ??? Precisely which fields of types that we are supposed to walk in\n-     this case vs. the normal case aren't well defined.  */\n-  if (code == DECL_EXPR\n-      && TREE_CODE (DECL_EXPR_DECL (*tp)) == TYPE_DECL\n-      && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (*tp))) != ERROR_MARK)\n+  switch (code)\n     {\n-      tree *type_p = &TREE_TYPE (DECL_EXPR_DECL (*tp));\n+    case ERROR_MARK:\n+    case IDENTIFIER_NODE:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case VECTOR_CST:\n+    case STRING_CST:\n+    case BLOCK:\n+    case PLACEHOLDER_EXPR:\n+    case SSA_NAME:\n+    case FIELD_DECL:\n+    case RESULT_DECL:\n+      /* None of these have subtrees other than those already walked\n+\t above.  */\n+      break;\n \n-      /* Call the function for the type.  See if it returns anything or\n-\t doesn't want us to continue.  If we are to continue, walk both\n-\t the normal fields and those for the declaration case.  */\n-      result = (*func) (type_p, &walk_subtrees, data);\n-      if (result || !walk_subtrees)\n-\treturn NULL_TREE;\n+    case TREE_LIST:\n+      WALK_SUBTREE (TREE_VALUE (*tp));\n+      WALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n+      break;\n \n-      result = walk_type_fields (*type_p, func, data, pset);\n-      if (result)\n-\treturn result;\n+    case TREE_VEC:\n+      {\n+\tint len = TREE_VEC_LENGTH (*tp);\n \n-      WALK_SUBTREE (TYPE_SIZE (*type_p));\n-      WALK_SUBTREE (TYPE_SIZE_UNIT (*type_p));\n+\tif (len == 0)\n+\t  break;\n \n-      /* If this is a record type, also walk the fields.  */\n-      if (TREE_CODE (*type_p) == RECORD_TYPE\n-\t  || TREE_CODE (*type_p) == UNION_TYPE\n-\t  || TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n-\t{\n-\t  tree field;\n+\t/* Walk all elements but the first.  */\n+\twhile (--len)\n+\t  WALK_SUBTREE (TREE_VEC_ELT (*tp, len));\n \n-\t  for (field = TYPE_FIELDS (*type_p); field;\n-\t       field = TREE_CHAIN (field))\n-\t    {\n-\t      /* We'd like to look at the type of the field, but we can easily\n-\t\t get infinite recursion.  So assume it's pointed to elsewhere\n-\t\t in the tree.  Also, ignore things that aren't fields.  */\n-\t      if (TREE_CODE (field) != FIELD_DECL)\n-\t\tcontinue;\n-\n-\t      WALK_SUBTREE (DECL_FIELD_OFFSET (field));\n-\t      WALK_SUBTREE (DECL_SIZE (field));\n-\t      WALK_SUBTREE (DECL_SIZE_UNIT (field));\n-\t      if (TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n-\t\tWALK_SUBTREE (DECL_QUALIFIER (field));\n-\t    }\n-\t}\n-    }\n+\t/* Now walk the first one as a tail call.  */\n+\tWALK_SUBTREE_TAIL (TREE_VEC_ELT (*tp, 0));\n+      }\n \n-  else if (code != SAVE_EXPR\n-\t   && code != BIND_EXPR\n-\t   && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n-    {\n-      int i, len;\n-\n-      /* Walk over all the sub-trees of this operand.  */\n-      len = TREE_CODE_LENGTH (code);\n-      /* TARGET_EXPRs are peculiar: operands 1 and 3 can be the same.\n-\t But, we only want to walk once.  */\n-      if (code == TARGET_EXPR\n-\t  && TREE_OPERAND (*tp, 3) == TREE_OPERAND (*tp, 1))\n-\t--len;\n-\n-      /* Go through the subtrees.  We need to do this in forward order so\n-         that the scope of a FOR_EXPR is handled properly.  */\n-#ifdef DEBUG_WALK_TREE\n-      for (i = 0; i < len; ++i)\n-\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n-#else\n-      for (i = 0; i < len - 1; ++i)\n-\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n+    case COMPLEX_CST:\n+      WALK_SUBTREE (TREE_REALPART (*tp));\n+      WALK_SUBTREE_TAIL (TREE_IMAGPART (*tp));\n \n-      if (len)\n-\t{\n-\t  /* The common case is that we may tail recurse here.  */\n-\t  if (code != BIND_EXPR\n-\t      && !TREE_CHAIN (*tp))\n-\t    WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, len - 1));\n-\t  else\n-\t    WALK_SUBTREE (TREE_OPERAND (*tp, len - 1));\n-\t}\n-#endif\n-    }\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\tconstructor_elt *ce;\n \n-  /* If this is a type, walk the needed fields in the type.  */\n-  else if (TYPE_P (*tp))\n-    {\n-      result = walk_type_fields (*tp, func, data, pset);\n-      if (result)\n-\treturn result;\n-    }\n-  else\n-    {\n-      /* Not one of the easy cases.  We must explicitly go through the\n-\t children.  */\n-      switch (code)\n-\t{\n-\tcase ERROR_MARK:\n-\tcase IDENTIFIER_NODE:\n-\tcase INTEGER_CST:\n-\tcase REAL_CST:\n-\tcase VECTOR_CST:\n-\tcase STRING_CST:\n-\tcase BLOCK:\n-\tcase PLACEHOLDER_EXPR:\n-\tcase SSA_NAME:\n-\tcase FIELD_DECL:\n-\tcase RESULT_DECL:\n-\t  /* None of these have subtrees other than those already walked\n-\t     above.  */\n-\t  break;\n+\tfor (idx = 0;\n+\t     VEC_iterate(constructor_elt, CONSTRUCTOR_ELTS (*tp), idx, ce);\n+\t     idx++)\n+\t  WALK_SUBTREE (ce->value);\n+      }\n+      break;\n \n-\tcase TREE_LIST:\n-\t  WALK_SUBTREE (TREE_VALUE (*tp));\n-\t  WALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n-\t  break;\n+    case SAVE_EXPR:\n+      WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));\n \n-\tcase TREE_VEC:\n+    case BIND_EXPR:\n+      {\n+\ttree decl;\n+\tfor (decl = BIND_EXPR_VARS (*tp); decl; decl = TREE_CHAIN (decl))\n \t  {\n-\t    int len = TREE_VEC_LENGTH (*tp);\n+\t    /* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n+\t       into declarations that are just mentioned, rather than\n+\t       declared; they don't really belong to this part of the tree.\n+\t       And, we can see cycles: the initializer for a declaration\n+\t       can refer to the declaration itself.  */\n+\t    WALK_SUBTREE (DECL_INITIAL (decl));\n+\t    WALK_SUBTREE (DECL_SIZE (decl));\n+\t    WALK_SUBTREE (DECL_SIZE_UNIT (decl));\n+\t  }\n+\tWALK_SUBTREE_TAIL (BIND_EXPR_BODY (*tp));\n+      }\n \n-\t    if (len == 0)\n-\t      break;\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (*tp); !tsi_end_p (i); tsi_next (&i))\n+\t  WALK_SUBTREE (*tsi_stmt_ptr (i));\n+      }\n+      break;\n \n-\t    /* Walk all elements but the first.  */\n-\t    while (--len)\n-\t      WALK_SUBTREE (TREE_VEC_ELT (*tp, len));\n+    case OMP_CLAUSE_PRIVATE:\n+    case OMP_CLAUSE_SHARED:\n+    case OMP_CLAUSE_FIRSTPRIVATE:\n+    case OMP_CLAUSE_LASTPRIVATE:\n+    case OMP_CLAUSE_COPYIN:\n+    case OMP_CLAUSE_COPYPRIVATE:\n+    case OMP_CLAUSE_IF:\n+    case OMP_CLAUSE_NUM_THREADS:\n+    case OMP_CLAUSE_SCHEDULE:\n+      WALK_SUBTREE (TREE_OPERAND (*tp, 0));\n+      /* FALLTHRU */\n+\n+    case OMP_CLAUSE_NOWAIT:\n+    case OMP_CLAUSE_ORDERED:\n+    case OMP_CLAUSE_DEFAULT:\n+      WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n+\n+    case OMP_CLAUSE_REDUCTION:\n+      {\n+\tint i;\n+\tfor (i = 0; i < 4; i++)\n+\t  WALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\tWALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n+      }\n \n-\t    /* Now walk the first one as a tail call.  */\n-\t    WALK_SUBTREE_TAIL (TREE_VEC_ELT (*tp, 0));\n-\t  }\n+    case TARGET_EXPR:\n+      {\n+\tint i, len;\n+\n+\t/* TARGET_EXPRs are peculiar: operands 1 and 3 can be the same.\n+\t   But, we only want to walk once.  */\n+\tlen = (TREE_OPERAND (*tp, 3) == TREE_OPERAND (*tp, 1)) ? 2 : 3;\n+\tfor (i = 0; i < len; ++i)\n+\t  WALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\tWALK_SUBTREE_TAIL (TREE_OPERAND (*tp, len));\n+      }\n \n-\tcase COMPLEX_CST:\n-\t  WALK_SUBTREE (TREE_REALPART (*tp));\n-\t  WALK_SUBTREE_TAIL (TREE_IMAGPART (*tp));\n+    case DECL_EXPR:\n+      /* Walk into various fields of the type that it's defining.  We only\n+\t want to walk into these fields of a type in this case.  Note that\n+\t decls get walked as part of the processing of a BIND_EXPR.\n \n-\tcase CONSTRUCTOR:\n-\t  {\n-\t    unsigned HOST_WIDE_INT idx;\n-\t    constructor_elt *ce;\n+\t ??? Precisely which fields of types that we are supposed to walk in\n+\t this case vs. the normal case aren't well defined.  */\n+      if (TREE_CODE (DECL_EXPR_DECL (*tp)) == TYPE_DECL\n+\t  && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (*tp))) != ERROR_MARK)\n+\t{\n+\t  tree *type_p = &TREE_TYPE (DECL_EXPR_DECL (*tp));\n \n-\t    for (idx = 0;\n-\t\t VEC_iterate(constructor_elt, CONSTRUCTOR_ELTS (*tp), idx, ce);\n-\t\t idx++)\n-\t      WALK_SUBTREE (ce->value);\n-\t  }\n-\t  break;\n+\t  /* Call the function for the type.  See if it returns anything or\n+\t     doesn't want us to continue.  If we are to continue, walk both\n+\t     the normal fields and those for the declaration case.  */\n+\t  result = (*func) (type_p, &walk_subtrees, data);\n+\t  if (result || !walk_subtrees)\n+\t    return NULL_TREE;\n \n-\tcase SAVE_EXPR:\n-\t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));\n+\t  result = walk_type_fields (*type_p, func, data, pset);\n+\t  if (result)\n+\t    return result;\n \n-\tcase BIND_EXPR:\n-\t  {\n-\t    tree decl;\n-\t    for (decl = BIND_EXPR_VARS (*tp); decl; decl = TREE_CHAIN (decl))\n-\t      {\n-\t\t/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n-\t\t   into declarations that are just mentioned, rather than\n-\t\t   declared; they don't really belong to this part of the tree.\n-\t\t   And, we can see cycles: the initializer for a declaration\n-\t\t   can refer to the declaration itself.  */\n-\t\tWALK_SUBTREE (DECL_INITIAL (decl));\n-\t\tWALK_SUBTREE (DECL_SIZE (decl));\n-\t\tWALK_SUBTREE (DECL_SIZE_UNIT (decl));\n-\t      }\n-\t    WALK_SUBTREE_TAIL (BIND_EXPR_BODY (*tp));\n-\t  }\n+\t  /* If this is a record type, also walk the fields.  */\n+\t  if (TREE_CODE (*type_p) == RECORD_TYPE\n+\t      || TREE_CODE (*type_p) == UNION_TYPE\n+\t      || TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n+\t    {\n+\t      tree field;\n \n-\tcase STATEMENT_LIST:\n-\t  {\n-\t    tree_stmt_iterator i;\n-\t    for (i = tsi_start (*tp); !tsi_end_p (i); tsi_next (&i))\n-\t      WALK_SUBTREE (*tsi_stmt_ptr (i));\n-\t  }\n-\t  break;\n+\t      for (field = TYPE_FIELDS (*type_p); field;\n+\t\t   field = TREE_CHAIN (field))\n+\t\t{\n+\t\t  /* We'd like to look at the type of the field, but we can\n+\t\t     easily get infinite recursion.  So assume it's pointed\n+\t\t     to elsewhere in the tree.  Also, ignore things that\n+\t\t     aren't fields.  */\n+\t\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t\t    continue;\n+\n+\t\t  WALK_SUBTREE (DECL_FIELD_OFFSET (field));\n+\t\t  WALK_SUBTREE (DECL_SIZE (field));\n+\t\t  WALK_SUBTREE (DECL_SIZE_UNIT (field));\n+\t\t  if (TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n+\t\t    WALK_SUBTREE (DECL_QUALIFIER (field));\n+\t\t}\n+\t    }\n \n-\tdefault:\n-\t  /* ??? This could be a language-defined node.  We really should make\n-\t     a hook for it, but right now just ignore it.  */\n-\t  break;\n+\t  WALK_SUBTREE (TYPE_SIZE (*type_p));\n+\t  WALK_SUBTREE_TAIL (TYPE_SIZE_UNIT (*type_p));\n \t}\n+      /* FALLTHRU */\n+\n+    default:\n+      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+\t{\n+\t  int i, len;\n+\n+\t  /* Walk over all the sub-trees of this operand.  */\n+\t  len = TREE_CODE_LENGTH (code);\n+\n+\t  /* Go through the subtrees.  We need to do this in forward order so\n+\t     that the scope of a FOR_EXPR is handled properly.  */\n+\t  if (len)\n+\t    {\n+\t      for (i = 0; i < len - 1; ++i)\n+\t\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\t      WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, len - 1));\n+\t    }\n+\t}\n+\n+      /* If this is a type, walk the needed fields in the type.  */\n+      else if (TYPE_P (*tp))\n+\treturn walk_type_fields (*tp, func, data, pset);\n+      break;\n     }\n \n   /* We didn't find what we were looking for.  */\n@@ -7364,4 +7438,30 @@ walk_tree_without_duplicates (tree *tp, walk_tree_fn func, void *data)\n   return result;\n }\n \n+\n+/* Return true if STMT is an empty statement or contains nothing but\n+   empty statements.  */\n+\n+bool\n+empty_body_p (tree stmt)\n+{\n+  tree_stmt_iterator i;\n+  tree body;\n+\n+  if (IS_EMPTY_STMT (stmt))\n+    return true;\n+  else if (TREE_CODE (stmt) == BIND_EXPR)\n+    body = BIND_EXPR_BODY (stmt);\n+  else if (TREE_CODE (stmt) == STATEMENT_LIST)\n+    body = stmt;\n+  else\n+    return false;\n+\n+  for (i = tsi_start (body); !tsi_end_p (i); tsi_next (&i))\n+    if (!empty_body_p (tsi_stmt (i)))\n+      return false;\n+\n+  return true;\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "9e7e5b011d5e6122d4b42f5124f507df2872361d", "filename": "gcc/tree.def", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -953,6 +953,116 @@ DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n \n DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 7)\n \n+/* The ordering of the codes between OMP_PARALLEL and OMP_CRITICAL is\n+   exposed to TREE_RANGE_CHECK.  */\n+/* OpenMP - #pragma omp parallel [clause1 ... clauseN]\n+   Operand 0: OMP_PARALLEL_BODY: Code to be executed by all threads.\n+   Operand 1: OMP_PARALLEL_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_PARALLEL, \"omp_parallel\", tcc_statement, 2)\n+\n+/* OpenMP - #pragma omp for [clause1 ... clauseN]\n+   Operand 0: OMP_FOR_BODY: Loop body.\n+   Operand 1: OMP_FOR_CLAUSES: List of clauses.\n+   Operand 2: OMP_FOR_INIT: Initialization code of the form\n+                             \tVAR = N1.\n+   Operand 3: OMP_FOR_COND: Loop conditional expression of the form\n+                             \tVAR { <, >, <=, >= } N2.\n+   Operand 4: OMP_FOR_INCR: Loop index increment of the form\n+\t\t\t     \tVAR { +=, -= } INCR.\n+   Operand 5: OMP_FOR_PRE_BODY: Filled by the gimplifier with things\n+\tfrom INIT, COND, and INCR that are technically part of the\n+\tOMP_FOR structured block, but are evaluated before the loop\n+\tbody begins.\n+\n+   VAR must be a signed integer variable, which is implicitly thread\n+   private.  N1, N2 and INCR are required to be loop invariant integer\n+   expressions that are evaluated without any synchronization.\n+   The evaluation order, frequency of evaluation and side-effects are\n+   unspecified by the standard.  */\n+DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n+\n+/* OpenMP - #pragma omp sections [clause1 ... clauseN]\n+   Operand 0: OMP_SECTIONS_BODY: Sections body.\n+   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 2)\n+\n+/* OpenMP - #pragma omp single\n+   Operand 0: OMP_SINGLE_BODY: Single section body.\n+   Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_SINGLE, \"omp_single\", tcc_statement, 2)\n+\n+/* OpenMP - #pragma omp section\n+   Operand 0: OMP_SECTION_BODY: Section body.  */\n+DEFTREECODE (OMP_SECTION, \"omp_section\", tcc_statement, 1)\n+\n+/* OpenMP - #pragma omp master\n+   Operand 0: OMP_MASTER_BODY: Master section body.  */\n+DEFTREECODE (OMP_MASTER, \"omp_master\", tcc_statement, 1)\n+\n+/* OpenMP - #pragma omp ordered\n+   Operand 0: OMP_ORDERED_BODY: Master section body.  */\n+DEFTREECODE (OMP_ORDERED, \"omp_ordered\", tcc_statement, 1)\n+\n+/* OpenMP - #pragma omp critical [name]\n+   Operand 0: OMP_CRITICAL_BODY: Critical section body.\n+   Operand 1: OMP_CRITICAL_NAME: Identifier for critical section.  */\n+DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 2)\n+\n+/* OpenMP - #pragma omp atomic\n+   Operand 0: The address at which the atomic operation is to be performed.\n+\tThis address should be stabilized with save_expr.\n+   Operand 1: The expression to evaluate.  When the old value of the object\n+\tat the address is used in the expression, it should appear as if\n+\tbuild_fold_indirect_ref of the address.  */\n+DEFTREECODE (OMP_ATOMIC, \"omp_atomic\", tcc_statement, 2)\n+\n+/* The ordering of the codes between OMP_CLAUSE_PRIVATE and\n+   OMP_CLAUSE_DEFAULT is exposed to TREE_RANGE_CHECK.  */\n+/* OpenMP clause: private (variable_list).  */\n+DEFTREECODE (OMP_CLAUSE_PRIVATE, \"private\", tcc_expression, 1)\n+\n+/* OpenMP clause: shared (variable_list).  */\n+DEFTREECODE (OMP_CLAUSE_SHARED, \"shared\", tcc_expression, 1)\n+\n+/* OpenMP clause: firstprivate (variable_list).  */\n+DEFTREECODE (OMP_CLAUSE_FIRSTPRIVATE, \"firstprivate\", tcc_expression, 1)\n+\n+/* OpenMP clause: lastprivate (variable_list).  */\n+DEFTREECODE (OMP_CLAUSE_LASTPRIVATE, \"lastprivate\", tcc_expression, 1)\n+\n+/* OpenMP clause: reduction (operator:variable_list).\n+   OMP_CLAUSE_REDUCTION_CODE: The tree_code of the operator.\n+   Operand 1: OMP_CLAUSE_REDUCTION_INIT: Stmt-list to initialize the var.\n+   Operand 2: OMP_CLAUSE_REDUCTION_MERGE:\n+     Stmt-list to merge private var into the shared one.\n+   Operand 3: OMP_CLAUSE_REDUCTION_PLACEHOLDER:\n+     A dummy VAR_DECL placeholder used in OMP_CLAUSE_REDUCTION_MERGE.  */\n+DEFTREECODE (OMP_CLAUSE_REDUCTION, \"reduction\", tcc_expression, 4)\n+\n+/* OpenMP clause: copyin (variable_list).  */\n+DEFTREECODE (OMP_CLAUSE_COPYIN, \"copyin\", tcc_expression, 1)\n+\n+/* OpenMP clause: copyprivate (variable_list).  */\n+DEFTREECODE (OMP_CLAUSE_COPYPRIVATE, \"copyprivate\", tcc_expression, 1)\n+\n+/* OpenMP clause: if (scalar-expression).  */\n+DEFTREECODE (OMP_CLAUSE_IF, \"if\", tcc_expression, 1)\n+\n+/* OpenMP clause: num_threads (integer-expression).  */\n+DEFTREECODE (OMP_CLAUSE_NUM_THREADS, \"num_threads\", tcc_expression, 1)\n+\n+/* OpenMP clause: schedule.  */\n+DEFTREECODE (OMP_CLAUSE_SCHEDULE, \"schedule\", tcc_expression, 1)\n+\n+/* OpenMP clause: nowait.  */\n+DEFTREECODE (OMP_CLAUSE_NOWAIT, \"nowait\", tcc_expression, 0)\n+\n+/* OpenMP clause: ordered.  */\n+DEFTREECODE (OMP_CLAUSE_ORDERED, \"ordered\", tcc_expression, 0)\n+\n+/* OpenMP clause: default.  */\n+DEFTREECODE (OMP_CLAUSE_DEFAULT, \"default\", tcc_expression, 0)\n+\n /* Reduction operations. \n    Operations that take a vector of elements and \"reduce\" it to a scalar\n    result (e.g. summing the elements of the vector, finding the minimum over"}, {"sha": "f7244fc4f747bcf0419c3c9bd96df5a3a290e469", "filename": "gcc/tree.h", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -351,6 +351,10 @@ struct tree_common GTY(())\n           ..._TYPE\n        SAVE_EXPR_RESOLVED_P in\n \t  SAVE_EXPR\n+       OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE in\n+\t  OMP_CLAUSE_LASTPRIVATE\n+       OMP_CLAUSE_PRIVATE_DEBUG in\n+\t  OMP_CLAUSE_PRIVATE\n \n    private_flag:\n \n@@ -579,6 +583,13 @@ enum tree_node_structure_enum {\n \t\t\t       __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n+#define TREE_RANGE_CHECK(T, CODE1, CODE2) __extension__\t\t\t\\\n+({  const tree __t = (T);\t\t\t\t\t\t\\\n+    if (TREE_CODE (__t) < (CODE1) && TREE_CODE (__t) > (CODE2))\t\t\\\n+      tree_range_check_failed (__t, __FILE__, __LINE__, __FUNCTION__,\t\\\n+\t\t\t       (CODE1), (CODE2));\t\t\t\\\n+    __t; })\n+\n /* These checks have to be special cased.  */\n #define EXPR_CHECK(T) __extension__\t\t\t\t\t\\\n ({  const tree __t = (T);\t\t\t\t\t\t\\\n@@ -660,6 +671,9 @@ extern void tree_not_check_failed (const tree, const char *, int, const char *,\n extern void tree_class_check_failed (const tree, const enum tree_code_class,\n \t\t\t\t     const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n+extern void tree_range_check_failed (const tree, const char *, int,\n+\t\t\t\t     const char *, enum tree_code,\n+\t\t\t\t     enum tree_code);\n extern void tree_not_class_check_failed (const tree,\n \t\t\t\t\t const enum tree_code_class,\n \t\t\t\t\t const char *, int, const char *)\n@@ -688,6 +702,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)\n #define TREE_NOT_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)\n #define TREE_CLASS_CHECK(T, CODE)\t\t(T)\n+#define TREE_RANGE_CHECK(T, CODE1, CODE2)\t(T)\n #define EXPR_CHECK(T)\t\t\t\t(T)\n #define NON_TYPE_CHECK(T)\t\t\t(T)\n #define TREE_VEC_ELT_CHECK(T, I)\t\t((T)->vec.a[I])\n@@ -1400,6 +1415,93 @@ struct tree_constructor GTY(())\n #define ASSERT_EXPR_VAR(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 0)\n #define ASSERT_EXPR_COND(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 1)\n \n+/* OpenMP directive and clause accessors.  */\n+\n+#define OMP_BODY(NODE) \\\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OMP_PARALLEL, OMP_CRITICAL), 0)\n+#define OMP_CLAUSES(NODE) \\\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OMP_PARALLEL, OMP_SINGLE), 1)\n+\n+#define OMP_PARALLEL_BODY(NODE)    TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 0)\n+#define OMP_PARALLEL_CLAUSES(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 1)\n+\n+#define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 0)\n+#define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 1)\n+#define OMP_FOR_INIT(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 2)\n+#define OMP_FOR_COND(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 3)\n+#define OMP_FOR_INCR(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 4)\n+#define OMP_FOR_PRE_BODY(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 5)\n+\n+#define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n+#define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n+\n+#define OMP_SECTION_BODY(NODE)\t   TREE_OPERAND (OMP_SECTION_CHECK (NODE), 0)\n+\n+#define OMP_SINGLE_BODY(NODE)\t   TREE_OPERAND (OMP_SINGLE_CHECK (NODE), 0)\n+#define OMP_SINGLE_CLAUSES(NODE)   TREE_OPERAND (OMP_SINGLE_CHECK (NODE), 1)\n+\n+#define OMP_MASTER_BODY(NODE)\t   TREE_OPERAND (OMP_MASTER_CHECK (NODE), 0)\n+\n+#define OMP_ORDERED_BODY(NODE)\t   TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 0)\n+\n+#define OMP_CRITICAL_BODY(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 0)\n+#define OMP_CRITICAL_NAME(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 1)\n+\n+#define OMP_CLAUSE_CHAIN(NODE) \\\n+  TREE_CHAIN (TREE_RANGE_CHECK (NODE, OMP_CLAUSE_PRIVATE, OMP_CLAUSE_DEFAULT))\n+#define OMP_CLAUSE_DECL(NODE) \\\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OMP_CLAUSE_PRIVATE, \\\n+\t\t\t\t  OMP_CLAUSE_COPYPRIVATE), 0)\n+\n+/* True on a PRIVATE clause if its decl is kept around for debugging\n+   information only and its DECL_VALUE_EXPR is supposed to point\n+   to what it has been remapped to.  */\n+#define OMP_CLAUSE_PRIVATE_DEBUG(NODE) \\\n+  TREE_PUBLIC (OMP_CLAUSE_PRIVATE_CHECK (NODE))\n+\n+/* True on a LASTPRIVATE clause if a FIRSTPRIVATE clause for the same\n+   decl is present in the chain.  */\n+#define OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE(NODE) \\\n+  TREE_PUBLIC (OMP_CLAUSE_LASTPRIVATE_CHECK (NODE))\n+\n+#define OMP_CLAUSE_IF_EXPR(NODE) \\\n+  TREE_OPERAND (OMP_CLAUSE_IF_CHECK (NODE), 0)\n+#define OMP_CLAUSE_NUM_THREADS_EXPR(NODE) \\\n+  TREE_OPERAND (OMP_CLAUSE_NUM_THREADS_CHECK (NODE), 0)\n+#define OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(NODE) \\\n+  TREE_OPERAND (OMP_CLAUSE_SCHEDULE_CHECK (NODE), 0)\n+\n+#define OMP_CLAUSE_REDUCTION_CODE(NODE)\t\\\n+  (OMP_CLAUSE_REDUCTION_CHECK (NODE)->exp.complexity)\n+#define OMP_CLAUSE_REDUCTION_INIT(NODE) \\\n+  TREE_OPERAND (OMP_CLAUSE_REDUCTION_CHECK (NODE), 1)\n+#define OMP_CLAUSE_REDUCTION_MERGE(NODE) \\\n+  TREE_OPERAND (OMP_CLAUSE_REDUCTION_CHECK (NODE), 2)\n+#define OMP_CLAUSE_REDUCTION_PLACEHOLDER(NODE) \\\n+  TREE_OPERAND (OMP_CLAUSE_REDUCTION_CHECK (NODE), 3)\n+\n+enum omp_clause_schedule_kind\n+{\n+  OMP_CLAUSE_SCHEDULE_STATIC,\n+  OMP_CLAUSE_SCHEDULE_DYNAMIC,\n+  OMP_CLAUSE_SCHEDULE_GUIDED,\n+  OMP_CLAUSE_SCHEDULE_RUNTIME\n+};\n+\n+#define OMP_CLAUSE_SCHEDULE_KIND(NODE) \\\n+  (OMP_CLAUSE_SCHEDULE_CHECK (NODE)->exp.complexity)\n+\n+enum omp_clause_default_kind\n+{\n+  OMP_CLAUSE_DEFAULT_UNSPECIFIED,\n+  OMP_CLAUSE_DEFAULT_SHARED,\n+  OMP_CLAUSE_DEFAULT_NONE,\n+  OMP_CLAUSE_DEFAULT_PRIVATE\n+};\n+\n+#define OMP_CLAUSE_DEFAULT_KIND(NODE) \\\n+  (OMP_CLAUSE_DEFAULT_CHECK (NODE)->exp.complexity)\n+\n struct tree_exp GTY(())\n {\n   struct tree_common common;\n@@ -3210,6 +3312,9 @@ extern tree build3_stat (enum tree_code, tree, tree, tree, tree MEM_STAT_DECL);\n extern tree build4_stat (enum tree_code, tree, tree, tree, tree,\n \t\t\t tree MEM_STAT_DECL);\n #define build4(c,t1,t2,t3,t4,t5) build4_stat (c,t1,t2,t3,t4,t5 MEM_STAT_INFO)\n+extern tree build5_stat (enum tree_code, tree, tree, tree, tree, tree,\n+\t\t\t tree MEM_STAT_DECL);\n+#define build5(c,t1,t2,t3,t4,t5,t6) build5_stat (c,t1,t2,t3,t4,t5,t6 MEM_STAT_INFO)\n extern tree build7_stat (enum tree_code, tree, tree, tree, tree, tree,\n \t\t\t tree, tree, tree MEM_STAT_DECL);\n #define build7(c,t1,t2,t3,t4,t5,t6,t7,t8) \\\n@@ -3823,6 +3928,7 @@ extern bool commutative_tree_code (enum tree_code);\n extern tree upper_bound_in_type (tree, tree);\n extern tree lower_bound_in_type (tree, tree);\n extern int operand_equal_for_phi_arg_p (tree, tree);\n+extern bool empty_body_p (tree);\n \f\n /* In stmt.c */\n \n@@ -3947,6 +4053,7 @@ extern tree strip_float_extensions (tree);\n extern tree c_strlen (tree, int);\n extern tree std_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n extern tree build_va_arg_indirect_ref (tree);\n+tree build_string_literal (int, const char *);\n \n /* In convert.c */\n extern tree strip_float_extensions (tree);"}, {"sha": "af10d38061554c408e20630ce2c7a21487050441", "filename": "libgomp/ChangeLog", "status": "added", "additions": 941, "deletions": 0, "changes": 941, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,941 @@\n+2006-01-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/25219\n+\t* testsuite/libgomp.fortran/pr25219.f90: New test.\n+\n+2005-12-05  Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* testsuite/libgomp.c/pr24455.c, testsuite/libgomp.c/copyin-1.c,\n+\ttestsuite/libgomp.c/copyin-2.c, testsuite/libgomp.c/copyin-3.c,\n+\ttestsuite/libgomp.c++/copyin-1.C, testsuite/libgomp.c++/copyin-2.C,\n+\ttestsuite/libgomp.c++/ctor-5.C, testsuite/libgomp.c++/ctor-8.C,\n+\ttestsuite/libgomp.c++/ctor-9.C, testsuite/libgomp.c++/pr24455.C,\n+\ttestsuite/libgomp.fortran/threadprivate1.f90,\n+\ttestsuite/libgomp.fortran/threadprivate2.f90,\n+\ttestsuite/libgomp.fortran/threadprivate3.f90,\n+\ttestsuite/libgomp.fortran/appendix-a/a.22.7.f9,\n+\ttestsuite/libgomp.fortran/appendix-a/a.22.8.f9,\n+\ttestsuite/libgomp.fortran/omp_parse3.f90: Change required\n+\teffective-target to TLS runtime.\n+\n+\t* testsuite/libgomp.fortran/pr25162.f: Require\n+\teffective-target TLS runtime.\n+\n+2005-12-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/nestedfn2.f90: New test.\n+\t* testsuite/libgomp.c/nestedfn-3.c: New test.\n+\n+2005-11-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/25162\n+\t* testsuite/libgomp.fortran/pr25162.f: New test.\n+\n+2005-11-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/posix/time.c (omp_get_wtime, omp_get_wtick): Fall back to\n+\tCLOCK_REALTIME if clock_* (CLOCK_MONOTONIC, &ts) call failed.\n+\n+2005-11-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* alloc.c, barrier.c, critical.c, env.c, error.c, fortran.c, iter.c,\n+\tlibgomp.h, libgomp_f.h.in, libgomp_g.h, loop.c, mkomp_h.pl, omp.h.in,\n+\tomp_lib.f90.in, omp_lib.h.in, ordered.c, parallel.c, sections.c,\n+\tsingle.c, team.c, work.c, config/linux/alpha/futex.h,\n+\tconfig/linux/bar.c, config/linux/bar.h, config/linux/ia64/futex.h,\n+\tconfig/linux/lock.c, config/linux/mutex.c, config/linux/mutex.h,\n+\tconfig/linux/powerpc/futex.h, config/linux/s390/futex.h,\n+\tconfig/linux/sem.c, config/linux/sem.h, config/linux/sparc/futex.h,\n+\tconfig/linux/x86/futex.h, config/posix/bar.c, config/posix/bar.h,\n+\tconfig/posix/lock.c, config/posix/mutex.h, config/posix/proc.c,\n+\tconfig/posix/sem.c, config/posix/sem.h, config/posix/time.c: Update\n+\tFSF address.\n+\n+2005-11-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* Makefile.am: Move libgomp_f.h from nodist_include_HEADERS\n+\tto nodist_noinst_HEADERS.\n+\t* Makefile.in: Rebuilt.\n+\n+\t* config/posix/omp-lock.h (omp_nest_lock_t): Change into struct,\n+\tadd integer count field.\n+\t* config/posix/lock.c (omp_destroy_nest_lock): Adjust for\n+\tomp_nest_lock_t type change.\n+\t(omp_init_nest_lock): Likewise.  Initialize count to 0.\n+\t(omp_set_nest_lock): Adjust for omp_nest_lock_t type change.\n+\tIncrement count.\n+\t(omp_unset_nest_lock): Adjust for omp_nest_lock_t type change.\n+\tDecrement count.\n+\t(omp_test_nest_lock): Adjust for omp_nest_lock_t type change.\n+\tIncrement count if successful and return the new nesting level.\n+\t* config/linux/lock.c (omp_test_nest_lock): Return new nesting level.\n+\t* omp_lib.f90.in (omp_test_lock): Fix LOCK argument type.\n+\t* testsuite/libgomp.c/lib-1.c: New test.\n+\t* testsuite/libgomp.fortran/lib1.f90: New test.\n+\t* testsuite/libgomp.fortran/lib2.f: New test.\n+\t* testsuite/libgomp.fortran/lib3.f: New test.\n+\n+2005-11-17  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 24845\n+\t* Makefile.am (nodist_toolexeclib_HEADERS): New.\n+\t* configure.ac (link_gomp): New.  Substitute it.\n+\t(AC_CONFIG_FILES): Add libgomp.spec.\n+\t* libgomp.spec.in: New file.\n+\t* Makefile.in, testsuite/Makefile.in, configure: Rebuild.\n+\t* testsuite/lib/libgomp-dg.exp: Add -B${blddir}/ to flags.\n+\n+2005-11-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/reduction1.f90: Adjust for\n+\treduction(-:var) behaving the same as reduction(+:var).\n+\t* testsuite/libgomp.c/reduction-4.c: New test.\n+\n+2005-11-15  Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* testsuite/libgomp.c/pr24455-1.c, testsuite/libgomp.c/pr24455.c,\n+\ttestsuite/libgomp.c/copyin-1.c, testsuite/libgomp.c/copyin-2.c,\n+\ttestsuite/libgomp.c/copyin-3.c,\n+\ttestsuite/libgomp.c++/copyin-1.C, testsuite/libgomp.c++/copyin-2.C,\n+\ttestsuite/libgomp.c++/ctor-5.C, testsuite/libgomp.c++/ctor-8.C,\n+\ttestsuite/libgomp.c++/ctor-9.C, testsuite/libgomp.c++/pr24455-1.C,\n+\ttestsuite/libgomp.c++/pr24455.C,\n+\ttestsuite/libgomp.fortran/threadprivate1.f90,\n+\ttestsuite/libgomp.fortran/threadprivate2.f90,\n+\ttestsuite/libgomp.fortran/threadprivate3.f90,\n+\ttestsuite/libgomp.fortran/appendix-a/a.22.7.f9,\n+\ttestsuite/libgomp.fortran/appendix-a/a.22.8.f9,\n+\ttestsuite/libgomp.fortran/omp_parse3.f90: Require\n+\teffective-target TLS.\n+\n+2005-11-14  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* HEADER: Remove.\n+\n+2005-11-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgomp/24797\n+\t* team.c (initialize_team): Pass NULL rather than free as\n+\tpthread_key_create destructor.  Initialize thread specific data\n+\tpointer in initial thread to a static local variable rather than\n+\tmalloced memory.\n+\n+2005-11-11  Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* testsuite/lib/libgomp-dg.exp: Locate libgcc.a and append\n+\tits location to ld_library_path.\n+\n+2005-11-10  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.c/c.exp: Rename from dg.exp.\n+\n+2005-11-10  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.c: Rename from libgomp.dg.\n+\n+2005-11-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.c++/pr24455.C: Add copyin clause for\n+\tthreadprivate variable 'i'.\n+\n+2005-11-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/linux/s390/futex.h: New file.\n+\t* configure.tgt: Use it.\n+\n+\t* testsuite/libgomp.fortran/omp_parse4.f90: Move n initialization\n+\tbefore the parallel.\n+\n+2005-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/24734\n+\t* testsuite/libgomp.c++/master-1.C: New test.\n+\n+2005-11-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.dg/copyin-3.c: New test.\n+\n+2005-11-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/retval1.f90: New test.\n+\t* testsuite/libgomp.fortran/vla7.f90: New test.\n+\n+2005-11-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/vla2.f90: New test.\n+\t* testsuite/libgomp.fortran/vla3.f90: New test.\n+\t* testsuite/libgomp.fortran/vla4.f90: New test.\n+\t* testsuite/libgomp.fortran/vla5.f90: New test.\n+\t* testsuite/libgomp.fortran/vla6.f90: New test.\n+\n+2005-11-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/linux/sparc/futex.h: New file.\n+\t* configure.tgt: Use it.\n+\t* testsuite/lib/libgomp-dg.exp: Use -mcpu=v9 for sparc testing.\n+\n+\t* critical.c: Include stdlib.h.\n+\t* acinclude.m4 (LIBGOMP_CHECK_SYNC_BUILTINS): Avoid warnings about\n+\tignoring return value.\n+\t* configure.ac: Don't put -Wc,-pthread into XCFLAGS until after\n+\tLIBGOMP_CHECK_SYNC_BUILTINS check.\n+\t* configure: Rebuilt.\n+\n+2005-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/vla1.f90: New test.\n+\n+2005-10-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/character2.f90: Fix race condition\n+\tsetting 's' in different threads.\n+\n+2005-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* libgomp.h (attribute_hidden, ialias): Define.\n+\t* config/posix/proc.c (omp_get_num_procs): Add ialias.\n+\t* config/posix/time.c (omp_get_wtime, omp_get_wtick): Likewise.\n+\t* config/posix/lock.c (omp_init_lock, omp_init_nest_lock,\n+\tomp_destroy_lock, omp_destroy_nest_lock, omp_set_lock,\n+\tomp_set_nest_lock, omp_unset_lock, omp_unset_nest_lock,\n+\tomp_test_lock, omp_test_nest_lock): Likewise.\n+\t* config/linux/lock.c (omp_init_lock, omp_init_nest_lock,\n+\tomp_destroy_lock, omp_destroy_nest_lock, omp_set_lock,\n+\tomp_set_nest_lock, omp_unset_lock, omp_unset_nest_lock,\n+\tomp_test_lock, omp_test_nest_lock): Likewise.\n+\t* env.c (omp_set_dynamic, omp_set_nested, omp_set_num_threads,\n+\tomp_get_dynamic, omp_get_nested): Likewise.\n+\t* parallel.c (omp_get_num_threads, omp_get_max_threads,\n+\tomp_get_thread_num, omp_in_parallel): Likewise.\n+\t* fortran.c (ialias_redirect): Define.\n+\t(omp_init_lock, omp_init_nest_lock, omp_destroy_lock,\n+\tomp_destroy_nest_lock, omp_set_lock, omp_set_nest_lock,\n+\tomp_unset_lock, omp_unset_nest_lock, omp_test_lock,\n+\tomp_test_nest_lock, omp_set_dynamic, omp_set_nested,\n+\tomp_set_num_threads, omp_get_dynamic, omp_get_nested,\n+\tomp_in_parallel, omp_get_max_threads, omp_get_num_procs,\n+\tomp_get_num_threads, omp_get_thread_num, omp_get_wtick,\n+\tomp_get_wtime): Add ialias_redirect.\n+\n+2005-10-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* fortran.c: Include stdlib.h.\n+\n+2005-10-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* Makefile.am (env.o, env.lo): Depend on libgomp_f.h.\n+\t* Makefile.in: Regenerated.\n+\n+2005-10-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* mkomp_h.pl: Remove all -Wc, option prefixes in $COMPILE.\n+\t* libgomp_f.h.in (omp_check_defines): New function.\n+\t* env.c: Include libgomp_f.h.\n+\t(initialize_env): Call omp_check_defines.\n+\n+\t* testsuite/libgomp.dg/copyin-2.c: New test.\n+\t* testsuite/libgomp.c++/copyin-2.C: New test.\n+\t* testsuite/libgomp.fortran/threadprivate3.f90: New test.\n+\n+\t* testsuite/libgomp.fortran/threadprivate2.f90: New test.\n+\t* testsuite/libgomp.fortran/sharing2.f90: New test.\n+\n+\t* testsuite/libgomp.dg/copyin-1.c: New test.\n+\t* testsuite/libgomp.c++/copyin-1.C: New test.\n+\n+2005-10-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/crayptr1.f90: New test.\n+\n+\t* testsuite/libgomp.fortran/workshare1.f90: New test.\n+\n+\t* libgomp.fortran/appendix-a/a.28.5.f90: Change into compile\n+\tonly test.\n+\t* libgomp.fortran/sharing1.f90: New test.\n+\n+2005-10-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/24502\n+\t* testsuite/libgomp.c++/loop-7.C: New test.\n+\n+\t* testsuite/libgomp.dg/nestedfn-2.c: New test.\n+\n+\t* testsuite/libgomp.dg/nestedfn-1.c: New test.\n+\t* testsuite/libgomp.fortran/reduction6.f90: New test.\n+\t* testsuite/libgomp.fortran/nestedfn1.f90: New test.\n+\n+2005-10-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/libgomp.c++/ctor-1.C: New.\n+\t* testsuite/libgomp.c++/ctor-2.C: New.\n+\t* testsuite/libgomp.c++/ctor-3.C: New.\n+\t* testsuite/libgomp.c++/ctor-4.C: New.\n+\t* testsuite/libgomp.c++/ctor-5.C: New.\n+\t* testsuite/libgomp.c++/ctor-6.C: New.\n+\t* testsuite/libgomp.c++/ctor-7.C: New.\n+\t* testsuite/libgomp.c++/ctor-8.C: New.\n+\t* testsuite/libgomp.c++/ctor-9.C: New.\n+\n+2005-10-21  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 24455\n+\t* testsuite/libgomp.c++/pr24455-1.C: New test.\n+\t* testsuite/libgomp.c++/pr24455.C: New test.\n+\t* testsuite/libgomp.dg/pr24455-1.c: New test.\n+\t* testsuite/libgomp.dg/pr24455.c: New test.\n+\n+2005-10-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/libgomp.c++/loop-6.C: New.\n+\t* testsuite/libgomp.dg/loop-3.c: New.\n+\n+2005-10-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/jacobi.f: Don't make i and j\n+\texplicitly private.\n+\t* testsuite/libgomp.fortran/omp_parse1.f90 (test_do): Make i\n+\texplicitly shared.\n+\n+2005-10-19  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/jacobi.f: New test.\n+\n+2005-10-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.tgt (i?86-linux): Default to with_arch instead of\n+\tCFLAGS.  Add -mtune to match target_cpu.\n+\t(x86_64-linux): Tune to i686.\n+\n+\t* fortran.c (omp_test_nest_lock_): Fix typo.\n+\n+2005-10-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* ordered.c (gomp_ordered_first, gomp_ordered_last, gomp_ordered_next,\n+\tgomp_ordered_sync): Do nothing if team->nthreads == 1.\n+\t* testsuite/libgomp.dg/ordered-3.c: New test.\n+\n+\t* testsuite/libgomp.dg/appendix-a/a.18.1.c: Remove unconditional abort.\n+\tRemove volatile keyword.\n+\n+\t* testsuite/libgomp.fortran/appendix-a/a.19.1.f90: Reorder variables\n+\tin COMMON block to avoid warnings on 64-bit targets.\n+\n+2005-10-18  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/shared-3.c: New test.\n+\n+2005-10-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/appendix-a/a.31.3.f90: Removed.\n+\t* testsuite/libgomp.fortran/reduction5.f90: New test.\n+\n+2005-10-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/appendix-a/a.40.1.f90: Add -ffixed-form to\n+\tdg-options.\n+\t* testsuite/libgomp.fortran/appendix-a/a.18.1.f90: Likewise.  Enable\n+\tflush loop now that __sync_synchronize has proper memory barrier.\n+\t* testsuite/libgomp.fortran/appendix-a/a.3.1.f90: Fix a typo.\n+\tAdd -ffixed-form to dg-options.\n+\n+2005-10-17  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/fortran.exp: Also gather tests\n+\tfrom subdirectories.\n+\t* testsuite/libgomp.fortran/appendix-a/a.15.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.16.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.18.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.19.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.2.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.21.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.22.7.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.22.8.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.26.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.28.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.28.2.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.28.3.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.28.4.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.28.5.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.3.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.31.3.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.31.4.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.31.5.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.33.3.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.38.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.39.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.4.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.40.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a.5.1.f90: New test.\n+\t* testsuite/libgomp.fortran/appendix-a/a10.1.f90: New test.\n+\n+2005-10-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.dg/dg.exp: Only unset lang_* if\n+\tlang_library_path exists.  Use find instead of glob to gather tests.\n+\t* testsuite/libgomp.dg/appendix-a/appendix-a.exp: Removed.\n+\n+2005-10-17  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/appendix-a/a.15.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.16.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.18.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.19.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.2.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.21.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.26.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.29.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.3.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.39.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.4.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/a.5.1.c: New test.\n+\t* testsuite/libgomp.dg/appendix-a/appendix-a.exp: New file.\n+\n+2005-10-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.dg/vla-1.c: New test.\n+\n+\t* testsuite/libgomp.fortran/reference2.f90: New test.\n+\n+\t* testsuite/libgomp.fortran/character2.f90: Remove explicit\n+\tdeclaration of omp_get_thread_num.\n+\t* testsuite/libgomp.fortran/threadprivate1.f90: Likewise.  Add\n+\tuse omp_lib.\n+\n+\t* testsuite/libgomp.fortran/reduction1.f90: New test.\n+\t* testsuite/libgomp.fortran/reduction2.f90: New test.\n+\t* testsuite/libgomp.fortran/reduction3.f90: New test.\n+\t* testsuite/libgomp.fortran/reduction4.f90: New test.\n+\n+2005-10-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.am (libgomp_la_SOURCES): Add bar.c.\n+\t* Makefile.in: Regenerate.\n+\t* barrier.c (GOMP_barrier): Use gomp_barrier_wait.\n+\t* libgomp.h: Include bar.h.\n+\t(struct gomp_barrier): Remove.\n+\t(struct gomp_team): Add barrier.  Replace master_barrier with\n+\tmaster_release.  Replace threads with ordered_release.\n+\t(struct gomp_thread): Replace barrier with release.\n+\t* ordered.c (gomp_ordered_first): Update for ordered_release change.\n+\t(gomp_ordered_last, gomp_ordered_next, gomp_ordered_static_init,\n+\tgomp_ordered_static_next, gomp_ordered_sync): Likewise.\n+\t* single.c (GOMP_single_copy_start): Use gomp_barrier_wait.\n+\t(GOMP_single_copy_end): Likewise.\n+\t* team.c (gomp_threads_dock): New.\n+\t(gomp_barrier_init, gomp_barrier_destroy): Remove.\n+\t(gomp_thread_start): Use gomp_barrier_wait.\n+\t(new_team, free_team): Update for gomp_team changes.\n+\t(gomp_team_start): Use gomp_barrier_wait and gomp_barrier_reinit.\n+\t(gomp_team_end): Use gomp_barrier_wait.\n+\t(initialize_team): Update for gomp_thread changes.\n+\t* work.c (gomp_work_share_end): Use gomp_barrier_wait_start.\n+\t(gomp_work_share_end_nowait): Use atomic ops when available.\n+\t* config/linux/bar.c, config/linux/bar.h: New files.\n+\t* config/posix/bar.c, config/posix/bar.h: New files.\n+\n+2005-10-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* single.c (GOMP_single_copy_end): Don't segfault if team is NULL.\n+\t* testsuite/libgomp.dg/single-2.c: New test.\n+\n+\t* testsuite/libgomp.dg/dg.exp (lang_library_path, lang_test_file,\n+\tlang_link_flags): Unset, so that they aren't inherited from previously\n+\tsourced *.exp.\n+\n+\t* testsuite/libgomp.fortran/threadprivate1.f90: New test.\n+\n+2005-10-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/lib/libgomp-dg.exp: Set blddir at toplevel.\n+\t(libgomp_init): Use lang_test_file, lang_library_path, and\n+\tlang_link_flags, set by the subdirectory files.  Add -fopenmp here.\n+\n+\t* testsuite/libgomp.fortran/fortran.exp (lang_library_path): New.\n+\t(lang_test_file, lang_link_flags): New.\n+\t(DEFAULT_FFLAGS, ALWAYS_CFLAGS, multilibs, blddir): Remove.\n+\n+\t* testsuite/libgomp.c++/c++.exp, testsuite/libgomp.c++/loop-1.C,\n+\ttestsuite/libgomp.c++/loop-2.C, testsuite/libgomp.c++/loop-3.C,\n+\ttestsuite/libgomp.c++/loop-4.C, testsuite/libgomp.c++/nested-1.C,\n+\ttestsuite/libgomp.c++/parallel-1.C,\n+\ttestsuite/libgomp.c++/reduction-1.C,\n+\ttestsuite/libgomp.c++/reduction-2.C,\n+\ttestsuite/libgomp.c++/reduction-3.C,\n+\ttestsuite/libgomp.c++/sections-1.C, testsuite/libgomp.c++/shared-1.C,\n+\ttestsuite/libgomp.c++/shared-2.C, testsuite/libgomp.c++/single-1.C,\n+\ttestsuite/libgomp.c++/single-2.C, testsuite/libgomp.c++/single-3.C:\n+\tNew files, largely cribbed from the C testsuite.\n+\n+2005-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/character1.f90: New test.\n+\t* testsuite/libgomp.fortran/character2.f90: New test.\n+\n+\t* testsuite/libgomp.dg/nested-1.c: New test.\n+\t* testsuite/libgomp.dg/nested-2.c: New test.\n+\t* testsuite/libgomp.fortran/do1.f90: New test.\n+\t* testsuite/libgomp.fortran/do2.f90: New test.\n+\n+\t* testsuite/libgomp.fortran/reference1.f90: New test.\n+\n+2005-10-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.dg/reduction-1.c: New test.\n+\t* testsuite/libgomp.dg/reduction-2.c: New test.\n+\t* testsuite/libgomp.dg/reduction-3.c: New test.\n+\n+2005-10-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.dg/atomic-1.c: New test.\n+\t* testsuite/libgomp.dg/atomic-2.c: New test.\n+\n+2005-10-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* critical.c (atomic_lock): New.\n+\t(initialize_critical): Initialize it.\n+\t(GOMP_atomic_start, GOMP_atomic_end): New.\n+\t* libgomp.map: Export them.\n+\t* libgomp_g.h: Declare them.\n+\n+\t* testsuite/libgomp.dg/atomic-10.c: Move from gcc testsuite.\n+\n+2005-10-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.ac: Move save_CFLAGS hack earlier.  Append -Wall/-Werror\n+\tto XCFLAGS instead of CFLAGS.\n+\n+2005-09-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.ac: Determine whether -pthread or -lpthread is needed.\n+\t* Makefile.am (libgomp_la_LDFLAGS): Remove explicit -lpthread.\n+\t* Makefine.in, configure: Rebuild.\n+\n+2005-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-loop03.c: Fix return code.\n+\t* testsuite/libgomp.dg/omp-single-3.c: New test.\n+\n+2005-09-28  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-single-2.c: New test.\n+\t* testsuite/libgomp.dg/shared-2.c: Fix return code.\n+\n+2005-09-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-loop03.c: Add initial barrier.\n+\t* testsuite/libgomp.dg/omp-parallel-for.c: Specify static schedule.\n+\n+2005-09-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-loop03.c: New test.\n+\n+2005-09-27  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-parallel-for.c: New test.\n+\n+2005-09-27  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-single-1.c: New test.\n+\t* testsuite/libgomp.dg/shared-1.c: Return 0.\n+\tAdd prototype for abort.\n+\t* testsuite/libgomp.dg/shared-2.c: Likewise.\n+\n+2005-09-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/omp_parse3.f90: Fix non-conforming\n+\tconstructs.\n+\n+2005-09-26  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/shared-1.c: New test.\n+\t* testsuite/libgomp.dg/shared-2.c: New test.\n+\n+2005-09-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp_workshare3.c: Mark dg-error.\n+\n+2005-09-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* iter.c (gomp_iter_static_next): Round up when computing number\n+\tof iterations.  Don't bother distributing a remainder equally.\n+\n+\t* testsuite/libgomp.dg/omp-loop01.c (main1): Rename from main.\n+\tDon't call srand.  Zero b before testing.\n+\t(main): New.\n+\n+2005-09-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/omp_atomic1.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_atomic2.f90: New test.\n+\n+2005-09-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/omp_parse1.f90: Add a test for !$omp do\n+\twithout !$omp end do, followed immediately by subroutine end.\n+\n+2005-09-23  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-parallel-if.c: New test.\n+\n+2005-09-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* critical.c (GOMP_critical_name_start): Change argument to void**.\n+\tReuse the pointer space if the mutex fits.\n+\t(GOMP_critical_name_end): Likewise.\n+\t(initialize_critical): Don't define if GOMP_MUTEX_INIT_0.\n+\t* libgomp_g.h (GOMP_critical_name_start): Update decl.\n+\t(GOMP_critical_name_end): Likewise.\n+\t* config/linux/mutex.h (GOMP_MUTEX_INIT_0): New.\n+\t* config/posix/mutex.h (GOMP_MUTEX_INIT_0): New.\n+\n+2005-09-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* critical.c (GOMP_critical_name_start, GOMP_critical_name_end): New.\n+\t(create_lock_lock): New.\n+\t(initialize_critical): Initialize it.\n+\t* libgomp.map (GOMP_critical_name_start, GOMP_critical_name_end): New.\n+\t* libgomp_g.h (GOMP_ordered_start, GOMP_ordered_end): Declare.\n+\n+2005-09-20  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgom.dg/omp-loop01.c: Include stdio.h.\n+\n+2005-09-20  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/omp-loop01.c: New test.\n+\t* testsuite/libgomp.dg/omp-loop02.c: New test.\n+\n+2005-09-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* configure.ac (AC_PROG_FC): Add.\n+\t(USE_FORTRAN): New automake conditional.\n+\t* configure: Rebuilt.\n+\t* Makefile.am (libgomp_la_SOURCES): Add fortran.c.\n+\t(nodist_include_HEADERS): Add omp_lib.h, omp_lib.f90 and libgomp_f.h.\n+\tIf USE_FORTRAN, add also omp_lib.mod and omp_lib_kinds.mod.\n+\tAdd rules to build them.\n+\t* Makefile.in: Rebuilt.\n+\t* mkomp_h.pl: Compute and replace also OMP_LOCK_KIND and\n+\tOMP_NEST_LOCK_KIND.\n+\t* libgomp.map: Add Fortran wrappers.\n+\t* libgomp_f.h.in: New file.\n+\t* omp_lib.h.in: New file.\n+\t* omp_lib.f90.in: New file.\n+\t* fortran.c: New file.\n+\t* testsuite/lib/libgomp-dg.exp: Load a few more .exp files.\n+\tAppend libgfortran directory to LD_LIBRARY_PATH if it exists.\n+\tAdd -Lpath_to_libgfortran and -lgfortran -lgfortranbegin if\n+\tlibgfortran has been built.\n+\t* testsuite/libgomp.fortran/fortran.exp: New file.\n+\t* testsuite/libgomp.fortran/omp_cond1.f: New test.\n+\t* testsuite/libgomp.fortran/omp_cond2.f: New test.\n+\t* testsuite/libgomp.fortran/omp_cond3.F90: New test.\n+\t* testsuite/libgomp.fortran/omp_cond4.F90: New test.\n+\t* testsuite/libgomp.fortran/omp_hello.f: New test.\n+\t* testsuite/libgomp.fortran/omp_orphan.f: New test.\n+\t* testsuite/libgomp.fortran/omp_parse1.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_parse2.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_parse3.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_parse4.f90: New test.\n+\t* testsuite/libgomp.fortran/omp_reduction.f: New test.\n+\t* testsuite/libgomp.fortran/omp_workshare1.f: New test.\n+\t* testsuite/libgomp.fortran/omp_workshare2.f: New test.\n+\n+2005-08-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* loop.c (GOMP_loop_static_start): Provide fallback wrapper\n+\tfunction for when aliases are not usable.\n+\t(GOMP_loop_dynamic_start, GOMP_loop_guided_start,\n+\tGOMP_loop_ordered_static_start, GOMP_loop_ordered_dynamic_start,\n+\tGOMP_loop_ordered_guided_start, GOMP_loop_static_next,\n+\tGOMP_loop_dynamic_next, GOMP_loop_guided_next,\n+\tGOMP_loop_ordered_static_next, GOMP_loop_ordered_dynamic_next,\n+\tGOMP_loop_ordered_guided_next): Likewise.\n+\t* ordered.c (GOMP_ordered_start): Likewise.\n+\n+2005-08-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/dg.exp: Use -O2 for now.\n+\t* testsuite/libgomp.dg/omp_hello.c: Fix return code\n+\t* testsuite/libgomp.dg/omp_matvec.c: Likewise.\n+\t* testsuite/libgomp.dg/omp_orphan.c: Likewise\n+\t* testsuite/libgomp.dg/omp_reduction.c: Likewise\n+\t* testsuite/libgomp.dg/omp_workshare1.c: Likewise\n+\t* testsuite/libgomp.dg/omp_workshare2.c: Likewise\n+\t* testsuite/libgomp.dg/omp_workshare3.c: Likewise\n+\t* testsuite/libgomp.dg/omp_workshare4.c: Likewise\n+\n+2005-07-07  Eric Christopher  <echristo@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.dg/dg.exp: Add -fopenmp to DEFAULT_CFLAGS.\n+\t* testsuite/libgomp.dg/omp_hello.c: Add standard includes, fix\n+\tup code.\n+\t* testsuite/libgomp.dg/omp_matvec.c: Ditto.\n+\t* testsuite/libgomp.dg/omp_orphan.c: Ditto.\n+\t* testsuite/libgomp.dg/omp_reduction.c: Ditto.\n+\t* testsuite/libgomp.dg/omp_workshare1.c: Ditto.\n+\t* testsuite/libgomp.dg/omp_workshare2.c: Ditto.\n+\t* testsuite/libgomp.dg/omp_workshare3.c: Ditto.\n+\t* testsuite/libgomp.dg/omp_workshare4.c: Ditto.\n+\n+2005-06-13  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* TOPLEVEL.patch: Remove.\n+\n+2005-05-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.ac: Test for clock_gettime.\n+\t* config.h.in, configure: Rebuild.\n+\t* config/posix/time.c: Use recommended TIME_WITH_SYS_TIME pattern.\n+\t(omp_get_wtime): Use clock_gettime if available.\n+\t(omp_get_wtick): Use clock_getres if available.\n+\n+2005-05-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/linux/ia64/futex.h: New file.\n+\t* configure.tgt: Use it.\n+\n+\t* team.c (gomp_barrier_init, gomp_barrier_destroy): Mark inline.\n+\n+2005-05-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/linux/powerpc/futex.h: New file.\n+\t* configure.tgt: Use it.\n+\n+\t* config/linux/i486/futex.h: Merge ...\n+\t* config/linux/x86_64/futex.h: ... into ...\n+\t* config/linux/x86/futex.h: ... here.\n+\t* configure.tgt: Update to match.\n+\n+2005-05-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/linux/alpha/futex.h: Conditionally define SYS_futex.\n+\t* config/linux/i486/futex.h: Likewise.\n+\t* config/linux/x86_64/futex.h: Likewise.\n+\n+\t* config/linux/lock.c: New file.\n+\t* config/linux/omp-lock.h: New file.\n+\n+\t* critical.c, env.h: Don't include omp.h\n+\t* config/posix/lock.c: Include libgomp.h instead of omp.h.\n+\t* config/posix/time.c: Likewise.\n+\t* config/posix/omp-lock.h: New file.\n+\t* libgomp.h: Include omp-lock.h and omp.h.\n+\t* Makefile.am (nodist_include_HEADERS): New.\n+\t(omp.h): New rule.\n+\t* configure.ac (PERL): New.\n+\t* mkomp_h.pl: New file.\n+\t* omp.h.in: Rename from omp.h; replace omp_lock_t and omp_nest_lock_t\n+\twith templates.\n+\t* Makefile.in, configure, testsuite/Makefile.in: Rebuild.\n+\n+\t* testsuite/lib/libgomp-dg.exp (libgomp_init): Add include into\n+\tbuild directory.  Re-add -march=i486 hack.\n+\n+\t* testsuite/lib/libgomp-dg.exp (libgomp_compile_flags): Remove.\n+\t(libgomp_link_flags): Remove.\n+\t(libgomp_initialized): Remove.\n+\t(libgomp_init): Don't protect from reinitialization.  Copy code\n+\tfrom libstdc++ for getting the multilib set correctly.\n+\n+2005-05-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/linux/alpha/futex.h: New file.\n+\t* configure.tgt (alpha*-*-linux*): Use it.\n+\n+\t* config/posix/mutex.c: New file.\n+\t* config/posix/sem.c: Use libgomp.h.\n+\n+\t* configure.tgt (x86_64-linux): Also test CC for -m32.\n+\t* config/linux/x86_64/futex.h (futex_wait): Fix r10 usage.\n+\n+\t* testsuite/lib/libgomp-dg.exp (libgomp_link_flags): Add / \n+\tafter $gccpath.\n+\n+\t* Makefile.am (SUBDIRS): New.\n+\t(libgomp_la_LDFLAGS): Add -lpthread.\n+\t* configure.ac (AM_INIT_AUTOMAKE): Enable dependencies.\n+\t* Makefile.in, aclocal.m4, config.h.in, configure: Rebuild.\n+\n+\t* libgomp_g.h: New file.\n+\t* libgomp.h: Split out all public declarations to libgomp_g.h.\n+\tUse pragma GCC visibility instead of ATTRIBUTE_HIDDEN.\n+\t* config/linux/mutex.h: Remove ATTRIBUTE_HIDDEN.\n+\t* config/linux/sem.h: Likewise.\n+\t* config/posix/sem.h: Likewise.\n+\n+\t* Makefile.am (AM_LDFLAGS): New.\n+\t(libgomp_version_script): Split out from ...\n+\t(libgomp_la_LDFLAGS): ... here.\n+\t(libgomp_version_info): New.\n+\t* acinclude.m4 (LIBGOMP_CHECK_TLS): Use LIBGOMP_ENABLE.\n+\t(LIBGOMP_ENABLE): New.\n+\t(LIBGOMP_CHECK_LINKER_FEATURES): New.\n+\t(LIBGOMP_ENABLE_SYMVERS): New.\n+\t* configure.ac (AC_INIT): Version 1.0.\n+\t(enable-version-specific-runtime-libs): Use LIBGOMP_ENABLE.\n+\t(enable-linux-futex): Likewise.  Rename from enable-futex.\n+\t(libtool_VERSION): New.\n+\t(LIBGOMP_ENABLE_SYMVERS): Use it.\n+\t* configure.tgt: Check with_gnu_ld wrt have_tls optimizations.\n+\t* Makefile.in, aclocal.m4, configure: Rebuild.\n+\n+\t* config/linux/mutex.c: Include libgomp.h instead of mutex.h.\n+\t(gomp_mutex_unlock_slow): Fix typo.\n+\t* config/linux/sem.c: Similarly.\n+\t(gomp_sem_post_slow): Fix typo.\n+\t* config/linux/sem.h (gomp_sem_post_slow): Fix typo.\n+\t* config/linux/i486/futex.h: Remove USE_LINUX_SYSENTER code.\n+\t[__PIC__] (sys_futex0): Don't use tmp output in asm.\n+\n+\t* Makefile.am (AM_CFLAGS): Expand with XCFLAGS.\n+\t(libgomp_la_LDFLAGS): Add top_srcdir to path.\n+\t* acinclude.m4: Copy libtool.m4 stuff from libgfortran.\n+\t* configure.ac: Check for getloadavg.  Substitute XCFLAGS and\n+\tXLDFLAGS.  Add XCFLAGS to CFLAGS around LIBGOMP_CHECK_SYNC_BUILTINS.\n+\t* configure.tgt: Set XCFLAGS and XLDFLAGS instead of CFLAGS and\n+\tLDFLAGS.  Pull enable_futex check to top-level.\n+\t* libgomp.h: Fix sem.h and mutex.h includes.  Define ATTRIBUTE_HIDDEN.\n+\t* Makefile.in, aclocal.m4, config.h.in, configure: Regenerate.\n+\n+\tFirst attempt at real configury.\n+\t* Makefile, config.h: Remove file.\n+\t* Makefile.am, Makefile.in: New file.\n+\t* acinclude.m4 aclocal.m4: New file.\n+\t* configure.ac, configure.tgt, configure: New file.\n+\n+\t* config/posix/lock.c: Rename from sys-lock.c.\n+\t* config/posix/mutex.h: Rename from sys-mutex.h.\n+\t* config/posix/sem.c: Rename from sys-sem.c.\n+\t* config/posix/sem.h: Rename from sys-sem.h.\n+\t* config/posix/proc.c: Rename from sys-proc.c.\n+\t* config/posix/time.c: Rename from sys-proc.c.\n+\n+\t* config/linux/mutex.c: New file.\n+\t* config/linux/mutex.h: New file.\n+\t* config/linux/sem.c: New file.\n+\t* config/linux/sem.h: New file.\n+\t* config/linux/i486/futex.h: New file.\n+\t* config/linux/x86_64/futex.h: New file.\n+\n+2005-05-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* iter.c (gomp_iter_dynamic_next, gomp_iter_guided_next): New.\n+\t* libgomp.h: Declare them.\n+\t* loop.c (gomp_loop_dynamic_start, gomp_loop_guided_start,\n+\tgomp_loop_dynamic_next, gomp_loop_guided_next): Use them.\n+\n+2005-05-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* libgomp-1 code drop\n+\n+2005-05-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* iter.c (gomp_iter_static_next): Return tri-state on 0.\n+\t* ordered.c (gomp_ordered_static_next): Remove not_last argument.\n+\t* libgomp.h (struct gomp_team_state): Make static_trip unsigned.\n+\t(gomp_iter_static_next): Update.\n+\t(gomp_ordered_static_next): Update.\n+\t* loop.c (gomp_loop_static_start): Update for gomp_iter_static_next.\n+\t(gomp_loop_ordered_static_start): Likewise.  Exit early for a\n+\ttotally empty range.\n+\t(gomp_loop_ordered_static_next): Refine test for calling\n+\tgomp_ordered_static_next.\n+\t* testsuite/ordered-1.c: Add case for more threads than iterations.\n+\n+\t* iter.c (gomp_iter_runtime_next_locked): Remove.\n+\t* loop.c (gomp_loop_static_start, gomp_loop_dynamic_start,\n+\tgomp_loop_guided_start, gomp_loop_ordered_static_start, \n+\tgomp_loop_ordered_dynamic_start, gomp_loop_ordered_guided_start,\n+\tgomp_loop_static_next, gomp_loop_dynamic_next, gomp_loop_guided_next,\n+\tgomp_loop_ordered_static_next, gomp_loop_ordered_dynamic_next,\n+\tgomp_loop_ordered_guided_next): Downcase name, make static, add\n+\tan external alias with the old name.\n+\t(GOMP_loop_runtime_start, GOMP_loop_ordered_runtime_start,\n+\tGOMP_loop_runtime_next, GOMP_loop_ordered_runtime_next): Use a\n+\tswitch and call one of the above static functions.\n+\t* libgomp.h: Update.\n+\n+\t* work.c (gomp_work_share_start): Lock the mutex for !first too.\n+\t* loop.c (GOMP_loop_static_start, GOMP_loop_dynamic_start,\n+\tGOMP_loop_guided_start, GOMP_loop_runtime_start,\n+\tGOMP_loop_ordered_static_start, GOMP_loop_ordered_dynamic_start,\n+\tGOMP_loop_ordered_guided_start): Update to match.\n+\t* sections.c (GOMP_sections_start): Likewise.\n+\t* single.c (GOMP_single_start, GOMP_single_copy_start): Likewise.\n+\n+\t* ordered.c (gomp_ordered_first, gomp_ordered_last, gomp_ordered_next,\n+\tgomp_ordered_static_init, gomp_ordered_static_next): Rename s/_loop//.\n+\tUse bounds check instead of modulus.\n+\t(gomp_ordered_sync): Split out of GOMP_ordered_start.\n+\t(gomp_ordered_last): Don't sync with ordered_owner here.\n+\t(gomp_ordered_next): Likewise.\n+\t(gomp_ordered_static_loop_next): Likewise.\n+\t* loop.c, libgomp.h: Update to match.\n+\n+\t* libgomp.h (GOMP_barrier): Declare.\n+\n+\t* testsuite/barrier-1.c: New file.\n+\t* testsuite/critical-1.c: New file.\n+\t* testsuite/ordered-2.c: New file.\n+\t* testsuite/ordered-1.c: New file.\n+\t* testsuite/sections-1.c: New file.\n+\t* testsuite/single-1.c: New file.\n+\t* testsuite/Makefile (TESTS): Add them.\n+\n+2005-05-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* libgomp.h (struct gomp_work_share): Add ordered_owner.\n+\t* loop.c (GOMP_loop_static_start): If not the startup thread,\n+\tacquire the mutex to wait for initialization complete.\n+\t(GOMP_loop_ordered_static_start): Likewise.\n+\t(GOMP_loop_ordered_runtime_start): Likewise.\n+\t(GOMP_loop_ordered_static_first): Remove.\n+\t(GOMP_loop_ordered_dynamic_first): Remove.\n+\t(GOMP_loop_ordered_guided_first): Remove.\n+\t(GOMP_loop_ordered_runtime_first): Remove.\n+\t* ordered.c (gomp_ordered_loop_first): Post to own release when\n+\twe're the first thread.\n+\t(gomp_ordered_loop_last): Wait on release if not owner.\n+\t(gomp_ordered_loop_next): Likewise.\n+\t(gomp_ordered_static_loop_init): New.\n+\t(gomp_ordered_static_loop_next): Use ordered_owner.\n+\t(GOMP_ordered_start): Likewise.\n+\t* work.c (gomp_new_work_share): Initialize ordered_owner.\n+\n+2005-05-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile (OPT): New.\n+\t(CFLAGS): Use it.\n+\n+\t* loop.c (GOMP_loop_end, GOMP_loop_end_nowait): New.\n+\t* sections.c (GOMP_sections_end, GOMP_sections_end_nowait): New.\n+\t* libgomp.h, libgomp.map, NOTES: Update to match.\n+\n+\t* team.c (struct gomp_thread_start_data): Remove ts, fn, data.\n+\tAdd initialized and thr members.\n+\t(gomp_thread_start): Pause when initially spawned to wait for\n+\tthe whole team to be created.\n+\t(gomp_team_start): Release team members at the end.\n+\n+\t* testsuite/loop-1.c (N): New.  Use it instead of hardcoded 100.\n+\t(f_foo_1): Use GOMP_loop_end.\n+\t(f_foo_2): Use GOMP_loop_end_nowait.\n+\n+\t* testsuite/loop-2.c: New file.\n+\t* testsuite/Makefile (TESTS): Add it.\n+\n+2005-05-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* iter.c (gomp_iter_static_next): Fix overflow check typo.\n+\t(gomp_iter_dynamic_next_locked): Fix overflow check thinko.\n+\t* team.c (new_team): Initialize oldest_live_gen to 1 if no\n+\tinitial work_share.\n+\n+\t* testsuite/Makefile: New file.\n+\t* testsuite/loop-1.c: New file.\n+\n+2005-05-03  Richard Henderson  <rth@redhat.com>\n+\n+\tInitial implementation and checkin."}, {"sha": "21e4001b4c977bc46ddb2205cae444de01732c8f", "filename": "libgomp/Makefile.am", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,59 @@\n+## Process this file with automake to produce Makefile.in\n+\n+ACLOCAL_AMFLAGS = -I ../config\n+SUBDIRS = testsuite\n+\n+## May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+config_path = @config_path@\n+search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) $(top_srcdir)\n+\n+empty =\n+space = $(empty) $(empty)\n+VPATH = $(subst $(space),:,$(strip $(search_path)))\n+\n+AM_CPPFLAGS = $(addprefix -I, $(search_path))\n+AM_CFLAGS = $(XCFLAGS)\n+AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)\n+\n+toolexeclib_LTLIBRARIES = libgomp.la\n+nodist_toolexeclib_HEADERS = libgomp.spec\n+\n+if LIBGOMP_BUILD_VERSIONED_SHLIB\n+libgomp_version_script = -Wl,--version-script,$(top_srcdir)/libgomp.map\n+else\n+libgomp_version_script =\n+endif\n+libgomp_version_info = -version-info $(libtool_VERSION)\n+libgomp_la_LDFLAGS = $(libgomp_version_info) $(libgomp_version_script)\n+\n+libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n+\tloop.c ordered.c parallel.c sections.c single.c team.c work.c \\\n+\tlock.c mutex.c proc.c sem.c bar.c time.c fortran.c\n+\n+nodist_noinst_HEADERS = libgomp_f.h\n+nodist_include_HEADERS = omp.h omp_lib.h omp_lib.f90\n+if USE_FORTRAN\n+nodist_include_HEADERS += omp_lib.mod omp_lib_kinds.mod\n+endif\n+\n+omp.h: omp.h.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/omp.h.in omp.h\n+omp_lib.h: omp_lib.h.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/omp_lib.h.in \\\n+\tomp_lib.h\n+omp_lib.f90: omp_lib.f90.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/omp_lib.f90.in \\\n+\tomp_lib.f90\n+libgomp_f.h: libgomp_f.h.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/libgomp_f.h.in \\\n+\tlibgomp_f.h\n+omp_lib_kinds.mod: omp_lib.mod\n+\t:\n+omp_lib.mod: omp_lib.f90\n+\t$(FC) $(FCFLAGS) -fsyntax-only omp_lib.f90\n+fortran.lo: libgomp_f.h\n+fortran.o: libgomp_f.h\n+env.lo: libgomp_f.h\n+env.o: libgomp_f.h"}, {"sha": "561aaa008452b411f00850c32ead1c630ac99a9d", "filename": "libgomp/Makefile.in", "status": "added", "additions": 859, "deletions": 0, "changes": 859, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,859 @@\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+\n+SOURCES = $(libgomp_la_SOURCES)\n+\n+srcdir = @srcdir@\n+top_srcdir = @top_srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+top_builddir = .\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+INSTALL = @INSTALL@\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+@USE_FORTRAN_TRUE@am__append_1 = omp_lib.mod omp_lib_kinds.mod\n+DIST_COMMON = $(am__configure_deps) $(srcdir)/../config.guess \\\n+\t$(srcdir)/../config.sub $(srcdir)/../depcomp \\\n+\t$(srcdir)/../install-sh $(srcdir)/../ltmain.sh \\\n+\t$(srcdir)/../missing $(srcdir)/../mkinstalldirs \\\n+\t$(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n+\t$(srcdir)/config.h.in $(srcdir)/libgomp.spec.in \\\n+\t$(top_srcdir)/configure ChangeLog\n+subdir = .\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 $(top_srcdir)/acinclude.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno configure.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = config.h\n+CONFIG_CLEAN_FILES = libgomp.spec\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n+\t\"$(DESTDIR)$(includedir)\" \"$(DESTDIR)$(toolexeclibdir)\"\n+toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libgomp_la_LIBADD =\n+am_libgomp_la_OBJECTS = alloc.lo barrier.lo critical.lo env.lo \\\n+\terror.lo iter.lo loop.lo ordered.lo parallel.lo sections.lo \\\n+\tsingle.lo team.lo work.lo lock.lo mutex.lo proc.lo sem.lo \\\n+\tbar.lo time.lo fortran.lo\n+libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n+DEFAULT_INCLUDES = -I. -I$(srcdir) -I.\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) \\\n+\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n+\t$(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n+\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n+SOURCES = $(libgomp_la_SOURCES)\n+DIST_SOURCES = $(libgomp_la_SOURCES)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n+\thtml-recursive info-recursive install-data-recursive \\\n+\tinstall-exec-recursive install-info-recursive \\\n+\tinstall-recursive installcheck-recursive installdirs-recursive \\\n+\tpdf-recursive ps-recursive uninstall-info-recursive \\\n+\tuninstall-recursive\n+nodist_includeHEADERS_INSTALL = $(INSTALL_HEADER)\n+nodist_toolexeclibHEADERS_INSTALL = $(INSTALL_HEADER)\n+HEADERS = $(nodist_include_HEADERS) $(nodist_noinst_HEADERS) \\\n+\t$(nodist_toolexeclib_HEADERS)\n+ETAGS = etags\n+CTAGS = ctags\n+DIST_SUBDIRS = $(SUBDIRS)\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+distdir = $(PACKAGE)-$(VERSION)\n+top_distdir = $(distdir)\n+am__remove_distdir = \\\n+  { test ! -d $(distdir) \\\n+    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \\\n+         && rm -fr $(distdir); }; }\n+DIST_ARCHIVES = $(distdir).tar.gz\n+GZIP_ENV = --best\n+distuninstallcheck_listfiles = find . -type f -print\n+distcleancheck_listfiles = find . -type f -print\n+VPATH = $(subst $(space),:,$(strip $(search_path)))\n+ACLOCAL = @ACLOCAL@\n+AMDEP_FALSE = @AMDEP_FALSE@\n+AMDEP_TRUE = @AMDEP_TRUE@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FC = @FC@\n+FCFLAGS = @FCFLAGS@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LDFLAGS = @LDFLAGS@\n+LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE = @LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE@\n+LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE = @LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+OBJEXT = @OBJEXT@\n+OPT_LDFLAGS = @OPT_LDFLAGS@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PERL = @PERL@\n+RANLIB = @RANLIB@\n+SECTION_LDFLAGS = @SECTION_LDFLAGS@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+USE_FORTRAN_FALSE = @USE_FORTRAN_FALSE@\n+USE_FORTRAN_TRUE = @USE_FORTRAN_TRUE@\n+VERSION = @VERSION@\n+XCFLAGS = @XCFLAGS@\n+XLDFLAGS = @XLDFLAGS@\n+ac_ct_AR = @ac_ct_AR@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_FC = @ac_ct_FC@\n+ac_ct_RANLIB = @ac_ct_RANLIB@\n+ac_ct_STRIP = @ac_ct_STRIP@\n+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@\n+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+config_path = @config_path@\n+datadir = @datadir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+link_gomp = @link_gomp@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+ACLOCAL_AMFLAGS = -I ../config\n+SUBDIRS = testsuite\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) $(top_srcdir)\n+empty = \n+space = $(empty) $(empty)\n+AM_CPPFLAGS = $(addprefix -I, $(search_path))\n+AM_CFLAGS = $(XCFLAGS)\n+AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)\n+toolexeclib_LTLIBRARIES = libgomp.la\n+nodist_toolexeclib_HEADERS = libgomp.spec\n+@LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE@libgomp_version_script = \n+@LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE@libgomp_version_script = -Wl,--version-script,$(top_srcdir)/libgomp.map\n+libgomp_version_info = -version-info $(libtool_VERSION)\n+libgomp_la_LDFLAGS = $(libgomp_version_info) $(libgomp_version_script)\n+libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n+\tloop.c ordered.c parallel.c sections.c single.c team.c work.c \\\n+\tlock.c mutex.c proc.c sem.c bar.c time.c fortran.c\n+\n+nodist_noinst_HEADERS = libgomp_f.h\n+nodist_include_HEADERS = omp.h omp_lib.h omp_lib.f90 $(am__append_1)\n+all: config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \\\n+\t      cd $(srcdir) && $(AUTOMAKE) --foreign  \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \\\n+\tcd $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign  Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\tcd $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\tcd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+\n+config.h: stamp-h1\n+\t@if test ! -f $@; then \\\n+\t  rm -f stamp-h1; \\\n+\t  $(MAKE) stamp-h1; \\\n+\telse :; fi\n+\n+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n+\t@rm -f stamp-h1\n+\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n+$(srcdir)/config.h.in:  $(am__configure_deps) \n+\tcd $(top_srcdir) && $(AUTOHEADER)\n+\trm -f stamp-h1\n+\ttouch $@\n+\n+distclean-hdr:\n+\t-rm -f config.h stamp-h1\n+libgomp.spec: $(top_builddir)/config.status $(srcdir)/libgomp.spec.in\n+\tcd $(top_builddir) && $(SHELL) ./config.status $@\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(mkdir_p) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    f=$(am__strip_dir) \\\n+\t    echo \" $(LIBTOOL) --mode=install $(toolexeclibLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t    $(LIBTOOL) --mode=install $(toolexeclibLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) \"$$p\" \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\t  else :; fi; \\\n+\tdone\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@set -x; list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  p=$(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$p'\"; \\\n+\t  $(LIBTOOL) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$p\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libgomp.la: $(libgomp_la_OBJECTS) $(libgomp_la_DEPENDENCIES) \n+\t$(LINK) -rpath $(toolexeclibdir) $(libgomp_la_LDFLAGS) $(libgomp_la_OBJECTS) $(libgomp_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bar.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/barrier.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/critical.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/env.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/error.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fortran.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loop.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mutex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sections.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sem.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/single.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/team.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/work.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\tif $(COMPILE) -MT $@ -MD -MP -MF \"$(DEPDIR)/$*.Tpo\" -c -o $@ $<; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/$*.Tpo\" \"$(DEPDIR)/$*.Po\"; else rm -f \"$(DEPDIR)/$*.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\tif $(COMPILE) -MT $@ -MD -MP -MF \"$(DEPDIR)/$*.Tpo\" -c -o $@ `$(CYGPATH_W) '$<'`; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/$*.Tpo\" \"$(DEPDIR)/$*.Po\"; else rm -f \"$(DEPDIR)/$*.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\tif $(LTCOMPILE) -MT $@ -MD -MP -MF \"$(DEPDIR)/$*.Tpo\" -c -o $@ $<; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/$*.Tpo\" \"$(DEPDIR)/$*.Plo\"; else rm -f \"$(DEPDIR)/$*.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+uninstall-info-am:\n+install-nodist_includeHEADERS: $(nodist_include_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(includedir)\" || $(mkdir_p) \"$(DESTDIR)$(includedir)\"\n+\t@list='$(nodist_include_HEADERS)'; for p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(am__strip_dir) \\\n+\t  echo \" $(nodist_includeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(includedir)/$$f'\"; \\\n+\t  $(nodist_includeHEADERS_INSTALL) \"$$d$$p\" \"$(DESTDIR)$(includedir)/$$f\"; \\\n+\tdone\n+\n+uninstall-nodist_includeHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(nodist_include_HEADERS)'; for p in $$list; do \\\n+\t  f=$(am__strip_dir) \\\n+\t  echo \" rm -f '$(DESTDIR)$(includedir)/$$f'\"; \\\n+\t  rm -f \"$(DESTDIR)$(includedir)/$$f\"; \\\n+\tdone\n+install-nodist_toolexeclibHEADERS: $(nodist_toolexeclib_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(mkdir_p) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(nodist_toolexeclib_HEADERS)'; for p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(am__strip_dir) \\\n+\t  echo \" $(nodist_toolexeclibHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(nodist_toolexeclibHEADERS_INSTALL) \"$$d$$p\" \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+uninstall-nodist_toolexeclibHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(nodist_toolexeclib_HEADERS)'; for p in $$list; do \\\n+\t  f=$(am__strip_dir) \\\n+\t  echo \" rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+$(RECURSIVE_TARGETS):\n+\t@failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+mostlyclean-recursive clean-recursive distclean-recursive \\\n+maintainer-clean-recursive:\n+\t@failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\tcase \"$@\" in \\\n+\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n+\t  *) list='$(SUBDIRS)' ;; \\\n+\tesac; \\\n+\trev=''; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = \".\"; then :; else \\\n+\t    rev=\"$$subdir $$rev\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\trev=\"$$rev .\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+ctags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n+\tdone\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '    { files[$$0] = 1; } \\\n+\t       END { for (i in files) print i; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\ttags=; \\\n+\there=`pwd`; \\\n+\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n+\t  include_option=--etags-include; \\\n+\t  empty_fix=.; \\\n+\telse \\\n+\t  include_option=--include; \\\n+\t  empty_fix=; \\\n+\tfi; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test ! -f $$subdir/TAGS || \\\n+\t      tags=\"$$tags $$include_option=$$here/$$subdir/TAGS\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '    { files[$$0] = 1; } \\\n+\t       END { for (i in files) print i; }'`; \\\n+\tif test -z \"$(ETAGS_ARGS)$$tags$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t    $$tags $$unique; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\ttags=; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '    { files[$$0] = 1; } \\\n+\t       END { for (i in files) print i; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$tags$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$tags $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && cd $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) $$here\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t$(am__remove_distdir)\n+\tmkdir $(distdir)\n+\t$(mkdir_p) $(distdir)/. $(distdir)/.. $(distdir)/../config\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's|.|.|g'`; \\\n+\tlist='$(DISTFILES)'; for file in $$list; do \\\n+\t  case $$file in \\\n+\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+\t    $(top_srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$topsrcdirstrip/|$(top_builddir)/|\"`;; \\\n+\t  esac; \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  dir=`echo \"$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t  if test \"$$dir\" != \"$$file\" && test \"$$dir\" != \".\"; then \\\n+\t    dir=\"/$$dir\"; \\\n+\t    $(mkdir_p) \"$(distdir)$$dir\"; \\\n+\t  else \\\n+\t    dir=''; \\\n+\t  fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \\\n+\t    fi; \\\n+\t    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \\\n+\t  else \\\n+\t    test -f $(distdir)/$$file \\\n+\t    || cp -p $$d/$$file $(distdir)/$$file \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\tlist='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test -d \"$(distdir)/$$subdir\" \\\n+\t    || $(mkdir_p) \"$(distdir)/$$subdir\" \\\n+\t    || exit 1; \\\n+\t    distdir=`$(am__cd) $(distdir) && pwd`; \\\n+\t    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \\\n+\t    (cd $$subdir && \\\n+\t      $(MAKE) $(AM_MAKEFLAGS) \\\n+\t        top_distdir=\"$$top_distdir\" \\\n+\t        distdir=\"$$distdir/$$subdir\" \\\n+\t        distdir) \\\n+\t      || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \\; -o \\\n+\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -444 -exec $(SHELL) $(install_sh) -c -m a+r {} {} \\; \\\n+\t|| chmod -R a+r $(distdir)\n+dist-gzip: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+dist-bzip2: distdir\n+\ttardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2\n+\t$(am__remove_distdir)\n+\n+dist-tarZ: distdir\n+\ttardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z\n+\t$(am__remove_distdir)\n+\n+dist-shar: distdir\n+\tshar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz\n+\t$(am__remove_distdir)\n+\n+dist-zip: distdir\n+\t-rm -f $(distdir).zip\n+\tzip -rq $(distdir).zip $(distdir)\n+\t$(am__remove_distdir)\n+\n+dist dist-all: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+# This target untars the dist file and tries a VPATH configuration.  Then\n+# it guarantees that the distribution is self-contained by making another\n+# tarfile.\n+distcheck: dist\n+\tcase '$(DIST_ARCHIVES)' in \\\n+\t*.tar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\\\n+\t*.tar.bz2*) \\\n+\t  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\\\n+\t*.tar.Z*) \\\n+\t  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\\\n+\t*.shar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\\\n+\t*.zip*) \\\n+\t  unzip $(distdir).zip ;;\\\n+\tesac\n+\tchmod -R a-w $(distdir); chmod a+w $(distdir)\n+\tmkdir $(distdir)/_build\n+\tmkdir $(distdir)/_inst\n+\tchmod a-w $(distdir)\n+\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n+\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n+\t  && cd $(distdir)/_build \\\n+\t  && ../configure --srcdir=.. --prefix=\"$$dc_install_base\" \\\n+\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n+\t        distuninstallcheck \\\n+\t  && chmod -R a-w \"$$dc_install_base\" \\\n+\t  && ({ \\\n+\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n+\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n+\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n+\t  && rm -rf \"$$dc_destdir\" \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n+\t  && rm -rf $(DIST_ARCHIVES) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck\n+\t$(am__remove_distdir)\n+\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n+\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n+\t  sed -e '1{h;s/./=/g;p;x;}' -e '$${p;x;}'\n+distuninstallcheck:\n+\t@cd $(distuninstallcheck_dir) \\\n+\t&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \\\n+\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n+\t        if test -n \"$(DESTDIR)\"; then \\\n+\t          echo \"  (check DESTDIR support)\"; \\\n+\t        fi ; \\\n+\t        $(distuninstallcheck_listfiles) ; \\\n+\t        exit 1; } >&2\n+distcleancheck: distclean\n+\t@if test '$(srcdir)' = . ; then \\\n+\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n+\t  exit 1 ; \\\n+\tfi\n+\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n+\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n+\t       $(distcleancheck_listfiles) ; \\\n+\t       exit 1; } >&2\n+check-am: all-am\n+check: check-recursive\n+all-am: Makefile $(LTLIBRARIES) all-multi $(HEADERS) config.h\n+installdirs: installdirs-recursive\n+installdirs-am:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(includedir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(mkdir_p) \"$$dir\"; \\\n+\tdone\n+install: install-recursive\n+install-exec: install-exec-recursive\n+install-data: install-data-recursive\n+uninstall: uninstall-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-recursive\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-multi clean-recursive\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-multi distclean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-tags\n+\n+dvi: dvi-recursive\n+\n+dvi-am:\n+\n+html: html-recursive\n+\n+info: info-recursive\n+\n+info-am:\n+\n+install-data-am: install-nodist_includeHEADERS\n+\n+install-exec-am: install-multi install-nodist_toolexeclibHEADERS \\\n+\tinstall-toolexeclibLTLIBRARIES\n+\n+install-info: install-info-recursive\n+\n+install-man:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-multi mostlyclean-recursive\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-recursive\n+\n+pdf-am:\n+\n+ps: ps-recursive\n+\n+ps-am:\n+\n+uninstall-am: uninstall-info-am uninstall-nodist_includeHEADERS \\\n+\tuninstall-nodist_toolexeclibHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+uninstall-info: uninstall-info-recursive\n+\n+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am all-multi \\\n+\tam--refresh check check-am clean clean-generic clean-libtool \\\n+\tclean-multi clean-recursive clean-toolexeclibLTLIBRARIES ctags \\\n+\tctags-recursive dist dist-all dist-bzip2 dist-gzip dist-shar \\\n+\tdist-tarZ dist-zip distcheck distclean distclean-compile \\\n+\tdistclean-generic distclean-hdr distclean-libtool \\\n+\tdistclean-multi distclean-recursive distclean-tags \\\n+\tdistcleancheck distdir distuninstallcheck dvi dvi-am html \\\n+\thtml-am info info-am install install-am install-data \\\n+\tinstall-data-am install-exec install-exec-am install-info \\\n+\tinstall-info-am install-man install-multi \\\n+\tinstall-nodist_includeHEADERS \\\n+\tinstall-nodist_toolexeclibHEADERS install-strip \\\n+\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n+\tinstalldirs installdirs-am maintainer-clean \\\n+\tmaintainer-clean-generic maintainer-clean-multi \\\n+\tmaintainer-clean-recursive mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool mostlyclean-multi \\\n+\tmostlyclean-recursive pdf pdf-am ps ps-am tags tags-recursive \\\n+\tuninstall uninstall-am uninstall-info-am \\\n+\tuninstall-nodist_includeHEADERS \\\n+\tuninstall-nodist_toolexeclibHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+\n+omp.h: omp.h.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/omp.h.in omp.h\n+omp_lib.h: omp_lib.h.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/omp_lib.h.in \\\n+\tomp_lib.h\n+omp_lib.f90: omp_lib.f90.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/omp_lib.f90.in \\\n+\tomp_lib.f90\n+libgomp_f.h: libgomp_f.h.in mkomp_h.pl\n+\t$(PERL) -w $(srcdir)/mkomp_h.pl \"$(COMPILE)\" $(srcdir)/libgomp_f.h.in \\\n+\tlibgomp_f.h\n+omp_lib_kinds.mod: omp_lib.mod\n+\t:\n+omp_lib.mod: omp_lib.f90\n+\t$(FC) $(FCFLAGS) -fsyntax-only omp_lib.f90\n+fortran.lo: libgomp_f.h\n+fortran.o: libgomp_f.h\n+env.lo: libgomp_f.h\n+env.o: libgomp_f.h\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "753363c49d669434a4d6f81195bc7d146f6a5fb3", "filename": "libgomp/NOTES", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FNOTES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2FNOTES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FNOTES?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,279 @@\n+Notes on the external ABI presented by libgomp.  This ought to get\n+transformed into proper documentation at some point.\n+\n+Implementing MASTER construct\n+\n+\tif (omp_get_thread_num () == 0)\n+\t  block\n+\n+\tAlternately, we generate two copies of the parallel subfunction\n+\tand only include this in the version run by the master thread.\n+\tSurely that's not worthwhile though...\n+\n+Implementing CRITICAL construct\n+\n+\tWithout a specified name,\n+\n+\tvoid GOMP_critical_start (void);\n+\tvoid GOMP_critical_end (void);\n+\n+\tso that we don't get COPY relocations from libgomp to the main\n+\tapplication.\n+\n+\tWith a specified name, use omp_set_lock and omp_unset_lock with\n+\tname being transformed into a variable declared like\n+\n+\t\tomp_lock_t gomp_critical_user_<name>\n+\t\t\t__attribute__((common))\n+\n+\tIdeally the ABI would specify that all zero is a valid unlocked\n+\tstate, and so we wouldn't actually need to initialize this at\n+\tstartup.\n+\n+Implementing ATOMIC construct\n+\n+\tThe target should implement the __sync builtins.\n+\n+\tFailing that we could add\n+\n+\tvoid GOMP_atomic_enter (void)\n+\tvoid GOMP_atomic_exit (void)\n+\n+\twhich reuses the regular lock code, but with yet another lock\n+\tobject private to the library.\n+\n+Implementing FLUSH construct\n+\n+\tExpands to the __sync_synchronize builtin.\n+\n+Implementing BARRIER construct\n+\n+\tvoid GOMP_barrier (void)\n+\n+Implementing THREADPRIVATE construct\n+\n+\tIn _most_ cases we can map this directly to __thread.  Except\n+\tthat OMP allows constructors for C++ objects.  We can either\n+\trefuse to support this (how often is it used?) or we can \n+\timplement something akin to .ctors.\n+\n+\tEven more ideally, this ctor feature is handled by extensions\n+\tto the main pthreads library.  Failing that, we can have a set\n+\tof entry points to register ctor functions to be called.\n+\n+Implementing PRIVATE clause\n+\n+\tIn association with a PARALLEL, or within the lexical extent\n+\tof a PARALLEL block, the variable becomes a local variable in\n+\tthe parallel subfunction.\n+\n+\tIn association with FOR or SECTIONS blocks, create a new\n+\tautomatic variable within the current function.  This preserves\n+\tthe semantic of new variable creation.\n+\n+Implementing FIRSTPRIVATE, LASTPRIVATE, COPYIN, COPYPRIVATE clauses\n+\n+\tSeems simple enough for PARALLEL blocks.  Create a private \n+\tstruct for communicating between parent and subfunction.\n+\tIn the parent, copy in values for scalar and \"small\" structs;\n+\tcopy in addresses for others TREE_ADDRESSABLE types.  In the \n+\tsubfunction, copy the value into the local variable.\n+\n+\tNot clear at all what to do with bare FOR or SECTION blocks.\n+\tThe only thing I can figure is that we do something like\n+\n+\n+\t\t#pragma omp for firstprivate(x) lastprivate(y)\n+\t\tfor (int i = 0; i < n; ++i)\n+\t\t  body;\n+\n+\t\t=>\n+\n+\t\t{\n+\t\t  int x = x, y;\n+\n+\t\t  // for stuff\n+\n+\t\t  if (i == n)\n+\t\t    y = y;\n+\t\t}\n+\n+\twhere the \"x=x\" and \"y=y\" assignments actually have different\n+\tuids for the two variables, i.e. not something you could write\n+\tdirectly in C.  Presumably this only makes sense if the \"outer\"\n+\tx and y are global variables.\n+\n+\tCOPYPRIVATE would work the same way, except the structure \n+\tbroadcast would have to happen via SINGLE machinery instead.\n+\n+Implementing REDUCTION clause\n+\n+\tThe private struct mentioned above should have a pointer to\n+\tan array of the type of the variable, indexed by the thread's\n+\tteam_id.  The thread stores its final value into the array,\n+\tand after the barrier the master thread iterates over the\n+\tarray to collect the values.\n+\n+Implementing PARALLEL construct\n+\n+\t#pragma omp parallel\n+\t{\n+\t  body;\n+\t}\n+\n+\t=>\n+\n+\tvoid subfunction (void *data)\n+\t{\n+\t  use data;\n+\t  body;\n+\t}\n+\n+\tsetup data;\n+\tGOMP_parallel_start (subfunction, &data, num_threads);\n+\tsubfunction (&data);\n+\tGOMP_parallel_end ();\n+\n+  void GOMP_parallel_start (void (*fn)(void *), void *data,\n+\t\t\t    unsigned num_threads)\n+\n+\tThe FN argument is the subfunction to be run in parallel.\n+\n+\tThe DATA argument is a pointer to a structure used to \n+\tcommunicate data in and out of the subfunction, as discussed\n+\tabove wrt FIRSTPRIVATE et al.\n+\n+\tThe NUM_THREADS argument is 1 if an IF clause is present\n+\tand false, or the value of the NUM_THREADS clause, if\n+\tpresent, or 0.\n+\n+\tThe function needs to create the appropriate number of\n+\tthreads and/or launch them from the dock.  It needs to\n+\tcreate the team structure and assign team ids.\n+\n+  void GOMP_parallel_end (void)\n+\n+\tTears down the team and return us to the previous\n+\tomp_in_parallel() state.\n+\n+Implementing FOR construct\n+\n+\t#pragma omp parallel for\n+\tfor (i = lb; i <= ub; i++)\n+\t  body;\n+\n+\t=>\n+\n+\tvoid subfunction (void *data)\n+\t{\n+\t  long _s0, _e0;\n+\t  while (GOMP_loop_static_next (&_s0, &_e0))\n+\t    {\n+\t      long _e1 = _e0, i;\n+\t      for (i = _s0; i < _e1; i++)\n+\t\tbody;\n+\t    }\n+\t  GOMP_loop_end_nowait ();\n+\t}\n+\n+\tGOMP_parallel_loop_static (subfunction, NULL, 0, lb, ub+1, 1, 0);\n+\tsubfunction (NULL);\n+\tGOMP_parallel_end ();\n+\n+\t#pragma omp for schedule(runtime)\n+\tfor (i = 0; i < n; i++)\n+\t  body;\n+\n+\t=>\n+\n+\t{\n+\t  long i, _s0, _e0;\n+\t  if (GOMP_loop_runtime_start (0, n, 1, &_s0, &_e0))\n+\t    do {\n+\t      long _e1 = _e0;\n+\t      for (i = _s0, i < _e0; i++)\n+\t        body;\n+\t    } while (GOMP_loop_runtime_next (&_s0, _&e0));\n+\t  GOMP_loop_end ();\n+\t}\n+\n+\tNote that while it looks like there is trickyness to propagating\n+\ta non-constant STEP, there isn't really.  We're explicitly allowed\n+\tto evaluate it as many times as we want, and any variables involved\n+\tshould automatically be handled as PRIVATE or SHARED like any other\n+\tvariables.  So the expression should remain evaluable in the \n+\tsubfunction.  We can also pull it into a local variable if we like,\n+\tbut since its supposed to remain unchanged, we can also not if we like.\n+\n+\tIf we have SCHEDULE(STATIC), and no ORDERED, then we ought to be\n+\table to get away with no work-sharing context at all, since we can\n+\tsimply perform the arithmetic directly in each thread to divide up\n+\tthe iterations.  Which would mean that we wouldn't need to call any\n+\tof these routines.\n+\n+\tThere are separate routines for handling loops with an ORDERED\n+\tclause.  Bookkeeping for that is non-trivial...\n+\n+Implementing ORDERED construct\n+\n+\tvoid GOMP_ordered_start (void)\n+\tvoid GOMP_ordered_end (void)\n+\n+Implementing SECTIONS construct\n+\n+\t#pragma omp sections\n+\t{\n+\t  #pragma omp section\n+\t  stmt1;\n+\t  #pragma omp section\n+\t  stmt2;\n+\t  #pragma omp section\n+\t  stmt3;\n+\t}\n+\n+\t=>\n+\t\n+\tfor (i = GOMP_sections_start (3); i != 0; i = GOMP_sections_next ())\n+\t  switch (i)\n+\t    {\n+\t    case 1:\n+\t      stmt1;\n+\t      break;\n+\t    case 2:\n+\t      stmt2;\n+\t      break;\n+\t    case 3:\n+\t      stmt3;\n+\t      break;\n+\t    }\n+\tGOMP_barrier ();\n+\n+Implementing SINGLE construct\n+\n+\t#pragma omp single\n+\t{\n+\t  body;\n+\t}\n+\n+\t=>\n+\n+\tif (GOMP_single_start ())\n+\t  body;\n+\tGOMP_barrier ();\n+\n+\n+\t#pragma omp single copyprivate(x)\n+\tbody;\n+\n+\t=>\n+\n+\tdatap = GOMP_single_copy_start ();\n+\tif (datap == NULL)\n+\t  {\n+\t    body;\n+\t    data.x = x;\n+\t    GOMP_single_copy_end (&data);\n+\t  }\n+\telse\n+\t  x = datap->x;\n+\tGOMP_barrier ();"}, {"sha": "b66cc9fcce29ee91033099ba4a196ece954b53be", "filename": "libgomp/acinclude.m4", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Facinclude.m4?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,318 @@\n+dnl Check whether the target supports TLS.\n+AC_DEFUN([LIBGOMP_CHECK_TLS], [\n+  LIBGOMP_ENABLE(tls, yes, [Use thread-local storage])\n+  AC_CACHE_CHECK([whether the target supports thread-local storage],\n+\t\t have_tls, [\n+    AC_TRY_COMPILE([__thread int foo;],\n+\t\t   [], have_tls=$enable_tls, have_tls=no)])\n+  if test $have_tls = yes; then\n+    AC_DEFINE(HAVE_TLS, 1,\n+\t      [Define to 1 if the target supports thread-local storage.])\n+  fi])\n+\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from libgfortran.\n+\n+dnl Check whether the target supports __sync_*_compare_and_swap.\n+AC_DEFUN([LIBGOMP_CHECK_SYNC_BUILTINS], [\n+  AC_CACHE_CHECK([whether the target supports __sync_*_compare_and_swap],\n+\t\t have_sync_builtins, [\n+  AC_TRY_LINK([], [int foo, bar; bar = __sync_val_compare_and_swap(&foo, 0, 1);],\n+\t      have_sync_builtins=yes, have_sync_builtins=no)])\n+  if test $have_sync_builtins = yes; then\n+    AC_DEFINE(HAVE_SYNC_BUILTINS, 1,\n+\t      [Define to 1 if the target supports __sync_*_compare_and_swap])\n+  fi])\n+\n+dnl Check whether the target supports hidden visibility.\n+AC_DEFUN([LIBGOMP_CHECK_ATTRIBUTE_VISIBILITY], [\n+  AC_CACHE_CHECK([whether the target supports hidden visibility],\n+\t\t have_attribute_visibility, [\n+  save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror\"\n+  AC_TRY_COMPILE([void __attribute__((visibility(\"hidden\"))) foo(void) { }],\n+\t\t [], have_attribute_visibility=yes,\n+\t\t have_attribute_visibility=no)\n+  CFLAGS=\"$save_CFLAGS\"])\n+  if test $have_attribute_visibility = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_VISIBILITY, 1,\n+      [Define to 1 if the target supports __attribute__((visibility(...))).])\n+  fi])\n+\n+dnl Check whether the target supports dllexport\n+AC_DEFUN([LIBGOMP_CHECK_ATTRIBUTE_DLLEXPORT], [\n+  AC_CACHE_CHECK([whether the target supports dllexport],\n+\t\t have_attribute_dllexport, [\n+  save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror\"\n+  AC_TRY_COMPILE([void __attribute__((dllexport)) foo(void) { }],\n+\t\t [], have_attribute_dllexport=yes,\n+\t\t have_attribute_dllexport=no)\n+  CFLAGS=\"$save_CFLAGS\"])\n+  if test $have_attribute_dllexport = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_DLLEXPORT, 1,\n+      [Define to 1 if the target supports __attribute__((dllexport)).])\n+  fi])\n+\n+dnl Check whether the target supports symbol aliases.\n+AC_DEFUN([LIBGOMP_CHECK_ATTRIBUTE_ALIAS], [\n+  AC_CACHE_CHECK([whether the target supports symbol aliases],\n+\t\t have_attribute_alias, [\n+  AC_TRY_LINK([\n+#define ULP\tSTR1(__USER_LABEL_PREFIX__)\n+#define STR1(x)\tSTR2(x)\n+#define STR2(x)\t#x\n+void foo(void) { }\n+extern void bar(void) __attribute__((alias(ULP \"foo\")));],\n+    [bar();], have_attribute_alias=yes, have_attribute_alias=no)])\n+  if test $have_attribute_alias = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_ALIAS, 1,\n+      [Define to 1 if the target supports __attribute__((alias(...))).])\n+  fi])\n+\n+sinclude(../libtool.m4)\n+dnl The lines below arrange for aclocal not to bring an installed\n+dnl libtool.m4 into aclocal.m4, while still arranging for automake to\n+dnl add a definition of LIBTOOL to Makefile.in.\n+ifelse(,,,[AC_SUBST(LIBTOOL)\n+AC_DEFUN([AM_PROG_LIBTOOL])\n+AC_DEFUN([AC_LIBTOOL_DLOPEN])\n+AC_DEFUN([AC_PROG_LD])\n+])\n+\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from libstdc++-v3.\n+\n+dnl\n+dnl LIBGOMP_ENABLE\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING)\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, permit a|b|c)\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, SHELL-CODE-HANDLER)\n+dnl\n+dnl See docs/html/17_intro/configury.html#enable for documentation.\n+dnl\n+m4_define([LIBGOMP_ENABLE],[dnl\n+m4_define([_g_switch],[--enable-$1])dnl\n+m4_define([_g_help],[AC_HELP_STRING(_g_switch$3,[$4 @<:@default=$2@:>@])])dnl\n+ AC_ARG_ENABLE($1,_g_help,\n+  m4_bmatch([$5],\n+   [^permit ],\n+     [[\n+      case \"$enableval\" in\n+       m4_bpatsubst([$5],[permit ])) ;;\n+       *) AC_MSG_ERROR(Unknown argument to enable/disable $1) ;;\n+          dnl Idea for future:  generate a URL pointing to\n+          dnl \"onlinedocs/configopts.html#whatever\"\n+      esac\n+     ]],\n+   [^$],\n+     [[\n+      case \"$enableval\" in\n+       yes|no) ;;\n+       *) AC_MSG_ERROR(Argument to enable/disable $1 must be yes or no) ;;\n+      esac\n+     ]],\n+   [[$5]]),\n+  [enable_]m4_bpatsubst([$1],-,_)[=][$2])\n+m4_undefine([_g_switch])dnl\n+m4_undefine([_g_help])dnl\n+])\n+\n+\n+dnl\n+dnl If GNU ld is in use, check to see if tricky linker opts can be used.  If\n+dnl the native linker is in use, all variables will be defined to something\n+dnl safe (like an empty string).\n+dnl\n+dnl Defines:\n+dnl  SECTION_LDFLAGS='-Wl,--gc-sections' if possible\n+dnl  OPT_LDFLAGS='-Wl,-O1' if possible\n+dnl  LD (as a side effect of testing)\n+dnl Sets:\n+dnl  with_gnu_ld\n+dnl  libgomp_gnu_ld_version (possibly)\n+dnl\n+dnl The last will be a single integer, e.g., version 1.23.45.0.67.89 will\n+dnl set libgomp_gnu_ld_version to 12345.  Zeros cause problems.\n+dnl\n+AC_DEFUN([LIBGOMP_CHECK_LINKER_FEATURES], [\n+  # If we're not using GNU ld, then there's no point in even trying these\n+  # tests.  Check for that first.  We should have already tested for gld\n+  # by now (in libtool), but require it now just to be safe...\n+  test -z \"$SECTION_LDFLAGS\" && SECTION_LDFLAGS=''\n+  test -z \"$OPT_LDFLAGS\" && OPT_LDFLAGS=''\n+  AC_REQUIRE([AC_PROG_LD])\n+  AC_REQUIRE([AC_PROG_AWK])\n+\n+  # The name set by libtool depends on the version of libtool.  Shame on us\n+  # for depending on an impl detail, but c'est la vie.  Older versions used\n+  # ac_cv_prog_gnu_ld, but now it's lt_cv_prog_gnu_ld, and is copied back on\n+  # top of with_gnu_ld (which is also set by --with-gnu-ld, so that actually\n+  # makes sense).  We'll test with_gnu_ld everywhere else, so if that isn't\n+  # set (hence we're using an older libtool), then set it.\n+  if test x${with_gnu_ld+set} != xset; then\n+    if test x${ac_cv_prog_gnu_ld+set} != xset; then\n+      # We got through \"ac_require(ac_prog_ld)\" and still not set?  Huh?\n+      with_gnu_ld=no\n+    else\n+      with_gnu_ld=$ac_cv_prog_gnu_ld\n+    fi\n+  fi\n+\n+  # Start by getting the version number.  I think the libtool test already\n+  # does some of this, but throws away the result.\n+  changequote(,)\n+  ldver=`$LD --version 2>/dev/null | head -1 | \\\n+         sed -e 's/GNU ld version \\([0-9.][0-9.]*\\).*/\\1/'`\n+  changequote([,])\n+  libgomp_gnu_ld_version=`echo $ldver | \\\n+         $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`\n+\n+  # Set --gc-sections.\n+  if test \"$with_gnu_ld\" = \"notbroken\"; then\n+    # GNU ld it is!  Joy and bunny rabbits!\n+\n+    # All these tests are for C++; save the language and the compiler flags.\n+    # Need to do this so that g++ won't try to link in libstdc++\n+    ac_test_CFLAGS=\"${CFLAGS+set}\"\n+    ac_save_CFLAGS=\"$CFLAGS\"\n+    CFLAGS='-x c++  -Wl,--gc-sections'\n+\n+    # Check for -Wl,--gc-sections\n+    # XXX This test is broken at the moment, as symbols required for linking\n+    # are now in libsupc++ (not built yet).  In addition, this test has\n+    # cored on solaris in the past.  In addition, --gc-sections doesn't\n+    # really work at the moment (keeps on discarding used sections, first\n+    # .eh_frame and now some of the glibc sections for iconv).\n+    # Bzzzzt.  Thanks for playing, maybe next time.\n+    AC_MSG_CHECKING([for ld that supports -Wl,--gc-sections])\n+    AC_TRY_RUN([\n+     int main(void)\n+     {\n+       try { throw 1; }\n+       catch (...) { };\n+       return 0;\n+     }\n+    ], [ac_sectionLDflags=yes],[ac_sectionLDflags=no], [ac_sectionLDflags=yes])\n+    if test \"$ac_test_CFLAGS\" = set; then\n+      CFLAGS=\"$ac_save_CFLAGS\"\n+    else\n+      # this is the suspicious part\n+      CFLAGS=''\n+    fi\n+    if test \"$ac_sectionLDflags\" = \"yes\"; then\n+      SECTION_LDFLAGS=\"-Wl,--gc-sections $SECTION_LDFLAGS\"\n+    fi\n+    AC_MSG_RESULT($ac_sectionLDflags)\n+  fi\n+\n+  # Set linker optimization flags.\n+  if test x\"$with_gnu_ld\" = x\"yes\"; then\n+    OPT_LDFLAGS=\"-Wl,-O1 $OPT_LDFLAGS\"\n+  fi\n+\n+  AC_SUBST(SECTION_LDFLAGS)\n+  AC_SUBST(OPT_LDFLAGS)\n+])\n+\n+\n+dnl\n+dnl Add version tags to symbols in shared library (or not), additionally\n+dnl marking other symbols as private/local (or not).\n+dnl\n+dnl --enable-symvers=style adds a version script to the linker call when\n+dnl       creating the shared library.  The choice of version script is\n+dnl       controlled by 'style'.\n+dnl --disable-symvers does not.\n+dnl  +  Usage:  LIBGOMP_ENABLE_SYMVERS[(DEFAULT)]\n+dnl       Where DEFAULT is either 'yes' or 'no'.  Passing `yes' tries to\n+dnl       choose a default style based on linker characteristics.  Passing\n+dnl       'no' disables versioning.\n+dnl\n+AC_DEFUN([LIBGOMP_ENABLE_SYMVERS], [\n+\n+LIBGOMP_ENABLE(symvers,yes,[=STYLE],\n+  [enables symbol versioning of the shared library],\n+  [permit yes|no|gnu])\n+\n+# If we never went through the LIBGOMP_CHECK_LINKER_FEATURES macro, then we\n+# don't know enough about $LD to do tricks...\n+AC_REQUIRE([LIBGOMP_CHECK_LINKER_FEATURES])\n+# FIXME  The following test is too strict, in theory.\n+if test $enable_shared = no ||\n+        test \"x$LD\" = x ||\n+        test x$libgomp_gnu_ld_version = x; then\n+  enable_symvers=no\n+fi\n+\n+# Check to see if libgcc_s exists, indicating that shared libgcc is possible.\n+if test $enable_symvers != no; then\n+  AC_MSG_CHECKING([for shared libgcc])\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=' -lgcc_s'\n+  AC_TRY_LINK(, [return 0;], libgomp_shared_libgcc=yes, libgomp_shared_libgcc=no)\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+  if test $libgomp_shared_libgcc = no; then\n+    cat > conftest.c <<EOF\n+int main (void) { return 0; }\n+EOF\n+changequote(,)dnl\n+    libgomp_libgcc_s_suffix=`${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \\\n+\t\t\t     -shared -shared-libgcc -o conftest.so \\\n+\t\t\t     conftest.c -v 2>&1 >/dev/null \\\n+\t\t\t     | sed -n 's/^.* -lgcc_s\\([^ ]*\\) .*$/\\1/p'`\n+changequote([,])dnl\n+    rm -f conftest.c conftest.so\n+    if test x${libgomp_libgcc_s_suffix+set} = xset; then\n+      CFLAGS=\" -lgcc_s$libgomp_libgcc_s_suffix\"\n+      AC_TRY_LINK(, [return 0;], libgomp_shared_libgcc=yes)\n+      CFLAGS=\"$ac_save_CFLAGS\"\n+    fi\n+  fi\n+  AC_MSG_RESULT($libgomp_shared_libgcc)\n+fi\n+\n+# For GNU ld, we need at least this version.  The format is described in\n+# LIBGOMP_CHECK_LINKER_FEATURES above.\n+libgomp_min_gnu_ld_version=21400\n+# XXXXXXXXXXX libgomp_gnu_ld_version=21390\n+\n+# Check to see if unspecified \"yes\" value can win, given results above.\n+# Change \"yes\" into either \"no\" or a style name.\n+if test $enable_symvers = yes; then\n+  if test $with_gnu_ld = yes &&\n+     test $libgomp_shared_libgcc = yes;\n+  then\n+    if test $libgomp_gnu_ld_version -ge $libgomp_min_gnu_ld_version ; then\n+      enable_symvers=gnu\n+    else\n+      # The right tools, the right setup, but too old.  Fallbacks?\n+      AC_MSG_WARN(=== Linker version $libgomp_gnu_ld_version is too old for)\n+      AC_MSG_WARN(=== full symbol versioning support in this release of GCC.)\n+      AC_MSG_WARN(=== You would need to upgrade your binutils to version)\n+      AC_MSG_WARN(=== $libgomp_min_gnu_ld_version or later and rebuild GCC.)\n+      if test $libgomp_gnu_ld_version -ge 21200 ; then\n+        # Globbing fix is present, proper block support is not.\n+        dnl AC_MSG_WARN([=== Dude, you are soooo close.  Maybe we can fake it.])\n+        dnl enable_symvers=???\n+        AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+        enable_symvers=no\n+      else\n+        # 2.11 or older.\n+        AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+        enable_symvers=no\n+      fi\n+    fi\n+  else\n+    # just fail for now\n+    AC_MSG_WARN([=== You have requested some kind of symbol versioning, but])\n+    AC_MSG_WARN([=== either you are not using a supported linker, or you are])\n+    AC_MSG_WARN([=== not building a shared libgcc_s (which is required).])\n+    AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+    enable_symvers=no\n+  fi\n+fi\n+\n+AM_CONDITIONAL(LIBGOMP_BUILD_VERSIONED_SHLIB, test $enable_symvers != no)\n+AC_MSG_NOTICE(versioning on shared library symbols is $enable_symvers)\n+])"}, {"sha": "696001cbb46c546ecd1fa05d803b96515dba1262", "filename": "libgomp/aclocal.m4", "status": "added", "additions": 890, "deletions": 0, "changes": 890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Faclocal.m4?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,890 @@\n+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version=\"1.9\"])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION so it can be traced.\n+# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+\t [AM_AUTOMAKE_VERSION([1.9.5])])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 7\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])\n+AC_SUBST([$1_FALSE])\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 8\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    case $depmode in\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    none) break ;;\n+    esac\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 3\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[for mf in $CONFIG_FILES; do\n+  # Strip MF so we end up with the name of the file.\n+  mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+  # Check whether this is an Automake generated Makefile or not.\n+  # We used to match only the files named `Makefile.in', but\n+  # some people rename them; so instead we look at the file content.\n+  # Grep'ing the first line is not enough: some people post-process\n+  # each Makefile.in and add a new line on top of each file to say so.\n+  # So let's grep whole file.\n+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then\n+    dirpart=`AS_DIRNAME(\"$mf\")`\n+  else\n+    continue\n+  fi\n+  # Extract the definition of DEPDIR, am__include, and am__quote\n+  # from the Makefile without running `make'.\n+  DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+  test -z \"$DEPDIR\" && continue\n+  am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+  test -z \"am__include\" && continue\n+  am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+  # When using ansi2knr, U may be empty or an underscore; expand it\n+  U=`sed -n 's/^U = //p' < \"$mf\"`\n+  # Find all dependency output files, they are included files with\n+  # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+  # simplest approach to changing $(DEPDIR) to its actual value in the\n+  # expansion.\n+  for file in `sed -n \"\n+    s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+       sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+    # Make sure the directory exists.\n+    test -f \"$dirpart/$file\" && continue\n+    fdir=`AS_DIRNAME([\"$file\"])`\n+    AS_MKDIR_P([$dirpart/$fdir])\n+    # echo \"creating $dirpart/$file\"\n+    echo '# dummy' > \"$dirpart/$file\"\n+  done\n+done\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 12\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.58])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+# test to see if srcdir already configured\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\" &&\n+   test -f $srcdir/config.status; then\n+  AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AM_PROG_INSTALL_SH\n+AM_PROG_INSTALL_STRIP\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t      \t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+                  [_AM_DEPENDENCIES(CC)],\n+                  [define([AC_PROG_CC],\n+                          defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+                  [_AM_DEPENDENCIES(CXX)],\n+                  [define([AC_PROG_CXX],\n+                          defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+])\n+])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $1 | $1:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $1\" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+install_sh=${install_sh-\"$am_aux_dir/install-sh\"}\n+AC_SUBST(install_sh)])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 3\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo done\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# We grep out `Entering directory' and `Leaving directory'\n+# messages which can occur if `w' ends up in MAKEFLAGS.\n+# In particular we don't look at `^make:' because GNU make might\n+# be invoked under some other name (usually \"gmake\"), in which\n+# case it prints its new name instead of `make'.\n+if test \"`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`\" = \"done\"; then\n+   am__include=include\n+   am__quote=\n+   _am_result=GNU\n+fi\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   if test \"`$am_make -s -f confmf 2> /dev/null`\" = \"done\"; then\n+      am__include=.include\n+      am__quote=\"\\\"\"\n+      _am_result=BSD\n+   fi\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+test x\"${MISSING+set}\" = xset || MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.\n+#\n+# Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories\n+# created by `make install' are always world readable, even if the\n+# installer happens to have an overly restrictive umask (e.g. 077).\n+# This was a mistake.  There are at least two reasons why we must not\n+# use `-m 0755':\n+#   - it causes special bits like SGID to be ignored,\n+#   - it may be too restrictive (some setups expect 775 directories).\n+#\n+# Do not use -m 0755 and let people choose whatever they expect by\n+# setting umask.\n+#\n+# We cannot accept any implementation of `mkdir' that recognizes `-p'.\n+# Some implementations (such as Solaris 8's) are not thread-safe: if a\n+# parallel make tries to run `mkdir -p a/b' and `mkdir -p a/c'\n+# concurrently, both version can detect that a/ is missing, but only\n+# one can create it and the other will error out.  Consequently we\n+# restrict ourselves to GNU make (using the --version option ensures\n+# this.)\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then\n+  # We used to keeping the `.' as first argument, in order to\n+  # allow $(mkdir_p) to be used without argument.  As in\n+  #   $(mkdir_p) $(somedir)\n+  # where $(somedir) is conditionally defined.  However this is wrong\n+  # for two reasons:\n+  #  1. if the package is installed by a user who cannot write `.'\n+  #     make install will fail,\n+  #  2. the above comment should most certainly read\n+  #     $(mkdir_p) $(DESTDIR)$(somedir)\n+  #     so it does not work when $(somedir) is undefined and\n+  #     $(DESTDIR) is not.\n+  #  To support the latter case, we have to write\n+  #     test -z \"$(somedir)\" || $(mkdir_p) $(DESTDIR)$(somedir),\n+  #  so the `.' trick is pointless.\n+  mkdir_p='mkdir -p --'\n+else\n+  # On NextStep and OpenStep, the `mkdir' command does not\n+  # recognize any option.  It will interpret all options as\n+  # directories to create, and then abort because `.' already\n+  # exists.\n+  for d in ./-p ./--version;\n+  do\n+    test -d $d && rmdir $d\n+  done\n+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.\n+  if test -f \"$ac_aux_dir/mkinstalldirs\"; then\n+    mkdir_p='$(mkinstalldirs)'\n+  else\n+    mkdir_p='$(install_sh) -d'\n+  fi\n+fi\n+AC_SUBST([mkdir_p])])\n+\n+# Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_ENABLE_MULTILIB([MAKEFILE], [REL-TO-TOP-SRCDIR])\n+# ---------------------------------------------------\n+# Add --enable-multilib to configure.\n+AC_DEFUN([AM_ENABLE_MULTILIB],\n+[# Default to --enable-multilib\n+AC_ARG_ENABLE(multilib,\n+[  --enable-multilib       build many library versions (default)],\n+[case \"$enableval\" in\n+  yes) multilib=yes ;;\n+  no)  multilib=no ;;\n+  *)   AC_MSG_ERROR([bad value $enableval for multilib option]) ;;\n+ esac],\n+\t      [multilib=yes])\n+\n+# We may get other options which we leave undocumented:\n+# --with-target-subdir, --with-multisrctop, --with-multisubdir\n+# See config-ml.in if you want the gory details.\n+\n+if test \"$srcdir\" = \".\"; then\n+  if test \"$with_target_subdir\" != \".\"; then\n+    multi_basedir=\"$srcdir/$with_multisrctop../$2\"\n+  else\n+    multi_basedir=\"$srcdir/$with_multisrctop$2\"\n+  fi\n+else\n+  multi_basedir=\"$srcdir/$2\"\n+fi\n+AC_SUBST(multi_basedir)\n+\n+AC_OUTPUT_COMMANDS([\n+# Only add multilib support code if we just rebuilt the top-level\n+# Makefile.\n+case \" $CONFIG_FILES \" in\n+ *\" ]m4_default([$1],Makefile)[ \"*)\n+   ac_file=]m4_default([$1],Makefile)[ . ${multi_basedir}/config-ml.in\n+   ;;\n+esac],\n+\t\t   [\n+srcdir=\"$srcdir\"\n+host=\"$host\"\n+target=\"$target\"\n+with_multisubdir=\"$with_multisubdir\"\n+with_multisrctop=\"$with_multisrctop\"\n+with_target_subdir=\"$with_target_subdir\"\n+ac_configure_args=\"${multilib_arg} ${ac_configure_args}\"\n+multi_basedir=\"$multi_basedir\"\n+CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n+CC=\"$CC\"])])dnl\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 3\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[AC_FOREACH([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t $srcdir/configure conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\${SHELL} \\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([acinclude.m4])"}, {"sha": "e3b6b42e64d761cbd398ef2338619f11d0409fee", "filename": "libgomp/alloc.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Falloc.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,61 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains wrappers for the system allocation routines.  Most\n+   places in the OpenMP API do not make any provision for failure, so in\n+   general we cannot allow memory allocation to fail.  */\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+\n+\n+void *\n+gomp_malloc (size_t size)\n+{\n+  void *ret = malloc (size);\n+  if (ret == NULL)\n+    gomp_fatal (\"Out of memory allocating %lu bytes\", (unsigned long) size);\n+  return ret;\n+}\n+\n+void *\n+gomp_malloc_cleared (size_t size)\n+{\n+  void *ret = calloc (1, size);\n+  if (ret == NULL)\n+    gomp_fatal (\"Out of memory allocating %lu bytes\", (unsigned long) size);\n+  return ret;\n+}\n+\n+void *\n+gomp_realloc (void *old, size_t size)\n+{\n+  void *ret = realloc (old, size);\n+  if (ret == NULL)\n+    gomp_fatal (\"Out of memory allocating %lu bytes\", (unsigned long) size);\n+  return ret;\n+}"}, {"sha": "bcad683af5e86f4a8e7c12732198ae462f4ae448", "filename": "libgomp/barrier.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fbarrier.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fbarrier.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fbarrier.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file handles the BARRIER construct.  */\n+\n+#include \"libgomp.h\"\n+\n+\n+void\n+GOMP_barrier (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+\n+  /* It is legal to have orphaned barriers.  */\n+  if (team == NULL)\n+    return;\n+\n+  gomp_barrier_wait (&team->barrier);\n+}"}, {"sha": "a24e14867c74bebec6c215c35865d8c3185423c2", "filename": "libgomp/config.h.in", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,82 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if the target supports __attribute__((alias(...))). */\n+#undef HAVE_ATTRIBUTE_ALIAS\n+\n+/* Define to 1 if the target supports __attribute__((dllexport)). */\n+#undef HAVE_ATTRIBUTE_DLLEXPORT\n+\n+/* Define to 1 if the target supports __attribute__((visibility(...))). */\n+#undef HAVE_ATTRIBUTE_VISIBILITY\n+\n+/* Define to 1 if you have the `clock_gettime' function. */\n+#undef HAVE_CLOCK_GETTIME\n+\n+/* Define to 1 if you have the `getloadavg' function. */\n+#undef HAVE_GETLOADAVG\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the <semaphore.h> header file. */\n+#undef HAVE_SEMAPHORE_H\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if the target supports __sync_*_compare_and_swap */\n+#undef HAVE_SYNC_BUILTINS\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#undef HAVE_SYS_TIME_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if the target supports thread-local storage. */\n+#undef HAVE_TLS\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#undef TIME_WITH_SYS_TIME\n+\n+/* Version number of package */\n+#undef VERSION"}, {"sha": "98681a8526ec7f3621f6e3e53bdc44efd4f3996a", "filename": "libgomp/config/linux/alpha/futex.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Falpha%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Falpha%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Falpha%2Ffutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,76 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* Provide target-specific access to the futex system call.  */\n+\n+#ifndef SYS_futex\n+#define SYS_futex               394\n+#endif\n+#define FUTEX_WAIT              0\n+#define FUTEX_WAKE              1\n+\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  register long sc_0 __asm__(\"$0\");\n+  register long sc_16 __asm__(\"$16\");\n+  register long sc_17 __asm__(\"$17\");\n+  register long sc_18 __asm__(\"$18\");\n+  register long sc_19 __asm__(\"$19\");\n+\n+  sc_0 = SYS_futex;\n+  sc_16 = (long) addr;\n+  sc_17 = FUTEX_WAIT;\n+  sc_18 = val;\n+  sc_19 = 0;\n+  __asm volatile (\"callsys\"\n+\t\t  : \"=r\" (sc_0), \"=r\"(sc_19)\n+\t\t  : \"0\"(sc_0), \"r\" (sc_16), \"r\"(sc_17), \"r\"(sc_18), \"1\"(sc_19)\n+\t\t  : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t    \"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  register long sc_0 __asm__(\"$0\");\n+  register long sc_16 __asm__(\"$16\");\n+  register long sc_17 __asm__(\"$17\");\n+  register long sc_18 __asm__(\"$18\");\n+  register long sc_19 __asm__(\"$19\");\n+\n+  sc_0 = SYS_futex;\n+  sc_16 = (long) addr;\n+  sc_17 = FUTEX_WAKE;\n+  sc_18 = count;\n+  __asm volatile (\"callsys\"\n+\t\t  : \"=r\" (sc_0), \"=r\"(sc_19)\n+\t\t  : \"0\"(sc_0), \"r\" (sc_16), \"r\"(sc_17), \"r\"(sc_18)\n+\t\t  : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t    \"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+}"}, {"sha": "5c4f32e6f8b4c4871e3addeccec08cd42fb36cdd", "filename": "libgomp/config/linux/bar.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fbar.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,64 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a barrier synchronization\n+   mechanism for libgomp.  This type is private to the library.  This \n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#include \"libgomp.h\"\n+#include \"futex.h\"\n+#include <limits.h>\n+\n+\n+void\n+gomp_barrier_wait_end (gomp_barrier_t *bar, bool last)\n+{\n+  if (last)\n+    {\n+      bar->generation++;\n+      futex_wake (&bar->generation, INT_MAX);\n+    }\n+  else\n+    {\n+      unsigned int generation = bar->generation;\n+\n+      gomp_mutex_unlock (&bar->mutex);\n+\n+      do\n+\tfutex_wait (&bar->generation, generation);\n+      while (bar->generation == generation);\n+    }\n+\n+  if (__sync_add_and_fetch (&bar->arrived, -1) == 0)\n+    gomp_mutex_unlock (&bar->mutex);\n+}\n+\n+void\n+gomp_barrier_wait (gomp_barrier_t *barrier)\n+{\n+  gomp_barrier_wait_end (barrier, gomp_barrier_wait_start (barrier));\n+}"}, {"sha": "57268585d8bb066bcbcdaae27de94b61cfc41913", "filename": "libgomp/config/linux/bar.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fbar.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,75 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a barrier synchronization\n+   mechanism for libgomp.  This type is private to the library.  This \n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#ifndef GOMP_BARRIER_H\n+#define GOMP_BARRIER_H 1\n+\n+#include \"mutex.h\"\n+\n+typedef struct\n+{\n+  gomp_mutex_t mutex;\n+  unsigned total;\n+  unsigned arrived;\n+  int generation;\n+} gomp_barrier_t;\n+\n+static inline void gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n+{\n+  gomp_mutex_init (&bar->mutex);\n+  bar->total = count;\n+  bar->arrived = 0;\n+  bar->generation = 0;\n+}\n+\n+static inline void gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)\n+{\n+  gomp_mutex_lock (&bar->mutex);\n+  bar->total = count;\n+  gomp_mutex_unlock (&bar->mutex);\n+}\n+\n+static inline void gomp_barrier_destroy (gomp_barrier_t *bar)\n+{\n+  /* Before destroying, make sure all threads have left the barrier.  */\n+  gomp_mutex_lock (&bar->mutex);\n+}\n+\n+extern void gomp_barrier_wait (gomp_barrier_t *);\n+extern void gomp_barrier_wait_end (gomp_barrier_t *, bool);\n+\n+static inline bool gomp_barrier_wait_start (gomp_barrier_t *bar)\n+{\n+  gomp_mutex_lock (&bar->mutex);\n+  return ++bar->arrived == bar->total;\n+}\n+\n+#endif /* GOMP_BARRIER_H */"}, {"sha": "5e54982d6f758e3089448450d37193b25a0044ee", "filename": "libgomp/config/linux/ia64/futex.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fia64%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fia64%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fia64%2Ffutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,71 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* Provide target-specific access to the futex system call.  */\n+\n+#include <sys/syscall.h>\n+\n+#define FUTEX_WAIT\t0\n+#define FUTEX_WAKE\t1\n+\n+\n+static inline void\n+sys_futex0(int *addr, int op, int val)\n+{\n+  register long out0 asm (\"out0\") = (long) addr;\n+  register long out1 asm (\"out1\") = op;\n+  register long out2 asm (\"out2\") = val;\n+  register long out3 asm (\"out3\") = 0;\n+  register long r15 asm (\"r15\") = SYS_futex;\n+\n+  __asm __volatile (\"break 0x100000\"\n+\t: \"=r\"(r15), \"=r\"(out0), \"=r\"(out1), \"=r\"(out2), \"=r\"(out3)\n+\t: \"r\"(r15), \"r\"(out0), \"r\"(out1), \"r\"(out2), \"r\"(out3)\n+        : \"memory\", \"r8\", \"r10\", \"out4\", \"out5\", \"out6\", \"out7\",\n+\t  /* Non-stacked integer registers, minus r8, r10, r15.  */\n+\t  \"r2\", \"r3\", \"r9\", \"r11\", \"r12\", \"r13\", \"r14\", \"r16\", \"r17\", \"r18\",\n+\t  \"r19\", \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\",\n+\t  \"r28\", \"r29\", \"r30\", \"r31\",\n+\t  /* Predicate registers.  */\n+\t  \"p6\", \"p7\", \"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\",\n+\t  /* Non-rotating fp registers.  */\n+\t  \"f6\", \"f7\", \"f8\", \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\n+\t  /* Branch registers.  */\n+\t  \"b6\");\n+}\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  sys_futex0 (addr, FUTEX_WAIT, val);\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  sys_futex0 (addr, FUTEX_WAKE, count);\n+}"}, {"sha": "211f6007b43b93001129de40deb4ec2074dcb7b8", "filename": "libgomp/config/linux/lock.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Flock.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,182 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of the public OpenMP locking\n+   primitives.  This implementation uses atomic instructions and the futex\n+   syscall.  */\n+\n+#include \"libgomp.h\"\n+#include <string.h>\n+#include <unistd.h>\n+#include <sys/syscall.h>\n+#include \"futex.h\"\n+\n+\n+/* The internal gomp_mutex_t and the external non-recursive omp_lock_t\n+   have the same form.  Re-use it.  */\n+\n+void\n+omp_init_lock (omp_lock_t *lock)\n+{\n+  gomp_mutex_init (lock);\n+}\n+\n+void\n+omp_destroy_lock (omp_lock_t *lock)\n+{\n+  gomp_mutex_destroy (lock);\n+}\n+\n+void\n+omp_set_lock (omp_lock_t *lock)\n+{\n+  gomp_mutex_lock (lock);\n+}\n+\n+void\n+omp_unset_lock (omp_lock_t *lock)\n+{\n+  gomp_mutex_unlock (lock);\n+}\n+\n+int\n+omp_test_lock (omp_lock_t *lock)\n+{\n+  return __sync_bool_compare_and_swap (lock, 0, 1);\n+}\n+\n+/* The external recursive omp_nest_lock_t form requires additional work.  */\n+\n+/* We need an integer to uniquely identify this thread.  Most generally\n+   this is the thread's TID, which ideally we'd get this straight from\n+   the TLS block where glibc keeps it.  Unfortunately, we can't get at\n+   that directly.\n+\n+   If we don't support (or have disabled) TLS, one function call is as\n+   good (or bad) as any other.  Use the syscall all the time.\n+\n+   On an ILP32 system (defined here as not LP64), we can make do with\n+   any thread-local pointer.  Ideally we'd use the TLS base address,\n+   since that requires the least amount of arithmetic, but that's not\n+   always available directly.  Make do with the gomp_thread pointer\n+   since it's handy.  */\n+\n+#if !defined (HAVE_TLS)\n+static inline int gomp_tid (void)\n+{\n+  return syscall (SYS_gettid);\n+}\n+#elif !defined(__LP64__)\n+static inline int gomp_tid (void)\n+{\n+  return (int) gomp_thread ();\n+}\n+#else\n+static __thread int tid_cache;\n+static inline int gomp_tid (void)\n+{\n+  int tid = tid_cache;\n+  if (__builtin_expect (tid == 0, 0))\n+    tid_cache = tid = syscall (SYS_gettid);\n+  return tid;\n+}\n+#endif\n+\n+\n+void\n+omp_init_nest_lock (omp_nest_lock_t *lock)\n+{\n+  memset (lock, 0, sizeof (lock));\n+}\n+\n+void\n+omp_destroy_nest_lock (omp_nest_lock_t *lock)\n+{\n+}\n+\n+void\n+omp_set_nest_lock (omp_nest_lock_t *lock)\n+{\n+  int otid, tid = gomp_tid ();\n+\n+  while (1)\n+    {\n+      otid = __sync_val_compare_and_swap (&lock->owner, 0, tid);\n+      if (otid == 0)\n+\t{\n+\t  lock->count = 1;\n+\t  return;\n+\t}\n+      if (otid == tid)\n+\t{\n+\t  lock->count++;\n+\t  return;\n+\t}\n+\n+      futex_wait (&lock->owner, otid);\n+    }\n+}\n+\n+void\n+omp_unset_nest_lock (omp_nest_lock_t *lock)\n+{\n+  /* ??? Validate that we own the lock here.  */\n+\n+  if (--lock->count == 0)\n+    {\n+      __sync_lock_release (&lock->owner);\n+      futex_wake (&lock->owner, 1);\n+    }\n+}\n+\n+int\n+omp_test_nest_lock (omp_nest_lock_t *lock)\n+{\n+  int otid, tid = gomp_tid ();\n+\n+  otid = __sync_val_compare_and_swap (&lock->owner, 0, tid);\n+  if (otid == 0)\n+    {\n+      lock->count = 1;\n+      return 1;\n+    }\n+  if (otid == tid)\n+    return ++lock->count;\n+\n+  return 0;\n+}\n+\n+ialias (omp_init_lock)\n+ialias (omp_init_nest_lock)\n+ialias (omp_destroy_lock)\n+ialias (omp_destroy_nest_lock)\n+ialias (omp_set_lock)\n+ialias (omp_set_nest_lock)\n+ialias (omp_unset_lock)\n+ialias (omp_unset_nest_lock)\n+ialias (omp_test_lock)\n+ialias (omp_test_nest_lock)"}, {"sha": "fa3dfd1cb036dc06927815d9c42880b6aa2ccc9b", "filename": "libgomp/config/linux/mutex.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fmutex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fmutex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fmutex.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,52 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#include \"libgomp.h\"\n+#include \"futex.h\"\n+\n+\n+void\n+gomp_mutex_lock_slow (gomp_mutex_t *mutex)\n+{\n+  do\n+    {\n+      int oldval = __sync_val_compare_and_swap (mutex, 1, 2);\n+      if (oldval != 0)\n+        futex_wait (mutex, 2);\n+    }\n+  while (!__sync_bool_compare_and_swap (mutex, 0, 2));\n+}\n+\n+void\n+gomp_mutex_unlock_slow (gomp_mutex_t *mutex)\n+{\n+  futex_wake (mutex, 1);\n+}"}, {"sha": "323814aa8e7e10093cc34924493c06839d65cda7", "filename": "libgomp/config/linux/mutex.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fmutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,63 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#ifndef GOMP_MUTEX_H\n+#define GOMP_MUTEX_H 1\n+\n+typedef int gomp_mutex_t;\n+\n+#define GOMP_MUTEX_INIT_0 1\n+\n+static inline void gomp_mutex_init (gomp_mutex_t *mutex)\n+{\n+  *mutex = 0;\n+}\n+\n+extern void gomp_mutex_lock_slow (gomp_mutex_t *mutex);\n+static inline void gomp_mutex_lock (gomp_mutex_t *mutex)\n+{\n+  if (!__sync_bool_compare_and_swap (mutex, 0, 1))\n+    gomp_mutex_lock_slow (mutex);\n+}\n+\n+extern void gomp_mutex_unlock_slow (gomp_mutex_t *mutex);\n+static inline void gomp_mutex_unlock (gomp_mutex_t *mutex)\n+{\n+  int val = __sync_lock_test_and_set (mutex, 0);\n+  if (__builtin_expect (val > 1, 0))\n+    gomp_mutex_unlock_slow (mutex);\n+}\n+\n+static inline void gomp_mutex_destroy (gomp_mutex_t *mutex)\n+{\n+}\n+\n+#endif /* GOMP_MUTEX_H */"}, {"sha": "350cba16056aa886016ef44ad8af41b6269edb66", "filename": "libgomp/config/linux/omp-lock.h", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fomp-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fomp-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fomp-lock.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,10 @@\n+/* This header is used during the build process to find the size and \n+   alignment of the public OpenMP locks, so that we can export data\n+   structures without polluting the namespace.\n+\n+   When using the Linux futex primitive, non-recursive locks require\n+   only one int.  Recursive locks require we identify the owning thread\n+   and so require two ints.  */\n+\n+typedef int omp_lock_t;\n+typedef struct { int owner, count; } omp_nest_lock_t;"}, {"sha": "20e03573783d23b6f1283ceaedbd93c682bf45e5", "filename": "libgomp/config/linux/powerpc/futex.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Ffutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,70 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* Provide target-specific access to the futex system call.  */\n+\n+#include <sys/syscall.h>\n+#define FUTEX_WAIT\t0\n+#define FUTEX_WAKE\t1\n+\n+static inline void\n+sys_futex0 (int *addr, int op, int val)\n+{\n+  register long int r0  __asm__ (\"r0\");\n+  register long int r3  __asm__ (\"r3\");\n+  register long int r4  __asm__ (\"r4\");\n+  register long int r5  __asm__ (\"r5\");\n+  register long int r6  __asm__ (\"r6\");\n+\n+  r0 = SYS_futex;\n+  r3 = (long) addr;\n+  r4 = op;\n+  r5 = val;\n+  r6 = 0;\n+\n+  /* ??? The powerpc64 sysdep.h file clobbers ctr; the powerpc32 sysdep.h\n+     doesn't.  It doesn't much matter for us.  In the interest of unity,\n+     go ahead and clobber it always.  */\n+\n+  __asm volatile (\"sc\"\n+\t\t  : \"=r\"(r0), \"=r\"(r3), \"=r\"(r4), \"=r\"(r5), \"=r\"(r6)\n+\t\t  : \"r\"(r0), \"r\"(r3), \"r\"(r4), \"r\"(r5), \"r\"(r6)\n+\t\t  : \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\",\n+\t\t    \"cr0\", \"ctr\", \"memory\");\n+}\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  sys_futex0 (addr, FUTEX_WAIT, val);\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  sys_futex0 (addr, FUTEX_WAKE, count);\n+}"}, {"sha": "9b3820c0d976e22ec89ce1f56b9e9f40eb69522b", "filename": "libgomp/config/linux/s390/futex.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fs390%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fs390%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fs390%2Ffutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,64 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* Provide target-specific access to the futex system call.  */\n+\n+#include <sys/syscall.h>\n+#define FUTEX_WAIT\t0\n+#define FUTEX_WAKE\t1\n+\n+static inline void\n+sys_futex0 (int *addr, int op, int val)\n+{\n+  register long int gpr2  __asm__ (\"2\");\n+  register long int gpr3  __asm__ (\"3\");\n+  register long int gpr4  __asm__ (\"4\");\n+  register long int gpr5  __asm__ (\"5\");\n+\n+  gpr2 = (long) addr;\n+  gpr3 = op;\n+  gpr4 = val;\n+  gpr5 = 0;\n+\n+  __asm volatile (\"svc %b1\"\n+\t\t  : \"=d\" (gpr2)\n+\t\t  : \"i\" (SYS_futex),\n+\t\t    \"0\" (gpr2), \"d\" (gpr3), \"d\" (gpr4), \"d\" (gpr5)\n+\t\t  : \"memory\");\n+}\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  sys_futex0 (addr, FUTEX_WAIT, val);\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  sys_futex0 (addr, FUTEX_WAKE, count);\n+}"}, {"sha": "798e3f1f2c0625e89f870259a506edb7ea3a0325", "filename": "libgomp/config/linux/sem.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fsem.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,65 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a semaphore synchronization\n+   mechanism for libgomp.  This type is private to the library.  This \n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#include \"libgomp.h\"\n+#include \"futex.h\"\n+\n+\n+void\n+gomp_sem_wait_slow (gomp_sem_t *sem)\n+{\n+  while (1)\n+    {\n+      int val = __sync_val_compare_and_swap (sem, 0, -1);\n+      if (val > 0)\n+\t{\n+\t  if (__sync_bool_compare_and_swap (sem, val, val - 1))\n+\t    return;\n+\t}\n+      futex_wait (sem, -1);\n+    }\n+}\n+\n+void\n+gomp_sem_post_slow (gomp_sem_t *sem)\n+{\n+  int old, tmp = *sem, wake;\n+\n+  do\n+    {\n+      old = tmp;\n+      wake = old > 0 ? old + 1 : 1;\n+      tmp = __sync_val_compare_and_swap (sem, old, wake);\n+    }\n+  while (old != tmp);\n+\n+  futex_wake (sem, wake);\n+}"}, {"sha": "fff0bbdedcbc4b9aa318da23c9a19c22381ce0fc", "filename": "libgomp/config/linux/sem.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fsem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fsem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fsem.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,60 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a semaphore synchronization\n+   mechanism for libgomp.  This type is private to the library.  This \n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#ifndef GOMP_SEM_H\n+#define GOMP_SEM_H 1\n+\n+typedef int gomp_sem_t;\n+\n+static inline void gomp_sem_init (gomp_sem_t *sem, int value)\n+{\n+  *sem = value;\n+}\n+\n+extern void gomp_sem_wait_slow (gomp_sem_t *);\n+static inline void gomp_sem_wait (gomp_sem_t *sem)\n+{\n+  if (!__sync_bool_compare_and_swap (sem, 1, 0))\n+    gomp_sem_wait_slow (sem);\n+}\n+\n+extern void gomp_sem_post_slow (gomp_sem_t *);\n+static inline void gomp_sem_post (gomp_sem_t *sem)\n+{\n+  if (!__sync_bool_compare_and_swap (sem, 0, 1))\n+    gomp_sem_post_slow (sem);\n+}\n+\n+static inline void gomp_sem_destroy (gomp_sem_t *sem)\n+{\n+}\n+\n+#endif /* GOMP_SEM_H */"}, {"sha": "7b1cc8379565240e82c597cb40d78ce21a803344", "filename": "libgomp/config/linux/sparc/futex.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fsparc%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fsparc%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fsparc%2Ffutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,80 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* Provide target-specific access to the futex system call.  */\n+\n+#include <sys/syscall.h>\n+#define FUTEX_WAIT\t0\n+#define FUTEX_WAKE\t1\n+\n+static inline void\n+sys_futex0 (int *addr, int op, int val)\n+{\n+  register long int g1  __asm__ (\"g1\");\n+  register long int o0  __asm__ (\"o0\");\n+  register long int o1  __asm__ (\"o1\");\n+  register long int o2  __asm__ (\"o2\");\n+  register long int o3  __asm__ (\"o3\");\n+\n+  g1 = SYS_futex;\n+  o0 = (long) addr;\n+  o1 = op;\n+  o2 = val;\n+  o3 = 0;\n+\n+#ifdef __arch64__\n+# define SYSCALL_STRING \"ta\\t0x6d\"\n+#else\n+# define SYSCALL_STRING \"ta\\t0x10\"\n+#endif\n+\n+  __asm volatile (SYSCALL_STRING\n+\t\t  : \"=r\" (g1), \"=r\" (o0)\n+\t\t  : \"0\" (g1), \"1\" (o0), \"r\" (o1), \"r\" (o2), \"r\" (o3)\n+\t\t  : \"g2\", \"g3\", \"g4\", \"g5\", \"g6\",\n+\t\t    \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",\n+\t\t    \"f8\", \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\n+\t\t    \"f16\", \"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\",\n+\t\t    \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\", \"f30\", \"f31\",\n+#ifdef __arch64__\n+\t\t    \"f32\", \"f34\", \"f36\", \"f38\", \"f40\", \"f42\", \"f44\", \"f46\",\n+\t\t    \"f48\", \"f50\", \"f52\", \"f54\", \"f56\", \"f58\", \"f60\", \"f62\",\n+#endif\n+\t\t    \"cc\", \"memory\");\n+}\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  sys_futex0 (addr, FUTEX_WAIT, val);\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  sys_futex0 (addr, FUTEX_WAKE, count);\n+}"}, {"sha": "4f9aac2ddbbec14eafaf7b66961023fbc8a1347c", "filename": "libgomp/config/linux/x86/futex.h", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fx86%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Flinux%2Fx86%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fx86%2Ffutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,110 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* Provide target-specific access to the futex system call.  */\n+\n+#define FUTEX_WAIT\t0\n+#define FUTEX_WAKE\t1\n+\n+#ifdef __LP64__\n+# ifndef SYS_futex\n+#  define SYS_futex\t202\n+# endif\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  register long r10 __asm__(\"%r10\") = 0;\n+  long res;\n+\n+  __asm volatile (\"syscall\"\n+\t\t  : \"=a\" (res)\n+\t\t  : \"0\"(SYS_futex), \"D\" (addr), \"S\"(FUTEX_WAIT),\n+\t\t    \"d\"(val), \"r\"(r10)\n+\t\t  : \"r11\", \"rcx\", \"memory\");\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  long res;\n+\n+  __asm volatile (\"syscall\"\n+\t\t  : \"=a\" (res)\n+\t\t  : \"0\"(SYS_futex), \"D\" (addr), \"S\"(FUTEX_WAKE), \"d\"(count)\n+\t\t  : \"r11\", \"rcx\", \"memory\");\n+}\n+#else\n+# ifndef SYS_futex\n+#  define SYS_futex\t240\n+# endif\n+\n+# ifdef __PIC__\n+\n+static inline void\n+sys_futex0 (int *addr, int op, int val)\n+{\n+  long res;\n+\n+  __asm volatile (\"xchgl\\t%%ebx, %2\\n\\t\"\n+\t\t  \"int\\t$0x80\\n\\t\"\n+\t\t  \"xchgl\\t%%ebx, %2\"\n+\t\t  : \"=a\" (res)\n+\t\t  : \"0\"(SYS_futex), \"r\" (addr), \"c\"(op),\n+\t\t    \"d\"(val), \"S\"(0)\n+\t\t  : \"memory\");\n+}\n+\n+# else\n+\n+static inline void\n+sys_futex0 (int *addr, int op, int val)\n+{\n+  long res;\n+\n+  __asm volatile (\"int $0x80\"\n+\t\t  : \"=a\" (res)\n+\t\t  : \"0\"(SYS_futex), \"b\" (addr), \"c\"(op),\n+\t\t    \"d\"(val), \"S\"(0)\n+\t\t  : \"memory\");\n+}\n+\n+# endif /* __PIC__ */\n+\n+static inline void\n+futex_wait (int *addr, int val)\n+{\n+  sys_futex0 (addr, FUTEX_WAIT, val);\n+}\n+\n+static inline void\n+futex_wake (int *addr, int count)\n+{\n+  sys_futex0 (addr, FUTEX_WAKE, count);\n+}\n+\n+#endif /* __LP64__ */"}, {"sha": "79721610ca75bc10a0a0471b3e6ca6ae00a15828", "filename": "libgomp/config/posix/bar.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fbar.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,111 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is the default implementation of a barrier synchronization mechanism\n+   for libgomp.  This type is private to the library.  Note that we rely on\n+   being able to adjust the barrier count while threads are blocked, so the\n+   POSIX pthread_barrier_t won't work.  */\n+\n+#include \"libgomp.h\"\n+\n+\n+void\n+gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n+{\n+  gomp_mutex_init (&bar->mutex1);\n+#ifndef HAVE_SYNC_BUILTINS\n+  gomp_mutex_init (&bar->mutex2);\n+#endif\n+  gomp_sem_init (&bar->sem1, 0);\n+  gomp_sem_init (&bar->sem2, 0);\n+  bar->total = count;\n+  bar->arrived = 0;\n+}\n+\n+void\n+gomp_barrier_destroy (gomp_barrier_t *bar)\n+{\n+  /* Before destroying, make sure all threads have left the barrier.  */\n+  gomp_mutex_lock (&bar->mutex1);\n+  gomp_mutex_unlock (&bar->mutex1);\n+\n+  gomp_mutex_destroy (&bar->mutex1);\n+#ifndef HAVE_SYNC_BUILTINS\n+  gomp_mutex_destroy (&bar->mutex2);\n+#endif\n+  gomp_sem_destroy (&bar->sem1);\n+  gomp_sem_destroy (&bar->sem2);\n+}\n+\n+void\n+gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)\n+{\n+  gomp_mutex_lock (&bar->mutex1);\n+  bar->total = count;\n+  gomp_mutex_unlock (&bar->mutex1);\n+}\n+\n+void\n+gomp_barrier_wait_end (gomp_barrier_t *bar, bool last)\n+{\n+  unsigned int n;\n+\n+  if (last)\n+    {\n+      n = --bar->arrived;\n+      if (n > 0)\n+\t{\n+\t  do\n+\t    gomp_sem_post (&bar->sem1);\n+\t  while (--n != 0);\n+\t  gomp_sem_wait (&bar->sem2);\n+\t}\n+      gomp_mutex_unlock (&bar->mutex1);\n+    }\n+  else\n+    {\n+      gomp_mutex_unlock (&bar->mutex1);\n+      gomp_sem_wait (&bar->sem1);\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+      n = __sync_add_and_fetch (&bar->arrived, -1);\n+#else\n+      gomp_mutex_lock (&bar->mutex2);\n+      n = --bar->arrived;\n+      gomp_mutex_unlock (&bar->mutex2);\n+#endif\n+\n+      if (n == 0)\n+\tgomp_sem_post (&bar->sem2);\n+    }\n+}\n+\n+void\n+gomp_barrier_wait (gomp_barrier_t *barrier)\n+{\n+  gomp_barrier_wait_end (barrier, gomp_barrier_wait_start (barrier));\n+}"}, {"sha": "5275efa96a728485268726a42d1c8c9589e97d07", "filename": "libgomp/config/posix/bar.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fbar.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,63 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is the default implementation of a barrier synchronization mechanism\n+   for libgomp.  This type is private to the library.  Note that we rely on\n+   being able to adjust the barrier count while threads are blocked, so the\n+   POSIX pthread_barrier_t won't work.  */\n+\n+#ifndef GOMP_BARRIER_H\n+#define GOMP_BARRIER_H 1\n+\n+#include <pthread.h>\n+\n+typedef struct\n+{\n+  gomp_mutex_t mutex1;\n+#ifndef HAVE_SYNC_BUILTINS\n+  gomp_mutex_t mutex2;\n+#endif\n+  gomp_sem_t sem1;\n+  gomp_sem_t sem2;\n+  unsigned total;\n+  unsigned arrived;\n+} gomp_barrier_t;\n+\n+extern void gomp_barrier_init (gomp_barrier_t *, unsigned);\n+extern void gomp_barrier_reinit (gomp_barrier_t *, unsigned);\n+extern void gomp_barrier_destroy (gomp_barrier_t *);\n+\n+extern void gomp_barrier_wait (gomp_barrier_t *);\n+extern void gomp_barrier_wait_end (gomp_barrier_t *, bool);\n+\n+static inline bool gomp_barrier_wait_start (gomp_barrier_t *bar)\n+{\n+  gomp_mutex_lock (&bar->mutex1);\n+  return ++bar->arrived == bar->total;\n+}\n+\n+#endif /* GOMP_BARRIER_H */"}, {"sha": "062174d32d564d57ecadf67d82b90b04e40a68e7", "filename": "libgomp/config/posix/lock.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Flock.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,121 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is the default PTHREADS implementation of the public OpenMP\n+   locking primitives.\n+\n+   Because OpenMP uses different entry points for normal and recursive\n+   locks, and pthreads uses only one entry point, a system may be able\n+   to do better and streamline the locking as well as reduce the size\n+   of the types exported.  */\n+\n+/* We need Unix98 extensions to get recursive locks.  */\n+#define _XOPEN_SOURCE 500\n+\n+#include \"libgomp.h\"\n+\n+\n+void\n+omp_init_lock (omp_lock_t *lock)\n+{\n+  pthread_mutex_init (lock, NULL);\n+}\n+\n+void\n+omp_destroy_lock (omp_lock_t *lock)\n+{\n+  pthread_mutex_destroy (lock);\n+}\n+\n+void\n+omp_set_lock (omp_lock_t *lock)\n+{\n+  pthread_mutex_lock (lock);\n+}\n+\n+void\n+omp_unset_lock (omp_lock_t *lock)\n+{\n+  pthread_mutex_unlock (lock);\n+}\n+\n+int\n+omp_test_lock (omp_lock_t *lock)\n+{\n+  return pthread_mutex_trylock (lock) == 0;\n+}\n+\n+void\n+omp_init_nest_lock (omp_nest_lock_t *lock)\n+{\n+  pthread_mutexattr_t attr;\n+\n+  pthread_mutexattr_init (&attr);\n+  pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);\n+  pthread_mutex_init (&lock->lock, &attr);\n+  lock->count = 0;\n+  pthread_mutexattr_destroy (&attr);\n+}\n+\n+void\n+omp_destroy_nest_lock (omp_nest_lock_t *lock)\n+{\n+  pthread_mutex_destroy (&lock->lock);\n+}\n+\n+void\n+omp_set_nest_lock (omp_nest_lock_t *lock)\n+{\n+  pthread_mutex_lock (&lock->lock);\n+  lock->count++;\n+}\n+\n+void\n+omp_unset_nest_lock (omp_nest_lock_t *lock)\n+{\n+  lock->count--;\n+  pthread_mutex_unlock (&lock->lock);\n+}\n+\n+int\n+omp_test_nest_lock (omp_nest_lock_t *lock)\n+{\n+  if (pthread_mutex_trylock (&lock->lock) == 0)\n+    return ++lock->count;\n+  return 0;\n+}\n+\n+ialias (omp_init_lock)\n+ialias (omp_init_nest_lock)\n+ialias (omp_destroy_lock)\n+ialias (omp_destroy_nest_lock)\n+ialias (omp_set_lock)\n+ialias (omp_set_nest_lock)\n+ialias (omp_unset_lock)\n+ialias (omp_unset_nest_lock)\n+ialias (omp_test_lock)\n+ialias (omp_test_nest_lock)"}, {"sha": "39bb64da0f90aa4acbb6dd9fd2e96bbf90bc6e85", "filename": "libgomp/config/posix/mutex.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fmutex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fmutex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fmutex.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1 @@\n+/* Everything is in the header.  */"}, {"sha": "c798e78aec889ca5865306542ce2e406e571c7ac", "filename": "libgomp/config/posix/mutex.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fmutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fmutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fmutex.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,60 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is the default PTHREADS implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  */\n+\n+#ifndef GOMP_MUTEX_H\n+#define GOMP_MUTEX_H 1\n+\n+#include <pthread.h>\n+\n+typedef pthread_mutex_t gomp_mutex_t;\n+\n+#define GOMP_MUTEX_INIT_0 0\n+\n+static inline void gomp_mutex_init (gomp_mutex_t *mutex)\n+{\n+  pthread_mutex_init (mutex, NULL);\n+}\n+\n+static inline void gomp_mutex_lock (gomp_mutex_t *mutex)\n+{\n+  pthread_mutex_lock (mutex);\n+}\n+\n+static inline void gomp_mutex_unlock (gomp_mutex_t *mutex)\n+{\n+   pthread_mutex_unlock (mutex);\n+}\n+\n+static inline void gomp_mutex_destroy (gomp_mutex_t *mutex)\n+{\n+  pthread_mutex_destroy (mutex);\n+}\n+\n+#endif /* GOMP_MUTEX_H */"}, {"sha": "ed70618d87ded7f3960d49e6153c3eb8284ea7da", "filename": "libgomp/config/posix/omp-lock.h", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fomp-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fomp-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fomp-lock.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,11 @@\n+/* This header is used during the build process to find the size and \n+   alignment of the public OpenMP locks, so that we can export data\n+   structures without polluting the namespace.\n+\n+   In this default POSIX implementation, we map the two locks to the\n+   same PTHREADS primitive.  */\n+\n+#include <pthread.h>\n+\n+typedef pthread_mutex_t omp_lock_t;\n+typedef struct { pthread_mutex_t lock; int count; } omp_nest_lock_t;"}, {"sha": "3f5eb7ddc1117e58da95ff30a1db102299799015", "filename": "libgomp/config/posix/proc.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fproc.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,98 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains system specific routines related to counting\n+   online processors and dynamic load balancing.  It is expected that\n+   a system may well want to write special versions of each of these.\n+\n+   The following implementation uses a mix of POSIX and BSD routines.  */\n+\n+#include \"libgomp.h\"\n+#include <unistd.h>\n+#include <stdlib.h>\n+\n+\n+/* At startup, determine the default number of threads.  It would seem\n+   this should be related to the number of cpus online.  */\n+\n+void\n+gomp_init_num_threads (void)\n+{\n+#ifdef _SC_NPROCESSORS_ONLN\n+  gomp_nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n+#endif\n+}\n+\n+/* When OMP_DYNAMIC is set, at thread launch determine the number of\n+   threads we should spawn for this team.  */\n+/* ??? I have no idea what best practice for this is.  Surely some\n+   function of the number of processors that are *still* online and\n+   the load average.  Here I use the number of processors online\n+   minus the 15 minute load average.  */\n+\n+unsigned\n+gomp_dynamic_max_threads (void)\n+{\n+  unsigned n_onln, loadavg;\n+\n+#ifdef _SC_NPROCESSORS_ONLN\n+  n_onln = sysconf (_SC_NPROCESSORS_ONLN);\n+  if (n_onln > gomp_nthreads_var)\n+    n_onln = gomp_nthreads_var;\n+#else\n+  n_onln = gomp_nthreads_var;\n+#endif\n+\n+  loadavg = 0;\n+#ifdef HAVE_GETLOADAVG\n+  {\n+    double dloadavg[3];\n+    if (getloadavg (dloadavg, 3) == 3)\n+      {\n+\t/* Add 0.1 to get a kind of biased rounding.  */\n+\tloadavg = dloadavg[2] + 0.1;\n+      }\n+  }\n+#endif\n+\n+  if (loadavg >= n_onln)\n+    return 1;\n+  else\n+    return n_onln - loadavg;\n+}\n+\n+int\n+omp_get_num_procs (void)\n+{\n+#ifdef _SC_NPROCESSORS_ONLN\n+  return sysconf (_SC_NPROCESSORS_ONLN);\n+#else\n+  return gomp_nthreads_var;\n+#endif\n+}\n+\n+ialias (omp_get_num_procs)"}, {"sha": "e8374bda50d578f02be15d9af402dd1e72224e7f", "filename": "libgomp/config/posix/sem.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fsem.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,46 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is the default POSIX 1003.1b implementation of a semaphore\n+   synchronization mechanism for libgomp.  This type is private to\n+   the library.\n+\n+   This is a bit heavy weight for what we need, in that we're not\n+   interested in sem_wait as a cancelation point, but it's not too\n+   bad for a default.  */\n+\n+#include \"libgomp.h\"\n+\n+\n+void\n+gomp_sem_wait (gomp_sem_t *sem)\n+{\n+  /* With POSIX, the wait can be canceled by signals.  We don't want that.\n+     It is expected that the return value here is -1 and errno is EINTR.  */\n+  while (sem_wait (sem) != 0)\n+    continue;\n+}"}, {"sha": "776a60d1c161d808db1959151ec19f58bb9966e1", "filename": "libgomp/config/posix/sem.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fsem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Fsem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fsem.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,68 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is the default POSIX 1003.1b implementation of a semaphore\n+   synchronization mechanism for libgomp.  This type is private to\n+   the library.\n+\n+   This is a bit heavy weight for what we need, in that we're not\n+   interested in sem_wait as a cancelation point, but it's not too\n+   bad for a default.  */\n+\n+#ifndef GOMP_SEM_H\n+#define GOMP_SEM_H 1\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility push(default)\n+#endif\n+\n+#include <semaphore.h>\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility pop\n+#endif\n+\n+typedef sem_t gomp_sem_t;\n+\n+static inline void gomp_sem_init (gomp_sem_t *sem, int value)\n+{\n+  sem_init (sem, 0, value);\n+}\n+\n+extern void gomp_sem_wait (gomp_sem_t *sem);\n+\n+static inline void gomp_sem_post (gomp_sem_t *sem)\n+{\n+  sem_post (sem);\n+}\n+\n+static inline void gomp_sem_destroy (gomp_sem_t *sem)\n+{\n+  sem_destroy (sem);\n+}\n+\n+#endif /* GOMP_SEM_H */"}, {"sha": "ef267a31228bc305dbd675e1a1d5db90189262c7", "filename": "libgomp/config/posix/time.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Ftime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfig%2Fposix%2Ftime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Ftime.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,81 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains system specific timer routines.  It is expected that\n+   a system may well want to write special versions of each of these.\n+\n+   The following implementation uses the most simple POSIX routines.\n+   If present, POSIX 4 clocks should be used instead.  */\n+\n+#include \"libgomp.h\"\n+#include <unistd.h>\n+#if TIME_WITH_SYS_TIME\n+# include <sys/time.h>\n+# include <time.h>\n+#else\n+# if HAVE_SYS_TIME_H\n+#  include <sys/time.h>\n+# else\n+#  include <time.h>\n+# endif\n+#endif\n+\n+\n+double\n+omp_get_wtime (void)\n+{\n+#ifdef HAVE_CLOCK_GETTIME\n+  struct timespec ts;\n+# ifdef CLOCK_MONOTONIC\n+  if (clock_gettime (CLOCK_MONOTONIC, &ts) < 0)\n+# endif\n+    clock_gettime (CLOCK_REALTIME, &ts);\n+  return ts.tv_sec + ts.tv_nsec / 1e9;\n+#else\n+  struct timeval tv;\n+  gettimeofday (&tv, NULL);\n+  return tv.tv_sec + tv.tv_usec / 1e6;\n+#endif\n+}\n+\n+double\n+omp_get_wtick (void)\n+{\n+#ifdef HAVE_CLOCK_GETTIME\n+  struct timespec ts;\n+# ifdef CLOCK_MONOTONIC\n+  if (clock_getres (CLOCK_MONOTONIC, &ts) < 0)\n+# endif\n+    clock_getres (CLOCK_REALTIME, &ts);\n+  return ts.tv_sec + ts.tv_nsec / 1e9;\n+#else\n+  return 1.0 / sysconf(_SC_CLK_TCK);\n+#endif\n+}\n+\n+ialias (omp_get_wtime)\n+ialias (omp_get_wtick)"}, {"sha": "4824adc51e999c71162618fa5e91e0b963601f1d", "filename": "libgomp/configure", "status": "added", "additions": 8126, "deletions": 0, "changes": 8126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "854514a27f42349f972304d236dba7b7ccf06b97", "filename": "libgomp/configure.ac", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,220 @@\n+# Process this file with autoconf to produce a configure script, like so:\n+# aclocal -I ../config && autoconf && autoheader && automake\n+\n+AC_PREREQ(2.59)\n+AC_INIT([GNU OpenMP Runtime Library], 1.0,,[libgomp])\n+AC_CONFIG_HEADER(config.h)\n+\n+# -------\n+# Options\n+# -------\n+\n+AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n+LIBGOMP_ENABLE(version-specific-runtime-libs, no, ,\n+   [Specify that runtime libraries should be installed in a compiler-specific directory],\n+   permit yes|no)\n+AC_MSG_RESULT($enable_version_specific_runtime_libs)\n+\n+AC_MSG_CHECKING([for --enable-linux-futex])\n+LIBGOMP_ENABLE(linux-futex, yes,\n+  [Use the Linux futex system call],\n+  permit yes|no)\n+AC_MSG_RESULT($enable_linux_futex)\n+\n+# -------\n+# -------\n+\n+# Gets build, host, target, *_vendor, *_cpu, *_os, etc.\n+#\n+# You will slowly go insane if you do not grok the following fact:  when\n+# building this library, the top-level /target/ becomes the library's /host/.\n+#\n+# configure then causes --target to default to --host, exactly like any\n+# other package using autoconf.  Therefore, 'target' and 'host' will\n+# always be the same.  This makes sense both for native and cross compilers\n+# just think about it for a little while.  :-)\n+#\n+# Also, if this library is being configured as part of a cross compiler, the\n+# top-level configure script will pass the \"real\" host as $with_cross_host.\n+#\n+# Do not delete or change the following two lines.  For why, see\n+# http://gcc.gnu.org/ml/libstdc++/2003-07/msg00451.html\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+\n+# Sets up automake.  Must come after AC_CANONICAL_SYSTEM.  Each of the\n+# following is magically included in AUTOMAKE_OPTIONS in each Makefile.am.\n+#  1.9.0:  minimum required version\n+#  no-define:  PACKAGE and VERSION will not be #define'd in config.h (a bunch\n+#              of other PACKAGE_* variables will, however, and there's nothing\n+#              we can do about that; they come from AC_INIT).\n+#  foreign:  we don't follow the normal rules for GNU packages (no COPYING\n+#            file in the top srcdir, etc, etc), so stop complaining.\n+#  no-dependencies:  turns off auto dependency generation (just for now)\n+#  -Wall:  turns on all automake warnings...\n+#  -Wno-portability:  ...except this one, since GNU make is required.\n+#  -Wno-override: ... and this one, since we do want this in testsuite.\n+AM_INIT_AUTOMAKE([1.9.0 foreign -Wall -Wno-portability -Wno-override])\n+AM_ENABLE_MULTILIB(, ..)\n+\n+# Calculate toolexeclibdir\n+# Also toolexecdir, though it's only used in toolexeclibdir\n+case ${enable_version_specific_runtime_libs} in\n+  yes)\n+    # Need the gcc compiler version to know where to install libraries\n+    # and header files if --enable-version-specific-runtime-libs option\n+    # is selected.\n+    toolexecdir='$(libdir)/gcc/$(target_alias)'\n+    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n+    ;;\n+  no)\n+    if test -n \"$with_cross_host\" &&\n+       test x\"$with_cross_host\" != x\"no\"; then\n+      # Install a library built with a cross compiler in tooldir, not libdir.\n+      toolexecdir='$(exec_prefix)/$(target_alias)'\n+      toolexeclibdir='$(toolexecdir)/lib'\n+    else\n+      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n+      toolexeclibdir='$(libdir)'\n+    fi\n+    multi_os_directory=`$CC -print-multi-os-directory`\n+    case $multi_os_directory in\n+      .) ;; # Avoid trailing /.\n+      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n+    esac\n+    ;;\n+esac\n+AC_SUBST(toolexecdir)\n+AC_SUBST(toolexeclibdir)\n+\n+# Check the compiler.\n+# The same as in boehm-gc and libstdc++. Have to borrow it from there.\n+# We must force CC to /not/ be precious variables; otherwise\n+# the wrong, non-multilib-adjusted value will be used in multilibs.\n+# As a side effect, we have to subst CFLAGS ourselves.\n+\n+m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])\n+m4_define([_AC_ARG_VAR_PRECIOUS],[])\n+AC_PROG_CC\n+m4_rename([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n+\n+AC_SUBST(CFLAGS)\n+\n+# In order to override CFLAGS_FOR_TARGET, all of our special flags go\n+# in XCFLAGS.  But we need them in CFLAGS during configury.  So put them\n+# in both places for now and restore CFLAGS at the end of config.\n+save_CFLAGS=\"$CFLAGS\"\n+\n+# Add -Wall -Werror if we are using GCC.\n+if test \"x$GCC\" = \"xyes\"; then\n+  XCFLAGS=\"$XCFLAGS -Wall -Werror\"\n+fi\n+\n+# Find other programs we need.\n+AC_CHECK_TOOL(AR, ar)\n+AC_CHECK_TOOL(RANLIB, ranlib, ranlib-not-found-in-path-error)\n+AC_PATH_PROG(PERL, perl, perl-not-found-in-path-error)\n+AC_PROG_MAKE_SET\n+AC_PROG_INSTALL\n+\n+# Configure libtool\n+AM_PROG_LIBTOOL\n+AC_SUBST(enable_shared)\n+AC_SUBST(enable_static)\n+\n+# We need gfortran to compile parts of the library\n+# We can't use AC_PROG_FC because it expects a fully working gfortran.\n+#AC_PROG_FC(gfortran)\n+FC=\"$GFORTRAN\"\n+AC_PROG_FC(gfortran)\n+FCFLAGS=\"$FCFLAGS -Wall\"\n+\n+# For libtool versioning info, format is CURRENT:REVISION:AGE\n+libtool_VERSION=1:0:0\n+AC_SUBST(libtool_VERSION)\n+\n+# Check header files.\n+AC_STDC_HEADERS\n+AC_HEADER_TIME\n+AC_CHECK_HEADERS(unistd.h semaphore.h sys/time.h)\n+AC_CHECK_HEADER([pthread.h],[],\n+  [AC_MSG_ERROR([Pthreads are required to build libgomp])])\n+\n+# Check to see if -pthread or -lpthread is needed.  Prefer the former.\n+XPCFLAGS=\"\"\n+CFLAGS=\"$CFLAGS -pthread\"\n+AC_LINK_IFELSE(\n+ [AC_LANG_PROGRAM(\n+  [#include <pthread.h>\n+   void *g(void *d) { return NULL; }],\n+  [pthread_t t; pthread_create(&t,NULL,g,NULL);])],\n+ [XPCFLAGS=\" -Wc,-pthread\"],\n+ [CFLAGS=\"$save_CFLAGS\" LIBS=\"-lpthread $LIBS\"\n+  AC_LINK_IFELSE(\n+   [AC_LANG_PROGRAM(\n+    [#include <pthread.h>\n+     void *g(void *d) { return NULL; }],\n+    [pthread_t t; pthread_create(&t,NULL,g,NULL);])],\n+   [],\n+   [AC_MSG_ERROR([Pthreads are required to build libgomp])])])\n+\n+# Check for functions needed.\n+AC_CHECK_FUNCS(getloadavg clock_gettime)\n+\n+# At least for glibc, clock_gettime is in librt.  But don't pull that\n+# in if it still doesn't give us the function we want.\n+if test $ac_cv_func_clock_gettime = no; then\n+  AC_CHECK_LIB(rt, clock_gettime,\n+    [LIBS=\"-lrt $LIBS\"\n+     AC_DEFINE(HAVE_CLOCK_GETTIME,\n+\t       [Define to 1 if you have the `clock_gettime' function.])])\n+fi\n+\n+# See if we support thread-local storage.\n+LIBGOMP_CHECK_TLS\n+\n+# See what sort of export controls are availible.\n+LIBGOMP_CHECK_ATTRIBUTE_VISIBILITY\n+LIBGOMP_CHECK_ATTRIBUTE_DLLEXPORT\n+LIBGOMP_CHECK_ATTRIBUTE_ALIAS\n+LIBGOMP_ENABLE_SYMVERS\n+\n+# Get target configury.\n+. ${srcdir}/configure.tgt\n+CFLAGS=\"$save_CFLAGS $XCFLAGS\"\n+\n+# Check for __sync_val_compare_and_swap, but only after the target has\n+# had a chance to set XCFLAGS.\n+LIBGOMP_CHECK_SYNC_BUILTINS\n+\n+XCFLAGS=\"$XCFLAGS$XPCFLAGS\"\n+\n+AC_SUBST(config_path)\n+AC_SUBST(XCFLAGS)\n+AC_SUBST(XLDFLAGS)\n+\n+# Cleanup and exit.\n+CFLAGS=\"$save_CFLAGS\"\n+AC_CACHE_SAVE\n+\n+if test ${multilib} = yes; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+# Set up the set of libraries that we need to link against for libgomp.\n+# Note that the GOMP_DRIVER_SPEC in gcc.c will force -pthread for -fopenmp,\n+# which will force linkage against -lpthread (or equivalent for the system).\n+# That's not 100% ideal, but about the best we can do easily.\n+if test $enable_shared = yes; then\n+  link_gomp=\"-lgomp %{static: $LIBS}\"\n+else\n+  link_gomp=\"-lgomp $LIBS\"\n+fi\n+AC_SUBST(link_gomp)\n+\n+AM_CONDITIONAL([USE_FORTRAN], [test \"$ac_cv_fc_compiler_gnu\" = yes])\n+\n+AC_CONFIG_FILES(Makefile testsuite/Makefile libgomp.spec)\n+AC_OUTPUT"}, {"sha": "f9679debc25df46bbe624fc89f86beefab28eb0c", "filename": "libgomp/configure.tgt", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.tgt?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,92 @@\n+# This is the target specific configuration file.  This is invoked by the\n+# autoconf generated configure script.  Putting it in a separate shell file\n+# lets us skip running autoconf when modifying target specific information.\n+\n+# This file switches on the shell variable ${target}, and sets the\n+# following shell variables:\n+#  config_path\t\tAn ordered list of directories to search for\n+#\t\t\tsources and headers.  This is relative to the\n+#\t\t\tconfig subdirectory of the source tree.\n+#  XCFLAGS\t\tAdd extra compile flags to use.\n+#  XLDFLAGS\t\tAdd extra link flags to use.\n+\n+# Optimize TLS usage by avoiding the overhead of dynamic allocation.\n+# This does require that the library be present during process \n+# startup, so mark the library as not to be dlopened.\n+if test $have_tls = yes && test \"$with_gnu_ld\" = \"yes\"; then\n+\tXCFLAGS=\"${XCFLAGS} -ftls-model=initial-exec\"\n+\tXLDFLAGS=\"${XLDFLAGS} -Wl,-z,nodlopen\"\n+fi\n+\n+# Since we require POSIX threads, assume a POSIX system by default.\n+config_path=\"posix\"\n+\n+# Check for futex enabled all at once.\n+if test $enable_linux_futex = yes; then\n+  case \"${target}\" in\n+\n+    alpha*-*-linux*)\n+\tconfig_path=\"linux/alpha linux posix\"\n+\t;;\n+\n+    ia64*-*-linux*)\n+\tconfig_path=\"linux/ia64 linux posix\"\n+\t;;\n+\n+    powerpc*-*-linux*)\n+\tconfig_path=\"linux/powerpc linux posix\"\n+\t;;\n+\n+    s390*-*-linux*)\n+\tconfig_path=\"linux/s390 linux posix\"\n+\t;;\n+\n+    # Note that bare i386 is not included here.  We need cmpxchg.\n+    i[456]86-*-linux*)\n+\tconfig_path=\"linux/x86 linux posix\"\n+\tif test -z \"$with_arch\"; then\n+\t  XCFLAGS=\"${XCFLAGS} -march=i486 -mtune=${target_cpu}\"\n+\tfi\n+\t;;\n+\n+    # Similar jiggery-pokery for x86_64 multilibs, except here we\n+    # can't rely on the --with-arch configure option, since that\n+    # applies to the 64-bit side.\n+    x86_64-*-linux*)\n+\tconfig_path=\"linux/x86 linux posix\"\n+\tcase \" ${CC} ${CFLAGS} \" in\n+\t  *\" -m32 \"*)\n+\t    XCFLAGS=\"${XCFLAGS} -march=i486 -mtune=i686\"\n+\t    ;;\n+\tesac\n+\t;;\n+\n+    # Note that sparcv7 and sparcv8 is not included here.  We need cas.\n+    sparcv9-*-linux* | sparc64-*-linux*)\n+\techo \"int i;\" > conftestx.c\n+\tif ${CC} ${CFLAGS} -c -o conftestx.o conftestx.c > /dev/null 2>&1; then\n+\t  config_path=\"linux/sparc linux posix\"\n+\t  case \"`/usr/bin/file conftestx.o`\" in\n+\t    *32-bit*)\n+\t      case \" ${CC} ${CFLAGS}\" in\n+\t\t*\" -mcpu=ultrasparc\"*)\n+\t\t  ;;\n+\t\t*)\n+\t\t  XCFLAGS=\"${XCFLAGS} -mcpu=v9\"\n+\t\t  ;;\n+\t      esac\n+\t      ;;\n+\t  esac\n+\tfi\n+\trm -f conftestx.c conftestx.o\n+\t;;\n+  esac\n+fi\n+\n+# Other system configury\n+case \"${target}\" in\n+\n+  *)\n+\t;;\n+\n+esac"}, {"sha": "70159ec7a6ed0691ec523815d397619884acfc71", "filename": "libgomp/critical.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fcritical.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fcritical.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fcritical.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,147 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file handles the CRITICAL construct.  */\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+\n+\n+static gomp_mutex_t default_lock;\n+\n+void\n+GOMP_critical_start (void)\n+{\n+  gomp_mutex_lock (&default_lock);\n+}\n+\n+void\n+GOMP_critical_end (void)\n+{\n+  gomp_mutex_unlock (&default_lock);\n+}\n+\n+#ifndef HAVE_SYNC_BUILTINS\n+static gomp_mutex_t create_lock_lock;\n+#endif\n+\n+void\n+GOMP_critical_name_start (void **pptr)\n+{\n+  gomp_mutex_t *plock;\n+\n+  /* If a mutex fits within the space for a pointer, and is zero initialized,\n+     then use the pointer space directly.  */\n+  if (GOMP_MUTEX_INIT_0\n+      && sizeof (gomp_mutex_t) <= sizeof (void *)\n+      && __alignof (gomp_mutex_t) <= sizeof (void *))\n+    plock = (gomp_mutex_t *)pptr;\n+\n+  /* Otherwise we have to be prepared to malloc storage.  */\n+  else\n+    {\n+      plock = *pptr;\n+\n+      if (plock == NULL)\n+\t{\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  gomp_mutex_t *nlock = gomp_malloc (sizeof (gomp_mutex_t));\n+\t  gomp_mutex_init (nlock);\n+\n+\t  plock = __sync_val_compare_and_swap (pptr, plock, nlock);\n+\t  if (plock != nlock)\n+\t    {\n+\t      gomp_mutex_destroy (nlock);\n+\t      free (nlock);\n+\t    }\n+#else\n+\t  gomp_mutex_lock (&create_lock_lock);\n+\t  plock = *pptr;\n+\t  if (plock == NULL)\n+\t    {\n+\t      plock = gomp_malloc (sizeof (gomp_mutex_t));\n+\t      gomp_mutex_init (plock);\n+\t      __sync_synchronize ();\n+\t      *pptr = plock;\n+\t    }\n+\t  gomp_mutex_unlock (&create_lock_lock);\n+#endif\n+\t}\n+    }\n+\n+  gomp_mutex_lock (plock);\n+}\n+\n+void\n+GOMP_critical_name_end (void **pptr)\n+{\n+  gomp_mutex_t *plock;\n+\n+  /* If a mutex fits within the space for a pointer, and is zero initialized,\n+     then use the pointer space directly.  */\n+  if (GOMP_MUTEX_INIT_0\n+      && sizeof (gomp_mutex_t) <= sizeof (void *)\n+      && __alignof (gomp_mutex_t) <= sizeof (void *))\n+    plock = (gomp_mutex_t *)pptr;\n+  else\n+    plock = *pptr;\n+\n+  gomp_mutex_unlock (plock);\n+}\n+\n+/* This mutex is used when atomic operations don't exist for the target\n+   in the mode requested.  The result is not globally atomic, but works so\n+   long as all parallel references are within #pragma omp atomic directives.\n+   According to responses received from omp@openmp.org, appears to be within\n+   spec.  Which makes sense, since that's how several other compilers \n+   handle this situation as well.  */\n+\n+static gomp_mutex_t atomic_lock;\n+\n+void\n+GOMP_atomic_start (void)\n+{\n+  gomp_mutex_lock (&atomic_lock);\n+}\n+\n+void\n+GOMP_atomic_end (void)\n+{\n+  gomp_mutex_unlock (&atomic_lock);\n+}\n+\n+#if !GOMP_MUTEX_INIT_0\n+static void __attribute__((constructor))\n+initialize_critical (void)\n+{\n+  gomp_mutex_init (&default_lock);\n+  gomp_mutex_init (&atomic_lock);\n+#ifndef HAVE_SYNC_BUILTINS\n+  gomp_mutex_init (&create_lock_lock);\n+#endif\n+}\n+#endif"}, {"sha": "985f9329b23f0d7a1b7b715f189d06dd161574c8", "filename": "libgomp/env.c", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,197 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file defines the OpenMP internal control variables, and arranges\n+   for them to be initialized from environment variables at startup.  */\n+\n+#include \"libgomp.h\"\n+#include \"libgomp_f.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+\n+unsigned gomp_nthreads_var = 1;\n+bool gomp_dyn_var = false;\n+bool gomp_nest_var = false;\n+enum gomp_schedule_type gomp_run_sched_var = GFS_DYNAMIC;\n+unsigned gomp_run_sched_chunk = 1;\n+\n+/* Parse the OMP_SCHEDULE environment variable.  */\n+\n+static void\n+parse_schedule (void)\n+{\n+  char *env, *end;\n+\n+  env = getenv (\"OMP_SCHEDULE\");\n+  if (env == NULL)\n+    return;\n+\n+  if (strncmp (env, \"static\", 6) == 0)\n+    {\n+      gomp_run_sched_var = GFS_STATIC;\n+      env += 6;\n+    }\n+  else if (strncmp (env, \"dynamic\", 7) == 0)\n+    {\n+      gomp_run_sched_var = GFS_DYNAMIC;\n+      env += 7;\n+    }\n+  else if (strncmp (env, \"guided\", 6) == 0)\n+    {\n+      gomp_run_sched_var = GFS_GUIDED;\n+      env += 6;\n+    }\n+  else\n+    goto unknown;\n+\n+  if (*env == '\\0')\n+    return;\n+  if (*env != ' ' && *env != ',')\n+    goto unknown;\n+  while (*env == ' ')\n+    env++;\n+  if (*env == '\\0')\n+    return;\n+  if (*env != ',')\n+    goto unknown;\n+  if (*++env == '\\0')\n+    goto invalid;\n+\n+  gomp_run_sched_chunk = strtoul (env, &end, 10);\n+  if (*end != '\\0')\n+    goto invalid;\n+  return;\n+\n+ unknown:\n+  gomp_error (\"Unknown value for environment variable OMP_SCHEDULE\");\n+  return;\n+\n+ invalid:\n+  gomp_error (\"Invalid value for chunk size in \"\n+\t      \"environment variable OMP_SCHEDULE\");\n+  gomp_run_sched_chunk = 1;\n+  return;\n+}\n+\n+/* Parse the OMP_NUM_THREADS environment varible.  Return true if one was\n+   present and it was successfully parsed.  */\n+\n+static bool\n+parse_num_threads (void)\n+{\n+  char *env, *end;\n+\n+  env = getenv (\"OMP_NUM_THREADS\");\n+  if (env == NULL)\n+    return false;\n+\n+  if (*env == '\\0')\n+    goto invalid;\n+\n+  gomp_nthreads_var = strtoul (env, &end, 10);\n+  if (*end != '\\0')\n+    goto invalid;\n+  return true;\n+\n+ invalid:\n+  gomp_error (\"Invalid value for enviroment variable OMP_NUM_THREADS\");\n+  gomp_nthreads_var = 1;\n+  return false;\n+}\n+\n+/* Parse a boolean value for environement variable NAME and store the \n+   result in VALUE.  */\n+\n+static void\n+parse_boolean (const char *name, bool *value)\n+{\n+  const char *env;\n+\n+  env = getenv (name);\n+  if (env == NULL)\n+    return;\n+\n+  if (strcmp (env, \"true\") == 0)\n+    *value = true;\n+  else if (strcmp (env, \"false\") == 0)\n+    *value = false;\n+  else\n+    gomp_error (\"Invalid value for environement variable %s\", name);\n+}\n+\n+static void __attribute__((constructor))\n+initialize_env (void)\n+{\n+  /* Do a compile time check that mkomp_h.pl did good job.  */\n+  omp_check_defines ();\n+\n+  parse_schedule ();\n+  parse_boolean (\"OMP_DYNAMIC\", &gomp_dyn_var);\n+  parse_boolean (\"OMP_NESTED\", &gomp_nest_var);\n+  if (!parse_num_threads ())\n+    gomp_init_num_threads ();\n+}\n+\n+\f\n+/* The public OpenMP API routines that access these variables.  */\n+\n+void\n+omp_set_num_threads (int n)\n+{\n+  gomp_nthreads_var = n;\n+}\n+\n+void\n+omp_set_dynamic (int val)\n+{\n+  gomp_dyn_var = val;\n+}\n+\n+int\n+omp_get_dynamic (void)\n+{\n+  return gomp_dyn_var;\n+}\n+\n+void\n+omp_set_nested (int val)\n+{\n+  gomp_nest_var = val;\n+}\n+\n+int\n+omp_get_nested (void)\n+{\n+  return gomp_nest_var;\n+}\n+\n+ialias (omp_set_dynamic)\n+ialias (omp_set_nested)\n+ialias (omp_set_num_threads)\n+ialias (omp_get_dynamic)\n+ialias (omp_get_nested)"}, {"sha": "673074fed82ddb1f053c55a5cfc6fd7f3929944a", "filename": "libgomp/error.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ferror.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,69 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains routines used to signal errors.  Most places in the\n+   OpenMP API do not make any provision for failure, so we can't just\n+   defer the decision on reporting the problem to the user; we must do it\n+   ourselves or not at all.  */\n+/* ??? Is this about what other implementations do?  Assume stderr hasn't\n+   been pointed somewhere unsafe?  */\n+\n+#include \"libgomp.h\"\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+static void\n+gomp_verror (const char *fmt, va_list list)\n+{\n+  fputs (\"\\nlibgomp: \", stderr);\n+  vfprintf (stderr, fmt, list);\n+  fputc ('\\n', stderr);\n+}\n+\n+void\n+gomp_error (const char *fmt, ...)\n+{\n+  va_list list;\n+\n+  va_start (list, fmt);\n+  gomp_verror (fmt, list);\n+  va_end (list);\n+}\n+\n+void\n+gomp_fatal (const char *fmt, ...)\n+{\n+  va_list list;\n+\n+  va_start (list, fmt);\n+  gomp_verror (fmt, list);\n+  va_end (list);\n+\n+  exit (EXIT_FAILURE);\n+}"}, {"sha": "a6f217ddbde41a53f08de140292530716cbe9358", "filename": "libgomp/fortran.c", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,224 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains Fortran wrapper routines.  */\n+\n+#include \"libgomp.h\"\n+#include \"libgomp_f.h\"\n+#include <stdlib.h>\n+\n+#ifdef HAVE_ATTRIBUTE_ALIAS\n+/* Use internal aliases if possible.  */\n+# define ialias_redirect(fn) \\\n+  extern __typeof (fn) fn __asm__ (\"gomp_ialias_\" #fn) attribute_hidden;\n+ialias_redirect (omp_init_lock)\n+ialias_redirect (omp_init_nest_lock)\n+ialias_redirect (omp_destroy_lock)\n+ialias_redirect (omp_destroy_nest_lock)\n+ialias_redirect (omp_set_lock)\n+ialias_redirect (omp_set_nest_lock)\n+ialias_redirect (omp_unset_lock)\n+ialias_redirect (omp_unset_nest_lock)\n+ialias_redirect (omp_test_lock)\n+ialias_redirect (omp_test_nest_lock)\n+ialias_redirect (omp_set_dynamic)\n+ialias_redirect (omp_set_nested)\n+ialias_redirect (omp_set_num_threads)\n+ialias_redirect (omp_get_dynamic)\n+ialias_redirect (omp_get_nested)\n+ialias_redirect (omp_in_parallel)\n+ialias_redirect (omp_get_max_threads)\n+ialias_redirect (omp_get_num_procs)\n+ialias_redirect (omp_get_num_threads)\n+ialias_redirect (omp_get_thread_num)\n+ialias_redirect (omp_get_wtick)\n+ialias_redirect (omp_get_wtime)\n+#endif        \n+\n+void\n+omp_init_lock_ (omp_lock_arg_t lock)\n+{\n+#ifndef OMP_LOCK_DIRECT\n+  omp_lock_arg (lock) = malloc (sizeof (omp_lock_t));\n+#endif\n+  omp_init_lock (omp_lock_arg (lock));\n+}\n+\n+void\n+omp_init_nest_lock_ (omp_nest_lock_arg_t lock)\n+{\n+#ifndef OMP_NEST_LOCK_DIRECT\n+  omp_nest_lock_arg (lock) = malloc (sizeof (omp_nest_lock_t));\n+#endif\n+  omp_init_nest_lock (omp_nest_lock_arg (lock));\n+}\n+\n+void\n+omp_destroy_lock_ (omp_lock_arg_t lock)\n+{\n+  omp_destroy_lock (omp_lock_arg (lock));\n+#ifndef OMP_LOCK_DIRECT\n+  free (omp_lock_arg (lock));\n+  omp_lock_arg (lock) = NULL;\n+#endif\n+}\n+\n+void\n+omp_destroy_nest_lock_ (omp_nest_lock_arg_t lock)\n+{\n+  omp_destroy_nest_lock (omp_nest_lock_arg (lock));\n+#ifndef OMP_NEST_LOCK_DIRECT\n+  free (omp_nest_lock_arg (lock));\n+  omp_nest_lock_arg (lock) = NULL;\n+#endif\n+}\n+\n+void\n+omp_set_lock_ (omp_lock_arg_t lock)\n+{\n+  omp_set_lock (omp_lock_arg (lock));\n+}\n+\n+void\n+omp_set_nest_lock_ (omp_nest_lock_arg_t lock)\n+{\n+  omp_set_nest_lock (omp_nest_lock_arg (lock));\n+}\n+\n+void\n+omp_unset_lock_ (omp_lock_arg_t lock)\n+{\n+  omp_unset_lock (omp_lock_arg (lock));\n+}\n+\n+void\n+omp_unset_nest_lock_ (omp_nest_lock_arg_t lock)\n+{\n+  omp_unset_nest_lock (omp_nest_lock_arg (lock));\n+}\n+\n+void\n+omp_set_dynamic_ (const int32_t *set)\n+{\n+  omp_set_dynamic (*set);\n+}\n+\n+void\n+omp_set_dynamic_8_ (const int64_t *set)\n+{\n+  omp_set_dynamic (*set);\n+}\n+\n+void\n+omp_set_nested_ (const int32_t *set)\n+{\n+  omp_set_nested (*set);\n+}\n+\n+void\n+omp_set_nested_8_ (const int64_t *set)\n+{\n+  omp_set_nested (*set);\n+}\n+\n+void\n+omp_set_num_threads_ (const int32_t *set)\n+{\n+  omp_set_num_threads (*set);\n+}\n+\n+void\n+omp_set_num_threads_8_ (const int64_t *set)\n+{\n+  omp_set_num_threads (*set);\n+}\n+\n+int32_t\n+omp_get_dynamic_ (void)\n+{\n+  return omp_get_dynamic ();\n+}\n+\n+int32_t\n+omp_get_nested_ (void)\n+{\n+  return omp_get_nested ();\n+}\n+\n+int32_t\n+omp_in_parallel_ (void)\n+{\n+  return omp_in_parallel ();\n+}\n+\n+int32_t\n+omp_test_lock_ (omp_lock_arg_t lock)\n+{\n+  return omp_test_lock (omp_lock_arg (lock));\n+}\n+\n+int32_t\n+omp_get_max_threads_ (void)\n+{\n+  return omp_get_max_threads ();\n+}\n+\n+int32_t\n+omp_get_num_procs_ (void)\n+{\n+  return omp_get_num_procs ();\n+}\n+\n+int32_t\n+omp_get_num_threads_ (void)\n+{\n+  return omp_get_num_threads ();\n+}\n+\n+int32_t\n+omp_get_thread_num_ (void)\n+{\n+  return omp_get_thread_num ();\n+}\n+\n+int32_t\n+omp_test_nest_lock_ (omp_nest_lock_arg_t lock)\n+{\n+  return omp_test_nest_lock (omp_nest_lock_arg (lock));\n+}\n+\n+double\n+omp_get_wtick_ (void)\n+{\n+  return omp_get_wtick ();\n+}\n+\n+double\n+omp_get_wtime_ (void)\n+{\n+  return omp_get_wtime ();\n+}"}, {"sha": "1a8a2a7d04fdd9d873377a4747db092ba13143bf", "filename": "libgomp/iter.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fiter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fiter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fiter.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,310 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains routines for managing work-share iteration, both\n+   for loops and sections.  */\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+\n+\n+/* This function implements the STATIC scheduling method.  The caller should\n+   iterate *pstart <= x < *pend.  Return zero if there are more iterations\n+   to perform; nonzero if not.  Return less than 0 if this thread had\n+   received the absolutely last iteration.  */\n+\n+int\n+gomp_iter_static_next (long *pstart, long *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  unsigned long nthreads = team ? team->nthreads : 1;\n+\n+  if (thr->ts.static_trip == -1)\n+    return -1;\n+\n+  /* Quick test for degenerate teams and orphaned constructs.  */\n+  if (nthreads == 1)\n+    {\n+      *pstart = ws->next;\n+      *pend = ws->end;\n+      thr->ts.static_trip = -1;\n+      return ws->next == ws->end;\n+    }\n+\n+  /* We interpret chunk_size zero as \"unspecified\", which means that we\n+     should break up the iterations such that each thread makes only one\n+     trip through the outer loop.  */\n+  if (ws->chunk_size == 0)\n+    {\n+      unsigned long n, q, i;\n+      unsigned long s0, e0;\n+      long s, e;\n+\n+      if (thr->ts.static_trip > 0)\n+\treturn 1;\n+\n+      /* Compute the total number of iterations.  */\n+      s = ws->incr + (ws->incr > 0 ? -1 : 1);\n+      n = (ws->end - ws->next + s) / ws->incr;\n+      i = thr->ts.team_id;\n+\n+      /* Compute the \"zero-based\" start and end points.  That is, as\n+         if the loop began at zero and incremented by one.  */\n+      q = n / nthreads;\n+      q += (q * nthreads != n);\n+      s0 = q * i;\n+      e0 = s0 + q;\n+      if (e0 > n)\n+        e0 = n;\n+\n+      /* Notice when no iterations allocated for this thread.  */\n+      if (s0 >= e0)\n+\t{\n+\t  thr->ts.static_trip = 1;\n+\t  return 1;\n+\t}\n+\n+      /* Transform these to the actual start and end numbers.  */\n+      s = (long)s0 * ws->incr + ws->next;\n+      e = (long)e0 * ws->incr + ws->next;\n+\n+      *pstart = s;\n+      *pend = e;\n+      thr->ts.static_trip = (e0 == n ? -1 : 1);\n+      return 0;\n+    }\n+  else\n+    {\n+      unsigned long n, s0, e0, i, c;\n+      long s, e;\n+\n+      /* Otherwise, each thread gets exactly chunk_size iterations\n+\t (if available) each time through the loop.  */\n+\n+      s = ws->incr + (ws->incr > 0 ? -1 : 1);\n+      n = (ws->end - ws->next + s) / ws->incr;\n+      i = thr->ts.team_id;\n+      c = ws->chunk_size;\n+\n+      /* Initial guess is a C sized chunk positioned nthreads iterations\n+\t in, offset by our thread number.  */\n+      s0 = (thr->ts.static_trip * nthreads + i) * c;\n+      e0 = s0 + c;\n+\n+      /* Detect overflow.  */\n+      if (s0 >= n)\n+\treturn 1;\n+      if (e0 > n)\n+\te0 = n;\n+\n+      /* Transform these to the actual start and end numbers.  */\n+      s = (long)s0 * ws->incr + ws->next;\n+      e = (long)e0 * ws->incr + ws->next;\n+\n+      *pstart = s;\n+      *pend = e;\n+\n+      if (e0 == n)\n+\tthr->ts.static_trip = -1;\n+      else\n+\tthr->ts.static_trip++;\n+      return 0;\n+    }\n+}\n+\n+\n+/* This function implements the DYNAMIC scheduling method.  Arguments are\n+   as for gomp_iter_static_next.  This function must be called with ws->lock\n+   held.  */\n+\n+bool\n+gomp_iter_dynamic_next_locked (long *pstart, long *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  long start, end, chunk, left;\n+\n+  start = ws->next;\n+  if (start == ws->end)\n+    return false;\n+\n+  chunk = ws->chunk_size * ws->incr;\n+  left = ws->end - start;\n+  if (ws->incr < 0)\n+    {\n+      if (chunk < left)\n+\tchunk = left;\n+    }\n+  else\n+    {\n+      if (chunk > left)\n+\tchunk = left;\n+    }\n+  end = start + chunk;\n+\n+  ws->next = end;\n+  *pstart = start;\n+  *pend = end;\n+  return true;\n+}\n+\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+/* Similar, but doesn't require the lock held, and uses compare-and-swap\n+   instead.  Note that the only memory value that changes is ws->next.  */\n+\n+bool\n+gomp_iter_dynamic_next (long *pstart, long *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  long start, end, nend, chunk, incr;\n+\n+  start = ws->next;\n+  end = ws->end;\n+  incr = ws->incr;\n+  chunk = ws->chunk_size * incr;\n+\n+  while (1)\n+    {\n+      long left = end - start;\n+      long tmp;\n+\n+      if (start == end)\n+\treturn false;\n+\n+      if (incr < 0)\n+\t{\n+\t  if (chunk < left)\n+\t    chunk = left;\n+\t}\n+      else\n+\t{\n+\t  if (chunk > left)\n+\t    chunk = left;\n+\t}\n+      nend = start + chunk;\n+\n+      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);\n+      if (__builtin_expect (tmp == start, 1))\n+\tbreak;\n+\n+      start = tmp;\n+    }\n+\n+  *pstart = start;\n+  *pend = nend;\n+  return true;\n+}\n+#endif /* HAVE_SYNC_BUILTINS */\n+\n+\n+/* This function implements the GUIDED scheduling method.  Arguments are\n+   as for gomp_iter_static_next.  This function must be called with the\n+   work share lock held.  */\n+\n+bool\n+gomp_iter_guided_next_locked (long *pstart, long *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_team *team = thr->ts.team;\n+  unsigned long nthreads = team ? team->nthreads : 1;\n+  unsigned long n, q;\n+  long start, end;\n+\n+  if (ws->next == ws->end)\n+    return false;\n+\n+  n = (ws->end - ws->next) / ws->incr;\n+  q = (n + nthreads - 1) / nthreads;\n+\n+  if (q < ws->chunk_size)\n+    q = ws->chunk_size;\n+  if (q > n)\n+    q = n;\n+\n+  start = ws->next;\n+  end = start + q * ws->incr;\n+\n+  ws->next = end;\n+  *pstart = start;\n+  *pend = end;\n+  return true;\n+}\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+/* Similar, but doesn't require the lock held, and uses compare-and-swap\n+   instead.  Note that the only memory value that changes is ws->next.  */\n+\n+bool\n+gomp_iter_guided_next (long *pstart, long *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_team *team = thr->ts.team;\n+  unsigned long nthreads = team ? team->nthreads : 1;\n+  long start, end, nend, incr;\n+  unsigned long chunk_size;\n+\n+  start = ws->next;\n+  end = ws->end;\n+  incr = ws->incr;\n+  chunk_size = ws->chunk_size;\n+\n+  while (1)\n+    {\n+      unsigned long n, q;\n+      long tmp;\n+\n+      if (start == end)\n+\treturn false;\n+\n+      n = (end - start) / ws->incr;\n+      q = (n + nthreads - 1) / nthreads;\n+\n+      if (q < chunk_size)\n+\tq = chunk_size;\n+      if (q > n)\n+\tq = n;\n+\n+      nend = start + q * incr;\n+\n+      tmp = __sync_val_compare_and_swap (&ws->next, start, nend);\n+      if (__builtin_expect (tmp == start, 1))\n+\tbreak;\n+\n+      start = tmp;\n+    }\n+\n+  *pstart = start;\n+  *pend = nend;\n+  return true;\n+}\n+#endif /* HAVE_SYNC_BUILTINS */"}, {"sha": "771fc1c47929ac58dc5abca541d04bd95faccec3", "filename": "libgomp/libgomp.h", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,328 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains data types and function declarations that are not\n+   part of the official OpenMP user interface.  There are declarations\n+   in here that are part of the GNU OpenMP ABI, in that the compiler is\n+   required to know about them and use them.\n+\n+   The convention is that the all caps prefix \"GOMP\" is used group items\n+   that are part of the external ABI, and the lower case prefix \"gomp\"\n+   is used group items that are completely private to the library.  */\n+\n+#ifndef LIBGOMP_H \n+#define LIBGOMP_H 1\n+\n+#include \"config.h\"\n+\n+#include <pthread.h>\n+#include <stdbool.h>\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility push(hidden)\n+#endif\n+\n+#include \"sem.h\"\n+#include \"mutex.h\"\n+#include \"bar.h\"\n+\n+\n+/* This structure contains the data to control one work-sharing construct,\n+   either a LOOP (FOR/DO) or a SECTIONS.  */\n+\n+enum gomp_schedule_type\n+{\n+  GFS_STATIC,\n+  GFS_DYNAMIC,\n+  GFS_GUIDED,\n+  GFS_RUNTIME\n+};\n+\n+struct gomp_work_share\n+{\n+  /* This member records the SCHEDULE clause to be used for this construct.\n+     The user specification of \"runtime\" will already have been resolved.\n+     If this is a SECTIONS construct, this value will always be DYNAMIC.  */\n+  enum gomp_schedule_type sched;\n+\n+  /* This is the chunk_size argument to the SCHEDULE clause.  */\n+  long chunk_size;\n+\n+  /* This is the iteration end point.  If this is a SECTIONS construct, \n+     this is the number of contained sections.  */\n+  long end;\n+\n+  /* This is the iteration step.  If this is a SECTIONS construct, this\n+     is always 1.  */\n+  long incr;\n+\n+  /* This lock protects the update of the following members.  */\n+  gomp_mutex_t lock;\n+\n+  union {\n+    /* This is the next iteration value to be allocated.  In the case of\n+       GFS_STATIC loops, this the iteration start point and never changes.  */\n+    long next;\n+\n+    /* This is the returned data structure for SINGLE COPYPRIVATE.  */\n+    void *copyprivate;\n+  };\n+\n+  /* This is the count of the number of threads that have exited the work\n+     share construct.  If the construct was marked nowait, they have moved on\n+     to other work; otherwise they're blocked on a barrier.  The last member\n+     of the team to exit the work share construct must deallocate it.  */\n+  unsigned threads_completed;\n+\n+  /* This is the index into the circular queue ordered_team_ids of the \n+     current thread that's allowed into the ordered reason.  */\n+  unsigned ordered_cur;\n+\n+  /* This is the number of threads that have registered themselves in\n+     the circular queue ordered_team_ids.  */\n+  unsigned ordered_num_used;\n+\n+  /* This is the team_id of the currently acknoledged owner of the ordered\n+     section, or -1u if the ordered section has not been acknowledged by\n+     any thread.  This is distinguished from the thread that is *allowed*\n+     to take the section next.  */\n+  unsigned ordered_owner;\n+\n+  /* This is a circular queue that details which threads will be allowed\n+     into the ordered region and in which order.  When a thread allocates\n+     iterations on which it is going to work, it also registers itself at\n+     the end of the array.  When a thread reaches the ordered region, it\n+     checks to see if it is the one at the head of the queue.  If not, it\n+     blocks on its RELEASE semaphore.  */\n+  unsigned ordered_team_ids[];\n+};\n+\n+/* This structure contains all of the thread-local data associated with \n+   a thread team.  This is the data that must be saved when a thread\n+   encounters a nested PARALLEL construct.  */\n+\n+struct gomp_team_state\n+{\n+  /* This is the team of which the thread is currently a member.  */\n+  struct gomp_team *team;\n+\n+  /* This is the work share construct which this thread is currently\n+     processing.  Recall that with NOWAIT, not all threads may be \n+     processing the same construct.  This value is NULL when there\n+     is no construct being processed.  */\n+  struct gomp_work_share *work_share;\n+\n+  /* This is the ID of this thread within the team.  This value is\n+     guaranteed to be between 0 and N-1, where N is the number of\n+     threads in the team.  */\n+  unsigned team_id;\n+\n+  /* The work share \"generation\" is a number that increases by one for\n+     each work share construct encountered in the dynamic flow of the\n+     program.  It is used to find the control data for the work share\n+     when encountering it for the first time.  This particular number\n+     reflects the generation of the work_share member of this struct.  */\n+  unsigned work_share_generation;\n+\n+  /* For GFS_RUNTIME loops that resolved to GFS_STATIC, this is the\n+     trip number through the loop.  So first time a particular loop\n+     is encountered this number is 0, the second time through the loop\n+     is 1, etc.  This is unused when the compiler knows in advance that\n+     the loop is statically scheduled.  */\n+  unsigned long static_trip;\n+};\n+\n+/* This structure describes a \"team\" of threads.  These are the threads\n+   that are spawned by a PARALLEL constructs, as well as the work sharing\n+   constructs that the team encounters.  */\n+\n+struct gomp_team\n+{\n+  /* This lock protects access to the following work shares data structures.  */\n+  gomp_mutex_t work_share_lock;\n+\n+  /* This is a dynamically sized array containing pointers to the control\n+     structs for all \"live\" work share constructs.  Here \"live\" means that\n+     the construct has been encountered by at least one thread, and not\n+     completed by all threads.  */\n+  struct gomp_work_share **work_shares;\n+\n+  /* The work_shares array is indexed by \"generation & generation_mask\".\n+     The mask will be 2**N - 1, where 2**N is the size of the array.  */\n+  unsigned generation_mask;\n+\n+  /* These two values define the bounds of the elements of the work_shares\n+     array that are currently in use.  */\n+  unsigned oldest_live_gen;\n+  unsigned num_live_gen;\n+\n+  /* This is the number of threads in the current team.  */\n+  unsigned nthreads;\n+\n+  /* This is the saved team state that applied to a master thread before\n+     the current thread was created.  */\n+  struct gomp_team_state prev_ts;\n+\n+  /* This barrier is used for most synchronization of the team.  */\n+  gomp_barrier_t barrier;\n+\n+  /* This semaphore should be used by the master thread instead of its\n+     \"native\" semaphore in the thread structure.  Required for nested\n+     parallels, as the master is a member of two teams.  */\n+  gomp_sem_t master_release;\n+\n+  /* This array contains pointers to the release semaphore of the threads\n+     in the team.  */\n+  gomp_sem_t *ordered_release[];\n+};\n+\n+/* This structure contains all data that is private to libgomp and is\n+   allocated per thread.  */\n+\n+struct gomp_thread\n+{\n+  /* This is the function that the thread should run upon launch.  */\n+  void (*fn) (void *data);\n+  void *data;\n+\n+  /* This is the current team state for this thread.  The ts.team member\n+     is NULL only if the thread is idle.  */\n+  struct gomp_team_state ts;\n+\n+  /* This semaphore is used for ordered loops.  */\n+  gomp_sem_t release;\n+};\n+\n+/* ... and here is that TLS data.  */\n+\n+#ifdef HAVE_TLS\n+extern __thread struct gomp_thread gomp_tls_data;\n+static inline struct gomp_thread *gomp_thread (void)\n+{\n+  return &gomp_tls_data;\n+}\n+#else\n+extern pthread_key_t gomp_tls_key;\n+static inline struct gomp_thread *gomp_thread (void)\n+{\n+  return pthread_getspecific (gomp_tls_key);\n+}\n+#endif\n+\n+/* These are the OpenMP 2.5 internal control variables described in\n+   section 2.3.  At least those that correspond to environment variables.  */\n+\n+extern unsigned gomp_nthreads_var;\n+extern bool gomp_dyn_var;\n+extern bool gomp_nest_var;\n+extern enum gomp_schedule_type gomp_run_sched_var;\n+extern unsigned gomp_run_sched_chunk;\n+\n+/* Function prototypes.  */\n+\n+/* alloc.c */\n+\n+extern void *gomp_malloc (size_t) __attribute__((malloc));\n+extern void *gomp_malloc_cleared (size_t) __attribute__((malloc));\n+extern void *gomp_realloc (void *, size_t);\n+\n+/* error.c */\n+\n+extern void gomp_error (const char *, ...)\n+\t__attribute__((format (printf, 1, 2)));\n+extern void gomp_fatal (const char *, ...)\n+\t__attribute__((noreturn, format (printf, 1, 2)));\n+\n+/* iter.c */\n+\n+extern int gomp_iter_static_next (long *, long *);\n+extern bool gomp_iter_dynamic_next_locked (long *, long *);\n+extern bool gomp_iter_guided_next_locked (long *, long *);\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+extern bool gomp_iter_dynamic_next (long *, long *);\n+extern bool gomp_iter_guided_next (long *, long *);\n+#endif\n+\n+/* ordered.c */\n+\n+extern void gomp_ordered_first (void);\n+extern void gomp_ordered_last (void);\n+extern void gomp_ordered_next (void);\n+extern void gomp_ordered_static_init (void);\n+extern void gomp_ordered_static_next (void);\n+extern void gomp_ordered_sync (void);\n+\n+/* parallel.c */\n+\n+extern unsigned gomp_resolve_num_threads (unsigned);\n+\n+/* proc.c (in config/) */\n+\n+extern void gomp_init_num_threads (void);\n+extern unsigned gomp_dynamic_max_threads (void);\n+\n+/* team.c */\n+\n+extern void gomp_team_start (void (*) (void *), void *, unsigned,\n+\t\t\t     struct gomp_work_share *);\n+extern void gomp_team_end (void);\n+\n+/* work.c */\n+\n+extern struct gomp_work_share * gomp_new_work_share (bool, unsigned);\n+extern bool gomp_work_share_start (bool);\n+extern void gomp_work_share_end (void);\n+extern void gomp_work_share_end_nowait (void);\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility pop\n+#endif\n+\n+/* Now that we're back to default visibility, include the globals.  */\n+#include \"libgomp_g.h\"\n+\n+/* Include omp.h by parts.  */\n+#include \"omp-lock.h\"\n+#define _LIBGOMP_OMP_LOCK_DEFINED 1\n+#include \"omp.h.in\"\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# define attribute_hidden __attribute__ ((visibility (\"hidden\")))\n+#else\n+# define attribute_hidden\n+#endif\n+\n+#ifdef HAVE_ATTRIBUTE_ALIAS\n+# define ialias(fn) \\\n+  extern __typeof (fn) gomp_ialias_##fn \\\n+    __attribute__ ((alias (#fn))) attribute_hidden;\n+#else\n+# define ialias(fn)\n+#endif\n+\n+#endif /* LIBGOMP_H */"}, {"sha": "9e13ef8116cf090e1c89a91220850097970e6062", "filename": "libgomp/libgomp.map", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,105 @@\n+OMP_1.0 {\n+  global:\n+\tomp_set_num_threads;\n+\tomp_get_num_threads;\n+\tomp_get_max_threads;\n+\tomp_get_thread_num;\n+\tomp_get_num_procs;\n+\tomp_in_parallel;\n+\tomp_set_dynamic;\n+\tomp_get_dynamic;\n+\tomp_set_nested;\n+\tomp_get_nested;\n+\tomp_init_lock;\n+\tomp_init_nest_lock;\n+\tomp_destroy_lock;\n+\tomp_destroy_nest_lock;\n+\tomp_set_lock;\n+\tomp_set_nest_lock;\n+\tomp_unset_lock;\n+\tomp_unset_nest_lock;\n+\tomp_test_lock;\n+\tomp_test_nest_lock;\n+\tomp_destroy_lock_;\n+\tomp_destroy_nest_lock_;\n+\tomp_get_dynamic_;\n+\tomp_get_max_threads_;\n+\tomp_get_nested_;\n+\tomp_get_num_procs_;\n+\tomp_get_num_threads_;\n+\tomp_get_thread_num_;\n+\tomp_in_parallel_;\n+\tomp_init_lock_;\n+\tomp_init_nest_lock_;\n+\tomp_set_dynamic_;\n+\tomp_set_dynamic_8_;\n+\tomp_set_lock_;\n+\tomp_set_nest_lock_;\n+\tomp_set_nested_;\n+\tomp_set_nested_8_;\n+\tomp_set_num_threads_;\n+\tomp_set_num_threads_8_;\n+\tomp_test_lock_;\n+\tomp_test_nest_lock_;\n+\tomp_unset_lock_;\n+\tomp_unset_nest_lock_;\n+  local:\n+\t*;\n+};\n+\n+OMP_2.0 {\n+  global:\n+\tomp_get_wtick;\n+\tomp_get_wtime;\n+\tomp_get_wtick_;\n+\tomp_get_wtime_;\n+} OMP_1.0;\n+\n+GOMP_1.0 {\n+  global:\n+\tGOMP_atomic_end;\n+\tGOMP_atomic_start;\n+\tGOMP_barrier;\n+\tGOMP_critical_end;\n+\tGOMP_critical_name_end;\n+\tGOMP_critical_name_start;\n+\tGOMP_critical_start;\n+\tGOMP_loop_dynamic_next;\n+\tGOMP_loop_dynamic_start;\n+\tGOMP_loop_end;\n+\tGOMP_loop_end_nowait;\n+\tGOMP_loop_guided_next;\n+\tGOMP_loop_guided_start;\n+\tGOMP_loop_ordered_dynamic_first;\n+\tGOMP_loop_ordered_dynamic_next;\n+\tGOMP_loop_ordered_dynamic_start;\n+\tGOMP_loop_ordered_guided_first;\n+\tGOMP_loop_ordered_guided_next;\n+\tGOMP_loop_ordered_guided_start;\n+\tGOMP_loop_ordered_runtime_first;\n+\tGOMP_loop_ordered_runtime_next;\n+\tGOMP_loop_ordered_runtime_start;\n+\tGOMP_loop_ordered_static_first;\n+\tGOMP_loop_ordered_static_next;\n+\tGOMP_loop_ordered_static_start;\n+\tGOMP_loop_runtime_next;\n+\tGOMP_loop_runtime_start;\n+\tGOMP_loop_static_next;\n+\tGOMP_loop_static_start;\n+\tGOMP_ordered_end;\n+\tGOMP_ordered_start;\n+\tGOMP_parallel_end;\n+\tGOMP_parallel_loop_dynamic_start;\n+\tGOMP_parallel_loop_guided_start;\n+\tGOMP_parallel_loop_runtime_start;\n+\tGOMP_parallel_loop_static_start;\n+\tGOMP_parallel_sections_start;\n+\tGOMP_parallel_start;\n+\tGOMP_sections_end;\n+\tGOMP_sections_end_nowait;\n+\tGOMP_sections_next;\n+\tGOMP_sections_start;\n+\tGOMP_single_copy_end;\n+\tGOMP_single_copy_start;\n+\tGOMP_single_start;\n+};"}, {"sha": "b7319f33a534bc99370eb5e5bfbbbaada59db08b", "filename": "libgomp/libgomp.spec.in", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.spec.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,3 @@\n+# This spec file is read by gcc when linking.  It is used to specify the\n+# standard libraries we need in order to link with -fopenmp.\n+*link_gomp: @link_gomp@"}, {"sha": "c49c8f68e527ea0513474564dfc4dda76a1e968e", "filename": "libgomp/libgomp_f.h.in", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp_f.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp_f.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_f.h.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,74 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains prototypes of functions in the external ABI.\n+   This file is included by files in the testsuite.  */\n+\n+#ifndef LIBGOMP_F_H\n+#define LIBGOMP_F_H 1\n+\n+#include \"libgomp.h\"\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+#if HAVE_INTTYPES_H\n+#include <inttypes.h>\n+#endif\n+\n+#if (OMP_LOCK_SIZE == OMP_LOCK_KIND) \\\n+    && (OMP_LOCK_ALIGN <= OMP_LOCK_SIZE)\n+# define OMP_LOCK_DIRECT\n+typedef omp_lock_t *omp_lock_arg_t;\n+# define omp_lock_arg(arg) (arg)\n+#else\n+typedef union { omp_lock_t *lock; uint64_t u; } *omp_lock_arg_t;\n+# define omp_lock_arg(arg) ((arg)->lock)\n+# endif\n+\n+#if (OMP_NEST_LOCK_SIZE == OMP_NEST_LOCK_KIND) \\\n+    && (OMP_NEST_LOCK_ALIGN <= OMP_NEST_LOCK_SIZE)\n+# define OMP_NEST_LOCK_DIRECT\n+typedef omp_nest_lock_t *omp_nest_lock_arg_t;\n+# define omp_nest_lock_arg(arg) (arg)\n+#else\n+typedef union { omp_nest_lock_t *lock; uint64_t u; } *omp_nest_lock_arg_t;\n+# define omp_nest_lock_arg(arg) ((arg)->lock)\n+# endif\n+\n+static inline void\n+omp_check_defines (void)\n+{\n+  char test[(OMP_LOCK_SIZE != sizeof (omp_lock_t)\n+\t     || OMP_LOCK_ALIGN != __alignof (omp_lock_t)\n+\t     || OMP_NEST_LOCK_SIZE != sizeof (omp_nest_lock_t)\n+\t     || OMP_NEST_LOCK_ALIGN != __alignof (omp_nest_lock_t)\n+\t     || OMP_LOCK_KIND != sizeof (*(omp_lock_arg_t) 0)\n+\t     || OMP_NEST_LOCK_KIND != sizeof (*(omp_nest_lock_arg_t) 0))\n+\t    ? -1 : 1] __attribute__ ((__unused__));\n+}\n+\n+#endif /* LIBGOMP_F_H */"}, {"sha": "52ecafdcf0fdcbe5201a272bb74907de9c234faa", "filename": "libgomp/libgomp_g.h", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,111 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains prototypes of functions in the external ABI.\n+   This file is included by files in the testsuite.  */\n+\n+#ifndef LIBGOMP_G_H \n+#define LIBGOMP_G_H 1\n+\n+#include <stdbool.h>\n+\n+/* barrier.c */\n+\n+extern void GOMP_barrier (void);\n+\n+/* critical.c */\n+\n+extern void GOMP_critical_start (void);\n+extern void GOMP_critical_end (void);\n+extern void GOMP_critical_name_start (void **);\n+extern void GOMP_critical_name_end (void **);\n+extern void GOMP_atomic_start (void);\n+extern void GOMP_atomic_end (void);\n+\n+/* loop.c */\n+\n+extern bool GOMP_loop_static_start (long, long, long, long, long *, long *);\n+extern bool GOMP_loop_dynamic_start (long, long, long, long, long *, long *);\n+extern bool GOMP_loop_guided_start (long, long, long, long, long *, long *);\n+extern bool GOMP_loop_runtime_start (long, long, long, long *, long *);\n+\n+extern bool GOMP_loop_ordered_static_start (long, long, long, long,\n+\t\t\t\t\t    long *, long *);\n+extern bool GOMP_loop_ordered_dynamic_start (long, long, long, long,\n+\t\t\t\t\t     long *, long *);\n+extern bool GOMP_loop_ordered_guided_start (long, long, long, long,\n+\t\t\t\t\t    long *, long *);\n+extern bool GOMP_loop_ordered_runtime_start (long, long, long, long *, long *);\n+\n+extern bool GOMP_loop_static_next (long *, long *);\n+extern bool GOMP_loop_dynamic_next (long *, long *);\n+extern bool GOMP_loop_guided_next (long *, long *);\n+extern bool GOMP_loop_runtime_next (long *, long *);\n+\n+extern bool GOMP_loop_ordered_static_next (long *, long *);\n+extern bool GOMP_loop_ordered_dynamic_next (long *, long *);\n+extern bool GOMP_loop_ordered_guided_next (long *, long *);\n+extern bool GOMP_loop_ordered_runtime_next (long *, long *);\n+\n+extern void GOMP_parallel_loop_static_start (void (*)(void *), void *,\n+\t\t\t\t\t     unsigned, long, long, long, long);\n+extern void GOMP_parallel_loop_dynamic_start (void (*)(void *), void *,\n+\t\t\t\t\t     unsigned, long, long, long, long);\n+extern void GOMP_parallel_loop_guided_start (void (*)(void *), void *,\n+\t\t\t\t\t     unsigned, long, long, long, long);\n+extern void GOMP_parallel_loop_runtime_start (void (*)(void *), void *,\n+\t\t\t\t\t      unsigned, long, long, long);\n+\n+extern void GOMP_loop_end (void);\n+extern void GOMP_loop_end_nowait (void);\n+\n+/* ordered.c */\n+\n+extern void GOMP_ordered_start (void);\n+extern void GOMP_ordered_end (void);\n+\n+/* parallel.c */\n+\n+extern void GOMP_parallel_start (void (*) (void *), void *, unsigned);\n+extern void GOMP_parallel_end (void);\n+\n+/* sections.c */\n+\n+extern unsigned GOMP_sections_start (unsigned);\n+extern unsigned GOMP_sections_next (void);\n+extern void GOMP_parallel_sections_start (void (*) (void *), void *,\n+\t\t\t\t\t  unsigned, unsigned);\n+extern void GOMP_sections_end (void);\n+extern void GOMP_sections_end_nowait (void);\n+\n+/* single.c */\n+\n+extern bool GOMP_single_start (void);\n+extern void *GOMP_single_copy_start (void);\n+extern void GOMP_single_copy_end (void *);\n+\n+#endif /* LIBGOMP_G_H */"}, {"sha": "3d1b1efaf31375c6b36993c48d54e8ceae40c410", "filename": "libgomp/loop.c", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,555 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file handles the LOOP (FOR/DO) construct.  */\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+\n+\n+/* Initialize the given work share construct from the given arguments.  */\n+\n+static inline void\n+gomp_loop_init (struct gomp_work_share *ws, unsigned long start,\n+\t\tunsigned long end, unsigned long incr,\n+\t\tenum gomp_schedule_type sched, unsigned long chunk_size)\n+{\n+  ws->sched = sched;\n+  ws->chunk_size = chunk_size;\n+  ws->end = end;\n+  ws->incr = incr;\n+  ws->next = start;\n+}\n+\n+/* The *_start routines are called when first encountering a loop construct\n+   that is not bound directly to a parallel construct.  The first thread \n+   that arrives will create the work-share construct; subsequent threads\n+   will see the construct exists and allocate work from it.\n+\n+   START, END, INCR are the bounds of the loop; due to the restrictions of\n+   OpenMP, these values must be the same in every thread.  This is not \n+   verified (nor is it entirely verifiable, since START is not necessarily\n+   retained intact in the work-share data structure).  CHUNK_SIZE is the\n+   scheduling parameter; again this must be identical in all threads.\n+\n+   Returns true if there's any work for this thread to perform.  If so,\n+   *ISTART and *IEND are filled with the bounds of the iteration block\n+   allocated to this thread.  Returns false if all work was assigned to\n+   other threads prior to this thread's arrival.  */\n+\n+static bool\n+gomp_loop_static_start (long start, long end, long incr, long chunk_size,\n+\t\t\tlong *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  if (gomp_work_share_start (false))\n+    gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t    GFS_STATIC, chunk_size);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return !gomp_iter_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_dynamic_start (long start, long end, long incr, long chunk_size,\n+\t\t\t long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t    GFS_DYNAMIC, chunk_size);\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_dynamic_next (istart, iend);\n+#else\n+  ret = gomp_iter_dynamic_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_guided_start (long start, long end, long incr, long chunk_size,\n+\t\t\tlong *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t    GFS_GUIDED, chunk_size);\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_guided_next (istart, iend);\n+#else\n+  ret = gomp_iter_guided_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_runtime_start (long start, long end, long incr,\n+\t\t\t long *istart, long *iend)\n+{\n+  switch (gomp_run_sched_var)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_static_start (start, end, incr, gomp_run_sched_chunk,\n+\t\t\t\t     istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_dynamic_start (start, end, incr, gomp_run_sched_chunk,\n+\t\t\t\t      istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_guided_start (start, end, incr, gomp_run_sched_chunk,\n+\t\t\t\t     istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* The *_ordered_*_start routines are similar.  The only difference is that\n+   this work-share construct is initialized to expect an ORDERED section.  */\n+\n+static bool\n+gomp_loop_ordered_static_start (long start, long end, long incr,\n+\t\t\t\tlong chunk_size, long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  if (start == end)\n+    return false;\n+\n+  if (gomp_work_share_start (true))\n+    {\n+      gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t      GFS_STATIC, chunk_size);\n+      gomp_ordered_static_init ();\n+    }\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return !gomp_iter_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_ordered_dynamic_start (long start, long end, long incr,\n+\t\t\t\t long chunk_size, long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (true))\n+    gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t    GFS_DYNAMIC, chunk_size);\n+\n+  ret = gomp_iter_dynamic_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_first ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_ordered_guided_start (long start, long end, long incr,\n+\t\t\t\tlong chunk_size, long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (true))\n+    gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t    GFS_GUIDED, chunk_size);\n+\n+  ret = gomp_iter_guided_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_first ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_ordered_runtime_start (long start, long end, long incr,\n+\t\t\t\t long *istart, long *iend)\n+{\n+  switch (gomp_run_sched_var)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_ordered_static_start (start, end, incr,\n+\t\t\t\t\t     gomp_run_sched_chunk,\n+\t\t\t\t\t     istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_ordered_dynamic_start (start, end, incr,\n+\t\t\t\t\t      gomp_run_sched_chunk,\n+\t\t\t\t\t      istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_ordered_guided_start (start, end, incr,\n+\t\t\t\t\t     gomp_run_sched_chunk,\n+\t\t\t\t\t     istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* The *_next routines are called when the thread completes processing of \n+   the iteration block currently assigned to it.  If the work-share \n+   construct is bound directly to a parallel construct, then the iteration\n+   bounds may have been set up before the parallel.  In which case, this\n+   may be the first iteration for the thread.\n+\n+   Returns true if there is work remaining to be performed; *ISTART and\n+   *IEND are filled with a new iteration block.  Returns false if all work\n+   has been assigned.  */\n+\n+static bool\n+gomp_loop_static_next (long *istart, long *iend)\n+{\n+  return !gomp_iter_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_dynamic_next (long *istart, long *iend)\n+{\n+  bool ret;\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  ret = gomp_iter_dynamic_next (istart, iend);\n+#else\n+  struct gomp_thread *thr = gomp_thread ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_dynamic_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_guided_next (long *istart, long *iend)\n+{\n+  bool ret;\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  ret = gomp_iter_guided_next (istart, iend);\n+#else\n+  struct gomp_thread *thr = gomp_thread ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_guided_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_runtime_next (long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  \n+  switch (thr->ts.work_share->sched)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_static_next (istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_dynamic_next (istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_guided_next (istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* The *_ordered_*_next routines are called when the thread completes\n+   processing of the iteration block currently assigned to it.\n+\n+   Returns true if there is work remaining to be performed; *ISTART and\n+   *IEND are filled with a new iteration block.  Returns false if all work\n+   has been assigned.  */\n+\n+static bool\n+gomp_loop_ordered_static_next (long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  int test;\n+\n+  gomp_ordered_sync ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  test = gomp_iter_static_next (istart, iend);\n+  if (test >= 0)\n+    gomp_ordered_static_next ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return test == 0;\n+}\n+\n+static bool\n+gomp_loop_ordered_dynamic_next (long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  gomp_ordered_sync ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_dynamic_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_next ();\n+  else\n+    gomp_ordered_last ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_ordered_guided_next (long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  gomp_ordered_sync ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_guided_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_next ();\n+  else\n+    gomp_ordered_last ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_ordered_runtime_next (long *istart, long *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  \n+  switch (thr->ts.work_share->sched)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_ordered_static_next (istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_ordered_dynamic_next (istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_ordered_guided_next (istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* The GOMP_parallel_loop_* routines pre-initialize a work-share construct\n+   to avoid one synchronization once we get into the loop.  */\n+\n+static void\n+gomp_parallel_loop_start (void (*fn) (void *), void *data,\n+\t\t\t  unsigned num_threads, long start, long end,\n+\t\t\t  long incr, enum gomp_schedule_type sched,\n+\t\t\t  long chunk_size)\n+{\n+  struct gomp_work_share *ws;\n+\n+  num_threads = gomp_resolve_num_threads (num_threads);\n+  ws = gomp_new_work_share (false, num_threads);\n+  gomp_loop_init (ws, start, end, incr, sched, chunk_size);\n+  gomp_team_start (fn, data, num_threads, ws);\n+}\n+\n+void\n+GOMP_parallel_loop_static_start (void (*fn) (void *), void *data,\n+\t\t\t\t unsigned num_threads, long start, long end,\n+\t\t\t\t long incr, long chunk_size)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_STATIC, chunk_size);\n+}\n+\n+void\n+GOMP_parallel_loop_dynamic_start (void (*fn) (void *), void *data,\n+\t\t\t\t  unsigned num_threads, long start, long end,\n+\t\t\t\t  long incr, long chunk_size)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_DYNAMIC, chunk_size);\n+}\n+\n+void\n+GOMP_parallel_loop_guided_start (void (*fn) (void *), void *data,\n+\t\t\t\t unsigned num_threads, long start, long end,\n+\t\t\t\t long incr, long chunk_size)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    GFS_GUIDED, chunk_size);\n+}\n+\n+void\n+GOMP_parallel_loop_runtime_start (void (*fn) (void *), void *data,\n+\t\t\t\t  unsigned num_threads, long start, long end,\n+\t\t\t\t  long incr)\n+{\n+  gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n+\t\t\t    gomp_run_sched_var, gomp_run_sched_chunk);\n+}\n+\n+/* The GOMP_loop_end* routines are called after the thread is told that\n+   all loop iterations are complete.  This first version synchronizes\n+   all threads; the nowait version does not.  */\n+\n+void\n+GOMP_loop_end (void)\n+{\n+  gomp_work_share_end ();\n+}\n+\n+void\n+GOMP_loop_end_nowait (void)\n+{\n+  gomp_work_share_end_nowait ();\n+}\n+\n+\n+/* We use static functions above so that we're sure that the \"runtime\"\n+   function can defer to the proper routine without interposition.  We\n+   export the static function with a strong alias when possible, or with\n+   a wrapper function otherwise.  */\n+\n+#ifdef HAVE_ATTRIBUTE_ALIAS\n+extern __typeof(gomp_loop_static_start) GOMP_loop_static_start\n+\t__attribute__((alias (\"gomp_loop_static_start\")));\n+extern __typeof(gomp_loop_dynamic_start) GOMP_loop_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_dynamic_start\")));\n+extern __typeof(gomp_loop_guided_start) GOMP_loop_guided_start\n+\t__attribute__((alias (\"gomp_loop_guided_start\")));\n+\n+extern __typeof(gomp_loop_ordered_static_start) GOMP_loop_ordered_static_start\n+\t__attribute__((alias (\"gomp_loop_ordered_static_start\")));\n+extern __typeof(gomp_loop_ordered_dynamic_start) GOMP_loop_ordered_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_ordered_dynamic_start\")));\n+extern __typeof(gomp_loop_ordered_guided_start) GOMP_loop_ordered_guided_start\n+\t__attribute__((alias (\"gomp_loop_ordered_guided_start\")));\n+\n+extern __typeof(gomp_loop_static_next) GOMP_loop_static_next\n+\t__attribute__((alias (\"gomp_loop_static_next\")));\n+extern __typeof(gomp_loop_dynamic_next) GOMP_loop_dynamic_next\n+\t__attribute__((alias (\"gomp_loop_dynamic_next\")));\n+extern __typeof(gomp_loop_guided_next) GOMP_loop_guided_next\n+\t__attribute__((alias (\"gomp_loop_guided_next\")));\n+\n+extern __typeof(gomp_loop_ordered_static_next) GOMP_loop_ordered_static_next\n+\t__attribute__((alias (\"gomp_loop_ordered_static_next\")));\n+extern __typeof(gomp_loop_ordered_dynamic_next) GOMP_loop_ordered_dynamic_next\n+\t__attribute__((alias (\"gomp_loop_ordered_dynamic_next\")));\n+extern __typeof(gomp_loop_ordered_guided_next) GOMP_loop_ordered_guided_next\n+\t__attribute__((alias (\"gomp_loop_ordered_guided_next\")));\n+#else\n+bool\n+GOMP_loop_static_start (long start, long end, long incr, long chunk_size,\n+\t\t\tlong *istart, long *iend)\n+{\n+  return gomp_loop_static_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n+bool\n+GOMP_loop_dynamic_start (long start, long end, long incr, long chunk_size,\n+\t\t\t long *istart, long *iend)\n+{\n+  return gomp_loop_dynamic_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n+bool\n+GOMP_loop_guided_start (long start, long end, long incr, long chunk_size,\n+\t\t\tlong *istart, long *iend)\n+{\n+  return gomp_loop_guided_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ordered_static_start (long start, long end, long incr,\n+\t\t\t\tlong chunk_size, long *istart, long *iend)\n+{\n+  return gomp_loop_ordered_static_start (start, end, incr, chunk_size,\n+\t\t\t\t\t istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ordered_dynamic_start (long start, long end, long incr,\n+\t\t\t\t long chunk_size, long *istart, long *iend)\n+{\n+  return gomp_loop_ordered_dynamic_start (start, end, incr, chunk_size,\n+\t\t\t\t\t  istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ordered_guided_start (long start, long end, long incr,\n+\t\t\t\tlong chunk_size, long *istart, long *iend)\n+{\n+  return gomp_loop_ordered_guided_start (start, end, incr, chunk_size,\n+\t\t\t\t\t istart, iend);\n+}\n+\n+bool\n+GOMP_loop_static_next (long *istart, long *iend)\n+{\n+  return gomp_loop_static_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_dynamic_next (long *istart, long *iend)\n+{\n+  return gomp_loop_dynamic_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_guided_next (long *istart, long *iend)\n+{\n+  return gomp_loop_guided_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ordered_static_next (long *istart, long *iend)\n+{\n+  return gomp_loop_ordered_static_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ordered_dynamic_next (long *istart, long *iend)\n+{\n+  return gomp_loop_ordered_dynamic_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ordered_guided_next (long *istart, long *iend)\n+{\n+  return gomp_loop_ordered_guided_next (istart, iend);\n+}\n+#endif"}, {"sha": "4002fa0a4a39d7bbb7d38fd97589a0cd858f5402", "filename": "libgomp/mkomp_h.pl", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fmkomp_h.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fmkomp_h.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fmkomp_h.pl?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,122 @@\n+#!/usr/bin/perl -w\n+#  Copyright (C) 2005 Free Software Foundation, Inc.\n+#  Contributed by Richard Henderson <rth@redhat.com>.\n+#\n+#  This file is part of the GNU OpenMP Library (libgomp).\n+#\n+#  Libgomp is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU Lesser General Public License as published by\n+#  the Free Software Foundation; either version 2.1 of the License, or\n+#  (at your option) any later version.\n+#\n+#  Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+#  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+#  more details.\n+#\n+#  You should have received a copy of the GNU Lesser General Public License \n+#  along with libgomp; see the file COPYING.LIB.  If not, write to the\n+#  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+#  MA 02110-1301, USA.\n+#\n+#  As a special exception, if you link this library with other files, some\n+#  of which are compiled with GCC, to produce an executable, this library\n+#  does not by itself cause the resulting executable to be covered by the\n+#  GNU General Public License.  This exception does not however invalidate\n+#  any other reasons why the executable file might be covered by the GNU\n+#  General Public License.\n+\n+# This file fills in the blanks for omp.h.in, computing the size and\n+# alignment of the lock types that we export.  We do this to avoid\n+# polluting the namespace with e.g. pthreads declarations.\n+\n+$COMPILE = $ARGV[0];\n+$INFILE = $ARGV[1];\n+$OUTFILE = $ARGV[2];\n+\n+$HEADER = \"#include \\\"omp-lock.h\\\"\\n\";\n+\n+# configure might put libtool specific options into $COMPILE.\n+$COMPILE =~ s/ -Wc,/ /g;\n+\n+# Close stderr in order to discard compiler errors.  Which we expect apleanty.\n+close STDERR;\n+\n+# Return true if the boolean expression evaluates true at compile-time.\n+sub compile_test {\n+\tmy $expr = shift;\n+\n+\topen GCC, \"|$COMPILE -fsyntax-only -xc -\";\n+\tprint GCC $HEADER;\n+\tprint GCC \"char test[($expr) ? 1 : -1];\\n\";\n+\treturn close GCC;\n+}\n+\n+# Return a number guaranteed to be larger than the integer epression.\n+sub upper_bound {\n+\tuse integer;\n+\tmy $expr = shift;\n+\tmy $max = 9;\n+\n+\twhile (compile_test(\"($expr) >= $max\")) {\n+\t\t$max = $max * 2;\n+\t}\n+\n+\treturn $max;\n+}\n+\n+# Return an exact number for the integer expression.\n+sub binary_search {\n+\tuse integer;\n+\tmy $expr = shift;\n+\tmy $low = 1;\n+\tmy $high = upper_bound($expr);\n+\n+\twhile ($low < $high) {\n+\t\tmy $mid = ($high + $low + 1) / 2;\n+\t\tif (compile_test(\"($expr) >= $mid\")) {\n+\t\t\t$low = $mid;\n+\t\t} else {\n+\t\t\t$high = $mid - 1;\n+\t\t}\n+\t}\n+\n+\treturn $low;\n+}\n+\n+# Apply OP to TYPE, where OP is either sizeof or __alignof.\n+sub resolve {\n+\tmy $op = shift;\n+\tmy $type = shift;\n+\n+\treturn binary_search(\"$op($type)\");\n+}\n+\n+# Find all the constants we need.\n+$sizeof_omp_lock_t = resolve (\"sizeof\", \"omp_lock_t\");\n+$alignof_omp_lock_t = resolve (\"__alignof\", \"omp_lock_t\");\n+$sizeof_omp_nest_lock_t = resolve (\"sizeof\", \"omp_nest_lock_t\");\n+$alignof_omp_nest_lock_t = resolve (\"__alignof\", \"omp_nest_lock_t\");\n+$omp_lock_kind = $sizeof_omp_lock_t;\n+$omp_nest_lock_kind = $sizeof_omp_nest_lock_t;\n+if ($sizeof_omp_lock_t >= 8 || $alignof_omp_lock_t > $sizeof_omp_lock_t) {\n+\t$omp_lock_kind = 8;\n+}\n+if ($sizeof_omp_nest_lock_t >= 8 || $alignof_omp_nest_lock_t > $sizeof_omp_nest_lock_t) {\n+\t$omp_nest_lock_kind = 8;\n+}\n+\n+# Edit the input template into the output.\n+open IN, \"<\", $INFILE;\n+open OUT, \">\", $OUTFILE;\n+while (<IN>) {\n+\ts/OMP_LOCK_SIZE/$sizeof_omp_lock_t/o;\n+\ts/OMP_LOCK_ALIGN/$alignof_omp_lock_t/o;\n+\ts/OMP_NEST_LOCK_SIZE/$sizeof_omp_nest_lock_t/o;\n+\ts/OMP_NEST_LOCK_ALIGN/$alignof_omp_nest_lock_t/o;\n+\ts/OMP_LOCK_KIND/$omp_lock_kind/o;\n+\ts/OMP_NEST_LOCK_KIND/$omp_nest_lock_kind/o;\n+\tprint OUT;\n+}\n+\n+close OUT;"}, {"sha": "5120377e627272864dc9adccfbf918dcfa5d8f2c", "filename": "libgomp/omp.h.in", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,85 @@\n+/* Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#ifndef OMP_H\n+#define OMP_H 1\n+\n+#ifndef _LIBGOMP_OMP_LOCK_DEFINED\n+#define _LIBGOMP_OMP_LOCK_DEFINED 1\n+/* These two structures get edited by the libgomp build process to \n+   reflect the shape of the two types.  Their internals are private\n+   to the library.  */\n+\n+typedef struct\n+{\n+  unsigned char _x[OMP_LOCK_SIZE] __attribute__((__aligned__(OMP_LOCK_ALIGN)));\n+} omp_lock_t;\n+\n+typedef struct\n+{\n+  unsigned char _x[OMP_NEST_LOCK_SIZE] __attribute__((__aligned__(OMP_NEST_LOCK_ALIGN)));\n+} omp_nest_lock_t;\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+extern void omp_set_num_threads (int);\n+extern int omp_get_num_threads (void);\n+extern int omp_get_max_threads (void);\n+extern int omp_get_thread_num (void);\n+extern int omp_get_num_procs (void);\n+\n+extern int omp_in_parallel (void);\n+\n+extern void omp_set_dynamic (int);\n+extern int omp_get_dynamic (void);\n+\n+extern void omp_set_nested (int);\n+extern int omp_get_nested (void);\n+\n+extern void omp_init_lock (omp_lock_t *);\n+extern void omp_destroy_lock (omp_lock_t *);\n+extern void omp_set_lock (omp_lock_t *);\n+extern void omp_unset_lock (omp_lock_t *);\n+extern int omp_test_lock (omp_lock_t *);\n+\n+extern void omp_init_nest_lock (omp_nest_lock_t *);\n+extern void omp_destroy_nest_lock (omp_nest_lock_t *);\n+extern void omp_set_nest_lock (omp_nest_lock_t *);\n+extern void omp_unset_nest_lock (omp_nest_lock_t *);\n+extern int omp_test_nest_lock (omp_nest_lock_t *);\n+\n+extern double omp_get_wtime (void);\n+extern double omp_get_wtick (void);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* OMP_H */"}, {"sha": "da5ee993c383ebc0ce561bb3a973b89db5633963", "filename": "libgomp/omp_lib.f90.in", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,199 @@\n+!  Copyright (C) 2005 Free Software Foundation, Inc.\n+!  Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+!  This file is part of the GNU OpenMP Library (libgomp).\n+\n+!  Libgomp is free software; you can redistribute it and/or modify it\n+!  under the terms of the GNU Lesser General Public License as published by\n+!  the Free Software Foundation; either version 2.1 of the License, or\n+!  (at your option) any later version.\n+\n+!  Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+!  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+!  more details.\n+\n+!  You should have received a copy of the GNU Lesser General Public License\n+!  along with libgomp; see the file COPYING.LIB.  If not, write to the\n+!  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+!  MA 02110-1301, USA.  */\n+\n+!  As a special exception, if you link this library with other files, some\n+!  of which are compiled with GCC, to produce an executable, this library\n+!  does not by itself cause the resulting executable to be covered by the\n+!  GNU General Public License.  This exception does not however invalidate\n+!  any other reasons why the executable file might be covered by the GNU\n+!  General Public License.\n+\n+      module omp_lib_kinds\n+        integer, parameter :: omp_integer_kind = 4\n+        integer, parameter :: omp_logical_kind = 4\n+        integer, parameter :: omp_lock_kind = OMP_LOCK_KIND\n+        integer, parameter :: omp_nest_lock_kind = OMP_NEST_LOCK_KIND\n+      end module\n+\n+      module omp_lib\n+        use omp_lib_kinds\n+        integer, parameter :: openmp_version = 200505\n+\n+        interface\n+          subroutine omp_init_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_lock_kind), intent (out) :: lock\n+          end subroutine omp_init_lock\n+        end interface\n+\n+        interface\n+          subroutine omp_init_nest_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_nest_lock_kind), intent (out) :: lock\n+          end subroutine omp_init_nest_lock\n+        end interface\n+\n+        interface\n+          subroutine omp_destroy_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_lock_kind), intent (inout) :: lock\n+          end subroutine omp_destroy_lock\n+        end interface\n+\n+        interface\n+          subroutine omp_destroy_nest_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_nest_lock_kind), intent (inout) :: lock\n+          end subroutine omp_destroy_nest_lock\n+        end interface\n+\n+        interface\n+          subroutine omp_set_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_lock_kind), intent (inout) :: lock\n+          end subroutine omp_set_lock\n+        end interface\n+\n+        interface\n+          subroutine omp_set_nest_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_nest_lock_kind), intent (inout) :: lock\n+          end subroutine omp_set_nest_lock\n+        end interface\n+\n+        interface\n+          subroutine omp_unset_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_lock_kind), intent (inout) :: lock\n+          end subroutine omp_unset_lock\n+        end interface\n+\n+        interface\n+          subroutine omp_unset_nest_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_nest_lock_kind), intent (inout) :: lock\n+          end subroutine omp_unset_nest_lock\n+        end interface\n+\n+        interface omp_set_dynamic\n+          subroutine omp_set_dynamic (set)\n+            logical (4), intent (in) :: set\n+          end subroutine omp_set_dynamic\n+          subroutine omp_set_dynamic_8 (set)\n+            logical (8), intent (in) :: set\n+          end subroutine omp_set_dynamic_8\n+        end interface\n+\n+        interface omp_set_nested\n+          subroutine omp_set_nested (set)\n+            logical (4), intent (in) :: set\n+          end subroutine omp_set_nested\n+          subroutine omp_set_nested_8 (set)\n+            logical (8), intent (in) :: set\n+          end subroutine omp_set_nested_8\n+        end interface\n+\n+        interface omp_set_num_threads\n+          subroutine omp_set_num_threads (set)\n+            integer (4), intent (in) :: set\n+          end subroutine omp_set_num_threads\n+          subroutine omp_set_num_threads_8 (set)\n+            integer (8), intent (in) :: set\n+          end subroutine omp_set_num_threads_8\n+        end interface\n+\n+        interface\n+          function omp_get_dynamic ()\n+            use omp_lib_kinds\n+            logical (omp_logical_kind) :: omp_get_dynamic\n+          end function omp_get_dynamic\n+        end interface\n+\n+        interface\n+          function omp_get_nested ()\n+            use omp_lib_kinds\n+            logical (omp_logical_kind) :: omp_get_nested\n+          end function omp_get_nested\n+        end interface\n+\n+        interface\n+          function omp_in_parallel ()\n+            use omp_lib_kinds\n+            logical (omp_logical_kind) :: omp_in_parallel\n+          end function omp_in_parallel\n+        end interface\n+\n+        interface\n+          function omp_test_lock (lock)\n+            use omp_lib_kinds\n+            logical (omp_logical_kind) :: omp_test_lock\n+            integer (omp_lock_kind), intent (inout) :: lock\n+          end function omp_test_lock\n+        end interface\n+\n+        interface\n+          function omp_get_max_threads ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_max_threads\n+          end function omp_get_max_threads\n+        end interface\n+\n+        interface\n+          function omp_get_num_procs ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_num_procs\n+          end function omp_get_num_procs\n+        end interface\n+\n+        interface\n+          function omp_get_num_threads ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_num_threads\n+          end function omp_get_num_threads\n+        end interface\n+\n+        interface\n+          function omp_get_thread_num ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_thread_num\n+          end function omp_get_thread_num\n+        end interface\n+\n+        interface\n+          function omp_test_nest_lock (lock)\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_test_nest_lock\n+            integer (omp_nest_lock_kind), intent (inout) :: lock\n+          end function omp_test_nest_lock\n+        end interface\n+\n+        interface\n+          function omp_get_wtick ()\n+            double precision :: omp_get_wtick\n+          end function omp_get_wtick\n+        end interface\n+\n+        interface\n+          function omp_get_wtime ()\n+            double precision :: omp_get_wtime\n+          end function omp_get_wtime\n+        end interface\n+\n+      end module omp_lib"}, {"sha": "52e2f227bf750136877e88099354da1e7198284c", "filename": "libgomp/omp_lib.h.in", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c", "patch": "@@ -0,0 +1,53 @@\n+!  Copyright (C) 2005 Free Software Foundation, Inc.\n+!  Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+!  This file is part of the GNU OpenMP Library (libgomp).\n+\n+!  Libgomp is free software; you can redistribute it and/or modify it\n+!  under the terms of the GNU Lesser General Public License as published by\n+!  the Free Software Foundation; either version 2.1 of the License, or\n+!  (at your option) any later version.\n+\n+!  Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+!  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+!  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+!  more details.\n+\n+!  You should have received a copy of the GNU Lesser General Public License\n+!  along with libgomp; see the file COPYING.LIB.  If not, write to the\n+!  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+!  MA 02110-1301, USA.  */\n+\n+!  As a special exception, if you link this library with other files, some\n+!  of which are compiled with GCC, to produce an executable, this library\n+!  does not by itself cause the resulting executable to be covered by the\n+!  GNU General Public License.  This exception does not however invalidate\n+!  any other reasons why the executable file might be covered by the GNU\n+!  General Public License.\n+\n+      integer omp_lock_kind, omp_nest_lock_kind, openmp_version\n+      parameter (omp_lock_kind = OMP_LOCK_KIND)\n+      parameter (omp_nest_lock_kind = OMP_NEST_LOCK_KIND)\n+      parameter (openmp_version = 200505)\n+\n+      external omp_init_lock, omp_init_nest_lock\n+      external omp_destroy_lock, omp_destroy_nest_lock\n+      external omp_set_lock, omp_set_nest_lock\n+      external omp_unset_lock, omp_unset_nest_lock\n+      external omp_set_dynamic, omp_set_nested\n+      external omp_set_num_threads\n+\n+      external omp_get_dynamic, omp_get_nested\n+      logical*4 omp_get_dynamic, omp_get_nested\n+      external omp_test_lock, omp_in_parallel\n+      logical*4 omp_test_lock, omp_in_parallel\n+\n+      external omp_get_max_threads, omp_get_num_procs\n+      integer*4 omp_get_max_threads, omp_get_num_procs\n+      external omp_get_num_threads, omp_get_thread_num\n+      integer*4 omp_get_num_threads, omp_get_thread_num\n+      external omp_test_nest_lock\n+      integer*4 omp_test_nest_lock\n+\n+      external omp_get_wtick, omp_get_wtime\n+      double precision omp_get_wtick, omp_get_wtime"}, {"sha": "7c5d671996a5d0be921a51d11feac717bcaedff1", "filename": "libgomp/ordered.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fordered.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fordered.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fordered.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "edd344a90a8744422e5825e5709c776f3c990029", "filename": "libgomp/parallel.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fparallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fparallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fparallel.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "de0acd843eaf942fab344aa7c40ec82d5cbcf43c", "filename": "libgomp/sections.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fsections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fsections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsections.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "dde05d9ceb8d72dc2372b16255ff83f52b8f192c", "filename": "libgomp/single.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsingle.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "1d8efb688afcf15e56b9754c6ba08b2a736915f3", "filename": "libgomp/team.c", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "561b7e25448e27f1236ee70a80b0ce5110194ef7", "filename": "libgomp/testsuite/Makefile.am", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.am?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "2b05ca70c96ba8bed48991daf5da0e4433f884d4", "filename": "libgomp/testsuite/Makefile.in", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.in?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "a0c675a7fe86dfc71d5398cf93e5d1ee2927025b", "filename": "libgomp/testsuite/lib/libgomp-dg.exp", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flib%2Flibgomp-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flib%2Flibgomp-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp-dg.exp?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "276ac6caad9b40351454727f86a277508a6a59ff", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.15.1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.15.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.15.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.15.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "28a994a28fa7cfddaa8b76074d6e20ccb755f779", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.16.1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.16.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.16.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.16.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "388763e59d162a77cf5fd3e40996adc25aaea37a", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.18.1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.18.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.18.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.18.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "65ffe624c2576b1dbcd339f15b5c1d09d3b04c8a", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.19.1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.19.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.19.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.19.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "f6ae4c7c5d0b083f5f770759d8a63d7d65065916", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.2.1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.2.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.2.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.2.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "0c1c39a1271f43a7b7a6595cc9ec6144b9d6385c", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.21.1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.21.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.21.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.21.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "e146fa2041c807aecca84c6e0c1bce85f87943db", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.26.1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.26.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.26.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.26.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "6f0f65fa03e701e48af633bdf4277bc0ca369c55", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.29.1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.29.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.29.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.29.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "9e7c24f754656fb4b4983a3b3a188645ab7c32c9", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.3.1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.3.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.3.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.3.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "0b7f0197ce9a6710425d40e9f091dfa37c09a122", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.33.3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.33.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.33.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.33.3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "b60534d1166390a25413c2582ec5d574efb45a0f", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.36.1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.36.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.36.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.36.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "a129e87fc49f12b0000ecb69ab3126c87b2117cc", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.39.1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.39.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.39.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.39.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "c6be4909002f8207869291914aee1c3317f4f792", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.4.1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.4.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.4.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.4.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "aa7b88d70988b8125a484cb82a5345ca55115005", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.40.1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.40.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.40.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.40.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "b909c4ddbc5859f08c607c121a7199417119c2a4", "filename": "libgomp/testsuite/libgomp.c/appendix-a/a.5.1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.5.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.5.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fappendix-a%2Fa.5.1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "82642a4e48de74d29497236c4d621be67ac0bda2", "filename": "libgomp/testsuite/libgomp.c/atomic-1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "6565279b9e8abc3795f109b1a73b1bdc897a50f7", "filename": "libgomp/testsuite/libgomp.c/atomic-10.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-10.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "6f4939256b7d5c9b36c35604a99263f580154674", "filename": "libgomp/testsuite/libgomp.c/atomic-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fatomic-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "915f2dea97cc174a70d117402e180758c59793ba", "filename": "libgomp/testsuite/libgomp.c/barrier-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fbarrier-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fbarrier-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fbarrier-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "8056a86054da4476f1298c94f269fd8b3941db9a", "filename": "libgomp/testsuite/libgomp.c/c.exp", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fc.exp?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "49c546004c83346bf5fcc755f1fbe1864b47ac40", "filename": "libgomp/testsuite/libgomp.c/copyin-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "ae2451ef1d857df30e6b1d0939fcaf325bd15c85", "filename": "libgomp/testsuite/libgomp.c/copyin-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "86b0d691f3a8f8223eaf451bfb122153af469a86", "filename": "libgomp/testsuite/libgomp.c/copyin-3.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcopyin-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "ecf54324523d0150f63ecab51654396546d9ed63", "filename": "libgomp/testsuite/libgomp.c/critical-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcritical-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcritical-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcritical-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "530a891f6b0099084026fa8b94ca7a50a1e7369d", "filename": "libgomp/testsuite/libgomp.c/critical-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcritical-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fcritical-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcritical-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "4839cf936f20d20a90a5fa4e4b6764fa0d6bcb3d", "filename": "libgomp/testsuite/libgomp.c/lib-1.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Flib-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Flib-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Flib-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "a90a8e601c7cb70aa0cf42da8d170d0f64c3cae5", "filename": "libgomp/testsuite/libgomp.c/loop-1.c", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "14f371dc8a9cb05661748e53c0cd02611af86ea2", "filename": "libgomp/testsuite/libgomp.c/loop-2.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "ba3ecdaca3af3cac779f2644eef5801a9cb85e13", "filename": "libgomp/testsuite/libgomp.c/loop-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "d3cfb01006980e8d606cb857ff85f438a8069049", "filename": "libgomp/testsuite/libgomp.c/nested-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "f52b074ff133c525adb66370b95c4c22157c05e4", "filename": "libgomp/testsuite/libgomp.c/nested-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "26c0d237cd2e5c25ce430de92c8496a76faf1ba4", "filename": "libgomp/testsuite/libgomp.c/nestedfn-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "fdbbe0f735c99e0b61c61dc0ce7e048419cca121", "filename": "libgomp/testsuite/libgomp.c/nestedfn-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "8f8847f97e9917d1a9fc6bc024e7603c9d88c57d", "filename": "libgomp/testsuite/libgomp.c/nestedfn-3.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "0e83c95832f1d40aafbcfa775fac5490280046e2", "filename": "libgomp/testsuite/libgomp.c/omp-loop01.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop01.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "04aaea2e356cfc914c81004e2113c2fbc44d4bd4", "filename": "libgomp/testsuite/libgomp.c/omp-loop02.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop02.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "7bb9a194331efc18f354dbb638e393978c0e1a24", "filename": "libgomp/testsuite/libgomp.c/omp-loop03.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop03.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop03.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-loop03.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "655ef26fa8c8cc2767d2b4afb347e11fadea27e2", "filename": "libgomp/testsuite/libgomp.c/omp-nested-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-nested-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-nested-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-nested-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "c6631a0a7cb340c240b6bc166d1653b528e97e2f", "filename": "libgomp/testsuite/libgomp.c/omp-parallel-for.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-parallel-for.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-parallel-for.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-parallel-for.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "5e378359aacec79bf6516693d0627e7d602ec9aa", "filename": "libgomp/testsuite/libgomp.c/omp-parallel-if.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-parallel-if.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-parallel-if.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-parallel-if.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "a44ca54ace7c681e633200238c946e15a5970a1e", "filename": "libgomp/testsuite/libgomp.c/omp-single-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "6878559739751c53c493878688b8b7f859837da0", "filename": "libgomp/testsuite/libgomp.c/omp-single-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "5a06532448eb90b21d7d30c81f406a8303fb54a5", "filename": "libgomp/testsuite/libgomp.c/omp-single-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp-single-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "8d58cd43bf62506fcf8957e6fa7b6eaa4ae7e1f2", "filename": "libgomp/testsuite/libgomp.c/omp_hello.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_hello.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_hello.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_hello.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "12b8c689608dad3af95ecc81076965d99b70c212", "filename": "libgomp/testsuite/libgomp.c/omp_matvec.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_matvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_matvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_matvec.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "cbf7abf3756566616a155c26224a0325ffaff201", "filename": "libgomp/testsuite/libgomp.c/omp_orphan.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_orphan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_orphan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_orphan.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "5c9c41ec7491cad9cd9adf6219e54883e0282e4b", "filename": "libgomp/testsuite/libgomp.c/omp_reduction.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_reduction.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "e33bef316d801bf29bdf0ff534ba638be47c26ba", "filename": "libgomp/testsuite/libgomp.c/omp_workshare1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "32c93dbdef69c5634ca76f9863da6ba41fa9121f", "filename": "libgomp/testsuite/libgomp.c/omp_workshare2.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "913f1f731bf8ef849655138d708cd840e42b9a14", "filename": "libgomp/testsuite/libgomp.c/omp_workshare3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "67605e38b56013b1ea7cfaa03baae468b55ebd3a", "filename": "libgomp/testsuite/libgomp.c/omp_workshare4.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fomp_workshare4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "23ec12547b9bb71036b7aab8eea3e55d0e928d48", "filename": "libgomp/testsuite/libgomp.c/ordered-1.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "15325b48bb382c4a10dfb12cfaebff15993203a7", "filename": "libgomp/testsuite/libgomp.c/ordered-2.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "2a2f219703f7593357539b31209f151eb0f8578b", "filename": "libgomp/testsuite/libgomp.c/ordered-3.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fordered-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "031f5bf881201c6326c1bac6efd6a48c2b3d3ab3", "filename": "libgomp/testsuite/libgomp.c/parallel-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fparallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fparallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fparallel-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "c39068f80687cd3ea76a62cb502c3e940afca3de", "filename": "libgomp/testsuite/libgomp.c/pr24455-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr24455-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr24455-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr24455-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "8af449e7b5c3f8cfb4a1ba61ac5ad4e0f54e5ebc", "filename": "libgomp/testsuite/libgomp.c/pr24455.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr24455.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr24455.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr24455.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "665163af09f9181a7a35f33090968497c6f3f94e", "filename": "libgomp/testsuite/libgomp.c/reduction-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "52b3faff787e3a3d160cd15c3c37dbda88d91852", "filename": "libgomp/testsuite/libgomp.c/reduction-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "4f8f2fc123660df26413aa80641604b131237d22", "filename": "libgomp/testsuite/libgomp.c/reduction-3.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "23e9d6d5bda819eb98887070257112fbf54116f7", "filename": "libgomp/testsuite/libgomp.c/reduction-4.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Freduction-4.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "6785941be6cfbfe154a374b0f87d499897bf0e99", "filename": "libgomp/testsuite/libgomp.c/sections-1.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fsections-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fsections-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsections-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "f7d4fb2d60f838f8bdb5a7534e9df18d087238a4", "filename": "libgomp/testsuite/libgomp.c/shared-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "56c88ecc734a51ce85c77e7a37c4eeac7cc48d30", "filename": "libgomp/testsuite/libgomp.c/shared-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "494a970ad8f71ced6209b31d6eeb232285fc7261", "filename": "libgomp/testsuite/libgomp.c/shared-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fshared-3.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "d1fd5e2de62b46e298108dbd3e3bf79202dfd4e8", "filename": "libgomp/testsuite/libgomp.c/single-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fsingle-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fsingle-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsingle-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "b510ce735e25df96d23507b8d185e055dc13f6df", "filename": "libgomp/testsuite/libgomp.c/single-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fsingle-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fsingle-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsingle-2.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "bdacdbbe8836e3bd2695951465a6341ae95a6f2c", "filename": "libgomp/testsuite/libgomp.c/vla-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fvla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Ftestsuite%2Flibgomp.c%2Fvla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fvla-1.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}, {"sha": "cd20c9dbe736800925c6c4a5b0e1be5c3cf35a28", "filename": "libgomp/work.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fwork.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/953ff28998b59b0912be907d74f7afa5a8ed1e9c/libgomp%2Fwork.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fwork.c?ref=953ff28998b59b0912be907d74f7afa5a8ed1e9c"}]}