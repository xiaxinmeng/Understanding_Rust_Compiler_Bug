{"sha": "b818abb0b19ba265174ae38e8f683b843aa1a05f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxOGFiYjBiMTliYTI2NTE3NGFlMzhlOGY2ODNiODQzYWExYTA1Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-10T01:00:39Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-10T01:00:39Z"}, "message": "(init_optabs): Use __gcc_bcmp, not real bcmp.\n\n(expand_unop): Handle NEG for complex modes.\n(expand_binop): Likewise.\n(expand_complex_binop): New function.\n\nFrom-SVN: r2092", "tree": {"sha": "e6396dc7a02e74a9aa07cd5cb53661f57846aed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6396dc7a02e74a9aa07cd5cb53661f57846aed1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b818abb0b19ba265174ae38e8f683b843aa1a05f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b818abb0b19ba265174ae38e8f683b843aa1a05f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b818abb0b19ba265174ae38e8f683b843aa1a05f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b818abb0b19ba265174ae38e8f683b843aa1a05f/comments", "author": null, "committer": null, "parents": [{"sha": "7c65f72c8e049e7ee50e65e27c211c92adfa6983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c65f72c8e049e7ee50e65e27c211c92adfa6983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c65f72c8e049e7ee50e65e27c211c92adfa6983"}], "stats": {"total": 239, "additions": 238, "deletions": 1}, "files": [{"sha": "53296a4112c3ef0815897aafde1c4e42a237f220", "filename": "gcc/optabs.c", "status": "modified", "additions": 238, "deletions": 1, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b818abb0b19ba265174ae38e8f683b843aa1a05f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b818abb0b19ba265174ae38e8f683b843aa1a05f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b818abb0b19ba265174ae38e8f683b843aa1a05f", "patch": "@@ -180,6 +180,11 @@ rtx fixunstfsi_libfunc;\n rtx fixunstfdi_libfunc;\n rtx fixunstfti_libfunc;\n \n+#ifdef GPC\n+/* from emit-rtl.c */\n+extern rtx gen_highpart();\n+#endif\n+\n /* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n    gives the gen_function to make a branch to test that condition.  */\n \n@@ -824,6 +829,228 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       delete_insns_since (last);\n     }\n \n+#ifdef GPC\n+  /* We need to open-code the complex type operations: '+, -, * and /' */\n+\n+  /* At this point we allow operations between two similar complex\n+     numbers, and also if one of the operands is not a complex number\n+     but rather of MODE_FLOAT or MODE_INT. However, the caller\n+     must make sure that the MODE of the non-complex operand matches\n+     the SUBMODE of the complex operand.\n+     @@ Perhaps the conversion to complex numbers should be somewhere else.\n+     @@ This is not tested very much.\n+   */\n+\n+  if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n+    { rtx real0 = (rtx) 0;\n+      rtx imag0 = (rtx) 0;\n+      rtx real1 = (rtx) 0;\n+      rtx imag1 = (rtx) 0;\n+      rtx realr;\n+      rtx imagr;\n+      rtx res;\n+      rtx seq;\n+      rtx equiv_value;\n+\n+      /* Find the correct mode for the real and imaginary parts */\n+      enum machine_mode submode =\n+\tmode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n+\t\t       class == MODE_COMPLEX_INT ? MODE_INT : MODE_FLOAT,\n+\t\t       0);\n+\n+      if (submode == BLKmode)\n+\tabort ();\n+\n+      if (! target)\n+\ttarget = gen_reg_rtx (mode);\n+\n+      start_sequence ();\n+\n+      realr = gen_lowpart  (submode, target);\n+      imagr = gen_highpart (submode, target);\n+\n+      if (GET_MODE (op0) == mode)\n+\t{\n+\t  real0 = gen_lowpart  (submode, op0);\n+\t  imag0 = gen_highpart (submode, op0);\n+\t}\n+      else\n+\treal0 = op0;\n+\n+      if (GET_MODE (op1) == mode)\n+\t{\n+\t  real1 = gen_lowpart  (submode, op1);\n+\t  imag1 = gen_highpart (submode, op1);\n+\t}\n+      else\n+\treal1 = op1;\n+\n+      if (! real0 || ! real1 || ! (imag0 || imag1))\n+\tabort ();\n+\n+      switch (binoptab->code) {\n+      case PLUS:\n+      case MINUS:\n+\t  res = expand_binop (submode, binoptab, real0, real1,\n+\t\t\t      realr, unsignedp, methods);\n+\t  if (res != realr)\n+\t    emit_move_insn (realr, res);\n+\n+\t  if (imag0 && imag1)\n+\t    res = expand_binop (submode, binoptab, imag0, imag1,\n+\t\t\t\timagr, unsignedp, methods);\n+\t  else if (imag0)\n+\t    res = imag0;\n+\t  else if (binoptab->code == MINUS)\n+\t    res = expand_unop (submode, neg_optab, imag1, imagr, unsignedp);\n+\t  else\n+\t    res = imag1;\n+\n+\t  if (res != imagr)\n+\t    emit_move_insn (imagr, res);\n+\t  break;\n+      case MULT:\n+\t  /* (a+ib) * (c+id) = (ac-bd) + i(ad+cb) */\n+\n+\t  res = expand_binop (submode, binoptab, real0, real1,\n+\t\t\t      realr, unsignedp, methods);\n+\n+\t  if (imag0 && imag1)\n+\t    {\n+\t      rtx temp =\n+\t\texpand_binop (submode, sub_optab, res,\n+\t\t\t      expand_binop (submode, binoptab, imag0, imag1,\n+\t\t\t\t\t    0, unsignedp, methods),\n+\t\t\t      realr, unsignedp, methods);\n+\n+\t      if (temp != realr)\n+\t\temit_move_insn (realr, temp);\n+\n+\t      res = expand_binop (submode, add_optab,\n+\t\t\t\t  expand_binop (submode, binoptab,\n+\t\t\t\t\t\treal0, imag1,\n+\t\t\t\t\t\t0, unsignedp, methods),\n+\t\t\t\t  expand_binop (submode, binoptab,\n+\t\t\t\t\t\treal1, imag0,\n+\t\t\t\t\t\t0, unsignedp, methods),\n+\t\t\t\t  imagr, unsignedp, methods);\n+\t      if (res != imagr)\n+\t\temit_move_insn (imagr, res);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (res != realr)\n+\t\temit_move_insn (realr, res);\n+\n+\t      if (imag0)\n+\t\tres = expand_binop (submode, binoptab,\n+\t\t\t\t    real1, imag0, imagr, unsignedp, methods);\n+\t      else\n+\t\tres = expand_binop (submode, binoptab,\n+\t\t\t\t    real0, imag1, imagr, unsignedp, methods);\n+\t      if (res != imagr)\n+\t\temit_move_insn (imagr, res);\n+\t    }\n+\t  break;\n+      case DIV:\n+\t  /* (c+id)/(a+ib) == ((c+id)*(a-ib))/(a*a+b*b) */\n+\t  \n+\t  if (! imag1)\n+\t    { /* Simply divide the real and imaginary parts by `a' */\n+\t      res = expand_binop (submode, binoptab, real0, real1,\n+\t\t\t\t  realr, unsignedp, methods);\n+\t      if (res != realr)\n+\t\temit_move_insn (realr, res);\n+\n+\t      res = expand_binop (submode, binoptab, imag0, real1,\n+\t\t\t\t  imagr, unsignedp, methods);\n+\t      if (res != imagr)\n+\t\temit_move_insn (imagr, res);\n+\t    }\n+\t  else /* Divider is of complex type */\n+\t    {  /* X/(a+ib) */\n+\n+\t      rtx divider;\n+\t      rtx real_t;\n+\t      rtx imag_t;\n+\t      \n+\t      optab mulopt = unsignedp ? umul_widen_optab : smul_optab;\n+\n+\t      /* Divider: a*a + b*b */\n+\t      divider = expand_binop (submode, add_optab,\n+\t\t\t\t     expand_binop (submode, mulopt,\n+\t\t\t\t\t\t   real1, real1,\n+\t\t\t\t\t\t   0, unsignedp, methods),\n+\t\t\t\t     expand_binop (submode, mulopt,\n+\t\t\t\t\t\t   imag1, imag1,\n+\t\t\t\t\t\t   0, unsignedp, methods),\n+\t\t\t\t     0, unsignedp, methods);\n+\n+\t      if (! imag0) /* ((c)(a-ib))/divider */\n+\t\t{\n+\t\t  /* Calculate the divident */\n+\t\t  real_t = expand_binop (submode, mulopt, real0, real1,\n+\t\t\t\t\t 0, unsignedp, methods);\n+\t\t  \n+\t\t  imag_t =\n+\t\t    expand_unop (submode, neg_optab,\n+\t\t\t\t expand_binop (submode, mulopt, real0, imag1,\n+\t\t\t\t\t       0, unsignedp, methods),\n+\t\t\t\t 0, unsignedp);\n+\t\t}\n+\t      else /* ((c+id)(a-ib))/divider */\n+\t\t{\n+\t\t  /* Calculate the divident */\n+\t\t  real_t = expand_binop (submode, add_optab,\n+\t\t\t\t\t expand_binop (submode, mulopt,\n+\t\t\t\t\t\t       real0, real1,\n+\t\t\t\t\t\t       0, unsignedp, methods),\n+\t\t\t\t\t expand_binop (submode, mulopt,\n+\t\t\t\t\t\t       imag0, imag1,\n+\t\t\t\t\t\t       0, unsignedp, methods),\n+\t\t\t\t\t 0, unsignedp, methods);\n+\t\t  \n+\t\t  imag_t = expand_binop (submode, sub_optab,\n+\t\t\t\t\t expand_binop (submode, mulopt,\n+\t\t\t\t\t\t       real0, imag1,\n+\t\t\t\t\t\t       0, unsignedp, methods),\n+\t\t\t\t\t expand_binop (submode, mulopt,\n+\t\t\t\t\t\t       real1, imag0,\n+\t\t\t\t\t\t       0, unsignedp, methods),\n+\t\t\t\t\t 0, unsignedp, methods);\n+\n+\t\t}\n+\n+\t      res = expand_binop (submode, binoptab, real_t, divider,\n+\t\t\t\t  realr, unsignedp, methods);\n+\t      if (res != realr)\n+\t\temit_move_insn (realr, res);\n+\n+\t      res = expand_binop (submode, binoptab, imag_t, divider,\n+\t\t\t\t  imagr, unsignedp, methods);\n+\t      if (res != imagr)\n+\t\temit_move_insn (imagr, res);\n+\t    }\n+\t  break;\n+\t  \n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      seq = gen_sequence ();\n+      end_sequence ();\n+\n+      if (binoptab->code != UNKNOWN)\n+\tequiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n+      else\n+\tequiv_value = 0;\n+\t  \n+      emit_no_conflict_block (seq, target, op0, op1, equiv_value);\n+      \n+      return target;\n+    }\n+#endif /* GPC */\n+\n   /* It can't be open-coded in this mode.\n      Use a library call if one is available and caller says that's ok.  */\n \n@@ -1144,9 +1371,19 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n   register rtx temp;\n   rtx last = get_last_insn ();\n   rtx pat;\n+#ifdef GPC\n+  enum machine_mode submode;\n+#endif\n \n   class = GET_MODE_CLASS (mode);\n \n+#ifdef GPC\n+  if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n+    submode = mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n+\t\t\t     class == MODE_COMPLEX_INT ?\n+\t\t\t       MODE_INT : MODE_FLOAT, 0);\n+#endif /* GPC */\n+\n   op0 = protect_from_queue (op0, 0);\n \n   if (flag_force_mem)\n@@ -4631,7 +4868,7 @@ init_optabs ()\n   memcpy_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"memcpy\");\n   bcopy_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"bcopy\");\n   memcmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"memcmp\");\n-  bcmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"bcmp\");\n+  bcmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gcc_bcmp\");\n   memset_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"memset\");\n   bzero_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"bzero\");\n "}]}