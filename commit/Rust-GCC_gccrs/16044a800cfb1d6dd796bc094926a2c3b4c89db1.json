{"sha": "16044a800cfb1d6dd796bc094926a2c3b4c89db1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYwNDRhODAwY2ZiMWQ2ZGQ3OTZiYzA5NDkyNmEyYzNiNGM4OWRiMQ==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2008-09-26T14:31:57Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2008-09-26T14:31:57Z"}, "message": "rs6000.c (rs6000_emit_allocate_stack): Use correct alias set on MEM when saving stack pointer.\n\n2008-09-26  Pat Haugen  <pthaugen@us.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_emit_allocate_stack): Use correct\n\talias set on MEM when saving stack pointer.\n\t* config/rs6000/rs6000.md (allocate_stack): Likewise\n\nFrom-SVN: r140693", "tree": {"sha": "227644874f4cf327a4f2972890dbb0627af517ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/227644874f4cf327a4f2972890dbb0627af517ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16044a800cfb1d6dd796bc094926a2c3b4c89db1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16044a800cfb1d6dd796bc094926a2c3b4c89db1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16044a800cfb1d6dd796bc094926a2c3b4c89db1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16044a800cfb1d6dd796bc094926a2c3b4c89db1/comments", "author": null, "committer": null, "parents": [{"sha": "8f5730b99779f7d34559c2715de46010698c2b7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5730b99779f7d34559c2715de46010698c2b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f5730b99779f7d34559c2715de46010698c2b7e"}], "stats": {"total": 46, "additions": 42, "deletions": 4}, "files": [{"sha": "d59b25b50f39f65d1d532467266b89c50a571ea9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16044a800cfb1d6dd796bc094926a2c3b4c89db1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16044a800cfb1d6dd796bc094926a2c3b4c89db1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16044a800cfb1d6dd796bc094926a2c3b4c89db1", "patch": "@@ -1,3 +1,9 @@\n+2008-09-26  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_allocate_stack): Use correct\n+\talias set on MEM when saving stack pointer.\n+\t* config/rs6000/rs6000.md (allocate_stack): Likewise\n+\n 2008-09-26  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/37574"}, {"sha": "924fa9e595404356396b61ed0d31aa94a7e9a4a2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16044a800cfb1d6dd796bc094926a2c3b4c89db1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16044a800cfb1d6dd796bc094926a2c3b4c89db1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=16044a800cfb1d6dd796bc094926a2c3b4c89db1", "patch": "@@ -15438,6 +15438,8 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12, int copy_r11)\n \n   if (TARGET_UPDATE)\n     {\n+      rtx par, set, mem;\n+\n       if (size > 32767)\n \t{\n \t  /* Need a note here so that try_split doesn't get confused.  */\n@@ -15453,13 +15455,25 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12, int copy_r11)\n \t\t\t\t\t    todec, stack_reg)\n \t\t\t: gen_movdi_di_update (stack_reg, stack_reg,\n \t\t\t\t\t    todec, stack_reg));\n+      /* Since we didn't use gen_frame_mem to generate the MEM, grab\n+\t it now and set the alias set/attributes. The above gen_*_update\n+\t calls will generate a PARALLEL with the MEM set being the first\n+\t operation. */\n+      par = PATTERN (insn);\n+      gcc_assert (GET_CODE (par) == PARALLEL);\n+      set = XVECEXP (par, 0, 0);\n+      gcc_assert (GET_CODE (set) == SET);\n+      mem = SET_DEST (set);\n+      gcc_assert (MEM_P (mem));\n+      MEM_NOTRAP_P (mem) = 1;\n+      set_mem_alias_set (mem, get_frame_alias_set ());\n     }\n   else\n     {\n       insn = emit_insn (TARGET_32BIT\n \t\t\t? gen_addsi3 (stack_reg, stack_reg, todec)\n \t\t\t: gen_adddi3 (stack_reg, stack_reg, todec));\n-      emit_move_insn (gen_rtx_MEM (Pmode, stack_reg),\n+      emit_move_insn (gen_frame_mem (Pmode, stack_reg),\n \t\t      copy_r11\n                       ? gen_rtx_REG (Pmode, 11)\n                       : gen_rtx_REG (Pmode, 12));"}, {"sha": "fb55fc00962889d30adacf1a1e00692aea829f16", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16044a800cfb1d6dd796bc094926a2c3b4c89db1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16044a800cfb1d6dd796bc094926a2c3b4c89db1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=16044a800cfb1d6dd796bc094926a2c3b4c89db1", "patch": "@@ -10340,14 +10340,32 @@\n     neg_op0 = GEN_INT (- INTVAL (operands[1]));\n \n   if (TARGET_UPDATE)\n-    emit_insn ((* ((TARGET_32BIT) ? gen_movsi_update : gen_movdi_di_update))\n-\t\t(stack_pointer_rtx, stack_pointer_rtx, neg_op0, chain));\n+    {\n+      rtx insn, par, set, mem;\n+\n+      insn = emit_insn ((* ((TARGET_32BIT) ? gen_movsi_update\n+\t\t\t\t\t   : gen_movdi_di_update))\n+\t\t\t(stack_pointer_rtx, stack_pointer_rtx, neg_op0,\n+\t\t\t chain));\n+      /* Since we didn't use gen_frame_mem to generate the MEM, grab\n+         it now and set the alias set/attributes. The above gen_*_update\n+         calls will generate a PARALLEL with the MEM set being the first\n+         operation. */\n+      par = PATTERN (insn);\n+      gcc_assert (GET_CODE (par) == PARALLEL);\n+      set = XVECEXP (par, 0, 0);\n+      gcc_assert (GET_CODE (set) == SET);\n+      mem = SET_DEST (set);\n+      gcc_assert (MEM_P (mem));\n+      MEM_NOTRAP_P (mem) = 1;\n+      set_mem_alias_set (mem, get_frame_alias_set ());\n+    }\n \n   else\n     {\n       emit_insn ((* ((TARGET_32BIT) ? gen_addsi3 : gen_adddi3))\n \t\t (stack_pointer_rtx, stack_pointer_rtx, neg_op0));\n-      emit_move_insn (gen_rtx_MEM (Pmode, stack_pointer_rtx), chain);\n+      emit_move_insn (gen_frame_mem (Pmode, stack_pointer_rtx), chain);\n     }\n \n   emit_move_insn (operands[0], virtual_stack_dynamic_rtx);"}]}