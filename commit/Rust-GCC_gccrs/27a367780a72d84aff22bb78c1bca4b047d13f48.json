{"sha": "27a367780a72d84aff22bb78c1bca4b047d13f48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdhMzY3NzgwYTcyZDg0YWZmMjJiYjc4YzFiY2E0YjA0N2QxM2Y0OA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-23T20:11:52Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-23T20:11:52Z"}, "message": "Add setjmp/longjmp exception handling.\n\nFrom-SVN: r13969", "tree": {"sha": "b0da7eae8ad9032c2b8113a0a7ee10a84644941c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0da7eae8ad9032c2b8113a0a7ee10a84644941c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27a367780a72d84aff22bb78c1bca4b047d13f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a367780a72d84aff22bb78c1bca4b047d13f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27a367780a72d84aff22bb78c1bca4b047d13f48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a367780a72d84aff22bb78c1bca4b047d13f48/comments", "author": null, "committer": null, "parents": [{"sha": "e976b8b277eb0ae570a2c3317e77713fff846758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e976b8b277eb0ae570a2c3317e77713fff846758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e976b8b277eb0ae570a2c3317e77713fff846758"}], "stats": {"total": 767, "additions": 650, "deletions": 117}, "files": [{"sha": "30a070b297fd66f4519770761fbad02497a87b26", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=27a367780a72d84aff22bb78c1bca4b047d13f48", "patch": "@@ -2388,3 +2388,6 @@ do {\t\t\t\t\t\t\\\n   /* The privilege level is in the two low order bits, mask em out\t\\\n      of the return address.  */\t\t\t\t\t\t\\\n   (GEN_INT (0xfffffffc))\n+\n+/* The number of Pmode words for the setjmp buffer.  */\n+#define JMP_BUF_SIZE 50"}, {"sha": "708060fc79018eb4d4cf7fb47fd6efd0a012098e", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=27a367780a72d84aff22bb78c1bca4b047d13f48", "patch": "@@ -3089,6 +3089,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n+/* The number of Pmode words for the setjmp buffer.  */\n+#define JMP_BUF_SIZE 12\n+\n /* Declare functions defined in sparc.c and used in templates.  */\n \n extern char *singlemove_string ();"}, {"sha": "f52fc13f9bf8eebdd0db93ec340f0f23192ecb52", "filename": "gcc/except.c", "status": "modified", "additions": 627, "deletions": 117, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=27a367780a72d84aff22bb78c1bca4b047d13f48", "patch": "@@ -43,6 +43,16 @@ Boston, MA 02111-1307, USA.  */\n    exception, and thus there is the concept of \"throwing\" the\n    exception up the call stack.\n \n+   There are two major codegen options for exception handling.  The\n+   flag -fsjlj-exceptions can be used to select the setjmp/longjmp\n+   approach, which is the default.  -fnosjlj-exceptions can be used to\n+   get the PC range table approach.  While this is a compile time\n+   flag, an entire application must be compiled with the same codegen\n+   option.  The first is a PC range table approach, the second is a\n+   setjmp/longjmp based scheme.  We will first discuss the PC range\n+   table approach, after that, we will discuss the setjmp/longjmp\n+   based approach.\n+\n    It is appropriate to speak of the \"context of a throw\". This\n    context refers to the address where the exception is thrown from,\n    and is used to determine which exception region will handle the\n@@ -83,13 +93,13 @@ Boston, MA 02111-1307, USA.  */\n    and is responsible for recording all of the exception regions into\n    one list (which is kept in a static variable named exception_table_list).\n \n-   The function __throw () is actually responsible for doing the\n-   throw. In the C++ frontend, __throw () is generated on a\n+   The function __throw is actually responsible for doing the\n+   throw. In the C++ frontend, __throw is generated on a\n    per-object-file basis for each source file compiled with\n-   -fexceptions. Before __throw () is invoked, the current context\n+   -fexceptions. Before __throw is invoked, the current context\n    of the throw needs to be placed in the global variable __eh_pc.\n \n-   __throw () attempts to find the appropriate exception handler for the \n+   __throw attempts to find the appropriate exception handler for the \n    PC value stored in __eh_pc by calling __find_first_exception_table_match\n    (which is defined in libgcc2.c). If __find_first_exception_table_match\n    finds a relevant handler, __throw jumps directly to it.\n@@ -99,22 +109,22 @@ Boston, MA 02111-1307, USA.  */\n    address of the caller of the current function (which will be used\n    as the new context to throw from), and then restarting the process\n    of searching for a handler for the new context. __throw may also\n-   call abort () if it is unable to unwind the stack, and can also\n+   call abort if it is unable to unwind the stack, and can also\n    call an external library function named __terminate if it reaches\n    the top of the stack without finding an appropriate handler. (By\n-   default __terminate () invokes abort (), but this behavior can be\n+   default __terminate invokes abort, but this behavior can be\n    changed by the user to perform some sort of cleanup behavior before\n    exiting).\n \n    Internal implementation details:\n \n    To associate a user-defined handler with a block of statements, the\n-   function expand_start_try_stmts () is used to mark the start of the\n+   function expand_start_try_stmts is used to mark the start of the\n    block of statements with which the handler is to be associated\n    (which is known as a \"try block\"). All statements that appear\n    afterwards will be associated with the try block.\n \n-   A call to expand_start_all_catch () marks the end of the try block,\n+   A call to expand_start_all_catch marks the end of the try block,\n    and also marks the start of the \"catch block\" (the user-defined\n    handler) associated with the try block.\n \n@@ -129,23 +139,23 @@ Boston, MA 02111-1307, USA.  */\n    If the handler chooses not to process the exception (perhaps by\n    looking at an \"exception type\" or some other additional data\n    supplied with the exception), it can fall through to the end of the\n-   handler. expand_end_all_catch () and expand_leftover_cleanups ()\n+   handler. expand_end_all_catch and expand_leftover_cleanups\n    add additional code to the end of each handler to take care of\n    rethrowing to the outer exception handler.\n \n    The handler also has the option to continue with \"normal flow of\n    code\", or in other words to resume executing at the statement\n    immediately after the end of the exception region. The variable\n    caught_return_label_stack contains a stack of labels, and jumping\n-   to the topmost entry's label via expand_goto () will resume normal\n+   to the topmost entry's label via expand_goto will resume normal\n    flow to the statement immediately after the end of the exception\n    region. If the handler falls through to the end, the exception will\n    be rethrown to the outer exception region.\n \n    The instructions for the catch block are kept as a separate\n    sequence, and will be emitted at the end of the function along with\n-   the handlers specified via expand_eh_region_end (). The end of the\n-   catch block is marked with expand_end_all_catch ().\n+   the handlers specified via expand_eh_region_end. The end of the\n+   catch block is marked with expand_end_all_catch.\n \n    Any data associated with the exception must currently be handled by\n    some external mechanism maintained in the frontend.  For example,\n@@ -161,7 +171,7 @@ Boston, MA 02111-1307, USA.  */\n    to be allocated isn't known at compile time.)\n \n    Internally-generated exception regions (cleanups) are marked by\n-   calling expand_eh_region_start () to mark the start of the region,\n+   calling expand_eh_region_start to mark the start of the region,\n    and expand_eh_region_end (handler) is used to both designate the\n    end of the region and to associate a specified handler/cleanup with\n    the region. The rtl code in HANDLER will be invoked whenever an\n@@ -184,14 +194,14 @@ Boston, MA 02111-1307, USA.  */\n    will be emitted at the end of the function.\n \n    Cleanups can also be specified by using add_partial_entry (handler)\n-   and end_protect_partials (). add_partial_entry creates the start of\n+   and end_protect_partials. add_partial_entry creates the start of\n    a new exception region; HANDLER will be invoked if an exception is\n    thrown with the context of the region between the calls to\n    add_partial_entry and end_protect_partials. end_protect_partials is\n    used to mark the end of these regions. add_partial_entry can be\n    called as many times as needed before calling end_protect_partials.\n    However, end_protect_partials should only be invoked once for each\n-   group of calls to add_partial_entry () as the entries are queued\n+   group of calls to add_partial_entry as the entries are queued\n    and all of the outstanding entries are processed simultaneously\n    when end_protect_partials is invoked. Similarly to the other\n    handlers, the code for HANDLER will be emitted at the end of the\n@@ -209,20 +219,30 @@ Boston, MA 02111-1307, USA.  */\n    exception involves calling __throw).  If an exception region is\n    created but no function calls occur within that region, the region\n    can be safely optimized away (along with its exception handlers)\n-   since no exceptions can ever be caught in that region.\n+   since no exceptions can ever be caught in that region.  This\n+   optimization is performed unless -fasynchronous-exceptions is\n+   given.  If the user wishes to throw from a signal handler, or other\n+   asynchronous place, -fasynchronous-exceptions should be used when\n+   compiling for maximally correct code, at the cost of additional\n+   exception regions.  Using -fasynchronous-exceptions only produces\n+   code that is reasonably safe in such situations, but a correct\n+   program cannot rely upon this working.  It can be used in failsafe\n+   code, where trying to continue on, and proceeding with potentially\n+   incorrect results is better than halting the program.\n+\n \n    Unwinding the stack:\n \n    The details of unwinding the stack to the next frame can be rather\n-   complex. While in many cases a generic __unwind_function () routine\n+   complex. While in many cases a generic __unwind_function routine\n    can be used by the generated exception handling code to do this, it\n    is often necessary to generate inline code to do the unwinding.\n \n    Whether or not these inlined unwinders are necessary is\n    target-specific.\n \n    By default, if the target-specific backend doesn't supply a\n-   definition for __unwind_function (), inlined unwinders will be used\n+   definition for __unwind_function, inlined unwinders will be used\n    instead. The main tradeoff here is in text space utilization.\n    Obviously, if inline unwinders have to be generated repeatedly,\n    this uses much more space than if a single routine is used.\n@@ -240,14 +260,14 @@ Boston, MA 02111-1307, USA.  */\n    is defined and has a non-zero value, a per-function unwinder is\n    not emitted for the current function.\n \n-   On some platforms it is possible that neither __unwind_function ()\n+   On some platforms it is possible that neither __unwind_function\n    nor inlined unwinders are available. For these platforms it is not\n-   possible to throw through a function call, and abort () will be\n+   possible to throw through a function call, and abort will be\n    invoked instead of performing the throw. \n \n    Future directions:\n \n-   Currently __throw () makes no differentiation between cleanups and\n+   Currently __throw makes no differentiation between cleanups and\n    user-defined exception regions. While this makes the implementation\n    simple, it also implies that it is impossible to determine if a\n    user-defined exception handler exists for a given exception without\n@@ -258,7 +278,7 @@ Boston, MA 02111-1307, USA.  */\n \n    This problem can be solved by marking user-defined handlers in a\n    special way (probably by adding additional bits to exception_table_list).\n-   A two-pass scheme could then be used by __throw () to iterate\n+   A two-pass scheme could then be used by __throw to iterate\n    through the table. The first pass would search for a relevant\n    user-defined handler for the current context of the throw, and if\n    one is found, the second pass would then invoke all needed cleanups\n@@ -268,36 +288,36 @@ Boston, MA 02111-1307, USA.  */\n    user-defined handler conditional on the \"type\" of the exception\n    thrown. (The type of the exception is actually the type of the data\n    that is thrown with the exception.) It will thus be necessary for\n-   __throw () to be able to determine if a given user-defined\n+   __throw to be able to determine if a given user-defined\n    exception handler will actually be executed, given the type of\n    exception.\n \n    One scheme is to add additional information to exception_table_list\n-   as to the types of exceptions accepted by each handler. __throw ()\n+   as to the types of exceptions accepted by each handler. __throw\n    can do the type comparisons and then determine if the handler is\n    actually going to be executed.\n \n    There is currently no significant level of debugging support\n-   available, other than to place a breakpoint on __throw (). While\n+   available, other than to place a breakpoint on __throw. While\n    this is sufficient in most cases, it would be helpful to be able to\n    know where a given exception was going to be thrown to before it is\n    actually thrown, and to be able to choose between stopping before\n    every exception region (including cleanups), or just user-defined\n    exception regions. This should be possible to do in the two-pass\n-   scheme by adding additional labels to __throw () for appropriate\n+   scheme by adding additional labels to __throw for appropriate\n    breakpoints, and additional debugger commands could be added to\n    query various state variables to determine what actions are to be\n    performed next.\n \n    Another major problem that is being worked on is the issue with\n    stack unwinding on various platforms. Currently the only platform\n-   that has support for __unwind_function () is the Sparc; all other\n+   that has support for __unwind_function is the Sparc; all other\n    ports require per-function unwinders, which causes large amounts of\n    code bloat.\n \n    Ideally it would be possible to store a small set of metadata with\n    each function that would then make it possible to write a\n-   __unwind_function () for every platform. This would eliminate the\n+   __unwind_function for every platform. This would eliminate the\n    need for per-function unwinders.\n \n    The main reason the data is needed is that on some platforms the\n@@ -310,7 +330,27 @@ Boston, MA 02111-1307, USA.  */\n    aren't compiled with exception handling support will still not be\n    possible on some platforms. This problem is currently being\n    investigated, but no solutions have been found that do not imply\n-   some unacceptable performance penalties.  */\n+   some unacceptable performance penalties.\n+\n+   For setjmp/longjmp based exception handling, some of the details\n+   are as above, but there are some additional details.  This section\n+   discusses the details.\n+\n+   We don't use NOTE_INSN_EH_REGION_{BEG,END} pairs.  We don't\n+   optimize EH regions yet.  We don't have to worry about machine\n+   specific issues with unwinding the stack, as we rely upon longjmp\n+   for all the machine specific details.  There is no variable context\n+   of a throw, just the one implied by the dynamic handler stack\n+   pointed to by the dynamic handler chain.  There is no exception\n+   table, and no calls to __register_excetpions.  __sjthrow is used\n+   instead of __throw, and it works by using the dynamic handler\n+   chain, and longjmp.  -fasynchronous-exceptions has no effect, as\n+   the elimination of trivial exception regions is not yet performed.\n+\n+   A frontend can set protect_cleanup_actions_with_terminate when all\n+   the cleanup actions should be protected with an EH region that\n+   calls terminate when an unhandled exception is throw.  C++ does\n+   this, Ada does not.  */\n \n \n #include \"config.h\"\n@@ -330,6 +370,20 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"assert.h\"\n \n+/* One to use setjmp/longjmp method of generating code for exception\n+   handling.  */\n+\n+int exceptions_via_longjmp = 1;\n+\n+/* One to enable asynchronous exception support.  */\n+\n+int asynchronous_exceptions = 0;\n+\n+/* One to protect cleanup actions with a handler that calls\n+   __terminate, zero otherwise.  */\n+\n+int protect_cleanup_actions_with_terminate = 0;\n+\n /* A list of labels used for exception handlers.  Created by\n    find_exception_handler_labels for the optimization passes.  */\n \n@@ -342,30 +396,42 @@ rtx exception_handler_labels;\n \n int throw_used;\n \n+/* The dynamic handler chain.  Nonzero if the function has already\n+   fetched a pointer to the dynamic handler chain for exception\n+   handling.  */\n+\n+rtx current_function_dhc;\n+\n+/* The dynamic cleanup chain.  Nonzero if the function has already\n+   fetched a pointer to the dynamic cleanup chain for exception\n+   handling.  */\n+\n+rtx current_function_dcc;\n+\n /* A stack used for keeping track of the currectly active exception\n    handling region.  As each exception region is started, an entry\n    describing the region is pushed onto this stack.  The current\n    region can be found by looking at the top of the stack, and as we\n    exit regions, the corresponding entries are popped. \n \n-   Entries cannot overlap; they must be nested. So there is only one\n+   Entries cannot overlap; they can be nested. So there is only one\n    entry at most that corresponds to the current instruction, and that\n    is the entry on the top of the stack.  */\n \n-struct eh_stack ehstack;\n+static struct eh_stack ehstack;\n \n /* A queue used for tracking which exception regions have closed but\n    whose handlers have not yet been expanded. Regions are emitted in\n    groups in an attempt to improve paging performance.\n \n    As we exit a region, we enqueue a new entry. The entries are then\n-   dequeued during expand_leftover_cleanups () and expand_start_all_catch (),\n+   dequeued during expand_leftover_cleanups and expand_start_all_catch,\n \n    We should redo things so that we either take RTL for the handler,\n    or we expand the handler expressed as a tree immediately at region\n    end time.  */\n \n-struct eh_queue ehqueue;\n+static struct eh_queue ehqueue;\n \n /* Insns for all of the exception handlers for the current function.\n    They are currently emitted by the frontend code.  */\n@@ -599,9 +665,10 @@ eh_outer_context (addr)\n   return addr;\n }\n \n-/* Start a new exception region and push the HANDLER for the region\n-   onto protect_list. All of the regions created with add_partial_entry\n-   will be ended when end_protect_partials () is invoked.  */\n+/* Start a new exception region for a region of code that has a\n+   cleanup action and push the HANDLER for the region onto\n+   protect_list. All of the regions created with add_partial_entry\n+   will be ended when end_protect_partials is invoked.  */\n \n void\n add_partial_entry (handler)\n@@ -612,13 +679,322 @@ add_partial_entry (handler)\n   /* Make sure the entry is on the correct obstack.  */\n   push_obstacks_nochange ();\n   resume_temporary_allocation ();\n+\n+  /* Because this is a cleanup action, we may have to protect the handler\n+     with __terminate.  */\n+  handler = protect_with_terminate (handler);\n+\n   protect_list = tree_cons (NULL_TREE, handler, protect_list);\n   pop_obstacks ();\n }\n \n-/* Output a note marking the start of an exception handling region.\n+/* Get a reference to the dynamic handler chain.  It points to the\n+   pointer to the next element in the dynamic handler chain.  It ends\n+   when there are no more elements in the dynamic handler chain, when\n+   the value is &top_elt from libgcc2.c.  Immediately after the\n+   pointer, is an area suitable for setjmp/longjmp when\n+   USE_BUILTIN_SETJMP isn't defined, and an area suitable for\n+   __builtin_setjmp/__builtin_longjmp when USE_BUILTIN_SETJMP is\n+   defined.\n+\n+   This routine is here to facilitate the porting of this code to\n+   systems with threads.  One can either replace the routine we emit a\n+   call for here in libgcc2.c, or one can modify this routine to work\n+   with their thread system.  */\n+\n+rtx\n+get_dynamic_handler_chain ()\n+{\n+#if 0\n+  /* Do this once we figure out how to get this to the front of the\n+     function, and we really only want one per real function, not one\n+     per inlined function.  */\n+  if (current_function_dhc == 0)\n+    {\n+      rtx dhc, insns;\n+      start_sequence ();\n+\n+      dhc = emit_library_call_value (get_dynamic_handler_chain_libfunc,\n+\t\t\t\t     NULL_RTX, 1,\n+\t\t\t\t     Pmode, 0);\n+      current_function_dhc = copy_to_reg (dhc);\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_insns_before (insns, get_first_nonparm_insn ());\n+    }\n+#else\n+  rtx dhc;\n+  dhc = emit_library_call_value (get_dynamic_handler_chain_libfunc,\n+\t\t\t\t NULL_RTX, 1,\n+\t\t\t\t Pmode, 0);\n+  current_function_dhc = copy_to_reg (dhc);\n+#endif\n+\n+  /* We don't want a copy of the dhc, but rather, the single dhc.  */\n+  return gen_rtx (MEM, Pmode, current_function_dhc);\n+}\n+\n+/* Get a reference to the dynamic cleanup chain.  It points to the\n+   pointer to the next element in the dynamic cleanup chain.\n+   Immediately after the pointer, are two Pmode variables, one for a\n+   pointer to a function that performs the cleanup action, and the\n+   second, the argument to pass to that function.  */\n+\n+rtx\n+get_dynamic_cleanup_chain ()\n+{\n+  rtx dhc, dcc;\n+\n+  dhc = get_dynamic_handler_chain ();\n+  dcc = plus_constant (dhc, GET_MODE_SIZE (Pmode));\n+\n+  current_function_dcc = copy_to_reg (dcc);\n+\n+  /* We don't want a copy of the dcc, but rather, the single dcc.  */\n+  return gen_rtx (MEM, Pmode, current_function_dcc);\n+}\n+\n+/* Generate code to evaluate X and jump to LABEL if the value is nonzero.\n+   LABEL is an rtx of code CODE_LABEL, in this function.  */\n+\n+void\n+jumpif_rtx (x, label)\n+     rtx x;\n+     rtx label;\n+{\n+  jumpif (make_tree (type_for_mode (GET_MODE (x), 0), x), label);\n+}\n+\n+/* Generate code to evaluate X and jump to LABEL if the value is zero.\n+   LABEL is an rtx of code CODE_LABEL, in this function.  */\n+\n+void\n+jumpifnot_rtx (x, label)\n+     rtx x;\n+     rtx label;\n+{\n+  jumpifnot (make_tree (type_for_mode (GET_MODE (x), 0), x), label);\n+}\n+\n+/* Start a dynamic cleanup on the EH runtime dynamic cleanup stack.\n+   We just need to create an element for the cleanup list, and push it\n+   into the chain.\n+\n+   A dynamic cleanup is a cleanup action implied by the presence of an\n+   element on the EH runtime dynamic cleanup stack that is to be\n+   performed when an exception is thrown.  The cleanup action is\n+   performed by __sjthrow when an exception is thrown.  Only certain\n+   actions can be optimized into dynamic cleanup actions.  For the\n+   restrictions on what actions can be performed using this routine,\n+   see expand_eh_region_start_tree.  */\n+\n+static void\n+start_dynamic_cleanup (func, arg)\n+     tree func;\n+     tree arg;\n+{\n+  rtx dhc, dcc;\n+  rtx new_func, new_arg;\n+  rtx x, buf;\n+  int size;\n+\n+  /* We allocate enough room for a pointer to the function, and\n+     one argument.  */\n+  size = 2;\n+\n+  /* XXX, FIXME: The stack space allocated this way is too long lived,\n+     but there is no allocation routine that allocates at the level of\n+     the last binding contour.  */\n+  buf = assign_stack_local (BLKmode,\n+\t\t\t    GET_MODE_SIZE (Pmode)*(size+1),\n+\t\t\t    0);\n+\n+  buf = change_address (buf, Pmode, NULL_RTX);\n+\n+  /* Store dcc into the first word of the newly allocated buffer.  */\n+\n+  dcc = get_dynamic_cleanup_chain ();\n+  emit_move_insn (buf, dcc);\n+\n+  /* Store func and arg into the cleanup list element.  */\n+\n+  new_func = gen_rtx (MEM, Pmode, plus_constant (XEXP (buf, 0),\n+\t\t\t\t\t\t GET_MODE_SIZE (Pmode)));\n+  new_arg = gen_rtx (MEM, Pmode, plus_constant (XEXP (buf, 0),\n+\t\t\t\t\t\tGET_MODE_SIZE (Pmode)*2));\n+  x = expand_expr (func, new_func, Pmode, 0);\n+  if (x != new_func)\n+    emit_move_insn (new_func, x);\n+\n+  x = expand_expr (arg, new_arg, Pmode, 0);\n+  if (x != new_arg)\n+    emit_move_insn (new_arg, x);\n+\n+  /* Update the cleanup chain.  */\n+\n+  emit_move_insn (dcc, XEXP (buf, 0));\n+}\n+\n+/* Emit RTL to start a dynamic handler on the EH runtime dynamic\n+   handler stack.  This should only be used by expand_eh_region_start\n+   or expand_eh_region_start_tree.  */\n+\n+static void\n+start_dynamic_handler ()\n+{\n+  rtx dhc, dcc;\n+  rtx x, arg;\n+  int size;\n+\n+#ifdef USE_BUILTIN_SETJMP\n+  /* The number of Pmode words for the setjmp buffer, when using the\n+     builtin setjmp/longjmp, see expand_builtin, case\n+     BUILT_IN_LONGJMP.  */\n+  size = 5;\n+#else\n+#ifdef JMP_BUF_SIZE\n+  size = JMP_BUF_SIZE;\n+#else\n+  /* Should be large enough for most systems, if it is not,\n+     JMP_BUF_SIZE should be defined with the proper value.  It will\n+     also tend to be larger than necessary for most systems, a more\n+     optimal port will define JMP_BUF_SIZE.  */\n+  size = FIRST_PSEUDO_REGISTER+2;\n+#endif\n+#endif\n+  /* XXX, FIXME: The stack space allocated this way is too long lived,\n+     but there is no allocation routine that allocates at the level of\n+     the last binding contour.  */\n+  arg = assign_stack_local (BLKmode,\n+\t\t\t    GET_MODE_SIZE (Pmode)*(size+1),\n+\t\t\t    0);\n+\n+  arg = change_address (arg, Pmode, NULL_RTX);\n+\n+  /* Store dhc into the first word of the newly allocated buffer.  */\n+\n+  dhc = get_dynamic_handler_chain ();\n+  dcc = gen_rtx (MEM, Pmode, plus_constant (XEXP (arg, 0),\n+\t\t\t\t\t    GET_MODE_SIZE (Pmode)));\n+  emit_move_insn (arg, dhc);\n+\n+  /* Zero out the start of the cleanup chain.  */\n+  emit_move_insn (dcc, const0_rtx);\n+\n+  /* The jmpbuf starts two words into the area allocated.  */\n+\n+  x = emit_library_call_value (setjmp_libfunc, NULL_RTX, 1, SImode, 1,\n+\t\t\t       plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2),\n+\t\t\t       Pmode);\n+\n+  /* If we come back here for a catch, transfer control to the\n+     handler.  */\n+\n+  jumpif_rtx (x, ehstack.top->entry->exception_handler_label);\n+\n+  /* We are committed to this, so update the handler chain.  */\n+\n+  emit_move_insn (dhc, XEXP (arg, 0));\n+}\n+\n+/* Start an exception handling region for the given cleanup action.\n    All instructions emitted after this point are considered to be part\n-   of the region until expand_eh_region_end () is invoked.  */\n+   of the region until expand_eh_region_end is invoked.  CLEANUP is\n+   the cleanup action to perform.  The return value is true if the\n+   exception region was optimized away.  If that case,\n+   expand_eh_region_end does not need to be called for this cleanup,\n+   nor should it be.\n+\n+   This routine notices one particular common case in C++ code\n+   generation, and optimizes it so as to not need the exception\n+   region.  It works by creating a dynamic cleanup action, instead of\n+   of a using an exception region.  */\n+\n+int\n+expand_eh_region_start_tree (cleanup)\n+     tree cleanup;\n+{\n+  rtx note;\n+\n+  /* This is the old code.  */\n+  if (! doing_eh (0))\n+    return 0;\n+\n+  /* The optimization only applies to actions protected with\n+     terminate, and only applies if we are using the setjmp/longjmp\n+     codegen method.  */\n+  if (exceptions_via_longjmp\n+      && protect_cleanup_actions_with_terminate)\n+    {\n+      tree func, arg;\n+      tree args;\n+\n+      /* Ignore any UNSAVE_EXPR.  */\n+      if (TREE_CODE (cleanup) == UNSAVE_EXPR)\n+\tcleanup = TREE_OPERAND (cleanup, 0);\n+      \n+      /* Further, it only applies if the action is a call, if there\n+\t are 2 arguments, and if the second argument is 2.  */\n+\n+      if (TREE_CODE (cleanup) == CALL_EXPR\n+\t  && (args = TREE_OPERAND (cleanup, 1))\n+\t  && (func = TREE_OPERAND (cleanup, 0))\n+\t  && (arg = TREE_VALUE (args))\n+\t  && (args = TREE_CHAIN (args))\n+\n+\t  /* is the second argument 2?  */\n+\t  && TREE_CODE (TREE_VALUE (args)) == INTEGER_CST\n+\t  && TREE_INT_CST_LOW (TREE_VALUE (args)) == 2\n+\t  && TREE_INT_CST_HIGH (TREE_VALUE (args)) == 0\n+\n+\t  /* Make sure there are no other arguments.  */\n+\t  && TREE_CHAIN (args) == NULL_TREE)\n+\t{\n+\t  /* Arrange for returns and gotos to pop the entry we make on the\n+\t     dynamic cleanup stack.  */\n+\t  expand_dcc_cleanup ();\n+\t  start_dynamic_cleanup (func, arg);\n+\t  return 1;\n+\t}\n+    }\n+\n+  if (exceptions_via_longjmp)\n+    {\n+      /* We need a new block to record the start and end of the\n+\t dynamic handler chain.  We could always do this, but we\n+\t really want to permit jumping into such a block, and we want\n+\t to avoid any errors or performance impact in the SJ EH code\n+\t for now.  */\n+      expand_start_bindings (0);\n+\n+      /* But we don't need or want a new temporary level.  */\n+      pop_temp_slots ();\n+\n+      /* Mark this block as created by expand_eh_region_start.  This\n+\t is so that we can pop the block with expand_end_bindings\n+\t automatically.  */\n+      mark_block_as_eh_region ();\n+\n+      /* Arrange for returns and gotos to pop the entry we make on the\n+\t dynamic handler stack.  */\n+      expand_dhc_cleanup ();\n+    }\n+\n+  if (exceptions_via_longjmp == 0)\n+    note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_BEG);\n+  emit_label (push_eh_entry (&ehstack));\n+  if (exceptions_via_longjmp == 0)\n+    NOTE_BLOCK_NUMBER (note)\n+      = CODE_LABEL_NUMBER (ehstack.top->entry->exception_handler_label);\n+  if (exceptions_via_longjmp)\n+    start_dynamic_handler ();\n+\n+  return 0;\n+}\n+\n+/* Start an exception handling region.  All instructions emitted after\n+   this point are considered to be part of the region until\n+   expand_eh_region_end is invoked.  */\n \n void\n expand_eh_region_start ()\n@@ -629,80 +1005,127 @@ expand_eh_region_start ()\n   if (! doing_eh (0))\n     return;\n \n-#if 0\n-  /* Maybe do this to prevent jumping in and so on...  */\n-  pushlevel (0);\n-#endif\n+  if (exceptions_via_longjmp)\n+    {\n+      /* We need a new block to record the start and end of the\n+\t dynamic handler chain.  We could always do this, but we\n+\t really want to permit jumping into such a block, and we want\n+\t to avoid any errors or performance impact in the SJ EH code\n+\t for now.  */\n+      expand_start_bindings (0);\n+\n+      /* But we don't need or want a new temporary level.  */\n+      pop_temp_slots ();\n+\n+      /* Mark this block as created by expand_eh_region_start.  This\n+\t is so that we can pop the block with expand_end_bindings\n+\t automatically.  */\n+      mark_block_as_eh_region ();\n+\n+      /* Arrange for returns and gotos to pop the entry we make on the\n+\t dynamic handler stack.  */\n+      expand_dhc_cleanup ();\n+    }\n \n-  note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_BEG);\n+  if (exceptions_via_longjmp == 0)\n+    note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_BEG);\n   emit_label (push_eh_entry (&ehstack));\n-  NOTE_BLOCK_NUMBER (note)\n-    = CODE_LABEL_NUMBER (ehstack.top->entry->exception_handler_label);\n+  if (exceptions_via_longjmp == 0)\n+    NOTE_BLOCK_NUMBER (note)\n+      = CODE_LABEL_NUMBER (ehstack.top->entry->exception_handler_label);\n+  if (exceptions_via_longjmp)\n+    start_dynamic_handler ();\n }\n \n-/* Output a note marking the end of the exception handling region on\n-   the top of ehstack.\n+/* End an exception handling region.  The information about the region\n+   is found on the top of ehstack.\n \n    HANDLER is either the cleanup for the exception region, or if we're\n    marking the end of a try block, HANDLER is integer_zero_node.\n \n-   HANDLER will be transformed to rtl when expand_leftover_cleanups ()\n+   HANDLER will be transformed to rtl when expand_leftover_cleanups\n    is invoked.  */\n \n void\n expand_eh_region_end (handler)\n      tree handler;\n {\n-  rtx note;\n-\n   struct eh_entry *entry;\n \n   if (! doing_eh (0))\n     return;\n \n   entry = pop_eh_entry (&ehstack);\n \n-  note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n-  NOTE_BLOCK_NUMBER (note) = CODE_LABEL_NUMBER (entry->exception_handler_label);\n+  if (exceptions_via_longjmp == 0)\n+    {\n+      rtx note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n+      NOTE_BLOCK_NUMBER (note) = CODE_LABEL_NUMBER (entry->exception_handler_label);\n+    }\n \n   /* Emit a label marking the end of this exception region.  */\n   emit_label (entry->end_label);\n \n-  /* Put in something that takes up space, as otherwise the end\n-     address for this EH region could have the exact same address as\n-     its outer region. This would cause us to miss the fact that\n-     resuming exception handling with this PC value would be inside\n-     the outer region.  */\n-  emit_insn (gen_nop ());\n+  if (exceptions_via_longjmp == 0)\n+    {\n+      /* Put in something that takes up space, as otherwise the end\n+\t address for this EH region could have the exact same address as\n+\t its outer region. This would cause us to miss the fact that\n+\t resuming exception handling with this PC value would be inside\n+\t the outer region.  */\n+      emit_insn (gen_nop ());\n+    }\n \n   entry->finalization = handler;\n \n   enqueue_eh_entry (&ehqueue, entry);\n \n-#if 0\n-  /* Maybe do this to prevent jumping in and so on...  */\n-  poplevel (1, 0, 0);\n-#endif\n+  /* If we have already started ending the bindings, don't recurse.\n+     This only happens when exceptions_via_longjmp is true.  */\n+  if (is_eh_region ())\n+    {\n+      /* Because we don't need or want a new temporary level and\n+\t because we didn't create one in expand_eh_region_start,\n+\t create a fake one now to avoid removing one in\n+\t expand_end_bindings.  */\n+      push_temp_slots ();\n+\n+      mark_block_as_not_eh_region ();\n+\n+      /* Maybe do this to prevent jumping in and so on...  */\n+      expand_end_bindings (NULL_TREE, 0, 0);\n+    }\n }\n \n-/* Emit a call to __throw and note that we threw something, so we know\n-   we need to generate the necessary code for __throw.  \n+/* If we are using the setjmp/longjmp EH codegen method, we emit a\n+   call to __sjthrow.\n+\n+   Otherwise, we emit a call to __throw and note that we threw\n+   something, so we know we need to generate the necessary code for\n+   __throw.\n \n    Before invoking throw, the __eh_pc variable must have been set up\n    to contain the PC being thrown from. This address is used by\n-   __throw () to determine which exception region (if any) is\n+   __throw to determine which exception region (if any) is\n    responsible for handling the exception.  */\n \n-static void\n+void\n emit_throw ()\n {\n+  if (exceptions_via_longjmp)\n+    {\n+      emit_library_call (sjthrow_libfunc, 0, VOIDmode, 0);\n+    }\n+  else\n+    {\n #ifdef JUMP_TO_THROW\n-  emit_indirect_jump (throw_libfunc);\n+      emit_indirect_jump (throw_libfunc);\n #else\n-  SYMBOL_REF_USED (throw_libfunc) = 1;\n-  emit_library_call (throw_libfunc, 0, VOIDmode, 0);\n+      SYMBOL_REF_USED (throw_libfunc) = 1;\n+      emit_library_call (throw_libfunc, 0, VOIDmode, 0);\n #endif\n-  throw_used = 1;\n+      throw_used = 1;\n+    }\n   emit_barrier ();\n }\n \n@@ -730,7 +1153,7 @@ expand_internal_throw (context)\n }\n \n /* Called from expand_exception_blocks and expand_end_catch_block to\n-   emit any pending handlers/cleanups queued from expand_eh_region_end ().  */\n+   emit any pending handlers/cleanups queued from expand_eh_region_end.  */\n \n void\n expand_leftover_cleanups ()\n@@ -752,13 +1175,18 @@ expand_leftover_cleanups ()\n       expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n       prev = get_last_insn ();\n-      if (! (prev && GET_CODE (prev) == BARRIER))\n+      if (prev == NULL || GET_CODE (prev) != BARRIER)\n \t{\n-\t  /* The below can be optimized away, and we could just fall into the\n-\t     next EH handler, if we are certain they are nested.  */\n-\t  /* Emit code to throw to the outer context if we fall off\n-\t     the end of the handler.  */\n-\t  expand_internal_throw (entry->end_label);\n+\t  if (exceptions_via_longjmp)\n+\t    emit_throw ();\n+\t  else\n+\t    {\n+\t      /* The below can be optimized away, and we could just fall into the\n+\t\t next EH handler, if we are certain they are nested.  */\n+\t      /* Emit code to throw to the outer context if we fall off\n+\t\t the end of the handler.  */\n+\t      expand_internal_throw (entry->end_label);\n+\t    }\n \t}\n \n       free (entry);\n@@ -801,12 +1229,15 @@ expand_start_all_catch ()\n      This is Lresume in the documention.  */\n   expand_label (label);\n   \n-  /* Put in something that takes up space, as otherwise the end\n-     address for the EH region could have the exact same address as\n-     the outer region, causing us to miss the fact that resuming\n-     exception handling with this PC value would be inside the outer\n-     region.  */\n-  emit_insn (gen_nop ());\n+  if (exceptions_via_longjmp == 0)\n+    {\n+      /* Put in something that takes up space, as otherwise the end\n+\t address for the EH region could have the exact same address as\n+\t the outer region, causing us to miss the fact that resuming\n+\t exception handling with this PC value would be inside the outer\n+\t region.  */\n+      emit_insn (gen_nop ());\n+    }\n \n   /* Push the label that points to where normal flow is resumed onto\n      the top of the label stack.  */\n@@ -832,7 +1263,6 @@ expand_start_all_catch ()\n \t still be emitted, so any code emitted after this point will\n \t end up being the handler.  */\n       emit_label (entry->exception_handler_label);\n-      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n       /* When we get down to the matching entry for this try block, stop.  */\n       if (entry->finalization == integer_zero_node)\n@@ -842,18 +1272,26 @@ expand_start_all_catch ()\n \t  break;\n \t}\n \n+      /* And now generate the insns for the handler.  */\n+      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+\n       prev = get_last_insn ();\n       if (prev == NULL || GET_CODE (prev) != BARRIER)\n \t{\n-\t  /* Code to throw out to outer context when we fall off end\n-\t     of the handler. We can't do this here for catch blocks,\n-\t     so it's done in expand_end_all_catch () instead.\n+\t  if (exceptions_via_longjmp)\n+\t    emit_throw ();\n+\t  else\n+\t    {\n+\t      /* Code to throw out to outer context when we fall off end\n+\t\t of the handler. We can't do this here for catch blocks,\n+\t\t so it's done in expand_end_all_catch instead.\n \n-\t     The below can be optimized away (and we could just fall\n-\t     into the next EH handler) if we are certain they are\n-\t     nested.  */\n+\t\t The below can be optimized away (and we could just fall\n+\t\t into the next EH handler) if we are certain they are\n+\t\t nested.  */\n \n-\t  expand_internal_throw (entry->end_label);\n+\t      expand_internal_throw (entry->end_label);\n+\t    }\n \t}\n       free (entry);\n     }\n@@ -873,17 +1311,22 @@ expand_end_all_catch ()\n   if (! doing_eh (1))\n     return;\n \n-  /* Code to throw out to outer context, if we fall off end of catch\n-     handlers.  This is rethrow (Lresume, same id, same obj) in the\n-     documentation. We use Lresume because we know that it will throw\n-     to the correct context.\n+  if (exceptions_via_longjmp)\n+    emit_throw ();\n+  else\n+    {\n+      /* Code to throw out to outer context, if we fall off end of catch\n+\t handlers.  This is rethrow (Lresume, same id, same obj) in the\n+\t documentation. We use Lresume because we know that it will throw\n+\t to the correct context.\n \n-     In other words, if the catch handler doesn't exit or return, we\n-     do a \"throw\" (using the address of Lresume as the point being\n-     thrown from) so that the outer EH region can then try to process\n-     the exception.  */\n+\t In other words, if the catch handler doesn't exit or return, we\n+\t do a \"throw\" (using the address of Lresume as the point being\n+\t thrown from) so that the outer EH region can then try to process\n+\t the exception.  */\n \n-  expand_internal_throw (DECL_RTL (top_label_entry (&caught_return_label_stack)));\n+      expand_internal_throw (DECL_RTL (top_label_entry (&caught_return_label_stack)));\n+    }\n \n   /* Now we have the complete catch sequence.  */\n   new_catch_clause = get_insns ();\n@@ -903,7 +1346,7 @@ expand_end_all_catch ()\n }\n \n /* End all the pending exception regions on protect_list. The handlers\n-   will be emitted when expand_leftover_cleanups () is invoked.  */\n+   will be emitted when expand_leftover_cleanups is invoked.  */\n \n void\n end_protect_partials ()\n@@ -914,14 +1357,57 @@ end_protect_partials ()\n       protect_list = TREE_CHAIN (protect_list);\n     }\n }\n+\n+/* Arrange for __terminate to be called if there is an unhandled throw\n+   from within E.  */\n+\n+tree\n+protect_with_terminate (e)\n+     tree e;\n+{\n+  /* We only need to do this when using setjmp/longjmp EH and the\n+     language requires it, as otherwise we protect all of the handlers\n+     at once, if we need to.  */\n+  if (exceptions_via_longjmp && protect_cleanup_actions_with_terminate)\n+    {\n+      tree handler, result;\n+\n+      /* All cleanups must be on the function_obstack.  */\n+      push_obstacks_nochange ();\n+      resume_temporary_allocation ();\n+\n+      handler = make_node (RTL_EXPR);\n+      TREE_TYPE (handler) = void_type_node;\n+      RTL_EXPR_RTL (handler) = const0_rtx;\n+      TREE_SIDE_EFFECTS (handler) = 1;\n+      start_sequence_for_rtl_expr (handler);\n+\n+      emit_library_call (terminate_libfunc, 0, VOIDmode, 0);\n+      emit_barrier ();\n+\n+      RTL_EXPR_SEQUENCE (handler) = get_insns ();\n+      end_sequence ();\n+\t\n+      result = build (TRY_CATCH_EXPR, TREE_TYPE (e), e, handler);\n+      TREE_SIDE_EFFECTS (result) = TREE_SIDE_EFFECTS (e);\n+      TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n+      TREE_READONLY (result) = TREE_READONLY (e);\n+\n+      pop_obstacks ();\n+\n+      e = result;\n+    }\n+\n+  return e;\n+}\n \f\n /* The exception table that we build that is used for looking up and\n    dispatching exceptions, the current number of entries, and its\n    maximum size before we have to extend it. \n \n    The number in eh_table is the code label number of the exception\n-   handler for the region. This is added by add_eh_table_entry () and\n-   used by output_exception_table_entry ().  */\n+   handler for the region. This is added by add_eh_table_entry and\n+   used by output_exception_table_entry.  */\n \n static int *eh_table;\n static int eh_table_size;\n@@ -1055,7 +1541,7 @@ register_exception_table ()\n }\n \f\n /* Emit the RTL for the start of the per-function unwinder for the\n-   current function. See emit_unwinder () for further information.\n+   current function. See emit_unwinder for further information.\n \n    DOESNT_NEED_UNWINDER is a target-specific macro that determines if\n    the current function actually needs a per-function unwinder or not.\n@@ -1069,6 +1555,12 @@ start_eh_unwinder ()\n     return;\n #endif\n \n+  /* If we are using the setjmp/longjmp implementation, we don't need a\n+     per function unwinder.  */\n+\n+  if (exceptions_via_longjmp)\n+    return;\n+\n   expand_eh_region_start ();\n }\n \n@@ -1089,6 +1581,12 @@ end_eh_unwinder ()\n     return;\n #endif\n \n+  /* If we are using the setjmp/longjmp implementation, we don't need a\n+     per function unwinder.  */\n+\n+  if (exceptions_via_longjmp)\n+    return;\n+\n   assemble_external (eh_saved_pc);\n \n   expr = make_node (RTL_EXPR);\n@@ -1128,6 +1626,7 @@ end_eh_unwinder ()\n \n   RTL_EXPR_SEQUENCE (expr) = get_insns ();\n   end_sequence ();\n+\n   expand_eh_region_end (expr);\n \n   emit_jump (end);\n@@ -1319,8 +1818,8 @@ check_exception_handler_labels ()\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE\n-\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG ||\n-\t      NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n+\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n+\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n \t{\n \t  for (handler = exception_handler_labels;\n \t       handler;\n@@ -1370,12 +1869,14 @@ init_eh_for_function ()\n   false_label_stack = 0;\n   caught_return_label_stack = 0;\n   protect_list = NULL_TREE;\n+  current_function_dhc = NULL_RTX;\n+  current_function_dcc = NULL_RTX;\n }\n \n /* Save some of the per-function EH info into the save area denoted by\n    P. \n \n-   This is currently called from save_stmt_status ().  */\n+   This is currently called from save_stmt_status.  */\n \n void\n save_eh_status (p)\n@@ -1389,6 +1890,8 @@ save_eh_status (p)\n   p->false_label_stack = false_label_stack;\n   p->caught_return_label_stack = caught_return_label_stack;\n   p->protect_list = protect_list;\n+  p->dhc = current_function_dhc;\n+  p->dcc = current_function_dcc;\n \n   init_eh ();\n }\n@@ -1409,6 +1912,8 @@ restore_eh_status (p)\n   catch_clauses\t= p->catch_clauses;\n   ehqueue = p->ehqueue;\n   ehstack = p->ehstack;\n+  current_function_dhc = p->dhc;\n+  current_function_dcc = p->dcc;\n }\n \f\n /* This section is for the exception handling specific optimization\n@@ -1425,12 +1930,13 @@ can_throw (insn)\n   if (GET_CODE (insn) == CALL_INSN)\n     return 1;\n \n-#ifdef ASYNCH_EXCEPTIONS\n-  /* If we wanted asynchronous exceptions, then everything but NOTEs\n-     and CODE_LABELs could throw.  */\n-  if (GET_CODE (insn) != NOTE && GET_CODE (insn) != CODE_LABEL)\n-    return 1;\n-#endif\n+  if (asynchronous_exceptions)\n+    {\n+      /* If we wanted asynchronous exceptions, then everything but NOTEs\n+\t and CODE_LABELs could throw.  */\n+      if (GET_CODE (insn) != NOTE && GET_CODE (insn) != CODE_LABEL)\n+\treturn 1;\n+    }\n \n   return 0;\n }\n@@ -1441,13 +1947,13 @@ can_throw (insn)\n    region can throw.\n \n    Regions are removed if they cannot possibly catch an exception.\n-   This is determined by invoking can_throw () on each insn within the\n+   This is determined by invoking can_throw on each insn within the\n    region; if can_throw returns true for any of the instructions, the\n    region can catch an exception, since there is an insn within the\n    region that is capable of throwing an exception.\n \n    Returns the NOTE_INSN_EH_REGION_END corresponding to this region, or\n-   calls abort () if it can't find one.\n+   calls abort if it can't find one.\n \n    Can abort if INSN is not a NOTE_INSN_EH_REGION_BEGIN, or if N doesn't\n    correspond to the region number, or if DELETE_OUTER is NULL.  */\n@@ -1554,16 +2060,20 @@ exception_optimize ()\n   rtx insn, regions = NULL_RTX;\n   int n;\n \n+  /* The below doesn't apply to setjmp/longjmp EH.  */\n+  if (exceptions_via_longjmp)\n+    return;\n+\n   /* Remove empty regions.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n \t{\n-\t  /* Since scan_region () will return the NOTE_INSN_EH_REGION_END\n+\t  /* Since scan_region will return the NOTE_INSN_EH_REGION_END\n \t     insn, we will indirectly skip through all the insns\n \t     inbetween. We are also guaranteed that the value of insn\n-\t     returned will be valid, as otherwise scan_region () won't\n+\t     returned will be valid, as otherwise scan_region won't\n \t     return.  */\n \t  insn = scan_region (insn, NOTE_BLOCK_NUMBER (insn), &n);\n \t}"}, {"sha": "b93a383bb6ab00f5969f1f2b9a0cd2bac49efbc3", "filename": "gcc/optabs.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a367780a72d84aff22bb78c1bca4b047d13f48/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=27a367780a72d84aff22bb78c1bca4b047d13f48", "patch": "@@ -119,6 +119,12 @@ rtx memset_libfunc;\n rtx bzero_libfunc;\n \n rtx throw_libfunc;\n+rtx sjthrow_libfunc;\n+rtx sjpopnthrow_libfunc;\n+rtx terminate_libfunc;\n+rtx setjmp_libfunc;\n+rtx longjmp_libfunc;\n+rtx get_dynamic_handler_chain_libfunc;\n \n rtx eqhf2_libfunc;\n rtx nehf2_libfunc;\n@@ -4268,6 +4274,17 @@ init_optabs ()\n   bzero_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"bzero\");\n \n   throw_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__throw\");\n+  sjthrow_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__sjthrow\");\n+  sjpopnthrow_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__sjpopnthrow\");\n+  terminate_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__terminate\");\n+#ifdef USE_BUILTIN_SETJMP\n+  setjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__builtin_setjmp\");\n+  longjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__builtin_longjmp\");\n+#else\n+  setjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"setjmp\");\n+  longjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"longjmp\");\n+#endif\n+  get_dynamic_handler_chain_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__get_dynamic_handler_chain\");\n \n   eqhf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__eqhf2\");\n   nehf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__nehf2\");"}]}