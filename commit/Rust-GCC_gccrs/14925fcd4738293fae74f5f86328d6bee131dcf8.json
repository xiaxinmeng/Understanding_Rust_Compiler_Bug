{"sha": "14925fcd4738293fae74f5f86328d6bee131dcf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ5MjVmY2Q0NzM4MjkzZmFlNzRmNWY4NjMyOGQ2YmVlMTMxZGNmOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-04T17:15:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-04T17:15:31Z"}, "message": "except.c (remove_eh_handler_and_replace): Break out from ...\n\n\t* except.c (remove_eh_handler_and_replace): Break out from ...\n\t(remove_eh_handler): ... here.\n\t(bring_to_root): New function.\n\t(remove_unreachable_regions): Collect MUST_NOT_THROW, unify runtime\n\thandled ones, bring others to root of tree.\n\nFrom-SVN: r145545", "tree": {"sha": "452f667b8f7772312789b3c5ac0378e0c8b4b261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/452f667b8f7772312789b3c5ac0378e0c8b4b261"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14925fcd4738293fae74f5f86328d6bee131dcf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14925fcd4738293fae74f5f86328d6bee131dcf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14925fcd4738293fae74f5f86328d6bee131dcf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14925fcd4738293fae74f5f86328d6bee131dcf8/comments", "author": null, "committer": null, "parents": [{"sha": "4cb735f794f9f1b7706eadcaae19cd0a4386b1a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cb735f794f9f1b7706eadcaae19cd0a4386b1a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cb735f794f9f1b7706eadcaae19cd0a4386b1a6"}], "stats": {"total": 124, "additions": 110, "deletions": 14}, "files": [{"sha": "730df1d450a9a5406d2f0d2eed5fc97d0ef4ffaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14925fcd4738293fae74f5f86328d6bee131dcf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14925fcd4738293fae74f5f86328d6bee131dcf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14925fcd4738293fae74f5f86328d6bee131dcf8", "patch": "@@ -1,3 +1,11 @@\n+2009-04-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* except.c (remove_eh_handler_and_replace): Break out from ...\n+\t(remove_eh_handler): ... here.\n+\t(bring_to_root): New function.\n+\t(remove_unreachable_regions): Collect MUST_NOT_THROW, unify runtime\n+\thandled ones, bring others to root of tree.\n+\n 2009-04-04  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-eh.c (tree_empty_eh_handler_p): Pattern match more curefully."}, {"sha": "2651e99f2d46cf0b733fe4f0afce6ba81d5c6fee", "filename": "gcc/except.c", "status": "modified", "additions": 102, "deletions": 14, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14925fcd4738293fae74f5f86328d6bee131dcf8/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14925fcd4738293fae74f5f86328d6bee131dcf8/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=14925fcd4738293fae74f5f86328d6bee131dcf8", "patch": "@@ -208,6 +208,7 @@ struct call_site_record GTY(())\n \n DEF_VEC_P(eh_region);\n DEF_VEC_ALLOC_P(eh_region, gc);\n+DEF_VEC_ALLOC_P(eh_region, heap);\n \n /* Used to save exception status for each function.  */\n struct eh_status GTY(())\n@@ -252,6 +253,8 @@ static int ehl_eq (const void *, const void *);\n static void add_ehl_entry (rtx, struct eh_region *);\n static void remove_exception_handler_label (rtx);\n static void remove_eh_handler (struct eh_region *);\n+static void remove_eh_handler_and_replace (struct eh_region *,\n+\t\t\t\t\t   struct eh_region *);\n static int for_each_eh_label_1 (void **, void *);\n \n /* The return value of reachable_next_level.  */\n@@ -718,21 +721,42 @@ can_be_reached_by_runtime (sbitmap contains_stmt, struct eh_region *r)\n     }\n }\n \n+/* Bring region R to the root of tree.  */\n+\n+static void\n+bring_to_root (struct eh_region *r)\n+{\n+  struct eh_region **pp;\n+  struct eh_region *outer = r->outer;\n+  if (!r->outer)\n+    return;\n+  for (pp = &outer->inner; *pp != r; pp = &(*pp)->next_peer)\n+    continue;\n+  *pp = r->next_peer;\n+  r->outer = NULL;\n+  r->next_peer = cfun->eh->region_tree;\n+  cfun->eh->region_tree = r;\n+}\n+\n /* Remove all regions whose labels are not reachable.\n    REACHABLE is bitmap of all regions that are used by the function\n    CONTAINS_STMT is bitmap of all regions that contains stmt (or NULL). */\n+\n void\n remove_unreachable_regions (sbitmap reachable, sbitmap contains_stmt)\n {\n   int i;\n   struct eh_region *r;\n+  VEC(eh_region,heap) *must_not_throws = VEC_alloc (eh_region, heap, 16);\n+  struct eh_region *local_must_not_throw = NULL;\n+  struct eh_region *first_must_not_throw = NULL;\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n       r = VEC_index (eh_region, cfun->eh->region_array, i);\n-      if (!r)\n+      if (!r || r->region_number != i)\n \tcontinue;\n-      if (r->region_number == i && !TEST_BIT (reachable, i) && !r->resume)\n+      if (!TEST_BIT (reachable, i) && !r->resume)\n \t{\n \t  bool kill_it = true;\n \n@@ -783,11 +807,60 @@ remove_unreachable_regions (sbitmap reachable, sbitmap contains_stmt)\n \t\t\t r->region_number);\n \t      remove_eh_handler (r);\n \t    }\n+\t  else if (r->type == ERT_MUST_NOT_THROW)\n+\t    {\n+\t      if (!first_must_not_throw)\n+\t        first_must_not_throw = r;\n+\t      VEC_safe_push (eh_region, heap, must_not_throws, r);\n+\t    }\n+\t}\n+      else\n+\tif (r->type == ERT_MUST_NOT_THROW)\n+\t  {\n+\t    if (!local_must_not_throw)\n+\t      local_must_not_throw = r;\n+\t    if (r->outer)\n+\t      VEC_safe_push (eh_region, heap, must_not_throws, r);\n+\t  }\n+    }\n+\n+  /* MUST_NOT_THROW regions without local handler are all the same; they\n+     trigger terminate call in runtime.\n+     MUST_NOT_THROW handled locally can differ in debug info associated\n+     to std::terminate () call or if one is coming from Java and other\n+     from C++ whether they call terminate or abort.  \n+\n+     We merge all MUST_NOT_THROW regions handled by the run-time into one.\n+     We alsobring all local MUST_NOT_THROW regions to the roots of EH tree\n+     (since unwinding never continues to the outer region anyway).\n+     If MUST_NOT_THROW with local handler is present in the tree, we use\n+     that region to merge into, since it will remain in tree anyway;\n+     otherwise we use first MUST_NOT_THROW.\n+\n+     Merging of locally handled regions needs changes to the CFG.  Crossjumping\n+     should take care of this, by looking at the actual code and\n+     ensuring that the cleanup actions are really the same.  */\n+\n+  if (local_must_not_throw)\n+    first_must_not_throw = local_must_not_throw;\n+\n+  for (i = 0; VEC_iterate (eh_region, must_not_throws, i, r); i++)\n+    {\n+      if (!r->label && !r->tree_label && r != first_must_not_throw)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Replacing MUST_NOT_THROW region %i by %i\\n\",\n+\t\t     r->region_number,\n+\t\t     first_must_not_throw->region_number);\n+\t  remove_eh_handler_and_replace (r, first_must_not_throw);\n \t}\n+      else\n+\tbring_to_root (r);\n     }\n #ifdef ENABLE_CHECKING\n   verify_eh_tree (cfun);\n #endif\n+  VEC_free (eh_region, heap, must_not_throws);\n }\n \n /* Return array mapping LABEL_DECL_UID to region such that region's tree_label\n@@ -2352,40 +2425,42 @@ remove_exception_handler_label (rtx label)\n   htab_clear_slot (crtl->eh.exception_handler_label_map, (void **) slot);\n }\n \n-/* Splice REGION from the region tree etc.  */\n+/* Splice REGION from the region tree and replace it by REPLACE etc.  */\n \n static void\n-remove_eh_handler (struct eh_region *region)\n+remove_eh_handler_and_replace (struct eh_region *region,\n+\t\t\t       struct eh_region *replace)\n {\n   struct eh_region **pp, **pp_start, *p, *outer, *inner;\n   rtx lab;\n \n+  outer = region->outer;\n   /* For the benefit of efficiently handling REG_EH_REGION notes,\n      replace this region in the region array with its containing\n      region.  Note that previous region deletions may result in\n      multiple copies of this region in the array, so we have a\n      list of alternate numbers by which we are known.  */\n \n-  outer = region->outer;\n-  VEC_replace (eh_region, cfun->eh->region_array, region->region_number, outer);\n+  VEC_replace (eh_region, cfun->eh->region_array, region->region_number,\n+\t       replace);\n   if (region->aka)\n     {\n       unsigned i;\n       bitmap_iterator bi;\n \n       EXECUTE_IF_SET_IN_BITMAP (region->aka, 0, i, bi)\n \t{\n-          VEC_replace (eh_region, cfun->eh->region_array, i, outer);\n+          VEC_replace (eh_region, cfun->eh->region_array, i, replace);\n \t}\n     }\n \n-  if (outer)\n+  if (replace)\n     {\n-      if (!outer->aka)\n-        outer->aka = BITMAP_GGC_ALLOC ();\n+      if (!replace->aka)\n+        replace->aka = BITMAP_GGC_ALLOC ();\n       if (region->aka)\n-\tbitmap_ior_into (outer->aka, region->aka);\n-      bitmap_set_bit (outer->aka, region->region_number);\n+\tbitmap_ior_into (replace->aka, region->aka);\n+      bitmap_set_bit (replace->aka, region->region_number);\n     }\n \n   if (crtl->eh.built_landing_pads)\n@@ -2403,12 +2478,16 @@ remove_eh_handler (struct eh_region *region)\n     continue;\n   *pp = region->next_peer;\n \n+  if (replace)\n+    pp_start = &replace->inner;\n+  else\n+    pp_start = &cfun->eh->region_tree;\n   inner = region->inner;\n   if (inner)\n     {\n       for (p = inner; p->next_peer ; p = p->next_peer)\n-\tp->outer = outer;\n-      p->outer = outer;\n+\tp->outer = replace;\n+      p->outer = replace;\n \n       p->next_peer = *pp_start;\n       *pp_start = inner;\n@@ -2442,6 +2521,15 @@ remove_eh_handler (struct eh_region *region)\n     }\n }\n \n+/* Splice REGION from the region tree and replace it by the outer region\n+   etc.  */\n+\n+static void\n+remove_eh_handler (struct eh_region *region)\n+{\n+  remove_eh_handler_and_replace (region, region->outer);\n+}\n+\n /* LABEL heads a basic block that is about to be deleted.  If this\n    label corresponds to an exception region, we may be able to\n    delete the region.  */"}]}