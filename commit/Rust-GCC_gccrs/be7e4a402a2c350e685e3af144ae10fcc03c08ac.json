{"sha": "be7e4a402a2c350e685e3af144ae10fcc03c08ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU3ZTRhNDAyYTJjMzUwZTY4NWUzYWYxNDRhZTEwZmNjMDNjMDhhYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T10:07:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T10:07:09Z"}, "message": "[multiple changes]\n\n2015-10-20  Philippe Gil  <gil@adacore.com>\n\n\t* g-debpoo.ads (Dump): NEW print Debug_Pool statistics & main\n\tcontributors.\n\t(Dump_Stdout): NEW print to stdout Debug_Pool statistics &\n\tmain contributors.\n\t(Reset): NEW reset counters to 0.\n\t(Get_Size): NEW return size allocated at parameter.\n\t(High_Water_Mark): NEW.\n\t(Current_Water_Mark): NEW.\n\t(System_Memory_Debug_Pool): NEW tell Debug_Pools that\n\tSystem.Memory uses it.\n\t* g-debpoo.adb (Traceback_Htable_Elem): add Frees, Total_Frees\n\tcomponents.\n\t(Find_Or_Create_Traceback): don't manage in System.Memory\n\tDebug_Pool Deallocate Traceback's.\n\t(Validity): add optional Handled table when System.Memory asked\n\tfor Allow_Unhandled_Memory.\n\t(Allocate): handle Allocate reentrancy occuring when System.Memory\n\tuses Debug_Pools.\n\t(Deallocate): handle when Allow_Unhandled_Memory\n\tis set deallocation of unhandled memory. Dont't check\n\tSize_In_Storage_Elements if equal to Storage_Count'Last. update\n\tFrees, Total_Frees new components.\n\n2015-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* fe.h: Minor tweak.\n\nFrom-SVN: r229036", "tree": {"sha": "4f725f3c61ee4589a4d7c3e9a1684d8f6af4b6d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f725f3c61ee4589a4d7c3e9a1684d8f6af4b6d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be7e4a402a2c350e685e3af144ae10fcc03c08ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7e4a402a2c350e685e3af144ae10fcc03c08ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be7e4a402a2c350e685e3af144ae10fcc03c08ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7e4a402a2c350e685e3af144ae10fcc03c08ac/comments", "author": null, "committer": null, "parents": [{"sha": "46ee0270b7a30d7d98eb0358079f5213556609b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ee0270b7a30d7d98eb0358079f5213556609b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46ee0270b7a30d7d98eb0358079f5213556609b8"}], "stats": {"total": 701, "additions": 624, "deletions": 77}, "files": [{"sha": "d8bb5cb65122e020b7d877935fefe27b836b764c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=be7e4a402a2c350e685e3af144ae10fcc03c08ac", "patch": "@@ -1,3 +1,32 @@\n+2015-10-20  Philippe Gil  <gil@adacore.com>\n+\n+\t* g-debpoo.ads (Dump): NEW print Debug_Pool statistics & main\n+\tcontributors.\n+\t(Dump_Stdout): NEW print to stdout Debug_Pool statistics &\n+\tmain contributors.\n+\t(Reset): NEW reset counters to 0.\n+\t(Get_Size): NEW return size allocated at parameter.\n+\t(High_Water_Mark): NEW.\n+\t(Current_Water_Mark): NEW.\n+\t(System_Memory_Debug_Pool): NEW tell Debug_Pools that\n+\tSystem.Memory uses it.\n+\t* g-debpoo.adb (Traceback_Htable_Elem): add Frees, Total_Frees\n+\tcomponents.\n+\t(Find_Or_Create_Traceback): don't manage in System.Memory\n+\tDebug_Pool Deallocate Traceback's.\n+\t(Validity): add optional Handled table when System.Memory asked\n+\tfor Allow_Unhandled_Memory.\n+\t(Allocate): handle Allocate reentrancy occuring when System.Memory\n+\tuses Debug_Pools.\n+\t(Deallocate): handle when Allow_Unhandled_Memory\n+\tis set deallocation of unhandled memory. Dont't check\n+\tSize_In_Storage_Elements if equal to Storage_Count'Last. update\n+\tFrees, Total_Frees new components.\n+\n+2015-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fe.h: Minor tweak.\n+\n 2015-10-20  Vincent Celier  <celier@adacore.com>\n \n \t* sem_cat.adb (Check_Categorization_Dependencies): Do nothing"}, {"sha": "1df23b5bb089d5d1f9ecf86875df65bcdaf9db42", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=be7e4a402a2c350e685e3af144ae10fcc03c08ac", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -39,6 +39,10 @@\n extern \"C\" {\n #endif\n \n+/* atree: */\n+\n+#define Serious_Errors_Detected atree__serious_errors_detected\n+\n /* comperr: */\n \n #define Compiler_Abort comperr__compiler_abort\n@@ -77,10 +81,6 @@ extern Boolean Is_Entity_Name\t\t(Node_Id);\n #define Get_Attribute_Definition_Clause einfo__get_attribute_definition_clause\n extern Node_Id Get_Attribute_Definition_Clause (Entity_Id, char);\n \n-/* atree: */\n-\n-#define Serious_Errors_Detected atree__serious_errors_detected\n-\n /* errout: */\n \n #define Error_Msg_N               errout__error_msg_n"}, {"sha": "94171c468c692ea0f470248cd2bfb0f1d5a00f0f", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 517, "deletions": 67, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=be7e4a402a2c350e685e3af144ae10fcc03c08ac", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,6 +32,7 @@\n with GNAT.IO; use GNAT.IO;\n \n with System.Address_Image;\n+with System.CRTL;\n with System.Memory;     use System.Memory;\n with System.Soft_Links; use System.Soft_Links;\n \n@@ -88,6 +89,18 @@ package body GNAT.Debug_Pools is\n    --  is high enough to make sure we still have enough frames to return to\n    --  the user after we have hidden the frames internal to this package.\n \n+   Disable : Boolean := False;\n+   --  This variable is used to avoid infinite loops, where this package would\n+   --  itself allocate memory and then calls itself recursively, forever.\n+   --  Useful when System_Memory_Debug_Pool_Enabled is True.\n+\n+   System_Memory_Debug_Pool_Enabled : Boolean := False;\n+   --  If True System.Memory allocation are using Debug_Pool\n+\n+   Allow_Unhandled_Memory : Boolean := False;\n+   --  If True protects Deallocate against releasing memory allocated before\n+   --  System_Memory_Debug_Pool_Enabled was set.\n+\n    ---------------------------\n    -- Back Trace Hash Table --\n    ---------------------------\n@@ -115,11 +128,25 @@ package body GNAT.Debug_Pools is\n       is access Traceback_Htable_Elem;\n \n    type Traceback_Htable_Elem is record\n-      Traceback : Tracebacks_Array_Access;\n-      Kind      : Traceback_Kind;\n-      Count     : Natural;\n-      Total     : Byte_Count;\n-      Next      : Traceback_Htable_Elem_Ptr;\n+      Traceback   : Tracebacks_Array_Access;\n+      Kind        : Traceback_Kind;\n+      Count       : Natural;\n+      --  size of the memory allocated/freed at Traceback since last Reset\n+      --  call.\n+\n+      Total       : Byte_Count;\n+      --  number of chunk of memory allocated/freed at Traceback since last\n+      --  Reset call.\n+\n+      Frees       : Natural;\n+      --  number of chunk of memory allocated at Traceback, currently freed\n+      --  since last Reset call. (only for Alloc & Indirect_Alloc elements)\n+\n+      Total_Frees : Byte_Count;\n+      --  size of the memory allocated at Traceback, currently freed since last\n+      --  Reset call. (only for Alloc & Indirect_Alloc elements)\n+\n+      Next        : Traceback_Htable_Elem_Ptr;\n    end record;\n \n    --  Subprograms used for the Backtrace_Htable instantiation\n@@ -268,7 +295,21 @@ package body GNAT.Debug_Pools is\n    --  up to the first one in the range:\n    --    Ignored_Frame_Start .. Ignored_Frame_End\n \n+   procedure Stdout_Put      (S : String);\n+   --  Wrapper for Put that ensure we always write to stdout\n+   --  instead of the current output file defined in GNAT.IO.\n+\n+   procedure Stdout_Put_Line (S : String);\n+   --  Wrapper for Put_Line that ensure we always write to stdout\n+   --  instead of the current output file defined in GNAT.IO.\n+\n    package Validity is\n+      function Is_Handled (Storage : System.Address) return Boolean;\n+      pragma Inline (Is_Handled);\n+      --  Return True if Storage is the address of a block that the debug pool\n+      --  had already under its control.\n+      --  Used to allow System.Memory to use Debug_Pools\n+\n       function Is_Valid (Storage : System.Address) return Boolean;\n       pragma Inline (Is_Valid);\n       --  Return True if Storage is the address of a block that the debug pool\n@@ -519,12 +560,14 @@ package body GNAT.Debug_Pools is\n       end if;\n \n       declare\n+         Disable_Exit_Value : constant Boolean := Disable;\n          Trace : aliased Tracebacks_Array\n                   (1 .. Integer (Pool.Stack_Trace_Depth) + Max_Ignored_Levels);\n          Len, Start   : Natural;\n          Elem  : Traceback_Htable_Elem_Ptr;\n \n       begin\n+         Disable := True;\n          Call_Chain (Trace, Len);\n          Skip_Levels (Pool.Stack_Trace_Depth, Trace, Start, Len,\n                       Ignored_Frame_Start, Ignored_Frame_End);\n@@ -539,18 +582,25 @@ package body GNAT.Debug_Pools is\n          if Elem = null then\n             Elem := new Traceback_Htable_Elem'\n               (Traceback => new Tracebacks_Array'(Trace (Start .. Len)),\n-               Count     => 1,\n-               Kind      => Kind,\n-               Total     => Byte_Count (Size),\n-               Next      => null);\n+               Count       => 1,\n+               Kind        => Kind,\n+               Total       => Byte_Count (Size),\n+               Frees       => 0,\n+               Total_Frees => 0,\n+               Next        => null);\n             Backtrace_Htable.Set (Elem);\n \n          else\n             Elem.Count := Elem.Count + 1;\n             Elem.Total := Elem.Total + Byte_Count (Size);\n          end if;\n \n+         Disable := Disable_Exit_Value;\n          return Elem;\n+      exception\n+         when others =>\n+            Disable := Disable_Exit_Value;\n+            raise;\n       end;\n    end Find_Or_Create_Traceback;\n \n@@ -579,7 +629,21 @@ package body GNAT.Debug_Pools is\n \n       type Byte is mod 2 ** System.Storage_Unit;\n \n-      type Validity_Bits is array (Validity_Byte_Index) of Byte;\n+      type Validity_Bits_Part is array (Validity_Byte_Index) of Byte;\n+      type Validity_Bits_Part_Ref is access all Validity_Bits_Part;\n+      No_Validity_Bits_Part : constant Validity_Bits_Part_Ref := null;\n+\n+      type Validity_Bits is record\n+         Valid : Validity_Bits_Part_Ref := No_Validity_Bits_Part;\n+         --  True if chunk of memory at this address currently allocated.\n+\n+         Handled : Validity_Bits_Part_Ref := No_Validity_Bits_Part;\n+         --  True if chunk of memory at this address was allocated once after\n+         --  Allow_Unhandled_Memory was set to True.\n+         --  Used to know on Deallocate if chunk of memory should be handled\n+         --  as a block allocated by this package.\n+\n+      end record;\n \n       type Validity_Bits_Ref is access all Validity_Bits;\n       No_Validity_Bits : constant Validity_Bits_Ref := null;\n@@ -590,17 +654,25 @@ package body GNAT.Debug_Pools is\n \n       function Hash (F : Integer_Address) return Header_Num;\n \n+      function Is_Valid_Or_Handled\n+        (Storage : System.Address;\n+         Valid   : Boolean) return Boolean;\n+      pragma Inline (Is_Valid_Or_Handled);\n+      --  internal implementation of Is_Valid and Is_Handled.\n+      --  Valid is used to select Valid or Handled arrays.\n+\n       package Validy_Htable is new GNAT.HTable.Simple_HTable\n         (Header_Num => Header_Num,\n          Element    => Validity_Bits_Ref,\n          No_Element => No_Validity_Bits,\n          Key        => Integer_Address,\n          Hash       => Hash,\n          Equal      => \"=\");\n-      --  Table to keep the validity bit blocks for the allocated data\n+      --  Table to keep the validity and handled bit blocks for the allocated\n+      --  data\n \n       function To_Pointer is new Ada.Unchecked_Conversion\n-        (System.Address, Validity_Bits_Ref);\n+        (System.Address, Validity_Bits_Part_Ref);\n \n       procedure Memset (A : Address; C : Integer; N : size_t);\n       pragma Import (C, Memset, \"memset\");\n@@ -614,11 +686,13 @@ package body GNAT.Debug_Pools is\n          return Header_Num (F mod Max_Header_Num);\n       end Hash;\n \n-      --------------\n-      -- Is_Valid --\n-      --------------\n+      -------------------------\n+      -- Is_Valid_Or_Handled --\n+      -------------------------\n \n-      function Is_Valid (Storage : System.Address) return Boolean is\n+      function Is_Valid_Or_Handled\n+        (Storage : System.Address;\n+         Valid   : Boolean) return Boolean is\n          Int_Storage  : constant Integer_Address := To_Integer (Storage);\n \n       begin\n@@ -646,11 +720,39 @@ package body GNAT.Debug_Pools is\n             if Ptr = No_Validity_Bits then\n                return False;\n             else\n-               return (Ptr (Offset / System.Storage_Unit) and Bit) /= 0;\n+               if Valid then\n+                  return (Ptr.Valid (Offset / System.Storage_Unit)\n+                             and Bit) /= 0;\n+               else\n+                  if Ptr.Handled = No_Validity_Bits_Part then\n+                     return False;\n+                  else\n+                     return (Ptr.Handled (Offset / System.Storage_Unit)\n+                                and Bit) /= 0;\n+                  end if;\n+               end if;\n             end if;\n          end;\n+      end Is_Valid_Or_Handled;\n+\n+      --------------\n+      -- Is_Valid --\n+      --------------\n+\n+      function Is_Valid (Storage : System.Address) return Boolean is\n+      begin\n+         return Is_Valid_Or_Handled (Storage => Storage, Valid => True);\n       end Is_Valid;\n \n+      -----------------\n+      -- Is_Handled --\n+      -----------------\n+\n+      function Is_Handled (Storage : System.Address) return Boolean is\n+      begin\n+         return Is_Valid_Or_Handled (Storage => Storage, Valid => False);\n+      end Is_Handled;\n+\n       ---------------\n       -- Set_Valid --\n       ---------------\n@@ -666,27 +768,53 @@ package body GNAT.Debug_Pools is\n          Bit          : constant Byte :=\n                           2 ** Natural (Offset mod System.Storage_Unit);\n \n+         procedure Set_Handled;\n+         pragma Inline (Set_Handled);\n+         --  if Allow_Unhandled_Memory set Handled bit in table.\n+\n+         -----------------\n+         -- Set_Handled --\n+         -----------------\n+\n+         procedure Set_Handled is\n+         begin\n+            if Allow_Unhandled_Memory then\n+               if Ptr.Handled = No_Validity_Bits_Part then\n+                  Ptr.Handled :=\n+                     To_Pointer (Alloc (size_t (Max_Validity_Byte_Index)));\n+                  Memset (Ptr.Handled.all'Address, 0,\n+                          size_t (Max_Validity_Byte_Index));\n+               end if;\n+               Ptr.Handled (Offset / System.Storage_Unit) :=\n+                  Ptr.Handled (Offset / System.Storage_Unit) or Bit;\n+            end if;\n+         end Set_Handled;\n+\n       begin\n          if Ptr = No_Validity_Bits then\n \n             --  First time in this memory area: allocate a new block and put\n             --  it in the table.\n \n             if Value then\n-               Ptr := To_Pointer (Alloc (size_t (Max_Validity_Byte_Index)));\n+               Ptr := new Validity_Bits;\n+               Ptr.Valid :=\n+                  To_Pointer (Alloc (size_t (Max_Validity_Byte_Index)));\n                Validy_Htable.Set (Block_Number, Ptr);\n-               Memset (Ptr.all'Address, 0, size_t (Max_Validity_Byte_Index));\n-               Ptr (Offset / System.Storage_Unit) := Bit;\n+               Memset (Ptr.Valid.all'Address, 0,\n+                       size_t (Max_Validity_Byte_Index));\n+               Ptr.Valid (Offset / System.Storage_Unit) := Bit;\n+               Set_Handled;\n             end if;\n \n          else\n             if Value then\n-               Ptr (Offset / System.Storage_Unit) :=\n-                 Ptr (Offset / System.Storage_Unit) or Bit;\n-\n+               Ptr.Valid (Offset / System.Storage_Unit) :=\n+                 Ptr.Valid (Offset / System.Storage_Unit) or Bit;\n+               Set_Handled;\n             else\n-               Ptr (Offset / System.Storage_Unit) :=\n-                 Ptr (Offset / System.Storage_Unit) and (not Bit);\n+               Ptr.Valid (Offset / System.Storage_Unit) :=\n+                 Ptr.Valid (Offset / System.Storage_Unit) and (not Bit);\n             end if;\n          end if;\n       end Set_Valid;\n@@ -720,10 +848,23 @@ package body GNAT.Debug_Pools is\n       P       : Ptr;\n       Trace   : Traceback_Htable_Elem_Ptr;\n \n+      Disable_Exit_Value : constant Boolean := Disable;\n+\n    begin\n       <<Allocate_Label>>\n       Lock_Task.all;\n \n+      if Disable then\n+         Storage_Address :=\n+           System.CRTL.malloc (System.CRTL.size_t (Size_In_Storage_Elements));\n+         Unlock_Task.all;\n+         return;\n+      end if;\n+\n+      Disable := True;\n+\n+      Pool.Alloc_Count := Pool.Alloc_Count + 1;\n+\n       --  If necessary, start physically releasing memory. The reason this is\n       --  done here, although Pool.Logically_Deallocated has not changed above,\n       --  is so that we do this only after a series of deallocations (e.g loop\n@@ -840,18 +981,19 @@ package body GNAT.Debug_Pools is\n       Pool.Allocated :=\n         Pool.Allocated + Byte_Count (Size_In_Storage_Elements);\n \n-      Current := Pool.Allocated -\n-                   Pool.Logically_Deallocated -\n-                     Pool.Physically_Deallocated;\n+      Current := Pool.Current_Water_Mark;\n \n       if Current > Pool.High_Water then\n          Pool.High_Water := Current;\n       end if;\n \n+      Disable := Disable_Exit_Value;\n+\n       Unlock_Task.all;\n \n    exception\n       when others =>\n+         Disable := Disable_Exit_Value;\n          Unlock_Task.all;\n          raise;\n    end Allocate;\n@@ -1019,7 +1161,12 @@ package body GNAT.Debug_Pools is\n                        & Address_Image (Header.Allocation_Address));\n                end if;\n \n-               System.Memory.Free (Header.Allocation_Address);\n+               if System_Memory_Debug_Pool_Enabled then\n+                  System.CRTL.free (Header.Allocation_Address);\n+               else\n+                  System.Memory.Free (Header.Allocation_Address);\n+               end if;\n+\n                Set_Valid (Tmp, False);\n \n                --  Remove this block from the list\n@@ -1159,6 +1306,44 @@ package body GNAT.Debug_Pools is\n          raise;\n    end Free_Physically;\n \n+   --------------\n+   -- Get_Size --\n+   --------------\n+\n+   procedure Get_Size\n+     (Storage_Address          : Address;\n+      Size_In_Storage_Elements : out Storage_Count;\n+      Valid                    : out Boolean) is\n+   begin\n+      Lock_Task.all;\n+\n+      Valid := Is_Valid (Storage_Address);\n+\n+      if Is_Valid (Storage_Address) then\n+         declare\n+            Header   : constant Allocation_Header_Access :=\n+              Header_Of (Storage_Address);\n+         begin\n+            if Header.Block_Size >= 0 then\n+               Valid := True;\n+               Size_In_Storage_Elements := Header.Block_Size;\n+            else\n+               Valid := False;\n+            end if;\n+         end;\n+      else\n+         Valid := False;\n+      end if;\n+\n+      Unlock_Task.all;\n+\n+   exception\n+      when others =>\n+         Unlock_Task.all;\n+         raise;\n+\n+   end Get_Size;\n+\n    ----------------\n    -- Deallocate --\n    ----------------\n@@ -1183,7 +1368,31 @@ package body GNAT.Debug_Pools is\n \n       if not Valid then\n          Unlock_Task.all;\n-         if Pool.Raise_Exceptions then\n+\n+         if Storage_Address = System.Null_Address then\n+            if Pool.Raise_Exceptions and then\n+              Size_In_Storage_Elements /= Storage_Count'Last\n+            then\n+               raise Freeing_Not_Allocated_Storage;\n+            else\n+               Put (Output_File (Pool),\n+                    \"error: Freeing Null_Address, at \");\n+               Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n+                         Deallocate_Label'Address,\n+                         Code_Address_For_Deallocate_End);\n+               return;\n+            end if;\n+         end if;\n+\n+         if Allow_Unhandled_Memory and then not Is_Handled (Storage_Address)\n+         then\n+            System.CRTL.free (Storage_Address);\n+            return;\n+         end if;\n+\n+         if Pool.Raise_Exceptions and then\n+           Size_In_Storage_Elements /= Storage_Count'Last\n+         then\n             raise Freeing_Not_Allocated_Storage;\n          else\n             Put (Output_File (Pool),\n@@ -1217,7 +1426,9 @@ package body GNAT.Debug_Pools is\n          --  The code below is all based on the assumption that Header.all\n          --  is not corrupted, such that the error is non-fatal.\n \n-         if Header.Block_Size /= Size_In_Storage_Elements then\n+         if Header.Block_Size /= Size_In_Storage_Elements and then\n+           Size_In_Storage_Elements /= Storage_Count'Last\n+         then\n             Put_Line (Output_File (Pool),\n                       \"error: Deallocate size \"\n                         & Storage_Count'Image (Size_In_Storage_Elements)\n@@ -1228,7 +1439,7 @@ package body GNAT.Debug_Pools is\n          if Pool.Low_Level_Traces then\n             Put (Output_File (Pool),\n                  \"info: Deallocated\"\n-                 & Storage_Count'Image (Size_In_Storage_Elements)\n+                 & Storage_Count'Image (Header.Block_Size)\n                  & \" bytes at 0x\" & Address_Image (Storage_Address)\n                  & \" (physically\"\n                  & Storage_Count'Image (Header.Block_Size + Extra_Allocation)\n@@ -1263,6 +1474,17 @@ package body GNAT.Debug_Pools is\n             end if;\n          end if;\n \n+         --  Update the Alloc_Traceback Frees/Total_Frees members (if present)\n+\n+         if Header.Alloc_Traceback /= null then\n+            Header.Alloc_Traceback.Frees := Header.Alloc_Traceback.Frees + 1;\n+            Header.Alloc_Traceback.Total_Frees :=\n+              Header.Alloc_Traceback.Total_Frees +\n+                Byte_Count (Header.Block_Size);\n+         end if;\n+\n+         Pool.Free_Count := Pool.Free_Count + 1;\n+\n          --  Update the header\n \n          Header.all :=\n@@ -1271,7 +1493,7 @@ package body GNAT.Debug_Pools is\n             Dealloc_Traceback  => To_Traceback\n                                     (Find_Or_Create_Traceback\n                                        (Pool, Dealloc,\n-                                        Size_In_Storage_Elements,\n+                                        Header.Block_Size,\n                                         Deallocate_Label'Address,\n                                         Code_Address_For_Deallocate_End)),\n             Next               => System.Null_Address,\n@@ -1453,9 +1675,7 @@ package body GNAT.Debug_Pools is\n \n       Put_Line\n         (\"Current Water Mark: \" &\n-         Byte_Count'Image\n-          (Pool.Allocated - Pool.Logically_Deallocated\n-                                   - Pool.Physically_Deallocated));\n+         Byte_Count'Image (Pool.Current_Water_Mark));\n \n       Put_Line\n         (\"High Water Mark: \" &\n@@ -1470,10 +1690,12 @@ package body GNAT.Debug_Pools is\n                Elem :=\n                  new Traceback_Htable_Elem'\n                       (Traceback => new Tracebacks_Array'(Data.Traceback.all),\n-                       Count     => Data.Count,\n-                       Kind      => Data.Kind,\n-                       Total     => Data.Total,\n-                       Next      => null);\n+                       Count       => Data.Count,\n+                       Kind        => Data.Kind,\n+                       Total       => Data.Total,\n+                       Frees       => Data.Frees,\n+                       Total_Frees => Data.Total_Frees,\n+                       Next        => null);\n                Backtrace_Htable_Cumulate.Set (Elem);\n \n                if Cumulate then\n@@ -1493,10 +1715,12 @@ package body GNAT.Debug_Pools is\n                         Elem := new Traceback_Htable_Elem'\n                           (Traceback => new Tracebacks_Array'\n                              (Data.Traceback (T .. Data.Traceback'Last)),\n-                           Count     => Data.Count,\n-                           Kind      => K,\n-                           Total     => Data.Total,\n-                           Next      => null);\n+                           Count       => Data.Count,\n+                           Kind        => K,\n+                           Total       => Data.Total,\n+                           Frees       => Data.Frees,\n+                           Total_Frees => Data.Total_Frees,\n+                           Next        => null);\n                         Backtrace_Htable_Cumulate.Set (Elem);\n \n                         --  Properly take into account that the subprograms\n@@ -1575,6 +1799,204 @@ package body GNAT.Debug_Pools is\n       end if;\n    end Print_Info;\n \n+   ----------\n+   -- Dump --\n+   ----------\n+\n+   procedure Dump\n+     (Pool   : Debug_Pool;\n+      Size   : Positive;\n+      Report : Report_Type := All_Reports) is\n+\n+      Total_Freed : constant Byte_Count :=\n+        Pool.Logically_Deallocated + Pool.Physically_Deallocated;\n+\n+      procedure Do_Report (Sort : Report_Type);\n+      --  Do a specific type of report\n+\n+      procedure Do_Report (Sort : Report_Type) is\n+         Elem        : Traceback_Htable_Elem_Ptr;\n+         Bigger      : Boolean;\n+         Grand_Total : Float;\n+\n+         Max  : array (1 .. Size) of Traceback_Htable_Elem_Ptr :=\n+           (others => null);\n+         --  Sorted array for the biggest memory users\n+\n+      begin\n+         New_Line;\n+         case Sort is\n+            when Memory_Usage | All_Reports  =>\n+               Put_Line (Size'Img & \" biggest memory users at this time:\");\n+               Put_Line (\"Results include bytes and chunks still allocated\");\n+               Grand_Total := Float (Pool.Current_Water_Mark);\n+            when Allocations_Count =>\n+               Put_Line (Size'Img & \" biggest number of live allocations:\");\n+               Put_Line (\"Results include bytes and chunks still allocated\");\n+               Grand_Total := Float (Pool.Current_Water_Mark);\n+            when Sort_Total_Allocs =>\n+               Put_Line (Size'Img & \" biggest number of allocations:\");\n+               Put_Line (\"Results include total bytes and chunks allocated,\");\n+               Put_Line (\"even if no longer allocated - Deallocations are\"\n+                         & \" ignored\");\n+               Grand_Total := Float (Pool.Allocated);\n+            when Marked_Blocks =>\n+               Put_Line (\"Special blocks marked by Mark_Traceback\");\n+               Grand_Total := 0.0;\n+         end case;\n+\n+         Elem := Backtrace_Htable.Get_First;\n+         while Elem /= null loop\n+            --  Handle only alloc elememts\n+            if Elem.Kind = Alloc then\n+               --  Ignore small blocks (depending on the sorting criteria) to\n+               --  gain speed\n+\n+               if (Sort = Memory_Usage\n+                   and then Elem.Total - Elem.Total_Frees >= 1_000)\n+                 or else (Sort = Allocations_Count\n+                          and then Elem.Count - Elem.Frees >= 1)\n+                 or else (Sort = Sort_Total_Allocs and then Elem.Count > 1)\n+                 or else (Sort = Marked_Blocks\n+                          and then Elem.Total = 0)\n+               then\n+                  if Sort = Marked_Blocks then\n+                     Grand_Total := Grand_Total + Float (Elem.Count);\n+                  end if;\n+\n+                  for M in Max'Range loop\n+                     Bigger := Max (M) = null;\n+                     if not Bigger then\n+                        case Sort is\n+                        when Memory_Usage | All_Reports =>\n+                           Bigger :=\n+                             Max (M).Total - Max (M).Total_Frees <\n+                             Elem.Total - Elem.Total_Frees;\n+                        when Allocations_Count =>\n+                           Bigger :=\n+                             Max (M).Count - Max (M).Frees\n+                             < Elem.Count - Elem.Frees;\n+                        when Sort_Total_Allocs | Marked_Blocks =>\n+                           Bigger := Max (M).Count < Elem.Count;\n+                        end case;\n+                     end if;\n+\n+                     if Bigger then\n+                        Max (M + 1 .. Max'Last) := Max (M .. Max'Last - 1);\n+                        Max (M) := Elem;\n+                        exit;\n+                     end if;\n+                  end loop;\n+               end if;\n+            end if;\n+\n+            Elem := Backtrace_Htable.Get_Next;\n+         end loop;\n+\n+         if Grand_Total = 0.0 then\n+            Grand_Total := 1.0;\n+         end if;\n+\n+         for M in Max'Range loop\n+            exit when Max (M) = null;\n+            declare\n+               type Percent is delta 0.1 range 0.0 .. 100.0;\n+               Total : Byte_Count;\n+               P : Percent;\n+            begin\n+               case Sort is\n+                  when Memory_Usage | Allocations_Count | All_Reports =>\n+                     Total := Max (M).Total - Max (M).Total_Frees;\n+                  when Sort_Total_Allocs =>\n+                     Total := Max (M).Total;\n+                  when Marked_Blocks =>\n+                     Total := Byte_Count (Max (M).Count);\n+               end case;\n+\n+               P := Percent (100.0 * Float (Total) / Grand_Total);\n+\n+               if Sort = Marked_Blocks then\n+                  Put (P'Img & \"%:\"\n+                       & Max (M).Count'Img & \" chunks /\"\n+                       & Integer (Grand_Total)'Img & \" at\");\n+               else\n+                  Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n+                       & Max (M).Count'Img & \" chunks at\");\n+               end if;\n+            end;\n+\n+            for J in Max (M).Traceback'Range loop\n+               Put (\" 0x\" & Address_Image (PC_For (Max (M).Traceback (J))));\n+            end loop;\n+\n+            New_Line;\n+         end loop;\n+      end Do_Report;\n+\n+   begin\n+\n+      Put_Line (\"Ada Allocs:\" & Pool.Allocated'Img\n+                & \" bytes in\" & Pool.Alloc_Count'Img & \" chunks\");\n+      Put_Line (\"Ada Free:\" & Total_Freed'Img & \" bytes in\" &\n+                  Pool.Free_Count'Img\n+                & \" chunks\");\n+      Put_Line (\"Ada Current watermark: \"\n+                & Byte_Count'Image (Pool.Current_Water_Mark)\n+                & \" in\" & Byte_Count'Image (Pool.Alloc_Count -\n+                    Pool.Free_Count) & \" chunks\");\n+      Put_Line (\"Ada High watermark: \" & Pool.High_Water_Mark'Img);\n+\n+      case Report is\n+         when All_Reports =>\n+            for Sort in Report_Type loop\n+               if Sort /= All_Reports then\n+                  Do_Report (Sort);\n+               end if;\n+            end loop;\n+\n+         when others =>\n+            Do_Report (Report);\n+      end case;\n+\n+   end Dump;\n+\n+   -----------------\n+   -- Dump_Stdout --\n+   -----------------\n+\n+   procedure Dump_Stdout\n+     (Pool   : Debug_Pool;\n+      Size   : Positive;\n+      Report : Report_Type := All_Reports)\n+   is\n+\n+      procedure Internal is new Dump\n+        (Put_Line => Stdout_Put_Line,\n+         Put      => Stdout_Put);\n+\n+   --  Start of processing for Dump_Stdout\n+\n+   begin\n+      Internal (Pool, Size, Report);\n+   end Dump_Stdout;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset is\n+      Elem : Traceback_Htable_Elem_Ptr;\n+   begin\n+      Elem := Backtrace_Htable.Get_First;\n+      while Elem /= null loop\n+         Elem.Count := 0;\n+         Elem.Frees := 0;\n+         Elem.Total := 0;\n+         Elem.Total_Frees := 0;\n+         Elem := Backtrace_Htable.Get_Next;\n+      end loop;\n+   end Reset;\n+\n    ------------------\n    -- Storage_Size --\n    ------------------\n@@ -1585,6 +2007,38 @@ package body GNAT.Debug_Pools is\n       return Storage_Count'Last;\n    end Storage_Size;\n \n+   ---------------------\n+   -- High_Water_Mark --\n+   ---------------------\n+\n+   function High_Water_Mark\n+     (Pool : Debug_Pool) return Byte_Count is\n+   begin\n+      return Pool.High_Water;\n+   end High_Water_Mark;\n+\n+   ------------------------\n+   -- Current_Water_Mark --\n+   ------------------------\n+\n+   function Current_Water_Mark\n+     (Pool : Debug_Pool) return Byte_Count is\n+   begin\n+      return Pool.Allocated - Pool.Logically_Deallocated -\n+        Pool.Physically_Deallocated;\n+   end Current_Water_Mark;\n+\n+   ------------------------------\n+   -- System_Memory_Debug_Pool --\n+   ------------------------------\n+\n+   procedure System_Memory_Debug_Pool\n+     (Has_Unhandled_Memory : Boolean := True) is\n+   begin\n+      System_Memory_Debug_Pool_Enabled := True;\n+      Allow_Unhandled_Memory := Has_Unhandled_Memory;\n+   end System_Memory_Debug_Pool;\n+\n    ---------------\n    -- Configure --\n    ---------------\n@@ -1661,33 +2115,11 @@ package body GNAT.Debug_Pools is\n       Display_Slots : Boolean := False;\n       Display_Leaks : Boolean := False)\n    is\n-      procedure Stdout_Put      (S : String);\n-      procedure Stdout_Put_Line (S : String);\n-      --  Wrappers for Put and Put_Line that ensure we always write to stdout\n-      --  instead of the current output file defined in GNAT.IO.\n \n       procedure Internal is new Print_Info\n         (Put_Line => Stdout_Put_Line,\n          Put      => Stdout_Put);\n \n-      ----------------\n-      -- Stdout_Put --\n-      ----------------\n-\n-      procedure Stdout_Put (S : String) is\n-      begin\n-         Put_Line (Standard_Output, S);\n-      end Stdout_Put;\n-\n-      ---------------------\n-      -- Stdout_Put_Line --\n-      ---------------------\n-\n-      procedure Stdout_Put_Line (S : String) is\n-      begin\n-         Put_Line (Standard_Output, S);\n-      end Stdout_Put_Line;\n-\n    --  Start of processing for Print_Info_Stdout\n \n    begin\n@@ -1780,6 +2212,24 @@ package body GNAT.Debug_Pools is\n       fclose (File);\n    end Dump_Gnatmem;\n \n+   ----------------\n+   -- Stdout_Put --\n+   ----------------\n+\n+   procedure Stdout_Put (S : String) is\n+   begin\n+      Put (Standard_Output, S);\n+   end Stdout_Put;\n+\n+   ---------------------\n+   -- Stdout_Put_Line --\n+   ---------------------\n+\n+   procedure Stdout_Put_Line (S : String) is\n+   begin\n+      Put_Line (Standard_Output, S);\n+   end Stdout_Put_Line;\n+\n --  Package initialization\n \n begin"}, {"sha": "049c206a96a7d8cad8663dca5c287673a414d37f", "filename": "gcc/ada/g-debpoo.ads", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2Fg-debpoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7e4a402a2c350e685e3af144ae10fcc03c08ac/gcc%2Fada%2Fg-debpoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.ads?ref=be7e4a402a2c350e685e3af144ae10fcc03c08ac", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -254,6 +254,71 @@ package GNAT.Debug_Pools is\n    --  deallocation of that memory chunk, its current status (allocated or\n    --  logically freed), etc.\n \n+   type Report_Type is\n+     (All_Reports,\n+      Memory_Usage,\n+      Allocations_Count,\n+      Sort_Total_Allocs,\n+      Marked_Blocks);\n+   for Report_Type use\n+     (All_Reports       => 0,\n+      Memory_Usage      => 1,\n+      Allocations_Count => 2,\n+      Sort_Total_Allocs => 3,\n+      Marked_Blocks     => 4);\n+\n+   generic\n+      with procedure Put_Line (S : String) is <>;\n+      with procedure Put      (S : String) is <>;\n+   procedure Dump\n+     (Pool   : Debug_Pool;\n+      Size   : Positive;\n+      Report : Report_Type := All_Reports);\n+   --  Dump information about memory usage.\n+   --  Size is the number of the biggest memory users we want to show. Report\n+   --  indicates which sorting order is used in the report\n+\n+   procedure Dump_Stdout\n+     (Pool   : Debug_Pool;\n+      Size   : Positive;\n+      Report : Report_Type := All_Reports);\n+   --  Standard instantiation of Dump to print on standard_output. More\n+   --  convenient to use where this is the intended location, and in particular\n+   --  easier to use from the debugger.\n+\n+   procedure Reset;\n+   --  Reset all internal data. This is in general not needed, unless you want\n+   --  to know what memory is used by specific parts of your application\n+\n+   procedure Get_Size\n+     (Storage_Address          : Address;\n+      Size_In_Storage_Elements : out Storage_Count;\n+      Valid                    : out Boolean);\n+   --  set Valid if Storage_Address is the address of a chunk of memory\n+   --  currently allocated by any pool.\n+   --  If Valid is True, Size_In_Storage_Elements is set to the size of this\n+   --  chunk of memory.\n+\n+   type Byte_Count is mod System.Max_Binary_Modulus;\n+   --  Type used for maintaining byte counts, needs to be large enough\n+   --  to accommodate counts allowing for repeated use of the same memory.\n+\n+   function High_Water_Mark\n+     (Pool : Debug_Pool) return Byte_Count;\n+   --  return the highest size of the memory allocated by the pool.\n+   --  memory used internally by the pool is not taken into account.\n+\n+   function Current_Water_Mark\n+     (Pool : Debug_Pool) return Byte_Count;\n+   --  return the size of the memory currently allocated by the pool.\n+   --  memory used internally by the pool is not taken into account.\n+\n+   procedure System_Memory_Debug_Pool\n+     (Has_Unhandled_Memory : Boolean := True);\n+   --  let the package know the System.Memory is using it.\n+   --  If Has_Unhandled_Memory is true, some deallocate can be done for\n+   --  memory not allocated with Allocate.\n+\n private\n    --  The following are the standard primitive subprograms for a pool\n \n@@ -292,10 +357,6 @@ private\n    --  on the setup of the storage pool.\n    --  The parameters have the same semantics as defined in the ARM95.\n \n-   type Byte_Count is mod System.Max_Binary_Modulus;\n-   --  Type used for maintaining byte counts, needs to be large enough\n-   --  to accommodate counts allowing for repeated use of the same memory.\n-\n    type Debug_Pool is new System.Checked_Pools.Checked_Pool with record\n       Stack_Trace_Depth              : Natural := Default_Stack_Trace_Depth;\n       Maximum_Logically_Freed_Memory : SSC     := Default_Max_Freed;\n@@ -306,6 +367,12 @@ private\n       Errors_To_Stdout               : Boolean := Default_Errors_To_Stdout;\n       Low_Level_Traces               : Boolean := Default_Low_Level_Traces;\n \n+      Alloc_Count    : Byte_Count := 0;\n+      --  Total number of allocation\n+\n+      Free_Count     : Byte_Count := 0;\n+      --  Total number of deallocation\n+\n       Allocated : Byte_Count := 0;\n       --  Total number of bytes allocated in this pool\n \n@@ -337,5 +404,6 @@ private\n       --  for the advanced freeing algorithms that needs to traverse all these\n       --  blocks to find possible references to the block being physically\n       --  freed.\n+\n    end record;\n end GNAT.Debug_Pools;"}]}