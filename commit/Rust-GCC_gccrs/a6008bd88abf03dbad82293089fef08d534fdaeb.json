{"sha": "a6008bd88abf03dbad82293089fef08d534fdaeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYwMDhiZDg4YWJmMDNkYmFkODIyOTMwODlmZWYwOGQ1MzRmZGFlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-01-05T09:32:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-01-05T09:32:19Z"}, "message": "mips-protos.h (mips_dangerous_for_la25_p): Declare.\n\n\t* config/mips/mips-protos.h (mips_dangerous_for_la25_p): Declare.\n\t(mips_preferred_reload_class): Declare.\n\t* config/mips/mips.h (DANGEROUS_FOR_LA25_P): Replace with function.\n\t(EXTRA_CONSTRAINT): Update accordingly.\n\t(PREFERRED_RELOAD_CLASS): Use mips_preferred_reload_class.\n\t* config/mips/mips.c (mips_dangerous_for_la25_p): New function.\n\t(mips_preferred_reload_class): New function.  Prefer LEA_REGS if\n\tmips_dangerous_for_la25_p.\n\t(mips_secondary_reload_class): Use LEA_REGS rather than GR_REGS\n\tif mips_dangerous_for_la25_p.\n\nFrom-SVN: r75420", "tree": {"sha": "65d76887069d195a7fc11856f45606f663fa911d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65d76887069d195a7fc11856f45606f663fa911d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6008bd88abf03dbad82293089fef08d534fdaeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6008bd88abf03dbad82293089fef08d534fdaeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6008bd88abf03dbad82293089fef08d534fdaeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6008bd88abf03dbad82293089fef08d534fdaeb/comments", "author": null, "committer": null, "parents": [{"sha": "543ebd4aea03f0051b035315344fced4e8fcf86c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543ebd4aea03f0051b035315344fced4e8fcf86c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/543ebd4aea03f0051b035315344fced4e8fcf86c"}], "stats": {"total": 102, "additions": 66, "deletions": 36}, "files": [{"sha": "3e87d8740c846636cb3566c0a00218adaeafc66d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6008bd88abf03dbad82293089fef08d534fdaeb", "patch": "@@ -1,3 +1,16 @@\n+2004-01-05  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_dangerous_for_la25_p): Declare.\n+\t(mips_preferred_reload_class): Declare.\n+\t* config/mips/mips.h (DANGEROUS_FOR_LA25_P): Replace with function.\n+\t(EXTRA_CONSTRAINT): Update accordingly.\n+\t(PREFERRED_RELOAD_CLASS): Use mips_preferred_reload_class.\n+\t* config/mips/mips.c (mips_dangerous_for_la25_p): New function.\n+\t(mips_preferred_reload_class): New function.  Prefer LEA_REGS if\n+\tmips_dangerous_for_la25_p.\n+\t(mips_secondary_reload_class): Use LEA_REGS rather than GR_REGS\n+\tif mips_dangerous_for_la25_p.\n+\n 2004-01-05  Bernardo Innocenti  <bernie@develer.com>\n \n \t* config/m68k/m68k.c (output_andsi3): Fix signed/unsigned comparison"}, {"sha": "bc0ce7b184a0b7109378aea4eeec7ab5f3a65c48", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=a6008bd88abf03dbad82293089fef08d534fdaeb", "patch": "@@ -124,6 +124,8 @@ extern int function_arg_pass_by_reference (const CUMULATIVE_ARGS *,\n \n extern bool mips_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n+extern bool mips_dangerous_for_la25_p (rtx);\n+extern enum reg_class mips_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t\t   rtx, int);"}, {"sha": "917bcda155bbe7ee838a7147133225ec9e1a4e3c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a6008bd88abf03dbad82293089fef08d534fdaeb", "patch": "@@ -7350,6 +7350,44 @@ mips_cannot_change_mode_class (enum machine_mode from,\n   return false;\n }\n \n+/* Return true if X should not be moved directly into register $25.\n+   We need this because many versions of GAS will treat \"la $25,foo\" as\n+   part of a call sequence and so allow a global \"foo\" to be lazily bound.  */\n+\n+bool\n+mips_dangerous_for_la25_p (rtx x)\n+{\n+  HOST_WIDE_INT offset;\n+\n+  if (TARGET_EXPLICIT_RELOCS)\n+    return false;\n+\n+  mips_split_const (x, &x, &offset);\n+  return global_got_operand (x, VOIDmode);\n+}\n+\n+/* Implement PREFERRED_RELOAD_CLASS.  */\n+\n+enum reg_class\n+mips_preferred_reload_class (rtx x, enum reg_class class)\n+{\n+  if (mips_dangerous_for_la25_p (x) && reg_class_subset_p (LEA_REGS, class))\n+    return LEA_REGS;\n+\n+  if (TARGET_HARD_FLOAT\n+      && FLOAT_MODE_P (GET_MODE (x))\n+      && reg_class_subset_p (FP_REGS, class))\n+    return FP_REGS;\n+\n+  if (reg_class_subset_p (GR_REGS, class))\n+    class = GR_REGS;\n+\n+  if (TARGET_MIPS16 && reg_class_subset_p (M16_REGS, class))\n+    class = M16_REGS;\n+\n+  return class;\n+}\n+\n /* This function returns the register class required for a secondary\n    register when copying between one of the registers in CLASS, and X,\n    using MODE.  If IN_P is nonzero, the copy is going from X to the\n@@ -7369,9 +7407,12 @@ mips_secondary_reload_class (enum reg_class class,\n \n   gp_reg_p = TARGET_MIPS16 ? M16_REG_P (regno) : GP_REG_P (regno);\n \n-  if (TEST_HARD_REG_BIT (reg_class_contents[(int) class], 25)\n-      && DANGEROUS_FOR_LA25_P (x))\n-    return LEA_REGS;\n+  if (mips_dangerous_for_la25_p (x))\n+    {\n+      gr_regs = LEA_REGS;\n+      if (TEST_HARD_REG_BIT (reg_class_contents[(int) class], 25))\n+\treturn gr_regs;\n+    }\n \n   /* Copying from HI or LO to anywhere other than a general register\n      requires a general register.  */\n@@ -7402,13 +7443,13 @@ mips_secondary_reload_class (enum reg_class class,\n     {\n       if (in_p)\n \treturn FP_REGS;\n-      return GP_REG_P (regno) ? NO_REGS : GR_REGS;\n+      return gp_reg_p ? NO_REGS : gr_regs;\n     }\n   if (ST_REG_P (regno))\n     {\n       if (! in_p)\n \treturn FP_REGS;\n-      return class == GR_REGS ? NO_REGS : GR_REGS;\n+      return class == gr_regs ? NO_REGS : gr_regs;\n     }\n \n   if (class == FP_REGS)\n@@ -7425,7 +7466,7 @@ mips_secondary_reload_class (enum reg_class class,\n \t     code by returning GR_REGS here.  */\n \t  return NO_REGS;\n \t}\n-      else if (GP_REG_P (regno) || x == CONST0_RTX (mode))\n+      else if (gp_reg_p || x == CONST0_RTX (mode))\n \t{\n \t  /* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */\n \t  return NO_REGS;\n@@ -7438,7 +7479,7 @@ mips_secondary_reload_class (enum reg_class class,\n       else\n \t{\n \t  /* Otherwise, we need to reload through an integer register.  */\n-\t  return GR_REGS;\n+\t  return gr_regs;\n \t}\n     }\n "}, {"sha": "dd94b8afcbc190665ea10b7d284b63a75d8860d6", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6008bd88abf03dbad82293089fef08d534fdaeb/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a6008bd88abf03dbad82293089fef08d534fdaeb", "patch": "@@ -2022,13 +2022,6 @@ extern enum reg_class mips_char_to_class[256];\n   ((C) == 'G'\t\t\t\t\t\t\t\t\\\n    && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\n \n-/* True if OP is a constant that should not be moved into $25.\n-   We need this because many versions of gas treat 'la $25,foo' as\n-   part of a call sequence and allow a global 'foo' to be lazily bound.  */\n-\n-#define DANGEROUS_FOR_LA25_P(OP)\t\t\t\t\t\\\n-  (!TARGET_EXPLICIT_RELOCS && global_got_operand (OP, VOIDmode))\n-\n /* Letters in the range `Q' through `U' may be defined in a\n    machine-dependent fashion to stand for arbitrary operand types.\n    The machine description macro `EXTRA_CONSTRAINT' is passed the\n@@ -2054,10 +2047,10 @@ extern enum reg_class mips_char_to_class[256];\n \t\t\t     && call_insn_operand (OP, VOIDmode))\t\\\n    : ((CODE) == 'T')\t  ? (CONSTANT_P (OP)\t\t\t\t\\\n \t\t\t     && move_operand (OP, VOIDmode)\t\t\\\n-\t\t\t     && DANGEROUS_FOR_LA25_P (OP))\t\t\\\n+\t\t\t     && mips_dangerous_for_la25_p (OP))\t\t\\\n    : ((CODE) == 'U')\t  ? (CONSTANT_P (OP)\t\t\t\t\\\n \t\t\t     && move_operand (OP, VOIDmode)\t\t\\\n-\t\t\t     && !DANGEROUS_FOR_LA25_P (OP))\t\t\\\n+\t\t\t     && !mips_dangerous_for_la25_p (OP))\t\\\n    : ((CODE) == 'W')\t  ? (GET_CODE (OP) == MEM\t\t\t\\\n \t\t\t     && memory_operand (OP, VOIDmode)\t\t\\\n \t\t\t     && (!TARGET_MIPS16\t\t\t\t\\\n@@ -2068,27 +2061,8 @@ extern enum reg_class mips_char_to_class[256];\n /* Say which of the above are memory constraints.  */\n #define EXTRA_MEMORY_CONSTRAINT(C, STR) ((C) == 'R' || (C) == 'W')\n \n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n-  ((CLASS) != ALL_REGS\t\t\t\t\t\t\t\\\n-   ? (! TARGET_MIPS16\t\t\t\t\t\t\t\\\n-      ? (CLASS)\t\t\t\t\t\t\t\t\\\n-      : ((CLASS) != GR_REGS\t\t\t\t\t\t\\\n-\t ? (CLASS)\t\t\t\t\t\t\t\\\n-\t : M16_REGS))\t\t\t\t\t\t\t\\\n-   : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n-       || GET_MODE_CLASS (GET_MODE (X)) == MODE_COMPLEX_FLOAT)\t\t\\\n-      ? (TARGET_SOFT_FLOAT\t\t\t\t\t\t\\\n-\t ? (TARGET_MIPS16 ? M16_REGS : GR_REGS)\t\t\t\t\\\n-\t : FP_REGS)\t\t\t\t\t\t\t\\\n-      : ((GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\t\t\\\n-\t  || GET_MODE (X) == VOIDmode)\t\t\t\t\t\\\n-\t ? (TARGET_MIPS16 ? M16_REGS : GR_REGS)\t\t\t\t\\\n-\t : (CLASS))))\n+  mips_preferred_reload_class (X, CLASS)\n \n /* Certain machines have the property that some registers cannot be\n    copied to some other registers without using memory.  Define this"}]}