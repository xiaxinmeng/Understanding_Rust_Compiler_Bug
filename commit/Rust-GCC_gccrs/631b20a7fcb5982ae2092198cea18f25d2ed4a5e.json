{"sha": "631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMxYjIwYTdmY2I1OTgyYWUyMDkyMTk4Y2VhMThmMjVkMmVkNGE1ZQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2013-07-21T17:39:50Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2013-07-21T17:39:50Z"}, "message": "Fix typos.\n\nFrom-SVN: r201105", "tree": {"sha": "b4024d8c280820c1b973990e1e6d3388cd6a735b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4024d8c280820c1b973990e1e6d3388cd6a735b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/comments", "author": null, "committer": null, "parents": [{"sha": "54a41d1b6fc8b66690f38f74f7d6d51e5f3b2d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54a41d1b6fc8b66690f38f74f7d6d51e5f3b2d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54a41d1b6fc8b66690f38f74f7d6d51e5f3b2d12"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "9a38ed7b48fd774c8737000e3aef2288e5f9fa95", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -2288,7 +2288,7 @@ aarch64_expand_epilogue (bool for_sibcall)\n \t However the dwarf emitter only understands a constant\n \t register offset.\n \n-\t The solution choosen here is to use the otherwise unused IP0\n+\t The solution chosen here is to use the otherwise unused IP0\n \t as a temporary register to hold the current SP value.  The\n \t CFA is described using IP0 then SP is modified.  */\n "}, {"sha": "aba8c6649b3334275fd7a107f3310f78d89e923a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -24362,7 +24362,7 @@ arm_expand_epilogue (bool really_return)\n   func_type = arm_current_func_type ();\n \n   /* Naked functions don't have epilogue.  Hence, generate return pattern, and\n-     let output_return_instruction take care of instruction emition if any.  */\n+     let output_return_instruction take care of instruction emission if any.  */\n   if (IS_NAKED (func_type)\n       || (IS_VOLATILE (func_type) && TARGET_ABORT_NORETURN))\n     {"}, {"sha": "6d95c101c2b5e7cb80ced88a79710e09e53de2cf", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -7541,7 +7541,7 @@ avr_rotate_bytes (rtx operands[])\n \t\tgcc_assert (move[blocked].links != -1);\n \t\t/* Replace src of  blocking move with scratch reg.  */\n \t\tmove[move[blocked].links].src = scratch;\n-\t\t/* Make dependent on scratch move occuring.  */\n+\t\t/* Make dependent on scratch move occurring.  */\n \t\tmove[blocked].links = size;\n \t\tsize=size+1;\n \t      }"}, {"sha": "140c56913599881800a1b5e787cde3a9b3973b09", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -2030,7 +2030,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   /* X86_TUNE_PAD_RETURNS */\n   m_CORE_ALL | m_AMD_MULTIPLE | m_GENERIC,\n \n-  /* X86_TUNE_PAD_SHORT_FUNCTION: Pad short funtion.  */\n+  /* X86_TUNE_PAD_SHORT_FUNCTION: Pad short function.  */\n   m_ATOM,\n \n   /* X86_TUNE_EXT_80387_CONSTANTS */\n@@ -29707,7 +29707,7 @@ ix86_get_function_versions_dispatcher (void *decl)\n \n   /* Find the default version and make it the first node.  */\n   first_v = node_v;\n-  /* Go to the beginnig of the chain.  */\n+  /* Go to the beginning of the chain.  */\n   while (first_v->prev != NULL)\n     first_v = first_v->prev;\n   default_version_info = first_v;\n@@ -35861,7 +35861,7 @@ ix86_pad_short_function (void)\n     }\n }\n \n-/* Fix up a Windows system unwinder issue.  If an EH region falls thru into\n+/* Fix up a Windows system unwinder issue.  If an EH region falls through into\n    the epilogue, the Windows system unwinder will apply epilogue logic and\n    produce incorrect offsets.  This can be avoided by adding a nop between\n    the last insn that can throw and the first insn of the epilogue.  */\n@@ -35883,7 +35883,7 @@ ix86_seh_fixup_eh_fallthru (void)\n       if (insn == NULL)\n \tcontinue;\n \n-      /* We only care about preceeding insns that can throw.  */\n+      /* We only care about preceding insns that can throw.  */\n       insn = prev_active_insn (insn);\n       if (insn == NULL || !can_throw_internal (insn))\n \tcontinue;\n@@ -36655,7 +36655,7 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n       op0 = gen_reg_rtx (mode);\n       emit_move_insn (op0, gen_lowpart (mode, op1));\n \n-      /* Load even elements into the second positon.  */\n+      /* Load even elements into the second position.  */\n       emit_insn (gen_load_even (op0,\n \t\t\t\tforce_reg (inner_mode,\n \t\t\t\t\t   ops [i + i + 1]),\n@@ -41179,7 +41179,7 @@ ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n \n /* Helper function of ix86_expand_mul_widen_evenodd.  Return true\n    if op is CONST_VECTOR with all odd elements equal to their\n-   preceeding element.  */\n+   preceding element.  */\n \n static bool\n const_vector_equal_evenodd_p (rtx op)"}, {"sha": "e8575ace160a448e8c660f4745b1cffdd76c96a5", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -2096,7 +2096,7 @@ picochip_expand_prologue (void)\n \n   /* Save the link registers. We could try to save just one register\n      here. This would reduce the amount of stack space required.\n-     There hasnt been a good reason to do that so far. */\n+     There hasn't been a good reason to do that so far. */\n   if (!picochip_can_eliminate_link_sp_save ())\n     picochip_emit_save_register (gen_rtx_REG (SImode, LINK_REGNUM),\n \t\t\t\t special_save_offset);\n@@ -3630,7 +3630,7 @@ memory_just_off (rtx opnd1, rtx opnd2)\n   }\n \n   /* Peepholing 2 STW/LDWs has the restriction that the resulting STL/LDL's address\n-     should be 4 byte aligned. We can currently guarentee that only if the base\n+     should be 4 byte aligned. We can currently guarantee that only if the base\n      address is FP(R13) and the offset is aligned. */\n \n   if (reg1 == reg2 && reg1 == 13 && abs(offset1-offset2) == 2 && minimum(offset1, offset2) % 4 == 0)\n@@ -3660,7 +3660,7 @@ registers_just_off (rtx opnd1, rtx opnd2)\n            LDL r[3:2],[r11]\n \n    NOTE:\n-   1. The LDWs themselves only guarentee that r11 will be a 2-byte\n+   1. The LDWs themselves only guarantee that r11 will be a 2-byte\n    aligned address. Only FP can be assumed to be 4 byte aligned.\n    2. The progression of addresses and the register numbers should\n    be similar. For eg., if you swap r2 and r3 in the above instructions,\n@@ -3883,7 +3883,7 @@ picochip_final_prescan_insn (rtx insn, rtx * opvec ATTRIBUTE_UNUSED,\n   if (GET_MODE (insn) == TImode || !picochip_schedule_type == DFA_TYPE_SPEED)\n     picochip_reset_vliw (insn);\n \n-  /* No VLIW scheduling occured, so don't go any further. */\n+  /* No VLIW scheduling occurred, so don't go any further. */\n   if (picochip_schedule_type != DFA_TYPE_SPEED)\n     return;\n "}, {"sha": "d43ec20e44044a61632b408aaee61ff75b9ecb17", "filename": "gcc/config/picochip/picochip.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.h?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -117,7 +117,7 @@ extern enum picochip_dfa_type picochip_schedule_type;\n #define FUNCTION_BOUNDARY 8\n \n /* This is the biggest alignment that can be allowed on this machine.\n-   Since the STANs have only 256 byte memory, it doesnt make sense\n+   Since the STANs have only 256 byte memory, it doesn't make sense\n    to have alignments greater than 32 bytes. Hence the value */\n #define MAX_OFILE_ALIGNMENT 32*8\n \n@@ -243,7 +243,7 @@ extern enum picochip_dfa_type picochip_schedule_type;\n    encoding.\n    Also r12 is put towards the end for leaf functions. Since leaf functions\n    do not have any calls, the prologue/epilogue for them wouldnt save up/\n-   restore its value. So, it doesnt make sense for us to use it in the middle,\n+   restore its value. So, it doesn't make sense for us to use it in the middle,\n    if we can avoid it. */\n #define REG_ALLOC_ORDER {5,4,3,2,1,0,12,6,7,8,9,10,11,14,16,0,0,0,0,0}\n #define LEAF_REG_ALLOC_ORDER {5,4,3,2,1,0,6,7,8,9,10,11,14,12,16,0,0,0,0,0}"}, {"sha": "04c759485f65480c5e52326fe4fbfb3359093a39", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -14596,7 +14596,7 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n /* Classify a register type.  Because the FMRGOW/FMRGEW instructions only work\n    on traditional floating point registers, and the VMRGOW/VMRGEW instructions\n    only work on the traditional altivec registers, note if an altivec register\n-   was choosen.  */\n+   was chosen.  */\n \n static enum rs6000_reg_type\n register_to_reg_type (rtx reg, bool *is_altivec)"}, {"sha": "c23fdf95a8cdf85ea1f770435de67a79cf5300ad", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -1112,7 +1112,7 @@ static unsigned int\n rx_function_arg_boundary (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  const_tree type ATTRIBUTE_UNUSED)\n {\n-  /* Older versions of the RX backend aligned all on-stack arguements\n+  /* Older versions of the RX backend aligned all on-stack arguments\n      to 32-bits.  The RX C ABI however says that they should be\n      aligned to their natural alignment.  (See section 5.2.2 of the ABI).  */\n   if (TARGET_GCC_ABI)"}, {"sha": "800d5f0aa0c4ae22eae3bdc66a358a734d5b1b0f", "filename": "gcc/config/s390/htmxlintrin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -31,7 +31,7 @@ extern \"C\" {\n \n /* These intrinsics are being made available for compatibility with\n    the IBM XL compiler.  For documentation please see the \"z/OS XL\n-   C/C++ Programming Guide\" publically available on the web.  */\n+   C/C++ Programming Guide\" publicly available on the web.  */\n \n extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n __TM_simple_begin ()"}, {"sha": "1ea52af0f2bd99c488092d185253b2202a34f853", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631b20a7fcb5982ae2092198cea18f25d2ed4a5e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=631b20a7fcb5982ae2092198cea18f25d2ed4a5e", "patch": "@@ -11253,7 +11253,7 @@ s390_sched_score (rtx insn)\n }\n \n /* This function is called via hook TARGET_SCHED_REORDER before\n-   issueing one insn from list READY which contains *NREADYP entries.\n+   issuing one insn from list READY which contains *NREADYP entries.\n    For target z10 it reorders load instructions to avoid early load\n    conflicts in the floating point pipeline  */\n static int"}]}