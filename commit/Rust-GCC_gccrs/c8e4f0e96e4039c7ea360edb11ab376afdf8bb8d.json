{"sha": "c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhlNGYwZTk2ZTQwMzljN2VhMzYwZWRiMTFhYjM3NmFmZGY4YmI4ZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2003-02-25T17:06:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2003-02-25T17:06:41Z"}, "message": "003-02-20  Aldy Hernandez  <aldyh@redhat.com>\n\n        * doc/tm.texi: Document Rename TARGET_VECTOR_TYPES_COMPATIBLE to\n        TARGET_VECTOR_OPAQUE_P.  Document accordingly.\n\n        * testsuite/gcc.dg/20030218-1.c: Check that initialization of\n        opaque types fail.\n\n        * c-typeck.c (comptypes): Change call to vector_types_compatible\n        to vector_opaque_p.\n        (convert_for_assignment): Call vector_opaque_p instead of\n        vector_types_compatible.\n        (really_start_incremental_init): Disallow initialization of opaque\n        types.\n\n        * target-def.h: Remove TARGET_VECTOR_TYPES_COMPATIBLE.\n        Define TARGET_VECTOR_OPAQUE_P.\n        (TARGET_INITIALIZER): Same.\n\n        * target.h (struct gcc_target): Remove vector_types_compatible.\n        Add vector_opaque_p.\n\n        * config/rs6000/rs6000.c (rs6000_spe_vector_types_compatible):\n        Remove.\n        (is_ev64_opaque_type): Check for TARGET_SPE and make sure type is\n        a vector type.  Change return type to bool.\n        (TARGET_VECTOR_TYPES_COMPATIBLE): Remove.\n        (TARGET_VECTOR_OPAQUE_P): Define.\n\n        * cp/parser.c (cp_parser_init_declarator): Call vector_opaque_p\n        target hook.\n        Include target.h.\n        (cp_parser_init_declarator): Fix typo in function comments.\n\nFrom-SVN: r63411", "tree": {"sha": "5cf30d09267a9dff332f16da7d0bc48a305e7975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cf30d09267a9dff332f16da7d0bc48a305e7975"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d9f2df2637ee19e5c9a33f1a83c84364209b02a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9f2df2637ee19e5c9a33f1a83c84364209b02a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d9f2df2637ee19e5c9a33f1a83c84364209b02a"}], "stats": {"total": 123, "additions": 80, "deletions": 43}, "files": [{"sha": "ceca00fa137ded4625678f73b199bf8e6cf2496c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -1,3 +1,37 @@\n+003-02-20  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * doc/tm.texi: Document Rename TARGET_VECTOR_TYPES_COMPATIBLE to\n+        TARGET_VECTOR_OPAQUE_P.  Document accordingly.\n+\n+        * testsuite/gcc.dg/20030218-1.c: Check that initialization of\n+        opaque types fail.\n+\n+        * c-typeck.c (comptypes): Change call to vector_types_compatible\n+        to vector_opaque_p.\n+        (convert_for_assignment): Call vector_opaque_p instead of\n+        vector_types_compatible.\n+        (really_start_incremental_init): Disallow initialization of opaque\n+        types.\n+\n+        * target-def.h: Remove TARGET_VECTOR_TYPES_COMPATIBLE.\n+        Define TARGET_VECTOR_OPAQUE_P.\n+        (TARGET_INITIALIZER): Same.\n+\n+        * target.h (struct gcc_target): Remove vector_types_compatible.\n+        Add vector_opaque_p.\n+\n+        * config/rs6000/rs6000.c (rs6000_spe_vector_types_compatible):\n+        Remove.\n+        (is_ev64_opaque_type): Check for TARGET_SPE and make sure type is\n+        a vector type.  Change return type to bool.\n+        (TARGET_VECTOR_TYPES_COMPATIBLE): Remove.\n+        (TARGET_VECTOR_OPAQUE_P): Define.\n+\n+        * cp/parser.c (cp_parser_init_declarator): Call vector_opaque_p\n+        target hook.\n+        Include target.h.\n+        (cp_parser_init_declarator): Fix typo in function comments.\n+\n Tue Feb 25 12:35:34 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* Makefile.in (lcm.o):  Add dependency on function.h"}, {"sha": "01a7c92a6653ec2110d20b983a2ea123641800dc", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -576,7 +576,8 @@ comptypes (type1, type2)\n \n     case VECTOR_TYPE:\n       /* The target might allow certain vector types to be compatible.  */\n-      val = (*targetm.vector_types_compatible) (t1, t2);\n+      val = (*targetm.vector_opaque_p) (t1)\n+\t|| (*targetm.vector_opaque_p) (t2);\n       break;\n \n     default:\n@@ -4071,7 +4072,8 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n     }\n   /* Some types can interconvert without explicit casts.  */\n   else if (codel == VECTOR_TYPE && coder == VECTOR_TYPE\n-\t   && (*targetm.vector_types_compatible) (type, rhstype))\n+\t   && ((*targetm.vector_opaque_p) (type)\n+\t       || (*targetm.vector_opaque_p) (rhstype)))\n     return convert (type, rhs);\n   /* Arithmetic types all interconvert, and enum is treated like int.  */\n   else if ((codel == INTEGER_TYPE || codel == REAL_TYPE \n@@ -5158,6 +5160,9 @@ really_start_incremental_init (type)\n   if (type == 0)\n     type = TREE_TYPE (constructor_decl);\n \n+  if ((*targetm.vector_opaque_p) (type))\n+    error (\"opaque vector types cannot be initialized\");\n+\n   p->type = constructor_type;\n   p->fields = constructor_fields;\n   p->index = constructor_index;"}, {"sha": "c26c4463b34d63355d0cfe91e52eb0d8b970753b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -268,8 +268,7 @@ static void is_altivec_return_reg PARAMS ((rtx, void *));\n static rtx generate_set_vrsave PARAMS ((rtx, rs6000_stack_t *, int));\n static void altivec_frame_fixup PARAMS ((rtx, rtx, HOST_WIDE_INT));\n static int easy_vector_constant PARAMS ((rtx));\n-static int is_ev64_opaque_type PARAMS ((tree));\n-static bool rs6000_spe_vector_types_compatible PARAMS ((tree, tree));\n+static bool is_ev64_opaque_type PARAMS ((tree));\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -422,8 +421,8 @@ static const char alt_reg_names[][8] =\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n-#undef TARGET_VECTOR_TYPES_COMPATIBLE\n-#define TARGET_VECTOR_TYPES_COMPATIBLE  rs6000_spe_vector_types_compatible\n+#undef TARGET_VECTOR_OPAQUE_P\n+#define TARGET_VECTOR_OPAQUE_P is_ev64_opaque_type\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -13599,35 +13598,17 @@ rs6000_memory_move_cost (mode, class, in)\n \n /* Return true if TYPE is of type __ev64_opaque__.  */\n \n-static int\n+static bool\n is_ev64_opaque_type (type)\n      tree type;\n {\n-  return (TYPE_NAME (type)\n+  return (TARGET_SPE\n+\t  && TREE_CODE (type) == VECTOR_TYPE\n+\t  && TYPE_NAME (type)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && DECL_NAME (TYPE_NAME (type))\n \t  && strcmp (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n \t\t     \"__ev64_opaque__\") == 0);\n }\n \n-/* Return true if vector type1 can be converted into vector type2.  */\n-\n-static bool\n-rs6000_spe_vector_types_compatible (t1, t2)\n-     tree t1;\n-     tree t2;\n-{\n-  if (!TARGET_SPE\n-      || TREE_CODE (t1) != VECTOR_TYPE || TREE_CODE (t2) != VECTOR_TYPE)\n-    return 0;\n-\n-  if (TYPE_NAME (t1) || TYPE_NAME (t2))\n-    return is_ev64_opaque_type (t1) || is_ev64_opaque_type (t2);\n-\n-  /* FIXME: We assume V2SI is the opaque type, so we accidentally\n-     allow inter conversion to and from V2SI modes.  We could use\n-     V1D1, and rewrite <spe.h> accordingly.  */\n-  return t1 == V2SI_type_node || t2 == V2SI_type_node;\n-}\n-\n #include \"gt-rs6000.h\""}, {"sha": "9ff6ab52bac54fe0fa8cb2609468b470aacd6c48", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -34,6 +34,7 @@\n #include \"diagnostic.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"target.h\"\n \n \f\n /* The lexer.  */\n@@ -9503,7 +9504,7 @@ cp_parser_asm_definition (cp_parser* parser)\n      declarator asm-specification [opt] attributes [opt] initializer [opt]\n \n    The DECL_SPECIFIERS and PREFIX_ATTRIBUTES apply to this declarator.\n-   Returns a reprsentation of the entity declared.  If MEMBER_P is TRUE,\n+   Returns a representation of the entity declared.  If MEMBER_P is TRUE,\n    then this declarator appears in a class scope.  The new DECL created\n    by this declarator is returned.\n \n@@ -9702,8 +9703,13 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* Parse the initializer.  */\n   if (is_initialized)\n-    initializer = cp_parser_initializer (parser, \n-\t\t\t\t\t &is_parenthesized_init);\n+    {\n+      if ((*targetm.vector_opaque_p) (TREE_TYPE (decl)))\n+\tcp_parser_error (parser, \"opaque vector types cannot be initialized\");\n+\n+      initializer = cp_parser_initializer (parser, \n+\t\t\t\t\t   &is_parenthesized_init);\n+    }\n   else\n     {\n       initializer = NULL_TREE;"}, {"sha": "a3c68a2923a783b3f4e3f5294908d1eb973beda5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -1452,10 +1452,12 @@ floating-point arithmetic.\n The default definition of this macro returns false for all sizes.\n @end table\n \n-@deftypefn {Target Hook} bool TARGET_VECTOR_TYPES_COMPATIBLE (tree @var{type1}, tree @var{type2})\n-This target hook should return @code{true} if no cast is needed when\n-copying a vector value of type @var{type1} into a vector lvalue of\n-type @var{type2}.  The default is that there are no such types.\n+@deftypefn {Target Hook} bool TARGET_VECTOR_OPAQUE_P (tree @var{type})\n+This target hook should return @code{true} a vector is opaque.  That\n+is, if no cast is needed when copying a vector value of type\n+@var{type} into another vector lvalue of the same size.  Vector opaque\n+types cannot be initialized.  The default is that there are no such\n+types.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_MS_BITFIELD_LAYOUT_P (tree @var{record_type})"}, {"sha": "a7f84c165eb984926fcc57fa1be47b25c93a6627", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -256,8 +256,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n \n-#ifndef TARGET_VECTOR_TYPES_COMPATIBLE\n-#define TARGET_VECTOR_TYPES_COMPATIBLE hook_bool_tree_tree_false\n+#ifndef TARGET_VECTOR_OPAQUE_P\n+#define TARGET_VECTOR_OPAQUE_P hook_bool_tree_false\n #endif\n \n /* In hook.c.  */\n@@ -307,7 +307,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n   TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n-  TARGET_VECTOR_TYPES_COMPATIBLE,\t\t\\\n+  TARGET_VECTOR_OPAQUE_P,\t\t\t\\\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\"}, {"sha": "95c97b4e224eac2b6c96150b32be46509545e627", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -320,8 +320,8 @@ struct gcc_target\n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) PARAMS ((enum machine_mode mode));\n \n-  /* True if two vector types can be copied without an explicit cast.  */\n-  bool (* vector_types_compatible) PARAMS ((tree, tree));\n+  /* True if a vector is opaque.  */\n+  bool (* vector_opaque_p) PARAMS ((tree));\n \n   /* Compute a (partial) cost for rtx X.  Return true if the complete\n      cost has been computed, and false if subexpressions should be"}, {"sha": "e41152c21c1475925ad0174a45776a725020065b", "filename": "gcc/testsuite/gcc.dg/20030218-1.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Ftestsuite%2Fgcc.dg%2F20030218-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d/gcc%2Ftestsuite%2Fgcc.dg%2F20030218-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030218-1.c?ref=c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "patch": "@@ -3,15 +3,24 @@\n \n /* Test vectors that can interconvert without a cast.  */\n \n-int vint __attribute__((mode(V2SI)));\n+typedef int __attribute__((mode(V2SI))) __ev64_opaque__;\n+\n+__ev64_opaque__ opp;\n+int vint   __attribute__((mode(V2SI)));\n int vshort __attribute__((mode(V4HI)));\n int vfloat __attribute__((mode(V2SF)));\n \n int\n main (void)\n {\n-  vint = vfloat;\n-  vshort = vint;\n+  __ev64_opaque__ george = { 1, 2 }; /* { dg-error \"opaque vector types cannot be initialized\" } */\n+\n+  opp = vfloat;\n+  vshort = opp;\n   vfloat = vshort; /* { dg-error \"incompatible types in assignment\" } */\n+\n+  /* Just because this is a V2SI, it doesn't make it an opaque.  */\n+  vint = vshort; /* { dg-error \"incompatible types in assignment\" } */\n+\n   return 0;\n }"}]}