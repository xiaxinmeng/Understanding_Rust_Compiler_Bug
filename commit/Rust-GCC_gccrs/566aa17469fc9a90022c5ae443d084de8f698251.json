{"sha": "566aa17469fc9a90022c5ae443d084de8f698251", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY2YWExNzQ2OWZjOWE5MDAyMmM1YWU0NDNkMDg0ZGU4ZjY5ODI1MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-21T09:41:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-21T09:41:11Z"}, "message": "i386.md (pophi1, [...]): Remove.\n\n\t* i386.md (pophi1, popqi1, pushqi1): Remove.\n\n\t* expr.c (emit_single_push_insn): New function.\n\t(move_by_pieces): Accept NULL as destination for push instructions.\n\t(gen_push_operand): Kill.\n\t(emit_push_insn): Pass NULL when pushing; avoid updating of\n\tstack_pointer_delta.\n\t* expr.h (gen_push_operand): Kill.\n\nFrom-SVN: r40686", "tree": {"sha": "d4f3de173ffadf7b9e6fde28b71832e04b0eda32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f3de173ffadf7b9e6fde28b71832e04b0eda32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/566aa17469fc9a90022c5ae443d084de8f698251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566aa17469fc9a90022c5ae443d084de8f698251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/566aa17469fc9a90022c5ae443d084de8f698251", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566aa17469fc9a90022c5ae443d084de8f698251/comments", "author": null, "committer": null, "parents": [{"sha": "d5c960a0e899ab90312f84826dca477363ceb8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c960a0e899ab90312f84826dca477363ceb8c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c960a0e899ab90312f84826dca477363ceb8c2"}], "stats": {"total": 187, "additions": 111, "deletions": 76}, "files": [{"sha": "f2b87045f2261e14eb6380829abd9fc02e4c0d5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=566aa17469fc9a90022c5ae443d084de8f698251", "patch": "@@ -1,3 +1,14 @@\n+Wed Mar 21 10:25:13 CET 2001  Jan Hubicka  <jh@use.cz>\n+\n+\t* i386.md (pophi1, popqi1, pushqi1): Remove.\n+\n+\t* expr.c (emit_single_push_insn): New function.\n+\t(move_by_pieces): Accept NULL as destination for push instructions.\n+\t(gen_push_operand): Kill.\n+\t(emit_push_insn): Pass NULL when pushing; avoid updating of\n+\tstack_pointer_delta.\n+\t* expr.h (gen_push_operand): Kill.\n+\n Tue Mar 20 20:15:06 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* rtl.texi (COMPARE): Clarify documentation and reference section"}, {"sha": "6eae78c567aad2f8ca4c8bb9d0128a04b29fadb1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=566aa17469fc9a90022c5ae443d084de8f698251", "patch": "@@ -1745,16 +1745,6 @@\n   [(set_attr \"type\" \"push\")\n    (set_attr \"mode\" \"HI\")])\n \n-(define_insn \"*pophi1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(mem:HI (reg:SI 7)))\n-   (set (reg:SI 7)\n-\t(plus:SI (reg:SI 7) (const_int 2)))]\n-  \"!TARGET_64BIT\"\n-  \"pop{w}\\\\t%0\"\n-  [(set_attr \"type\" \"pop\")\n-   (set_attr \"mode\" \"HI\")])\n-\n (define_insn \"*movhi_1\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=*a,r,r,*a,r,m\")\n \t(match_operand:HI 1 \"general_operand\" \"i,r,rn,rm,rm,rn\"))]\n@@ -1868,30 +1858,6 @@\n   \"\"\n   \"ix86_expand_move (QImode, operands); DONE;\")\n \n-;; emit_push_insn when it calls move_by_pieces requires an insn to\n-;; \"push a byte\".  But actually we use pushw, which has the effect\n-;; of rounding the amount pushed up to a halfword.\n-\n-(define_insn \"*pushqi2\"\n-  [(set (match_operand:QI 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:QI 1 \"nonmemory_no_elim_operand\" \"n,r\"))]\n-  \"!TARGET_64BIT\"\n-  \"@\n-   push{w}\\\\t{|word ptr }%1\n-   push{w}\\\\t%w1\"\n-  [(set_attr \"type\" \"push\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*popqi1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r*m\")\n-\t(mem:QI (reg:SI 7)))\n-   (set (reg:SI 7)\n-\t(plus:SI (reg:SI 7) (const_int 2)))]\n-  \"!TARGET_64BIT\"\n-  \"pop{w}\\\\t%0\"\n-  [(set_attr \"type\" \"pop\")\n-   (set_attr \"mode\" \"HI\")])\n-\n ;; Situation is quite tricky about when to choose full sized (SImode) move\n ;; over QImode moves.  For Q_REG -> Q_REG move we use full size only for\n ;; partial register dependency machines (such as AMD Athlon), where QImode"}, {"sha": "f2523a41b2251231e2341a24ba666070fd8a44d1", "filename": "gcc/expr.c", "status": "modified", "additions": 100, "deletions": 39, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=566aa17469fc9a90022c5ae443d084de8f698251", "patch": "@@ -174,6 +174,7 @@ static void do_jump_by_parts_equality PARAMS ((tree, rtx, rtx));\n static void do_compare_and_jump\tPARAMS ((tree, enum rtx_code, enum rtx_code,\n \t\t\t\t\t rtx, rtx));\n static rtx do_store_flag\tPARAMS ((tree, rtx, enum machine_mode, int));\n+static void emit_single_push_insn PARAMS ((enum machine_mode, rtx, tree));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -1387,6 +1388,10 @@ convert_modes (mode, oldmode, x, unsignedp)\n    from block FROM to block TO.  (These are MEM rtx's with BLKmode).\n    The caller must pass FROM and TO\n     through protect_from_queue before calling.\n+\n+   When TO is NULL, the emit_single_push_insn is used to push the\n+   FROM to stack.\n+\n    ALIGN is maximum alignment we can assume.  */\n \n void\n@@ -1396,28 +1401,43 @@ move_by_pieces (to, from, len, align)\n      unsigned int align;\n {\n   struct move_by_pieces data;\n-  rtx to_addr = XEXP (to, 0), from_addr = XEXP (from, 0);\n+  rtx to_addr, from_addr = XEXP (from, 0);\n   unsigned int max_size = MOVE_MAX_PIECES + 1;\n   enum machine_mode mode = VOIDmode, tmode;\n   enum insn_code icode;\n \n   data.offset = 0;\n-  data.to_addr = to_addr;\n   data.from_addr = from_addr;\n-  data.to = to;\n+  if (to)\n+    {\n+      to_addr = XEXP (to, 0);\n+      data.to = to;\n+      data.autinc_to\n+\t= (GET_CODE (to_addr) == PRE_INC || GET_CODE (to_addr) == PRE_DEC\n+\t   || GET_CODE (to_addr) == POST_INC || GET_CODE (to_addr) == POST_DEC);\n+      data.reverse\n+\t= (GET_CODE (to_addr) == PRE_DEC || GET_CODE (to_addr) == POST_DEC);\n+    }\n+  else\n+    {\n+      to_addr = NULL_RTX;\n+      data.to = NULL_RTX;\n+      data.autinc_to = 1;\n+#ifdef STACK_GROWS_DOWNWARD\n+      data.reverse = 1;\n+#else\n+      data.reverse = 0;\n+#endif\n+    }\n+  data.to_addr = to_addr;\n   data.from = from;\n-  data.autinc_to\n-    = (GET_CODE (to_addr) == PRE_INC || GET_CODE (to_addr) == PRE_DEC\n-       || GET_CODE (to_addr) == POST_INC || GET_CODE (to_addr) == POST_DEC);\n   data.autinc_from\n     = (GET_CODE (from_addr) == PRE_INC || GET_CODE (from_addr) == PRE_DEC\n        || GET_CODE (from_addr) == POST_INC\n        || GET_CODE (from_addr) == POST_DEC);\n \n   data.explicit_inc_from = 0;\n   data.explicit_inc_to = 0;\n-  data.reverse\n-    = (GET_CODE (to_addr) == PRE_DEC || GET_CODE (to_addr) == POST_DEC);\n   if (data.reverse) data.offset = len;\n   data.len = len;\n \n@@ -1550,14 +1570,17 @@ move_by_pieces_1 (genfun, mode, data)\n       if (data->reverse)\n \tdata->offset -= size;\n \n-      if (data->autinc_to)\n+      if (data->to)\n \t{\n-\t  to1 = gen_rtx_MEM (mode, data->to_addr);\n-\t  MEM_COPY_ATTRIBUTES (to1, data->to);\n+\t  if (data->autinc_to)\n+\t    {\n+\t      to1 = gen_rtx_MEM (mode, data->to_addr);\n+\t      MEM_COPY_ATTRIBUTES (to1, data->to);\n+\t    }\n+\t  else\n+\t    to1 = change_address (data->to, mode,\n+\t\t\t\t  plus_constant (data->to_addr, data->offset));\n \t}\n-      else\n-\tto1 = change_address (data->to, mode,\n-\t\t\t      plus_constant (data->to_addr, data->offset));\n \n       if (data->autinc_from)\n \t{\n@@ -1573,7 +1596,10 @@ move_by_pieces_1 (genfun, mode, data)\n       if (HAVE_PRE_DECREMENT && data->explicit_inc_from < 0)\n \temit_insn (gen_add2_insn (data->from_addr, GEN_INT (-size)));\n \n-      emit_insn ((*genfun) (to1, from1));\n+      if (data->to)\n+\temit_insn ((*genfun) (to1, from1));\n+      else\n+\temit_single_push_insn (mode, from1, NULL);\n \n       if (HAVE_POST_INCREMENT && data->explicit_inc_to > 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (size)));\n@@ -3078,11 +3104,6 @@ push_block (size, extra, below)\n   return memory_address (GET_CLASS_NARROWEST_MODE (MODE_INT), temp);\n }\n \n-rtx\n-gen_push_operand ()\n-{\n-  return gen_rtx_fmt_e (STACK_PUSH_CODE, Pmode, stack_pointer_rtx);\n-}\n \n /* Return an rtx for the address of the beginning of a as-if-it-was-pushed\n    block of SIZE bytes.  */\n@@ -3103,6 +3124,51 @@ get_push_address (size)\n   return copy_to_reg (temp);\n }\n \n+/* Emit single push insn.  */\n+static void\n+emit_single_push_insn (mode, x, type)\n+     rtx x;\n+     enum machine_mode mode;\n+     tree type;\n+{\n+#ifdef PUSH_ROUNDING\n+  rtx dest_addr;\n+  int rounded_size = PUSH_ROUNDING (GET_MODE_SIZE (mode));\n+  rtx dest;\n+\n+  if (GET_MODE_SIZE (mode) == rounded_size)\n+    dest_addr = gen_rtx_fmt_e (STACK_PUSH_CODE, Pmode, stack_pointer_rtx);\n+  else\n+    {\n+#ifdef STACK_GROWS_DOWNWARD\n+      dest_addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\tGEN_INT (-rounded_size));\n+#else\n+      dest_addr = gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\tGEN_INT (rounded_size));\n+#endif\n+      dest_addr = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, dest_addr);\n+    }\n+\n+  dest = gen_rtx_MEM (mode, dest_addr);\n+\n+  stack_pointer_delta += PUSH_ROUNDING (GET_MODE_SIZE (mode));\n+\n+  if (type != 0)\n+    {\n+      set_mem_attributes (dest, type, 1);\n+      /* Function incoming arguments may overlap with sibling call\n+         outgoing arguments and we cannot allow reordering of reads\n+         from function arguments with stores to outgoing arguments\n+         of sibling calls.  */\n+      MEM_ALIAS_SET (dest) = 0;\n+    }\n+  emit_move_insn (dest, x);\n+#else\n+  abort();\n+#endif\n+}\n+\n /* Generate code to push X onto the stack, assuming it has mode MODE and\n    type TYPE.\n    MODE is redundant except when X is a CONST_INT (since they don't\n@@ -3223,9 +3289,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      && where_pad != none && where_pad != stack_direction)\n \t    anti_adjust_stack (GEN_INT (extra));\n \n-\t  stack_pointer_delta += INTVAL (size) - used;\n-\t  move_by_pieces (gen_rtx_MEM (BLKmode, gen_push_operand ()), xinner,\n-\t\t\t  INTVAL (size) - used, align);\n+\t  move_by_pieces (NULL, xinner, INTVAL (size) - used, align);\n \n \t  if (current_function_check_memory_usage && ! in_check_memory_usage)\n \t    {\n@@ -3477,10 +3541,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n #ifdef PUSH_ROUNDING\n       if (args_addr == 0 && PUSH_ARGS)\n-\t{\n-\t  addr = gen_push_operand ();\n-\t  stack_pointer_delta += PUSH_ROUNDING (GET_MODE_SIZE (mode));\n-\t}\n+\temit_single_push_insn (mode, x, type);\n       else\n #endif\n \t{\n@@ -3493,20 +3554,20 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t    addr = memory_address (mode, gen_rtx_PLUS (Pmode, args_addr,\n \t\t\t\t\t\t       args_so_far));\n \t  target = addr;\n-\t}\n+\t  dest = gen_rtx_MEM (mode, addr);\n+\t  if (type != 0)\n+\t    {\n+\t      set_mem_attributes (dest, type, 1);\n+\t      /* Function incoming arguments may overlap with sibling call\n+\t\t outgoing arguments and we cannot allow reordering of reads\n+\t\t from function arguments with stores to outgoing arguments\n+\t\t of sibling calls.  */\n+\t      MEM_ALIAS_SET (dest) = 0;\n+\t    }\n \n-      dest = gen_rtx_MEM (mode, addr);\n-      if (type != 0)\n-\t{\n-\t  set_mem_attributes (dest, type, 1);\n-\t  /* Function incoming arguments may overlap with sibling call\n-\t     outgoing arguments and we cannot allow reordering of reads\n-\t     from function arguments with stores to outgoing arguments\n-\t     of sibling calls.  */\n-\t  MEM_ALIAS_SET (dest) = 0;\n-\t}\n+\t  emit_move_insn (dest, x);\n \n-      emit_move_insn (dest, x);\n+\t}\n \n       if (current_function_check_memory_usage && ! in_check_memory_usage)\n \t{"}, {"sha": "abfc38de8e9faca4c9b98c7217823cfad6ff8bd8", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566aa17469fc9a90022c5ae443d084de8f698251/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=566aa17469fc9a90022c5ae443d084de8f698251", "patch": "@@ -1040,9 +1040,6 @@ extern rtx emit_move_insn_1 PARAMS ((rtx, rtx));\n    and return an rtx to address the beginning of the block.  */\n extern rtx push_block PARAMS ((rtx, int, int));\n \n-/* Make an operand to push something on the stack.  */\n-extern rtx gen_push_operand PARAMS ((void));\n-\n #ifdef TREE_CODE\n /* Generate code to push something onto the stack, given its mode and type.  */\n extern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx,"}]}