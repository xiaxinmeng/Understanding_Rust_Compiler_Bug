{"sha": "2742a1edf52524ccaf6d406327695912a198bb65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc0MmExZWRmNTI1MjRjY2FmNmQ0MDYzMjc2OTU5MTJhMTk4YmI2NQ==", "commit": {"author": {"name": "Mark Dettinger", "email": "dettinge@de.ibm.com", "date": "2004-12-10T16:25:51Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-12-10T16:25:51Z"}, "message": "s390.c (struct processor_costs): New fields ml, sqdbr, sqebr.\n\n2004-12-06  Mark Dettinger  <dettinge@de.ibm.com>\n\n\t* config/s390/s390.c (struct processor_costs): New fields ml,\n\tsqdbr, sqebr.\n\t(s390_rtx_costs): Added the missing handling of multiply & add,\n\tsquare root, and umulsidi.\n\nFrom-SVN: r91996", "tree": {"sha": "185c3d4fd7f0a425d23e5e76c41fcaf1f8d82bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/185c3d4fd7f0a425d23e5e76c41fcaf1f8d82bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2742a1edf52524ccaf6d406327695912a198bb65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2742a1edf52524ccaf6d406327695912a198bb65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2742a1edf52524ccaf6d406327695912a198bb65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2742a1edf52524ccaf6d406327695912a198bb65/comments", "author": null, "committer": null, "parents": [{"sha": "9bf0e5888c1217afef058dbb59cb5d7824c4bba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf0e5888c1217afef058dbb59cb5d7824c4bba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf0e5888c1217afef058dbb59cb5d7824c4bba2"}], "stats": {"total": 50, "additions": 47, "deletions": 3}, "files": [{"sha": "829df473ded767c1431b6932b12c68f0f8ed5cb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2742a1edf52524ccaf6d406327695912a198bb65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2742a1edf52524ccaf6d406327695912a198bb65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2742a1edf52524ccaf6d406327695912a198bb65", "patch": "@@ -1,3 +1,10 @@\n+2004-12-10  Mark Dettinger  <dettinge@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct processor_costs): New fields ml,\n+\tsqdbr, sqebr.\n+\t(s390_rtx_costs): Added the missing handling of multiply & add,\n+\tsquare root, and umulsidi.\n+\n 2004-12-10  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* expmed.c (synth_mult): Initialize new_limit.latency before"}, {"sha": "856a0b78ea38b652820409b69147dc97ad1f99ce", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2742a1edf52524ccaf6d406327695912a198bb65/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2742a1edf52524ccaf6d406327695912a198bb65/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=2742a1edf52524ccaf6d406327695912a198bb65", "patch": "@@ -94,6 +94,7 @@ struct processor_costs\n   const int mghi;     /* cost of an MGHI instruction.  */\n   const int mh;       /* cost of an MH instruction.  */\n   const int mhi;      /* cost of an MHI instruction.  */\n+  const int ml;       /* cost of an ML instruction.  */\n   const int mr;       /* cost of an MR instruction.  */\n   const int ms;       /* cost of an MS instruction.  */\n   const int msg;      /* cost of an MSG instruction.  */\n@@ -102,6 +103,8 @@ struct processor_costs\n   const int msgr;     /* cost of an MSGR instruction.  */\n   const int msr;      /* cost of an MSR instruction.  */\n   const int mult_df;  /* cost of multiplication in DFmode.  */\n+  const int sqdbr;    /* cost of square root in DFmode.  */\n+  const int sqebr;    /* cost of square root in SFmode.  */\n };\n \n const struct processor_costs *s390_cost;\n@@ -113,6 +116,7 @@ struct processor_costs z900_cost =\n   COSTS_N_INSNS (10),    /* MGHI  */\n   COSTS_N_INSNS (5),     /* MH    */\n   COSTS_N_INSNS (4),     /* MHI   */\n+  COSTS_N_INSNS (5),     /* ML    */\n   COSTS_N_INSNS (5),     /* MR    */\n   COSTS_N_INSNS (4),     /* MS    */\n   COSTS_N_INSNS (15),    /* MSG   */\n@@ -121,6 +125,8 @@ struct processor_costs z900_cost =\n   COSTS_N_INSNS (10),    /* MSGR  */\n   COSTS_N_INSNS (4),     /* MSR   */\n   COSTS_N_INSNS (7),     /* multiplication in DFmode */\n+  COSTS_N_INSNS (44),    /* SQDBR */\n+  COSTS_N_INSNS (35),    /* SQEBR */\n };\n \n static const\n@@ -130,6 +136,7 @@ struct processor_costs z990_cost =\n   COSTS_N_INSNS (2),     /* MGHI  */\n   COSTS_N_INSNS (2),     /* MH    */\n   COSTS_N_INSNS (2),     /* MHI   */\n+  COSTS_N_INSNS (4),     /* ML    */\n   COSTS_N_INSNS (4),     /* MR    */\n   COSTS_N_INSNS (5),     /* MS    */\n   COSTS_N_INSNS (6),     /* MSG   */\n@@ -138,6 +145,8 @@ struct processor_costs z990_cost =\n   COSTS_N_INSNS (4),     /* MSGR  */\n   COSTS_N_INSNS (4),     /* MSR   */\n   COSTS_N_INSNS (1),     /* multiplication in DFmode */\n+  COSTS_N_INSNS (66),    /* SQDBR */\n+  COSTS_N_INSNS (38),    /* SQEBR */\n };\n \n \n@@ -1882,21 +1891,36 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case LSHIFTRT:\n     case ROTATE:\n     case ROTATERT:\n-    case PLUS:\n     case AND:\n     case IOR:\n     case XOR:\n-    case MINUS:\n     case NEG:\n     case NOT:\n       *total = COSTS_N_INSNS (1);\n       return false;\n \n+    case PLUS:\n+    case MINUS:\n+      /* Check for multiply and add.  */\n+      if (GET_MODE (x) == DFmode\n+\t  && GET_CODE (XEXP (x, 0)) == MULT\n+\t  && TARGET_HARD_FLOAT && TARGET_IEEE_FLOAT && TARGET_FUSED_MADD)\n+\t{\n+\t  /* This is the multiply and add case.  */\n+\t  *total = s390_cost->mult_df \n+\t    + rtx_cost (XEXP (XEXP (x, 0), 0), MULT) \n+\t    + rtx_cost (XEXP (XEXP (x, 0), 1), MULT) \n+\t    + rtx_cost (XEXP (x, 1), code);\n+\t  return true;  /* Do not do an additional recursive descent.  */\n+\t}\n+      *total = COSTS_N_INSNS (1);\n+      return false;\n+\n     case MULT:      \n       switch (GET_MODE (x))\n \t{\n \tcase SImode:\n-\t  {\t  \n+\t  {\n \t    rtx left = XEXP (x, 0);\n \t    rtx right = XEXP (x, 1);\n \t    if (GET_CODE (right) == CONST_INT\n@@ -1928,6 +1952,11 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t\t    && GET_CODE (right) == SIGN_EXTEND)\n \t\t  /* mulsidi case: mr, m */\n \t\t  *total = s390_cost->m;\n+\t\telse if (GET_CODE (left) == ZERO_EXTEND\n+\t\t\t && GET_CODE (right) == ZERO_EXTEND\n+\t\t\t && TARGET_CPU_ZARCH)\n+\t\t  /* umulsidi case: ml, mlr */\n+\t\t  *total = s390_cost->ml;\n \t\telse\n \t\t  /* Complex calculation is required.  */\n \t\t  *total = COSTS_N_INSNS (40);\n@@ -1950,7 +1979,15 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n       *total = COSTS_N_INSNS (33);\n       return false;\n \n+    case SQRT:\n+      if (GET_MODE (x) == SFmode)\n+\t*total = s390_cost->sqebr;\n+      else /* DFmode */\n+\t*total = s390_cost->sqdbr;\n+      return false;\n+\n     case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n       if (outer_code == MULT)\n \t*total = 0;\n       return false;"}]}