{"sha": "563dd08adfa12573fdecf9669fdf685fef5fd360", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYzZGQwOGFkZmExMjU3M2ZkZWNmOTY2OWZkZjY4NWZlZjVmZDM2MA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-07-08T02:18:25Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-07-08T02:18:25Z"}, "message": "cpphash.c (is__va_args__): New function.\n\n\t* cpphash.c (is__va_args__): New function.\n\t(count_params): Fix line reported in error messages.  Use\n\tis__va_args__.  Don't return ')' on error.  Flag GNU style\n\trest args macro definitions.\n\t(parse_define): Check macro name is not __VA_ARGS__.\n\t(save_expansion): Check identifier in non-varargs-macro is\n\tnot __VA_ARGS__.  Don't flag GNU_VARARGS.\n\t* cpplex.c (parse_args): Accept no argument iff GNU_REST_ARGS.\n\t(maybe_paste_with_next): Use per-macro GNU_REST_ARGS rather\n\t than per-token GNU_VARARGS.\n\t* cpplib.h (GNU_VARARGS): Remove.\n\t(GNU_REST_ARGS): New.\n\n\t* gcc.dg/cpp/macsyntx.c: New tests.\n\nFrom-SVN: r34919", "tree": {"sha": "9ca49cb51958d754a1e1218f2ee16625c7cb8dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ca49cb51958d754a1e1218f2ee16625c7cb8dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/563dd08adfa12573fdecf9669fdf685fef5fd360", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/563dd08adfa12573fdecf9669fdf685fef5fd360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/563dd08adfa12573fdecf9669fdf685fef5fd360", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/563dd08adfa12573fdecf9669fdf685fef5fd360/comments", "author": null, "committer": null, "parents": [{"sha": "0828a0bd1b6f503880c694f106c8424967cb38aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0828a0bd1b6f503880c694f106c8424967cb38aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0828a0bd1b6f503880c694f106c8424967cb38aa"}], "stats": {"total": 192, "additions": 157, "deletions": 35}, "files": [{"sha": "eaee6c8ac7da1c672c7bb6b18a778438855282d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=563dd08adfa12573fdecf9669fdf685fef5fd360", "patch": "@@ -1,3 +1,18 @@\n+2000-07-08  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpphash.c (is__va_args__): New function.\n+\t(count_params): Fix line reported in error messages.  Use\n+\tis__va_args__.  Don't return ')' on error.  Flag GNU style\n+\trest args macro definitions.\n+\t(parse_define): Check macro name is not __VA_ARGS__.\n+\t(save_expansion): Check identifier in non-varargs-macro is\n+\tnot __VA_ARGS__.  Don't flag GNU_VARARGS.\n+\t* cpplex.c (parse_args): Accept no argument iff GNU_REST_ARGS.\n+\t(maybe_paste_with_next): Use per-macro GNU_REST_ARGS rather\n+\t than per-token GNU_VARARGS.\n+\t* cpplib.h (GNU_VARARGS): Remove.\n+\t(GNU_REST_ARGS): New.\n+\n Sat Jul  8 01:38:25 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (call_pop, call, call_value_pop): Do not set"}, {"sha": "ee0521b59770769b67d0d88fc600529eaccb31a8", "filename": "gcc/cpphash.c", "status": "modified", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=563dd08adfa12573fdecf9669fdf685fef5fd360", "patch": "@@ -52,6 +52,7 @@ static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n static const cpp_token *count_params PARAMS ((cpp_reader *,\n \t\t\t\t\t      const cpp_token *,\n \t\t\t\t\t      cpp_toklist *));\n+static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n static cpp_toklist *parse_define PARAMS((cpp_reader *));\n static int check_macro_redefinition PARAMS((cpp_reader *, cpp_hashnode *hp,\n \t\t\t\t\t     const cpp_toklist *));\n@@ -197,6 +198,26 @@ find_param (first, token)\n   return 0;\n }\n \n+/* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n+   replacement list of a variable-arguments macro.  TOKEN is assumed\n+   to be of type CPP_NAME.  */\n+static int\n+is__va_args__ (pfile, token)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+{\n+  if (!CPP_OPTION (pfile, pedantic)\n+      || token->val.name.len != sizeof (var_args_str) - 1\n+      || ustrncmp (token->val.name.text, var_args_str,\n+\t\t   sizeof (var_args_str) - 1))\n+    return 0;\n+\n+  cpp_pedwarn_with_line (pfile, token->line, token->col,\n+       \"\\\"%s\\\" is only valid in the replacement list of a function-like macro\",\n+\t\t       var_args_str);\n+  return 1;\n+}\n+\n /* Counts the parameters to a function like macro, and saves their\n    spellings if necessary.  Returns the token that we stopped scanning\n    at; if it's type isn't CPP_CLOSE_PAREN there was an error, which\n@@ -208,7 +229,6 @@ count_params (pfile, first, list)\n      cpp_toklist *list;\n {\n   unsigned int params_len = 0, prev_ident = 0;\n-  unsigned int line = pfile->token_list.line;\n   const cpp_token *token, *temp;\n \n   list->paramc = 0;\n@@ -217,7 +237,8 @@ count_params (pfile, first, list)\n       switch (token->type)\n \t{\n \tcase CPP_EOF:\n-\t  cpp_error_with_line (pfile, line, token->col,\n+\tmissing_paren:\n+\t  cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t       \"missing ')' in macro parameter list\");\n \t  goto out;\n \n@@ -227,21 +248,14 @@ count_params (pfile, first, list)\n \tcase CPP_NAME:\n \t  if (prev_ident)\n \t    {\n-\t      cpp_error_with_line (pfile, line, token->col,\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t   \"macro parameters must be comma-separated\");\n \t      goto out;\n \t    }\n \n \t  /* Constraint 6.10.3.5  */\n-\t  if (token->val.name.len == sizeof (var_args_str) - 1\n-\t      && !ustrncmp (token->val.name.text, var_args_str,\n-\t\t\t    sizeof (var_args_str) - 1))\n-\t    {\n-\t      cpp_error_with_line (pfile, line, token->col,\n-\t\t\t\t   \"\\\"%s\\\" is not a valid parameter name\",\n-\t\t\t\t   var_args_str);\n-\t      goto out;\n-\t    }\n+\t  if (is__va_args__ (pfile, token))\n+\t    goto out;\n \n \t  params_len += token->val.name.len + 1;\n \t  prev_ident = 1;\n@@ -250,7 +264,7 @@ count_params (pfile, first, list)\n \t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n \t  if (find_param (first, token))\n \t    {\n-\t      cpp_error_with_line (pfile, line, token->col,\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t\t   \"duplicate macro parameter \\\"%.*s\\\"\",\n \t\t\t\t   (int) token->val.name.len,\n \t\t\t\t   token->val.name.text);\n@@ -259,7 +273,7 @@ count_params (pfile, first, list)\n \t  break;\n \n \tdefault:\n-\t  cpp_error_with_line (pfile, line, token->col,\n+\t  cpp_error_with_line (pfile, token->line, token->col,\n \t\t\t       \"illegal token in macro parameter list\");\n \t  goto out;\n \n@@ -271,8 +285,10 @@ count_params (pfile, first, list)\n \tcase CPP_COMMA:\n \t  if (!prev_ident)\n \t    {\n-\t      cpp_error_with_line (pfile, line, token->col,\n-\t\t\t\t   \"missing parameter name\");\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t\t   \"parameter name expected\");\n+\t      if (token->type == CPP_CLOSE_PAREN)\n+\t\ttoken--;\t\t/* Return the ',' not ')'.  */\n \t      goto out;\n \t    }\n \t  prev_ident = 0;\n@@ -293,22 +309,24 @@ count_params (pfile, first, list)\n \t      tok->val.name.len = sizeof (var_args_str) - 1;\n \t      tok->val.name.text = var_args_str; /* Safe.  */\n \t      list->paramc++;\n-\n+\t  \n \t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n \t\tcpp_pedwarn (pfile,\n \t\t\t     \"C89 does not permit anon varargs macros\");\n \t    }\n-\t  else if (CPP_PEDANTIC (pfile))\n-\t    cpp_pedwarn (pfile,\n-\t\t\t \"ISO C does not permit named varargs parameters\");\n+\t  else\n+\t    {\n+\t      list->flags |= GNU_REST_ARGS;\n+\t      if (CPP_PEDANTIC (pfile))\n+\t\tcpp_pedwarn (pfile,\n+\t\t\t     \"ISO C does not permit named varargs parameters\");\n+\t    }\n \n \t  list->flags |= VAR_ARGS;\n \t  token++;\n \t  if (token->type == CPP_CLOSE_PAREN)\n \t    goto scanned;\n-\t  cpp_error_with_line (pfile, line, token->col,\n-\t\t\t       \"')' expected after \\\"...\\\"\");\n-\t  goto out;\n+\t  goto missing_paren;\n \t}\n     }\n \n@@ -345,8 +363,15 @@ parse_define (pfile)\n   cpp_toklist *list;\n   int prev_white = 0;\n \n-  while ((token = cpp_get_token (pfile))->type == CPP_COMMENT)\n-    prev_white = 1;\n+  /* The first token after the macro's name.  */\n+  token = cpp_get_token (pfile);\n+\n+  /* Constraint 6.10.3.5  */\n+  if (is__va_args__ (pfile, token - 1))\n+    return 0;\n+\n+  while (token->type == CPP_COMMENT)\n+    token++, prev_white = 1;\n \n   /* Allocate the expansion's list.  It will go in the hash table.  */\n   list = (cpp_toklist *) xmalloc (sizeof (cpp_toklist));\n@@ -461,6 +486,12 @@ save_expansion (pfile, list, first, first_param)\n \t\t}\n \t    }\n \t}\n+      else if (token->type == CPP_NAME)\n+\t{\n+\t  /* Constraint 6.10.3.5  */\n+\t  if (!(list->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n+\t    return 1;\n+\t}\n       ntokens++;\n       if (token_spellings[token->type].type > SPELL_NONE)\n \tlen += token->val.name.len;\n@@ -497,10 +528,6 @@ save_expansion (pfile, list, first, first_param)\n \t    dest->flags = token[-1].flags | STRINGIFY_ARG;\n \t  else\n \t    dest->flags = token->flags;  /* Particularly PREV_WHITE.  */\n-\n-\t  if ((int) param_no == list->paramc && list->flags & VAR_ARGS\n-\t      && dest != list->tokens && dest[-1].flags & PASTE_LEFT)\n-\t    dest[-1].flags |= GNU_VARARGS;\n \t  dest++;\n \t  continue;\n "}, {"sha": "03439fa7233cabd80ea2432ebeb36f27faf00431", "filename": "gcc/cpplex.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=563dd08adfa12573fdecf9669fdf685fef5fd360", "patch": "@@ -2222,9 +2222,9 @@ parse_args (pfile, hp, args)\n \t e.g. #define debug(format, args...) ...\n \t debug(\"string\");\n \t This is exactly the same as if the rest argument had received no\n-\t tokens - debug(\"string\",);  */\n+\t tokens - debug(\"string\",);  This extension is deprecated.  */\n \t\n-      if (argc + 1 == macro->paramc && (macro->flags & VAR_ARGS))\n+      if (argc + 1 == macro->paramc && (macro->flags & GNU_REST_ARGS))\n \t{\n \t  /* Duplicate the placemarker.  Then we can set its flags and\n              position and safely be using more than one.  */\n@@ -2525,15 +2525,19 @@ maybe_paste_with_next (pfile, token)\n   second = cpp_get_token (pfile);\n   pfile->paste_level = 0;\n \n-  /* Ignore placemarker argument tokens.  */\n+  /* Ignore placemarker argument tokens (cannot be from an empty macro\n+     since macros are not expanded).  */\n   if (token->type == CPP_PLACEMARKER)\n      pasted = duplicate_token (pfile, second);\n   else if (second->type == CPP_PLACEMARKER)\n     {\n+      cpp_context *mac_context = CURRENT_CONTEXT (pfile) - 1;\n       /* GCC has special extended semantics for a ## b where b is a\n \t varargs parameter: a disappears if b consists of no tokens.\n \t This extension is deprecated.  */\n-      if (token->flags & GNU_VARARGS)\n+      if ((mac_context->u.list->flags & GNU_REST_ARGS)\n+\t  && (mac_context->u.list->tokens[mac_context->posn - 1].val.aux + 1\n+\t      == (unsigned) mac_context->u.list->paramc))\n \t{\n \t  cpp_warning (pfile, \"deprecated GNU ## extension used\");\n \t  pasted = duplicate_token (pfile, second);"}, {"sha": "e9bb24f8ee0b07e621f00722b942ebf4e3366fb2", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=563dd08adfa12573fdecf9669fdf685fef5fd360", "patch": "@@ -158,7 +158,6 @@ struct cpp_name\n #define STRINGIFY_ARG\t(1 << 3) /* If macro argument to be stringified.  */\n #define PASTE_LEFT\t(1 << 4) /* If on LHS of a ## operator.  */\n #define PASTED\t\t(1 << 5) /* The result of a ## operator.  */\n-#define GNU_VARARGS\t(1 << 6) /* GNU ## kludge.   */\n \n /* A preprocessing token.  This has been carefully packed and should\n    occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n@@ -181,7 +180,8 @@ struct cpp_token\n /* cpp_toklist flags.  */\n #define LIST_OFFSET     (1 << 0)\n #define VAR_ARGS\t(1 << 1)\n-#define BEG_OF_FILE\t(1 << 2)\n+#define GNU_REST_ARGS\t(1 << 2) /* Set in addition to VAR_ARGS.  */\n+#define BEG_OF_FILE\t(1 << 3)\n \n struct directive;\t\t/* These are deliberately incomplete.  */\n struct answer;"}, {"sha": "4410e2e55264ab928d1a05f7ba79ba056c4298c5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=563dd08adfa12573fdecf9669fdf685fef5fd360", "patch": "@@ -1,3 +1,7 @@\n+2000-07-08  Neil Booth  <NeilB@earthling.net>\n+\n+\t* gcc.dg/cpp/macsyntx.c: New tests.\n+\n 2000-07-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/20000707-1.c: New test."}, {"sha": "baa69d1834aba80e951f5ae2d720be3412025dc2", "filename": "gcc/testsuite/gcc.dg/cpp/macsyntx.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563dd08adfa12573fdecf9669fdf685fef5fd360/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacsyntx.c?ref=563dd08adfa12573fdecf9669fdf685fef5fd360", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+/* { dg-options -pedantic } */\n+\n+/* Tests macro syntax, for both definition and invocation, including:-\n+\n+   o Full range of macro definition semantics.\n+   o No. of arguments supplied to function-like macros.\n+   o Odd GNU rest args behaviour.\n+   o Macro arguments do not flow into the rest of the file.  */\n+\n+\n+/* Test basic macro definition syntax.  The macros are all called\n+   \"foo\" deliberately to provoke an (excess) redefinition warning in\n+   case the macros succeed in being entered in the macro hash table\n+   despite being an error.\n+\n+   Split a couple of the lines to check that the errors appear on the\n+   right line (i.e. are associated with the correct token).  */\n+\n+#define ;\t\t\t/* { dg-error \"identifier\" } */\n+#define SEMI;\t\t\t/* { dg-warning \"space\" } */\n+#define foo(X\t\t\t/* { dg-error \"missing\" } */\n+#define foo\\\n+(X,)\t\t\t\t/* { dg-error \"parameter name\" } */\n+#define foo(, X)\t\t/* { dg-error \"parameter name\" } */\n+#define foo(X, X)\t\t/* { dg-error \"duplicate\" } */\n+#define foo(X Y)\t\t/* { dg-error \"comma\" } */\n+#define foo(()\t\t\t/* { dg-error \"illegal token\" } */\n+#define foo(..., X)\t\t/* { dg-error \"missing\" } */\n+#define foo \\\n+__VA_ARGS__\t\t\t/* { dg-warning \"__VA_ARGS__\" } */\n+#define foo(__VA_ARGS__)\t/* { dg-warning \"__VA_ARGS__\" } */\n+#define foo(...) __VA_ARGS__\t/* OK.  */\n+#define __VA_ARGS__\t\t/* { dg-warning \"__VA_ARGS__\" } */\n+\n+/* test # of supplied arguments.  */\n+#define none()\n+#define one(x)\n+#define two(x, y)\n+#define var0(...)\n+#define var1(x, ...)\n+none()\t\t\t\t/* OK.  */\n+none(ichi)\t\t\t/* { dg-error \"too many\" } */\n+one()\t\t\t\t/* OK.  */\n+one(ichi)\t\t\t/* OK.  */\n+one(ichi\\\n+, ni)\t\t\t\t/* { dg-error \"too many\" } */\n+two(ichi)\t\t\t/* { dg-error \"insufficient\" } */\n+var0()\t\t\t\t/* OK.  */\n+var0(ichi)\t\t\t/* OK.  */\n+var1()\t\t\t\t/* { dg-error \"insufficient\" } */\n+var1(ichi)\t\t\t/* { dg-error \"insufficient\" } */\n+var1(ichi, ni)\t\t\t/* OK.  */\n+\n+/* This tests two deprecated oddities of GNU rest args - omitting a\n+   comma is OK, and backtracking a token on pasting an empty rest\n+   args.  */\n+#define rest(x, y...) x ## y\t/* { dg-warning \"ISO C\" } */\n+rest(ichi,)\t\t\t/* { dg-warning \"deprecated\" } */\n+rest(ichi)\t\t\t/* { dg-warning \"deprecated\" } */\n+#if 23 != rest(2, 3)\t\t/* OK, no warning.  */\n+#error 23 != 23 !!\n+#endif\n+\n+/* Test that we don't allow arguments to flow into the rest of the\n+   file.  */\n+#define half_invocation do_nowt(2\n+#define do_nowt(x) x\n+half_invocation )\t\t/* OK.  */\n+do_nowt (half_invocation))\t/* { dg-error \"unterminated invocation\" } */"}]}