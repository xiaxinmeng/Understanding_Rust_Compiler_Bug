{"sha": "aa65d1a2adda3ca65e8e4e71295074b3ad647c65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE2NWQxYTJhZGRhM2NhNjVlOGU0ZTcxMjk1MDc0YjNhZDY0N2M2NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-05-03T15:08:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-05-03T15:08:33Z"}, "message": "search.c (lookup_field_r): Set the TREE_TYPE of an ambiguous lookup to error_mark_node here.\n\n\t* search.c (lookup_field_r): Set the TREE_TYPE of an ambiguous\n\tlookup to error_mark_node here.\n\t(lookup_member): Revise documentation.  Add comments.  Don't set\n\tthe TREE_TYPE to error_mark_node here, and don't build up an extra\n\tTREE_LIST for ambiguous lookups.\n\t(setup_class_bindings): Adjust accordingly.\n\t(push_class_decls): Revise out-of-date comments.\n\nFrom-SVN: r26754", "tree": {"sha": "4f8d68559a4ca64c60ede627fb30d919f290f50c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f8d68559a4ca64c60ede627fb30d919f290f50c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa65d1a2adda3ca65e8e4e71295074b3ad647c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa65d1a2adda3ca65e8e4e71295074b3ad647c65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa65d1a2adda3ca65e8e4e71295074b3ad647c65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa65d1a2adda3ca65e8e4e71295074b3ad647c65/comments", "author": null, "committer": null, "parents": [{"sha": "2f8ec491ba5250824d0375d8b8e488c2cd689764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8ec491ba5250824d0375d8b8e488c2cd689764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8ec491ba5250824d0375d8b8e488c2cd689764"}], "stats": {"total": 74, "additions": 49, "deletions": 25}, "files": [{"sha": "4c8551746f361e13f00c0f592c730c72f7cacc9d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa65d1a2adda3ca65e8e4e71295074b3ad647c65/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa65d1a2adda3ca65e8e4e71295074b3ad647c65/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa65d1a2adda3ca65e8e4e71295074b3ad647c65", "patch": "@@ -1,5 +1,13 @@\n 1999-05-03  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* search.c (lookup_field_r): Set the TREE_TYPE of an ambiguous\n+\tlookup to error_mark_node here.\n+\t(lookup_member): Revise documentation.  Add comments.  Don't set\n+\tthe TREE_TYPE to error_mark_node here, and don't build up an extra\n+\tTREE_LIST for ambiguous lookups.\n+\t(setup_class_bindings): Adjust accordingly.\n+\t(push_class_decls): Revise out-of-date comments.\n+\t\n \t* typeck.c (build_const_cast): Tighten checks for legality.\n \n 1999-05-02  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>"}, {"sha": "33873a0a3054ae6f5d03fbab6484ecadf82dfed5", "filename": "gcc/cp/search.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa65d1a2adda3ca65e8e4e71295074b3ad647c65/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa65d1a2adda3ca65e8e4e71295074b3ad647c65/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=aa65d1a2adda3ca65e8e4e71295074b3ad647c65", "patch": "@@ -1297,14 +1297,19 @@ lookup_field_r (binfo, data)\n \t  /* We have a real ambiguity.  We keep a chain of all the\n \t     candidates.  */\n \t  if (!lfi->ambiguous && lfi->rval)\n-\t    /* This is the first time we noticed an ambiguity.  Add\n-\t       what we previously thought was a reasonable candidate\n-\t       to the list.  */\n-\t    lfi->ambiguous = scratch_tree_cons (NULL_TREE, lfi->rval,\n-\t\t\t\t\t\tNULL_TREE);\n+\t    {\n+\t      /* This is the first time we noticed an ambiguity.  Add\n+\t\t what we previously thought was a reasonable candidate\n+\t\t to the list.  */\n+\t      lfi->ambiguous = scratch_tree_cons (NULL_TREE, lfi->rval,\n+\t\t\t\t\t\t  NULL_TREE);\n+\t      TREE_TYPE (lfi->ambiguous) = error_mark_node;\n+\t    }\n+\n \t  /* Add the new value.  */\n \t  lfi->ambiguous = scratch_tree_cons (NULL_TREE, nval, \n \t\t\t\t\t      lfi->ambiguous);\n+\t  TREE_TYPE (lfi->ambiguous) = error_mark_node;\n \t  lfi->errstr = \"request for member `%D' is ambiguous\";\n \t}\n     }\n@@ -1341,8 +1346,8 @@ lookup_field_r (binfo, data)\n    XBASETYPE.  PROTECT is 0 or two, we do not check access.  If it is\n    1, we enforce accessibility.  If PROTECT is zero, then, for an\n    ambiguous lookup, we return NULL.  If PROTECT is 1, we issue an\n-   error message.  If PROTECT is two 2, we return a TREE_LIST whose\n-   TREE_PURPOSE is error_mark_node and whose TREE_VALUE is the list of\n+   error message.  If PROTECT is 2, we return a TREE_LIST whose\n+   TREEE_TYPE is error_mark_node and whose TREE_VALUEs are the list of\n    ambiguous candidates.\n \n    WANT_TYPE is 1 when we should only return TYPE_DECLs, if no\n@@ -1372,6 +1377,8 @@ lookup_member (xbasetype, name, protect, want_type)\n       tree field = IDENTIFIER_CLASS_VALUE (name);\n       if (TREE_CODE (field) != FUNCTION_DECL\n \t  && ! (want_type && TREE_CODE (field) != TYPE_DECL))\n+\t/* We're in the scope of this class, and the value has already\n+\t   been looked up.  Just return the cached value.  */\n \treturn field;\n     }\n \n@@ -1415,14 +1422,7 @@ lookup_member (xbasetype, name, protect, want_type)\n   if (protect == 2) \n     {\n       if (lfi.ambiguous)\n-\t{\n-\t  /* An ERROR_MARK for the TREE_TYPE tells hack_identifier\n-\t     that the lookup is ambiguous.  */\n-\t  TREE_TYPE (lfi.ambiguous) = error_mark_node;\n-\t  return scratch_tree_cons (error_mark_node,\n-\t\t\t\t    lfi.ambiguous,\n-\t\t\t\t    NULL_TREE);\n-\t}\n+\treturn lfi.ambiguous;\n       else\n \tprotect = 0;\n     }\n@@ -2838,9 +2838,9 @@ setup_class_bindings (name, type_binding_p)\n \t\t\t\t    /*protect=*/2,\n \t\t\t\t    /*want_type=*/1);\n       if (TREE_CODE (type_binding) == TREE_LIST \n-\t  && TREE_PURPOSE (type_binding) == error_mark_node)\n+\t  && TREE_TYPE (type_binding) == error_mark_node)\n \t/* NAME is ambiguous.  */\n-\tpush_class_level_binding (name, TREE_VALUE (type_binding));\n+\tpush_class_level_binding (name, type_binding);\n       else\n \tpushdecl_class_level (type_binding);\n     }\n@@ -2853,8 +2853,8 @@ setup_class_bindings (name, type_binding_p)\n   if (type_binding_p\n       && (TREE_CODE (value_binding) == TYPE_DECL\n \t  || (TREE_CODE (value_binding) == TREE_LIST\n-\t      && TREE_PURPOSE (value_binding) == error_mark_node\n-\t      && (TREE_CODE (TREE_VALUE (TREE_VALUE (value_binding)))\n+\t      && TREE_TYPE (value_binding) == error_mark_node\n+\t      && (TREE_CODE (TREE_VALUE (value_binding))\n \t\t  == TYPE_DECL))))\n     /* We found a type-binding, even when looking for a non-type\n        binding.  This means that we already processed this binding\n@@ -2863,12 +2863,12 @@ setup_class_bindings (name, type_binding_p)\n   else\n     {\n       if (TREE_CODE (value_binding) == TREE_LIST \n-\t  && TREE_PURPOSE (value_binding) == error_mark_node)\n+\t  && TREE_TYPE (value_binding) == error_mark_node)\n \t/* NAME is ambiguous.  */\n-\tpush_class_level_binding (name, TREE_VALUE (value_binding));\n+\tpush_class_level_binding (name, value_binding);\n       else\n \t{\n-\t  if (TREE_CODE (value_binding) == TREE_LIST)\n+\t  if (BASELINK_P (value_binding))\n \t    /* NAME is some overloaded functions.  */\n \t    value_binding = TREE_VALUE (value_binding);\n \t  pushdecl_class_level (value_binding);\n@@ -2970,11 +2970,10 @@ push_class_decls (type)\n      cache later.  */\n   maybe_push_cache_obstack ();\n \n-  /* Push class fields into CLASS_VALUE scope, and mark.  */\n+  /* Enter type declarations and mark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_push_type_decls, unmarked_pushdecls_p, 0);\n \n-  /* Compress fields which have only a single entry\n-     by a given name, and unmark.  */\n+  /* Enter non-type declarations and unmark.  */\n   dfs_walk (TYPE_BINFO (type), dfs_push_decls, marked_pushdecls_p, 0);\n \n   /* Undo the call to maybe_push_cache_obstack above.  */"}, {"sha": "4b1c5d82598eab1fc682589ed567bda920de057c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typedef4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa65d1a2adda3ca65e8e4e71295074b3ad647c65/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypedef4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa65d1a2adda3ca65e8e4e71295074b3ad647c65/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypedef4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypedef4.C?ref=aa65d1a2adda3ca65e8e4e71295074b3ad647c65", "patch": "@@ -0,0 +1,17 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct B1 {\n+  typedef int X;\n+};\n+\n+struct B2 {\n+  typedef int X;\n+};\n+\n+template <class T>\n+struct D : public B1, public B2 {\n+  typedef int X;\n+};\n+\n+template struct D<int>;"}]}