{"sha": "1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJlMGU1OGQzMDAzYWE4YTc4MGQyMjliZjM4YjBlNGE2MTkyOGI5ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-11-20T06:15:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-11-20T06:15:03Z"}, "message": "tree.c (free_lang_data_in_type): If BINFO has no important information in it, set it to NULL.\n\n\n\t* tree.c (free_lang_data_in_type): If BINFO has no important\n\tinformation in it, set it to NULL.\n\t(get_binfo_at_offset): Do not walk fields, only bases.\n\t* ipa-utils.h (polymorphic_type_binfo_p): Be ready for BINFO_TYPE\n\tto be NULL.\n\t* ipa-polymorphic-call.c (record_known_type): Likewise.\n\nFrom-SVN: r217824", "tree": {"sha": "b027bc052b062a295ed4e82de7214afde37561ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b027bc052b062a295ed4e82de7214afde37561ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/comments", "author": null, "committer": null, "parents": [{"sha": "1b5695e6100dec3f7c1e86ba5594471987cda466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5695e6100dec3f7c1e86ba5594471987cda466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b5695e6100dec3f7c1e86ba5594471987cda466"}], "stats": {"total": 37, "additions": 24, "deletions": 13}, "files": [{"sha": "be20db1d2002c4c9ff1218917145e790ea500895", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "patch": "@@ -1,3 +1,12 @@\n+2014-11-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree.c (free_lang_data_in_type): If BINFO has no important\n+\tinformation in it, set it to NULL.\n+\t(get_binfo_at_offset): Do not walk fields, only bases.\n+\t* ipa-utils.h (polymorphic_type_binfo_p): Be ready for BINFO_TYPE\n+\tto be NULL.\n+\t* ipa-polymorphic-call.c (record_known_type): Likewise.\n+\n 2014-11-19  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/63854"}, {"sha": "41d4554784d3bfa239da63880e5c6fc53add1a0e", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "patch": "@@ -1849,7 +1849,7 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n {\n   tree binfo = TYPE_BINFO (type->type);\n   unsigned int i;\n-  vec <tree> type_binfos = vNULL;\n+  auto_vec <tree, 8> type_binfos;\n   bool possibly_instantiated = type_possibly_instantiated_p (type->type);\n \n   /* We may need to consider types w/o instances because of possible derived\n@@ -1868,7 +1868,6 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n \t\t\t\tinserted, matched_vtables,\n \t\t\t\ttype->anonymous_namespace, completep);\n     }\n-  type_binfos.release ();\n   for (i = 0; i < type->derived_types.length (); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted, \n \t\t\t\t\t matched_vtables,\n@@ -2226,7 +2225,7 @@ possible_polymorphic_call_targets (tree otr_type,\n {\n   static struct cgraph_node_hook_list *node_removal_hook_holder;\n   vec <cgraph_node *> nodes = vNULL;\n-  vec <tree> bases_to_consider = vNULL;\n+  auto_vec <tree, 8> bases_to_consider;\n   odr_type type, outer_type;\n   polymorphic_call_target_d key;\n   polymorphic_call_target_d **slot;\n@@ -2521,7 +2520,6 @@ possible_polymorphic_call_targets (tree otr_type,\n \t}\n     }\n \n-  bases_to_consider.release();\n   (*slot)->targets = nodes;\n   (*slot)->complete = complete;\n   if (completep)"}, {"sha": "249f0d7286f6d2266dfc982f719ca5c2dfe760df", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "patch": "@@ -1307,6 +1307,7 @@ record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset\n   if (type\n       && (offset\n           || (TREE_CODE (type) != RECORD_TYPE\n+\t      || !TYPE_BINFO (type)\n \t      || !polymorphic_type_binfo_p (TYPE_BINFO (type)))))\n     {\n       ipa_polymorphic_call_context context;"}, {"sha": "12c6edbc3a7df5b05c9cf27306a47de9e2a71135", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "patch": "@@ -183,7 +183,8 @@ polymorphic_type_binfo_p (const_tree binfo)\n   /* See if BINFO's type has an virtual table associtated with it.\n      Check is defensive because of Java FE produces BINFOs\n      without BINFO_TYPE set.   */\n-  return BINFO_TYPE (binfo) && BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (binfo)));\n+  return (BINFO_TYPE (binfo) && TYPE_BINFO (BINFO_TYPE (binfo))\n+\t  && BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (binfo))));\n }\n #endif  /* GCC_IPA_UTILS_H  */\n "}, {"sha": "6abe4c31b0fe4506034043e2e70e89b2d7af9108", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be0e58d3003aa8a780d229bf38b0e4a61928b9e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1be0e58d3003aa8a780d229bf38b0e4a61928b9e", "patch": "@@ -4976,7 +4976,14 @@ free_lang_data_in_type (tree type)\n \n       TYPE_METHODS (type) = NULL_TREE;\n       if (TYPE_BINFO (type))\n-\tfree_lang_data_in_binfo (TYPE_BINFO (type));\n+\t{\n+\t  free_lang_data_in_binfo (TYPE_BINFO (type));\n+\t  if ((!BINFO_VTABLE (TYPE_BINFO (type))\n+\t       || !flag_devirtualize)\n+\t      && (!BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n+\t\t  || debug_info_level != DINFO_LEVEL_NONE))\n+\t    TYPE_BINFO (type) = NULL;\n+\t}\n     }\n   else\n     {\n@@ -11926,7 +11933,7 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n \n       for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n \t{\n-\t  if (TREE_CODE (fld) != FIELD_DECL)\n+\t  if (TREE_CODE (fld) != FIELD_DECL || !DECL_ARTIFICIAL (fld))\n \t    continue;\n \n \t  pos = int_bit_position (fld);\n@@ -11937,12 +11944,6 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n       if (!fld || TREE_CODE (TREE_TYPE (fld)) != RECORD_TYPE)\n \treturn NULL_TREE;\n \n-      if (!DECL_ARTIFICIAL (fld))\n-\t{\n-\t  binfo = TYPE_BINFO (TREE_TYPE (fld));\n-\t  if (!binfo)\n-\t    return NULL_TREE;\n-\t}\n       /* Offset 0 indicates the primary base, whose vtable contents are\n \t represented in the binfo for the derived class.  */\n       else if (offset != 0)\n@@ -11967,6 +11968,7 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n \t\t      * BITS_PER_UNIT < pos\n \t\t      /* Rule out types with no virtual methods or we can get confused\n \t\t\t here by zero sized bases.  */\n+\t\t      && TYPE_BINFO (BINFO_TYPE (base_binfo))\n \t\t      && BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (base_binfo)))\n \t\t      && (!containing_binfo\n \t\t\t  || (tree_to_shwi (BINFO_OFFSET (containing_binfo))"}]}