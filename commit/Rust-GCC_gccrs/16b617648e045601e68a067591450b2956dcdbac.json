{"sha": "16b617648e045601e68a067591450b2956dcdbac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZiNjE3NjQ4ZTA0NTYwMWU2OGEwNjc1OTE0NTBiMjk1NmRjZGJhYw==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2002-01-01T22:15:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2002-01-01T22:15:20Z"}, "message": "vms.h (DWARF2_UNWIND_INFO, [...]): Define.\n\n\t* config/alpha/vms.h (DWARF2_UNWIND_INFO, EH_RETURN_HANDLER_RTX,\n\tLINK_EH_SPEC, MD_FALLBACK_FRAME_STATE_FOR): Define.\n\t* config/alpha/t-vms (EXTRA_PARTS): Add vms-dwarf2eh.o\n\t(vms-dwarf2eh.o): Add Makefile rule.\n\t* config/alpha/vms-ld.c (main): Handle vms-dwarf2eh.o.\n\t* config/alpha/vms-dwarf2eh.asm: New file.\n\nFrom-SVN: r48451", "tree": {"sha": "7edfad896dcb77dcbd8b2cf89f3f0d0d296332df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7edfad896dcb77dcbd8b2cf89f3f0d0d296332df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16b617648e045601e68a067591450b2956dcdbac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b617648e045601e68a067591450b2956dcdbac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b617648e045601e68a067591450b2956dcdbac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b617648e045601e68a067591450b2956dcdbac/comments", "author": null, "committer": null, "parents": [{"sha": "f01c9bcdd8644f1272ac18f793d04cafde1e7860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01c9bcdd8644f1272ac18f793d04cafde1e7860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f01c9bcdd8644f1272ac18f793d04cafde1e7860"}], "stats": {"total": 525, "additions": 518, "deletions": 7}, "files": [{"sha": "dfc09c8ea44553d6b8ade16df42e32386079fb09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b617648e045601e68a067591450b2956dcdbac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b617648e045601e68a067591450b2956dcdbac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16b617648e045601e68a067591450b2956dcdbac", "patch": "@@ -1,5 +1,12 @@\n 2002-01-01  Douglas B Rupp  <rupp@gnat.com>\n \n+\t* config/alpha/vms.h (DWARF2_UNWIND_INFO, EH_RETURN_HANDLER_RTX,\n+\tLINK_EH_SPEC, MD_FALLBACK_FRAME_STATE_FOR): Define.\n+\t* config/alpha/t-vms (EXTRA_PARTS): Add vms-dwarf2eh.o\n+\t(vms-dwarf2eh.o): Add Makefile rule.\n+\t* config/alpha/vms-ld.c (main): Handle vms-dwarf2eh.o.\n+\t* config/alpha/vms-dwarf2eh.asm: New file.\n+\n \t* gcc.c (delete_if_ordinary): Delete all versions.\n \n 2002-01-01  Hans-Peter Nilsson  <hp@bitrange.com>"}, {"sha": "5057c317a6b2d05a21328976124cc6dc15e9c4ab", "filename": "gcc/config/alpha/t-vms", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Ft-vms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Ft-vms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-vms?ref=16b617648e045601e68a067591450b2956dcdbac", "patch": "@@ -3,12 +3,15 @@ LIB2FUNCS_EXTRA = $(srcdir)/config/alpha/vms_tramp.asm\n # VMS_EXTRA_PARTS is defined in x-vms and represent object files that\n # are only needed for VMS targets, but can only be compiled on a VMS host\n # (because they need DEC C).\n-EXTRA_PARTS = vms-dwarf2.o $(VMS_EXTRA_PARTS)\n+EXTRA_PARTS = vms-dwarf2.o vms-dwarf2eh.o $(VMS_EXTRA_PARTS)\n \n # This object must be linked with in order to make the executable debuggable.\n # vms-ld handles it automatically when passed -g.\n vms-dwarf2.o : $(srcdir)/config/alpha/vms-dwarf2.asm\n-\tgcc -c -x assembler $<\n+\tgcc -c -x assembler $< -o $@\n+\n+vms-dwarf2eh.o : $(srcdir)/config/alpha/vms-dwarf2eh.asm\n+\tgcc -c -x assembler $< -o $@\n \n # Assemble startup files.\n vcrt0.o: $(CRT0_S) $(GCC_PASSES)"}, {"sha": "22f7050351154d61d6dff5f98d12cfb33a4b4ba7", "filename": "gcc/config/alpha/vms-dwarf2eh.asm", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Fvms-dwarf2eh.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Fvms-dwarf2eh.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-dwarf2eh.asm?ref=16b617648e045601e68a067591450b2956dcdbac", "patch": "@@ -0,0 +1,37 @@\n+/* VMS dwarf2 exception handling section sequentializer.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Contributed by Douglas B. Rupp (rupp@gnat.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Linking with this file forces the Dwarf2 EH section to be\n+   individually loaded by the VMS linker an the unwinder to read it.  */\n+\n+.section\t.eh_frame,NOWRT\n+\t\t.align 0\n+\t\t.global __EH_FRAME_BEGIN__\n+__EH_FRAME_BEGIN__:"}, {"sha": "83ceaf9b031c5cf1057c59155896f3e5800f43fa", "filename": "gcc/config/alpha/vms-ld.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-ld.c?ref=16b617648e045601e68a067591450b2956dcdbac", "patch": "@@ -1,5 +1,6 @@\n /* VMS linker wrapper.\n-   Copyright (C) 1996-2001 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002\n+   Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (rupp@gnat.com).\n \n This file is part of GNU CC.\n@@ -38,6 +39,9 @@ typedef struct dsc {unsigned short len, mbz; char *adr; } Descr;\n /* File specification for vms-dwarf2.o.  */\n static char *vmsdwarf2spec = 0;\n \n+/* File specification for vms-dwarf2eh.o.  */\n+static char *vmsdwarf2ehspec = 0;\n+\n /* verbose = 1 if -v passed.   */\n static int verbose = 0;\n \n@@ -589,8 +593,11 @@ main (argc, argv)\n \n \t  buff_len = strlen (buff);\n \n-\t  if (buff_len >= 13\n-\t      && strcasecmp (&buff[buff_len-13],\"vms-dwarf2.o\\n\") == 0)\n+\t  if (buff_len >= 15\n+\t      && strcasecmp (&buff[buff_len - 15], \"vms-dwarf2eh.o\\n\") == 0)\n+\t    vmsdwarf2ehspec = xstrdup (buff);\n+\t  else if (buff_len >= 13\n+\t      && strcasecmp (&buff[buff_len - 13],\"vms-dwarf2.o\\n\") == 0)\n \t    vmsdwarf2spec = xstrdup (buff);\n \t  else if (is_cld)\n \t    {\n@@ -607,14 +614,22 @@ main (argc, argv)\n     fprintf (optfile, \"symbol_vector=(main=procedure)\\n\");\n #endif\n \n+  if (vmsdwarf2ehspec)\n+    {\n+      fprintf (optfile, \"case_sensitive=yes\\n\");\n+      fprintf (optfile, \"cluster=DWARF2eh,,,%s\", vmsdwarf2ehspec);\n+      fprintf (optfile, \"collect=DWARF2eh,eh_frame\\n\");\n+      fprintf (optfile, \"case_sensitive=NO\\n\");\n+    }\n+\n   if (debug && vmsdwarf2spec)\n     {\n       fprintf (optfile, \"case_sensitive=yes\\n\");\n       fprintf (optfile, \"cluster=DWARF2debug,,,%s\", vmsdwarf2spec);\n       fprintf (optfile, \"collect=DWARF2debug,debug_abbrev,debug_aranges,-\\n\");\n       fprintf (optfile, \" debug_frame,debug_info,debug_line,debug_loc,-\\n\");\n-      fprintf (optfile,\n-\t       \" debug_macinfo,debug_pubnames,debug_str,debug_zzzzzz\\n\");\n+      fprintf (optfile, \" debug_macinfo,debug_pubnames,debug_str,-\\n\");\n+      fprintf (optfile, \" debug_zzzzzz\\n\");\n       fprintf (optfile, \"case_sensitive=NO\\n\");\n     }\n "}, {"sha": "ca3474829c9ce4335570e3c7d5bb7b0ccc81a845", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b617648e045601e68a067591450b2956dcdbac/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=16b617648e045601e68a067591450b2956dcdbac", "patch": "@@ -1,3 +1,401 @@\n+/* Output variables, constants and external declarations, for GNU compiler.\n+   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define TARGET_OBJECT_SUFFIX \".obj\"\n+#define TARGET_EXECUTABLE_SUFFIX \".exe\"\n+\n+/* This enables certain macros in alpha.h, which will make an indirect\n+   reference to an external symbol an invalid address.  This needs to be\n+   defined before we include alpha.h, since it determines which macros\n+   are used for GO_IF_*.  */\n+\n+#define NO_EXTERNAL_INDIRECT_ADDRESS\n+\n+#include \"alpha/alpha.h\"\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+\"-D__ALPHA -Dvms -DVMS -D__vms__ -D__VMS__ -Asystem=vms\"\n+\n+#undef CPP_SUBTARGET_SPEC\n+#define CPP_SUBTARGET_SPEC \"\\\n+%{mfloat-ieee:-D__IEEE_FLOAT} \\\n+%{mfloat-vax:-D__G_FLOAT} \\\n+%{!mfloat-vax:-D__IEEE_FLOAT}\"\n+\n+/* By default, allow $ to be part of an identifier.  */\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_FP|MASK_FPREGS|MASK_GAS)\n+#undef TARGET_ABI_OPEN_VMS\n+#define TARGET_ABI_OPEN_VMS 1\n+\n+#undef TARGET_NAME   \n+#define TARGET_NAME \"OpenVMS/Alpha\"\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (%s)\", TARGET_NAME);           \n+\n+/* The structure return address arrives as an \"argument\" on VMS.  */\n+#undef STRUCT_VALUE_REGNUM\n+#define STRUCT_VALUE 0\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+/* \"long\" is 32 bits, but 64 bits for Ada.  */\n+#undef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE 32\n+#define ADA_LONG_TYPE_SIZE 64\n+\n+/* Pointer is 32 bits but the hardware has 64-bit addresses, sign extended.  */\n+#undef POINTER_SIZE\n+#define POINTER_SIZE 32\n+#define POINTERS_EXTEND_UNSIGNED 0\n+\n+#define MAX_OFILE_ALIGNMENT 524288  /* 8 x 2^16 by DEC Ada Test CD40VRA */\n+\n+#undef FIXED_REGISTERS\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }\n+\n+#undef CALL_USED_REGISTERS\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   We allocate in the following order:\n+   $f1\t\t\t(nonsaved floating-point register)\n+   $f10-$f15\t\t(likewise)\n+   $f22-$f30\t\t(likewise)\n+   $f21-$f16\t\t(likewise, but input args)\n+   $f0\t\t\t(nonsaved, but return value)\n+   $f2-$f9\t\t(saved floating-point registers)\n+   $1\t\t\t(nonsaved integer registers)\n+   $22-$25\t\t(likewise)\n+   $28\t\t\t(likewise)\n+   $0\t\t\t(likewise, but return value)\n+   $21-$16\t\t(likewise, but input args)\n+   $27\t\t\t(procedure value in OSF, nonsaved in NT)\n+   $2-$8\t\t(saved integer registers)\n+   $9-$14\t\t(saved integer registers)\n+   $26\t\t\t(return PC)\n+   $15\t\t\t(frame pointer)\n+   $29\t\t\t(global pointer)\n+   $30, $31, $f31\t(stack pointer and always zero/ap & fp)  */\n+\n+#undef REG_ALLOC_ORDER\n+#define REG_ALLOC_ORDER\t\t\\\n+  {33,\t\t\t\t\t\\\n+   42, 43, 44, 45, 46, 47,\t\t\\\n+   54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n+   53, 52, 51, 50, 49, 48,\t\t\\\n+   32,\t\t\t\t\t\\\n+   34, 35, 36, 37, 38, 39, 40, 41,\t\\\n+   1,\t\t\t\t\t\\\n+   22, 23, 24, 25,\t\t\t\\\n+   28,\t\t\t\t\t\\\n+   0,\t\t\t\t\t\\\n+   21, 20, 19, 18, 17, 16,\t\t\\\n+   27,\t\t\t\t\t\\\n+   2, 3, 4, 5, 6, 7, 8,\t\t\t\\\n+   9, 10, 11, 12, 13, 14,\t\t\\\n+   26,\t\t\t\t\t\\\n+   15,\t\t\t\t\t\\\n+   29,\t\t\t\t\t\\\n+   30, 31, 63 }\n+\n+#undef HARD_FRAME_POINTER_REGNUM\n+#define HARD_FRAME_POINTER_REGNUM 29\n+\n+/* Define registers used by the epilogue and return instruction.  */\n+#undef EPILOGUE_USES\n+#define EPILOGUE_USES(REGNO)    ((REGNO) == 26 || (REGNO) == 29)\n+\n+#undef CAN_ELIMINATE\n+#define CAN_ELIMINATE(FROM, TO)  \\\n+((TO) != STACK_POINTER_REGNUM || ! alpha_using_fp ())\n+\n+#undef INITIAL_ELIMINATION_OFFSET\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{ if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+    (OFFSET) = alpha_sa_size () + alpha_pv_save_size ();\t\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n+    (OFFSET) = (ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ()\t\\\n+\t\t\t     + get_frame_size ()\t\t\t\\\n+\t\t\t     + current_function_pretend_args_size)\t\\\n+\t\t- current_function_pretend_args_size);\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    abort();\t\t\t\t\t\t\t\t\\\n+  if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n+    (OFFSET) += ALPHA_ROUND (current_function_outgoing_args_size);\t\\\n+}\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On Alpha/VMS, this is a structure that contains the number of\n+   arguments and, for each argument, the datatype of that argument.\n+\n+   The number of arguments is a number of words of arguments scanned so far.\n+   Thus 6 or more means all following args should go on the stack.  */\n+\n+enum avms_arg_type {I64, FF, FD, FG, FS, FT};\n+typedef struct {int num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n+\n+#undef CUMULATIVE_ARGS\n+#define CUMULATIVE_ARGS avms_arg_info\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#undef INIT_CUMULATIVE_ARGS\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n+  (CUM).num_args = 0;\t\t\t\t\t\t\\\n+  (CUM).atypes[0] = (CUM).atypes[1] = (CUM).atypes[2] = I64;\t\\\n+  (CUM).atypes[3] = (CUM).atypes[4] = (CUM).atypes[5] = I64;\n+\n+#undef FUNCTION_ARG_ADVANCE\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\t\\\n+    (CUM).num_args += 6;\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((CUM).num_args < 6)\t\t\t\t\t\t\\\n+        (CUM).atypes[(CUM).num_args] = alpha_arg_type (MODE);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+     (CUM).num_args += ALPHA_ARG_SIZE (MODE, TYPE, NAMED);\t\t\\\n+    }\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#undef FUNCTION_ARG_PARTIAL_NREGS\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n+((CUM).num_args < 6 && 6 < (CUM).num_args\t\t\t\t\\\n+   + ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\t\t\t\t\t\\\n+ ? 6 - (CUM).num_args : 0)\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as for INIT_CUMULATIVE_ARGS.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed. \n+\n+   For VMS, we allocate space for all 6 arg registers plus a count.\n+\n+   However, if NO registers need to be saved, don't allocate any space.\n+   This is not only because we won't need the space, but because AP includes\n+   the current_pretend_args_size and we don't want to mess up any\n+   ap-relative addresses already made.  */\n+\n+#undef SETUP_INCOMING_VARARGS\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{ if ((CUM).num_args < 6)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (! (NO_RTL))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  emit_move_insn (gen_rtx_REG (DImode, 1),\t\\\n+\t\t\t  virtual_incoming_args_rtx);\t\\\n+\t  emit_insn (gen_arg_home ());\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t        \\\n+      PRETEND_SIZE = 7 * UNITS_PER_WORD;\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* ABI has stack checking, but it's broken.  */\n+#undef STACK_CHECK_BUILTIN\n+#define STACK_CHECK_BUILTIN 0\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  alpha_write_verstamp (FILE);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set noreorder\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set volatile\\n\");\t\t\t\t\\\n+  ASM_OUTPUT_SOURCE_FILENAME (FILE, main_input_filename);\t\\\n+}\n+\n+#define LINK_SECTION_ASM_OP \"\\t.link\"\n+#define READONLY_SECTION_ASM_OP \"\\t.rdata\"\n+#define LITERALS_SECTION_ASM_OP \"\\t.literals\"\n+#define CTORS_SECTION_ASM_OP \"\\t.ctors\"\n+#define DTORS_SECTION_ASM_OP \"\\t.dtors\"\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS\tin_link, in_rdata, in_literals\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+readonly_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rdata)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", READONLY_SECTION_ASM_OP);\t\\\n+      in_section = in_rdata;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+link_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_link)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", LINK_SECTION_ASM_OP); \t\\\n+      in_section = in_link;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}                                                               \\\n+void\t\t\t\t\t\t\t\t\\\n+literals_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_literals)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", LITERALS_SECTION_ASM_OP); \t\\\n+      in_section = in_literals;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+extern void readonly_section\tPARAMS ((void));\n+extern void link_section\tPARAMS ((void));\n+extern void literals_section\tPARAMS ((void));\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) abort ()\n+\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  fprintf (FILE, \"\\t.quad $L%d\\n\", (VALUE))\n+\n+#undef READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION readonly_section\n+\n+#define ASM_FILE_END(FILE) alpha_write_linkage (FILE);\n+\n+#undef CASE_VECTOR_MODE\n+#define CASE_VECTOR_MODE DImode\n+#undef CASE_VECTOR_PC_RELATIVE\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+{ ASM_OUTPUT_ALIGN (FILE, 3); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n+\n+/* This says how to output assembler code to declare an                \n+   uninitialized external linkage data object.  */ \n+\n+#define COMMON_ASM_OP \"\\t.comm\\t\"\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"%s\", COMMON_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+} while (0)\n+\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.  \n+   Note that $27 has been set to the address of the trampoline, so we can\n+   use it for addressability of the two data items.  */\n+\n+#undef TRAMPOLINE_TEMPLATE\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n+{\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.quad 0\\n\");\t\t\\\n+  fprintf (FILE, \"\\t.linkage __tramp\\n\");\t\\\n+  fprintf (FILE, \"\\t.quad 0\\n\");\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#undef TRAMPOLINE_SIZE\n+#define TRAMPOLINE_SIZE    32\n+\n+/* The alignment of a trampoline, in bits.  */\n+\n+#undef TRAMPOLINE_ALIGNMENT\n+#define TRAMPOLINE_ALIGNMENT  64\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#undef INITIALIZE_TRAMPOLINE\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+  alpha_initialize_trampoline (TRAMP, FNADDR, CXT, 16, 24, -1)\n+\n+/* Control how constructors and destructors are emitted.  */\n+#define TARGET_ASM_CONSTRUCTOR  vms_asm_out_constructor\n+#define TARGET_ASM_DESTRUCTOR   vms_asm_out_destructor\n+\n+#undef SDB_DEBUGGING_INFO\n+#undef MIPS_DEBUGGING_INFO\n+#undef DBX_DEBUGGING_INFO\n+\n+#define DWARF2_DEBUGGING_INFO\n+#define VMS_DEBUGGING_INFO\n+\n+#define DWARF2_UNWIND_INFO 1\n+\n+#undef EH_RETURN_HANDLER_RTX\n+#define EH_RETURN_HANDLER_RTX \\\n+  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, 8))\n+\n+#define LINK_EH_SPEC \"vms-dwarf2eh.o%s\"\n+\n+#ifdef IN_LIBGCC2\n+#include <libicb.h>\n+#include <pdscdef.h>\n+#endif\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+ do {\t\t\t\t\t\t\t\t\t\\\n+  unsigned long handle;\t\t\t\t\t\t\t\\\n+  PDSCDEF *pv;\t\t\t\t\t\t\t\t\\\n+  INVO_CONTEXT_BLK invo;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  memset (&invo, 0, sizeof INVO_CONTEXT_BLK);\t\t\t\t\\\n /* Output variables, constants and external declarations, for GNU compiler.\n    Copyright (C) 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.\n \n@@ -375,6 +773,57 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define DWARF2_DEBUGGING_INFO\n #define VMS_DEBUGGING_INFO\n \n+#define DWARF2_UNWIND_INFO 1\n+\n+#undef EH_RETURN_HANDLER_RTX\n+#define EH_RETURN_HANDLER_RTX \\\n+  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, 8))\n+\n+#define LINK_EH_SPEC \"vms-dwarf2eh.o%s\"\n+\n+#ifdef IN_LIBGCC2\n+#include <libicb.h>\n+#include <pdscdef.h>\n+#endif\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+ do {\t\t\t\t\t\t\t\t\t\\\n+  unsigned long handle;\t\t\t\t\t\t\t\\\n+  PDSCDEF *pv;\t\t\t\t\t\t\t\t\\\n+  INVO_CONTEXT_BLK invo;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  invo.libicb$q_ireg [29] = *((long long *) (CONTEXT)->reg [29]);\t\\\n+  invo.libicb$q_ireg [30] = (long long) (CONTEXT)->cfa\t\t\t\\\n+  handle = LIB$GET_INVO_HANDLE (&invo);\t\t\t\t\t\\\n+  LIB$GET_INVO_CONTEXT (handle, &invo);\t\t\t\t\t\\\n+  pv = (PDSCDEF *) invo.libicb$ph_procedure_descriptor;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (pv && ((pv->pdsc$w_flags & 0xf) == PDSC$K_KIND_FP_STACK))\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int i, j;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      (FS)->cfa_offset = pv->pdsc$l_size;\t\t\t\t\\\n+      (FS)->cfg_reg = pv->pdsc$w_flags & PDSC$M_BASE_REG_IS_FP ? 29 : 30; \\\n+      (FS)->retaddr_column = 26;\t\t\t\t\t\\\n+      (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n+      (FS)->regs.reg[27].loc.offset = -pv->pdsc$l_size;\t\t\t\\\n+      (FS)->regs.reg[27].how = REG_SAVED_OFFSET;\t\t\t\\\n+      (FS)->regs.reg[26].loc.offset\t\t\t\t\t\\\n+\t = pv->pdsc$w_rsa_offset - pv->pdsc$l_size);\t\t\t\\\n+      (FS)->regs.reg[26].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (i = 0, j = 0; i < 32; i++)\t\t\t\t\t\\\n+\tif (1<<i & pv->pdsc$l_ireg_mask)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    (FS)->regs.reg[i].loc.offset\t\t\t\t\\\n+\t      = pv->pdsc$l_size - pv->pdsc$w_rsa_offset - 8 * j++;\t\\\n+\t    (FS)->regs.reg[i].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      goto SUCCESS;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n /* This is how to output an assembler line\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */"}]}