{"sha": "6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA1N2MwZTYwMmIzNWNlYTgzMThkNTExZWY2ZTlmYjJiNmMwZjk4Yw==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-08-25T10:12:10Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-08-25T10:12:10Z"}, "message": "loop.c (loop_dump_aux, debug_loop): New functions.\n\n\t* loop.c (loop_dump_aux, debug_loop): New functions.\n\t(LOOP_BLOCK_NUM_1, LOOP_BLOCK_NUM, LOOP_INSN_UID): New macros.\n\n\t* flow.c (flow_loops_dump): Add callback parameter.\n\t(flow_loop_dump): Add callback parameter and call it.  Move\n\tloop note debugging code to loop_dump_aux.\n\n\t* basic-block.h (flow_loop_dump): Add callback parameter\n\t(flow_loops_dump): Likewise.\n\n\t* toplev.c (rest_of_compilation): Add NULL callback function pointer\n\tto call to flow_loops_dump.\n\nFrom-SVN: r35979", "tree": {"sha": "da7c48d1f368cda84269244c1fbc8a0384c561ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da7c48d1f368cda84269244c1fbc8a0384c561ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/comments", "author": null, "committer": null, "parents": [{"sha": "028fc6e76056429c0f6e3c28d45a558ed2c961d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028fc6e76056429c0f6e3c28d45a558ed2c961d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028fc6e76056429c0f6e3c28d45a558ed2c961d4"}], "stats": {"total": 188, "additions": 155, "deletions": 33}, "files": [{"sha": "a48284ea4e8990994df8f1a30ddf6d884092de17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "patch": "@@ -1,3 +1,18 @@\n+2000-08-26  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* loop.c (loop_dump_aux, debug_loop): New functions.\n+\t(LOOP_BLOCK_NUM_1, LOOP_BLOCK_NUM, LOOP_INSN_UID): New macros.\n+\n+\t* flow.c (flow_loops_dump): Add callback parameter.\n+\t(flow_loop_dump): Add callback parameter and call it.  Move\n+\tloop note debugging code to loop_dump_aux.\n+\n+\t* basic-block.h (flow_loop_dump): Add callback parameter\n+\t(flow_loops_dump): Likewise.\n+\n+\t* toplev.c (rest_of_compilation): Add NULL callback function pointer\n+\tto call to flow_loops_dump.\n+\t\n 2000-08-26  Michael Hayes  <mhayes@cygnus.com>\n \n \t* loop.c (count_loop_regs_set): Replace start and end arguments"}, {"sha": "a6533245a8f30daeb404fce590413a850952d239", "filename": "gcc/basic-block.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "patch": "@@ -398,8 +398,12 @@ struct loops\n \n extern int flow_loops_find PARAMS ((struct loops *));\n extern void flow_loops_free PARAMS ((struct loops *));\n-extern void flow_loops_dump PARAMS ((const struct loops *, FILE *, int));\n-\n+extern void flow_loops_dump PARAMS ((const struct loops *, FILE *,\n+\t\t\t\t     void (*)(const struct loop *,\n+\t\t\t\t\t      FILE *, int), int));\n+extern void flow_loop_dump PARAMS ((const struct loop *, FILE *,\n+\t\t\t\t    void (*)(const struct loop *,\n+\t\t\t\t\t     FILE *, int), int));\n \n /* This structure maintains an edge list vector.  */\n struct edge_list "}, {"sha": "4e7e756486c0264a6d58f0d49d9932c9c9eef288", "filename": "gcc/flow.c", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "patch": "@@ -7199,12 +7199,49 @@ flow_loop_nested_p (outer, loop)\n   return sbitmap_a_subset_b_p (loop->nodes, outer->nodes);\n }\n \n-/* Dump the loop information specified by LOOPS to the stream FILE.  */\n \n+/* Dump the loop information specified by LOOP to the stream FILE\n+   using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n void\n-flow_loops_dump (loops, file, verbose)\n+flow_loop_dump (loop, file, loop_dump_aux, verbose)\n+     const struct loop *loop;\n+     FILE *file;\n+     void (*loop_dump_aux)(const struct loop *, FILE *, int);\n+     int verbose;\n+{\n+  if (! loop || ! loop->header)\n+    return;\n+\n+  fprintf (file, \";;\\n;; Loop %d (%d to %d):%s%s\\n\",\n+\t   loop->num, INSN_UID (loop->first->head),\n+\t   INSN_UID (loop->last->end),\n+\t   loop->shared ? \" shared\" : \"\",\n+\t   loop->invalid ? \" invalid\" : \"\");\n+  fprintf (file, \";;  header %d, latch %d, pre-header %d, first %d, last %d\\n\",\n+\t   loop->header->index, loop->latch->index,\n+\t   loop->pre_header ? loop->pre_header->index : -1,\n+\t   loop->first->index, loop->last->index);\n+  fprintf (file, \";;  depth %d, level %d, outer %ld\\n\",\n+\t   loop->depth, loop->level,\n+\t   (long) (loop->outer ? loop->outer->num : -1));\n+\n+  fprintf (file, \";;  %d\", loop->num_nodes);\n+  flow_nodes_print (\" nodes\", loop->nodes, file);\n+  fprintf (file, \";;  %d\", loop->num_exits);\n+  flow_exits_print (\" exits\", loop->exits, loop->num_exits, file);\n+\n+  if (loop_dump_aux)\n+    loop_dump_aux (loop, file, verbose);\n+}\n+\n+\n+/* Dump the loop information specified by LOOPS to the stream FILE,\n+   using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n+void \n+flow_loops_dump (loops, file, loop_dump_aux, verbose)\n      const struct loops *loops;\n      FILE *file;\n+     void (*loop_dump_aux)(const struct loop *, FILE *, int);\n      int verbose;\n {\n   int i;\n@@ -7214,23 +7251,14 @@ flow_loops_dump (loops, file, verbose)\n   if (! num_loops || ! file)\n     return;\n \n-  fprintf (file, \";; %d loops found, %d levels\\n\",\n+  fprintf (file, \";; %d loops found, %d levels\\n\", \n \t   num_loops, loops->levels);\n \n   for (i = 0; i < num_loops; i++)\n     {\n       struct loop *loop = &loops->array[i];\n \n-      fprintf (file, \";; loop %d (%d to %d):\\n;;   header %d, latch %d, pre-header %d, depth %d, level %d, outer %ld\\n\",\n-\t       i, INSN_UID (loop->header->head), INSN_UID (loop->latch->end),\n-\t       loop->header->index, loop->latch->index,\n-\t       loop->pre_header ? loop->pre_header->index : -1,\n-\t       loop->depth, loop->level,\n-\t       (long) (loop->outer ? (loop->outer - loops->array) : -1));\n-      fprintf (file, \";;   %d\", loop->num_nodes);\n-      flow_nodes_print (\" nodes\", loop->nodes, file);\n-      fprintf (file, \";;   %d\", loop->num_exits);\n-      flow_exits_print (\" exits\", loop->exits, loop->num_exits, file);\n+      flow_loop_dump (loop, file, loop_dump_aux, verbose);\n \n       if (loop->shared)\n \t{\n@@ -7252,35 +7280,20 @@ flow_loops_dump (loops, file, verbose)\n \t\t     must be disjoint.  */\n \t\t  disjoint = ! flow_loop_nested_p (smaller ? loop : oloop,\n \t\t\t\t\t\t   smaller ? oloop : loop);\n-\t\t  fprintf (file,\n+\t\t  fprintf (file, \n \t\t\t   \";; loop header %d shared by loops %d, %d %s\\n\",\n \t\t\t   loop->header->index, i, j,\n \t\t\t   disjoint ? \"disjoint\" : \"nested\");\n \t\t}\n \t    }\n \t}\n-\n-      if (verbose)\n-\t{\n-\t  /* Print diagnostics to compare our concept of a loop with\n-\t     what the loop notes say.  */\n-\t  if (GET_CODE (PREV_INSN (loop->first->head)) != NOTE\n-\t      || NOTE_LINE_NUMBER (PREV_INSN (loop->first->head))\n-\t      != NOTE_INSN_LOOP_BEG)\n-\t    fprintf (file, \";; No NOTE_INSN_LOOP_BEG at %d\\n\",\n-\t\t     INSN_UID (PREV_INSN (loop->first->head)));\n-\t  if (GET_CODE (NEXT_INSN (loop->last->end)) != NOTE\n-\t      || NOTE_LINE_NUMBER (NEXT_INSN (loop->last->end))\n-\t      != NOTE_INSN_LOOP_END)\n-\t    fprintf (file, \";; No NOTE_INSN_LOOP_END at %d\\n\",\n-\t\t     INSN_UID (NEXT_INSN (loop->last->end)));\n-\t}\n     }\n \n   if (verbose)\n     flow_loops_cfg_dump (loops, file);\n }\n \n+\n /* Free all the memory allocated for LOOPS.  */\n \n void\n@@ -7316,6 +7329,7 @@ flow_loops_free (loops)\n     }\n }\n \n+\n /* Find the exits from the loop using the bitmap of loop nodes NODES\n    and store in EXITS array.  Return the number of exits from the\n    loop.  */"}, {"sha": "4400cbf40e9a10cdddac8e6a8692cd67aeeea85d", "filename": "gcc/loop.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "patch": "@@ -313,6 +313,9 @@ static int replace_label PARAMS ((rtx *, void *));\n static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n \n+static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n+void debug_loop PARAMS ((const struct loop *));\n+\n typedef struct rtx_and_int {\n   rtx r;\n   int i;\n@@ -9953,3 +9956,89 @@ replace_label (x, data)\n \n   return 0;\n }\n+\f\n+#define LOOP_BLOCK_NUM_1(INSN) \\\n+((INSN) ? (BLOCK_FOR_INSN (INSN) ? BLOCK_NUM (INSN) : - 1) : -1)\n+\n+/* The notes do not have an assigned block, so look at the next insn.  */\n+#define LOOP_BLOCK_NUM(INSN) \\\n+((INSN) ? (GET_CODE (INSN) == NOTE \\\n+            ? LOOP_BLOCK_NUM_1 (next_nonnote_insn (INSN)) \\\n+            : LOOP_BLOCK_NUM_1 (INSN)) \\\n+        : -1)\n+\n+#define LOOP_INSN_UID(INSN) ((INSN) ? INSN_UID (INSN) : -1)\n+\n+static void loop_dump_aux (loop, file, verbose)\n+     const struct loop *loop;\n+     FILE *file;\n+     int verbose;\n+{\n+  rtx label;\n+\n+  if (! loop || ! file)\n+    return;\n+\n+  /* Print diagnostics to compare our concept of a loop with\n+     what the loop notes say.  */\n+  if (! PREV_INSN (loop->first->head)\n+      || GET_CODE (PREV_INSN (loop->first->head)) != NOTE\n+      || NOTE_LINE_NUMBER (PREV_INSN (loop->first->head))\n+      != NOTE_INSN_LOOP_BEG)\n+    fprintf (file, \";;  No NOTE_INSN_LOOP_BEG at %d\\n\", \n+\t     INSN_UID (PREV_INSN (loop->first->head)));\n+  if (! NEXT_INSN (loop->last->end)\n+      || GET_CODE (NEXT_INSN (loop->last->end)) != NOTE\n+      || NOTE_LINE_NUMBER (NEXT_INSN (loop->last->end))\n+      != NOTE_INSN_LOOP_END)\n+    fprintf (file, \";;  No NOTE_INSN_LOOP_END at %d\\n\",\n+\t     INSN_UID (NEXT_INSN (loop->last->end)));\n+\n+  if (loop->start)\n+    {\n+      fprintf (file,\n+\t       \";;  start %d (%d), cont dom %d (%d), cont %d (%d), vtop %d (%d), end %d (%d)\\n\",\n+\t       LOOP_BLOCK_NUM (loop->start),\n+\t       LOOP_INSN_UID (loop->start),\n+\t       LOOP_BLOCK_NUM (loop->cont),\n+\t       LOOP_INSN_UID (loop->cont),\n+\t       LOOP_BLOCK_NUM (loop->cont),\n+\t       LOOP_INSN_UID (loop->cont),\n+\t       LOOP_BLOCK_NUM (loop->vtop),\n+\t       LOOP_INSN_UID (loop->vtop),\n+\t       LOOP_BLOCK_NUM (loop->end),\n+\t       LOOP_INSN_UID (loop->end));\n+      fprintf (file, \";;  top %d (%d), scan start %d (%d)\\n\",\n+\t       LOOP_BLOCK_NUM (loop->top),\n+\t       LOOP_INSN_UID (loop->top) ,\n+\t       LOOP_BLOCK_NUM (loop->scan_start),\n+\t       LOOP_INSN_UID (loop->scan_start));\n+      fprintf (file, \";;  exit_count %d\", loop->exit_count);\n+      if (loop->exit_count)\n+\t{\n+\t  fputs (\", labels:\", file);\n+\t  for (label = loop->exit_labels; label; label = LABEL_NEXTREF (label))\n+\t    {\n+\t      fprintf (file, \" %d \",\n+\t\t       LOOP_INSN_UID (XEXP (label, 0)));\n+\t    }\n+\t}\n+      fputs (\"\\n\", file);\n+      \n+      /* This can happen when a marked loop appears as two nested loops,\n+\t say from while (a || b) {}.  The inner loop won't match\n+\t the loop markers but the outer one will.  */\n+      if (LOOP_BLOCK_NUM (loop->cont) != loop->latch->index)\n+\tfprintf (file, \";;  NOTE_INSN_LOOP_CONT not in loop latch\\n\");\n+    }\n+}\n+  \n+\n+/* Call this function from the debugger to dump LOOP.  */\n+\n+void\n+debug_loop (loop)\n+     const struct loop *loop;\n+{\n+  flow_loop_dump (loop, stderr, loop_dump_aux, 1);\n+}"}, {"sha": "e0f606fe5b4c13dc134f61515e54b432d310344f", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6057c0e602b35cea8318d511ef6e9fb2b6c0f98c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6057c0e602b35cea8318d511ef6e9fb2b6c0f98c", "patch": "@@ -3165,7 +3165,7 @@ rest_of_compilation (decl)\n       estimate_probability (&loops);\n \n       if (rtl_dump_file)\n-\tflow_loops_dump (&loops, rtl_dump_file, 0);\n+\tflow_loops_dump (&loops, rtl_dump_file, NULL, 0);\n \n       flow_loops_free (&loops);\n     }"}]}