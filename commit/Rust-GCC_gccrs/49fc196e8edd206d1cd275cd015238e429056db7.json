{"sha": "49fc196e8edd206d1cd275cd015238e429056db7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlmYzE5NmU4ZWRkMjA2ZDFjZDI3NWNkMDE1MjM4ZTQyOTA1NmRiNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-04-24T22:01:53Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-04-24T22:01:53Z"}, "message": "struct-layout-1_generate.c: In arrays avoid types where sizeof (type) < __alignof__ (type).\n\n\t* gcc.dg/compat/struct-layout-1_generate.c: In arrays avoid types\n\twhere sizeof (type) < __alignof__ (type).\n\t* gcc.dg/compat/struct-layout-1.h: Likewise.\n\nFrom-SVN: r98673", "tree": {"sha": "f96c05c3708b7cc058f1f01f8a6132be40246190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f96c05c3708b7cc058f1f01f8a6132be40246190"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49fc196e8edd206d1cd275cd015238e429056db7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49fc196e8edd206d1cd275cd015238e429056db7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49fc196e8edd206d1cd275cd015238e429056db7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49fc196e8edd206d1cd275cd015238e429056db7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5919150114c386c1ca290351d8b686c05b103392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5919150114c386c1ca290351d8b686c05b103392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5919150114c386c1ca290351d8b686c05b103392"}], "stats": {"total": 397, "additions": 388, "deletions": 9}, "files": [{"sha": "79373868287d548a081f92b067061168b1087bd1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fc196e8edd206d1cd275cd015238e429056db7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fc196e8edd206d1cd275cd015238e429056db7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=49fc196e8edd206d1cd275cd015238e429056db7", "patch": "@@ -1,3 +1,9 @@\n+2005-04-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/compat/struct-layout-1_generate.c: In arrays avoid types\n+\twhere sizeof (type) < __alignof__ (type).\n+\t* gcc.dg/compat/struct-layout-1.h: Likewise.\n+\n 2005-04-24  Per Bothner  <per@bothner.com>\n \t    Devang Patel  <dpatel@apple.com>\n "}, {"sha": "e165e203a32609a6ac4f7682912f02712216fb91", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1.h", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fc196e8edd206d1cd275cd015238e429056db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fc196e8edd206d1cd275cd015238e429056db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1.h?ref=49fc196e8edd206d1cd275cd015238e429056db7", "patch": "@@ -101,6 +101,64 @@ extern int fn5 (void), fn6 (void), fn7 (void), fn8 (void), fn9 (void);\n #define atpaal8\t\t__attribute__((packed, aligned (8)))\n #define atpaal16\t__attribute__((packed, aligned (16)))\n \n+#if UCHAR_MAX == 255 && USHORT_MAX == 65535 && UINT_MAX == 4294967295U \\\n+    && ULLONG_MAX == 18446744073709551615ULL\n+/* For ILP32 and LP64 targets, assume float is at least 32-bit\n+   and double plus long double at least 64-bit.  */\n+# define atalx1\t\tatal1\n+# define atalx2\t\tatal2\n+# define atalx4\t\tatal4\n+# define atalx8\t\tatal8\n+# define atalx16\tatal16\n+# define atalx1pa\tatal1pa\n+# define atalx2pa\tatal2pa\n+# define atalx4pa\tatal4pa\n+# define atalx8pa\tatal8pa\n+# define atalx16pa\tatal16pa\n+# define atpaalx1\tatpaal1\n+# define atpaalx2\tatpaal2\n+# define atpaalx4\tatpaal4\n+# define atpaalx8\tatpaal8\n+# define atpaalx16\tatpaal16\n+# if ULONG_MAX > 4294967295UL\n+#  define ataly8\tatal8\n+#  define ataly8pa\tatal8pa\n+#  define atpaaly8\tatpaal8\n+#  define ataly16\tatal16\n+#  define ataly16pa\tatal16pa\n+#  define atpaaly16\tatpaal16\n+# else\n+#  define ataly8\n+#  define ataly8pa\n+#  define atpaaly8\n+#  define ataly16\n+#  define ataly16pa\n+#  define atpaaly16\n+# endif\n+#else\n+# define atalx1\n+# define atalx2\n+# define atalx4\n+# define atalx8\n+# define atalx16\n+# define atalx1pa\n+# define atalx2pa\n+# define atalx4pa\n+# define atalx8pa\n+# define atalx16pa\n+# define atpaalx1\n+# define atpaalx2\n+# define atpaalx4\n+# define atpaalx8\n+# define atpaalx16\n+# define ataly8\n+# define ataly8pa\n+# define atpaaly8\n+# define ataly16\n+# define ataly16pa\n+# define atpaaly16\n+#endif\n+\n #define atQI\t\t__attribute__((mode (QI)))\n #define atHI\t\t__attribute__((mode (HI)))\n #define atSI\t\t__attribute__((mode (SI)))\n@@ -427,6 +485,153 @@ typedef enum E9 Tal16E9 atal16;\n typedef void *Tal16ptr atal16;\n typedef char *Tal16cptr atal16;\n typedef int *Tal16iptr atal16;\n+typedef char Talx1char atalx1;\n+typedef signed char Talx1schar atalx1;\n+typedef unsigned char Talx1uchar atalx1;\n+typedef short int Talx1short atalx1;\n+typedef unsigned short int Talx1ushort atalx1;\n+typedef int Talx1int atalx1;\n+typedef unsigned int Talx1uint atalx1;\n+typedef long int Talx1long atalx1;\n+typedef unsigned long int Talx1ulong atalx1;\n+typedef long long int Talx1llong atalx1;\n+typedef unsigned long long int Talx1ullong atalx1;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Talx1cchar atalx1;\n+typedef _Complex signed char Talx1cschar atalx1;\n+typedef _Complex unsigned char Talx1cuchar atalx1;\n+typedef _Complex short int Talx1cshort atalx1;\n+typedef _Complex unsigned short int Talx1cushort atalx1;\n+typedef _Complex int Talx1cint atalx1;\n+typedef _Complex unsigned int Talx1cuint atalx1;\n+typedef _Complex long int Talx1clong atalx1;\n+typedef _Complex unsigned long int Talx1culong atalx1;\n+typedef _Complex long long int Talx1cllong atalx1;\n+typedef _Complex unsigned long long int Talx1cullong atalx1;\n+#endif\n+typedef float Talx1float atalx1;\n+typedef double Talx1double atalx1;\n+typedef long double Talx1ldouble atalx1;\n+typedef _Complex float Talx1cfloat atalx1;\n+typedef _Complex double Talx1cdouble atalx1;\n+typedef _Complex long double Talx1cldouble atalx1;\n+typedef bool Talx1bool atalx1;\n+typedef enum E0 Talx1E0 atalx1;\n+typedef enum E1 Talx1E1 atalx1;\n+typedef enum E2 Talx1E2 atalx1;\n+typedef enum E3 Talx1E3 atalx1;\n+typedef enum E4 Talx1E4 atalx1;\n+typedef enum E5 Talx1E5 atalx1;\n+typedef enum E6 Talx1E6 atalx1;\n+typedef enum E7 Talx1E7 atalx1;\n+typedef enum E8 Talx1E8 atalx1;\n+typedef enum E9 Talx1E9 atalx1;\n+typedef void *Talx1ptr atalx1;\n+typedef char *Talx1cptr atalx1;\n+typedef int *Talx1iptr atalx1;\n+typedef short int Talx2short atalx2;\n+typedef unsigned short int Talx2ushort atalx2;\n+typedef int Talx2int atalx2;\n+typedef unsigned int Talx2uint atalx2;\n+typedef long int Talx2long atalx2;\n+typedef unsigned long int Talx2ulong atalx2;\n+typedef long long int Talx2llong atalx2;\n+typedef unsigned long long int Talx2ullong atalx2;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Talx2cchar atalx2;\n+typedef _Complex signed char Talx2cschar atalx2;\n+typedef _Complex unsigned char Talx2cuchar atalx2;\n+typedef _Complex short int Talx2cshort atalx2;\n+typedef _Complex unsigned short int Talx2cushort atalx2;\n+typedef _Complex int Talx2cint atalx2;\n+typedef _Complex unsigned int Talx2cuint atalx2;\n+typedef _Complex long int Talx2clong atalx2;\n+typedef _Complex unsigned long int Talx2culong atalx2;\n+typedef _Complex long long int Talx2cllong atalx2;\n+typedef _Complex unsigned long long int Talx2cullong atalx2;\n+#endif\n+typedef float Talx2float atalx2;\n+typedef double Talx2double atalx2;\n+typedef long double Talx2ldouble atalx2;\n+typedef _Complex float Talx2cfloat atalx2;\n+typedef _Complex double Talx2cdouble atalx2;\n+typedef _Complex long double Talx2cldouble atalx2;\n+typedef enum E0 Talx2E0 atalx2;\n+typedef enum E1 Talx2E1 atalx2;\n+typedef enum E2 Talx2E2 atalx2;\n+typedef enum E3 Talx2E3 atalx2;\n+typedef enum E4 Talx2E4 atalx2;\n+typedef enum E5 Talx2E5 atalx2;\n+typedef enum E6 Talx2E6 atalx2;\n+typedef enum E7 Talx2E7 atalx2;\n+typedef enum E8 Talx2E8 atalx2;\n+typedef enum E9 Talx2E9 atalx2;\n+typedef void *Talx2ptr atalx2;\n+typedef char *Talx2cptr atalx2;\n+typedef int *Talx2iptr atalx2;\n+typedef int Talx4int atalx4;\n+typedef unsigned int Talx4uint atalx4;\n+typedef long int Talx4long atalx4;\n+typedef unsigned long int Talx4ulong atalx4;\n+typedef long long int Talx4llong atalx4;\n+typedef unsigned long long int Talx4ullong atalx4;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex short int Talx4cshort atalx4;\n+typedef _Complex unsigned short int Talx4cushort atalx4;\n+typedef _Complex int Talx4cint atalx4;\n+typedef _Complex unsigned int Talx4cuint atalx4;\n+typedef _Complex long int Talx4clong atalx4;\n+typedef _Complex unsigned long int Talx4culong atalx4;\n+typedef _Complex long long int Talx4cllong atalx4;\n+typedef _Complex unsigned long long int Talx4cullong atalx4;\n+#endif\n+typedef float Talx4float atalx4;\n+typedef double Talx4double atalx4;\n+typedef long double Talx4ldouble atalx4;\n+typedef _Complex float Talx4cfloat atalx4;\n+typedef _Complex double Talx4cdouble atalx4;\n+typedef _Complex long double Talx4cldouble atalx4;\n+typedef enum E0 Talx4E0 atalx4;\n+typedef enum E1 Talx4E1 atalx4;\n+typedef enum E2 Talx4E2 atalx4;\n+typedef enum E3 Talx4E3 atalx4;\n+typedef enum E4 Talx4E4 atalx4;\n+typedef enum E5 Talx4E5 atalx4;\n+typedef enum E6 Talx4E6 atalx4;\n+typedef enum E7 Talx4E7 atalx4;\n+typedef enum E8 Talx4E8 atalx4;\n+typedef enum E9 Talx4E9 atalx4;\n+typedef void *Talx4ptr atalx4;\n+typedef char *Talx4cptr atalx4;\n+typedef int *Talx4iptr atalx4;\n+typedef long int Taly8long ataly8;\n+typedef unsigned long int Taly8ulong ataly8;\n+typedef long long int Talx8llong atalx8;\n+typedef unsigned long long int Talx8ullong atalx8;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex int Talx8cint atalx8;\n+typedef _Complex unsigned int Talx8cuint atalx8;\n+typedef _Complex long int Talx8clong atalx8;\n+typedef _Complex unsigned long int Talx8culong atalx8;\n+typedef _Complex long long int Talx8cllong atalx8;\n+typedef _Complex unsigned long long int Talx8cullong atalx8;\n+#endif\n+typedef double Talx8double atalx8;\n+typedef long double Talx8ldouble atalx8;\n+typedef _Complex float Talx8cfloat atalx8;\n+typedef _Complex double Talx8cdouble atalx8;\n+typedef _Complex long double Talx8cldouble atalx8;\n+typedef void *Taly8ptr ataly8;\n+typedef char *Taly8cptr ataly8;\n+typedef int *Taly8iptr ataly8;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex long int Taly16clong ataly16;\n+typedef _Complex unsigned long int Taly16culong ataly16;\n+typedef _Complex long long int Talx16cllong atalx16;\n+typedef _Complex unsigned long long int Talx16cullong atalx16;\n+#endif\n+typedef _Complex double Talx16cdouble atalx16;\n+typedef _Complex long double Talx16cldouble atalx16;\n typedef int (*Tfnptr) (void);\n \n /* Bitfield macros.  In C, it is invalid to use numbers larger"}, {"sha": "192d7c2ef9bdd50657c4dbdf6157598ed6ad767c", "filename": "gcc/testsuite/gcc.dg/compat/struct-layout-1_generate.c", "status": "modified", "additions": 177, "deletions": 9, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fc196e8edd206d1cd275cd015238e429056db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fc196e8edd206d1cd275cd015238e429056db7/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=49fc196e8edd206d1cd275cd015238e429056db7", "patch": "@@ -1,5 +1,5 @@\n /* Structure layout test generator.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n This file is part of GCC.\n@@ -459,6 +459,149 @@ struct types complex_attrib_types[] = {\n { \"Tal16cldouble\", TYPE_CFLOAT, 0, 0 }\n #define NCATYPES2 (sizeof (complex_attrib_types) / sizeof (complex_attrib_types[0]))\n };\n+struct types attrib_array_types[] = {\n+{ \"Talx1char\", TYPE_UINT, 127, 'C' },\n+{ \"Talx1schar\", TYPE_INT, 127, 'C' },\n+{ \"Talx1uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Talx1short\", TYPE_INT, 32767, 'S' },\n+{ \"Talx1ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talx1int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx1uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx1long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx1ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx1llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx1ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx1bool\", TYPE_UINT, 1, 'B' },\n+{ \"Talx1ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx1E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx1E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx1E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx1E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx1E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx1E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx1E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx1E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx1E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Talx2short\", TYPE_INT, 32767, 'S' },\n+{ \"Talx2ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talx2int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx2uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx2long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx2ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx2llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx2ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx2ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx2E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx2E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx2E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx2E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx2E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx2E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx2E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx2E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx2E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Talx4int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx4uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx4long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx4ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx4llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx4ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx4ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx4E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx4E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx4E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx4E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx4E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx4E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx4E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx4E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx4E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Taly8long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Taly8ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx8llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx8ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Taly8ptr\", TYPE_PTR, 0, 0 },\n+{ \"Taly8cptr\", TYPE_PTR, 0, 0 },\n+{ \"Taly8iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx8double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx8ldouble\", TYPE_FLOAT, 0, 0 }\n+#define NAATYPES2 (sizeof (attrib_array_types) / sizeof (attrib_array_types[0]))\n+};\n+struct types complex_attrib_array_types[] = {\n+{ \"Talx1cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Talx1cschar\", TYPE_CINT, 127, 0 },\n+{ \"Talx1cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Talx1cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talx1cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talx1cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx1cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx1clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx1culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx1cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx1cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx1cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx1cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx1cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx2cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Talx2cschar\", TYPE_CINT, 127, 0 },\n+{ \"Talx2cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Talx2cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talx2cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talx2cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx2cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx2clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx2culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx2cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx2cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx2cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx2cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx2cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx4cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talx4cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talx4cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx4cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx4clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx4culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx4cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx4cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx4cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx4cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx4cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx8cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx8cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx8clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx8culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx8cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx8cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx8cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx8cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx8cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Taly16clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Taly16culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx16cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx16cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx16cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx16cldouble\", TYPE_CFLOAT, 0, 0 }\n+#define NCAATYPES2 (sizeof (complex_attrib_array_types) / sizeof (complex_attrib_array_types[0]))\n+};\n \n struct types bitfld_types[NTYPES2];\n int n_bitfld_types;\n@@ -1153,7 +1296,7 @@ singles (enum FEATURE features)\n }\n \n void\n-choose_type (enum FEATURE features, struct entry *e, int r)\n+choose_type (enum FEATURE features, struct entry *e, int r, int in_array)\n {\n   int i;\n \n@@ -1164,9 +1307,18 @@ choose_type (enum FEATURE features, struct entry *e, int r)\n     i += NVTYPES2;\n   if ((r & 3) == 0)\n     {\n-      i += NATYPES2;\n-      if (features & FEATURE_COMPLEX)\n-        i += NCATYPES2;\n+      if (in_array)\n+\t{\n+\t  i += NAATYPES2;\n+\t  if (features & FEATURE_COMPLEX)\n+\t    i += NCAATYPES2;\n+\t}\n+      else\n+\t{\n+\t  i += NATYPES2;\n+\t  if (features & FEATURE_COMPLEX)\n+\t    i += NCATYPES2;\n+\t}\n     }\n   r >>= 2;\n   r %= i;\n@@ -1185,18 +1337,30 @@ choose_type (enum FEATURE features, struct entry *e, int r)\n \te->type = &vector_types[r];\n       r -= NVTYPES2;\n     }\n-  if (e->type == NULL)\n+  if (e->type == NULL && !in_array)\n     {\n       if (r < NATYPES2)\n \te->type = &attrib_types[r];\n       r -= NATYPES2;\n     }\n-  if (e->type == NULL && (features & FEATURE_COMPLEX))\n+  if (e->type == NULL && !in_array && (features & FEATURE_COMPLEX))\n     {\n       if (r < NCATYPES2)\n \te->type = &complex_attrib_types[r];\n       r -= NCATYPES2;\n     }\n+  if (e->type == NULL && in_array)\n+    {\n+      if (r < NAATYPES2)\n+\te->type = &attrib_array_types[r];\n+      r -= NAATYPES2;\n+    }\n+  if (e->type == NULL && in_array && (features & FEATURE_COMPLEX))\n+    {\n+      if (r < NCAATYPES2)\n+\te->type = &complex_attrib_array_types[r];\n+      r -= NCAATYPES2;\n+    }\n   if (e->type == NULL)\n     abort ();\n }\n@@ -1243,7 +1407,7 @@ generate_fields (enum FEATURE features, struct entry *e, struct entry *parent,\n \t  break;\n \tcase 4:\n \t  e[n].etype = ETYPE_TYPE;\n-\t  choose_type (features, &e[n], r);\n+\t  choose_type (features, &e[n], r, 0);\n \t  break;\n \tcase 5:\n \t  e[n].etype = ETYPE_ARRAY;\n@@ -1252,7 +1416,7 @@ generate_fields (enum FEATURE features, struct entry *e, struct entry *parent,\n \t  if (i)\n \t    e[n].type = &base_types[r % NTYPES1];\n \t  else\n-\t    choose_type (features, &e[n], r);\n+\t    choose_type (features, &e[n], r, 1);\n \t  r = generate_random ();\n \t  if ((features & FEATURE_ZEROARRAY) && (r & 3) == 0)\n \t    {\n@@ -1425,6 +1589,10 @@ generate_fields (enum FEATURE features, struct entry *e, struct entry *parent,\n \t\t   && e[n].type < &attrib_types[NATYPES2])\n \t\t  || (e[n].type >= &complex_attrib_types[0]\n \t\t      && e[n].type < &complex_attrib_types[NCATYPES2])\n+\t\t  || (e[n].type >= &attrib_array_types[0]\n+\t\t      && e[n].type < &attrib_array_types[NAATYPES2])\n+\t\t  || (e[n].type >= &complex_attrib_array_types[0]\n+\t\t      && e[n].type < &complex_attrib_array_types[NAATYPES2])\n \t\t  || (e[n].type >= &aligned_bitfld_types[0]\n \t\t      && e[n].type < &aligned_bitfld_types[n_aligned_bitfld_types])))\n \t    e[n].attrib = NULL;"}]}