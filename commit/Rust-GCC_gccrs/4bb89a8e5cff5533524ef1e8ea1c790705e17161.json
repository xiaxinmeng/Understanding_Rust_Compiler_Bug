{"sha": "4bb89a8e5cff5533524ef1e8ea1c790705e17161", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiODlhOGU1Y2ZmNTUzMzUyNGVmMWU4ZWExYzc5MDcwNWUxNzE2MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-06-18T17:36:27Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-06-18T17:36:27Z"}, "message": "deal with block move input reg also being a scratch reg.\n\nFrom-SVN: r4691", "tree": {"sha": "cbe9bdb38b147a2836b41689481da875bdf2a7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbe9bdb38b147a2836b41689481da875bdf2a7e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bb89a8e5cff5533524ef1e8ea1c790705e17161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb89a8e5cff5533524ef1e8ea1c790705e17161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bb89a8e5cff5533524ef1e8ea1c790705e17161", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb89a8e5cff5533524ef1e8ea1c790705e17161/comments", "author": null, "committer": null, "parents": [{"sha": "aa8642c95d23e9a1c048b995f398ca38c4ddf1c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa8642c95d23e9a1c048b995f398ca38c4ddf1c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa8642c95d23e9a1c048b995f398ca38c4ddf1c5"}], "stats": {"total": 30, "additions": 21, "deletions": 9}, "files": [{"sha": "20b7a6b62f08cde75c497fb2526c90cad9bea0f1", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb89a8e5cff5533524ef1e8ea1c790705e17161/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb89a8e5cff5533524ef1e8ea1c790705e17161/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4bb89a8e5cff5533524ef1e8ea1c790705e17161", "patch": "@@ -2201,6 +2201,7 @@ output_block_move (insn, operands, num_regs, move_type)\n   int offset\t\t= 0;\n   int use_lwl_lwr\t= FALSE;\n   int last_operand\t= num_regs+4;\n+  int safe_regs\t\t= 4;\n   int i;\n   rtx xoperands[10];\n \n@@ -2215,20 +2216,31 @@ output_block_move (insn, operands, num_regs, move_type)\n   } load_store[4];\n \n   /* Detect a bug in GCC, where it can give us a register\n-     the same as one of the addressing registers.  */\n-  for (i = 4; i < last_operand; i++)\n+     the same as one of the addressing registers and reduce\n+     the number of registers available.  */\n+  for (i = 4;\n+       i < last_operand && safe_regs < (sizeof(xoperands) / sizeof(xoperands[0]));\n+       i++)\n     {\n-      if (reg_mentioned_p (operands[i], operands[0])\n-\t  || reg_mentioned_p (operands[i], operands[1]))\n-\t{\n-\t  abort_with_insn (insn, \"register passed as address and temp register to block move\");\n-\t}\n+      if (!reg_mentioned_p (operands[i], operands[0])\n+\t  && !reg_mentioned_p (operands[i], operands[1]))\n+\n+\txoperands[safe_regs++] = operands[i];\n+    }\n+\n+  if (safe_regs < last_operand)\n+    {\n+      xoperands[0] = operands[0];\n+      xoperands[1] = operands[1];\n+      xoperands[2] = operands[2];\n+      xoperands[3] = operands[3];\n+      return output_block_move (insn, xoperands, safe_regs-4, move_type);\n     }\n \n   /* If we are given global or static addresses, and we would be\n      emitting a few instructions, try to save time by using a\n      temporary register for the pointer.  */\n-  if (bytes > 2*align || move_type != BLOCK_MOVE_NORMAL)\n+  if (num_regs > 2 && (bytes > 2*align || move_type != BLOCK_MOVE_NORMAL))\n     {\n       if (CONSTANT_P (src_reg))\n \t{\n@@ -2263,7 +2275,7 @@ output_block_move (insn, operands, num_regs, move_type)\n     num_regs = (sizeof (load_store) / sizeof (load_store[0]));\n \n   else if (num_regs < 1)\n-    abort ();\n+    abort_with_insn (insn, \"Cannot do block move, not enough scratch registers\");\n \n   if (TARGET_GAS && move_type != BLOCK_MOVE_LAST && set_noreorder++ == 0)\n     output_asm_insn (\".set\\tnoreorder\", operands);"}]}