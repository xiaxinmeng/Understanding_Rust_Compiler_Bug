{"sha": "4911b24d71955b757fdaac29b878ae33c32f3e0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkxMWIyNGQ3MTk1NWI3NTdmZGFhYzI5Yjg3OGFlMzNjMzJmM2UwYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-09-12T18:50:08Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-09-12T18:50:08Z"}, "message": "C++: special-case single non-viable candidate (more PR c++/85110)\n\nI broke out the \"no viable candidates\" case in build_new_method_call_1\ninto a subroutine, and added special-case handling for when there's\na single non-viable candidate where there's an argument conversion\nerror.  I turned the error-handling from convert_for_assignment into\na subroutine, calling it from this new special-case.\n\nThis converts:\n\ndemo.cc: In function 'int test_4(int, const char*, float)':\ndemo.cc:5:44: error: no matching function for call to 's4::member_1(int&, const char*&, float&)'\n5 |   return s4::member_1 (first, second, third);\n  |                                            ^\ndemo.cc:1:24: note: candidate: 'static int s4::member_1(int, const char**, float)'\n1 | struct s4 { static int member_1 (int one, const char **two, float three); };\n  |                        ^~~~~~~~\ndemo.cc:1:56: note:   no known conversion for argument 2 from 'const char*' to 'const char**'\n1 | struct s4 { static int member_1 (int one, const char **two, float three); };\n  |                                           ~~~~~~~~~~~~~^~~\n\nto:\n\ndemo.cc: In function 'int test_4(int, const char*, float)':\ndemo.cc:5:31: error: cannot convert 'const char*' to 'const char**'\n5 |   return s4::member_1 (first, second, third);\n  |                               ^~~~~~\n  |                               |\n  |                               const char*\ndemo.cc:1:56: note:   initializing argument 2 of 'static int s4::member_1(int, const char**, float)'\n1 | struct s4 { static int member_1 (int one, const char **two, float three); };\n  |                                           ~~~~~~~~~~~~~^~~\n\nthus highlighting the problematic argument at the callsite (and its type).\n\ngcc/cp/ChangeLog:\n\tPR c++/85110\n\t* call.c (struct conversion_info): Add \"loc\" field.\n\t(arg_conversion_rejection): Add \"loc\" param, using it to\n\tinitialize the new field.\n\t(bad_arg_conversion_rejection): Likewise.\n\t(explicit_conversion_rejection): Initialize the new field to\n\tUNKNOWN_LOCATION.\n\t(template_conversion_rejection): Likewise.\n\t(add_function_candidate): Pass on the argument location to the new\n\tparam of arg_conversion_rejection.\n\t(add_conv_candidate): Likewise.\n\t(build_builtin_candidate): Likewise.\n\t(build_user_type_conversion_1): Likewise.\n\t(single_z_candidate): New function.\n\t(maybe_get_bad_conversion_for_unmatched_call): New function.\n\t(complain_about_bad_argument): New function, based on part of\n\tconvert_for_assignment.\n\t(build_new_method_call_1): Split out handling of the \"no viable\n\tcandidates\" case into...\n\t(complain_about_no_candidates_for_method_call): ...this new\n\tfunction, and use the new functions above to special-case the\n\thandling of a single non-viable candidate due to a bad argument.\n\t* cp-tree.h (complain_about_bad_argument): New decl.\n\t* typeck.c (convert_for_assignment): Split out one error-handling\n\tcase into complain_about_bad_argument.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/85110\n\t* g++.dg/cpp0x/explicit4.C: Update expected output to reflect\n\tspecial-casing of diagnostic for a single non-viable candidate due\n\tto a bad argument.\n\t* g++.dg/diagnostic/param-type-mismatch-2.C: Likewise.\n\tAdd test coverage for an unmatched overloaded operator.\n\t* g++.dg/expr/pmf-1.C: Likewise.\n\t* g++.old-deja/g++.bugs/900330_02.C: Likewise.\n\t* g++.old-deja/g++.jason/conversion11.C: Likewise.\n\t* g++.old-deja/g++.law/arg11.C: Likewise.\n\t* g++.old-deja/g++.law/arm9.C: Likewise.\n\t* g++.old-deja/g++.robertl/eb131.C: Likewise.\n\nFrom-SVN: r264250", "tree": {"sha": "4e4772fd56335a5477fd9d79405d21633523558c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e4772fd56335a5477fd9d79405d21633523558c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4911b24d71955b757fdaac29b878ae33c32f3e0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4911b24d71955b757fdaac29b878ae33c32f3e0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4911b24d71955b757fdaac29b878ae33c32f3e0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4911b24d71955b757fdaac29b878ae33c32f3e0b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b582f1f3b7e19f050a219117e0d1af0e9a76af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b582f1f3b7e19f050a219117e0d1af0e9a76af4"}], "stats": {"total": 366, "additions": 263, "deletions": 103}, "files": [{"sha": "9201d67c0ab79022adcaf6c1bbb2bb7b127ffd4b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -1,3 +1,31 @@\n+2018-09-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/85110\n+\t* call.c (struct conversion_info): Add \"loc\" field.\n+\t(arg_conversion_rejection): Add \"loc\" param, using it to\n+\tinitialize the new field.\n+\t(bad_arg_conversion_rejection): Likewise.\n+\t(explicit_conversion_rejection): Initialize the new field to\n+\tUNKNOWN_LOCATION.\n+\t(template_conversion_rejection): Likewise.\n+\t(add_function_candidate): Pass on the argument location to the new\n+\tparam of arg_conversion_rejection.\n+\t(add_conv_candidate): Likewise.\n+\t(build_builtin_candidate): Likewise.\n+\t(build_user_type_conversion_1): Likewise.\n+\t(single_z_candidate): New function.\n+\t(maybe_get_bad_conversion_for_unmatched_call): New function.\n+\t(complain_about_bad_argument): New function, based on part of\n+\tconvert_for_assignment.\n+\t(build_new_method_call_1): Split out handling of the \"no viable\n+\tcandidates\" case into...\n+\t(complain_about_no_candidates_for_method_call): ...this new\n+\tfunction, and use the new functions above to special-case the\n+\thandling of a single non-viable candidate due to a bad argument.\n+\t* cp-tree.h (complain_about_bad_argument): New decl.\n+\t* typeck.c (convert_for_assignment): Split out one error-handling\n+\tcase into complain_about_bad_argument.\n+\n 2018-09-09  Cesar Philippidis  <cesar@codesourcery.com>\n             Julian Brown  <julian@codesourcery.com>\n "}, {"sha": "69503ca7920ad9b92866da57f898afddbcd20650", "filename": "gcc/cp/call.c", "status": "modified", "additions": 154, "deletions": 38, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -436,6 +436,8 @@ struct conversion_info {\n   tree from;\n   /* The type of the parameter.  */\n   tree to_type;\n+  /* The location of the argument.  */\n+  location_t loc;\n };\n   \n struct rejection_reason {\n@@ -627,24 +629,28 @@ arity_rejection (tree first_arg, int expected, int actual)\n }\n \n static struct rejection_reason *\n-arg_conversion_rejection (tree first_arg, int n_arg, tree from, tree to)\n+arg_conversion_rejection (tree first_arg, int n_arg, tree from, tree to,\n+\t\t\t  location_t loc)\n {\n   struct rejection_reason *r = alloc_rejection (rr_arg_conversion);\n   int adjust = first_arg != NULL_TREE;\n   r->u.conversion.n_arg = n_arg - adjust;\n   r->u.conversion.from = from;\n   r->u.conversion.to_type = to;\n+  r->u.conversion.loc = loc;\n   return r;\n }\n \n static struct rejection_reason *\n-bad_arg_conversion_rejection (tree first_arg, int n_arg, tree from, tree to)\n+bad_arg_conversion_rejection (tree first_arg, int n_arg, tree from, tree to,\n+\t\t\t      location_t loc)\n {\n   struct rejection_reason *r = alloc_rejection (rr_bad_arg_conversion);\n   int adjust = first_arg != NULL_TREE;\n   r->u.bad_conversion.n_arg = n_arg - adjust;\n   r->u.bad_conversion.from = from;\n   r->u.bad_conversion.to_type = to;\n+  r->u.bad_conversion.loc = loc;\n   return r;\n }\n \n@@ -655,6 +661,7 @@ explicit_conversion_rejection (tree from, tree to)\n   r->u.conversion.n_arg = 0;\n   r->u.conversion.from = from;\n   r->u.conversion.to_type = to;\n+  r->u.conversion.loc = UNKNOWN_LOCATION;\n   return r;\n }\n \n@@ -665,6 +672,7 @@ template_conversion_rejection (tree from, tree to)\n   r->u.conversion.n_arg = 0;\n   r->u.conversion.from = from;\n   r->u.conversion.to_type = to;\n+  r->u.conversion.loc = UNKNOWN_LOCATION;\n   return r;\n }\n \n@@ -2257,14 +2265,17 @@ add_function_candidate (struct z_candidate **candidates,\n       if (! t)\n \t{\n \t  viable = 0;\n-\t  reason = arg_conversion_rejection (first_arg, i, argtype, to_type);\n+\t  reason = arg_conversion_rejection (first_arg, i, argtype, to_type,\n+\t\t\t\t\t     EXPR_LOCATION (arg));\n \t  break;\n \t}\n \n       if (t->bad_p)\n \t{\n \t  viable = -1;\n-\t  reason = bad_arg_conversion_rejection (first_arg, i, arg, to_type);\n+\t  reason = bad_arg_conversion_rejection (first_arg, i, arg, to_type,\n+\t\t\t\t\t\t EXPR_LOCATION (arg));\n+\n \t}\n     }\n \n@@ -2353,7 +2364,8 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n       if (t->bad_p)\n \t{\n \t  viable = -1;\n-\t  reason = bad_arg_conversion_rejection (NULL_TREE, i, arg, convert_type);\n+\t  reason = bad_arg_conversion_rejection (NULL_TREE, i, arg, convert_type,\n+\t\t\t\t\t\t EXPR_LOCATION (arg));\n \t}\n \n       if (i == 0)\n@@ -2414,13 +2426,14 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \t  /* We need something for printing the candidate.  */\n \t  t = build_identity_conv (types[i], NULL_TREE);\n \t  reason = arg_conversion_rejection (NULL_TREE, i, argtypes[i],\n-\t\t\t\t\t     types[i]);\n+\t\t\t\t\t     types[i], EXPR_LOCATION (args[i]));\n \t}\n       else if (t->bad_p)\n \t{\n \t  viable = 0;\n \t  reason = bad_arg_conversion_rejection (NULL_TREE, i, args[i],\n-\t\t\t\t\t\t types[i]);\n+\t\t\t\t\t\t types[i],\n+\t\t\t\t\t\t EXPR_LOCATION (args[i]));\n \t}\n       convs[i] = t;\n     }\n@@ -2439,7 +2452,8 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \t{\n \t  viable = 0;\n \t  reason = arg_conversion_rejection (NULL_TREE, 0, argtypes[2],\n-\t\t\t\t\t     boolean_type_node);\n+\t\t\t\t\t     boolean_type_node,\n+\t\t\t\t\t     EXPR_LOCATION (args[2]));\n \t}\n     }\n \n@@ -3930,7 +3944,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n \t    {\n \t      cand->viable = 0;\n \t      cand->reason = arg_conversion_rejection (NULL_TREE, -2,\n-\t\t\t\t\t\t       rettype, totype);\n+\t\t\t\t\t\t       rettype, totype,\n+\t\t\t\t\t\t       EXPR_LOCATION (expr));\n \t    }\n \t  else if (DECL_NONCONVERTING_P (cand->fn)\n \t\t   && ics->rank > cr_exact)\n@@ -3950,7 +3965,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n \t      cand->viable = -1;\n \t      cand->reason\n \t\t= bad_arg_conversion_rejection (NULL_TREE, -2,\n-\t\t\t\t\t\trettype, totype);\n+\t\t\t\t\t\trettype, totype,\n+\t\t\t\t\t\tEXPR_LOCATION (expr));\n \t    }\n \t  else if (primary_template_specialization_p (cand->fn)\n \t\t   && ics->rank > cr_exact)\n@@ -9165,6 +9181,129 @@ name_as_c_string (tree name, tree type, bool *free_p)\n   return CONST_CAST (char *, pretty_name);\n }\n \n+/* If CANDIDATES contains exactly one candidate, return it, otherwise\n+   return NULL.  */\n+\n+static z_candidate *\n+single_z_candidate (z_candidate *candidates)\n+{\n+  if (candidates == NULL)\n+    return NULL;\n+\n+  if (candidates->next)\n+    return NULL;\n+\n+  return candidates;\n+}\n+\n+/* If CANDIDATE is invalid due to a bad argument type, return the\n+   pertinent conversion_info.\n+\n+   Otherwise, return NULL.  */\n+\n+static const conversion_info *\n+maybe_get_bad_conversion_for_unmatched_call (const z_candidate *candidate)\n+{\n+  /* Must be an rr_arg_conversion or rr_bad_arg_conversion.  */\n+  rejection_reason *r = candidate->reason;\n+\n+  if (r == NULL)\n+    return NULL;\n+\n+  switch (r->code)\n+    {\n+    default:\n+      return NULL;\n+\n+    case rr_arg_conversion:\n+      return &r->u.conversion;\n+\n+    case rr_bad_arg_conversion:\n+      return &r->u.bad_conversion;\n+    }\n+}\n+\n+/* Issue an error and note complaining about a bad argument type at a\n+   callsite with a single candidate FNDECL.\n+\n+   ARG_LOC is the location of the argument (or UNKNOWN_LOCATION, in which\n+   case input_location is used).\n+   FROM_TYPE is the type of the actual argument; TO_TYPE is the type of\n+   the formal parameter.  */\n+\n+void\n+complain_about_bad_argument (location_t arg_loc,\n+\t\t\t     tree from_type, tree to_type,\n+\t\t\t     tree fndecl, int parmnum)\n+{\n+  auto_diagnostic_group d;\n+  range_label_for_type_mismatch rhs_label (from_type, to_type);\n+  range_label *label = &rhs_label;\n+  if (arg_loc == UNKNOWN_LOCATION)\n+    {\n+      arg_loc = input_location;\n+      label = NULL;\n+    }\n+  gcc_rich_location richloc (arg_loc, label);\n+  error_at (&richloc,\n+\t    \"cannot convert %qH to %qI\",\n+\t    from_type, to_type);\n+  inform (get_fndecl_argument_location (fndecl, parmnum),\n+\t  \"  initializing argument %P of %qD\", parmnum, fndecl);\n+}\n+\n+/* Subroutine of build_new_method_call_1, for where there are no viable\n+   candidates for the call.  */\n+\n+static void\n+complain_about_no_candidates_for_method_call (tree instance,\n+\t\t\t\t\t      z_candidate *candidates,\n+\t\t\t\t\t      tree explicit_targs,\n+\t\t\t\t\t      tree basetype,\n+\t\t\t\t\t      tree optype, tree name,\n+\t\t\t\t\t      bool skip_first_for_error,\n+\t\t\t\t\t      vec<tree, va_gc> *user_args)\n+{\n+  auto_diagnostic_group d;\n+  if (!COMPLETE_OR_OPEN_TYPE_P (basetype))\n+    cxx_incomplete_type_error (instance, basetype);\n+  else if (optype)\n+    error (\"no matching function for call to %<%T::operator %T(%A)%#V%>\",\n+\t   basetype, optype, build_tree_list_vec (user_args),\n+\t   TREE_TYPE (instance));\n+  else\n+    {\n+      /* Special-case for when there's a single candidate that's failing\n+\t due to a bad argument type.  */\n+      if (z_candidate *candidate = single_z_candidate (candidates))\n+\t  if (const conversion_info *conv\n+\t\t= maybe_get_bad_conversion_for_unmatched_call (candidate))\n+\t    {\n+\t      complain_about_bad_argument (conv->loc,\n+\t\t\t\t\t   conv->from, conv->to_type,\n+\t\t\t\t\t   candidate->fn, conv->n_arg);\n+\t      return;\n+\t    }\n+\n+      tree arglist = build_tree_list_vec (user_args);\n+      tree errname = name;\n+      bool twiddle = false;\n+      if (IDENTIFIER_CDTOR_P (errname))\n+\t{\n+\t  twiddle = IDENTIFIER_DTOR_P (errname);\n+\t  errname = constructor_name (basetype);\n+\t}\n+      if (explicit_targs)\n+\terrname = lookup_template_function (errname, explicit_targs);\n+      if (skip_first_for_error)\n+\targlist = TREE_CHAIN (arglist);\n+      error (\"no matching function for call to %<%T::%s%E(%A)%#V%>\",\n+\t     basetype, &\"~\"[!twiddle], errname, arglist,\n+\t     TREE_TYPE (instance));\n+    }\n+  print_z_candidates (location_of (name), candidates);\n+}\n+\n /* Build a call to \"INSTANCE.FN (ARGS)\".  If FN_P is non-NULL, it will\n    be set, upon return, to the function called.  ARGS may be NULL.\n    This may change ARGS.  */\n@@ -9382,34 +9521,11 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,\n   if (!any_viable_p)\n     {\n       if (complain & tf_error)\n-\t{\n-\t  auto_diagnostic_group d;\n-\t  if (!COMPLETE_OR_OPEN_TYPE_P (basetype))\n-\t    cxx_incomplete_type_error (instance, basetype);\n-\t  else if (optype)\n-\t    error (\"no matching function for call to %<%T::operator %T(%A)%#V%>\",\n-\t\t   basetype, optype, build_tree_list_vec (user_args),\n-\t\t   TREE_TYPE (instance));\n-\t  else\n-\t    {\n-\t      tree arglist = build_tree_list_vec (user_args);\n-\t      tree errname = name;\n-\t      bool twiddle = false;\n-\t      if (IDENTIFIER_CDTOR_P (errname))\n-\t\t{\n-\t\t  twiddle = IDENTIFIER_DTOR_P (errname);\n-\t\t  errname = constructor_name (basetype);\n-\t\t}\n-\t      if (explicit_targs)\n-\t\terrname = lookup_template_function (errname, explicit_targs);\n-\t      if (skip_first_for_error)\n-\t\targlist = TREE_CHAIN (arglist);\n-\t      error (\"no matching function for call to %<%T::%s%E(%A)%#V%>\",\n-\t\t     basetype, &\"~\"[!twiddle], errname, arglist,\n-\t\t     TREE_TYPE (instance));\n-\t    }\n-\t  print_z_candidates (location_of (name), candidates);\n-\t}\n+\tcomplain_about_no_candidates_for_method_call (instance, candidates,\n+\t\t\t\t\t\t      explicit_targs, basetype,\n+\t\t\t\t\t\t      optype, name,\n+\t\t\t\t\t\t      skip_first_for_error,\n+\t\t\t\t\t\t      user_args);\n       call = error_mark_node;\n     }\n   else"}, {"sha": "6cd6e5f5886f6a76f1955d52cd7905c5aabe37a8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -6088,6 +6088,9 @@ extern bool can_convert_arg_bad\t\t\t(tree, tree, tree, int,\n extern int conv_flags\t\t\t\t(int, int, tree, tree, int);\n extern struct conversion * good_conversion\t(tree, tree, tree, int, tsubst_flags_t);\n extern location_t get_fndecl_argument_location  (tree, int);\n+extern void complain_about_bad_argument\t(location_t arg_loc,\n+\t\t\t\t\t\t tree from_type, tree to_type,\n+\t\t\t\t\t\t tree fndecl, int parmnum);\n \n \n /* A class for recording information about access failures (e.g. private"}, {"sha": "e9932202b4684f91dea7b7f477e5fb09fd29e6d7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -8820,23 +8820,9 @@ convert_for_assignment (tree type, tree rhs,\n \t\t\t\t\t\t   parmnum, complain, flags);\n \t\t}\n \t      else if (fndecl)\n-\t\t{\n-\t\t  auto_diagnostic_group d;\n-\t\t  location_t loc = cp_expr_location (rhs);\n-\t\t  range_label_for_type_mismatch rhs_label (rhstype, type);\n-\t\t  range_label *label = &rhs_label;\n-\t\t  if (loc == UNKNOWN_LOCATION)\n-\t\t    {\n-\t\t      loc = input_location;\n-\t\t      label = NULL;\n-\t\t    }\n-\t\t  gcc_rich_location richloc (loc, label);\n-\t\t  error_at (&richloc,\n-\t\t\t    \"cannot convert %qH to %qI\",\n-\t\t\t    rhstype, type);\n-\t\t  inform (get_fndecl_argument_location (fndecl, parmnum),\n-\t\t\t  \"  initializing argument %P of %qD\", parmnum, fndecl);\n-\t\t}\n+\t\tcomplain_about_bad_argument (cp_expr_location (rhs),\n+\t\t\t\t\t     rhstype, type,\n+\t\t\t\t\t     fndecl, parmnum);\n \t      else\n \t\tswitch (errtype)\n \t\t  {"}, {"sha": "5a50c801203791bb0a5313ed5829e6dbf6314693", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -1,3 +1,18 @@\n+2018-09-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/85110\n+\t* g++.dg/cpp0x/explicit4.C: Update expected output to reflect\n+\tspecial-casing of diagnostic for a single non-viable candidate due\n+\tto a bad argument.\n+\t* g++.dg/diagnostic/param-type-mismatch-2.C: Likewise.\n+\tAdd test coverage for an unmatched overloaded operator.\n+\t* g++.dg/expr/pmf-1.C: Likewise.\n+\t* g++.old-deja/g++.bugs/900330_02.C: Likewise.\n+\t* g++.old-deja/g++.jason/conversion11.C: Likewise.\n+\t* g++.old-deja/g++.law/arg11.C: Likewise.\n+\t* g++.old-deja/g++.law/arm9.C: Likewise.\n+\t* g++.old-deja/g++.robertl/eb131.C: Likewise.\n+\n 2018-09-12  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/87284"}, {"sha": "065a473854d42a99821bef638d0159498e572009", "filename": "gcc/testsuite/g++.dg/cpp0x/explicit4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit4.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -13,5 +13,5 @@ int main()\n {\n   B b;\n   (A(b));\t\t\t// OK\n-  (A(b,1));\t\t\t// { dg-error \"no match\" }\n+  (A(b,1));\t\t\t// { dg-error \"cannot convert\" }\n }"}, {"sha": "f74f8d39e26f7e4616ad89346319d10f5eb7a900", "filename": "gcc/testsuite/g++.dg/diagnostic/param-type-mismatch-2.C", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fparam-type-mismatch-2.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -71,17 +71,14 @@ struct s4 { static int member_1 (int one, const char **two, float three); }; //\n \n int test_4 (int first, const char *second, float third)\n {\n-  return s4::member_1 (first, second, third); // { dg-error \"no matching function for call to 's4::member_1\\\\(int&, const char\\\\*&, float&\\\\)'\" }\n+  return s4::member_1 (first, second, third); // { dg-error \"31: cannot convert 'const char\\\\*' to 'const char\\\\*\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return s4::member_1 (first, second, third);\n-                                            ^\n+                               ^~~~~~\n+                               |\n+                               const char*\n      { dg-end-multiline-output \"\" } */\n-  // { dg-message \"candidate: 'static int s4::member_1\\\\(int, const char\\\\*\\\\*, float\\\\)'\" \"\" { target *-*-* } s4_member_1 }\n-  /* { dg-begin-multiline-output \"\" }\n- struct s4 { static int member_1 (int one, const char **two, float three); };\n-                        ^~~~~~~~\n-     { dg-end-multiline-output \"\" } */\n-  // { dg-message \"no known conversion for argument 2 from 'const char\\\\*' to 'const char\\\\*\\\\*'\" \"\" { target *-*-* } s4_member_1 }\n+  // { dg-message \"initializing argument 2 of 'static int s4::member_1\\\\(int, const char\\\\*\\\\*, float\\\\)'\" \"\" { target *-*-* } s4_member_1 } \n   /* { dg-begin-multiline-output \"\" } \n  struct s4 { static int member_1 (int one, const char **two, float three); };\n                                            ~~~~~~~~~~~~~^~~\n@@ -95,18 +92,15 @@ struct s5 { int member_1 (int one, const char **two, float three); }; // { dg-li\n int test_5 (int first, const char *second, float third)\n {\n   s5 inst;\n-  return inst.member_1 (first, second, third); // { dg-error \"no matching function for call to 's5::member_1\\\\(int&, const char\\\\*&, float&\\\\)'\" }\n+  return inst.member_1 (first, second, third); // { dg-error \"32: cannot convert 'const char\\\\*' to 'const char\\\\*\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return inst.member_1 (first, second, third);\n-                                             ^\n+                                ^~~~~~\n+                                |\n+                                const char*\n      { dg-end-multiline-output \"\" } */\n-  // { dg-message \"candidate: 'int s5::member_1\\\\(int, const char\\\\*\\\\*, float\\\\)'\" \"\" { target *-*-* } s5_member_1 }\n+  // { dg-message \"initializing argument 2 of 'int s5::member_1\\\\(int, const char\\\\*\\\\*, float\\\\)'\" \"\" { target *-*-* } s5_member_1 } \n   /* { dg-begin-multiline-output \"\" }\n- struct s5 { int member_1 (int one, const char **two, float three); };\n-                 ^~~~~~~~\n-     { dg-end-multiline-output \"\" } */\n-  // { dg-message \"no known conversion for argument 2 from 'const char\\\\*' to 'const char\\\\*\\\\*'\" \"\" { target *-*-* } s5_member_1 }\n-  /* { dg-begin-multiline-output \"\" } \n  struct s5 { int member_1 (int one, const char **two, float three); };\n                                     ~~~~~~~~~~~~~^~~\n      { dg-end-multiline-output \"\" } */\n@@ -118,17 +112,14 @@ struct s6 { int member_1 (int one, const char **two, float three); }; // { dg-li\n \n int test_6 (int first, const char *second, float third, s6 *ptr)\n {\n-  return ptr->member_1 (first, second, third); // { dg-error \"no matching function for call to 's6::member_1\\\\(int&, const char\\\\*&, float&\\\\)'\" }\n+  return ptr->member_1 (first, second, third); // { dg-error \"32: cannot convert 'const char\\\\*' to 'const char\\\\*\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return ptr->member_1 (first, second, third);\n-                                             ^\n+                                ^~~~~~\n+                                |\n+                                const char*\n      { dg-end-multiline-output \"\" } */\n-  // { dg-message \"candidate: 'int s6::member_1\\\\(int, const char\\\\*\\\\*, float\\\\)'\" \"\" { target *-*-* } s6_member_1 }\n-  /* { dg-begin-multiline-output \"\" }\n- struct s6 { int member_1 (int one, const char **two, float three); };\n-                 ^~~~~~~~\n-     { dg-end-multiline-output \"\" } */\n-  // { dg-message \"no known conversion for argument 2 from 'const char\\\\*' to 'const char\\\\*\\\\*'\" \"\" { target *-*-* } s6_member_1 }\n+  // { dg-message \"initializing argument 2 of 'int s6::member_1\\\\(int, const char\\\\*\\\\*, float\\\\)'\" \"\" { target *-*-* } s6_member_1 } \n   /* { dg-begin-multiline-output \"\" } \n  struct s6 { int member_1 (int one, const char **two, float three); };\n                                     ~~~~~~~~~~~~~^~~\n@@ -168,17 +159,14 @@ struct s8 { static int member_1 (int one, T two, float three); }; // { dg-line s\n \n int test_8 (int first, const char *second, float third)\n {\n-  return s8 <const char **>::member_1 (first, second, third); // { dg-error \"no matching function for call to 's8<const char\\\\*\\\\*>::member_1\\\\(int&, const char\\\\*&, float&\\\\)'\" }\n+  return s8 <const char **>::member_1 (first, second, third); // { dg-error \"47: cannot convert 'const char\\\\*' to 'const char\\\\*\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return s8 <const char **>::member_1 (first, second, third);\n-                                                            ^\n-     { dg-end-multiline-output \"\" } */\n-  // { dg-message \"candidate: 'static int s8<T>::member_1\\\\(int, T, float\\\\)\" \"\" { target *-*-* } s8_member_1 }\n-  /* { dg-begin-multiline-output \"\" }\n- struct s8 { static int member_1 (int one, T two, float three); };\n-                        ^~~~~~~~\n+                                               ^~~~~~\n+                                               |\n+                                               const char*\n      { dg-end-multiline-output \"\" } */\n-  // { dg-message \"no known conversion for argument 2 from 'const char\\\\*' to 'const char\\\\*\\\\*'\" \"\" { target *-*-* } s8_member_1 }\n+  // { dg-message \"initializing argument 2 of 'static int s8<T>::member_1\\\\(int, T, float\\\\) .with T = const char\\\\*\\\\*.'\" \"\" { target *-*-* } s8_member_1 } \n   /* { dg-begin-multiline-output \"\" }\n  struct s8 { static int member_1 (int one, T two, float three); };\n                                            ~~^~~\n@@ -193,19 +181,43 @@ struct s9 { int member_1 (int one, T two, float three); }; // { dg-line s9_membe\n int test_9 (int first, const char *second, float third)\n {\n   s9 <const char **> inst;\n-  return inst.member_1 (first, second, third); // { dg-error \"no matching function for call to 's9<const char\\\\*\\\\*>::member_1\\\\(int&, const char\\\\*&, float&\\\\)'\" }\n+  return inst.member_1 (first, second, third); // { dg-error \"32: cannot convert 'const char\\\\*' to 'const char\\\\*\\\\*'\" }\n   /* { dg-begin-multiline-output \"\" }\n    return inst.member_1 (first, second, third);\n-                                             ^\n+                                ^~~~~~\n+                                |\n+                                const char*\n      { dg-end-multiline-output \"\" } */\n-  // { dg-message \"candidate: 'int s9<T>::member_1\\\\(int, T, float\\\\)\" \"\" { target *-*-* } s9_member_1 }\n+  // { dg-message \"initializing argument 2 of 'int s9<T>::member_1\\\\(int, T, float\\\\) .with T = const char\\\\*\\\\*.'\" \"\" { target *-*-* } s9_member_1 } \n   /* { dg-begin-multiline-output \"\" }\n  struct s9 { int member_1 (int one, T two, float three); };\n-                 ^~~~~~~~\n+                                    ~~^~~\n      { dg-end-multiline-output \"\" } */\n-  // { dg-message \"no known conversion for argument 2 from 'const char\\\\*' to 'const char\\\\*\\\\*'\" \"\" { target *-*-* } s9_member_1 }\n+}\n+\n+/* Overloaded operator (with one candidate).  */\n+\n+struct s10 {};\n+\n+extern int operator- (const s10&, int); // { dg-line s10_operator }\n+\n+int test_10 ()\n+{\n+  s10 v10_a, v10_b;\n+\n+  return v10_a - v10_b; // { dg-error \"no match for\" }\n   /* { dg-begin-multiline-output \"\" }\n- struct s9 { int member_1 (int one, T two, float three); };\n-                                    ~~^~~\n+   return v10_a - v10_b;\n+          ~~~~~~^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+  // { dg-message \"candidate\" \"\" { target *-*-* } s10_operator }\n+  /* { dg-begin-multiline-output \"\" }\n+ extern int operator- (const s10&, int);\n+            ^~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+  // { dg-message \"no known conversion for argument 2 from\" \"\" { target *-*-* } s10_operator }\n+  /* { dg-begin-multiline-output \"\" }\n+ extern int operator- (const s10&, int);\n+                                   ^~~\n      { dg-end-multiline-output \"\" } */\n }"}, {"sha": "35ebe5290f4966c819fcd46d58aee7cf69b7dac6", "filename": "gcc/testsuite/g++.dg/expr/pmf-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fpmf-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fpmf-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fpmf-1.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -14,6 +14,6 @@ struct A\n   {\n     void (A::*p)() = &A::f;\n     void (A::*q)() = &(A::f);       // { dg-error \"parenthesized\" }\n-    foo(&g<int>);                   // { dg-error \"no matching\" }\n+    foo(&g<int>);                   // { dg-error \"cannot convert\" }\n   }\n };"}, {"sha": "f1591b2e5c7d6e2f1eed6a15a5dedeae9a888b53", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900330_02.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900330_02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900330_02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900330_02.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -24,7 +24,7 @@ struct D : public B {\n \n void h(D* pd)\n {\n-  pd->f(1);\t\t// { dg-error \"no matching\" } D::f(struct B) hides B::f(int)\n+  pd->f(1);\t\t// { dg-error \"cannot convert\" } D::f(struct B) hides B::f(int)\n }\n \n int main () { return 0; }"}, {"sha": "ccbd1f58b1b85ab53bd66d0830cce635af5787bc", "filename": "gcc/testsuite/g++.old-deja/g++.jason/conversion11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fconversion11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fconversion11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fconversion11.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -22,6 +22,6 @@ void DoSomething(Ding A);\n void foo(Something* pX)\n {\n   DoSomething(1);\t\t// { dg-error \"could not convert\" }\n-  pX->DoSomething(1);\t\t// { dg-error \"no matching\" } \n-  (*pX).DoSomething(1);\t\t// { dg-error \"no matching\" } \n+  pX->DoSomething(1);\t\t// { dg-error \"cannot convert\" } \n+  (*pX).DoSomething(1);\t\t// { dg-error \"cannot convert\" } \n }"}, {"sha": "d68f1842ccaa8084f042bb81e008e44efa3b0167", "filename": "gcc/testsuite/g++.old-deja/g++.law/arg11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farg11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farg11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farg11.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -17,6 +17,6 @@ int\n foo(S *o)\n { // Neither call has a usable constructor for conversions of char[5] to Ack.\n   function(\"adsf\");// { dg-error \"could not convert\" }\n-  o->method(\"adsf\");// { dg-error \"no matching\" } \n+  o->method(\"adsf\");// { dg-error \"cannot convert\" } \n   return 0;\n }"}, {"sha": "ab18189dde3ee63d947682c96da544e5b06c3c5d", "filename": "gcc/testsuite/g++.old-deja/g++.law/arm9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Farm9.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -23,7 +23,7 @@ void B::set (f2 f) { std::cout << \"called B\\n|no known conversion\";} // { dg-mes\n \n int main() {\n     B b;\n-    b.set(F1); // ARM page 309: should call A.set(f1) and that what g++ does,// { dg-error \"match\" }\n+    b.set(F1); // ARM page 309: should call A.set(f1) and that what g++ does,// { dg-error \"cannot convert\" }\n                // but 13.1 of ARM clearly states that it should call B::set()\n                // or generate an error because overloading works only for\n                // functions within the same scope (first page of chapter 13)"}, {"sha": "c2377fb2d22ed823127b7f107d4823774f98cb41", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb131.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb131.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4911b24d71955b757fdaac29b878ae33c32f3e0b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb131.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb131.C?ref=4911b24d71955b757fdaac29b878ae33c32f3e0b", "patch": "@@ -15,6 +15,6 @@ struct a {\n \n a::a()\n {\n-\tfoo( &junk ); // { dg-error \"match\" } junk is an unqualified-id.\n-\tfoo( &bar );  // { dg-error \"match\" } bar is an unqualified-id.\n+\tfoo( &junk ); // { dg-error \"cannot convert\" } junk is an unqualified-id.\n+\tfoo( &bar );  // { dg-error \"cannot convert\" } bar is an unqualified-id.\n }"}]}