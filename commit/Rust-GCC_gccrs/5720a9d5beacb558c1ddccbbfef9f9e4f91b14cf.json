{"sha": "5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "node_id": "C_kwDOANBUbNoAKDU3MjBhOWQ1YmVhY2I1NThjMWRkY2NiYmZlZjlmOWU0ZjkxYjE0Y2Y", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-10T12:31:01Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-10T12:31:01Z"}, "message": "vect: Hookize better_loop_vinfo_p\n\nOne of the things we want to do on AArch64 is compare vector loops\nside-by-side and pick the best one.  For some targets, we want this\nto be based on issue rates as well as the usual latency-based costs\n(at least for loops with relatively high iteration counts).\n\nThe current approach to doing this is: when costing vectorisation\ncandidate A, try to guess what the other main candidate B will look\nlike and adjust A's latency-based cost up or down based on the likely\ndifference between A and B's issue rates.  This effectively means\nthat we try to cost parts of B at the same time as A, without actually\nbeing able to see B.\n\nThis is needlessly indirect and complex.  It was a compromise due\nto the code being added (too) late in the GCC 11 cycle, so that\ntarget-independent changes weren't possible.\n\nThe target-independent code already compares two candidate loop_vec_infos\nside-by-side, so that information about A and B above are available\ndirectly.  This patch creates a way for targets to hook into this\ncomparison.\n\nThe AArch64 code can therefore hook into better_main_loop_than_p to\ncompare issue rates.  If the issue rate comparison isn't decisive,\nthe code can fall back to the normal latency-based comparison instead.\n\ngcc/\n\t* tree-vectorizer.h (vector_costs::better_main_loop_than_p)\n\t(vector_costs::better_epilogue_loop_than_p)\n\t(vector_costs::compare_inside_loop_cost)\n\t(vector_costs::compare_outside_loop_cost): Likewise.\n\t* tree-vectorizer.c (vector_costs::better_main_loop_than_p)\n\t(vector_costs::better_epilogue_loop_than_p)\n\t(vector_costs::compare_inside_loop_cost)\n\t(vector_costs::compare_outside_loop_cost): New functions,\n\tcontaining code moved from...\n\t* tree-vect-loop.c (vect_better_loop_vinfo_p): ...here.", "tree": {"sha": "3f728ad5f83db3e244ed18b3efb52e90f059de6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f728ad5f83db3e244ed18b3efb52e90f059de6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "772d76acb5aead98eb3c47a78363d867287d5e77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772d76acb5aead98eb3c47a78363d867287d5e77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/772d76acb5aead98eb3c47a78363d867287d5e77"}], "stats": {"total": 363, "additions": 226, "deletions": 137}, "files": [{"sha": "3d9033f06c9399d4ee557b20708bd9ab289d422b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 137, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "patch": "@@ -2784,144 +2784,12 @@ vect_better_loop_vinfo_p (loop_vec_info new_loop_vinfo,\n \treturn new_simdlen_p;\n     }\n \n-  loop_vec_info main_loop = LOOP_VINFO_ORIG_LOOP_INFO (old_loop_vinfo);\n-  if (main_loop)\n-    {\n-      poly_uint64 main_poly_vf = LOOP_VINFO_VECT_FACTOR (main_loop);\n-      unsigned HOST_WIDE_INT main_vf;\n-      unsigned HOST_WIDE_INT old_factor, new_factor, old_cost, new_cost;\n-      /* If we can determine how many iterations are left for the epilogue\n-\t loop, that is if both the main loop's vectorization factor and number\n-\t of iterations are constant, then we use them to calculate the cost of\n-\t the epilogue loop together with a 'likely value' for the epilogues\n-\t vectorization factor.  Otherwise we use the main loop's vectorization\n-\t factor and the maximum poly value for the epilogue's.  If the target\n-\t has not provided with a sensible upper bound poly vectorization\n-\t factors are likely to be favored over constant ones.  */\n-      if (main_poly_vf.is_constant (&main_vf)\n-\t  && LOOP_VINFO_NITERS_KNOWN_P (main_loop))\n-\t{\n-\t  unsigned HOST_WIDE_INT niters\n-\t    = LOOP_VINFO_INT_NITERS (main_loop) % main_vf;\n-\t  HOST_WIDE_INT old_likely_vf\n-\t    = estimated_poly_value (old_vf, POLY_VALUE_LIKELY);\n-\t  HOST_WIDE_INT new_likely_vf\n-\t    = estimated_poly_value (new_vf, POLY_VALUE_LIKELY);\n-\n-\t  /* If the epilogue is using partial vectors we account for the\n-\t     partial iteration here too.  */\n-\t  old_factor = niters / old_likely_vf;\n-\t  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (old_loop_vinfo)\n-\t      && niters % old_likely_vf != 0)\n-\t    old_factor++;\n-\n-\t  new_factor = niters / new_likely_vf;\n-\t  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (new_loop_vinfo)\n-\t      && niters % new_likely_vf != 0)\n-\t    new_factor++;\n-\t}\n-      else\n-\t{\n-\t  unsigned HOST_WIDE_INT main_vf_max\n-\t    = estimated_poly_value (main_poly_vf, POLY_VALUE_MAX);\n-\n-\t  old_factor = main_vf_max / estimated_poly_value (old_vf,\n-\t\t\t\t\t\t\t   POLY_VALUE_MAX);\n-\t  new_factor = main_vf_max / estimated_poly_value (new_vf,\n-\t\t\t\t\t\t\t   POLY_VALUE_MAX);\n-\n-\t  /* If the loop is not using partial vectors then it will iterate one\n-\t     time less than one that does.  It is safe to subtract one here,\n-\t     because the main loop's vf is always at least 2x bigger than that\n-\t     of an epilogue.  */\n-\t  if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (old_loop_vinfo))\n-\t    old_factor -= 1;\n-\t  if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (new_loop_vinfo))\n-\t    new_factor -= 1;\n-\t}\n-\n-      /* Compute the costs by multiplying the inside costs with the factor and\n-\t add the outside costs for a more complete picture.  The factor is the\n-\t amount of times we are expecting to iterate this epilogue.  */\n-      old_cost = old_loop_vinfo->vector_costs->body_cost () * old_factor;\n-      new_cost = new_loop_vinfo->vector_costs->body_cost () * new_factor;\n-      old_cost += old_loop_vinfo->vector_costs->outside_cost ();\n-      new_cost += new_loop_vinfo->vector_costs->outside_cost ();\n-      return new_cost < old_cost;\n-    }\n-\n-  /* Limit the VFs to what is likely to be the maximum number of iterations,\n-     to handle cases in which at least one loop_vinfo is fully-masked.  */\n-  HOST_WIDE_INT estimated_max_niter = likely_max_stmt_executions_int (loop);\n-  if (estimated_max_niter != -1)\n-    {\n-      if (known_le (estimated_max_niter, new_vf))\n-\tnew_vf = estimated_max_niter;\n-      if (known_le (estimated_max_niter, old_vf))\n-\told_vf = estimated_max_niter;\n-    }\n-\n-  /* Check whether the (fractional) cost per scalar iteration is lower\n-     or higher: new_inside_cost / new_vf vs. old_inside_cost / old_vf.  */\n-  poly_int64 rel_new = new_loop_vinfo->vector_costs->body_cost () * old_vf;\n-  poly_int64 rel_old = old_loop_vinfo->vector_costs->body_cost () * new_vf;\n-\n-  HOST_WIDE_INT est_rel_new_min\n-    = estimated_poly_value (rel_new, POLY_VALUE_MIN);\n-  HOST_WIDE_INT est_rel_new_max\n-    = estimated_poly_value (rel_new, POLY_VALUE_MAX);\n-\n-  HOST_WIDE_INT est_rel_old_min\n-    = estimated_poly_value (rel_old, POLY_VALUE_MIN);\n-  HOST_WIDE_INT est_rel_old_max\n-    = estimated_poly_value (rel_old, POLY_VALUE_MAX);\n-\n-  /* Check first if we can make out an unambigous total order from the minimum\n-     and maximum estimates.  */\n-  if (est_rel_new_min < est_rel_old_min\n-      && est_rel_new_max < est_rel_old_max)\n-    return true;\n-  else if (est_rel_old_min < est_rel_new_min\n-\t   && est_rel_old_max < est_rel_new_max)\n-    return false;\n-  /* When old_loop_vinfo uses a variable vectorization factor,\n-     we know that it has a lower cost for at least one runtime VF.\n-     However, we don't know how likely that VF is.\n-\n-     One option would be to compare the costs for the estimated VFs.\n-     The problem is that that can put too much pressure on the cost\n-     model.  E.g. if the estimated VF is also the lowest possible VF,\n-     and if old_loop_vinfo is 1 unit worse than new_loop_vinfo\n-     for the estimated VF, we'd then choose new_loop_vinfo even\n-     though (a) new_loop_vinfo might not actually be better than\n-     old_loop_vinfo for that VF and (b) it would be significantly\n-     worse at larger VFs.\n-\n-     Here we go for a hacky compromise: pick new_loop_vinfo if it is\n-     no more expensive than old_loop_vinfo even after doubling the\n-     estimated old_loop_vinfo VF.  For all but trivial loops, this\n-     ensures that we only pick new_loop_vinfo if it is significantly\n-     better than old_loop_vinfo at the estimated VF.  */\n-\n-  if (est_rel_old_min != est_rel_new_min\n-      || est_rel_old_max != est_rel_new_max)\n-    {\n-      HOST_WIDE_INT est_rel_new_likely\n-\t= estimated_poly_value (rel_new, POLY_VALUE_LIKELY);\n-      HOST_WIDE_INT est_rel_old_likely\n-\t= estimated_poly_value (rel_old, POLY_VALUE_LIKELY);\n-\n-      return est_rel_new_likely * 2 <= est_rel_old_likely;\n-    }\n-\n-  /* If there's nothing to choose between the loop bodies, see whether\n-     there's a difference in the prologue and epilogue costs.  */\n-  auto old_outside_cost = old_loop_vinfo->vector_costs->outside_cost ();\n-  auto new_outside_cost = new_loop_vinfo->vector_costs->outside_cost ();\n-  if (new_outside_cost != old_outside_cost)\n-    return new_outside_cost < old_outside_cost;\n+  const auto *old_costs = old_loop_vinfo->vector_costs;\n+  const auto *new_costs = new_loop_vinfo->vector_costs;\n+  if (loop_vec_info main_loop = LOOP_VINFO_ORIG_LOOP_INFO (old_loop_vinfo))\n+    return new_costs->better_epilogue_loop_than_p (old_costs, main_loop);\n \n-  return false;\n+  return new_costs->better_main_loop_than_p (old_costs);\n }\n \n /* Decide whether to replace OLD_LOOP_VINFO with NEW_LOOP_VINFO.  Return"}, {"sha": "dcbb2a3f13af78cdef028b80b4afcffb41b6ae8c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "patch": "@@ -1744,3 +1744,207 @@ vector_costs::adjust_cost_for_freq (stmt_vec_info stmt_info,\n     }\n   return cost;\n }\n+\n+/* See the comment above the declaration for details.  */\n+\n+bool\n+vector_costs::better_main_loop_than_p (const vector_costs *other) const\n+{\n+  int diff = compare_inside_loop_cost (other);\n+  if (diff != 0)\n+    return diff < 0;\n+\n+  /* If there's nothing to choose between the loop bodies, see whether\n+     there's a difference in the prologue and epilogue costs.  */\n+  diff = compare_outside_loop_cost (other);\n+  if (diff != 0)\n+    return diff < 0;\n+\n+  return false;\n+}\n+\n+\n+/* See the comment above the declaration for details.  */\n+\n+bool\n+vector_costs::better_epilogue_loop_than_p (const vector_costs *other,\n+\t\t\t\t\t   loop_vec_info main_loop) const\n+{\n+  loop_vec_info this_loop_vinfo = as_a<loop_vec_info> (this->m_vinfo);\n+  loop_vec_info other_loop_vinfo = as_a<loop_vec_info> (other->m_vinfo);\n+\n+  poly_int64 this_vf = LOOP_VINFO_VECT_FACTOR (this_loop_vinfo);\n+  poly_int64 other_vf = LOOP_VINFO_VECT_FACTOR (other_loop_vinfo);\n+\n+  poly_uint64 main_poly_vf = LOOP_VINFO_VECT_FACTOR (main_loop);\n+  unsigned HOST_WIDE_INT main_vf;\n+  unsigned HOST_WIDE_INT other_factor, this_factor, other_cost, this_cost;\n+  /* If we can determine how many iterations are left for the epilogue\n+     loop, that is if both the main loop's vectorization factor and number\n+     of iterations are constant, then we use them to calculate the cost of\n+     the epilogue loop together with a 'likely value' for the epilogues\n+     vectorization factor.  Otherwise we use the main loop's vectorization\n+     factor and the maximum poly value for the epilogue's.  If the target\n+     has not provided with a sensible upper bound poly vectorization\n+     factors are likely to be favored over constant ones.  */\n+  if (main_poly_vf.is_constant (&main_vf)\n+      && LOOP_VINFO_NITERS_KNOWN_P (main_loop))\n+    {\n+      unsigned HOST_WIDE_INT niters\n+\t= LOOP_VINFO_INT_NITERS (main_loop) % main_vf;\n+      HOST_WIDE_INT other_likely_vf\n+\t= estimated_poly_value (other_vf, POLY_VALUE_LIKELY);\n+      HOST_WIDE_INT this_likely_vf\n+\t= estimated_poly_value (this_vf, POLY_VALUE_LIKELY);\n+\n+      /* If the epilogue is using partial vectors we account for the\n+\t partial iteration here too.  */\n+      other_factor = niters / other_likely_vf;\n+      if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (other_loop_vinfo)\n+\t  && niters % other_likely_vf != 0)\n+\tother_factor++;\n+\n+      this_factor = niters / this_likely_vf;\n+      if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (this_loop_vinfo)\n+\t  && niters % this_likely_vf != 0)\n+\tthis_factor++;\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT main_vf_max\n+\t= estimated_poly_value (main_poly_vf, POLY_VALUE_MAX);\n+\n+      other_factor = main_vf_max / estimated_poly_value (other_vf,\n+\t\t\t\t\t\t       POLY_VALUE_MAX);\n+      this_factor = main_vf_max / estimated_poly_value (this_vf,\n+\t\t\t\t\t\t       POLY_VALUE_MAX);\n+\n+      /* If the loop is not using partial vectors then it will iterate one\n+\t time less than one that does.  It is safe to subtract one here,\n+\t because the main loop's vf is always at least 2x bigger than that\n+\t of an epilogue.  */\n+      if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (other_loop_vinfo))\n+\tother_factor -= 1;\n+      if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (this_loop_vinfo))\n+\tthis_factor -= 1;\n+    }\n+\n+  /* Compute the costs by multiplying the inside costs with the factor and\n+     add the outside costs for a more complete picture.  The factor is the\n+     amount of times we are expecting to iterate this epilogue.  */\n+  other_cost = other->body_cost () * other_factor;\n+  this_cost = this->body_cost () * this_factor;\n+  other_cost += other->outside_cost ();\n+  this_cost += this->outside_cost ();\n+  return this_cost < other_cost;\n+}\n+\n+/* A <=>-style subroutine of better_main_loop_than_p.  Check whether we can\n+   determine the return value of better_main_loop_than_p by comparing the\n+   inside (loop body) costs of THIS and OTHER.  Return:\n+\n+   * -1 if better_main_loop_than_p should return true.\n+   * 1 if better_main_loop_than_p should return false.\n+   * 0 if we can't decide.  */\n+\n+int\n+vector_costs::compare_inside_loop_cost (const vector_costs *other) const\n+{\n+  loop_vec_info this_loop_vinfo = as_a<loop_vec_info> (this->m_vinfo);\n+  loop_vec_info other_loop_vinfo = as_a<loop_vec_info> (other->m_vinfo);\n+\n+  struct loop *loop = LOOP_VINFO_LOOP (this_loop_vinfo);\n+  gcc_assert (LOOP_VINFO_LOOP (other_loop_vinfo) == loop);\n+\n+  poly_int64 this_vf = LOOP_VINFO_VECT_FACTOR (this_loop_vinfo);\n+  poly_int64 other_vf = LOOP_VINFO_VECT_FACTOR (other_loop_vinfo);\n+\n+  /* Limit the VFs to what is likely to be the maximum number of iterations,\n+     to handle cases in which at least one loop_vinfo is fully-masked.  */\n+  HOST_WIDE_INT estimated_max_niter = likely_max_stmt_executions_int (loop);\n+  if (estimated_max_niter != -1)\n+    {\n+      if (known_le (estimated_max_niter, this_vf))\n+\tthis_vf = estimated_max_niter;\n+      if (known_le (estimated_max_niter, other_vf))\n+\tother_vf = estimated_max_niter;\n+    }\n+\n+  /* Check whether the (fractional) cost per scalar iteration is lower or\n+     higher: this_inside_cost / this_vf vs. other_inside_cost / other_vf.  */\n+  poly_int64 rel_this = this_loop_vinfo->vector_costs->body_cost () * other_vf;\n+  poly_int64 rel_other\n+    = other_loop_vinfo->vector_costs->body_cost () * this_vf;\n+\n+  HOST_WIDE_INT est_rel_this_min\n+    = estimated_poly_value (rel_this, POLY_VALUE_MIN);\n+  HOST_WIDE_INT est_rel_this_max\n+    = estimated_poly_value (rel_this, POLY_VALUE_MAX);\n+\n+  HOST_WIDE_INT est_rel_other_min\n+    = estimated_poly_value (rel_other, POLY_VALUE_MIN);\n+  HOST_WIDE_INT est_rel_other_max\n+    = estimated_poly_value (rel_other, POLY_VALUE_MAX);\n+\n+  /* Check first if we can make out an unambigous total order from the minimum\n+     and maximum estimates.  */\n+  if (est_rel_this_min < est_rel_other_min\n+      && est_rel_this_max < est_rel_other_max)\n+    return -1;\n+\n+  if (est_rel_other_min < est_rel_this_min\n+      && est_rel_other_max < est_rel_this_max)\n+    return 1;\n+\n+  /* When other_loop_vinfo uses a variable vectorization factor,\n+     we know that it has a lower cost for at least one runtime VF.\n+     However, we don't know how likely that VF is.\n+\n+     One option would be to compare the costs for the estimated VFs.\n+     The problem is that that can put too much pressure on the cost\n+     model.  E.g. if the estimated VF is also the lowest possible VF,\n+     and if other_loop_vinfo is 1 unit worse than this_loop_vinfo\n+     for the estimated VF, we'd then choose this_loop_vinfo even\n+     though (a) this_loop_vinfo might not actually be better than\n+     other_loop_vinfo for that VF and (b) it would be significantly\n+     worse at larger VFs.\n+\n+     Here we go for a hacky compromise: pick this_loop_vinfo if it is\n+     no more expensive than other_loop_vinfo even after doubling the\n+     estimated other_loop_vinfo VF.  For all but trivial loops, this\n+     ensures that we only pick this_loop_vinfo if it is significantly\n+     better than other_loop_vinfo at the estimated VF.  */\n+  if (est_rel_other_min != est_rel_this_min\n+      || est_rel_other_max != est_rel_this_max)\n+    {\n+      HOST_WIDE_INT est_rel_this_likely\n+\t= estimated_poly_value (rel_this, POLY_VALUE_LIKELY);\n+      HOST_WIDE_INT est_rel_other_likely\n+\t= estimated_poly_value (rel_other, POLY_VALUE_LIKELY);\n+\n+      return est_rel_this_likely * 2 <= est_rel_other_likely ? -1 : 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* A <=>-style subroutine of better_main_loop_than_p, used when there is\n+   nothing to choose between the inside (loop body) costs of THIS and OTHER.\n+   Check whether we can determine the return value of better_main_loop_than_p\n+   by comparing the outside (prologue and epilogue) costs of THIS and OTHER.\n+   Return:\n+\n+   * -1 if better_main_loop_than_p should return true.\n+   * 1 if better_main_loop_than_p should return false.\n+   * 0 if we can't decide.  */\n+\n+int\n+vector_costs::compare_outside_loop_cost (const vector_costs *other) const\n+{\n+  auto this_outside_cost = this->outside_cost ();\n+  auto other_outside_cost = other->outside_cost ();\n+  if (this_outside_cost != other_outside_cost)\n+    return this_outside_cost < other_outside_cost ? -1 : 1;\n+\n+  return 0;\n+}"}, {"sha": "9b419959711484315efa5a1e2689bb3cecdbac0d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5720a9d5beacb558c1ddccbbfef9f9e4f91b14cf", "patch": "@@ -1419,6 +1419,21 @@ class vector_costs\n      read back using the functions below.  */\n   virtual void finish_cost ();\n \n+  /* The costs in THIS and OTHER both describe ways of vectorizing\n+     a main loop.  Return true if the costs described by THIS are\n+     cheaper than the costs described by OTHER.  Return false if any\n+     of the following are true:\n+\n+     - THIS and OTHER are of equal cost\n+     - OTHER is better than THIS\n+     - we can't be sure about the relative costs of THIS and OTHER.  */\n+  virtual bool better_main_loop_than_p (const vector_costs *other) const;\n+\n+  /* Likewise, but the costs in THIS and OTHER both describe ways of\n+     vectorizing an epilogue loop of MAIN_LOOP.  */\n+  virtual bool better_epilogue_loop_than_p (const vector_costs *other,\n+\t\t\t\t\t    loop_vec_info main_loop) const;\n+\n   unsigned int prologue_cost () const;\n   unsigned int body_cost () const;\n   unsigned int epilogue_cost () const;\n@@ -1429,6 +1444,8 @@ class vector_costs\n \t\t\t\t unsigned int);\n   unsigned int adjust_cost_for_freq (stmt_vec_info, vect_cost_model_location,\n \t\t\t\t     unsigned int);\n+  int compare_inside_loop_cost (const vector_costs *) const;\n+  int compare_outside_loop_cost (const vector_costs *) const;\n \n   /* The region of code that we're considering vectorizing.  */\n   vec_info *m_vinfo;"}]}