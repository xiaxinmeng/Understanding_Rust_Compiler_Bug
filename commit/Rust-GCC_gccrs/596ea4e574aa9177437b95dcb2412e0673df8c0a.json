{"sha": "596ea4e574aa9177437b95dcb2412e0673df8c0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk2ZWE0ZTU3NGFhOTE3NzQzN2I5NWRjYjI0MTJlMDY3M2RmOGMwYQ==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-05-28T02:58:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-28T02:58:19Z"}, "message": "cp-tree.h (ansi_opname): Make it a macro.\n\n2000-05-27  Alex Samuel    <samuel@codesourcery.com>\n\t    Mark Mitchell  <mark@codesourcery.com>\n\n\t* cp-tree.h (ansi_opname): Make it a macro.\n\t(ansi_assopname): Likewise.\n\t(struct lang_decl_flags): Add assignment_operator_p.\n\t(struct lang_decl): Add operator_code.\n\t(DECL_VTT_PARM): Adjust.\n\t(DECL_OVERLOADED_OPERATOR_P): Return the operator_code for an\n\toverloaded operator.\n\t(SET_OVERLOADED_OPERATOR_CODE): New macro.\n\t(DECL_ASSIGNMENT_OPERATOR_P): New macro.\n\t(DECL_ARRAY_DELETE_OPERATOR_P): Adjust.\n\t(opname_tab): Remove.\n\t(assignop_tab): Likewise.\n\t(operator_name_info_t): New type.\n\t(operator_name_info): New variable.\n\t(assignment_operator_name_info): Likewise.\n\t(build_cp_library_fn): Remove declaration.\n\t(push_cp_library_fn): Likewise.\n\t(operator_name_string): Likewise.\n\t(build_decl_overload): Likewise.\n\t* call.c (print_z_candidates): Simplify.\n\t(build_object_call): Adjust usage of ansi_opname.  Use\n\tDECL_OVERLOADED_OPERATOR_P.\n\t(op_error): Adjust operator name lookup.\n\t(build_conditional_expr): Adjust usage of ansi_opname.\n\t(build_new_op): Likewise.\n\t(build_op_delete_call): Likewise.\n\t(build_over_call): Likewise.\n\t(joust): Use DECL_OVERLOADED_OPERATOR_P.\n\t* decl.c (duplicate_decls): Copy operator_code.\n\t(init_decl_processing): Adjust parameters to push_cp_library_fn.\n\t(builtin_function): Adjust parameters to build_library_fn_1.\n\t(build_library_fn_1): Accept an overloaded operator code.\n\t(build_library_fn): Pass ERROR_MARK.\n\t(build_cp_library_fn): Accept an overloaded operator code.\n\t(push_cp_library_fn): Likewise.\n\t(grokfndecl): Tweak.\n\t(grokdeclarator): Simplify code to compute names of overloaded\n\toperators.  Adjust use of ansi_opname.\n\t(ambi_op_p): Work on tree_codes, not identifiers.\n\t(unary_op_p): Likewise.\n\t(grok_op_properties): Likewise.\n\t(start_function): Use DECL_OVERLOADED_OPERATOR_P.\n\t(lang_mark_tree): Don't try to mark the operator_code.\n\t* decl2.c (grok_function_init): Use DECL_OVERLOADED_OPERATOR_P.\n\t* error.c (dump_decl): Remove special handling for operator\n\tnames.\n\t(dump_function_name): Likewise.\n\t(dump_expr): Adjust name lookup of operators.\n\t(op_to_string): Simplify.\n\t(assop_to_string): Likewise.\n\t* init.c (build_new_1): Adjust use of ansi_opname.\n\t* lex.c (opname_tab): Remove.\n\t(assignop_tab): Likewise.\n\t(ansi_opname): Likewise.\n\t(ansi_assopname): Likewise.\n\t(operator_name_string): Likewise.\n\t(reinit_lang_specific): Likewise.\n\t(operator_name_info): New variable.\n\t(assignment_operator_name_info): Likewise.\n\t(init_operators): New function.\n\t(init_parse): Use it.\n\t(do_identifier): Adjust use of ansi_opname.\n\t* method.c (mangle_expression): Don't use ansi_opname for\n\tmangling.\n\t(build_decl_overload_real): Use DECL_OVERLOADED_OPERATOR_P.\n\t(build_decl_overload): Remove.\n\t(build_typename_overload): Use OPERATOR_TYPENAME_FORMAT directly.\n\t(do_build_assign_ref): Adjust use of ansi_opname.\n\t(synthesize_method): Likewise.\n\t(implicitly_declare_fn): Likewise.\n\t* operators.def: New file.\n\t* parse.y (operator): Adjust use of ansi_opname.\n\t* pt.c (tsubst_decl): Use IDENTIFIER_OPNAME_P.\n\t(set_mangled_name_for_template_decl): Don't play games with\n\tcurrent_namespace.\n\t(special_function_p): Adjust use of ansi_opname.\n\t* typeck.c (check_return_expr): Likewise.\n\t* Make-lang.in (cc1plus): Depend on operators.def.\n\t* Makefile.in (lex.o): Likewise.\n\t(decl.o): Likewise.\n\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r34223", "tree": {"sha": "e69d1900e45d7c20303ea928d731e1f70c7ec263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e69d1900e45d7c20303ea928d731e1f70c7ec263"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/596ea4e574aa9177437b95dcb2412e0673df8c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/596ea4e574aa9177437b95dcb2412e0673df8c0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/596ea4e574aa9177437b95dcb2412e0673df8c0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/596ea4e574aa9177437b95dcb2412e0673df8c0a/comments", "author": null, "committer": null, "parents": [{"sha": "4f1c5cce901c4d53fb9130183ca275ef1d04fe8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f1c5cce901c4d53fb9130183ca275ef1d04fe8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f1c5cce901c4d53fb9130183ca275ef1d04fe8a"}], "stats": {"total": 1358, "additions": 752, "deletions": 606}, "files": [{"sha": "08a9bcea04ed8158445480a63809b3b2a525ea24", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -1,3 +1,87 @@\n+2000-05-27  Alex Samuel    <samuel@codesourcery.com>\n+\t    Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (ansi_opname): Make it a macro.\n+\t(ansi_assopname): Likewise.\n+\t(struct lang_decl_flags): Add assignment_operator_p.\n+\t(struct lang_decl): Add operator_code.\n+\t(DECL_VTT_PARM): Adjust.\n+\t(DECL_OVERLOADED_OPERATOR_P): Return the operator_code for an\n+\toverloaded operator.\n+\t(SET_OVERLOADED_OPERATOR_CODE): New macro.\n+\t(DECL_ASSIGNMENT_OPERATOR_P): New macro.\n+\t(DECL_ARRAY_DELETE_OPERATOR_P): Adjust.\n+\t(opname_tab): Remove.\n+\t(assignop_tab): Likewise.\n+\t(operator_name_info_t): New type.\n+\t(operator_name_info): New variable.\n+\t(assignment_operator_name_info): Likewise.\n+\t(build_cp_library_fn): Remove declaration.\n+\t(push_cp_library_fn): Likewise.\n+\t(operator_name_string): Likewise.\n+\t(build_decl_overload): Likewise.\n+\t* call.c (print_z_candidates): Simplify.\n+\t(build_object_call): Adjust usage of ansi_opname.  Use\n+\tDECL_OVERLOADED_OPERATOR_P.\n+\t(op_error): Adjust operator name lookup.\n+\t(build_conditional_expr): Adjust usage of ansi_opname.\n+\t(build_new_op): Likewise.\n+\t(build_op_delete_call): Likewise.\n+\t(build_over_call): Likewise.\n+\t(joust): Use DECL_OVERLOADED_OPERATOR_P.\n+\t* decl.c (duplicate_decls): Copy operator_code.\n+\t(init_decl_processing): Adjust parameters to push_cp_library_fn.\n+\t(builtin_function): Adjust parameters to build_library_fn_1.\n+\t(build_library_fn_1): Accept an overloaded operator code.\n+\t(build_library_fn): Pass ERROR_MARK.\n+\t(build_cp_library_fn): Accept an overloaded operator code.\n+\t(push_cp_library_fn): Likewise.\n+\t(grokfndecl): Tweak.\n+\t(grokdeclarator): Simplify code to compute names of overloaded\n+\toperators.  Adjust use of ansi_opname.\n+\t(ambi_op_p): Work on tree_codes, not identifiers.\n+\t(unary_op_p): Likewise.\n+\t(grok_op_properties): Likewise.\n+\t(start_function): Use DECL_OVERLOADED_OPERATOR_P.\n+\t(lang_mark_tree): Don't try to mark the operator_code.\n+\t* decl2.c (grok_function_init): Use DECL_OVERLOADED_OPERATOR_P.\n+\t* error.c (dump_decl): Remove special handling for operator\n+\tnames.\n+\t(dump_function_name): Likewise.\n+\t(dump_expr): Adjust name lookup of operators.\n+\t(op_to_string): Simplify.\n+\t(assop_to_string): Likewise.\n+\t* init.c (build_new_1): Adjust use of ansi_opname.\n+\t* lex.c (opname_tab): Remove.\n+\t(assignop_tab): Likewise.\n+\t(ansi_opname): Likewise.\n+\t(ansi_assopname): Likewise.\n+\t(operator_name_string): Likewise.\n+\t(reinit_lang_specific): Likewise.\n+\t(operator_name_info): New variable.\n+\t(assignment_operator_name_info): Likewise.\n+\t(init_operators): New function.\n+\t(init_parse): Use it.\n+\t(do_identifier): Adjust use of ansi_opname.\n+\t* method.c (mangle_expression): Don't use ansi_opname for\n+\tmangling.\n+\t(build_decl_overload_real): Use DECL_OVERLOADED_OPERATOR_P.\n+\t(build_decl_overload): Remove.\n+\t(build_typename_overload): Use OPERATOR_TYPENAME_FORMAT directly.\n+\t(do_build_assign_ref): Adjust use of ansi_opname.\n+\t(synthesize_method): Likewise.\n+\t(implicitly_declare_fn): Likewise.\n+\t* operators.def: New file.\n+\t* parse.y (operator): Adjust use of ansi_opname.\n+\t* pt.c (tsubst_decl): Use IDENTIFIER_OPNAME_P.\n+\t(set_mangled_name_for_template_decl): Don't play games with\n+\tcurrent_namespace.\n+\t(special_function_p): Adjust use of ansi_opname.\n+\t* typeck.c (check_return_expr): Likewise.\n+\t* Make-lang.in (cc1plus): Depend on operators.def.\n+\t* Makefile.in (lex.o): Likewise.\n+\t(decl.o): Likewise.\n+\n 2000-05-27  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* Make-lang.in (cplib2.ready): Eradicate."}, {"sha": "0d6fae85ceafcefb530ef226168783abc5a089de", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -123,7 +123,8 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/class.c $(srcdir)/cp/cp-tree.def \\\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o \\\n         c-pragma.o $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def \\\n-\t$(srcdir)/cp/gxx.gperf $(srcdir)/cp/cfns.gperf hash.o\n+\t$(srcdir)/cp/gxx.gperf $(srcdir)/cp/cfns.gperf hash.o \\\n+\t$(srcdir)/cp/operators.def\n \tcd cp; $(MAKE) $(LANG_FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus$(exeext)\n #\f\n # Build hooks:"}, {"sha": "5284e7d71000e6f174bc1278c3668be7ba8ae4c2", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -254,11 +254,11 @@ lex.o : lex.c $(CXX_TREE_H) \\\n   $(PARSE_H) input.c $(srcdir)/../flags.h hash.h lex.h \\\n   $(srcdir)/../c-pragma.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../output.h $(srcdir)/../mbchar.h $(GGC_H) \\\n-  $(srcdir)/../input.h\n+  $(srcdir)/../input.h operators.def\n decl.o : decl.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n   $(srcdir)/../except.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../hash.h $(GGC_H) $(RTL_H)\n+  $(srcdir)/../hash.h $(GGC_H) $(RTL_H) operators.def\n decl2.o : decl2.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(EXPR_H) $(srcdir)/../output.h $(srcdir)/../except.h \\\n   $(srcdir)/../toplev.h $(srcdir)/../dwarf2out.h $(srcdir)/../dwarfout.h \\"}, {"sha": "2bd5c81843a9e43e5585843bdbcbe197766720e6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -2257,7 +2257,7 @@ print_z_candidates (candidates)\n     {\n       if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n \t{\n-\t  if (candidates->fn == ansi_opname [COND_EXPR])\n+\t  if (TREE_VEC_LENGTH (candidates->convs) == 3)\n \t    cp_error (\"%s %D(%T, %T, %T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n@@ -2609,7 +2609,7 @@ build_object_call (obj, args)\n       return error_mark_node;\n     }\n \n-  fns = lookup_fnfields (TYPE_BINFO (type), ansi_opname [CALL_EXPR], 1);\n+  fns = lookup_fnfields (TYPE_BINFO (type), ansi_opname (CALL_EXPR), 1);\n   if (fns == error_mark_node)\n     return error_mark_node;\n \n@@ -2689,7 +2689,7 @@ build_object_call (obj, args)\n      function, we must be careful not to unconditionally look at\n      DECL_NAME here.  */\n   if (TREE_CODE (cand->fn) == FUNCTION_DECL\n-      && DECL_NAME (cand->fn) == ansi_opname [CALL_EXPR])\n+      && DECL_OVERLOADED_OPERATOR_P (cand->fn) == CALL_EXPR)\n     return build_over_call (cand, mem_args, LOOKUP_NORMAL);\n \n   obj = convert_like_with_context\n@@ -2705,8 +2705,12 @@ op_error (code, code2, arg1, arg2, arg3, problem)\n      tree arg1, arg2, arg3;\n      const char *problem;\n {\n-  const char * opname\n-    = (code == MODIFY_EXPR ? assignop_tab [code2] : opname_tab [code]);\n+  const char * opname;\n+\n+  if (code == MODIFY_EXPR)\n+    opname = assignment_operator_name_info[code2].name;\n+  else\n+    opname = operator_name_info[code].name;\n \n   switch (code)\n     {\n@@ -2987,7 +2991,7 @@ build_conditional_expr (arg1, arg2, arg3)\n       candidates = add_builtin_candidates (candidates, \n \t\t\t\t\t   COND_EXPR, \n \t\t\t\t\t   NOP_EXPR,\n-\t\t\t\t\t   ansi_opname[COND_EXPR],\n+\t\t\t\t\t   ansi_opname (COND_EXPR),\n \t\t\t\t\t   args,\n \t\t\t\t\t   LOOKUP_NORMAL);\n \n@@ -3166,10 +3170,10 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     {\n       code2 = TREE_CODE (arg3);\n       arg3 = NULL_TREE;\n-      fnname = ansi_assopname[code2];\n+      fnname = ansi_assopname (code2);\n     }\n   else\n-    fnname = ansi_opname[code];\n+    fnname = ansi_opname (code);\n \n   switch (code)\n     {\n@@ -3314,7 +3318,8 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t     one, then we fall back to the old way of doing things.  */\n \t  if (flags & LOOKUP_COMPLAIN)\n \t    cp_pedwarn (\"no `%D (int)' declared for postfix `%s', trying prefix operator instead\",\n-\t\t\tfnname, opname_tab [code]);\n+\t\t\tfnname, \n+\t\t\toperator_name_info[code].name);\n \t  if (code == POSTINCREMENT_EXPR)\n \t    code = PREINCREMENT_EXPR;\n \t  else\n@@ -3354,7 +3359,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     {\n       extern int warn_synth;\n       if (warn_synth\n-\t  && fnname == ansi_opname[MODIFY_EXPR]\n+\t  && fnname == ansi_assopname (NOP_EXPR)\n \t  && DECL_ARTIFICIAL (cand->fn)\n \t  && candidates->next\n \t  && ! candidates->next->next)\n@@ -3516,7 +3521,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n     return error_mark_node;\n \n   type = TREE_TYPE (TREE_TYPE (addr));\n-  fnname = ansi_opname[code];\n+  fnname = ansi_opname (code);\n \n   if (IS_AGGR_TYPE (type) && ! (flags & LOOKUP_GLOBAL))\n     /* In [class.free]\n@@ -4137,7 +4142,7 @@ build_over_call (cand, args, flags)\n \t  return address;\n \t}\n     }\n-  else if (DECL_NAME (fn) == ansi_opname[MODIFY_EXPR]\n+  else if (DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n \t   && copy_args_p (fn)\n \t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CONTEXT (fn)))\n     {\n@@ -5123,7 +5128,7 @@ joust (cand1, cand2, warn)\n       /* Kludge around broken overloading rules whereby\n \t Integer a, b; test ? a : b; is ambiguous, since there's a builtin\n \t that takes references and another that takes values.  */\n-      if (cand1->fn == ansi_opname[COND_EXPR])\n+      if (DECL_OVERLOADED_OPERATOR_P (cand1->fn) == COND_EXPR)\n \t{\n \t  tree c1 = TREE_VEC_ELT (cand1->convs, 1);\n \t  tree c2 = TREE_VEC_ELT (cand2->convs, 1);"}, {"sha": "347cde81e50ea40a8ae0c107caa003f18970f5f8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -1012,8 +1012,11 @@ extern tree current_function_return_value;\n extern tree global_namespace;\n \n extern tree ridpointers[];\n-extern tree ansi_opname[];\n-extern tree ansi_assopname[];\n+\n+#define ansi_opname(CODE) \\\n+  (operator_name_info[(int) (CODE)].identifier)\n+#define ansi_assopname(CODE) \\\n+  (assignment_operator_name_info[(int) (CODE)].identifier)\n \n /* Nonzero means `$' can be in an identifier.  */\n \n@@ -1864,7 +1867,8 @@ struct lang_decl_flags\n   unsigned global_ctor_p : 1;\n   unsigned global_dtor_p : 1;\n   unsigned tinfo_fn_p : 1;\n-  unsigned dummy : 4;\n+  unsigned assignment_operator_p : 1;\n+  unsigned dummy : 3;\n \n   tree context;\n \n@@ -1903,15 +1907,21 @@ struct lang_decl\n   /* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n   tree cloned_function;\n \n-  /* In a FUNCTION_DECL, this is VTT_PARM.  */\n-  tree vtt_parm;\n-\n   union\n   {\n     tree sorted_fields;\n     struct pending_inline *pending_inline_info;\n     struct language_function *saved_language_function;\n   } u;\n+\n+  union {\n+    /* In an overloaded operator, this is the value of\n+       DECL_OVERLOADED_OPERATOR_P.  */\n+    enum tree_code operator_code;\n+    /* In a maybe-in-charge constructor or destructor, this is\n+       DECL_VTT_PARM.  */\n+    tree vtt_parm;\n+  } u2;\n };\n \n /* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n@@ -1997,7 +2007,7 @@ struct lang_decl\n /* In a maybe-in-charge constructor or destructor, this is the VTT\n    parameter.  It's not actually on the DECL_ARGUMENTS list.  */\n #define DECL_VTT_PARM(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->vtt_parm)\n+  (DECL_LANG_SPECIFIC (NODE)->u2.vtt_parm)\n \n /* If there's a DECL_VTT_PARM, this is a magic variable that indicates\n    whether or not the VTT parm should be used.  In a subobject\n@@ -2017,9 +2027,24 @@ struct lang_decl\n #define DECL_CONV_FN_P(NODE) \\\n   (IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)))\n \n-/* Non-zero if NODE is an overloaded operator.  */\n-#define DECL_OVERLOADED_OPERATOR_P(NODE)\t\\\n-  (IDENTIFIER_OPNAME_P (DECL_NAME ((NODE))))\n+/* Set the overloaded operator code for NODE to CODE.  */\n+#define SET_OVERLOADED_OPERATOR_CODE(NODE, CODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->u2.operator_code = (CODE))\n+\n+/* If NODE is an overloaded operator, then this returns the TREE_CODE\n+   associcated with the overloaded operator.\n+   DECL_ASSIGNMENT_OPERATOR_P must also be checked to determine\n+   whether or not NODE is an assignment operator.  If NODE is not an\n+   overloaded operator, ERROR_MARK is returned.  Since the numerical\n+   value of ERROR_MARK is zero, this macro can be used as a predicate\n+   to test whether or not NODE is an overloaded operator.  */\n+#define DECL_OVERLOADED_OPERATOR_P(NODE)       \t\t\\\n+  (IDENTIFIER_OPNAME_P (DECL_NAME ((NODE)))\t\t\\\n+   ? DECL_LANG_SPECIFIC (NODE)->u2.operator_code : ERROR_MARK)\n+\n+/* Non-zero if NODE is an assignment operator.  */\n+#define DECL_ASSIGNMENT_OPERATOR_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.assignment_operator_p)\n \n /* For FUNCTION_DECLs: nonzero means that this function is a\n    constructor or a destructor with an extra in-charge parameter to\n@@ -2040,7 +2065,7 @@ struct lang_decl\n \n /* Nonzero if NODE is an overloaded `operator delete[]' function.  */\n #define DECL_ARRAY_DELETE_OPERATOR_P(NODE) \\\n-  (DECL_NAME (NODE) == ansi_opname[(int) VEC_DELETE_EXPR])\n+  (DECL_OVERLOADED_OPERATOR_P (NODE) == VEC_DELETE_EXPR)\n \n /* Nonzero for _DECL means that this decl appears in (or will appear\n    in) as a member in a RECORD_TYPE or UNION_TYPE node.  It is also for\n@@ -3794,10 +3819,22 @@ enum tree_string_flags\n };\n \n /* in lex.c  */\n-/* Indexed by TREE_CODE, these tables give C-looking names to\n-   operators represented by TREE_CODES.  For example,\n-   opname_tab[(int) MINUS_EXPR] == \"-\".  */\n-extern const char **opname_tab, **assignop_tab;\n+\n+typedef struct operator_name_info_t\n+{\n+  /* The IDENTIFIER_NODE for the operator.  */\n+  tree identifier;\n+  /* The name of the operator.  */\n+  const char *name;\n+  /* The mangled name of the operator.  */\n+  const char *mangled_name;\n+} operator_name_info_t;\n+\n+/* A mapping from tree codes to operator name information.  */\n+extern operator_name_info_t operator_name_info[];\n+/* Similar, but for assignment operators.  */\n+extern operator_name_info_t assignment_operator_name_info[];\n+\n \f\n /* in call.c */\n extern int check_dtor_name\t\t\tPARAMS ((tree, tree));\n@@ -3959,11 +3996,9 @@ extern tree unqualified_namespace_lookup\tPARAMS ((tree, int, tree *));\n extern int  lookup_using_namespace              PARAMS ((tree, tree, tree, tree, int, tree *));\n extern int  qualified_lookup_using_namespace    PARAMS ((tree, tree, tree, int));\n extern tree build_library_fn\t\t\tPARAMS ((tree, tree));\n-extern tree build_cp_library_fn\t\t\tPARAMS ((tree, tree));\n extern tree build_library_fn_ptr\t\tPARAMS ((const char *, tree));\n extern tree build_cp_library_fn_ptr\t\tPARAMS ((const char *, tree));\n extern tree push_library_fn\t\t\tPARAMS ((tree, tree));\n-extern tree push_cp_library_fn\t\t\tPARAMS ((tree, tree));\n extern tree push_void_library_fn\t\tPARAMS ((tree, tree));\n extern tree push_throw_library_fn\t\tPARAMS ((tree, tree));\n extern void init_decl_processing\t\tPARAMS ((void));\n@@ -4184,7 +4219,6 @@ extern tree make_pointer_declarator\t\tPARAMS ((tree, tree));\n extern tree make_reference_declarator\t\tPARAMS ((tree, tree));\n extern tree make_call_declarator\t\tPARAMS ((tree, tree, tree, tree));\n extern void set_quals_and_spec\t\t\tPARAMS ((tree, tree, tree));\n-extern const char *operator_name_string\t\tPARAMS ((tree));\n extern void lang_init\t\t\t\tPARAMS ((void));\n extern void lang_finish\t\t\t\tPARAMS ((void));\n #if 0\n@@ -4234,7 +4268,6 @@ extern int cp_type_qual_from_rid                PARAMS ((tree));\n extern void init_method\t\t\t\tPARAMS ((void));\n extern char *build_overload_name\t\tPARAMS ((tree, int, int));\n extern tree build_static_name\t\t\tPARAMS ((tree, tree));\n-extern tree build_decl_overload\t\t\tPARAMS ((tree, tree, int));\n extern tree build_decl_overload_real            PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t       tree, int)); \n extern void set_mangled_name_for_decl           PARAMS ((tree));"}, {"sha": "25270d465241e609fce4181cfa748b00f87e0c6f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 223, "deletions": 114, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -108,8 +108,8 @@ static void signal_catch PARAMS ((int)) ATTRIBUTE_NORETURN;\n static int decl_jump_unsafe PARAMS ((tree));\n static void storedecls PARAMS ((tree));\n static void require_complete_types_for_parms PARAMS ((tree));\n-static int ambi_op_p PARAMS ((tree));\n-static int unary_op_p PARAMS ((tree));\n+static int ambi_op_p PARAMS ((enum tree_code));\n+static int unary_op_p PARAMS ((enum tree_code));\n static tree store_bindings PARAMS ((tree, tree));\n static tree lookup_tag_reverse PARAMS ((tree, tree));\n static tree obscure_complex_init PARAMS ((tree, tree));\n@@ -126,7 +126,7 @@ static void set_identifier_type_value_with_scope\n \tPARAMS ((tree, tree, struct binding_level *));\n static void record_builtin_type PARAMS ((enum rid, const char *, tree));\n static void record_unknown_type PARAMS ((tree, const char *));\n-static tree build_library_fn_1\t\t\tPARAMS ((tree, tree));\n+static tree build_library_fn_1 PARAMS ((tree, enum tree_code, tree));\n static int member_function_or_else PARAMS ((tree, tree, enum overload_flags));\n static void bad_specifiers PARAMS ((tree, const char *, int, int, int, int,\n \t\t\t\t  int));\n@@ -186,6 +186,8 @@ static tree cp_make_fname_decl PARAMS ((tree, const char *, int));\n static void initialize_predefined_identifiers PARAMS ((void));\n static tree check_special_function_return_type \n   PARAMS ((special_function_kind, tree, tree, tree));\n+static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n+static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PARAMS ((void));\n@@ -3425,7 +3427,7 @@ duplicate_decls (newdecl, olddecl)\n       DECL_VIRTUAL_P (newdecl) |= DECL_VIRTUAL_P (olddecl);\n       DECL_NEEDS_FINAL_OVERRIDER_P (newdecl) |= DECL_NEEDS_FINAL_OVERRIDER_P (olddecl);\n       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);\n-      DECL_VTT_PARM (newdecl) = DECL_VTT_PARM (olddecl);\n+      DECL_LANG_SPECIFIC (newdecl)->u2 = DECL_LANG_SPECIFIC (olddecl)->u2;\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n \n       /* Optionally warn about more than one declaration for the same\n@@ -6596,11 +6598,10 @@ init_decl_processing ()\n     newtype = build_exception_variant\n       (ptr_ftype_sizetype, add_exception_specifier (NULL_TREE, bad_alloc_type_node, -1));\n     deltype = build_exception_variant (void_ftype_ptr, empty_except_spec);\n-    push_cp_library_fn (ansi_opname[(int) NEW_EXPR], newtype);\n-    push_cp_library_fn (ansi_opname[(int) VEC_NEW_EXPR], newtype);\n-    global_delete_fndecl = push_cp_library_fn (ansi_opname[(int) DELETE_EXPR],\n-\t\t\t\t\t       deltype);\n-    push_cp_library_fn (ansi_opname[(int) VEC_DELETE_EXPR], deltype);\n+    push_cp_library_fn (NEW_EXPR, newtype);\n+    push_cp_library_fn (VEC_NEW_EXPR, newtype);\n+    global_delete_fndecl = push_cp_library_fn (DELETE_EXPR, deltype);\n+    push_cp_library_fn (VEC_DELETE_EXPR, deltype);\n   }\n \n   abort_fndecl\n@@ -6756,7 +6757,7 @@ builtin_function (name, type, code, class, libname)\n      enum built_in_class class;\n      const char *libname;\n {\n-  tree decl = build_library_fn_1 (get_identifier (name), type);\n+  tree decl = build_library_fn_1 (get_identifier (name), ERROR_MARK, type);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = code;\n \n@@ -6776,15 +6777,17 @@ builtin_function (name, type, code, class, libname)\n    function.  Not called directly.  */\n \n static tree\n-build_library_fn_1 (name, type)\n+build_library_fn_1 (name, operator_code, type)\n      tree name;\n+     enum tree_code operator_code;\n      tree type;\n {\n   tree fn = build_lang_decl (FUNCTION_DECL, name, type);\n   DECL_EXTERNAL (fn) = 1;\n   TREE_PUBLIC (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n   TREE_NOTHROW (fn) = 1;\n+  SET_OVERLOADED_OPERATOR_CODE (fn, operator_code);\n   return fn;\n }\n \n@@ -6797,19 +6800,20 @@ build_library_fn (name, type)\n      tree name;\n      tree type;\n {\n-  tree fn = build_library_fn_1 (name, type);\n+  tree fn = build_library_fn_1 (name, ERROR_MARK, type);\n   make_function_rtl (fn);\n   return fn;\n }\n \n /* Returns the _DECL for a library function with C++ linkage.  */\n \n-tree\n-build_cp_library_fn (name, type)\n+static tree\n+build_cp_library_fn (name, operator_code, type)\n      tree name;\n+     enum tree_code operator_code;\n      tree type;\n {\n-  tree fn = build_library_fn_1 (name, type);\n+  tree fn = build_library_fn_1 (name, operator_code, type);\n   TREE_NOTHROW (fn) = TYPE_NOTHROW_P (type);\n   set_mangled_name_for_decl (fn);\n   make_function_rtl (fn);\n@@ -6835,7 +6839,7 @@ build_cp_library_fn_ptr (name, type)\n      const char *name;\n      tree type;\n {\n-  return build_cp_library_fn (get_identifier (name), type);\n+  return build_cp_library_fn (get_identifier (name), ERROR_MARK, type);\n }\n \n /* Like build_library_fn, but also pushes the function so that we will\n@@ -6853,12 +6857,14 @@ push_library_fn (name, type)\n /* Like build_cp_library_fn, but also pushes the function so that it\n    will be found by normal lookup.  */\n \n-tree\n-push_cp_library_fn (name, type)\n-     tree name;\n+static tree\n+push_cp_library_fn (operator_code, type)\n+     enum tree_code operator_code;\n      tree type;\n {\n-  tree fn = build_cp_library_fn (name, type);\n+  tree fn = build_cp_library_fn (ansi_opname (operator_code), \n+\t\t\t\t operator_code,\n+\t\t\t\t type);\n   pushdecl (fn);\n   return fn;\n }\n@@ -8892,7 +8898,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       quals = NULL_TREE;\n     }\n \n-  if (DECL_OVERLOADED_OPERATOR_P (decl))\n+  if (IDENTIFIER_OPNAME_P (DECL_NAME (decl)))\n     grok_op_properties (decl, virtualp, check < 0);\n \n   if (ctype && decl_function_context (decl))\n@@ -9794,18 +9800,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t  dname);\n \t\tname = IDENTIFIER_POINTER (dname);\n \t      }\n-\t    else if (!IDENTIFIER_OPNAME_P (dname))\n+\t    else if (!IDENTIFIER_TYPENAME_P (dname))\n \t      name = IDENTIFIER_POINTER (dname);\n \t    else\n \t      {\n-\t\tif (IDENTIFIER_TYPENAME_P (dname))\n-\t\t  {\n-\t\t    my_friendly_assert (flags == NO_SPECIAL, 154);\n-\t\t    flags = TYPENAME_FLAG;\n-\t\t    ctor_return_type = TREE_TYPE (dname);\n-\t\t    sfk = sfk_conversion;\n-\t\t  }\n-\t\tname = operator_name_string (dname);\n+\t\tmy_friendly_assert (flags == NO_SPECIAL, 154);\n+\t\tflags = TYPENAME_FLAG;\n+\t\tctor_return_type = TREE_TYPE (dname);\n+\t\tsfk = sfk_conversion;\n+\t\tif (IDENTIFIER_GLOBAL_VALUE (dname)\n+\t\t    && (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (dname)) \n+\t\t\t== TYPE_DECL))\n+\t\t  name = IDENTIFIER_POINTER (dname);\n+\t\telse\n+\t\t  name = \"<invalid operator>\";\n \t      }\n \t    break;\n \n@@ -10369,10 +10377,19 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  else\n \t\t    tmp = TREE_OPERAND (declarator, 0);\n \t\t  op = IDENTIFIER_OPNAME_P (tmp);\n+\t\t  if (IDENTIFIER_TYPENAME_P (tmp))\n+\t\t    {\n+\t\t      if (IDENTIFIER_GLOBAL_VALUE (tmp)\n+\t\t\t  && (TREE_CODE (IDENTIFIER_GLOBAL_VALUE (tmp)) \n+\t\t\t      == TYPE_DECL))\n+\t\t\tname = IDENTIFIER_POINTER (tmp);\n+\t\t      else\n+\t\t\tname = \"<invalid operator>\";\n+\t\t    }\n \t\t}\n \t      error (\"storage class specified for %s `%s'\",\n \t\t     op ? \"member operator\" : \"field\",\n-\t\t     op ? operator_name_string (tmp) : name);\n+\t\t     name);\n \t    }\n \t  else\n \t    {\n@@ -11356,10 +11373,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    return void_type_node;\n \t\t  }\n \n-\t\tif (declarator == ansi_opname[(int) NEW_EXPR]\n-\t\t    || declarator == ansi_opname[(int) VEC_NEW_EXPR]\n-\t\t    || declarator == ansi_opname[(int) DELETE_EXPR]\n-\t\t    || declarator == ansi_opname[(int) VEC_DELETE_EXPR])\n+\t\tif (declarator == ansi_opname (NEW_EXPR)\n+\t\t    || declarator == ansi_opname (VEC_NEW_EXPR)\n+\t\t    || declarator == ansi_opname (DELETE_EXPR)\n+\t\t    || declarator == ansi_opname (VEC_DELETE_EXPR))\n \t\t  {\n \t\t    if (virtualp)\n \t\t      {\n@@ -12225,30 +12242,30 @@ grok_ctor_properties (ctype, decl)\n   return 1;\n }\n \n-/* An operator with this name can be either unary or binary.  */\n+/* An operator with this code is unary, but can also be binary.  */\n \n static int\n-ambi_op_p (name)\n-     tree name;\n+ambi_op_p (code)\n+     enum tree_code code;\n {\n-  return (name == ansi_opname [(int) INDIRECT_REF]\n-\t  || name == ansi_opname [(int) ADDR_EXPR]\n-\t  || name == ansi_opname [(int) NEGATE_EXPR]\n-\t  || name == ansi_opname[(int) POSTINCREMENT_EXPR]\n-\t  || name == ansi_opname[(int) POSTDECREMENT_EXPR]\n-\t  || name == ansi_opname [(int) CONVERT_EXPR]);\n+  return (code == INDIRECT_REF\n+\t  || code == ADDR_EXPR\n+\t  || code == CONVERT_EXPR\n+\t  || code == NEGATE_EXPR\n+\t  || code == PREINCREMENT_EXPR\n+\t  || code == PREDECREMENT_EXPR);\n }\n \n /* An operator with this name can only be unary.  */\n \n static int\n-unary_op_p (name)\n-     tree name;\n+unary_op_p (code)\n+     enum tree_code code;\n {\n-  return (name == ansi_opname [(int) TRUTH_NOT_EXPR]\n-\t  || name == ansi_opname [(int) BIT_NOT_EXPR]\n-\t  || name == ansi_opname [(int) COMPONENT_REF]\n-\t  || IDENTIFIER_TYPENAME_P (name));\n+  return (code == TRUTH_NOT_EXPR\n+\t  || code == BIT_NOT_EXPR\n+\t  || code == COMPONENT_REF\n+\t  || code == TYPE_EXPR);\n }\n \n /* Do a little sanity-checking on how they declared their operator.  */\n@@ -12259,43 +12276,87 @@ grok_op_properties (decl, virtualp, friendp)\n      int virtualp, friendp;\n {\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+  tree argtype;\n   int methodp = (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n   tree name = DECL_NAME (decl);\n+  enum tree_code operator_code;\n+  int arity;\n+\n+  /* Count the number of arguments.  */\n+  for (argtype = argtypes, arity = 0;\n+       argtype && argtype != void_list_node;\n+       argtype = TREE_CHAIN (argtype))\n+    ++arity;\n \n   if (current_class_type == NULL_TREE)\n     friendp = 1;\n \n+  if (DECL_CONV_FN_P (decl))\n+    operator_code = TYPE_EXPR;\n+  else\n+    do\n+      {\n+#define DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGING, ARITY, ASSN_P)  \\\n+\tif (ansi_opname (CODE) == name)\t\t\t\t\t    \\\n+\t  {\t\t\t\t\t\t\t\t    \\\n+\t    operator_code = CODE;\t\t\t\t\t    \\\n+\t    break;\t\t\t\t\t\t\t    \\\n+\t  }\t\t\t\t\t\t\t\t    \\\n+\telse if (ansi_assopname (CODE) == name)\t\t\t\t    \\\n+\t  {\t\t\t\t\t\t\t\t    \\\n+\t    operator_code = CODE;\t\t\t\t\t    \\\n+\t    DECL_ASSIGNMENT_OPERATOR_P (decl) = 1;\t\t\t    \\\n+\t    break;\t\t\t\t\t\t\t    \\\n+\t  }\n+\n+#include \"operators.def\"\n+#undef DEF_OPERATOR\n+\n+\tmy_friendly_abort (20000527);\n+      }\n+    while (0);\n+  my_friendly_assert (operator_code != LAST_CPLUS_TREE_CODE, 20000526);\n+  SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n+\n   if (! friendp)\n     {\n-      /* [class.copy]\n+      switch (operator_code)\n+\t{\n+\tcase CALL_EXPR:\n+\t  TYPE_OVERLOADS_CALL_EXPR (current_class_type) = 1;\n+\t  break;\n+\t  \n+\tcase ARRAY_REF:\n+\t  TYPE_OVERLOADS_ARRAY_REF (current_class_type) = 1;\n+\t  break;\n \n-\t A user-declared copy assignment operator X::operator= is a\n-\t non-static non-template member function of class X with\n-\t exactly one parameter of type X, X&, const X&, volatile X& or\n-\t const volatile X&.  */\n-      if (name == ansi_opname[(int) MODIFY_EXPR]\n-\t  && !(DECL_TEMPLATE_INSTANTIATION (decl)\n-\t       && is_member_template (DECL_TI_TEMPLATE (decl))))\n-\t;\n-      else if (name == ansi_opname[(int) CALL_EXPR])\n-\tTYPE_OVERLOADS_CALL_EXPR (current_class_type) = 1;\n-      else if (name == ansi_opname[(int) ARRAY_REF])\n-\tTYPE_OVERLOADS_ARRAY_REF (current_class_type) = 1;\n-      else if (name == ansi_opname[(int) COMPONENT_REF]\n-\t       || name == ansi_opname[(int) MEMBER_REF])\n-\tTYPE_OVERLOADS_ARROW (current_class_type) = 1;\n-      else if (name == ansi_opname[(int) NEW_EXPR])\n-\tTYPE_HAS_NEW_OPERATOR (current_class_type) = 1;\n-      else if (name == ansi_opname[(int) DELETE_EXPR])\n-\tTYPE_GETS_DELETE (current_class_type) |= 1;\n-      else if (name == ansi_opname[(int) VEC_NEW_EXPR])\n-\tTYPE_HAS_ARRAY_NEW_OPERATOR (current_class_type) = 1;\n-      else if (name == ansi_opname[(int) VEC_DELETE_EXPR])\n-\tTYPE_GETS_DELETE (current_class_type) |= 2;\n-    }\n-\n-  if (name == ansi_opname[(int) NEW_EXPR]\n-      || name == ansi_opname[(int) VEC_NEW_EXPR])\n+\tcase COMPONENT_REF:\n+\tcase MEMBER_REF:\n+\t  TYPE_OVERLOADS_ARROW (current_class_type) = 1;\n+\t  break;\n+\t  \n+\tcase NEW_EXPR:\n+\t  TYPE_HAS_NEW_OPERATOR (current_class_type) = 1;\n+\t  break;\n+\t  \n+\tcase DELETE_EXPR:\n+\t  TYPE_GETS_DELETE (current_class_type) |= 1;\n+\t  break;\n+\t  \n+\tcase VEC_NEW_EXPR:\n+\t  TYPE_HAS_ARRAY_NEW_OPERATOR (current_class_type) = 1;\n+\t  break;\n+\t  \n+\tcase VEC_DELETE_EXPR:\n+\t  TYPE_GETS_DELETE (current_class_type) |= 2;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  if (operator_code == NEW_EXPR || operator_code == VEC_NEW_EXPR)\n     {\n       /* When the compiler encounters the definition of A::operator new, it\n \t doesn't look at the class declaration to find out if it's static.  */\n@@ -12311,8 +12372,7 @@ grok_op_properties (decl, virtualp, friendp)\n       else\n \tTREE_TYPE (decl) = coerce_new_type (TREE_TYPE (decl));\n     }\n-  else if (name == ansi_opname[(int) DELETE_EXPR]\n-\t   || name == ansi_opname[(int) VEC_DELETE_EXPR])\n+  else if (operator_code == DELETE_EXPR || operator_code == VEC_DELETE_EXPR)\n     {\n       if (methodp)\n \trevert_static_member_fn (decl);\n@@ -12332,11 +12392,11 @@ grok_op_properties (decl, virtualp, friendp)\n \t an enumeration, or a reference to an enumeration.  13.4.0.6 */\n       if (! methodp || DECL_STATIC_FUNCTION_P (decl))\n \t{\n-\t  if (DECL_CONV_FN_P (decl)\n-\t      || name == ansi_opname[(int) CALL_EXPR]\n-\t      || name == ansi_opname[(int) MODIFY_EXPR]\n-\t      || name == ansi_opname[(int) COMPONENT_REF]\n-\t      || name == ansi_opname[(int) ARRAY_REF])\n+\t  if (operator_code == TYPE_EXPR\n+\t      || operator_code == CALL_EXPR\n+\t      || operator_code == COMPONENT_REF\n+\t      || operator_code == ARRAY_REF\n+\t      || operator_code == NOP_EXPR)\n \t    cp_error (\"`%D' must be a nonstatic member function\", decl);\n \t  else\n \t    {\n@@ -12367,7 +12427,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    }\n \t}\n \n-      if (name == ansi_opname[(int) CALL_EXPR])\n+      if (operator_code == CALL_EXPR)\n \treturn;\t\t\t/* No restrictions on args. */\n \n       if (IDENTIFIER_TYPENAME_P (name) && ! DECL_TEMPLATE_INFO (decl))\n@@ -12397,18 +12457,27 @@ grok_op_properties (decl, virtualp, friendp)\n \t    }\n \t}\n \n-      if (name == ansi_opname[(int) MODIFY_EXPR])\n+      if (DECL_ASSIGNMENT_OPERATOR_P (decl) \n+\t  && operator_code == NOP_EXPR)\n \t{\n \t  tree parmtype;\n \n-\t  if (list_length (argtypes) != 3 && methodp)\n+\t  if (arity != 2 && methodp)\n \t    {\n \t      cp_error (\"`%D' must take exactly one argument\", decl);\n \t      return;\n \t    }\n \t  parmtype = TREE_VALUE (TREE_CHAIN (argtypes));\n \n+\t  /* [class.copy]\n+\n+\t     A user-declared copy assignment operator X::operator= is\n+\t     a non-static non-template member function of class X with\n+\t     exactly one parameter of type X, X&, const X&, volatile\n+\t     X& or const volatile X&.  */\n \t  if (copy_assignment_arg_p (parmtype, virtualp)\n+\t      && !(DECL_TEMPLATE_INSTANTIATION (decl)\n+\t\t   && is_member_template (DECL_TI_TEMPLATE (decl)))\n \t      && ! friendp)\n \t    {\n \t      TYPE_HAS_ASSIGN_REF (current_class_type) = 1;\n@@ -12417,19 +12486,55 @@ grok_op_properties (decl, virtualp, friendp)\n \t\tTYPE_HAS_CONST_ASSIGN_REF (current_class_type) = 1;\n \t    }\n \t}\n-      else if (name == ansi_opname[(int) COND_EXPR])\n+      else if (operator_code == COND_EXPR)\n \t{\n \t  /* 13.4.0.3 */\n \t  cp_error (\"ISO C++ prohibits overloading operator ?:\");\n \t}\n-      else if (ambi_op_p (name))\n+      else if (ambi_op_p (operator_code))\n \t{\n-\t  if (list_length (argtypes) == 2)\n-\t    /* prefix */;\n-\t  else if (list_length (argtypes) == 3)\n+\t  if (arity == 1)\n+\t    /* We pick the one-argument operator codes by default, so\n+\t       we don't have to change anything.  */\n+\t    ;\n+\t  else if (arity == 2)\n \t    {\n-\t      if ((name == ansi_opname[(int) POSTINCREMENT_EXPR]\n-\t\t   || name == ansi_opname[(int) POSTDECREMENT_EXPR])\n+\t      /* If we thought this was a unary operator, we now know\n+\t\t it to be a binary operator.  */\n+\t      switch (operator_code)\n+\t\t{\n+\t\tcase INDIRECT_REF:\n+\t\t  operator_code = MULT_EXPR;\n+\t\t  break;\n+\n+\t\tcase ADDR_EXPR:\n+\t\t  operator_code = BIT_AND_EXPR;\n+\t\t  break;\n+\n+\t\tcase CONVERT_EXPR:\n+\t\t  operator_code = PLUS_EXPR;\n+\t\t  break;\n+\n+\t\tcase NEGATE_EXPR:\n+\t\t  operator_code = MINUS_EXPR;\n+\t\t  break;\n+\n+\t\tcase PREINCREMENT_EXPR:\n+\t\t  operator_code = POSTINCREMENT_EXPR;\n+\t\t  break;\n+\n+\t\tcase PREDECREMENT_EXPR:\n+\t\t  operator_code = PREDECREMENT_EXPR;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  my_friendly_abort (20000527);\n+\t\t}\n+\n+\t      SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n+\n+\t      if ((operator_code == POSTINCREMENT_EXPR\n+\t\t   || operator_code == POSTDECREMENT_EXPR)\n \t\t  && ! processing_template_decl\n \t\t  && ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)), integer_type_node))\n \t\t{\n@@ -12452,15 +12557,18 @@ grok_op_properties (decl, virtualp, friendp)\n \n \t  /* More Effective C++ rule 6.  */\n \t  if (warn_ecpp\n-\t      && (name == ansi_opname[(int) POSTINCREMENT_EXPR]\n-\t\t  || name == ansi_opname[(int) POSTDECREMENT_EXPR]))\n+\t      && (operator_code == POSTINCREMENT_EXPR\n+\t\t  || operator_code == POSTDECREMENT_EXPR\n+\t\t  || operator_code == PREINCREMENT_EXPR\n+\t\t  || operator_code == PREDECREMENT_EXPR))\n \t    {\n \t      tree arg = TREE_VALUE (argtypes);\n \t      tree ret = TREE_TYPE (TREE_TYPE (decl));\n \t      if (methodp || TREE_CODE (arg) == REFERENCE_TYPE)\n \t\targ = TREE_TYPE (arg);\n \t      arg = TYPE_MAIN_VARIANT (arg);\n-\t      if (list_length (argtypes) == 2)\n+\t      if (operator_code == PREINCREMENT_EXPR\n+\t\t  || operator_code == PREDECREMENT_EXPR)\n \t\t{\n \t\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n \t\t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n@@ -12475,19 +12583,19 @@ grok_op_properties (decl, virtualp, friendp)\n \t\t}\n \t    }\n \t}\n-      else if (unary_op_p (name))\n+      else if (unary_op_p (operator_code))\n \t{\n-\t  if (list_length (argtypes) != 2)\n+\t  if (arity != 1)\n \t    {\n \t      if (methodp)\n \t\tcp_error (\"`%D' must take `void'\", decl);\n \t      else\n \t\tcp_error (\"`%D' must take exactly one argument\", decl);\n \t    }\n \t}\n-      else /* if (binary_op_p (name)) */\n+      else /* if (binary_op_p (operator_code)) */\n \t{\n-\t  if (list_length (argtypes) != 3)\n+\t  if (arity != 2)\n \t    {\n \t      if (methodp)\n \t\tcp_error (\"`%D' must take exactly one argument\", decl);\n@@ -12497,20 +12605,20 @@ grok_op_properties (decl, virtualp, friendp)\n \n \t  /* More Effective C++ rule 7.  */\n \t  if (warn_ecpp\n-\t      && (name == ansi_opname [TRUTH_ANDIF_EXPR]\n-\t\t  || name == ansi_opname [TRUTH_ORIF_EXPR]\n-\t\t  || name == ansi_opname [COMPOUND_EXPR]))\n+\t      && (operator_code == TRUTH_ANDIF_EXPR\n+\t\t  || operator_code == TRUTH_ORIF_EXPR\n+\t\t  || operator_code == COMPOUND_EXPR))\n \t    cp_warning (\"user-defined `%D' always evaluates both arguments\",\n \t\t\tdecl);\n \t}\n \n       /* Effective C++ rule 23.  */\n       if (warn_ecpp\n-\t  && list_length (argtypes) == 3\n-\t  && (name == ansi_opname [PLUS_EXPR]\n-\t      || name == ansi_opname [MINUS_EXPR]\n-\t      || name == ansi_opname [TRUNC_DIV_EXPR]\n-\t      || name == ansi_opname [MULT_EXPR])\n+\t  && arity == 2\n+\t  && (operator_code == PLUS_EXPR\n+\t      || operator_code == MINUS_EXPR\n+\t      || operator_code == TRUNC_DIV_EXPR\n+\t      || operator_code == MULT_EXPR)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n \tcp_warning (\"`%D' should return by value\", decl);\n \n@@ -12520,8 +12628,8 @@ grok_op_properties (decl, virtualp, friendp)\n         if (TREE_PURPOSE (argtypes))\n           {\n             TREE_PURPOSE (argtypes) = NULL_TREE;\n-            if (name == ansi_opname[(int) POSTINCREMENT_EXPR] \n-                || name == ansi_opname[(int) POSTDECREMENT_EXPR])   \n+            if (operator_code == POSTINCREMENT_EXPR\n+\t\t|| operator_code == POSTDECREMENT_EXPR)\n               {\n                 if (pedantic)\n                   cp_pedwarn (\"`%D' cannot have default arguments\", decl);\n@@ -13464,7 +13572,7 @@ start_function (declspecs, declarator, attrs, flags)\n \n   /* Effective C++ rule 15.  See also c_expand_return.  */\n   if (warn_ecpp\n-      && DECL_NAME (decl1) == ansi_opname[(int) MODIFY_EXPR]\n+      && DECL_OVERLOADED_OPERATOR_P (decl1) == NOP_EXPR\n       && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)\n     cp_warning (\"`operator=' should return a reference to `*this'\");\n \n@@ -14896,7 +15004,8 @@ lang_mark_tree (t)\n \t      ggc_mark_tree (ld->befriending_classes);\n \t      ggc_mark_tree (ld->saved_tree);\n \t      ggc_mark_tree (ld->cloned_function);\n-\t      ggc_mark_tree (ld->vtt_parm);\n+\t      if (!DECL_OVERLOADED_OPERATOR_P (t))\n+\t\tggc_mark_tree (ld->u2.vtt_parm);\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tggc_mark_tree (ld->u.sorted_fields);\n \t      else if (TREE_CODE (t) == FUNCTION_DECL"}, {"sha": "6a90a0a0dbb97b17cd287f2f20edd5a6555a3e27", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -1960,7 +1960,7 @@ grok_function_init (decl, init)\n \t}\n #endif\n       DECL_PURE_VIRTUAL_P (decl) = 1;\n-      if (DECL_NAME (decl) == ansi_opname [(int) MODIFY_EXPR])\n+      if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n \t{\n \t  tree parmtype\n \t    = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl))));"}, {"sha": "f4c116be161fa740183f78cdfca487164084870c", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -945,14 +945,6 @@ dump_decl (t, flags)\n \t    dump_type (TREE_TYPE (t), flags);\n \t    break;\n \t  }\n-\telse if (IDENTIFIER_OPNAME_P (t))\n-\t  {\n-\t    const char *name_string = operator_name_string (t);\n-\t    OB_PUTS (\"operator\");\n-\t    if (ISALPHA (name_string[0]))\n-\t      OB_PUTC (' ');\n-\t    OB_PUTCP (name_string);\n-\t  }\n \telse\n \t  OB_PUTID (t);\n       }\n@@ -1278,13 +1270,7 @@ dump_function_name (t, flags)\n       dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n   else if (IDENTIFIER_OPNAME_P (name))\n-    {\n-      const char *name_string = operator_name_string (name);\n-      OB_PUTS (\"operator\");\n-      if (ISALPHA (name_string[0]))\n-\tOB_PUTC (' ');\n-      OB_PUTCP (name_string);\n-    }\n+    OB_PUTID (name);\n   else\n     dump_decl (name, flags);\n \n@@ -1694,7 +1680,7 @@ dump_expr (t, flags)\n     case EQ_EXPR:\n     case NE_EXPR:\n     case EXACT_DIV_EXPR:\n-      dump_binary_op (opname_tab[(int) TREE_CODE (t)], t, flags);\n+      dump_binary_op (operator_name_info[(int) TREE_CODE (t)].name, t, flags);\n       break;\n \n     case CEIL_DIV_EXPR:\n@@ -1782,14 +1768,14 @@ dump_expr (t, flags)\n     case TRUTH_NOT_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-      dump_unary_op (opname_tab [(int)TREE_CODE (t)], t, flags);\n+      dump_unary_op (operator_name_info [(int)TREE_CODE (t)].name, t, flags);\n       break;\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n       OB_PUTC ('(');\n       dump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n-      OB_PUTCP (opname_tab[(int)TREE_CODE (t)]);\n+      OB_PUTCP (operator_name_info[(int)TREE_CODE (t)].name);\n       OB_PUTC (')');\n       break;\n \n@@ -2307,13 +2293,10 @@ op_to_string (p, v)\n      enum tree_code p;\n      int v ATTRIBUTE_UNUSED;\n {\n-  static char buf[] = \"operator                \";\n+  tree id;\n \n-  if (p == 0)\n-    return \"{unknown}\";\n-  \n-  strcpy (buf + 8, opname_tab [p]);\n-  return buf;\n+  id = operator_name_info[(int) p].identifier;\n+  return id ? IDENTIFIER_POINTER (id) : \"{unknown}\";\n }\n \n static const char *\n@@ -2342,13 +2325,10 @@ assop_to_string (p, v)\n      enum tree_code p;\n      int v ATTRIBUTE_UNUSED;\n {\n-  static char buf[] = \"operator                \";\n+  tree id;\n \n-  if (p == 0)\n-    return \"{unknown}\";\n-  \n-  strcpy (buf + 9, assignop_tab [p]);\n-  return buf;\n+  id = assignment_operator_name_info[(int) p].identifier;\n+  return id ? IDENTIFIER_POINTER (id) : \"{unknown}\";\n }\n \n static const char *"}, {"sha": "073aa68ec4dd82636abf3dfd593aa74cdf9c944f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -2331,7 +2331,7 @@ build_new_1 (exp)\n       tree args;\n \n       args = tree_cons (NULL_TREE, size, placement);\n-      fnname = ansi_opname[code];\n+      fnname = ansi_opname (code);\n \n       if (use_global_new)\n \trval = (build_new_function_call "}, {"sha": "e9cd519e6f91b8c0b10582cf6406eb0a5f895709", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 78, "deletions": 282, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -94,6 +94,7 @@ static void mark_impl_file_chain PARAMS ((void *));\n static int read_ucs PARAMS ((int));\n static int is_extended_char PARAMS ((int));\n static int is_extended_char_1 PARAMS ((int));\n+static void init_operators PARAMS ((void));\n \n /* Given a file name X, return the nondirectory portion.\n    Keep in mind that X can be computed more than once.  */\n@@ -144,10 +145,6 @@ extern struct obstack token_obstack;\n /* ??? Don't really know where this goes yet.  */\n #include \"input.c\"\n \n-/* Holds translations from TREE_CODEs to operator name strings,\n-   i.e., opname_tab[PLUS_EXPR] == \"+\".  */\n-const char **opname_tab;\n-const char **assignop_tab;\n \f\n extern int yychar;\t\t/*  the lookahead symbol\t\t*/\n extern YYSTYPE yylval;\t\t/*  the semantic value of the\t\t*/\n@@ -297,52 +294,6 @@ set_quals_and_spec (call_declarator, cv_qualifiers, exception_specification)\n   CALL_DECLARATOR_EXCEPTION_SPEC (call_declarator) = exception_specification;\n }\n \f\n-/* Build names and nodes for overloaded operators.  */\n-\n-tree ansi_opname[LAST_CPLUS_TREE_CODE];\n-tree ansi_assopname[LAST_CPLUS_TREE_CODE];\n-\n-const char *\n-operator_name_string (name)\n-     tree name;\n-{\n-  char *opname = IDENTIFIER_POINTER (name) + 2;\n-  tree *opname_table;\n-  int i, assign;\n-\n-  /* Works for builtin and user defined types.  */\n-  if (IDENTIFIER_GLOBAL_VALUE (name)\n-      && TREE_CODE (IDENTIFIER_GLOBAL_VALUE (name)) == TYPE_DECL)\n-    return IDENTIFIER_POINTER (name);\n-\n-  if (opname[0] == 'a' && opname[2] != '\\0' && opname[2] != '_')\n-    {\n-      opname += 1;\n-      assign = 1;\n-      opname_table = ansi_assopname;\n-    }\n-  else\n-    {\n-      assign = 0;\n-      opname_table = ansi_opname;\n-    }\n-\n-  for (i = 0; i < (int) LAST_CPLUS_TREE_CODE; i++)\n-    {\n-      if (opname[0] == IDENTIFIER_POINTER (opname_table[i])[2+assign]\n-\t  && opname[1] == IDENTIFIER_POINTER (opname_table[i])[3+assign])\n-\tbreak;\n-    }\n-\n-  if (i == LAST_CPLUS_TREE_CODE)\n-    return \"<invalid operator>\";\n-\n-  if (assign)\n-    return assignop_tab[i];\n-  else\n-    return opname_tab[i];\n-}\n-\f\n int interface_only;\t\t/* whether or not current file is only for\n \t\t\t\t   interface definitions.  */\n int interface_unknown;\t\t/* whether or not we know this class\n@@ -487,19 +438,6 @@ init_filename_times ()\n     }\n }\n \n-/* Change by Bryan Boreham, Kewill, Thu Jul 27 09:46:05 1989.\n-   Stuck this hack in to get the files open correctly; this is called\n-   in place of init_parse if we are an unexec'd binary.    */\n-\n-#if 0\n-void\n-reinit_lang_specific ()\n-{\n-  init_filename_times ();\n-  reinit_search_statistics ();\n-}\n-#endif\n-\n static int *\n init_cpp_parse ()\n {\n@@ -514,15 +452,88 @@ init_cpp_parse ()\n   return token_count;\n }\n \n+/* A mapping from tree codes to operator name information.  */\n+operator_name_info_t operator_name_info[(int) LAST_CPLUS_TREE_CODE];\n+/* Similar, but for assignment operators.  */\n+operator_name_info_t assignment_operator_name_info[(int) LAST_CPLUS_TREE_CODE];\n+  \n+/* Initialize data structures that keep track of operator names.  */\n+\n+static void\n+init_operators ()\n+{\n+  tree identifier;\n+  char buffer[256];\n+  struct operator_name_info_t *oni;\n+  \n+#define DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY, ASSN_P) \\\n+  my_friendly_assert ((strlen (\"operator \") + strlen (NAME) + 1\t\t    \\\n+\t\t       <= 256),\t\t\t\t\t\t    \\\n+\t\t      20000526);\t\t\t\t\t    \\\n+  sprintf (buffer, \"operator %s\", NAME);\t\t\t\t    \\\n+  identifier = get_identifier (buffer);\t\t\t\t\t    \\\n+  IDENTIFIER_OPNAME_P (identifier) = 1;\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  oni = (ASSN_P\t\t\t\t\t\t\t\t    \\\n+\t ? &assignment_operator_name_info[(int) CODE]\t\t\t    \\\n+\t : &operator_name_info[(int) CODE]);\t\t\t\t    \\\n+  oni->identifier = identifier;\t\t\t\t\t\t    \\\n+  oni->name = NAME;\t\t\t\t\t\t\t    \\\n+  oni->mangled_name = flag_new_abi ? NEW_MANGLING : OLD_MANGLING;\n+\n+#include \"operators.def\"\n+#undef DEF_OPERATOR\n+\n+  operator_name_info[(int) ERROR_MARK].identifier \n+    = get_identifier (\"<invalid operator>\");\n+\n+  /* Handle some special cases.  These operators are not defined in\n+     the language, but can be produced internally.  We may need them\n+     for error-reporting.  (Eventually, we should ensure that this\n+     does not happen.  Error messages involving these operators will\n+     be confusing to users.)  */\n+  \n+  operator_name_info [(int) INIT_EXPR].name \n+    = operator_name_info [(int) MODIFY_EXPR].name;\n+  operator_name_info [(int) EXACT_DIV_EXPR].name = \"(ceiling /)\";\n+  operator_name_info [(int) CEIL_DIV_EXPR].name = \"(ceiling /)\";\n+  operator_name_info [(int) FLOOR_DIV_EXPR].name = \"(floor /)\";\n+  operator_name_info [(int) ROUND_DIV_EXPR].name = \"(round /)\";\n+  operator_name_info [(int) CEIL_MOD_EXPR].name = \"(ceiling %)\";\n+  operator_name_info [(int) FLOOR_MOD_EXPR].name = \"(floor %)\";\n+  operator_name_info [(int) ROUND_MOD_EXPR].name = \"(round %)\";\n+  operator_name_info [(int) ABS_EXPR].name = \"abs\";\n+  operator_name_info [(int) FFS_EXPR].name = \"ffs\";\n+  operator_name_info [(int) BIT_ANDTC_EXPR].name = \"&~\";\n+  operator_name_info [(int) TRUTH_AND_EXPR].name = \"strict &&\";\n+  operator_name_info [(int) TRUTH_OR_EXPR].name = \"strict ||\";\n+  operator_name_info [(int) IN_EXPR].name = \"in\";\n+  operator_name_info [(int) RANGE_EXPR].name = \"...\";\n+  operator_name_info [(int) CONVERT_EXPR].name = \"+\";\n+\n+  assignment_operator_name_info [(int) EXACT_DIV_EXPR].name \n+    = \"(exact /=)\";\n+  assignment_operator_name_info [(int) CEIL_DIV_EXPR].name \n+    = \"(ceiling /=)\";\n+  assignment_operator_name_info [(int) FLOOR_DIV_EXPR].name \n+    = \"(floor /=)\";\n+  assignment_operator_name_info [(int) ROUND_DIV_EXPR].name \n+    = \"(round /=)\";\n+  assignment_operator_name_info [(int) CEIL_MOD_EXPR].name \n+    = \"(ceiling %=)\";\n+  assignment_operator_name_info [(int) FLOOR_MOD_EXPR].name \n+    = \"(floor %=)\";\n+  assignment_operator_name_info [(int) ROUND_MOD_EXPR].name \n+    = \"(round %=)\";\n+}\n+\n const char *\n init_parse (filename)\n      const char *filename;\n {\n   extern int flag_no_gnu_keywords;\n   extern int flag_operator_names;\n \n-  int i;\n-\n #ifdef MULTIBYTE_CHARS\n   /* Change to the native locale for multibyte conversions.  */\n   setlocale (LC_CTYPE, \"\");\n@@ -580,138 +591,7 @@ init_parse (filename)\n \t  cplus_tree_code_name,\n \t  (LAST_CPLUS_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (char *));\n \n-  opname_tab = (const char **)oballoc ((int)LAST_CPLUS_TREE_CODE * sizeof (char *));\n-  memset (opname_tab, 0, (int)LAST_CPLUS_TREE_CODE * sizeof (char *));\n-  assignop_tab = (const char **)oballoc ((int)LAST_CPLUS_TREE_CODE * sizeof (char *));\n-  memset (assignop_tab, 0, (int)LAST_CPLUS_TREE_CODE * sizeof (char *));\n-\n-  ansi_opname[0] = get_identifier (\"<invalid operator>\");\n-  for (i = 0; i < (int) LAST_CPLUS_TREE_CODE; i++)\n-    {\n-      ansi_opname[i] = ansi_opname[0];\n-      ansi_assopname[i] = ansi_opname[0];\n-    }\n-\n-  ansi_opname[(int) MULT_EXPR] = get_identifier (\"__ml\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) MULT_EXPR]) = 1;\n-  ansi_opname[(int) INDIRECT_REF] = ansi_opname[(int) MULT_EXPR];\n-  ansi_assopname[(int) MULT_EXPR] = get_identifier (\"__aml\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) MULT_EXPR]) = 1;\n-  ansi_assopname[(int) INDIRECT_REF] = ansi_assopname[(int) MULT_EXPR];\n-  ansi_opname[(int) TRUNC_MOD_EXPR] = get_identifier (\"__md\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) TRUNC_MOD_EXPR]) = 1;\n-  ansi_assopname[(int) TRUNC_MOD_EXPR] = get_identifier (\"__amd\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) TRUNC_MOD_EXPR]) = 1;\n-  ansi_opname[(int) CEIL_MOD_EXPR] = ansi_opname[(int) TRUNC_MOD_EXPR];\n-  ansi_opname[(int) FLOOR_MOD_EXPR] = ansi_opname[(int) TRUNC_MOD_EXPR];\n-  ansi_opname[(int) ROUND_MOD_EXPR] = ansi_opname[(int) TRUNC_MOD_EXPR];\n-  ansi_opname[(int) MINUS_EXPR] = get_identifier (\"__mi\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) MINUS_EXPR]) = 1;\n-  ansi_opname[(int) NEGATE_EXPR] = ansi_opname[(int) MINUS_EXPR];\n-  ansi_assopname[(int) MINUS_EXPR] = get_identifier (\"__ami\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) MINUS_EXPR]) = 1;\n-  ansi_assopname[(int) NEGATE_EXPR] = ansi_assopname[(int) MINUS_EXPR];\n-  ansi_opname[(int) RSHIFT_EXPR] = get_identifier (\"__rs\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) RSHIFT_EXPR]) = 1;\n-  ansi_assopname[(int) RSHIFT_EXPR] = get_identifier (\"__ars\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) RSHIFT_EXPR]) = 1;\n-  ansi_opname[(int) NE_EXPR] = get_identifier (\"__ne\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) NE_EXPR]) = 1;\n-  ansi_opname[(int) GT_EXPR] = get_identifier (\"__gt\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) GT_EXPR]) = 1;\n-  ansi_opname[(int) GE_EXPR] = get_identifier (\"__ge\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) GE_EXPR]) = 1;\n-  ansi_opname[(int) BIT_IOR_EXPR] = get_identifier (\"__or\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) BIT_IOR_EXPR]) = 1;\n-  ansi_assopname[(int) BIT_IOR_EXPR] = get_identifier (\"__aor\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) BIT_IOR_EXPR]) = 1;\n-  ansi_opname[(int) TRUTH_ANDIF_EXPR] = get_identifier (\"__aa\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) TRUTH_ANDIF_EXPR]) = 1;\n-  ansi_opname[(int) TRUTH_NOT_EXPR] = get_identifier (\"__nt\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) TRUTH_NOT_EXPR]) = 1;\n-  ansi_opname[(int) PREINCREMENT_EXPR] = get_identifier (\"__pp\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) PREINCREMENT_EXPR]) = 1;\n-  ansi_opname[(int) POSTINCREMENT_EXPR] = ansi_opname[(int) PREINCREMENT_EXPR];\n-  ansi_opname[(int) MODIFY_EXPR] = get_identifier (\"__as\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) MODIFY_EXPR]) = 1;\n-  ansi_assopname[(int) NOP_EXPR] = ansi_opname[(int) MODIFY_EXPR];\n-  ansi_opname[(int) COMPOUND_EXPR] = get_identifier (\"__cm\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) COMPOUND_EXPR]) = 1;\n-  ansi_opname[(int) EXACT_DIV_EXPR] = get_identifier (\"__dv\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) EXACT_DIV_EXPR]) = 1;\n-  ansi_assopname[(int) EXACT_DIV_EXPR] = get_identifier (\"__adv\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) EXACT_DIV_EXPR]) = 1;\n-  ansi_opname[(int) TRUNC_DIV_EXPR] = ansi_opname[(int) EXACT_DIV_EXPR];\n-  ansi_opname[(int) CEIL_DIV_EXPR] = ansi_opname[(int) EXACT_DIV_EXPR];\n-  ansi_opname[(int) FLOOR_DIV_EXPR] = ansi_opname[(int) EXACT_DIV_EXPR];\n-  ansi_opname[(int) ROUND_DIV_EXPR] = ansi_opname[(int) EXACT_DIV_EXPR];\n-  ansi_opname[(int) PLUS_EXPR] = get_identifier (\"__pl\");\n-  ansi_assopname[(int) TRUNC_DIV_EXPR] = ansi_assopname[(int) EXACT_DIV_EXPR];\n-  ansi_assopname[(int) CEIL_DIV_EXPR] = ansi_assopname[(int) EXACT_DIV_EXPR];\n-  ansi_assopname[(int) FLOOR_DIV_EXPR] = ansi_assopname[(int) EXACT_DIV_EXPR];\n-  ansi_assopname[(int) ROUND_DIV_EXPR] = ansi_assopname[(int) EXACT_DIV_EXPR];\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) PLUS_EXPR]) = 1;\n-  ansi_assopname[(int) PLUS_EXPR] = get_identifier (\"__apl\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) PLUS_EXPR]) = 1;\n-  ansi_opname[(int) CONVERT_EXPR] = ansi_opname[(int) PLUS_EXPR];\n-  ansi_assopname[(int) CONVERT_EXPR] = ansi_assopname[(int) PLUS_EXPR];\n-  ansi_opname[(int) LSHIFT_EXPR] = get_identifier (\"__ls\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) LSHIFT_EXPR]) = 1;\n-  ansi_assopname[(int) LSHIFT_EXPR] = get_identifier (\"__als\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) LSHIFT_EXPR]) = 1;\n-  ansi_opname[(int) EQ_EXPR] = get_identifier (\"__eq\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) EQ_EXPR]) = 1;\n-  ansi_opname[(int) LT_EXPR] = get_identifier (\"__lt\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) LT_EXPR]) = 1;\n-  ansi_opname[(int) LE_EXPR] = get_identifier (\"__le\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) LE_EXPR]) = 1;\n-  ansi_opname[(int) BIT_AND_EXPR] = get_identifier (\"__ad\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) BIT_AND_EXPR]) = 1;\n-  ansi_assopname[(int) BIT_AND_EXPR] = get_identifier (\"__aad\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) BIT_AND_EXPR]) = 1;\n-  ansi_opname[(int) ADDR_EXPR] = ansi_opname[(int) BIT_AND_EXPR];\n-  ansi_assopname[(int) ADDR_EXPR] = ansi_assopname[(int) BIT_AND_EXPR];\n-  ansi_opname[(int) BIT_XOR_EXPR] = get_identifier (\"__er\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) BIT_XOR_EXPR]) = 1;\n-  ansi_assopname[(int) BIT_XOR_EXPR] = get_identifier (\"__aer\");\n-  IDENTIFIER_OPNAME_P (ansi_assopname[(int) BIT_XOR_EXPR]) = 1;\n-  ansi_opname[(int) TRUTH_ORIF_EXPR] = get_identifier (\"__oo\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) TRUTH_ORIF_EXPR]) = 1;\n-  ansi_opname[(int) BIT_NOT_EXPR] = get_identifier (\"__co\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) BIT_NOT_EXPR]) = 1;\n-  ansi_opname[(int) PREDECREMENT_EXPR] = get_identifier (\"__mm\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) PREDECREMENT_EXPR]) = 1;\n-  ansi_opname[(int) POSTDECREMENT_EXPR] = ansi_opname[(int) PREDECREMENT_EXPR];\n-  ansi_opname[(int) COMPONENT_REF] = get_identifier (\"__rf\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) COMPONENT_REF]) = 1;\n-  ansi_opname[(int) MEMBER_REF] = get_identifier (\"__rm\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) MEMBER_REF]) = 1;\n-  ansi_opname[(int) CALL_EXPR] = get_identifier (\"__cl\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) CALL_EXPR]) = 1;\n-  ansi_opname[(int) ARRAY_REF] = get_identifier (\"__vc\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) ARRAY_REF]) = 1;\n-  ansi_opname[(int) NEW_EXPR] = get_identifier (\"__nw\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) NEW_EXPR]) = 1;\n-  ansi_opname[(int) DELETE_EXPR] = get_identifier (\"__dl\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) DELETE_EXPR]) = 1;\n-  ansi_opname[(int) VEC_NEW_EXPR] = get_identifier (\"__vn\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) VEC_NEW_EXPR]) = 1;\n-  ansi_opname[(int) VEC_DELETE_EXPR] = get_identifier (\"__vd\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) VEC_DELETE_EXPR]) = 1;\n-  ansi_opname[(int) TYPE_EXPR] = get_identifier (OPERATOR_TYPENAME_FORMAT);\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) TYPE_EXPR]) = 1;\n-\n-  /* This is not true: these operators are not defined in ANSI,\n-     but we need them anyway.  */\n-  ansi_opname[(int) MIN_EXPR] = get_identifier (\"__mn\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) MIN_EXPR]) = 1;\n-  ansi_opname[(int) MAX_EXPR] = get_identifier (\"__mx\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) MAX_EXPR]) = 1;\n-  ansi_opname[(int) COND_EXPR] = get_identifier (\"__cn\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) COND_EXPR]) = 1;\n-  ansi_opname[(int) SIZEOF_EXPR] = get_identifier (\"__sz\");\n-  IDENTIFIER_OPNAME_P (ansi_opname[(int) SIZEOF_EXPR]) = 1;\n-\n+  init_operators ();\n   init_method ();\n   init_error ();\n   gcc_obstack_init (&inline_text_obstack);\n@@ -787,88 +667,6 @@ init_parse (filename)\n   null_node = build_int_2 (0, 0);\n   ridpointers[RID_NULL] = null_node;\n \n-  opname_tab[(int) COMPONENT_REF] = \"->\";\n-  opname_tab[(int) MEMBER_REF] = \"->*\";\n-  opname_tab[(int) INDIRECT_REF] = \"*\";\n-  opname_tab[(int) ARRAY_REF] = \"[]\";\n-  opname_tab[(int) MODIFY_EXPR] = \"=\";\n-  opname_tab[(int) INIT_EXPR] = \"=\";\n-  opname_tab[(int) NEW_EXPR] = \"new\";\n-  opname_tab[(int) DELETE_EXPR] = \"delete\";\n-  opname_tab[(int) VEC_NEW_EXPR] = \"new []\";\n-  opname_tab[(int) VEC_DELETE_EXPR] = \"delete []\";\n-  opname_tab[(int) COND_EXPR] = \"?:\";\n-  opname_tab[(int) CALL_EXPR] = \"()\";\n-  opname_tab[(int) PLUS_EXPR] = \"+\";\n-  opname_tab[(int) MINUS_EXPR] = \"-\";\n-  opname_tab[(int) MULT_EXPR] = \"*\";\n-  opname_tab[(int) TRUNC_DIV_EXPR] = \"/\";\n-  opname_tab[(int) CEIL_DIV_EXPR] = \"(ceiling /)\";\n-  opname_tab[(int) FLOOR_DIV_EXPR] = \"(floor /)\";\n-  opname_tab[(int) ROUND_DIV_EXPR] = \"(round /)\";\n-  opname_tab[(int) TRUNC_MOD_EXPR] = \"%\";\n-  opname_tab[(int) CEIL_MOD_EXPR] = \"(ceiling %)\";\n-  opname_tab[(int) FLOOR_MOD_EXPR] = \"(floor %)\";\n-  opname_tab[(int) ROUND_MOD_EXPR] = \"(round %)\";\n-  opname_tab[(int) EXACT_DIV_EXPR] = \"/\";\n-  opname_tab[(int) NEGATE_EXPR] = \"-\";\n-  opname_tab[(int) MIN_EXPR] = \"<?\";\n-  opname_tab[(int) MAX_EXPR] = \">?\";\n-  opname_tab[(int) ABS_EXPR] = \"abs\";\n-  opname_tab[(int) FFS_EXPR] = \"ffs\";\n-  opname_tab[(int) LSHIFT_EXPR] = \"<<\";\n-  opname_tab[(int) RSHIFT_EXPR] = \">>\";\n-  opname_tab[(int) BIT_IOR_EXPR] = \"|\";\n-  opname_tab[(int) BIT_XOR_EXPR] = \"^\";\n-  opname_tab[(int) BIT_AND_EXPR] = \"&\";\n-  opname_tab[(int) BIT_ANDTC_EXPR] = \"&~\";\n-  opname_tab[(int) BIT_NOT_EXPR] = \"~\";\n-  opname_tab[(int) TRUTH_ANDIF_EXPR] = \"&&\";\n-  opname_tab[(int) TRUTH_ORIF_EXPR] = \"||\";\n-  opname_tab[(int) TRUTH_AND_EXPR] = \"strict &&\";\n-  opname_tab[(int) TRUTH_OR_EXPR] = \"strict ||\";\n-  opname_tab[(int) TRUTH_NOT_EXPR] = \"!\";\n-  opname_tab[(int) LT_EXPR] = \"<\";\n-  opname_tab[(int) LE_EXPR] = \"<=\";\n-  opname_tab[(int) GT_EXPR] = \">\";\n-  opname_tab[(int) GE_EXPR] = \">=\";\n-  opname_tab[(int) EQ_EXPR] = \"==\";\n-  opname_tab[(int) NE_EXPR] = \"!=\";\n-  opname_tab[(int) IN_EXPR] = \"in\";\n-  opname_tab[(int) RANGE_EXPR] = \"...\";\n-  opname_tab[(int) CONVERT_EXPR] = \"+\";\n-  opname_tab[(int) ADDR_EXPR] = \"&\";\n-  opname_tab[(int) PREDECREMENT_EXPR] = \"--\";\n-  opname_tab[(int) PREINCREMENT_EXPR] = \"++\";\n-  opname_tab[(int) POSTDECREMENT_EXPR] = \"--\";\n-  opname_tab[(int) POSTINCREMENT_EXPR] = \"++\";\n-  opname_tab[(int) COMPOUND_EXPR] = \",\";\n-\n-  assignop_tab[(int) NOP_EXPR] = \"=\";\n-  assignop_tab[(int) PLUS_EXPR] =  \"+=\";\n-  assignop_tab[(int) CONVERT_EXPR] =  \"+=\";\n-  assignop_tab[(int) MINUS_EXPR] = \"-=\";\n-  assignop_tab[(int) NEGATE_EXPR] = \"-=\";\n-  assignop_tab[(int) MULT_EXPR] = \"*=\";\n-  assignop_tab[(int) INDIRECT_REF] = \"*=\";\n-  assignop_tab[(int) TRUNC_DIV_EXPR] = \"/=\";\n-  assignop_tab[(int) EXACT_DIV_EXPR] = \"(exact /=)\";\n-  assignop_tab[(int) CEIL_DIV_EXPR] = \"(ceiling /=)\";\n-  assignop_tab[(int) FLOOR_DIV_EXPR] = \"(floor /=)\";\n-  assignop_tab[(int) ROUND_DIV_EXPR] = \"(round /=)\";\n-  assignop_tab[(int) TRUNC_MOD_EXPR] = \"%=\";\n-  assignop_tab[(int) CEIL_MOD_EXPR] = \"(ceiling %=)\";\n-  assignop_tab[(int) FLOOR_MOD_EXPR] = \"(floor %=)\";\n-  assignop_tab[(int) ROUND_MOD_EXPR] = \"(round %=)\";\n-  assignop_tab[(int) MIN_EXPR] = \"<?=\";\n-  assignop_tab[(int) MAX_EXPR] = \">?=\";\n-  assignop_tab[(int) LSHIFT_EXPR] = \"<<=\";\n-  assignop_tab[(int) RSHIFT_EXPR] = \">>=\";\n-  assignop_tab[(int) BIT_IOR_EXPR] = \"|=\";\n-  assignop_tab[(int) BIT_XOR_EXPR] = \"^=\";\n-  assignop_tab[(int) BIT_AND_EXPR] = \"&=\";\n-  assignop_tab[(int) ADDR_EXPR] = \"&=\";\n-\n   init_filename_times ();\n \n   /* Some options inhibit certain reserved words.\n@@ -908,8 +706,6 @@ init_parse (filename)\n   token_count = init_cpp_parse ();\n   interface_unknown = 1;\n \n-  ggc_add_tree_root (ansi_opname, LAST_CPLUS_TREE_CODE);\n-  ggc_add_tree_root (ansi_assopname, LAST_CPLUS_TREE_CODE);\n   ggc_add_string_root (&internal_filename, 1);\n   ggc_add_tree_root (ridpointers, RID_MAX);\n   ggc_add_tree_root (&defarg_fns, 1);\n@@ -3322,7 +3118,7 @@ do_identifier (token, parsing, args)\n \treturn build_min_nt (LOOKUP_EXPR, token);\n       else if (IDENTIFIER_OPNAME_P (token))\n \t{\n-\t  if (token != ansi_opname[ERROR_MARK])\n+\t  if (token != ansi_opname (ERROR_MARK))\n \t    cp_error (\"`%D' not defined\", token);\n \t  id = error_mark_node;\n \t}"}, {"sha": "13d627ad17bd9beb41befc9e8a7a30e9477e3c6a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 48, "deletions": 57, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -520,12 +520,10 @@ mangle_expression (value)\n     {\n       int i;\n       int operands = TREE_CODE_LENGTH (TREE_CODE (value));\n-      tree id;\n       const char *name;\n \n-      id = ansi_opname [(int) TREE_CODE (value)];\n-      my_friendly_assert (id != NULL_TREE, 0);\n-      name = IDENTIFIER_POINTER (id);\n+      name = operator_name_info[TREE_CODE (value)].mangled_name;\n+      my_friendly_assert (name != NULL, 0);\n       if (name[0] != '_' || name[1] != '_')\n \t/* On some erroneous inputs, we can get here with VALUE a\n \t   LOOKUP_EXPR.  In that case, the NAME will be the\n@@ -1576,31 +1574,47 @@ build_static_name (context, name)\n    of a class (including a static member) and 2 if the declaration is\n    for a constructor.  */\n tree \n-build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n+build_decl_overload_real (decl, parms, ret_type, tparms, targs,\n \t\t\t  for_method) \n-     tree dname;\n+     tree decl;\n      tree parms;\n      tree ret_type;\n      tree tparms;\n      tree targs;\n      int for_method;\n {\n-  const char *name = IDENTIFIER_POINTER (dname);\n+  const char *name;\n+  enum tree_code operator_code;\n+\n+  operator_code = DECL_OVERLOADED_OPERATOR_P (decl);\n+  if (!DECL_CONV_FN_P (decl) && operator_code)\n+    {\n+      /* member operators new and delete look like methods at this\n+         point.  */\n+      if (! for_method && CP_DECL_CONTEXT (decl) == global_namespace\n+\t  && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST\n+\t  && TREE_CHAIN (parms) == void_list_node)\n+\tswitch (operator_code)\n+\t  {\n+\t  case DELETE_EXPR:\n+\t    return get_identifier (\"__builtin_delete\");\n+\t  case VEC_DELETE_EXPR:\n+\t    return get_identifier (\"__builtin_vec_delete\");\n+\t  case NEW_EXPR:\n+\t    return get_identifier (\"__builtin_new\");\n+\t  case VEC_NEW_EXPR:\n+\t    return get_identifier (\"__builtin_vec_new\");\n+\t  default:\n+\t    break;\n+\t  }\n \n-  /* member operators new and delete look like methods at this point.  */\n-  if (! for_method && current_namespace == global_namespace\n-      && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST\n-      && TREE_CHAIN (parms) == void_list_node)\n-    {\n-      if (dname == ansi_opname[(int) DELETE_EXPR])\n-\treturn get_identifier (\"__builtin_delete\");\n-      else if (dname == ansi_opname[(int) VEC_DELETE_EXPR])\n-\treturn get_identifier (\"__builtin_vec_delete\");\n-      if (dname == ansi_opname[(int) NEW_EXPR])\n-\treturn get_identifier (\"__builtin_new\");\n-      else if (dname == ansi_opname[(int) VEC_NEW_EXPR])\n-\treturn get_identifier (\"__builtin_vec_new\");\n+      if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n+\tname = assignment_operator_name_info[(int) operator_code].mangled_name;\n+      else\n+\tname = operator_name_info[(int) operator_code].mangled_name;\n     }\n+  else\n+    name = IDENTIFIER_POINTER (DECL_NAME (decl));\n \n   start_squangling ();\n   OB_INIT ();\n@@ -1618,15 +1632,12 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n       build_template_parm_names (tparms, targs);\n       OB_PUTC ('_');\n     }\n-  else if (!for_method && current_namespace == global_namespace)\n-    /* XXX this works only if we call this in the same namespace\n-       as the declaration. Unfortunately, we don't have the _DECL,\n-       only its name */\n+  else if (!for_method && CP_DECL_CONTEXT (decl) == global_namespace)\n     OB_PUTC ('F');\n \n-  if (!for_method && current_namespace != global_namespace)\n+  if (!for_method && CP_DECL_CONTEXT (decl) != global_namespace)\n     /* qualify with namespace */\n-    build_qualified_name (current_namespace);\n+    build_qualified_name (CP_DECL_CONTEXT (decl));\n \n   if (parms == NULL_TREE)\n     OB_PUTC ('e');\n@@ -1639,7 +1650,7 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t  /* Allocate typevec array.  */\n \t  size_t typevec_size = list_length (parms);\n           maxtype = 0;\n-\t  if (!for_method && current_namespace != global_namespace)\n+\t  if (!for_method && CP_DECL_CONTEXT (decl) != global_namespace)\n \t    /* The namespace of a global function needs one slot.  */\n \t    typevec_size++;\n \t  VARRAY_TREE_INIT (typevec, typevec_size, \"typevec\");\n@@ -1668,11 +1679,11 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t{\n \t  /* the namespace qualifier for a global function \n \t     will count as type */\n-\t  if (current_namespace != global_namespace\n+\t  if (CP_DECL_CONTEXT (decl) != global_namespace\n \t      && !flag_do_squangling)\n \t    {\n \t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n-\t      VARRAY_TREE (typevec, maxtype) = current_namespace;\n+\t      VARRAY_TREE (typevec, maxtype) = CP_DECL_CONTEXT (decl);\n \t      maxtype++;\n \t    }\n \t  build_mangled_name (parms, 0, 0);\n@@ -1694,31 +1705,10 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n   end_squangling ();\n   {\n     tree n = get_identifier (obstack_base (&scratch_obstack));\n-    if (IDENTIFIER_OPNAME_P (dname))\n-      IDENTIFIER_OPNAME_P (n) = 1;\n     return n;\n   }\n }\n \n-/* Change the name of a function definition so that it may be\n-   overloaded. NAME is the name of the function to overload,\n-   PARMS is the parameter list (which determines what name the\n-   final function obtains).\n-\n-   FOR_METHOD is 1 if this overload is being performed\n-   for a method, rather than a function type.  It is 2 if\n-   this overload is being performed for a constructor.  */\n-\n-tree\n-build_decl_overload (dname, parms, for_method)\n-     tree dname;\n-     tree parms;\n-     int for_method;\n-{\n-  return build_decl_overload_real (dname, parms, NULL_TREE, NULL_TREE,\n-\t\t\t\t   NULL_TREE, for_method); \n-}\n-\n /* Set the mangled name (DECL_ASSEMBLER_NAME) for DECL.  */\n \n void\n@@ -1746,9 +1736,10 @@ set_mangled_name_for_decl (decl)\n \t\t\t0);\n \n   DECL_ASSEMBLER_NAME (decl)\n-    = build_decl_overload (DECL_NAME (decl), parm_types, \n-\t\t\t   DECL_FUNCTION_MEMBER_P (decl)\n-\t\t\t   + DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n+    = build_decl_overload_real (decl, parm_types, NULL_TREE,\n+\t\t\t\tNULL_TREE, NULL_TREE,\n+\t\t\t\tDECL_FUNCTION_MEMBER_P (decl)\n+\t\t\t\t+ DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n }\n \n /* Build an overload name for the type expression TYPE.  */\n@@ -1760,7 +1751,7 @@ build_typename_overload (type)\n   tree id;\n \n   OB_INIT ();\n-  OB_PUTID (ansi_opname[(int) TYPE_EXPR]);\n+  OB_PUTS (OPERATOR_TYPENAME_FORMAT);\n   nofold = 1;\n   start_squangling ();\n   build_mangled_name (type, 0, 1);\n@@ -2367,7 +2358,7 @@ do_build_assign_ref (fndecl)\n \t    (build_reference_type (basetype), parm,\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n-\t  p = build_member_call (basetype, ansi_opname [MODIFY_EXPR],\n+\t  p = build_member_call (basetype, ansi_assopname (NOP_EXPR),\n \t\t\t\t build_tree_list (NULL_TREE, p));\n \t  finish_expr_stmt (p);\n \t}\n@@ -2467,7 +2458,7 @@ synthesize_method (fndecl)\n   store_parm_decls ();\n   clear_last_expr ();\n \n-  if (DECL_NAME (fndecl) == ansi_opname[MODIFY_EXPR])\n+  if (DECL_OVERLOADED_OPERATOR_P (fndecl) == NOP_EXPR)\n     {\n       do_build_assign_ref (fndecl);\n       need_body = 0;\n@@ -2550,7 +2541,7 @@ implicitly_declare_fn (kind, type, const_p)\n       if (const_p)\n \ttype = build_qualified_type (type, TYPE_QUAL_CONST);\n \n-      name = ansi_opname [(int) MODIFY_EXPR];\n+      name = ansi_assopname (NOP_EXPR);\n \n       argtype = build_reference_type (type);\n       args = tree_cons (NULL_TREE,"}, {"sha": "1ad8d04a4239f69669fbc0100e34459b8d082f4b", "filename": "gcc/cp/operators.def", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -0,0 +1,153 @@\n+/* -*-C-*-\n+\t\n+   This file contains definitions of the various C++ operators,\n+   including both overloadable operators (like `+') and\n+   non-overloadable operators (like the `?:' ternary operator).  \n+   Writtey by Mark Mitchell <mark@codesourcery.com>\n+\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* The DEF_OPERATOR macro takes the following arguments:\n+\n+   NAME\n+\n+     The name of the operator, as a C string, but without the\n+     preceeding `operator'.  This is the name that would be given in\n+     the source program.  For `operator +', for example, this would be\n+     `+'.\n+   \n+   CODE\n+\n+     The tree_code for this operator.  For `operator +', for example,\n+     this would be PLUS_EXPR.  Because there are no tree codes for\n+     assignment operators, the same tree-codes are reused; i.e.,\n+     `operator +' will also have PLUS_EXPR as its CODE.\n+\n+   NEW_MANGLING\n+\n+     The mangling prefix for the operator, as a C string, and as\n+     mangled under the new ABI.  For `operator +', for example, this\n+     would be \"pl\".\n+\n+   OLD_MANGLING\n+\n+     Analagous, but for the old ABI.\n+\n+   ARITY\n+   \n+     The arity of the operator, or -1 if any arity is allowed.  (As\n+     for `operator ()'.)  Postincrement and postdecrement operators\n+     are marked as binary.\n+\n+   ASSN_P\n+\n+     A boolean value.  If non-zero, this is an assignment operator.  \n+\n+   Before including this file, you should define DEFOPERATOR\n+   to take these arguments.  \n+\n+   There is code (such as in grok_op_properties) that depends on the\n+   order the operators are presented in this file.  In particular,\n+   unary operators must preceed binary operators.  */\n+ \n+/* Use DEF_SIMPLE_OPERATOR to define a non-assignment operator.  Its\n+   arguments are as for DEF_OPERATOR, but there is no need to provide\n+   an ASSIGNMENT_P argument; it is always zero.  */\n+\n+#define DEF_SIMPLE_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY) \\\n+  DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY, 0)\n+\n+/* Use DEF_ASSN_OPERATOR to define an assignment operator.  Its\n+   arguments are as for DEF_OPERATOR, but there is no need to provide\n+   an ASSIGNMENT_P argument; it is always one.  */\n+\n+#define DEF_ASSN_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY) \\\n+  DEF_OPERATOR(NAME, CODE, NEW_MANGLING, OLD_MANGLING, ARITY, 1)\n+\n+/* Memory allocation operators.  */\n+DEF_SIMPLE_OPERATOR (\"new\", NEW_EXPR, \"nw\", \"__nw\", -1)\n+DEF_SIMPLE_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\", \"__vn\", -1)\n+DEF_SIMPLE_OPERATOR (\"delete\", DELETE_EXPR, \"dl\", \"__dl\", -1)\n+DEF_SIMPLE_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\", \"__vd\", -1)\n+\n+/* Unary operators.  */\n+DEF_SIMPLE_OPERATOR (\"+\", CONVERT_EXPR, \"ps\", \"__pl\", 1)\n+DEF_SIMPLE_OPERATOR (\"-\", NEGATE_EXPR, \"ng\", \"__mi\", 1)\n+DEF_SIMPLE_OPERATOR (\"&\", ADDR_EXPR, \"ad\", \"__ad\", 1)\n+DEF_SIMPLE_OPERATOR (\"*\", INDIRECT_REF, \"de\", \"__ml\", 1)\n+DEF_SIMPLE_OPERATOR (\"~\", BIT_NOT_EXPR, \"co\", \"__co\", 1)\n+DEF_SIMPLE_OPERATOR (\"!\", TRUTH_NOT_EXPR, \"nt\", \"__nt\", 1)\n+DEF_SIMPLE_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", \"__pp\", 1)\n+DEF_SIMPLE_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", \"__mm\", 1)\n+DEF_SIMPLE_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", \"__sz\", 1)\n+/* This is an extension.  */\n+DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"vx7alignof\", \"__al\", 1)\n+\n+/* The cast operator.  */\n+DEF_SIMPLE_OPERATOR (\"\", TYPE_EXPR, \"cv\", OPERATOR_TYPENAME_FORMAT, 1)\n+\n+/* Binary operators.  */\n+DEF_SIMPLE_OPERATOR (\"+\", PLUS_EXPR, \"pl\", \"__pl\", 2)\n+DEF_SIMPLE_OPERATOR (\"-\", MINUS_EXPR, \"mi\", \"__mi\", 2)\n+DEF_SIMPLE_OPERATOR (\"*\", MULT_EXPR, \"ml\", \"__ml\", 2)\n+DEF_SIMPLE_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", \"__dv\", 2)\n+DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"md\", \"__md\", 2)\n+DEF_SIMPLE_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", \"__ad\", 2)\n+DEF_SIMPLE_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", \"__or\", 2)\n+DEF_SIMPLE_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", \"__er\", 2)\n+DEF_SIMPLE_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", \"__ls\", 2)\n+DEF_SIMPLE_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", \"__rs\", 2)\n+DEF_SIMPLE_OPERATOR (\"==\", EQ_EXPR, \"eq\", \"__eq\", 2)\n+DEF_SIMPLE_OPERATOR (\"!=\", NE_EXPR, \"ne\", \"__ne\", 2)\n+DEF_SIMPLE_OPERATOR (\"<\", LT_EXPR, \"lt\", \"__lt\", 2)\n+DEF_SIMPLE_OPERATOR (\">\", GT_EXPR, \"gt\", \"__gt\", 2)\n+DEF_SIMPLE_OPERATOR (\"<=\", LE_EXPR, \"le\", \"__le\", 2)\n+DEF_SIMPLE_OPERATOR (\">=\", GE_EXPR, \"ge\", \"__ge\", 2)\n+DEF_SIMPLE_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", \"__aa\", 2)\n+DEF_SIMPLE_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", \"__oo\", 2)\n+DEF_SIMPLE_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", \"__cm\", 2)\n+DEF_SIMPLE_OPERATOR (\"->*\", MEMBER_REF, \"pm\", \"__rm\", 2)\n+DEF_SIMPLE_OPERATOR (\"->\", COMPONENT_REF, \"pt\", \"__rf\", 2)\n+DEF_SIMPLE_OPERATOR (\"[]\", ARRAY_REF, \"ix\", \"__vc\", 2)\n+DEF_SIMPLE_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", \"__pp\", 2)\n+DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", \"__mm\", 2)\n+/* These are extensions.  */\n+DEF_SIMPLE_OPERATOR (\"<?\", MIN_EXPR, \"vx3min\", \"__mn\", 2)\n+DEF_SIMPLE_OPERATOR (\"<?\", MAX_EXPR, \"vx3max\", \"__mx\", 2)\n+\n+/* Assignment operators.  */\n+DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", \"__as\", 2)\n+DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\", \"__apl\", 2)\n+DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\", \"__ami\", 2)\n+DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\", \"__aml\", 2)\n+DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\", \"__adv\", 2)\n+DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"mD\", \"__amd\", 2)\n+DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\", \"__aad\", 2)\n+DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", \"__aor\", 2)\n+DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", \"__aer\", 2)\n+DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", \"__als\", 2)\n+DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", \"__ars\", 2)\n+\n+/* Ternary operators.  */\n+DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", \"__cn\", 3)\n+\n+/* Miscellaneous.  */\n+DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", \"__cl\", -1)\n+"}, {"sha": "9cb24dd90b0976566283ae748909df81adcfb195", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -8090,143 +8090,143 @@ case 843:\n     break;}\n case 844:\n #line 3674 \"parse.y\"\n-{ yyval.ttype = ansi_opname[MULT_EXPR]; ;\n+{ yyval.ttype = ansi_opname (MULT_EXPR); ;\n     break;}\n case 845:\n #line 3676 \"parse.y\"\n-{ yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n+{ yyval.ttype = ansi_opname (TRUNC_DIV_EXPR); ;\n     break;}\n case 846:\n #line 3678 \"parse.y\"\n-{ yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n+{ yyval.ttype = ansi_opname (TRUNC_MOD_EXPR); ;\n     break;}\n case 847:\n #line 3680 \"parse.y\"\n-{ yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n+{ yyval.ttype = ansi_opname (PLUS_EXPR); ;\n     break;}\n case 848:\n #line 3682 \"parse.y\"\n-{ yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n+{ yyval.ttype = ansi_opname (MINUS_EXPR); ;\n     break;}\n case 849:\n #line 3684 \"parse.y\"\n-{ yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n+{ yyval.ttype = ansi_opname (BIT_AND_EXPR); ;\n     break;}\n case 850:\n #line 3686 \"parse.y\"\n-{ yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n+{ yyval.ttype = ansi_opname (BIT_IOR_EXPR); ;\n     break;}\n case 851:\n #line 3688 \"parse.y\"\n-{ yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n+{ yyval.ttype = ansi_opname (BIT_XOR_EXPR); ;\n     break;}\n case 852:\n #line 3690 \"parse.y\"\n-{ yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n+{ yyval.ttype = ansi_opname (BIT_NOT_EXPR); ;\n     break;}\n case 853:\n #line 3692 \"parse.y\"\n-{ yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n+{ yyval.ttype = ansi_opname (COMPOUND_EXPR); ;\n     break;}\n case 854:\n #line 3694 \"parse.y\"\n-{ yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n+{ yyval.ttype = ansi_opname (yyvsp[0].code); ;\n     break;}\n case 855:\n #line 3696 \"parse.y\"\n-{ yyval.ttype = ansi_opname[LT_EXPR]; ;\n+{ yyval.ttype = ansi_opname (LT_EXPR); ;\n     break;}\n case 856:\n #line 3698 \"parse.y\"\n-{ yyval.ttype = ansi_opname[GT_EXPR]; ;\n+{ yyval.ttype = ansi_opname (GT_EXPR); ;\n     break;}\n case 857:\n #line 3700 \"parse.y\"\n-{ yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n+{ yyval.ttype = ansi_opname (yyvsp[0].code); ;\n     break;}\n case 858:\n #line 3702 \"parse.y\"\n-{ yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n+{ yyval.ttype = ansi_assopname (yyvsp[0].code); ;\n     break;}\n case 859:\n #line 3704 \"parse.y\"\n-{ yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n+{ yyval.ttype = ansi_assopname (NOP_EXPR); ;\n     break;}\n case 860:\n #line 3706 \"parse.y\"\n-{ yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n+{ yyval.ttype = ansi_opname (yyvsp[0].code); ;\n     break;}\n case 861:\n #line 3708 \"parse.y\"\n-{ yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n+{ yyval.ttype = ansi_opname (yyvsp[0].code); ;\n     break;}\n case 862:\n #line 3710 \"parse.y\"\n-{ yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n+{ yyval.ttype = ansi_opname (POSTINCREMENT_EXPR); ;\n     break;}\n case 863:\n #line 3712 \"parse.y\"\n-{ yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n+{ yyval.ttype = ansi_opname (PREDECREMENT_EXPR); ;\n     break;}\n case 864:\n #line 3714 \"parse.y\"\n-{ yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n+{ yyval.ttype = ansi_opname (TRUTH_ANDIF_EXPR); ;\n     break;}\n case 865:\n #line 3716 \"parse.y\"\n-{ yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n+{ yyval.ttype = ansi_opname (TRUTH_ORIF_EXPR); ;\n     break;}\n case 866:\n #line 3718 \"parse.y\"\n-{ yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n+{ yyval.ttype = ansi_opname (TRUTH_NOT_EXPR); ;\n     break;}\n case 867:\n #line 3720 \"parse.y\"\n-{ yyval.ttype = ansi_opname[COND_EXPR]; ;\n+{ yyval.ttype = ansi_opname (COND_EXPR); ;\n     break;}\n case 868:\n #line 3722 \"parse.y\"\n-{ yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n+{ yyval.ttype = ansi_opname (yyvsp[0].code); ;\n     break;}\n case 869:\n #line 3724 \"parse.y\"\n-{ yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n+{ yyval.ttype = ansi_opname (COMPONENT_REF); ;\n     break;}\n case 870:\n #line 3726 \"parse.y\"\n-{ yyval.ttype = ansi_opname[MEMBER_REF]; ;\n+{ yyval.ttype = ansi_opname (MEMBER_REF); ;\n     break;}\n case 871:\n #line 3728 \"parse.y\"\n-{ yyval.ttype = ansi_opname[CALL_EXPR]; ;\n+{ yyval.ttype = ansi_opname (CALL_EXPR); ;\n     break;}\n case 872:\n #line 3730 \"parse.y\"\n-{ yyval.ttype = ansi_opname[ARRAY_REF]; ;\n+{ yyval.ttype = ansi_opname (ARRAY_REF); ;\n     break;}\n case 873:\n #line 3732 \"parse.y\"\n-{ yyval.ttype = ansi_opname[NEW_EXPR]; ;\n+{ yyval.ttype = ansi_opname (NEW_EXPR); ;\n     break;}\n case 874:\n #line 3734 \"parse.y\"\n-{ yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n+{ yyval.ttype = ansi_opname (DELETE_EXPR); ;\n     break;}\n case 875:\n #line 3736 \"parse.y\"\n-{ yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n+{ yyval.ttype = ansi_opname (VEC_NEW_EXPR); ;\n     break;}\n case 876:\n #line 3738 \"parse.y\"\n-{ yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n+{ yyval.ttype = ansi_opname (VEC_DELETE_EXPR); ;\n     break;}\n case 877:\n #line 3741 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 878:\n #line 3743 \"parse.y\"\n-{ yyval.ttype = ansi_opname[ERROR_MARK]; ;\n+{ yyval.ttype = ansi_opname (ERROR_MARK); ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */"}, {"sha": "6f26be4e35f48cf6f76b70b56a364a4a96e2512a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -3671,76 +3671,76 @@ operator:\n \n operator_name:\n \t  operator '*'\n-\t\t{ $$ = ansi_opname[MULT_EXPR]; }\n+\t\t{ $$ = ansi_opname (MULT_EXPR); }\n \t| operator '/'\n-\t\t{ $$ = ansi_opname[TRUNC_DIV_EXPR]; }\n+\t\t{ $$ = ansi_opname (TRUNC_DIV_EXPR); }\n \t| operator '%'\n-\t\t{ $$ = ansi_opname[TRUNC_MOD_EXPR]; }\n+\t\t{ $$ = ansi_opname (TRUNC_MOD_EXPR); }\n \t| operator '+'\n-\t\t{ $$ = ansi_opname[PLUS_EXPR]; }\n+\t\t{ $$ = ansi_opname (PLUS_EXPR); }\n \t| operator '-'\n-\t\t{ $$ = ansi_opname[MINUS_EXPR]; }\n+\t\t{ $$ = ansi_opname (MINUS_EXPR); }\n \t| operator '&'\n-\t\t{ $$ = ansi_opname[BIT_AND_EXPR]; }\n+\t\t{ $$ = ansi_opname (BIT_AND_EXPR); }\n \t| operator '|'\n-\t\t{ $$ = ansi_opname[BIT_IOR_EXPR]; }\n+\t\t{ $$ = ansi_opname (BIT_IOR_EXPR); }\n \t| operator '^'\n-\t\t{ $$ = ansi_opname[BIT_XOR_EXPR]; }\n+\t\t{ $$ = ansi_opname (BIT_XOR_EXPR); }\n \t| operator '~'\n-\t\t{ $$ = ansi_opname[BIT_NOT_EXPR]; }\n+\t\t{ $$ = ansi_opname (BIT_NOT_EXPR); }\n \t| operator ','\n-\t\t{ $$ = ansi_opname[COMPOUND_EXPR]; }\n+\t\t{ $$ = ansi_opname (COMPOUND_EXPR); }\n \t| operator ARITHCOMPARE\n-\t\t{ $$ = ansi_opname[$2]; }\n+\t\t{ $$ = ansi_opname ($2); }\n \t| operator '<'\n-\t\t{ $$ = ansi_opname[LT_EXPR]; }\n+\t\t{ $$ = ansi_opname (LT_EXPR); }\n \t| operator '>'\n-\t\t{ $$ = ansi_opname[GT_EXPR]; }\n+\t\t{ $$ = ansi_opname (GT_EXPR); }\n \t| operator EQCOMPARE\n-\t\t{ $$ = ansi_opname[$2]; }\n+\t\t{ $$ = ansi_opname ($2); }\n \t| operator ASSIGN\n-\t\t{ $$ = ansi_assopname[$2]; }\n+\t\t{ $$ = ansi_assopname ($2); }\n \t| operator '='\n-\t\t{ $$ = ansi_opname [MODIFY_EXPR]; }\n+\t\t{ $$ = ansi_assopname (NOP_EXPR); }\n \t| operator LSHIFT\n-\t\t{ $$ = ansi_opname[$2]; }\n+\t\t{ $$ = ansi_opname ($2); }\n \t| operator RSHIFT\n-\t\t{ $$ = ansi_opname[$2]; }\n+\t\t{ $$ = ansi_opname ($2); }\n \t| operator PLUSPLUS\n-\t\t{ $$ = ansi_opname[POSTINCREMENT_EXPR]; }\n+\t\t{ $$ = ansi_opname (POSTINCREMENT_EXPR); }\n \t| operator MINUSMINUS\n-\t\t{ $$ = ansi_opname[PREDECREMENT_EXPR]; }\n+\t\t{ $$ = ansi_opname (PREDECREMENT_EXPR); }\n \t| operator ANDAND\n-\t\t{ $$ = ansi_opname[TRUTH_ANDIF_EXPR]; }\n+\t\t{ $$ = ansi_opname (TRUTH_ANDIF_EXPR); }\n \t| operator OROR\n-\t\t{ $$ = ansi_opname[TRUTH_ORIF_EXPR]; }\n+\t\t{ $$ = ansi_opname (TRUTH_ORIF_EXPR); }\n \t| operator '!'\n-\t\t{ $$ = ansi_opname[TRUTH_NOT_EXPR]; }\n+\t\t{ $$ = ansi_opname (TRUTH_NOT_EXPR); }\n \t| operator '?' ':'\n-\t\t{ $$ = ansi_opname[COND_EXPR]; }\n+\t\t{ $$ = ansi_opname (COND_EXPR); }\n \t| operator MIN_MAX\n-\t\t{ $$ = ansi_opname[$2]; }\n+\t\t{ $$ = ansi_opname ($2); }\n \t| operator POINTSAT  %prec EMPTY\n-\t\t{ $$ = ansi_opname[COMPONENT_REF]; }\n+\t\t{ $$ = ansi_opname (COMPONENT_REF); }\n \t| operator POINTSAT_STAR  %prec EMPTY\n-\t\t{ $$ = ansi_opname[MEMBER_REF]; }\n+\t\t{ $$ = ansi_opname (MEMBER_REF); }\n \t| operator LEFT_RIGHT\n-\t\t{ $$ = ansi_opname[CALL_EXPR]; }\n+\t\t{ $$ = ansi_opname (CALL_EXPR); }\n \t| operator '[' ']'\n-\t\t{ $$ = ansi_opname[ARRAY_REF]; }\n+\t\t{ $$ = ansi_opname (ARRAY_REF); }\n \t| operator NEW  %prec EMPTY\n-\t\t{ $$ = ansi_opname[NEW_EXPR]; }\n+\t\t{ $$ = ansi_opname (NEW_EXPR); }\n \t| operator DELETE  %prec EMPTY\n-\t\t{ $$ = ansi_opname[DELETE_EXPR]; }\n+\t\t{ $$ = ansi_opname (DELETE_EXPR); }\n \t| operator NEW '[' ']'\n-\t\t{ $$ = ansi_opname[VEC_NEW_EXPR]; }\n+\t\t{ $$ = ansi_opname (VEC_NEW_EXPR); }\n \t| operator DELETE '[' ']'\n-\t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }\n+\t\t{ $$ = ansi_opname (VEC_DELETE_EXPR); }\n \t/* Names here should be looked up in class scope ALSO.  */\n \t| operator type_specifier_seq conversion_declarator\n \t\t{ $$ = grokoptypename ($2.t, $3); }\n \t| operator error\n-\t\t{ $$ = ansi_opname[ERROR_MARK]; }\n+\t\t{ $$ = ansi_opname (ERROR_MARK); }\n \t;\n \n %%"}, {"sha": "b64fc72a72edcf1680c99cf30131db7a26c2c6f4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -5790,7 +5790,7 @@ tsubst_decl (t, args, type, in_decl)\n \t    if (DECL_CONSTRUCTOR_P (r))\n \t      grok_ctor_properties (ctx, r);\n \t  }\n-\telse if (DECL_OVERLOADED_OPERATOR_P (r))\n+\telse if (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n \t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n       }\n       break;\n@@ -9869,7 +9869,6 @@ static void\n set_mangled_name_for_template_decl (decl)\n      tree decl;\n {\n-  tree saved_namespace;\n   tree context = NULL_TREE;\n   tree fn_type;\n   tree ret_type;\n@@ -9985,21 +9984,10 @@ set_mangled_name_for_template_decl (decl)\n   my_friendly_assert (TREE_VEC_LENGTH (tparms) == TREE_VEC_LENGTH (targs),\n \t\t      0);\n \n-  /* If the template is in a namespace, we need to put that into the\n-     mangled name. Unfortunately, build_decl_overload_real does not\n-     get the decl to mangle, so it relies on the current\n-     namespace. Therefore, we set that here temporarily. */\n-  my_friendly_assert (DECL_P (decl), 980702);\n-  saved_namespace = current_namespace;\n-  current_namespace = CP_DECL_CONTEXT (decl);  \n-\n   /* Actually set the DCL_ASSEMBLER_NAME.  */\n   DECL_ASSEMBLER_NAME (decl)\n-    = build_decl_overload_real (DECL_NAME (decl), parm_types, ret_type,\n+    = build_decl_overload_real (decl, parm_types, ret_type,\n \t\t\t\ttparms, targs, \n \t\t\t\tDECL_FUNCTION_MEMBER_P (decl) \n \t\t\t\t+ DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n-\n-  /* Restore the previously active namespace.  */\n-  current_namespace = saved_namespace;\n }"}, {"sha": "382e254c4f3eeb6ca7b2522d5caf3c5c21229b72", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -2429,7 +2429,7 @@ special_function_p (decl)\n     return sfk_copy_constructor;\n   if (DECL_CONSTRUCTOR_P (decl))\n     return sfk_constructor;\n-  if (DECL_NAME (decl) == ansi_opname[(int) MODIFY_EXPR])\n+  if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n     return sfk_assignment_operator;\n   if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n     return sfk_destructor;"}, {"sha": "28ac0f31bc8c7c9782ce09b6844f3da5d3d7cc13", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -6836,15 +6836,15 @@ check_return_expr (retval)\n     current_function_returns_null = 1;\n \n   /* Only operator new(...) throw(), can return NULL [expr.new/13].  */\n-  if ((DECL_NAME (current_function_decl) == ansi_opname[(int) NEW_EXPR]\n-       || DECL_NAME (current_function_decl) == ansi_opname[(int) VEC_NEW_EXPR])\n+  if ((DECL_OVERLOADED_OPERATOR_P (current_function_decl) == NEW_EXPR\n+       || DECL_OVERLOADED_OPERATOR_P (current_function_decl) == VEC_NEW_EXPR)\n       && !TYPE_NOTHROW_P (TREE_TYPE (current_function_decl))\n       && null_ptr_cst_p (retval))\n     cp_warning (\"`operator new' should throw an exception, not return NULL\");\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n-      && DECL_NAME (current_function_decl) == ansi_opname[(int) MODIFY_EXPR]\n+      && DECL_NAME (current_function_decl) == ansi_assopname(NOP_EXPR)\n       && retval != current_class_ref)\n     cp_warning (\"`operator=' should return a reference to `*this'\");\n "}, {"sha": "cf368863f5144de85ad3f330e1e32efed6128633", "filename": "gcc/testsuite/g++.old-deja/g++.other/op1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fop1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/596ea4e574aa9177437b95dcb2412e0673df8c0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fop1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fop1.C?ref=596ea4e574aa9177437b95dcb2412e0673df8c0a", "patch": "@@ -0,0 +1,6 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct S {\n+  bool operator! (int, ...); // ERROR - \n+};"}]}