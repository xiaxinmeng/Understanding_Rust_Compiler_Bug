{"sha": "45329b398e53033647ba465cacc256f32ff7daf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUzMjliMzk4ZTUzMDMzNjQ3YmE0NjVjYWNjMjU2ZjMyZmY3ZGFmNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-09-01T21:03:18Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-09-01T21:03:18Z"}, "message": "posix-threads.cc (_Jv_CondWait): Use _Jv_PthreadGetMutex.\n\n\t* posix-threads.cc (_Jv_CondWait): Use _Jv_PthreadGetMutex.\n\t* include/posix-threads.h (_Jv_Mutex_t): Define as structure,\n\texcept on Linux.\n\t(_Jv_PthreadGetMutex): New function.\n\t(_Jv_PthreadCheckMonitor): Use it.\n\t(_Jv_MutexInit): Likewise.  ALso, initialize `count'.\n\t(_Jv_MutexLock): Update `count'.\n\t(_Jv_MutexUnlock): Likewise.\n\t(_Jv_PthreadCheckMonitor): Use Linux-specific knowledge when\n\tappropriate.\n\nFrom-SVN: r29032", "tree": {"sha": "03902269d263d5fdbf51b709ce65fe57c0a73bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03902269d263d5fdbf51b709ce65fe57c0a73bb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45329b398e53033647ba465cacc256f32ff7daf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45329b398e53033647ba465cacc256f32ff7daf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45329b398e53033647ba465cacc256f32ff7daf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45329b398e53033647ba465cacc256f32ff7daf4/comments", "author": null, "committer": null, "parents": [{"sha": "4499762c6e6403127bd8f9a1932ac64940fca20f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4499762c6e6403127bd8f9a1932ac64940fca20f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4499762c6e6403127bd8f9a1932ac64940fca20f"}], "stats": {"total": 103, "additions": 80, "deletions": 23}, "files": [{"sha": "c2f8b0ae63fabf74eb963ee27905766912eee847", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45329b398e53033647ba465cacc256f32ff7daf4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45329b398e53033647ba465cacc256f32ff7daf4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=45329b398e53033647ba465cacc256f32ff7daf4", "patch": "@@ -1,3 +1,16 @@\n+1999-09-01  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* posix-threads.cc (_Jv_CondWait): Use _Jv_PthreadGetMutex.\n+\t* include/posix-threads.h (_Jv_Mutex_t): Define as structure,\n+\texcept on Linux.\n+\t(_Jv_PthreadGetMutex): New function.\n+\t(_Jv_PthreadCheckMonitor): Use it.\n+\t(_Jv_MutexInit): Likewise.  ALso, initialize `count'.\n+\t(_Jv_MutexLock): Update `count'.\n+\t(_Jv_MutexUnlock): Likewise.\n+\t(_Jv_PthreadCheckMonitor): Use Linux-specific knowledge when\n+\tappropriate.\n+\n 1999-09-01  Kresten Krab Thorup  <krab@gnu.org>\n \n \t* Makefile.am (.java.lo): Add rule."}, {"sha": "e3b3f4f36d223fe5c54fa019704c60fbf997d950", "filename": "libjava/include/posix-threads.h", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45329b398e53033647ba465cacc256f32ff7daf4/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45329b398e53033647ba465cacc256f32ff7daf4/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=45329b398e53033647ba465cacc256f32ff7daf4", "patch": "@@ -30,26 +30,44 @@ details.  */\n //\n \n typedef pthread_cond_t _Jv_ConditionVariable_t;\n-#ifdef HAVE_RECURSIVE_MUTEX\n+\n+// FIXME: it is ugly to use LINUX_THREADS as the define.  Instead\n+// think of a better scheme.\n+#ifdef LINUX_THREADS\n+\n+// On Linux we use implementation details of mutexes in order to get\n+// faster results.\n typedef pthread_mutex_t _Jv_Mutex_t;\n-#else\n-// Some systems do not have recursive mutexes, so we must simulate\n-// them.  Solaris is one such system.\n+\n+#else /* LINUX_THREADS */\n+\n typedef struct\n {\n   // Mutex used when locking this structure transiently.\n   pthread_mutex_t mutex;\n+#ifndef HAVE_RECURSIVE_MUTEX\n+  // Some systems do not have recursive mutexes, so we must simulate\n+  // them.  Solaris is one such system.\n+\n   // Mutex the thread holds the entire time this mutex is held.  This\n   // is used to make condition variables work properly.\n   pthread_mutex_t mutex2;\n   // Condition variable used when waiting for this lock.\n   pthread_cond_t cond;\n   // Thread holding this mutex.  If COUNT is 0, no thread is holding.\n   pthread_t thread;\n-  // Number of times mutex is held.  If 0, the lock is not held.\n+#endif /* HAVE_RECURSIVE_MUTEX */\n+\n+  // Number of times mutex is held.  If 0, the lock is not held.  We\n+  // do this even if we have a native recursive mutex so that we can\n+  // keep track of whether the lock is held; this lets us do error\n+  // checking.  FIXME it would be nice to optimize this; on some\n+  // systems we could do so by relying on implementation details of\n+  // recursive mutexes.\n   int count;\n } _Jv_Mutex_t;\n-#endif /* HAVE_RECURSIVE_MUTEX */\n+\n+#endif /* LINUX_THREADS */\n \n typedef struct\n {\n@@ -65,23 +83,41 @@ typedef struct\n typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n \n \n+// This convenience function is used to return the POSIX mutex\n+// corresponding to our mutex.\n+inline pthread_mutex_t *\n+_Jv_PthreadGetMutex (_Jv_Mutex_t *mu)\n+{\n+#if defined (LINUX_THREADS)\n+  return mu;\n+#elif defined (HAVE_RECURSIVE_MUTEX)\n+  return &mu->mutex;\n+#else\n+  return &mu->mutex2;\n+#endif\n+}\n+\n+#include <stdio.h>\n+\n // This is a convenience function used only by the pthreads thread\n // implementation.  This is slow, but that's too bad -- we need to do\n // the checks for correctness.  It might be nice to be able to compile\n // this out.\n-inline int _Jv_PthreadCheckMonitor (_Jv_Mutex_t *mu)\n+inline int\n+_Jv_PthreadCheckMonitor (_Jv_Mutex_t *mu)\n {\n-  pthread_mutex_t *pmu;\n-#ifdef HAVE_RECURSIVE_MUTEX\n-  pmu = mu;\n-#else\n-  pmu = &mu->mutex2;\n-#endif\n+  pthread_mutex_t *pmu = _Jv_PthreadGetMutex (mu);\n   // See if the mutex is locked by this thread.\n   if (pthread_mutex_trylock (pmu))\n     return 1;\n+#ifdef LINUX_THREADS\n+  // On Linux we exploit knowledge of the implementation.\n+  int r = pmu->m_count == 1;\n+#else\n+  int r = mu->count == 0;\n+#endif\n   pthread_mutex_unlock (pmu);\n-  return 0;\n+  return r;\n }\n \n //\n@@ -133,7 +169,10 @@ _Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu)\n inline void\n _Jv_MutexInit (_Jv_Mutex_t *mu)\n {\n-  pthread_mutex_init (mu, NULL);\n+  pthread_mutex_init (_Jv_PthreadGetMutex (mu), NULL);\n+#ifndef LINUX_THREADS\n+  mu->count = 0;\n+#endif\n }\n #else\n void _Jv_MutexInit (_Jv_Mutex_t *mu);\n@@ -166,13 +205,23 @@ extern void _Jv_MutexDestroy (_Jv_Mutex_t *mu);\n inline int\n _Jv_MutexLock (_Jv_Mutex_t *mu)\n {\n-  return pthread_mutex_lock (mu);\n+  int r = pthread_mutex_lock (mu);\n+#ifndef LINUX_THREADS\n+  if (! r)\n+    ++mu->count;\n+#endif\n+  return r;\n }\n \n inline int\n _Jv_MutexUnlock (_Jv_Mutex_t *mu)\n {\n-  return pthread_mutex_unlock (mu);\n+  int r = pthread_mutex_unlock (mu);\n+#ifndef LINUX_THREADS\n+  if (! r)\n+    --mu->count;\n+#endif\n+  return r;\n }\n \n #else /* HAVE_RECURSIVE_MUTEX */"}, {"sha": "9701596ea81e50fda3f6d961fde316fcfc472a4f", "filename": "libjava/posix-threads.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45329b398e53033647ba465cacc256f32ff7daf4/libjava%2Fposix-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45329b398e53033647ba465cacc256f32ff7daf4/libjava%2Fposix-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix-threads.cc?ref=45329b398e53033647ba465cacc256f32ff7daf4", "patch": "@@ -79,12 +79,7 @@ _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n     return 1;\n \n   int r;\n-  pthread_mutex_t *pmu;\n-#ifdef HAVE_RECURSIVE_MUTEX\n-  pmu = mu;\n-#else\n-  pmu = &mu->mutex2;\n-#endif\n+  pthread_mutex_t *pmu = _Jv_PthreadGetMutex (mu);\n \n   if (millis == 0 && nanos == 0)\n     r = pthread_cond_wait (cv, pmu);"}]}