{"sha": "2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE4MDY3NzJiOGRmYWNjMmM4Y2Q4ZGNmYmFmODNjMDM0NjM0ZTRkYQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T18:07:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:07:33Z"}, "message": "sem_ch5.ads, [...] (Analyze_Loop_Statement): Add circuit to warn on infinite loops.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch5.ads, sem_ch5.adb (Analyze_Loop_Statement): Add circuit to\n\twarn on infinite loops.\n\tAdd \\\\ to some continuation messages\n\t(Analyze_Assignment_Statement): Call Warn_On_Useless_Assignment\n\t(Process_Bounds): If the bounds are integer literals that result from\n\tconstant-folding, and they carry a user-defined type, preserve that type\n\trather than treating this as an integer range.\n\t(Analyze_Exit_Statement): Test for E_Return_Statement in legality check.\n\t(Analyze_Goto_Statement): Test for E_Return_Stateemnt in legality check.\n\t(Analyze_Assignment_Statement): Add call to Check_Elab_Assign for\n\tleft hand side of assignment.\n\t(Analyze_Assignment): Add suport to manage assigments to the attribute\n\tpriority of a protected object.\n\t(Check_Possible_Current_Value_Condition): Allow fully qualified names\n\tnot just identifiers.\n\t(Check_Possible_Current_Value_Condition): Acquire left operand of AND\n\tor AND THEN for possible tracking.\n\t(Analyze_Iteration_Scheme): Check for setting Current_Value for the\n\tcase of while loops so we can track values in the loop body.\n\nFrom-SVN: r118303", "tree": {"sha": "709d556c8d65f6ffa011f66837322431cbfcb251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/709d556c8d65f6ffa011f66837322431cbfcb251"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da/comments", "author": null, "committer": null, "parents": [{"sha": "b67a385c629b7a6c3fab21d1da2c2e7879951c30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67a385c629b7a6c3fab21d1da2c2e7879951c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67a385c629b7a6c3fab21d1da2c2e7879951c30"}], "stats": {"total": 376, "additions": 287, "deletions": 89}, "files": [{"sha": "f74cfa991755dd332304224ef6f126f19d88a512", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 286, "deletions": 79, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "patch": "@@ -26,25 +26,30 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Case; use Sem_Case;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n+with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n+with Snames;   use Snames;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Targparm; use Targparm;\n@@ -56,8 +61,8 @@ package body Sem_Ch5 is\n    Unblocked_Exit_Count : Nat := 0;\n    --  This variable is used when processing if statements, case statements,\n    --  and block statements. It counts the number of exit points that are\n-   --  not blocked by unconditional transfer instructions (for IF and CASE,\n-   --  these are the branches of the conditional, for a block, they are the\n+   --  not blocked by unconditional transfer instructions: for IF and CASE,\n+   --  these are the branches of the conditional; for a block, they are the\n    --  statement sequence of the block, and the statement sequences of any\n    --  exception handlers that are part of the block. When processing is\n    --  complete, if this count is zero, it means that control cannot fall\n@@ -338,6 +343,74 @@ package body Sem_Ch5 is\n       Resolve (Lhs, T1);\n \n       if not Is_Variable (Lhs) then\n+\n+         --  Ada 2005 (AI-327): Check assignment to the attribute Priority of\n+         --  a protected object.\n+\n+         declare\n+            Ent : Entity_Id;\n+            S   : Entity_Id;\n+\n+         begin\n+            if Ada_Version >= Ada_05 then\n+\n+               --  Handle chains of renamings\n+\n+               Ent := Lhs;\n+               while Nkind (Ent) in N_Has_Entity\n+                 and then Present (Entity (Ent))\n+                 and then Present (Renamed_Object (Entity (Ent)))\n+               loop\n+                  Ent := Renamed_Object (Entity (Ent));\n+               end loop;\n+\n+               if (Nkind (Ent) = N_Attribute_Reference\n+                     and then Attribute_Name (Ent) = Name_Priority)\n+\n+                  --  Renamings of the attribute Priority applied to protected\n+                  --  objects have been previously expanded into calls to the\n+                  --  Get_Ceiling run-time subprogram.\n+\n+                 or else\n+                  (Nkind (Ent) = N_Function_Call\n+                     and then (Entity (Name (Ent)) = RTE (RE_Get_Ceiling)\n+                                or else\n+                               Entity (Name (Ent)) = RTE (RO_PE_Get_Ceiling)))\n+               then\n+                  --  The enclosing subprogram cannot be a protected function\n+\n+                  S := Current_Scope;\n+                  while not (Is_Subprogram (S)\n+                               and then Convention (S) = Convention_Protected)\n+                     and then S /= Standard_Standard\n+                  loop\n+                     S := Scope (S);\n+                  end loop;\n+\n+                  if Ekind (S) = E_Function\n+                    and then Convention (S) = Convention_Protected\n+                  then\n+                     Error_Msg_N\n+                       (\"protected function cannot modify protected object\",\n+                        Lhs);\n+                  end if;\n+\n+                  --  Changes of the ceiling priority of the protected object\n+                  --  are only effective if the Ceiling_Locking policy is in\n+                  --  effect (AARM D.5.2 (5/2)).\n+\n+                  if Locking_Policy /= 'C' then\n+                     Error_Msg_N (\"assignment to the attribute PRIORITY has \" &\n+                                  \"no effect?\", Lhs);\n+                     Error_Msg_N (\"\\since no Locking_Policy has been \" &\n+                                  \"specified\", Lhs);\n+                  end if;\n+\n+                  return;\n+               end if;\n+            end if;\n+         end;\n+\n          Diagnose_Non_Variable_Lhs (Lhs);\n          return;\n \n@@ -520,7 +593,7 @@ package body Sem_Ch5 is\n \n       --  ??? a real accessibility check is needed when ???\n \n-      --  Post warning for useless assignment\n+      --  Post warning for redundant assignment or variable to itself\n \n       if Warn_On_Redundant_Constructs\n \n@@ -555,6 +628,12 @@ package body Sem_Ch5 is\n          Error_Msg_CRT (\"composite assignment\", N);\n       end if;\n \n+      --  Check elaboration warning for left side if not in elab code\n+\n+      if not In_Subprogram_Or_Concurrent_Unit then\n+         Check_Elab_Assign (Lhs);\n+      end if;\n+\n       --  Final step. If left side is an entity, then we may be able to\n       --  reset the current tracked values to new safe values. We only have\n       --  something to do if the left side is an entity name, and expansion\n@@ -570,6 +649,22 @@ package body Sem_Ch5 is\n          begin\n             if Safe_To_Capture_Value (N, Ent) then\n \n+               --  If simple variable on left side, warn if this assignment\n+               --  blots out another one (rendering it useless) and note\n+               --  location of assignment in case no one references value.\n+               --  We only do this for source assignments, otherwise we can\n+               --  generate bogus warnings when an assignment is rewritten as\n+               --  another assignment, and gets tied up with itself.\n+\n+               if Warn_On_Modified_Unread\n+                 and then Ekind (Ent) = E_Variable\n+                 and then Comes_From_Source (N)\n+                 and then In_Extended_Main_Source_Unit (Ent)\n+               then\n+                  Warn_On_Useless_Assignment (Ent, Sloc (N));\n+                  Set_Last_Assignment (Ent, Lhs);\n+               end if;\n+\n                --  If we are assigning an access type and the left side is an\n                --  entity, then make sure that the Is_Known_[Non_]Null flags\n                --  properly reflect the state of the entity after assignment.\n@@ -714,6 +809,7 @@ package body Sem_Ch5 is\n          end if;\n \n          Check_References (Ent);\n+         Warn_On_Useless_Assignments (Ent);\n          End_Scope;\n \n          if Unblocked_Exit_Count = 0 then\n@@ -992,7 +1088,10 @@ package body Sem_Ch5 is\n             Set_Has_Exit (Scope_Id);\n             exit;\n \n-         elsif Kind = E_Block or else Kind = E_Loop then\n+         elsif Kind = E_Block\n+           or else Kind = E_Loop\n+           or else Kind = E_Return_Statement\n+         then\n             null;\n \n          else\n@@ -1043,7 +1142,8 @@ package body Sem_Ch5 is\n \n          if Label_Scope = Scope_Id\n            or else (Ekind (Scope_Id) /= E_Block\n-                     and then Ekind (Scope_Id) /= E_Loop)\n+                     and then Ekind (Scope_Id) /= E_Loop\n+                     and then Ekind (Scope_Id) /= E_Return_Statement)\n          then\n             if Scope_Id /= Label_Scope then\n                Error_Msg_N\n@@ -1102,7 +1202,7 @@ package body Sem_Ch5 is\n          Unblocked_Exit_Count := Unblocked_Exit_Count + 1;\n          Analyze_And_Resolve (Cond, Any_Boolean);\n          Check_Unset_Reference (Cond);\n-         Check_Possible_Current_Value_Condition (Cnode);\n+         Set_Current_Value_Condition (Cnode);\n \n          --  If already deleting, then just analyze then statements\n \n@@ -1372,8 +1472,8 @@ package body Sem_Ch5 is\n                              (\"ambiguous bounds in range of iteration\",\n                                R_Copy);\n                            Error_Msg_N (\"\\possible interpretations:\", R_Copy);\n-                           Error_Msg_NE (\"\\} \", R_Copy, Found);\n-                           Error_Msg_NE (\"\\} \", R_Copy, It.Typ);\n+                           Error_Msg_NE (\"\\\\} \", R_Copy, Found);\n+                           Error_Msg_NE (\"\\\\} \", R_Copy, It.Typ);\n                            exit;\n                         end if;\n                      end if;\n@@ -1392,10 +1492,26 @@ package body Sem_Ch5 is\n \n          --  If the type of the discrete range is Universal_Integer, then\n          --  the bound's type must be resolved to Integer, and any object\n-         --  used to hold the bound must also have type Integer.\n+         --  used to hold the bound must also have type Integer, unless the\n+         --  literal bounds are constant-folded expressions that carry a user-\n+         --  defined type.\n \n          if Typ = Universal_Integer then\n-            Typ := Standard_Integer;\n+            if Nkind (Lo) = N_Integer_Literal\n+              and then Present (Etype (Lo))\n+              and then Scope (Etype (Lo)) /= Standard_Standard\n+            then\n+               Typ := Etype (Lo);\n+\n+            elsif Nkind (Hi) = N_Integer_Literal\n+              and then Present (Etype (Hi))\n+              and then Scope (Etype (Hi)) /= Standard_Standard\n+            then\n+               Typ := Etype (Hi);\n+\n+            else\n+               Typ := Standard_Integer;\n+            end if;\n          end if;\n \n          Set_Etype (R, Typ);\n@@ -1486,6 +1602,8 @@ package body Sem_Ch5 is\n             if Present (Cond) then\n                Analyze_And_Resolve (Cond, Any_Boolean);\n                Check_Unset_Reference (Cond);\n+               Set_Current_Value_Condition (N);\n+               return;\n \n             --  Else we have a FOR loop\n \n@@ -1686,8 +1804,9 @@ package body Sem_Ch5 is\n    ----------------------------\n \n    procedure Analyze_Loop_Statement (N : Node_Id) is\n-      Id  : constant Node_Id := Identifier (N);\n-      Ent : Entity_Id;\n+      Id   : constant Node_Id := Identifier (N);\n+      Iter : constant Node_Id := Iteration_Scheme (N);\n+      Ent  : Entity_Id;\n \n    begin\n       if Present (Id) then\n@@ -1729,11 +1848,165 @@ package body Sem_Ch5 is\n \n       Kill_Current_Values;\n       New_Scope (Ent);\n-      Analyze_Iteration_Scheme (Iteration_Scheme (N));\n+      Analyze_Iteration_Scheme (Iter);\n       Analyze_Statements (Statements (N));\n       Process_End_Label (N, 'e', Ent);\n       End_Scope;\n       Kill_Current_Values;\n+\n+      --  Check for possible infinite loop which we can diagnose successfully.\n+      --  The case we look for is a while loop which tests a local variable,\n+      --  where there is no obvious direct or indirect update of the variable\n+      --  within the body of the loop.\n+\n+      --  Note: we don't try to give a warning if condition actions are\n+      --  present, since the loop structure can be very complex in this case.\n+\n+      if No (Iter)\n+        or else No (Condition (Iter))\n+        or else Present (Condition_Actions (Iter))\n+        or else Debug_Flag_Dot_W\n+      then\n+         return;\n+      end if;\n+\n+      --  Initial conditions met, see if condition is of right form\n+\n+      declare\n+         Cond : constant Node_Id := Condition (Iter);\n+         Var  : Entity_Id;\n+         Loc  : Node_Id;\n+\n+      begin\n+         --  Condition is a direct variable reference\n+\n+         if Is_Entity_Name (Cond)\n+           and then not Is_Library_Level_Entity (Entity (Cond))\n+         then\n+            Loc := Cond;\n+\n+         --  Case of condition is a comparison with compile time known value\n+\n+         elsif Nkind (Cond) in N_Op_Compare then\n+            if Is_Entity_Name (Left_Opnd (Cond))\n+              and then Compile_Time_Known_Value (Right_Opnd (Cond))\n+            then\n+               Loc := Left_Opnd (Cond);\n+\n+            elsif Is_Entity_Name (Right_Opnd (Cond))\n+              and then Compile_Time_Known_Value (Left_Opnd (Cond))\n+            then\n+               Loc := Right_Opnd (Cond);\n+\n+            else\n+               return;\n+            end if;\n+\n+         --  Case of condition is function call with one parameter\n+\n+         elsif Nkind (Cond) = N_Function_Call then\n+            declare\n+               PA : constant List_Id := Parameter_Associations (Cond);\n+            begin\n+               if Present (PA)\n+                 and then List_Length (PA) = 1\n+                 and then Is_Entity_Name (First (PA))\n+               then\n+                  Loc := First (PA);\n+               else\n+                  return;\n+               end if;\n+            end;\n+\n+         else\n+            return;\n+         end if;\n+\n+         --  If we fall through Loc is set to the node that is an entity ref\n+\n+         Var := Entity (Loc);\n+\n+         if Present (Var)\n+           and then Ekind (Var) = E_Variable\n+           and then not Is_Library_Level_Entity (Var)\n+           and then Comes_From_Source (Var)\n+         then\n+            null;\n+         else\n+            return;\n+         end if;\n+\n+         --  Search for reference to variable in loop\n+\n+         Ref_Search : declare\n+            function Test_Ref (N : Node_Id) return Traverse_Result;\n+            --  Test for reference to variable in question. Returns Abandon\n+            --  if matching reference found.\n+\n+            function Find_Ref is new Traverse_Func (Test_Ref);\n+            --  Function to traverse body of procedure. Returns Abandon if\n+            --  matching reference found.\n+\n+            --------------\n+            -- Test_Ref --\n+            --------------\n+\n+            function Test_Ref (N : Node_Id) return Traverse_Result is\n+            begin\n+               --  Waste of time to look at iteration scheme\n+\n+               if N = Iter then\n+                  return Skip;\n+\n+               --  Direct reference to variable in question\n+\n+               elsif Is_Entity_Name (N)\n+                 and then Present (Entity (N))\n+                 and then Entity (N) = Var\n+                 and then May_Be_Lvalue (N)\n+               then\n+                  return Abandon;\n+\n+                  --  Reference to variable renaming variable in question\n+\n+               elsif Is_Entity_Name (N)\n+                 and then Present (Entity (N))\n+                 and then Ekind (Entity (N)) = E_Variable\n+                 and then Present (Renamed_Object (Entity (N)))\n+                 and then Is_Entity_Name (Renamed_Object (Entity (N)))\n+                 and then Entity (Renamed_Object (Entity (N))) = Var\n+                 and then May_Be_Lvalue (N)\n+               then\n+                  return Abandon;\n+\n+               --  Check for call to other than library level subprogram\n+\n+               elsif Nkind (N) = N_Procedure_Call_Statement\n+                 or else Nkind (N) = N_Function_Call\n+               then\n+                  if not Is_Entity_Name (Name (N))\n+                    or else not Is_Library_Level_Entity (Entity (Name (N)))\n+                  then\n+                     return Abandon;\n+                  end if;\n+               end if;\n+\n+               --  All OK, continue scan\n+\n+               return OK;\n+            end Test_Ref;\n+\n+         --  Start of processing for Ref_Search\n+\n+         begin\n+            if Find_Ref (N) = OK then\n+               Error_Msg_NE\n+                 (\"variable& is not modified in loop body?\", Loc, Var);\n+               Error_Msg_N\n+                 (\"\\possible infinite loop\", Loc);\n+            end if;\n+         end Ref_Search;\n+      end;\n    end Analyze_Loop_Statement;\n \n    ----------------------------\n@@ -1823,72 +2096,6 @@ package body Sem_Ch5 is\n       end loop;\n    end Analyze_Statements;\n \n-   --------------------------------------------\n-   -- Check_Possible_Current_Value_Condition --\n-   --------------------------------------------\n-\n-   procedure Check_Possible_Current_Value_Condition (Cnode : Node_Id) is\n-      Cond : Node_Id;\n-\n-   begin\n-      --  Loop to deal with (ignore for now) any NOT operators present\n-\n-      Cond := Condition (Cnode);\n-      while Nkind (Cond) = N_Op_Not loop\n-         Cond := Right_Opnd (Cond);\n-      end loop;\n-\n-      --  Check possible relational operator\n-\n-      if Nkind (Cond) = N_Op_Eq\n-           or else\n-         Nkind (Cond) = N_Op_Ne\n-           or else\n-         Nkind (Cond) = N_Op_Ge\n-           or else\n-         Nkind (Cond) = N_Op_Le\n-           or else\n-         Nkind (Cond) = N_Op_Gt\n-           or else\n-         Nkind (Cond) = N_Op_Lt\n-      then\n-         if Compile_Time_Known_Value (Right_Opnd (Cond))\n-           and then Nkind (Left_Opnd (Cond)) = N_Identifier\n-         then\n-            declare\n-               Ent : constant Entity_Id := Entity (Left_Opnd (Cond));\n-\n-            begin\n-               if Ekind (Ent) = E_Variable\n-                    or else\n-                  Ekind (Ent) = E_Constant\n-                    or else\n-                  Is_Formal (Ent)\n-                    or else\n-                  Ekind (Ent) = E_Loop_Parameter\n-               then\n-                  --  Here we have a case where the Current_Value field\n-                  --  may need to be set. We set it if it is not already\n-                  --  set to a compile time expression value.\n-\n-                  --  Note that this represents a decision that one\n-                  --  condition blots out another previous one. That's\n-                  --  certainly right if they occur at the same level.\n-                  --  If the second one is nested, then the decision is\n-                  --  neither right nor wrong (it would be equally OK\n-                  --  to leave the outer one in place, or take the new\n-                  --  inner one. Really we should record both, but our\n-                  --  data structures are not that elaborate.\n-\n-                  if Nkind (Current_Value (Ent)) not in N_Subexpr then\n-                     Set_Current_Value (Ent, Cnode);\n-                  end if;\n-               end if;\n-            end;\n-         end if;\n-      end if;\n-   end Check_Possible_Current_Value_Condition;\n-\n    ----------------------------\n    -- Check_Unreachable_Code --\n    ----------------------------"}, {"sha": "47358830c5612325e45b36057c35f5d4a0bd9dbd", "filename": "gcc/ada/sem_ch5.ads", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da/gcc%2Fada%2Fsem_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a806772b8dfacc2c8cd8dcfbaf83c034634e4da/gcc%2Fada%2Fsem_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.ads?ref=2a806772b8dfacc2c8cd8dcfbaf83c034634e4da", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,15 +47,6 @@ package Sem_Ch5 is\n    --  care of setting Reachable, since labels defined by the expander can\n    --  be assumed to be reachable.\n \n-   procedure Check_Possible_Current_Value_Condition (Cnode : Node_Id);\n-   --  Cnode is N_If_Statement, N_Elsif_Part, or N_Iteration_Scheme\n-   --  (the latter when a WHILE condition is present). This call checks\n-   --  if Condition (Cnode) is of the form ([NOT] var op val), where var\n-   --  is a simple object, val is known at compile time, and op is one\n-   --  of the six relational operators. If this is the case, and the\n-   --  Current_Value field of \"var\" is not set, then it is set to Cnode.\n-   --  See Exp_Util.Set_Current_Value_Condition for further details.\n-\n    procedure Check_Unreachable_Code (N : Node_Id);\n    --  This procedure is called with N being the node for a statement that\n    --  is an unconditional transfer of control. It checks to see if the"}]}