{"sha": "d79f08e0b8c18dae25ccf9ce7f61862f2c148d00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc5ZjA4ZTBiOGMxOGRhZTI1Y2NmOWNlN2Y2MTg2MmYyYzE0OGQwMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-09T10:45:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-09T10:45:36Z"}, "message": "(combine_instructions): When calling set_nonzero_bits_and_sign_copies,\n\nset things up so that we can call get_last value; call\nrecord_dead_and_set_regs in loop.\n(set_nonzero_bits_and_sign_copies): Handle paradoxical SET.\n\nFrom-SVN: r3444", "tree": {"sha": "aa5b23a06f3cc623b21051a2940f320948d3cb6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa5b23a06f3cc623b21051a2940f320948d3cb6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d79f08e0b8c18dae25ccf9ce7f61862f2c148d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79f08e0b8c18dae25ccf9ce7f61862f2c148d00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79f08e0b8c18dae25ccf9ce7f61862f2c148d00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79f08e0b8c18dae25ccf9ce7f61862f2c148d00/comments", "author": null, "committer": null, "parents": [{"sha": "b6542989bcdb2cb4d562950e5937eec091d47c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6542989bcdb2cb4d562950e5937eec091d47c53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6542989bcdb2cb4d562950e5937eec091d47c53"}], "stats": {"total": 34, "additions": 31, "deletions": 3}, "files": [{"sha": "5f45cd6e895e20706cb34118fbef1c20356384fc", "filename": "gcc/combine.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d79f08e0b8c18dae25ccf9ce7f61862f2c148d00/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d79f08e0b8c18dae25ccf9ce7f61862f2c148d00/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d79f08e0b8c18dae25ccf9ce7f61862f2c148d00", "patch": "@@ -451,13 +451,27 @@ combine_instructions (f, nregs)\n \n      Scan all SETs and see if we can deduce anything about what\n      bits are known to be zero for some registers and how many copies\n-     of the sign bit are known to exist for those registers.  */\n+     of the sign bit are known to exist for those registers.\n+\n+     Also set any known values so that we can use it while searching\n+     for what bits are known to be set.  */\n+\n+  label_tick = 1;\n \n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n       INSN_CUID (insn) = ++i;\n+      subst_low_cuid = i;\n+      subst_insn = insn;\n+\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\tnote_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies);\n+\t{\n+\t  note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies);\n+\t  record_dead_and_set_regs (insn);\n+\t}\n+\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tlabel_tick++;\n     }\n \n   nonzero_sign_valid = 1;\n@@ -467,6 +481,12 @@ combine_instructions (f, nregs)\n   label_tick = 1;\n   last_call_cuid = 0;\n   mem_last_set = 0;\n+  bzero (reg_last_death, nregs * sizeof (rtx));\n+  bzero (reg_last_set, nregs * sizeof (rtx));\n+  bzero (reg_last_set_value, nregs * sizeof (rtx));\n+  bzero (reg_last_set_table_tick, nregs * sizeof (short));\n+  bzero (reg_last_set_label, nregs * sizeof (short));\n+  bzero (reg_last_set_invalid, nregs * sizeof (char));\n \n   for (insn = f; insn; insn = next ? next : NEXT_INSN (insn))\n     {\n@@ -606,7 +626,15 @@ set_nonzero_bits_and_sign_copies (x, set)\n       /* If this is a complex assignment, see if we can convert it into a\n \t simple assignment.  */\n       set = expand_field_assignment (set);\n-      if (SET_DEST (set) == x)\n+\n+      /* If this is a simple assignment, or we have a paradoxical SUBREG,\n+\t set what we know about X.  */\n+\n+      if (SET_DEST (set) == x\n+\t  || (GET_CODE (SET_DEST (set)) == SUBREG\n+\t      && (GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n+\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x)))))\n+\t      && SUBREG_REG (SET_DEST (set)) == x))\n \t{\n \t  reg_nonzero_bits[REGNO (x)]\n \t    |= nonzero_bits (SET_SRC (set), nonzero_bits_mode);"}]}