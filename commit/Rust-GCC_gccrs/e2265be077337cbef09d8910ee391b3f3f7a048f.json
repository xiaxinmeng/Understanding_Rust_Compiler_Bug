{"sha": "e2265be077337cbef09d8910ee391b3f3f7a048f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIyNjViZTA3NzMzN2NiZWYwOWQ4OTEwZWUzOTFiM2YzZjdhMDQ4Zg==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@rr.iij4u.or.jp", "date": "2007-01-18T17:04:21Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2007-01-18T17:04:21Z"}, "message": "m32r-protos.h (m32r_expand_epilogue): Declare it.\n\n* config/m32r/m32r-protos.h (m32r_expand_epilogue): Declare it.\n* config/m32r/m32r.c (m32r_setup_incoming_varargs): Use gen_frame_mem.\n  (m32r_compute_frame_size): Use unsigned for regno.\n  (m32r_reload_lr): Use gen_frame_mem.\n  (pop): New.\n  (m32r_output_function_epilogue): Don't output the function epilogue textually here.\n  (m32r_expand_epilogue): New.\n  (direct_return): Return false if the function has the interrupt attribute.\n  (m32r_hard_regno_rename_ok): Remove code for the textual epilogue.\n* config/m32r/m32r.md (epilogue): New expander.\n  (return_lr, return_rte): New insns.\n  (return): Make it expander.\n  (return_normal): New expander.\n\nFrom-SVN: r120904", "tree": {"sha": "1ad9e5ce04be82cf522c7d6e5355f81fe06f3316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ad9e5ce04be82cf522c7d6e5355f81fe06f3316"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2265be077337cbef09d8910ee391b3f3f7a048f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2265be077337cbef09d8910ee391b3f3f7a048f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2265be077337cbef09d8910ee391b3f3f7a048f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2265be077337cbef09d8910ee391b3f3f7a048f/comments", "author": {"login": "kazkojima", "id": 14949970, "node_id": "MDQ6VXNlcjE0OTQ5OTcw", "avatar_url": "https://avatars.githubusercontent.com/u/14949970?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kazkojima", "html_url": "https://github.com/kazkojima", "followers_url": "https://api.github.com/users/kazkojima/followers", "following_url": "https://api.github.com/users/kazkojima/following{/other_user}", "gists_url": "https://api.github.com/users/kazkojima/gists{/gist_id}", "starred_url": "https://api.github.com/users/kazkojima/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kazkojima/subscriptions", "organizations_url": "https://api.github.com/users/kazkojima/orgs", "repos_url": "https://api.github.com/users/kazkojima/repos", "events_url": "https://api.github.com/users/kazkojima/events{/privacy}", "received_events_url": "https://api.github.com/users/kazkojima/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bfcb91214958cbe7b86b184bae34f8d07db4dbbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfcb91214958cbe7b86b184bae34f8d07db4dbbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfcb91214958cbe7b86b184bae34f8d07db4dbbc"}], "stats": {"total": 355, "additions": 209, "deletions": 146}, "files": [{"sha": "c54f4a67cbb3072ba09f82686c4f2eae9c32f31e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2265be077337cbef09d8910ee391b3f3f7a048f", "patch": "@@ -1,3 +1,21 @@\n+2007-01-18  Kaz Kojima  <kkojima@rr.iij4u.or.jp>\n+\n+\t* config/m32r/m32r-protos.h (m32r_expand_epilogue): Declare it.\n+\t* config/m32r/m32r.c (m32r_setup_incoming_varargs): Use gen_frame_mem.\n+\t(m32r_compute_frame_size): Use unsigned for regno.\n+\t(m32r_reload_lr): Use gen_frame_mem.\n+\t(pop): New.\n+\t(m32r_output_function_epilogue): Don't output the function epilogue\n+\ttextually here.\n+\t(m32r_expand_epilogue): New.\n+\t(direct_return): Return false if the function has the interrupt\n+\tattribute.\n+\t(m32r_hard_regno_rename_ok): Remove code for the textual epilogue.\n+\t* config/m32r/m32r.md (epilogue): New expander.\n+\t(return_lr, return_rte): New insns.\n+\t(return): Make it expander.\n+\t(return_normal): New expander.\n+\n 2007-01-18  Josh Conner  <jconner@apple.com>\n \n \tPR target/30485"}, {"sha": "f6cd29cf31c619e46ad22ff7056d03b16abc81d3", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=e2265be077337cbef09d8910ee391b3f3f7a048f", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for m32r.c functions used in the md file & elsewhere.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -27,6 +27,7 @@ extern void   m32r_init (void);\n extern void   m32r_init_expanders (void);\n extern unsigned m32r_compute_frame_size (int);\n extern void   m32r_expand_prologue (void);\n+extern void   m32r_expand_epilogue (void);\n extern int    direct_return (void);\n extern void   m32r_load_pic_register (void);\n "}, {"sha": "9b288f319a1ecbf78b2d9c5838d88387b0aaa529", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=e2265be077337cbef09d8910ee391b3f3f7a048f", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on the Renesas M32R cpu.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005 Free Software Foundation, Inc.\n+   2005, 2007 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -273,7 +273,7 @@ init_reg_tables (void)\n \t    m32r_mode_class[i] = 1 << (int) T_MODE;\n \t  else if (GET_MODE_SIZE (i) == 32)\n \t    m32r_mode_class[i] = 1 << (int) O_MODE;\n-\t  else \n+\t  else\n \t    m32r_mode_class[i] = 0;\n \t  break;\n \tcase MODE_FLOAT:\n@@ -286,7 +286,7 @@ init_reg_tables (void)\n \t    m32r_mode_class[i] = 1 << (int) TF_MODE;\n \t  else if (GET_MODE_SIZE (i) == 32)\n \t    m32r_mode_class[i] = 1 << (int) OF_MODE;\n-\t  else \n+\t  else\n \t    m32r_mode_class[i] = 0;\n \t  break;\n \tcase MODE_CC:\n@@ -695,8 +695,8 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t      && CMP_INT16_P (INTVAL (y))\t\t/* Reg equal to small const.  */\n \t      && y != const0_rtx)\n \t    {\n-\t      rtx tmp = gen_reg_rtx (SImode);\t\t\n-\t      \n+\t      rtx tmp = gen_reg_rtx (SImode);\n+\n \t      emit_insn (gen_addsi3 (tmp, x, GEN_INT (-INTVAL (y))));\n \t      x = tmp;\n \t      y = const0_rtx;\n@@ -711,17 +711,17 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t      || y == const0_rtx) \t   \t\t/* Reg equal to zero.  */\n \t    {\n \t      emit_insn (gen_cmp_eqsi_insn (x, y));\n-\t\t\n+\n \t      return gen_rtx_fmt_ee (code, CCmode, cc_reg, const0_rtx);\n \t    }\n \t  break;\n-      \n+\n \tcase LT:\n \t  if (register_operand (y, SImode)\n \t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\t      /* Reg compared to reg.  */\n-\t      \n+\n \t      switch (code)\n \t\t{\n \t\tcase LT:\n@@ -751,17 +751,17 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n-\t      \n+\n \t      return gen_rtx_fmt_ee (code, CCmode, cc_reg, const0_rtx);\n \t    }\n \t  break;\n-\t  \n+\n \tcase LTU:\n \t  if (register_operand (y, SImode)\n \t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\t      /* Reg (unsigned) compared to reg.  */\n-\t      \n+\n \t      switch (code)\n \t\t{\n \t\tcase LTU:\n@@ -791,7 +791,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n-\t      \n+\n \t      return gen_rtx_fmt_ee (code, CCmode, cc_reg, const0_rtx);\n \t    }\n \t  break;\n@@ -806,12 +806,12 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n       if (compare_code == EQ\n \t  && register_operand (y, SImode))\n \treturn gen_rtx_fmt_ee (code, CCmode, x, y);\n-      \n+\n       /* Reg/zero signed comparison.  */\n       if ((compare_code == EQ || compare_code == LT)\n \t  && y == const0_rtx)\n \treturn gen_rtx_fmt_ee (code, CCmode, x, y);\n-      \n+\n       /* Reg/smallconst equal comparison.  */\n       if (compare_code == EQ\n \t  && GET_CODE (y) == CONST_INT\n@@ -822,7 +822,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t  emit_insn (gen_addsi3 (tmp, x, GEN_INT (-INTVAL (y))));\n \t  return gen_rtx_fmt_ee (code, CCmode, tmp, const0_rtx);\n \t}\n-      \n+\n       /* Reg/const equal comparison.  */\n       if (compare_code == EQ\n \t  && CONSTANT_P (y))\n@@ -1045,9 +1045,9 @@ m32r_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       int size = M32R_MAX_PARM_REGS - first_reg_offset;\n       rtx regblock;\n \n-      regblock = gen_rtx_MEM (BLKmode,\n-\t\t\t      plus_constant (arg_pointer_rtx,\n-\t\t\t\t\t     FIRST_PARM_OFFSET (0)));\n+      regblock = gen_frame_mem (BLKmode,\n+\t\t\t\tplus_constant (arg_pointer_rtx,\n+\t\t\t\t\t       FIRST_PARM_OFFSET (0)));\n       set_mem_alias_set (regblock, get_varargs_alias_set ());\n       move_block_from_reg (first_reg_offset, regblock, size);\n \n@@ -1191,30 +1191,30 @@ m32r_compute_function_type (tree decl)\n         |                       |       |                       |\n   SP+0->+-----------------------+       +-----------------------+\n                                         |  reg parm save area,  |\n-                                        |  only created for     |    \n-                                        |  variable argument    |    \n-                                        |  functions            |    \n+                                        |  only created for     |\n+                                        |  variable argument    |\n+                                        |  functions            |\n \t\t\t\t\t+-----------------------+\n                                         |   previous frame ptr  |\n-                                        +-----------------------+    \n-                                        |                       |    \n-                                        |  register save area   |    \n-                                        |                       |    \n+                                        +-----------------------+\n+                                        |                       |\n+                                        |  register save area   |\n+                                        |                       |\n \t\t\t\t\t+-----------------------+\n-                                        |    return address     |    \n-                                        +-----------------------+    \n-                                        |                       |    \n-                                        |  local variables      |    \n-                                        |                       |    \n-                                        +-----------------------+    \n-                                        |                       |    \n-                                        |  alloca allocations   |    \n-                                        |                       |    \n-                                        +-----------------------+    \n-                                        |                       |    \n-   low                                  |  arguments on stack   |    \n-   memory                               |                       |    \n-                                  SP+0->+-----------------------+    \n+                                        |    return address     |\n+                                        +-----------------------+\n+                                        |                       |\n+                                        |  local variables      |\n+                                        |                       |\n+                                        +-----------------------+\n+                                        |                       |\n+                                        |  alloca allocations   |\n+                                        |                       |\n+                                        +-----------------------+\n+                                        |                       |\n+   low                                  |  arguments on stack   |\n+   memory                               |                       |\n+                                  SP+0->+-----------------------+\n \n Notes:\n 1) The \"reg parm save area\" does not exist for non variable argument fns.\n@@ -1270,7 +1270,7 @@ static struct m32r_frame_info zero_frame_info;\n unsigned int\n m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n {\n-  int regno;\n+  unsigned int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n   unsigned int reg_size, frame_size;\n   unsigned int gmask;\n@@ -1332,25 +1332,25 @@ m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n \f\n /* The table we use to reference PIC data.  */\n static rtx global_offset_table;\n-                                                                                \n+\n static void\n m32r_reload_lr (rtx sp, int size)\n {\n   rtx lr = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n \n   if (size == 0)\n-    emit_insn (gen_movsi (lr, gen_rtx_MEM (Pmode, sp)));\n+    emit_insn (gen_movsi (lr, gen_frame_mem (Pmode, sp)));\n   else if (size < 32768)\n-    emit_insn (gen_movsi (lr, gen_rtx_MEM (Pmode,\n-\t\t\t\t\t   gen_rtx_PLUS (Pmode, sp,\n-\t\t\t\t\t\t\t GEN_INT (size)))));\n+    emit_insn (gen_movsi (lr, gen_frame_mem (Pmode,\n+\t\t\t\t\t     gen_rtx_PLUS (Pmode, sp,\n+\t\t\t\t\t\t\t   GEN_INT (size)))));\n   else\n-    {   \n+    {\n       rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TMP_REGNUM);\n \n       emit_insn (gen_movsi (tmp, GEN_INT (size)));\n       emit_insn (gen_addsi3 (tmp, tmp, sp));\n-      emit_insn (gen_movsi (lr, gen_rtx_MEM (Pmode, tmp)));\n+      emit_insn (gen_movsi (lr, gen_frame_mem (Pmode, tmp)));\n     }\n \n   emit_insn (gen_rtx_USE (VOIDmode, lr));\n@@ -1362,7 +1362,7 @@ m32r_load_pic_register (void)\n   global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n   emit_insn (gen_get_pc (pic_offset_table_rtx, global_offset_table,\n                          GEN_INT (TARGET_MODEL_SMALL)));\n-                                                                                \n+\n   /* Need to emit this whether or not we obey regdecls,\n      since setjmp/longjmp can cause life info to screw up.  */\n   emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n@@ -1442,7 +1442,7 @@ m32r_expand_prologue (void)\n     /* Push lr for mcount (form_pc, x).  */\n     emit_insn (gen_movsi_push (stack_pointer_rtx,\n                                gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)));\n-                                                                                \n+\n   if (pic_reg_used)\n     {\n       m32r_load_pic_register ();\n@@ -1481,19 +1481,27 @@ m32r_output_function_prologue (FILE * file, HOST_WIDE_INT size)\n \t   current_frame_info.extra_size);\n }\n \f\n-/* Do any necessary cleanup after a function to restore stack, frame,\n-   and regs.  */\n+/* Output RTL to pop register REGNO from the stack.  */\n \n static void\n-m32r_output_function_epilogue (FILE * file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+pop (int regno)\n+{\n+  rtx x;\n+\n+  x = emit_insn (gen_movsi_pop (gen_rtx_REG (Pmode, regno),\n+\t\t\t\tstack_pointer_rtx));\n+  REG_NOTES (x)\n+    = gen_rtx_EXPR_LIST (REG_INC, stack_pointer_rtx, 0);\n+}\n+\n+/* Expand the m32r epilogue as a series of insns.  */\n+\n+void\n+m32r_expand_epilogue (void)\n {\n   int regno;\n   int noepilogue = FALSE;\n   int total_size;\n-  enum m32r_function_type fn_type = m32r_compute_function_type (current_function_decl);\n-\n-  /* This is only for the human reader.  */\n-  fprintf (file, \"\\t%s EPILOGUE\\n\", ASM_COMMENT_START);\n \n   gcc_assert (current_frame_info.initialized);\n   total_size = current_frame_info.total_size;\n@@ -1504,7 +1512,7 @@ m32r_output_function_epilogue (FILE * file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n       /* If the last insn was a BARRIER, we don't have to write any code\n \t because a jump (aka return) was put there.  */\n-      if (GET_CODE (insn) == NOTE)\n+      if (insn && GET_CODE (insn) == NOTE)\n \tinsn = prev_nonnote_insn (insn);\n       if (insn && GET_CODE (insn) == BARRIER)\n \tnoepilogue = TRUE;\n@@ -1516,88 +1524,82 @@ m32r_output_function_epilogue (FILE * file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       unsigned int args_size = current_frame_info.args_size;\n       unsigned int gmask = current_frame_info.gmask;\n       int can_trust_sp_p = !current_function_calls_alloca;\n-      const char * sp_str = reg_names[STACK_POINTER_REGNUM];\n-      const char * fp_str = reg_names[FRAME_POINTER_REGNUM];\n+\n+      if (flag_exceptions)\n+        emit_insn (gen_blockage ());\n \n       /* The first thing to do is point the sp at the bottom of the register\n \t save area.  */\n       if (can_trust_sp_p)\n \t{\n \t  unsigned int reg_offset = var_size + args_size;\n+\n \t  if (reg_offset == 0)\n \t    ; /* Nothing to do.  */\n-\t  else if (reg_offset < 128)\n-\t    fprintf (file, \"\\taddi %s,%s%d\\n\",\n-\t\t     sp_str, IMMEDIATE_PREFIX, reg_offset);\n \t  else if (reg_offset < 32768)\n-\t    fprintf (file, \"\\tadd3 %s,%s,%s%d\\n\",\n-\t\t     sp_str, sp_str, IMMEDIATE_PREFIX, reg_offset);\n-\t  else if (reg_offset < (1 << 24))\n-\t    fprintf (file, \"\\tld24 %s,%s%d\\n\\tadd %s,%s\\n\",\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     IMMEDIATE_PREFIX, reg_offset,\n-\t\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   GEN_INT (reg_offset)));\n \t  else\n-\t    fprintf (file, \"\\tseth %s,%s%d\\n\\tor3 %s,%s,%s%d\\n\\tadd %s,%s\\n\",\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     IMMEDIATE_PREFIX, reg_offset >> 16,\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     IMMEDIATE_PREFIX, reg_offset & 0xffff,\n-\t\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+\t    {\n+\t      rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TMP_REGNUM);\n+\n+\t      emit_insn (gen_movsi (tmp, GEN_INT (reg_offset)));\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     tmp));\n+\t    }\n \t}\n       else if (frame_pointer_needed)\n \t{\n \t  unsigned int reg_offset = var_size + args_size;\n \n \t  if (reg_offset == 0)\n-\t    fprintf (file, \"\\tmv %s,%s\\n\", sp_str, fp_str);\n+\t    emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n \t  else if (reg_offset < 32768)\n-\t    fprintf (file, \"\\tadd3 %s,%s,%s%d\\n\",\n-\t\t     sp_str, fp_str, IMMEDIATE_PREFIX, reg_offset);\n-\t  else if (reg_offset < (1 << 24))\n-\t    fprintf (file, \"\\tld24 %s,%s%d\\n\\tadd %s,%s\\n\",\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     IMMEDIATE_PREFIX, reg_offset,\n-\t\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx, frame_pointer_rtx,\n+\t\t\t   GEN_INT (reg_offset)));\n \t  else\n-\t    fprintf (file, \"\\tseth %s,%s%d\\n\\tor3 %s,%s,%s%d\\n\\tadd %s,%s\\n\",\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     IMMEDIATE_PREFIX, reg_offset >> 16,\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t\t     IMMEDIATE_PREFIX, reg_offset & 0xffff,\n-\t\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+\t    {\n+\t      rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TMP_REGNUM);\n+\n+\t      emit_insn (gen_movsi (tmp, GEN_INT (reg_offset)));\n+\t      emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     tmp));\n+\t    }\n \t}\n       else\n \tgcc_unreachable ();\n \n       if (current_frame_info.save_lr)\n-\tfprintf (file, \"\\tpop %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n+\tpop (RETURN_ADDR_REGNUM);\n \n       /* Restore any saved registers, in reverse order of course.  */\n       gmask &= ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK);\n       for (regno = M32R_MAX_INT_REGS - 1; regno >= 0; --regno)\n \t{\n \t  if ((gmask & (1L << regno)) != 0)\n-\t    fprintf (file, \"\\tpop %s\\n\", reg_names[regno]);\n+\t    pop (regno);\n \t}\n \n       if (current_frame_info.save_fp)\n-\tfprintf (file, \"\\tpop %s\\n\", fp_str);\n+\tpop (FRAME_POINTER_REGNUM);\n \n       /* Remove varargs area if present.  */\n       if (current_frame_info.pretend_size != 0)\n-\tfprintf (file, \"\\taddi %s,%s%d\\n\",\n-\t\t sp_str, IMMEDIATE_PREFIX, current_frame_info.pretend_size);\n-\t\n-      /* Emit the return instruction.  */\n-      if (M32R_INTERRUPT_P (fn_type))\n-\tfprintf (file, \"\\trte\\n\");\n-      else\n-\tfprintf (file, \"\\tjmp %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n+\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (current_frame_info.pretend_size)));\n+\n+      emit_insn (gen_blockage ());\n     }\n+}\n+\n+/* Do any necessary cleanup after a function to restore stack, frame,\n+   and regs.  */\n \n+static void\n+m32r_output_function_epilogue (FILE * file ATTRIBUTE_UNUSED,\n+\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n   /* Reset state info for each function.  */\n   current_frame_info = zero_frame_info;\n   m32r_compute_function_type (NULL_TREE);\n@@ -1612,10 +1614,13 @@ direct_return (void)\n   if (!reload_completed)\n     return FALSE;\n \n+  if (M32R_INTERRUPT_P (m32r_compute_function_type (current_function_decl)))\n+    return FALSE;\n+\n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (get_frame_size ());\n \n-   return current_frame_info.total_size == 0;\n+  return current_frame_info.total_size == 0;\n }\n \n \f\n@@ -1626,14 +1631,14 @@ m32r_legitimate_pic_operand_p (rtx x)\n {\n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n     return 0;\n-                                                                                \n+\n   if (GET_CODE (x) == CONST\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n           || GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)\n       && (GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))\n     return 0;\n-                                                                                \n+\n   return 1;\n }\n \n@@ -1773,7 +1778,7 @@ m32r_print_operand (FILE * file, rtx x, int code)\n       else\n \toutput_operand_lossage (\"invalid operand to %%s code\");\n       return;\n-      \n+\n     case 'p':\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"@%s+\", reg_names [REGNO (x)]);\n@@ -2096,14 +2101,14 @@ emit_cond_move (rtx * operands, rtx insn ATTRIBUTE_UNUSED)\n {\n   static char buffer [100];\n   const char * dest = reg_names [REGNO (operands [0])];\n-  \n+\n   buffer [0] = 0;\n-  \n+\n   /* Destination must be a register.  */\n   gcc_assert (GET_CODE (operands [0]) == REG);\n   gcc_assert (conditional_move_operand (operands [2], SImode));\n   gcc_assert (conditional_move_operand (operands [3], SImode));\n-      \n+\n   /* Check to see if the test is reversed.  */\n   if (GET_CODE (operands [1]) == NE)\n     {\n@@ -2130,19 +2135,19 @@ m32r_not_same_reg (rtx a, rtx b)\n {\n   int reg_a = -1;\n   int reg_b = -2;\n-  \n+\n   while (GET_CODE (a) == SUBREG)\n     a = SUBREG_REG (a);\n-  \n+\n   if (GET_CODE (a) == REG)\n     reg_a = REGNO (a);\n-  \n+\n   while (GET_CODE (b) == SUBREG)\n     b = SUBREG_REG (b);\n-  \n+\n   if (GET_CODE (b) == REG)\n     reg_b = REGNO (b);\n-  \n+\n   return reg_a != reg_b;\n }\n \n@@ -2163,7 +2168,7 @@ m32r_function_symbol (const char *name)\n   else\n     gcc_unreachable (); /* Shouldn't happen.  */\n   extra_flags |= model << SYMBOL_FLAG_MODEL_SHIFT;\n-                                                                                \n+\n   if (extra_flags)\n     SYMBOL_REF_FLAGS (sym) |= extra_flags;\n \n@@ -2232,7 +2237,7 @@ m32r_expand_block_move (rtx operands[])\n \n   leftover = bytes % MAX_MOVE_BYTES;\n   bytes   -= leftover;\n-  \n+\n   /* If necessary, generate a loop to handle the bulk of the copy.  */\n   if (bytes)\n     {\n@@ -2272,7 +2277,7 @@ m32r_expand_block_move (rtx operands[])\n       emit_move_insn (dst_reg, new_dst_reg);\n       emit_move_insn (src_reg, new_src_reg);\n       emit_insn (gen_addsi3 (dst_reg, dst_reg, GEN_INT (4)));\n-      \n+\n       if (bytes > MAX_MOVE_BYTES)\n \t{\n \t  emit_insn (gen_cmpsi (src_reg, final_src));\n@@ -2288,7 +2293,7 @@ m32r_expand_block_move (rtx operands[])\n }\n \n \f\n-/* Emit load/stores for a small constant word aligned block_move. \n+/* Emit load/stores for a small constant word aligned block_move.\n \n    operands[0] is the memory address of the destination.\n    operands[1] is the memory address of the source.\n@@ -2302,17 +2307,17 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n   HOST_WIDE_INT bytes = INTVAL (operands[2]);\n   int\t\tfirst_time;\n   int\t\tgot_extra = 0;\n-  \n+\n   gcc_assert (bytes >= 1 && bytes <= MAX_MOVE_BYTES);\n-  \n+\n   /* We do not have a post-increment store available, so the first set of\n      stores are done without any increment, then the remaining ones can use\n      the pre-increment addressing mode.\n-     \n+\n      Note: expand_block_move() also relies upon this behavior when building\n      loops to copy large blocks.  */\n   first_time = 1;\n-  \n+\n   while (bytes > 0)\n     {\n       if (bytes >= 8)\n@@ -2338,20 +2343,20 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t{\n \t  if (bytes > 4)\n \t    got_extra = 1;\n-\t  \n+\n \t  output_asm_insn (\"ld\\t%5, %p1\", operands);\n-\t  \n+\n \t  if (got_extra)\n \t    output_asm_insn (\"ld\\t%6, %p1\", operands);\n-\t\t\n+\n \t  if (first_time)\n \t    output_asm_insn (\"st\\t%5, @%0\", operands);\n \t  else\n \t    output_asm_insn (\"st\\t%5, %s0\", operands);\n \n \t  bytes -= 4;\n \t}\n-      else \n+      else\n \t{\n \t  /* Get the entire next word, even though we do not want all of it.\n \t     The saves us from doing several smaller loads, and we assume that\n@@ -2381,7 +2386,7 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t      my_operands[1] = GEN_INT (dst_offset);\n \t      my_operands[2] = operands[0];\n \t      output_asm_insn (\"sth\\t%0, @(%1,%2)\", my_operands);\n-\t      \n+\n \t      /* If there is a byte left to store then increment the\n \t\t destination address and shift the contents of the source\n \t\t register down by 8 bits.  We could not do the address\n@@ -2417,7 +2422,7 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t      my_operands[1] = GEN_INT (dst_inc_amount);\n \t      output_asm_insn (\"addi\\t%0, #%1\", my_operands);\n \t    }\n-\t  \n+\n \t  /* Update the source pointer if needed.  We have to do this\n \t     so that the patterns matches what we output in this\n \t     function.  */\n@@ -2428,7 +2433,7 @@ m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t      my_operands[1] = GEN_INT (src_inc_amount);\n \t      output_asm_insn (\"addi\\t%0, #%1\", my_operands);\n \t    }\n-\t  \n+\n \t  bytes = 0;\n \t}\n \n@@ -2447,11 +2452,6 @@ m32r_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n       && !regs_ever_live[new_reg])\n     return 0;\n \n-  /* We currently emit epilogues as text, not rtl, so the liveness\n-     of the return address register isn't visible.  */\n-  if (current_function_is_leaf && new_reg == RETURN_ADDR_REGNUM)\n-    return 0;\n-\n   return 1;\n }\n \n@@ -2460,6 +2460,6 @@ m32r_return_addr (int count)\n {\n   if (count != 0)\n     return const0_rtx;\n-  \n+\n   return get_hard_reg_initial_val (Pmode, RETURN_ADDR_REGNUM);\n }"}, {"sha": "2487dd893e86779f345351733fe96b74d7ca4480", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2265be077337cbef09d8910ee391b3f3f7a048f/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=e2265be077337cbef09d8910ee391b3f3f7a048f", "patch": "@@ -1,6 +1,6 @@\n ;; Machine description of the Renesas M32R cpu for GNU C compiler\n-;; Copyright (C) 1996, 1997, 1998, 1999, 2001, 2003, 2004, 2005\n-;  Free Software Foundation, Inc.\n+;; Copyright (C) 1996, 1997, 1998, 1999, 2001, 2003, 2004, 2005,\n+;  2007 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n@@ -200,7 +200,7 @@\n \n \f\n (include \"predicates.md\")\n-  \n+\n ;; Expand prologue as RTL\n (define_expand \"prologue\"\n   [(const_int 1)]\n@@ -211,6 +211,16 @@\n   DONE;\n }\")\n \n+;; Expand epilogue as RTL\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  m32r_expand_epilogue ();\n+  emit_jump_insn (gen_return_normal ());\n+  DONE;\n+}\")\n \f\n ;; Move instructions.\n ;;\n@@ -1166,7 +1176,7 @@\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n \n-;; We generate RTL for comparisons and branches by having the cmpxx \n+;; We generate RTL for comparisons and branches by having the cmpxx\n ;; patterns store away the operands.  Then the bcc patterns\n ;; emit RTL for both the compare and the branch.\n ;;\n@@ -1795,7 +1805,7 @@\n    (set (match_dup 0)\n \t(ne:SI (reg:CC 17) (const_int 0)))]\n   \"\")\n-\t\n+\n (define_expand \"slt\"\n   [(match_operand:SI 0 \"register_operand\" \"\")]\n   \"\"\n@@ -2270,13 +2280,47 @@\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"length\" \"2\")])\n \n-(define_insn \"return\"\n-  [(return)]\n-  \"direct_return ()\"\n+(define_insn \"return_lr\"\n+  [(parallel [(return) (use (reg:SI 14))])]\n+  \"\"\n   \"jmp lr\"\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"length\" \"2\")])\n- \n+\n+(define_insn \"return_rte\"\n+  [(return)]\n+  \"\"\n+  \"rte\"\n+  [(set_attr \"type\" \"uncond_branch\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"return\"\n+  [(return)]\n+  \"direct_return ()\"\n+  \"\n+{\n+  emit_jump_insn (gen_return_lr ());\n+  DONE;\n+}\")\n+\n+(define_expand \"return_normal\"\n+  [(return)]\n+  \"!direct_return ()\"\n+  \"\n+{\n+  enum m32r_function_type fn_type;\n+\n+  fn_type = m32r_compute_function_type (current_function_decl);\n+  if (M32R_INTERRUPT_P (fn_type))\n+    {\n+      emit_jump_insn (gen_return_rte ());\n+      DONE;\n+    }\n+\n+  emit_jump_insn (gen_return_lr ());\n+  DONE;\n+}\")\n+\n (define_expand \"tablejump\"\n   [(parallel [(set (pc) (match_operand 0 \"register_operand\" \"r\"))\n               (use (label_ref (match_operand 1 \"\" \"\")))])]\n@@ -2367,7 +2411,7 @@\n \t\t\t (match_operand 2 \"\" \"\")))\n \t     (clobber (reg:SI 14))])]\n   \"\"\n-  \"                                                                             \n+  \"\n {\n   if (flag_pic)\n     current_function_uses_pic_offset_table = 1;"}]}