{"sha": "f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJlZDllOTY1NmEzNzVjZjgwYjExZGZiM2EyNjRhNzU1MTY1NGVjZA==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "1999-05-26T17:00:06Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "1999-05-26T17:00:06Z"}, "message": "[multiple changes]\n\n1999-05-26  Bryce McKinlay <bryce@albatross.co.nz>\n\t* java/net/DatagramSocket.java (getSoTimeout): Verify class type.\n\t* java/net/DatagramSocketImpl.java (getOption): Made abstract.\n\t(setOption): Made abstract.\n\t* java/net/PlainDatagramSocketImpl.java: Mirror SocketOptions fields\n\tto avoid cpp conflicts in native code.\n\t* java/net/PlainSocketImpl.java: Mirror SocketOptions fields to avoid\n\tcpp conflicts in native code.\n\t* java/net/ServerSocket.java (toString): Prepended \"ServerSocket\".\n\t* java/net/Socket.java (getLocalAddress): Implemented.\n\t(setTcpNoDelay): Implemented.\n\t(getTcpNoDelay): Implemented.\n\t(setSoLinger): Implemented.\n\t(getSoLinger): Implemented.\n\t(getSoTimeout): Verify class type.\n\t(setSendBufferSize): Implemented.\n\t(getSendBufferSize): Implemented.\n\t(setReceiveBufferSize): Implemented.\n\t(getReceiveBufferSize): Implemented.\n\t(toString): Prepended \"Socket\".\n\t* java/net/SocketImpl.java (toString): Rewritten.\n\t(getOption): Made abstract.\n\t(setOption): Made abstract.\n\t* java/net/natPlainSocketImpl.cc (connect): Set localport properly.\n\t(setOption): Implemented.\n\t(getOption): Implemented.\n1999-05-26  Warren Levy  <warrenl@cygnus.com>\n\t* java/net/DatagramSocket.java (DatagramSocket): Get local host\n\taddress when null.  Set SO_REUSEADDR for multicasts.\n\t(getSoTimeout): Implemented.\n\t(setSoTimeout): Implemented.\n\t* java/net/DatagramSocketImpl.java: Implement SocketOptions interface.\n\t* java/net/MulticastSocket.java (getInterface): Implemented.\n\t(setInterface): Implemented.\n\t(setTimeToLive): Check for invalid ttl.\n\t(joinGroup): Verify multicast address and security.\n\t(leaveGroup): Verify multicast address and security.\n\t(send): Implemented.\n\t* java/net/PlainDatagramSocketImpl.java (timeout): Added.\n\t(iface): Added.\n\t(ttl): Added.\n\t(setOption): Added.\n\t(getOption): Added.\n\t(mcastGrp): Added.\n\t(getTTL): Implemented as non-native.\n\t(setTTL): ditto.\n\t(join): ditto.\n\t(leave): ditto.\n\t* java/net/ServerSocket.java (setSoTimeout): Implemented.\n\t(getSoTimeout): Implemented.\n\t(setSocketFactory): Made synchronized.\n\t* java/net/Socket.java (setSoTimeout): Implemented.\n\t(getSoTimeout): Implemented.\n\t(close): Made synchronized.\n\t(setSocketImplFactory): Made synchronized.\n\t* java/net/SocketImpl.java: Implement SocketOptions interface.\n\t* java/net/natInetAddress.cc: Corrected module name at top of file.\n\t* java/net/natPlainDatagramSocketImpl.cc (McastReq): Added union.\n\t(bind): Added FIXME.\n\t(peek): Implemented.\n\t(setTTL): Removed.\n\t(getTTL): Removed.\n\t(join): Removed.\n\t(leave): Removed.\n\t(mcastGrp): Added.\n\t(setOption): Implemented for SO_REUSEADDR.\n\t(getOption): Implemented for SO_REUSEADDR.\n\nFrom-SVN: r27184", "tree": {"sha": "a946b25d980c088ac8a79fbfeefceff665041269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a946b25d980c088ac8a79fbfeefceff665041269"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/comments", "author": null, "committer": null, "parents": [{"sha": "de4abb91d1a9f13baceb3e50f73829c0f21b830c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4abb91d1a9f13baceb3e50f73829c0f21b830c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de4abb91d1a9f13baceb3e50f73829c0f21b830c"}], "stats": {"total": 696, "additions": 608, "deletions": 88}, "files": [{"sha": "030da4d11aa51c633d82279490a3f88722375251", "filename": "libjava/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -1,3 +1,74 @@\n+1999-05-26  Bryce McKinlay <bryce@albatross.co.nz>\n+\n+\t* java/net/DatagramSocket.java (getSoTimeout): Verify class type.\n+\t* java/net/DatagramSocketImpl.java (getOption): Made abstract.\n+\t(setOption): Made abstract.\n+\t* java/net/PlainDatagramSocketImpl.java: Mirror SocketOptions fields\n+\tto avoid cpp conflicts in native code.\n+\t* java/net/PlainSocketImpl.java: Mirror SocketOptions fields to avoid\n+\tcpp conflicts in native code.\n+\t* java/net/ServerSocket.java (toString): Prepended \"ServerSocket\".\n+\t* java/net/Socket.java (getLocalAddress): Implemented.\n+\t(setTcpNoDelay): Implemented.\n+\t(getTcpNoDelay): Implemented.\n+\t(setSoLinger): Implemented.\n+\t(getSoLinger): Implemented.\n+\t(getSoTimeout): Verify class type.\n+\t(setSendBufferSize): Implemented.\n+\t(getSendBufferSize): Implemented.\n+\t(setReceiveBufferSize): Implemented.\n+\t(getReceiveBufferSize): Implemented.\n+\t(toString): Prepended \"Socket\".\n+\t* java/net/SocketImpl.java (toString): Rewritten.\n+\t(getOption): Made abstract.\n+\t(setOption): Made abstract.\n+\t* java/net/natPlainSocketImpl.cc (connect): Set localport properly.\n+\t(setOption): Implemented.\n+\t(getOption): Implemented.\n+\n+1999-05-26  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/net/DatagramSocket.java (DatagramSocket): Get local host\n+\taddress when null.  Set SO_REUSEADDR for multicasts.\n+\t(getSoTimeout): Implemented.\n+\t(setSoTimeout): Implemented.\n+\t* java/net/DatagramSocketImpl.java: Implement SocketOptions interface.\n+\t* java/net/MulticastSocket.java (getInterface): Implemented.\n+\t(setInterface): Implemented.\n+\t(setTimeToLive): Check for invalid ttl.\n+\t(joinGroup): Verify multicast address and security.\n+\t(leaveGroup): Verify multicast address and security.\n+\t(send): Implemented.\n+\t* java/net/PlainDatagramSocketImpl.java (timeout): Added.\n+\t(iface): Added.\n+\t(ttl): Added.\n+\t(setOption): Added.\n+\t(getOption): Added.\n+\t(mcastGrp): Added.\n+\t(getTTL): Implemented as non-native.\n+\t(setTTL): ditto.\n+\t(join): ditto.\n+\t(leave): ditto.\n+\t* java/net/ServerSocket.java (setSoTimeout): Implemented.\n+\t(getSoTimeout): Implemented.\n+\t(setSocketFactory): Made synchronized.\n+\t* java/net/Socket.java (setSoTimeout): Implemented.\n+\t(getSoTimeout): Implemented.\n+\t(close): Made synchronized.\n+\t(setSocketImplFactory): Made synchronized.\n+\t* java/net/SocketImpl.java: Implement SocketOptions interface.\n+\t* java/net/natInetAddress.cc: Corrected module name at top of file.\n+\t* java/net/natPlainDatagramSocketImpl.cc (McastReq): Added union.\n+\t(bind): Added FIXME.\n+\t(peek): Implemented.\n+\t(setTTL): Removed.\n+\t(getTTL): Removed.\n+\t(join): Removed.\n+\t(leave): Removed.\n+\t(mcastGrp): Added.\n+\t(setOption): Implemented for SO_REUSEADDR.\n+\t(getOption): Implemented for SO_REUSEADDR.\n+\n 1999-05-24  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/util/ResourceBundle.java (getBundle): Throw"}, {"sha": "3bfb0327c4926dd08d07ae3a0e48b30ee318f341", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -56,12 +56,19 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n     // TBD: if this is right then the same should be done in Socket().\n     try\n     {\n-      impl.bind(port, laddr == null ? InetAddress.getLocalHost() : laddr);\n+      if (laddr == null)\n+\tladdr = InetAddress.getLocalHost();\n     }\n     catch (UnknownHostException e)\n     {\n       throw new BindException(e.getMessage());\n     }\n+\n+    // For multicasting, set the socket to be reused (Stevens pp. 195-6).\n+    if (this instanceof MulticastSocket)\n+      impl.setOption(SocketOptions.SO_REUSEADDR, new Boolean(true));\n+\n+    impl.bind(port, laddr);\n     this.laddr = laddr;\n   }\n \n@@ -82,8 +89,11 @@ public int getLocalPort()\n \n   public synchronized int getSoTimeout() throws SocketException\n   {\n-    // FIXME: TODO - DatagramSocket.getSoTimeout\n-     throw new SocketException(\"DatagramSocket.getSoTimeout - not yet implemented\");\n+    Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n+    if (timeout instanceof Integer) \n+      return ((Integer)timeout).intValue();\n+    else\n+      return 0;\n   }\n \n   public synchronized void receive(DatagramPacket p) throws IOException\n@@ -114,8 +124,10 @@ public void send(DatagramPacket p) throws IOException\n \n   public synchronized void setSoTimeout(int timeout) throws SocketException\n   {\n-    // FIXME: TODO - DatagramSocket.setSoTimeout\n-    throw new SocketException(\"DatagramSocket.setSoTimeout - not yet implemented\");\n+    if (timeout < 0)\n+      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n+\n+    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n   // JDK1.2"}, {"sha": "9ae61cfc129bfdccb20b0f5c6beaeccc11b2a510", "filename": "libjava/java/net/DatagramSocketImpl.java", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -23,9 +23,7 @@\n  * Status:  Believed complete and correct.\n  */\n \n-// JDK1.2: needs to implement SocketOptions.\n-// JDK1.2: public abstract class DatagramSocketImpl implements SocketOptions\n-public abstract class DatagramSocketImpl\n+public abstract class DatagramSocketImpl implements SocketOptions\n {\n   protected int localport;\n   protected FileDescriptor fd;\n@@ -48,6 +46,10 @@ protected abstract void bind(int lport, InetAddress laddr)\n   protected abstract void join(InetAddress inetaddr) throws IOException;\n   protected abstract void leave(InetAddress inetaddr) throws IOException;\n \n+  public abstract Object getOption(int optID) throws SocketException;\n+  public abstract void setOption(int optID, Object value)\n+    throws SocketException;\n+\n   protected FileDescriptor getFileDescriptor()\n   {\n     return fd;"}, {"sha": "03a6e6b175cfc81959c276d54ebc8eea59e0f453", "filename": "libjava/java/net/MulticastSocket.java", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -25,7 +25,8 @@\n public class MulticastSocket extends DatagramSocket\n {\n   // FIXME: the local addr bound to the multicast socket can be reused;\n-  // unlike unicast sockets.  see p.1159 JCL book.\n+  // unlike unicast sockets.  It binds to any available network interface.\n+  // See p.1159 JCL book.\n \n   public MulticastSocket() throws IOException\n   {\n@@ -39,13 +40,16 @@ public MulticastSocket(int port) throws IOException\n \n   public InetAddress getInterface() throws SocketException\n   {\n-    // FIXME: TODO - MulticastSocket.getInterface\n-    throw new SocketException(\"MulticastSocket.getInterface - not yet implemented\");\n+    // FIXME: Is it possible that an InetAddress wasn't returned from getOption?\n+    return (InetAddress) impl.getOption(SocketOptions.IP_MULTICAST_IF);\n   }\n \n   // Deprecated in JDK1.2\n   public byte getTTL() throws IOException\n   {\n+    // Use getTTL here rather than getTimeToLive in case we're using an impl\n+    // other than the default PlainDatagramSocketImpl and it doesn't have\n+    // getTimeToLive yet.\n     return impl.getTTL();\n   }\n \n@@ -57,35 +61,66 @@ public int getTimeToLive() throws IOException\n \n   public void setInterface(InetAddress inf) throws SocketException\n   {\n-    // FIXME: TODO - MulticastSocket.setInterface\n-    throw new SocketException(\"MulticastSocket.setInterface - not yet implemented\");\n+    impl.setOption(SocketOptions.IP_MULTICAST_IF, inf);\n   }\n \n   // Deprecated in JDK1.2\n   public void setTTL(byte ttl) throws IOException\n   {\n+    // Use setTTL here rather than setTimeToLive in case we're using an impl\n+    // other than the default PlainDatagramSocketImpl and it doesn't have\n+    // setTimeToLive yet.\n     impl.setTTL(ttl);\n   }\n \n   // JDK1.2\n   public void setTimeToLive(int ttl) throws IOException\n   {\n+    if (ttl < 0 || ttl > 255)\n+      throw new IllegalArgumentException(\"Invalid ttl: \" + ttl);\n+\n     impl.setTimeToLive(ttl);\n   }\n \n   public void joinGroup(InetAddress mcastaddr) throws IOException\n   {\n+    if (! mcastaddr.isMulticastAddress())\n+      throw new IOException(\"Not a Multicast address\");\n+\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkMulticast(mcastaddr);\n+\n     impl.join(mcastaddr);\n   }\n \n   public void leaveGroup(InetAddress mcastaddr) throws IOException\n   {\n+    if (! mcastaddr.isMulticastAddress())\n+      throw new IOException(\"Not a Multicast address\");\n+\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkMulticast(mcastaddr);\n+\n     impl.leave(mcastaddr);\n   }\n \n-  public void send(DatagramPacket p, byte ttl) throws IOException\n+  public synchronized void send(DatagramPacket p, byte ttl) throws IOException\n   {\n-    // FIXME:  use ttl instead of getTTL() for time to live.\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      {\n+\tInetAddress addr = p.getAddress();\n+\tif (addr.isMulticastAddress())\n+\t  s.checkMulticast(addr, ttl);\n+\telse\n+\t  s.checkConnect(addr.getHostAddress(), p.getPort());\n+      }\n+\n+    int oldttl = impl.getTimeToLive();\n+    impl.setTimeToLive(((int) ttl) & 0xFF);\n     impl.send(p);\n+    impl.setTimeToLive(oldttl);\n   }\n }"}, {"sha": "2a063717cc53c8b533f3b69e06c9962bbe556883", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -24,13 +24,28 @@\n \n class PlainDatagramSocketImpl extends DatagramSocketImpl\n {\n+  // These fields are mirrored for use in native code to avoid cpp conflicts\n+  // when the #defines in system header files are the same as the public fields.\n+  static final int _Jv_TCP_NODELAY_ = SocketOptions.TCP_NODELAY,\n+                   _Jv_SO_BINDADDR_ = SocketOptions.SO_BINDADDR,\n+                   _Jv_SO_REUSEADDR_ = SocketOptions.SO_REUSEADDR,\n+\t\t   _Jv_IP_MULTICAST_IF_ = SocketOptions.IP_MULTICAST_IF,\n+                   _Jv_SO_LINGER_ = SocketOptions.SO_LINGER,\n+                   _Jv_SO_TIMEOUT_ = SocketOptions.SO_TIMEOUT,\n+                   _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,\n+                   _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF;\n+\n   int fnum = -1;\n   InetAddress address;\t// TBD: DatagramSocket.getLocalAddress()?\n+  // FIXME: These values are set/read by setOption/getOption.\n+  int timeout = 0;\n+  InetAddress iface = null;\n+  int ttl = -1;\n \n   // FIXME: Probably should have bind (and create?) calls from DatagramSocket\n   // constuctor.  If so, then same change should be made to the corresponding\n   // Socket (non-datagram) classes.  This allows the implementation more\n-  // compleete control over how the socket is set up and used (e.g. connect,\n+  // complete control over how the socket is set up and used (e.g. connect,\n   // setting options, etc.).\n   public PlainDatagramSocketImpl()\n   {\n@@ -40,17 +55,39 @@ protected native void bind(int lport, InetAddress laddr)\n \tthrows SocketException;\n   protected native void create() throws SocketException;\n   protected native int peek(InetAddress i) throws IOException;\n-  protected native void setTTL(byte ttl) throws IOException;\n-  protected native byte getTTL() throws IOException;\n   protected native void setTimeToLive(int ttl) throws IOException;\n   protected native int getTimeToLive() throws IOException;\n-  protected native void join(InetAddress inetaddr) throws IOException;\n-  protected native void leave(InetAddress inetaddr) throws IOException;\n   protected native void send(DatagramPacket p) throws IOException;\n   protected native void receive(DatagramPacket p) throws IOException;\n+  public native void setOption(int optID, Object value) throws SocketException;\n+  public native Object getOption(int optID) throws SocketException;\n+  private native void mcastGrp(InetAddress inetaddr, boolean join)\n+\tthrows IOException;\n \n   protected void close() throws IOException\n   {\n     fd.close();\n   }\n+\n+  // Deprecated in JDK 1.2.\n+  protected byte getTTL() throws IOException\n+  {\n+    return (byte) getTimeToLive();\n+  }\n+\n+  // Deprecated in JDK 1.2.\n+  protected void setTTL(byte ttl) throws IOException\n+  {\n+    setTimeToLive(((int) ttl) & 0xFF);\n+  }\n+\n+  protected void join(InetAddress inetaddr) throws IOException\n+  {\n+    mcastGrp(inetaddr, true);\n+  }\n+\n+  protected void leave(InetAddress inetaddr) throws IOException\n+  {\n+    mcastGrp(inetaddr, false);\n+  }\n }"}, {"sha": "b8e10ad6dc999407824d62ffbf13e313917851ec", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -24,8 +24,23 @@\n \n class PlainSocketImpl extends SocketImpl\n {\n+  // These fields are mirrored for use in native code to avoid cpp conflicts\n+  // when the #defines in system header files are the same as the public fields.\n+  static final int _Jv_TCP_NODELAY_ = SocketOptions.TCP_NODELAY,\n+                   _Jv_SO_BINDADDR_ = SocketOptions.SO_BINDADDR,\n+                   _Jv_SO_REUSEADDR_ = SocketOptions.SO_REUSEADDR,\n+\t\t   _Jv_IP_MULTICAST_IF_ = SocketOptions.IP_MULTICAST_IF,\n+                   _Jv_SO_LINGER_ = SocketOptions.SO_LINGER,\n+                   _Jv_SO_TIMEOUT_ = SocketOptions.SO_TIMEOUT,\n+                   _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,\n+                   _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF;\n+\n   int fnum = -1;\n \n+  public native void setOption(int optID, Object value) throws SocketException;\n+\n+  public native Object getOption(int optID) throws SocketException;\n+\n   protected native void create (boolean stream)  throws IOException;\n \n   protected void connect (String host, int port) throws IOException"}, {"sha": "ae1e1135e357d47a4cd29a3e6bf633e5c99cfda2", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -1,4 +1,4 @@\n-// Socket.java\n+// ServerSocket.java\n \n /* Copyright (C) 1999  Cygnus Solutions\n \n@@ -14,8 +14,7 @@\n   */\n \n /** Written using on-line Java Platform 1.2 API Specification.\n-  * Status:  I believe all methods are implemented, but many\n-  * of them just throw an exception.\n+  * Status:  I believe all methods are implemented.\n   */\n \n package java.net;\n@@ -81,25 +80,31 @@ public void close () throws IOException\n     impl.close();\n   }\n \n-  public void setSoTimeout (int timeout) throws SocketException\n+  public synchronized void setSoTimeout (int timeout) throws SocketException\n   {\n-    throw new InternalError(\"ServerSocket.setSoTimeout not implemented\");\n+    if (timeout < 0)\n+      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n+\n+    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n-  public int getSoTimeout () throws SocketException\n+  public synchronized int getSoTimeout () throws SocketException\n   {\n-    throw new InternalError(\"ServerSocket.getSoTimeout not implemented\");\n+    Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n+    if (timeout instanceof Integer) \n+      return ((Integer)timeout).intValue();\n+    else\n+      return 0;\n   }\n \n   public String toString ()\n   {\n-    return impl.toString();\n+    return \"ServerSocket\" + impl.toString();\n   }\n \n-  public static void setSocketFactory (SocketImplFactory fac)\n+  public static synchronized void setSocketFactory (SocketImplFactory fac)\n     throws IOException\n   {\n     factory = fac;\n   }\n-\n }"}, {"sha": "e4ef2d7eb88c35b376f0bbe8a20c15362769e4c8", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 61, "deletions": 20, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -14,8 +14,7 @@\n   */\n \n /** Written using on-line Java Platform 1.2 API Specification.\n-  * Status:  I believe all methods are implemented, but many\n-  * of them just throw an exception.\n+  * Status:  I believe all methods are implemented.\n   */\n \n package java.net;\n@@ -116,9 +115,18 @@ public InetAddress getInetAddress ()\n \n   public InetAddress getLocalAddress ()\n   {\n-    // There doesn't seem to be any way to implement this\n-    // using a (generic) SocketImpl ...  What am I missing?\n-    throw new InternalError(\"Socket.getLocalAddres not implemented\");\n+    InetAddress localAddress;\n+    try\n+      {\n+\tlocalAddress = (InetAddress)impl.getOption(SocketOptions.SO_BINDADDR);\n+      }\n+    catch (SocketException x)\n+      {\n+\t// (hopefully) shouldn't happen\n+\tSystem.err.println(x);\n+        throw new java.lang.InternalError(\"Error in PlainSocketImpl.getOption\");\n+      }\n+    return localAddress;\n   }\n \n   public int getPort ()\n@@ -143,65 +151,98 @@ public OutputStream getOutputStream () throws IOException\n \n   public void setTcpNoDelay (boolean on)  throws SocketException\n   {\n-    throw new InternalError(\"Socket.setTcpNoDelay not implemented\");\n+    impl.setOption( SocketOptions.TCP_NODELAY, new Boolean(on) );\n   }\n \n   public boolean getTcpNoDelay() throws SocketException\n   {\n-    throw new InternalError(\"Socket.getTcpNoDelay not implemented\");\n+    Boolean bool = (Boolean)impl.getOption( SocketOptions.TCP_NODELAY );\n+    return bool.booleanValue();\n   }\n \n   public void setSoLinger(boolean on, int linger) throws SocketException\n   {\n-    throw new InternalError(\"Socket.setSoLinger not implemented\");\n+    if ( on && (linger >= 0) ) \n+      {\n+\tif (linger > 65535)\n+\t  linger = 65535;\n+\timpl.setOption( SocketOptions.SO_LINGER, new Integer(linger) );\n+      } \n+    else if ( on && (linger < 0) ) \n+      throw new IllegalArgumentException(\"SO_LINGER must be >= 0\");\n+    else\n+      impl.setOption( SocketOptions.SO_LINGER, new Boolean(false) );\n   }\n \n   public int getSoLinger() throws SocketException\n   {\n-    throw new InternalError(\"Socket.getSoLinger not implemented\");\n+    Object linger = impl.getOption(SocketOptions.SO_LINGER);    \n+    if (linger instanceof Integer) \n+      return ((Integer)linger).intValue();\n+    else\n+      return -1;\n   }\n \n-  public void setSoTimeout (int timeout) throws SocketException\n+  public synchronized void setSoTimeout (int timeout) throws SocketException\n   {\n-    throw new InternalError(\"Socket.setSoTimeout not implemented\");\n+    if (timeout < 0)\n+      throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n+\n+    impl.setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n-  public int getSoTimeout () throws SocketException\n+  public synchronized int getSoTimeout () throws SocketException\n   {\n-    throw new InternalError(\"Socket.getSoTimeout not implemented\");\n+    Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n+    if (timeout instanceof Integer) \n+      return ((Integer)timeout).intValue();\n+    else\n+      return 0;\n   }\n \n+  // JDK1.2\n   public void setSendBufferSize (int size) throws SocketException\n   {\n-    throw new InternalError(\"Socket.setSendBufferSize not implemented\");\n+    if (size <= 0)\n+      throw new IllegalArgumentException(\"Invalid buffer size: \" + size);\n+\n+    impl.setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n   }\n \n+  // JDK1.2\n   public int getSendBufferSize () throws SocketException\n   {\n-    throw new InternalError(\"Socket.getSendBufferSize not implemented\");\n+    Integer buf = (Integer)impl.getOption(SocketOptions.SO_SNDBUF);\n+    return buf.intValue();\n   }\n \n+  // JDK1.2\n   public void setReceiveBufferSize (int size) throws SocketException\n   {\n-    throw new InternalError(\"Socket.setReceiveBufferSize not implemented\");\n+    if (size <= 0)\n+      throw new IllegalArgumentException(\"Invalid buffer size: \" + size);\n+\n+    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n   }\n \n+  // JDK1.2\n   public int getReceiveBufferSize () throws SocketException\n   {\n-    throw new InternalError(\"Socket.getReceiveBufferSize not implemented\");\n+    Integer buf = (Integer)impl.getOption(SocketOptions.SO_RCVBUF);\n+    return buf.intValue();\n   }\n \n-  public void close ()  throws IOException\n+  public synchronized void close ()  throws IOException\n   {\n     impl.close();\n   }\n \n   public String toString ()\n   {\n-    return impl.toString();\n+    return \"Socket\" + impl.toString();\n   }\n \n-  public static void setSocketImplFactory (SocketImplFactory fac)\n+  public static synchronized void setSocketImplFactory (SocketImplFactory fac)\n     throws IOException\n   {\n     factory = fac;"}, {"sha": "b764e8e4cffb3c6d060145f417f4aab7b6412e53", "filename": "libjava/java/net/SocketImpl.java", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImpl.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -17,12 +17,10 @@\n   */\n \n /** Written using on-line Java Platform 1.2 API Specification.\n-  * Believed complete and correct, except for implementation of toString.\n+  * Believed complete and correct.\n   */\n \n-// JDK1.2: needs to implement SocketOptions.\n-// JDK1.2: public abstract class SocketImpl implements SocketOptions\n-public abstract class SocketImpl\n+public abstract class SocketImpl implements SocketOptions\n {\n   protected InetAddress address;\n \n@@ -65,8 +63,14 @@ protected abstract void connect (InetAddress host, int port)\n \n   protected int getLocalPort () { return localport; }\n \n+  public abstract Object getOption(int optID) throws SocketException;\n+\n+  public abstract void setOption(int optID, Object value)\n+    throws SocketException;\n+\n   public String toString ()\n   {\n-    return super.toString();  // FIXME\n+    return \"[addr=\" + address.toString() + \",port=\" + Integer.toString(port) +\n+      \",localport=\" + Integer.toString(localport) + \"]\";\n   }\n }"}, {"sha": "397db64e16889721acd954b2f1e9fffe6cb12190", "filename": "libjava/java/net/SocketOptions.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FSocketOptions.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FSocketOptions.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketOptions.java?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -29,10 +29,10 @@\n   public static final int SO_LINGER = 0x80;\n   public static final int SO_TIMEOUT = 0x1006;\n \n-// JDK1.2\n+  // JDK1.2\n   public static final int SO_SNDBUF = 0x1001;\n \n-// JDK1.2\n+  // JDK1.2\n   public static final int SO_RCVBUF = 0x1002;\n \n   public void setOption(int optID, Object value) throws SocketException;"}, {"sha": "da3a1fbddf6c46e518f2457d3e9fe4ec4dc3b5c7", "filename": "libjava/java/net/natInetAddress.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddress.cc?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -1,4 +1,4 @@\n-// natClass.cc - Implementation of java.lang.Class native methods.\n+// natInetAddress.cc\n \n /* Copyright (C) 1998, 1999  Cygnus Solutions\n "}, {"sha": "42abbe135db4d199a2a638b4b73c3302304995a0", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 123, "deletions": 24, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -23,6 +23,7 @@ details.  */\n #include <java/net/PlainDatagramSocketImpl.h>\n #include <java/net/InetAddress.h>\n #include <java/net/DatagramPacket.h>\n+#include <java/lang/Boolean.h>\n \n #ifndef HAVE_SOCKLEN_T\n typedef int socklen_t;\n@@ -36,6 +37,15 @@ union SockAddr\n #endif\n };\n \n+union McastReq\n+{\n+  struct ip_mreq mreq;\n+#ifdef HAVE_INET6\n+  struct ipv6_mreq mreq6;\n+#endif\n+};\n+\n+\n // FIXME: routines here and/or in natPlainSocketImpl.cc could throw\n // NoRouteToHostException; also consider UnknownHostException, ConnectException.\n \n@@ -58,6 +68,7 @@ void\n java::net::PlainDatagramSocketImpl::bind (jint lport,\n   java::net::InetAddress *host)\n {\n+  // FIXME: prob. need to do a setsockopt with SO_BROADCAST to allow multicast.\n   union SockAddr u;\n   jbyteArray haddress = host->address;\n   jbyte *bytes = elements (haddress);\n@@ -97,9 +108,41 @@ java::net::PlainDatagramSocketImpl::bind (jint lport,\n jint\n java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *i)\n {\n-  // FIXME: TODO - PlainDatagramSocketImpl::peek\n-  // throws IOException;\n-  return 0;\n+  // FIXME: Deal with Multicast and if the socket is connected.\n+  union SockAddr u;\n+  socklen_t addrlen = sizeof(u);\n+  ssize_t retlen =\n+    ::recvfrom (fnum, (char *) NULL, 0, MSG_PEEK, (sockaddr*) &u,\n+      &addrlen);\n+  if (retlen < 0)\n+    goto error;\n+  // FIXME: Deal with Multicast addressing and if the socket is connected.\n+  jbyteArray raddr;\n+  jint rport;\n+  if (u.address.sin_family == AF_INET)\n+    {\n+      raddr = JvNewByteArray (4);\n+      memcpy (elements (raddr), &u.address.sin_addr, 4);\n+      rport = ntohs (u.address.sin_port);\n+    }\n+#ifdef HAVE_INET6\n+  else if (u.address.sin_family == AF_INET6)\n+    {\n+      raddr = JvNewByteArray (16);\n+      memcpy (elements (raddr), &u.address6.sin6_addr, 16);\n+      rport = ntohs (u.address6.sin6_port);\n+    }\n+#endif\n+  else\n+    goto error;\n+  // FIXME: Multicast:  s->address = new InetAddress (raddr, NULL);\n+  i->address = raddr;\n+  return rport;\n+ error:\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"DatagramSocketImpl.peek: %.*s\", 80, strerr);\n+  JvThrow (new java::io::IOException (JvNewStringUTF (msg)));\n }\n \n void\n@@ -182,21 +225,6 @@ java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n   JvThrow (new java::io::IOException (JvNewStringUTF (msg)));\n }\n \n-void\n-java::net::PlainDatagramSocketImpl::setTTL (jbyte ttl)\n-{\n-  // FIXME: TODO - :PlainDatagramSocketImpl::setTTL\n-  // throws IOException;\n-}\n-\n-jbyte\n-java::net::PlainDatagramSocketImpl::getTTL ()\n-{\n-  // FIXME: TODO - PlainDatagramSocketImpl::getTTL\n-  // throws IOException;\n-  return 0;\n-}\n-\n void\n java::net::PlainDatagramSocketImpl::setTimeToLive (jint ttl)\n {\n@@ -213,15 +241,86 @@ java::net::PlainDatagramSocketImpl::getTimeToLive ()\n }\n \n void\n-java::net::PlainDatagramSocketImpl::join (java::net::InetAddress *inetaddr)\n+java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *inetaddr,\n+  jboolean join)\n {\n-  // throws IOException;\n-  // FIXME: TODO - PlainDatagramSocketImpl::join\n+  union McastReq u;\n+  jbyteArray haddress = inetaddr->address;\n+  jbyte *bytes = elements (haddress);\n+  int len = haddress->length;\n+  int level, opname;\n+  const char *ptr;\n+  if (len == 4)\n+    {\n+      level = IPPROTO_IP;\n+      opname = join ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;\n+      memcpy (&u.mreq.imr_multiaddr, bytes, len);\n+      // FIXME:  If a non-default interface is set, use it; see Stevens p. 501.\n+      u.mreq.imr_interface.s_addr = htonl (INADDR_ANY); \n+      len = sizeof (struct ip_mreq);\n+      ptr = (const char *) &u.mreq;\n+    }\n+#ifdef HAVE_INET6\n+  else if (len == 16)\n+    {\n+      level = IPPROTO_IPV6;\n+      opname = join ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP;\n+      memcpy (&u.mreq6.ipv6mr_multiaddr, bytes, len);\n+      // FIXME:  If a non-default interface is set, use it; see Stevens p. 501.\n+      u.mreq6.ipv6mr_interface = 0;\n+      len = sizeof (struct ipv6_mreq);\n+      ptr = (const char *) &u.mreq6;\n+    }\n+#endif\n+  else\n+    goto error;\n+  if (::setsockopt (fnum, level, opname, ptr, len) == 0)\n+    return;\n+ error:\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"DatagramSocketImpl.%s: %.*s\", join ? \"join\" : \"leave\", 80,\n+    strerr);\n+  JvThrow (new java::io::IOException (JvNewStringUTF (msg)));\n }\n \n void\n-java::net::PlainDatagramSocketImpl::leave (java::net::InetAddress *inetaddr)\n+java::net::PlainDatagramSocketImpl::setOption (jint optID,\n+  java::lang::Object *value)\n {\n-  // throws IOException;\n-  // FIXME: TODO - PlainDatagramSocketImpl::leave\n+  if (optID == _Jv_SO_REUSEADDR_)\n+    {\n+      // FIXME: Is it possible that a Boolean wasn't passed in?\n+      const int on = (((java::lang::Boolean *) value)->booleanValue()) ? 1 : 0;\n+      if (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &on,\n+\t  sizeof (int)) == 0)\n+        return;\n+    }\n+  else\n+    errno = ENOPROTOOPT;\n+\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"DatagramSocketImpl.setOption: %.*s\", 80, strerr);\n+  JvThrow (new java::net::SocketException (JvNewStringUTF (msg)));\n+}\n+\n+java::lang::Object *\n+java::net::PlainDatagramSocketImpl::getOption (jint optID)\n+{\n+  if (optID == _Jv_SO_REUSEADDR_)\n+    {\n+      int on;\n+      socklen_t len;\n+      if (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &on,\n+\t  (socklen_t *) &len) == 0)\n+        return new java::lang::Boolean (on == 1);\n+    }\n+  else\n+    errno = ENOPROTOOPT;\n+\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"DatagramSocketImpl.getOption: %.*s\", 80, strerr);\n+  JvThrow (new java::net::SocketException (JvNewStringUTF (msg)));\n }"}, {"sha": "feaaa7799822c04a6098bdc017ceaae5d5c1045d", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 205, "deletions": 6, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ed9e9656a375cf80b11dfb3a264a7551654ecd/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=f2ed9e9656a375cf80b11dfb3a264a7551654ecd", "patch": "@@ -11,17 +11,25 @@ details.  */\n #include <sys/types.h>\n #include <sys/socket.h>\n #include <netinet/in.h>\n+#include <netinet/tcp.h>\n #include <errno.h>\n #include <stdio.h>\n #include <string.h>\n \n #include <cni.h>\n+#include <javaprims.h>\n #include <java/io/IOException.h>\n #include <java/io/FileDescriptor.h>\n #include <java/net/BindException.h>\n #include <java/net/ConnectException.h>\n #include <java/net/PlainSocketImpl.h>\n #include <java/net/InetAddress.h>\n+#include <java/net/SocketException.h>\n+#include <java/lang/InternalError.h>\n+#include <java/lang/Object.h>\n+#include <java/lang/Boolean.h>\n+#include <java/lang/Class.h>\n+#include <java/lang/Integer.h>\n \n #ifndef HAVE_SOCKLEN_T\n typedef int socklen_t;\n@@ -93,6 +101,7 @@ void\n java::net::PlainSocketImpl::connect (java::net::InetAddress *host, jint rport)\n {\n   union SockAddr u;\n+  socklen_t addrlen = sizeof(u);\n   jbyteArray haddress = host->address;\n   jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n@@ -115,12 +124,14 @@ java::net::PlainSocketImpl::connect (java::net::InetAddress *host, jint rport)\n #endif\n   else\n     goto error;\n-  if (::connect (fnum, ptr, len) == 0)\n-    {\n-      address = host;\n-      port = rport;\n-      return;\n-    }\n+  if (::connect (fnum, ptr, len) != 0)\n+    goto error;\n+  address = host;\n+  port = rport;\n+  if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+    goto error;\n+  localport = ntohs (u.address.sin_port);\n+  return;  \n  error:\n   char msg[100];\n   char* strerr = strerror (errno);\n@@ -178,3 +189,191 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n   sprintf (msg, \"SocketImpl.accept: %.*s\", 80, strerr);\n   JvThrow (new java::io::IOException (JvNewStringUTF (msg)));\n }\n+\n+void\n+java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n+{\n+  int val;\n+  socklen_t val_len = sizeof (val);\n+\n+  if ( _Jv_IsInstanceOf(value,\n+    java::lang::Class::forName(JvNewStringUTF(\"java.lang.Boolean\"))))\n+    {\n+      java::lang::Boolean *boolobj = \n+        static_cast<java::lang::Boolean *> (value);\n+      if (boolobj->booleanValue())\n+        val = 1; \n+      else \n+        {\n+\t  if (optID == _Jv_SO_LINGER_)\n+\t    val = -1;\n+\t  else\n+\t    val = 0;\n+        }\n+    }\n+  else  // assume value is an Integer\n+    {\n+      java::lang::Integer *intobj = \n+        static_cast<java::lang::Integer *> (value);          \n+      val = (int) intobj->intValue();\n+    }\n+\n+  switch (optID) \n+    {\n+      case _Jv_TCP_NODELAY_ :\n+#ifdef TCP_NODELAY\n+        if (::setsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n+\t    val_len) != 0)\n+\t  goto error;    \n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"TCP_NODELAY not supported\")));      \n+#endif /* TCP_NODELAY */\n+        return;\n+      case _Jv_SO_LINGER_ :\n+#ifdef SO_LINGER\n+        struct linger l_val;\n+        l_val.l_onoff = (val != -1);\n+        l_val.l_linger = val;\n+        if (::setsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n+\t    sizeof(l_val)) != 0)\n+\t  goto error;    \n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_LINGER not supported\")));      \n+#endif /* SO_LINGER */\n+        return;\n+      case _Jv_SO_SNDBUF_ :\n+      case _Jv_SO_RCVBUF_ :\n+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n+        int opt;\n+        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n+        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n+\t  goto error;    \n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\")));\n+#endif \n+        return;\n+      case _Jv_SO_BINDADDR_ :\n+        JvThrow (new java::net::SocketException (\n+          JvNewStringUTF (\"SO_BINDADDR: read only option\")));\n+        return;\n+      case _Jv_IP_MULTICAST_IF_ :\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\")));\n+        return;\n+      case _Jv_SO_REUSEADDR_ :\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_REUSEADDR: option not implemented\")));\n+        return;\n+      case _Jv_SO_TIMEOUT_ :\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_TIMEOUT: option not implemented\")));\n+        return;\n+      default :\n+        errno = ENOPROTOOPT;\n+    }\n+\n+ error:\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"SocketImpl.setOption: %.*s\", 80, strerr);\n+  JvThrow (new java::net::SocketException (JvNewStringUTF (msg)));\n+}\n+\n+java::lang::Object *\n+java::net::PlainSocketImpl::getOption (jint optID)\n+{\n+  int val;\n+  socklen_t val_len = sizeof(val);\n+  union SockAddr u;\n+  socklen_t addrlen = sizeof(u);\n+  struct linger l_val;\n+  socklen_t l_val_len = sizeof(l_val);\n+\n+  switch (optID)\n+    {\n+#ifdef TCP_NODELAY\n+      case _Jv_TCP_NODELAY_ :\n+        if (::getsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n+\t    &val_len) != 0)\n+          goto error;\n+        else\n+\t  return new java::lang::Boolean (val != 0);\n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"TCP_NODELAY not supported\")));      \n+#endif       \n+        break;\n+\n+      case _Jv_SO_LINGER_ :\n+#ifdef SO_LINGER\n+        if (::getsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n+\t    &l_val_len) != 0)\n+\t  goto error;    \n+        if (l_val.l_onoff)\n+          return new java::lang::Integer (l_val.l_linger);\n+        else\n+\t  return new java::lang::Boolean (false);\n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_LINGER not supported\")));      \n+#endif\n+        break;    \n+      case _Jv_SO_RCVBUF_ :\n+      case _Jv_SO_SNDBUF_ :\n+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n+        int opt;\n+        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n+        if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n+\t  goto error;    \n+        else\n+\t  return new java::lang::Integer (val);\n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\")));\n+#endif    \n+\tbreak;\n+      case _Jv_SO_BINDADDR_:\n+\tjbyteArray laddr;\n+\tif (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+\t  goto error;\n+\tif (u.address.sin_family == AF_INET)\n+\t  {\n+\t    laddr = JvNewByteArray (4);\n+\t    memcpy (elements (laddr), &u.address.sin_addr, 4);\n+\t  }\n+#ifdef HAVE_INET6\n+        else if (u.address.sin_family == AF_INET6)\n+\t  {\n+\t    laddr = JvNewByteArray (16);\n+\t    memcpy (elements (laddr), &u.address6.sin6_addr, 16);\n+\t  }\n+#endif\n+\telse\n+\t  goto error;\n+\treturn new java::net::InetAddress (laddr, NULL);\n+\tbreak;\n+      case _Jv_IP_MULTICAST_IF_ :\n+\tJvThrow (new java::lang::InternalError (\n+\t  JvNewStringUTF (\"IP_MULTICAST_IF: option not implemented\")));\n+\tbreak;\n+      case _Jv_SO_REUSEADDR_ :\n+\tJvThrow (new java::lang::InternalError (\n+\t  JvNewStringUTF (\"SO_REUSEADDR: option not implemented\")));\n+\tbreak;\n+      case _Jv_SO_TIMEOUT_ :\n+\tJvThrow (new java::lang::InternalError (\n+\t  JvNewStringUTF (\"SO_TIMEOUT: option not implemented\")));\n+\tbreak;\n+      default :\n+\terrno = ENOPROTOOPT;\n+    }\n+\n+ error:\n+  char msg[100];\n+  char* strerr = strerror (errno);\n+  sprintf (msg, \"SocketImpl.getOption: %.*s\", 80, strerr);\n+  JvThrow (new java::net::SocketException (JvNewStringUTF (msg)));\n+}"}]}