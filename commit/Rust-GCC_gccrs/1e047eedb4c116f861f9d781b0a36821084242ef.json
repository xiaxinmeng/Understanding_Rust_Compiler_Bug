{"sha": "1e047eedb4c116f861f9d781b0a36821084242ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUwNDdlZWRiNGMxMTZmODYxZjlkNzgxYjBhMzY4MjEwODQyNDJlZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:12:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:12:41Z"}, "message": "[31/77] Use scalar_int_mode for move2add\n\nThe postreload move2add optimisations are specific to scalar\nintegers.  This patch adds an explicit check to the main guarding\n\"if\" and propagates the information through subroutines.\n\ngcc/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* postreload.c (move2add_valid_value_p): Change the type of the\n\tmode parameter to scalar_int_mode.\n\t(move2add_use_add2_insn): Add a mode parameter and use it instead\n\tof GET_MODE (reg).\n\t(move2add_use_add3_insn): Likewise.\n\t(reload_cse_move2add): Update accordingly.\n\nFrom-SVN: r251483", "tree": {"sha": "4c7a16380509138a44cd7ecd340f4804b1ed2672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c7a16380509138a44cd7ecd340f4804b1ed2672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e047eedb4c116f861f9d781b0a36821084242ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e047eedb4c116f861f9d781b0a36821084242ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e047eedb4c116f861f9d781b0a36821084242ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e047eedb4c116f861f9d781b0a36821084242ef/comments", "author": null, "committer": null, "parents": [{"sha": "e4dc9904bad9c0ce64b984f5fe895ff66e6f8d9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dc9904bad9c0ce64b984f5fe895ff66e6f8d9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4dc9904bad9c0ce64b984f5fe895ff66e6f8d9d"}], "stats": {"total": 56, "additions": 30, "deletions": 26}, "files": [{"sha": "39eebf7877baad93890daac4c178dc689df1a52b", "filename": "gcc/postreload.c", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e047eedb4c116f861f9d781b0a36821084242ef/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e047eedb4c116f861f9d781b0a36821084242ef/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=1e047eedb4c116f861f9d781b0a36821084242ef", "patch": "@@ -1692,7 +1692,7 @@ move2add_record_sym_value (rtx reg, rtx sym, rtx off)\n /* Check if REGNO contains a valid value in MODE.  */\n \n static bool\n-move2add_valid_value_p (int regno, machine_mode mode)\n+move2add_valid_value_p (int regno, scalar_int_mode mode)\n {\n   if (reg_set_luid[regno] <= move2add_last_label_luid)\n     return false;\n@@ -1723,21 +1723,21 @@ move2add_valid_value_p (int regno, machine_mode mode)\n   return true;\n }\n \n-/* This function is called with INSN that sets REG to (SYM + OFF),\n-   while REG is known to already have value (SYM + offset).\n+/* This function is called with INSN that sets REG (of mode MODE)\n+   to (SYM + OFF), while REG is known to already have value (SYM + offset).\n    This function tries to change INSN into an add instruction\n    (set (REG) (plus (REG) (OFF - offset))) using the known value.\n    It also updates the information about REG's known value.\n    Return true if we made a change.  */\n \n static bool\n-move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx_insn *insn)\n+move2add_use_add2_insn (scalar_int_mode mode, rtx reg, rtx sym, rtx off,\n+\t\t\trtx_insn *insn)\n {\n   rtx pat = PATTERN (insn);\n   rtx src = SET_SRC (pat);\n   int regno = REGNO (reg);\n-  rtx new_src = gen_int_mode (UINTVAL (off) - reg_offset[regno],\n-\t\t\t      GET_MODE (reg));\n+  rtx new_src = gen_int_mode (UINTVAL (off) - reg_offset[regno], mode);\n   bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n   bool changed = false;\n \n@@ -1759,7 +1759,7 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx_insn *insn)\n   else\n     {\n       struct full_rtx_costs oldcst, newcst;\n-      rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n+      rtx tem = gen_rtx_PLUS (mode, reg, new_src);\n \n       get_full_set_rtx_cost (pat, &oldcst);\n       SET_SRC (pat) = tem;\n@@ -1769,10 +1769,10 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx_insn *insn)\n       if (costs_lt_p (&newcst, &oldcst, speed)\n \t  && have_add2_insn (reg, new_src))\n \tchanged = validate_change (insn, &SET_SRC (pat), tem, 0);\t\n-      else if (sym == NULL_RTX && GET_MODE (reg) != BImode)\n+      else if (sym == NULL_RTX && mode != BImode)\n \t{\n-\t  machine_mode narrow_mode;\n-\t  FOR_EACH_MODE_UNTIL (narrow_mode, GET_MODE (reg))\n+\t  scalar_int_mode narrow_mode;\n+\t  FOR_EACH_MODE_UNTIL (narrow_mode, mode)\n \t    {\n \t      if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n \t\t  && ((reg_offset[regno] & ~GET_MODE_MASK (narrow_mode))\n@@ -1802,17 +1802,18 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx_insn *insn)\n }\n \n \n-/* This function is called with INSN that sets REG to (SYM + OFF),\n-   but REG doesn't have known value (SYM + offset).  This function\n-   tries to find another register which is known to already have\n+/* This function is called with INSN that sets REG (of mode MODE) to\n+   (SYM + OFF), but REG doesn't have known value (SYM + offset).  This\n+   function tries to find another register which is known to already have\n    value (SYM + offset) and change INSN into an add instruction\n    (set (REG) (plus (the found register) (OFF - offset))) if such\n    a register is found.  It also updates the information about\n    REG's known value.\n    Return true iff we made a change.  */\n \n static bool\n-move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx_insn *insn)\n+move2add_use_add3_insn (scalar_int_mode mode, rtx reg, rtx sym, rtx off,\n+\t\t\trtx_insn *insn)\n {\n   rtx pat = PATTERN (insn);\n   rtx src = SET_SRC (pat);\n@@ -1831,7 +1832,7 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx_insn *insn)\n   SET_SRC (pat) = plus_expr;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (move2add_valid_value_p (i, GET_MODE (reg))\n+    if (move2add_valid_value_p (i, mode)\n \t&& reg_base_reg[i] < 0\n \t&& reg_symbol_ref[i] != NULL_RTX\n \t&& rtx_equal_p (sym, reg_symbol_ref[i]))\n@@ -1921,16 +1922,18 @@ reload_cse_move2add (rtx_insn *first)\n       pat = PATTERN (insn);\n       /* For simplicity, we only perform this optimization on\n \t straightforward SETs.  */\n+      scalar_int_mode mode;\n       if (GET_CODE (pat) == SET\n-\t  && REG_P (SET_DEST (pat)))\n+\t  && REG_P (SET_DEST (pat))\n+\t  && is_a <scalar_int_mode> (GET_MODE (SET_DEST (pat)), &mode))\n \t{\n \t  rtx reg = SET_DEST (pat);\n \t  int regno = REGNO (reg);\n \t  rtx src = SET_SRC (pat);\n \n \t  /* Check if we have valid information on the contents of this\n \t     register in the mode of REG.  */\n-\t  if (move2add_valid_value_p (regno, GET_MODE (reg))\n+\t  if (move2add_valid_value_p (regno, mode)\n               && dbg_cnt (cse2_move2add))\n \t    {\n \t      /* Try to transform (set (REGX) (CONST_INT A))\n@@ -1950,7 +1953,8 @@ reload_cse_move2add (rtx_insn *first)\n \t\t  && reg_base_reg[regno] < 0\n \t\t  && reg_symbol_ref[regno] == NULL_RTX)\n \t\t{\n-\t\t  changed |= move2add_use_add2_insn (reg, NULL_RTX, src, insn);\n+\t\t  changed |= move2add_use_add2_insn (mode, reg, NULL_RTX,\n+\t\t\t\t\t\t     src, insn);\n \t\t  continue;\n \t\t}\n \n@@ -1967,7 +1971,7 @@ reload_cse_move2add (rtx_insn *first)\n \t      else if (REG_P (src)\n \t\t       && reg_set_luid[regno] == reg_set_luid[REGNO (src)]\n \t\t       && reg_base_reg[regno] == reg_base_reg[REGNO (src)]\n-\t\t       && move2add_valid_value_p (REGNO (src), GET_MODE (reg)))\n+\t\t       && move2add_valid_value_p (REGNO (src), mode))\n \t\t{\n \t\t  rtx_insn *next = next_nonnote_nondebug_insn (insn);\n \t\t  rtx set = NULL_RTX;\n@@ -1987,7 +1991,7 @@ reload_cse_move2add (rtx_insn *first)\n \t\t\tgen_int_mode (added_offset\n \t\t\t\t      + base_offset\n \t\t\t\t      - regno_offset,\n-\t\t\t\t      GET_MODE (reg));\n+\t\t\t\t      mode);\n \t\t      bool success = false;\n \t\t      bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n \n@@ -1999,11 +2003,11 @@ reload_cse_move2add (rtx_insn *first)\n \t\t\t{\n \t\t\t  rtx old_src = SET_SRC (set);\n \t\t\t  struct full_rtx_costs oldcst, newcst;\n-\t\t\t  rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n+\t\t\t  rtx tem = gen_rtx_PLUS (mode, reg, new_src);\n \n \t\t\t  get_full_set_rtx_cost (set, &oldcst);\n \t\t\t  SET_SRC (set) = tem;\n-\t\t\t  get_full_set_src_cost (tem, GET_MODE (reg), &newcst);\n+\t\t\t  get_full_set_src_cost (tem, mode, &newcst);\n \t\t\t  SET_SRC (set) = old_src;\n \t\t\t  costs_add_n_insns (&oldcst, 1);\n \n@@ -2023,7 +2027,7 @@ reload_cse_move2add (rtx_insn *first)\n \t\t      move2add_record_mode (reg);\n \t\t      reg_offset[regno]\n \t\t\t= trunc_int_for_mode (added_offset + base_offset,\n-\t\t\t\t\t      GET_MODE (reg));\n+\t\t\t\t\t      mode);\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -2059,16 +2063,16 @@ reload_cse_move2add (rtx_insn *first)\n \n \t      /* If the reg already contains the value which is sum of\n \t\t sym and some constant value, we can use an add2 insn.  */\n-\t      if (move2add_valid_value_p (regno, GET_MODE (reg))\n+\t      if (move2add_valid_value_p (regno, mode)\n \t\t  && reg_base_reg[regno] < 0\n \t\t  && reg_symbol_ref[regno] != NULL_RTX\n \t\t  && rtx_equal_p (sym, reg_symbol_ref[regno]))\n-\t\tchanged |= move2add_use_add2_insn (reg, sym, off, insn);\n+\t\tchanged |= move2add_use_add2_insn (mode, reg, sym, off, insn);\n \n \t      /* Otherwise, we have to find a register whose value is sum\n \t\t of sym and some constant value.  */\n \t      else\n-\t\tchanged |= move2add_use_add3_insn (reg, sym, off, insn);\n+\t\tchanged |= move2add_use_add3_insn (mode, reg, sym, off, insn);\n \n \t      continue;\n \t    }"}]}