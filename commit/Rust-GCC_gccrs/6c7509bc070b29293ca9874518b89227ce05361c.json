{"sha": "6c7509bc070b29293ca9874518b89227ce05361c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM3NTA5YmMwNzBiMjkyOTNjYTk4NzQ1MThiODkyMjdjZTA1MzYxYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-11-22T17:56:43Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2016-11-22T17:56:43Z"}, "message": "OpenMP loop cloning for SIMT execution\n\n2016-11-22  Jakub Jelinek  <jakub@redhat.com>\n            Alexander Monakov  <amonakov@ispras.ru>\n\n\t* internal-fn.c (expand_GOMP_USE_SIMT): New function.\n\t* tree.c (omp_clause_num_ops): OMP_CLAUSE__SIMT_ has 0 operands.\n\t(omp_clause_code_name): Add _simt_ name.\n\t(walk_tree_1): Handle OMP_CLAUSE__SIMT_.\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__SIMT_.\n\t* omp-low.c (scan_sharing_clauses): Handle OMP_CLAUSE__SIMT_.\n\t(scan_omp_simd): New function.\n\t(scan_omp_1_stmt): Use it in target regions if needed.\n\t(omp_max_vf): Don't max with omp_max_simt_vf.\n\t(lower_rec_simd_input_clauses): Use omp_max_simt_vf if\n\tOMP_CLAUSE__SIMT_ is present.\n\t(lower_rec_input_clauses): Compute maybe_simt from presence of\n\tOMP_CLAUSE__SIMT_.\n\t(lower_lastprivate_clauses): Likewise.\n\t(expand_omp_simd): Likewise.\n\t(execute_omp_device_lower): Lower IFN_GOMP_USE_SIMT.\n\t* internal-fn.def (GOMP_USE_SIMT): New internal function.\n\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE__SIMT_.\n\nCo-Authored-By: Alexander Monakov <amonakov@ispras.ru>\n\nFrom-SVN: r242714", "tree": {"sha": "ad30078ae6fda7ac5d0a41f3cf4bd216096ef5ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad30078ae6fda7ac5d0a41f3cf4bd216096ef5ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c7509bc070b29293ca9874518b89227ce05361c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7509bc070b29293ca9874518b89227ce05361c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7509bc070b29293ca9874518b89227ce05361c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7509bc070b29293ca9874518b89227ce05361c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad4a77a11c929706b8f206443c2b0504edee549f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4a77a11c929706b8f206443c2b0504edee549f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad4a77a11c929706b8f206443c2b0504edee549f"}], "stats": {"total": 121, "additions": 110, "deletions": 11}, "files": [{"sha": "c4cd4c64ded04ebd9aa64f3bc691e0ed26c34e0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -1,3 +1,25 @@\n+2016-11-22  Jakub Jelinek  <jakub@redhat.com>\n+            Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* internal-fn.c (expand_GOMP_USE_SIMT): New function.\n+\t* tree.c (omp_clause_num_ops): OMP_CLAUSE__SIMT_ has 0 operands.\n+\t(omp_clause_code_name): Add _simt_ name.\n+\t(walk_tree_1): Handle OMP_CLAUSE__SIMT_.\n+\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__SIMT_.\n+\t* omp-low.c (scan_sharing_clauses): Handle OMP_CLAUSE__SIMT_.\n+\t(scan_omp_simd): New function.\n+\t(scan_omp_1_stmt): Use it in target regions if needed.\n+\t(omp_max_vf): Don't max with omp_max_simt_vf.\n+\t(lower_rec_simd_input_clauses): Use omp_max_simt_vf if\n+\tOMP_CLAUSE__SIMT_ is present.\n+\t(lower_rec_input_clauses): Compute maybe_simt from presence of\n+\tOMP_CLAUSE__SIMT_.\n+\t(lower_lastprivate_clauses): Likewise.\n+\t(expand_omp_simd): Likewise.  Remove explicit offloaded region check.\n+\t(execute_omp_device_lower): Lower IFN_GOMP_USE_SIMT.\n+\t* internal-fn.def (GOMP_USE_SIMT): New internal function.\n+\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE__SIMT_.\n+\n 2016-11-22  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* internal-fn.c (expand_GOMP_SIMT_LANE): New."}, {"sha": "b1dbc988b9c038dd730e8ab04152927a7b4c8ad3", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -158,6 +158,14 @@ expand_ANNOTATE (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in omp_device_lower pass.  */\n+\n+static void\n+expand_GOMP_USE_SIMT (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Lane index on SIMT targets: thread index in the warp on NVPTX.  On targets\n    without SIMT execution this should be expanded in omp_device_lower pass.  */\n "}, {"sha": "9a03e17be23a786c3b7f1160ed2f4fc13455fed3", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -141,6 +141,7 @@ DEF_INTERNAL_INT_FN (FFS, ECF_CONST, ffs, unary)\n DEF_INTERNAL_INT_FN (PARITY, ECF_CONST, parity, unary)\n DEF_INTERNAL_INT_FN (POPCOUNT, ECF_CONST, popcount, unary)\n \n+DEF_INTERNAL_FN (GOMP_USE_SIMT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_VF, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_LAST_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "eab0af5b58dc205ba764a016c39512042a0eec75", "filename": "gcc/omp-low.c", "status": "modified", "additions": 68, "deletions": 11, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -278,6 +278,7 @@ static bool omp_any_child_fn_dumped;\n static void scan_omp (gimple_seq *, omp_context *);\n static tree scan_omp_1_op (tree *, int *, void *);\n static gphi *find_phi_with_arg_on_edge (tree, edge);\n+static int omp_max_simt_vf (void);\n \n #define WALK_SUBSTMTS  \\\n     case GIMPLE_BIND: \\\n@@ -2192,6 +2193,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n+\tcase OMP_CLAUSE__SIMT_:\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -2363,6 +2365,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n \tcase OMP_CLAUSE__GRIDDIM_:\n+\tcase OMP_CLAUSE__SIMT_:\n \t  break;\n \n \tcase OMP_CLAUSE_TILE:\n@@ -3066,6 +3069,48 @@ scan_omp_for (gomp_for *stmt, omp_context *outer_ctx)\n   scan_omp (gimple_omp_body_ptr (stmt), ctx);\n }\n \n+/* Duplicate #pragma omp simd, one for SIMT, another one for SIMD.  */\n+\n+static void\n+scan_omp_simd (gimple_stmt_iterator *gsi, gomp_for *stmt,\n+\t       omp_context *outer_ctx)\n+{\n+  gbind *bind = gimple_build_bind (NULL, NULL, NULL);\n+  gsi_replace (gsi, bind, false);\n+  gimple_seq seq = NULL;\n+  gimple *g = gimple_build_call_internal (IFN_GOMP_USE_SIMT, 0);\n+  tree cond = create_tmp_var_raw (integer_type_node);\n+  DECL_CONTEXT (cond) = current_function_decl;\n+  DECL_SEEN_IN_BIND_EXPR_P (cond) = 1;\n+  gimple_bind_set_vars (bind, cond);\n+  gimple_call_set_lhs (g, cond);\n+  gimple_seq_add_stmt (&seq, g);\n+  tree lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree lab3 = create_artificial_label (UNKNOWN_LOCATION);\n+  g = gimple_build_cond (NE_EXPR, cond, integer_zero_node, lab1, lab2);\n+  gimple_seq_add_stmt (&seq, g);\n+  g = gimple_build_label (lab1);\n+  gimple_seq_add_stmt (&seq, g);\n+  gimple_seq new_seq = copy_gimple_seq_and_replace_locals (stmt);\n+  gomp_for *new_stmt = as_a <gomp_for *> (new_seq);\n+  tree clause = build_omp_clause (gimple_location (stmt), OMP_CLAUSE__SIMT_);\n+  OMP_CLAUSE_CHAIN (clause) = gimple_omp_for_clauses (new_stmt);\n+  gimple_omp_for_set_clauses (new_stmt, clause);\n+  gimple_seq_add_stmt (&seq, new_stmt);\n+  g = gimple_build_goto (lab3);\n+  gimple_seq_add_stmt (&seq, g);\n+  g = gimple_build_label (lab2);\n+  gimple_seq_add_stmt (&seq, g);\n+  gimple_seq_add_stmt (&seq, stmt);\n+  g = gimple_build_label (lab3);\n+  gimple_seq_add_stmt (&seq, g);\n+  gimple_bind_set_body (bind, seq);\n+  update_stmt (bind);\n+  scan_omp_for (new_stmt, outer_ctx);\n+  scan_omp_for (stmt, outer_ctx);\n+}\n+\n /* Scan an OpenMP sections directive.  */\n \n static void\n@@ -3969,7 +4014,13 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_FOR:\n-      scan_omp_for (as_a <gomp_for *> (stmt), ctx);\n+      if (((gimple_omp_for_kind (as_a <gomp_for *> (stmt))\n+\t    & GF_OMP_FOR_KIND_MASK) == GF_OMP_FOR_KIND_SIMD)\n+\t  && omp_maybe_offloaded_ctx (ctx)\n+\t  && omp_max_simt_vf ())\n+\tscan_omp_simd (gsi, as_a <gomp_for *> (stmt), ctx);\n+      else\n+\tscan_omp_for (as_a <gomp_for *> (stmt), ctx);\n       break;\n \n     case GIMPLE_OMP_SECTIONS:\n@@ -4316,8 +4367,7 @@ omp_max_vf (void)\n       if (GET_MODE_CLASS (vqimode) == MODE_VECTOR_INT)\n \tvf = GET_MODE_NUNITS (vqimode);\n     }\n-  int svf = omp_max_simt_vf ();\n-  return MAX (vf, svf);\n+  return vf;\n }\n \n /* Helper function of lower_rec_input_clauses, used for #pragma omp simd\n@@ -4329,7 +4379,11 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx, int &max_vf,\n {\n   if (max_vf == 0)\n     {\n-      max_vf = omp_max_vf ();\n+      if (find_omp_clause (gimple_omp_for_clauses (ctx->stmt),\n+\t\t\t   OMP_CLAUSE__SIMT_))\n+\tmax_vf = omp_max_simt_vf ();\n+      else\n+\tmax_vf = omp_max_vf ();\n       if (max_vf > 1)\n \t{\n \t  tree c = find_omp_clause (gimple_omp_for_clauses (ctx->stmt),\n@@ -4405,8 +4459,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   int pass;\n   bool is_simd = (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n \t\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD);\n-  bool maybe_simt\n-    = is_simd && omp_maybe_offloaded_ctx (ctx) && omp_max_simt_vf () > 1;\n+  bool maybe_simt = is_simd && find_omp_clause (clauses, OMP_CLAUSE__SIMT_);\n   int max_vf = 0;\n   tree lane = NULL_TREE, idx = NULL_TREE;\n   tree simt_lane = NULL_TREE;\n@@ -5497,7 +5550,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n   if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n       && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n     {\n-      maybe_simt = omp_maybe_offloaded_ctx (ctx) && omp_max_simt_vf () > 1;\n+      maybe_simt = find_omp_clause (orig_clauses, OMP_CLAUSE__SIMT_);\n       simduid = find_omp_clause (orig_clauses, OMP_CLAUSE__SIMDUID_);\n       if (simduid)\n \tsimduid = OMP_CLAUSE__SIMDUID__DECL (simduid);\n@@ -10749,10 +10802,9 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n     }\n   tree step = fd->loop.step;\n \n-  bool offloaded = cgraph_node::get (current_function_decl)->offloadable;\n-  for (struct omp_region *rgn = region; !offloaded && rgn; rgn = rgn->outer)\n-    offloaded = rgn->type == GIMPLE_OMP_TARGET;\n-  bool is_simt = offloaded && omp_max_simt_vf () > 1 && safelen_int > 1;\n+  bool is_simt = (safelen_int > 1\n+\t\t  && find_omp_clause (gimple_omp_for_clauses (fd->for_stmt),\n+\t\t\t\t      OMP_CLAUSE__SIMT_));\n   tree simt_lane = NULL_TREE, simt_maxlane = NULL_TREE;\n   if (is_simt)\n     {\n@@ -15006,6 +15058,8 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gbind *bind;\n   bool simd = find_omp_clause (gimple_omp_ordered_clauses (ord_stmt),\n \t\t\t       OMP_CLAUSE_SIMD);\n+  /* FIXME: this should check presence of OMP_CLAUSE__SIMT_ on the enclosing\n+     loop.  */\n   bool maybe_simt\n     = simd && omp_maybe_offloaded_ctx (ctx) && omp_max_simt_vf () > 1;\n   bool threads = find_omp_clause (gimple_omp_ordered_clauses (ord_stmt),\n@@ -20167,6 +20221,9 @@ execute_omp_device_lower ()\n \ttree type = lhs ? TREE_TYPE (lhs) : integer_type_node;\n \tswitch (gimple_call_internal_fn (stmt))\n \t  {\n+\t  case IFN_GOMP_USE_SIMT:\n+\t    rhs = vf == 1 ? integer_zero_node : integer_one_node;\n+\t    break;\n \t  case IFN_GOMP_SIMT_LANE:\n \t  case IFN_GOMP_SIMT_LAST_LANE:\n \t    rhs = vf == 1 ? build_zero_cst (type) : NULL_TREE;"}, {"sha": "eec2d4f35b5cb053c607f05d9b76b2c7dafc047e", "filename": "gcc/tree-core.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -438,6 +438,10 @@ enum omp_clause_code {\n   /* Internally used only clause, holding SIMD uid.  */\n   OMP_CLAUSE__SIMDUID_,\n \n+  /* Internally used only clause, flag whether this is SIMT simd\n+     loop or not.  */\n+  OMP_CLAUSE__SIMT_,\n+\n   /* Internally used only clause, holding _Cilk_for # of iterations\n      on OMP_PARALLEL.  */\n   OMP_CLAUSE__CILK_FOR_COUNT_,"}, {"sha": "95db710042883d140fb3152e7e6b1c4724de1ecb", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -893,6 +893,10 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n       pp_right_paren (pp);\n       break;\n \n+    case OMP_CLAUSE__SIMT_:\n+      pp_string (pp, \"_simt_\");\n+      break;\n+\n     case OMP_CLAUSE_GANG:\n       pp_string (pp, \"gang\");\n       if (OMP_CLAUSE_GANG_EXPR (clause) != NULL_TREE)"}, {"sha": "9b0b806cb56b32e21267d274435140a5583b463a", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -320,6 +320,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_HINT  */\n   0, /* OMP_CLAUSE_DEFALTMAP  */\n   1, /* OMP_CLAUSE__SIMDUID_  */\n+  0, /* OMP_CLAUSE__SIMT_  */\n   1, /* OMP_CLAUSE__CILK_FOR_COUNT_  */\n   0, /* OMP_CLAUSE_INDEPENDENT  */\n   1, /* OMP_CLAUSE_WORKER  */\n@@ -391,6 +392,7 @@ const char * const omp_clause_code_name[] =\n   \"hint\",\n   \"defaultmap\",\n   \"_simduid_\",\n+  \"_simt_\",\n   \"_Cilk_for_count_\",\n   \"independent\",\n   \"worker\",\n@@ -11893,6 +11895,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_SEQ:\n \tcase OMP_CLAUSE_TILE:\n+\tcase OMP_CLAUSE__SIMT_:\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \n \tcase OMP_CLAUSE_LASTPRIVATE:"}]}