{"sha": "121308d427978857aade10a387e92f130d36cd75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIxMzA4ZDQyNzk3ODg1N2FhZGUxMGEzODdlOTJmMTMwZDM2Y2Q3NQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2001-12-20T19:03:37Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2001-12-20T19:03:37Z"}, "message": "Fix prologue/epilogue generation for ARM ISR routines.\n\nAdd test case to catch bugs reported in prologue/epilogue generation for ARM ISR routines.\n\nFrom-SVN: r48210", "tree": {"sha": "9f0cec9290dcba0fb929ea8824a97a26b3a9be17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0cec9290dcba0fb929ea8824a97a26b3a9be17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/121308d427978857aade10a387e92f130d36cd75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121308d427978857aade10a387e92f130d36cd75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121308d427978857aade10a387e92f130d36cd75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121308d427978857aade10a387e92f130d36cd75/comments", "author": null, "committer": null, "parents": [{"sha": "e6a8345b03643aebbcba7188effd96340f2a1fd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a8345b03643aebbcba7188effd96340f2a1fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a8345b03643aebbcba7188effd96340f2a1fd9"}], "stats": {"total": 204, "additions": 161, "deletions": 43}, "files": [{"sha": "5e68161996efe520642e91e1e89244f0d86ceb3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121308d427978857aade10a387e92f130d36cd75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121308d427978857aade10a387e92f130d36cd75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=121308d427978857aade10a387e92f130d36cd75", "patch": "@@ -1,3 +1,25 @@\n+2001-12-20 Alan Shieh <ashieh@hkn.eecs.berkeley.edu>\n+\n+\t* config/arm/arm.c (arm_output_epilogue): Changed IP restore\n+\tto use ldmfd instead of ldmea.\n+\t* config/arm/arm.c (arm_compute_initial_elimination_offset):\n+\tModified to reflect behavior of arm_expand_prologue when generating\n+\tinterrupt handlers\n+\n+2001-12-20  Nick Clifton  <nickc@cambridge.redhat.com>\n+\n+\t* config/arm/arm.c (arm_compute_save_reg0_reg12_mask):  New\n+        function. Compute which of registers r0 through r12 should be\n+\tsaved onto the stack during a function's prologue.\n+        (arm_compute_save_reg_mask): Use\n+        arm_compute_save_reg0_reg12_mask. \n+        (arm_compute_initial_elimination_offset): Use\n+        arm_compute_save_reg0_reg12_mask.\n+\n+        (arm_expand_prologue): Do not mark as save of the IP register\n+        for an interrupt handler as being part of the frame creation\n+        code.\n+\n 2001-12-20  Richard Henderson  <rth@redhat.com>\n \n \t* varasm.c (assemble_real): Use REAL_VALUE_TO_x and assemble_integer"}, {"sha": "d4a81f3d170cfbccfe393e76d808cbc492a4d6d8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 64, "deletions": 43, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121308d427978857aade10a387e92f130d36cd75/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121308d427978857aade10a387e92f130d36cd75/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=121308d427978857aade10a387e92f130d36cd75", "patch": "@@ -104,6 +104,7 @@ static void\t push_minipool_barrier\t        PARAMS ((rtx, Hint));\n static void\t push_minipool_fix\t\tPARAMS ((rtx, Hint, rtx *, Mmode, rtx));\n static void\t note_invalid_constants\t        PARAMS ((rtx, Hint));\n static int       current_file_function_operand\tPARAMS ((rtx));\n+static Ulong arm_compute_save_reg0_reg12_mask   PARAMS ((void));\n static Ulong     arm_compute_save_reg_mask\tPARAMS ((void));\n static Ulong     arm_isr_value \t\t\tPARAMS ((tree));\n static Ulong     arm_compute_func_type\t\tPARAMS ((void));\n@@ -7001,38 +7002,20 @@ output_ascii_pseudo_op (stream, p, len)\n   fputs (\"\\\"\\n\", stream);\n }\n \f\n-/* Compute a bit mask of which registers need to be\n-   saved on the stack for the current function.  */\n+/* Compute the register sabe mask for registers 0 through 12\n+   inclusive.  This code is used by both arm_compute_save_reg_mask\n+   and arm_compute_initial_elimination_offset.  */\n \n static unsigned long\n-arm_compute_save_reg_mask ()\n+arm_compute_save_reg0_reg12_mask ()\n {\n+  unsigned long func_type = arm_current_func_type ();\n   unsigned int save_reg_mask = 0;\n   unsigned int reg;\n-  unsigned long func_type = arm_current_func_type ();\n-\n-  if (IS_NAKED (func_type))\n-    /* This should never really happen.  */\n-    return 0;\n-\n-  /* If we are creating a stack frame, then we must save the frame pointer,\n-     IP (which will hold the old stack pointer), LR and the PC.  */\n-  if (frame_pointer_needed)\n-    save_reg_mask |=\n-      (1 << ARM_HARD_FRAME_POINTER_REGNUM)\n-      | (1 << IP_REGNUM)\n-      | (1 << LR_REGNUM)\n-      | (1 << PC_REGNUM);\n-\n-  /* Volatile functions do not return, so there\n-     is no need to save any other registers.  */\n-  if (IS_VOLATILE (func_type))\n-    return save_reg_mask;\n \n   if (IS_INTERRUPT (func_type))\n     {\n       unsigned int max_reg;\n-      \n       /* Interrupt functions must not corrupt any registers,\n \t even call clobbered ones.  If this is a leaf function\n \t we can just examine the registers used by the RTL, but\n@@ -7042,7 +7025,7 @@ arm_compute_save_reg_mask ()\n       if (ARM_FUNC_TYPE (func_type) == ARM_FT_FIQ)\n \t/* FIQ handlers have registers r8 - r12 banked, so\n \t   we only need to check r0 - r7, Normal ISRs only\n-\t   bank r14 and r15, so ew must check up to r12.\n+\t   bank r14 and r15, so we must check up to r12.\n \t   r13 is the stack pointer which is always preserved,\n \t   so we do not need to consider it here.  */\n \tmax_reg = 7;\n@@ -7077,6 +7060,38 @@ arm_compute_save_reg_mask ()\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n     }\n \n+  return save_reg_mask;\n+}\n+\n+/* Compute a bit mask of which registers need to be\n+   saved on the stack for the current function.  */\n+\n+static unsigned long\n+arm_compute_save_reg_mask ()\n+{\n+  unsigned int save_reg_mask = 0;\n+  unsigned long func_type = arm_current_func_type ();\n+\n+  if (IS_NAKED (func_type))\n+    /* This should never really happen.  */\n+    return 0;\n+\n+  /* If we are creating a stack frame, then we must save the frame pointer,\n+     IP (which will hold the old stack pointer), LR and the PC.  */\n+  if (frame_pointer_needed)\n+    save_reg_mask |=\n+      (1 << ARM_HARD_FRAME_POINTER_REGNUM)\n+      | (1 << IP_REGNUM)\n+      | (1 << LR_REGNUM)\n+      | (1 << PC_REGNUM);\n+\n+  /* Volatile functions do not return, so there\n+     is no need to save any other registers.  */\n+  if (IS_VOLATILE (func_type))\n+    return save_reg_mask;\n+\n+  save_reg_mask |= arm_compute_save_reg0_reg12_mask ();\n+\n   /* Decide if we need to save the link register.\n      Interrupt routines have their own banked link register,\n      so they never need to save it.\n@@ -7535,7 +7550,7 @@ arm_output_epilogue (really_return)\n       if (IS_INTERRUPT (func_type))\n \t/* Interrupt handlers will have pushed the\n \t   IP onto the stack, so restore it now.  */\n-\tprint_multi_reg (f, \"ldmea\\t%r\", SP_REGNUM, 1 << IP_REGNUM);\n+\tprint_multi_reg (f, \"ldmfd\\t%r\", SP_REGNUM, 1 << IP_REGNUM);\n     }\n   else\n     {\n@@ -7946,27 +7961,22 @@ arm_compute_initial_elimination_offset (from, to)\n   call_saved_registers = 0;\n   if (! IS_VOLATILE (func_type))\n     {\n+      unsigned int reg_mask;\n       unsigned int reg;\n \n-      /* In theory we should check all of the hard registers to\n-\t see if they will be saved onto the stack.  In practice\n-\t registers 11 upwards have special meanings and need to\n-\t be check individually.  */\n-      for (reg = 0; reg <= 10; reg ++)\n-\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n-\t  call_saved_registers += 4;\n+      /* Makre sure that we compute which registers will be saved\n+\t on the stack using the same algorithm that is used by\n+\t arm_compute_save_reg_mask().  */\n+      reg_mask = arm_compute_save_reg0_reg12_mask ();\n \n-      /* Determine if register 11 will be clobbered.  */\n-      if (! TARGET_APCS_FRAME\n-\t  && ! frame_pointer_needed\n-\t  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-\t  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n-\tcall_saved_registers += 4;\n+      /* Now count the number of bits set in save_reg_mask.\n+\t For each set bit we need 4 bytes of stack space.  */\n \n-      /* The PIC register is fixed, so if the function will\n-\t corrupt it, it has to be saved onto the stack.  */\n-      if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-\tcall_saved_registers += 4;\n+      while (reg_mask)\n+\t{\n+\t  call_saved_registers += 4;\n+\t  reg_mask = reg_mask & ~ (reg_mask & - reg_mask);\n+\t}\n \n       if (regs_ever_live[LR_REGNUM]\n \t  /* If a stack frame is going to be created, the LR will\n@@ -8097,7 +8107,18 @@ arm_expand_prologue ()\n \t     Creating a frame pointer however, corrupts the IP\n \t     register, so we must push it first.  */\n \t  insn = emit_multi_reg_push (1 << IP_REGNUM);\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  /* Do not set RTX_FRAME_RELATED_P on this insn.\n+\t     The dwarf stack unwinding code only wants to see one\n+\t     stack decrement per function, and this is not it.  If\n+\t     this instruction is labeled as being part of the frame\n+\t     creation sequence then dwarf2out_frame_debug_expr will\n+\t     abort when it encounters the assignment of IP to FP\n+\t     later on, since the use of SP here establishes SP as\n+\t     the CFA register and not IP.\n+\n+\t     Anyway this instruction is not really part of the stack\n+\t     frame creation although it is part of the prologue.  */\n \t}\n       else if (IS_NESTED (func_type))\n \t{"}, {"sha": "f79e241633deca1785400c547a1d98d1cffbb3d9", "filename": "gcc/testsuite/gcc.misc-tests/arm-isr.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121308d427978857aade10a387e92f130d36cd75/gcc%2Ftestsuite%2Fgcc.misc-tests%2Farm-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121308d427978857aade10a387e92f130d36cd75/gcc%2Ftestsuite%2Fgcc.misc-tests%2Farm-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Farm-isr.c?ref=121308d427978857aade10a387e92f130d36cd75", "patch": "@@ -0,0 +1,48 @@\n+#ifndef __thumb__\n+/* There used to be a couple of bugs in the ARM's prologue and epilogue\n+   generation for ISR routines.  The wrong epilogue instruction would be\n+   generated to restore the IP register if it had to be pushed onto the\n+   stack, and the wrong offset was being computed for local variables if\n+   r0 - r3 had to be saved.  This tests for both of these cases.  */\n+\n+int z = 9;\n+\n+int\n+bar (void)\n+{\n+  return z;\n+}\n+\n+int\n+foo (int a, int b, int c, int d, int e, int f, int g, int h)\n+{\n+  volatile int i = (a + b) - (g + h) + bar ();\n+  volatile int j = (e + f) - (c + d);\n+\n+  return a + b + c + d + e + f + g + h + i + j;\n+}\n+\n+int foo1 (int a, int b, int c, int d, int e, int f, int g, int h) __attribute__ ((interrupt (\"IRQ\")));\n+\n+int\n+foo1 (int a, int b, int c, int d, int e, int f, int g, int h)\n+{\n+  volatile int i = (a + b) - (g + h) + bar ();\n+  volatile int j = (e + f) - (c + d);\n+\n+  return a + b + c + d + e + f + g + h + i + j;\n+}\n+#endif\n+\n+int\n+main (void)\n+{\n+#ifndef __thumb__\n+  if (foo (1, 2, 3, 4, 5, 6, 7, 8) != 32)\n+    abort ();\n+    \n+  if (foo1 (1, 2, 3, 4, 5, 6, 7, 8) != 32)\n+    abort ();\n+#endif\n+  exit (0);\n+}"}, {"sha": "9d4a1b5df4f4dafd65edc7dc77aa99eb56602ce4", "filename": "gcc/testsuite/gcc.misc-tests/arm-isr.exp", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121308d427978857aade10a387e92f130d36cd75/gcc%2Ftestsuite%2Fgcc.misc-tests%2Farm-isr.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121308d427978857aade10a387e92f130d36cd75/gcc%2Ftestsuite%2Fgcc.misc-tests%2Farm-isr.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Farm-isr.exp?ref=121308d427978857aade10a387e92f130d36cd75", "patch": "@@ -0,0 +1,27 @@\n+#   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# This file is based on a bug report submitted to gcc-bugs:\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+dg-init\n+if {[istarget \"*arm-*-*\"] || [istarget \"xscale-*-*\"]} {\n+  dg-runtest \"$srcdir/$subdir/arm-isr.c\" \"\" \"\"\n+}\n+dg-finish\n+"}]}